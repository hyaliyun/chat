import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},A={class:"review-title"},I={class:"review-content"};function E(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",A,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const C=c(k,[["render",E],["__scopeId","data-v-545e38e7"]]),S=JSON.parse('[{"question":"# Problem Statement You are given a problem involving the calculation of the final amount of money in a savings account given an initial principal, annual interest rate, and the number of years the money is invested or saved. Interest is compounded annually. The formula to calculate the final amount ( A ) after ( t ) years with an annual interest rate ( r ) (expressed as a decimal) and an initial principal ( P ) is: [ A = P cdot (1 + r)^t ] where: - ( P ) is the initial principal in dollars. - ( r ) is the annual interest rate in decimal form. - ( t ) is the time in years. # Task Write a function named `calculate_savings` that takes three parameters: 1. `principal` (float): initial principal in dollars. Must be non-negative. 2. `annual_rate` (float): annual interest rate in decimal form. Must be non-negative. 3. `years` (int): the number of years the money is invested or saved. Must be non-negative. The function should return the final amount in the savings account rounded to two decimal places. # Input and Output Format * **Input**: - A float `principal`: The initial amount of money. - A float `annual_rate`: The annual interest rate in decimal form. - An int `years`: The number of years the money is invested. * **Output**: - A float representing the final amount in the savings account rounded to two decimal places. # Constraints - The `principal` and `annual_rate` must be non-negative. - The `years` must be a non-negative integer. If any of the constraints are violated, the function should raise a `ValueError` with an appropriate error message. # Example ```python def calculate_savings(principal: float, annual_rate: float, years: int) -> float: # Your code here # Example Usage print(calculate_savings(1000.0, 0.05, 10)) # Returns 1628.89 print(calculate_savings(500, 0.03, 5)) # Returns 579.64 ``` # Notes 1. Your implementation should make use of the built-in `**` operator to perform the exponentiation. 2. Ensure your function handles all edge cases as specified, raising `ValueError` for invalid inputs.","solution":"def calculate_savings(principal: float, annual_rate: float, years: int) -> float: if principal < 0: raise ValueError(\\"Principal must be non-negative.\\") if annual_rate < 0: raise ValueError(\\"Annual rate must be non-negative.\\") if years < 0: raise ValueError(\\"Years must be non-negative.\\") final_amount = principal * (1 + annual_rate) ** years return round(final_amount, 2)"},{"question":"# Question: Minimum Moves to Reach End of Maze You are required to implement a function that calculates the minimum number of moves required to reach the end of a given maze from the start position. The maze is represented as a 2D grid where each cell can either be empty (0) or blocked (1). You can move up, down, left, or right from a cell, but you cannot move diagonally, and you cannot move through a blocked cell. The grid is given as an `n x m` list of lists. The start position is always at the top-left corner of the grid (0, 0), and the goal is to reach the bottom-right corner of the grid (n-1, m-1). __Requirements:__ * If it is not possible to reach the bottom-right corner from the top-left corner, return -1. * Ensure the function computes results efficiently even for larger grids. * Implement the function using a breadth-first search (BFS) method to achieve optimal time complexity. __Function Signature:__ ```python def min_moves_to_end(maze: List[List[int]]) -> int: pass ``` __Input:__ * A list of lists `maze` of integers, representing the grid. __Output:__ * Return the minimum number of moves required to reach the bottom-right corner or -1 if it is not possible. __Constraints:__ * The input `maze` will be a non-empty list of lists containing only 0s and 1s, and will always be rectangular. * The dimensions of the grid are limited to `1 <= n, m <= 1000`. __Example:__ ```python assert min_moves_to_end([[0, 0, 1], [0, 1, 0], [0, 0, 0]]) == 4 assert min_moves_to_end([[0, 1], [1, 0]]) == -1 assert min_moves_to_end([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 4 assert min_moves_to_end([[0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 0, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0]]) == 8 ``` __Explanation:__ * For the first example, the path is (0,0) -> (1,0) -> (2,0) -> (2,1) -> (2,2). * For the second example, it is impossible to reach the end, hence -1. * For the third example, the path can be multiple different ways, e.g., (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2).","solution":"from typing import List def min_moves_to_end(maze: List[List[int]]) -> int: from collections import deque # Edge case: checking if the start or end is blocked if maze[0][0] == 1 or maze[-1][-1] == 1: return -1 n, m = len(maze), len(maze[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() if row == n - 1 and col == m - 1: return dist for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < n and 0 <= c < m and maze[r][c] == 0 and (r, c) not in visited: visited.add((r, c)) queue.append((r, c, dist + 1)) return -1"},{"question":"# Warehouse Robot Path Planning You are tasked with programming a simple robot to navigate a warehouse. The robot starts at a specific position within a 2D grid warehouse and must move to the target position while avoiding obstacles. The warehouse layout is represented as a matrix where empty cells are denoted by 0, obstacles by 1, the robot\'s start position by \'S\', and the target position by \'T\'. **Goal**: Implement a function `find_path` that finds a path from the start position to the target position without colliding with obstacles. If there is no valid path, return an empty list. The robot can move up, down, left, or right, but not diagonally. # Function Signature ```python def find_path(warehouse: list[list[int]], start: tuple[int, int], target: tuple[int, int]) -> list[tuple[int, int]]: pass ``` # Input * **warehouse** (list of list of int) - A 2D grid representing the warehouse. * **start** (tuple of int) - The starting coordinates of the robot (row, column). * **target** (tuple of int) - The target coordinates for the robot (row, column). # Output * **path** (list of tuple) - A list of coordinates representing the path from start to target. Each coordinate should be a tuple (row, column). If there is no valid path, return an empty list. # Constraints * 2 <= len(warehouse), len(warehouse[0]) <= 100 * 0 <= start[0], start[1], target[0], target[1] < length of the respective dimensions * The start and target positions do not contain obstacles. # Example ```python warehouse = [ [0, 0, 0, 0], [1, 1, 0, 1], [0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0] ] start = (0, 0) target = (4, 3) result = find_path(warehouse, start, target) print(result) # Possible Output: # [(0, 0), (0, 1), (0, 2), (0, 3), (1, 2), (2, 2), (2, 3), (3, 3), (4, 3)] ``` # Notes * Ensure the robot does not move outside the boundaries of the warehouse. * Use Breadth-First Search (BFS) for finding the shortest path. * Multiple valid paths may exist; your function only needs to return one of them. * Careful consideration of edge cases, such as fully obstructed paths, should be handled gracefully by returning an empty list.","solution":"def find_path(warehouse, start, target): from collections import deque rows, cols = len(warehouse), len(warehouse[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(r, c): return 0 <= r < rows and 0 <= c < cols and warehouse[r][c] == 0 queue = deque([(start, [start])]) visited = set([start]) while queue: (current_r, current_c), path = queue.popleft() if (current_r, current_c) == target: return path for dr, dc in directions: new_r, new_c = current_r + dr, current_c + dc if is_valid(new_r, new_c) and (new_r, new_c) not in visited: visited.add((new_r, new_c)) queue.append(((new_r, new_c), path + [(new_r, new_c)])) return []"},{"question":"# Coding Assessment Question Problem Description: You are tasked with implementing a function `find_mex(arr: List[int]) -> int`. This function should find the \\"minimum excludant\\" (MEX) of a given list of non-negative integers. The MEX of a set of integers is the smallest non-negative integer that is not present in the set. Detailed Requirements: 1. **Function Signature**: `def find_mex(arr: List[int]) -> int:` 2. **Inputs**: - `arr`: a list of non-negative integers (0 ≤ arr[i] ≤ 10^6) and the length of the list (1 ≤ len(arr) ≤ 10^6). 3. **Output**: - An integer representing the MEX of the given list. 4. **Constraints**: - Ensure the function works within reasonable time and space limits. # Example: ```python >>> find_mex([1, 0, 2, 4, 3]) 5 >>> find_mex([2, 3, 1, 0]) 4 >>> find_mex([0, 1, 2, 3]) 4 >>> find_mex([1, 2, 3, 4]) 0 ``` # Notes: 1. The function should handle large inputs efficiently. 2. Consider edge case scenarios such as: - The input list containing all consecutive numbers starting from 0. - The input list having large gaps. - Lists where the smallest number missing is not at the beginning or end. 3. The solution should not involve sorting the array since the time complexity needs to be optimal. --- Good luck! Ensure your solution meets the optimal time and space complexity as discussed, and handles edge cases appropriately.","solution":"from typing import List def find_mex(arr: List[int]) -> int: Finds the minimum excludant (MEX) of a given list of non-negative integers. The MEX of a set of integers is the smallest non-negative integer that is not present in the set. # Create a set of the input list for O(1) average time complexity lookups. num_set = set(arr) # Start checking from 0 and find the smallest number not in the set. mex = 0 while mex in num_set: mex += 1 return mex"},{"question":"**String Transformation to Lexicographically Smallest Form** You are given a string consisting of lowercase alphabets. You can perform the following operation any number of times: choose two adjacent characters and swap them if they can make the string lexicographically smaller. Your task is to implement an algorithm that transforms the given string into its lexicographically smallest form by performing the allowed operation. # Task 1. **Implement the Transformation Algorithm**: Create a function `lexicographical_transform` that takes a string as input and returns its lexicographically smallest form. # Requirements 1. **lexicographical_transform**: - Input: A single string `s` with only lowercase alphabet characters. - Output: A lexicographically smallest string that can be obtained by performing the allowed adjacent swap operations. - Constraints: - The length of the string will be between 1 and `10^5`. - The string will only contain lowercase alphabets (\'a\' to \'z\'). # Example ```python print(lexicographical_transform(\\"bcda\\")) # Output: \\"abcd\\" print(lexicographical_transform(\\"cab\\")) # Output: \\"abc\\" print(lexicographical_transform(\\"acb\\")) # Output: \\"abc\\" ``` # Explanation - For the input \\"bcda\\", you can swap \'b\' and \'c\' to get \\"cbda\\", then swap \'b\' and \'d\' to get \\"cdba\\", and so on until you get \\"abcd\\". - For the input \\"cab\\", swapping \'c\' with \'a\' to get \\"acb\\", and then swapping \'c\' with \'b\' to get \\"abc\\" gives the smallest lexicographical string. - For the input \\"acb\\", swap \'c\' with \'b\' to get \\"abc\\". Implement the function considering the time complexity implications to handle the maximum constraints efficiently.","solution":"def lexicographical_transform(s: str) -> str: Transforms the given string into its lexicographically smallest form by performing adjacent swaps of characters. # Convert the string to a list of characters for easier manipulation s = list(s) n = len(s) # iterate through the list until no more swaps can be performed swapped = True while swapped: swapped = False for i in range(n - 1): if s[i] > s[i + 1]: # swap s[i] and s[i + 1] s[i], s[i + 1] = s[i + 1], s[i] swapped = True return \'\'.join(s)"},{"question":"# Coding Assessment Question Context You are tasked with implementing a class representing a histogram, which is a data structure frequently used in statistical analysis and data processing. The histogram keeps track of the frequency of different integer values and allows querying for various statistics. Task Implement the `Histogram` class with the following functionalities: 1. **Add**: Add a value to the histogram. 2. **Remove**: Remove a value from the histogram. (If the value is not present, raise a `ValueError`) 3. **GetFrequency**: Retrieve the frequency of a given value. 4. **Mode**: Return the value(s) with the highest frequency. 5. **Median**: Return the median value of the histogram. If there is an even number of elements, return the average of the two middle elements. 6. **Mean**: Return the mean of all values in the histogram. 7. **Clear**: Remove all elements from the histogram. Requirements - Implement the `Histogram` class with all the specified methods. - Handle edge cases such as querying an empty histogram (should raise a `ValueError`). Example Usage ```python hist = Histogram() hist.add(1) hist.add(2) hist.add(2) hist.add(3) print(hist.get_frequency(2)) # Output: 2 print(hist.mode()) # Output: [2] print(hist.median()) # Output: 2.0 print(hist.mean()) # Output: 2.0 hist.remove(2) print(hist.get_frequency(2)) # Output: 1 hist.clear() try: hist.median() # Should raise ValueError as the histogram is now empty except ValueError: print(\\"Histogram is empty\\") ``` Input/Output Format - **Add**: Accepts a single integer `value`. - **Remove**: Accepts a single integer `value` and removes it from the histogram. - **GetFrequency**: Accepts a single integer `value` and returns its frequency. - **Mode**: Returns a list of value(s) with the highest frequency. - **Median**: Returns a float representing the median value. - **Mean**: Returns a float representing the mean value. - **Clear**: Clears the histogram. Constraints - The values in the histogram will be integers. - Assume the values added will be reasonable for standard arithmetic operations within memory limits. Performance - Ensure that all operations execute efficiently, considering time complexity.","solution":"from collections import Counter class Histogram: def __init__(self): self.counter = Counter() self.values = [] def add(self, value): self.counter[value] += 1 self.values.append(value) self.values.sort() def remove(self, value): if self.counter[value] == 0: raise ValueError(\\"Value not found in histogram\\") self.counter[value] -= 1 if self.counter[value] == 0: del self.counter[value] self.values.remove(value) def get_frequency(self, value): return self.counter[value] def mode(self): if not self.values: raise ValueError(\\"Histogram is empty\\") max_freq = max(self.counter.values()) return [key for key, freq in self.counter.items() if freq == max_freq] def median(self): if not self.values: raise ValueError(\\"Histogram is empty\\") n = len(self.values) mid = n // 2 if n % 2 == 1: return float(self.values[mid]) else: return (self.values[mid - 1] + self.values[mid]) / 2.0 def mean(self): if not self.values: raise ValueError(\\"Histogram is empty\\") return sum(self.values) / len(self.values) def clear(self): self.counter.clear() self.values.clear()"},{"question":"# Coding Assessment Question: Implementing a Simple File Compression Algorithm Scenario: You are working as a software developer for a data storage company that requires an efficient way to compress and decompress text data. Your task is to implement a simple lossless compression algorithm that can reduce the file size. The chosen method for this task is Run-Length Encoding (RLE). Problem Statement: Write a Python function to compress and decompress text using the Run-Length Encoding algorithm. The functions should work for text files containing any printable ASCII characters and should handle large files efficiently. Provide meaningful error messages if the input file is not found or if there is an issue writing to the output file. Requirements: 1. Two functions: `compress_string(input_str: str) -> str` and `decompress_string(compressed_str: str) -> str`. 2. Handle edge cases such as empty strings or excessively long repeated characters. 3. Provide clear error messages for file-related issues. 4. Ensure the algorithm performs well with large input sizes. Input: - A string `input_str` which is the text message to be compressed. - A string `compressed_str` which is the text message to be decompressed. Output: - A string representing the compressed or decompressed message. Constraints: - The input string and compressed string should contain only printable ASCII characters. Examples: ```python input_str = \\"aaabbbccdddd\\" compressed_str = \\"a3b3c2d4\\" # Compressed String compressed_result = compress_string(input_str) print(compressed_result) # a3b3c2d4 # Decompressed String decompressed_result = decompress_string(compressed_result) print(decompressed_result) # aaabbbccdddd ``` Additional Notes: - Consider edge cases such as when the input string is empty or contains a single character. - Handle sequences that do not compress (e.g., \\"abcd\\" should remain \\"a1b1c1d1\\"). - Your solution should efficiently handle large input strings within a reasonable time. Function Definitions: ```python def compress_string(input_str: str) -> str: # Write your implementation here pass def decompress_string(compressed_str: str) -> str: # Write your implementation here pass ```","solution":"def compress_string(input_str: str) -> str: Compresses the input string using Run-Length Encoding (RLE). if not input_str: return \\"\\" compressed = [] count = 1 for i in range(1, len(input_str)): if input_str[i] == input_str[i - 1]: count += 1 else: compressed.append(f\\"{input_str[i - 1]}{count}\\") count = 1 compressed.append(f\\"{input_str[-1]}{count}\\") return \'\'.join(compressed) def decompress_string(compressed_str: str) -> str: Decompresses the input string encoded with Run-Length Encoding (RLE). if not compressed_str: return \\"\\" decompressed = [] length = len(compressed_str) i = 0 while i < length: char = compressed_str[i] count = 0 i += 1 while i < length and compressed_str[i].isdigit(): count = count * 10 + int(compressed_str[i]) i += 1 decompressed.append(char * count) return \'\'.join(decompressed)"},{"question":"# Coding Question Consider two strings `s` and `t`. You are required to determine the length of the longest common subsequence between them. A subsequence is a sequence that appears in the same relative order but not necessarily consecutively. Function Signature ```python def longest_common_subsequence(s: str, t: str) -> int: Determine the length of the longest common subsequence of two strings. Parameters: - s (str): First input string. - t (str): Second input string. Returns: - int: The length of the longest common subsequence. pass ``` Input 1. `s` (1 ≤ len(s) ≤ 1000): The first string. 2. `t` (1 ≤ len(t) ≤ 1000): The second string. Output An integer representing the length of the longest common subsequence between `s` and `t`. Example ```python s = \\"abcde\\" t = \\"ace\\" # Output: 3 ``` Constraints: - The function should work efficiently to handle the maximum possible length of the strings. Notes: - Consider using a dynamic programming approach to solve this problem efficiently. - Create a 2D array `dp` where `dp[i][j]` represents the length of the longest common subsequence of `s[0:i]` and `t[0:j]`. - Fill the `dp` table iteratively, starting from `dp[0][0]` and moving to `dp[len(s)][len(t)]`.","solution":"def longest_common_subsequence(s: str, t: str) -> int: Determine the length of the longest common subsequence of two strings. Parameters: - s (str): First input string. - t (str): Second input string. Returns: - int: The length of the longest common subsequence. m, n = len(s), len(t) dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the dp table iteratively for i in range(1, m + 1): for j in range(1, n + 1): if s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[m][n]"},{"question":"# Problem Statement You are given an undirected graph represented as an adjacency list where each node points to a list of its neighboring nodes. Write a function that finds the shortest path from a given start node to a goal node using the Dijkstra\'s algorithm. The function should return this path as a list of nodes, or `None` if no path exists. # Function Signature ```python def dijkstra_shortest_path(graph: Dict[int, List[Tuple[int, int]]], start: int, goal: int) -> List[int]: pass ``` # Input * `graph`: A dictionary where keys are node identifiers (integers) and values are lists of tuples. Each tuple consists of a neighboring node identifier and the edge weight (node_id, weight). * `start`: An integer representing the start node. * `goal`: An integer representing the goal node. # Output * A list of integers representing the nodes in the shortest path from start to goal. # Constraints * Nodes are uniquely identified by consecutive integers. * The graph is connected and non-empty. * Edge weights are non-negative integers. # Performance Requirements * Your algorithm should run in O((V + E) log V) time complexity, where V is the number of vertices and E is the number of edges. # Example ```python graph = { 0: [(1, 2), (2, 4)], 1: [(0, 2), (2, 1), (3, 7)], 2: [(0, 4), (1, 1), (3, 2)], 3: [(1, 7), (2, 2)] } start = 0 goal = 3 print(dijkstra_shortest_path(graph, start, goal)) # Expected Output: [0, 1, 2, 3] ``` # Notes * Consider cases where no path exists between the start and goal nodes by returning `None`. * Ensure to handle graphs with varying edge weights efficiently. * You may use a priority queue to manage the frontier nodes.","solution":"import heapq from typing import List, Tuple, Dict def dijkstra_shortest_path(graph: Dict[int, List[Tuple[int, int]]], start: int, goal: int) -> List[int]: # Priority queue to store (cost, current_node, path) and initialize with the start node priority_queue = [(0, start, [start])] # Dictionary to record the shortest distance to each node shortest_distance = {start: 0} while priority_queue: current_cost, current_node, path = heapq.heappop(priority_queue) # If we reach the goal, return the path if current_node == goal: return path # Explore neighbors for neighbor, weight in graph[current_node]: distance = current_cost + weight # If a shorter path to the neighbor is found if neighbor not in shortest_distance or distance < shortest_distance[neighbor]: shortest_distance[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor, path + [neighbor])) # If the goal is never reached, return None return None"},{"question":"# Scenario: You are in charge of developing an algorithm to generate the most efficient route for garbage collection trucks in a city. The city map is represented as a grid with certain cells marked as garbage dumps. # Problem Description: Implement the function `shortestPathToCollectAllGarbage(grid)` which calculates the minimum steps needed for a garbage truck starting at the top-left corner of the grid (0, 0) to visit all garbage dumps and return to the starting position. The grid contains obstacles represented by \'X\' that cannot be traversed. Garbage dumps are marked as \'G\', open spaces as \'.\', and the starting point is always \'.\'. # Function Signature: ```python def shortestPathToCollectAllGarbage(grid: List[List[str]]) -> int: ``` # Input: 1. `grid` (List[List[str]]): A 2D list where each element is either \'.\', \'X\', or \'G\', representing open space, obstacle, and garbage dump respectively. # Output: - Returns an integer representing the minimum number of steps required to collect all garbage and return to the starting point. If it\'s not possible to collect all garbage, return -1. # Constraints: - The grid size is between 1x1 and 20x20. - The grid cells can only contain \'.\', \'X\', or \'G\'. - There can be multiple garbage dumps (\'G\'). # Requirements: 1. Implement an efficient algorithm to calculate the shortest path using Breadth-First Search (BFS) and Traveling Salesman Problem (TSP) approaches due to grid constraints. 2. Handle edge cases where it\'s impossible to reach some or all garbage dumps. # Example: ```python from typing import List, Tuple from collections import deque def shortestPathToCollectAllGarbage(grid: List[List[str]]) -> int: def bfs(start: Tuple[int, int]) -> dict: # Perform BFS to find shortest paths from the start point to all garbage dumps q = deque([start]) visited = set([start]) distances = {start: 0} while q: x, y = q.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] != \'X\' and (nx, ny) not in visited: visited.add((nx, ny)) distances[(nx, ny)] = distances[(x, y)] + 1 q.append((nx, ny)) return distances # Find all garbage dumps and the starting point garbage_dumps = [] for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'G\': garbage_dumps.append((i, j)) elif grid[i][j] == \'.\': start = (i, j) if not garbage_dumps: return 0 # No garbage to collect dists = bfs(start) for dump in garbage_dumps: if dump not in dists: return -1 # If any garbage dump is unreachable all_points = [start] + garbage_dumps all_dists = {point: bfs(point) for point in all_points} from itertools import permutations min_steps = float(\'inf\') for perm in permutations(garbage_dumps): steps = dists[perm[0]] for i in range(len(perm) - 1): steps += all_dists[perm[i]][perm[i + 1]] steps += all_dists[perm[-1]][start] min_steps = min(min_steps, steps) return min_steps # Example validation calls print(shortestPathToCollectAllGarbage([[\'.\', \'G\', \'.\', \'.\', \'.\'], [\'.\', \'X\', \'X\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'G\', \'.\']])) # Output should be 10 ```","solution":"from typing import List, Tuple from collections import deque from itertools import permutations def bfs(grid: List[List[str]], start: Tuple[int, int]) -> dict: q = deque([start]) visited = set([start]) distances = {start: 0} while q: x, y = q.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] != \'X\' and (nx, ny) not in visited: visited.add((nx, ny)) distances[(nx, ny)] = distances[(x, y)] + 1 q.append((nx, ny)) return distances def shortestPathToCollectAllGarbage(grid: List[List[str]]) -> int: garbage_dumps = [] for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'G\': garbage_dumps.append((i, j)) elif grid[i][j] == \'.\' and i == 0 and j == 0: start = (i, j) if not garbage_dumps: return 0 # No garbage to collect dists = bfs(grid, start) for dump in garbage_dumps: if dump not in dists: return -1 # If any garbage dump is unreachable all_points = [start] + garbage_dumps all_dists = {point: bfs(grid, point) for point in all_points} def calculate_total_steps(path): steps = dists[path[0]] for i in range(len(path) - 1): steps += all_dists[path[i]][path[i + 1]] steps += all_dists[path[-1]][start] return steps min_steps = float(\'inf\') for perm in permutations(garbage_dumps): steps = calculate_total_steps(perm) min_steps = min(min_steps, steps) return min_steps"},{"question":"# Question Write a Python function `find_min_max(arr)` that takes an array of integers and returns a tuple containing the minimum and maximum values in the array without using the built-in `min` and `max` functions. The function should implement the following: * **Input**: - `arr`: a list of integers representing the array. * **Output**: - A tuple where the first element is the minimum value in the array and the second element is the maximum value. * **Constraints**: - The array will contain at least one element. - The elements in the array are integers within the range -10^9 to 10^9. * **Additional Specifications**: - Ensure your solution is efficient and handles both positive and negative integers. - Raise a ValueError if the input array is empty. * **Example**: ```python arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] result = find_min_max(arr) print(result) # Example output: (1, 9) ``` To implement the function: ```python def find_min_max(arr): if len(arr) == 0: raise ValueError(\\"Array must contain at least one element\\") min_val = arr[0] max_val = arr[0] for num in arr: if num < min_val: min_val = num if num > max_val: max_val = num return (min_val, max_val) # Example usage arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] result = find_min_max(arr) print(result) # Example output: (1, 9) ```","solution":"def find_min_max(arr): Returns a tuple containing the minimum and maximum values in the array. if not arr: raise ValueError(\\"Array must contain at least one element\\") min_val, max_val = arr[0], arr[0] for num in arr: if num < min_val: min_val = num if num > max_val: max_val = num return (min_val, max_val)"},{"question":"# Problem Statement You are required to implement a function that generates all possible combinations of a given string with the characters sorted in ascending order. This task is crucial in fields like statistical analysis and data processing, where such combinations can be used for generating test cases, permutations, etc. Function Signature ```python def generate_combinations(s: str) -> List[str]: ``` # Input - `s`: A string, 1 ≤ |s| ≤ 10. It represents the input string consisting of lowercase English letters only. # Output - Returns a list of strings, each representing a unique combination of the characters sorted in ascending order. # Constraints - The output list should be sorted in lexicographical order. - Each combination should be unique and characters in each combination should also be sorted in ascending order. # Example ```python assert generate_combinations(\\"abc\\") == [\\"a\\", \\"ab\\", \\"abc\\", \\"ac\\", \\"b\\", \\"bc\\", \\"c\\"] assert generate_combinations(\\"aab\\") == [\\"a\\", \\"aa\\", \\"aab\\", \\"ab\\", \\"b\\"] assert generate_combinations(\\"xy\\") == [\\"x\\", \\"xy\\", \\"y\\"] assert generate_combinations(\\"a\\") == [\\"a\\"] ``` # Explanation 1. For the string \\"abc\\": - The possible combinations are: \\"a\\", \\"ab\\", \\"abc\\", \\"ac\\", \\"b\\", \\"bc\\", and \\"c\\". - These combinations are naturally in lexicographical order as \\"abc\\" is already sorted. 2. For the string \\"aab\\": - The possible unique combinations are: \\"a\\", \\"aa\\", \\"aab\\", \\"ab\\", and \\"b\\". - The function should ensure duplicates are removed and the result is in the desired order. 3. For the string \\"a\\": - The only possible combination is: \\"a\\". Implement the function, ensuring efficiency and correctness for the possible edge cases provided.","solution":"from itertools import combinations from typing import List def generate_combinations(s: str) -> List[str]: Generates all possible combinations of a given string with characters sorted in ascending order. Each combination is sorted and the result list is in lexicographical order. sorted_s = sorted(s) result = set() for r in range(1, len(sorted_s) + 1): for combo in combinations(sorted_s, r): result.add(\'\'.join(combo)) return sorted(result)"},{"question":"# Matrix Transpose Efficiency Test Objective You need to efficiently compute the transposition of a given 2D matrix and return the transposed matrix. Problem Statement Implement the function `transpose_matrix(matrix: List[List[int]]) -> List[List[int]]` that computes the transpose of an (m times n) matrix. Input and Output * **Input**: * `matrix`: A list of lists representing the original 2D matrix of integers. * **Output**: * Returns a new list of lists representing the transposed matrix. Constraints * Each inner list in `matrix` represents a row in a 2D matrix. * The input matrix can be of any dimension (m times n). Performance Requirement The function should run in (O(m times n)) time complexity. Example ```python >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[1]]) [[1]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6], [7, 8]]) [[1, 3, 5, 7], [2, 4, 6, 8]] >>> transpose_matrix([]) [] >>> transpose_matrix([[1, 2, 3]]) [[1], [2], [3]] ``` Note * Ensure the function handles an edge case where the matrix is empty (zero rows and columns). * Consider another edge case where the matrix has only one row or one column. Function Signature ```python from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: # Your implementation here ``` Additional Information * Given `[[1, 2, 3], [4, 5, 6]]`, the transposed matrix will be `[[1, 4], [2, 5], [3, 6]]`. * Given `[[1, 2, 3]]`, the transposed matrix will be `[[1], [2], [3]]`. Implement the function `transpose_matrix` to accomplish the task as described above.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: if not matrix or not matrix[0]: return [] rows = len(matrix) columns = len(matrix[0]) transposed = [[0] * rows for _ in range(columns)] for i in range(rows): for j in range(columns): transposed[j][i] = matrix[i][j] return transposed"},{"question":"You are required to decipher a partially implemented **URL Shortener** service class in Python. Your task is to complete the implementation by adding an additional method called `decode`. This method should retrieve the original URL given its shortened version. **Function Signature**: ```python def decode(self, short_url: str) -> str | None: pass ``` # Instructions 1. **Function Details**: - **Input**: A string `short_url` representing the shortened URL. - **Output**: Returns the original URL as a string if it exists, otherwise returns `None`. - **Constraints**: - You may assume that the shortening process works using a unique hash code approach, mapping long URLs to shorter ones. - Ensure your implementation does not alter any other functionalities of the URL shortener. 2. **Examples**: ```python url_shortener = URLShortener() original_url = \\"https://www.example.com\\" short_url = url_shortener.encode(original_url) assert url_shortener.decode(short_url) == \\"https://www.example.com\\" assert url_shortener.decode(\\"http://short.url/fake\\") is None ``` 3. **Guidelines**: - Enforce a mapping between the original URL and the shortened version. - Handle scenarios where the shortened URL provided does not map to any original URL. - Your method should be efficient in retrieving original URLs. # Additional Notes: - Focus on ensuring the correct retrieval of URLs even after multiple encodings and decodings. - Consider using a data structure that allows quick look-up. Implement the `decode` method in the `URLShortener` class: # Code to Implement ```python class URLShortener: def __init__(self): self.url_to_short = {} self.short_to_url = {} self.base_url = \\"http://short.url/\\" self.counter = 0 def encode(self, long_url: str) -> str: if long_url in self.url_to_short: return self.url_to_short[long_url] self.counter += 1 short_url = self.base_url + str(self.counter) self.url_to_short[long_url] = short_url self.short_to_url[short_url] = long_url return short_url def decode(self, short_url: str) -> str | None: # Your code here pass ``` The `decode` method should retrieve the original URL if the `short_url` exists in the `short_to_url` dictionary, otherwise return `None`.","solution":"class URLShortener: def __init__(self): self.url_to_short = {} self.short_to_url = {} self.base_url = \\"http://short.url/\\" self.counter = 0 def encode(self, long_url: str) -> str: if long_url in self.url_to_short: return self.url_to_short[long_url] self.counter += 1 short_url = self.base_url + str(self.counter) self.url_to_short[long_url] = short_url self.short_to_url[short_url] = long_url return short_url def decode(self, short_url: str) -> str | None: return self.short_to_url.get(short_url)"},{"question":"**[Question 2]:** Write a function named `file_size_summary` that scans a given directory and produces a summary of file sizes. The summary should categorize the files into different size ranges and count the number of files in each range. The size ranges to consider are: 1. Less than 1 KB 2. 1 KB to less than 1 MB 3. 1 MB to less than 100 MB 4. 100 MB to less than 1 GB 5. 1 GB or more Your implementation should also handle potential errors such as: - Invalid directory paths. - Lack of read permissions for files within the directory. - Non-file entries (e.g., other directories). Write the function `file_size_summary` with the following signature: ```python import os from typing import Dict def file_size_summary(directory: str) -> Dict[str, int]: # Your implementation here ``` # Input: - `directory` (str): The path of the directory to scan. # Output: - Returns a dictionary with the size categories as keys and the corresponding counts of files in each category as values. # Constraints: - The directory can contain any number of files. - Recursive traversal of subdirectories is not required. # Example Output: If the directory contains the following files with sizes: - `file1.txt` - 500 Bytes - `file2.txt` - 1500 Bytes - `file3.zip` - 2 MB - `file4.iso` - 700 MB - `file5.mkv` - 2 GB The output will be: ```python { \\"Less than 1 KB\\": 1, \\"1 KB to less than 1 MB\\": 1, \\"1 MB to less than 100 MB\\": 1, \\"100 MB to less than 1 GB\\": 1, \\"1 GB or more\\": 1 } ``` # Additional Considerations: - Ensure that the function is efficient and can handle directories with a large number of files. - Use appropriate exception handling to catch and handle errors gracefully. - Your implementation should follow best practices for coding style and readability.","solution":"import os from typing import Dict def file_size_summary(directory: str) -> Dict[str, int]: size_categories = { \\"Less than 1 KB\\": 0, \\"1 KB to less than 1 MB\\": 0, \\"1 MB to less than 100 MB\\": 0, \\"100 MB to less than 1 GB\\": 0, \\"1 GB or more\\": 0 } try: for entry in os.scandir(directory): if entry.is_file(): try: size = entry.stat().st_size if size < 1024: size_categories[\\"Less than 1 KB\\"] += 1 elif size < 1024 ** 2: size_categories[\\"1 KB to less than 1 MB\\"] += 1 elif size < 1024 ** 2 * 100: size_categories[\\"1 MB to less than 100 MB\\"] += 1 elif size < 1024 ** 3: size_categories[\\"100 MB to less than 1 GB\\"] += 1 else: size_categories[\\"1 GB or more\\"] += 1 except PermissionError: # Handle lack of read permission gracefully continue except FileNotFoundError: return {\\"Error\\": \\"Directory not found\\"} except NotADirectoryError: return {\\"Error\\": \\"Not a directory\\"} except PermissionError: return {\\"Error\\": \\"Permission denied\\"} return size_categories"},{"question":"# Data Processing and Visualization You are asked to create a function that processes a given dataset and generates a specific type of plot with customized formatting and annotations. The function should be capable of handling potential data inconsistencies and manage missing values effectively. **Function Signature** ```python def generate_scatter_plot(data: List[dict], x_key: str, y_key: str, annotation_key: str): ``` # Input 1. `data` (List[dict]): A list of dictionaries representing the dataset. Each dictionary corresponds to a single data point with the keys being the attributes. 2. `x_key` (str): The key used to extract x-values from each dictionary. 3. `y_key` (str): The key used to extract y-values from each dictionary. 4. `annotation_key` (str): The key used to extract annotations for each data point. # Output * A `matplotlib` scatter plot which displays the data points with annotations. # Constraints * Handle missing values by skipping over data points with missing values. * Customize the plot by: - Annotating each point with the value from `annotation_key`. - Setting the x-axis label as `x_key` and y-axis label as `y_key`. - Adding a title \\"Scatter Plot of {} vs {}\\".format(y_key, x_key). - Ensuring the plot\'s grid is enabled for better visual comprehension. * Maintain the readability of annotations by adjusting the text size and offsets if necessary. **Examples** ```python data = [ {\\"GDP\\": 60000, \\"Life Expectancy\\": 80, \\"Country\\": \\"Country A\\"}, {\\"GDP\\": 40000, \\"Life Expectancy\\": 72, \\"Country\\": \\"Country B\\"}, {\\"GDP\\": 20000, \\"Life Expectancy\\": 68, \\"Country\\": \\"Country C\\"}, {\\"GDP\\": None, \\"Life Expectancy\\": 75, \\"Country\\": \\"Country D\\"}, {\\"GDP\\": 30000, \\"Life Expectancy\\": 70, \\"Country\\": \\"Country E\\"}, ] generate_scatter_plot(data, \\"GDP\\", \\"Life Expectancy\\", \\"Country\\") # Output: A scatter plot with x-axis labeled \'GDP\', y-axis labeled \'Life Expectancy\', and points annotated with the respective country names. ``` # Hint You can use the `matplotlib` library to generate the plot. The `annotate` method of `matplotlib` can be used to add annotations to each data point.","solution":"import matplotlib.pyplot as plt from typing import List, Dict def generate_scatter_plot(data: List[Dict], x_key: str, y_key: str, annotation_key: str): x_values = [] y_values = [] annotations = [] for entry in data: if x_key in entry and y_key in entry and annotation_key in entry: if entry[x_key] is not None and entry[y_key] is not None: x_values.append(entry[x_key]) y_values.append(entry[y_key]) annotations.append(entry[annotation_key]) plt.figure(figsize=(10, 6)) plt.scatter(x_values, y_values) for i, annotation in enumerate(annotations): plt.annotate(annotation, (x_values[i], y_values[i]), textcoords=\\"offset points\\", xytext=(5, 5), ha=\'center\', fontsize=8) plt.xlabel(x_key) plt.ylabel(y_key) plt.title(f\\"Scatter Plot of {y_key} vs {x_key}\\") plt.grid(True) plt.show()"},{"question":"# Coding Assessment Question Context A company has hired you to help them analyze their financial data. They need a function to determine the longest period during which a specific stock showed a continuous increasing trend. Task Write a function `longest_increasing_trend(prices: list[float]) -> int` that takes a list of daily stock prices and returns the length of the longest continuous increasing trend. Input/Output Format * **Input**: A list of floats `prices` representing the stock prices on consecutive days. The list can be empty. * **Output**: An integer representing the length of the longest continuous increasing trend. If the list is empty, the output should be 0. Constraints 1. The function should handle edge cases (e.g., an empty list or a list with one element). 2. Optimize performance to handle large lists efficiently. Example ```python >>> longest_increasing_trend([100.0, 101.5, 102.0, 99.9, 100.5, 101.0]) 3 >>> longest_increasing_trend([102.0, 101.5, 100.0, 99.9]) 1 >>> longest_increasing_trend([100.0, 100.0, 100.0]) 1 >>> longest_increasing_trend([]) 0 >>> longest_increasing_trend([99.0]) 1 ```","solution":"def longest_increasing_trend(prices): Returns the length of the longest continuous increasing trend in stock prices. if not prices: return 0 longest_trend = 1 current_trend = 1 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: current_trend += 1 longest_trend = max(longest_trend, current_trend) else: current_trend = 1 return longest_trend"},{"question":"# Coding Assessment Question Problem Description You are given an array of integers, where each element represents the number of rocks a person can throw in one day. Your task is to write a function `max_rocks_sequence(rocks: list) -> int` to determine the maximum number of consecutive days during which the amount of rocks thrown increases or stays the same each day. Function Signature ```python def max_rocks_sequence(rocks: list) -> int: ``` Input - `rocks`: A list of integers representing the number of rocks thrown each day. The list may be empty. Output - An integer representing the length of the longest sequence of consecutive days during which the number of rocks thrown is non-decreasing. Constraints - The length of `rocks` will be at most 10^4. - Each element of `rocks` will be an integer from 0 to 10^9. Examples ```python # Example 1 rocks = [1, 2, 2, 3, 1, 2, 3, 4] assert max_rocks_sequence(rocks) == 4 # The sequence [1, 2, 2, 3] # Example 2 rocks = [5, 4, 3, 2, 1] assert max_rocks_sequence(rocks) == 1 # No increasing subsequence longer than 1 day # Example 3 rocks = [2, 2, 2, 2, 2] assert max_rocks_sequence(rocks) == 5 # The sequence [2, 2, 2, 2, 2] # Example 4 rocks = [] assert max_rocks_sequence(rocks) == 0 # No days to throw rocks # Example 5 rocks = [3, 3, 4, 2, 2, 2, 1, 0] assert max_rocks_sequence(rocks) == 3 # The sequence [2, 2, 2] ``` Requirements - Handle input validation and if the input is invalid, return 0. - Ensure the algorithm is optimized to run efficiently within the given constraints. Good luck!","solution":"def max_rocks_sequence(rocks: list) -> int: Returns the length of the longest sequence of consecutive days during which the number of rocks thrown is non-decreasing. if not rocks: return 0 max_length = 1 current_length = 1 for i in range(1, len(rocks)): if rocks[i] >= rocks[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"# Sieve of Eratosthenes Optimization Challenge You are tasked to optimize the classic Sieve of Eratosthenes algorithm. This algorithm is used to find all prime numbers up to a given limit. However, your implementation should enhance the efficiency of the classic version through various optimizations. 1. Optimized Sieve Implementation Implement an optimized function to find all prime numbers up to a given limit: ```python def optimized_sieve(limit: int) -> list[int]: ``` * **Input**: An integer `limit` representing the upper bound of prime numbers to find. * **Output**: A list of integers representing all prime numbers up to the input limit. # Constraints * The limit should be a positive integer greater than 1. * Your solution should handle inputs up to 10,000,000 efficiently in terms of time and space complexity. # Example ```python limit = 30 primes = optimized_sieve(limit) assert primes == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] ``` # Additional Rules 1. Consider the use of efficient data structures and techniques to minimize unnecessary computations. 2. Ensure that your solution properly handles large inputs without significant performance degradation. 3. Avoid using any pre-existing libraries for prime number computation except Python\'s standard library. # Explanation The classic Sieve of Eratosthenes algorithm marks the non-prime numbers in a Boolean array through simple iteration. Your optimized version should make improvements such as skipping even numbers after 2 and starting the marking process from the square of each prime number. Example Walkthrough: To find all primes up to `30` using optimized sieve: 1. Initialize a boolean list `is_prime` of size `31` with True values. 2. Set `is_prime[0]` and `is_prime[1]` to False. 3. Start from the first prime number `2` and mark its multiples as False. 4. Continue with the next true value in the list, marking its multiples. 5. Return all indices with True values. **Good luck with your implementation! Ensure your code is clean, well-commented, and tested for various edge cases.**","solution":"def optimized_sieve(limit: int) -> list[int]: Optimized Sieve of Eratosthenes algorithm to find all prime numbers up to the given limit. if limit < 2: return [] is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False # 0 and 1 are not prime numbers p = 2 while p * p <= limit: if is_prime[p]: for multiple in range(p * p, limit + 1, p): is_prime[multiple] = False p += 1 primes = [num for num, prime in enumerate(is_prime) if prime] return primes"},{"question":"# Problem Statement Given a string that represents a positive integer, your task is to write a function that returns the next lexicographical permutation of the given number represented as a string. If such a permutation is not possible, the function should return the smallest possible permutation of the number. # Function Signature ```python def next_lexicographical_permutation(num: str) -> str: pass ``` # Input - `num` - A string representing a positive integer without leading zeros. # Output - Return the next lexicographical permutation of the number as a string. If no such permutation exists, return the smallest permutation of the number. # Constraints - The length of the string `num` will be between 1 and 10^5. - The integer represented by `num` will be positive and fit within the range of typical integer values in programming languages. # Detailed Requirements 1. Implement a function that determines the next lexicographical permutation of the given string number. 2. If no such permutation exists (i.e., the number is in descending order), return the smallest possible permutation of the digits. 3. Ensure the function handles edge cases such as single-digit numbers or multiple digits with the same value. 4. The algorithm should ideally run in O(n) time complexity where n is the length of the string. # Example ```python >>> next_lexicographical_permutation(\\"123\\") \\"132\\" >>> next_lexicographical_permutation(\\"321\\") \\"123\\" >>> next_lexicographical_permutation(\\"115\\") \\"151\\" >>> next_lexicographical_permutation(\\"1\\") \\"1\\" ``` # Notes - The function should correctly handle large string numbers without converting them to actual numeric types, ensuring it works within the constraints. - Pay careful attention to handling edge cases and ensuring the function is efficient and robust. - Consider using an in-place algorithm for finding the next permutation to minimize memory usage.","solution":"def next_lexicographical_permutation(num: str) -> str: # Convert to list for easier manipulation num_list = list(num) # Step 1: Find the largest index k such that num_list[k] < num_list[k + 1] k = len(num_list) - 2 while k >= 0 and num_list[k] >= num_list[k + 1]: k -= 1 if k == -1: # If no such index exists, the permutation is the last permutation return \'\'.join(sorted(num_list)) # Step 2: Find the largest index l greater than k such that num_list[k] < num_list[l] l = len(num_list) - 1 while num_list[k] >= num_list[l]: l -= 1 # Step 3: Swap the value of num_list[k] with that of num_list[l] num_list[k], num_list[l] = num_list[l], num_list[k] # Step 4: Reverse the sequence from num_list[k + 1] to the end of the list num_list[k + 1:] = reversed(num_list[k + 1:]) return \'\'.join(num_list)"},{"question":"# Sum Combination Problem Problem Statement: You need to find and print all unique combinations of positive integers that sum up to a given number `n`. Detailed Description: Given a target sum `n`, generate all possible combinations of positive integers that add up to `n`. Each combination should be sorted in ascending order, and no combination should appear more than once. Function Signature: ```python def sum_combinations(n: int) -> list[list[int]]: # Your code here ``` Input/Output: * **Input**: * `n` (int): The target integer to reach using combinations of positive integers. * **Output**: * A list of lists, where each inner list contains a combination of integers that add up to `n`. Constraints: * The input `n` will be a positive integer within a reasonable range (1 ≤ n ≤ 30). Example: ```python print(sum_combinations(4)) # Output: [[1, 1, 1, 1], [1, 1, 2], [1, 3], [2, 2], [4]] print(sum_combinations(3)) # Output: [[1, 1, 1], [1, 2], [3]] print(sum_combinations(1)) # Output: [[1]] print(sum_combinations(0)) # Output: ValueError: Sum must be a positive integer ``` Implementation Notes: * Ensure that your solution handles invalid inputs (e.g., zero or negative numbers) by raising a `ValueError` with a relevant message. * To avoid duplicate combinations, sort the combinations in ascending order before adding them to the result list. * Use a recursive approach or dynamic programming to efficiently generate the combinations. * Include examples and edge cases in docstrings and comments.","solution":"def sum_combinations(n: int) -> list[list[int]]: if n <= 0: raise ValueError(\\"Sum must be a positive integer\\") def find_combinations(target, start, path, result): if target == 0: result.append(path) return for i in range(start, n + 1): if target - i >= 0: find_combinations(target - i, i, path + [i], result) result = [] find_combinations(n, 1, [], result) return result"},{"question":"# Coding Assessment Question You are tasked with implementing a specialized sorting algorithm that aims to efficiently sort an array of floating-point numbers where the majority of the numbers are within a small range, but a few outliers exist. This algorithm, known as \\"Bucketed Quick Sort,\\" combines elements of both bucket sort and quicksort to handle such distributions efficiently. Function Signature ```python def bucketed_quick_sort(arr): pass ``` Input/Output * **Input**: - `arr`: A list of floating-point numbers. For example, `[1.1, 2.9, 3.2, 0.5, 100.5, 2.1, -50.3]`. * **Output**: - Returns a new list containing the numbers sorted in non-decreasing order. Constraints * The length of the list, `n`, will be in the range `[1, 10^4]`. * The elements of the list are floating-point numbers and can include negative values. * Your function should aim to achieve an average-case time complexity close to (O(n log n)). Scenario Suppose you are developing a financial application that frequently receives large datasets consisting mostly of prices within a certain range, but occasionally with some extreme values due to errors or anomalies. Sorting these datasets efficiently is crucial for performing further calculations and analytics. Performance Requirements * The function should be able to handle lists with a large number of elements efficiently, even with the presence of outliers. * Aim to minimize overhead and avoid excessive memory usage, striking a balance between the advantages of bucket sort and the efficiency of quicksort. Example ```python # Example usage print(bucketed_quick_sort([1.1, 2.9, 3.2, 0.5, 100.5, 2.1, -50.3])) # Output: [-50.3, 0.5, 1.1, 2.1, 2.9, 3.2, 100.5] print(bucketed_quick_sort([4.8, 3.2, 1.5, 2.3, 3.7])) # Output: [1.5, 2.3, 3.2, 3.7, 4.8] ``` Note Ensure that the implementation appropriately balances the initial bucketing (which handles localized distribution efficiently) with the recursive quicksort approach (dealing with outliers). Carefully test edge cases with extremely small and large datasets.","solution":"def bucketed_quick_sort(arr): def quick_sort(arr): if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right) if not arr: return arr min_val = min(arr) max_val = max(arr) bucket_size = (max_val - min_val) / len(arr) if len(arr) > 1 else 1 if bucket_size == 0: return arr buckets = [[] for _ in range(len(arr) + 1)] for num in arr: bucket_index = int((num - min_val) // bucket_size) buckets[bucket_index].append(num) sorted_array = [] for bucket in buckets: if bucket: sorted_array.extend(quick_sort(bucket)) return sorted_array"},{"question":"# Question: Implement Majority Element Finder via Boyer-Moore Voting Algorithm The Boyer-Moore Voting Algorithm is an efficient way to find the majority element in a sequence, where the majority element is defined as the element that appears more than half the times in the list. This task requires you to implement this algorithm to find the majority element in a given list of integers. # Objective Implement a function `find_majority_element(nums: list[int]) -> int` that takes a list of integers and returns the majority element. If no majority element exists, return `-1`. # Input * `nums` (list): A list of integers. # Output * An integer representing the majority element or `-1` if no such element exists. # Constraints * The input list will contain `n` elements where `1 <= n <= 10^5`. * The majority element, if present, will appear more than `n//2` times. # Performance Requirement * Aim for an implementation with O(n) time complexity and O(1) space complexity. # Example ```python nums = [2, 2, 1, 1, 1, 2, 2] print(find_majority_element(nums)) # Output: 2 ``` ```python nums = [3, 3, 4, 2, 4, 4, 2, 4, 4] print(find_majority_element(nums)) # Output: 4 ``` ```python nums = [1, 2, 3, 4] print(find_majority_element(nums)) # Output: -1 ``` # Guidelines To find the majority element using the Boyer-Moore Voting Algorithm: 1. Initialize a candidate index and a count. 2. Iterate through the list: - If the count is 0, set the current candidate to the current element. - Increment or decrement the count depending on whether the current element is the same as the candidate. 3. After one pass, verify that the candidate is indeed the majority element by counting its occurrences.","solution":"def find_majority_element(nums): Finds the majority element in a list using the Boyer-Moore Voting Algorithm. Returns the majority element if it exists, otherwise returns -1. candidate = None count = 0 # Phase 1: Find a potential candidate for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) # Phase 2: Verify the candidate if candidate is not None and nums.count(candidate) > len(nums) // 2: return candidate return -1"},{"question":"# Stock Market Price Analysis You are developing a feature for a stock trading application that will help users analyze stock price movements over a period of time. Given historical stock price data, you need to implement a function that calculates the maximum profit that can be achieved by buying and selling the stock on different days. The function should also identify the days on which to buy and sell the stock to achieve this maximum profit. **Function Requirements** 1. **Function Name**: `max_profit(prices: List[int]) -> dict` 2. **Input**: - `prices` (List[int]): A list of integers representing the stock prices on different days. 3. **Output**: - A dictionary with the following structure: ```python { \\"max_profit\\": int, # The maximum profit that can be achieved \\"buy_day\\": int, # The day to buy the stock (0-based index) \\"sell_day\\": int # The day to sell the stock (0-based index) } ``` 4. **Constraints**: - There must be at least 2 prices in the list. - If no profit can be achieved, both `buy_day` and `sell_day` should be set to `None`. **Performance Requirements** - The solution should run in O(n) time complexity, where `n` is the number of days (length of the price list). **Example Usage** ```python result = max_profit([7, 1, 5, 3, 6, 4]) # Example output # { # \\"max_profit\\": 5, # Maximum profit (6 - 1) # \\"buy_day\\": 1, # Buy on day 1 (price 1) # \\"sell_day\\": 4 # Sell on day 4 (price 6) # } result = max_profit([7, 6, 4, 3, 1]) # Example output # { # \\"max_profit\\": 0, # No profit can be achieved # \\"buy_day\\": None, # No valid buy day # \\"sell_day\\": None # No valid sell day # } ``` **Hints** 1. Use a single pass approach to find the minimum price and calculate the maximum profit simultaneously. 2. Keep track of the minimum price encountered so far as you iterate through the list. 3. Calculate potential profit at each step and update the maximum profit and corresponding days as needed. Good luck!","solution":"from typing import List, Dict def max_profit(prices: List[int]) -> Dict[str, int]: if not prices or len(prices) < 2: return { \\"max_profit\\": 0, \\"buy_day\\": None, \\"sell_day\\": None } min_price_day = 0 max_profit = 0 buy_day = None sell_day = None for i in range(1, len(prices)): if prices[i] < prices[min_price_day]: min_price_day = i current_profit = prices[i] - prices[min_price_day] if current_profit > max_profit: max_profit = current_profit buy_day = min_price_day sell_day = i return { \\"max_profit\\": max_profit, \\"buy_day\\": buy_day, \\"sell_day\\": sell_day }"},{"question":"# **Calculate Factorial using Recursion** Background Factorial is a mathematical function that multiplies a given number by every number lower than it down to one. It\'s denoted as `n!` and is widely used in combinatorics, algebra, and other fields of mathematics. Using recursion, you can elegantly solve the factorial problem with a simple function call. Task Write a Python function `calculate_factorial(n: int) -> int` that takes a single integer `n` and returns the factorial of `n` computed recursively. Details: 1. **Input Format**: A single integer `n`. 2. **Output Format**: An integer representing the factorial of the input number `n`. Constraints: - The function should raise a `ValueError` if the input is a negative number, as factorial is not defined for negative numbers. - The function should raise a `TypeError` if the input is not an integer. Examples: ``` calculate_factorial(0) # 1, because 0! = 1 by definition calculate_factorial(1) # 1, because 1! = 1 calculate_factorial(4) # 24, because 4! = 4 * 3 * 2 * 1 = 24 calculate_factorial(5) # 120, because 5! = 5 * 4 * 3 * 2 * 1 = 120 calculate_factorial(-3) # Raises ValueError calculate_factorial(4.5) # Raises TypeError ``` Notes: 1. Utilize a recursive method to calculate the factorial. 2. Validate your input before attempting the recursive calculation. 3. Write appropriate test cases to handle possible edge cases.","solution":"def calculate_factorial(n): Calculate the factorial of a non-negative integer n using recursion. Raises a ValueError for negative integers and TypeError for non-integers. Args: n (int): the input integer for which factorial needs to be calculated. Returns: int: factorial of the input integer n. Raises: ValueError: if n is a negative integer. TypeError: if n is not an integer. if not isinstance(n, int): raise TypeError(\\"Input must be an integer.\\") if n < 0: raise ValueError(\\"Factorial is not defined for negative numbers.\\") if n == 0: return 1 else: return n * calculate_factorial(n - 1)"},{"question":"# Question Context: You are working on a software project for a library that needs a utility function to check if a book title string is a palindrome. A palindrome is a string that reads the same backward as forward, ignoring cases, spaces, and punctuation. Task: Write a function `is_palindrome(title: str) -> bool` that: 1. Accepts a single input string representing the book title. 2. Returns `True` if the string is a palindrome, and `False` otherwise. # Requirements: 1. The function should ignore whitespace and be case-insensitive. 2. The function should handle only alphabetic characters and ignore non-alphabetic characters (e.g., punctuation). # Input Format: * One string `title`. # Output Format: * Boolean indicating if the string is a palindrome. # Constraints: * The length of the string will be at most 10<sup>6</sup> characters. * The input can contain alphabetic characters (both uppercase and lowercase), spaces, and punctuation. # Example Usage: ```python >>> is_palindrome(\'A man, a plan, a canal, Panama!\') True >>> is_palindrome(\'Was it a car or a cat I saw?\') True >>> is_palindrome(\'No lemon, no melon\') True >>> is_palindrome(\'Hello World\') False >>> is_palindrome(\'Do geese see God?\') True >>> is_palindrome(\'Madam, in Eden, I’m Adam\') True >>> is_palindrome(\'Not a palindrome\') False ``` # Performance Requirements: - The solution should handle input strings efficiently, especially for very long strings up to 10<sup>6</sup> characters. Implementation Example: Here is a function signature to start with: ```python def is_palindrome(title: str) -> bool: pass ```","solution":"def is_palindrome(title: str) -> bool: Checks if a given title string is a palindrome, ignoring cases, spaces, and punctuation. :param title: str - The book title to check :return: bool - True if the title is a palindrome, False otherwise # Filter out non-alphabetic characters and convert to lower case filtered_title = \'\'.join(char.lower() for char in title if char.isalpha()) # Check if the filtered title is equal to its reverse return filtered_title == filtered_title[::-1]"},{"question":"# Question Scenario You are working on a task management app that helps users to manage their daily tasks efficiently. The app allows users to define tasks and specify dependencies between them. For example, a user might want to \\"Write Report\\" only after \\"Research Topic\\" and \\"Collect Data\\" tasks are completed. Task Write a function `prioritize_tasks(task_graph: List[List[int]], tasks: Dict[int, str]) -> List[str]` that performs a topological sort on the given task dependency graph and returns a list of task names in the order they should be completed. Input and Output formats * **Input**: * `task_graph`: A List of Lists of integers where `task_graph[u]` contains all vertices `v` that there are directed edges from vertex `u` to vertex `v`. * `tasks`: A dictionary where keys are integers representing the vertices, and values are the names of tasks. * **Output**: * A list of strings representing the correct order of task completion. Constraints * The task dependency graph is a directed acyclic graph (DAG). * The length of the task graph (number of vertices) is at most 1000. * Each vertex in the task graph is unique. * The task graph represents valid dependencies for task completion. Example ```python tasks = { 0: \\"Collect Data\\", 1: \\"Research Topic\\", 2: \\"Write Report\\", 3: \\"Proofread Report\\", 4: \\"Submit Report\\", } task_graph = [[2], [2], [3], [4], []] print(prioritize_tasks(task_graph, tasks)) # Output: # [\'Collect Data\', \'Research Topic\', \'Write Report\', \'Proofread Report\', \'Submit Report\'] ``` Use the given task_graph and tasks dictionary to demonstrate the function in action.","solution":"from typing import List, Dict def prioritize_tasks(task_graph: List[List[int]], tasks: Dict[int, str]) -> List[str]: Perform topological sort on the given task dependency graph and return the order of tasks names in which they should be completed. :param task_graph: Adjacency list representing the task dependency graph. :param tasks: Dictionary mapping task indices to their names. :return: List of task names in the order they should be completed. from collections import deque # Calculate in-degrees (number of incoming edges) for each node in_degree = [0] * len(task_graph) for node in range(len(task_graph)): for neighbor in task_graph[node]: in_degree[neighbor] += 1 # Initialize the queue with nodes having zero in-degree queue = deque([i for i in range(len(task_graph)) if in_degree[i] == 0]) topo_order = [] while queue: node = queue.popleft() topo_order.append(node) for neighbor in task_graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If there\'s a cycle in the graph, topo_order will not contain all the vertices if len(topo_order) != len(task_graph): raise ValueError(\\"The graph is not a DAG (cycle detected).\\") # Mapping indices to task names task_order = [tasks[i] for i in topo_order] return task_order"},{"question":"# Sum of Leaves in a Binary Tree **Context**: In computer science, binary trees are a fundamental data structure used in various applications such as sorting, searching, and hierarchical data representation. One common problem is calculating the sum of all the leaf nodes in a binary tree. **Objective**: Write a function that calculates the sum of all the leaf nodes in a binary tree. **Function Signature**: ```python def sum_of_leaves(root: Optional[TreeNode]) -> int: ``` **Input**: - `root` (TreeNode or None): The root node of the binary tree. It is either a TreeNode object or `None` if the tree is empty. **Output**: - Returns the sum of all the leaf nodes as an integer. **TreeNode Class Definition**: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` **Examples**: ```python # Example 1: # Tree structure: # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) >>> sum_of_leaves(root) 12 # Example 2: # Tree structure: # 3 # / # 9 20 # / # 15 7 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) >>> sum_of_leaves(root) 31 # Example 3: # Tree structure: # 1 root = TreeNode(1) >>> sum_of_leaves(root) 1 # Example 4: # Tree structure: # None >>> sum_of_leaves(None) 0 ``` **Constraints**: - The structure of the TreeNode class should not be modified. - The `TreeNode` values will be integers. **Performance Requirements**: - The solution should traverse the tree efficiently, ensuring a time complexity of O(n), where n is the number of nodes in the tree. **Notes**: - A leaf node is a node with no children. - Ensure that your implementation handles edge cases such as an empty tree or a tree with only one node. **Task**: Implement the `sum_of_leaves` function to meet the above specifications.","solution":"from typing import Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sum_of_leaves(root: Optional[TreeNode]) -> int: if root is None: return 0 if root.left is None and root.right is None: return root.val return sum_of_leaves(root.left) + sum_of_leaves(root.right)"},{"question":"# Question Statement Delete Middle Node of a Linked List In this exercise, you are required to implement a function that removes the middle node from a singly linked list in **one pass**. If the list has an even number of nodes, remove the second of the middle two nodes. You should modify the list in place and ensure there are no memory leaks. # Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def delete_middle(head: ListNode) -> ListNode: pass ``` # Input - The head of a singly linked list `head`, where each node is represented by an instance of `ListNode`. # Output - The head of the singly linked list after removing the middle node. # Constraints - The linked list will have at least one node. - Node values are within the acceptable range for integers. - The structure of the linked list must be maintained. # Example Input: ``` 1 -> 2 -> 3 -> 4 -> 5 ``` Output: ``` 1 -> 2 -> 4 -> 5 ``` Input: ``` 1 -> 2 -> 3 -> 4 ``` Output: ``` 1 -> 2 -> 4 ``` # Explanation To solve this problem, you should: 1. Use two pointers (`slow` and `fast`) to traverse the list. 2. Move `slow` one step at a time while moving `fast` two steps at a time. 3. When `fast` reaches the end, `slow` will be at the middle node (or the first of the middle two nodes in an even-length list). 4. Remove the middle node by adjusting the `next` pointers appropriately. # Testing Ensure your function handles cases where the linked list contains: - Only one node (in which case, the result should be an empty list). - An even number of nodes. - An odd number of nodes. Test it with varying lengths to confirm it works within the defined constraints.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def delete_middle(head: ListNode) -> ListNode: if not head or not head.next: return None slow = head fast = head prev = None while fast and fast.next: fast = fast.next.next prev = slow slow = slow.next if prev: prev.next = slow.next return head"},{"question":"# Binary Tree Depth Calculation Objective Create a function to compute the maximum depth of a binary tree. This will test your proficiency with tree data structures and recursive algorithms. Function Signature ```python def max_depth(root: TreeNode) -> int: pass ``` Inputs - `root` (TreeNode): The root node of a binary tree. The `TreeNode` structure is defined as follows: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` Outputs - An integer representing the maximum depth of the binary tree. Constraints - The number of nodes in the tree is between 0 and 10^4. - Each node\'s value is an integer. Example ```python # Constructing the following binary tree: # 3 # / # 9 20 # / # 15 7 tree = TreeNode(3) tree.left = TreeNode(9) tree.right = TreeNode(20, TreeNode(15), TreeNode(7)) print(max_depth(tree)) # Output: 3 # Empty tree print(max_depth(None)) # Output: 0 ``` Scenario You are developing a functionality for a content management system where the depth of a nested comment thread needs to be calculated. Each comment can have multiple nested replies, and you need to determine the longest chain of replies. Implement the `max_depth` function to assist with this requirement.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_depth(root: TreeNode) -> int: if root is None: return 0 else: left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"Finding the Longest Increasing Subsequence **Scenario**: You are developing an algorithm for a financial software company, and one of the tasks involves analyzing historical stock prices. For this purpose, you need to find the longest increasing subsequence from a list of stock prices, which can help in identifying trends for investment strategies. **Task**: Implement the function `longest_increasing_subsequence(nums)` that finds the length of the longest increasing subsequence in a given list of integers representing stock prices. **Function Signature**: ```python def longest_increasing_subsequence(nums: List[int]) -> int: ``` **Input**: * `nums`: A list of integers, where each integer represents a stock price on a particular day. **Output**: * An integer representing the length of the longest increasing subsequence. **Constraints**: * `1 <= len(nums) <= 10^4` * `-10^5 <= nums[i] <= 10^5` for every index `i` in `nums` **Example**: ```python print(longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18])) # Expected output: 4 (subsequence: [2, 3, 7, 18]) print(longest_increasing_subsequence([0, 1, 0, 3, 2, 3])) # Expected output: 4 (subsequence: [0, 1, 2, 3]) print(longest_increasing_subsequence([7, 7, 7, 7, 7, 7])) # Expected output: 1 (subsequence: [7]) ``` **Note**: The elements in the subsequence must be strictly increasing, and you may assume that there will always be at least one increasing subsequence in the list.","solution":"from typing import List def longest_increasing_subsequence(nums: List[int]) -> int: Function to find the length of the longest increasing subsequence in a given list of integers. if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"# Problem Statement You need to implement a function `max_consecutive_repeats` that processes a list of strings and returns the maximum number of times a single character consecutively repeats in each string. If a string is empty, it should return 0 for that string. # Requirements Function Signature ```python def max_consecutive_repeats(strings: list) -> list: ``` Input * `strings`: A list of strings. Output * A list of integers, where each integer is the maximum number of times a single character consecutively repeats in the corresponding string from the input. Constraints * Strings can contain any printable ASCII characters. * Each string in the list may be empty or very large. # Examples ```python >>> max_consecutive_repeats([\\"aaabbcc\\", \\"aabbcc\\", \\"abc\\", \\"\\"]) [3, 2, 1, 0] >>> max_consecutive_repeats([\\"aaaa\\", \\"bbbb\\", \\"cccc\\", \\"dddd\\"]) [4, 4, 4, 4] >>> max_consecutive_repeats([\\"a\\", \\"b\\", \\"cc\\", \\"ddd\\"]) [1, 1, 2, 3] ``` # Caveats * Ensure your function handles edge cases such as empty strings or strings with no repeats efficiently. * The function should be able to process large lists of strings quickly.","solution":"def max_consecutive_repeats(strings): Returns a list of integers representing the maximum number of times a single character consecutively repeats in each string from the input list. def helper(s): if not s: return 0 max_count, current_count = 1, 1 for i in range(1, len(s)): if s[i] == s[i-1]: current_count += 1 max_count = max(max_count, current_count) else: current_count = 1 return max_count return [helper(s) for s in strings]"},{"question":"# Problem Statement You are required to implement a flight itinerary planner that constructs the optimal route of flights based on a given list of tickets. Each ticket is represented as a tuple (origin, destination). Your solution should determine the itinerary in lexicographical order if multiple solutions are possible. # Objectives 1. **Function `find_itinerary(tickets: List[Tuple[str, str]]) -> List[str]`:** - **Input**: - A `tickets`: a list of tuples where each tuple contains two strings, representing the origin and destination of a flight. - **Output**: A list of strings representing the flight itinerary in the correct order. - **Constraints**: The itinerary must use all the tickets exactly once and start from \\"JFK\\". - **Requirements**: - If multiple valid itineraries exist, return the lexicographically smallest one. - **Performance**: Solutions should efficiently handle a reasonably large number of tickets. # Examples ```python # Example 1 tickets = [(\\"MUC\\", \\"LHR\\"), (\\"JFK\\", \\"MUC\\"), (\\"SFO\\", \\"SJC\\"), (\\"LHR\\", \\"SFO\\")] assert find_itinerary(tickets) == [\\"JFK\\", \\"MUC\\", \\"LHR\\", \\"SFO\\", \\"SJC\\"] # Example 2 tickets = [(\\"JFK\\", \\"KUL\\"), (\\"JFK\\", \\"NRT\\"), (\\"NRT\\", \\"JFK\\")] assert find_itinerary(tickets) == [\\"JFK\\", \\"NRT\\", \\"JFK\\", \\"KUL\\"] # Example 3 tickets = [(\\"JFK\\", \\"SFO\\"), (\\"JFK\\", \\"ATL\\"), (\\"SFO\\", \\"ATL\\"), (\\"ATL\\", \\"JFK\\"), (\\"ATL\\", \\"SFO\\")] assert find_itinerary(tickets) == [\\"JFK\\", \\"ATL\\", \\"JFK\\", \\"SFO\\", \\"ATL\\", \\"SFO\\"] ``` # Note - The given `tickets` list will always contain at least one ticket starting from \\"JFK\\". - The itinerary will always include exactly one solution for the given tickets, but it can have multiple valid orderings, in which case the lexicographically smallest one should be returned. - You are expected to write and test your solutions to ensure all scenarios and edge cases are properly handled.","solution":"def find_itinerary(tickets): Given a list of tuple tickets, return the itinerary starting from JFK in lexicographical order. from collections import defaultdict import heapq # Create a graph flights = defaultdict(list) for origin, destination in tickets: heapq.heappush(flights[origin], destination) # Resulting itinerary itinerary = [] def visit(airport): while flights[airport]: # Get the destination with the smallest lexicographical order next_destination = heapq.heappop(flights[airport]) visit(next_destination) itinerary.append(airport) visit(\'JFK\') return itinerary[::-1] # Reverse to get from start to end"},{"question":"# Scenario: You are building a part of a simple e-commerce application where you need to frequently look up products by their unique IDs and return the product details. Given that the system should be efficient with fast lookup times, you decide to use a binary search tree (BST) for managing the product data. # Task: Implement a binary search tree that supports insertion of product details, searching for a product by its ID, and retrieving the in-order traversal of all products in the tree. # Requirements: 1. **Initialization**: Create an empty binary search tree. 2. **Methods**: * `insert(product_id, product_details)`: Insert a product with the given ID and details into the BST. * `search(product_id)`: Find and return the product details by its ID. If not found, return `None`. * `in_order_traversal()`: Return a list of product details in ascending order of product IDs. 3. **Constraints**: * Assume `product_id` is a positive integer. * `product_details` is a string containing information about the product. * Product IDs are unique, so no need to handle duplicate IDs. * The tree must remain balanced through the use of AVL Tree properties. # Input Format: - For `insert` method: * `product_id`: Integer product ID. * `product_details`: Associated product details (string). - For `search` method: * `product_id`: Integer product ID to search for. - For `in_order_traversal` method: * No input parameters. # Output Format: - `search`: The product details if found, otherwise `None`. - `insert`: No return value. - `in_order_traversal`: A list of product details in ascending order based on product IDs. # Example: ```python # Initializing the binary search tree product_tree = ProductBST() # Inserting products product_tree.insert(10, \'Product A\') product_tree.insert(5, \'Product B\') product_tree.insert(15, \'Product C\') product_tree.insert(2, \'Product D\') product_tree.insert(7, \'Product E\') # Searching for products print(product_tree.search(10)) # Expected output: \'Product A\' print(product_tree.search(3)) # Expected output: None # Getting in-order traversal of the tree print(product_tree.in_order_traversal()) # Expected output: [\'Product D\', \'Product B\', \'Product E\', \'Product A\', \'Product C\'] ``` Implement the `ProductBST` class in Python with the above specifications.","solution":"class Node: def __init__(self, product_id, product_details): self.product_id = product_id self.product_details = product_details self.height = 1 self.left = None self.right = None class ProductBST: def __init__(self): self.root = None def insert(self, product_id, product_details): def _insert(node, product_id, product_details): if not node: return Node(product_id, product_details) elif product_id < node.product_id: node.left = _insert(node.left, product_id, product_details) else: node.right = _insert(node.right, product_id, product_details) node.height = 1 + max(self.get_height(node.left), self.get_height(node.right)) balance = self.get_balance(node) if balance > 1: # Left heavy if product_id < node.left.product_id: # Left Left return self.rotate_right(node) else: # Left Right node.left = self.rotate_left(node.left) return self.rotate_right(node) if balance < -1: # Right heavy if product_id > node.right.product_id: # Right Right return self.rotate_left(node) else: # Right Left node.right = self.rotate_right(node.right) return self.rotate_left(node) return node self.root = _insert(self.root, product_id, product_details) def search(self, product_id): def _search(node, product_id): if not node or node.product_id == product_id: return node elif product_id < node.product_id: return _search(node.left, product_id) else: return _search(node.right, product_id) node = _search(self.root, product_id) return node.product_details if node else None def in_order_traversal(self): def _in_order(node): return _in_order(node.left) + [node.product_details] + _in_order(node.right) if node else [] return _in_order(self.root) def get_height(self, node): return node.height if node else 0 def get_balance(self, node): return self.get_height(node.left) - self.get_height(node.right) if node else 0 def rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def rotate_right(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y"},{"question":"# Parallel Array Traversal **Scenario**: Imagine you are given two parallel arrays of equal length containing numerical data. Your task is to write a function that traverses these arrays simultaneously and calculates the sum of products of their corresponding elements. Additionally, you need to handle the edge cases where the arrays are empty. Function: `sum_of_products` - **Input**: - `array1`: A list of integers. - `array2`: A list of integers of the same length as `array1`. - **Output**: - An integer representing the sum of the products of corresponding elements in `array1` and `array2`. - **Function Signature**: ```python def sum_of_products(array1: list[int], array2: list[int]) -> int: ``` Constraints - `0 <= len(array1) == len(array2) <= 10^5` - `-10^9 <= array1[i], array2[i] <= 10^9` Example ```python # Input array1 = [1, 2, 3] array2 = [4, 5, 6] # Function Execution result = sum_of_products(array1, array2) # Expected Output print(result) # 32 ``` # Explanation In the provided example: - Products: 1*4 = 4, 2*5 = 10, 3*6 = 18 - Sum of Products: 4 + 10 + 18 = 32 Your implementation will be tested with various inputs to ensure accuracy and performance. Handle edge cases where the arrays are of length zero and ensure efficient traversal and computation for large input sizes.","solution":"def sum_of_products(array1: list[int], array2: list[int]) -> int: Returns the sum of the products of corresponding elements in array1 and array2. return sum(a * b for a, b in zip(array1, array2))"},{"question":"# Coding Question **Generate Fibonacci Sequence** Fibonacci sequence is a series of numbers in which each number ( Fibonacci number ) is the sum of the two preceding numbers. The simplest is the series 0, 1, 1, 2, 3, 5, 8, etc. In this exercise, you will implement a function that generates the Fibonacci sequence up to a given limit. **Function Signature**: ```python def generate_fibonacci(limit: int) -> List[int]: Generate a list of Fibonacci numbers up to `limit` (inclusive). Parameters: - limit (int): The maximum value for the last number in the Fibonacci sequence. Returns: - List[int]: A list of Fibonacci numbers up to `limit`. Example: >>> generate_fibonacci(21) [0, 1, 1, 2, 3, 5, 8, 13, 21] ``` # Constraints * `1 <= limit <= 10**6` * The function should be capable of generating the sequence up to `limit` effectively. # Input and Output * **Input**: An integer `limit`. * **Output**: A list of integers representing the Fibonacci sequence up to the given limit. # Evaluation Criteria * Correctness: The function must return all Fibonacci numbers in sequence up to the specified limit. * Efficiency: The solution should handle large limits efficiently. * Readability: The code should be well-structured and easy to read.","solution":"from typing import List def generate_fibonacci(limit: int) -> List[int]: Generate a list of Fibonacci numbers up to `limit` (inclusive). Parameters: - limit (int): The maximum value for the last number in the Fibonacci sequence. Returns: - List[int]: A list of Fibonacci numbers up to `limit`. if limit < 0: return [] fibonacci_sequence = [] a, b = 0, 1 while a <= limit: fibonacci_sequence.append(a) a, b = b, a + b return fibonacci_sequence"},{"question":"# Sorted Squares of a Sorted Array Given an array of integers `nums` sorted in non-decreasing order, return an array of the squares of each number, also sorted in non-decreasing order. Input and Output Format: - **Input**: - `nums` (List[int]): A list of integers sorted in non-decreasing order. - **Output**: - A list of the squares of each number from `nums`, sorted in non-decreasing order. Constraints: - The `nums` array can contain both negative and positive integers. - The `nums` array is guaranteed to have at least one element and at most 10^4 elements. - The integers in `nums` range between -10^4 and 10^4. Function Signature: ```python def sorted_squares(nums: List[int]) -> List[int]: pass ``` Example: ```python assert sorted_squares([-4, -1, 0, 3, 10]) == [0, 1, 9, 16, 100] assert sorted_squares([-7, -3, 2, 3, 11]) == [4, 9, 9, 49, 121] ``` Requirements: 1. You cannot use any external libraries. 2. The solution should be efficient with a time complexity of O(n). Good luck! Utilize your understanding of arrays and sorting algorithms to solve this problem.","solution":"from typing import List def sorted_squares(nums: List[int]) -> List[int]: Returns an array of the squares of each number from nums, sorted in non-decreasing order. n = len(nums) result = [0] * n left, right = 0, n - 1 pos = n - 1 while left <= right: left_square = nums[left]**2 right_square = nums[right]**2 if left_square > right_square: result[pos] = left_square left += 1 else: result[pos] = right_square right -= 1 pos -= 1 return result"},{"question":"Coding Question: Triplet Sum Close to Target # Context: Finding triplets in an array that sum up to a specific value is a common problem in computer science, often leading to interesting variations and related challenges. # Problem Statement: Implement a function `closest_triplet_sum(arr: List[int], target: int) -> int` that returns the sum of the triplet in the given array `arr` which is closest to the given `target`. Input: - `arr`: A list of integers (may contain positive and negative numbers). - `target`: An integer representing the target sum. Output: - Returns an integer which is the sum of the triplet closest to the target. # Constraints: - The input list will contain at least 3 elements and at most 1000 elements. - The elements of the list are in the range of -10000 to 10000. # Examples: Example 1: ```python arr = [-1, 2, 1, -4] target = 1 # The sum that is closest to 1 is 2. (-1 + 2 + 1 = 2) assert closest_triplet_sum(arr, target) == 2 ``` Example 2: ```python arr = [1, 1, -1, -1, 3] target = 3 # The sum that is closest to 3 is 3. (1 + 1 + 1 = 3) assert closest_triplet_sum(arr, target) == 3 ``` Example 3: ```python arr = [4, -1, 2, 1] target = 0 # The sum that is closest to 0 is 2. (-1 + 1 + 2 = 2) assert closest_triplet_sum(arr, target) == 2 ``` # Notes: 1. The answer should be exactly the sum of the triplet, not the difference between the target and sum. 2. Optimize for larger inputs where a brute force checking of all possible triplets is infeasible.","solution":"from typing import List def closest_triplet_sum(arr: List[int], target: int) -> int: arr.sort() # First, sort the array closest_sum = float(\'inf\') # Initialize the closest sum with infinity for i in range(len(arr) - 2): # Iterate through the array left, right = i + 1, len(arr) - 1 while left < right: curr_sum = arr[i] + arr[left] + arr[right] if abs(target - curr_sum) < abs(target - closest_sum): closest_sum = curr_sum if curr_sum < target: left += 1 elif curr_sum > target: right -= 1 else: # when curr_sum == target return curr_sum return closest_sum"},{"question":"# Question Context You have been provided with a list of transactions from multiple bank accounts. Each transaction consists of an account identifier, a transaction type (deposit or withdrawal), and an amount. Your task is to generate a summary for each account to understand the final balance after executing all transactions. Task Write a Python function that calculates the final balance for each account after processing all transactions. The function should return a dictionary where the keys are the account identifiers and the values are the final balances. Function Signature ```python def calculate_final_balances(transactions: List[Tuple[str, str, int]]) -> Dict[str, int]: pass ``` Input * `transactions` (List[Tuple[str, str, int]]): A list of tuples representing the transactions, where: * The first element is a string representing the account identifier. * The second element is a string representing the transaction type (\\"deposit\\" or \\"withdrawal\\"). * The third element is an integer representing the transaction amount. Output * Returns a dictionary where each key is an account identifier, and the corresponding value is the final balance. Constraints and Requirements * The function should handle multiple transactions for the same account. * The function should handle both deposits and withdrawals correctly, adjusting the balance accordingly. * Transactions are assumed to be valid, i.e., the withdrawal amounts do not exceed the balance at any point. * The list of transactions can be large, so the function should be efficient in processing them. Example ```python assert calculate_final_balances([ (\\"acc1\\", \\"deposit\\", 500), (\\"acc2\\", \\"deposit\\", 300), (\\"acc1\\", \\"withdrawal\\", 200), (\\"acc3\\", \\"deposit\\", 700), (\\"acc2\\", \\"withdrawal\\", 100), (\\"acc3\\", \\"withdrawal\\", 200) ]) == {\\"acc1\\": 300, \\"acc2\\": 200, \\"acc3\\": 500} ```","solution":"from typing import List, Tuple, Dict def calculate_final_balances(transactions: List[Tuple[str, str, int]]) -> Dict[str, int]: balances = {} for account_id, transaction_type, amount in transactions: if account_id not in balances: balances[account_id] = 0 if transaction_type == \\"deposit\\": balances[account_id] += amount elif transaction_type == \\"withdrawal\\": balances[account_id] -= amount return balances"},{"question":"Find Duplicates in a List Finding duplicates in a list is a common task that can help with identifying redundant data or optimizing storage. # Problem Statement You are required to implement a function to find all the duplicate elements in an input list and return them in a list. The duplicates in the result list should appear in the order of their first occurrence in the original list. # Input * A list `arr` of `n` integers. # Output * Return a list containing the duplicate values. If no duplicates are found, return an empty list. # Constraints * The elements of the list are integers and can be both positive and negative. * The list `arr` can be of size `0 <= len(arr) <= 10^6`. # Example: ```python >>> find_duplicates([4, 5, 6, 7, 6, 4, 3, 5]) [4, 5, 6] >>> find_duplicates([1, 2, 3, 4]) [] >>> find_duplicates([1, 2, 2, 3, 3, 3]) [2, 3] >>> find_duplicates([]) [] ``` # Task Implement the `find_duplicates` function as described.","solution":"def find_duplicates(arr): Returns a list of duplicate elements in the order of their first occurrence. seen = set() duplicates = set() for item in arr: if item in seen: duplicates.add(item) else: seen.add(item) return list(duplicates)"},{"question":"**Context**: You are a software engineer working on a system that uses graph algorithms for efficient route planning in a city. Your job is to implement a function to find the shortest path between two points in the city represented as nodes in a graph, using Dijkstra\'s algorithm. **Task**: You need to write the function `shortest_path(graph, start_node, end_node)` which finds the shortest path from `start_node` to `end_node` using Dijkstra\'s algorithm. **Input**: - `graph` (dict): A dictionary representing the weighted graph where the keys are node identifiers and the values are dictionaries with neighbor nodes as keys and edge weights as values. - `start_node` (str): The identifier of the starting node. - `end_node` (str): The identifier of the ending node. **Output**: - The function should return a tuple containing the length of the shortest path and a list of nodes representing the shortest path from `start_node` to `end_node`. **Constraints**: - The graph is connected and all edge weights are positive. - `start_node` and `end_node` are valid nodes in the graph. - There exists at least one path between `start_node` and `end_node`. **Example**: ```python def shortest_path(graph: dict, start_node: str, end_node: str) -> tuple[int, list[str]]: # Implementation here # Example usage: graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'A\': 1, \'C\': 2, \'D\': 5}, \'C\': {\'A\': 4, \'B\': 2, \'D\': 1}, \'D\': {\'B\': 5, \'C\': 1} } start_node = \'A\' end_node = \'D\' path_length, path = shortest_path(graph, start_node, end_node) print(\\"Shortest path length:\\", path_length) print(\\"Path:\\", path) # Output should be: # Shortest path length: 4 # Path: [\'A\', \'B\', \'C\', \'D\'] ```","solution":"import heapq def shortest_path(graph, start_node, end_node): def dijkstra(graph, start_node): queue = [(0, start_node)] distances = {node: float(\'inf\') for node in graph} distances[start_node] = 0 previous_nodes = {node: None for node in graph} while queue: current_distance, current_node = heapq.heappop(queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(queue, (distance, neighbor)) return distances, previous_nodes distances, previous_nodes = dijkstra(graph, start_node) path = [] current_node = end_node while current_node is not None: path.append(current_node) current_node = previous_nodes[current_node] path = path[::-1] return distances[end_node], path"},{"question":"# Problem Statement Implement an `order_count_summary` function that generates a summary of order counts grouped by product category from a list of orders, using class-based aggregation. Requirements 1. **Function Signature**: ```python def order_count_summary(orders: list[dict]) -> list[tuple[str, int]]: ``` 2. **Parameters**: - `orders` (list of dict): A list of orders, where each order is represented as a dictionary with keys `\\"id\\"`, `\\"product\\"`, and `\\"category\\"`. - Example: ```python [ {\\"id\\": 1, \\"product\\": \\"Laptop\\", \\"category\\": \\"Electronics\\"}, {\\"id\\": 2, \\"product\\": \\"Headphones\\", \\"category\\": \\"Electronics\\"}, {\\"id\\": 3, \\"product\\": \\"Sofa\\", \\"category\\": \\"Furniture\\"} ] ``` 3. **Output**: - A list of tuples containing each product category and the count of orders in that category, sorted by category name in ascending order. The format should be: ```python [(\\"category_name1\\", count1), (\\"category_name2\\", count2)...] ``` 4. **Constraints and Assumptions**: - Each order is a unique non-empty dictionary with valid keys. - Categories and product names are case-sensitive. - The function should correctly handle cases where there are no orders or categories have zero counts. 5. **Example**: ```python orders = [ {\\"id\\": 1, \\"product\\": \\"Laptop\\", \\"category\\": \\"Electronics\\"}, {\\"id\\": 2, \\"product\\": \\"Headphones\\", \\"category\\": \\"Electronics\\"}, {\\"id\\": 3, \\"product\\": \\"Sofa\\", \\"category\\": \\"Furniture\\"}, {\\"id\\": 4, \\"product\\": \\"Chair\\", \\"category\\": \\"Furniture\\"}, {\\"id\\": 5, \\"product\\": \\"Table\\", \\"category\\": \\"Furniture\\"} ] order_count_summary(orders) >>> [(\\"Electronics\\", 2), (\\"Furniture\\", 3)] ``` 6. **Implementation Steps**: 1. Define a class `OrderSummary` with methods to update counts and generate the summary. 2. Iterate over the orders to populate the count data. 3. Sort the resulting category count data by category name in ascending order. 4. Handle any edge cases, such as empty input lists. Performance Considerations: - The function should efficiently handle a reasonably large number of orders. - Ensure correct and optimal data handling for aggregation and sorting.","solution":"def order_count_summary(orders): Function to generate a summary of order counts grouped by product category. Parameters: orders (list of dict): List of orders, where each order is represented as a dictionary with keys \'id\', \'product\', and \'category\'. Returns: list of tuples: A list of tuples containing each product category and the count of orders in that category, sorted by category name in ascending order. from collections import defaultdict # Initialize a default dictionary to store category counts category_counts = defaultdict(int) # Loop through each order to update the category count for order in orders: category = order[\'category\'] category_counts[category] += 1 # Convert the dictionary to a sorted list of tuples sorted_category_counts = sorted(category_counts.items()) return sorted_category_counts"},{"question":"# Generate all Possible Sentences from Words Problem Statement Given a list of lists, where each sublist contains words, generate all possible sentences by selecting one word from each sublist. # Constraints 1. The lists may contain any number of words, including zero. 2. Words consist of lowercase alphabets and have length between 1 and 10. 3. The number of sublists will not exceed 10. 4. Your function should return an empty list if any sublist is empty. # Input Format * A list of lists `word_lists`. # Output Format * A list of strings, where each string represents a sentence generated by selecting one word from each sublist. # Function Signature ```python def generate_sentences(word_lists: list[list[str]]) -> list[str]: pass ``` # Example Input ```python word_lists = [ [\\"the\\", \\"a\\"], [\\"quick\\", \\"slow\\"], [\\"brown\\", \\"lazy\\"], [\\"fox\\", \\"dog\\"] ] ``` Output ```python [ \\"the quick brown fox\\", \\"the quick brown dog\\", \\"the quick lazy fox\\", \\"the quick lazy dog\\", \\"the slow brown fox\\", \\"the slow brown dog\\", \\"the slow lazy fox\\", \\"the slow lazy dog\\", \\"a quick brown fox\\", \\"a quick brown dog\\", \\"a quick lazy fox\\", \\"a quick lazy dog\\", \\"a slow brown fox\\", \\"a slow brown dog\\", \\"a slow lazy fox\\", \\"a slow lazy dog\\" ] ``` # Notes * Consider using recursion or backtracking to explore all combinations. * Ensure your function efficiently handles lists up to 10 sublists, each containing up to 10 words.","solution":"from itertools import product def generate_sentences(word_lists: list[list[str]]) -> list[str]: Generate all possible sentences by picking one word from each sublist. :param word_lists: List of lists, where each sublist contains words. :return: List of strings, where each string represents a sentence. # If any sublist is empty, no sentence can be formed if any(len(sublist) == 0 for sublist in word_lists): return [] # Use itertools.product to generate combinations possible_sentences = [\' \'.join(words) for words in product(*word_lists)] return possible_sentences"},{"question":"# Context A tech company is building an application to analyze user activities. One aspect of this task involves determining the longest streak of continuous days a user has been active. Given a list of days a user has been active, you need to calculate the longest streak of consecutive days. # Problem Statement Write a function `longest_activity_streak(days: List[int]) -> int` that takes a list of integers representing the days a user was active and returns the length of the longest streak of consecutive active days. # Function Signature ```python def longest_activity_streak(days: List[int]) -> int: pass ``` # Input 1. `days` - a list of integers, where each integer represents a day number on which the user was active. # Output * An integer, the length of the longest streak of consecutive active days. # Examples 1. `longest_activity_streak([1, 2, 3, 5, 6, 8, 9, 10])` should return `3` (streaks: [1, 2, 3] and [8, 9, 10]; longest is 3). 2. `longest_activity_streak([7, 1, 2, 3, 7, 8, 9])` should return `4` (streak: [7, 8, 9, 10]). 3. `longest_activity_streak([5, 9, 1, 11, 12, 13])` should return `3` (streak: [11, 12, 13]). 4. `longest_activity_streak([4, 2, 0, 5, 6, 7, 1])` should return `4` (streak: [4, 5, 6, 7]). # Constraints * `days` list will contain between 1 and 10^5 integers. * Each element in `days` will be a non-negative integer (0 ≤ days[i] ≤ 10^6). # Notes * Days may not be sorted, but the function should correctly handle any order. * Consider edge cases like having all days being the same or completely random and non-consecutive.","solution":"from typing import List def longest_activity_streak(days: List[int]) -> int: if not days: return 0 days_set = set(days) longest_streak = 0 for day in days_set: if day - 1 not in days_set: # only start counting from the beginning of a streak current_day = day current_streak = 1 while current_day + 1 in days_set: current_day += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Context: As part of your job at an e-commerce company, you are tasked with analyzing customer shopping patterns. Your team has decided to implement a system that categorizes a customer\'s shopping cart based on the range of purchase quantities of specific product categories. # Problem Statement: Write a Python function `categorize_cart(cart: dict) -> dict` that takes a shopping cart represented as a dictionary and assigns categories based on the total quantity of each product type in the cart. * Each key in `cart` is a product type (a string) and each corresponding value is an integer representing the quantity purchased. * The function should return a dictionary where the keys are the product types and the values are strings representing the category (\\"few\\", \\"moderate\\", \\"many\\"). The categorization rules are: - Quantity 1 to 3: \\"few\\" - Quantity 4 to 10: \\"moderate\\" - Quantity 11 or more: \\"many\\" # Inputs: - `cart (dict)`: Dictionary where keys are product types (strings) and values are quantities (integers). # Outputs: - A dictionary with product types as the keys and their categories as the values. # Constraints: - `1 <= len(cart) <= 100` - `1 <= quantity <= 10^3` # Example: ```python def categorize_cart(cart: dict) -> dict: pass # An example of the function in use: cart = { \\"apples\\": 2, \\"bananas\\": 5, \\"oranges\\": 12, \\"milk\\": 1, \\"bread\\": 7 } print(categorize_cart(cart)) # Output: {\'apples\': \'few\', \'bananas\': \'moderate\', \'oranges\': \'many\', \'milk\': \'few\', \'bread\': \'moderate\'} ``` # Notes: - Ensure that the input dictionary is not altered. - Handle edge cases such as minimum and maximum values correctly.","solution":"def categorize_cart(cart: dict) -> dict: categories = {} for product, quantity in cart.items(): if 1 <= quantity <= 3: category = \\"few\\" elif 4 <= quantity <= 10: category = \\"moderate\\" else: # quantity >= 11 category = \\"many\\" categories[product] = category return categories"},{"question":"# Coding Assessment: Genetic Algorithm for Function Optimization Problem Statement You are provided with an implementation of a Genetic Algorithm for optimizing a two-dimensional function. Your task is to implement a similar optimization algorithm but for a three-dimensional function. Objectives 1. Implement a `genetic_algorithm_3d` function that optimizes a given function in three dimensions. 2. Your implementation should be configurable to find either the maximum or minimum value of the function based on a flag. 3. Implement a `Chromosome3D` class with appropriate methods to support the optimization process. Input - **Function to Optimize**: A function `f(x, y, z)` that takes three arguments and returns a floating-point value. - **Initial Population**: A list of initial chromosomes with coordinates `(x, y, z)`. - **Bounds**: The minimum and maximum bounds for `x`, `y`, `z`. - **Algorithm Parameters**: Population size, number of generations, mutation rate, crossover rate, and selection method. Output - A chromosome object with the optimized coordinates `(x, y, z)` and the corresponding function value. # Constraints 1. **Chromosome3D Class**: Your `Chromosome3D` class must have the following methods: - `__init__(self, x: float, y: float, z: float)` - `mutate(self, mutation_rate: float, bounds: Tuple[Tuple[float, float], Tuple[float, float], Tuple[float, float]]) -> \'Chromosome3D\'` - `crossover(self, other: \'Chromosome3D\') -> Tuple[\'Chromosome3D\', \'Chromosome3D\']` - `fitness(self, function_to_optimize) -> float` 2. **Genetic Algorithm Function**: Your `genetic_algorithm_3d` function must have the following signature: ```python def genetic_algorithm_3d( population: List[Chromosome3D], function_to_optimize, find_max: bool = True, population_size: int = 100, generations: int = 100, mutation_rate: float = 0.01, crossover_rate: float = 0.7, bounds: Tuple[Tuple[float, float], Tuple[float, float], Tuple[float, float]] = ((-math.inf, math.inf), (-math.inf, math.inf), (-math.inf, math.inf)) ) -> Chromosome3D: ``` 3. **Performance Requirement**: Your implementation should efficiently converge to an optimal or near-optimal solution within a reasonable number of generations for typical inputs. # Example Usage ```python # Define a sample function to optimize def function_to_optimize(x, y, z): return -((x-3)**2 + (y+2)**2 + (z-5)**2) + 50 # Create initial population initial_population = [Chromosome3D(x, y, z) for x, y, z in [(0, 0, 0), (1, 1, 1), (2, -1, -2), (-1, 2, 1)]] # Perform genetic algorithm optimization result = genetic_algorithm_3d( population=initial_population, function_to_optimize=function_to_optimize, find_max=True, population_size=100, generations=50, mutation_rate=0.01, crossover_rate=0.7, bounds=((0, 5), (-5, 5), (-10, 10)) ) print(f\\"Optimal state: (x={result.x}, y={result.y}, z={result.z}), value={result.fitness(function_to_optimize)}\\") ``` Ensure your function is well-tested with various 3D functions to validate its correctness and performance.","solution":"import random import math from typing import Tuple, List class Chromosome3D: def __init__(self, x: float, y: float, z: float): self.x = x self.y = y self.z = z def mutate(self, mutation_rate: float, bounds: Tuple[Tuple[float, float], Tuple[float, float], Tuple[float, float]]) -> \'Chromosome3D\': if random.random() < mutation_rate: self.x = random.uniform(bounds[0][0], bounds[0][1]) if random.random() < mutation_rate: self.y = random.uniform(bounds[1][0], bounds[1][1]) if random.random() < mutation_rate: self.z = random.uniform(bounds[2][0], bounds[2][1]) return self def crossover(self, other: \'Chromosome3D\') -> Tuple[\'Chromosome3D\', \'Chromosome3D\']: child1 = Chromosome3D(self.x, other.y, self.z) child2 = Chromosome3D(other.x, self.y, other.z) return child1, child2 def fitness(self, function_to_optimize) -> float: return function_to_optimize(self.x, self.y, self.z) def genetic_algorithm_3d( population: List[Chromosome3D], function_to_optimize, find_max: bool = True, population_size: int = 100, generations: int = 100, mutation_rate: float = 0.01, crossover_rate: float = 0.7, bounds: Tuple[Tuple[float, float], Tuple[float, float], Tuple[float, float]] = ((-math.inf, math.inf), (-math.inf, math.inf), (-math.inf, math.inf)) ) -> Chromosome3D: current_population = population def select_parent(optimized_population): return random.choice(optimized_population) for _ in range(generations): # Evaluate fitness of each chromosome fitness_values = [(chromosome.fitness(function_to_optimize), chromosome) for chromosome in current_population] fitness_values.sort(key=lambda x: x[0], reverse=find_max) # Select the best half selected_parents = [chrom[1] for chrom in fitness_values[:population_size // 2]] # Generate new population through crossover new_population = [] while len(new_population) < population_size: parent1 = select_parent(selected_parents) if random.random() < crossover_rate: parent2 = select_parent(selected_parents) offspring1, offspring2 = parent1.crossover(parent2) new_population.append(offspring1) new_population.append(offspring2) else: new_population.append(parent1.mutate(mutation_rate, bounds)) # Ensure new population has the same size as defined if len(new_population) > population_size: new_population = new_population[:population_size] current_population = new_population best_chromosome = max(current_population, key=lambda chrom: chrom.fitness(function_to_optimize)) if find_max else min(current_population, key=lambda chrom: chrom.fitness(function_to_optimize)) return best_chromosome"},{"question":"# Text Generation with GPT-3 You are developing a text generation application using OpenAI\'s GPT-3 model. Your task is to create a function that interfaces with the OpenAI API and generates text based on an input prompt. The function should manage the connection to the API, send the prompt, and return the generated text, formatted to meet certain output constraints. Task Description: Implement a function `generate_text_with_gpt3` that: - Takes as input: * `prompt` (str): The input text prompt to seed the generation. * `max_tokens` (int): The maximum number of tokens to generate (default is 100). * `temperature` (float): The sampling temperature (default is 0.7). * `api_key` (str): The API key for accessing the OpenAI API. - Returns: * A string containing the generated text. Constraints: - `prompt` will be a string with a length not exceeding 256 characters. - `max_tokens` will always be a positive integer between 1 and 500. - `temperature` will always be a floating-point number between 0.0 and 1.0. - `api_key` will always be a valid non-empty string. Notes: - Use the `openai` Python library to interact with the API. - Ensure that the function handles potential exceptions such as network errors or invalid API responses gracefully. - The returned text should be trimmed to remove any leading or trailing whitespace. - Optimize to minimize API usage costs by ensuring the function only generates the necessary number of tokens. Example Usage: ```python >>> prompt = \\"Once upon a time\\" >>> max_tokens = 50 >>> temperature = 0.5 >>> api_key = \\"your_openai_api_key_here\\" >>> result = generate_text_with_gpt3(prompt, max_tokens, temperature, api_key) >>> print(result) \\"Once upon a time, in a small village nestled between rolling hills and dense forests, there lived a young girl named Lily who had a secret...\\" ```","solution":"import openai def generate_text_with_gpt3(prompt, max_tokens=100, temperature=0.7, api_key=\'\'): Generates text based on the input prompt using OpenAI\'s GPT-3 model. Args: - prompt (str): The input text prompt to seed the text generation. - max_tokens (int): The maximum number of tokens to generate. - temperature (float): The sampling temperature. - api_key (str): The API key for accessing the OpenAI API. Returns: - str: The generated text. try: openai.api_key = api_key response = openai.Completion.create( engine=\\"davinci\\", prompt=prompt, max_tokens=max_tokens, temperature=temperature ) generated_text = response.choices[0].text.strip() return generated_text except Exception as e: # Handle potential exceptions such as network errors or invalid API responses gracefully. return str(e)"},{"question":"# Code Analyzer You are creating a simple code-analysis tool that needs to assess Python code files for comment density. Comment density is calculated as the ratio of comment lines to total lines of code. Your task is to implement the `CodeAnalyzer` class, which needs to support the following: 1. Create a `CodeAnalyzer` object that takes a string input representing the code file content. 2. Implement a method `comment_density` that returns the ratio of the comment lines to the total lines of code. 3. Implement a method `analyze_comments` that returns a list of all comment lines in the code. # Requirements: 1. **Input and Output Formats**: * Input is a multi-line string where each line represents a line of code or a comment. * Lines starting with `#` (after stripping leading whitespace) are considered comments. * `comment_density` returns a float representing the density ratio. * `analyze_comments` returns a list of strings, each one representing a comment line. 2. **Constraints**: * Input string consists of a valid set of Python source code lines. * The string can have multiple types of lines, including blank lines, code lines, and comment lines. 3. **Performance**: * Efficient execution with linear time complexity relative to the number of lines in the input string. # Example ```python code = # This is a comment def foo(): x = 42 # Inline comment y = x * 2 # This is another comment return y # Final comment analyzer = CodeAnalyzer(code) print(analyzer.comment_density()) # Output: 0.5 (3 comment lines / 6 total lines) print(analyzer.analyze_comments()) # Output: [\'# This is a comment\', \'# This is another comment\', \'# Final comment\'] ``` # Function Signature ```python class CodeAnalyzer: def __init__(self, code: str) -> None: pass def comment_density(self) -> float: pass def analyze_comments(self) -> list: pass ```","solution":"class CodeAnalyzer: def __init__(self, code: str) -> None: self.lines = code.split(\'n\') def comment_density(self) -> float: total_lines = len(self.lines) comment_lines = len([line for line in self.lines if line.strip().startswith(\'#\')]) if total_lines == 0: return 0.0 return comment_lines / total_lines def analyze_comments(self) -> list: return [line.strip() for line in self.lines if line.strip().startswith(\'#\')]"},{"question":"# Coding Assessment Question Problem Statement Write a function `find_min_rotated_sorted_array(arr: List[int]) -> int` that takes a list of integers `arr` representing a rotated sorted array and returns the minimum element in the array. A rotated sorted array is an array that has been initially sorted in ascending order, but then rotated (shifted) at an unknown pivot point. Requirements 1. The function should make use of a binary search algorithm to achieve an efficient solution. 2. The function should handle situations where the array may contain duplicate elements. 3. The function should handle edge cases where the input array is empty by returning `None`. Input * A list of integers `arr` (which may contain duplicates). Output * Return the smallest integer in the rotated sorted array. If the array is empty, return `None`. Constraints * Time Complexity: O(log n) in average and O(n) in the worst case due to potential duplicates. * Space Complexity: O(1) Example ```python >>> find_min_rotated_sorted_array([3, 4, 5, 1, 2]) 1 >>> find_min_rotated_sorted_array([2, 2, 2, 0, 1]) 0 >>> find_min_rotated_sorted_array([1]) 1 >>> find_min_rotated_sorted_array([]) None >>> find_min_rotated_sorted_array([1, 1, 1, 1, 1]) 1 ``` Additional Notes * Use the binary search algorithm for an efficient solution. * Account for the presence of duplicates which might affect the efficiency of the binary search. * Handle edge cases such as an empty array by returning `None`.","solution":"from typing import List def find_min_rotated_sorted_array(arr: List[int]) -> int: if not arr: return None left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] < arr[right]: right = mid elif arr[mid] > arr[right]: left = mid + 1 else: # arr[mid] == arr[right] so we can\'t decide which half to discard right -= 1 # reduce the search space by one return arr[left]"},{"question":"# Coding Assessment Question: String-Formatted Substring Sum **Background**: In certain text-processing tasks, integrating numerical computations with string manipulations is crucial. One common requirement is to identify substrings, convert them to numbers, and perform calculations on the extracted numbers. **Objective**: Implement a function `substring_sum` that calculates the sum of all numeric substrings found in a given string. Each contiguous sequence of digits within the string should be treated as a distinct number. **Function Signature**: ```python def substring_sum(s: str) -> int: pass ``` **Inputs and Outputs**: * **Input**: A single string `s` containing alphanumeric characters and possibly special symbols. * **Output**: An integer representing the sum of all numeric substrings. **Constraints**: * The string can be up to (10^5) characters long. * Numbers are contiguous sequences of digits without leading zeros, unless the number is exactly `0`. **Example**: 1. **Input**: `\\"ab123cd45ef6\\"` **Output**: `174` (since `123 + 45 + 6 = 174`) 2. **Input**: `\\"9apple33banana7\\"` **Output**: `49` (since `9 + 33 + 7 = 49`) 3. **Input**: `\\"no2digits4here\\"` **Output**: `6` (since `2 + 4 = 6`) 4. **Input**: `\\"nothing\\"` **Output**: `0` (since there are no numeric substrings) **Hint**: Use pattern matching or string traversal to identify numeric substrings, then sum them up efficiently. **Edge Cases to Consider**: * Empty string `\\"\\"` * Strings with no numeric substrings, e.g., `\\"abcdef\\"` * Strings with large numeric substrings close to the maximum integer size. **Starter Template**: ```python def substring_sum(s: str) -> int: def is_digit(c): return \'0\' <= c <= \'9\' total_sum = 0 num_str = \'\' for char in s: if is_digit(char): num_str += char else: if num_str: total_sum += int(num_str) num_str = \'\' if num_str: total_sum += int(num_str) return total_sum ```","solution":"def substring_sum(s: str) -> int: Calculate the sum of all numeric substrings in the given string. def is_digit(c): return \'0\' <= c <= \'9\' total_sum = 0 num_str = \'\' # Iterate over each character in the string for char in s: if is_digit(char): num_str += char else: if num_str: total_sum += int(num_str) num_str = \'\' # If there\'s a number left at the end of the string, add it to the sum if num_str: total_sum += int(num_str) return total_sum"},{"question":"# Manipulation of Linked Lists through Multiple Operations Objective Enhance your understanding of singly linked list operations by implementing various linked list functionalities. Task Extend the given `LinkedList` class by implementing the following functionalities: 1. **Reverse the Linked List**: Implement a method to reverse the linked list. 2. **Detect Cycle**: Implement a method to detect if there is a cycle in the linked list. 3. **Merge Two Sorted Linked Lists**: Implement a static method that merges two sorted linked lists into a single sorted linked list. 4. **Remove N-th Node from End**: Implement a method to remove the N-th node from the end of the linked list. Requirements - Ensure proper checks and raise appropriate exceptions for invalid operations. - Your methods should follow these signatures: ```python def reverse(self) -> None: pass def has_cycle(self) -> bool: pass @staticmethod def merge_sorted_lists(list1: LinkedList, list2: LinkedList) -> LinkedList: pass def remove_nth_from_end(self, n: int) -> None: pass ``` Input and Output Formats - **Reverse** (`reverse`): - **Input**: None - **Output**: The linked list should be modified in-place to be reversed. - **Cycle Detection** (`has_cycle`): - **Input**: None - **Output**: Boolean indicating presence of a cycle. - **Merge Two Sorted Lists** (`merge_sorted_lists`): - **Input**: Two `LinkedList` objects `list1` and `list2` - **Output**: A new `LinkedList` that is the sorted merge of the input lists. - **Remove N-th Node from End** (`remove_nth_from_end`): - **Input**: An integer `n` - **Output**: The linked list should be modified in-place with the N-th node from the end removed. Constraints - The linked lists can have up to 1000 nodes. - Ensure your solutions handle edge cases and are optimized for performance on large inputs. Example ```python # Assuming a Node class for singly linked list is defined as: class Node: def __init__(self, value: int, next: Optional[\'Node\'] = None): self.value = value self.next = next # Sample LinkedList initialization class LinkedList: def __init__(self): self.head = None def append(self, value: int) -> None: if not self.head: self.head = Node(value) else: current = self.head while current.next: current = current.next current.next = Node(value) def display(self) -> None: current = self.head while current: print(current.value, end=\\" -> \\") current = current.next print(\\"None\\") # Example linked list manipulation list1 = LinkedList() for value in [1, 2, 4]: list1.append(value) list2 = LinkedList() for value in [1, 3, 4]: list2.append(value) # Merge two sorted lists merged_list = LinkedList.merge_sorted_lists(list1, list2) merged_list.display() # Example output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> None # Reverse the merged list merged_list.reverse() merged_list.display() # Example output: 4 -> 4 -> 3 -> 2 -> 1 -> 1 -> None # Check cycle in the merged list print(merged_list.has_cycle()) # Output: False # Remove the 2nd node from the end merged_list.remove_nth_from_end(2) merged_list.display() # Example output: 4 -> 4 -> 3 -> 2 -> 1 -> None ``` Implement and test the functionalities with various linked lists to ensure correctness and efficiency.","solution":"class Node: def __init__(self, value: int, next=None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None def append(self, value: int) -> None: if not self.head: self.head = Node(value) else: current = self.head while current.next: current = current.next current.next = Node(value) def reverse(self) -> None: prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def has_cycle(self) -> bool: slow = fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False @staticmethod def merge_sorted_lists(list1, list2): dummy = Node(0) current = dummy p1, p2 = list1.head, list2.head while p1 and p2: if p1.value < p2.value: current.next = p1 p1 = p1.next else: current.next = p2 p2 = p2.next current = current.next current.next = p1 if p1 else p2 merged_list = LinkedList() merged_list.head = dummy.next return merged_list def remove_nth_from_end(self, n: int) -> None: dummy = Node(0) dummy.next = self.head fast = slow = dummy for _ in range(n + 1): fast = fast.next while fast: fast = fast.next slow = slow.next slow.next = slow.next.next self.head = dummy.next def display(self) -> None: current = self.head result = [] while current: result.append(current.value) current = current.next return result"},{"question":"# Scheduling Tasks with Priority Queues Given a list of tasks, where each task is represented by a tuple containing the task\'s name and its priority, implement a function that schedules the tasks using a priority queue. The function should return a list of tasks ordered by their priority from highest to lowest. Function Signature ```python def schedule_tasks(tasks: List[Tuple[str, int]]) -> List[str]: pass ``` Input * `tasks` (List[Tuple[str, int]]): A list of tuples where each tuple consists of a task name (string) and a priority (integer). Tasks with higher priority values should be executed first. Output * Returns a list of task names in the order they should be executed according to their priority. Example ```python tasks = [(\\"task1\\", 2), (\\"task2\\", 1), (\\"task3\\", 3)] result = schedule_tasks(tasks) assert result == [\\"task3\\", \\"task1\\", \\"task2\\"] ``` Constraints * `1 <= len(tasks) <= 100` * Each task name is a non-empty string of at most 50 characters. * Each priority is an integer between -1000 and 1000. Requirements * Use an appropriate data structure to efficiently manage the priority queue. * Ensure that the scheduling respects the order of tasks with identical priorities (i.e., first come, first served basis). Notes You might find it helpful to use Python\'s `heapq` library for managing the priority queue. Be mindful of maintaining the order of tasks with the same priority.","solution":"from typing import List, Tuple import heapq def schedule_tasks(tasks: List[Tuple[str, int]]) -> List[str]: Schedule the tasks using a priority queue and return them in order of their priority from highest to lowest. # Use a heap to create a max-heap by storing negative of priority max_heap = [(-priority, task) for task, priority in tasks] heapq.heapify(max_heap) ordered_tasks = [] while max_heap: priority, task = heapq.heappop(max_heap) ordered_tasks.append(task) return ordered_tasks"},{"question":"# Problem Statement You are given a series of strings representing logs from a system where each log has an associated priority level and timestamp. Your task is to implement a function that extracts and summarizes the sequence of events per priority level within a given time range. # Function Signature ```python def summarize_logs(logs: list[tuple[int, str]], start_time: str, end_time: str) -> dict[str, list[str]]: pass ``` # Input - `logs`: A list of tuples where each tuple contains an integer representing the priority level and a string representing the log message. The log message format is \\"timestamp|message\\" where the timestamp is in the format \\"YYYY-MM-DD HH:MM:SS\\". - `start_time`: A string representing the start time of the range in the format \\"YYYY-MM-DD HH:MM:SS\\". - `end_time`: A string representing the end time of the range in the format \\"YYYY-MM-DD HH:MM:SS\\". # Output - A dictionary where keys are the unique priority levels (as strings) and values are lists of log messages that fall within the given time range, ordered by timestamp. # Constraints - The length of `logs` will not exceed 100,000. - All timestamps in the logs will be valid and unique. - The start and end times will be valid and the start time will be less than or equal to the end time. - The priority levels will be between 1 and 5. # Example ```python # Example usage logs = [ (2, \\"2023-01-01 10:00:00|System started\\"), (1, \\"2023-01-01 10:05:00|Error occurred\\"), (3, \\"2023-01-01 10:10:00|User logged in\\"), (2, \\"2023-01-01 10:15:00|Warning issued\\"), (1, \\"2023-01-01 10:20:00|Recovery action taken\\") ] start_time = \\"2023-01-01 10:00:00\\" end_time = \\"2023-01-01 10:15:00\\" # Example expected output # { # \\"2\\": [\\"2023-01-01 10:00:00|System started\\", \\"2023-01-01 10:15:00|Warning issued\\"], # \\"1\\": [\\"2023-01-01 10:05:00|Error occurred\\"], # \\"3\\": [\\"2023-01-01 10:10:00|User logged in\\"] # } summarize_logs(logs, start_time, end_time) ``` # Task Description 1. **Filter Logs**: Implement the function to filter logs that fall within the given time range. 2. **Organize by Priority**: Group the filtered logs by their priority levels and ensure the log messages are ordered by timestamp within each priority group. 3. **Performance**: Handle edge cases efficiently, ensuring the solution performs well for large datasets.","solution":"def summarize_logs(logs: list[tuple[int, str]], start_time: str, end_time: str) -> dict[str, list[str]]: from collections import defaultdict from datetime import datetime def is_within_range(log_time_str, start_time_str, end_time_str): log_time = datetime.strptime(log_time_str, \\"%Y-%m-%d %H:%M:%S\\") start_time = datetime.strptime(start_time_str, \\"%Y-%m-%d %H:%M:%S\\") end_time = datetime.strptime(end_time_str, \\"%Y-%m-%d %H:%M:%S\\") return start_time <= log_time <= end_time result = defaultdict(list) for priority, log_message in logs: timestamp, message = log_message.split(\'|\', 1) if is_within_range(timestamp, start_time, end_time): result[str(priority)].append(log_message) for priority in result: result[priority].sort() return dict(result)"},{"question":"# Question: Optimizing Palindrome Frequency in a Range Context A palindrome is a number that reads the same backward as forward (e.g., 121, 1331). Calculating the frequency of palindromic numbers in a large range can be challenging with traditional methods. Your task is to develop an efficient algorithm that counts the number of palindromic numbers within a given range. Task Write a Python function `count_palindromes(lower_limit: int, upper_limit: int) -> int` that efficiently counts all palindromic numbers in the inclusive range from `lower_limit` to `upper_limit`. Implementation Details - **Input**: - `lower_limit` (int): A non-negative integer specifying the lower bound of the range. - `upper_limit` (int): A non-negative integer greater than or equal to `lower_limit` specifying the upper bound of the range. - **Output**: - Return the count of palindromic numbers within the specified range. Constraints - You must use an optimized solution that minimizes unnecessary checks compared to a naive, brute-force method. - The input values will often be large, such as `upper_limit` up to ( 10^9 ). Example ```python assert count_palindromes(1, 1000) == 199 assert count_palindromes(1000, 10000) == 90 ``` Hints - Avoid checking every number in the range directly. - Construct possible palindromic numbers and check if they fall within the specified range. - You can leverage properties of palindromes to generate them more efficiently (e.g., building from half of the number and mirroring it). **Note**: This problem requires you to think about efficient number generation and range checks to handle large inputs efficiently.","solution":"def count_palindromes(lower_limit: int, upper_limit: int) -> int: Returns the count of palindromic numbers within the inclusive range from lower_limit to upper_limit. def is_palindrome(num): return str(num) == str(num)[::-1] count = 0 for number in range(lower_limit, upper_limit + 1): if is_palindrome(number): count += 1 return count"},{"question":"# Fibonacci Sequence Modification Context: The Fibonacci sequence is a well-known series of numbers where each number is the sum of the two preceding ones, typically starting with 0 and 1. This sequence can be modified by defining different starting values, which will result in a sequence that follows the same summing pattern but starts with the provided initial values. Objective: Write a function that generates a modified Fibonacci sequence given two initial values and returns the Nth term of this sequence. Function Signature: ```python def modified_fibonacci(a: int, b: int, n: int) -> int: ``` Input: * `a` (int): the first number in the sequence, where -10^3 ≤ a ≤ 10^3. * `b` (int): the second number in the sequence, where -10^3 ≤ b ≤ 10^3. * `n` (int): the position in the sequence (1-based index), where 1 ≤ n ≤ 30. Output: * The `n`th number in the modified Fibonacci sequence. Constraints: * Ensure the function calculates the sequence efficiently. * Treat the sequence as starting at the 1st element for the given initial values. Example: ```python assert modified_fibonacci(0, 1, 5) == 3 # Standard Fibonacci, 0, 1, 1, 2, 3 assert modified_fibonacci(2, 3, 6) == 21 # Modified Fibonacci, 2, 3, 5, 8, 13, 21 ``` Notes: * The sequence always starts with `a` at position 1 and `b` at position 2. * Ensure your solution works for both negative and positive starting values.","solution":"def modified_fibonacci(a: int, b: int, n: int) -> int: Generate a modified Fibonacci sequence given two initial values and return the Nth term of this sequence. :param a: The first number in the sequence :param b: The second number in the sequence :param n: The position of the term to return (1-based index) :return: The Nth number in the modified Fibonacci sequence if n == 1: return a elif n == 2: return b fib = [a, b] for i in range(2, n): fib.append(fib[-1] + fib[-2]) return fib[-1]"},{"question":"# Coding Assessment Question Context You are tasked with developing a text-processing function that identifies and eliminates duplicate words in a sentence while preserving the order of first occurrences. This is useful in natural language processing and data cleaning tasks where unique word representation is critical. Task Write a function `remove_duplicate_words(sentence: str) -> str` that takes a sentence as input and returns a new sentence without any duplicate words. Input and Output Formats * **Input**: * `sentence (str)`: A string containing words separated by spaces. Each word consists of only lowercase English letters and is between 1 and 20 characters in length. The length of the sentence does not exceed 1,000 characters. * **Output**: * A string containing the words from the input sentence in the same order as their first occurrence, but with all subsequent duplicate words removed. Constraints and Performance Requirements * The function should handle sentences up to 1,000 characters efficiently. * Ensure that the relative order of the first occurrences of words is maintained. Special Notes 1. Consider using data structures like sets or dictionaries to track occurrences of words. 2. Be mindful of the space and time complexity, aiming for an efficient linear time solution. Example ```python def remove_duplicate_words(sentence: str) -> str: pass ``` **Example Usage:** ```python >>> remove_duplicate_words(\\"this is a test this is only a test\\") \\"this is a test only\\" >>> remove_duplicate_words(\\"data science is fun data science is challenging\\") \\"data science is fun challenging\\" >>> remove_duplicate_words(\\"hello world hello\\") \\"hello world\\" >>> remove_duplicate_words(\\"unique words only appear once\\") \\"unique words only appear once\\" ```","solution":"def remove_duplicate_words(sentence: str) -> str: Takes a sentence and removes duplicate words while preserving the first occurrence order. Parameters: sentence (str): The input sentence containing words separated by spaces. Returns: str: A sentence without duplicate words, preserving the order of first occurrences. seen = set() result = [] for word in sentence.split(): if word not in seen: seen.add(word) result.append(word) return \' \'.join(result)"},{"question":"# Scenario Imagine you are developing a system that manages bookings for events. Each booking has a `start` time and an `end` time. You need to design a data structure that can quickly check if a new booking overlaps with any existing bookings. # Task Implement a class `EventBookings` that manages event bookings. The class should efficiently check for overlap with existing bookings. # Requirements 1. **add_booking(start, end)**: Adds a new booking with the given `start` and `end` times. 2. **is_overlapping(start, end)**: Checks if a given booking overlaps with any of the existing bookings. 3. **total_bookings()**: Returns the total number of bookings. # Constraints - The time complexity for checking an overlap should be efficient. - Bookings are defined by their `start` and `end` times as integers. - Ensure that the `add_booking` method avoids adding overlapping bookings. # Input and Output - **add_booking(start, end)**: Two integers `start` and `end` representing the start and end times of a booking. - **is_overlapping(start, end)**: Two integers `start` and `end` representing the start and end times of a booking. Returns `True` if the booking overlaps with any existing booking, otherwise `False`. - **total_bookings()**: No parameters. Returns an integer representing the total number of bookings. # Example ```python eb = EventBookings() eb.add_booking(10, 20) eb.add_booking(21, 30) print(eb.is_overlapping(15, 25)) # Output: True print(eb.is_overlapping(31, 40)) # Output: False print(eb.total_bookings()) # Output: 2 ``` # Implementation Challenge Implement the `EventBookings` class ensuring each method efficiently handles overlapping checks and maintains a list of non-overlapping bookings.","solution":"class EventBookings: def __init__(self): self.bookings = [] def add_booking(self, start, end): Adds a new booking with the given start and end times if it does not overlap with existing bookings. if not self.is_overlapping(start, end): self.bookings.append((start, end)) self.bookings.sort() def is_overlapping(self, start, end): Checks if a given booking overlaps with any of the existing bookings. for b_start, b_end in self.bookings: if start < b_end and end > b_start: return True return False def total_bookings(self): Returns the total number of bookings. return len(self.bookings)"},{"question":"# Problem Statement: Imagine you are working on data processing software for an e-commerce platform. One of the tasks involves summarizing transaction details. Given the timestamps of transactions in the form of UNIX time, write a function to categorize these transactions by month and year, and calculate the total transaction amount for each category. # Requirements: 1. **Input Format**: You will receive a list of transactions, where each transaction is represented as a tuple containing: * UNIX timestamp of the transaction. * Transaction amount (a positive float). 2. **Output Format**: The function should return a dictionary where the keys are strings representing the \\"month-year\\" (e.g., \\"01-2023\\"), and the values are the sum of transaction amounts for that period. 3. **Hint**: Use python\'s `datetime` module to convert the UNIX timestamp to a `datetime` object, and then extract the month and year from it. # Constraints: - All timestamps are valid UNIX timestamps. - The input list can contain up to 10^5 transactions. # Function Signature: ```python from typing import List, Tuple, Dict def summarize_transactions(transactions: List[Tuple[int, float]]) -> Dict[str, float]: pass ``` # Example: ```python transactions = [ (1640995200, 100.50), # Corresponds to 01-Jan-2022 (1643673600, 150.75), # Corresponds to 01-Feb-2022 (1672531200, 200.10), # Corresponds to 01-Jan-2023 (1643673600, 50.25) # Corresponds to 01-Feb-2022 ] # The function call should return: # { # \\"01-2022\\": 100.50, # \\"02-2022\\": 201.00, # \\"01-2023\\": 200.10 # } ``` # Task: Implement the `summarize_transactions` function which takes a list of transactions and categorizes them by month and year, while summing up the transaction amounts for each category. # Hint: Use the `datetime` module to handle the conversion of UNIX timestamps to month and year strings.","solution":"from typing import List, Tuple, Dict from datetime import datetime def summarize_transactions(transactions: List[Tuple[int, float]]) -> Dict[str, float]: summary = {} for timestamp, amount in transactions: dt = datetime.utcfromtimestamp(timestamp) key = dt.strftime(\\"%m-%Y\\") if key not in summary: summary[key] = 0.0 summary[key] += amount return summary"},{"question":"# Coding Assessment: Optimizing Warehouse Inventory Management System Context You are developing a warehouse inventory management system. The system should efficiently handle the arrival of new items, outgoing shipments, and provide inventory status updates. Specifically, you need to manage the stock levels of various items, track their movements, and generate inventory reports. Requirements Implement the following functions: 1. **add_item(inventory: Dict[str, int], item: str, quantity: int) -> Dict[str, int]**: * Adds a specified quantity of an item to the inventory. If the item doesn\'t exist, it initializes with the given quantity. 2. **remove_item(inventory: Dict[str, int], item: str, quantity: int) -> Dict[str, int]**: * Removes a specified quantity of an item from the inventory. If the quantity to remove is greater than the current stock, remove only the available stock and set item quantity to 0. 3. **generate_report(inventory: Dict[str, int]) -> str**: * Generates a report of the current inventory status, listing items and their quantities in a readable format. 4. **total_items(inventory: Dict[str, int]) -> int**: * Returns the total count of all items currently in the inventory. 5. **most_stocked_item(inventory: Dict[str, int]) -> str**: * Identifies and returns the item with the highest stock quantity from the inventory. If there\'s a tie, return any one of the most-stocked items. Input * You will be provided with a dictionary representing the inventory and a series of operations to perform. Output * The functions should correctly manipulate the inventory and provide well-formatted reports back to the user. Example ```python # Example inventory: inventory = {\\"apple\\": 10, \\"banana\\": 5, \\"orange\\": 7} # Perform operations: inventory = add_item(inventory, \\"apple\\", 5) inventory = remove_item(inventory, \\"banana\\", 3) report = generate_report(inventory) total = total_items(inventory) most_stocked = most_stocked_item(inventory) # Expected Output: # inventory = {\\"apple\\": 15, \\"banana\\": 2, \\"orange\\": 7} # report = Item Quantity apple 15 banana 2 orange 7 # total = 24 # most_stocked = \\"apple\\" ``` Ensure your implementation handles possible edge cases such as negative quantities, non-existent items, and zero quantity updates.","solution":"def add_item(inventory, item, quantity): Adds a specified quantity of an item to the inventory. If the item doesn\'t exist, it initializes it with the given quantity. if item in inventory: inventory[item] += quantity else: inventory[item] = quantity return inventory def remove_item(inventory, item, quantity): Removes a specified quantity of an item from the inventory. If the quantity to remove is greater than the current stock, remove only the available stock. if item in inventory: if inventory[item] <= quantity: inventory[item] = 0 else: inventory[item] -= quantity return inventory def generate_report(inventory): Generates a report of the current inventory status. report = \\"Item Quantityn\\" for item, quantity in inventory.items(): report += f\\"{item:<12}{quantity}n\\" return report.strip() def total_items(inventory): Returns the total count of all items currently in the inventory. return sum(inventory.values()) def most_stocked_item(inventory): Identifies and returns the item with the highest stock quantity. if not inventory: return None return max(inventory, key=inventory.get)"},{"question":"# Coding Assessment Question Context Binary search is a fundamental algorithm often used for finding elements within sorted data. Your task is to implement a modification of binary search called \\"Rotated Binary Search\\" which operates on an array that has been initially sorted and then rotated at some pivot. Task Implement a function `rotated_binary_search(nums: List[int], target: int) -> int` that finds the position (index) of a target value within a rotated sorted array or returns -1 if the target is not found. Function Signature ```python def rotated_binary_search(nums: List[int], target: int) -> int: pass ``` Input * `nums`: A list of integers representing the rotated sorted array. * `target`: An integer representing the value to search for within `nums`. Output * Returns the index of `target` in `nums` if the `target` exists in `nums`. * Returns -1 if `target` is not present. Examples ```python assert rotated_binary_search([4, 5, 6, 7, 0, 1, 2], 0) == 4 assert rotated_binary_search([4, 5, 6, 7, 0, 1, 2], 3) == -1 assert rotated_binary_search([1], 0) == -1 assert rotated_binary_search([1], 1) == 0 assert rotated_binary_search([5, 6, 7, 8, 9, 1, 2, 3], 6) == 1 ``` Constraints * `1 <= nums.length <= 5000` * `-10^4 <= nums[i] <= 10^4` * `nums` contains unique integers. * `nums` is sorted in ascending order at first, but then rotated at an unknown pivot point. * `target` is an integer value within the range `-10^4` to `10^4`. Performance Requirements * Ensure your implementation is efficient and runs with a time complexity of O(log n) where n is the length of `nums`.","solution":"from typing import List def rotated_binary_search(nums: List[int], target: int) -> int: Searches for a target value within a rotated sorted array and returns the position (index) of the target if found, otherwise -1. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid # Identify the sorted part of the array if nums[left] <= nums[mid]: # Left part is sorted if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: # Right part is sorted if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Question: Implement Text Justification Algorithm You are tasked with implementing a text justification function that formats a list of words into a specific width. The text should be fully justified such that each line contains exactly the given number of characters. Function Signature ```python def justify_text(words: List[str], maxWidth: int) -> List[str]: ``` Input - `words` (List[str]): A list of strings consisting of words, where each word is made up of alphanumeric characters. - `maxWidth` (int): An integer representing the maximum width of each line. Output - (List[str]): A list of strings, where each string represents a fully justified line of text with exactly `maxWidth` characters. Constraints - `1 <= len(words) <= 1000` - `1 <= len(words[i]) <= maxWidth <= 100` - Words can only be separated by a single space, which means the total characters in a line including spaces should not exceed `maxWidth`. Performance Requirements - The function should efficiently handle the input size within the provided constraints. # Examples 1. ```python words = [\\"This\\", \\"is\\", \\"an\\", \\"example\\", \\"of\\", \\"text\\", \\"justification.\\"] maxWidth = 16 justify_text(words, maxWidth) ``` Output: ```python [\\"This is an\\", \\"example of text\\", \\"justification. \\"] ``` 2. ```python words = [\\"What\\", \\"must\\", \\"be\\", \\"acknowledgment\\", \\"shall\\", \\"be\\"] maxWidth = 16 justify_text(words, maxWidth) ``` Output: ```python [\\"What must be\\", \\"acknowledgment \\", \\"shall be \\"] ``` 3. ```python words = [\\"Science\\", \\"is\\", \\"what\\", \\"we\\", \\"understand\\", \\"well\\", \\"enough\\", \\"to\\", \\"explain\\", \\"to\\", \\"a\\", \\"computer.\\", \\"Art\\", \\"is\\", \\"everything\\", \\"else\\", \\"we\\", \\"do\\"] maxWidth = 20 justify_text(words, maxWidth) ``` Output: ```python [\\"Science is what we\\", \\"understand well\\", \\"enough to explain to\\", \\"a computer. Art is\\", \\"everything else we\\", \\"do \\"] ``` # Challenges 1. Ensure spaces are distributed evenly between words on each line. 2. If there is an uneven number of spaces to distribute, the extra spaces should go to the leftmost slots. 3. Handle the last line of text differently: it should be left-justified, and no extra space is inserted between words. It should still be padded with spaces to ensure the width is exactly `maxWidth`.","solution":"def justify_text(words, maxWidth): def justify_line(line, maxWidth): num_spaces = maxWidth - sum(len(word) for word in line) if len(line) == 1: return line[0] + \' \' * num_spaces gaps = len(line) - 1 space_between_words, extra_spaces = divvy(num_spaces, gaps) justified_line = \'\' for i in range(gaps): justified_line += line[i] + \' \' * (space_between_words + (1 if i < extra_spaces else 0)) justified_line += line[-1] return justified_line def divvy(total, divisors): return divmod(total, divisors) lines = [] current_line = [] current_length = 0 for word in words: if current_length + len(word) + len(current_line) > maxWidth: lines.append(justify_line(current_line, maxWidth)) current_line = [] current_length = 0 current_line.append(word) current_length += len(word) final_line = \' \'.join(current_line) final_line_padded = final_line + \' \' * (maxWidth - len(final_line)) lines.append(final_line_padded) return lines"},{"question":"# Question: Implement an Efficient Matrix Transpose Function Given an `m x n` matrix represented as a list of lists, implement a function to compute the transpose of the matrix. The transpose of a matrix is obtained by switching the rows with the columns. # Function Signature ```python def transpose(matrix: list[list[int]]) -> list[list[int]]: Arguments: matrix: A list of lists of integers representing an m x n matrix. Returns: A list of lists of integers representing the transposed n x m matrix. ``` # Expected Input and Output * **Input**: * `matrix`: An `m x n` matrix represented as a list of lists of integers. * **Output**: * A new `n x m` matrix where the rows and columns are switched. * **Constraints**: * 1 ≤ m, n ≤ 1000 * Each element in the matrix will be an integer between -10^9 and 10^9. # Example ```python >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6] ... ] >>> transpose(matrix) [ [1, 4], [2, 5], [3, 6] ] ``` # Performance Your implementation should handle the worst-case scenario of an `m x n` matrix where both m and n are large, efficiently using space and time proportional to the number of elements in the matrix. # Notes * Describe the algorithmic steps in your function. * Ensure your implementation is capable of handling edge cases, such as matrices with a single row or column, and adheres to input constraints.","solution":"def transpose(matrix: list[list[int]]) -> list[list[int]]: Returns the transpose of the given matrix. Arguments: matrix : list[list[int]] - A list of lists of integers representing an m x n matrix. Returns: list[list[int]] - A list of lists of integers representing the transposed n x m matrix. # Get the number of rows (m) and columns (n) in the original matrix m = len(matrix) n = len(matrix[0]) # Create the transposed matrix with dimensions n x m transposed_matrix = [[0] * m for _ in range(n)] # Iterate over the matrix to fill in the transposed values for i in range(m): for j in range(n): transposed_matrix[j][i] = matrix[i][j] return transposed_matrix"},{"question":"# In-Place Merge Sort Implementation Merge sort is a divide-and-conquer algorithm that divides the input array into two halves, recursively sorts them, and then merges the two sorted halves. Traditionally, merge sort is not in-place and requires additional memory, but it can be adapted to work in-place with careful manipulation. Task You are required to implement an in-place merge sort algorithm to sort the given array. The goal is to achieve the sorting without using extra space for another array. Input * An array `arr` of integers with `n` elements where `1 ≤ n ≤ 10^5`. Output * The same array `arr`, now sorted in place. Function Signature ```python def in_place_merge_sort(arr: list[int]) -> None: pass ``` Example ```python >>> arr = [5, 2, 7] >>> in_place_merge_sort(arr) >>> print(arr) [2, 5, 7] >>> arr = [1, 1, 2, 2, 3] >>> in_place_merge_sort(arr) >>> print(arr) [1, 1, 2, 2, 3] >>> arr = [10, 9, 8, 7, 6] >>> in_place_merge_sort(arr) >>> print(arr) [6, 7, 8, 9, 10] >>> arr = [15, 10, 20, 5, 3, 8, 12, 25] >>> in_place_merge_sort(arr) >>> print(arr) [3, 5, 8, 10, 12, 15, 20, 25] ``` Constraints * The implementation should handle edge cases such as an array of one element or an empty array. * Time Complexity: (O(n log n)). * Space Complexity: (O(1)) additional space (apart from the input array). Tips * Implement recursive merge sort but modify the merging step to merge in place. * Use a two-pointer technique to merge the subarrays within the main array. * Ensure the merging process is efficient and does not rely on extra space.","solution":"def merge(arr, start, mid, end): start2 = mid + 1 if arr[mid] <= arr[start2]: # Already in place return while start <= mid and start2 <= end: if arr[start] <= arr[start2]: start += 1 else: value = arr[start2] index = start2 while index != start: arr[index] = arr[index - 1] index -= 1 arr[start] = value start += 1 mid += 1 start2 += 1 def in_place_merge_sort_helper(arr, l, r): if l < r: m = l + (r - l) // 2 in_place_merge_sort_helper(arr, l, m) in_place_merge_sort_helper(arr, m + 1, r) merge(arr, l, m, r) def in_place_merge_sort(arr): if not arr or len(arr) == 1: return in_place_merge_sort_helper(arr, 0, len(arr) - 1)"},{"question":"# Question: Balanced HTML Tag Validator You are tasked with writing a function to validate the correctness of HTML-like tags in a given string. The goal is to ensure that all opening tags have matching closing tags and that they are properly nested. **Objectives:** 1. Implement a function `is_valid_html(tags: str) -> bool` that checks if the HTML tags within the input string are balanced and properly nested. 2. The function should return `True` if the tags are valid, and `False` otherwise. **Constraints:** - Tags are case-insensitive, meaning `<A>` and `</a>` should be considered a valid match. - Tags are assumed to be well-formed in terms of syntax (e.g., `<tag>` and `</tag>`), and no attributes are present within tags. - The input string may contain characters other than tags, which should be ignored in the validation process. - Self-closing tags (e.g., `<br/>`) are not considered in this question. **Function Signature:** ```python def is_valid_html(tags: str) -> bool: ``` **Example Usage:** ```python print(is_valid_html(\\"<div><span></span></div>\\")) # Output: True print(is_valid_html(\\"<div><p></div></p>\\")) # Output: False print(is_valid_html(\\"<div><span></div></span>\\")) # Output: False print(is_valid_html(\\"<A><B></B></A>\\")) # Output: True print(is_valid_html(\\"<a><b></b></a>\\")) # Output: True ``` **Notes:** - Ensure that the function handles nested and overlapping tags correctly. - Handle all edge cases, such as no tags in the string, improper tags closing, and varying case sensitivity between opening and closing tags. Your task is to implement the `is_valid_html` function ensuring it behaves as described and accurately validates the HTML-like tags.","solution":"import re def is_valid_html(tags: str) -> bool: Checks if the HTML tags in the input string are balanced and properly nested. tag_pattern = re.compile(r\'<(/?)(w+)>\') stack = [] for match in tag_pattern.finditer(tags): is_closing_tag, tag_name = match.groups() if is_closing_tag: if not stack or stack[-1].lower() != tag_name.lower(): return False stack.pop() else: stack.append(tag_name) return not stack"},{"question":"# Question: Rotate a 2D Matrix Your task is to implement a function that rotates a given ( n times n ) 2D matrix by 90 degrees clockwise. The rotation should be done in-place, meaning you cannot use any auxiliary data structures to complete the task. Function Signature ```python def rotate_matrix(matrix: list[list[int]]) -> None: Rotates the given n x n 2D matrix by 90 degrees clockwise in-place. :param matrix: A list of n lists, each containing n integers, representing the matrix. ``` Input/Output Examples 1. **Input**: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) ``` - **Output**: ```python matrix = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` - **Explanation**: The matrix is rotated by 90 degrees clockwise. 2. **Input**: ```python matrix = [ [1, 2], [3, 4] ] rotate_matrix(matrix) ``` - **Output**: ```python matrix = [ [3, 1], [4, 2] ] ``` - **Explanation**: The matrix is rotated by 90 degrees clockwise. 3. **Input**: ```python matrix = [ [1] ] rotate_matrix(matrix) ``` - **Output**: ```python matrix = [ [1] ] ``` - **Explanation**: A 1x1 matrix remains the same after rotation. # Constraints and Limitations - The matrix is always an ( n times n ) (square) matrix where ( 1 leq n leq 100 ). - The matrix is guaranteed to contain integers. - The function must perform the operation in-place, using only O(1) extra memory.","solution":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotates the given n x n 2D matrix by 90 degrees clockwise in-place. :param matrix: A list of n lists, each containing n integers, representing the matrix. n = len(matrix) for i in range(n // 2): for j in range(i, n - 1 - i): # save the top element top = matrix[i][j] # move left element to top matrix[i][j] = matrix[n - 1 - j][i] # move bottom element to left matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j] # move right element to bottom matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i] # move top element to right matrix[j][n - 1 - i] = top"},{"question":"# Find Missing Number in Array Objective Write a Python function to find a missing number from an array containing `n` unique integers ranging from `1` to `n+1` inclusive. Problem Statement Given an array of `n` unique integers where each integer is between `1` and `n+1` inclusive, implement a function `find_missing_number(arr: List[int]) -> int` that returns the missing integer. Also, create a test suite to verify your implementation. Input and Output Format * **Input**: A list of `n` integers `arr`, where each integer is unique and within the range `1` to `n+1`. * **Output**: An integer representing the missing number in the array. Constraints * The array will contain unique integers. * The length of the array, `n`, will satisfy (1 leq n leq 10^6). * The solution should efficiently handle large arrays. Performance Requirements * Time Complexity: O(n) * Space Complexity: O(1) Example 1 * **Input**: `arr = [3, 1, 4]` * **Output**: `2` Example 2 * **Input**: `arr = [1, 5, 2, 3]` * **Output**: `4` Example 3 * **Input**: `arr = [6, 4, 3, 2, 1]` * **Output**: `5` Tasks 1. Implement the function `find_missing_number(arr: List[int]) -> int`. 2. Write a suite of test cases to ensure your implementation is correct, considering edge cases like an array with only one element or very large arrays. Notes * Consider using mathematical properties to make your solution efficient. * Ensure your function is tested for edge cases and performance limits.","solution":"from typing import List def find_missing_number(arr: List[int]) -> int: n = len(arr) expected_sum = (n + 1) * (n + 2) // 2 actual_sum = sum(arr) return expected_sum - actual_sum"},{"question":"Find Missing Number You are given a list `nums` containing `n` distinct numbers in the range `[0, n]` inclusive. This means that the list has `n+1` numbers for which one number is missing. Your task is to write a function that finds and returns the missing number from the list. Function Signature ```python def find_missing_number(nums: list[int]) -> int: pass ``` Input - `nums`: A list of integers representing the numbers from `0` to `n` inclusive, with one number missing. Output - An integer representing the missing number from the list. Constraints - 1 <= n <= 10^4 - Each number in the list is distinct and falls within the range `[0, n]`. Example ```python >>> find_missing_number([3, 0, 1]) 2 >>> find_missing_number([9,6,4,2,3,5,7,0,1]) 8 ``` Explanation 1. In the first example, the list has numbers `[3, 0, 1]` and the range is `[0, 3]`. The missing number in the sequence is `2`. 2. In the second example, the list has all numbers between `0` and `9` inclusive except `8`, which is the missing number. Implement the `find_missing_number` function to solve this problem. Ensure the implementation efficiently handles the given constraints and edge cases.","solution":"def find_missing_number(nums: list[int]) -> int: Returns the missing number in the list of numbers ranging from 0 to n inclusive. n = len(nums) # Calculate the expected sum of numbers from 0 to n expected_sum = n * (n + 1) // 2 # Calculate the actual sum of numbers in the list actual_sum = sum(nums) # The missing number is the difference between the expected sum and the actual sum return expected_sum - actual_sum"},{"question":"# Problem Description You are required to implement a simple Sudoku solver in Python. The solver must be able to fill in the missing numbers in a given partially completed 9x9 Sudoku board (grid), such that the completed Sudoku board satisfies the usual Sudoku rules. # Function Specifications 1. **Class Definition**: - `class SudokuSolver:` - `__init__(self, board: List[List[int]])` - Initialize with a 9x9 board, where empty cells are represented by 0. - `is_valid(self, num: int, row: int, col: int) -> bool` - Check if placing `num` in `board[row][col]` is valid according to Sudoku rules. - `solve(self) -> bool` - Solves the Sudoku board and returns True if solved successfully, else False. - `get_board(self) -> List[List[int]]` - Return the solved Sudoku board. # Input and Output **Input**: - The `SudokuSolver` class is initialized with a 2D list `board` representing a 9x9 Sudoku board where empty cells are represented by 0. - The method `is_valid` takes an integer `num` and its row and column indices as input to check if placing the number is valid. - The method `solve` tries to solve the board and returns a boolean indicating success. - The method `get_board` returns the resultant solved 9x9 board. **Output**: - The method `solve` returns a boolean value. - The method `get_board` returns a 2D list representing the solved Sudoku board. # Constraints - The input board is a 9x9 grid containing integers between 0 and 9. - There is always at least one solution for the given board. - The initial board provided to `SudokuSolver` is always a valid Sudoku board configuration. # Example ```python # Example usage board = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] solver = SudokuSolver(board) if solver.solve(): solved_board = solver.get_board() for row in solved_board: print(row) # Should print a fully solved 9x9 Sudoku board ``` Implement the `SudokuSolver` class to meet all the requirements given above.","solution":"from typing import List class SudokuSolver: def __init__(self, board: List[List[int]]): self.board = board def is_valid(self, num: int, row: int, col: int) -> bool: # Check the row for c in range(9): if self.board[row][c] == num: return False # Check the column for r in range(9): if self.board[r][col] == num: return False # Check the 3x3 sub-grid start_row, start_col = 3 * (row // 3), 3 * (col // 3) for r in range(start_row, start_row + 3): for c in range(start_col, start_col + 3): if self.board[r][c] == num: return False return True def solve(self) -> bool: for row in range(9): for col in range(9): if self.board[row][col] == 0: for num in range(1, 10): if self.is_valid(num, row, col): self.board[row][col] = num if self.solve(): return True self.board[row][col] = 0 return False return True def get_board(self) -> List[List[int]]: return self.board"},{"question":"# Matrix Multiplication Validator As part of a system that performs matrix operations, you have been asked to create a function that validates if two matrices can be multiplied and then performs the multiplication if valid. Task 1. Implement two functions: - `can_multiply_matrices(A: list, B: list) -> bool`: This function takes two matrices `A` and `B` (represented as lists of lists) and returns `True` if they can be multiplied and `False` otherwise. - `multiply_matrices(A: list, B: list) -> list`: This function takes two matrices `A` and `B` (represented as lists of lists) and returns their product matrix if they can be multiplied. If not, it should raise a `ValueError`. Input and Output Formats: **Matrix Validation**: * Input: Two matrices `A` and `B`. * Output: A boolean value. `True` if the matrices can be multiplied, `False` otherwise. **Matrix Multiplication**: * Input: Two matrices `A` and `B`. * Output: A matrix (list of lists) representing the product of `A` and `B`. Constraints: - The matrices `A` and `B` will only contain integer values. - The number of columns in matrix `A` must equal the number of rows in matrix `B` to be valid for multiplication. - The dimensions of `A` and `B` will be such that neither has more than (100) rows or columns. Examples: **Validation**: ```python can_multiply_matrices([[1, 2, 3], [4, 5, 6]], [[7, 8], [9, 10], [11, 12]]) # Output: True ``` ```python can_multiply_matrices([[1, 2]], [[3, 4], [5, 6], [7, 8]]) # Output: False ``` **Multiplication**: ```python multiply_matrices([[1, 2, 3], [4, 5, 6]], [[7, 8], [9, 10], [11, 12]]) # Output: [[58, 64], [139, 154]] ``` ```python multiply_matrices([[2]], [[3]]) # Output: [[6]] ``` ```python multiply_matrices([[1, 2]], [[3, 4], [5, 6]]) # Output: [[13, 16]] ``` If the matrices cannot be multiplied: ```python multiply_matrices([[1, 2]], [[3, 4], [5, 6], [7, 8]]) # Raises ValueError ``` Write your implementation for the validation and multiplication functions, ensuring you handle edge cases appropriately.","solution":"def can_multiply_matrices(A, B): Check if two matrices can be multiplied. Parameters: A (list of list of int): Matrix A B (list of list of int): Matrix B Returns: bool: True if matrices can be multiplied, otherwise False # Number of columns in A should be equal to the number of rows in B return len(A[0]) == len(B) def multiply_matrices(A, B): Multiply two matrices if possible. Parameters: A (list of list of int): Matrix A B (list of list of int): Matrix B Returns: list of list of int: Resultant matrix after multiplication Raises: ValueError: If matrices cannot be multiplied if not can_multiply_matrices(A, B): raise ValueError(\\"Matrices cannot be multiplied due to incompatible dimensions\\") # Initialize result matrix with zeros result = [[0 for _ in range(len(B[0]))] for _ in range(len(A))] # Perform multiplication for i in range(len(A)): for j in range(len(B[0])): for k in range(len(B)): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"# Median Maintenance Background In data streaming and real-time analytics, maintaining the median of an ongoing list of numbers efficiently is crucial. The median is the value separating the higher half from the lower half of a data sample. If the list has an odd number of elements, the median is the middle one. If it has an even number of elements, the median is the average of the two middle ones. Task Implement a class, `MedianMaintainer`, that efficiently keeps track of the median as new numbers are added to the list. The class should support two operations: 1. `add_number(num: float) -> None`: Add a new number to the collection. 2. `get_median() -> float`: Return the current median of the collection. The `MedianMaintainer` class should use a data structure that ensures both operations are optimized for performance. Your class should follow this structure: ```python class MedianMaintainer: def __init__(self): ... def add_number(self, num: float) -> None: ... def get_median(self) -> float: ... ``` Constraints * The total number of elements that can be added is up to (10^5). * You can use heaps or any other efficient data structure to maintain the median. * The `add_number` and `get_median` operations should be optimized for time complexity. Example Usage ```python med_maintainer = MedianMaintainer() numbers = [5, 15, 1, 3] for num in numbers: med_maintainer.add_number(num) print(f\\"Added {num}, current median is {med_maintainer.get_median()}\\") # Expected output: # Added 5, current median is 5.0 # Added 15, current median is 10.0 # Added 1, current median is 5.0 # Added 3, current median is 4.0 ``` Notes * Include initialization for any data structures you use in the class constructor. * Ensure that the method to add a new number and compute the median runs efficiently for a large number of elements. * Write unit tests to verify the correctness of your `MedianMaintainer` implementation, accounting for both odd and even numbers of elements. * Handle edge cases where there might not be any elements in the collection when `get_median` is called.","solution":"import heapq class MedianMaintainer: def __init__(self): self.lower_half = [] # max heap (negative values) self.upper_half = [] # min heap def add_number(self, num: float) -> None: if len(self.lower_half) == 0 or num <= -self.lower_half[0]: heapq.heappush(self.lower_half, -num) else: heapq.heappush(self.upper_half, num) # Balance the heaps if len(self.lower_half) > len(self.upper_half) + 1: heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half)) elif len(self.upper_half) > len(self.lower_half): heapq.heappush(self.lower_half, -heapq.heappop(self.upper_half)) def get_median(self) -> float: if len(self.lower_half) == 0 and len(self.upper_half) == 0: raise ValueError(\\"No elements present\\") if len(self.lower_half) > len(self.upper_half): return -self.lower_half[0] else: return (-self.lower_half[0] + self.upper_half[0]) / 2"},{"question":"# Problem Statement Create a function that identifies and removes consecutive duplicate words in a given text. The function should also ensure that the resulting text has only single spaces between words and no leading or trailing spaces. # Function Signature ```python def remove_consecutive_duplicates(text: str) -> str: pass ``` # Input - `text` (str): A string which can contain any printable characters, including words separated by spaces. # Output - (str): The modified text where consecutive duplicate words have been removed and the spacing is normalized. # Constraints - The function should handle both empty and non-empty text. - The function should maintain the original case of the words. # Examples ```python assert remove_consecutive_duplicates(\\"This is is a test test\\") == \\"This is a test\\" assert remove_consecutive_duplicates(\\"Hello Hello world world\\") == \\"Hello world\\" assert remove_consecutive_duplicates(\\"No duplicates here\\") == \\"No duplicates here\\" assert remove_consecutive_duplicates(\\" a a a b c c \\") == \\"a b c\\" assert remove_consecutive_duplicates(\\"\\") == \\"\\" assert remove_consecutive_duplicates(\\"Same word same word\\") == \\"Same word same word\\" ``` # Additional Notes - Treat consecutive words case-sensitively. For example, \\"Hello hello\\" should not be considered duplicates and should not be removed. - Consecutive words include words separated by multiple spaces; consider them duplicates if they appear next to each other arbitrarily spaced.","solution":"def remove_consecutive_duplicates(text: str) -> str: if not text: return \\"\\" words = text.split() result = [] for i, word in enumerate(words): if i == 0 or word != words[i - 1]: result.append(word) return \' \'.join(result)"},{"question":"# Scenario You are part of a software development team working on a new feature for a text manipulation tool. One of the functionalities required is the ability to handle text formatting by capitalizing the first letter of each word in a given string. This feature must handle various edge cases such as punctuation, numbers, and mixed capitalization. # Task Write a function `capitalize_words(input_string: str) -> str` that takes a string and returns a new string where the first letter of each word is capitalized. Words are considered to be sequences of characters separated by whitespace or punctuation. # Input * **input_string**: A non-empty string `1 <= len(input_string) <= 1000`, containing alphabetical characters, numbers, whitespace, and punctuation. # Output * Returns a new string with the first letter of each word capitalized. # Function Signature ```python def capitalize_words(input_string: str) -> str: pass ``` # Examples * `capitalize_words(\\"hello world\\")` should return `Hello World`. * `capitalize_words(\\"this is a test.\\")` should return `This Is A Test.`. * `capitalize_words(\\"multiple spaces\\")` should return `Multiple Spaces`. * `capitalize_words(\\"mix of CAPS and lowercase\\")` should return `Mix Of CAPS And Lowercase`. # Constraints * Words can contain letters in lowercase or uppercase, numbers, and punctuation marks, and they should retain their integrity except for the first character being capitalized if it\'s a letter. * The function should handle leading, trailing, and multiple spaces between words correctly. # Notes * Pay attention to the preservation of other characters like numbers and punctuation marks within the words. * Ensure the solution handles both simple and complex cases efficiently, maintaining the original spacing and punctuation.","solution":"import re def capitalize_words(input_string: str) -> str: Capitalizes the first letter of each word in the input string. Words are defined as sequences of characters separated by whitespace or punctuation. return re.sub(r\'bw\', lambda m: m.group().upper(), input_string)"},{"question":"# Scenario You are building a memory management system for a simplified operating system. Parts of the system memory need to be efficiently allocated and deallocated to avoid fragmentation. The best-fit and first-fit strategies are popular approaches in such cases. # Challenge Create a memory allocator that uses the best-fit strategy for allocating memory blocks and a first-fit strategy for deallocating them. The allocator should manage a fixed size memory pool, handle requests for memory allocation, and release memory back to the pool when done. # Task 1. Implement the `MemoryAllocator` class with methods to allocate and deallocate memory blocks. 2. Use the best-fit strategy for finding a suitable block for allocation. 3. Use the first-fit strategy for finding a suitable position for deallocated memory. # Requirements - Implement methods `allocate(memory_size)` and `deallocate(start_address, memory_size)`. - Track and manage free and used memory blocks, ensuring efficient use of the memory pool. - Handle edge cases where memory requests cannot be fulfilled due to lack of sufficient contiguous space. # Input and Output - Input: Size of the memory to be allocated or deallocated, and address of memory to be deallocated. - Output: Success or failure status of allocation, updated memory layout after operations. # Example Suppose you have the following sequence of operations: ```python allocator = MemoryAllocator(total_memory=100) print(allocator.allocate(20)) # Allocates 20 units if available, returns starting address or failure message print(allocator.allocate(50)) # Allocates 50 units if available, returns starting address or failure message allocator.deallocate(20, 20) # Deallocates 20 units starting from address 20 print(allocator.allocate(10)) # Allocates 10 units, should use best-fit position ``` # Constraints - Memory size is a positive integer up to the total memory pool size. - Start address for deallocation must be a valid previously allocated address. - Ensure efficient memory allocation and deallocation to minimize fragmentation. Implement the `MemoryAllocator` class with the required methods, ensuring it follows the best-fit strategy for allocating and first-fit for deallocating memory blocks while effectively managing the memory pool.","solution":"class MemoryAllocator: def __init__(self, total_memory): self.total_memory = total_memory self.memory = [(0, total_memory)] # A single block of free memory initially self.allocated_memory = [] # To keep track of allocated memory blocks def allocate(self, memory_size): best_fit_index = -1 best_fit_size = float(\'inf\') # Find the best-fit block for index, (start, size) in enumerate(self.memory): if size == memory_size: # Perfect fit best_fit_index = index best_fit_size = size break elif size > memory_size and size < best_fit_size: best_fit_index = index best_fit_size = size if best_fit_index == -1: return -1 # Allocation failed start_address, size = self.memory.pop(best_fit_index) self.allocated_memory.append((start_address, memory_size)) # If there\'s remaining free memory in the block, add it back if size > memory_size: self.memory.append((start_address + memory_size, size - memory_size)) self.memory.sort() # Keep the free memory list sorted by start address return start_address def deallocate(self, start_address, memory_size): try: self.allocated_memory.remove((start_address, memory_size)) except ValueError: return -1 # Deallocation failed due to invalid address or size self.memory.append((start_address, memory_size)) # Merge contiguous free blocks self.memory.sort() merged_memory = [] current_start, current_size = self.memory[0] for i in range(1, len(self.memory)): next_start, next_size = self.memory[i] if current_start + current_size == next_start: # Merge contiguous blocks current_size += next_size else: merged_memory.append((current_start, current_size)) current_start, current_size = next_start, next_size merged_memory.append((current_start, current_size)) self.memory = merged_memory return 0"},{"question":"# Sum of Perfect Square Roots **Objective**: Write a function to determine if a given list contains numbers whose sum of square roots is an integer. Function Signature ```python def has_integer_square_root_sum(numbers: list) -> bool: Returns True if the sum of square roots is an integer, False otherwise. pass ``` # Input * A list `numbers` containing non-negative integers. * The list must have at least one element and each element must be an integer value. # Output * A boolean value `True` if the sum of the square roots of the numbers is an integer, otherwise `False`. # Constraints * The function should handle lists containing up to 10^6 elements efficiently. * Raise a `TypeError` if any element in the list is not an integer. # Example Cases Example 1: **Input**: ```python numbers = [4, 16, 1] ``` **Output**: ```python True ``` **Explanation**: The square roots are 2, 4, and 1 respectively, and their sum is 7, which is an integer. Example 2: **Input**: ```python numbers = [2, 3, 5] ``` **Output**: ```python False ``` **Explanation**: The sum of the square roots (√2 + √3 + √5) is not an integer. Example 3: **Input**: ```python numbers = [9, 16, 25] ``` **Output**: ```python True ``` **Explanation**: The square roots are 3, 4, and 5 respectively, and their sum is 12, which is an integer. # Implementation Hints 1. Iterate through the list and compute the sum of the square roots. 2. Check if the resulting sum is an integer. 3. Handle edge cases for lists containing zeros or non-integer sums.","solution":"import math def has_integer_square_root_sum(numbers: list) -> bool: Returns True if the sum of square roots of the elements in the list is an integer, False otherwise. Raises a TypeError if any element in the list is not an integer. if not all(isinstance(num, int) for num in numbers): raise TypeError(\\"All elements in the list must be integers\\") sum_of_roots = sum(math.sqrt(num) for num in numbers) return sum_of_roots.is_integer()"},{"question":"# Question Given a string `s` representing a valid XML-like structure, write a Python function `count_matching_pairs(s: str) -> int`. This function should return the number of pairs of matching opening and closing tags within the string. A matching pair is defined as an opening tag `<tag>` and its corresponding closing tag `</tag>` where `tag` is a sequence of alphanumeric characters. # Input - A string `s` (1 ≤ len(s) ≤ 10^5), where it is guaranteed that every opening tag `<tag>` has a corresponding closing tag `</tag>`. # Output - Return an integer representing the number of pairs of matching tags. # Example ```python >>> count_matching_pairs(\\"<a><b></b><c></c></a>\\") 3 ``` # Explanation In the input string, the matching tag pairs are: 1. `<a>` and `</a>` 2. `<b>` and `</b>` 3. `<c>` and `</c>` Thus, the function returns 3. # Constraints 1. The input string will only consist of valid well-formed XML-like syntax with a proper structure of nested tags. 2. The tags will only contain alphanumeric characters and no attributes or spaces. 3. The solution must handle the string efficiently, ensuring that it processes in linear time relative to the length of the string. # Tips - Utilize a stack data structure to keep track of opening tags and match them with corresponding closing tags. - Ensure to pop from the stack when a closing tag is found to confirm a pair. - Be mindful of edge cases and ensure the overall performance is optimal for the given constraints.","solution":"import re def count_matching_pairs(s: str) -> int: Returns the number of pairs of matching opening and closing tags in the given string. tag_pattern = re.compile(r\'</?([a-zA-Z0-9]+)>\') stack = [] count = 0 for match in tag_pattern.finditer(s): tag = match.group(1) if match.group(0).startswith(\'</\'): if stack and stack[-1] == tag: stack.pop() count += 1 else: stack.append(tag) return count"},{"question":"# Coding Assessment Question Objective: Create a function that extracts and formats phone numbers from a given list of contacts. Problem Statement: You need to implement a function `extract_phone_numbers(contacts: List[Dict[str, Any]]) -> List[str]` that processes a list of contact dictionaries and returns a list of formatted phone numbers. Each contact dictionary includes various information, including a phone number. The phone number should be extracted and formatted in the standard E.164 format. Input: - `extract_phone_numbers(contacts: List[Dict[str, Any]]) -> List[str]`: - A list of dictionaries, where each dictionary represents a contact with multiple fields, including a `phone` field containing the phone number as a string (which might include various delimiters and country codes). Output: - A list of strings, where each string is the phone number formatted in the standard E.164 format. Constraints: - The phone number field can contain spaces, dashes, or parentheses, and might be prefixed with a \\"+\\" for the country code. - Phone numbers must be valid to be included in the output list. - If the phone number is invalid, it should be skipped. Example: ```python >>> contacts = [ {\\"name\\": \\"Alice\\", \\"phone\\": \\"+1 (408) 555-1234\\"}, {\\"name\\": \\"Bob\\", \\"phone\\": \\"202-555-0191\\"}, {\\"name\\": \\"Charlie\\", \\"phone\\": \\"+44 7700 900555\\"}, {\\"name\\": \\"David\\", \\"phone\\": \\"invalid_number\\"} ] >>> extract_phone_numbers(contacts) [\'+14085551234\', \'+12025550191\', \'+447700900555\'] ``` Requirements: - Parse the phone numbers to remove spaces, dashes, and parentheses. - Ensure that the phone number is correctly prefixed with a \\"+\\" followed by the country code and the rest of the number. - Validate phone numbers for correctness (length, valid characters, etc.). - Handle any invalid or malformed phone numbers by skipping them.","solution":"import re from typing import List, Dict, Any def extract_phone_numbers(contacts: List[Dict[str, Any]]) -> List[str]: def format_phone_number(phone: str) -> str: # Remove spaces, dashes, and parentheses cleaned_phone = re.sub(r\\"[()s-]\\", \\"\\", phone) # Check if phone number is prefixed with \\"+\\" if not cleaned_phone.startswith(\\"+\\"): cleaned_phone = f\\"+1{cleaned_phone}\\" # Assuming default country code as +1 if not present # Validate the phone number format if re.match(r\\"^+d{10,15}\\", cleaned_phone): return cleaned_phone else: return None formatted_phone_numbers = [] for contact in contacts: phone = contact.get(\\"phone\\", \\"\\") formatted_phone = format_phone_number(phone) if formatted_phone: formatted_phone_numbers.append(formatted_phone) return formatted_phone_numbers"},{"question":"# Elevator System Simulation You are required to design and implement a simple simulation of an elevator system. The purpose of this task is to understand object-oriented programming by creating various classes that interact with each other, modeling the behavior of a real-world elevator system. The system includes: * An `Elevator` class that represents an elevator with a current position and a direction (up or down). * A `Building` class that consists of multiple elevators and floors. Function Signature ```python class Elevator: def __init__(self, id: int, current_floor: int = 0): # Initializes an elevator with a unique ID and its starting floor self.id = id self.current_floor = current_floor self.direction = \\"up\\" # Can be \\"up\\", \\"down\\", or \\"idle\\" def request(self, start_floor: int, end_floor: int): # Simulates an elevator request where the elevator needs to travel and stop at the requested floors pass def move(self): # Moves the elevator one floor in its current direction pass def __repr__(self): # Returns a string representation of the elevator\'s status return f\\"Elevator {self.id} at floor {self.current_floor} going {self.direction}\\" class Building: def __init__(self, floors: int, elevators: int): # Initializes the building with a given number of floors and elevators self.floors = floors self.elevators = [Elevator(id=i) for i in range(elevators)] def request_elevator(self, start_floor: int, end_floor: int) -> int: # Selects the best elevator to fulfill the request and returns its ID pass def step(self): # Advances the state of all elevators by one simulation step pass def __repr__(self): # Returns a string representation of all elevators in the building return \\"n\\".join(str(elevator) for elevator in self.elevators) ``` Input * `Building`: an instance of a building with a specified number of floors and elevators. * `Elevator`: an individual elevator with unique ID and initial floor position. Output * A string representation of the current status of all elevators in the building after a series of requests and moves. # Constraints * The building has between 2 and 100 floors. * The building has between 1 and 10 elevators. * The `request_elevator` method must efficiently determine the best elevator to handle a given request. # Examples 1. Initialize a building with 5 floors and 2 elevators: ```python building = Building(floors=5, elevators=2) ``` Output: ``` Elevator 0 at floor 0 going up Elevator 1 at floor 0 going up ``` 2. Make a request for an elevator from floor 1 to floor 3: ```python elevator_id = building.request_elevator(start_floor=1, end_floor=3) ``` Output: ``` Elevator 0 at floor 1 going up Elevator 1 at floor 0 going up ``` 3. Move all elevators one step: ```python building.step() ``` Output: ``` Elevator 0 at floor 2 going up Elevator 1 at floor 1 going up ``` 4. Final state of the building and its elevators: ```python print(building) ``` Output: ``` Elevator 0 at floor 3 going up Elevator 1 at floor 2 going up ``` # Instructions 1. Implement the `Elevator` class with methods to handle elevator requests and movement. 2. Implement the `Building` class with methods to handle building-wide elevator requests and simulate their steps. 3. Ensure that the system accurately models the movement of elevators between floors based on requests. Points to Consider * Handle cases where multiple requests are made simultaneously. * Make efficient decisions in `request_elevator` to minimize wait times. * Ensure the system scales logically with an increased number of floors and elevators. Good Luck!","solution":"class Elevator: def __init__(self, id: int, current_floor: int = 0): self.id = id self.current_floor = current_floor self.direction = \\"idle\\" # Can be \\"up\\", \\"down\\", or \\"idle\\" self.target_floors = [] # List of pending floors to stop at def request(self, start_floor: int, end_floor: int): if start_floor != self.current_floor: self.target_floors.append(start_floor) self.target_floors.append(end_floor) self.update_direction() def move(self): if not self.target_floors: self.direction = \\"idle\\" return next_floor = self.target_floors[0] if self.current_floor < next_floor: self.direction = \\"up\\" self.current_floor += 1 elif self.current_floor > next_floor: self.direction = \\"down\\" self.current_floor -= 1 if self.current_floor == next_floor: self.target_floors.pop(0) self.update_direction() def update_direction(self): if not self.target_floors: self.direction = \\"idle\\" elif self.current_floor < self.target_floors[0]: self.direction = \\"up\\" elif self.current_floor > self.target_floors[0]: self.direction = \\"down\\" def __repr__(self): return f\\"Elevator {self.id} at floor {self.current_floor} going {self.direction}\\" class Building: def __init__(self, floors: int, elevators: int): self.floors = floors self.elevators = [Elevator(id=i) for i in range(elevators)] def request_elevator(self, start_floor: int, end_floor: int) -> int: best_elevator = min(self.elevators, key=lambda e: abs(e.current_floor - start_floor)) best_elevator.request(start_floor, end_floor) return best_elevator.id def step(self): for elevator in self.elevators: elevator.move() def __repr__(self): return \\"n\\".join(str(elevator) for elevator in self.elevators)"},{"question":"# Coding Assessment Question Context You are developing a data processing module that requires the identification of \\"anagram groups\\" within a large dataset. An anagram group consists of strings that, when rearranged, contain exactly the same characters. Problem Statement Write a Python function `group_anagrams(words: list) -> list` that groups anagrams from a given list of words. Input Format * A list of strings representing the words. For example, [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]. Output Format * Return a list where each element is a list of words that are anagrams of each other. Constraints * Each string will consist of lowercase English letters. * The length of each string will be between 1 and 100. * The total number of strings will be between 1 and 10^5. Examples ```python >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\'eat\', \'tea\', \'ate\'], [\'tan\', \'nat\'], [\'bat\']] >>> group_anagrams([\\"\\"]) [[\'\']] >>> group_anagrams([\\"a\\"]) [[\'a\']] ``` Performance Requirements * The expected time complexity should be O(N*K log K), where N is the number of words and K is the maximum length of a word. * The expected space complexity should be O(N*K). Implementation Notes * You may use a dictionary to map sorted character sequences to their anagram groups. * Handle edge cases such as an empty list or list with one word.","solution":"def group_anagrams(words): Takes a list of words and groups them into lists of anagrams. :param words: List[str] :return: List[List[str]] from collections import defaultdict # Dictionary to hold sorted tuple of characters as key and list of anagrams as value anagrams_dict = defaultdict(list) for word in words: # Sort the word and use tuple of characters as a key sorted_word = tuple(sorted(word)) anagrams_dict[sorted_word].append(word) # Extract the groups of anagrams into a list of lists return list(anagrams_dict.values())"},{"question":"# Data Aggregator for Real-Time Analytics You are tasked with developing a data-aggregation service that periodically fetches data from multiple APIs, aggregates the results, and computes real-time analytics. This service is intended for a dashboard that displays various metrics to end-users. Your task is to implement a class `DataAggregator` which includes methods to: 1. **Fetch Data**: Obtain data from a list of provided APIs. 2. **Aggregate Data**: Combine and aggregate the fetched data in a meaningful way. 3. **Compute Metrics**: Calculate specific metrics based on the aggregated data. # Requirements 1. Implement the class `DataAggregator` with the following methods: * **`__init__(self, apis: List[str], aggregation_interval: int = 60)`**: * Initialize with a list of API URLs and optional aggregation interval (default = 60 seconds). * Maintain an internal state to store the aggregated data. * **`fetch_data(self) -> List[dict]`**: * Fetch data from each provided API URL. * Handle network errors, API errors, and ensure data consistency. * **`aggregate_data(self, data_list: List[dict]) -> dict`**: * Combine data from multiple APIs into a single aggregated result. * Ensure meaningful aggregation (e.g., summing up values, computing averages). * **`compute_metrics(self, aggregated_data: dict) -> dict`**: * Calculate specific metrics, such as averages, maximums, minimums, etc., based on the aggregated data. 2. Consider edge cases and error handling, including API failures, inconsistent data, and network delays. # Constraints * Data must be fetched from each API within a specified timeout (e.g., 10 seconds). * The aggregation interval is provided in seconds (default is 60 seconds). * The structure of the API response and specific metrics required will be explained in examples. # Example Usage ```python apis = [ \\"https://api.example1.com/data\\", \\"https://api.example2.com/data\\" ] aggregator = DataAggregator(apis, aggregation_interval=120) # Fetch, aggregate, and compute metrics for the data raw_data = aggregator.fetch_data() aggregated_data = aggregator.aggregate_data(raw_data) metrics = aggregator.compute_metrics(aggregated_data) print(f\\"Computed Metrics: {metrics}\\") ``` # Example API Response and Metrics Assume each API responds with a JSON object containing a list of integers representing different data points. Example API Response ```json { \\"data\\": [4, 8, 15, 16, 23, 42] } ``` Aggregated Data Combine the data lists from each API. ```json [ 4, 8, 15, 16, 23, 42, 4, 8, 15, 16, 23, 42 ] ``` Computed Metrics Calculate specific metrics like average, maximum, minimum, etc. ```json { \\"average\\": 19.75, \\"maximum\\": 42, \\"minimum\\": 4 } ``` Implement the `DataAggregator` class as specified, ensuring robust handling of various scenarios, and test it thoroughly.","solution":"import requests from typing import List, Dict import statistics class DataAggregator: def __init__(self, apis: List[str], aggregation_interval: int = 60): self.apis = apis self.aggregation_interval = aggregation_interval self.data = [] def fetch_data(self) -> List[dict]: data_list = [] for api in self.apis: try: response = requests.get(api, timeout=10) response.raise_for_status() data_list.append(response.json()) except requests.RequestException as e: print(f\\"Error fetching data from {api}: {e}\\") return data_list def aggregate_data(self, data_list: List[dict]) -> dict: aggregated_data = {\\"data\\": []} for data in data_list: if \\"data\\" in data: aggregated_data[\\"data\\"].extend(data[\\"data\\"]) return aggregated_data def compute_metrics(self, aggregated_data: dict) -> dict: if \\"data\\" not in aggregated_data or not aggregated_data[\\"data\\"]: return {\\"average\\": None, \\"maximum\\": None, \\"minimum\\": None} data_points = aggregated_data[\\"data\\"] metrics = { \\"average\\": statistics.mean(data_points), \\"maximum\\": max(data_points), \\"minimum\\": min(data_points), } return metrics"},{"question":"# Logistic Regression Classifier Coding Question You are given a dataset containing various attributes of emails and a binary label representing whether an email is spam (1) or not spam (0). Your task is to implement a function using `Logistic Regression` that trains on these features to classify emails. Ensure to follow these specific steps for implementation: **Function Implementation:** 1. **Function Signature**: `def logistic_regression_classifier(data: dict) -> float:` 2. **Input**: The input will be a dictionary with two keys, - `data`: A list of lists where each inner list contains the attributes of an email. - `target`: A list of binary labels corresponding to each list of attributes in `data`. 3. **Process**: * Split the dataset into training and testing sets using a 70-30 ratio for training and testing respectively. * Train the Logistic Regression classifier using the training dataset. * Predict the labels for the test dataset. * Compute the accuracy of the model. 4. **Output**: A float value representing the accuracy of the model on the test dataset. **Constraints**: * Perform all necessary preprocessing, such as scaling or normalization, within the function. * Use appropriate Logistic Regression hyperparameters to avoid overfitting and ensure robust performance. * Evaluate the model performance using accuracy. **Example**: ```python >>> data = { ... \\"data\\": [ ... [0.0, 0.2, 0.1, 0.0, 0.4, 0.3], ... [0.1, 0.3, 0.0, 0.0, 0.2, 0.8], ... # Add more feature sets ... ], ... \\"target\\": [0, 1, # Add more target labels ... ] ... } >>> logistic_regression_classifier(data) 0.85 # Example output representing the accuracy of the model ``` **Note**: The example provided in the main function of the code snippet is based on a simplified email spam detection dataset. Refer to this example for guidance on processing and feature extraction. Good luck, and ensure your solution is well-tested across multiple scenarios to validate its robustness!","solution":"import numpy as np from sklearn.model_selection import train_test_split from sklearn.linear_model import LogisticRegression from sklearn.preprocessing import StandardScaler from sklearn.metrics import accuracy_score def logistic_regression_classifier(data: dict) -> float: # Extract features and labels from the input dict X = np.array(data[\'data\']) y = np.array(data[\'target\']) # Split the data into training and testing sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42) # Standardize the features scaler = StandardScaler() X_train = scaler.fit_transform(X_train) X_test = scaler.transform(X_test) # Initialize and train the Logistic Regression model model = LogisticRegression(random_state=42, max_iter=1000) model.fit(X_train, y_train) # Predict the labels for the test dataset y_pred = model.predict(X_test) # Compute the accuracy of the model accuracy = accuracy_score(y_test, y_pred) return accuracy"},{"question":"# Problem Statement: Matrix Diagonal Sum Context You are tasked with developing a function that computes the sum of the diagonals in a given square matrix. This type of problem is common in various applications including image processing, scientific computations, and linear algebra. Task Implement the function `diagonal_sum(matrix: list) -> dict` that computes the sum of the primary and secondary diagonals of a square matrix. Function signature ```python def diagonal_sum(matrix: list) -> dict: ``` Input - `matrix`: A list of lists of integers representing a square matrix (i.e., each inner list has the same length as the number of inner lists). Output - A dictionary with two keys `\\"primary_diagonal_sum\\"` and `\\"secondary_diagonal_sum\\"`, where the values are the sums of the primary and secondary diagonals of the matrix respectively. Constraints 1. If the input matrix is not square, raise a `ValueError` indicating \\"Input must be a square matrix\\". 2. Each element in the matrix must be an integer. Examples ```python diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) # Output: {\\"primary_diagonal_sum\\": 15, \\"secondary_diagonal_sum\\": 15} diagonal_sum([[5, 1, 3, 2], [0, 4, 0, 1], [7, 6, 3, 8], [2, 2, 6, 1]]) # Output: {\\"primary_diagonal_sum\\": 13, \\"secondary_diagonal_sum\\": 10} diagonal_sum([[4]]) # Output: {\\"primary_diagonal_sum\\": 4, \\"secondary_diagonal_sum\\": 4} diagonal_sum([[1, 2], [3, 4, 5]]) # Raises ValueError: Input must be a square matrix diagonal_sum([[1, \'a\'], [3, 4]]) # Raises ValueError: All elements of the matrix must be integers ```","solution":"def diagonal_sum(matrix: list) -> dict: Returns the sum of the primary and secondary diagonals of a square matrix. Args: matrix (list): A list of lists of integers representing the square matrix. Returns: dict: A dictionary containing the sums of the primary and secondary diagonals. Raises: ValueError: If the input matrix is not a square matrix or contains non-integer elements. if not all(isinstance(row, list) and all(isinstance(el, int) for el in row) for row in matrix): raise ValueError(\\"All elements of the matrix must be integers\\") n = len(matrix) if not all(len(row) == n for row in matrix): raise ValueError(\\"Input must be a square matrix\\") primary_diagonal_sum = 0 secondary_diagonal_sum = 0 for i in range(n): primary_diagonal_sum += matrix[i][i] secondary_diagonal_sum += matrix[i][n-1-i] return { \\"primary_diagonal_sum\\": primary_diagonal_sum, \\"secondary_diagonal_sum\\": secondary_diagonal_sum }"},{"question":"# Intersection of Two Linked Lists Given two singly linked lists, write a function to identify their intersection node. The intersection is defined as the node at which the two lists converge and share the same reference. If the two linked lists have no intersection, return `None`. # Input and Output Formats: - **Input**: * Two linked lists represented by their heads `headA` and `headB`. - **Output**: * The intersecting node or `None` if there is no intersection. # Example: Consider the following linked lists: List A: 3 -> 7 -> 8 -> 10 List B: 99 -> 1 -> 8 -> 10 The intersection point is the node with value `8` because from this point onwards, the lists are identical. ```python class ListNode: def __init__(self, x): self.val = x self.next = None def getIntersectionNode(headA: ListNode, headB: ListNode) -> ListNode: Determine the intersection point of two singly linked lists. if not headA or not headB: return None # Pointers to traverse the lists currentA, currentB = headA, headB # Traverse both lists while currentA != currentB: currentA = currentA.next if currentA else headB currentB = currentB.next if currentB else headA return currentA # Helper function to create a linked list from a list def createLinkedList(elements): head = ListNode(elements[0]) current = head for element in elements[1:]: current.next = ListNode(element) current = current.next return head # Helper function to attach two lists def attachLists(headA, lengthA, headB, lengthB, intersectValue): currentA, currentB = headA, headB while lengthA > 1: currentA = currentA.next lengthA -= 1 while lengthB > 0: currentB = currentB.next lengthB -= 1 currentA.next = currentB # Tests # Creating lists # List A: 3 -> 7 -> 8 -> 10 # List B: 99 -> 1 -> 8 -> 10 headA = createLinkedList([3, 7, 8, 10]) headB = createLinkedList([99, 1]) attachLists(headB, 2, headA, 3, 8) # Test intersection function intersectNode = getIntersectionNode(headA, headB) assert intersectNode.val == 8, f\\"Expected intersection at 8, got {intersectNode.val} instead\\" ``` # Note: - You should maintain the original structures of the lists during the entire duration of the function. - The algorithm should run in O(n + m) time, where n and m are the lengths of the respective lists. - You are allowed to use O(1) extra memory. With this question, you will test the candidate\'s ability to manipulate linked lists, tackle pointer-based problems, and handle edge cases such as lists of different lengths or no intersection.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def getIntersectionNode(headA: ListNode, headB: ListNode) -> ListNode: Determine the intersection point of two singly linked lists. if not headA or not headB: return None # Pointers to traverse the lists currentA, currentB = headA, headB # Traverse both lists while currentA != currentB: currentA = currentA.next if currentA else headB currentB = currentB.next if currentB else headA return currentA"},{"question":"# Coding Assessment Question: Find Dijkstra\'s Shortest Path Distance Objective Given a graph represented as an adjacency matrix and a starting node, compute the shortest path distances from the starting node to all other nodes in the graph. Task Write a function `dijkstra_shortest_path(graph: List[List[int]], start: int) -> List[int]` which takes: 1. A 2D list `graph` representing a weighted, directed graph where `graph[i][j]` specifies the weight of the edge from node `i` to node `j`. A value of `-1` indicates no direct edge. 2. An integer `start` representing the index of the starting node. Your function should return a list of integers representing the shortest path distances from the starting node to every other node. If a node is not reachable from the starting node, the corresponding distance should be `inf`. Input - A 2D list `graph` of size `n x n` (1 ≤ n ≤ 100), where each element `graph[i][j]` is an integer representing the edge weight or `-1` for no edge. - An integer `start` (0 ≤ start < n) representing the starting node. Output Format - A list of length `n` where the i-th element represents the shortest path distance from the start node to the i-th node. Use `float(\'inf\')` for unreachable nodes. Example ```python graph = [ [0, 4, -1, -1, -1, -1, -1, 8, -1], [4, 0, 8, -1, -1, -1, -1, 11, -1], [-1, 8, 0, 7, -1, 4, -1, -1, 2], [-1, -1, 7, 0, 9, 14, -1, -1, -1], [-1, -1, -1, 9, 0, 10, -1, -1, -1], [-1, -1, 4, 14, 10, 0, 2, -1, -1], [-1, -1, -1, -1, -1, 2, 0, 1, 6], [8, 11, -1, -1, -1, -1, 1, 0, 7], [-1, -1, 2, -1, -1, -1, 6, 7, 0] ] start = 0 assert dijkstra_shortest_path(graph, start) == [0, 4, 12, 19, 21, 11, 9, 8, 14] ``` Constraints Use efficient algorithms to manage the computations as the input size may reach upper limits. Guidelines - Implement Dijkstra\'s algorithm efficiently for the given graph. - Handle the adjacency matrix input format appropriately. - Ensure the solution is scalable and handles edge cases, such as graphs with no edges or nodes that are not reachable. Code Snippet ```python from typing import List import heapq def dijkstra_shortest_path(graph: List[List[int]], start: int) -> List[int]: n = len(graph) distances = [float(\'inf\')] * n distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor in range(n): if graph[current_node][neighbor] != -1: distance = graph[current_node][neighbor] new_distance = current_distance + distance if new_distance < distances[neighbor]: distances[neighbor] = new_distance heapq.heappush(priority_queue, (new_distance, neighbor)) return distances # Example usage graph = [ [0, 4, -1, -1, -1, -1, -1, 8, -1], [4, 0, 8, -1, -1, -1, -1, 11, -1], [-1, 8, 0, 7, -1, 4, -1, -1, 2], [-1, -1, 7, 0, 9, 14, -1, -1, -1], [-1, -1, -1, 9, 0, 10, -1, -1, -1], [-1, -1, 4, 14, 10, 0, 2, -1, -1], [-1, -1, -1, -1, -1, 2, 0, 1, 6], [8, 11, -1, -1, -1, -1, 1, 0, 7], [-1, -1, 2, -1, -1, -1, 6, 7, 0] ] start = 0 print(dijkstra_shortest_path(graph, start)) # Should output: [0, 4, 12, 19, 21, 11, 9, 8, 14] ```","solution":"from typing import List import heapq def dijkstra_shortest_path(graph: List[List[int]], start: int) -> List[int]: Implements Dijkstra\'s algorithm to find the shortest path distances from the start node to all other nodes in the graph. Parameters: graph (List[List[int]]): 2D list representing the adjacency matrix of the graph. graph[i][j] specifies the weight of the edge from node i to node j. A value of -1 indicates no direct edge. start (int): The index of the starting node. Returns: List[int]: A list where the i-th element represents the shortest path distance from the start node to the i-th node. If a node is not reachable, the corresponding distance is float(\'inf\'). n = len(graph) distances = [float(\'inf\')] * n distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor in range(n): if graph[current_node][neighbor] != -1: distance = graph[current_node][neighbor] new_distance = current_distance + distance if new_distance < distances[neighbor]: distances[neighbor] = new_distance heapq.heappush(priority_queue, (new_distance, neighbor)) return distances"},{"question":"# Problem Statement You are working for an airline company that needs a scheduling tool to manage flight reservations effectively. Recently, they have realized that their flight schedule includes various overlapping flights which cause confusion among the staff and passengers. Your task is to write a function that merges overlapping flight intervals and provides a clear, non-overlapping schedule. For example, if a flight is scheduled from 10:00 to 12:00 and another from 11:00 to 13:00, these should be merged into a single interval from 10:00 to 13:00. # Implementation and Constraints 1. **Function Signature**: ```python def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: ``` 2. **Inputs**: * **intervals** (`List[Tuple[int, int]]`): A list of tuples where each tuple `(start, end)` represents the start and end time of a flight interval. 3. **Outputs**: * Returns a list of tuples representing the merged intervals, sorted by the start time. 4. **Constraints**: * The start and end times are given in 24-hour \\"HHMM\\" format. * Start and end times will be valid integer values between `0000` and `2359`. * End time should always be greater than the start time for each interval. * The intervals list can have zero or more intervals. * Intervals must be merged if they overlap or are contiguous. # Example Usage ```python # Example 1: merge_intervals([(1000, 1200), (1130, 1245), (1400, 1500)]) # Output: [(1000, 1245), (1400, 1500)] # Example 2: merge_intervals([(900, 1100), (1100, 1200), (1215, 1315), (1300, 1330)]) # Output: [(900, 1200), (1215, 1330)] # Example 3: merge_intervals([(2330, 2359), (2335, 2345)]) # Output: [(2330, 2359)] ``` # Testing * Write additional tests to cover edge cases such as empty lists, single interval lists, contiguous intervals, and all overlapping intervals. * Ensure the function handles times around midnight correctly.","solution":"from typing import List, Tuple def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: if not intervals: return [] intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_end = merged_intervals[-1][1] if current[0] <= last_end: merged_intervals[-1] = (merged_intervals[-1][0], max(last_end, current[1])) else: merged_intervals.append(current) return merged_intervals"},{"question":"Problem Statement # Context Your team is tasked with developing a simplified spell checker for text documents. One component of this is identifying the most frequent words in a text that could be potential dictionary entries. Before implementing a full spell-checking algorithm, you need to write a function that processes the text and provides a list of the most frequent words, excluding a specified set of common stopwords. # Task Write a function `top_k_frequent_words` that identifies the `k` most frequent words in a given text while excluding a list of stopwords. The function should return a list of the top `k` frequent words sorted by their frequency in descending order. If two words have the same frequency, they should be ordered alphabetically. # Requirements 1. The function should be named `top_k_frequent_words`. 2. The function should take three parameters: - `text` (str): The input text from which to identify the most frequent words. - `stopwords` (list[str]): A list of common stopwords to be excluded. - `k` (int): The number of top frequent words to return. 3. The function should return a list of strings, each string being one of the top `k` frequent words. 4. Words are case-insensitive, and the function should return words in lowercase. # Function Signature ```python def top_k_frequent_words(text: str, stopwords: list[str], k: int) -> list[str]: pass ``` # Constraints * The length of `text` will be between 0 and 10^5 characters. * The `stopwords` list will have between 0 and 10^3 words. * The value of `k` will be a positive integer and less than or equal to the number of unique non-stopwords in the text. # Example ```python assert top_k_frequent_words(\\"The quick brown fox jumps over the lazy dog\\", [\\"the\\"], 3) == [\\"brown\\", \\"dog\\", \\"fox\\"] assert top_k_frequent_words(\\"To be, or not to be, that is the question\\", [\\"to\\", \\"be\\", \\"or\\", \\"not\\", \\"that\\", \\"is\\", \\"the\\"], 2) == [\\"question\\"] assert top_k_frequent_words(\\"\\", [\\"a\\", \\"list\\", \\"of\\", \\"stopwords\\"], 5) == [] assert top_k_frequent_words(\\"Repeat repeat REPEAT\\", [\\"repeat\\"], 1) == [] assert top_k_frequent_words(\\"A a a a B B C C C\\", [\\"a\\"], 2) == [\\"c\\", \\"b\\"] ``` # Notes - Words should be defined as contiguous sequences of alphabetic characters. - The function should be efficient and capable of handling large texts within the given constraints. - Use appropriate data structures to ensure the function operates within reasonable time and space complexity.","solution":"import re from collections import Counter def top_k_frequent_words(text: str, stopwords: list[str], k: int) -> list[str]: Identify the `k` most frequent words in the given `text`, excluding any words in the `stopwords` list. :param text: The input text from which to identify the most frequent words. :param stopwords: A list of common stopwords to be excluded. :param k: The number of top frequent words to return. :return: A list of the top `k` frequent words sorted by their frequency in descending order. If two words have the same frequency, they should be ordered alphabetically. # Convert text to lowercase to ensure words are counted in a case-insensitive way text = text.lower() # Find all words in the text using regex to match alphabetic sequences words = re.findall(r\'b[a-z]+b\', text) # Remove stopwords from the words list filtered_words = [word for word in words if word not in stopwords] # Count the frequencies of each word word_count = Counter(filtered_words) # Get the top k elements sorted by frequency (highest first) and alphabetically for ties most_common = word_count.most_common() most_common.sort(key=lambda x: (-x[1], x[0])) # Sort by frequency desc and then alphabetically # Extract only the words, up to k elements top_k_words = [word for word, count in most_common[:k]] return top_k_words"},{"question":"# Graph Cycle Detection Using Depth-First Search Given a directed graph represented as an adjacency list, write a function to detect if there is a cycle in the graph using Depth-First Search (DFS). # Input Format * An integer `n` representing the number of vertices in the graph. * A list of tuples `edges` where each tuple `(u, v)` indicates a directed edge from vertex `u` to vertex `v`. # Output Format * A boolean value: * `True` if there is a cycle in the graph. * `False` if there is no cycle in the graph. # Constraints * 1 ≤ n ≤ 1000 * 0 ≤ len(edges) ≤ n*(n-1) where no self-loops are allowed. # Performance Requirements * Aim for an efficient implementation as the runtime should be within acceptable limits for the given constraints. # Example ```python def graph_cycle_detection(n, edges): def dfs(vertex, visited, rec_stack): # Mark the current node as visited and add it to the recursion stack visited[vertex] = True rec_stack[vertex] = True # Recur for all neighbours for neighbour in adj_list[vertex]: if not visited[neighbour]: if dfs(neighbour, visited, rec_stack): return True elif rec_stack[neighbour]: return True # Remove the vertex from recursion stack rec_stack[vertex] = False return False # Create adjacency list of the graph adj_list = {i: [] for i in range(n)} for u, v in edges: adj_list[u].append(v) # Mark all the vertices as not visited and not part of recursion stack visited = [False] * n rec_stack = [False] * n # Call the recursive helper function to detect cycle in different DFS trees for node in range(n): if not visited[node]: if dfs(node, visited, rec_stack): return True return False # Example usage: n = 4 edges = [(0, 1), (1, 2), (2, 0), (2, 3)] print(graph_cycle_detection(n, edges)) # Output: True edges = [(0, 1), (1, 2), (2, 3)] print(graph_cycle_detection(n, edges)) # Output: False ``` Implement the function `graph_cycle_detection` to determine if a cycle is present in the given directed graph.","solution":"def graph_cycle_detection(n, edges): def dfs(vertex, visited, rec_stack): # Mark the current node as visited and add it to the recursion stack visited[vertex] = True rec_stack[vertex] = True # Recur for all neighbours for neighbour in adj_list[vertex]: if not visited[neighbour]: if dfs(neighbour, visited, rec_stack): return True elif rec_stack[neighbour]: return True # Remove the vertex from recursion stack rec_stack[vertex] = False return False # Create adjacency list of the graph adj_list = {i: [] for i in range(n)} for u, v in edges: adj_list[u].append(v) # Mark all the vertices as not visited and not part of recursion stack visited = [False] * n rec_stack = [False] * n # Call the recursive helper function to detect cycle in different DFS trees for node in range(n): if not visited[node]: if dfs(node, visited, rec_stack): return True return False"},{"question":"# Problem Statement In image editing processes, it is often necessary to apply transformations to images. One such transformation involves rotating the pixel values of the image by 90 degrees either clockwise or counterclockwise. Given a matrix representing an image, your task is to implement functions that rotate this matrix 90 degrees in both clockwise and counterclockwise directions. 1. **Rotate Clockwise**: Implement a function to rotate a given NxN matrix 90 degrees clockwise. 2. **Rotate Counterclockwise**: Implement a function to rotate a given NxN matrix 90 degrees counterclockwise. # Function Signatures ```python def rotate_clockwise(matrix: list[list[int]]) -> list[list[int]]: pass def rotate_counterclockwise(matrix: list[list[int]]) -> list[list[int]]: pass ``` # Input/Output Formats * **rotate_clockwise**: - **Input**: A list of lists of integers representing an NxN matrix. - **Output**: A list of lists of integers representing the matrix rotated 90 degrees clockwise. * **rotate_counterclockwise**: - **Input**: A list of lists of integers representing an NxN matrix. - **Output**: A list of lists of integers representing the matrix rotated 90 degrees counterclockwise. # Constraints * The matrix will always be square (NxN). * `1 <= N <= 1000`. * Each element in the matrix is an integer such that `-10^9 <= matrix[i][j] <= 10^9`. # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert rotate_clockwise(matrix) == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_counterclockwise(matrix) == [ [3, 6, 9], [2, 5, 8], [1, 4, 7] ] ``` # Implementation Notes 1. **Clockwise Rotation**: To rotate the matrix 90 degrees clockwise, transpose the matrix and then reverse each row. 2. **Counterclockwise Rotation**: To rotate the matrix 90 degrees counterclockwise, transpose the matrix and then reverse each column.","solution":"def rotate_clockwise(matrix: list[list[int]]) -> list[list[int]]: Rotate the given NxN matrix 90 degrees clockwise. n = len(matrix) result = [] for i in range(n): new_row = [matrix[n - j - 1][i] for j in range(n)] result.append(new_row) return result def rotate_counterclockwise(matrix: list[list[int]]) -> list[list[int]]: Rotate the given NxN matrix 90 degrees counterclockwise. n = len(matrix) result = [] for i in range(n): new_row = [matrix[j][n - i - 1] for j in range(n)] result.append(new_row) return result"},{"question":"# Order Processor - Efficient Transaction Handling In this task, you will improve the efficiency of an order processing system by implementing optimized algorithms for managing and processing customer orders. The core functionality involves maintaining and processing a queue of orders such that the system can efficiently add new orders, retrieve and remove the highest priority order, and update order statuses. # Requirements 1. Implement an optimized version of the `add_order` function to insert a new order into a priority queue, where orders are prioritized based on their urgency and timestamp. 2. Implement an optimized version of the `process_order` function that retrieves and removes the highest priority order from the queue. 3. Implement an `update_order_status` function that efficiently updates the status of a specific order in the queue. # Input and Output Formats `add_order` * **Input**: - `orders`: A list of tuples representing the current orders in the queue. - `order`: A tuple representing the new order to be added. The tuple should include (order_id, urgency_level, timestamp). * **Output**: - A new list containing all orders in the queue with the new order added, sorted by urgency and timestamp. `process_order` * **Input**: - `orders`: A list of tuples representing the current orders in the queue. * **Output**: - A tuple representing the highest priority order, and a new list with the highest priority order removed from the queue. `update_order_status` * **Input**: - `orders`: A list of tuples representing the current orders in the queue. - `order_id`: An integer representing the ID of the order to be updated. - `new_status`: A string representing the new status of the order. * **Output**: - A new list containing all orders with the specified order\'s status updated. # Constraints - Orders should be prioritized first by urgency level (higher number indicates higher urgency) and then by timestamp (earlier timestamp is higher priority). - Assume that order IDs are unique. - Input orders will be well-formed with consistent data types. # Example ```python # Example usage of the `add_order` orders = [(1, 2, 1615295057, \'pending\'), (2, 1, 1615295058, \'pending\')] new_order = (3, 3, 1615295059, \'pending\') result = add_order(orders, new_order) # Expected Output: [(3, 3, 1615295059, \'pending\'), (1, 2, 1615295057, \'pending\'), (2, 1, 1615295058, \'pending\')] # Example usage of the `process_order` result, updated_orders = process_order(orders) # Expected Output: ((3, 3, 1615295059, \'pending\'), [(1, 2, 1615295057, \'pending\'), (2, 1, 1615295058, \'pending\')]) # Example usage of the `update_order_status` orders = [(1, 2, 1615295057, \'pending\'), (2, 1, 1615295058, \'pending\')] result = update_order_status(orders, 1, \'completed\') # Expected Output: [(1, 2, 1615295057, \'completed\'), (2, 1, 1615295058, \'pending\')] ``` # Your Task: 1. Enhance the `add_order` function to use a heap or other efficient data structure for maintaining priority queue operations. 2. Implement the `process_order` function using the same data structure to ensure efficient removal of the highest priority order. 3. Implement the `update_order_status` function that efficiently updates the status of a specific order without compromising the order of the queue.","solution":"from heapq import heappush, heappop def add_order(orders, order): Add a new order to the list of orders with priority sorting. heap = [] for o in orders: heappush(heap, (-o[1], o[2], o)) # We use negative urgency for max-heap behavior heappush(heap, (-order[1], order[2], order)) return [heappop(heap)[2] for _ in range(len(heap))] def process_order(orders): Process and remove the highest priority order. if not orders: return None, orders heap = [] for o in orders: heappush(heap, (-o[1], o[2], o)) # We use negative urgency for max-heap behavior highest_priority_order = heappop(heap)[2] return highest_priority_order, [heappop(heap)[2] for _ in range(len(heap))] def update_order_status(orders, order_id, new_status): Update the status of an existing order by order_id. updated_orders = [] for o in orders: if o[0] == order_id: updated_orders.append((o[0], o[1], o[2], new_status)) else: updated_orders.append(o) return updated_orders"},{"question":"# Scenario You are a software developer tasked with improving the customer experience for an online shopping platform. Users frequently leave items in their shopping carts without making a purchase. To address this, you need to implement a feature that identifies users with abandoned carts and sends them automated reminders. The platform stores shopping cart data, including item details and timestamps, in a relational database. # Task Write a function that identifies users with items in their cart that have been inactive (i.e., not updated) for more than a specified number of days. The function should return a list of user IDs whose carts have been inactive. # Function Signature ```python def identify_idle_carts(days_inactive: int) -> list: pass ``` # Input and Output * **Input**: * `days_inactive`: An integer representing the number of days a cart should be inactive to be considered abandoned. * **Output**: * Returns a list of user IDs whose carts have been inactive for more than the specified number of days. # Constraints * Assume the database schema has a table `carts` with the following columns: * `user_id`: An integer representing the user\'s ID. * `item_id`: An integer representing the item\'s ID in the cart. * `last_updated`: A timestamp representing the last time the cart was updated. * Assume the current date is accessible and can be utilized in your function. * The function should handle large datasets efficiently. # Example Assume the current date is `2023-10-18`. ```python days_inactive = 7 # Example return value: Users with carts inactive since before 2023-10-11. result = identify_idle_carts(days_inactive) print(result) # Expected to print a list, e.g., [123, 456, 789] indicating user IDs ``` # Performance Requirements Ensure that the function runs efficiently, even with a large number of users and cart items. Optimize the database query to handle potentially large datasets and minimize the execution time.","solution":"from datetime import datetime, timedelta import sqlite3 def identify_idle_carts(days_inactive: int) -> list: Identifies users with carts that have been inactive for more than the specified number of days. Params: - days_inactive (int): The number of days of inactivity to consider a cart abandoned. Returns: - list: A list of user IDs with inactive carts. # Establish a connection to the database (for this example, assuming SQLite) conn = sqlite3.connect(\'shopping_platform.db\') cursor = conn.cursor() # Calculate the cutoff date based on the current date current_date = datetime.now() cutoff_date = current_date - timedelta(days=days_inactive) # Query to find users with carts that have been inactive since the cutoff date query = SELECT DISTINCT user_id FROM carts WHERE last_updated < ? cursor.execute(query, (cutoff_date,)) results = cursor.fetchall() # Close the database connection conn.close() # Extract user_ids from the results user_ids = [row[0] for row in results] return user_ids"},{"question":"# Introduction In a digital music player, certain songs are grouped into playlists based on specific criteria. One common task is to find and list the most popular songs based on user play counts. # Task Write a function named `top_songs(play_counts: Dict[str, int], n: int) -> List[Tuple[str, int]]` that takes a dictionary representing song play counts and returns the top `n` songs with the highest play counts. # Requirements * **Function Signature**: `def top_songs(play_counts: Dict[str, int], n: int) -> List[Tuple[str, int]]` * **Input**: - A dictionary `play_counts` where keys are song titles (strings) and values are play counts (integers). - An integer `n` representing the number of top songs to return. * **Output**: A list of tuples, where each tuple contains a song title and its play count, sorted in descending order by play count. If there is a tie in play counts, preserve the original order from the dictionary. # Constraints 1. If `n` is greater than the number of unique songs in `play_counts`, return all songs sorted by play counts. 2. If `n` is zero or the dictionary is empty, return an empty list. 3. Assume that the play counts are non-negative integers. 4. Handle case-sensitivity as distinct songs. # Examples ```python >>> top_songs({\\"SongA\\": 120, \\"SongB\\": 200, \\"SongC\\": 150}, 2) [(\'SongB\', 200), (\'SongC\', 150)] >>> top_songs({\\"Rock\\": 300, \\"Pop\\": 300, \\"Jazz\\": 100}, 1) [(\'Rock\', 300)] # Note: \\"Rock\\" comes before \\"Pop\\" in case of a tie. >>> top_songs({\\"Classic\\": 45, \\"Indie\\": 60, \\"Pop\\": 55, \\"Punk\\": 60}, 3) [(\'Indie\', 60), (\'Punk\', 60), (\'Pop\', 55)] >>> top_songs({}, 5) [] >>> top_songs({\\"Track1\\": 50}, 0) [] >>> top_songs({\\"SongA\\": 100}, 1) [(\'SongA\', 100)] ``` # Additional Notes * Test your function with various cases to ensure that ties are handled correctly and the original order is preserved if there\'s a tie in play counts. * Consider performance implications if the number of songs is large when determining the top `n`.","solution":"def top_songs(play_counts, n): Returns the top n songs with the highest play counts. Parameters: play_counts (Dict[str, int]): A dictionary where keys are song titles and values are play counts. n (int): The number of top songs to return. Returns: List[Tuple[str, int]]: A list of tuples sorted in descending order by play count, each tuple contains a song title and its play count. # Sort the dictionary items by play counts in descending order, preserving original order in case of ties sorted_songs = sorted(play_counts.items(), key=lambda item: (-item[1], list(play_counts.keys()).index(item[0]))) # Return the top n songs return sorted_songs[:n]"},{"question":"# Question Background Graph traversal algorithms are essential in computer science for searching or traversing nodes in a graph. Breadth-First Search (BFS) and Depth-First Search (DFS) are two fundamental search algorithms with various applications such as finding the shortest path, solving puzzles and games, and analyzing social networks. Problem Implement two functions `bfs(graph, start)` and `dfs(graph, start)` that perform Breadth-First Search and Depth-First Search respectively on a graph. The graph will be represented as an adjacency list. Function Signatures ```python from typing import List, Dict def bfs(graph: Dict[int, List[int]], start: int) -> List[int]: Perform Breadth-First Search on the graph starting from the \'start\' node. :param graph: A dictionary representing the graph where keys are node IDs and values are lists of connected nodes. :param start: The starting node for the BFS traversal. :return: A list of nodes in the order they are visited. pass def dfs(graph: Dict[int, List[int]], start: int) -> List[int]: Perform Depth-First Search on the graph starting from the \'start\' node. :param graph: A dictionary representing the graph where keys are node IDs and values are lists of connected nodes. :param start: The starting node for the DFS traversal. :return: A list of nodes in the order they are visited. pass ``` Requirements - The `bfs` function should use a queue to explore the neighbours of each node, ensuring nodes are explored level by level. - The `dfs` function should utilize a stack (or recursion) to explore nodes by diving deep before backtracking. - Both functions should avoid revisiting nodes to prevent infinite loops. - Return the list of nodes in the order they are visited. Constraints - The graph is connected, meaning there\'s a path between any two nodes. - Nodes are labeled with unique integers. - Node values and graph structure must be handled efficiently. - Assumed range for node labels: [0, 1000] - Graph size: Maximum of 1000 nodes. Example ```python graph = { 0: [1, 2], 1: [0, 3, 4], 2: [0, 5], 3: [1], 4: [1, 6], 5: [2], 6: [4] } print(bfs(graph, 0)) # Output: [0, 1, 2, 3, 4, 5, 6] print(dfs(graph, 0)) # Output: [0, 1, 3, 4, 6, 2, 5] ``` In this example, the `bfs` function should return the nodes in the order they are visited using Breadth-First Search, and the `dfs` function should return the nodes in the order they are visited using Depth-First Search.","solution":"from typing import List, Dict def bfs(graph: Dict[int, List[int]], start: int) -> List[int]: visited = [] queue = [start] visited_set = set() while queue: node = queue.pop(0) if node not in visited_set: visited.append(node) visited_set.add(node) queue.extend(graph[node]) return visited def dfs(graph: Dict[int, List[int]], start: int) -> List[int]: visited = [] stack = [start] visited_set = set() while stack: node = stack.pop() if node not in visited_set: visited.append(node) visited_set.add(node) stack.extend(reversed(graph[node])) return visited"},{"question":"# Coding Assessment Question Context You are developing an application to recommend restaurants to users based on their preferences. You have access to user ratings for various restaurants, and you want to implement a collaborative filtering algorithm to predict the ratings a user might give to restaurants they haven\'t yet reviewed. Specifically, you will use a simple user-based collaborative filtering approach. Task Write a function `predict_user_rating` that, given a user-item rating matrix, a specific user, a specific item, and the number of nearest neighbors to consider, computes the predicted rating for the specified item using user-based collaborative filtering. # Function Signature ```python def predict_user_rating( rating_matrix: np.ndarray, user_index: int, item_index: int, k: int ) -> float: Predicts the rating a user would give to a specific item based on the ratings of similar users. Args: rating_matrix: 2D ndarray of shape (u, i) representing the ratings given by u users to i items. If a rating is not available, it will be represented by zero. user_index: An integer representing the index of the target user in the rating matrix. item_index: An integer representing the index of the target item in the rating matrix. k: An integer representing the number of nearest neighbors (similar users) to consider. Returns: float: The predicted rating for the specified item by the specified user. ``` # Input and Output Format - **Input**: - `rating_matrix` : An array of shape `(u, i)` where `u` represents the number of users and `i` represents the number of items. Each element represents the rating given by a user to an item, or zero if no rating was given. - `user_index` : An integer representing the index of the target user in the rating matrix. - `item_index` : An integer representing the index of the target item in the rating matrix. - `k` : An integer that represents the number of nearest neighbors to consider. - **Output**: A float value representing the predicted rating for the given `item_index` by the given `user_index`. # Constraints - Assume `1 <= u <= 10^4` and `1 <= i <= 10^3`. - Ratings are non-negative integers and zero represents missing ratings. - `0 <= k <= u`. - `0 <= user_index < u` and `0 <= item_index < i`. # Example ```python rating_matrix = np.array([ [5, 3, 0, 1], [4, 0, 0, 1], [1, 1, 0, 5], [1, 0, 0, 4], [0, 1, 5, 4] ]) user_index = 0 item_index = 2 k = 2 predicted_rating = predict_user_rating(rating_matrix, user_index, item_index, k) print(predicted_rating) # Expected output: a float value representing the predicted rating ``` # Notes - Make sure to handle edge cases, such as when there are no available neighbors to consider (`k=0`). - Euclidean distance or cosine similarity can be used to find the nearest neighbors. - Ensure efficient implementation to handle large matrices. Hints 1. Compute the similarity between the target user and all other users. 2. Select the top-k most similar users who have rated the target item. 3. Compute the weighted average of these ratings based on the similarity scores to predict the target user\'s rating for the item.","solution":"import numpy as np def predict_user_rating(rating_matrix: np.ndarray, user_index: int, item_index: int, k: int) -> float: def cosine_similarity(user1, user2): Calculate the Cosine similarity between two users. norm_user1 = np.linalg.norm(user1) norm_user2 = np.linalg.norm(user2) if norm_user1 == 0 or norm_user2 == 0: return 0 return np.dot(user1, user2) / (norm_user1 * norm_user2) def get_k_nearest_neighbors(): Get indices and similarities of k nearest neighbors user_ratings = rating_matrix[user_index] similarities = [] for i in range(len(rating_matrix)): if i != user_index: sim = cosine_similarity(user_ratings, rating_matrix[i]) similarities.append((i, sim)) # Sorting by similarity and selecting k nearest neighbors similarities.sort(key=lambda x: x[1], reverse=True) return similarities[:k] nearest_neighbors = get_k_nearest_neighbors() numerator = 0 denominator = 0 for neighbor_index, similarity in nearest_neighbors: neighbor_rating = rating_matrix[neighbor_index][item_index] if neighbor_rating > 0: # Consider only non-zero ratings numerator += similarity * neighbor_rating denominator += similarity if denominator == 0: return 0.0 # If no neighbors rated the target item return numerator / denominator"},{"question":"# Problem Statement You are given an array of integers `arr` and an integer `k`. Your task is to split the array into `k` non-empty subarrays such that the largest sum among those subarrays is minimized. Return the minimized largest sum. # Function Signature ```python def split_array_minimized_max_sum(arr: List[int], k: int) -> int: pass ``` # Input * `arr`: A list of integers of length `n` where `1 <= n <= 1000` and `1 <= arr[i] <= 10^4` for each `i`. * `k`: An integer where `1 <= k <= n`. # Output * Returns an integer representing the minimized largest sum of `k` subarrays. # Constraints * Ensure the solution efficiently handles arrays with a length up to 1000. * Use efficient algorithms and data structures to minimize computation time, especially for larger values of `n`. # Examples The function should operate as follows: ```python assert split_array_minimized_max_sum([7, 2, 5, 10, 8], 2) == 18 assert split_array_minimized_max_sum([1, 2, 3, 4, 5], 2) == 9 assert split_array_minimized_max_sum([1, 4, 4], 3) == 4 assert split_array_minimized_max_sum([1, 2, 3, 4, 5], 1) == 15 ``` # Additional Notes * Consider both cases where `k` can be as small as 1 (the entire array as one subarray) and as large as `n` (each element as its own subarray). * Efficient use of binary search and prefix sums might be helpful in optimizing your solution. # Hints 1. Use binary search to find a candidate for the minimized largest sum. 2. Validate each candidate sum by checking if it\'s possible to partition the array into `k` or fewer subarrays with each subarray having sum less than or equal to that candidate.","solution":"from typing import List def can_partition(nums: List[int], k: int, max_sum: int) -> bool: current_sum = 0 count = 1 for num in nums: if current_sum + num > max_sum: count += 1 current_sum = num if count > k: return False else: current_sum += num return True def split_array_minimized_max_sum(arr: List[int], k: int) -> int: left, right = max(arr), sum(arr) result = right while left <= right: mid = (left + right) // 2 if can_partition(arr, k, mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"# Problem Statement You are tasked with implementing an order fulfillment system to determine the order completion status for a list of orders based on their required quantities and the available inventory. Given a list of orders and current warehouse inventory, write a function to check if each order can be completely fulfilled with the available items. # Function Signature ```python def check_order_fulfillment(orders: list[dict], inventory: dict) -> list[bool]: pass ``` # Input - `orders`: A list of dictionaries, where each dictionary represents an order. Each order has items as keys and required quantities as values. - `inventory`: A dictionary representing the available inventory in the warehouse, with items as keys and quantities as values. # Output - A list of booleans, where each boolean indicates whether the corresponding order in the input list can be completely fulfilled with the available inventory. # Constraints - Each order can contain between 1 and 50 items. - There will be at most 100 orders. - The inventory and order quantities will be non-negative integers. - Items are represented by strings, and their names will be unique. # Example ```python # Example usage orders = [ {\\"item1\\": 2, \\"item2\\": 3}, {\\"item1\\": 1, \\"item3\\": 4}, {\\"item4\\": 1} ] inventory = { \\"item1\\": 3, \\"item2\\": 3, \\"item3\\": 2, \\"item4\\": 5 } # Example expected output # The first order can be fulfilled as we have enough \'item1\' and \'item2\'. # The second order cannot be fulfilled because \'item3\' is understocked. # The third order can be fulfilled as we have enough \'item4\'. # Therefore, the function should return [True, False, True]. check_order_fulfillment(orders, inventory) ``` # Task Description 1. **Order Fulfillment Check**: Implement the function to check if each order can be fulfilled given the current inventory. 2. **Inventory Management**: Account for the inventory decrement as items are allocated to fulfill orders. 3. **Edge Cases & Performance**: Handle edge cases such as empty orders or zero quantities and ensure the solution is efficient for the given constraints.","solution":"def check_order_fulfillment(orders: list[dict], inventory: dict) -> list[bool]: Check if each order can be fulfilled with the available inventory. :param orders: List of orders, where each order is a dictionary with items and quantities. :param inventory: Available inventory, a dictionary with items and their quantities. :return: List of booleans indicating if each order can be fulfilled. fulfillments = [] for order in orders: can_fulfill = True for item, qty in order.items(): if item not in inventory or inventory[item] < qty: can_fulfill = False break fulfillments.append(can_fulfill) return fulfillments"},{"question":"# Matrix Rotation Challenge Problem Statement You are given an `n x n` 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). You need to do this in-place, which means you have to modify the input matrix directly. Function Signature ```python def rotate_matrix(matrix: list[list[int]]) -> None: ``` Input - `matrix` (list[list[int]]): A 2D list of integers representing an `n x n` matrix. (1 <= n <= 1000) Output - Modify the input matrix in-place to reflect a 90-degree clockwise rotation. Constraints - You must perform the rotation in-place, using only constant extra space. Examples ```python matrix_1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix_1) # Matrix after rotation: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] matrix_2 = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate_matrix(matrix_2) # Matrix after rotation: # [ # [15, 13, 2, 5], # [14, 3, 4, 1], # [12, 6, 8, 9], # [16, 7, 10, 11] # ] ```","solution":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotates the given n x n matrix by 90 degrees clockwise in-place. Parameters: matrix (list[list[int]]): The input n x n matrix to be rotated. n = len(matrix) # First, transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Second, reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Problem Statement: You are given a grid of characters and you need to find the size of the largest connected group of identical characters. Two cells are considered part of the same connected group if they share a border (vertical or horizontal). Implement the following function: 1. **`largest_connected_group`**: Finds the size of the largest connected group of identical characters in the grid. # Function Signature: 1. **`def largest_connected_group(grid: list[list[str]]) -> int:`** # Input: - `grid`: A list of lists of characters representing the grid. # Output: - The function should return an integer representing the size of the largest connected group of identical characters. # Constraints: - The grid dimensions are between 1x1 and 100x100, inclusive. - Each cell of the grid contains a single lowercase letter. # Example: ```python grid = [ [\'a\', \'a\', \'b\'], [\'a\', \'a\', \'b\'], [\'b\', \'b\', \'b\'] ] size = largest_connected_group(grid) print(size) # Output: 5 (the `b` cells form the largest connected group) grid = [ [\'a\', \'b\', \'c\'], [\'b\', \'b\', \'d\'], [\'c\', \'d\', \'d\'] ] size = largest_connected_group(grid) print(size) # Output: 3 (the largest connected groups are `b` and `d` cells, each having size 3) ``` # Notes: - Implement helper functions if needed to keep the code organized. - Think about edge cases such as a grid being only one cell. - Use Depth-First Search (DFS) or Breadth-First Search (BFS) to explore the grid and find connected components.","solution":"def largest_connected_group(grid): Returns the size of the largest connected group of identical characters in the grid. if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(x, y, char): # Use stack for DFS stack = [(x, y)] count = 0 while stack: cx, cy = stack.pop() if visited[cx][cy]: continue visited[cx][cy] = True count += 1 # Check all four directions for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and grid[nx][ny] == char: stack.append((nx, ny)) return count largest_group = 0 for r in range(rows): for c in range(cols): if not visited[r][c]: current_group_size = dfs(r, c, grid[r][c]) largest_group = max(largest_group, current_group_size) return largest_group"},{"question":"# Coding Assessment Question: Balanced Binary Search Tree Verification **Scenario**: You are working on a project involving a wide range of dynamic data sets. To optimize search operations, the data needs to be stored in a balanced binary search tree (BST). You need to ensure that the tree remains balanced after various operations such as insertions and deletions. **Problem Statement**: Write a function `is_balanced_bst(root: TreeNode) -> bool` that determines if a given binary search tree is balanced and adheres to BST properties. A balanced BST is defined as one in which the depth of all the leaves differs by no more than one. **Input**: - `root`: A `TreeNode` object representing the root of the binary search tree. **Output**: - A boolean value, `True` if the tree is both balanced and a valid BST, `False` otherwise. **Constraints**: - The number of nodes in the tree is between `0` and `1,000`. - Each `TreeNode` contains the following attributes: - `val`: An integer value representing the node\'s value. - `left`: A pointer to the left child node (or `None` if there is no left child). - `right`: A pointer to the right child node (or `None` if there is no right child). **Performance Requirements**: - The solution should efficiently handle up to 1,000 nodes and determine the tree’s balance and validity in a reasonable time frame. **Example**: Given a binary search tree represented by the following TreeNode structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Creates the following BST: # 5 # / # 3 8 # / / # 2 7 10 root = TreeNode(5) root.left = TreeNode(3, TreeNode(2)) root.right = TreeNode(8, TreeNode(7), TreeNode(10)) ``` The function call `is_balanced_bst(root)` should return `True`. **Additional Notes**: - Implement helper functions as needed to determine the height and balance of the tree, and to validate BST properties. - Consider edge cases such as an empty tree, which should be considered as balanced. - Ensure that your solution does not perform redundant checks and runs efficiently.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced_bst(root: TreeNode) -> bool: def is_balanced_and_bst(node, low, high): if not node: return (True, 0) if node.val <= low or node.val >= high: return (False, 0) left_balanced, left_height = is_balanced_and_bst(node.left, low, node.val) right_balanced, right_height = is_balanced_and_bst(node.right, node.val, high) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 height = max(left_height, right_height) + 1 return (balanced, height) balanced, _ = is_balanced_and_bst(root, float(\'-inf\'), float(\'inf\')) return balanced"},{"question":"# Coding Assessment Question **Scenario**: You are developing a feature for a calendar application where users can schedule meetings. One of the functionalities requires checking room availability. You need to create an interval merging algorithm to determine free and occupied times. **Task**: Implement a function to merge overlapping intervals to identify the consolidated busy times. Given a list of intervals, you should combine all overlapping intervals into single intervals. **Function Signature**: ```python def merge_intervals(intervals: list) -> list: pass ``` **Input**: * `intervals`: A list of intervals where each interval is represented as a tuple `(start, end)`. The start time is inclusive, and the end time is exclusive. (0 <= len(intervals) <= 1000) **Output**: * A list of merged intervals sorted by the start time. **Constraints**: * Each interval is a tuple of two integers where `0 <= start < end`. * If the input list is empty, return an empty list. * The intervals may be unsorted. **Performance**: * Your solution should handle up to 1000 intervals efficiently. **Examples**: ```python >>> merge_intervals([(1, 3), (2, 6), (8, 10), (15, 18)]) [(1, 6), (8, 10), (15, 18)] >>> merge_intervals([(1, 4), (4, 5)]) [(1, 5)] >>> merge_intervals([]) [] ``` Implement the function `merge_intervals`.","solution":"def merge_intervals(intervals): Merges overlapping intervals from a list of intervals. Args: intervals (list of tuple): List of tuples where each tuple represents start and end time. Returns: list of tuple: List of merged intervals sorted by starting times. if not intervals: return [] # Sort intervals by their starting times intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] # Initialize merged list with the first interval for current in intervals[1:]: prev_start, prev_end = merged[-1] current_start, current_end = current if current_start <= prev_end: # Check if there is an overlap # If overlapping, merge the intervals by updating the end time merged[-1] = (prev_start, max(prev_end, current_end)) else: # If no overlap, add the current interval to the merged list merged.append(current) return merged"},{"question":"# Problem Statement You have been given a sequence of `N` integers. Your task is to implement the \\"Maximum Subarray Sum\\" algorithm to find the largest sum of a contiguous subarray within a one-dimensional array of integers, which may contain both positive and negative numbers. Additionally, return the indices of the start and end of this subarray. # Function Signature ```python def maximum_subarray_sum(arr: List[int]) -> Tuple[int, int, int]: ``` # Input - `arr` (List[int]): A list of integers representing the sequence. # Output - Return a tuple of three values: - The maximum sum of a contiguous subarray. - The starting index of this subarray. - The ending index of this subarray. # Constraints - The number of integers (1 leq N leq 10^5). - Each integer in the array is within the range of (-10^4) to (10^4). - Indices are 0-based. # Example ```python arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4] print(maximum_subarray_sum(arr)) # Expected output: (6, 3, 6) ``` # Requirements 1. Implement the function `maximum_subarray_sum(arr: List[int]) -> Tuple[int, int, int]` that computes the maximum sum of any contiguous subarray within a given array, along with the starting and ending indices of this subarray. 2. Ensure your implementation handles large inputs efficiently, ideally in linear time complexity, i.e., (O(N)). # Tips - Use Kadane\'s Algorithm to keep track of the maximum sum found so far and the current subarray sum. - Maintain variables to track the starting and ending indices of the maximum subarray.","solution":"from typing import List, Tuple def maximum_subarray_sum(arr: List[int]) -> Tuple[int, int, int]: if not arr: return 0, -1, -1 max_sum = current_sum = arr[0] start = end = temp_start = 0 for i in range(1, len(arr)): if current_sum + arr[i] > arr[i]: current_sum += arr[i] else: current_sum = arr[i] temp_start = i if current_sum > max_sum: max_sum = current_sum start = temp_start end = i return max_sum, start, end"},{"question":"# Context In software development, dynamically managing data structures is a common task. One such structure is the Min-Heap, which enables efficient retrieval of the minimum value. Min-Heaps are useful in scenarios like implementing priority queues or scheduling processes. For this task, consider how to extend a basic Min-Heap implementation to support a custom operation. # Question Design and implement a class `CustomMinHeap` that not only supports the common operations of a Min-Heap (insertion, extraction of the minimum element) but also provides a method to increase the value of any element and adjust the heap accordingly. # Class and Method Definitions ```python class CustomMinHeap: def __init__(self): Initializes an empty Min-Heap. def insert(self, value: int) -> None: Inserts a value into the Min-Heap. :param value: The value to be inserted. def extract_min(self) -> int: Extracts and returns the minimum value from the Min-Heap. :return: The minimum value. def increase_value(self, index: int, new_value: int) -> None: Increases the value of the element at the specified index to new_value and readjusts the heap. :param index: The index of the element to be increased. :param new_value: The new value to be assigned. ``` # Input - `insert(value: int)`: A method to insert an integer value into the heap. - `extract_min() -> int`: A method to extract and return the minimum value in the heap. - `increase_value(index: int, new_value: int)`: A method to increase the value of the element at the specified index to `new_value`. # Output - The `insert` method should update the heap but return nothing. - The `extract_min` method should return an integer representing the minimum value. - The `increase_value` method should update the specified element and maintain the heap property. # Constraints - The heap should maintain its properties after every operation. - The `increase_value` method can only increase element values and should not decrease them. # Examples ```python heap = CustomMinHeap() heap.insert(3) heap.insert(1) heap.insert(6) heap.insert(5) heap.insert(2) heap.insert(4) assert heap.extract_min() == 1 # Minimum value is 1 heap.increase_value(0, 7) # Increase value at index 0 (which is 2) to 7 assert heap.extract_min() == 3 # Minimum value is now 3 assert heap.extract_min() == 4 # Next minimum is 4 assert heap.extract_min() == 5 # Next minimum is 5 ``` # Notes - You should ensure that the indices for the `increase_value` method are valid and within the current heap size. - Readjust the heap after each operation to maintain the Min-Heap property.","solution":"class CustomMinHeap: def __init__(self): Initializes an empty Min-Heap. self.heap = [] def insert(self, value: int) -> None: Inserts a value into the Min-Heap. :param value: The value to be inserted. self.heap.append(value) self._heapify_up(len(self.heap) - 1) def extract_min(self) -> int: Extracts and returns the minimum value from the Min-Heap. :return: The minimum value. if len(self.heap) == 0: return None if len(self.heap) == 1: return self.heap.pop() min_value = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return min_value def increase_value(self, index: int, new_value: int) -> None: Increases the value of the element at the specified index to new_value and readjusts the heap. :param index: The index of the element to be increased. :param new_value: The new value to be assigned. if 0 <= index < len(self.heap) and self.heap[index] < new_value: self.heap[index] = new_value self._heapify_down(index) def _heapify_up(self, index: int): parent_index = (index - 1) // 2 while index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] index = parent_index parent_index = (index - 1) // 2 def _heapify_down(self, index: int): smallest = index left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 if left_child_index < len(self.heap) and self.heap[left_child_index] < self.heap[smallest]: smallest = left_child_index if right_child_index < len(self.heap) and self.heap[right_child_index] < self.heap[smallest]: smallest = right_child_index if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest)"},{"question":"# Sorting Events By Importance You are assisting in the development of an event management system. Each event is associated with a certain level of importance. Your task is to write a function that takes in a list of events and their importance levels and returns the list sorted by the importance levels. Each event has a unique identifier and a numeric importance value. Function Signature ```python def sort_events_by_importance(events: List[Tuple[str, int]]) -> List[Tuple[str, int]]: This function sorts a list of events based on their importance levels in descending order. :param events: List of tuples where each tuple represents an event with a string identifier and an integer representing the importance level. :return: A list of tuples sorted by importance levels in descending order. ``` Input 1. **events**: A list of tuples where each tuple contains a string (event identifier) and an integer (importance level). Output * A list of tuples sorted by the importance levels in descending order. Constraints * Each event identifier is unique. * All importance levels are integers. Example ```python events_list = [ (\\"event1\\", 5), (\\"event2\\", 3), (\\"event3\\", 9), (\\"event4\\", 1), (\\"event5\\", 4) ] assert sort_events_by_importance(events_list) == [ (\\"event3\\", 9), (\\"event1\\", 5), (\\"event5\\", 4), (\\"event2\\", 3), (\\"event4\\", 1) ] ``` Notes * You may assume the list will have at least one event. * Consider using built-in sorting functions to ensure efficient sorting. * Handle edge cases where multiple events have the same importance level. * Ensure the function correctly handles the sorting of various list sizes, including large lists. This new question aligns with the existing set by focusing on core concepts of sorting and data manipulation in Python. It maintains the complexity level by requiring sorting based on specific criteria and handles real-world scenarios through event management.","solution":"from typing import List, Tuple def sort_events_by_importance(events: List[Tuple[str, int]]) -> List[Tuple[str, int]]: This function sorts a list of events based on their importance levels in descending order. :param events: List of tuples where each tuple represents an event with a string identifier and an integer representing the importance level. :return: A list of tuples sorted by importance levels in descending order. return sorted(events, key=lambda event: event[1], reverse=True)"},{"question":"# Scenario You are assigned to enhance a basic matrix manipulation module by implementing a function that rotates a given square matrix 90 degrees clockwise in place. Given that the matrix is represented as a list of lists, you need to modify it directly without using extra space for another matrix. # Requirements **Function Signature**: ```python def rotate(matrix: list[list[int]]) -> None: pass ``` # Input & Output Formats * `rotate`: * **Input**: A square matrix represented as a list of `n` lists, each containing `n` integers (1 ≤ n ≤ 100). * **Output**: The matrix will be modified in place to represent the rotated version. # Constraints * You must rotate the matrix in place. * The matrix contains only integer elements. # Performance Requirements * Time Complexity: O(n^2) where n is the dimension of the square matrix. * Space Complexity: O(1), excluding the input matrix. # Example ```python >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ```","solution":"def rotate(matrix: list[list[int]]) -> None: Rotates a given n x n 2D matrix 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Problem Statement You are assigned the task of implementing a function `count_substrings` that counts how many times a given substring appears in a string for all possible distinct substrings of lengths ranging from 1 to K, which is provided as input. Your function should return a dictionary where the keys are the distinct substrings and the values are the counts of their occurrences. # Function Signature ```python def count_substrings(s: str, K: int) -> dict: ``` # Input 1. `s` (str): A string of alphabetic characters (lowercase only) with length ranging from 1 to 100. 2. `K` (int): An integer denoting the maximum length of substrings to consider, where 1 <= K <= len(s). # Output - Returns a dictionary where: * Keys are distinct substrings of `s` with lengths from 1 to K. * Values are integers representing the number of times each substring appears in `s`. # Constraints - The input string `s` contains only lowercase alphabetic characters. - Length of input string `s` is between 1 to 100. - K is an integer such that 1 <= K <= len(s). # Example ```python # Example 1 s = \\"ababa\\" K = 2 print(count_substrings(s, K)) # Output: {\'a\': 3, \'b\': 2, \'ab\': 2, \'ba\': 2} # Example 2 s = \\"abc\\" K = 1 print(count_substrings(s, K)) # Output: {\'a\': 1, \'b\': 1, \'c\': 1} ``` # Notes - Ensure your implementation efficiently handles strings of various lengths up to the maximum constraint. - Utilize appropriate Python data structures for efficient substring extraction and counting. # Edge Cases to Consider - The input string consists of repeating characters only (e.g., \\"aaaa\\"). - K equals the length of the input string. - An input string of minimum length (1 character). # Testing - Include tests to cover typical use cases and edge cases. - Validate that the function correctly identifies and counts substrings of all lengths from 1 to K. - Utilize the `doctest` library to verify your solution.","solution":"def count_substrings(s: str, K: int) -> dict: Returns a dictionary with counts of all distinct substrings of lengths ranging from 1 to K. if not s or K < 1 or K > len(s): return {} substring_count = {} # Iterate over all possible substring lengths for length in range(1, K + 1): # Iterate over the string to find all substrings of the current length for i in range(len(s) - length + 1): substring = s[i:i + length] if substring in substring_count: substring_count[substring] += 1 else: substring_count[substring] = 1 return substring_count"},{"question":"# String Pattern Rotation A string is said to be a rotation of another if you can obtain the second string by rotating the first string an arbitrary number of times either to the left or to the right. For example, the string \\"hello\\" can be rotated to the left by 2 positions to get \\"llohe\\" or to the right by 2 positions to get \\"lohel\\". # Task Write a function `is_rotation(original: str, rotated: str) -> bool` that checks if the `rotated` string is a rotation of the `original` string. # Details - **Input**: Two strings `original` and `rotated` where: - (1 leq text{len(original)}, text{len(rotated)} leq 10^3) - Both strings contain only lowercase Latin letters. - **Output**: A boolean value `True` if `rotated` is a rotation of `original`, else `False`. # Performance Requirements - The function should have a time complexity of (O(n)) where (n) is the length of the original string. # Example ```python def is_rotation(original: str, rotated: str) -> bool: pass # Your implementation here # Example usages and expected outputs print(is_rotation(\\"hello\\", \\"llohe\\")) # Expected output: True print(is_rotation(\\"hello\\", \\"ohell\\")) # Expected output: True print(is_rotation(\\"hello\\", \\"olelh\\")) # Expected output: False print(is_rotation(\\"abcd\\", \\"dabc\\")) # Expected output: True print(is_rotation(\\"abcd\\", \\"abcd\\")) # Expected output: True ``` # Explanation 1. **Rotation**: - Rotation to the left means shifting characters to the left and wrapping around from the start. - Rotation to the right means shifting characters to the right and wrapping around from the end. 2. **Concatenation Trick**: - To check if one string is a rotation of another, concatenate the `original` string with itself and check if the `rotated` string is a substring of the result. 3. **Equality Check**: - If the lengths of the two strings are different, immediately return `False`. # Constraints 1. Ensure that the function handles strings with different lengths appropriately by checking lengths before performing additional operations. 2. Strings are assumed to contain only lowercase letters and be non-empty.","solution":"def is_rotation(original: str, rotated: str) -> bool: Check if the `rotated` string is a rotation of the `original` string. if len(original) != len(rotated): return False concatenated = original + original return rotated in concatenated"},{"question":"# Question: Validate and Format Phone Numbers You are tasked with developing a Python function that validates and formats a list of phone numbers. The function should check if each phone number is valid according to North American Numbering Plan (NANP) standards and then format the valid phone numbers in the specified format. Function Signature ```python def validate_and_format_phone_numbers(phone_numbers: list[str]) -> list[str]: pass ``` Input - `phone_numbers` (list[str]): A list of strings containing phone numbers. Output - A list of strings containing valid and formatted phone numbers. Each phone number should be formatted as `(XXX) XXX-XXXX`. Constraints - A valid phone number has exactly 10 digits. - The list may contain phone numbers with various delimiters (e.g., spaces, dashes, parentheses) or be purely numeric. - If a phone number is invalid (i.e., not conforming to the 10-digit standard), it should be excluded from the output list. Sample Execution ```python phone_numbers = [\\"123-456-7890\\", \\"(123) 456-7890\\", \\"1234567890\\", \\"123 456 7890\\", \\"123-45-6789\\"] formatted_phone_numbers = validate_and_format_phone_numbers(phone_numbers) print(formatted_phone_numbers) # Expected output: [\'(123) 456-7890\', \'(123) 456-7890\', \'(123) 456-7890\', \'(123) 456-7890\'] ``` Background This exercise is meant to test your understanding of: - String manipulation and regular expressions in Python. - Validating input based on a set of rules. - Formatting output strings to meet a specific standard. - Working with lists and handling invalid data. **Example of the formatted output**: If given \\"123-456-7890\\" as input, the output should be \\"(123) 456-7890\\".","solution":"import re def validate_and_format_phone_numbers(phone_numbers: list[str]) -> list[str]: Validates and formats a list of phone numbers according to the NANP standards. Parameters: phone_numbers (list[str]): A list of strings containing phone numbers. Returns: (list[str]): A list of formatted phone numbers. formatted_numbers = [] for phone in phone_numbers: # Remove all non-digit characters digits = re.sub(r\'D\', \'\', phone) # Check if the phone number has exactly 10 digits if len(digits) == 10: formatted = f\\"({digits[:3]}) {digits[3:6]}-{digits[6:]}\\" formatted_numbers.append(formatted) return formatted_numbers"},{"question":"# Problem Description You are tasked with creating a simulation of a predator-prey ecosystem using the Lotka-Volterra equations. Your simulation should model the population dynamics of a predator and a prey species over time and visualize the results on a graph. # Function Specification You need to write a function `simulate_predator_prey` with the following signature: ```python def simulate_predator_prey(a: float, b: float, c: float, d: float, prey_init: int, predator_init: int, nb_steps: int, dt: float) -> None: ``` Input: - `a`: A float representing the growth rate of the prey population. - `b`: A float representing the rate at which predators destroy prey. - `c`: A float representing the death rate of the predator population. - `d`: A float representing the rate at which predators increase by consuming prey. - `prey_init`: An integer for the initial number of prey. - `predator_init`: An integer for the initial number of predators. - `nb_steps`: An integer indicating the number of time steps for the simulation. - `dt`: A float specifying the time increment per step. Output: - Displays a plot with two lines: one for the prey population and one for the predator population, plotting their sizes over the given number of steps. # Constraints: - Ensure the function correctly implements the Lotka-Volterra equations: - (frac{dtext{prey}}{dt} = a times text{prey} - b times text{prey} times text{predator}) - (frac{dtext{predator}}{dt} = d times text{prey} times text{predator} - c times text{predator}) - Handle possible numerical stability issues, such as preventing the population from becoming negative. - Efficiently compute the populations over a large number of steps. # Example Usage ```python simulate_predator_prey(0.1, 0.02, 0.3, 0.01, prey_init=40, predator_init=9, nb_steps=1000, dt=0.01) ``` This should display a plot showing the populations of prey and predators over time. # Performance Requirements - Ensure the computation remains efficient for a large number of steps (e.g., 10,000 steps). - Manage memory usage effectively to avoid excessive use of resources.","solution":"import numpy as np import matplotlib.pyplot as plt def simulate_predator_prey(a: float, b: float, c: float, d: float, prey_init: int, predator_init: int, nb_steps: int, dt: float) -> None: # Initialize the population arrays prey_population = np.zeros(nb_steps+1) predator_population = np.zeros(nb_steps+1) # Set the initial populations prey_population[0] = prey_init predator_population[0] = predator_init # Implement the Euler method for solving the differential equations for t in range(nb_steps): prey = prey_population[t] predator = predator_population[t] prey_change = (a * prey - b * prey * predator) * dt predator_change = (d * prey * predator - c * predator) * dt # Ensure populations do not become negative prey_population[t+1] = max(prey + prey_change, 0) predator_population[t+1] = max(predator + predator_change, 0) # Plotting the results plt.figure(figsize=(12, 6)) plt.plot(prey_population, label=\'Prey\') plt.plot(predator_population, label=\'Predator\') plt.xlabel(\'Time Steps\') plt.ylabel(\'Population\') plt.title(\'Predator-Prey Population Dynamics\') plt.legend() plt.show()"},{"question":"# Problem Statement A software development company is creating a new feature for an online platform that notifies users about upcoming events. You have been tasked with writing a function that helps in finding possible sequences of event notifications based on provided dependencies. Each event depends on another event, and the goal is to determine one of the possible orders of sending notifications, respecting the given dependencies. This problem is akin to the well-known \\"Topological Sorting\\" problem. # Function Signature ```python def find_notification_order(events: int, dependencies: List[Tuple[int, int]]) -> List[int]: :param events: The total number of events (0 to events-1). :param dependencies: A list of tuples where each tuple (a, b) represents that event \'a\' needs to be notified before event \'b\'. :return: A list of integers representing one of the possible valid sequences of event notification order. Example: >>> events = 4 >>> dependencies = [(0, 1), (1, 2), (2, 3), (1, 3)] >>> find_notification_order(events, dependencies) [0, 1, 2, 3] # One valid sequence >>> events = 3 >>> dependencies = [(1, 0), (2, 0)] >>> find_notification_order(events, dependencies) [1, 2, 0] # Another valid sequence ``` # Input * `events`: Integer (1 ≤ events ≤ 1000). The total number of events, represented by integers 0 to events-1. * `dependencies`: A list of tuples, where each tuple `(a, b)` represents a dependency that event `a` must precede event `b`. # Output * A list of integers representing one possible valid sequence in which event notifications can be sent while respecting the given dependencies. # Constraints * The dependencies form a Directed Acyclic Graph (DAG). * The input guarantees that it is always possible to find at least one valid sequence. # Example Given `events = 4` and `dependencies = [(0, 1), (1, 2), (2, 3), (1, 3)]`, the function could return: ``` [0, 1, 2, 3] ``` Note that other valid sequences might exist, like `[0, 1, 3, 2]`. # Detailed Description 1. Initialize a graph representation of the events and their dependencies. 2. Use Kahn\'s Algorithm (BFS) or DFS algorithm to perform a topological sort on the events. 3. Ensure that the resulting order respects all given dependencies. 4. Return the order as a list of integers. If no valid order exists, return an empty list (input guarantees a valid order will always exist). This problem assesses the understanding of graph algorithms, particularly topological sorting, and the principles of managing dependencies in a directed graph.","solution":"from typing import List, Tuple from collections import deque, defaultdict def find_notification_order(events: int, dependencies: List[Tuple[int, int]]) -> List[int]: Perform a topological sort to determine one possible order of event notifications. Parameters: events (int): The total number of events. dependencies (List[Tuple[int, int]]): A list of tuples where each tuple (a, b) represents that event \'a\' needs to be notified before event \'b\'. Returns: List[int]: A list of integers representing one of the possible valid sequences of event notification order. # Initialize graph and in-degree dictionary graph = defaultdict(list) in_degree = {i: 0 for i in range(events)} # Build the graph and in-degree dictionary for a, b in dependencies: graph[a].append(b) in_degree[b] += 1 # Find all nodes with no incoming edges (in-degree 0) queue = deque([node for node in in_degree if in_degree[node] == 0]) result = [] while queue: node = queue.popleft() result.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(result) != events: return [] # In case there is a cycle, but the problem guarantees it\'s a DAG return result"},{"question":"# Implement Single Source Shortest Path Algorithm The Single Source Shortest Path (SSSP) problem is a classic algorithm problem where, given a graph and a source vertex, you need to find the shortest path from the source vertex to all other vertices in the graph. One common algorithm to solve this problem is Dijkstra\'s algorithm, which efficiently finds the shortest paths from the source vertex to all other vertices in a weighted graph with non-negative weights. # Objective Implement the `Dijkstra` class, focusing on the methods `add_edge`, `dijkstra`, and `shortest_path`. # Specifications 1. **Graph Representation**: - The graph should be represented using an adjacency list. 2. **Edge Addition**: - `add_edge(self, u: int, v: int, weight: float) -> None`: Add an edge with a given weight between vertices `u` and `v`. 3. **Run Dijkstra\'s Algorithm**: - `dijkstra(self, src: int) -> Dict[int, float]`: Compute the shortest paths from the source vertex `src` using Dijkstra\'s algorithm and return a dictionary where the keys are the vertex indices and the values are the shortest path distances from the source vertex. 4. **Retrieve Shortest Path**: - `shortest_path(self, src: int, dest: int) -> Tuple[List[int], float]`: Retrieve the shortest path and distance from the source vertex `src` to the destination vertex `dest`. # Requirements: - **Input**: - `add_edge`: Two integers `u` and `v` representing vertices, and a float `weight` representing the edge weight. - `dijkstra`: One integer `src` representing the source vertex. - `shortest_path`: Two integers `src` and `dest` representing the source and destination vertices. - **Output**: - `dijkstra`: Dictionary with vertex indices as keys and shortest path distances from the source vertex as values. - `shortest_path`: Tuple containing a list of vertices representing the shortest path and a float representing the total distance of the shortest path. # Example ```python # Example Usage graph = Dijkstra() graph.add_edge(0, 1, 1.0) graph.add_edge(0, 2, 4.0) graph.add_edge(1, 2, 2.0) graph.add_edge(1, 3, 5.0) graph.add_edge(2, 3, 1.0) # Compute shortest paths from source vertex 0 distances = graph.dijkstra(0) print(distances) # Output: {0: 0, 1: 1.0, 2: 3.0, 3: 4.0} # Retrieve shortest path from vertex 0 to vertex 3 path, distance = graph.shortest_path(0, 3) print(f\\"Path: {path}, Distance: {distance}\\") # Output: Path: [0, 1, 2, 3], Distance: 4.0 ``` Implement the `Dijkstra` class so that the above example executes correctly.","solution":"import heapq class Dijkstra: def __init__(self): self.graph = {} def add_edge(self, u: int, v: int, weight: float) -> None: if u not in self.graph: self.graph[u] = [] if v not in self.graph: self.graph[v] = [] self.graph[u].append((v, weight)) self.graph[v].append((u, weight)) # Assuming undirected graph def dijkstra(self, src: int) -> dict: dist = {node: float(\'inf\') for node in self.graph} dist[src] = 0 priority_queue = [(0, src)] heapq.heapify(priority_queue) while priority_queue: current_dist, current_node = heapq.heappop(priority_queue) if current_dist > dist[current_node]: continue for neighbor, weight in self.graph[current_node]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return dist def shortest_path(self, src: int, dest: int) -> tuple: dist = self.dijkstra(src) path = [] current = dest if dist[dest] == float(\'inf\'): return (path, float(\'inf\')) while current != src: path.append(current) for neighbor, weight in self.graph[current]: if dist[current] - weight == dist[neighbor]: current = neighbor break path.append(src) path.reverse() return (path, dist[dest])"},{"question":"Question: Polygon Area Calculation **Scenario**: You are tasked with calculating the area of a simple polygon given the coordinates of its vertices in order. The vertices are provided in a clockwise or counterclockwise direction, and the polygon is non-self-intersecting. Problem Statement Write a function `calculate_polygon_area` that accepts a list of tuples representing the vertices of a polygon and returns the area of the polygon. Function Signature ```python def calculate_polygon_area(vertices: list[tuple[float, float]]) -> float: pass ``` Input - `vertices`: A list of tuples where each tuple contains two floating point numbers representing the X and Y coordinates of a vertex of the polygon. Output - Returns a floating-point number representing the area of the polygon. Constraints - The provided list of vertices will be of length >= 3 and defines a non-self-intersecting polygon. - The vertices list will provide at least three vertices. Example ```python vertices = [(0, 0), (4, 0), (4, 3), (0, 3)] area = calculate_polygon_area(vertices) print(area) # Output should be 12.0 ``` Requirements - You must use the Shoelace formula to calculate the area of the polygon. - The function should handle both integer and floating-point coordinates in the vertices list.","solution":"def calculate_polygon_area(vertices): Calculate the area of a polygon using the Shoelace formula. :param vertices: List of tuples containing the vertices of the polygon in order. :return: Area of the polygon. n = len(vertices) area = 0 for i in range(n): x1, y1 = vertices[i] x2, y2 = vertices[(i + 1) % n] area += x1 * y2 - x2 * y1 return abs(area) / 2"},{"question":"# Graph Traversal using BFS **Problem Statement**: Breadth-First Search (BFS) is an important algorithm for traversing or searching tree or graph data structures. Your task is to implement BFS for a directed graph. The graph is provided as an adjacency list where each node is represented by an integer, and the edges are represented by a list of integers corresponding to adjacent nodes. **Requirements**: Implement a function `bfs(graph: Dict[int, List[int]], start_node: int) -> List[int]` that performs a breadth-first search on the given directed graph starting from the specified node. **Parameters**: - `graph`: A dictionary representing the adjacency list of the directed graph. Keys are node integers, and values are lists of integers representing adjacent nodes. - `start_node`: An integer representing the starting node for the BFS traversal. **Returns**: - A list of integers representing the nodes visited in BFS order starting from `start_node`. **Constraints**: - Assume all node values are unique. - The graph can have cycles. - The graph can have up to `10^3` nodes and edges in total. # Example Usage ```python graph = { 0: [1, 2], 1: [2], 2: [0, 3], 3: [3] } start_node = 2 print(bfs(graph, start_node)) # Output: [2, 0, 3, 1] graph = { 0: [1, 2], 1: [3], 2: [3], 3: [] } start_node = 0 print(bfs(graph, start_node)) # Output: [0, 1, 2, 3] ``` # Edge Cases to Consider: - The graph is empty. - All nodes are isolated with no edges. - The starting node has no outgoing edges. - The graph contains cycles. - Multiple nodes have the same shortest distance from the start node. # Notes - The BFS algorithm involves using a queue to explore the graph level by level. - Ensure that each node is visited at most once to avoid infinite loops in the presence of cycles.","solution":"from collections import deque from typing import Dict, List def bfs(graph: Dict[int, List[int]], start_node: int) -> List[int]: Perform BFS on the given directed graph starting from the specified node. :param graph: A dictionary representing the adjacency list of the directed graph. :param start_node: An integer representing the starting node for the BFS traversal. :return: A list of integers representing the nodes visited in BFS order. visited = set() queue = deque([start_node]) result = [] while queue: current_node = queue.popleft() if current_node not in visited: result.append(current_node) visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor not in visited: queue.append(neighbor) return result"},{"question":"Binary Search Tree Post-Order Traversal You are tasked to implement a function that performs a post-order traversal of a binary search tree (BST) and returns the result as a list. In a post-order traversal, nodes are recursively visited in the order: left subtree, right subtree, and then the node itself. 1. TreeNode Class First, define a class for the nodes of the BST: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` 2. Post-Order Traversal Function Implement the function to perform post-order traversal: ```python def post_order_traversal(root: TreeNode) -> List[int]: ``` * **Input**: The root node of a binary search tree. * **Output**: A list of integers representing the values of nodes in post-order traversal. # Constraints * The number of nodes in the tree will be in the range [0, 10,000]. * Each node\'s value will be a unique integer. # Example ```python # Example tree: # 1 # # 2 # / # 3 # The function should return [3, 2, 1] root = TreeNode(1) root.right = TreeNode(2) root.right.left = TreeNode(3) result = post_order_traversal(root) assert result == [3, 2, 1] ``` # Additional Rules 1. Handle edge cases such as an empty tree, which should return an empty list. 2. Ensure your implementation is efficient and can handle large trees within the provided constraints. 3. Avoid using any helper libraries or built-in methods for tree traversal other than basic data structures and recursion. **Good luck with your implementation! Ensure your code is clean, well-commented, and tested for various edge cases.**","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def post_order_traversal(root: Optional[TreeNode]) -> List[int]: Performs a post-order traversal of a binary search tree and returns the result as a list. :param root: The root node of the BST. :return: A list of integers representing the values of nodes in post-order traversal. result = [] def traverse(node): if not node: return traverse(node.left) traverse(node.right) result.append(node.val) traverse(root) return result"},{"question":"**Question**: You are required to implement the Depth-First Search (DFS) algorithm to perform traversal on a given undirected graph and return the traversal order starting from a specified vertex. # Input - An integer `V` (1 ≤ `V` ≤ 1000) representing the number of vertices. - An integer `E` (0 ≤ `E` ≤ 10000) representing the number of edges. - A list of `E` edges, where each edge is represented by two integers: `src` and `dst`, indicating an undirected edge between vertex `src` and vertex `dst`. - An integer `start` representing the vertex from which the DFS should start. # Output - A list of integers representing the order of vertex traversal in DFS. # Function Signature ```python def depth_first_search(vertex_count: int, edges: list[tuple[int, int]], start: int) -> list[int]: pass ``` # Constraints - All vertices are numbered from 0 to V-1. - There are no repeated edges, and no self-loops. # Example ```python edges = [ (0, 1), (0, 2), (1, 3), (2, 4), (4, 5) ] vertex_count = 6 start = 0 result = depth_first_search(vertex_count, edges, start) print(result) # Output: [0, 2, 4, 5, 1, 3] ``` In this example, the function should return the traversal order starting from vertex 0 using the Depth-First Search algorithm.","solution":"def depth_first_search(vertex_count: int, edges: list[tuple[int, int]], start: int) -> list[int]: def dfs(v, visited, adjacency_list, result): visited[v] = True result.append(v) for neighbor in adjacency_list[v]: if not visited[neighbor]: dfs(neighbor, visited, adjacency_list, result) # Create adjacency list adjacency_list = [[] for _ in range(vertex_count)] for src, dst in edges: adjacency_list[src].append(dst) adjacency_list[dst].append(src) # Track visited nodes visited = [False] * vertex_count # Resultant DFS order result = [] # Initiate DFS from start node dfs(start, visited, adjacency_list, result) return result"},{"question":"# Pathfinding on a Grid You are given a 2D grid representing a map where cells can be either walkable or blocked. Your task is to implement a function that finds the shortest path from a given starting cell to a target cell on the grid. The path can only be constructed by moving up, down, left, or right, and you cannot move through blocked cells. # Task Implement a function `shortest_path` that takes a 2D grid, a starting position, and a target position as input, and returns the length of the shortest path from the start to the target. If no path exists, return `-1`. # Function Signature ```python def shortest_path(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> int: pass ``` # Input - **grid**: A `List[List[int]]` representing the 2D grid where `0` represents a walkable cell and `1` represents a blocked cell. The grid dimensions will be between `1x1` and `100x100`. - **start**: A `Tuple[int, int]` representing the coordinates `(row, col)` of the starting cell. - **target**: A `Tuple[int, int]` representing the coordinates `(row, col)` of the target cell. # Output - Returns an `int` representing the length of the shortest path from the start to the target. If no path exists, return `-1`. # Constraints - The start and target cells are distinct and both will always be walkable (`0`). - The grid is guaranteed to be non-empty with at least one walkable cell. # Example ```python grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0] ] start = (0, 0) target = (4, 4) output = shortest_path(grid, start, target) print(output) # Expected output: 8 ``` # Explanation 1. From the start cell `(0, 0)`, the path to the target cell `(4, 4)` is derived using the shortest path algorithm (BFS). 2. The path length is calculated by counting the minimum number of steps required to reach the target. # Note - Only consider valid moves that stay within the grid boundaries and lead to walkable cells. - There is no diagonal movement allowed. Your task is to implement the function `shortest_path` that adheres to these constraints and ensures optimal pathfinding based on the grid provided.","solution":"from typing import List, Tuple from collections import deque def shortest_path(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> int: Finds the length of the shortest path from start to target on a grid. Using BFS for shortest path in an unweighted grid. rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Right, Down, Left, Up # BFS initialization queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add(start) while queue: row, col, dist = queue.popleft() # If we reach the target, return the distance if (row, col) == target: return dist # Explore all 4 possible directions for dr, dc in directions: new_row, new_col = row + dr, col + dc # Check if the new position is within bounds and walkable if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 0: if (new_row, new_col) not in visited: visited.add((new_row, new_col)) queue.append((new_row, new_col, dist + 1)) # If no path is found return -1"},{"question":"# Problem Statement Write a function `encode_string` that takes in a string and returns its encoded version based on the following rules: - Each group of consecutive identical characters should be replaced by the character followed by the count of its consecutive appearances. - If a character appears only once consecutively, do not add the count for that character. # Function Signature ```python def encode_string(input_string: str) -> str: ``` # Input * `input_string` (str): A non-empty string consisting of only uppercase and lowercase alphabetic characters. # Output * Returns the encoded string. # Constraints * The input string will contain only uppercase and lowercase alphabetic characters and will be non-empty. # Examples ```python print(encode_string(\\"aaabbcaaa\\")) # \\"a3b2ca3\\" print(encode_string(\\"AABCC\\")) # \\"A2BC2\\" print(encode_string(\\"xyz\\")) # \\"xyz\\" print(encode_string(\\"kkkkkk\\")) # \\"k6\\" print(encode_string(\\"PPQQq\\")) # \\"P2Q2q\\" ``` # Explanation of Examples 1. `\\"aaabbcaaa\\"` is encoded as `\\"a3b2ca3\\"` because: - `\'a\'` appears 3 times consecutively - `\'b\'` appears 2 times consecutively - `\'c\'` appears once (no count needed for single occurrence) - `\'a\'` appears 3 times consecutively at the end 2. `\\"AABCC\\"` is encoded as `\\"A2BC2\\"`: - `\'A\'` appears 2 times consecutively - `\'B\'` appears once (no count needed for single occurrence) - `\'C\'` appears 2 times consecutively 3. `\\"xyz\\"` remains `\\"xyz\\"` as there are no consecutive characters. 4. `\\"kkkkkk\\"` is encoded as `\\"k6\\"` because `\'k\'` appears 6 times consecutively. 5. `\\"PPQQq\\"` is encoded as `\\"P2Q2q\\"` because: - `\'P\'` appears 2 times consecutively - `\'Q\'` appears 2 times consecutively - `\'q\'` appears once (no count needed for single occurrence) # Instructions * Implement the function `encode_string`. * Your solution should handle all the mentioned constraints and edge cases. * Avoid using any external libraries.","solution":"def encode_string(input_string: str) -> str: if not input_string: return \\"\\" encoded_string = [] count = 1 for i in range(1, len(input_string)): if input_string[i] == input_string[i - 1]: count += 1 else: if count > 1: encoded_string.append(f\\"{input_string[i - 1]}{count}\\") else: encoded_string.append(input_string[i - 1]) count = 1 if count > 1: encoded_string.append(f\\"{input_string[-1]}{count}\\") else: encoded_string.append(input_string[-1]) return \\"\\".join(encoded_string)"},{"question":"Question You are given an efficient algorithm for calculating permutations recursively. Write a Python function `generate_permutations` that generates all possible permutations of a given list of integers. The function should return the permutations as a list of lists, where each inner list is a unique permutation of the original list. # Function Signature ```python def generate_permutations(nums: List[int]) -> List[List[int]]: ``` # Input - `nums` (List[int]): A list of integers for which permutations are to be generated (length <= 6). # Output - List[List[int]]: A list of lists, where each list represents a distinct permutation of the input list. # Constraints - `1 <= len(nums) <= 6` - Each integer in `nums` is unique. - The values in `nums` are within the range `-10^6` to `10^6`. # Example ```python >>> generate_permutations([1, 2, 3]) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] >>> generate_permutations([0, -1]) [[0, -1], [-1, 0]] >>> generate_permutations([5]) [[5]] >>> generate_permutations([]) [[]] >>> generate_permutations([1, 2, 3, 4]) [[1, 2, 3, 4], [1, 2, 4, 3], [1, 3, 2, 4], [1, 3, 4, 2], [1, 4, 2, 3], [1, 4, 3, 2], [2, 1, 3, 4], [2, 1, 4, 3], [2, 3, 1, 4], [2, 3, 4, 1], [2, 4, 1, 3], [2, 4, 3, 1], [3, 1, 2, 4], [3, 1, 4, 2], [3, 2, 1, 4], [3, 2, 4, 1], [3, 4, 1, 2], [3, 4, 2, 1], [4, 1, 2, 3], [4, 1, 3, 2], [4, 2, 1, 3], [4, 2, 3, 1], [4, 3, 1, 2], [4, 3, 2, 1]] ``` # Considerations - Ensure that the function is optimized to avoid unnecessary computations as the number of permutations can grow factorially with the list length. - Use a recursive approach to generate permutations systematically, ensuring all distinct permutations are captured in the output list.","solution":"def generate_permutations(nums): def permute(nums, path, res): if not nums: res.append(path) else: for i in range(len(nums)): permute(nums[:i] + nums[i+1:], path + [nums[i]], res) result = [] permute(nums, [], result) return result"},{"question":"# Coding Assessment Question Context: Your software development company has developed an online retail platform where customers can search for products. To enhance the search functionality, you need to implement a feature to rank products by their relevance score. Each product has a relevance score and you need to display the top \'n\' products with the highest relevance scores. Given that the list of products can be very large, it\'s crucial to implement an efficient algorithm to retrieve these top \'n\' products. Task: Write a Python function named `top_n_products` that takes a list of product dictionaries, where each dictionary contains a \'name\' and a \'score\' key, and an integer n, and returns a list of the top \'n\' product names with the highest scores. If two products have the same score, they should be ordered alphabetically by their names. Specifications: - **Function Name**: `top_n_products` - **Parameters**: - `products` (list[dict]): A list of dictionaries, where each dictionary represents a product with keys \'name\' (string) and \'score\' (float). - `n` (int): The number of top products to return. - **Returns**: A list of strings representing the names of the top \'n\' products with the highest scores. # Constraints: 1. The list may contain products with the same scores. 2. The algorithm should run in O(m * log n) time complexity, where m is the number of products. 3. Handle edge cases such as when the input list is empty or \'n\' is greater than the number of products available. # Example: ```python products = [ {\'name\': \'Product A\', \'score\': 4.5}, {\'name\': \'Product B\', \'score\': 4.7}, {\'name\': \'Product C\', \'score\': 4.5}, {\'name\': \'Product D\', \'score\': 4.9}, {\'name\': \'Product E\', \'score\': 4.8} ] assert top_n_products(products, 3) == [\'Product D\', \'Product E\', \'Product B\'] assert top_n_products(products, 1) == [\'Product D\'] assert top_n_products([], 2) == [] assert top_n_products(products, 5) == [\'Product D\', \'Product E\', \'Product B\', \'Product A\', \'Product C\'] ``` # Notes: - Ensure the function handles large lists efficiently. - Consider using a heap or other suitable data structure for maintaining the top \'n\' elements.","solution":"import heapq def top_n_products(products, n): Returns the top \'n\' products with the highest scores. If two products have the same score, they should be ordered alphabetically by their names. Args: products (list of dict): A list of dictionaries with \'name\' and \'score\' keys. n (int): The number of top products to return. Returns: list of str: A list of product names with the highest scores. if not products or n <= 0: return [] # Min-heap to maintain the top n elements with custom comparator heap = [] for product in products: name, score = product[\'name\'], product[\'score\'] # We use (-score, name) for the min-heap to simulate a max-heap heapq.heappush(heap, (-score, name)) top_products = [] for _ in range(min(n, len(heap))): top_products.append(heapq.heappop(heap)[1]) return top_products"},{"question":"# Scenario You are a software developer working for a company that develops network security tools. One of your tasks is to write a system that detects potential vulnerabilities such as cycles in a network, which can indicate points of failure or security weaknesses. # Task Implement a function that determines if a given directed graph contains any cycles using Depth First Search (DFS). # Function Signature ```python def has_cycle(n, edges): ``` # Inputs - `n` (int): Number of nodes in the graph (`0` to `n-1`). - `edges` (List[Tuple[int, int]]): A list of tuples where each tuple (u, v) represents a directed edge from node `u` to node `v`. # Outputs - A boolean value `True` if the graph contains at least one cycle, otherwise `False`. # Constraints - `1 <= n <= 100` (Ensures the computation is manageable) - There are no duplicate edges or self-loops in the input. # Example Given the graph: ``` n = 4 edges = [ (0, 1), (1, 2), (2, 0), (2, 3) ] ``` The function should output: ``` True ``` Given the graph: ``` n = 5 edges = [ (0, 1), (1, 2), (2, 3), (3, 4), (4, 0) ] ``` The function should output: ``` True ``` Given the graph: ``` n = 3 edges = [ (0, 1), (1, 2) ] ``` The function should output: ``` False ``` # Remarks - Utilize DFS to detect cycles by keeping track of the visitation state of nodes (white, gray, black scheme). - Ensure the solution is efficient given the constraints.","solution":"def has_cycle(n, edges): from collections import defaultdict # Build the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) WHITE, GRAY, BLACK = 0, 1, 2 color = [WHITE] * n def dfs(node): if color[node] == GRAY: # A cycle is detected return True if color[node] == BLACK: # Node is already fully processed return False color[node] = GRAY # Mark the node as being processed for neighbor in graph[node]: if dfs(neighbor): return True color[node] = BLACK # Mark the node as fully processed return False for node in range(n): if dfs(node): return True return False"},{"question":"# Dynamic Array and Linked List Operations In this question, you will design a hybrid data structure that combines the properties of an array and a linked list. This structure should support dynamic resizing like an array and provide efficient insertion and deletion like a linked list. # Objective Implement a `DynamicLinkedArray` class that supports the following operations: - Inserting an element at any position. - Deleting an element at any position. - Accessing an element by its index. - Resizing the internal array dynamically. # Function Signatures 1. `__init__(self, initial_capacity: int = 10) -> None` 2. `insert(self, index: int, value: int) -> None` 3. `delete(self, index: int) -> None` 4. `get(self, index: int) -> int` 5. `resize(self, new_capacity: int) -> None` # Requirements - **Input**: - `initial_capacity`: Initial capacity of the internal array. - `index`: Position at which to insert or delete an element. - `value`: Value to be inserted. - `new_capacity`: New capacity to resize the internal array. - **Output**: - `get`: Should return the value at the specified index. # Example ```python dla = DynamicLinkedArray(initial_capacity=5) dla.insert(0, 10) dla.insert(1, 20) dla.insert(1, 15) assert dla.get(0) == 10 assert dla.get(1) == 15 assert dla.get(2) == 20 dla.delete(1) assert dla.get(1) == 20 dla.resize(10) ``` # Constraints - Manage and maintain internal pointers or references to allow for efficient insertions and deletions. - Ensure that the dynamic resizing maintains the correct order of elements. - Handle edge cases, such as inserting or deleting at the beginning or end of the array. - The initial capacity should be able to expand based on the operations performed.","solution":"class DynamicLinkedArray: def __init__(self, initial_capacity: int = 10) -> None: self.capacity = initial_capacity self.size = 0 self.array = [None] * self.capacity def insert(self, index: int, value: int) -> None: if self.size >= self.capacity: self.resize(self.capacity * 2) if index < 0 or index > self.size: raise IndexError(\\"Index out of bounds\\") for i in range(self.size, index, -1): self.array[i] = self.array[i - 1] self.array[index] = value self.size += 1 def delete(self, index: int) -> None: if index < 0 or index >= self.size: raise IndexError(\\"Index out of bounds\\") for i in range(index, self.size - 1): self.array[i] = self.array[i + 1] # Clear the last element after shifting self.array[self.size - 1] = None self.size -= 1 def get(self, index: int) -> int: if index < 0 or index >= self.size: raise IndexError(\\"Index out of bounds\\") return self.array[index] def resize(self, new_capacity: int) -> None: if new_capacity < self.size: raise ValueError(\\"New capacity must be larger than the current size\\") new_array = [None] * new_capacity for i in range(self.size): new_array[i] = self.array[i] self.array = new_array self.capacity = new_capacity"},{"question":"# Scenario You are tasked with creating a function that manipulates a sequence of numbers to maximize the sum of its elements. However, there is a twist: if two adjacent elements are both positive or both negative, you must insert a zero between them, which will break any contiguous sequence of positive or negative numbers. # Requirements **Function Signature**: ```python def maximize_sum(sequence: list[int]) -> list[int]: pass ``` # Input & Output Formats * `maximize_sum`: * **Input**: A list `sequence` of integers which can include both positive and negative numbers. * **Output**: A modified list where zeros are inserted between any two adjacent numbers that are both positive or both negative, ensuring that the resulting list has no contiguous sequence of positive or negative numbers longer than one element. # Constraints * The input list will contain at least one integer. * The input list can be arbitrarily long within practical computational limits. * Optimize for both time and space efficiency. # Performance Requirements * Time Complexity: O(n) where n is the length of the list. * Space Complexity: O(n) where n is the length of the list. # Example ```python >>> maximize_sum([1, 2, -3, -4, 5]) [1, 0, 2, -3, 0, -4, 0, 5] >>> maximize_sum([3, -5, -6, 7, 8]) [3, -5, 0, -6, 7, 0, 8] ```","solution":"def maximize_sum(sequence): Inserts zeroes between adjacent numbers which are both positive or both negative. :param sequence: List[int] - A list of integers including both positive and negative numbers. :return: List[int] - The modified list. if not sequence: return [] result = [sequence[0]] for i in range(1, len(sequence)): if (sequence[i] > 0 and sequence[i-1] > 0) or (sequence[i] < 0 and sequence[i-1] < 0): result.append(0) result.append(sequence[i]) return result"},{"question":"# Coding Challenge Context/Scenario Your task is to implement an algorithm to determine whether a given linked list contains a cycle. A cycle exists if some node in the list can be reached again by continuously following the `next` pointer. Function Signature Create a function `has_cycle`: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def has_cycle(head: ListNode) -> bool: Given the head of a linked list, determine if the linked list has a cycle in it. Return True if there is a cycle in the linked list, otherwise return False. ``` Expected Input and Output Formats * **Input**: - `head (ListNode)`: The head of the linked list. * **Output**: - `bool`: True if the linked list contains a cycle, False otherwise. Constraints and Limitations - You must use constant O(1) space (i.e., you cannot allocate any additional list or collections). - The algorithm should run in O(n) time where n is the number of nodes in the linked list. Example ```python >>> class ListNode: >>> def __init__(self, val=0, next=None): >>> self.val = val >>> self.next = next >>> node1 = ListNode(3) >>> node2 = ListNode(2) >>> node3 = ListNode(0) >>> node4 = ListNode(-4) >>> node1.next = node2 >>> node2.next = node3 >>> node3.next = node4 >>> node4.next = node2 # Cycle here >>> has_cycle(node1) True >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node1.next = node2 >>> has_cycle(node1) False >>> node1 = ListNode(1) >>> has_cycle(node1) False ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def has_cycle(head: ListNode) -> bool: Given the head of a linked list, determine if the linked list has a cycle in it. Return True if there is a cycle in the linked list, otherwise return False. if not head or not head.next: return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True"},{"question":"# Coding Assessment Question You are tasked with developing a simple library management system that deals with books and members of the library. Specifically, you need to implement functionalities to add books and members and allow members to borrow and return books. Each book and member should be uniquely identifiable. Function Definitions **add_book(library: dict, book_id: str, title: str) -> None** * **Input**: - `library` (dict): The existing library data structure. - `book_id` (str): The unique identifier for the book. - `title` (str): The title of the book. * **Output**: - None, but the function should add the book to the `library`. * **Constraints**: - `book_id` and `title` must be non-empty strings. - A book with the same `book_id` should not already exist in the library. **add_member(library: dict, member_id: str, name: str) -> None** * **Input**: - `library` (dict): The existing library data structure. - `member_id` (str): The unique identifier for the member. - `name` (str): The name of the member. * **Output**: - None, but the function should add the member to the `library`. * **Constraints**: - `member_id` and `name` must be non-empty strings. - A member with the same `member_id` should not already exist in the library. **borrow_book(library: dict, member_id: str, book_id: str) -> bool** * **Input**: - `library` (dict): The existing library data structure. - `member_id` (str): The unique identifier for the member borrowing the book. - `book_id` (str): The unique identifier for the book to be borrowed. * **Output**: - Returns `True` if the book was successfully borrowed, `False` otherwise. * **Constraints**: - The book must exist in the library and not be currently borrowed. - The member must exist in the library. **return_book(library: dict, member_id: str, book_id: str) -> None** * **Input**: - `library` (dict): The existing library data structure. - `member_id` (str): The unique identifier for the member returning the book. - `book_id` (str): The unique identifier for the book to be returned. * **Output**: - None, but the function should process the return of the book. * **Constraints**: - The book must exist in the library and be currently borrowed by the member. # Examples Add Book ```python library = {} add_book(library, \\"B001\\", \\"The Great Gatsby\\") add_book(library, \\"B002\\", \\"To Kill a Mockingbird\\") # library should now have two books indexed by their IDs. ``` Add Member ```python add_member(library, \\"M001\\", \\"Alice\\") add_member(library, \\"M002\\", \\"Bob\\") # library should now have two members indexed by their IDs. ``` Borrow Book ```python borrow_book(library, \\"M001\\", \\"B001\\") # should return True if the book is successfully borrowed. borrow_book(library, \\"M003\\", \\"B001\\") # should return False since member does not exist. borrow_book(library, \\"M001\\", \\"B003\\") # should return False since the book does not exist. ``` Return Book ```python return_book(library, \\"M001\\", \\"B001\\") # should return the book. ``` # Requirements - Ensure that the input validations are handled appropriately. - Maintain the integrity of the library data structure with respect to book availability and borrowing status.","solution":"def add_book(library: dict, book_id: str, title: str) -> None: if not book_id or not title: raise ValueError(\\"book_id and title must be non-empty strings.\\") if \'books\' not in library: library[\'books\'] = {} if book_id in library[\'books\']: raise ValueError(f\\"Book with id {book_id} already exists.\\") library[\'books\'][book_id] = {\'title\': title, \'borrowed_by\': None} def add_member(library: dict, member_id: str, name: str) -> None: if not member_id or not name: raise ValueError(\\"member_id and name must be non-empty strings.\\") if \'members\' not in library: library[\'members\'] = {} if member_id in library[\'members\']: raise ValueError(f\\"Member with id {member_id} already exists.\\") library[\'members\'][member_id] = {\'name\': name, \'borrowed_books\': []} def borrow_book(library: dict, member_id: str, book_id: str) -> bool: if \'books\' not in library or book_id not in library[\'books\']: return False if \'members\' not in library or member_id not in library[\'members\']: return False if library[\'books\'][book_id][\'borrowed_by\'] is not None: return False library[\'books\'][book_id][\'borrowed_by\'] = member_id library[\'members\'][member_id][\'borrowed_books\'].append(book_id) return True def return_book(library: dict, member_id: str, book_id: str) -> None: if \'books\' not in library or book_id not in library[\'books\']: raise ValueError(\\"The book does not exist in the library.\\") if \'members\' not in library or member_id not in library[\'members\']: raise ValueError(\\"The member does not exist in the library.\\") if library[\'books\'][book_id][\'borrowed_by\'] != member_id: raise ValueError(\\"The book is not borrowed by the provided member.\\") library[\'books\'][book_id][\'borrowed_by\'] = None library[\'members\'][member_id][\'borrowed_books\'].remove(book_id)"},{"question":"# Problem Statement You are tasked with writing a function to detect and remove red-eye effect from images. The red-eye effect is the appearance of red pupils in photos taken using a flash. To solve this, you\'ll identify regions in the image representing eyes and adjust their color components to minimize the red-eye effect. # Function Signature ```python def remove_red_eye(img_path: str) -> None: Detects and removes red-eye effect from an image and saves the result. Parameters: img_path (str): The path to the input image file. Returns: None ``` # Input * `img_path` (str): A valid file path to the input image. # Output * The function should save the adjusted image to a file named `red_eye_removed.png` in the current working directory. # Constraints * The function should handle RGB images only. * You may assume that the input image path is valid and the image load operation will succeed. * The function should raise a `ValueError` if the image is not in RGB format. # Performance Requirements * The implementation should efficiently handle images of size up to 2048x2048 pixels. # Example ```python # Remove red-eye effect and save the processed image as \'red_eye_removed.png\' remove_red_eye(\\"image_data/party_photo.jpg\\") ``` # Notes * Use the `numpy` library to efficiently process pixel values. * You may use the `PIL` (Pillow) library to handle image loading and saving. * For simplicity, consider that a pixel is part of a red-eye effect if its red component is significantly higher than both the blue and green components. * Adjust the red component of affected pixels to be the average of the blue and green components. # Hints * Convert the image to a numpy array to perform pixel-wise operations. * Ensure the adjusted pixel values remain within the acceptable range [0, 255].","solution":"from PIL import Image import numpy as np def remove_red_eye(img_path: str) -> None: Detects and removes red-eye effect from an image and saves the result. Parameters: img_path (str): The path to the input image file. Returns: None # Load the image img = Image.open(img_path) # Ensure the image is in RGB format if img.mode != \'RGB\': raise ValueError(\\"Image must be in RGB format\\") # Convert to numpy array for efficient processing img_np = np.array(img) # Define red-eye effect threshold red_threshold = 1.5 # Mark pixels with red-eye effect red_eye_mask = img_np[:,:,0] > (red_threshold * np.maximum(img_np[:,:,1], img_np[:,:,2])) # Adjust the red component of affected pixels img_np[red_eye_mask, 0] = ((img_np[red_eye_mask, 1] + img_np[red_eye_mask, 2]) // 2).astype(np.uint8) # Convert back to PIL image img_no_red_eye = Image.fromarray(img_np) # Save the processed image img_no_red_eye.save(\'red_eye_removed.png\')"},{"question":"**Objective**: Design and implement a function to calculate the first N prime numbers and analyze its performance on large inputs. **Scenario**: You need to generate a list of the first N prime numbers efficiently. Implement a function `first_n_primes` that accepts an integer N and returns a list of the first N prime numbers. Ensure your function handles large values of N effectively, optimizing for both speed and memory usage. **Guidelines**: - You should use an efficient algorithm such as the Sieve of Eratosthenes. - Your function should handle edge cases, such as N being zero or negative. - Consider the runtime complexity and aim to minimize it. **Function Signature**: ```python def first_n_primes(n: int) -> List[int]: ``` **Input Format**: - `n`: An integer representing the number of prime numbers to generate. **Output Format**: - A list of the first N prime numbers. **Constraints**: - `n` should be non-negative. - Your solution should work efficiently for large values of `n`, up to at least 10,000. **Examples**: ```python >>> first_n_primes(5) [2, 3, 5, 7, 11] >>> first_n_primes(0) [] >>> first_n_primes(10) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] ``` **Important Considerations**: - Ensure your implementation uses an efficient algorithm to handle large inputs within a reasonable time frame. - Properly validate the input to handle edge cases gracefully. - The function should return an empty list if `n` is zero or negative.","solution":"from typing import List def first_n_primes(n: int) -> List[int]: Returns a list of the first n prime numbers. if n <= 0: return [] primes = [] sieve = [True] * (n * 15) # Overestimate the size to ensure enough primes are covered sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for p in range(2, len(sieve)): if sieve[p]: primes.append(p) if len(primes) == n: break for multiple in range(p * p, len(sieve), p): sieve[multiple] = False return primes"},{"question":"# Coding Assessment Question Context Given a string containing characters belonging to the set `{ \'(\', \')\', \'[\', \']\', \'{\', \'}\' }`, you need to determine if the string represents a valid sequence of nested and matched parentheses, brackets, and curly braces. Task Write a function `is_valid_sequence` that checks if the input string is a valid sequence of nested parentheses, brackets, and curly braces. * **Input**: * `s` (str): A string containing only characters \'(\', \')\', \'[\', \']\', \'{\', \'}\'. * **Output**: * A boolean value: `True` if the input string is valid, and `False` otherwise. For example: ```python >>> is_valid_sequence(\\"()\\") True >>> is_valid_sequence(\\"([{}])\\") True >>> is_valid_sequence(\\"(]\\") False ``` Constraints * The length of the input string `s` will be between 1 and 10,000 characters. * The input string `s` will only contain the specified characters. Requirements * Your solution should consider the use of appropriate data structures to efficiently determine the maintenance of the correct sequence of matched pairs. * A linear time complexity solution is expected, ideally `O(n)` where `n` is the length of the string. Edge Cases: * Handle cases with a single character string. * Consider strings with nested levels of varying complexity. # Example The following illustrates additional expected results: ```python >>> is_valid_sequence(\\"{[()]}\\") True >>> is_valid_sequence(\\"((())\\") False >>> is_valid_sequence(\\"{[}\\") False ``` # Implement the function below: ```python def is_valid_sequence(s): # Your code here pass ```","solution":"def is_valid_sequence(s): Checks if the input string is a valid sequence of nested parentheses, brackets, and curly braces. Args: s (str): A string containing only characters \'(\', \')\', \'[\', \']\', \'{\', \'}\'. Returns: bool: True if the input string is valid, False otherwise. stack = [] matching_bracket = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} for char in s: if char in \\"([{\\": stack.append(char) elif char in \\")]}\\": if stack and stack[-1] == matching_bracket[char]: stack.pop() else: return False return not stack"},{"question":"# Question: Implementing a Simple In-Memory Cache System You are tasked with building a simple in-memory cache system that stores integer keys and values. This system should support basic cache operations and manage its size using the Least Recently Used (LRU) eviction policy when the cache reaches its maximum capacity. # Task 1. Implement a class `LRUCache` with the following methods: - `__init__(capacity: int)`: Initializes the cache with a given size. - `get(key: int) -> int`: Returns the value associated with the key if it exists in the cache. If the key does not exist, return -1. - `put(key: int, value: int) -> None`: Inserts or updates the value associated with the key. If the cache reached its capacity, it should invalidate the least recently used item before inserting the new item. # Requirements 1. **Implement** the `LRUCache` class such that the `get` and `put` operations are performed in constant time O(1) on average. 2. **Utilize** appropriate data structures to maintain the order of item usage, ensuring the least recently used item can be efficiently identified and removed. # Input: - Sequence of `put` and `get` operations on the cache. # Output: - Results of `get` operations. # Example: ```python cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) # returns 1 cache.put(3, 3) # evicts key 2 print(cache.get(2)) # returns -1 (not found) cache.put(4, 4) # evicts key 1 print(cache.get(1)) # returns -1 (not found) print(cache.get(3)) # returns 3 print(cache.get(4)) # returns 4 ``` # Constraints: - The number of operations will not exceed 10^4. - Capacity will be a positive integer. # Function Signatures: 1. `def __init__(self, capacity: int):` 2. `def get(self, key: int) -> int:` 3. `def put(self, key: int, value: int) -> None:`","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.cache.move_to_end(key, last=True) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key, last=True) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"# Context We have explored the Dijkstra’s algorithm for finding the shortest path from a source vertex to all other vertices in a graph with non-negative weights. Now it\'s time for an implementation challenge to test your understanding of graph traversal and priority queues. # Task Implement a new Python function named `dijkstra_optimized` within the given Graph class to compute the shortest paths from a given source vertex to all other vertices using Dijkstra’s algorithm. Ensure that your implementation is optimized for large graphs. # Input 1. A Graph object representing the graph with vertices and edges. 2. A source vertex from which to compute the shortest paths. # Output 1. A dictionary where the keys are vertices, and the values are the shortest distances from the source vertex to each vertex. # Constraints 1. The number of vertices (V) is at most (10^4). 2. The number of edges (E) is at most (5 times 10^4). 3. All edge weights are non-negative. # Performance Requirements 1. Ensure your solution has a time complexity of at most O(E log V). 2. Utilize a priority queue for efficient vertex selection. # Function Signature ```python class Graph: # (Same as provided in the code snippet) def dijkstra_optimized(self, source: int) -> Dict[int, int]: # Your implementation here pass ``` # Example ```python g = Graph() g = Graph.build([0, 1, 2, 3], [[0, 1, 1], [0, 2, 4], [1, 2, 2], [2, 3, 1], [1, 3, 5]]) shortest_paths = g.dijkstra_optimized(0) print(shortest_paths) # Expected output: # {0: 0, 1: 1, 2: 3, 3: 4} ``` Ensure your implementation adheres to the guidelines and performance constraints provided.","solution":"import heapq from typing import Dict, List, Tuple class Graph: def __init__(self): self.vertices = [] self.edges = {} @staticmethod def build(vertices: List[int], edge_list: List[Tuple[int, int, int]]) -> \'Graph\': graph = Graph() graph.vertices = vertices for u in vertices: graph.edges[u] = [] for u, v, w in edge_list: graph.edges[u].append((v, w)) graph.edges[v].append((u, w)) # Assuming undirected graph return graph def dijkstra_optimized(self, source: int) -> Dict[int, int]: distances = {vertex: float(\'infinity\') for vertex in self.vertices} distances[source] = 0 priority_queue = [(0, source)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in self.edges[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"Task: Create a Robust Function to Convert and Validate DNA Sequences Problem Statement You are given a function that converts a DNA sequence to its RNA complement. DNA sequences consist of the nucleotides: \'A\' (Adenine), \'T\' (Thymine), \'C\' (Cytosine), and \'G\' (Guanine). In RNA, \'T\' is replaced with \'U\' (Uracil). The current function lacks comprehensive validation for input sequences and does not handle certain edge cases. Your task is to improve this function by adding validation checks, handling edge cases, and ensuring robustness. Function Signature ```python def dna_to_rna(dna_sequence: str) -> str: pass ``` Input - `dna_sequence` (str): A string representing the DNA sequence. This is guaranteed to be non-empty. Output - A **string** representing the RNA sequence. Constraints 1. The input string must only contain characters \'A\', \'T\', \'C\', and \'G\'. 2. If the input contains any invalid characters or is an empty string, raise an appropriate `ValueError`. Example ```python >>> dna_to_rna(\\"GATTACA\\") \'GAUUACA\' >>> dna_to_rna(\\"CCGTA\\") \'CCGUA\' >>> dna_to_rna(\\"\\") Traceback (most recent call last): ... ValueError: Input DNA sequence cannot be empty >>> dna_to_rna(\\"GATXACA\\") Traceback (most recent call last): ... ValueError: Invalid character \'X\' in DNA sequence >>> dna_to_rna(\\"ATCG123\\") Traceback (most recent call last): ... ValueError: Invalid character \'1\' in DNA sequence ``` Requirements - Ensure the function handles the conversion accurately. - Add validation to check for invalid characters and empty input. - Raise appropriate errors when constraints are violated.","solution":"def dna_to_rna(dna_sequence: str) -> str: Converts a DNA sequence to its RNA complement. Parameters: dna_sequence (str): A string representing the DNA sequence. Returns: str: A string representing the RNA sequence. Raises: ValueError: If the input contains any invalid characters or is an empty string. if not dna_sequence: raise ValueError(\\"Input DNA sequence cannot be empty\\") # Valid nucleotides for a DNA sequence valid_nucleotides = {\'A\', \'T\', \'C\', \'G\'} # Check for invalid characters for char in dna_sequence: if char not in valid_nucleotides: raise ValueError(f\\"Invalid character \'{char}\' in DNA sequence\\") # Mapping of DNA to RNA complement dna_to_rna_mapping = { \'A\': \'A\', \'T\': \'U\', \'C\': \'C\', \'G\': \'G\' } # Convert the DNA sequence to RNA sequence rna_sequence = \'\'.join(dna_to_rna_mapping[char] for char in dna_sequence) return rna_sequence"},{"question":"# Substring Search Using Knuth-Morris-Pratt Algorithm You are given a text and a pattern. Your task is to implement the Knuth-Morris-Pratt (KMP) algorithm to find all the starting indices of the pattern in the text. # Task 1. Implement the `build_lps` function to construct the longest prefix suffix (LPS) array for the given pattern. 2. Implement the `kmp_search` function to search the pattern in the text using the KMP algorithm. 3. Return a list of starting indices where the pattern is found in the text. # Input - A string `text` representing the text to be searched. - A string `pattern` representing the pattern to search for in the text. # Output A list of integers representing the starting indices of each occurrence of the pattern in the text. # Example ```python text = \\"ababcabcabababd\\" pattern = \\"ababd\\" ``` **Output**: ``` [10] ``` # Constraints - The `text` and `pattern` strings consist only of lowercase English letters. - 1 ≤ len(text), len(pattern) ≤ 100000 # Notes 1. Use the given `build_lps` and `kmp_search` templates to build your solution. 2. Ensure your solution handles edge cases like empty patterns and repeating patterns properly. 3. Optimize for performance, given the constraints. ```python def build_lps(pattern: str) -> list[int]: Build the longest prefix suffix (LPS) array for the pattern. :param pattern: The pattern string for which to build the LPS array. :return: A list of integers representing the LPS array. # Your implementation here def kmp_search(text: str, pattern: str) -> list[int]: Search for the pattern in the text using the KMP algorithm. :param text: The text string in which to search for the pattern. :param pattern: The pattern string to search for in the text. :return: A list of integers representing the starting indices of each occurrence of the pattern. # Your implementation here if __name__ == \\"__main__\\": text = input(\\"Enter the text: \\") pattern = input(\\"Enter the pattern: \\") indices = kmp_search(text, pattern) print(indices) ``` # Remarks * Test the implementation with different test cases provided in the examples. * Consider and properly handle edge cases. * Ensure your implementation is efficient and accurate.","solution":"def build_lps(pattern: str) -> list[int]: Build the longest prefix suffix (LPS) array for the pattern. :param pattern: The pattern string for which to build the LPS array. :return: A list of integers representing the LPS array. lps = [0] * len(pattern) length = 0 # length of the previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def kmp_search(text: str, pattern: str) -> list[int]: Search for the pattern in the text using the KMP algorithm. :param text: The text string in which to search for the pattern. :param pattern: The pattern string to search for in the text. :return: A list of integers representing the starting indices of each occurrence of the pattern. if not pattern: return [] # An empty pattern is not considered for searching lps = build_lps(pattern) result = [] i, j = 0, 0 while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"# Check if Two Strings are Anagrams Context You are part of a software team building a text analysis tool. One of the tasks involves evaluating whether two given strings are anagrams. An anagram is a word or phrase formed by rearranging the letters of another, thus using exactly the same characters in equal quantity. Task Write a Python function that takes two strings and determines whether they are anagrams of each other. Input The function `are_anagrams` takes two arguments: - `str1` (str): The first string. - `str2` (str): The second string. Output The function should return a boolean value: - `True` if the two strings are anagrams of each other. - `False` otherwise. Constraints - Both input strings will contain only lowercase English letters. - The length of each string will be between 1 and 100,000. Example ```python # Given strings str1 = \\"listen\\" str2 = \\"silent\\" # Expected output result = are_anagrams(str1, str2) print(result) # should print: True # Given strings str1 = \\"hello\\" str2 = \\"billion\\" # Expected output result = are_anagrams(str1, str2) print(result) # should print: False ``` Solution Template Here\'s a template to get you started: ```python def are_anagrams(str1: str, str2: str) -> bool: if len(str1) != len(str2): return False # Convert both strings to sorted lists of characters return sorted(str1) == sorted(str2) # Test cases if __name__ == \\"__main__\\": test_cases = [ (\\"listen\\", \\"silent\\"), # True (\\"hello\\", \\"billion\\"), # False (\\"racecar\\", \\"carrace\\"), # True (\\"anagram\\", \\"nagaram\\"), # True (\\"rat\\", \\"car\\"), # False ] for str1, str2 in test_cases: result = are_anagrams(str1, str2) print(f\\"{str1} and {str2} are anagrams: {result}\\") ```","solution":"def are_anagrams(str1: str, str2: str) -> bool: if len(str1) != len(str2): return False # Count the frequency of each character in str1 from collections import Counter counter1 = Counter(str1) counter2 = Counter(str2) # Compare the two frequency maps return counter1 == counter2"},{"question":"# Coding Assessment Question: Find Most Frequent Integer in Array Objective: Write a function that identifies the most frequent integer in an array. If multiple integers are tied for the most frequent, return the smallest one. Detailed Requirements: 1. **Function Signature**: `def most_frequent_integer(arr: list) -> int:` 2. **Input**: A list of integers, `arr`. 3. **Output**: An integer that represents the most frequent integer in the list. If there are ties in frequency, return the smallest integer. 4. **Constraints**: - The input list can be empty, in which case, return `None`. - The array may contain negative and positive integers. - Aim to solve the problem with a time complexity close to O(n). Performance: - Achieve a time complexity of O(n) due to a single pass through the array and potentially another to find the answer. Example: ```python assert most_frequent_integer([1, 2, 2, 3, 3, 4, 4, 4]) == 4 assert most_frequent_integer([1, 1, 2, 2, 3, 3]) == 1 # Tied frequencies, return the smallest assert most_frequent_integer([5, -1, -1, 3, 5, 5]) == 5 assert most_frequent_integer([7]) == 7 assert most_frequent_integer([]) == None ``` Scenario: This function could be particularly useful in data analysis, where you may need to determine the most common element in a dataset. For example, understanding the most frequent user activity on a website or the most common error code in logs can help with pattern recognition and improving system performance. ```python def most_frequent_integer(arr: list) -> int: if not arr: return None frequency = {} for num in arr: if num not in frequency: frequency[num] = 0 frequency[num] += 1 most_frequent = min(arr) max_count = frequency[most_frequent] for num, count in frequency.items(): if count > max_count or (count == max_count and num < most_frequent): most_frequent = num max_count = count return most_frequent # Sample test cases assert most_frequent_integer([1, 2, 2, 3, 3, 4, 4, 4]) == 4 assert most_frequent_integer([1, 1, 2, 2, 3, 3]) == 1 assert most_frequent_integer([5, -1, -1, 3, 5, 5]) == 5 assert most_frequent_integer([7]) == 7 assert most_frequent_integer([]) == None ```","solution":"def most_frequent_integer(arr: list) -> int: if not arr: return None frequency = {} for num in arr: if num not in frequency: frequency[num] = 0 frequency[num] += 1 most_frequent = min(arr) max_count = frequency[most_frequent] for num, count in frequency.items(): if count > max_count or (count == max_count and num < most_frequent): most_frequent = num max_count = count return most_frequent"},{"question":"# Coding Assessment Question You are given a collection of stock prices for each day. You need to determine the maximum possible profit from buying on one day and selling on another day later in the time series. # Task Write a Python function that does the following: 1. Reads in a list of integers representing stock prices over a series of days. 2. Determines the maximum profit that can be made by buying on one day and selling on a later day. 3. If it\'s impossible to make a profit (i.e., prices continue to decline or there is only one price), return the string \\"No Profit Possible\\". # Requirements 1. **Input**: A list of integers representing stock prices. 2. **Output**: An integer value representing the maximum profit, or a string message as specified above. 3. **Constraints**: * The list input can have up to 1,000,000 elements. * The input list can be empty or contain only one element. In these cases, the function should return the string \\"No Profit Possible\\". # Performance: * The function must handle large lists efficiently, making sure to run in linear time. Examples: ```python # Example 1: input_prices = [7, 1, 5, 3, 6, 4] max_profit(input_prices) # Output: 5 # Example 2: input_prices = [7, 6, 4, 3, 1] max_profit(input_prices) # Output: \\"No Profit Possible\\" # Example 3: input_prices = [] max_profit(input_prices) # Output: \\"No Profit Possible\\" ``` # Function Definition ```python def max_profit(prices): if len(prices) < 2: return \\"No Profit Possible\\" min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit if max_profit > 0 else \\"No Profit Possible\\" ``` Ensure that the implementation is efficient and can manage large input sizes within the given constraints. The solution should be optimized to run in O(n) time complexity.","solution":"def max_profit(prices): Determines the maximum profit that can be made by buying on one day and selling on a later day. Parameters: prices (list of int): List of integers representing stock prices over a series of days. Returns: int or str: Maximum profit that can be made, or \\"No Profit Possible\\" if no profit can be made. if len(prices) < 2: return \\"No Profit Possible\\" min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit if max_profit > 0 else \\"No Profit Possible\\""},{"question":"# Coding Assessment Question Context You are tasked with improving an image processing function to handle large datasets efficiently. This enhanced function should not only apply a transformation to the image but also dynamically allocate processing resources for optimal performance. Requirements Modify the provided `image_transform` function to: 1. Implement parallel processing: distribute different portions of the image across multiple cores to expedite the task. 2. Dynamically allocate resources based on system capabilities and image size. 3. Ensure that no portion of the image is overlooked and that all resources are utilized efficiently. Constraints * `image` will be a 2D list of integers where each integer represents a pixel value. * `transform_fn` is a callable function that takes an integer as input and outputs an integer. * Assume availability of multiprocessing libraries. * Suitable error handling for potential exceptions during parallel execution must be included. Input & Output # Input * `image`: List[List[int]] — a 2D list representing the image. * `transform_fn`: Callable[[int], int] — a function to transform the pixel value. # Output * Returns a 2D list of the same dimensions as `image`, where each pixel value has been transformed. Example ```python >>> def example_transform(val): >>> return val * 2 >>> image = [ >>> [1, 2, 3], >>> [4, 5, 6], >>> [7, 8, 9] >>> ] >>> transformed_image = parallel_image_transform(image, example_transform) >>> for row in transformed_image: >>> print(row) [2, 4, 6] [8, 10, 12] [14, 16, 18] ``` Function Signature ```python def parallel_image_transform( image: List[List[int]], transform_fn: Callable[[int], int] ) -> List[List[int]]: pass ```","solution":"import multiprocessing from typing import List, Callable def parallel_image_transform(image: List[List[int]], transform_fn: Callable[[int], int]) -> List[List[int]]: Apply a transformation to an image using parallel processing. Args: - image (List[List[int]]): A 2D list representing the image. - transform_fn (Callable[[int], int]): A function to transform the pixel value. Returns: - List[List[int]]: The transformed image. def worker(sub_image, transform_fn, results, idx): transformed_sub_image = [[transform_fn(pixel) for pixel in row] for row in sub_image] results[idx] = transformed_sub_image num_cores = multiprocessing.cpu_count() image_height = len(image) chunk_size = (image_height + num_cores - 1) // num_cores # Ceiling division # Distribute the image into chunks based on the number of cores. chunks = [image[i * chunk_size:(i + 1) * chunk_size] for i in range(num_cores)] manager = multiprocessing.Manager() results = manager.dict() jobs = [] for idx, chunk in enumerate(chunks): p = multiprocessing.Process(target=worker, args=(chunk, transform_fn, results, idx)) jobs.append(p) p.start() for proc in jobs: proc.join() # Collect the results and flatten the list transformed_image = [] for idx in sorted(results.keys()): transformed_image.extend(results[idx]) return transformed_image"},{"question":"# Problem Statement Given an unsorted array of integers `nums` and a target integer `k`, implement a function `find_pairs_with_sum(nums: list[int], k: int) -> list[tuple[int, int]]` which finds all unique pairs of elements in the array that add up to the given sum `k`. Write a function that returns a list of all unique pairs `(a, b)` such that `a + b = k` and `a <= b`. Each pair should be a tuple sorted in ascending order. The list of pairs should also be sorted lexicographically. If no such pairs exist, return an empty list. # Function Signature ```python def find_pairs_with_sum(nums: list[int], k: int) -> list[tuple[int, int]]: ``` # Input - `nums`: A list of integers which can contain both positive and negative numbers, and may have duplicates. - `k`: An integer representing the target sum. # Output - Return a list of tuples representing the unique pairs `(a, b)` where `a + b = k` and `a <= b`. Each tuple in the list should be in ascending order, and the list itself should be sorted lexicographically. # Constraints - The length of `nums` is between `0` and `10^4`. - The values in `nums` are integers, potentially both negative and positive. - The target sum `k` is an integer. # Example ```python >>> find_pairs_with_sum([1, 2, 3, 4, 3, 5, 0, -1, -2], 3) [(-2, 5), (-1, 4), (0, 3), (1, 2)] >>> find_pairs_with_sum([1, 1, 1, 1, 1], 2) [(1, 1)] >>> find_pairs_with_sum([], 3) [] >>> find_pairs_with_sum([1, 2, 2, 3, 4], 5) [(1, 4), (2, 3)] ``` # Note - Ensure the function handles duplicate elements in the input list correctly and does not include duplicate pairs in the result. - The pairs `(a, b)` should be listed in lexicographical order where `a <= b`. Write your function in a clean, organized manner with proper handling of edge cases and constraints.","solution":"def find_pairs_with_sum(nums, k): Finds all unique pairs of integers in the list that add up to the given sum k. Each pair (a, b) is such that a <= b and the list of pairs is sorted lexicographically. :param nums: List of integers. :param k: Target sum integer. :return: List of tuples representing the unique pairs (a, b). seen = set() pairs = set() for num in nums: target = k - num if target in seen: pairs.add(tuple(sorted((num, target)))) seen.add(num) return sorted(list(pairs))"},{"question":"# Programming Question: Reconstructing Palindromic Strings You are tasked with a problem involving the reconstruction of palindromic strings. Specifically, you need to determine if a given string can be rearranged to form a palindrome. If it can, print \\"YES\\". If it cannot, print \\"NO\\". A palindrome is a string that reads the same backward as forward, e.g., \\"racecar\\" or \\"abba\\". Write a Python function: ```python def is_reconstructable_palindrome(s: str) -> str: pass ``` # Input * A string `s` (1 <= len(s) <= 10^6) which consists of only lowercase letters. # Output * Return \\"YES\\" if the string can be rearranged to form a palindrome, otherwise return \\"NO\\". # Constraints * Optimize the function for time considering the length of the input string. # Example ```python >>> is_reconstructable_palindrome(\\"racecar\\") \\"YES\\" >>> is_reconstructable_palindrome(\\"aabb\\") \\"YES\\" >>> is_reconstructable_palindrome(\\"abc\\") \\"NO\\" ``` # Notes: * To be able to rearrange a string to form a palindrome, at most one character can have an odd frequency. All other characters must have an even frequency. * Ensure that the function handles large strings efficiently.","solution":"def is_reconstructable_palindrome(s: str) -> str: Determines if a string can be rearranged to form a palindrome. Args: s (str): The input string. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\". from collections import Counter # Count frequency of each character in the string char_count = Counter(s) # Count the number of characters with odd frequencies odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged into a palindrome if it has at most one character with an odd count if odd_count > 1: return \\"NO\\" return \\"YES\\""},{"question":"# Objective Given a set of students with their grades in different subjects, write a function to calculate each student\'s GPA and the class average GPA. Assume each subject carries the same weight. # Function Implementation Function 1: Calculate Student GPA - **Function Name**: `student_gpa` - **Input**: - `grades` (List[float]): A list of the student\'s grades in various subjects. - **Output**: (float) The calculated GPA for the student. - **Constraints**: - Each grade must be between 0.0 and 4.0 (inclusive). Function 2: Calculate Class Average GPA - **Function Name**: `class_average_gpa` - **Input**: - `all_grades` (List[List[float]]): A list where each element is a list representing a single student\'s grades. - **Output**: (float) The average GPA for the entire class. - **Constraints**: - At least one student must be present. - Each grade within the nested lists must be between 0.0 and 4.0 (inclusive). # Error Handling - Raise ValueError with appropriate messages in the following conditions: - A grade outside the range of 0.0 to 4.0 in both `student_gpa` and `class_average_gpa`. - An empty list of grades for a student in `student_gpa`. - An empty `all_grades` list with no students in `class_average_gpa`. # Example ```python from typing import List def student_gpa(grades: List[float]) -> float: # Implement the function as specified above def class_average_gpa(all_grades: List[List[float]]) -> float: # Implement the function as specified above ``` Sample Usage ```python # Calculate a student\'s GPA student_gpa([3.5, 2.7, 4.0, 3.8]) # Expected output: 3.5 # Calculate the class average GPA class_average_gpa([[3.5, 2.7, 4.0, 3.8], [3.0, 3.1, 3.2, 3.3]]) # Expected output: 3.325 ``` # Notes - Ensure your solution handles edge cases and constraints effectively. - Consider using the built-in `sum` and `len` functions to simplify your implementation.","solution":"from typing import List def student_gpa(grades: List[float]) -> float: if not grades: raise ValueError(\\"Grades list cannot be empty.\\") for grade in grades: if not 0.0 <= grade <= 4.0: raise ValueError(f\\"Grade {grade} is out of acceptable range 0.0 to 4.0.\\") return sum(grades) / len(grades) def class_average_gpa(all_grades: List[List[float]]) -> float: if not all_grades: raise ValueError(\\"All grades list cannot be empty.\\") total_gpa = 0 student_count = 0 for grades in all_grades: if not grades: raise ValueError(\\"Grades list for a student cannot be empty.\\") for grade in grades: if not 0.0 <= grade <= 4.0: raise ValueError(f\\"Grade {grade} is out of acceptable range 0.0 to 4.0.\\") total_gpa += student_gpa(grades) student_count += 1 return total_gpa / student_count"},{"question":"# Data Structure Comparison: Sorting Algorithm Efficiency Context: As a software engineer, you are tasked with optimizing a data processing pipeline. You need to compare the efficiencies of different sorting algorithms on various types of input data. Your goal is to implement a function that, given an unsorted list, applies two different sorting algorithms and returns the time taken for each to sort the list. Problem: Write a function `sort_comparison` that takes a list of integers and compares the performance of two sorting algorithms: Merge Sort and Quick Sort. The function should return the time taken by each algorithm to sort the input list. Specifications: 1. **Function Signature:** ```python def sort_comparison(data: List[int]) -> Tuple[float, float]: Compares the time taken by Merge Sort and Quick Sort to sort the given list. :param data: List of integers to be sorted. :return: A tuple containing the time taken by Merge Sort and Quick Sort, respectively. ``` 2. **Input:** - `data`: A list of integers. 3. **Output:** - A tuple containing two float values: the time taken by Merge Sort and Quick Sort, respectively. 4. **Constraints:** - Use Python\'s `time` module to measure the timing of each algorithm. - Ensure the function handles edge cases such as empty lists and lists with duplicate elements. Example Usage: ```python from typing import List, Tuple import time def merge_sort(data: List[int]) -> List[int]: if len(data) <= 1: return data mid = len(data) // 2 left = merge_sort(data[:mid]) right = merge_sort(data[mid:]) return merge(left, right) def merge(left: List[int], right: List[int]) -> List[int]: result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result def quick_sort(data: List[int]) -> List[int]: if len(data) <= 1: return data pivot = data[len(data) // 2] left = [x for x in data if x < pivot] middle = [x for x in data if x == pivot] right = [x for x in data if x > pivot] return quick_sort(left) + middle + quick_sort(right) def sort_comparison(data: List[int]) -> Tuple[float, float]: start_time = time.time() merge_sort(data.copy()) merge_sort_time = time.time() - start_time start_time = time.time() quick_sort(data.copy()) quick_sort_time = time.time() - start_time return merge_sort_time, quick_sort_time data = [38, 27, 43, 3, 9, 82, 10] merge_time, quick_time = sort_comparison(data) print(f\\"Merge Sort Time: {merge_time}\\") print(f\\"Quick Sort Time: {quick_time}\\") ``` **Important:** - Ensure the sorting algorithms are implemented correctly and handle various input types. - Accurately capture and compare the timing for each algorithm.","solution":"from typing import List, Tuple import time def merge_sort(data: List[int]) -> List[int]: if len(data) <= 1: return data mid = len(data) // 2 left = merge_sort(data[:mid]) right = merge_sort(data[mid:]) return merge(left, right) def merge(left: List[int], right: List[int]) -> List[int]: result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result def quick_sort(data: List[int]) -> List[int]: if len(data) <= 1: return data pivot = data[len(data) // 2] left = [x for x in data if x < pivot] middle = [x for x in data if x == pivot] right = [x for x in data if x > pivot] return quick_sort(left) + middle + quick_sort(right) def sort_comparison(data: List[int]) -> Tuple[float, float]: start_time = time.time() merge_sort(data.copy()) merge_sort_time = time.time() - start_time start_time = time.time() quick_sort(data.copy()) quick_sort_time = time.time() - start_time return merge_sort_time, quick_sort_time"},{"question":"# Stock Price Alert System You are tasked with creating a system that monitors stock prices and sends an alert when the price of a specified stock crosses a certain threshold. The system will have to retrieve the current stock price from a provided URL and compare it to a given target price. Implement the following two functions: 1. **get_stock_price**: This function should fetch the current price of a stock from a given URL and return it as a floating-point number. * **Input**: A string representing the URL from which to fetch the stock price. * **Output**: A float representing the current stock price. * **Constraints**: - Ensure the function handles network timeouts appropriately. - The function must correctly parse the stock price from the HTML or JSON response. 2. **check_stock_price**: This function should compare the fetched stock price with a target price and print an alert message if the stock price exceeds the target price. * **Input**: Two arguments: - A string representing the URL of the stock price. - A float representing the target stock price. * **Output**: None (prints an alert message if the condition is met). * **Constraints**: - The message should include the current stock price and the target price. - The function must handle any errors related to fetching the stock price or invalid data. # Example ```python # Example usage if __name__ == \\"__main__\\": stock_url = \\"https://api.example.com/stock/AAPL\\" target_price = 150.0 check_stock_price(stock_url, target_price) ``` # Notes - Ensure robust error handling and consider edge cases such as missing or incomplete data. - For testing purposes, you can use mock URLs or predefined JSON content to simulate different scenarios. - Performance considerations: avoid unnecessary computations and handle network-related delays efficiently.","solution":"import requests def get_stock_price(url): Fetch the current stock price from a given URL. Args: - url (str): The URL from which to fetch the stock price. Returns: - float: The current stock price. try: response = requests.get(url, timeout=10) response.raise_for_status() data = response.json() # Assuming the JSON response has the stock price under the \'price\' key return float(data[\'price\']) except requests.exceptions.RequestException as e: print(f\\"Error fetching the stock price: {e}\\") except (ValueError, KeyError) as e: print(f\\"Error parsing the stock price from response: {e}\\") def check_stock_price(url, target_price): Compare the fetched stock price with a target price and print an alert message if the stock price exceeds the target price. Args: - url (str): The URL of the stock price. - target_price (float): The target stock price. Returns: - None current_price = get_stock_price(url) if current_price: if current_price > target_price: print(f\\"Alert: The stock price is {current_price}, which exceeds the target price of {target_price}.\\")"},{"question":"# Coding Assessment Question Context You are tasked to improve the efficiency of a search algorithm for a large dataset by implementing a method to find the kth smallest element in an unsorted array. This method should be efficient even for large datasets. Requirements Implement the `kth_smallest` function using the Quickselect algorithm, which efficiently finds the kth smallest element in an unsorted array without entirely sorting the array. This function should handle large datasets and different values of k efficiently. Constraints * The array `arr` will contain n integers where 1 <= n <= 10^6. * `k` will be an integer within the range 1 <= k <= n. Input & Output # Input * `arr`: List[int] — an unsorted list of integers. * `k`: int — the kth smallest element to find in the array (1-based index). # Output * Returns an integer — the kth smallest element in the array. Example ```python >>> arr = [7, 10, 4, 3, 20, 15] >>> k = 3 >>> kth_smallest_element = kth_smallest(arr, k) >>> print(kth_smallest_element) 7 >>> arr = [7, 10, 4, 3, 20, 15] >>> k = 4 >>> kth_smallest_element = kth_smallest(arr, k) >>> print(kth_smallest_element) 10 ``` Function Signature ```python def kth_smallest(arr: List[int], k: int) -> int: pass ```","solution":"def kth_smallest(arr, k): Find the kth smallest element in an unsorted list using the Quickselect algorithm. def partition(left, right, pivot_index): pivot_value = arr[pivot_index] # Move pivot to end arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left # Move all smaller elements to the left for i in range(left, right): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 # Move pivot to its final place arr[right], arr[store_index] = arr[store_index], arr[right] return store_index def select(left, right, k_smallest): # If the list contains only one element, return that element if left == right: return arr[left] # Select a random pivot_index between left and right pivot_index = left + (right - left) // 2 pivot_index = partition(left, right, pivot_index) # The pivot is in its final sorted position if k_smallest == pivot_index: return arr[k_smallest] # Go left elif k_smallest < pivot_index: return select(left, pivot_index - 1, k_smallest) # Go right else: return select(pivot_index + 1, right, k_smallest) return select(0, len(arr) - 1, k - 1)"},{"question":"```markdown **Graph Traversal on Weighted Grids** # Problem Statement You are given an `n x m` grid where each cell contains a non-negative integer representing the weight of that cell. Starting from the top-left cell (0, 0), your goal is to find the minimum cost to reach the bottom-right cell (n-1, m-1). You can only move right or down from any cell. Write a function `min_cost_path(grid: List[List[int]]) -> int` that calculates and returns the minimum cost to traverse from the top-left to the bottom-right of the grid. # Input Format - `grid` (List[List[int]]): A 2D list representing the grid with dimensions `n x m` (1 ≤ n, m ≤ 100) - Each element `grid[i][j]` is a non-negative integer (0 ≤ grid[i][j] ≤ 1000) # Output Format - Return the minimum cost (int) to reach the bottom-right cell from the top-left cell. # Constraints - The dimensions `n` and `m` of the grid are at most 100. - Each cell in the grid has a weight between 0 and 1000 inclusive. - Always consider you have at least one valid path from the top-left to the bottom-right. # Examples ```python def min_cost_path(grid: List[List[int]]) -> int: # Your implementation here pass # Example usage: print(min_cost_path([ [1, 3, 1], [1, 5, 1], [4, 2, 1] ])) # Output: 7 print(min_cost_path([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ])) # Output: 21 print(min_cost_path([ [1] ])) # Output: 1 ``` # Hints 1. Use dynamic programming to keep track of the minimum cost to reach each cell. 2. The cost to reach a cell is the weight of the cell plus the minimum cost to reach any of its incoming neighbors (i.e., from the top or left cell). 3. Initialize the cost of the starting point as its weight, and update the cost for each cell iteratively. ```","solution":"from typing import List def min_cost_path(grid: List[List[int]]) -> int: n = len(grid) m = len(grid[0]) # Create a 2D list for storing the minimum cost for each cell dp = [[0] * m for _ in range(n)] # Initialize the cost for the starting cell (top-left) dp[0][0] = grid[0][0] # Initialize the first row (only movement is from the left) for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column (only movement is from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) # The answer is the cost to reach the bottom-right cell return dp[n-1][m-1]"},{"question":"# Scenario You are working on a text processing tool that involves modifying words in a sentence based on certain pattern matching and transformation rules. # Problem Statement Your task is to implement a function: 1. `transform_sentence(sentence: str, pattern: str, replacement: str) -> str`: This function takes a sentence, a pattern, and a replacement string as input. It replaces all words in the sentence that match the given pattern with the replacement string. # Input and Output Formats **Function: `transform_sentence`** - **Input**: - `sentence` (string): A string representing the sentence. - `pattern` (string): A string representing the word pattern to match. The pattern uses the character `*` to match any sequence of characters within a word. - `replacement` (string): A string representing the word to replace the matched pattern. - **Output**: - A string representing the sentence after all matching words have been replaced. # Constraints - The sentence consists of words separated by single spaces. There will be no punctuation. - The pattern will contain only lowercase letters and the `*` character. - The replacement string will contain only lowercase letters. - The length of the sentence will not exceed 1000 characters. - The length of the pattern and replacement string will not exceed 100 characters. # Examples ```python sentence = \\"hello world hell\\" pattern = \\"he*\\" replacement = \\"hi\\" transform_sentence(sentence, pattern, replacement) # should return \\"hi world hi\\" sentence = \\"banana band bandana\\" pattern = \\"ba*\\" replacement = \\"tar\\" transform_sentence(sentence, pattern, replacement) # should return \\"tar tar tar\\" sentence = \\"foo bar baz\\" pattern = \\"b*\\" replacement = \\"bee\\" transform_sentence(sentence, pattern, replacement) # should return \\"foo bee bee\\" ``` # Explanation - For the sentence \\"hello world hell\\", the pattern \\"he*\\" matches the words \\"hello\\" and \\"hell\\", so they are replaced with \\"hi\\". - For the sentence \\"banana band bandana\\", the pattern \\"ba*\\" matches the words \\"banana\\", \\"band\\", and \\"bandana\\", so they are replaced with \\"tar\\". - For the sentence \\"foo bar baz\\", the pattern \\"b*\\" matches the words \\"bar\\" and \\"baz\\", so they are replaced with \\"bee\\". By implementing the `transform_sentence` function, you will be able to effortlessly replace words in a sentence based on flexible pattern matching rules.","solution":"import re def transform_sentence(sentence: str, pattern: str, replacement: str) -> str: Replaces all words in the sentence that match the given pattern with the replacement string. Parameters: sentence (str): The input sentence containing words. pattern (str): The pattern to match words. The \'*\' in the pattern matches any sequence of characters. replacement (str): The replacement string for words matching the pattern. Returns: str: The transformed sentence with matching words replaced. # Convert the pattern to a proper regex pattern regex_pattern = pattern.replace(\'*\', \'.*\') # Split the sentence into words words = sentence.split() # Apply the replacement if the word matches the pattern transformed_words = [replacement if re.fullmatch(regex_pattern, word) else word for word in words] # Join the transformed words back into a sentence transformed_sentence = \' \'.join(transformed_words) return transformed_sentence"},{"question":"# Unique Character String In this task, you are required to determine whether a given string has all unique characters without using additional data structures. Problem Statement Implement a function `has_unique_characters(s: str) -> bool` that checks if the given string `s` contains all unique characters. # Input * `s` (string): an input string containing any printable ASCII characters. # Output * A boolean: - `True` if all characters in the string are unique. - `False` if there are any duplicate characters in the string. # Constraints * The input string can contain any printable ASCII characters, including spaces and punctuation. * The function should not use additional data structures (e.g., sets or dictionaries). # Function Signature ```python def has_unique_characters(s: str) -> bool: pass ``` # Examples ```python >>> has_unique_characters(\\"abcdef\\") True >>> has_unique_characters(\\"aabcdef\\") False >>> has_unique_characters(\\"12345\\") True >>> has_unique_characters(\\"123451\\") False >>> has_unique_characters(\\"!@#%^&*()_-+=<>?\\") True >>> has_unique_characters(\\"hello world\\") False ``` # Instructions - Implement your solution without using additional data structures (like sets or dictionaries). - Optimize the function to execute efficiently. - Ensure the function works correctly for edge cases, such as empty strings and strings with a single character. - Follow good coding practices, ensuring the code is clean and well-documented.","solution":"def has_unique_characters(s: str) -> bool: Checks if the given string `s` contains all unique characters. :param s: Input string containing any printable ASCII characters. :return: True if all characters in the string are unique, False otherwise. # ASCII Character set has 128 unique characters if len(s) > 128: return False # Iterate over the string and use a bit vector to keep track of seen characters checker = 0 for char in s: val = ord(char) if (checker & (1 << val)) > 0: return False checker |= (1 << val) return True"},{"question":"# Scenario You are tasked with developing an interactive calculator for a software application tailored towards financial analysts. The calculator needs to support the following operations: addition, subtraction, multiplication, and division. An additional feature is required that calculates the compound interest based on user input. # Task Implement the function `financial_calculator` that performs basic arithmetic operations and calculates compound interest. # Function Signature ```python def financial_calculator(operations: List[Tuple[str, float, float]], compound_data: Tuple[float, float, int]) -> Tuple[List[float], float]: ``` # Input - `operations`: A list of tuples where each tuple contains: - A string representing the operation (`\'add\'`, `\'subtract\'`, `\'multiply\'`, `\'divide\'`) - Two floats which are the operands for the operation. - `compound_data`: A tuple containing: - The principal amount (float). - The annual interest rate (float, in percentage). - The number of years (int) for which the interest is to be calculated. # Output - Returns a tuple containing: - A list of floats representing the results of the arithmetic operations in the order they appear in the input list. - A float representing the compounded amount after the specified number of years. # Constraints - The input list `operations` contains between 1 to 10 tuples. - The input `compound_data` will always have valid non-negative values. - Division by zero should return `\'undefined\'` for that operation\'s result. - The interest is compounded annually. # Example ```python operations = [(\'add\', 1.5, 2.5), (\'subtract\', 10, 4.5), (\'multiply\', 3, 3), (\'divide\', 9, 3)] compound_data = (1000, 5, 10) print(financial_calculator(operations, compound_data)) # Expected output: ([4.0, 5.5, 9.0, 3.0], 1628.89) ``` # Notes - Your compound interest calculation can use the formula ( A = P left(1 + frac{r}{100}right)^n ) where: * ( P ) is the principal amount. * ( r ) is the annual interest rate. * ( n ) is the number of years. * ( A ) is the amount of money accumulated after n years, including interest. - If division by zero is encountered during any arithmetic operation, append `\'undefined\'` to the result list for that operation. Implement the `financial_calculator` function to fulfill these requirements.","solution":"from typing import List, Tuple def financial_calculator(operations: List[Tuple[str, float, float]], compound_data: Tuple[float, float, int]) -> Tuple[List[float], float]: results = [] for operation, x, y in operations: if operation == \'add\': results.append(x + y) elif operation == \'subtract\': results.append(x - y) elif operation == \'multiply\': results.append(x * y) elif operation == \'divide\': if y == 0: results.append(\'undefined\') else: results.append(x / y) principal, rate, years = compound_data compound_amount = principal * ((1 + (rate / 100)) ** years) return results, round(compound_amount, 2)"},{"question":"# Context You are creating a \\"Currency Converter\\" application that provides users with the ability to convert amounts from one currency to another using the latest exchange rates from an external API. It is essential to handle possible failures and provide meaningful feedback. # Task Write a Python function that retrieves the latest exchange rates from the ExchangeRate-API and converts a given amount from one currency to another. Your function should handle potential errors gracefully and return a meaningful message in case of any issues. # Function Signature ```python def convert_currency(amount: float, from_currency: str, to_currency: str) -> dict: ``` # Requirements - Your function should return a dictionary with three keys: `\\"converted_amount\\"`, `\\"rate\\"`, and `\\"error\\"`. - `\\"converted_amount\\"`: Contains the converted amount. - `\\"rate\\"`: Contains the exchange rate used for the conversion. - `\\"error\\"`: Contains an error message if there was any issue during the process. - If there is a failure in fetching the exchange rates, it should return the error message `\\"Failed to fetch exchange rates.\\"`. - Handle different HTTP status codes (4xx and 5xx) with appropriate messages. - Do not change the `API_ENDPOINT_URL` provided. - Assume the API returns data in JSON format with a structure similar to: ```json { \\"base\\": \\"USD\\", \\"rates\\": { \\"EUR\\": 0.842, \\"GBP\\": 0.751, ... } } ``` # Constraints - Use the built-in **requests** library. - Each request should have a timeout of 5 seconds (`timeout=5`). - The `amount` parameter will always be a positive float, and `from_currency` and `to_currency` parameters will always be valid ISO currency codes represented as strings. # Example Usage ```python result = convert_currency(100, \'USD\', \'EUR\') if result[\'error\']: print(\\"Error:\\", result[\'error\']) else: print(f\\"Converted amount: {result[\'converted_amount\']} at rate {result[\'rate\']}\\") ``` # Notes - Consider using exception handling for managing timeouts and HTTP errors. - Ensure that all exceptions are caught, and appropriate messages are returned in the `\\"error\\"` key. - Use a loop for retries if necessary, but you are not required to implement retries unless you deem it necessary for robustness.","solution":"import requests API_ENDPOINT_URL = \\"https://api.exchangerate-api.com/v4/latest/\\" def convert_currency(amount: float, from_currency: str, to_currency: str) -> dict: Convert amount from one currency to another using the latest exchange rates. Parameters: - amount (float): The amount of money to convert. - from_currency (str): The three-letter currency code to convert from. - to_currency (str): The three-letter currency code to convert to. Returns: - dict: A dictionary containing the converted amount, exchange rate, and an error message if any. try: response = requests.get(f\\"{API_ENDPOINT_URL}{from_currency}\\", timeout=5) if response.status_code != 200: return {\\"converted_amount\\": None, \\"rate\\": None, \\"error\\": \\"Failed to fetch exchange rates.\\"} data = response.json() rates = data.get(\'rates\', {}) if to_currency not in rates: return {\\"converted_amount\\": None, \\"rate\\": None, \\"error\\": f\\"Exchange rate for \'{to_currency}\' not found.\\"} rate = rates[to_currency] converted_amount = amount * rate return {\\"converted_amount\\": converted_amount, \\"rate\\": rate, \\"error\\": None} except requests.Timeout: return {\\"converted_amount\\": None, \\"rate\\": None, \\"error\\": \\"Request timed out.\\"} except requests.RequestException: return {\\"converted_amount\\": None, \\"rate\\": None, \\"error\\": \\"Failed to fetch exchange rates.\\"}"},{"question":"# Scenario You are working on optimizing a database query performance for large datasets. One common approach is to pre-compute and store the results of frequently executed queries. Your task is to simulate this by caching the results of Fibonacci number calculations, a commonly used sequence in computational problems. # Task Implement a function `fibonacci_with_cache` that computes the nth Fibonacci number using memoization to cache previously computed values. The Fibonacci sequence is defined as: ``` F(0) = 0, F(1) = 1 F(n) = F(n-1) + F(n-2) for n > 1 ``` Your function should efficiently handle computing large Fibonacci numbers by storing and reusing results of subproblems. # Function Signature ```python def fibonacci_with_cache(n: int) -> int: ``` # Input 1. `n`: An integer representing the position in the Fibonacci sequence to calculate. (0 ≤ n ≤ 1000) # Output An integer representing the nth Fibonacci number. # Constraints - Ensure that the function performs efficiently for the entire input range by using memoization or dynamic programming. - Handle large values of `n` within the given constraints without running into performance issues. # Example ```python print(fibonacci_with_cache(10)) # Expected Output: 55 print(fibonacci_with_cache(50)) # Expected Output: 12586269025 ``` # Notes 1. Use an appropriate data structure (like a dictionary) to store intermediate Fibonacci values that have been computed. 2. Avoid recomputation by checking if a Fibonacci value has already been cached before performing new calculations. 3. Test the function with different values of `n` including boundary cases such as 0, 1, and large numbers up to 1000 to ensure correctness and performance.","solution":"def fibonacci_with_cache(n: int, cache={}) -> int: Computes the nth Fibonacci number using memoization to cache previously computed values. :param n: An integer representing the position in the Fibonacci sequence to calculate. :param cache: A dictionary used to store previously computed Fibonacci numbers. :return: The nth Fibonacci number. if n in cache: return cache[n] if n == 0: return 0 if n == 1: return 1 cache[n] = fibonacci_with_cache(n-1, cache) + fibonacci_with_cache(n-2, cache) return cache[n]"},{"question":"# Elevator System Simulation # Problem Statement: You are to design a basic elevator system simulator. The building has one elevator and multiple floors, and the task is to implement the logic to handle elevator requests. The elevator operates using the following rules: 1. The elevator starts at floor 0. 2. Upon receiving a list of requests, each request being a tuple of (start_floor, end_floor), the elevator processes each request in the order they appear. 3. The elevator moves to the `start_floor` to pick up the passenger and then moves to the `end_floor` to drop off the passenger. 4. The elevator should keep track of the floors it stops at, including intermediate floors when moving between requested floors. 5. The final output should be a list of all floors the elevator stops at in sequence. # Function Signature: ```python def elevator_simulation(requests: list[tuple[int, int]]) -> list[int]: Simulates the elevator movements based on the given list of requests. :param requests: List of tuples where each tuple contains two integers: the start floor and the end floor of the request. :return: List of integers representing the floors the elevator stops at in order. ``` # Constraints: * The number of floors in the building is sufficiently large (e.g., 1000 floors). * The requests list can contain up to 1000 requests. * The floor values in the requests can range from 0 to 999 (both inclusive). # Input/Output Examples: ```python requests = [(0, 5), (1, 3), (3, 2)] print(elevator_simulation(requests)) # Expected Output: # [0, 5, 1, 3, 2] requests = [(2, 6), (6, 0), (3, 8)] print(elevator_simulation(requests)) # Expected Output: # [0, 2, 6, 0, 3, 8] ``` Implement the function `elevator_simulation` that simulates the elevator\'s movements and returns the list of floors it stops at based on the given requests.","solution":"def elevator_simulation(requests): Simulates the elevator movements based on the given list of requests. :param requests: List of tuples where each tuple contains two integers: the start floor and the end floor of the request. :return: List of integers representing the floors the elevator stops at in order. current_floor = 0 stops = [current_floor] for start_floor, end_floor in requests: if start_floor != current_floor: stops.append(start_floor) current_floor = start_floor if end_floor != current_floor: stops.append(end_floor) current_floor = end_floor return stops"},{"question":"# Problem Statement You are tasked with implementing a function that determines if a string exists as a contiguous subsequence within another string. A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. The function should return `True` if the first string (subsequence) is found within the second string (main sequence), otherwise return `False`. # Function Signature ```python def is_subsequence(subseq: str, main_seq: str) -> bool: Determines if `subseq` is a contiguous subsequence of `main_seq`. Args: subseq (str): The subsequence to search for. main_seq (str): The main sequence to search within. Returns: bool: True if `subseq` is a subsequence of `main_seq`, False otherwise. ``` # Input Constraints - `subseq` and `main_seq` are non-empty strings. - Both strings have lengths between 1 and 1000 characters inclusive. - The search is case-sensitive. # Output Format - Return `True` if the subsequence exists within the main sequence. - Return `False` if the subsequence does not exist within the main sequence. # Example ```python print(is_subsequence(\\"abc\\", \\"aebfc\\")) # Output: True print(is_subsequence(\\"axc\\", \\"ahbgdc\\")) # Output: False print(is_subsequence(\\"ace\\", \\"abcde\\")) # Output: True print(is_subsequence(\\"aec\\", \\"abcde\\")) # Output: False ``` # Evaluation Criteria - Correctness: The function should accurately identify subsequences. - Efficiency: The function should run within acceptable time limits for the given input size. - Edge Cases: The function should handle edge cases such as very short and very long strings effectively.","solution":"def is_subsequence(subseq, main_seq): Determines if `subseq` is a contiguous subsequence of `main_seq`. Args: subseq (str): The subsequence to search for. main_seq (str): The main sequence to search within. Returns: bool: True if `subseq` is a subsequence of `main_seq`, False otherwise. if not subseq: return True subseq_idx = 0 for char in main_seq: if char == subseq[subseq_idx]: subseq_idx += 1 if subseq_idx == len(subseq): return True return False"},{"question":"# Coding Assessment Question: Implementing a Genetic Algorithm for Optimization Context You are developing an optimization solution using a genetic algorithm to solve a problem where the goal is to maximize a given fitness function. Genetic algorithms are a class of optimization techniques inspired by natural selection, where candidate solutions are evolved over generations based on their fitness. Task Write a function that applies a genetic algorithm to optimize a given fitness function. The function should return the best solution found and its corresponding fitness value after a defined number of generations. Function Signature ```python def genetic_algorithm(fitness_function: callable, population_size: int, chromosome_length: int, generations: int, crossover_rate: float, mutation_rate: float) -> tuple[list[int], float]: ``` Input Format * `fitness_function`: A callable function that takes a list of integers (representing a chromosome) and returns a float (the fitness value). * `population_size`: An integer representing the number of chromosomes in the population. * `chromosome_length`: An integer representing the number of genes in each chromosome. * `generations`: An integer representing the number of generations to evolve the population. * `crossover_rate`: A float representing the probability of crossover between pairs of chromosomes. * `mutation_rate`: A float representing the probability of mutating a gene in a chromosome. Output Format * The function returns a tuple: * The first element is a list of integers representing the best chromosome found. * The second element is a float representing the fitness value of the best chromosome. Constraints * You can assume the `fitness_function` is defined and valid. * `population_size`, `chromosome_length`, and `generations` will be positive integers. * `crossover_rate` and `mutation_rate` will be floats between 0 and 1 (inclusive). Example ```python import random def sample_fitness_function(chromosome): # Example fitness function: sum of the chromosome return sum(chromosome) # Define parameters for the genetic algorithm population_size = 10 chromosome_length = 5 generations = 20 crossover_rate = 0.7 mutation_rate = 0.01 best_chromosome, best_fitness = genetic_algorithm(sample_fitness_function, population_size, chromosome_length, generations, crossover_rate, mutation_rate) print(f\\"Best chromosome: {best_chromosome}\\") print(f\\"Best fitness: {best_fitness}\\") ``` **Note:** - Implement the typical steps of a genetic algorithm including initial population generation, selection, crossover, mutation, and replacement. - Ensure the algorithm handles edge cases and converges to an optimal or near-optimal solution.","solution":"import random def genetic_algorithm(fitness_function: callable, population_size: int, chromosome_length: int, generations: int, crossover_rate: float, mutation_rate: float) -> tuple[list[int], float]: # Generate initial population def generate_chromosome(): return [random.randint(0, 1) for _ in range(chromosome_length)] population = [generate_chromosome() for _ in range(population_size)] def select_parent(population): weights = [fitness_function(chrom) for chrom in population] total_fitness = sum(weights) selection_probs = [fitness/total_fitness for fitness in weights] return population[random.choices(range(len(population)), weights=selection_probs, k=1)[0]] def crossover(parent1, parent2): if random.random() < crossover_rate: point = random.randint(1, chromosome_length - 1) return parent1[:point] + parent2[point:], parent2[:point] + parent1[point:] else: return parent1, parent2 def mutate(chromosome): return [gene if random.random() > mutation_rate else 1 - gene for gene in chromosome] best_chromosome = None best_fitness = float(\'-inf\') for _ in range(generations): new_population = [] for _ in range(population_size // 2): parent1 = select_parent(population) parent2 = select_parent(population) offspring1, offspring2 = crossover(parent1, parent2) new_population.append(mutate(offspring1)) new_population.append(mutate(offspring2)) population = new_population for chrom in population: fitness = fitness_function(chrom) if fitness > best_fitness: best_chromosome, best_fitness = chrom, fitness return best_chromosome, best_fitness"},{"question":"# Scenario You are developing a component for an e-commerce application that provides customized shipping cost calculations based on item weight. The shipping cost is determined by different weight bands, with each band having a distinct rate. # Task Implement a method `calculate_shipping()` that calculates the shipping cost based on the weight of the item using predefined weight bands and rates. The weight bands and rates are provided as a list of tuples, where each tuple contains the upper limit of the weight band and the rate per unit weight for that band. # Function Signature Below is the method you need to implement within a class `ShippingCalculator`: ```python def calculate_shipping(self, weight: float) -> float: Calculate the shipping cost based on the weight of the item. Args: weight (float): The weight of the item. Returns: float: The calculated shipping cost. ``` # Input * A floating-point value `weight` representing the weight of the item to be shipped. * The class `ShippingCalculator` has an attribute `weight_bands` which is a list of tuples. Each tuple contains: * a floating-point `limit` representing the upper limit of the weight band (exclusive). * a floating-point `rate` representing the rate per unit weight for that band. # Output * A floating-point value representing the calculated shipping cost. # Constraints * 0 <= weight <= 1000 * 0 < limit <= 1000 for any given weight band * All rates and weights are valid floating-point numbers. # Expected Complexity * Expected time complexity is O(N), where N is the number of weight bands. * Expected space complexity is O(1). # Example Usage ```python bands = [(2.0, 5.0), (5.0, 4.0), (10.0, 3.0), (float(\'inf\'), 2.0)] calculator = ShippingCalculator(bands) print(calculator.calculate_shipping(3.5)) # Expected output: 14.0 print(calculator.calculate_shipping(6.0)) # Expected output: 18.0 ``` # Note To calculate the shipping cost, iterate through the weight bands and accumulate the cost according to the rates until the entire weight is covered. Ensure to handle edge cases, such as weights that fall exactly on the boundary of two bands.","solution":"class ShippingCalculator: def __init__(self, weight_bands): self.weight_bands = weight_bands def calculate_shipping(self, weight: float) -> float: remaining_weight = weight cost = 0.0 for limit, rate in self.weight_bands: if remaining_weight > limit: cost += limit * rate remaining_weight -= limit else: cost += remaining_weight * rate break return cost"},{"question":"# Task: In this task, you need to implement the Run-Length Encoding (RLE) compression algorithm. This algorithm replaces sequences of the same data values occurring in many consecutive data elements with a count and a single value. # Problem Statement: Write a Python function `run_length_encoding(data: str) -> str` that takes a string consisting only of uppercase letters and returns an encoded string using Run-Length Encoding. # Function Signature: ```python def run_length_encoding(data: str) -> str: ``` # Input: * `data`: A string consisting only of uppercase letters (A-Z) with a length of at most 10^4. # Output: * A string that represents the Run-Length Encoded data. # Constraints: * The input string will contain only uppercase English letters. * The input string will not be empty. # Example: Given a string: ``` \\"AAABBCCDDDDEE\\" ``` The steps: 1. Identify sequences of the same character. 2. Replace the sequence with the character followed by the number of occurrences in the sequence. # Implementation Details: - Implement a helper function if necessary to handle the counting and encoding of sequences. - Ensure to handle edge cases such as sequences with a length of one. # Example Call: ```python data = \\"AAABBCCDDDDEE\\" encoded_data = run_length_encoding(data) print(encoded_data) ``` # Expected Output: ``` \\"A3B2C2D4E2\\" ``` # Additional Example: Example Call: ```python data = \\"XYZ\\" encoded_data = run_length_encoding(data) print(encoded_data) ``` Expected Output: ``` \\"X1Y1Z1\\" ```","solution":"def run_length_encoding(data: str) -> str: if not data: return \\"\\" encoded_str = \\"\\" current_char = data[0] count = 1 for char in data[1:]: if char == current_char: count += 1 else: encoded_str += f\\"{current_char}{count}\\" current_char = char count = 1 # Append the last set of characters encoded_str += f\\"{current_char}{count}\\" return encoded_str"},{"question":"You are required to modify the function `fetch_data` to maximize its efficiency and reliability. The original function retrieves data from a specified URL using HTTP requests. It simply performs a basic GET request and returns the response content without any further processing or optimization. Objective Refactor the function `fetch_data` to: 1. Improve error handling and robustness. 2. Optimize performance for large or slow data transfers. 3. Include mechanisms to retry failed attempts or recover from transient network issues. Requirements - **Input**: - `url`: A string representing the URL to fetch data from. - `testing`: A boolean flag indicating if the function is running in test mode. - **Output**: - The content retrieved from the URL as a string. - **Constraints**: - Assume the server uses standard HTTP port (80 or 443). - Ensure the function can handle large responses efficiently (up to 500MB). Performance Requirements - Implement efficient data retrieval techniques to minimize memory usage. - Ensure the function does not hang indefinitely and implements proper timeout support. Edge Cases & Error Handling - Gracefully handle scenarios where the URL is invalid or the server is unreachable. - Manage HTTP errors, such as 4xx and 5xx statuses, appropriately. - Implement retry mechanisms for transient errors. - Support timeouts for connection setup and data transfer phases. # Scenario You are developing a web scraping tool that needs to fetch data from various unreliable web servers efficiently and reliably. It should ensure robust performance even when faced with large datasets or transient network issues. Function Signature ```python def fetch_data(url: str, testing: bool = False) -> str: # Your improved implementation here ``` Example Consider the URL `http://example.com/data`. ```python content = fetch_data(\\"http://example.com/data\\", testing=True) ``` The function should retrieve the data from the URL, handle any potential issues gracefully, and return the content as a string. Ensure the function can deal with common network problems and optimize performance for large data transfers.","solution":"import requests from requests.adapters import HTTPAdapter from requests.packages.urllib3.util.retry import Retry def fetch_data(url: str, testing: bool = False) -> str: Fetch data from a specified URL, optimized for reliability and efficiency. Args: url (str): The URL to fetch data from. testing (bool): A boolean flag indicating if the function is running in test mode. Returns: str: The content retrieved from the URL. Raises: Exception: If there is a failure in fetching the data. try: session = requests.Session() retries = Retry(total=5, backoff_factor=1, status_forcelist=[500, 502, 503, 504]) session.mount(\'http://\', HTTPAdapter(max_retries=retries)) session.mount(\'https://\', HTTPAdapter(max_retries=retries)) response = session.get(url, timeout=(5, 30), stream=True) response.raise_for_status() content_length = response.headers.get(\'Content-Length\') if content_length is not None and int(content_length) > 500 * 1024 * 1024: raise Exception(\\"Response too large\\") content = [] for chunk in response.iter_content(chunk_size=1024): if chunk: content.append(chunk) return b\'\'.join(content).decode(\'utf-8\') except requests.exceptions.RequestException as e: if testing: print(f\\"Request failed: {e}\\") raise Exception(\\"Error fetching data\\") from e"},{"question":"# Coding Assessment Question: Scenario: In an effort to manage warehouse inventory efficiently, you need to implement a function that determines the maximum number of units that can be stored within a limited number of storage bins, given their varying sizes and unit capacities. Function Specification: Write a function `maximize_storage(bins: List[int], max_bins: int) -> int` that computes the maximum number of units that can fit into a specified number of bins out of the given list. Input: * `bins`: a list of integers representing the unit capacities of different bins. (1 <= len(bins) <= 10^5, 1 <= bins[i] <= 10^4) * `max_bins`: an integer `k` representing the maximum number of bins that can be used. (1 <= k <= len(bins)) Output: * Returns an integer representing the maximum number of units that can be stored using the most efficient selection of bins. Constraints: * Raise a `ValueError` if `max_bins` is greater than the length of `bins` or less than 1. * Raise a `TypeError` if `bins` contains non-integer values. Examples: ```python >>> maximize_storage([3, 6, 2, 8, 7, 4], 3) 21 >>> maximize_storage([10, 20, 5, 5, 5], 2) 30 >>> maximize_storage([15, 8, 7, 14, 6], 5) 50 >>> maximize_storage([1, 2, 3, 4, 5], 10) Traceback (most recent call last): ... ValueError: max_bins should be in the range of 1 to len(bins) >>> maximize_storage([3, 6, \'a\', 8], 2) Traceback (most recent call last): ... TypeError: All bin capacities must be integers ``` Notes: 1. Consider edge cases such as `max_bins` equal to the length of the bins list or containing large numbers. 2. Validate inputs carefully and ensure the function handles errors gracefully. 3. Aim for an efficient implementation that can scale with the input size.","solution":"from typing import List def maximize_storage(bins: List[int], max_bins: int) -> int: Computes the maximum number of units that can fit into the specified number of bins. Parameters: bins (List[int]): List of integers representing the unit capacities of different bins. max_bins (int): Integer representing the maximum number of bins that can be used. Returns: int: Maximum number of units that can be stored using the most efficient selection of bins. if max_bins < 1 or max_bins > len(bins): raise ValueError(\\"max_bins should be in the range of 1 to len(bins)\\") if not all(isinstance(bin, int) for bin in bins): raise TypeError(\\"All bin capacities must be integers\\") # Sort bins in descending order of their sizes to maximize the storage sorted_bins = sorted(bins, reverse=True) # Sum up the capacities of the largest \'max_bins\' bins return sum(sorted_bins[:max_bins])"},{"question":"# Dictionary Flattening Challenge Description: You need to write a function that flattens a nested dictionary. The keys from the nested dictionary should be concatenated with underscores `_` to represent the structure hierarchy in the flattened output. Objectives: 1. Implement the function `flatten_dictionary` that takes a nested dictionary and returns a flattened dictionary with keys representing the hierarchy from the original nested structure. 2. The resultant keys should be in the form of concatenated keys from each level of the hierarchy, separated by underscores `_`. 3. If the input is an empty dictionary, the function should return an empty dictionary. Function Signature: ```python def flatten_dictionary(nested_dict: dict) -> dict: pass ``` Constraints: - The input dictionary can be arbitrarily nested. - Keys in the input dictionary will be strings, and values will either be strings, dictionaries, or other JSON serializable types. - Maintain the same value types in the output as in the input. Example: ```python nested_dict = { \\"a\\": 1, \\"b\\": { \\"c\\": 2, \\"d\\": { \\"e\\": 3 } }, \\"f\\": { \\"g\\": 4 } } result = flatten_dictionary(nested_dict) # Expected result: {\'a\': 1, \'b_c\': 2, \'b_d_e\': 3, \'f_g\': 4} ``` # Testing: - Implement unit tests to verify the correct flattening of nested structures. - Make sure to handle various depths of nesting and any empty structures within the dictionary properly. This sample question aligns with the style, complexity, and scope of the provided examples, maintaining consistency across the set while addressing a different aspect of data manipulation in programming.","solution":"def flatten_dictionary(nested_dict): Flattens a nested dictionary. The keys from the nested dictionary are concatenated with underscores (_) to represent the structure hierarchy in the flattened output. Args: nested_dict (dict): The input nested dictionary. Returns: dict: The flattened dictionary with keys representing the hierarchy from the original nested structure. def _flatten(current_dict, parent_key, sep=\\"_\\"): items = [] for k, v in current_dict.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(_flatten(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items) return _flatten(nested_dict, \\"\\") # Example usage: # nested_dict = {\\"a\\": 1, \\"b\\": {\\"c\\": 2, \\"d\\": {\\"e\\": 3}}, \\"f\\": {\\"g\\": 4}} # print(flatten_dictionary(nested_dict)) # Output: {\'a\': 1, \'b_c\': 2, \'b_d_e\': 3, \'f_g\': 4}"},{"question":"# Given Problem You are required to implement a function that applies a series of updates to an input string according to specified rules and returns the final updated string. The updates consist of insertions, deletions, and replacements. # Requirements 1. **Function Name**: update_string 2. **Arguments**: - `input_string` (str): The initial string to be updated. - `operations` (List[Tuple[str, int, Union[str, None]]]): A list of tuples representing the operations to be performed. Each tuple contains: - Operation type (one of `insert`, `delete`, `replace`), - Index (int): The position in the string where the operation takes place, - Character (str): The character to be inserted or replaced with, or `None` if not applicable. 3. **Output**: Return the updated string after all operations are applied. 4. **Constraints**: - Indices are 0-based. - All index values are within the bounds of the string\'s length at the moment the operation is applied. - If an `insert` operation contains an index equal to the string length, the character is appended at the end. - Operations are applied in the order they appear in the list. # Examples ```python # Insert and delete operations update_string(\\"hello\\", [(\\"insert\\", 5, \\"!\\"), (\\"delete\\", 4, None)]) # Output: \\"hell!\\" # Replace and insert operations update_string(\\"apple\\", [(\\"replace\\", 1, \\"p\\"), (\\"insert\\", 5, \\"!\\")]) # Output: \\"apple!\\" # Delete and insert operations update_string(\\"test\\", [(\\"delete\\", 0, None), (\\"insert\\", 3, \\"s\\")]) # Output: \\"ests\\" ``` # Implementation Write the function `update_string` to meet the above requirements. **Function Signature**: ```python def update_string(input_string: str, operations: List[Tuple[str, int, Union[str, None]]]) -> str: pass ``` **Notes**: - Ensure you handle invalid input scenarios. - The function should efficiently manage the string updates according to the given operations.","solution":"from typing import List, Tuple, Union def update_string(input_string: str, operations: List[Tuple[str, int, Union[str, None]]]) -> str: # Convert the string to a list to allow modification str_list = list(input_string) for operation in operations: op_type, index, char = operation if op_type == \\"insert\\": str_list.insert(index, char) elif op_type == \\"delete\\": del str_list[index] elif op_type == \\"replace\\": str_list[index] = char # Convert the list back to a string and return return \'\'.join(str_list)"},{"question":"# Question: You are given a list of integers, and you need to identify the subarray with the maximum sum. Additionally, your task is to implement this functionality to return both the maximum sum and the indices of the subarray that form this maximum sum. This problem can be solved efficiently using dynamic programming. Requirements: 1. Implement the function `max_subarray_sum` that should return a tuple containing: - The maximum sum (integer). - A list of two integers representing the starting and ending indices (inclusive) of the subarray with the maximum sum. Input: - `nums`: list of int (each integer represents a number in the array) Output: - Tuple (int, list of two integers) representing the maximum sum and the corresponding indices # Constraints: - 1 <= `len(nums)` <= 10^5 - -10^4 <= `nums[i]` <= 10^4 # Examples: ```python nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4] assert max_subarray_sum(nums) == (6, [3, 6]) nums = [1] assert max_subarray_sum(nums) == (1, [0, 0]) nums = [5, 4, -1, 7, 8] assert max_subarray_sum(nums) == (23, [0, 4]) ``` # Notes: - The function should handle empty lists appropriately by returning a tuple containing 0 and an empty list. - In case there are multiple subarrays with the same maximum sum, return the one with the smallest starting index. - The implementation should consider the principles of dynamic programming for efficient computation. # Implementation: Implement the `max_subarray_sum` function in Python. ```python def max_subarray_sum(nums): if not nums: return 0, [] max_sum = current_sum = nums[0] start = end = 0 temp_start = 0 for i in range(1, len(nums)): if current_sum < 0: current_sum = nums[i] temp_start = i else: current_sum += nums[i] if current_sum > max_sum: max_sum = current_sum start = temp_start end = i return max_sum, [start, end] # Test cases print(max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4])) # (6, [3, 6]) print(max_subarray_sum([1])) # (1, [0, 0]) print(max_subarray_sum([5, 4, -1, 7, 8])) # (23, [0, 4]) ```","solution":"def max_subarray_sum(nums): if not nums: return 0, [] max_sum = current_sum = nums[0] start = end = 0 temp_start = 0 for i in range(1, len(nums)): if current_sum < 0: current_sum = nums[i] temp_start = i else: current_sum += nums[i] if current_sum > max_sum: max_sum = current_sum start = temp_start end = i return max_sum, [start, end]"},{"question":"# Question: Smallest Multiple of Consecutive Numbers **Problem Description:** You are tasked with writing a function `smallest_multiple(n: int) -> int` that finds the smallest positive number that is evenly divisible by all of the numbers from 1 to `n`. **Function Signature:** ```python def smallest_multiple(n: int) -> int: ``` **Input:** - `n` (1 ≤ n ≤ 40): An integer representing the upper bound of consecutive numbers. **Output:** - Returns an integer which is the smallest positive number that is evenly divisible by all of the numbers from 1 to `n`. **Example:** ```python print(smallest_multiple(10)) # Expected output: 2520 print(smallest_multiple(5)) # Expected output: 60 print(smallest_multiple(20)) # Expected output: 232792560 print(smallest_multiple(15)) # Expected output: 360360 ``` **Constraints:** - You need to handle the upper limit of `n` efficiently. - Make sure to use an algorithm that minimizes the number of operations to avoid timing out on larger inputs. **Notes:** - The function should leverage mathematical properties of the least common multiple (LCM). - Consider using efficient calculation methods such as the Euclidean algorithm for computing the greatest common divisor (GCD) and using it to find the LCM.","solution":"import math def lcm(a, b): Helper function to calculate Least Common Multiple (LCM) of two numbers return abs(a*b) // math.gcd(a, b) def smallest_multiple(n: int) -> int: Function to find the smallest positive number that is evenly divisible by all numbers from 1 to n answer = 1 for i in range(2, n + 1): answer = lcm(answer, i) return answer"},{"question":"# Problem Statement: You are tasked with developing a basic file system simulation, where you need to handle directory operations. Specifically, you need to create directories and list the contents. Implement a function to manage the directory creation and listing path in a hierarchical manner. # Function Signature: ```python def simulate_file_system(operations: List[Tuple[str, str]]) -> List[str]: Simulate the file system operations. Args: operations: List of tuples, where each tuple contains: - command (str): Either \\"mkdir\\" or \\"ls\\". - path (str): A directory path for the command. Returns: List of strings, where each string represents the output of the \'ls\' command. ``` # Input: * `operations`: A list of tuples, where each tuple contains: * `command` (str): Either \\"mkdir\\" or \\"ls\\". * `path` (str): A directory path for the command. Paths are strings that may include \'/\' to denote hierarchy. # Output: * A list of strings, where each string represents the output of the \'ls\' command, listing contents of the directory specified in the path. The contents should be listed in lexicographical order. # Constraints: * 1 <= len(operations) <= 500 * Paths will be valid and of reasonable length (<= 100 characters). * It is guaranteed that the paths in the \'mkdir\' operations are unique and hierarchical. # Example: ```python operations = [ (\\"mkdir\\", \\"/a/b/c\\"), (\\"mkdir\\", \\"/a/b/d\\"), (\\"ls\\", \\"/a/b\\"), (\\"mkdir\\", \\"/x/y\\"), (\\"ls\\", \\"/x\\"), (\\"ls\\", \\"/\\") ] output = simulate_file_system(operations) print(output) # should output the contents of the directories according to the ls commands # Example output: # [ # \\"cnd\\", # \\"y\\", # \\"anx\\" # ] ``` # Notes: * Directories should be created only if the parent exists; otherwise, assume the parent directories are already created. * Listing a directory with no children should return an empty string. * Handle the operations in the order they are listed in the input.","solution":"from typing import List, Tuple def simulate_file_system(operations: List[Tuple[str, str]]) -> List[str]: file_system = {} def mkdir(path): parts = path.split(\'/\') cur = file_system for part in parts: if part: if part not in cur: cur[part] = {} cur = cur[part] def ls(path): parts = path.split(\'/\') cur = file_system for part in parts: if part: cur = cur[part] return \'n\'.join(sorted(cur.keys())) results = [] for command, path in operations: if command == \\"mkdir\\": mkdir(path) elif command == \\"ls\\": results.append(ls(path)) return results"},{"question":"# Coding Assessment Question: Graph Algorithms for Shortest Paths Context You are tasked with developing part of a navigation system that calculates the shortest paths in a road network. The road network is represented as a weighted, directed graph, and you need to implement an algorithm to determine the shortest path from a given starting node to all other nodes in the graph. To achieve this, you decide to implement Dijkstra\'s algorithm. Task Implement the graph and the shortest path calculation using Dijkstra\'s algorithm. The required functionality is as follows: 1. **Graph Construction**: Build the graph given a list of edges. 2. **Dijkstra\'s Algorithm**: Compute the shortest paths from a given start node to all other nodes. Input and Output Formats 1. **build_graph(edges: List[Tuple[int, int, int]]) -> Dict[int, List[Tuple[int, int]]** - `edges`: A list of edges, where each edge is represented by a tuple of three integers `(u, v, w)` indicating an edge from node `u` to node `v` with weight `w`. ```python edges = [ (1, 2, 4), (1, 3, 2), ... (4, 5, 6) ] ``` - Returns a dictionary representing the adjacency list of the graph, where the keys are node identifiers and the values are lists of tuples `(neighbor, weight)`. 2. **dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]** - `graph`: The graph represented as an adjacency list. - `start`: The starting node for the shortest path calculation. - Returns a dictionary where the keys are node identifiers and the values are the shortest distances from the start node to each node. Constraints - The graph can contain up to 10,000 nodes and 50,000 edges. - Handle cases where the graph may not be connected. - Ensure the algorithm is efficient and follows the time complexity of O((V + E) log V) where V is the number of nodes and E is the number of edges. Example Usage ```python edges = [ (1, 2, 4), (1, 3, 2), (2, 3, 5), (3, 4, 1), (4, 5, 6) ] graph = build_graph(edges) start_node = 1 shortest_paths = dijkstra(graph, start_node) print(f\\"Shortest paths from node {start_node}: {shortest_paths}\\") ``` Notes - Handle edge cases such as negative weights (Dijkstra\'s algorithm does not support graphs with negative weight edges), disconnected components, and graphs with cycles. - Document any assumptions or design decisions in your code comments. This question aligns with the given requirements in terms of style, complexity, and scope, and extends the assessment to the domain of graph algorithms and shortest path calculations.","solution":"import heapq from typing import List, Tuple, Dict def build_graph(edges: List[Tuple[int, int, int]]) -> Dict[int, List[Tuple[int, int]]]: Builds the graph from a list of edges. Args: edges (List[Tuple[int, int, int]]): A list of tuples representing the edges in the graph. Returns: Dict[int, List[Tuple[int, int]]]: The adjacency list representation of the graph. graph = {} for u, v, w in edges: if u not in graph: graph[u] = [] graph[u].append((v, w)) # Assuming it\'s a directed graph; otherwise, uncomment the lines below # if v not in graph: # graph[v] = [] # graph[v].append((u, w)) return graph def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]: Computes the shortest path from the start node to all other nodes using Dijkstra\'s algorithm. Args: graph (Dict[int, List[Tuple[int, int]]]): The adjacency list representation of the graph. start (int): The starting node. Returns: Dict[int, int]: A dictionary with the shortest distance to each node from the start node. # Priority queue to keep track of the shortest path pq = [(0, start)] # Dictionary to store the shortest path distance to each node distances = {start: 0} # While there are nodes to process while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > distances.get(current_node, float(\'inf\')): continue for neighbor, weight in graph.get(current_node, []): distance = current_distance + weight if distance < distances.get(neighbor, float(\'inf\')): distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances"},{"question":"# Reversing Words in a String # Objective Write a function that takes a string as input and returns a new string with the words in reverse order. Words are defined as sequences of non-space characters separated by spaces. The reversed string should maintain the original spacing and punctuation. # Input * A single string containing a sequence of words and spaces. # Output * Return a new string with the words in reverse order. # Constraints * Do not use any external libraries (standard library functions are allowed). * Function signature should be: `def reverse_words(input_string: str) -> str`. # Example ```python def reverse_words(input_string: str) -> str: # Implement the function here # Example Usage: print(reverse_words(\\"The quick brown fox\\")) # Output: \\"fox brown quick The\\" print(reverse_words(\\"hello world!\\")) # Output: \\"world! hello\\" print(reverse_words(\\"a b c d\\")) # Output: \\"d c b a\\" ``` # Notes 1. Multiple spaces between words should be treated as a single space. 2. Leading or trailing spaces should be preserved in the reversed string. 3. Punctuation marks attached to words should stay with the words after reversal. This question requires handling string manipulation and takes care of preserving the spaces, thus testing the ability to manipulate and process strings effectively.","solution":"def reverse_words(input_string: str) -> str: Takes a string as input and returns a new string with the words in reverse order. Preserves leading, trailing, and multiple spaces between words. words = input_string.split() reversed_words = \' \'.join(reversed(words)) return reversed_words"},{"question":"# Coding Assessment Question Scenario You are working as a software engineer at a finance company, and you have been tasked with simulating a simple stock trading algorithm. The algorithm buys and sells stocks to maximize profit based on the daily prices of a particular stock. You need to implement a function that computes the maximum profit that can be achieved by making at most two transactions. Task Write a Python function `max_profit_with_two_transactions(prices: list) -> int` that calculates the maximum profit achievable with at most two transactions. Function Signature ```python def max_profit_with_two_transactions(prices: list) -> int: ``` Input - `prices`: a list of integers where each integer represents the stock price on a given day. Output - Return an integer representing the maximum profit achievable with at most two transactions. Constraints - The length of `prices` can range from 0 to 10^5. - All numbers in `prices` will be non-negative integers. - The function should handle cases where no transactions are profitable gracefully. Examples ```python >>> max_profit_with_two_transactions([3, 3, 5, 0, 0, 3, 1, 4]) 6 >>> max_profit_with_two_transactions([1, 2, 3, 4, 5]) 4 >>> max_profit_with_two_transactions([7, 6, 4, 3, 1]) 0 >>> max_profit_with_two_transactions([1, 2]) 1 ``` Requirements - Your solution must ensure that all edge cases are handled properly. - Provide an efficient algorithm with a time complexity better than O(n^2). By adding this question, we maintain consistent difficulty and scope while exploring a different but related area—stock trading—allowing us to assess the candidate\'s understanding of dynamic programming and optimization problems.","solution":"def max_profit_with_two_transactions(prices: list) -> int: n = len(prices) if n < 2: return 0 # Initialize the profits from two transactions profit_after_first_buy = -prices[0] profit_after_first_sell = 0 profit_after_second_buy = float(\'-inf\') profit_after_second_sell = 0 for price in prices: profit_after_second_sell = max(profit_after_second_sell, profit_after_second_buy + price) profit_after_second_buy = max(profit_after_second_buy, profit_after_first_sell - price) profit_after_first_sell = max(profit_after_first_sell, profit_after_first_buy + price) profit_after_first_buy = max(profit_after_first_buy, -price) return profit_after_second_sell"},{"question":"# File Synchronization Utility You are asked to create a utility that synchronizes the contents of two directories by copying any files that are missing or have been updated. Problem Statement Implement a function `sync_directories(src: str, dest: str) -> None` that: 1. Synchronizes the `src` directory to the `dest` directory. 2. Copies any new or updated files from `src` to `dest`. 3. Deletes any files in `dest` that are not present in `src`. 4. Uses efficient file comparison to detect changes (e.g., based on timestamps and file sizes). Input and Output Formats * **Input**: * `src` (string): The path to the source directory. * `dest` (string): The path to the destination directory. * **Output**: * None. The function should perform the synchronization action but doesn\'t return anything. Constraints: * Both paths provided (`src` and `dest`) will be valid directories. * Directories may contain nested subdirectories and files. * The function should handle large directories efficiently. Example ```python # Example usage sync_directories(\\"/path/to/source\\", \\"/path/to/destination\\") ``` # Additional Notes: - Ensure proper error handling for file access permissions and other common file I/O issues. - Use logging to report actions such as files copied, updated, or deleted for transparency.","solution":"import os import shutil from pathlib import Path import filecmp def sync_directories(src: str, dest: str) -> None: Synchronizes the `src` directory to the `dest` directory. Copies any new or updated files from `src` to `dest`. Deletes any files in `dest` that are not present in `src`. src = Path(src) dest = Path(dest) # Synchronize source to destination for src_dir, _, files in os.walk(src): relative_dir = os.path.relpath(src_dir, src) dest_dir = dest / relative_dir dest_dir.mkdir(parents=True, exist_ok=True) for file in files: src_file = Path(src_dir) / file dest_file = dest_dir / file if not dest_file.exists() or not filecmp.cmp(src_file, dest_file, shallow=False): shutil.copy2(src_file, dest_file) # Clean up destination directory to remove extraneous files for dest_dir, _, files in os.walk(dest): relative_dir = os.path.relpath(dest_dir, dest) src_dir = src / relative_dir for file in files: src_file = src_dir / file dest_file = Path(dest_dir) / file if not src_file.exists(): os.remove(dest_file)"},{"question":"# Coding Assessment Question **Objective**: Implement a function to compute value from a nested dictionary given a list of keys representing nested levels. **Function Signature**: ```python def retrieve_value(nested_dict: dict, keys: list) -> any: pass ``` # Input & Output * **Input Format**: * `nested_dict`: A dictionary representing nested levels of dictionaries. * `keys`: A list of keys indicating the path to a value within the nested dictionaries. * **Output Format**: * The value obtained by navigating the keys list, or `None` if any key is not found at any nested level. # Constraints * The depth of the nested dictionary and the length of the keys list do not exceed (10^3). * The dictionary contains only hashable types (integers, strings, tuples, etc.) as keys. # Performance Requirements * Your implementation should handle the navigation efficiently within the given constraints. # Example 1. **Example 1**: * Input: ```python nested_dict = {\\"a\\": {\\"b\\": {\\"c\\": 42}}} keys = [\\"a\\", \\"b\\", \\"c\\"] ``` * Output: `42` 2. **Example 2**: * Input: ```python nested_dict = {\\"a\\": {\\"b\\": {\\"c\\": {\\"d\\": 99}}}} keys = [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] ``` * Output: `99` 3. **Example 3**: * Input: ```python nested_dict = {\\"a\\": {\\"b\\": {\\"x\\": 25}}} keys = [\\"a\\", \\"b\\", \\"c\\"] ``` * Output: `None` 4. **Example 4**: * Input: ```python nested_dict = {\\"k1\\": {\\"k2\\": {\\"k3\\": \\"value\\"}}} keys = [\\"k1\\", \\"k4\\"] ``` * Output: `None` # Instructions * Implement the `retrieve_value` function according to the given requirements. * Ensure your function is efficient and handles edge cases effectively. * Do not print anything in the function; return the result directly.","solution":"def retrieve_value(nested_dict: dict, keys: list) -> any: Given a nested dictionary and a list of keys, this function returns the value found by navigating through the dictionary using the provided keys. If any key is not found at any level, returns None. current_level = nested_dict for key in keys: if isinstance(current_level, dict) and key in current_level: current_level = current_level[key] else: return None return current_level"},{"question":"# Question: Calculating the Shortest Path in a Weighted Graph You need to implement a Python function that finds the shortest path between two nodes in a weighted, directed graph using Dijkstra\'s algorithm. Function Signature ```python def shortest_path(graph: dict[str, dict[str, int]], start: str, end: str) -> int: pass ``` Input: - `graph` (dict[str, dict[str, int]]): A dictionary representing the graph, where keys are node identifiers and values are dictionaries that map neighboring nodes to edge weights. - `start` (str): The node identifier from which to start the path. - `end` (str): The node identifier at which to end the path. Output: - An integer representing the total weight of the shortest path from `start` to `end`. If there is no path, return `-1`. Constraints: - The graph is non-negative and directed. - The graph may contain up to 100 nodes and 1000 edges. - If either the `start` or `end` node does not exist in the graph, return `-1`. - If there is no valid path, return `-1`. Sample Execution: ```python graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'C\': 2, \'D\': 5}, \'C\': {\'D\': 1}, \'D\': {} } print(shortest_path(graph, \'A\', \'D\')) # Expected: 4 (A -> B -> C -> D) print(shortest_path(graph, \'A\', \'E\')) # Expected: -1 (No such node as \'E\') print(shortest_path(graph, \'A\', \'A\')) # Expected: 0 (Starting and ending at the same node) ``` Background: This question assesses your ability to: - Implement Dijkstra\'s algorithm to find the shortest path in a weighted graph. - Handle edge cases such as nonexistent nodes and unreachable nodes. - Manage data structures effectively for graph representations and priority queues. Ensure your implementation does not cause side effects and handles all specified constraints appropriately.","solution":"import heapq def shortest_path(graph, start, end): Finds the shortest path between start and end nodes in a weighted directed graph using Dijkstra\'s algorithm. Args: graph (dict): A dictionary representing the graph. start (str): The start node. end (str): The end node. Returns: int: The total weight of the shortest path from start to end. If no path exists, returns -1. if start not in graph or end not in graph: return -1 # Priority queue to store (cost, vertex) queue = [(0, start)] # Dictionary to store the minimal cost to reach each node distances = {start: 0} while queue: current_distance, current_node = heapq.heappop(queue) if current_node == end: return current_distance # Skip processing if we have already found a shorter path previously if current_distance > distances.get(current_node, float(\'inf\')): continue for neighbor, weight in graph[current_node].items(): distance = current_distance + weight if distance < distances.get(neighbor, float(\'inf\')): distances[neighbor] = distance heapq.heappush(queue, (distance, neighbor)) return -1"},{"question":"# Integer to Binary Coded Decimal (BCD) Converter You are tasked with implementing an Integer to Binary Coded Decimal (BCD) Converter. Binary Coded Decimal is a class of binary encodings of decimal numbers where each decimal digit is represented by a fixed number of binary bits, usually four or eight. 1. Integer to BCD Encoding Function Implement the function that converts an integer to its BCD representation: ```python def int_to_bcd(n: int) -> str: ``` * **Input**: A positive integer `n`. * **Output**: A string representing the Binary Coded Decimal (BCD) of the input integer. 2. BCD to Integer Decoding Function Implement the decoding function that converts a BCD representation back to its integer form: ```python def bcd_to_int(bcd: str) -> int: ``` * **Input**: A string `bcd` representing the BCD encoded number. * **Output**: The integer represented by the BCD input. # Constraints * The input integer `n` should be between 0 and 999999999 (inclusive). * The function should handle leading zeros in the BCD string. # Example ```python n = 12345 # Convert integer to BCD bcd_representation = int_to_bcd(n) assert bcd_representation == \\"0001 0010 0011 0100 0101\\" # Convert BCD back to integer decoded_integer = bcd_to_int(bcd_representation) assert decoded_integer == 12345 ``` # Additional Rules 1. You are required to use four bits for each decimal digit. 2. The BCD string should be space-separated for each four-bit unit, for better readability as shown in the example. 3. Ensure your code is optimized to handle the largest input size efficiently. 4. Do not utilize any pre-existing libraries for encoding or decoding except Python\'s standard library. 5. The solutions should be clean, well-commented, and tested for various edge cases including 0, and maximum boundary inputs. **Good luck with your implementation! Ensure your code is clean, well-commented, and tested for various edge cases.**","solution":"def int_to_bcd(n: int) -> str: Converts an integer to its Binary Coded Decimal (BCD) representation. Parameters: n (int): The integer to be converted, between 0 and 999999999 (inclusive). Returns: str: The BCD representation, space-separated for every four-bit unit. if n < 0 or n > 999999999: raise ValueError(\\"Input integer must be between 0 and 999999999\\") # Convert each digit to its 4-bit binary representation bcd_str = \' \'.join(f\'{int(digit):04b}\' for digit in str(n)) return bcd_str def bcd_to_int(bcd: str) -> int: Converts a Binary Coded Decimal (BCD) representation back to its integer form. Parameters: bcd (str): The BCD encoded string, space-separated for every four-bit unit. Returns: int: The integer represented by the BCD input. # Split the BCD string by spaces to get each 4-bit binary string bcd_digits = bcd.split() # Convert each 4-bit binary string back to a digit and concatenate them integer_value = int(\'\'.join(str(int(bit_group, 2)) for bit_group in bcd_digits)) return integer_value"},{"question":"Weather Data Aggregator Context: Your task is to develop a data aggregation function that processes a list of weather data entries. Each entry includes a city name, temperature in Celsius, and humidity percentage. The function should calculate the average temperature and average humidity for each city. Problem Description: Write a function `weather_aggregator` that takes a list of dictionaries representing weather data entries and returns a dictionary where the keys are city names and the values are dictionaries containing the average temperature and average humidity for each city. Function Signature: ```python def weather_aggregator(data: list) -> dict: ``` Input: - `data`: A list of dictionaries with each dictionary containing: - `city`: A string representing the city name. - `temperature`: An integer representing the temperature in Celsius. - `humidity`: An integer representing the humidity percentage. - Each city appears at least once in the input list. The length of the list is 1 <= len(data) <= 10^5. Output: - A dictionary where each key is a city name and the value is another dictionary with the keys `avg_temperature` and `avg_humidity`, representing the average temperature and average humidity for that city. Constraints: - Handle the calculation of averages accurately. - Ensure the function is efficient in both time and space complexities. Examples: ```python >>> weather_aggregator([ ... {\\"city\\": \\"San Francisco\\", \\"temperature\\": 15, \\"humidity\\": 70}, ... {\\"city\\": \\"New York\\", \\"temperature\\": 20, \\"humidity\\": 50}, ... {\\"city\\": \\"San Francisco\\", \\"temperature\\": 17, \\"humidity\\": 65}, ... {\\"city\\": \\"New York\\", \\"temperature\\": 22, \\"humidity\\": 55}, ... {\\"city\\": \\"Boston\\", \\"temperature\\": 10, \\"humidity\\": 80} ... ]) { \\"San Francisco\\": {\\"avg_temperature\\": 16.0, \\"avg_humidity\\": 67.5}, \\"New York\\": {\\"avg_temperature\\": 21.0, \\"avg_humidity\\": 52.5}, \\"Boston\\": {\\"avg_temperature\\": 10.0, \\"avg_humidity\\": 80.0} } >>> weather_aggregator([ ... {\\"city\\": \\"Los Angeles\\", \\"temperature\\": 25, \\"humidity\\": 40} ... ]) { \\"Los Angeles\\": {\\"avg_temperature\\": 25.0, \\"avg_humidity\\": 40.0} } >>> weather_aggregator([]) {} ``` Notes: - The averages should be floating-point numbers. - Ensure the handling of edge cases, such as a single entry list. - Aim for clarity in your solution and concise calculation of the aggregates.","solution":"def weather_aggregator(data): from collections import defaultdict city_data = defaultdict(lambda: {\'total_temperature\': 0, \'total_humidity\': 0, \'count\': 0}) for entry in data: city = entry[\\"city\\"] temperature = entry[\\"temperature\\"] humidity = entry[\\"humidity\\"] city_data[city][\'total_temperature\'] += temperature city_data[city][\'total_humidity\'] += humidity city_data[city][\'count\'] += 1 result = {} for city, metrics in city_data.items(): avg_temperature = metrics[\'total_temperature\'] / metrics[\'count\'] avg_humidity = metrics[\'total_humidity\'] / metrics[\'count\'] result[city] = {\\"avg_temperature\\": avg_temperature, \\"avg_humidity\\": avg_humidity} return result"},{"question":"# Scenario A transportation company is planning an optimization of their logistic routes. To streamline their data processing, they need to know the maximum subarray sum for their route efficiency measurements across multiple regions. They have multiple arrays denoting changes in efficiency over geographical segments. # Task Write a function `max_subarray_sum(arr: list[int]) -> int` that finds the sum of the maximum subarray within a given array using Kadane’s algorithm. # Function Signature ```python def max_subarray_sum(arr: list[int]) -> int ``` # Input * A list of integers `arr` where each integer represents the change in efficiency for a segment of the route. # Output * Returns an integer that is the sum of the maximum subarray in the given array. # Constraints * The length of the array `arr` will be at least 1 and at most 10^5. * Each integer in `arr` will be within the range of `-10^4` to `10^4`. # Example 1. For an input `arr = [1, -2, 3, 4, -1, 2, 1, -5, 4]` - The function should return `9` - Explanation: The maximum subarray is `[3, 4, -1, 2, 1]` with sum `9`. 2. For an input `arr = [-3, -2, -1]` - The function should return `-1` - Explanation: The maximum subarray is `[-1]` with sum `-1`. 3. For an input `arr = [5, 4, -1, 7, 8]` - The function should return `23` - Explanation: The maximum subarray is `[5, 4, -1, 7, 8]` with sum `23`. # Additional Requirements * Ensure the function handles edge cases such as arrays with only negative numbers or arrays where the largest sum does not span the entire array. * The solution should be efficient and run in O(n) time complexity.","solution":"def max_subarray_sum(arr: list[int]) -> int: Finds the sum of the maximum subarray within a given array using Kadane’s algorithm. max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Binary Tree Level Order Traversal Challenge You are asked to implement a function `level_order_traversal` to perform a level-order traversal of a binary tree. The function should return a list of lists, where each sublist contains the nodes at that level of the tree. You may use the given `BinaryTree` and `TreeNode` classes for this purpose and add your function to the given binary tree class. Your implementation must handle the following requirements: * If the tree is empty, return an empty list. * Traverse the tree level by level from left to right. # Function Signature: ```python class BinaryTree: ... def level_order_traversal(self) -> List[List[Any]]: pass ``` # Input: - The `level_order_traversal` method does not take any input parameters. # Output: - The `level_order_traversal` should return a list of lists, each sublist representing a level of the binary tree. # Example: ```python binary_tree = BinaryTree() binary_tree.insert_root(1) binary_tree.insert_left(binary_tree.root, 2) binary_tree.insert_right(binary_tree.root, 3) binary_tree.insert_left(binary_tree.root.left, 4) binary_tree.insert_right(binary_tree.root.left, 5) binary_tree.insert_left(binary_tree.root.right, 6) binary_tree.insert_right(binary_tree.root.right, 7) print(binary_tree.level_order_traversal()) # Output: [[1], [2, 3], [4, 5, 6, 7]] ``` # Constraints: - Your code should handle trees with a varying number of levels efficiently. - Ensure edge cases such as empty trees and trees with a single node are tested. # Testing: 1. Add multiple test cases similar to the example given above. 2. Ensure edge cases such as empty trees and trees with a single node are tested.","solution":"from typing import List, Any, Optional from collections import deque class TreeNode: def __init__(self, val: Any): self.val = val self.left: Optional[TreeNode] = None self.right: Optional[TreeNode] = None class BinaryTree: def __init__(self): self.root: Optional[TreeNode] = None def insert_root(self, val: Any) -> TreeNode: self.root = TreeNode(val) return self.root def insert_left(self, node: TreeNode, val: Any) -> TreeNode: node.left = TreeNode(val) return node.left def insert_right(self, node: TreeNode, val: Any) -> TreeNode: node.right = TreeNode(val) return node.right def level_order_traversal(self) -> List[List[Any]]: if not self.root: return [] result = [] queue = deque([self.root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"**Scenario**: You are tasked with creating a library to manage user sessions for a web application. The library should be able to create, retrieve, and delete sessions efficiently. Additionally, it needs necessary mechanisms to handle session expiration and prevent multiple active sessions for a single user. **Task**: Implement a class `SessionManager` with the following methods: 1. `create_session(user_id: int) -> str`: Create a new session for a given user ID. Return a unique session ID. 2. `get_session_info(session_id: str) -> dict`: Retrieve information associated with a session ID. Return a dictionary with keys \\"user_id\\" and \\"created_at\\". 3. `delete_session(session_id: str) -> bool`: Delete a session with a given session ID. Return `True` if the session was successfully deleted, otherwise `False`. 4. `cleanup_expired_sessions() -> None`: Delete all sessions that have expired. 5. `is_valid_session(session_id: str) -> bool`: Check if a session ID is still valid (i.e., not expired and exists). * Expected input and output formats: * `create_session(user_id)` -> \\"session_id_string\\" * `get_session_info(\\"session_id_string\\")` -> { \\"user_id\\": int, \\"created_at\\": datetime } * `delete_session(\\"session_id_string\\")` -> True/False * `cleanup_expired_sessions()` -> None * `is_valid_session(\\"session_id_string\\")` -> True/False * Constraints: * Assume a session is valid for 30 minutes from creation. * Use an in-memory store (e.g., a dictionary) to keep track of session data. * Ensure there are no multiple active sessions for a single user; creating a new session for a user should invalidate any previous session(s). Below is the starting code for the class: ```python from datetime import datetime, timedelta import uuid class SessionManager: SESSION_DURATION = timedelta(minutes=30) def __init__(self): self.sessions = {} def create_session(self, user_id: int) -> str: # Implement the logic to create a new session for the user. # Invalidate any existing session for the user. pass def get_session_info(self, session_id: str) -> dict: # Implement the logic to retrieve session information for the given session ID. pass def delete_session(self, session_id: str) -> bool: # Implement the logic to delete the specified session. pass def cleanup_expired_sessions(self) -> None: # Implement the logic to delete all expired sessions. pass def is_valid_session(self, session_id: str) -> bool: # Implement the logic to check if the session is valid. pass ```","solution":"from datetime import datetime, timedelta import uuid class SessionManager: SESSION_DURATION = timedelta(minutes=30) def __init__(self): self.sessions = {} self.user_sessions = {} def create_session(self, user_id: int) -> str: # Invalidate any existing session for the user if user_id in self.user_sessions: old_session_id = self.user_sessions[user_id] if old_session_id in self.sessions: del self.sessions[old_session_id] # Create a new session session_id = str(uuid.uuid4()) created_at = datetime.now() self.sessions[session_id] = {\\"user_id\\": user_id, \\"created_at\\": created_at} self.user_sessions[user_id] = session_id return session_id def get_session_info(self, session_id: str) -> dict: # Retrieve session information return self.sessions.get(session_id, None) def delete_session(self, session_id: str) -> bool: if session_id in self.sessions: user_id = self.sessions[session_id][\'user_id\'] del self.sessions[session_id] if user_id in self.user_sessions and self.user_sessions[user_id] == session_id: del self.user_sessions[user_id] return True return False def cleanup_expired_sessions(self) -> None: now = datetime.now() expired_sessions = [sid for sid, info in self.sessions.items() if now - info[\\"created_at\\"] > self.SESSION_DURATION] for session_id in expired_sessions: user_id = self.sessions[session_id][\'user_id\'] del self.sessions[session_id] if user_id in self.user_sessions and self.user_sessions[user_id] == session_id: del self.user_sessions[user_id] def is_valid_session(self, session_id: str) -> bool: if session_id in self.sessions: session_info = self.sessions[session_id] if datetime.now() - session_info[\\"created_at\\"] <= self.SESSION_DURATION: return True return False"},{"question":"# Problem Statement: You have been hired to develop a financial analysis tool that assesses the investment performance of different assets. One of the key metrics you need to calculate is the Compound Annual Growth Rate (CAGR) of an investment. # Description: The Compound Annual Growth Rate (CAGR) measures the mean annual growth rate of an investment over a specified period of time longer than one year. The CAGR formula can be expressed as: CAGR = ((Ending Value / Beginning Value) ^ (1 / Number of Years)) - 1 where: - `Ending Value` is the value of the investment at the end of the period. - `Beginning Value` is the value of the investment at the start of the period. - `Number of Years` is the number of years over which the investment grows. # Function Signature: ```python def calculate_cagr(beginning_value: float, ending_value: float, years: int) -> float: ``` # Constraints: 1. All input parameters: `beginning_value`, `ending_value`, and `years` should be positive. If any parameter is not positive, raise a `ValueError` with the message \\"Beginning value, ending value, and number of years must all be positive\\". 2. You must round the CAGR to six decimal places before returning it. # Inputs: - `beginning_value` (float): The initial value of the investment. - `ending_value` (float): The value of the investment at the end of the period. - `years` (int): The number of years over which the investment has grown. # Outputs: - Returns a float indicating the CAGR, rounded to six decimal places. # Example: ```python >>> calculate_cagr(1000, 2000, 10) 0.071773 >>> calculate_cagr(5000, 10000, 5) 0.148698 ``` Your function must pass the following doctests provided in the stub. Ensure it handles edge cases and raises errors appropriately. Happy coding!","solution":"def calculate_cagr(beginning_value: float, ending_value: float, years: int) -> float: Calculate the Compound Annual Growth Rate (CAGR) of an investment. :param beginning_value: float - The initial value of the investment. :param ending_value: float - The value of the investment at the end of the period. :param years: int - The number of years over which the investment has grown. :return: float - The CAGR, rounded to six decimal places. :raises ValueError: If any input parameter is not positive. if beginning_value <= 0 or ending_value <= 0 or years <= 0: raise ValueError(\\"Beginning value, ending value, and number of years must all be positive\\") cagr = ((ending_value / beginning_value) ** (1 / years)) - 1 return round(cagr, 6)"},{"question":"# Coding Question You are tasked with creating an efficient data structure to store a dynamic set of numbers and perform the following operations: 1. Add a number to the set. 2. Remove a number from the set. 3. Get the median of the current set of numbers. Implement a class `MedianFinder` that uses a min-heap and a max-heap to achieve this. Your implementation should demonstrate understanding of heap operations and maintaining balance between the two heaps. Function Signature ```python class MedianFinder: def __init__(self): pass def add_num(self, num: int) -> None: pass def remove_num(self, num: int) -> None: pass def find_median(self) -> float: pass ``` Task 1. **Add Num**: - Implement the `add_num` method to add a number to the data structure. - This method should maintain the balance between the heaps to ensure efficient median calculation. 2. **Remove Num**: - Implement the `remove_num` method to remove a number from the data structure. - The method should adjust the heaps to maintain balance after removal. 3. **Find Median**: - Implement the `find_median` method to return the median of the numbers currently in the data structure. - The operation should return the middle value if the count of numbers is odd, or the average of the two middle values if the count is even. Input - The `MedianFinder` class will be instantiated. - The `add_num(num)` method will be called with an integer `num` to add to the data structure. - The `remove_num(num)` method will be called with an integer `num` to remove from the data structure. - The `find_median()` method will be called to retrieve the median of the current set of numbers. Output - The `add_num` and `remove_num` methods do not return any output. - The `find_median` method returns the median as a floating-point number. Constraints - The number of calls to `add_num` and `remove_num` does not exceed 10^5. - The values for `num` are between -10^5 and 10^5, inclusive. Example Usage ```python mf = MedianFinder() mf.add_num(1) mf.add_num(2) assert mf.find_median() == 1.5 # Median is (1 + 2) / 2 mf.add_num(3) assert mf.find_median() == 2 # Median is 2 mf.remove_num(2) assert mf.find_median() == 2 # Median is 1.5 after 2 is removed mf.add_num(4) mf.add_num(5) assert mf.find_median() == 3 # Median is 3 mf.remove_num(1) assert mf.find_median() == 4 # Median is 4 after 1 is removed ``` Notes - You are required to write all three methods in the `MedianFinder` class. - Ensure the solution is efficient and adheres to the specified constraints.","solution":"import heapq class MedianFinder: def __init__(self): self.lower_half = [] # Max-heap (invert min-heap) self.upper_half = [] # Min-heap def add_num(self, num: int) -> None: # Add to max-heap (lower_half) heapq.heappush(self.lower_half, -num) # Balance the heaps if (self.lower_half and self.upper_half and (-self.lower_half[0] > self.upper_half[0])): heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half)) # Balance sizes if len(self.lower_half) > len(self.upper_half) + 1: heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half)) if len(self.upper_half) > len(self.lower_half): heapq.heappush(self.lower_half, -heapq.heappop(self.upper_half)) def remove_num(self, num: int) -> None: # Try to remove from lower_half (max-heap) if num <= -self.lower_half[0]: self.lower_half.remove(-num) heapq.heapify(self.lower_half) else: # Try to remove from upper_half (min-heap) self.upper_half.remove(num) heapq.heapify(self.upper_half) # Balance sizes if len(self.lower_half) > len(self.upper_half) + 1: heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half)) if len(self.upper_half) > len(self.lower_half): heapq.heappush(self.lower_half, -heapq.heappop(self.upper_half)) def find_median(self) -> float: if len(self.lower_half) > len(self.upper_half): return -self.lower_half[0] return (-self.lower_half[0] + self.upper_half[0]) / 2.0"},{"question":"# Problem Description You are tasked with creating a runtime optimizer for a web application. One of the critical modules deals with large amounts of data processed in web sessions. Each session has a set of operations with varying execution times. Your goal is to implement an algorithm that splits these operations into two balanced subsets with minimal difference in their total execution times. # Task Implement a function that takes a list of operation execution times and returns two lists representing the two subsets of operations with nearly equal total execution times. # Function Signature ```python def balance_operations(operation_times: list[int]) -> tuple[list[int], list[int]]: pass ``` # Input - `operation_times` (list): A list of integers where each integer signifies the execution time of an operation. # Output - Return a tuple of two lists: the two subsets of operations with their execution times balanced. # Constraints - The length of `operations_times` is between 2 and 1000. - Each execution time will be a positive integer not exceeding 10,000. - The sum of the times in each subset should be as close as possible to each other. # Examples ```python # Function signature to balance operations def balance_operations(operation_times): pass # Test with sample operation times test_operations = [10, 20, 15, 5, 30] balanced_set1, balanced_set2 = balance_operations(test_operations) assert sum(balanced_set1) == 35 assert sum(balanced_set2) == 45 test_operations2 = [1, 2, 3, 4, 5, 6, 7, 8] balanced_set1, balanced_set2 = balance_operations(test_operations2) assert sum(balanced_set1) == 18 assert sum(balanced_set2) == 18 # Check edge cases with minimum constraints test_operations3 = [1, 2] balanced_set1, balanced_set2 = balance_operations(test_operations3) assert sum(balanced_set1) == 1 assert sum(balanced_set2) == 2 test_operations4 = [987, 234, 564, 123, 876] balanced_set1, balanced_set2 = balance_operations(test_operations4) assert abs(sum(balanced_set1) - sum(balanced_set2)) <= max(operation_times)/2 ``` # Hints - Dynamic programming or greedy algorithms might help in achieving the desired optimization. - Ensure your function handles both small and large input sizes efficiently. - Aim to minimize the absolute difference between the sums of the two subsets.","solution":"def balance_operations(operation_times: list[int]) -> tuple[list[int], list[int]]: # Get the total sum of the operation times total_sum = sum(operation_times) n = len(operation_times) target = total_sum // 2 # Create a DP table to track the maximum sum we can get for a given capacity and item count dp = [[0] * (target + 1) for _ in range(n + 1)] # Build the DP table for i in range(1, n + 1): for j in range(1, target + 1): if operation_times[i - 1] <= j: dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - operation_times[i - 1]] + operation_times[i - 1]) else: dp[i][j] = dp[i - 1][j] sum1 = dp[n][target] sum2 = total_sum - sum1 # Determine which items are in the first subset subset1 = [] subset2 = [] w = target for i in range(n, 0, -1): if dp[i][w] != dp[i - 1][w]: subset1.append(operation_times[i - 1]) w -= operation_times[i - 1] else: subset2.append(operation_times[i - 1]) # The remaining items are in the second subset subset2.extend(operation_times[:i - 1]) return subset1, subset2"},{"question":"# Scenario You are developing a software tool that processes customer orders for an online store. One of the features needed is a system to validate and categorize order references. Each order reference is composed of a string containing uppercase letters and digits. To ensure the validity and categorize the orders, the following criteria must be met: 1. An order reference is considered valid if it consists of exactly 4 uppercase letters followed by exactly 4 digits. 2. Based on the sum of the digits, categorize the order as \\"High Value\\" if the sum is 25 or greater, and \\"Low Value\\" otherwise. # Task Implement a function `validate_and_categorize_orders` that validates each order reference from a collection of input strings and returns a list of tuples. Each tuple should contain the original order reference and its category (\\"High Value\\" or \\"Low Value\\"). # Function Signature ```python def validate_and_categorize_orders(order_refs: List[str]) -> List[Tuple[str, str]]: Validates and categorizes each order reference. :param order_refs: List of strings, each being an order reference. :return: List of tuples, each containing the order reference and its category. pass ``` # Input - A list of strings, `order_refs`, where each string is an order reference. # Output - A list of tuples, each containing the original order reference and its category as a string (\\"High Value\\" or \\"Low Value\\"). # Constraints - Each order reference string will have a maximum length of 20 characters. - The list of order references will have at most (10^5) strings. # Examples Example 1: ```python order_refs = [\\"ABCD1234\\", \\"ZZZZ9999\\", \\"INVALID12\\", \\"AAAA1111\\"] print(validate_and_categorize_orders(order_refs)) # Output: [(\\"ABCD1234\\", \\"Low Value\\"), (\\"ZZZZ9999\\", \\"High Value\\"), (\\"INVALID12\\", \\"Low Value\\")] ``` Example 2: ```python order_refs = [\\"A1B2C3D4\\", \\"XXXX5678\\"] print(validate_and_categorize_orders(order_refs)) # Output: [(\\"A1B2C3D4\\", \\"Low Value\\"), (\\"XXXX5678\\", \\"High Value\\")] ``` # Additional Requirements - Ensure that your solution can handle up to (10^5) order references efficiently. - Consider using regular expressions to validate the order format effectively.","solution":"import re from typing import List, Tuple def validate_and_categorize_orders(order_refs: List[str]) -> List[Tuple[str, str]]: Validates and categorizes each order reference. :param order_refs: List of strings, each being an order reference. :return: List of tuples, each containing the order reference and its category. result = [] pattern = re.compile(r\'^[A-Z]{4}d{4}\') for order in order_refs: if pattern.match(order): digits_sum = sum(int(digit) for digit in order[4:]) category = \\"High Value\\" if digits_sum >= 25 else \\"Low Value\\" result.append((order, category)) else: # If order ID does not match the pattern, we can ignore it. # This can be altered if invalid orders also need to be handled. continue return result"},{"question":"# Binary Search Tree: Node Depths Calculation # Scenario You are given a Binary Search Tree (BST) and need to compute the sum of the depths of all nodes in the tree. The depth of a node is defined as the number of edges from the root to the node. For example, the depth of the root node is 0. # Task Write a Python function `node_depths` that calculates the sum of the depths of all nodes in the BST. # Function Signature ```python def node_depths(root: Optional[TreeNode]) -> int: ``` # Input 1. `root` (Optional[TreeNode]): The root node of the BST. The TreeNode class is predefined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output * Returns an `int` representing the total sum of the depths of all nodes. # Constraints 1. The number of nodes in the tree is between 1 and 10,000. 2. Each node\'s value is an integer. 3. The tree is a valid Binary Search Tree (BST). # Performance Requirement * The implemented solution should have a time complexity of (O(n)) where (n) is the number of nodes in the tree. * Space complexity should be (O(h)), where (h) is the height of the tree due to the recursion stack. # Example ```python # Example Usage root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(2) root.left.right = TreeNode(5) root.left.left.left = TreeNode(1) root.right.right = TreeNode(22) result = node_depths(root) print(f\\"Sum of node depths: {result}\\") # Expected: 12 ``` # Notes * You may define additional helper functions within your solution. * A node\'s depth is calculated with respect to the root node, which has a depth of 0. * Consider using a depth-first search (DFS) or breadth-first search (BFS) strategy to traverse the tree and accumulate the depth values.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def node_depths(root: TreeNode, depth: int = 0) -> int: Calculates the sum of the depths of all nodes in the binary search tree. :param root: TreeNode, the root of the binary search tree. :param depth: int, the current depth in the tree. :return: int, the sum of the depths of all nodes. if root is None: return 0 left_depths = node_depths(root.left, depth + 1) right_depths = node_depths(root.right, depth + 1) return depth + left_depths + right_depths"},{"question":"# Coding Assessment Question: Context: Banking systems need to simulate and manage transactions efficiently to ensure account security and consistency. One way to test this is by creating a transaction process that handles deposits and withdrawals, ensuring that accounts always have accurate balances and sufficient funds for withdrawals without leading to negative balances. Task: Write a Python class named `BankAccount` that allows for creating bank accounts, making deposits, and processing withdrawals. The class should include methods to check for sufficient funds and handle invalid transactions gracefully. Class Signature: ```python class BankAccount: def __init__(self, account_number: str, initial_balance: float = 0.0): pass def deposit(self, amount: float) -> None: pass def withdraw(self, amount: float) -> bool: pass def get_balance(self) -> float: pass ``` Methods Description: * **__init__**: Constructor method to initialize the bank account with an account number and an initial balance. - **Inputs**: - **account_number**: A string representing the account number. - **initial_balance**: Optional; A float representing the initial balance (default is 0.0). * **deposit**: Method to deposit a specified amount into the account. - **Inputs**: - **amount**: A float representing the amount to deposit. * **withdraw**: Method to withdraw a specified amount from the account. It should return `True` if the transaction is successful and `False` otherwise (e.g., insufficient funds). - **Inputs**: - **amount**: A float representing the amount to withdraw. - **Outputs**: - **success**: A boolean indicating whether the transaction was successful. * **get_balance**: Method to return the current balance of the account. - **Outputs**: - **balance**: A float representing the current account balance. Constraints: * Ensure that deposits and withdrawals update the balance accurately. * Withdrawals should not allow the balance to go below zero. * Input values for deposits and withdrawals should be positive numbers. * Handle edge cases like depositing or withdrawing 0. Example: ```python account = BankAccount(\\"12345ABCDE\\", 100.0) account.deposit(50.0) print(account.get_balance()) # Should output 150.0 success = account.withdraw(200.0) print(success) # Should output False print(account.get_balance()) # Should still output 150.0 success = account.withdraw(50.0) print(success) # Should output True print(account.get_balance()) # Should output 100.0 ``` In this example, you first deposit 50 into an account that initially has 100. The balance then becomes 150. Attempting to withdraw 200 should fail as there are insufficient funds, leaving the balance unchanged. The subsequent 50 withdrawal should succeed, reducing the balance to 100.","solution":"class BankAccount: def __init__(self, account_number: str, initial_balance: float = 0.0): self.account_number = account_number self.balance = initial_balance def deposit(self, amount: float) -> None: if amount > 0: self.balance += amount def withdraw(self, amount: float) -> bool: if amount > 0 and self.balance >= amount: self.balance -= amount return True return False def get_balance(self) -> float: return self.balance"},{"question":"Image Processing and Analysis Task You are required to create a function that processes an image by applying a series of transformations and then analyzes the transformation result. Your goal is to write a function named `process_image` that performs the following operations: 1. **Load Image**: Load an image from a given file path. 2. **Apply Transformations**: Apply a series of predefined transformations: rotate, resize, and convert to grayscale. 3. **Analyze Image**: Calculate and return the mean pixel intensity of the processed image. # Function Signature ```python def process_image(file_path: str, rotation_angle: int, output_size: tuple) -> float: Loads, processes, and analyzes an image. Parameters: - file_path (str): The file path of the image to be processed. - rotation_angle (int): The angle in degrees by which to rotate the image. - output_size (tuple): The target size as a tuple (width, height) to resize the image. Returns: - float: The mean pixel intensity of the processed image. ``` # Requirements 1. **Load the image**: - Use an appropriate library (like PIL in Python) to load the image from the specified file path. 2. **Apply Transformations**: - **Rotate** the image by the specified angle (in degrees). - **Resize** the image to the target width and height (provided as a tuple). - **Convert** the image to grayscale. 3. **Analyze Image**: - Calculate the mean pixel intensity of the grayscale image. - Return the calculated mean pixel intensity as a float. # Constraints - Ensure the specified file path points to a valid image file. - Handle invalid image formats or corrupted files gracefully with meaningful error messages. - The function should manage edge cases, such as extremely small or large rotation angles and invalid sizes for resizing. # Example ```python mean_intensity = process_image(\\"/path/to/image.jpg\\", 45, (256, 256)) print(mean_intensity) # Expected output: Mean pixel intensity of the processed image as a float. ``` --- This question fits the original set\'s style, length, complexity, and topic alignment while introducing the new concept of image processing and analysis.","solution":"from PIL import Image import numpy as np def process_image(file_path: str, rotation_angle: int, output_size: tuple) -> float: Loads, processes, and analyzes an image. Parameters: - file_path (str): The file path of the image to be processed. - rotation_angle (int): The angle in degrees by which to rotate the image. - output_size (tuple): The target size as a tuple (width, height) to resize the image. Returns: - float: The mean pixel intensity of the processed image. try: # Load the image image = Image.open(file_path) # Rotate the image image = image.rotate(rotation_angle, expand=True) # Resize the image image = image.resize(output_size) # Convert the image to grayscale image = image.convert(\\"L\\") # Convert the image to a numpy array and calculate the mean pixel intensity image_array = np.array(image) mean_intensity = image_array.mean() return mean_intensity except Exception as e: print(f\\"Failed to process image: {e}\\") return None"},{"question":"# Coding Assessment Question Scenario You are working on a text processing tool that assists writers in analyzing their manuscripts. One of the key features requested is the ability to identify the most frequently occurring word in a given text. Your task is to write a function that not only returns the most frequent word but also its frequency count. Task Implement a function `most_frequent_word` that finds the most frequently occurring word in a given string of text. If multiple words have the same highest frequency, return the alphabetically smallest word. Function Signature ```python def most_frequent_word(text: str) -> tuple[str, int]: pass ``` Input * `text`: A string containing the text to be analyzed. Words are separated by whitespace and punctuation is ignored. The text can have mixed case, but ensure that your word comparison is case-insensitive. Output * Returns a tuple containing: - The word that appears the most frequently (convert to lower case for comparison purposes). - The frequency count of that word. Constraints * The input text can be empty. * Words are separated by spaces and punctuation marks which should be ignored. Example ```python >>> most_frequent_word(\\"To be, or not to be, that is the question.\\") (\'be\', 2) >>> most_frequent_word(\\"Hello, hello world! World, hello.\\") (\'hello\', 3) >>> most_frequent_word(\\"A quick brown fox jumps over the lazy dog.\\") (\'a\', 1) ``` Edge Cases * Verify behavior with an empty text string. * Consider different cases for words, ensuring the comparison is case insensitive. * Verify handling of punctuation (all punctuation should be ignored). Additional Challenge Try optimizing the implementation to handle very large texts efficiently.","solution":"import re from collections import Counter def most_frequent_word(text: str) -> tuple[str, int]: # Use regular expression to find words, ignore punctuation words = re.findall(r\'bw+b\', text.lower()) if not words: return (\\"\\", 0) # Count the frequency of each word freq = Counter(words) # Find the word with the highest frequency, and if tie, the alphabetically smallest one most_common_word = min(freq.items(), key=lambda x: (-x[1], x[0])) return most_common_word"},{"question":"# Question Sparse Matrix Multiplication You are asked to implement a function to perform sparse matrix multiplication. # Task: Implement the function `sparse_matrix_multiplication(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]`. # Function Definition: **sparse_matrix_multiplication(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]**: * This function takes two matrices `matrix1` and `matrix2`, represented as 2D lists, and returns their product matrix also as a 2D list. * Both matrices will be sparse, meaning most of their elements are zero, and their dimensions will be such that the multiplication is possible. # Example: * Input: ```python matrix1 = [ [1, 0, 0], [-1, 0, 3] ] matrix2 = [ [7, 0, 0], [0, 0, 0], [0, 0, 1] ] ``` * Output: ```python [ [7, 0, 0], [-7, 0, 3] ] ``` # Requirements: * You should use an efficient algorithm that takes advantage of the sparsity of the matrices. * The function must handle edge cases, such as cases where one or both matrices are zero matrices. # Constraints: * Matrices `matrix1` and `matrix2` will have dimensions suitable for multiplication, specifically: - If `matrix1` is of size m x n, `matrix2` will be of size n x p. - Both matrices will contain integers (including negative and zero values). # Example Test Cases ```python matrix1 = [ [1, 0, 0], [-1, 0, 3] ] matrix2 = [ [7, 0, 0], [0, 0, 0], [0, 0, 1] ] assert sparse_matrix_multiplication(matrix1, matrix2) == [ [7, 0, 0], [-7, 0, 3] ] matrix1 = [ [0, 0], [0, 0] ] matrix2 = [ [0, 0], [0, 0] ] assert sparse_matrix_multiplication(matrix1, matrix2) == [ [0, 0], [0, 0] ] matrix1 = [ [1, 2, 0], [-1, 0, 3] ] matrix2 = [ [0, 0], [7, 5], [0, 1] ] assert sparse_matrix_multiplication(matrix1, matrix2) == [ [14, 10], [0, 3] ] ``` *Note*: Ensure your solution is efficiently handling the sparsity of matrices to reduce unnecessary computations.","solution":"from typing import List def sparse_matrix_multiplication(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: # Determine the dimensions of the matrices m = len(matrix1) n = len(matrix1[0]) p = len(matrix2[0]) # Initialize the result matrix with zeros result = [[0] * p for _ in range(m)] # Convert both matrices to list of non-zero entries matrix1_non_zero = {} matrix2_non_zero = {} for i in range(m): for j in range(n): if matrix1[i][j] != 0: if i not in matrix1_non_zero: matrix1_non_zero[i] = {} matrix1_non_zero[i][j] = matrix1[i][j] for i in range(n): for j in range(p): if matrix2[i][j] != 0: if i not in matrix2_non_zero: matrix2_non_zero[i] = {} matrix2_non_zero[i][j] = matrix2[i][j] # Compute the matrix multiplication for i in matrix1_non_zero: for k in matrix1_non_zero[i]: if k in matrix2_non_zero: for j in matrix2_non_zero[k]: result[i][j] += matrix1_non_zero[i][k] * matrix2_non_zero[k][j] return result"},{"question":"# Coding Assessment Question **Problem Statement:** You are tasked with writing a function that computes the missing side of a right triangle, given the other two sides. According to the Pythagorean theorem, in a right triangle, the square of the hypotenuse (( c )) is equal to the sum of the squares of the other two sides (( a ) and ( b )). Given the lengths of two sides of a right triangle, you need to find the length of the third side. The function should determine whether the missing side is the hypotenuse or one of the other sides based on the provided input. Your function should validate the inputs to ensure that all lengths are positive. If any length is non-positive, the function should raise a `ValueError` with the message \\"All side lengths must be positive\\". **Function Signature:** ```python def find_missing_side(side1: float, side2: float, hypotenuse: bool) -> float: pass ``` # Input: - `side1`: A positive float representing one of the sides of the triangle. - `side2`: A positive float representing another side of the triangle. - `hypotenuse`: A boolean indicating whether the missing side is the hypotenuse (True) or not (False). # Output: - Returns a float, the length of the missing side. # Constraints: - All input side lengths will be positive floating-point numbers. # Example Usage: ```python print(find_missing_side(side1=3, side2=4, hypotenuse=True)) # Output: 5.0 print(find_missing_side(side1=5, side2=12, hypotenuse=True)) # Output: 13.0 print(find_missing_side(side1=13, side2=12, hypotenuse=False))# Output: 5.0 ``` # Edge Cases: - If either `side1` or `side2` is zero or negative, the function should raise a `ValueError`. **Test Cases:** 1. `find_missing_side(3, 4, True)` should return `5.0`. 2. `find_missing_side(6, 8, True)` should return `10.0`. 3. `find_missing_side(5, 12, True)` should return `13.0`. 4. `find_missing_side(13, 5, False)` should return `12.0`. 5. `find_missing_side(-3, 4, True)` should raise `ValueError`. 6. `find_missing_side(5, 0, True)` should raise `ValueError`. # Implementation: ```python import math def find_missing_side(side1: float, side2: float, hypotenuse: bool) -> float: if side1 <= 0 or side2 <= 0: raise ValueError(\\"All side lengths must be positive\\") if hypotenuse: return math.sqrt(side1**2 + side2**2) else: if side1 > side2: return math.sqrt(side1**2 - side2**2) else: return math.sqrt(side2**2 - side1**2) ```","solution":"import math def find_missing_side(side1: float, side2: float, hypotenuse: bool) -> float: if side1 <= 0 or side2 <= 0: raise ValueError(\\"All side lengths must be positive\\") if hypotenuse: return math.sqrt(side1**2 + side2**2) else: # side1 and side2 should form right-angle sides, hence # one should be larger (the hypotenuse) and one smaller return math.sqrt(abs(side1**2 - side2**2))"},{"question":"# Scenario You are tasked with building a command-line application that takes a text file and highlights specific phrases within the file content. The phrases to be highlighted are provided as input arguments. The application should format the text, bolding every occurrence of each specified phrase, and then save the formatted content to a new text file. # Objective Develop a script to read a text file, search for specified phrases, and highlight them by bolding. Bolding will be represented by enclosing the phrase in `**` (double asterisks). # Instructions 1. Implement the function `highlight_phrases_in_file`: * Takes input file name (`input_filename`), a list of phrases to highlight (`phrases`), and output file name (`output_filename`). * Reads the content of the input file. * Highlights each occurrence of each phrase in the file content. * Writes the modified content to the output file. ```python def highlight_phrases_in_file(input_filename, phrases, output_filename): pass ``` 2. Ensure that the phrases are highlighted by surrounding them with `**` (e.g., **phrase**). # Expected Input and Output - **Input**: `highlight_phrases_in_file(\'sample.txt\', [\'hello\', \'world\'], \'highlighted_sample.txt\')` - **Output**: Content of `highlighted_sample.txt` should have \'hello\' and \'world\' phrases bolded if they appear in \'sample.txt\'. # Example Usage Given an input text file `sample.txt` with the following content: ``` Hello, world! This is a simple file with the words hello and world mentioned multiple times. ``` and running: ```python highlight_phrases_in_file(\'sample.txt\', [\'hello\', \'world\'], \'highlighted_sample.txt\') ``` The `highlighted_sample.txt` should have the following content: ``` **Hello**, **world**! This is a simple file with the words **hello** and **world** mentioned multiple times. ``` # Constraints - Ignore case when matching phrases (highlight should be case insensitive). - The input should be read and output should be written in UTF-8 text format. - If the input file does not exist, the script should raise an appropriate error message. # Additional Notes - Take care to preserve the original content format with only the specified phrases highlighted. - Handle edge cases where phrases might overlap or be subsets of one another. # Potential Edge Cases - Overlapping phrases. - Empty phrases list. - Input file does not exist.","solution":"def highlight_phrases_in_file(input_filename, phrases, output_filename): try: with open(input_filename, \'r\', encoding=\'utf-8\') as file: content = file.read() except FileNotFoundError: raise FileNotFoundError(f\\"The file {input_filename} does not exist\\") # Sort phrases by length in descending order to prevent overlapping issues phrases = sorted(phrases, key=len, reverse=True) for phrase in phrases: content = content.replace(phrase, f\'**{phrase}**\') content = content.replace(phrase.capitalize(), f\'**{phrase.capitalize()}**\') content = content.replace(phrase.upper(), f\'**{phrase.upper()}**\') with open(output_filename, \'w\', encoding=\'utf-8\') as file: file.write(content)"},{"question":"# Problem Statement In a social networking platform, users can follow others to receive updates or posts. The platform needs a way to determine how information propagates through the network when a user posts an update. The goal is to identify the users who will eventually receive the update directly or indirectly. # Requirements 1. **Function Signature**: ```python def get_reach(network: dict[str, list[str]], user: str) -> list[str]: ``` - **Input**: * `network`: A dictionary where keys are string usernames, and values are lists of usernames that the key user follows. * `user`: A string username who has posted an update. - **Output**: * Return a list of usernames, in any order, that will receive the update directly or indirectly. # Example Input: ```python network = { \\"alice\\": [\\"bob\\", \\"charlie\\"], \\"bob\\": [\\"david\\"], \\"charlie\\": [\\"david\\", \\"edward\\"], \\"david\\": [\\"frank\\"], \\"edward\\": [], \\"frank\\": [], \\"george\\": [] } user = \\"alice\\" ``` Output: ```python [\\"bob\\", \\"charlie\\", \\"david\\", \\"edward\\", \\"frank\\"] ``` Explanation: - Alice follows Bob and Charlie. - Bob follows David. - Charlie follows David and Edward. - David follows Frank. - Edward follows no one. - Frank follows no one. - George is isolated and follows no one, hence not included in the propagation from Alice. # Constraints and Performance Requirements 1. Assume 1 <= len(network) <= 1000. 2. Assume all usernames are unique strings and the values in the dictionary entries are lists of unique strings. 3. The solution should handle networks where users follow no one and possibly isolated users. 4. The implementation should be efficient, avoiding unnecessary computations and ensuring both time and space complexity are optimal. # Notes - The output list should not contain duplicates. - The user that posts the update should not be included in the output list. - Ensure the network preserves the direction of following correctly, meaning if `user1` follows `user2`, then `user2` does not necessarily follow `user1`. # Additional Test Cases ```python def test_get_reach(): assert sorted(get_reach({ \\"alice\\": [\\"bob\\", \\"charlie\\"], \\"bob\\": [\\"david\\"], \\"charlie\\": [\\"david\\", \\"edward\\"], \\"david\\": [\\"frank\\"], \\"edward\\": [], \\"frank\\": [], \\"george\\": [] }, \\"alice\\")) == [\\"bob\\", \\"charlie\\", \\"david\\", \\"edward\\", \\"frank\\"] assert sorted(get_reach({ \\"alice\\": [\\"bob\\"], \\"bob\\": [\\"alice\\", \\"charlie\\"], \\"charlie\\": [\\"alice\\"], }, \\"alice\\")) == [\\"bob\\", \\"charlie\\"] assert sorted(get_reach({ \\"alice\\": [\\"bob\\", \\"charlie\\"], \\"bob\\": [], \\"charlie\\": [], \\"david\\": [\\"edward\\"], \\"edward\\": [\\"david\\"], \\"frank\\": [], \\"george\\": [\\"frank\\"] }, \\"george\\")) == [\\"frank\\"] if __name__ == \\"__main__\\": test_get_reach() ```","solution":"def get_reach(network: dict[str, list[str]], user: str) -> list[str]: Given a social network and a user who posts an update, this function returns a list of users who will receive the update directly or indirectly. reached_users = set() stack = [user] while stack: current_user = stack.pop() for follower in network.get(current_user, []): if follower not in reached_users: reached_users.add(follower) stack.append(follower) reached_users.discard(user) return list(reached_users)"},{"question":"# Regular Expression Pattern Matching In this task, you will implement a function to perform pattern matching using regular expressions. Regular expressions (regex) are a powerful way to match patterns in text based on a specific syntax. Your function will take a text and a pattern, and it should return True if the pattern matches the text, and False otherwise. Problem Statement Write a function `regex_match(text, pattern)` that determines whether a given pattern matches the entire text using regular expressions. Input: - `text`: A string that represents the text to be matched against. - `pattern`: A string that represents the regular expression pattern to match. Output: - A boolean value: `True` if the pattern matches the text, `False` otherwise. Constraints: - The length of `text` will be between 1 and 1000 characters. - The length of `pattern` will be between 1 and 100 characters. - You may assume the pattern will use basic regex constructs like `.` (any character), `*` (zero or more of the preceding element), and `+` (one or more of the preceding element). Example: ```python text = \\"aab\\" pattern = \\"c*a*b\\" result = regex_match(text, pattern) print(result) # Output: True ``` Explanation: - In the given example, the pattern \\"c*a*b\\" can match the text \\"aab\\". Here, `c*` means zero or more `c`, `a*` means zero or more `a`, and `b` means exactly `b`. Performance Requirements: The function should execute efficiently within the given constraints and handle all edge cases. # Hints - You can use the `re` module in Python for regular expression operations. - Consider edge cases, such as when the pattern is longer than the text or uses special characters excessively. - The primary functions that might help are `re.fullmatch()` for exact matches. Expected Output: ```python text = \\"aa\\" pattern = \\"a\\" result = regex_match(text, pattern) print(result) # Output: False text = \\"ab\\" pattern = \\".*\\" result = regex_match(text, pattern) print(result) # Output: True text = \\"mississippi\\" pattern = \\"mis*is*p*.\\" result = regex_match(text, pattern) print(result) # Output: False ``` Feel free to use Python’s `re` module to achieve the desired functionality.","solution":"import re def regex_match(text, pattern): Determines whether a given pattern matches the entire text using regular expressions. Parameters: - text (str): A string that represents the text to be matched against. - pattern (str): A string that represents the regular expression pattern to match. Returns: - bool: True if the pattern matches the text, False otherwise. return bool(re.fullmatch(pattern, text))"},{"question":"# Problem Statement You are tasked with developing a function that determines whether a given tic-tac-toe board configuration is a valid state or not. In a valid tic-tac-toe game, the number of moves made by \'X\' should either be equal to or one more than the number of moves made by \'O\'. Additionally, \'X\' starts the game, so there should not be more \'O\'s than \'X\'s at any point. Also, if one player has won, the game should not have more moves after the winning move. # Task Implement the function `is_valid_tictactoe_state(board: List[str]) -> bool` where: * `board`: A list of strings representing the current state of the board. Each string contains three characters representing a row on the board, where each character is either \'X\', \'O\', or a space \' \' (indicating an empty cell). Input * `board` (len(board) == 3, len(board[i]) == 3 for all `i`): A 3x3 tic-tac-toe board containing \'X\', \'O\', and \' \' characters. Output * Return a boolean value indicating whether the given tic-tac-toe board configuration is a valid state. # Example ```python is_valid_tictactoe_state([\\"XOX\\", \\" X \\", \\" O \\"]) # Output: True is_valid_tictactoe_state([\\"XXX\\", \\"OOO\\", \\" \\"]) # Output: False ``` Explanation For the first example: 1. The board is: ``` XOX X O ``` 2. Counts: X = 3, O = 2, and \' \' = 4 3. The count of \'X\' is one more than \'O\', which is allowed. For the second example: 1. The board is: ``` XXX OOO ``` 2. Both players cannot win simultaneously, hence invalid. # Constraints * Ensure your solution handles the validation of the board state correctly. * Verify that counts and winning conditions don\'t contradict the rules of tic-tac-toe. * Consider edge cases such as all spaces or a winning state with extra moves.","solution":"from typing import List def is_valid_tictactoe_state(board: List[str]) -> bool: Determines if a given tic-tac-toe board configuration is a valid state. def check_winner(player: str) -> bool: # Check rows, columns and diagonals for a win return any([ all(cell == player for cell in row) for row in board ]) or any([ all(board[row][col] == player for row in range(3)) for col in range(3) ]) or all([ board[i][i] == player for i in range(3) ]) or all([ board[i][2 - i] == player for i in range(3) ]) # Count X\'s and O\'s x_count = sum(row.count(\'X\') for row in board) o_count = sum(row.count(\'O\') for row in board) if o_count > x_count: return False if x_count > o_count + 1: return False x_wins = check_winner(\'X\') o_wins = check_winner(\'O\') if x_wins and o_wins: return False if x_wins and x_count != o_count + 1: return False if o_wins and x_count != o_count: return False return True"},{"question":"# Question: Sorting an Array by Frequency and Value You are provided with an array of integers. Your task is to sort the array based on the frequency of each integer in ascending order. When two integers have the same frequency, they should be sorted by their value in descending order. Function Signature ```python def sort_by_frequency(arr: List[int]) -> List[int]: pass ``` Input * `arr`: A list of integers. Constraints: (1 leq text{len}(arr) leq 10^3). Output * A list of integers sorted by the specified criteria. # Example ```python >>> sort_by_frequency([4, 6, 2, 2, 6, 4, 4, 4]) [6, 6, 2, 2, 4, 4, 4, 4] ``` # Explanation - The frequency of the integers is: 4 appears 4 times, 6 appears 2 times, and 2 appears 2 times. - Since 2 and 6 have the same frequency, we sort them by their value in descending order, which gives 6, 6, 2, 2. - The final sorted array is: [6, 6, 2, 2, 4, 4, 4, 4]. Notes * Consider all edge cases such as arrays with identical elements or arrays with maximum length. * Ensure an efficient implementation with respect to time complexity. ```python from typing import List from collections import Counter def sort_by_frequency(arr: List[int]) -> List[int]: counts = Counter(arr) sorted_arr = sorted(arr, key=lambda x: (counts[x], -x)) return sorted_arr ```","solution":"from typing import List from collections import Counter def sort_by_frequency(arr: List[int]) -> List[int]: # Count frequency of each element using Counter counts = Counter(arr) # Sort the array using a custom lambda function. # Key: first by frequency (ascending), then by value (descending) sorted_arr = sorted(arr, key=lambda x: (counts[x], -x)) return sorted_arr"},{"question":"# Question: Geometric Shape Areas You are tasked with writing three functions to calculate the areas of different geometric shapes: circles, rectangles, and triangles. Each function must handle various input validations and return the appropriate area amount based on standard geometric formulas. Function 1: `circle_area(radius: float) -> float` **Calculate the area of a circle.** - **Input**: - `radius` (float): The radius of the circle. - **Output**: - `float`: Area of the circle calculated using the formula π * radius^2. - **Constraints**: - `radius` must be greater than 0. Function 2: `rectangle_area(length: float, width: float) -> float` **Calculate the area of a rectangle.** - **Input**: - `length` (float): The length of the rectangle. - `width` (float): The width of the rectangle. - **Output**: - `float`: Area of the rectangle calculated using the formula length * width. - **Constraints**: - Both `length` and `width` must be greater than 0. Function 3: `triangle_area(base: float, height: float) -> float` **Calculate the area of a triangle.** - **Input**: - `base` (float): The base of the triangle. - `height` (float): The height of the triangle. - **Output**: - `float`: Area of the triangle calculated using the formula 0.5 * base * height. - **Constraints**: - Both `base` and `height` must be greater than 0. # Testing & Validation - Include checks for invalid inputs like negative or zero values for radius, length, width, base, and height. - Use various test cases to validate the correctness of your implementation.","solution":"import math def circle_area(radius: float) -> float: Calculate the area of a circle given its radius. :param radius: float, the radius of the circle :return: float, the area of the circle if radius <= 0: raise ValueError(\\"Radius must be greater than 0.\\") return math.pi * radius**2 def rectangle_area(length: float, width: float) -> float: Calculate the area of a rectangle given its length and width. :param length: float, the length of the rectangle :param width: float, the width of the rectangle :return: float, the area of the rectangle if length <= 0 or width <= 0: raise ValueError(\\"Length and width must be greater than 0.\\") return length * width def triangle_area(base: float, height: float) -> float: Calculate the area of a triangle given its base and height. :param base: float, the base of the triangle :param height: float, the height of the triangle :return: float, the area of the triangle if base <= 0 or height <= 0: raise ValueError(\\"Base and height must be greater than 0.\\") return 0.5 * base * height"},{"question":"# Find the Second Most Frequent Word You are provided with a text document, and your task is to write a function to find the second most frequently occurring word in the document. If multiple words have the same frequency, any one of them can be returned. The words are case-insensitive, and you should ignore any punctuation marks. Function Signature ```python def second_most_frequent_word(text: str) -> str: Function to find the second most frequently occurring word in the text. :param text: A string containing the text document. :return: A string representing the second most frequent word. ``` Constraints - The text document contains only alphabetic characters and punctuations. - The length of the text document is less than 10^4 characters. - Words are separated by white spaces, and punctuation marks are considered as separators. Example Usage ```python text = \\"Hello, world! HelLo everyone. This is a test. Hello World!\\" # Function call second_word = second_most_frequent_word(text) print(second_word) # Output: \\"world\\" ``` Task 1. Implement the `second_most_frequent_word` function as described above. 2. Ensure that the function handles edge cases such as no words or only one unique word in the text. 3. Test the function with different text inputs to verify its correctness and efficiency. # Considerations - Use regular expressions to handle punctuation marks. - Convert all words to lower case to ensure case-insensitivity. - Consider the time complexity of your solution while counting word frequencies. - Handle cases where there\'s no second most frequent word gracefully.","solution":"import re from collections import Counter def second_most_frequent_word(text: str) -> str: Function to find the second most frequently occurring word in the text. :param text: A string containing the text document. :return: A string representing the second most frequent word. # Remove punctuation and convert text to lowercase words = re.findall(r\'bw+b\', text.lower()) # Count word frequencies word_counts = Counter(words) # If there are less than 2 unique words, return an empty string or handle accordingly if len(word_counts) < 2: return \\"\\" # Get the most common words most_common_words = word_counts.most_common() # Get the second most frequent word second_most_frequent = most_common_words[1][0] return second_most_frequent"},{"question":"# Coding Assessment Question You are asked to implement two functions that deal with triangular numbers and their properties. The functions will validate if the number is triangular and compute the nearest triangular number if the given number is not triangular. Task **Function 1:** `is_triangular_number(n: int) -> bool` Implement a function to verify if the given number is a triangular number. A triangular number is one that can be represented as a triangle with dots. The `n`-th triangular number is given by the formula `n * (n + 1) / 2`. - **Input** - `n` (int): A positive integer to be checked for the triangular number property. - **Output** - Returns `True` if the number is a triangular number, `False` otherwise. - **Constraints** - `n` should be a positive integer. - The function should handle large values efficiently. - **Examples** ```python assert is_triangular_number(6) == True assert is_triangular_number(10) == True assert is_triangular_number(7) == False ``` **Function 2:** `nearest_triangular_number(n: int) -> int` Implement a function to find the nearest triangular number to the given number. If the given number is already a triangular number, return the number itself. If not, find the closest triangular number either smaller or larger. - **Input** - `n` (int): A positive integer for which the nearest triangular number is sought. - **Output** - Returns the nearest triangular number as an `int`. - **Constraints** - `n` should be a positive integer. - The function should efficiently handle large values and the proximity of triangular numbers. - **Examples** ```python assert nearest_triangular_number(8) == 10 assert nearest_triangular_number(14) == 15 assert nearest_triangular_number(6) == 6 ``` Implement these functions keeping in mind the constraints, edge cases, and performance optimizations.","solution":"import math def is_triangular_number(n: int) -> bool: Checks if a number is a triangular number. if n <= 0: return False # Calculate the determinant of the quadratic equation x^2 + x - 2n = 0 determinant = 1 + 8 * n sqrt_determinant = int(math.isqrt(determinant)) # for precision in integer arithmetic if sqrt_determinant * sqrt_determinant != determinant: return False # Check if the computed root is an integer k = (-1 + sqrt_determinant) / 2 return k == int(k) def nearest_triangular_number(n: int) -> int: Finds the nearest triangular number to the given number. if n <= 0: return 0 # No positive triangular numbers for non-positive input k = int(math.isqrt(2 * n)) # Start from approximate root of the equation lower = k * (k + 1) // 2 upper = (k + 1) * (k + 2) // 2 if abs(n - lower) <= abs(n - upper): return lower else: return upper"},{"question":"# Problem Statement You are tasked with writing functionalities related to matrices and linear algebra. These concepts are critical in various domains including computer graphics, engineering, and data science. # Your Task 1. **Calculate Determinant of a 2x2 Matrix**: Implement a function that calculates the determinant of a given 2x2 matrix. The determinant ( D ) of a 2x2 matrix is given by: [ D = ad - bc ] where the matrix is represented as: [ begin{pmatrix} a & b c & d end{pmatrix} ] 2. **Check if a Matrix is Singular**: Implement a function that checks if a given 2x2 matrix is singular. A matrix is considered singular if its determinant is zero. # Instructions 1. **determinant_2x2**: * **Input**: A list of lists `matrix` where `matrix` is a 2x2 array such that `matrix = [[a, b], [c, d]]`. * **Output**: `float` - the determinant of the matrix. * **Constraints**: The matrix will have exactly 2 rows and 2 columns. 2. **is_singular**: * **Input**: A list of lists `matrix` where `matrix` is a 2x2 array such that `matrix = [[a, b], [c, d]]`. * **Output**: `bool` - True if the matrix is singular, and False otherwise. * **Constraints**: The matrix will have exactly 2 rows and 2 columns. # Example ```python >>> determinant_2x2([[1, 2], [3, 4]]) -2.0 >>> is_singular([[1, 2], [2, 4]]) True >>> is_singular([[1, 2], [3, 4]]) False ``` # Requirements - The solutions should handle edge cases involving invalid inputs. - Performance should be O(1) for both functions. - Adhere to the provided constraints for correctness.","solution":"def determinant_2x2(matrix): Calculate the determinant of a 2x2 matrix. matrix: list of lists, a 2x2 matrix [[a, b], [c, d]] Returns: float: the determinant of the matrix if len(matrix) != 2 or any(len(row) != 2 for row in matrix): raise ValueError(\\"Input must be a 2x2 matrix\\") a, b = matrix[0] c, d = matrix[1] return a * d - b * c def is_singular(matrix): Check if a 2x2 matrix is singular. matrix: list of lists, a 2x2 matrix [[a, b], [c, d]] Returns: bool: True if the matrix is singular (determinant is zero), False otherwise return determinant_2x2(matrix) == 0.0"},{"question":"# Chess Move Validation You are asked to implement a function to validate if a given move is legal in a chess game. In particular, this problem will focus on validating the movement of one type of piece: the rook. Problem Statement Implement the following function in Python: 1. **`is_valid_rook_move(board: list, start: tuple, end: tuple) -> bool`**: - This function checks if a rook can legally move from the `start` position to the `end` position on a given chess `board`. - **Input**: - `board`: a 2D list representing an 8x8 chessboard, where each element is either an empty string `\\"\\"` representing an empty square, or a string representing a piece (e.g. `\\"WR\\"` for a white rook, `\\"BR\\"` for a black rook, `\\"WP\\"` for a white pawn, etc.). - `start`: a tuple `(row, col)` representing the starting coordinates of the rook on the board. - `end`: a tuple `(row, col)` representing the ending coordinates of the rook on the board. - **Output**: A boolean value indicating whether the move from `start` to `end` is valid for a rook. # Additional Details - The rook can move any number of squares along a row or column. - The rook cannot pass through other pieces, either friendly or enemy. - The target position can be occupied by an enemy piece (indicating capture) but not by a friendly piece. # Example ```python board = [ [\\"WR\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"BR\\"], [\\"\\", \\"\\", \\"\\", \\"\\", \\"WP\\", \\"\\", \\"\\", \\"\\"], [\\"\\", \\"BP\\", \\"\\", \\"\\", \\"\\", \\"BP\\", \\"\\", \\"\\"], [\\"\\", \\"\\", \\"\\", \\"WR\\", \\"\\", \\"\\", \\"\\", \\"\\"], [\\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\"], [\\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\"], [\\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\"], [\\"BR\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"WR\\"], ] start = (0, 0) end = (0, 4) print(is_valid_rook_move(board, start, end)) # Output: True start = (3, 3) end = (3, 0) print(is_valid_rook_move(board, start, end)) # Output: True start = (0, 7) end = (7, 7) print(is_valid_rook_move(board, start, end)) # Output: False (destination occupied by friendly piece) ``` Ensure to handle all edge cases, such as moving off the board, and that the board remains unchanged after the function is executed.","solution":"def is_valid_rook_move(board, start, end): Checks if a rook can legally move from the start position to the end position on the board. :param board: List[List[str]] - 2D list representing the chessboard :param start: Tuple[int, int] - starting coordinates (row, col) of the rook :param end: Tuple[int, int] - ending coordinates (row, col) of the rook :return: bool - True if the move is valid, False otherwise start_row, start_col = start end_row, end_col = end start_piece = board[start_row][start_col] end_piece = board[end_row][end_col] if start_piece == \\"\\" or \\"R\\" not in start_piece: return False if start_row != end_row and start_col != end_col: return False if start_row == end_row: step = 1 if start_col < end_col else -1 for col in range(start_col + step, end_col, step): if board[start_row][col] != \\"\\": return False if start_col == end_col: step = 1 if start_row < end_row else -1 for row in range(start_row + step, end_row, step): if board[row][start_col] != \\"\\": return False if end_piece != \\"\\" and start_piece[0] == end_piece[0]: return False return True"},{"question":"# Question Scenario: You are tasked with developing an application that requires manipulating a string through various operations. Given the specific operations, efficient handling of string transformations is crucial. To achieve this, you decide to implement a dynamic string manipulation class that can handle append, delete, and get operations efficiently. Task: Implement a class `DynamicString` with the following methods: 1. **__init__()**: - Initializes an empty string. 2. **append(value: str) -> None**: - Appends the given `value` string to the current string. 3. **delete(count: int) -> None**: - Deletes the last `count` characters from the current string. If `count` is greater than the length of the string, deletes the entire string. 4. **get_string() -> str**: - Returns the current string. Class Definition: ```python class DynamicString: def __init__(self) -> None: self.current_string = \\"\\" def append(self, value: str) -> None: pass def delete(self, count: int) -> None: pass def get_string(self) -> str: pass ``` Constraints: - All input strings `value` consist of ASCII characters. - The `count` for delete operations will be a non-negative integer. - The length of `value` in append operations will be between 1 and 10^5. - The number of operations (append/delete/get_string) can be up to 10^5. Example: ```python ds = DynamicString() ds.append(\\"Hello\\") ds.append(\\"World\\") assert ds.get_string() == \\"HelloWorld\\" ds.delete(5) assert ds.get_string() == \\"Hello\\" ds.delete(10) assert ds.get_string() == \\"\\" ds.append(\\"Python\\") assert ds.get_string() == \\"Python\\" ``` Performance Requirements: - Ensure all operations (`append`, `delete`, and `get_string`) are performed efficiently, ideally in O(1) average time.","solution":"class DynamicString: def __init__(self) -> None: self.current_string = [] def append(self, value: str) -> None: self.current_string.append(value) def delete(self, count: int) -> None: remaining_count = count while remaining_count > 0 and self.current_string: last_string = self.current_string.pop() if len(last_string) > remaining_count: self.current_string.append(last_string[:-remaining_count]) remaining_count = 0 else: remaining_count -= len(last_string) def get_string(self) -> str: return \'\'.join(self.current_string)"},{"question":"# Coding Challenge In a software development environment, you\'re often required to handle large datasets where performance and efficiency are critical. One common task is to find the most frequently occurring element in an array. Objective Your task is to implement a function that finds the most frequently occurring element in a given list. If there are multiple elements with the same highest frequency, return any one of them. Requirements - Implement the function `most_frequent_element` that takes a list as input and returns the most frequently occurring element. - You may assume the list is non-empty and contains only hashable elements. Function Signature ```python def most_frequent_element(lst: List) -> any: pass ``` Input - `lst`: A list of hashable elements. - Example: [1, 3, 3, 2, 1, 3, 4, 2, 3] Output - The single most frequently occurring element. - Example: 3 Constraints - The input list will have at least one element. - The list can contain any hashable types like integers, strings, or tuples. Example Here is an example of how your function should work: ```python >>> most_frequent_element([1, 3, 3, 2, 1, 3, 4, 2, 3]) 3 >>> most_frequent_element([\'a\', \'b\', \'a\', \'c\', \'a\']) \'a\' >>> most_frequent_element([(1, 2), (1, 2), (3, 4)]) (1, 2) ``` Code Template Use the following template to start your implementation: ```python from typing import List def most_frequent_element(lst: List) -> any: frequency = {} for element in lst: if element in frequency: frequency[element] += 1 else: frequency[element] = 1 # Return the element with the highest frequency return max(frequency, key=frequency.get) if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"from typing import List def most_frequent_element(lst: List) -> any: Finds the most frequently occurring element in the list. Args: lst: A list of hashable elements. Returns: The most frequently occurring element. frequency = {} for element in lst: if element in frequency: frequency[element] += 1 else: frequency[element] = 1 # Return the element with the highest frequency return max(frequency, key=frequency.get)"},{"question":"Question: Implement the Knuth-Morris-Pratt (KMP) Algorithm for Pattern Matching **Problem Statement**: You are given two strings, `text` and `pattern`. Your task is to implement the Knuth-Morris-Pratt (KMP) algorithm to find all occurrences of the `pattern` in the `text`. # Function Signature ```python def KMP_search(text: str, pattern: str) -> List[int]: ``` # Input - `text`: A string where the pattern is to be searched. - `pattern`: A string representing the pattern to be searched in the text. # Output - Returns a list of integers representing the starting indices of all occurrences of the `pattern` in the `text`. # Constraints - The lengths of `text` and `pattern` will be between 1 and 10^5. - The `text` and `pattern` contain only lowercase English letters. # Example ```python text = \\"ababcabcabababd\\" pattern = \\"ababd\\" result = KMP_search(text, pattern) print(result) # Output should be [10] ``` # Note - Explain how the KMP algorithm preprocesses the pattern to create a partial match table, also known as the \\"pi\\" table. - Detail how the KMP algorithm utilizes this table during the search process to skip unnecessary comparisons. This problem tests your understanding of the KMP algorithm and your ability to handle substrings and pattern matching efficiently. Ensure your implementation optimizes the process using the partial match table. For example, if `text = \\"ababcabcabababd\\"` and `pattern = \\"ababd\\"`, the result would be `[10]`, indicating the pattern starts at index 10 in the text.","solution":"from typing import List def compute_LPS_array(pattern: str) -> List[int]: This function computes the Longest Prefix Suffix (LPS) array, also known as the \\"partial match\\" table, which will be used to skip unnecessary comparisons in the KMP algorithm. m = len(pattern) lps = [0] * m length = 0 # Length of the previous longest prefix suffix i = 1 while i < m: if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def KMP_search(text: str, pattern: str) -> List[int]: This function implements the KMP algorithm to find all occurrences of the pattern in the text. It returns a list of starting indices of the pattern in the text. n = len(text) m = len(pattern) lps = compute_LPS_array(pattern) result = [] i = 0 # index for text j = 0 # index for pattern while i < n: if pattern[j] == text[i]: i += 1 j += 1 if j == m: result.append(i - j) j = lps[j - 1] elif i < n and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"# Question: Unique Character Identifier Write a Python function `unique_character_identifier(string: str) -> list` that returns a list of all unique characters in the given string in the order they first appear. The function should be case-sensitive. Constraints: - The input string can include all printable ASCII characters. - Characters are considered unique based on their first occurrence in the string (preserve order). - The length of the input string (1 leq |string| leq 10^6). Input: - A single string `string` with length (1 leq |string| leq 10^6). Output: - A list of unique characters in the order they first appear in the input string. Example: ```python >>> string = \\"Programming is fun!\\" >>> unique_character_identifier(string) [\'P\', \'r\', \'o\', \'g\', \'a\', \'m\', \'i\', \'n\', \' \', \'s\', \'f\', \'u\', \'!\'] >>> string = \\"aabbcc\\" >>> unique_character_identifier(string) [\'a\', \'b\', \'c\'] ``` Implementation: Provide the implementation of the function to meet the above requirements. Ensure the function handles edge cases like repeated characters and special characters correctly.","solution":"def unique_character_identifier(string: str) -> list: Returns a list of all unique characters in the given string in the order they first appear. seen = set() unique_chars = [] for char in string: if char not in seen: unique_chars.append(char) seen.add(char) return unique_chars"},{"question":"# Prime Factorization Sum Problem Description Write a function `sum_of_prime_factor_digits(n: int) -> int` that calculates the sum of the digits of all prime factors of a given number `n`. Prime factors include repeated multiples. Input - An integer `n` representing the number for which the prime factors\' digit sum will be calculated. - (2 leq n leq 10^9) Output - An integer representing the sum of the digits of all the prime factors of the given number. Example ```python assert sum_of_prime_factor_digits(28) == 10 # 28 = 2 * 2 * 7 -> prime factors: 2, 2, 7 -> digit sum: 2+2+7 = 11 assert sum_of_prime_factor_digits(45) == 12 # 45 = 3 * 3 * 5 -> prime factors: 3, 3, 5 -> digit sum: 3+3+5 = 11 assert sum_of_prime_factor_digits(77) == 14 # 77 = 7 * 11 -> prime factors: 7, 11 -> digit sum: 7+1+1 = 9 assert sum_of_prime_factor_digits(100) == 5 # 100 = 2 * 2 * 5 * 5 -> prime factors: 2, 2, 5, 5 -> digit sum: 2+2+5+5 = 14 assert sum_of_prime_factor_digits(9973) == 28 # 9973 is a prime number -> prime factor: 9973 -> digit sum: 9+9+7+3 = 28 ``` Constraints: - Optimize for efficiency due to potential large input size. - Handle edge cases such as the smallest prime numbers and extremely large single primes.","solution":"def sum_of_prime_factor_digits(n: int) -> int: Calculates the sum of the digits of all prime factors of n. Prime factors include repeated multiples. def sum_of_digits(num): return sum(int(digit) for digit in str(num)) def prime_factors(num): factors = [] # Check for number of 2s while num % 2 == 0: factors.append(2) num //= 2 # Check for other primes for i in range(3, int(num**0.5) + 1, 2): while num % i == 0: factors.append(i) num //= i # If num is a prime number greater than 2 if num > 2: factors.append(num) return factors # Get the prime factors factors = prime_factors(n) # Sum the digits of each prime factor total_sum = sum(sum_of_digits(factor) for factor in factors) return total_sum"},{"question":"# Implement Queue Using Two Stacks You have been provided with a partially implemented class `QueueWithStacks`. Your task is to complete the class by implementing the `enqueue`, `dequeue`, and `peek` methods to simulate a queue using two stacks. Objective Complete the implementation of the `enqueue`, `dequeue`, and `peek` methods in the `QueueWithStacks` class to manage a queue using two stacks. # Tasks 1. **enqueue(x)**: - Pushes the element `x` to the end of the queue. 2. **dequeue()**: - Removes the element from the front of the queue and returns it. - Raises an `IndexError` if the queue is empty when calling `dequeue`. 3. **peek()**: - Returns the element at the front of the queue without removing it. - Raises an `IndexError` if the queue is empty when calling `peek`. # Input/Output - **enqueue method**: - **Input**: - `x`: An integer representing the element to add to the queue. - **Output**: None - **dequeue method**: - **Input**: None - **Output**: An integer representing the dequeued element. - **peek method**: - **Input**: None - **Output**: An integer representing the element at the front of the queue. # Constraints - The elements in the queue are integers. # Sample Usage ```python queue = QueueWithStacks() queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) print(queue.peek()) # Expected output: 1 print(queue.dequeue()) # Expected output: 1 print(queue.dequeue()) # Expected output: 2 queue.enqueue(4) print(queue.peek()) # Expected output: 3 print(queue.dequeue()) # Expected output: 3 print(queue.dequeue()) # Expected output: 4 ``` # Considerations - Ensure your implementation moves elements between the stacks efficiently to maintain queue order. - Handle cases where the queue is empty and methods `dequeue` or `peek` are called. Write your implementation of the `enqueue`, `dequeue`, and `peek` methods below.","solution":"class QueueWithStacks: def __init__(self): self.stack_push = [] self.stack_pop = [] def enqueue(self, x): self.stack_push.append(x) def dequeue(self): if not self.stack_pop: while self.stack_push: self.stack_pop.append(self.stack_push.pop()) if not self.stack_pop: raise IndexError(\\"dequeue from empty queue\\") return self.stack_pop.pop() def peek(self): if not self.stack_pop: while self.stack_push: self.stack_pop.append(self.stack_push.pop()) if not self.stack_pop: raise IndexError(\\"peek from empty queue\\") return self.stack_pop[-1]"},{"question":"# Context: In computer graphics and game development, maintaining spatial relationships between objects is crucial. One way to represent the position and movement of objects is through the use of 2D vectors. A vector can be defined as having a magnitude and direction, making it useful in various computations such as velocity, acceleration, displacement, and more. # Task: Write a class `Vector2D` that implements basic operations for 2D vectors. Your class should support vector addition, subtraction, scalar multiplication, dot product, and magnitude calculation. # Input: * None directly (interactions through class methods and properties). # Output: * Methods that perform the specified vector operations. # Constraints: * Implement the following methods: * `__init__(self, x: float, y: float)`: Initializes the vector with components `x` and `y`. * `add(self, other: \'Vector2D\') -> \'Vector2D\'`: Returns a new vector that is the sum of this vector and another vector. * `subtract(self, other: \'Vector2D\') -> \'Vector2D\'`: Returns a new vector that is the difference between this vector and another vector. * `multiply_by_scalar(self, scalar: float) -> \'Vector2D\'`: Returns a new vector that is the product of this vector and a scalar. * `dot_product(self, other: \'Vector2D\') -> float`: Returns the dot product of this vector and another vector. * `magnitude(self) -> float`: Returns the magnitude (length) of the vector. * Ensure the class handles floating-point arithmetic precisely. # Requirements: * Validate input types for each method to ensure type correctness. * Utilize appropriate mathematical formulas to implement the methods. * The class should be able to handle vectors with both positive and negative components effectively. Example Usage: ```python v1 = Vector2D(3, 4) v2 = Vector2D(1, 2) print(v1.add(v2)) # Expected output: Vector2D(4, 6) print(v1.subtract(v2)) # Expected output: Vector2D(2, 2) print(v1.multiply_by_scalar(3)) # Expected output: Vector2D(9, 12) print(v1.dot_product(v2)) # Expected output: 11 (3*1 + 4*2) print(v1.magnitude()) # Expected output: 5.0 (sqrt(3^2 + 4^2)) ``` # Definition of `Vector2D` class: ```python import math class Vector2D: def __init__(self, x: float, y: float): self.x = x self.y = y def add(self, other: \'Vector2D\') -> \'Vector2D\': return Vector2D(self.x + other.x, self.y + other.y) def subtract(self, other: \'Vector2D\') -> \'Vector2D\': return Vector2D(self.x - other.x, self.y - other.y) def multiply_by_scalar(self, scalar: float) -> \'Vector2D\': return Vector2D(self.x * scalar, self.y * scalar) def dot_product(self, other: \'Vector2D\') -> float: return self.x * other.x + self.y * other.y def magnitude(self) -> float: return math.sqrt(self.x**2 + self.y**2) def __repr__(self) -> str: return f\\"Vector2D({self.x}, {self.y})\\" ```","solution":"import math class Vector2D: def __init__(self, x: float, y: float): self.x = x self.y = y def add(self, other: \'Vector2D\') -> \'Vector2D\': return Vector2D(self.x + other.x, self.y + other.y) def subtract(self, other: \'Vector2D\') -> \'Vector2D\': return Vector2D(self.x - other.x, self.y - other.y) def multiply_by_scalar(self, scalar: float) -> \'Vector2D\': return Vector2D(self.x * scalar, self.y * scalar) def dot_product(self, other: \'Vector2D\') -> float: return self.x * other.x + self.y * other.y def magnitude(self) -> float: return math.sqrt(self.x**2 + self.y**2) def __repr__(self) -> str: return f\\"Vector2D({self.x}, {self.y})\\" def __eq__(self, other): return math.isclose(self.x, other.x) and math.isclose(self.y, other.y)"},{"question":"# Managing Flight Reservations Program **Background**: An airline company wants to implement a system to manage flight reservations. The system should be able to track available seats, booked seats, and manage the reservation and cancellation processes. You are tasked with creating a class-based solution to manage the reservations for this airline. **Objective**: Implement a class `FlightReservation` that tracks seat reservations and cancellations for a single flight. **Task**: 1. Implement the `__init__`, `book_seat`, `cancel_seat`, and `get_available_seats` methods to handle the reservations. 2. Write a function `process_reservations(commands: list[tuple[str, int]]) -> list[str]` that: - Accepts a list of commands where each command is a tuple containing a command string (\'book\' or \'cancel\') and a seat number. - Uses an instance of the `FlightReservation` class to process each command. - Returns a list of strings indicating the outcome of each command in the order they were processed. **Class Signature**: ```python class FlightReservation: def __init__(self, total_seats: int): pass def book_seat(self, seat_number: int) -> str: pass def cancel_seat(self, seat_number: int) -> str: pass def get_available_seats(self) -> list[int]: pass ``` **Function Signature**: ```python def process_reservations(commands: list[tuple[str, int]]) -> list[str]: ``` **Input**: - `commands`: A list of tuples, where each tuple contains a command (\'book\' or \'cancel\') and an integer representing the seat number. Example: `[(\'book\', 1), (\'book\', 2), (\'cancel\', 1)]` - `total_seats`: An integer representing the total number of seats available on the flight. **Output**: - A list of strings indicating the outcome of each command. Example: `[\'Seat 1 booked\', \'Seat 2 booked\', \'Seat 1 canceled\']` **Constraints**: - The number of commands `n` is such that `1 <= n <= 1000`. - The seat number `seat_number` is such that `1 <= seat_number <= total_seats`. - Each seat can only be booked once before it gets canceled. **Example**: ```python total_seats = 5 commands = [(\'book\', 1), (\'book\', 2), (\'cancel\', 1), (\'book\', 1)] # Following code should be implemented within the function process_reservations reservation_system = FlightReservation(total_seats) result = process_reservations(commands) print(result) # Output: [\'Seat 1 booked\', \'Seat 2 booked\', \'Seat 1 canceled\', \'Seat 1 booked\'] ``` You are to write the `FlightReservation` class and the `process_reservations` function according to the specifications.","solution":"class FlightReservation: def __init__(self, total_seats: int): self.total_seats = total_seats self.booked_seats = set() def book_seat(self, seat_number: int) -> str: if seat_number < 1 or seat_number > self.total_seats: return f\\"Seat {seat_number} is out of range\\" if seat_number in self.booked_seats: return f\\"Seat {seat_number} is already booked\\" self.booked_seats.add(seat_number) return f\\"Seat {seat_number} booked\\" def cancel_seat(self, seat_number: int) -> str: if seat_number < 1 or seat_number > self.total_seats: return f\\"Seat {seat_number} is out of range\\" if seat_number not in self.booked_seats: return f\\"Seat {seat_number} is not booked\\" self.booked_seats.remove(seat_number) return f\\"Seat {seat_number} canceled\\" def get_available_seats(self) -> list[int]: return [seat for seat in range(1, self.total_seats + 1) if seat not in self.booked_seats] def process_reservations(commands: list[tuple[str, int]], total_seats: int) -> list[str]: reservation_system = FlightReservation(total_seats) results = [] for command, seat_number in commands: if command == \'book\': results.append(reservation_system.book_seat(seat_number)) elif command == \'cancel\': results.append(reservation_system.cancel_seat(seat_number)) return results"},{"question":"**Objective**: Design a function that identifies the top k frequently occurring elements in a list of integers and returns them in descending order of frequency. If two elements have the same frequency, order them by their value in descending order. **Scenario**: You\'ve collected a series of survey responses, where each integer in the list represents a different category selected by respondents. To analyze the most popular categories, you need to determine which categories (integers) appear most frequently. **Function Signature**: ```python def top_k_frequent_elements(arr: list[int], k: int) -> list[int]: Return the k most frequently occurring elements in the given list in descending order of frequency. Parameters: arr (list[int]): A list of integers that may contain duplicates. k (int): An integer specifying the number of top frequent elements to retrieve. Returns: list[int]: A list of the k most frequent elements in descending order of frequency. Raises: ValueError: If k is out of the valid range (1 <= k <= number of unique elements in arr). pass ``` **Constraints**: 1. The list `arr` is not empty. 2. 1 ≤ k ≤ number of unique elements in arr **Requirements**: 1. The algorithm should have an average time complexity of O(n log k) where n is the length of the list. 2. Handle edge cases such as lists with varying frequencies. 3. The function should return the elements sorted by frequency and then by their value in descending order if frequencies are equal. **Examples**: ```python # Example 1 arr = [1, 1, 1, 2, 2, 3] k = 2 assert top_k_frequent_elements(arr, k) == [1, 2] # 1 appears 3 times, 2 appears 2 times # Example 2 arr = [3, 3, 3, 2, 2, 2, 2, 1] k = 1 assert top_k_frequent_elements(arr, k) == [2] # 2 appears 4 times # Example 3 arr = [1, 2, 2, 3, 3, 3] k = 3 assert top_k_frequent_elements(arr, k) == [3, 2, 1] # All unique elements, sorted by frequency then value # Example 4 arr = [5, 5, 4, 4, 4, 3, 3, 2, 1, 1, 1, 1] k = 2 assert top_k_frequent_elements(arr, k) == [1, 4] # 1 appears 4 times, 4 appears 3 times ``` **Hint**: To efficiently solve this problem, consider using a heap to keep track of the top k elements based on their frequency. Utilize a hash map to count frequencies and a priority queue to determine the order of elements.","solution":"from collections import Counter import heapq def top_k_frequent_elements(arr, k): Return the k most frequently occurring elements in the given list in descending order of frequency. Parameters: arr (list[int]): A list of integers that may contain duplicates. k (int): An integer specifying the number of top frequent elements to retrieve. Returns: list[int]: A list of the k most frequent elements in descending order of frequency. Raises: ValueError: If k is out of the valid range (1 <= k <= number of unique elements in arr). if not arr: raise ValueError(\\"The input array is empty.\\") if not (1 <= k <= len(set(arr))): raise ValueError(\\"k is out of the valid range (1 <= k <= number of unique elements in arr).\\") # Count frequency of each element counter = Counter(arr) # Use a heap to keep track of top k elements based on frequency heap = [(-freq, num) for num, freq in counter.items()] heapq.heapify(heap) # Extract top k elements from the heap top_k = [heapq.heappop(heap)[1] for _ in range(k)] return top_k"},{"question":"# File Data Analysis with Pandas Given the following requirements: 1. A CSV file named `data.csv` that contains columns `id`, `name`, `score`, `date` representing an ID number, a student\'s name, their score, and the date the score was recorded, respectively. 2. You are required to read the CSV file and perform certain operations using the Pandas library. Implement the function `analyze_data` to perform the following tasks: 1. Read the CSV file into a DataFrame. 2. Filter out rows where the `score` is below 50. 3. Sort the DataFrame by `score` in descending order. 4. Group the data by `name` and calculate the average score for each student. 5. Return the name of the student with the highest average score. Function Signature: ```python def analyze_data() -> str: ``` Inputs: - No direct inputs to the function, but the function will read from the `data.csv` file. Output: - `str`: The name of the student with the highest average score. Example CSV File (`data.csv`): ``` id,name,score,date 1,John Doe,75,2023-01-15 2,Jane Smith,82,2023-01-16 3,John Doe,65,2023-01-17 4,Jane Smith,45,2023-01-18 5,John Doe,35,2023-01-19 6,Jane Smith,93,2023-01-20 ``` Example Usage: ```python print(analyze_data()) # Expected output: \\"Jane Smith\\" (assuming Jane Smith has the highest average score after filtering and sorting) ``` Implement `analyze_data`, ensuring to handle possible exceptions and providing efficient operations for handling potentially large datasets.","solution":"import pandas as pd def analyze_data() -> str: try: # Read the CSV file into a DataFrame df = pd.read_csv(\'data.csv\') # Filter out rows where the score is below 50 df = df[df[\'score\'] >= 50] # Sort the DataFrame by score in descending order df = df.sort_values(by=\'score\', ascending=False) # Group the data by name and calculate the average score for each student avg_scores = df.groupby(\'name\')[\'score\'].mean() # Get the name of the student with the highest average score top_student = avg_scores.idxmax() return top_student except Exception as e: print(f\\"An error occurred: {e}\\") return \\"\\""},{"question":"# Coding Assessment Question Context You are part of a developer team working on a basic data processing library, and you need to implement a critical functionality related to handling data sequences. One such function is the `running_median`, which calculates the median value at each step as elements are added to a sequence. Problem Statement **Task**: Implement a `running_median` function in Python that computes the median of the list of numbers as they are added iteratively. The function should process an input list of integers and return a list of medians after each addition. * **Function Specifications**: - **Function**: `running_median` - **Input**: A list of integers (`numbers`). - **Output**: A list of floating-point numbers representing the running medians. * **Constraints**: - The input list is not empty and contains between 1 and 10,000 integers. - Integers are within the range `[-10^6, 10^6]`. * **Performance Requirements**: - The solution should handle the list processing efficiently. - Aim for O(n log n) for the overall time complexity. Example Usage ```python def running_median(numbers: list) -> list: >>> running_median([2, 1, 5, 7, 2, 0, 5]) [2.0, 1.5, 2.0, 3.5, 2.0, 2.0, 2.0] >>> running_median([10, 20, 30]) [10.0, 15.0, 20.0] # Your program should be able to execute the following if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` **Note**: Ensure your solution passes the provided doctest cases without modifications and adheres to the constraints and specifications listed.","solution":"import heapq def running_median(numbers: list) -> list: Given a list of integers, computes the running median as integers are added. :param numbers: List of integers. :return: List of floating-point numbers representing the running medians. >>> running_median([2, 1, 5, 7, 2, 0, 5]) [2.0, 1.5, 2.0, 3.5, 2.0, 2.0, 2.0] >>> running_median([10, 20, 30]) [10.0, 15.0, 20.0] lower_half = [] # Max-heap to store the smaller half of numbers upper_half = [] # Min-heap to store the larger half of numbers medians = [] for number in numbers: if not lower_half or number <= -lower_half[0]: heapq.heappush(lower_half, -number) else: heapq.heappush(upper_half, number) # Balance the heaps if len(lower_half) > len(upper_half) + 1: heapq.heappush(upper_half, -heapq.heappop(lower_half)) elif len(upper_half) > len(lower_half): heapq.heappush(lower_half, -heapq.heappop(upper_half)) # Calculate the median if len(lower_half) == len(upper_half): median = (-lower_half[0] + upper_half[0]) / 2.0 else: median = float(-lower_half[0]) medians.append(median) return medians"},{"question":"New Question # Scenario You are developing a simple social media analytics tool that analyzes user activity data. One of the requirements is to calculate the most active user within a given period based on their activity timestamps. # Task Write a function `most_active_user(activity_data: list[dict]) -> str` that takes a list of dictionaries representing user activity and returns the username of the most active user within that period. # Functional Requirements 1. **Input**: - A list of dictionaries where each dictionary contains: - `username` (string): the username of the user - `timestamp` (string): the time of the activity in the format `YYYY-MM-DDTHH:MM:SSZ` 2. **Output**: - A string representing the username of the most active user (the user with the most activity entries). # Constraints & Performance - The function should efficiently handle lists of up to 10,000 activity records. - Timestamps are guaranteed to follow ISO 8601 format. - If there is a tie (multiple users with the same number of activities), return the username that appears first alphabetically. # Example ```python activity_data = [ {\\"username\\": \\"alice\\", \\"timestamp\\": \\"2023-10-05T14:48:00Z\\"}, {\\"username\\": \\"bob\\", \\"timestamp\\": \\"2023-10-05T14:49:00Z\\"}, {\\"username\\": \\"alice\\", \\"timestamp\\": \\"2023-10-05T14:50:00Z\\"}, {\\"username\\": \\"charlie\\", \\"timestamp\\": \\"2023-10-05T15:20:00Z\\"}, {\\"username\\": \\"bob\\", \\"timestamp\\": \\"2023-10-05T15:45:00Z\\"} ] expected_output = \\"alice\\" # Alice has 2 activity records while Bob and Charlie have 1 each. ``` # Notes - Assume the input data is well-formed and does not require validation. - Consider using a dictionary to count activities per user. - Sorting can help resolve tie-breaking scenarios efficiently. Create the function based on these requirements and provide a solution that fulfills the example given.","solution":"def most_active_user(activity_data): Returns the most active user based on their activity timestamps. If there is a tie, return the username that appears first alphabetically. from collections import defaultdict user_activity_count = defaultdict(int) for record in activity_data: user_activity_count[record[\'username\']] += 1 # Find the user with the most activities, breaking ties by alphabetical order most_active = max(sorted(user_activity_count.keys()), key=lambda u: user_activity_count[u]) return most_active"},{"question":"# Coding Assessment Question Context: You are designing a system that simplifies large numbers by representing them in a human-readable format. Specifically, you will be converting large positive integers into a format that uses K (thousands), M (millions), B (billions), and T (trillions). Task: Write a Python function `simplify_number(num: int) -> str` that takes a large positive integer and returns a string representing the simplified version using the appropriate suffix (K, M, B, T). The number should be rounded to one decimal place if necessary. Implementation Steps: 1. Determine the range in which the number falls (thousands, millions, billions, trillions). 2. Divide the number by the appropriate power of 10 to get the simplified version. 3. Round the result to one decimal place if necessary. 4. Append the correct suffix (K, M, B, T). 5. Return the resulting string. Input Format: - `num`: A positive integer representing the number to be simplified. Output Format: - Return a string representing the simplified number with the appropriate suffix. Constraints: - The input number is between 1,000 and 999,999,999,999 inclusive. Performance Requirements: - The solution should have a time complexity of O(1) and space complexity of O(1). Example: - `simplify_number(1234)` should return `\\"1.2K\\"` - `simplify_number(2500000)` should return `\\"2.5M\\"` - `simplify_number(7500000000)` should return `\\"7.5B\\"` - `simplify_number(1400000000000)` should return `\\"1.4T\\"` Note: - Ensure proper rounding to one decimal place. - Handle edge cases such as exactly 1,000,000 should return \\"1.0M\\".","solution":"def simplify_number(num: int) -> str: Simplifies a large positive integer to a human-readable format with K, M, B, or T suffix. Args: num (int): A large positive integer. Returns: str: The simplified number with the appropriate suffix. if num >= 1_000_000_000_000: return f\\"{num / 1_000_000_000_000:.1f}T\\" elif num >= 1_000_000_000: return f\\"{num / 1_000_000_000:.1f}B\\" elif num >= 1_000_000: return f\\"{num / 1_000_000:.1f}M\\" elif num >= 1_000: return f\\"{num / 1_000:.1f}K\\" else: return str(num)"},{"question":"# Data Analysis and Visualization You are tasked with writing a Python function to analyze and visualize sales data. The sales data is provided in a CSV file format with the following columns: - `Date` (str): The date of the sale in the format `YYYY-MM-DD`. - `Product` (str): The name of the product sold. - `Quantity` (int): The quantity of the product sold. - `Price` (float): The price per unit of the product. Your task is to perform the following: 1. **Data Loading and Cleaning**: Read the CSV file and handle any missing or malformed data. 2. **Monthly Sales Analysis**: Calculate the total sales amount for each month. 3. **Top Products Visualization**: Create a bar graph showing the top 5 products based on total sales amount. Function Specification Write a function `analyze_sales_data` that accepts the following parameters: - `file_path` (str): The file path to the sales CSV file. The function should return a dictionary with the monthly sales and display a bar graph of the top 5 products based on sales amount. Requirements: 1. **Input and Output**: - The input consists of `file_path` (string) to the CSV file. - The output is a dictionary with the keys as months formatted as `YYYY-MM` and values as total sales amount for that month. The function should also display a bar graph of the top 5 products. 2. **Constraints**: - Handle any missing data gracefully by filling or removing them. - Ensure data types are appropriately converted for calculations. - Use libraries like `pandas` for data manipulation and `matplotlib` or `seaborn` for visualization. 3. **Performance**: - Ensure the function is optimized for large datasets without excessive memory or computational overhead. ```python import pandas as pd import matplotlib.pyplot as plt def analyze_sales_data(file_path: str) -> dict: Analyze and visualize sales data from the CSV file. Parameters: - file_path: str - Path to the sales data CSV file. Returns: A dictionary with keys as months (formatted YYYY-MM) and values as total sales amount for that month. Displays a bar graph of the top 5 products based on sales amount. try: # Load data df = pd.read_csv(file_path) # Clean data df[\'Date\'] = pd.to_datetime(df[\'Date\'], errors=\'coerce\') df = df.dropna(subset=[\'Date\', \'Product\', \'Quantity\', \'Price\']) df[\'Quantity\'] = pd.to_numeric(df[\'Quantity\'], errors=\'coerce\') df[\'Price\'] = pd.to_numeric(df[\'Price\'], errors=\'coerce\') df = df.dropna(subset=[\'Quantity\', \'Price\']) # Calculate total sales amount df[\'SalesAmount\'] = df[\'Quantity\'] * df[\'Price\'] # Monthly sales df[\'Month\'] = df[\'Date\'].dt.strftime(\'%Y-%m\') monthly_sales = df.groupby(\'Month\')[\'SalesAmount\'].sum().to_dict() # Top products product_sales = df.groupby(\'Product\')[\'SalesAmount\'].sum().sort_values(ascending=False) top_products = product_sales.head(5) # Plot top products top_products.plot(kind=\'bar\', title=\'Top 5 Products by Sales Amount\', ylabel=\'Sales Amount\') plt.show() return monthly_sales except Exception as e: print(f\\"An error occurred: {e}\\") return {} # Example of function usage if __name__ == \\"__main__\\": sales_data = analyze_sales_data(\\"path/to/sales_data.csv\\") print(sales_data) ``` Make sure to test your function with different datasets to validate the results and ensure the visualization appears as expected.","solution":"import pandas as pd import matplotlib.pyplot as plt def analyze_sales_data(file_path: str) -> dict: Analyze and visualize sales data from the CSV file. Parameters: - file_path: str - Path to the sales data CSV file. Returns: A dictionary with keys as months (formatted YYYY-MM) and values as total sales amount for that month. Displays a bar graph of the top 5 products based on sales amount. try: # Load data df = pd.read_csv(file_path) # Clean data df[\'Date\'] = pd.to_datetime(df[\'Date\'], errors=\'coerce\') df = df.dropna(subset=[\'Date\', \'Product\', \'Quantity\', \'Price\']) df[\'Quantity\'] = pd.to_numeric(df[\'Quantity\'], errors=\'coerce\') df[\'Price\'] = pd.to_numeric(df[\'Price\'], errors=\'coerce\') df = df.dropna(subset=[\'Quantity\', \'Price\']) # Calculate total sales amount df[\'SalesAmount\'] = df[\'Quantity\'] * df[\'Price\'] # Monthly sales df[\'Month\'] = df[\'Date\'].dt.strftime(\'%Y-%m\') monthly_sales = df.groupby(\'Month\')[\'SalesAmount\'].sum().to_dict() # Top products product_sales = df.groupby(\'Product\')[\'SalesAmount\'].sum().sort_values(ascending=False) top_products = product_sales.head(5) # Plot top products top_products.plot(kind=\'bar\', title=\'Top 5 Products by Sales Amount\', ylabel=\'Sales Amount\') plt.show() return monthly_sales except Exception as e: print(f\\"An error occurred: {e}\\") return {}"},{"question":"# Coding Question: Matrix Rotation and Daylight Cycles You are required to implement a function that simulates the rotation of a square matrix representing a cityscape over one full daylight cycle. The matrix elements can be `U` for buildings, `D` for gardens, or `P` for parks. The matrix should rotate 90 degrees clockwise for each \\"hour\\" in the cycle which lasts a total of 24 hours. Requirements: - **Function Signature**: `def simulate_daylight(matrix: List[List[str]]) -> List[List[str]]:` - **Input**: A square matrix (list of lists) where each element is `U`, `D`, or `P`. - **Output**: A transformed matrix after a full daylight cycle. Constraints: - The matrix will always be a square matrix (2x2, 3x3, ..., nxn). - Rotation should be done 90 degrees clockwise for each hour. - No element outside of `U`, `D`, or `P` will be present in the matrix. Performance: - The function should simulate the matrix rotations efficiently. Optimized solutions will consider avoiding redundant rotations. Examples: ```python matrix = [ [\'U\', \'D\'], [\'P\', \'U\'] ] assert simulate_daylight(matrix) == [ [\'D\', \'P\'], [\'U\', \'U\'] ] matrix = [ [\'U\', \'D\', \'P\'], [\'P\', \'U\', \'D\'], [\'D\', \'P\', \'U\'] ] assert simulate_daylight(matrix) == [ [\'U\', \'P\', \'D\'], [\'D\', \'U\', \'P\'], [\'P\', \'D\', \'U\'] ] matrix = [ [\'U\', \'U\', \'D\', \'P\'], [\'P\', \'D\', \'U\', \'P\'], [\'D\', \'P\', \'D\', \'U\'], [\'U\', \'P\', \'U\', \'D\'] ] assert simulate_daylight(matrix) == [ [\'U\', \'U\', \'D\', \'P\'], [\'P\', \'D\', \'U\', \'P\'], [\'D\', \'P\', \'D\', \'U\'], [\'U\', \'P\', \'U\', \'D\'] ] ```","solution":"def rotate_90_clockwise(matrix): Rotates the given n x n matrix 90 degrees clockwise. n = len(matrix) new_matrix = [[\'\'] * n for _ in range(n)] for i in range(n): for j in range(n): new_matrix[j][n - 1 - i] = matrix[i][j] return new_matrix def simulate_daylight(matrix): Simulates the rotation of the square matrix over one full daylight cycle (24 hours). for _ in range(24): matrix = rotate_90_clockwise(matrix) return matrix"},{"question":"# Problem Statement You are tasked with developing a system for managing a library\'s book inventory. To enhance the library\'s recommendation feature, you need to implement a function that analyzes the library\'s book collection and finds the n most costly books. # Requirements Write a function `find_top_n_costliest_books` that takes a list of book dictionaries and an integer n, and returns a list of the n books with the highest prices. # Function Signature ```python def find_top_n_costliest_books(books: list[dict], n: int) -> list[dict]: pass ``` # Input * `books` (list of dicts): A list where each element is a dictionary representing a book, with keys `title` (string) and `price` (positive float or integer). * `n` (int): A non-negative integer representing the number of top priced books to find. # Output * A list of dictionaries representing the n books with the highest prices. The books in the result should be sorted by price in descending order. If two books have the same price, they should appear in the order they were originally listed in the input. # Constraints * If n is zero, the function should return an empty list. * If n is greater than the number of books available, the function should return all books, sorted by price. * If there are no books in the list, the function should return an empty list. * The function should handle edge cases gracefully, including an empty list of books. # Examples ```python books = [ {\'title\': \'Book A\', \'price\': 30.0}, {\'title\': \'Book B\', \'price\': 50.0}, {\'title\': \'Book C\', \'price\': 40.0}, {\'title\': \'Book D\', \'price\': 10.0} ] n = 2 print(find_top_n_costliest_books(books, n)) # Output: [{\'title\': \'Book B\', \'price\': 50.0}, {\'title\': \'Book C\', \'price\': 40.0}] books = [ {\'title\': \'Book A\', \'price\': 30.0}, {\'title\': \'Book B\', \'price\': 50.0}, {\'title\': \'Book C\', \'price\': 40.0}, {\'title\': \'Book D\', \'price\': 10.0} ] n = 0 print(find_top_n_costliest_books(books, n)) # Output: [] books = [ {\'title\': \'Book A\', \'price\': 20.0}, {\'title\': \'Book B\', \'price\': 20.0}, {\'title\': \'Book C\', \'price\': 10.0}, ] n = 5 print(find_top_n_costliest_books(books, n)) # Output: [{\'title\': \'Book A\', \'price\': 20.0}, {\'title\': \'Book B\', \'price\': 20.0}, {\'title\': \'Book C\', \'price\': 10.0}] ``` # Explanation In the first example, the function returns the top 2 books with the highest prices, sorted in descending order of prices. The second example demonstrates the function returning an empty list when n is zero. The third example shows all books being returned sorted by price when n is more than the number of available books. Focus on handling the input gracefully and ensuring that the books are returned in the correct order based on their prices. Good luck with your implementation!","solution":"def find_top_n_costliest_books(books, n): Finds the n most costly books from the list of books. Parameters: books (list): A list of dictionaries where each dictionary represents a book with \'title\' and \'price\'. n (int): The number of top priced books to find. Returns: list: A list of the n books with the highest prices, sorted by price in descending order. if not books or n <= 0: return [] # Sort the books by price in descending order sorted_books = sorted(books, key=lambda x: x[\'price\'], reverse=True) # Return the top n books return sorted_books[:n]"},{"question":"# Sum of Non-Adjacent Elements Scenario: You are developing a feature for a budgeting application where users can query the maximum sum of non-adjacent transactions in their financial history. Given an array of integers representing user transactions, your job is to determine the maximum sum of non-adjacent elements in this array. Task: Implement the `max_sum_non_adjacent` function that computes the maximum sum of non-adjacent elements in the given list of integers. You should consider both positive and negative numbers and ensure the sum is maximized by including or excluding elements appropriately. Function Signature: ```python def max_sum_non_adjacent(nums: List[int]) -> int: ``` Input: * `nums`: a list of integers representing the user\'s transaction amounts. Output: * Return an integer representing the maximum sum of non-adjacent elements from the given list. Constraints: * The list can be empty or can contain up to (10^5) elements. * List elements can range from (-10^4) to (10^4). Example: ```python assert max_sum_non_adjacent([3, 2, 5, 10, 7]) == 15 assert max_sum_non_adjacent([-2, 1, 3, -4, 5]) == 8 assert max_sum_non_adjacent([3, 2, 7, 10]) == 13 assert max_sum_non_adjacent([]) == 0 assert max_sum_non_adjacent([-3, -2, -5, -10, -7]) == 0 assert max_sum_non_adjacent([2, 1, 4, 9, 0]) == 11 ``` You can use these examples to test your implementation.","solution":"from typing import List def max_sum_non_adjacent(nums: List[int]) -> int: Returns the maximum sum of non-adjacent elements from the given list of integers. if not nums: return 0 if len(nums) == 1: return max(0, nums[0]) include = 0 exclude = 0 for num in nums: new_exclude = max(include, exclude) include = exclude + num exclude = new_exclude return max(include, exclude)"},{"question":"# Find Duplicate Characters Write a function that identifies all duplicate characters in a given string. The function should return a dictionary where the keys are the duplicate characters, and the values are the counts of their occurrences. Your Task 1. **Character Counting**: Implement a function to count the occurrences of each character in the input string. 2. **Extract Duplicates**: Create a dictionary that only includes characters that appear more than once. Requirements - Implement the function `find_duplicates(s: str) -> dict` which will count and extract duplicate characters from the input string. Input - A string `s` consisting of printable characters. Output - A dictionary where keys are the characters that appear more than once in the input string, and values are their counts. Constraints - The input string length will be ≤ 10^5. Example ```python >>> find_duplicates(\\"programming\\") {\'r\': 2, \'g\': 2, \'m\': 2} >>> find_duplicates(\\"example\\") {} ``` **Note:** Consider optimizing your solution to handle large inputs efficiently.","solution":"def find_duplicates(s): Returns a dictionary of duplicate characters and their counts in the input string. char_count = {} duplicates = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char, count in char_count.items(): if count > 1: duplicates[char] = count return duplicates"},{"question":"Coding Assessment Question: Binary Tree Right Side View # Problem Statement You are tasked with finding the right side view of a binary tree. The right side view of a binary tree is the set of nodes visible when the tree is viewed from the right side. # Requirements 1. **Function Signature**: Implement a function `rightSideView(root: TreeNode) -> List[int]` in Python. 2. **Input**: * A binary tree represented by its root node (`root`), which could be None (empty tree). 3. **Output**: * A list of integer values representing the nodes visible from the right side. # Steps to Implement 1. **Binary Tree Node Definition**: * Use a class `TreeNode` to define a node in the binary tree. Each node contains a value, a left child, and a right child. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` 2. **Right Side View Calculation**: * Traverse the tree level by level (use a breadth-first search approach). * Add the last node at each level to the output list as it will be the node visible from the right side. * Handle edge cases such as an empty tree. # Example ```python def rightSideView(root: TreeNode) -> List[int]: if not root: return [] from collections import deque queue = deque([root]) right_side = [] while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() # The last node in this level if i == level_length - 1: right_side.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return right_side # Example Usage root = TreeNode(1, TreeNode(2, None, TreeNode(5)), TreeNode(3, None, TreeNode(4))) print(rightSideView(root)) # Output: [1, 3, 4] ``` # Performance Requirements: * The algorithm should run in linear time relative to the number of nodes in the tree (O(N)). * Use additional linear space for the queue and the output list (O(N)). # Constraints: - The number of nodes in the binary tree will be in the range [0, 100]. - The values of the nodes are unique and will be in the range [-1000, 1000].","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def rightSideView(root: Optional[TreeNode]) -> List[int]: if not root: return [] queue = deque([root]) right_side = [] while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() # The last node in this level if i == level_length - 1: right_side.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return right_side"},{"question":"# Context You\'ve been studying various sorting algorithms and understand the complexities involved in sorting large datasets. Now, you come across an efficient algorithm called Merge Sort, which is particularly useful for large lists of data because of its O(n log n) time complexity. # Problem Implement the Merge Sort algorithm to sort a list of integers. Further, make sure the implementation can handle sorting the list in both ascending and descending order. # Task 1. Implement the function `merge_sort(arr: list, ascending: bool=True) -> list` which sorts a list of integers using the Merge Sort algorithm. - **Input**: A list `arr` of integers (|arr| ≤ (10^6)), and a boolean `ascending`. If `ascending` is `True`, sort the list in ascending order; otherwise, sort in descending order. - **Output**: Returns a new list that is sorted based on the value of `ascending`. # Requirements 1. **Function**: `merge_sort` - **Input**: A list `arr` of integers and a boolean `ascending`. - **Output**: Returns the sorted list. - **Constraints**: - Handle sorting of both small and large datasets efficiently. - Preserve the order of equal elements (stable sort). # Examples ```python assert merge_sort([4, 2, 5, 3, 1, 6], ascending=True) == [1, 2, 3, 4, 5, 6] assert merge_sort([4, 2, 5, 3, 1, 6], ascending=False) == [6, 5, 4, 3, 2, 1] assert merge_sort([], ascending=True) == [] assert merge_sort([1], ascending=True) == [1] assert merge_sort([2, 1, 3], ascending=False) == [3, 2, 1] assert merge_sort([5, 5, 5, 5, 5], ascending=True) == [5, 5, 5, 5, 5] ``` # Implementation You can implement the Merge Sort algorithm recursively by dividing the input list into two halves, sorting each half, and then merging them back together in the desired order.","solution":"def merge_sort(arr, ascending=True): if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid], ascending) right = merge_sort(arr[mid:], ascending) return merge(left, right, ascending) def merge(left, right, ascending): result = [] i = j = 0 while i < len(left) and j < len(right): if (ascending and left[i] <= right[j]) or (not ascending and left[i] >= right[j]): result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result"},{"question":"# Problem Statement: Calendar Event Conflict Checker You are given the task of creating a function that checks for conflicts in a list of calendar events. Each event is represented by a start time and an end time, both in the form of strings. The goal is to determine if any events overlap. Function Signature ```python def has_event_conflicts(events: List[Tuple[str, str]]) -> bool: Checks if there are any conflicts among the given calendar events. :param events: A list of tuples, where each tuple contains two strings representing the start and end times of an event. :return: True if there is any conflict, False otherwise. pass ``` Input * A list of tuple pairs, where each tuple consists of the start time and end time of an event. * The time format will be a 24-hour format string (`\\"HH:MM\\"`), representing the time from 00:00 to 23:59. The start time will always be less than the end time within each tuple. Output * The function returns `True` if there is any overlap between the given events, otherwise `False`. Constraints 1. The list contains at least one event. 2. Each event is represented by a valid time range within the day.` [\\"HH:MM\\"]` to `\\"HH:MM\\"` Example ```python events = [(\\"09:00\\", \\"10:00\\"), (\\"09:30\\", \\"11:00\\"), (\\"11:30\\", \\"12:00\\")] conflict = has_event_conflicts(events) # Output: True events = [(\\"09:00\\", \\"10:00\\"), (\\"10:30\\", \\"11:00\\"), (\\"11:30\\", \\"12:00\\")] conflict = has_event_conflicts(events) # Output: False ``` Requirements 1. Implement the function `has_event_conflicts` to check conflicting intervals. 2. Use appropriate data structures to handle and compare time intervals. 3. Ensure to handle edge cases, such as events that start immediately after the previous event ends. # Notes - The function should efficiently handle typical numbers of calendar events (up to 1000 events). - Assume that all time inputs are valid and properly formatted.","solution":"def has_event_conflicts(events): Checks if there are any conflicts among the given calendar events. :param events: A list of tuples, where each tuple contains two strings representing the start and end times of an event. :return: True if there is any conflict, False otherwise. # First, we need to sort events by their start time events.sort(key=lambda x: x[0]) # Iterate through the events to check for any overlap for i in range(len(events) - 1): current_end_time = events[i][1] next_start_time = events[i+1][0] # If the current event\'s end time is later than the next event\'s start time, we have a conflict if current_end_time > next_start_time: return True return False"},{"question":"# Coding Challenge **Context**: You are working on a networking application that involves processing and analyzing ranges of IP addresses. As part of the feature set, you need a function to determine if a given IP address falls within a specified range of IP addresses. **Objective**: Write a function `ip_in_range(ip: str, start_ip: str, end_ip: str)` that takes three strings representing an IP address, a start IP address, and an end IP address, and returns a boolean indicating whether the given IP address falls within the specified range, inclusive. Function Signature ```python def ip_in_range(ip: str, start_ip: str, end_ip: str) -> bool: ... ``` # Input * `ip` (str): A string representing an IPv4 address (e.g., \\"192.168.1.1\\"). * `start_ip` (str): A string representing the start of the IP range (e.g., \\"192.168.0.0\\"). * `end_ip` (str): A string representing the end of the IP range (e.g., \\"192.168.255.255\\"). # Output * A boolean value indicating whether the given IP address falls within the specified range, inclusive. # Constraints * The IP addresses will be valid IPv4 addresses. * The IP range will be continuous and valid. * You may assume that start_ip will be less than or equal to end_ip. # Examples ```python assert ip_in_range(\\"192.168.1.1\\", \\"192.168.0.0\\", \\"192.168.255.255\\") == True assert ip_in_range(\\"192.168.0.0\\", \\"192.168.0.0\\", \\"192.168.255.255\\") == True assert ip_in_range(\\"192.168.255.255\\", \\"192.168.0.0\\", \\"192.168.255.255\\") == True assert ip_in_range(\\"10.0.0.1\\", \\"192.168.0.0\\", \\"192.168.255.255\\") == False assert ip_in_range(\\"192.168.1.1\\", \\"192.168.1.0\\", \\"192.168.1.10\\") == True ``` # Guidelines 1. Convert the IP addresses to integers for easier comparison. 2. Handle input validation, ensuring IPs are valid. 3. The function should not use any external libraries for IP processing. 4. Aim for a solution that is easy to understand and efficient. **Note**: IPv4 addresses are in the format `x.x.x.x`, where `x` is an integer between 0 and 255. To compare IP addresses, convert them to a numerical format that facilitates easy comparison.","solution":"def ip_in_range(ip: str, start_ip: str, end_ip: str) -> bool: def ip_to_int(ip_str): parts = ip_str.split(\'.\') return (int(parts[0]) << 24) + (int(parts[1]) << 16) + (int(parts[2]) << 8) + int(parts[3]) ip_int = ip_to_int(ip) start_ip_int = ip_to_int(start_ip) end_ip_int = ip_to_int(end_ip) return start_ip_int <= ip_int <= end_ip_int"},{"question":"# Coding Assessment Question: You have been assigned to create a function that aids in generating a secure password meeting specific criteria. The function will be utilized by a company to ensure employees create strong passwords. **Function Details**: * Implement a function `generate_password(length: int, include_special_chars: bool) -> str` that generates a random password. **Input**: * `length` (int): The desired length of the password. Must be an integer greater than or equal to 6. * `include_special_chars` (bool): A boolean indicating whether the password should include special characters (!, @, #, , %, ^, &, *). **Output**: * A single string representing the generated password. **Constraints**: * The password must contain at least one uppercase letter, one lowercase letter, and one digit. * If `include_special_chars` is `True`, the password must also contain at least one special character. * The function should raise an exception if it is impossible to create a password that meets these requirements with the given length. **Performance Requirements**: * The function should efficiently generate a random password regardless of the length constraint. **Scenario**: The company enforces strict password policies to enhance cybersecurity. Employees often need to quickly generate strong passwords during registration or password updates. This function ensures compliance with the company\'s security standards. **Example Use Cases**: * `generate_password(8, True)` could return `\\"A1b!cD2f\\"`. * `generate_password(10, False)` could return `\\"aB3cD4eF5G\\"`. **Edge Cases**: * Inputs like `generate_password(5, True)` should raise an exception: `\\"Password length must be at least 6\\"`. * Inputs like `generate_password(4, False)` should raise an exception: `\\"Password length must be at least 6\\"`. * Inputs like `generate_password(6, True)` should generate a valid password meeting all the criteria specified, such as `\\"aB3!cD\\"`.","solution":"import random import string def generate_password(length: int, include_special_chars: bool) -> str: if length < 6: raise ValueError(\\"Password length must be at least 6\\") # character sets uppercase = string.ascii_uppercase lowercase = string.ascii_lowercase digits = string.digits specials = \\"!@#%^&*\\" # character pools based on whether special characters are included if include_special_chars: all_chars = uppercase + lowercase + digits + specials else: all_chars = uppercase + lowercase + digits # ensuring the minimum requirement characters password_chars = [ random.choice(uppercase), random.choice(lowercase), random.choice(digits) ] if include_special_chars: password_chars.append(random.choice(specials)) # filling the rest of the characters remaining_length = length - len(password_chars) password_chars.extend(random.choices(all_chars, k=remaining_length)) # shuffling to avoid predictable sequences random.shuffle(password_chars) return \'\'.join(password_chars)"},{"question":"# Longest Increasing Subsequence Problem Statement You are given a list of integers representing a sequence. Your task is to implement an algorithm to find the length of the longest increasing subsequence (LIS) in the given sequence. A subsequence is derived by deleting some or no elements of the sequence, without changing the order of the remaining elements. Function Signature ```python def length_of_lis(sequence: list) -> int: Compute the length of the longest increasing subsequence (LIS) in the given sequence. Args: sequence (list): A list of integers representing the sequence. Returns: int: The length of the longest increasing subsequence. Example: sequence = [10, 22, 9, 33, 21, 50, 41, 60] length_of_lis(sequence) -> 5 # The LIS is [10, 22, 33, 50, 60] ``` Constraints * The sequence may contain up to 1000 integers. * Each integer in the sequence ranges from -10^4 to 10^4. Implementation Details * You may implement this in O(n^2) time using dynamic programming, or in O(n log n) time using methods like binary search with a dynamic list. * Ensure your solution efficiently handles sequences of varying lengths and values, including edge cases such as an empty sequence or a sequence with all identical elements. Example Input ```python sequence = [10, 22, 9, 33, 21, 50, 41, 60] ``` Expected Output ```python 5 # The LIS is [10, 22, 33, 50, 60] ``` Follow the same approach to implement your solution, taking into account the time complexity and edge cases to ensure the efficiency and robustness of the algorithm.","solution":"def length_of_lis(sequence: list) -> int: Compute the length of the longest increasing subsequence (LIS) in the given sequence. Args: sequence (list): A list of integers representing the sequence. Returns: int: The length of the longest increasing subsequence. if not sequence: return 0 n = len(sequence) lis = [1] * n for i in range(1, n): for j in range(i): if sequence[i] > sequence[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis)"},{"question":"# Coding Question Context A logistics company wants to optimize its delivery routes to minimize the distance traveled by its fleet of delivery trucks. To achieve this, they need to find the shortest path between multiple delivery points. Problem Given a list of delivery points represented as `(x, y)` coordinates, implement an algorithm to compute the shortest path that visits all delivery points exactly once and returns to the starting point. This problem is similar to the Traveling Salesman Problem (TSP). Requirements 1. Implement a function to find the shortest round-trip path. 2. Your function should handle a moderate number of delivery points efficiently. 3. The function should return the order of delivery points as a list of indices representing their positions in the input list. Function Signature ```python def shortest_delivery_path(points: list[tuple[int, int]]) -> list[int]: Finds the shortest round-trip path that visits all delivery points exactly once and returns to the start. :param points: List of tuples representing delivery points as (x, y) coordinates. :return: List of indices representing the order of delivery points to minimize travel distance. Example: >>> shortest_delivery_path([(0, 0), (1, 1), (2, 2)]) [0, 1, 2, 0] >>> shortest_delivery_path([(0, 0), (0, 2), (2, 2), (2, 0)]) [0, 1, 2, 3, 0] ``` Constraints 1. The input list can contain up to 10 delivery points. 2. Consider using heuristic or approximation algorithms to achieve reasonable performance. Input/Output Format * **Input**: A list of tuples representing `(x, y)` coordinates of delivery points. * **Output**: A list of indices depicting the order in which the delivery points should be visited for the shortest path. The first and last index should be the starting point. Examples 1. `shortest_delivery_path([(0, 0), (1, 1), (2, 2)])` should return `[0, 1, 2, 0]`. 2. `shortest_delivery_path([(0, 0), (0, 2), (2, 2), (2, 0)])` should return `[0, 1, 2, 3, 0]`. Notes 1. The solution should aim for optimal path length but may use approximation methods due to computational complexity. 2. Consider edge cases such as identical points and small input sizes. 3. Write tests to ensure the correctness and efficiency of your implementation.","solution":"import itertools import math def shortest_delivery_path(points): n = len(points) # To calculate the distance between two points def distance(p1, p2): return math.sqrt((points[p1][0] - points[p2][0]) ** 2 + (points[p1][1] - points[p2][1]) ** 2) # Create a distance matrix dist_matrix = [[distance(i, j) for j in range(n)] for i in range(n)] # Function to compute the total distance of a given path def path_distance(path): return sum(dist_matrix[path[i]][path[i + 1]] for i in range(len(path) - 1)) # Generate all possible permutations of points all_permutations = itertools.permutations(range(1, n)) # Initialize minimum path and its distance min_path = None min_distance = float(\'inf\') # Check each permutation # Always start from the first point (0) and return to it at the end for perm in all_permutations: current_path = [0] + list(perm) + [0] current_distance = path_distance(current_path) if current_distance < min_distance: min_distance = current_distance min_path = current_path return min_path"},{"question":"# Question: Implement a Stack-based Expression Evaluator You are required to implement a function, `evaluate_expression`, which evaluates a given arithmetic expression represented as a string using a stack-based approach. The expression will contain non-negative integers, and the operators `+`, `-`, `*`, and `/`. The function should handle operator precedence and parentheses properly. Function Signature ```python def evaluate_expression(expression: str) -> int: pass ``` Input * `expression` (str): A string representing the arithmetic expression to be evaluated. The expression contains non-negative integers, parentheses, and the operators `+`, `-`, `*`, and `/`. Output * The function should return the evaluated result of the expression as an integer. Constraints * The expression is valid and all the operators are binary. * Parentheses in the expression are properly closed and nested. * Division results should be integer divisions (`/` operator). * Assume no spaces in the input string. * The input expression string length does not exceed 1000 characters. Example Scenarios ```python evaluate_expression(\\"3+2*2\\") # Output: 7 evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") # Output: 23 evaluate_expression(\\"4/(2+2)\\") # Output: 1 ``` **Note**: The function should implement a stack-based algorithm to handle operator precedence and parentheses correctly. The use of Python\'s `eval` function is not allowed.","solution":"def evaluate_expression(expression: str) -> int: def operate(op, second, first): if op == \'+\': return first + second elif op == \'-\': return first - second elif op == \'*\': return first * second elif op == \'/\': return int(first / second) # use int() to truncate towards zero precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2} operators = [] operands = [] i = 0 while i < len(expression): char = expression[i] if char.isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 operands.append(num) i -= 1 elif char == \'(\': operators.append(char) elif char == \')\': while operators and operators[-1] != \'(\': operands.append(operate(operators.pop(), operands.pop(), operands.pop())) operators.pop() # pop the \'(\' elif char in precedence: while (operators and operators[-1] in precedence and precedence[operators[-1]] >= precedence[char]): operands.append(operate(operators.pop(), operands.pop(), operands.pop())) operators.append(char) i += 1 while operators: operands.append(operate(operators.pop(), operands.pop(), operands.pop())) return operands[0]"},{"question":"# Question: Implement a Financial Portfolio Optimization Algorithm Your task is to implement a function that optimizes a financial portfolio by determining the ideal allocation of assets to maximize returns while controlling risk using the Markowitz Portfolio Theory. Function Specifications 1. **Function Signature** ```python def optimize_portfolio( expected_returns: list, covariance_matrix: list, risk_tolerance: float ) -> tuple: ``` 2. **Input** - `expected_returns`: List of expected returns for each asset in the portfolio. - `covariance_matrix`: A 2D list representing the covariance matrix of asset returns. - `risk_tolerance`: A float value indicating the risk tolerance of the investor (higher values indicate higher risk tolerance). 3. **Output** - A tuple containing: - The optimal asset allocation to maximize returns based on the given risk tolerance. This should be a list of floats representing the proportion of the total investment allocated to each asset. - The expected portfolio return as a float. - The portfolio risk (standard deviation) as a float. Constraints - The `expected_returns` list and the size of the square `covariance_matrix` will have the same length. - `expected_returns` and `covariance_matrix` will contain at least 2 assets. - The values in `covariance_matrix` will be symmetric and non-negative. - All elements in `expected_returns` will be non-negative. - The sum of the optimal asset allocation proportions should equal 1 (considering floating-point precision). Performance Requirements - The implementation should efficiently handle up to 100 assets. Edge Cases to Consider - Singular covariance matrices should be handled where possible. - Ensure that the portfolio allocation does not result in negative proportions or allocations exceeding 100% per asset. Example ```python # Given expected returns for 3 assets expected_returns = [0.1, 0.2, 0.15] # Given 3x3 covariance matrix covariance_matrix = [ [0.005, -0.010, 0.004], [-0.010, 0.040, -0.002], [0.004, -0.002, 0.023] ] # Given risk tolerance risk_tolerance = 5.0 # Call the function optimal_allocation, portfolio_return, portfolio_risk = optimize_portfolio(expected_returns, covariance_matrix, risk_tolerance) # Expected output print(optimal_allocation) # Example: [0.2, 0.5, 0.3] <- Assuming proportions of assets print(portfolio_return) # Example: 0.165 <- Expected portfolio return as float print(portfolio_risk) # Example: 0.015 <- Portfolio risk as float (standard deviation) ```","solution":"import numpy as np from scipy.optimize import minimize def optimize_portfolio(expected_returns, covariance_matrix, risk_tolerance): Optimizes a financial portfolio using Markowitz Portfolio Theory. Parameters: expected_returns (list): List of expected returns for each asset. covariance_matrix (list): 2D list representing the covariance matrix of asset returns. risk_tolerance (float): Risk tolerance of the investor. Returns: tuple: (optimal_allocation, portfolio_return, portfolio_risk) n_assets = len(expected_returns) expected_returns = np.array(expected_returns) covariance_matrix = np.array(covariance_matrix) # Function to minimize (negative of the Sharpe Ratio) def objective(weights): portfolio_return = np.dot(weights, expected_returns) portfolio_variance = np.dot(weights.T, np.dot(covariance_matrix, weights)) portfolio_risk = np.sqrt(portfolio_variance) return -1 * (portfolio_return - risk_tolerance * portfolio_risk) # Constraints constraints = ({\'type\': \'eq\', \'fun\': lambda weights: np.sum(weights) - 1}) bounds = tuple((0, 1) for asset in range(n_assets)) initial_guess = n_assets * [1. / n_assets,] result = minimize(objective, initial_guess, method=\'SLSQP\', bounds=bounds, constraints=constraints) optimal_allocation = result.x portfolio_return = np.dot(optimal_allocation, expected_returns) portfolio_variance = np.dot(optimal_allocation.T, np.dot(covariance_matrix, optimal_allocation)) portfolio_risk = np.sqrt(portfolio_variance) return optimal_allocation.tolist(), portfolio_return, portfolio_risk"},{"question":"# Question **Breadth-First Search (BFS) for Graph Traversal** As a software engineer working on graph algorithms, you need to implement the Breadth-First Search (BFS) algorithm for traversing or searching through graph data structures. BFS explores all the vertices of a graph with equal distance from the source vertex before moving on to vertices further away. Requirements 1. Implement the `breadth_first_search` function. 2. The function should take the following parameters: - `graph` (Dict[int, List[int]]): An adjacency list representing the graph, where keys are vertices and values are lists of adjacent vertices. - `start` (int): The starting vertex for BFS traversal. 3. The function should return a list of vertices in the order they were visited using BFS. **Constraints:** - The `graph` is connected and undirected. - The `start` vertex exists in the graph. **Example:** ```python graph = { 0: [1, 2], 1: [0, 3, 4], 2: [0, 5, 6], 3: [1], 4: [1], 5: [2], 6: [2] } start = 0 result = breadth_first_search(graph, start) # Expected output order is [0, 1, 2, 3, 4, 5, 6] print(result) ``` **Expected Output:** ```plaintext [0, 1, 2, 3, 4, 5, 6] ``` **Additional Tests:** ```python def test_case_1(): graph = {1: [2, 3], 2: [1, 4], 3: [1], 4: [2]} start = 1 assert breadth_first_search(graph, start) == [1, 2, 3, 4] def test_case_2(): graph = {0: [1], 1: [0, 2, 3], 2: [1], 3: [1]} start = 2 assert breadth_first_search(graph, start) == [2, 1, 0, 3] def test_case_3(): graph = {0: [1, 2, 3], 1: [0], 2: [0], 3: [0, 4], 4: [3, 5], 5: [4]} start = 3 assert breadth_first_search(graph, start) == [3, 0, 4, 1, 2, 5] ``` Write your implementation to fulfill these requirements and pass the provided test cases.","solution":"from collections import deque from typing import List, Dict def breadth_first_search(graph: Dict[int, List[int]], start: int) -> List[int]: Perform a breadth-first search on the graph starting from the specified vertex. Parameters: graph (Dict[int, List[int]]): An adjacency list representing the graph. start (int): The starting vertex for BFS traversal. Returns: List[int]: A list of vertices in the order they were visited. visited = set() queue = deque([start]) visited_order = [] while queue: vertex = queue.popleft() if vertex not in visited: visited.add(vertex) visited_order.append(vertex) for neighbor in graph[vertex]: if neighbor not in visited: queue.append(neighbor) return visited_order"},{"question":"# Problem Statement A popular data processing tool processes log files by extracting specific fields of interest. Your task is to parse a series of log entries and extract the unique IP addresses and the associated counts of occurrences in the log. The log entries follow a specific format, and you need to implement a function that processes these logs accordingly. Each log entry is structured as follows: `\\"timestamp - log_level - IP_address - message\\"`, where: - `timestamp` is a string representing the date and time in the format `\\"YYYY-MM-DD HH:MM:SS\\"`. - `log_level` is a string indicating the severity of the log entry (`\\"INFO\\"`, `\\"WARN\\"`, `\\"ERROR\\"`, etc.). - `IP_address` is a string in the standard IPv4 format (e.g., `\\"192.168.1.1\\"`). - `message` is a string containing additional information related to the log entry. # Function to Implement Implement the function `parse_log_entries(log_entries: List[str]) -> Dict[str, int]`. This function should return a dictionary where the keys are unique IP addresses extracted from the log entries, and the values are the counts of occurrences of each IP address. # Input * `log_entries` (List[str]): A list of strings representing the log entries. # Output * (Dict[str, int]): A dictionary mapping each unique IP address to its occurrence count. # Constraints 1. Each log entry is guaranteed to match the specified format. 2. There can be up to 100,000 log entries. # Example ```python assert parse_log_entries([ \\"2023-03-15 10:23:45 - INFO - 192.168.1.1 - User login\\", \\"2023-03-15 10:24:01 - ERROR - 192.168.1.1 - Failed login attempt\\", \\"2023-03-15 10:25:20 - WARN - 192.168.1.2 - Disk space low\\", \\"2023-03-15 10:25:22 - INFO - 192.168.1.1 - User logout\\" ]) == {\\"192.168.1.1\\": 3, \\"192.168.1.2\\": 1} ``` # Additional Notes - Consider using regular expressions to extract the IP addresses efficiently. - Ensure the function runs efficiently even with the maximum number of log entries. - Think about edge cases where some IP addresses might appear many times or only once. # Scenario Imagine you are tasked with developing a feature for a system monitoring application that keeps track of unique IP addresses accessing the system and the frequency of these accesses. This feature will help in identifying potential issues such as abuse or unauthorized access based on the frequency of IP occurrences in the log files.","solution":"import re from typing import List, Dict def parse_log_entries(log_entries: List[str]) -> Dict[str, int]: # Define a regex pattern to extract the IP address ip_pattern = re.compile(r\'d+.d+.d+.d+\') ip_count = {} for entry in log_entries: match = ip_pattern.search(entry) if match: ip_address = match.group() if ip_address in ip_count: ip_count[ip_address] += 1 else: ip_count[ip_address] = 1 return ip_count"},{"question":"# Question You are given a list of integers, and your task is to calculate the product of all elements in the list except for the current element without using the division operation. This problem can be efficiently solved using prefix and suffix products. Implement a function named `product_except_self` that computes the desired product for each element in the list. # Requirements * **Function Signature**: `def product_except_self(nums: list[int]) -> list[int]:` * **Parameters**: - `nums`: A list of integers. * **Returns**: A list of integers where each element is the product of all the elements in the input list except for the element at that position. # Constraints 1. The list `nums` will contain at least two integers. 2. Each element in the list is an integer, and the values can be positive, negative, or zero. 3. The function should have a time complexity of O(n) and should use constant space (excluding the output list). # Examples ```python nums = [1, 2, 3, 4] print(product_except_self(nums)) # Output: [24, 12, 8, 6] nums = [-1, 1, 0, -3, 3] print(product_except_self(nums)) # Output: [0, 0, 9, 0, 0] nums = [2, 3, 4, 5] print(product_except_self(nums)) # Output: [60, 40, 30, 24] ``` # Implementation Guidelines * Utilize two auxiliary arrays (or lists): `left_products` and `right_products`. * `left_products[i]` should contain the product of all the elements to the left of index `i`. * `right_products[i]` should contain the product of all the elements to the right of index `i`. * Construct the result array by multiplying the corresponding elements of `left_products` and `right_products`.","solution":"def product_except_self(nums: list[int]) -> list[int]: n = len(nums) # Initialize the arrays to store the product of all the elements to the left and right left_products = [1] * n right_products = [1] * n # Fill left_products from left to right for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Fill right_products from right to left for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Now multiply left_products and right_products to get the result result = [1] * n for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"# Problem Statement You are required to implement a function that finds the k-th largest element in an unsorted array. Your function should take in an array and an integer k, then return the k-th largest element. # Function Signature ```python def find_kth_largest(nums: List[int], k: int) -> int: Find the k-th largest element in an unsorted array. Args: nums (List[int]): The list of integers. k (int): The k-th position to find the largest element (1-based index). Returns: int: The k-th largest element. ``` # Input - **nums (List[int])**: An unsorted list of integers. (1 ≤ len(nums) ≤ 10^4, -10^4 ≤ nums[i] ≤ 10^4) - **k (int)**: The position (1-based index) of the largest element to find in the list. (1 ≤ k ≤ len(nums)) # Output - **int**: The k-th largest element in the list. # Requirements - Implement an efficient solution that runs in O(n log n) time complexity or better. - Do not use any built-in Python sorting functions directly (like `sort` or `sorted`). # Example ```python # Example 1 nums = [3, 2, 1, 5, 6, 4] k = 2 result = find_kth_largest(nums, k) print(result) # Output: 5 # Example 2 nums = [3, 2, 3, 1, 2, 4, 5, 5, 6] k = 4 result = find_kth_largest(nums, k) print(result) # Output: 4 ``` # Constraints - Ensure your function can handle both small and large arrays efficiently. - Consider edge cases such as arrays with duplicate elements. # Evaluation Criteria - Correctness: The function must consistently return the correct k-th largest element. - Performance: The function should handle large input sizes within an acceptable time frame. - Code Quality: The implementation should be clean, well-documented, and follow best practices.","solution":"import heapq from typing import List def find_kth_largest(nums: List[int], k: int) -> int: Find the k-th largest element in an unsorted array. Args: nums (List[int]): The list of integers. k (int): The k-th position to find the largest element (1-based index). Returns: int: The k-th largest element. # Use a min-heap to keep track of the top k largest elements min_heap = nums[:k] heapq.heapify(min_heap) for i in range(k, len(nums)): if nums[i] > min_heap[0]: heapq.heappushpop(min_heap, nums[i]) return min_heap[0]"},{"question":"Implement a Custom List with Advanced Functionality You are required to implement a custom list class `AdvancedList` which extends the functionalities of a basic list to include some advanced operations. **Class Definition**: `AdvancedList` **Methods**: 1. `append_item(item: int) -> None`: Append an integer item to the list. 2. `filter_even() -> list`: Return a list containing only the even numbers from the original list. 3. `reverse_list() -> list`: Return a new list that contains the elements of the original list in reverse order. 4. `sum_elements() -> int`: Compute the sum of all the elements in the list. 5. `find_first_occurrence(target: int) -> int`: Return the index of the first occurrence of the target integer in the list. If the target is not found, return -1. **Input**: - For `append_item`, the input is a single integer. - For `find_first_occurrence`, the input is a single integer target to search for. - All other methods operate on the list maintained within the `AdvancedList` class. **Output**: - `append_item` doesn’t return any value. - `filter_even` returns a list of integers. - `reverse_list` returns a list of integers. - `sum_elements` returns a single integer. - `find_first_occurrence` returns a single integer representing the index or -1 if the target is not found. **Constraints**: - The list will only contain integers. - Operations should handle typical edge cases, such as empty lists or lists with one element. # Example ```python adv_list = AdvancedList() adv_list.append_item(1) adv_list.append_item(2) adv_list.append_item(3) adv_list.append_item(4) adv_list.append_item(5) print(adv_list.filter_even()) # Output: [2, 4] print(adv_list.reverse_list()) # Output: [5, 4, 3, 2, 1] print(adv_list.sum_elements()) # Output: 15 print(adv_list.find_first_occurrence(3)) # Output: 2 print(adv_list.find_first_occurrence(6)) # Output: -1 ``` # Performance Requirements: - Ensure your methods are optimized for performance, especially for large lists up to `10^6` elements. Implement the `AdvancedList` class with careful consideration of efficiency and correctness.","solution":"class AdvancedList: def __init__(self): self.list = [] def append_item(self, item: int) -> None: self.list.append(item) def filter_even(self) -> list: return [item for item in self.list if item % 2 == 0] def reverse_list(self) -> list: return self.list[::-1] def sum_elements(self) -> int: return sum(self.list) def find_first_occurrence(self, target: int) -> int: try: return self.list.index(target) except ValueError: return -1"},{"question":"# Coding Assessment Question: Maximum Depth Calculation of Nested List **Background**: You are working on estimating the complexity of nested data structures by determining their maximum depth. The maximum depth of a list is defined as the deepest level of nesting within the list. **Objective**: Implement a function `max_depth` that calculates the maximum depth of a given nested list. Your function should correctly handle nested lists and return the correct depth value. **Function Signature**: ```python def max_depth(nested_list: list) -> int: pass ``` **Inputs and Outputs**: * **Input**: A single list `nested_list` containing integers or other nested lists of integers. * **Output**: An integer representing the maximum depth of the given list. **Constraints**: * An empty list `[]` is at depth 0. * The input list can contain up to (10^5) elements in total, including nested elements. * The depth level of nesting will not exceed 100 for practical purposes. **Example**: 1. **Input**: `[1, [2, 3], [4, [5]]]` **Output**: `3` 2. **Input**: `[1, [2, [3, [4]]]]` **Output**: `4` 3. **Input**: `[1, 2, 3]` **Output**: `1` 4. **Input**: `[[4], [6, [9, [18, 15, [44]]]]]` **Output**: `5` **Hint**: Use a recursive approach to determine the maximum depth, but ensure to handle significant depth levels efficiently. **Edge Cases to Consider**: * Empty list `[]` * Lists containing deeply nested structures, e.g., `[1, [2, [3, [4, [5]]]]]` * Very deeply nested single elements, e.g., `[[[[[[1]]]]]]` **Starter Template**: ```python def max_depth_helper(nested_list: list) -> int: if not nested_list: return 0 depth = 1 for ele in nested_list: if isinstance(ele, list): depth = max(depth, max_depth_helper(ele) + 1) return depth def max_depth(nested_list: list) -> int: return max_depth_helper(nested_list) ```","solution":"def max_depth(nested_list: list) -> int: def max_depth_helper(nested_list): if not nested_list: return 0 depth = 1 for ele in nested_list: if isinstance(ele, list): depth = max(depth, max_depth_helper(ele) + 1) return depth return max_depth_helper(nested_list)"},{"question":"# Coding Challenge: Circular Queue Implementation Objective Write a class to implement a Circular Queue (also known as a circular buffer) that operates in a fixed size and supports basic operations such as enqueue, dequeue, and checking if it is full or empty. Detailed Requirements - **Class Name**: ```python class CircularQueue: ``` - **Method Signatures**: ```python def __init__(self, k: int): # Initializes the queue with a fixed size k. def enqueue(self, value: int) -> bool: # Adds an element to the end of the queue. def dequeue(self) -> bool: # Removes an element from the front of the queue. def front(self) -> int: # Returns the front element of the queue. def rear(self) -> int: # Returns the last element of the queue. def is_empty(self) -> bool: # Checks if the queue is empty. def is_full(self) -> bool: # Checks if the queue is full. ``` - **Input**: - `k`: An integer representing the maximum size of the circular queue. - `value`: An integer representing the value to be added to the queue in `enqueue` method. - **Output**: - Methods that do not return a specific value should return a boolean indicating success (`True`) or failure (`False`). - **Constraints**: - The size of the queue (k) should be a positive integer. - **Performance**: - All operations should be performed in constant time O(1). Example: ```python >>> cq = CircularQueue(3) >>> cq.enqueue(1) True >>> cq.enqueue(2) True >>> cq.enqueue(3) True >>> cq.enqueue(4) False # Queue is full >>> cq.rear() 3 >>> cq.is_full() True >>> cq.dequeue() True >>> cq.enqueue(4) True >>> cq.rear() 4 >>> cq.front() 2 >>> cq.is_empty() False >>> cq.dequeue() True >>> cq.dequeue() True >>> cq.dequeue() True >>> cq.dequeue() False # Queue is empty >>> cq.is_empty() True ``` Guidelines: 1. Implement a circular buffer using a list to manage the elements. 2. Implement proper edge cases handling, such as when checking `front` or `rear` on an empty queue. 3. Use modulo operation to wrap around the queue when the end is reached. 4. Ensure the methods `front` and `rear` raise appropriate exceptions if the queue is empty. 5. Include doctests for validation and demonstrate the usage and functionality of all methods.","solution":"class CircularQueue: def __init__(self, k: int): self.size = k self.queue = [None] * k self.head = -1 self.tail = -1 def enqueue(self, value: int) -> bool: if self.is_full(): return False if self.is_empty(): self.head = 0 self.tail = (self.tail + 1) % self.size self.queue[self.tail] = value return True def dequeue(self) -> bool: if self.is_empty(): return False if self.head == self.tail: self.head = -1 self.tail = -1 else: self.head = (self.head + 1) % self.size return True def front(self) -> int: if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.head] def rear(self) -> int: if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.tail] def is_empty(self) -> bool: return self.head == -1 def is_full(self) -> bool: return (self.tail + 1) % self.size == self.head"},{"question":"# Question: Sum of Multiples You have been tasked with implementing a function that calculates the sum of all multiples of `3` or `5` below a given positive integer. # Function Signature ```python def sum_of_multiples(limit: int) -> int: pass ``` # Input * `limit`: A positive integer representing the upper bound (exclusive). # Output * Return an integer that is the sum of all multiples of `3` or `5` below the given `limit`. # Constraints * `1 <= limit <= 10^5` # Example Example 1 ```python assert sum_of_multiples(10) == 23 # The multiples of 3 or 5 below 10 are 3, 5, 6, and 9. Their sum is 23. ``` Example 2 ```python assert sum_of_multiples(20) == 78 # The multiples of 3 or 5 below 20 are 3, 5, 6, 9, 10, 12, 15, and 18. Their sum is 78. ``` # Additional Information You need to ensure efficient computation to handle the upper bounds of the input limits efficiently. Try to avoid using iterative summation for each integer.","solution":"def sum_of_multiples(limit: int) -> int: Returns the sum of all multiples of 3 or 5 below the given limit. Parameters: limit (int): the upper bound (exclusive) to find multiples Returns: int: Sum of all multiples of 3 or 5 below the limit # Initialize sum total_sum = 0 # Iterate through each number below the limit for i in range(limit): # Check if the number is a multiple of 3 or 5 if i % 3 == 0 or i % 5 == 0: total_sum += i return total_sum"},{"question":"Infix to Postfix Conversion You are provided with an implementation of an algorithm that converts infix expressions to postfix expressions using a stack. Your task is to extend this implementation by writing a function that can handle multiple expressions at once and returns a list of their corresponding postfix expressions. # Objective Write a function `convert_expressions(expressions: List[str]) -> List[str]` that: - Takes a list of infix expressions and converts each one to its postfix form. - Returns a list of postfix expressions. # Input/Output - **Input**: - `expressions` (List[str]): A list of infix expressions as strings. - **Output**: - `postfix_expressions` (List[str]): A list of postfix expressions as strings. # Constraints: - The infix expressions may include the operators `+`, `-`, `*`, `/`, and parentheses `()`. - Each expression is a valid infix expression. - You may assume that operators and operands are separated by spaces. # Performance Requirement: - The function should efficiently handle multiple expressions with typical lengths (up to a few hundred characters each). # Example Here is an example of how your function might be used: ```python expressions = [\\"A + B\\", \\"A + B * C\\", \\"( A + B ) * C\\"] postfix_expressions = convert_expressions(expressions) print(postfix_expressions) # Output: [\\"A B +\\", \\"A B C * +\\", \\"A B + C *\\"] ``` # Context Infix expressions are common in mathematical notation but are not directly suitable for execution by computers, especially in calculators or stack-based machines, where postfix (reverse Polish) notation is preferred. Whereas infix notation is the common arithmetic and logical formula notation, where an operator is placed between the operands, postfix notation places the operator after the operands. # Note You do not need to handle input or output via user input, just implement the function `convert_expressions`.","solution":"def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 def infix_to_postfix(expression): stack = [] postfix = [] tokens = expression.split() for token in tokens: if token.isalnum(): postfix.append(token) elif token == \'(\': stack.append(token) elif token == \')\': while stack and stack[-1] != \'(\': postfix.append(stack.pop()) stack.pop() else: while stack and precedence(stack[-1]) >= precedence(token): postfix.append(stack.pop()) stack.append(token) while stack: postfix.append(stack.pop()) return \' \'.join(postfix) def convert_expressions(expressions): Converts a list of infix expressions to postfix expressions. :param expressions: List of infix expressions as strings :return: List of postfix expressions as strings return [infix_to_postfix(expression) for expression in expressions]"},{"question":"# Question: Implement a File System Path Simplifier You are tasked with writing a function that simplifies a given Unix-style absolute file path. Task Write a function `simplify_path` that simplifies the given Unix-style path. The Unix file system uses the following conventions: - A `/` represents the root directory. - Each directory is separated by a `/`. - A `.` means the current directory. - A `..` means to move up one directory. - Multiple consecutive slashes should be treated as a single slash. The simplified path should use the minimum number of directories. Expected Input and Output Your function should have the following signature: ```python def simplify_path(path: str) -> str: pass ``` **Input**: - A string `path`, representing the Unix-style absolute file path. **Output**: - A simplified string that represents the absolute file path. Constraints * `1 <= len(path) <= 3000` * `path` starts with `\'/\'` and consists of lowercase English letters, digits, `\'.\'`, `\'/\'`, and `\'..\'`. # Example ```python path = \\"/home/\\" # Expected Output: \\"/home\\" path = \\"/../\\" # Expected Output: \\"/\\" path = \\"/home//foo/\\" # Expected Output: \\"/home/foo\\" path = \\"/a/./b/../../c/\\" # Expected Output: \\"/c\\" ``` Context In Unix systems, file paths are often complex, and redundant system navigation can slow down operations. Simplifying paths allows for more efficient access and organization of files and directories. Implementing a path simplifier requires a sound understanding of stack-based algorithms and string manipulation.","solution":"def simplify_path(path): Simplifies the given Unix-style absolute file path. :param path: A string representing the Unix-style absolute file path. :return: A simplified string that represents the absolute file path. # Initialize a stack to use for processing the path components stack = [] # Split the path by \'/\' to analyze each part parts = path.split(\\"/\\") for part in parts: # If the part is empty or a \'.\', we don\'t need to do anything if part == \\"\\" or part == \\".\\": continue # If the part is \'..\', we need to go up one directory (pop from stack) elif part == \\"..\\": if stack: stack.pop() # Otherwise, it\'s a valid directory name and we add it to the stack else: stack.append(part) # Join the stack by \'/\' to form the simplified path # Also ensure to add a leading \'/\' to make it an absolute path simplified_path = \\"/\\" + \\"/\\".join(stack) return simplified_path"},{"question":"# Median of Two Sorted Arrays You are required to implement a function that finds the median of two sorted arrays merged into one sorted array. Function Signature ```python def find_median_sorted_arrays(nums1: [int], nums2: [int]) -> float: pass ``` Input: - `nums1`: A list of integers sorted in non-decreasing order. - `nums2`: Another list of integers sorted in non-decreasing order. Output: - Returns a float, the median of the two merged arrays. Constraints: - Both lists can be of different lengths ((0 leq text{len}(nums1), text{len}(nums2) leq 10^3)). - The combined length of the arrays is at least 1 and at most 2000. Requirements: - The function should be efficient with a time complexity better than (O(n+m)), ideally (O(log(min(n,m)))). - The lists may contain duplicate values. Example: ```python nums1 = [1, 3] nums2 = [2] result = find_median_sorted_arrays(nums1, nums2) print(result) # Expected output: 2 nums1 = [1, 2] nums2 = [3, 4] result = find_median_sorted_arrays(nums1, nums2) print(result) # Expected output: 2.5 ``` Scenario: Consider you are given two sorted arrays of different lengths representing times in seconds of runners finishing a race from two different groups. You need to find the median time when you consider all runners together. For example, if group one has times [1, 3] and group two has time [2], the combined times in ascending order are [1, 2, 3], and the median is 2. Your task is to implement this using an efficient algorithm.","solution":"def find_median_sorted_arrays(nums1: [int], nums2: [int]) -> float: if len(nums1) > len(nums2): nums1, nums2 = nums2, nums1 x, y = len(nums1), len(nums2) low, high = 0, x while low <= high: partitionX = (low + high) // 2 partitionY = (x + y + 1) // 2 - partitionX maxX = float(\'-inf\') if partitionX == 0 else nums1[partitionX - 1] minX = float(\'inf\') if partitionX == x else nums1[partitionX] maxY = float(\'-inf\') if partitionY == 0 else nums2[partitionY - 1] minY = float(\'inf\') if partitionY == y else nums2[partitionY] if maxX <= minY and maxY <= minX: if (x + y) % 2 == 0: return (max(maxX, maxY) + min(minX, minY)) / 2 else: return max(maxX, maxY) elif maxX > minY: high = partitionX - 1 else: low = partitionX + 1 raise ValueError(\\"Input arrays are not valid\\")"},{"question":"# Problem Statement: Matrix Chain Multiplication with Dynamic Programming Context You are given a sequence of matrices, and you need to compute the minimum number of scalar multiplications needed to multiply the sequence of matrices. The dimensions of the matrices are specified in an array. Your task is to implement the matrix chain multiplication problem using dynamic programming. Objective Implement a function named `matrix_chain_order` that computes the minimum cost of multiplying the given sequence of matrices. Function Specifications * **Function Name**: `matrix_chain_order` * **Input**: - `dimensions`: List of `n+1` integers where the `i-th` matrix has dimensions `dimensions[i-1] x dimensions[i]`. * **Output**: - Returns an integer representing the minimum number of scalar multiplications needed. - Optionally, you may return the optimal parenthesization of the product sequence for verification purposes. Constraints * `dimensions` list should have at least two elements. * All elements in `dimensions` should be positive integers. * Inputs may need validation for types and bounds. Requirements * Implement the function with O(n^3) time complexity. * Ensure proper validation for inputs to prevent runtime errors. Example ```python >>> matrix_chain_order([10, 20, 30, 40, 30]) 30000 >>> matrix_chain_order([10, 20, 30]) 6000 >>> matrix_chain_order([40, 20, 30, 10, 30]) 26000 ``` Implementation Guidelines 1. Initialize a 2D list `m` of size `n x n` to store the minimum multiplication costs. 2. Populate the diagonal of `m` with zeros. 3. Use a nested loop to calculate the minimum cost for each possible chain length. 4. Return the minimum cost from `m[1][n-1]`. ```python def matrix_chain_order(dimensions: list) -> int: n = len(dimensions) - 1 m = [[0]*n for _ in range(n)] for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + dimensions[i] * dimensions[k + 1] * dimensions[j + 1] if q < m[i][j]: m[i][j] = q return m[0][n - 1] ``` Testing - Ensure test cases cover basic, edge, and complex scenarios, including non-integer inputs and progressively increasing dimensions. This question challenges the candidate to implement a dynamic programming solution for an optimal matrix multiplication problem, similar in complexity and scope to the sample problem while ensuring unique and novel problem context.","solution":"def matrix_chain_order(dimensions): Computes the minimum number of scalar multiplications needed to multiply a chain of matrices. Args: dimensions: List of dimensions where the i-th matrix has dimensions dimensions[i-1] x dimensions[i]. Returns: The minimum number of scalar multiplications needed to multiply the matrix chain. if not isinstance(dimensions, list) or len(dimensions) < 2 or any(type(d) != int or d <= 0 for d in dimensions): raise ValueError(\\"Invalid dimensions input. It must be a list of at least two positive integers.\\") n = len(dimensions) - 1 # Number of matrices m = [[0 for _ in range(n)] for _ in range(n)] for length in range(2, n + 1): # Length of the matrix chain segment for i in range(n - length + 1): j = i + length - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + dimensions[i] * dimensions[k + 1] * dimensions[j + 1] if q < m[i][j]: m[i][j] = q return m[0][n - 1]"},{"question":"# Question: Matrix Operation and Optimization Context You are assigned to develop a utility that handles operations on a 2D matrix. Your focus is to add a method to efficiently transpose the matrix and compute the sum along its main diagonal (trace). This task will test your understanding of matrix manipulations, computational efficiency, and optimal solution implementations. Requirements 1. **Matrix Class (`MatrixOperations`)**: - Should store an integer matrix as a list of lists. - Must support addition of new rows. 2. **Method to Transpose the Matrix**: - Implement a method `transpose` within the `MatrixOperations` class to return the transposed matrix. 3. **Method to Compute Trace**: - Implement a method `compute_trace` to compute the sum of elements along the main diagonal. Implementation Details - **Input Format**: - Rows of integers are input one by one and added to the matrix. - **Output Format**: - Transposed matrix as a list of lists. - Trace of the matrix as an integer. - **Constraints**: - Each row is guaranteed to be of the same length. - The matrix size should be up to 500x500 for efficient operations. Function Signature ```python from typing import List class MatrixOperations: def __init__(self): self.matrix = [] def add_row(self, row: List[int]) -> None: pass # Add the given row to the matrix def transpose(self) -> List[List[int]]: pass # Return the transposed matrix def compute_trace(self) -> int: pass # Return the sum of the elements along the main diagonal # Example Usage: # matrix = MatrixOperations() # matrix.add_row([1, 2, 3]) # matrix.add_row([4, 5, 6]) # matrix.add_row([7, 8, 9]) # transposed = matrix.transpose() # trace = matrix.compute_trace() ``` Performance Requirements - Ensure the transpose and trace computation methods are efficient and perform well under the given constraints. Aim for operations to complete in reasonable time even for the upper limits of matrix size.","solution":"from typing import List class MatrixOperations: def __init__(self): self.matrix = [] def add_row(self, row: List[int]) -> None: Add a given row to the matrix. self.matrix.append(row) def transpose(self) -> List[List[int]]: Return the transposed matrix. # Transposing the matrix return [list(row) for row in zip(*self.matrix)] def compute_trace(self) -> int: Return the sum of the elements along the main diagonal. # The trace is the sum of diagonal elements return sum(self.matrix[i][i] for i in range(min(len(self.matrix), len(self.matrix[0]))))"},{"question":"# Assignment: Implement a Dijkstra\'s Algorithm for Shortest Path You are tasked with implementing Dijkstra\'s algorithm, which finds the shortest path from a starting node to all other nodes in a graph with non-negative edge weights. # Task: 1. Improve the function `initialize_graph` to ensure that the graph is properly initialized with all necessary nodes and edges, including validation checks for non-negative edge weights. 2. Write the function `dijkstra` to compute the shortest path from a given start node to all other nodes in the graph. * Input: * `graph` - A dictionary where keys are node identifiers and values are dictionaries of neighboring node identifiers and their respective edge weights. * `start_node` - The identifier of the node from which shortest paths will be computed. * Output: * A dictionary where keys are node identifiers and values are the shortest distance from the start node to that node. # Constraints: * Assume that the graph is represented using an adjacency list. * Edge weights are non-negative integers. * Handle any possible edge cases such as disconnected nodes and ensure that the algorithm does not enter an infinite loop. # Example: ```python graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'C\': 2, \'D\': 5}, \'C\': {\'D\': 1}, \'D\': {} } start_node = \'A\' shortest_paths = dijkstra(graph, start_node) assert shortest_paths == {\'A\': 0, \'B\': 1, \'C\': 3, \'D\': 4} ``` # Notes: * You may use a priority queue (such as a heap) to optimize the efficiency of the algorithm. * Ensure that your implementation correctly handles graphs where some nodes are not reachable from the start node. * Your solution should be robust, efficient, and follow the principles of Dijkstra\'s Algorithm.","solution":"import heapq def initialize_graph(edges): graph = {} for edge in edges: u, v, weight = edge if weight < 0: raise ValueError(\\"Edge weights must be non-negative\\") if u not in graph: graph[u] = {} if v not in graph: graph[v] = {} graph[u][v] = weight return graph def dijkstra(graph, start_node): if start_node not in graph: raise ValueError(\\"Start node not in graph\\") distances = {node: float(\'infinity\') for node in graph} distances[start_node] = 0 priority_queue = [(0, start_node)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Largest Smallest Substring Write a function `largest_smallest_substring` that identifies the smallest substring within a given string such that replacing each character in this substring with a different character (distinct from the characters in the substring) results in the largest possible new substring. Input * A string `s` containing only lowercase alphabetic characters. Output * A tuple containing: 1. The original smallest substring 2. The largest possible new substring after replacing every character in the original substring. Constraints - ( 1 leq text{len}(s) leq 100 ) # Example ```python >>> largest_smallest_substring(\\"abcdeedcba\\") (\'abcde\', \'vwxyz\') >>> largest_smallest_substring(\\"aaaa\\") (\'a\', \'z\') >>> largest_smallest_substring(\\"axbycz\\") (\'a\', \'z\') >>> largest_smallest_substring(\\"zyx\\") (\'z\', \'a\') ``` # Notes 1. You should replace each distinct character in the smallest substring with the next distinct available character in the alphabet, in such a way that maximizes the lexicographical order of the result. 2. You only need to consider the basic English alphabet from \'a\' to \'z\'. 3. The replacement should produce a new substring which is lexicographically largest compared to other possible replacements.","solution":"def largest_smallest_substring(s): Identifies the smallest substring within a given string such that replacing each character in this substring with a different character (distinct from the characters in the substring) results in the largest possible new substring. Parameters: s (str): The input string containing only lowercase alphabetic characters. Returns: tuple: A tuple containing the original smallest substring and the largest possible new substring after replacing every character in the original substring. from string import ascii_lowercase as alphabet min_substr = min(s) largest_substr = alphabet[-1] return min_substr, largest_substr"},{"question":"# Question: String Transformation with Mapping Design and implement a function that transforms a given string according to a specified character mapping. You will be provided with: - A dictionary `char_map` where each key-value pair represents the mapping (e.g., `{\'a\': \'b\', \'b\': \'c\'}`). - A string `input_str` that needs to be transformed based on the character mapping. Your task is to write a function `transform_string` that takes two arguments: 1. `char_map`: A dictionary specifying the character transformations. 2. `input_str`: The string to be transformed. The function should return a new string with the characters transformed according to the provided mapping. If a character in the input string is not present in the mapping, it should remain unchanged in the output string. Implementation ```python def transform_string(char_map: dict, input_str: str) -> str: Transforms the input string based on the character mapping Parameters: char_map (dict): A dictionary specifying character transformations input_str (str): The string to be transformed Returns: str: The transformed string Example: char_map = { \'a\': \'b\', \'b\': \'c\', \'c\': \'a\' } >>> transform_string(char_map, \'abc\') \'bca\' >>> transform_string(char_map, \'hello\') \'hello\' return \'\'.join(char_map.get(char, char) for char in input_str) ``` Input and Output Format: - **Input**: A dictionary representing the character mapping and a string to be transformed. - **Output**: A string that is transformed according to the input character mapping. Constraints: - The input string can contain any printable ASCII characters. - The character mappings are case-sensitive and do not include whitespace characters. Example: **Input**: ```python char_map = { \'a\': \'b\', \'b\': \'c\', \'c\': \'a\' } print(transform_string(char_map, \'abac\')) ``` **Output**: ```python \'bcba\' ``` **Note**: This approach ensures all specified character transformations are applied correctly, while any unmapped characters remain unchanged.","solution":"def transform_string(char_map: dict, input_str: str) -> str: Transforms the input string based on the character mapping Parameters: char_map (dict): A dictionary specifying character transformations input_str (str): The string to be transformed Returns: str: The transformed string Example: char_map = { \'a\': \'b\', \'b\': \'c\', \'c\': \'a\' } >>> transform_string(char_map, \'abc\') \'bca\' >>> transform_string(char_map, \'hello\') \'hello\' return \'\'.join(char_map.get(char, char) for char in input_str)"},{"question":"# Description: You are provided with two functions, `find_peak_iterative` and `find_peak_recursive`, which find a peak element in a list using iterative and recursive approaches, respectively. A peak element is an element that is greater than or equal to its neighbors. Your task is to implement a hybrid method that combines elements of both approaches as follows: # Task: Implement a function `find_peak_hybrid(nums: list[int | float]) -> int | float` that: 1. If the list size is less than or equal to a predefined threshold, use an iterative approach. 2. If the list size is greater than the threshold, use the recursive approach. # Constraints: - The list `nums` contains only integers and floats. - The function must handle an empty list by raising a `ValueError` with a message indicating the list is empty. # Inputs: - `nums` (List of integers/floats): The list of numbers to find a peak element from. # Output: - Returns a peak element in the list. # Example Usage: ```python >>> find_peak_hybrid([1, 3, 2]) 3 >>> find_peak_hybrid([5, 10, 20, 15]) 20 >>> find_peak_hybrid([10, 20, 15, 2, 23, 90, 67]) 20 >>> find_peak_hybrid([8, 9, 10, 2, 5, 6]) 10 >>> find_peak_hybrid([0, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10]) 100 >>> find_peak_hybrid([]) Traceback (most recent call last): ... ValueError: find_peak_hybrid() arg is an empty sequence ``` # Note: - Ensure your implementation is efficient and handles edge cases correctly. - Set the threshold for switching between iterative and recursive methods as 10 for this implementation. ```python def find_peak_hybrid(nums: list[int | float]) -> int | float: # Define the threshold THRESHOLD = 10 if len(nums) == 0: raise ValueError(\\"find_peak_hybrid() arg is an empty sequence\\") def find_peak_recursive(nums, left, right): mid = (left + right) >> 1 if (mid == 0 or nums[mid - 1] <= nums[mid]) and (mid == len(nums) - 1 or nums[mid + 1] <= nums[mid]): return nums[mid] elif mid > 0 and nums[mid - 1] > nums[mid]: return find_peak_recursive(nums, left, mid - 1) else: return find_peak_recursive(nums, mid + 1, right) def find_peak_iterative(nums): for i in range(len(nums)): if (i == 0 or nums[i - 1] <= nums[i]) and (i == len(nums) - 1 or nums[i + 1] <= nums[i]): return nums[i] # Use iterative for small data if len(nums) <= THRESHOLD: return find_peak_iterative(nums) else: return find_peak_recursive(nums, 0, len(nums) - 1) ```","solution":"def find_peak_hybrid(nums: list[int | float]) -> int | float: # Define the threshold THRESHOLD = 10 if len(nums) == 0: raise ValueError(\\"find_peak_hybrid() arg is an empty sequence\\") def find_peak_recursive(nums, left, right): mid = (left + right) // 2 if (mid == 0 or nums[mid - 1] <= nums[mid]) and (mid == len(nums) - 1 or nums[mid + 1] <= nums[mid]): return nums[mid] elif mid > 0 and nums[mid - 1] > nums[mid]: return find_peak_recursive(nums, left, mid - 1) else: return find_peak_recursive(nums, mid + 1, right) def find_peak_iterative(nums): for i in range(len(nums)): if (i == 0 or nums[i - 1] <= nums[i]) and (i == len(nums) - 1 or nums[i + 1] <= nums[i]): return nums[i] # Use iterative for small data if len(nums) <= THRESHOLD: return find_peak_iterative(nums) else: return find_peak_recursive(nums, 0, len(nums) - 1)"},{"question":"# Pascal’s Triangle Sum Calculation Context: You are working on a mathematical software application that needs to handle and compute various properties of Pascal’s Triangle. One of the key tasks is to calculate the sum of all elements in a specified row of Pascal’s Triangle. Each element of Pascal\'s Triangle is the sum of the two directly above it, starting with the number 1 at the top. Understanding Pascal’s Triangle and efficiently computing its properties is essential for the feature set of the application. Task: You need to write a function that computes the sum of all elements in a given row of Pascal\'s Triangle. Input: - `row_index`: An integer specifying the zero-based index of the row in Pascal’s Triangle. Output: - An integer representing the sum of all elements in the specified row. Constraints: - The function should handle input values up to `row_index = 100000`. Function Signature: ```python def pascal_triangle_row_sum(row_index: int) -> int: ``` Requirements: - Implement the function according to the provided function signature. - Use mathematical properties of Pascal’s Triangle to optimize the computation, rather than constructing the triangle row by row. Example: ```python >>> pascal_triangle_row_sum(0) 1 >>> pascal_triangle_row_sum(1) 2 >>> pascal_triangle_row_sum(2) 4 >>> pascal_triangle_row_sum(3) 8 >>> pascal_triangle_row_sum(10) 1024 ``` Explanation: - The sum of the elements in the ith row of Pascal\'s Triangle is equal to `2^i`. - In the first example, the sum for row 0 (1) is `2^0 = 1`. - In the second example, the sum for row 1 (1, 1) is `2^1 = 2`. - In the third example, the sum for row 2 (1, 2, 1) is `2^2 = 4`. - In the fourth example, the sum for row 3 (1, 3, 3, 1) is `2^3 = 8`. - In the fifth example, the sum for row 10 is `2^10 = 1024`. This problem requires understanding of the properties of Pascal’s Triangle and applying mathematical knowledge to efficiently compute the result.","solution":"def pascal_triangle_row_sum(row_index: int) -> int: Returns the sum of all elements in the specified row of Pascal\'s Triangle. return 2 ** row_index"},{"question":"Context Binary Search is an efficient algorithm for finding an item from a sorted list of items. Given a sorted list and a target value, the algorithm repeatedly divides the search interval in half. If the value of the target is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise, narrow it to the upper half. The process continues until the target value is found or the interval is empty. Task Implement a function `binary_search` that searches for a target value in a sorted array of integers. The function should return the index of the target value if it is present in the array, otherwise, it should return -1. **Function Signature:** ```python def binary_search(arr: list[int], target: int) -> int: Searches for a target value in a sorted array using the binary search algorithm. Args: arr (list[int]): A sorted array of integers. target (int): The value to search for. Returns: int: The index of the target value if present, otherwise -1. Examples: >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) 4 >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 11) -1 >>> binary_search([], 5) -1 >>> binary_search([3, 5, 7, 9, 11, 13], 7) 2 >>> binary_search([3, 5, 7, 9, 11, 13], 6) -1 ``` **Constraints:** 1. The input array can contain up to (10^5) elements. 2. The elements in the array are integers within the range ([-10^6, 10^6]). 3. The input array is guaranteed to be sorted in non-decreasing order. **Performance Requirements:** - The time complexity should be (O(log n)). - The space complexity should be (O(1)).","solution":"def binary_search(arr, target): Searches for a target value in a sorted array using the binary search algorithm. Args: arr (list[int]): A sorted array of integers. target (int): The value to search for. Returns: int: The index of the target value if present, otherwise -1. left, right = 0, len(arr) - 1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Problem Statement You are given a list of integers representing prices of a stock on different days. Your objective is to implement a function to find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times), but you must sell the stock before you buy the next day. Function Signature ```python def max_profit(prices: list[int]) -> int: pass ``` Parameters - `prices`: A list of integers where `prices[i]` is the price of a given stock on the `i-th` day. The length of the list will not exceed 1000. Returns - An integer representing the maximum profit one can achieve from these transactions. Constraints - 1 <= len(prices) <= 1000 - 0 <= prices[i] <= 10000 Example ```python >>> max_profit([7, 1, 5, 3, 6, 4]) 7 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([7, 6, 4, 3, 1]) 0 ``` # Additional Context The problem revolves around the concept of finding the maximum profit using greedy algorithms. This can be achieved by continuously taking profit whenever there is a rise in the stock price from one day to the next. Your implementation should consider all such profitable opportunities without over-complicating the logic, ensuring efficient computation within the prescribed constraints.","solution":"def max_profit(prices: list[int]) -> int: Calculates the maximum profit that can be achieved by buying and selling stocks given the prices list. :param prices: List of integers representing stock prices on different days. :return: Maximum profit achievable. max_profit = 0 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: max_profit += prices[i] - prices[i - 1] return max_profit"},{"question":"# Coding Assessment Question **Context**: You are given a list of airline flight times. Each airline provides a start time and an end time for their available flights as tuples of integers representing hours in a 24-hour format (e.g., (13, 15) means the flight is available from 1 PM to 3 PM). You need to find the maximum number of flights that overlap at any given time. This task is often needed in airport management to determine peak times and allocate resources efficiently. **Function Specification**: **Function Name**: max_overlapping_flights **Parameters**: * `flights: list[tuple[int, int]]`: A list where each element is a tuple containing two integers representing the start and end times of a flight. **Return**: * `int`: The maximum number of flights that are overlapping at any given time. **Constraints**: * All times are in the 24-hour format and range from 0 to 23. * The start time will always be less than the end time within a tuple. * The list can contain up to 10^5 flights. **Example**: ```python # Example 1: print(max_overlapping_flights([(1, 3), (2, 5), (3, 6)])) # Output: 2 # Example 2: print(max_overlapping_flights([(0, 2), (1, 4), (5, 8), (6, 9)])) # Output: 2 # Example 3: print(max_overlapping_flights([(1, 3), (3, 5), (5, 7)])) # Output: 1 # Example 4: print(max_overlapping_flights([(2, 6), (4, 9), (8, 12)])) # Output: 2 # Example 5: print(max_overlapping_flights([(0, 1), (1, 2), (2, 3), (3, 4)])) # Output: 1 ``` # Instructions: 1. Implement the function `max_overlapping_flights` that takes in a list of flight times as tuples and returns the maximum number of overlapping flights at any given time. 2. Consider edge cases where no flights overlap or flights start and end at the same times. 3. Ensure the function runs efficiently for large datasets.","solution":"def max_overlapping_flights(flights): events = [] for start, end in flights: events.append((start, \'start\')) events.append((end, \'end\')) # Sort events, by time, with \'end\' events coming before \'start\' events.sort(key=lambda x: (x[0], x[1] == \'start\')) max_overlap = 0 current_overlap = 0 for event in events: if event[1] == \'start\': current_overlap += 1 max_overlap = max(max_overlap, current_overlap) else: current_overlap -= 1 return max_overlap"},{"question":"# Pairwise Product Maximization You are given a list of integers. The task is to find two distinct elements in the list such that their product is the maximum among all possible pairs of distinct elements and return this product. Write a function `maximize_pairwise_product(nums: list) -> int` that computes the maximum product of two distinct elements in the given list. Input - `nums` (list): A list of integers where each integer represents an element in the list. The list contains at least two elements. Output - Returns `int`: The maximum product of any two distinct elements. Constraints - `2 <= len(nums) <= 10^5` - `-10^9 <= nums[i] <= 10^9` Performance Requirements The solution should efficiently handle the upper limit constraints within a reasonable time frame. Examples 1. **Example 1** ```python nums = [1, 10, 3, 4, 7] print(maximize_pairwise_product(nums)) # Output: 70 ``` 2. **Example 2** ```python nums = [-10, -20, 5, 6, -3, 8] print(maximize_pairwise_product(nums)) # Output: 200 ``` 3. **Example 3** ```python nums = [5, 5, 5] print(maximize_pairwise_product(nums)) # Output: 25 ``` Constraints - Use efficient algorithms to ensure the solution can handle large inputs. - Be mindful of edge cases, such as lists with multiple identical largest values. - Validate input to ensure the function handles different scenarios gracefully.","solution":"def maximize_pairwise_product(nums): Returns the maximum product of any two distinct elements. if len(nums) < 2: raise ValueError(\\"The input list must contain at least two elements.\\") # Initialize the two largest and two smallest numbers max1 = max2 = float(\'-inf\') min1 = min2 = float(\'inf\') for num in nums: # Update the two largest numbers if num > max1: max2 = max1 max1 = num elif num > max2: max2 = num # Update the two smallest numbers if num < min1: min2 = min1 min1 = num elif num < min2: min2 = num # The maximum product of two distinct elements return max(max1 * max2, min1 * min2)"},{"question":"# Count Unique Permutations Given a string ( s ) consisting only of lowercase alphabets, determine the number of unique permutations of the characters in the string. The aim is to understand how permutations can be counted efficiently, especially when the string contains repeated characters. Function Signature ```python def count_unique_permutations(s: str) -> int: pass ``` Input * A string ( s ) ((1 leq |s| leq 10^5)), containing only lowercase English letters. Output * Returns an integer representing the number of unique permutations of the string\'s characters. Example ```python assert count_unique_permutations(\\"aab\\") == 3 assert count_unique_permutations(\\"abc\\") == 6 assert count_unique_permutations(\\"aa\\") == 1 assert count_unique_permutations(\\"abcd\\") == 24 ``` # Constraints * The solution should be able to handle the string length up to ( 10^5 ) efficiently. * The time complexity should be optimal and take into consideration the factorials involved, which could be handled via precomputed values. # Notes 1. Utilize combinatorial mathematics to calculate permutations efficiently. 2. Handle factorial calculations and modular inverses to prevent overflow, especially for large values. 3. Consider edge cases, such as strings with all identical characters or very large inputs near the upper length limit. 4. Performance analysis should ensure that the solution scales properly for the input constraints. By following these guidelines, you can produce robust, high-performing code suitable for the constraints given.","solution":"from collections import Counter from math import factorial def count_unique_permutations(s: str) -> int: Returns the number of unique permutations of the characters in the string s. # Get the frequency of each character in the string freq = Counter(s) # Calculate the factorial of the length of the string total_permutations = factorial(len(s)) # Divide by the factorial of the frequency of each character to account for duplicates for char_count in freq.values(): total_permutations //= factorial(char_count) return total_permutations"},{"question":"# Palindrome and Substring Finder Your task is to implement a function that finds the longest palindromic substring within a given string and also returns all the unique substrings of that palindromic substring. # Objective Write a function that takes a string as input and returns the longest palindromic substring and all its unique substrings. # Implementation Details 1. Implement the `longest_palindromic_substring` function to find the longest palindromic substring within the given string. 2. Identify all unique substrings within this longest palindromic substring. # Function Signature ```python def longest_palindromic_substring(s: str) -> tuple[str, set[str]]: ... ``` # Input - **s**: A string (1 ≤ len(s) ≤ 1000) composed of lowercase English letters. # Output - A tuple containing: - The longest palindromic substring. - A set of unique substrings of the longest palindromic substring. # Example Given the input string: ```plaintext \\"babad\\" ``` Expected Output: ```plaintext (\'bab\', {\'b\', \'a\', \'ab\', \'ba\', \'bab\'}) ``` or ```plaintext (\'aba\', {\'a\', \'b\', \'ab\', \'ba\', \'aba\'}) ``` # Constraints - The solution should efficiently handle strings with lengths up to 1000. - Ensure the solution works in a reasonable timeframe. # Notes - If there are multiple longest palindromic substrings with the same length, you can return any one of them. - The function should identify and return the longest palindromic substring and all its unique substrings correctly. Ensure all edge cases are handled, and the function performs efficiently on the upper limits of the input constraints.","solution":"def longest_palindromic_substring(s: str) -> tuple[str, set[str]]: def expand_from_center(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest_palindrome = \\"\\" for i in range(len(s)): substr1 = expand_from_center(i, i) substr2 = expand_from_center(i, i + 1) if len(substr1) > len(longest_palindrome): longest_palindrome = substr1 if len(substr2) > len(longest_palindrome): longest_palindrome = substr2 unique_substrings = set() for i in range(len(longest_palindrome)): for j in range(i + 1, len(longest_palindrome) + 1): unique_substrings.add(longest_palindrome[i:j]) return longest_palindrome, unique_substrings"},{"question":"# Fibonacci Number Calculation You are given an incomplete implementation of a function that calculates the n-th Fibonacci number using an iterative approach. Your task is to complete this function. Function Signature ```python def calculate_fibonacci(n: int) -> int: ``` Parameters * **n** (int): The position in the Fibonacci sequence (0-indexed). Returns * **int**: The n-th Fibonacci number. Constraints 1. The input integer `n` should be in the range [0, 30]. 2. The function should raise a `ValueError` with appropriate messages for inputs violating the above constraint. Example ```python >>> calculate_fibonacci(0) 0 >>> calculate_fibonacci(1) 1 >>> calculate_fibonacci(10) 55 >>> calculate_fibonacci(30) 832040 ``` Additional Notes * The Fibonacci sequence is defined as: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n > 1 * Ensure your function raises the exception `\\"Input out of range. Valid range: 0 to 30\\"` for inputs outside the specified range. Implement the `calculate_fibonacci` function with the provided specifications.","solution":"def calculate_fibonacci(n: int) -> int: if n < 0 or n > 30: raise ValueError(\\"Input out of range. Valid range: 0 to 30\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for i in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Scenario You are working on a simulation program that models a bank\'s customer service system. In this system, customers arrive at different times and need to be served in the order they arrive. Some customers have VIP status, which means they should be served before regular customers who arrived at the same time. # Task Implement a class `BankQueue` that simulates this customer service queue using Python\'s list operations. The queue should support operations to add a customer (either regular or VIP), serve the next customer, and check the next customer to be served. Ensure that VIP customers are always served before regular customers when possible, but otherwise, maintain the order of arrival. # Requirements 1. **add_customer(name, vip=False)**: Add a customer to the queue. The parameter `name` is a string representing the customer\'s name, and `vip` is a boolean indicating whether the customer has VIP status. 2. **serve_customer()**: Serve and remove the next customer from the queue (prioritize VIP customers first). Return the name of the served customer. 3. **next_customer()**: Return (but do not remove) the name of the next customer to be served. 4. **queue_size()**: Return the number of customers currently in the queue. # Constraints - Maintain an efficient and clear structure for the queue. - You can only use list operations (append, pop, insert, etc.) to implement the queue. - Ensure VIP customers are served with priority over regular customers. # Input and Output - **add_customer(name, vip=False)**: Two parameters `name` (string) and `vip` (boolean). - **serve_customer()**: No parameters, returns the name (string) of the served customer. - **next_customer()**: No parameters, returns the name (string) of the next customer to be served. - **queue_size()**: No parameters, returns an integer representing the number of customers in the queue. # Example ```python bq = BankQueue() bq.add_customer(\'Alice\') bq.add_customer(\'Bob\', True) bq.add_customer(\'Charlie\') print(bq.queue_size()) # Output: 3 print(bq.next_customer()) # Output: \'Bob\' print(bq.serve_customer()) # Output: \'Bob\' print(bq.queue_size()) # Output: 2 print(bq.next_customer()) # Output: \'Alice\' print(bq.serve_customer()) # Output: \'Alice\' print(bq.serve_customer()) # Output: \'Charlie\' ``` # Implementation Challenge Implement the `BankQueue` class ensuring each method adheres to the described priority and FIFO behavior efficiently in terms of time complexity.","solution":"class BankQueue: def __init__(self): self.queue = [] self.vip_queue = [] def add_customer(self, name, vip=False): if vip: self.vip_queue.append(name) else: self.queue.append(name) def serve_customer(self): if self.vip_queue: return self.vip_queue.pop(0) elif self.queue: return self.queue.pop(0) else: return None def next_customer(self): if self.vip_queue: return self.vip_queue[0] elif self.queue: return self.queue[0] else: return None def queue_size(self): return len(self.queue) + len(self.vip_queue)"},{"question":"You are required to develop a system to track and analyze the performance of multiple athletes over a series of competitions. The system needs to be capable of adding new athletes, recording their performance for each competition, and calculating their overall ranking based on their total score. # Objectives: 1. Write a function `add_athlete(name: str) -> None` to add a new athlete to the system. 2. Implement the `record_performance(name: str, score: int) -> None` function to record the score of a specific athlete for a competition. 3. Implement the `get_athlete_score(name: str) -> int` function to retrieve the total score of a specified athlete. 4. Create a `rank_athletes() -> List[str]` function to return a list of athlete names sorted by their total score in descending order. # Function Definitions: - `add_athlete(name: str) -> None` - **Input**: - name: The name of the athlete. - **Output**: None - `record_performance(name: str, score: int) -> None` - **Input**: - name: The name of the athlete. - score: An integer score for the competition. - **Output**: None - `get_athlete_score(name: str) -> int` - **Input**: - name: The name of the athlete. - **Output**: Total score of the athlete as an integer. - `rank_athletes() -> List[str]` - **Output**: A list of athlete names sorted by their total score in descending order. # Constraints: - Athlete names are unique and will contain only alphabetic characters. - Scores are positive integers. - The functions should handle cases where records for athletes do not exist gracefully. # Example Usage: ```python # Adding athletes add_athlete(\\"Alice\\") add_athlete(\\"Bob\\") # Recording performances record_performance(\\"Alice\\", 15) record_performance(\\"Bob\\", 10) record_performance(\\"Alice\\", 20) # Retrieving total scores alice_score = get_athlete_score(\\"Alice\\") # Should return 35 bob_score = get_athlete_score(\\"Bob\\") # Should return 10 # Ranking athletes ranking = rank_athletes() # Should return [\\"Alice\\", \\"Bob\\"] print(ranking) ``` Implement these functions in Python following the provided specifications and constraints. Ensure your implementation effectively manages the addition of new athletes, the recording of their performance, and the ranking process based on total scores.","solution":"athletes = {} def add_athlete(name: str) -> None: Adds a new athlete to the system. if name not in athletes: athletes[name] = 0 def record_performance(name: str, score: int) -> None: Records the score of a specific athlete for a competition. if name in athletes: athletes[name] += score def get_athlete_score(name: str) -> int: Retrieves the total score of a specified athlete. return athletes.get(name, 0) def rank_athletes() -> list: Returns a list of athlete names sorted by their total score in descending order. return [name for name, score in sorted(athletes.items(), key=lambda item: item[1], reverse=True)]"},{"question":"Find Duplicates in an Array # Context You are given an array of integers. Your task is to identify all the elements that appear more than once in the array and return them in a new array. The result array should contain each duplicate element only once, regardless of how many times it appears in the input array. # Input 1. A single instance of a list of integers `arr`. # Output 1. An instance of a list that contains all the duplicate elements from the input array, with each element appearing only once. # Constraints 1. The elements of the array are integers. 2. The input array may contain both positive and negative integers. 3. The input array may contain zero or more integers. # Performance Requirements 1. The time complexity of the operation should be linear, i.e., O(n) where n is the length of the input array. 2. The space complexity should be O(n) for storing the duplicate elements and any necessary data structures. # Function Definition ```python def find_duplicates(arr: list[int]) -> list[int]: pass ``` # Example ```python # Example Case # Input: arr = [1, 3, 2, 1, 4, 5, 6, 3, 2, 7, 8, 1] # Output: duplicates = find_duplicates(arr) # duplicates should be [1, 3, 2] ``` # Notes 1. You may assume that the function `find_duplicates` and list manipulation methods are well-defined. 2. Your solution should correctly identify all elements that occur more than once without considering their abundance.","solution":"def find_duplicates(arr: list[int]) -> list[int]: Returns a list of elements that appear more than once in the input array. Each duplicate element appears only once in the result. element_count = {} duplicates = [] # Count frequency of each element for num in arr: if num in element_count: element_count[num] += 1 else: element_count[num] = 1 # Collect elements that appear more than once for num, count in element_count.items(): if count > 1: duplicates.append(num) return duplicates"},{"question":"# String Permutation Checker Write a function `is_permutation(s1: str, s2: str) -> bool` that checks whether the two input strings are permutations of each other. A permutation is a rearrangement of characters. The function should be case-sensitive and consider whitespace as significant. # Function Signature ```python def is_permutation(s1: str, s2: str) -> bool: pass ``` # Input * `s1`: A string, where 0 ≤ len(s1) ≤ 10^5. * `s2`: A string, where 0 ≤ len(s2) ≤ 10^5. # Output * A boolean value, `True` if `s1` and `s2` are permutations of each other, and `False` otherwise. # Example ```python >>> is_permutation(\\"abc\\", \\"cab\\") True >>> is_permutation(\\"hello\\", \\"bello\\") False >>> is_permutation(\\"dog \\", \\"god\\") False >>> is_permutation(\\"\\", \\"\\") True >>> is_permutation(\\"12345\\", \\"54321\\") True ``` # Constraints * The function must run efficiently with respect to time and space complexity. * Consider edge cases, such as empty strings and strings of different lengths, appropriately.","solution":"from collections import Counter def is_permutation(s1: str, s2: str) -> bool: Checks if two strings are permutations of each other. Arguments: s1 -- first string s2 -- second string Returns: True if s1 and s2 are permutations of each other, False otherwise. if len(s1) != len(s2): return False return Counter(s1) == Counter(s2)"},{"question":"# Problem Description: You are tasked with finding a single \\"peak\\" element from an unsorted list of integers. A peak element is defined as a value that is not smaller than its neighbors. For the purposes of this problem, given an array `nums`, a peak element can be found at index `i` if: - `nums[i-1] <= nums[i] >= nums[i+1]` You should implement a function that returns the index of any one peak element in the list. The array may contain multiple peaks, in which case returning the index to any one of the peaks is sufficient. You must devise an efficient algorithm that works in O(log `n`) time. # Input: * A list of integers `nums` where `1 <= len(nums) <= 10^4` and `-2^31 <= nums[i] <= 2^31 - 1`. # Output: * An integer representing the index of any one peak element. # Function Signature: ```python def find_peak_element(nums: list[int]) -> int: pass ``` # Constraints: * Your solution must run in O(log `n`) time. * The input list is guaranteed to contain at least one peak element. # Performance Requirements: Your solution should use a binary search technique to achieve the required O(log `n`) time complexity. # Edge Cases: * The peak element can be at the beginning or at the end of the list. * Consider lists with all elements equal, though this is less common. # Example: ```python # Example 1: # Input: nums = [1, 2, 3, 1] # Output: 2 (nums[2] = 3 is a peak element) # Example 2: # Input: nums = [1, 2, 1, 3, 5, 6, 4] # Output: 5 (nums[5] = 6 is a peak element) ``` **Notes**: 1. Avoid brute force solutions that check each element; use a binary search approach instead. 2. You can assume that `nums[-1]` and `nums[len(nums)]` are considered out of bounds and are treated as negative infinity.","solution":"def find_peak_element(nums: list[int]) -> int: Finds a peak element index in the list `nums` using binary search. A peak element is defined as an element that is not smaller than its neighbors. Parameters: - nums: list[int] : List of integers where we need to find the peak element index. Returns: - int: Index of any one peak element. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: # If the mid element is greater than the next element, # then the peak must be on the left half (including mid) right = mid else: # If the mid element is less than the next element, # then the peak must be on the right half (excluding mid) left = mid + 1 # Left will point to the peak element index return left"},{"question":"# Question You are tasked with developing a library management system that involves checking in and checking out books from the library. You must implement a function that tracks which books are currently checked out and by whom, and then allows users to effectively return books. The function should also ensure that books cannot be checked out more than once. Function Specification ```python def manage_library(actions: list[tuple[str, str, str]]) -> dict[str, list[str]]: Manages the borrowing and returning of books in a library. The function accepts a list of actions in the format (action, user, book) and returns a dictionary where the keys are user IDs and the values are lists of books currently checked out by that user. :param actions: A list of tuples where each tuple represents an action. An action tuple consists of: (\'borrow\' or \'return\', user ID, book title). :return: A dictionary with user IDs as keys and lists of books currently checked out as values. ``` # Input * `actions`: A list of tuples, where each tuple contains three elements: * A string representing the action, either \\"borrow\\" or \\"return\\". * A string representing the user\'s ID. * A string representing the book title. # Output * A dictionary where the keys are user IDs (strings) and the values are lists of strings representing the titles of the books the user currently has checked out. # Constraints * `1 ≤ len(actions) ≤ 10^4` - The length of the list of actions is constrained between 1 and 10,000. * User IDs and book titles will consist of alphanumeric characters and spaces and will be between 1 to 100 characters in length. * Each book can be borrowed by only one user at a time. * If a user tries to return a book they haven\'t borrowed, the action should be ignored. * If a user attempts to borrow a book that\'s already borrowed by someone else, the action should be ignored. # Example ```python actions = [ (\\"borrow\\", \\"user_1\\", \\"Book A\\"), (\\"borrow\\", \\"user_2\\", \\"Book B\\"), (\\"return\\", \\"user_1\\", \\"Book A\\"), (\\"borrow\\", \\"user_2\\", \\"Book A\\") ] print(manage_library(actions)) # Output: {\'user_2\': [\'Book B\', \'Book A\']} ``` # Explanation: 1. `user_1` borrows \\"Book A\\". 2. `user_2` borrows \\"Book B\\". 3. `user_1` returns \\"Book A\\". 4. `user_2` borrows \\"Book A\\". Thus, `user_2` ends up with two books: \\"Book B\\" and \\"Book A\\".","solution":"def manage_library(actions): Manages the borrowing and returning of books in a library. The function accepts a list of actions in the format (action, user, book) and returns a dictionary where the keys are user IDs and the values are lists of books currently checked out by that user. :param actions: A list of tuples where each tuple represents an action. An action tuple consists of: (\'borrow\' or \'return\', user ID, book title). :return: A dictionary with user IDs as keys and lists of books currently checked out as values. borrowed_books = {} user_books = {} for action, user, book in actions: if action == \\"borrow\\": if book not in borrowed_books: borrowed_books[book] = user if user not in user_books: user_books[user] = [] user_books[user].append(book) elif action == \\"return\\": if book in borrowed_books and borrowed_books[book] == user: borrowed_books.pop(book) user_books[user].remove(book) if not user_books[user]: user_books.pop(user) return user_books"},{"question":"# Task Description: You are required to implement a function `longest_prefix_suffix` that finds the length of the longest proper prefix of a string which is also a suffix. A proper prefix is a prefix that is not equal to the string itself. # Function Signature: ```python def longest_prefix_suffix(s: str) -> int: Given a string s, find the length of the longest proper prefix of s that is also a suffix. Parameters: s (str): The input string Returns: int: The length of the longest proper prefix that is also a suffix pass ``` # Constraints: 1. The input string `s` has a length between 1 and 1000. # Example: ```python s1 = \\"abab\\" print(longest_prefix_suffix(s1)) # Expected output: 2 s2 = \\"aaaa\\" print(longest_prefix_suffix(s2)) # Expected output: 3 s3 = \\"abcab\\" print(longest_prefix_suffix(s3)) # Expected output: 2 s4 = \\"a\\" print(longest_prefix_suffix(s4)) # Expected output: 0 ``` # Notes: 1. A proper prefix is any prefix of the string except the string itself. 2. The suffix is the end part of the string and must match the prefix exactly. 3. The solution should efficiently handle the string to determine matching prefix and suffix lengths; consider using the KMP (Knuth-Morris-Pratt) algorithm\'s partial match table (prefix function).","solution":"def longest_prefix_suffix(s: str) -> int: Given a string s, find the length of the longest proper prefix of s that is also a suffix. Parameters: s (str): The input string Returns: int: The length of the longest proper prefix that is also a suffix n = len(s) if n == 0: return 0 lps = [0] * n # lps[i] will be the length of the longest proper prefix which is also suffix for s[0:i+1] length = 0 # length of the previous longest prefix suffix i = 1 # Loop from the second character to the last character while i < n: if s[i] == s[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length-1] else: lps[i] = 0 i += 1 return lps[-1] if len(s) > 1 else 0"},{"question":"# Problem Statement You are given a 2D grid filled with integers where each cell is either land (`1`) or water (`0`). Your task is to find the size of the largest island of land. An island is a group of adjacent lands horizontally or vertically (not diagonally). You need to implement functions that identify each island and calculate its size. # Functions to Implement You need to implement the following two functions: 1. `dfs(row: int, col: int, grid: List[List[int]], visited: List[List[bool]]) -> int`: - **Input**: - `row`: The row index of the current cell. - `col`: The column index of the current cell. - `grid`: A 2D list of integers representing the grid. - `visited`: A 2D list of boolean values representing cells that have already been visited. - **Output**: An integer representing the size of the island that includes the cell `(row, col)`. 2. `largest_island(grid: List[List[int]]) -> int`: - **Input**: - `grid`: A 2D list of integers representing the grid. - **Output**: An integer representing the size of the largest island in the grid. # Example ```python grid = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 1, 1] ] visited = [[False for _ in range(len(grid[0]))] for _ in range(len(grid))] print(dfs(0, 0, grid, visited)) # Output: 4 print(largest_island(grid)) # Output: 4 ``` # Constraints - The grid will have dimensions `m x n` where `1 <= m, n <= 1000`. - Only land cells are the cells with value `1`, and only water cells are the cells with value `0`. - The grid is rectangular in shape. # Notes - Ensure that your implementation efficiently traverses the grid. - Handle edge cases where the grid consists entirely of water or land. - Make sure that your DFS implementation properly handles grid boundaries to avoid out-of-bounds errors.","solution":"from typing import List def dfs(row: int, col: int, grid: List[List[int]], visited: List[List[bool]]) -> int: Perform a Depth-First Search to calculate the size of the island. # Check for bounds and if the cell is water or already visited if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] == 0 or visited[row][col]: return 0 # Mark the cell as visited visited[row][col] = True # Initialize the size of the island to 1 (current cell) size = 1 # Traverse all four connected neighbors (up, down, left, right) size += dfs(row - 1, col, grid, visited) # Up size += dfs(row + 1, col, grid, visited) # Down size += dfs(row, col - 1, grid, visited) # Left size += dfs(row, col + 1, grid, visited) # Right return size def largest_island(grid: List[List[int]]) -> int: Find the size of the largest island in the grid. if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] max_size = 0 for row in range(rows): for col in range(cols): if grid[row][col] == 1 and not visited[row][col]: # Found an unvisited land cell, start a DFS island_size = dfs(row, col, grid, visited) max_size = max(max_size, island_size) return max_size"},{"question":"# Coding Assessment Question Objective Create a Python function to simulate reading and processing data from multiple sensors over a period of time and return the sensor with the most stable readings. Problem Statement You are given data from multiple sensors, each recording readings over a specific period. Your task is to determine the most stable sensor, defined as the sensor with the smallest standard deviation of its readings. Function Specifications 1. **Function Name**: `find_most_stable_sensor` 2. **Input Parameters**: - `sensors_data`: List of lists, where each sublist contains float values representing the readings from a single sensor. 3. **Output**: - Integer; Index of the most stable sensor (0-based index). - If the input list is empty or contains an empty sublist, raise a `ValueError` with a descriptive message. 4. **Constraints**: - Each sublist in the input list should contain at least one reading. - Use Python\'s standard library to compute the standard deviation. - Use efficient algorithms to handle large lists of readings. ```python import statistics def find_most_stable_sensor(sensors_data: list[list[float]]) -> int | ValueError: Input Parameters: ----------------- sensors_data: List of lists, where each sublist contains float values representing sensor readings. Returns: -------- An integer representing the index (0-based) of the most stable sensor, i.e., the sensor with the smallest standard deviation in its readings. If the inputs are invalid (empty list or any empty sublist), raises a ValueError with an appropriate error message. Examples: --------- >>> find_most_stable_sensor([[2.3, 2.5, 2.7], [3.2, 3.5, 3.4], [1.2, 1.3, 1.1]]) 2 >>> find_most_stable_sensor([[2.1, 2.3], [], [1.5, 1.7]]) ValueError(\'Input Error: Each sensor must have at least one reading.\') >>> find_most_stable_sensor([]) ValueError(\'Input Error: Sensor data cannot be empty.\') pass # Your code here ``` Notes: 1. Both the input validation and the computation of the standard deviation must be implemented. 2. Make sure to return the index of the most stable sensor accurately. 3. Ensure your code is efficient and can handle large datasets. # Example Results Explained: 1. For `[[2.3, 2.5, 2.7], [3.2, 3.5, 3.4], [1.2, 1.3, 1.1]]`, the standard deviation of readings for each sensor is: - Sensor 0: std = 0.2 - Sensor 1: std = 0.15 - Sensor 2: std = 0.08165 (approx) Since sensor 2 has the smallest standard deviation, the function returns `2`. 2. For `[[2.1, 2.3], [], [1.5, 1.7]]` or `[]`, the function raises a `ValueError`.","solution":"import statistics def find_most_stable_sensor(sensors_data): Input Parameters: ----------------- sensors_data: List of lists, where each sublist contains float values representing sensor readings. Returns: -------- An integer representing the index (0-based) of the most stable sensor, i.e., the sensor with the smallest standard deviation in its readings. If the inputs are invalid (empty list or any empty sublist), raises a ValueError with an appropriate error message. Examples: --------- >>> find_most_stable_sensor([[2.3, 2.5, 2.7], [3.2, 3.5, 3.4], [1.2, 1.3, 1.1]]) 2 >>> find_most_stable_sensor([[2.1, 2.3], [], [1.5, 1.7]]) ValueError(\'Input Error: Each sensor must have at least one reading.\') >>> find_most_stable_sensor([]) ValueError(\'Input Error: Sensor data cannot be empty.\') if not sensors_data: raise ValueError(\'Input Error: Sensor data cannot be empty.\') min_std = float(\'inf\') most_stable_sensor_idx = -1 for idx, readings in enumerate(sensors_data): if not readings: raise ValueError(\'Input Error: Each sensor must have at least one reading.\') std_dev = statistics.stdev(readings) if std_dev < min_std: min_std = std_dev most_stable_sensor_idx = idx return most_stable_sensor_idx"},{"question":"# Nested Dictionary Flattening You are required to implement a function that flattens a nested dictionary. The nested dictionary may contain other dictionaries as values, which need to be flattened into a single-level dictionary. The keys of the nested dictionaries should be concatenated with a period (`.`) to form the keys of the flat dictionary. **Function Signature:** ```python def flatten_dictionary(nested_dict: dict) -> dict: Flattens a nested dictionary into a single-level dictionary. Args: - nested_dict (dict): A dictionary which may contain nested dictionaries. Returns: - dict: A flattened dictionary with concatenated keys. Example: flatten_dictionary({ \\"key1\\": 1, \\"key2\\": { \\"key3\\": 2, \\"key4\\": { \\"key5\\": 3 } } }) # Output: {\\"key1\\": 1, \\"key2.key3\\": 2, \\"key2.key4.key5\\": 3} pass ``` # Requirements 1. **Function Definition**: Implement the function `flatten_dictionary` which takes one argument, a dictionary potentially containing other dictionaries, and returns a flattened dictionary. 2. **Key Concatenation**: The keys in the resulting dictionary should be concatenated with a period (`.`) to indicate their hierarchical structure from the original nested dictionary. 3. **No Nesting in Output**: The final dictionary should not contain any nested dictionaries. # Constraints - The dictionary keys are strings. - The values in the dictionary can be integers, strings, lists, tuples, or other dictionaries. - The function should handle nested dictionaries of arbitrary depth. # Example ```python assert flatten_dictionary({ \\"a\\": 1, \\"b\\": { \\"c\\": 2, \\"d\\": { \\"e\\": 3, \\"f\\": 4 } } }) == { \\"a\\": 1, \\"b.c\\": 2, \\"b.d.e\\": 3, \\"b.d.f\\": 4 } assert flatten_dictionary({ \\"x\\": 10, \\"y\\": { \\"z\\": 20, \\"w\\": { \\"v\\": 30 } }, \\"u\\": { \\"t\\": 40 } }) == { \\"x\\": 10, \\"y.z\\": 20, \\"y.w.v\\": 30, \\"u.t\\": 40 } ``` Implement the `flatten_dictionary` function to achieve the above requirements and pass the example tests.","solution":"def flatten_dictionary(nested_dict: dict) -> dict: def flatten(current_dict, parent_key=\'\'): items = [] for key, value in current_dict.items(): new_key = parent_key + \'.\' + key if parent_key else key if isinstance(value, dict): items.extend(flatten(value, new_key).items()) else: items.append((new_key, value)) return dict(items) return flatten(nested_dict)"},{"question":"# Sorting Strings by Character Frequency You are tasked with creating a function to sort an array of strings based on the frequency of a specified character within each string. The sorting should be performed in descending order of the frequency of the specified character. If two strings have the same frequency, they should be sorted in their original order of appearance in the array (i.e., stable sorting). # Function Specifications 1. **Function Name**: `sort_by_char_frequency` 2. **Parameters**: - `strings` (list of str): A list of strings to be sorted. - `char` (str): The character whose frequency should be used as the sorting key. 3. **Returns**: - A list of strings sorted based on the frequency of the specified character, in descending order. 4. **Constraints**: - The input list `strings` can contain up to 10^4 strings. - Each string in `strings` can be up to 10^3 characters long. - The character `char` will always be a single character string and an alphanumeric character. - Duplicate frequencies should not affect the relative order of strings with the same frequency (i.e., stable sort). 5. **Performance Requirement**: - The function should be efficient and complete its task in linearithmic time relative to the size of the input (O(n log n)). # Examples ```python example_strings = [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\", \\"elderberry\\", \\"fig\\", \\"grape\\"] char = \'e\' result = sort_by_char_frequency(example_strings, char) print(result) # Expected Output: [\'elderberry\', \'cherry\', \'apple\', \'date\', \'banana\', \'fig\', \'grape\'] ``` # Implementation Details Include the necessary imports and define the `sort_by_char_frequency` function, ensuring efficient performance and correct handling of edge cases. ```python def sort_by_char_frequency(strings: list, char: str) -> list: Parameters: strings (list of str): A list of strings to be sorted char (str): A character whose frequency in the strings should be the sorting key Returns: sorted_strings (list of str): The list of strings sorted by the frequency of the specified character return sorted(strings, key=lambda s: s.count(char), reverse=True) # Example usage example_strings = [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\", \\"elderberry\\", \\"fig\\", \\"grape\\"] char = \'e\' print(sort_by_char_frequency(example_strings, char)) # Output: [\'elderberry\', \'cherry\', \'apple\', \'date\', \'banana\', \'fig\', \'grape\'] ``` Ensure your function is thoroughly tested with various cases, including edge cases, to confirm its correctness and efficiency.","solution":"def sort_by_char_frequency(strings, char): Sorts the strings based on the frequency of \'char\' in each string in descending order. return sorted(strings, key=lambda s: s.count(char), reverse=True)"},{"question":"# Problem Statement Create a class called `SortedCircularLinkedList` that implements a sorted circular linked list of integers. Your implementation should: 1. Maintain the elements in ascending order. 2. Support insertion of new elements. 3. Support removal of existing elements. 4. Provide a method to display the elements in the list. # Requirements - Implement the `SortedCircularLinkedList` class with the following methods: - `insert(self, value: int) -> None`: Insert a new value into the list while maintaining sorted order. - `remove(self, value: int) -> bool`: Remove a value from the list, return `True` if the value was found and removed, otherwise `False`. - `display(self) -> List[int]`: Return a list of all the elements in sorted order. # Class Implementation Method Headers 1. **Inserting a value**: ```python def insert(self, value: int) -> None: ``` - **value**: The integer value to insert into the list. 2. **Removing a value**: ```python def remove(self, value: int) -> bool: ``` - **value**: The integer value to remove from the list. - **returns**: `True` if the value was found and removed, otherwise `False`. 3. **Displaying the list**: ```python def display(self) -> List[int]: ``` - **returns**: A list of integers representing the elements in sorted order. # Constraints - The list will contain up to 1000 elements. - Each element will be an integer between -10^6 and 10^6. - The list must always remain sorted after every insertion and removal operation. # Example ```python # Example usage of the class scll = SortedCircularLinkedList() scll.insert(10) scll.insert(5) scll.insert(20) scll.insert(15) print(scll.display()) # Expected Output: [5, 10, 15, 20] scll.remove(10) print(scll.display()) # Expected Output: [5, 15, 20] scll.remove(25) print(scll.display()) # Expected Output: [5, 15, 20] (10 is not in the list, so no change) ``` # Notes - The circular nature of the list implies that the last element points back to the first element. - Pay attention to edge cases, such as inserting into an empty list or removing an element that does not exist. - Ensure proper handling of pointers to maintain the circular structure during insertions and removals.","solution":"class SortedCircularLinkedList: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self): self.tail = None def insert(self, value: int) -> None: new_node = self.Node(value) if not self.tail: new_node.next = new_node self.tail = new_node else: current = self.tail.next prev = self.tail while current != self.tail and current.value < value: prev = current current = current.next if current == self.tail and current.value < value: new_node.next = current.next current.next = new_node self.tail = new_node else: new_node.next = current prev.next = new_node def remove(self, value: int) -> bool: if not self.tail: return False current = self.tail.next prev = self.tail while current != self.tail and current.value != value: prev = current current = current.next if current.value == value: if current == self.tail and current.next == self.tail: self.tail = None elif current == self.tail: prev.next = self.tail.next self.tail = prev else: prev.next = current.next return True return False def display(self) -> list: elements = [] if not self.tail: return elements current = self.tail.next while True: elements.append(current.value) if current == self.tail: break current = current.next return elements"},{"question":"# Find Critical Servers in a Network **Objective**: Implement an algorithm to identify all critical servers in a computer network. A critical server (also known as an articulation point) is a server that, if removed, will increase the number of connected components in the network. Input You are given a network represented as an adjacency list, where `network` is a dictionary such that `network[u]` is a list of servers directly connected to server `u`. Your function should accept a dictionary `network` where the keys are server identifiers (integers starting from 0) and the values are lists of adjacent server identifiers. Output Return a list of integers representing the critical servers in the network. Constraints 1. Network can have up to 10,000 servers. 2. There may be multiple connections between two servers. 3. Network does not contain self-loops. 4. You must handle networks with no connections and completely connected networks. Example ```python def find_critical_servers(network: dict[int, list[int]]) -> list[int]: Return the list of critical servers `critical_servers` Example: >>> find_critical_servers({ >>> 0: [1, 2], >>> 1: [0, 2], >>> 2: [0, 1, 3, 5], >>> 3: [2, 4], >>> 4: [3], >>> 5: [2, 6, 8], >>> 6: [5, 7], >>> 7: [6, 8], >>> 8: [5, 7], >>> }) [2, 3, 5] Example for empty network: >>> find_critical_servers({}) [] # Write your implementation here ``` Explanation In the above example: * Server 2 is critical because its removal will disconnect parts of the network, increasing the total number of connected components. * Server 3 is critical because removing it will isolate server 4 from the rest of the network. * Server 5 is critical since its removal isolates servers 6, 7, and 8. Make sure to handle edge cases like an empty network correctly and efficiently. **Hint**: Use Depth First Search (DFS) and the concept of discovery and low times to find the articulation points efficiently in O(V + E) time.","solution":"def find_critical_servers(network: dict[int, list[int]]) -> list[int]: Return the list of critical servers `critical_servers` Uses DFS and Low-Time technique to find articulation points in the graph. def dfs(u, parent, time): nonlocal dfs_index dfs_index += 1 disc[u] = low[u] = dfs_index children = 0 for v in network[u]: if disc[v] == -1: children += 1 parent_map[v] = u dfs(v, u, time + 1) low[u] = min(low[u], low[v]) if parent is not None and low[v] >= disc[u]: articulation_points.add(u) if parent is None and children > 1: articulation_points.add(u) elif v != parent: low[u] = min(low[u], disc[v]) dfs_index = 0 disc = {key: -1 for key in network} low = {key: float(\'inf\') for key in network} parent_map = {key: None for key in network} articulation_points = set() for node in network: if disc[node] == -1: dfs(node, None, 0) return list(articulation_points)"},{"question":"# Scenario Web technologies like HTML and CSS frequently require manipulation of styles via code. UI developers often need functions that automate style adjustments for various user interface elements, making the code more maintainable and scalable. # Task Write a Python function `merge_styles(base_style: dict, additional_style: dict) -> dict` that takes two dictionaries representing CSS style properties. The function should merge the two dictionaries, giving preference to the properties in `additional_style` when conflicts arise (i.e., if the same property exists in both styles, the value from `additional_style` should override the value from `base_style`). # Input Specifications * `base_style`: A dictionary where keys are CSS property names (strings) and values are the corresponding CSS property values (strings). * `additional_style`: Another dictionary with the same structure as `base_style`. # Output Specifications * Returns a dictionary combining the properties from both input dictionaries, with `additional_style` values taking precedence in case of conflicts. # Constraints * Keys in both dictionaries will be well-formed CSS property names (e.g., \'color\', \'font-size\', \'margin\'). * Values will be well-formed CSS values (e.g., \'red\', \'12px\', \'5px 10px\'). * There will be no nested dictionaries. # Example ```python >>> base_style = {\'color\': \'blue\', \'font-size\': \'12px\', \'margin\': \'5px\'} >>> additional_style = {\'color\': \'red\', \'padding\': \'10px\'} >>> merge_styles(base_style, additional_style) {\'color\': \'red\', \'font-size\': \'12px\', \'margin\': \'5px\', \'padding\': \'10px\'} >>> base_style = {\'width\': \'100px\'} >>> additional_style = {\'height\': \'200px\'} >>> merge_styles(base_style, additional_style) {\'width\': \'100px\', \'height\': \'200px\'} >>> base_style = {\'background\': \'white\', \'border\': \'1px solid black\'} >>> additional_style = {\'background\': \'blue\'} >>> merge_styles(base_style, additional_style) {\'background\': \'blue\', \'border\': \'1px solid black\'} ``` # Requirements - The function must ensure that no duplicate property names exist in the resulting dictionary. - The resulting dictionary can utilize properties from both input dictionaries, ensuring no nested structures. - The algorithm should be efficient to handle typical usage scenarios in web development.","solution":"def merge_styles(base_style, additional_style): Merges two style dictionaries giving precedence to additional_style. Parameters: - base_style: dict. Dictionary representing the base CSS styles. - additional_style: dict. Dictionary representing the additional CSS styles. Returns: - dict. Merged dictionary with additional_style values taking precedence. merged_style = base_style.copy() # Start with base_style merged_style.update(additional_style) # Override with additional_style return merged_style"},{"question":"# Matrix Multiplication Coding Assessment Given two matrices, your task is to implement a function that performs matrix multiplication. Matrix multiplication is defined as the dot product of rows from the first matrix with columns of the second matrix. Ensure you verify the compatibility of the dimensions before proceeding with the multiplication. 1. **`matrix_multiply(matrix1: list[list[int]], matrix2: list[list[int]]) -> list[list[int]]`**: This function should return the product of the input matrices `matrix1` and `matrix2`. # Requirements - **Input Format**: - `matrix1`: List of lists, where each inner list represents a row of the first matrix. - `matrix2`: List of lists, where each inner list represents a row of the second matrix. - **Output Format**: - A list of lists representing the product matrix. - **Constraints**: - The number of columns in `matrix1` must equal the number of rows in `matrix2` for the product to be defined. - All elements in the matrices will be integers. - **Performance**: - Optimize for efficiency in matrix multiplication operations. # Example ```python matrix1 = [ [1, 2, 3], [4, 5, 6] ] matrix2 = [ [7, 8], [9, 10], [11, 12] ] # Expected output result = [ [58, 64], [139, 154] ] # In this case: # (1*7 + 2*9 + 3*11) = 58 # (1*8 + 2*10 + 3*12) = 64 # (4*7 + 5*9 + 6*11) = 139 # (4*8 + 5*10 + 6*12) = 154 ``` Implement the specified function ensuring correctness and optimal performance.","solution":"def matrix_multiply(matrix1, matrix2): Multiplies two matrices and returns the result. :param matrix1: list of lists where each inner list is a row of the first matrix. :param matrix2: list of lists where each inner list is a row of the second matrix. :return: list of lists representing the product matrix. # Number of rows in matrix1 rows_matrix1 = len(matrix1) # Number of columns in matrix1 (also the number of rows in matrix2) cols_matrix1 = len(matrix1[0]) # Number of columns in matrix2 cols_matrix2 = len(matrix2[0]) # Initialize the result matrix with zeros result = [[0 for _ in range(cols_matrix2)] for _ in range(rows_matrix1)] # Perform the multiplication for i in range(rows_matrix1): for j in range(cols_matrix2): for k in range(cols_matrix1): result[i][j] += matrix1[i][k] * matrix2[k][j] return result"},{"question":"# Next Prime Number Finder Objective: Create a function that finds the next prime number greater than a given integer. The function should efficiently determine the smallest prime number that is strictly greater than the input number. Function Signature: ```python def next_prime(n: int) -> int: ... ``` Inputs: * `n` (int): A non-negative integer. Constraints: ( 0 leq n leq 10^6 ) Output: * `int`: Returns the smallest prime number that is strictly greater than the input. Examples: ```python next_prime(3) # returns 5 next_prime(8) # returns 11 next_prime(14) # returns 17 next_prime(30) # returns 31 next_prime(99) # returns 101 next_prime(1000) # returns 1009 ``` Edge Cases to Consider: 1. Input is a prime number (e.g., 2, 3, 5). 2. Input is zero or one, the smallest non-negative integers. 3. Input is near the upper limit, requiring efficient execution. Performance Requirements: - The function should handle the input size constraint efficiently, leveraging optimal algorithms for prime checking and generation. It should complete within a reasonable time frame for all permissible input values.","solution":"def is_prime(num): Helper function to check if a number is a prime number. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def next_prime(n): Finds the next prime number greater than a given integer n. candidate = n + 1 while not is_prime(candidate): candidate += 1 return candidate"},{"question":"# Problem Statement: You are working for a company that deals with satellite image processing. One common task is to analyze images represented as matrices of pixel values. Each pixel can either be on (represented by a 1) or off (represented by a 0). A contiguous block of pixels that are on (1s) forms a \\"connected component.\\" A connected component is defined as a group of 1s connected horizontally or vertically, but not diagonally. Your task is to write a function `count_connected_components(grid: List[List[int]]) -> int` that counts the number of connected components in a given 2D binary grid. Function Signature: ```python def count_connected_components(grid: List[List[int]]) -> int: ``` Input: * A 2D binary grid `grid` represented by a list of lists, where each element is either a 0 or a 1. * The grid dimensions can be up to 100x100. Output: * Return an integer which is the total number of connected components of 1s in the grid. Constraints: * The grid will always be a valid 2D list and won\'t be empty. * Elements will only be 0 or 1. * The dimensions of the grid will be at most 100x100. Example: ```python assert count_connected_components([ [1, 1, 0, 0], [0, 1, 0, 0], [0, 0, 1, 1], [0, 0, 0, 1] ]) == 3 # There are three connected components of 1s. assert count_connected_components([ [1, 0, 0, 1], [0, 0, 1, 1], [0, 1, 0, 0], [1, 0, 0, 0] ]) == 4 # There are four connected components of 1s. ``` Requirements: * **Edge Cases Handling**: Ensure to handle small grids (1x1), grids with no 1s, and grids fully filled with 1s. * **Performance**: Efficiently traverse and mark components without unnecessary redundancy. Additional Notes: * Consider using Depth-First Search (DFS) or Breadth-First Search (BFS) for exploring connected components. * Ensure all parts of the grid are checked to account for isolated components.","solution":"from typing import List def count_connected_components(grid: List[List[int]]) -> int: def dfs(x, y): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 0: return grid[x][y] = 0 # Mark as visited # Check all 4 possible directions dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) if not grid: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: count += 1 dfs(i, j) return count"},{"question":"# Scenario You are required to develop a function that examines and filters a list based on specific criteria related to numeric properties. Specifically, the function should retain numbers that are prime and discard the rest. # Problem Statement Write a function `filter_primes(numbers: List[int]) -> List[int]` that takes a list of integers `numbers` as input and returns a new list consisting only of the prime numbers from the original list. # Example ```python >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([11, 13, 17, 19, 23, 24, 25, 29]) [11, 13, 17, 19, 23, 29] >>> filter_primes([1, 4, 6, 8, 10, 12]) [] >>> filter_primes([]) [] >>> filter_primes([7, 7, 11, 11]) [7, 7, 11, 11] ``` # Input and Output Formats - **Input**: A list of integers `numbers` where the length of the list can be between 0 and 10^5 and each integer can be between 1 and 10^9. - **Output**: A list of integers containing only the prime numbers from the input list. # Constraints - The function should correctly identify prime numbers, where a prime number is defined as a number greater than 1 that has no positive divisors other than 1 and itself. - The order of the numbers in the output list should match the order of occurrence in the input list. # Performance Requirements Your solution should aim for optimal time complexity, making use of efficient algorithms for prime checking, and should be able to handle the upper limits of the input size within a reasonable time frame.","solution":"from typing import List def is_prime(n: int) -> bool: Determines if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(numbers: List[int]) -> List[int]: Filters and returns a list of prime numbers from the input list. return [num for num in numbers if is_prime(num)]"},{"question":"# Coding Assessment Question: Implement a Circular Buffer Context: As a software engineer, you are tasked with implementing a circular buffer (also known as a ring buffer). This data structure is particularly useful for situations where you need a fixed-size buffer that allows for efficient reading and writing operations, such as buffering data streams. Task: Implement a `CircularBuffer` class with the following methods: 1. `write(value: int) -> None`: Insert an integer value into the buffer. If the buffer is full, overwrite the oldest values. 2. `read() -> int`: Remove and return the oldest value in the buffer. Raise an exception if the buffer is empty. 3. `is_full() -> bool`: Return a boolean indicating whether the buffer is full. 4. `is_empty() -> bool`: Return a boolean indicating whether the buffer is empty. Expected Behavior: - Writing values should correctly wrap around to the beginning of the buffer when the end is reached. - Reading values should correctly remove the oldest value and wrap around as necessary. - The buffer should correctly indicate whether it is full or empty at any given time. Input and Output Formats: * `write(value: int)`: * **Input**: An integer value to be inserted. * **Output**: None. * `read()`: * **Input**: None. * **Output**: The oldest integer from the buffer. * `is_full()`: * **Input**: None. * **Output**: A boolean indicating whether the buffer is full. * `is_empty()`: * **Input**: None. * **Output**: A boolean indicating whether the buffer is empty. Constraints: 1. All integer values passed to `write` will be non-negative. 2. The `read` operation should raise an exception if the buffer is empty. 3. The buffer size will be given during initialization and remain fixed thereafter. 4. Implement the circular buffer using an array to store the elements. Performance Requirements: - The `write` and `read` operations must both run in O(1) time. Complete the method definitions in the class `CircularBuffer`: ```python class CircularBuffer: def __init__(self, size: int): self.__buffer = [None] * size self.__max_size = size self.__head = 0 self.__tail = 0 self.__is_full = False def write(self, value: int) -> None: Insert new element into the buffer pass # Implement this method def read(self) -> int: Remove and return the oldest element in the buffer pass # Implement this method def is_full(self) -> bool: Check if the buffer is full pass # Implement this method def is_empty(self) -> bool: Check if the buffer is empty pass # Implement this method # Example: # buffer = CircularBuffer(3) # buffer.write(1) # buffer.write(2) # buffer.write(3) # print(buffer.is_full()) # True # print(buffer.read()) # 1 # buffer.write(4) # print(buffer.read()) # 2 # print(buffer.is_empty()) # False # print(buffer.read()) # 3 # print(buffer.read()) # 4 # print(buffer.is_empty()) # True ```","solution":"class CircularBuffer: def __init__(self, size: int): self.__buffer = [None] * size self.__max_size = size self.__head = 0 self.__tail = 0 self.__is_full = False def write(self, value: int) -> None: self.__buffer[self.__head] = value if self.__is_full: self.__tail = (self.__tail + 1) % self.__max_size self.__head = (self.__head + 1) % self.__max_size self.__is_full = self.__head == self.__tail def read(self) -> int: if self.is_empty(): raise Exception(\\"Buffer is empty\\") value = self.__buffer[self.__tail] self.__buffer[self.__tail] = None self.__tail = (self.__tail + 1) % self.__max_size self.__is_full = False return value def is_full(self) -> bool: return self.__is_full def is_empty(self) -> bool: return not self.__is_full and self.__head == self.__tail"},{"question":"# Shortest Path in a Weighted Grid Given an `n x n` grid where each cell contains a positive integer representing the cost to traverse that cell, your task is to find the minimum cost path from the top-left corner `(0, 0)` to the bottom-right corner `(n-1, n-1)`. The path can only move right or down at each step. Specifications: 1. **Grid Representation**: * An `n x n` grid where `grid[i][j]` contains the traversal cost of the cell `(i, j)`. 2. **Path Constraints**: * Start at cell `(0, 0)` and end at cell `(n-1, n-1)`. * Only right (`(i, j+1)`) or down (`(i+1, j)`) movements are allowed. 3. **Cost Calculation**: * The cost of a path is the sum of the costs of the cells along that path. Input and Output Formats: * **Function Signature**: ```python def min_cost_path(grid: list[list[int]]) -> int: pass ``` * **Inputs**: * `grid`: A 2D list of integers representing the cost grid. * **Output**: * Returns an integer representing the minimum cost to reach the bottom-right corner from the top-left corner. Examples: * **Example 1**: ```python grid1 = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert min_cost_path(grid1) == 7 # Explanation: Path: 1→3→1→1→1→0 ``` * **Example 2**: ```python grid2 = [ [2, 2, 1], [1, 7, 1], [4, 3, 1] ] assert min_cost_path(grid2) == 7 # Explanation: Path: 2→2→1→1→1→0 ``` * **Example 3**: ```python grid3 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert min_cost_path(grid3) == 21 # Explanation: Path: 1→2→3→6→9 ``` Implementation Notes: - Apply dynamic programming to store the minimum cost to reach each cell. - Traverse the grid from top-left to bottom-right, updating the minimum cost at each cell. - Identify any edge cases such as very small grids (`1x1`) or grids with uniform costs. Implement the function, write the necessary assertions to validate your results, and provide a brief analysis of any encountered edge cases or challenges.","solution":"def min_cost_path(grid): n = len(grid) # Edge case for empty grid if n == 0 or len(grid[0]) == 0: return 0 # Create a DP table to store the minimum cost for each cell dp = [[0] * n for _ in range(n)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner contains the minimum cost path return dp[-1][-1]"},{"question":"# Merge Sorted Arrays You are working on a project that involves combining data from multiple sorted sources. Your task is to write a Python function that merges two sorted arrays into one sorted array. The function should be efficient and capable of handling large datasets. # Function Specifications 1. **Function Name**: `merge_sorted_arrays` 2. **Parameters**: - `array1` (list of int): A sorted list of integers. - `array2` (list of int): Another sorted list of integers. 3. **Returns**: - A new sorted list containing all the elements from `array1` and `array2`. 4. **Constraints**: - The input lists `array1` and `array2` will have lengths in the range [0, 10^6]. - The elements of the input lists will be within the range `[-10^9, 10^9]`. - The function should run in linear time relative to the total number of elements in the input lists. # Examples ```python array1 = [1, 3, 5, 7] array2 = [2, 4, 6, 8] result = merge_sorted_arrays(array1, array2) print(result) # Expected Output: [1, 2, 3, 4, 5, 6, 7, 8] ``` # Implementation Details Define the `merge_sorted_arrays` function. Ensure that the function merges the arrays in a manner that maintains the overall sorted order without using additional sorting methods after the merge. The process should be linear in time complexity. ```python def merge_sorted_arrays(array1: list, array2: list) -> list: Merge two sorted arrays into one sorted array. Parameters: array1 (list of int): A sorted list of integers array2 (list of int): Another sorted list of integers Returns: merged_array (list of int): A new sorted list containing all elements from array1 and array2 index1 = 0 index2 = 0 merged_array = [] while index1 < len(array1) and index2 < len(array2): if array1[index1] < array2[index2]: merged_array.append(array1[index1]) index1 += 1 else: merged_array.append(array2[index2]) index2 += 1 # Append remaining elements if any if index1 < len(array1): merged_array.extend(array1[index1:]) if index2 < len(array2): merged_array.extend(array2[index2:]) return merged_array # Example usage array1 = [1, 3, 5, 7] array2 = [2, 4, 6, 8] print(merge_sorted_arrays(array1, array2)) # Expected Output: [1, 2, 3, 4, 5, 6, 7, 8] ``` Implement and test your function thoroughly to ensure it handles different edge cases and large inputs efficiently.","solution":"def merge_sorted_arrays(array1, array2): Merge two sorted arrays into one sorted array. Parameters: array1 (list of int): A sorted list of integers array2 (list of int): Another sorted list of integers Returns: merged_array (list of int): A new sorted list containing all elements from array1 and array2 index1 = 0 index2 = 0 merged_array = [] while index1 < len(array1) and index2 < len(array2): if array1[index1] < array2[index2]: merged_array.append(array1[index1]) index1 += 1 else: merged_array.append(array2[index2]) index2 += 1 # Append remaining elements if any if index1 < len(array1): merged_array.extend(array1[index1:]) if index2 < len(array2): merged_array.extend(array2[index2:]) return merged_array"},{"question":"# Question: You are tasked with implementing a function that parses a string representation of a list of integers and returns the corresponding list of integers. The function should be able to handle various edge cases such as invalid characters, empty strings, different types of delimiters, and having unnecessary spaces between elements. Here are the specifications: Function Signature ```python def parse_int_list(int_list_string: str) -> list: pass ``` Input - `int_list_string` (str): A string representing a list of integers. The string may contain integer values separated by commas and/or spaces, and possibly enclosed in square brackets. The string may contain leading and trailing spaces, and integers may be both positive and negative. Output - Returns a list of integers which are extracted from the input string. Constraints - The input string will have a length `0 <= len(int_list_string) <= 200`. - The function should raise a ValueError with an appropriate message for invalid inputs (e.g., non-numeric characters besides permitted delimiters, mismatched brackets, etc.). Example ```python >>> parse_int_list(\\"[1, 2, 3]\\") [1, 2, 3] >>> parse_int_list(\\"4,5,6\\") [4, 5, 6] >>> parse_int_list(\\" 7 , -8 , 9 \\") [7, -8, 9] >>> parse_int_list(\\"[10, -20, 30]\\") [10, -20, 30] >>> parse_int_list(\\" [1 , 2 5, 3, 40] \\") [1, 25, 3, 40] >>> parse_int_list(\\"[1,,2]\\") Traceback (most recent call last): ... ValueError: Invalid list string with consecutive delimiters >>> parse_int_list(\\"[,]\\") Traceback (most recent call last): ... ValueError: Empty list or invalid format >>> parse_int_list(\\"a, b, c\\") Traceback (most recent call last): ... ValueError: Non-integer value was passed to the function >>> parse_int_list(\\"[1 2 3]\\") Traceback (most recent call last): ... ValueError: Invalid format, missing commas >>> parse_int_list(\\"\\") Traceback (most recent call last): ... ValueError: Empty string was passed to the function ``` Additional tests: ```python >>> parse_int_list(\\"[2147483647, -2147483648]\\") # Maximum and minimum 32-bit signed integers [2147483647, -2147483648] >>> parse_int_list(\\" -1, -2, -3 \\") # Negative integers [-1, -2, -3] >>> parse_int_list(\\" \\") Traceback (most recent call last): ... ValueError: Empty string was passed to the function >>> parse_int_list(\\"[1.5, 2]\\") Traceback (most recent call last): ... ValueError: Non-integer value was passed to the function >>> parse_int_list(\\"[[1], 2, 3]\\") Traceback (most recent call last): ... ValueError: Invalid list string containing nested lists ``` The function should be robust and handle all edge cases gracefully, providing clear error messages where necessary.","solution":"import re def parse_int_list(int_list_string: str) -> list: Parses a string representation of a list of integers and returns the corresponding list of integers. if not int_list_string.strip(): raise ValueError(\\"Empty string was passed to the function\\") # Remove outer brackets if present int_list_string = int_list_string.strip() if int_list_string.startswith(\'[\') and int_list_string.endswith(\']\'): int_list_string = int_list_string[1:-1].strip() # Check for nested brackets which are invalid if \'[\' in int_list_string or \']\' in int_list_string: raise ValueError(\\"Invalid list string containing nested lists\\") # Split by comma and then filter empty strings raw_elements = [elem.strip() for elem in re.split(r\'[,s]+\', int_list_string) if elem.strip()] if not raw_elements: raise ValueError(\\"Empty list or invalid format\\") # Check for any non-integer values int_elements = [] for elem in raw_elements: if re.match(r\'^-?d+\', elem): int_elements.append(int(elem)) else: raise ValueError(\\"Non-integer value was passed to the function\\") return int_elements"},{"question":"# Manipulating Strings Based on Criteria **Context**: String manipulation is a common requirement in many software projects, particularly when dealing with text processing, data cleaning, and formatting. Dropping characters or modifying strings based on specific criteria is a frequent task that optimizes and cleans data inputs. **Problem Statement**: Implement a function `manipulate_string` that modifies a given string by removing vowels and reversing the order of characters selectively based on specified criteria. # Function Signature ```python def manipulate_string(input_string: str, drop_vowels: bool, reverse_substrings: bool) -> str: pass ``` # Input - **input_string (str)**: The input string to be manipulated. - **drop_vowels (bool)**: A boolean flag that indicates whether vowels (a, e, i, o, u) should be removed from the string. - **reverse_substrings (bool)**: A boolean flag that indicates whether the character order should be reversed within each contiguous block of non-vowel characters after vowel removal (if drop_vowels is True). # Output - **str**: The manipulated string based on the provided criteria. # Constraints 1. The input string will contain only lowercase English letters. 2. If `drop_vowels` is False, the original string\'s vowels should remain unchanged. 3. If `reverse_substrings` is True, the reversing operation should be applied after vowel removal (if applicable). # Examples ```python print(manipulate_string(\\"example\\", drop_vowels=True, reverse_substrings=False)) # Output: \\"xmpl\\" print(manipulate_string(\\"example\\", drop_vowels=True, reverse_substrings=True)) # Output: \\"lpmx\\" print(manipulate_string(\\"example\\", drop_vowels=False, reverse_substrings=True)) # Output: \\"elpmaxe\\" print(manipulate_string(\\"example\\", drop_vowels=False, reverse_substrings=False)) # Output: \\"example\\" ``` # Notes * Ensure your function handles input strings of different lengths efficiently. * You should account for cases where the input string contains only vowels or only consonants. * Handle cases where either or both criteria might not require any modifications to the input string. * Consider using regular expressions or string manipulation techniques available in Python for an efficient solution. **Testing**: Besides the provided examples, create additional test cases to validate your implementation: 1. Edge cases such as empty strings. 2. Strings containing only vowels. 3. Strings containing only consonants. 4. Different combinations of the boolean flags.","solution":"def manipulate_string(input_string: str, drop_vowels: bool, reverse_substrings: bool) -> str: vowels = \\"aeiou\\" if drop_vowels: input_string = \'\'.join([ch for ch in input_string if ch not in vowels]) if reverse_substrings: return input_string[::-1] return input_string"},{"question":"**Question: \\"Dynamic Inventory Management Using Simple Moving Average\\"** **Context**: In inventory management, predicting future demand is crucial for maintaining optimal stock levels. One common approach is to use the Simple Moving Average (SMA) method to smooth out demand fluctuations and forecast future demand based on past trends. **Task**: Implement the function `sma_forecast` to predict future inventory demand using the Simple Moving Average method. # Function Signature: ```python def sma_forecast(demand_history: List[int], window_size: int, forecast_period: int) -> List[float]: ``` # Input: - `demand_history` (List[int]): A list of historical demand values where each value represents demand for a specific period. - `window_size` (int): The number of periods over which to calculate the moving average. Must be positive and less than or equal to the length of `demand_history`. - `forecast_period` (int): The number of future periods for which to forecast demand. Must be positive. # Output: - Return a list of floats containing the forecasted demand for each of the upcoming `forecast_period` periods. # Constraints: - Handle edge cases such as when `demand_history` is empty, or `window_size` and `forecast_period` do not meet the constraints. - Assume that if there is not enough data to cover the window size, you cannot compute the moving average and should return an empty list. # Requirements: - Use the Simple Moving Average method to forecast future demand. - The function should be efficient and handle large input sizes gracefully. # Example: ```python # Example input demand_history = [100, 120, 130, 140, 150, 160, 180, 200] window_size = 3 forecast_period = 5 # Call the function forecasted_demand = sma_forecast(demand_history, window_size, forecast_period) # forecasted_demand should be [176.67, 176.67, 176.67, 176.67, 176.67] (assuming smooth trends) ``` In this example, the function should calculate the Simple Moving Average over the provided window size and use it to forecast future demands. The list `forecasted_demand` should contain forecasted values for the specified forecast period.","solution":"from typing import List def sma_forecast(demand_history: List[int], window_size: int, forecast_period: int) -> List[float]: Predict future inventory demand using the Simple Moving Average method. Parameters: demand_history (List[int]): A list of historical demand values. window_size (int): Number of periods over which to calculate the moving average. forecast_period (int): Number of future periods to forecast. Returns: List[float]: A list containing the forecasted demand for each of the upcoming forecast periods. if len(demand_history) < window_size or window_size <= 0 or forecast_period <= 0: return [] # Calculate the SMA for the last window_size periods sma = sum(demand_history[-window_size:]) / window_size # Forecast the same SMA for the given forecast period return [sma] * forecast_period"},{"question":"Problem Statement You are given a list of dates representing the start and end dates of various tasks in a project. Your task is to write a function to determine the maximum number of overlapping tasks at any given point in time. # Input - A list of tuples, where each tuple contains two dates (strings) in the format \\"YYYY-MM-DD\\", representing the start and end dates of a task. # Output - An integer representing the maximum number of tasks that overlap at any given time. # Constraints - Each date in the range \\"2000-01-01\\" ≤ date ≤ \\"2099-12-31\\" - The input list will contain at most 1000 tasks - Tasks are inclusive of their start and end dates - It is guaranteed that the start date is earlier than or equal to the end date for each task # Example Consider the following tasks: - Task A (\'2023-03-01\', \'2023-03-05\') - Task B (\'2023-03-02\', \'2023-03-06\') - Task C (\'2023-03-04\', \'2023-03-07\') - Task D (\'2023-03-08\', \'2023-03-10\') The function `max_overlapping_tasks([(\\"2023-03-01\\", \\"2023-03-05\\"), (\\"2023-03-02\\", \\"2023-03-06\\"), (\\"2023-03-04\\", \\"2023-03-07\\"), (\\"2023-03-08\\", \\"2023-03-10\\")])` should return `3`, as tasks A, B, and C overlap on \\"2023-03-04\\" and \\"2023-03-05\\". # Guidance To determine the maximum number of overlapping tasks, you can use a sweep line algorithm with two events for each task\'s start and end time. Implement the following helper functions: 1. `convert_to_date(date_str: str) -> datetime.date`: Converts a string date to a `datetime.date` object. 2. `max_overlapping_tasks(tasks: list[tuple[str, str]]) -> int`: Calculates the maximum number of overlapping tasks. # Sample Function Definition ```python def max_overlapping_tasks(tasks: list[tuple[str, str]]) -> int: # Your code here ``` # Note Ensure your solution covers edge cases and uses efficient algorithms to handle the input size within reasonable time limits.","solution":"from datetime import datetime def convert_to_date(date_str): Convert a date string in format \'YYYY-MM-DD\' to a datetime.date object. return datetime.strptime(date_str, \'%Y-%m-%d\').date() def max_overlapping_tasks(tasks): Calculate the maximum number of overlapping tasks at any given point in time. Args: tasks (list of tuples): A list of tuples, where each tuple contains two strings representing the start and end dates of a task in the format \'YYYY-MM-DD\'. Returns: int: The maximum number of tasks that overlap at any given time. events = [] # Convert task dates to events for start, end in tasks: start_date = convert_to_date(start) end_date = convert_to_date(end) events.append((start_date, \'start\')) events.append((end_date, \'end\')) # Sort events events.sort() max_overlap = 0 current_overlap = 0 # Sweep line algorithm for date, event_type in events: if event_type == \'start\': current_overlap += 1 max_overlap = max(max_overlap, current_overlap) elif event_type == \'end\': current_overlap -= 1 return max_overlap"},{"question":"Coding Assessment Question You are tasked with creating a utility that helps manage university course enrollments by assigning students to courses based on predefined prerequisites. You will develop a function that determines if a student can enroll in a specific course given their previously completed courses and the prerequisites of the desired course. # Function Signature ```python def can_enroll(student_courses: list, course: str, prerequisites: dict) -> bool: ``` # Objective Implement the `can_enroll` function that: 1. Takes three parameters: `student_courses`, `course`, and `prerequisites`. 2. Determines if the student can enroll in the desired `course` based on the courses they have already completed and the prerequisites of the desired course. # Input/Output Format * **Input**: * `student_courses` (list): A list of course names (strings) that the student has already completed. * `course` (str): The name of the course the student wishes to enroll in. * `prerequisites` (dict): A dictionary where the keys are course names and the values are lists of prerequisites (each list contains course names that must be completed before enrolling in the key course). * **Output**: * `bool`: Returns `True` if the student can enroll in the course, otherwise `False`. # Constraints * The dictionary `prerequisites` will not contain circular dependencies. * A course with no prerequisites may be missing from the dictionary or have an empty list as its value. * All courses and prerequisites referenced in the inputs exist in the context of a full course catalog. * `student_courses` may contain multiple entries, but course names in `student_courses` are assumed to be unique. * The `course` input will always be a valid course within the provided `prerequisites`. # Context This function will be a part of a larger system that manages student enrollments and course schedules. Proper validation of prerequisites ensures that students meet the necessary requirements before enrolling in advanced courses. # Performance Requirements * Ensure the function executes efficiently, considering all possible scenarios within the provided constraints. # Implementation Notes * Use Python list operations and dictionary lookups for efficient evaluation. * Focus on clear logic and readability in handling prerequisites. Design and implement the `can_enroll` function based on the above requirements.","solution":"def can_enroll(student_courses: list, course: str, prerequisites: dict) -> bool: Determines if the student can enroll in the given course based on previously completed courses and the prerequisites of the desired course. :param student_courses: List of courses the student has already completed :param course: The course the student wishes to enroll in :param prerequisites: Dictionary of courses with their respective list of prerequisites :return: True if the student can enroll in the course, otherwise False # Get the list of prerequisites for the chosen course course_prerequisites = prerequisites.get(course, []) # Check if all the prerequisites are in the student\'s completed courses list for prereq in course_prerequisites: if prereq not in student_courses: return False return True"},{"question":"# Scenario You are tasked with designing a library management system to help catalog books. Part of the system should allow you to add new books and query the catalog based on various criteria. One critical feature is sorting the book catalog in a user-defined order. # Task Write a class `LibraryCatalog` that can manage a collection of books and supports adding new books and sorting the catalog by different fields. # Class: `LibraryCatalog` Methods Method 1: `add_book` ```python def add_book(self, title: str, author: str, year: int) -> None ``` - Adds a new book to the catalog with the specified title, author, and publication year. Method 2: `sort_by_title` ```python def sort_by_title(self, ascending: bool = True) -> None ``` - Sorts the catalog by book titles in ascending or descending order based on the parameter \'ascending\'. Default value is `True`. Method 3: `sort_by_author` ```python def sort_by_author(self, ascending: bool = True) -> None ``` - Sorts the catalog by author names in ascending or descending order based on the parameter \'ascending\'. Default value is `True`. Method 4: `sort_by_year` ```python def sort_by_year(self, ascending: bool = True) -> None ``` - Sorts the catalog by publication year in ascending or descending order based on the parameter \'ascending\'. Default value is `True`. Example ```python catalog = LibraryCatalog() catalog.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) catalog.add_book(\\"1984\\", \\"George Orwell\\", 1949) catalog.add_book(\\"Brave New World\\", \\"Aldous Huxley\\", 1932) catalog.sort_by_title() assert catalog.books[0][\'title\'] == \\"1984\\" catalog.sort_by_author() assert catalog.books[0][\'author\'] == \\"Aldous Huxley\\" catalog.sort_by_year(ascending=False) assert catalog.books[0][\'year\'] == 1960 ``` # Constraints - The library should handle a reasonable number of books efficiently. - Implement error handling for invalid inputs. - Aim for a balance between readability and performance. # Notes - Ensure that your class and methods adhere to proper coding standards and practices. - Avoid duplication of functionality and optimize for clear logic in sorting and managing the books. - Think about the data structure that will allow easy sorting and retrieval of the book information.","solution":"class LibraryCatalog: def __init__(self): self.books = [] def add_book(self, title: str, author: str, year: int) -> None: Adds a new book to the catalog with the specified title, author, and publication year. book = {\'title\': title, \'author\': author, \'year\': year} self.books.append(book) def sort_by_title(self, ascending: bool = True) -> None: Sorts the catalog by book titles in ascending or descending order based on the parameter \'ascending\'. self.books.sort(key=lambda book: book[\'title\'], reverse=not ascending) def sort_by_author(self, ascending: bool = True) -> None: Sorts the catalog by author names in ascending or descending order based on the parameter \'ascending\'. self.books.sort(key=lambda book: book[\'author\'], reverse=not ascending) def sort_by_year(self, ascending: bool = True) -> None: Sorts the catalog by publication year in ascending or descending order based on the parameter \'ascending\'. self.books.sort(key=lambda book: book[\'year\'], reverse=not ascending)"},{"question":"# Scenario You are developing a new feature for a library management system that maintains real-time shelving, borrowing, and returning of books. The library system keeps an inventory of books using a hash table where each book\'s ISBN number is the key and the book information (such as title, author, and availability status) is the value. To improve the system, you need to implement a function to add, delete, and search for books using this hash table. # Task You must implement the `LibraryHashTable` class to manage the library\'s book inventory efficiently. The class should support operations to add a new book, delete a book, and search for a book by its ISBN number. # Specification **Class Signature**: ```python class LibraryHashTable: def __init__(self): Initializes an empty hash table for the library inventory. pass def add_book(self, isbn: str, book_info: dict) -> None: Adds a new book to the inventory using its ISBN as the key. Args: isbn: The ISBN number of the book as a string. book_info: A dictionary containing the book\'s information (title, author, and availability status). pass def delete_book(self, isbn: str) -> bool: Deletes a book from the inventory using its ISBN as the key. Args: isbn: The ISBN number of the book as a string. Returns: bool: True if the book was successfully deleted, False if the book was not found. pass def search_book(self, isbn: str) -> dict | None: Searches for a book in the inventory using its ISBN as the key. Args: isbn: The ISBN number of the book as a string. Returns: dict | None: A dictionary containing the book information if found, None if the book was not found. pass ``` # Input * `isbn` (str): The ISBN number of the book, formatted as a string. * `book_info` (dict): A dictionary containing the book\'s information with keys `title` (string), `author` (string), and `availability` (boolean). # Output * `add_book` (None): The method should not return any value. * `delete_book` (bool): Returns `True` if the book was successfully deleted, `False` if the book was not found. * `search_book` (dict | None): Returns a dictionary containing book information if found, otherwise `None`. # Performance Requirements * Average Case: O(1) for all operations (assuming a good hash function and load factor). # Constraints * ISBN number is unique for each book. * Ensure the hash table can handle up to 10^5 books efficiently. # Examples ```python library = LibraryHashTable() # Example of adding books library.add_book(\\"978-3-16-148410-0\\", {\\"title\\": \\"Book One\\", \\"author\\": \\"Author A\\", \\"availability\\": True}) library.add_book(\\"978-1-86197-876-9\\", {\\"title\\": \\"Book Two\\", \\"author\\": \\"Author B\\", \\"availability\\": False}) # Example of searching for books assert library.search_book(\\"978-3-16-148410-0\\") == {\\"title\\": \\"Book One\\", \\"author\\": \\"Author A\\", \\"availability\\": True} assert library.search_book(\\"978-1-86197-876-9\\") == {\\"title\\": \\"Book Two\\", \\"author\\": \\"Author B\\", \\"availability\\": False} assert library.search_book(\\"978-0-12-345678-9\\") is None # Example of deleting books assert library.delete_book(\\"978-3-16-148410-0\\") is True assert library.search_book(\\"978-3-16-148410-0\\") is None assert library.delete_book(\\"978-0-12-345678-9\\") is False ```","solution":"class LibraryHashTable: def __init__(self): Initializes an empty hash table for the library inventory. self.inventory = {} def add_book(self, isbn: str, book_info: dict) -> None: Adds a new book to the inventory using its ISBN as the key. Args: isbn: The ISBN number of the book as a string. book_info: A dictionary containing the book\'s information (title, author, and availability status). self.inventory[isbn] = book_info def delete_book(self, isbn: str) -> bool: Deletes a book from the inventory using its ISBN as the key. Args: isbn: The ISBN number of the book as a string. Returns: bool: True if the book was successfully deleted, False if the book was not found. if isbn in self.inventory: del self.inventory[isbn] return True return False def search_book(self, isbn: str) -> dict | None: Searches for a book in the inventory using its ISBN as the key. Args: isbn: The ISBN number of the book as a string. Returns: dict | None: A dictionary containing the book information if found, None if the book was not found. return self.inventory.get(isbn, None)"},{"question":"# Problem Statement Create a function to simulate basic bank account operations. The function must be capable of handling multiple types of transactions, including deposit, withdrawal, checking the balance, and returning the transaction history. The function should be flexible enough to handle an arbitrary number of operations specified in a list and return the results accordingly. # Requirements * Implement a class `BankAccount` that supports the following operations: - `deposit` - Add a specified amount to the balance. - `withdraw` - Subtract a specified amount from the balance if sufficient funds are available. - `check_balance` - Return the current balance. - `history` - Return the transaction history as a list of strings describing each completed operation. * Each method should update the account state appropriately and add a descriptive string to the transaction history. * Ensure the account object maintains proper encapsulation of the balance and transaction history. # Input and Output * **Input**: A list of transactions to be processed in order. Each transaction is a list where the first element is the operation name (`\\"deposit\\"`, `\\"withdraw\\"`, `\\"check_balance\\"`, or `\\"history\\"`), followed by parameters specific to the transaction. - Example: - `[[\\"deposit\\", 100], [\\"withdraw\\", 50], [\\"check_balance\\"], [\\"deposit\\", 200], [\\"history\\"]]` * **Output**: A list of results for any `check_balance` or `history` operations within the transaction sequence. For other operations, no output is needed. - Example: - `[50, 250, [\\"Deposited 100\\", \\"Withdrew 50\\", \\"Checked balance: 50\\", \\"Deposited 200\\"]]` # Constraints 1. All operations will follow the specified structure and will not contain invalid commands. 2. The input list of transactions will have at most 1000 operations. 3. Each amount (for deposit and withdrawal) will be a non-negative integer and fit within standard 32-bit signed integer range. # Example Scenarios Example 1: * **Input**: `[[\\"deposit\\", 100], [\\"withdraw\\", 50], [\\"check_balance\\"], [\\"deposit\\", 200], [\\"history\\"]]` * **Output**: `[50, 250, [\\"Deposited 100\\", \\"Withdrew 50\\", \\"Checked balance: 50\\", \\"Deposited 200\\"]]` Example 2: * **Input**: `[[\\"deposit\\", 1000], [\\"withdraw\\", 750], [\\"withdraw\\", 500], [\\"check_balance\\"], [\\"history\\"]]` * **Output**: `[250, [\\"Deposited 1000\\", \\"Withdrew 750\\", \\"Attempted to withdraw 500: Insufficient funds\\", \\"Checked balance: 250\\"]]` Write the class `BankAccount` and its methods to perform the operations as described.","solution":"class BankAccount: def __init__(self): self._balance = 0 self._history = [] def deposit(self, amount): self._balance += amount self._history.append(f\\"Deposited {amount}\\") def withdraw(self, amount): if amount <= self._balance: self._balance -= amount self._history.append(f\\"Withdrew {amount}\\") else: self._history.append(f\\"Attempted to withdraw {amount}: Insufficient funds\\") def check_balance(self): self._history.append(f\\"Checked balance: {self._balance}\\") return self._balance def get_history(self): return self._history def process_transactions(transactions): account = BankAccount() results = [] for transaction in transactions: if transaction[0] == \\"deposit\\": account.deposit(transaction[1]) elif transaction[0] == \\"withdraw\\": account.withdraw(transaction[1]) elif transaction[0] == \\"check_balance\\": results.append(account.check_balance()) elif transaction[0] == \\"history\\": results.append(account.get_history()) return results"},{"question":"# Coding Assessment Question Array Rotation Check: You are given two arrays, `arr1` and `arr2`, both containing unique integers. Your task is to determine if `arr2` is a rotation of `arr1`. One array is said to be a rotation of another if it can be obtained by shifting the elements of the other array to the right or left a certain number of times. For example, `[1, 2, 3, 4, 5]` when rotated right twice becomes `[4, 5, 1, 2, 3]`. Function Definition: Implement a function `is_rotation(arr1, arr2)` that takes in two lists of integers and returns `True` if `arr2` is a rotation of `arr1`, and `False` otherwise. Input: - Two lists of integers, `arr1` and `arr2`. Output: - A boolean value, `True` or `False`. Example: ```python >>> arr1 = [1, 2, 3, 4, 5] >>> arr2 = [3, 4, 5, 1, 2] >>> result = is_rotation(arr1, arr2) >>> print(result) True >>> arr1 = [1, 2, 3, 4, 5] >>> arr2 = [2, 3, 4, 5, 6] >>> result = is_rotation(arr1, arr2) >>> print(result) False ``` Constraints: 1. The length of both arrays will be equal and within the range [1, 1000]. 2. The elements in both arrays are unique integers. 3. The function should run in O(n) time complexity where n is the length of the arrays. Good luck!","solution":"def is_rotation(arr1, arr2): Determines if arr2 is a rotation of arr1. Parameters: arr1 (list of int): The first array. arr2 (list of int): The second array. Returns: bool: True if arr2 is a rotation of arr1, False otherwise. if len(arr1) != len(arr2): return False concatenated = arr1 + arr1 return \' \'.join(map(str, arr2)) in \' \'.join(map(str, concatenated))"},{"question":"# Problem Statement You are working on an e-commerce platform and are tasked with analyzing user shopping patterns. Given a list of `transactions` where each element is a tuple representing a transaction and contains a `user_id` and a `category`, your task is to find the top `k` categories with the highest number of unique users. Implement an efficient solution making sure the time complexity is within O(n log k) where `n` is the number of transactions. # Function Signature ```python def top_k_categories(transactions: list[tuple[int, str]], k: int) -> list[str]: pass ``` # Input * `transactions`: A list of tuples where each tuple is in the form `(user_id, category)`. * `k`: An integer determining the top number of categories to return. # Output * A list of strings representing the top `k` categories by unique user count. # Constraints * The length of `transactions` is `n` where `1 <= n <= 10^5`. * Each `user_id` and `category` are non-empty strings with a maximum length of 100. * `1 <= k <= 10^5`. # Performance Requirements * Your solution should run in O(n log k) time complexity. # Example ```python >>> top_k_categories([(1, \'electronics\'), (2, \'fashion\'), (1, \'fashion\'), (3, \'electronics\'), (4, \'books\'), (3, \'books\')], 2) [\'electronics\', \'fashion\'] >>> top_k_categories([(1, \'electronics\'), (2, \'fashion\'), (1, \'fashion\'), (3, \'electronics\'), (4, \'books\'), (3, \'books\')], 1) [\'electronics\'] >>> top_k_categories([(1, \'electronics\'), (2, \'fashion\'), (1, \'fashion\'), (3, \'electronics\'), (4, \'books\')], 3) [\'electronics\', \'fashion\', \'books\'] ``` # Notes * You should return the categories sorted by the number of unique users in descending order. * If two categories have the same number of unique users, their order in the output list can be arbitrary.","solution":"from collections import defaultdict from heapq import nlargest def top_k_categories(transactions, k): Finds the top k categories with the highest number of unique users. :param transactions: List of tuples (user_id, category). :param k: Integer representing the top number of categories to return. :return: List of top k categories by unique user count. # Dictionary to keep track of unique users per category category_user_count = defaultdict(set) # Populate the dictionary with user_id and category for user_id, category in transactions: category_user_count[category].add(user_id) # Convert the sets to their lengths to get unique user counts category_unique_users = {category: len(users) for category, users in category_user_count.items()} # Use heapq.nlargest to efficiently get the top k categories top_k = nlargest(k, category_unique_users, key=category_unique_users.get) return top_k"},{"question":"Maze Pathfinding with Breadth-First Search # Context You are given a grid representing a maze consisting of walls and open spaces. Your task is to determine the minimum number of moves required to reach the target destination from a given starting point. The maze allows you to move up, down, left, or right in the grid, but not through walls. # Task Implement a function `min_steps_to_target(maze: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> int` that finds the shortest path from the start position to the target position using breadth-first search (BFS). # Input Format - `maze`: A list of lists of integers representing the maze grid: - `0` represents an open space. - `1` represents a wall. - `start`: A tuple `(x, y)` representing the starting coordinates in the maze. - `target`: A tuple `(x, y)` representing the target coordinates in the maze. # Output Format - Return an integer representing the minimum number of moves required to reach the target from the start. If the target cannot be reached, return `-1`. # Function Signature ```python def min_steps_to_target(maze: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> int: ``` # Constraints 1. The size of the maze grid will be between `1x1` and `50x50`. 2. The start and target positions will always be within the bounds of the maze. 3. The maze will always contain valid start and target positions (i.e., these positions will be `0`). # Example ```python # Given maze: # [ # [0, 0, 1, 0, 0], # [0, 0, 0, 0, 0], # [0, 0, 1, 1, 0], # [1, 0, 1, 1, 0], # [0, 0, 0, 0, 0] # ] # Start: (0, 0) # Target: (4, 4) min_steps_to_target([ [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 1, 0], [1, 0, 1, 1, 0], [0, 0, 0, 0, 0] ], (0, 0), (4, 4)) -> 8 # Given maze: # [ # [0, 1, 0], # [0, 1, 0], # [0, 0, 0] # ] # Start: (0, 0) # Target: (2, 2) min_steps_to_target([ [0, 1, 0], [0, 1, 0], [0, 0, 0] ], (0, 0), (2, 2)) -> 4 ``` # Notes - Use a queue to implement the BFS and track visited positions. - Ensure to handle edge cases such as very small mazes or mazes filled with walls. - The solutions should be efficient and avoid excessive recalculations.","solution":"from collections import deque from typing import List, Tuple def min_steps_to_target(maze: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> int: # Initialize the directions for moving up, down, left, and right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] rows, cols = len(maze), len(maze[0]) queue = deque([(start[0], start[1], 0)]) # (x, y, steps) visited = set(start) while queue: x, y, steps = queue.popleft() # If we\'ve reached the target, return the number of steps if (x, y) == target: return steps # Explore all four possible directions for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and maze[nx][ny] == 0: queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) # If we\'ve exhausted all possibilities and haven\'t found the target, return -1 return -1"},{"question":"# Problem Statement Create a function that determines if a given integer is an Armstrong number. An Armstrong number (also known as a narcissistic number) of a three-digit number is one whose sum of the cubes of its digits is equal to the number itself. For example, 153 is an Armstrong number because 1^3 + 5^3 + 3^3 = 153. # Input The function should accept a single integer `num` where (100 <= num < 1000). # Output The function should return a boolean value: - `True` if the number is an Armstrong number. - `False` otherwise. # Constraints 1. Focus only on three-digit numbers. 2. Ensure the input is always a valid three-digit number. # Requirements 1. Implement the function `is_armstrong(num: int) -> bool` that adheres to the above constraints and solves the problem. 2. The solution should utilize mathematical operations to determine if the number is an Armstrong number. 3. Include appropriate comments and documentation for clarity. # Example ```python >>> is_armstrong(153) True >>> is_armstrong(370) True >>> is_armstrong(123) False ``` # Function Signature ```python def is_armstrong(num: int) -> bool: # Your code here pass ``` # Evaluation Your solution will be evaluated based on: 1. **Correctness**: Properly identifying Armstrong numbers as described. 2. **Efficiency**: The use of efficient and effective methods to carry out the task. 3. **Code Quality**: Clear, readable, and well-commented code.","solution":"def is_armstrong(num: int) -> bool: Determines if the given integer is an Armstrong number. Args: num (int): A three-digit integer. Returns: bool: True if the number is an Armstrong number, False otherwise. # Extract digits hundreds = num // 100 tens = (num // 10) % 10 units = num % 10 # Calculate the sum of cubes of the digits armstrong_sum = (hundreds ** 3) + (tens ** 3) + (units ** 3) # Check if the calculated sum matches the original number return armstrong_sum == num"},{"question":"# Sorting Integers with Custom Comparator You are given a list of integers and a custom comparator function that defines a specific sorting order based on some criteria. Your task is to write a function that sorts the integers according to the provided comparator. Objective: Implement the `custom_sort` function which sorts the integers based on the rules defined by a custom comparator function. The custom comparator will compare two integers and decide their order. # Input Format: 1. A list of integers `lst`. 2. A comparator function `cmp` that takes two integers as arguments and returns: - A negative integer if the first integer should come before the second. - Zero if the two integers are equal. - A positive integer if the first integer should come after the second. # Output Format: A list of integers sorted according to the provided comparator function. # Constraints: - The length of `lst` is between 1 and 10^4. - Each element in `lst` is an integer between -10^9 and 10^9. # Performance Requirements: - The function should efficiently handle the constraints. # Function Signature: ```python from typing import List, Callable def custom_sort(lst: List[int], cmp: Callable[[int, int], int]) -> List[int]: ``` # Example: ```python # Example 1 input: lst = [4, 2, 3, 1, 5] cmp = lambda x, y: x - y # Ascending order comparator output: [1, 2, 3, 4, 5] # Example 2 input: lst = [4, 2, 3, 1, 5] cmp = lambda x, y: y - x # Descending order comparator output: [5, 4, 3, 2, 1] # Example 3 input: lst = [4, 2, -3, 1, -5, 0] cmp = lambda x, y: abs(x) - abs(y) # Comparator for absolute values in ascending order output: [0, 1, 2, -3, 4, -5] ``` # Notes: - The custom comparator function `cmp` will only compare two integers at a time. - Ensure that the implementation makes use of the custom comparator correctly to determine the order of elements in the sorted list. - Think about the efficiency of your sorting approach given the potential size of the input list. # Challenge: Write the implementation of the `custom_sort` function as per the description above.","solution":"from typing import List, Callable def custom_sort(lst: List[int], cmp: Callable[[int, int], int]) -> List[int]: # Convert comparator to key for sorting from functools import cmp_to_key return sorted(lst, key=cmp_to_key(cmp))"},{"question":"# Problem Statement: Bank Transaction Tracker Context You have been hired by a bank to develop a utility function that helps customers track and categorize their bank transactions. Each transaction has a unique ID, a type (either \\"Debit\\" or \\"Credit\\"), an amount, and a category (such as \\"Groceries\\", \\"Utilities\\", or \\"Salary\\"). The bank wants to provide customers with summaries of their transactions based on these categories, allowing them to see the total amount debited or credited for each category. Task Implement the function `track_transactions(transaction_list: list) -> dict` that processes a list of transactions and provides summaries based on the categories. Function signature ```python def track_transactions(transaction_list: list) -> dict: ``` Input - `transaction_list`: A list of dictionaries where each dictionary contains: - `id` (string): A unique identifier for the transaction. - `type` (string): Either \\"Debit\\" or \\"Credit\\". - `amount` (float): The transaction amount. - `category` (string): Category of the transaction (e.g., \\"Groceries\\", \\"Utilities\\", \\"Salary\\"). Output - A dictionary where the keys are category names and the values are another dictionary with two keys: - `\\"debit\\"`: Total amount debited in that category. - `\\"credit\\"`: Total amount credited in that category. Constraints 1. If `type` is not \\"Debit\\" or \\"Credit\\", raise a `ValueError` with the message \\"Invalid transaction type: {type}\\". 2. If any transaction dictionary is missing a required key, raise a `ValueError` with the message \\"Transaction is missing key: {key}\\". 3. If the amount is negative, raise a `ValueError` with the message \\"Amount cannot be negative\\". Example ```python transaction_list = [ {\\"id\\": \\"T001\\", \\"type\\": \\"Debit\\", \\"amount\\": 150.75, \\"category\\": \\"Groceries\\"}, {\\"id\\": \\"T002\\", \\"type\\": \\"Credit\\", \\"amount\\": 2000.00, \\"category\\": \\"Salary\\"}, {\\"id\\": \\"T003\\", \\"type\\": \\"Debit\\", \\"amount\\": 75.50, \\"category\\": \\"Utilities\\"}, {\\"id\\": \\"T004\\", \\"type\\": \\"Debit\\", \\"amount\\": 50.25, \\"category\\": \\"Groceries\\"}, {\\"id\\": \\"T005\\", \\"type\\": \\"Credit\\", \\"amount\\": 100.00, \\"category\\": \\"Cashback\\"}, {\\"id\\": \\"T006\\", \\"type\\": \\"Credit\\", \\"amount\\": 150.00, \\"category\\": \\"Groceries\\"}, ] track_transactions(transaction_list) # Output: # { # \\"Groceries\\": {\\"debit\\": 201.0, \\"credit\\": 150.0}, # \\"Salary\\": {\\"debit\\": 0.0, \\"credit\\": 2000.0}, # \\"Utilities\\": {\\"debit\\": 75.5, \\"credit\\": 0.0}, # \\"Cashback\\": {\\"debit\\": 0.0, \\"credit\\": 100.0} # } ```","solution":"def track_transactions(transaction_list: list) -> dict: Processes a list of transactions and provides summaries based on the categories. summary = {} for transaction in transaction_list: # Validate transaction fields required_keys = {\\"id\\", \\"type\\", \\"amount\\", \\"category\\"} for key in required_keys: if key not in transaction: raise ValueError(f\\"Transaction is missing key: {key}\\") trans_type = transaction[\\"type\\"] amount = transaction[\\"amount\\"] category = transaction[\\"category\\"] # Validate transaction type if trans_type not in {\\"Debit\\", \\"Credit\\"}: raise ValueError(f\\"Invalid transaction type: {trans_type}\\") # Validate transaction amount if amount < 0: raise ValueError(f\\"Amount cannot be negative\\") if category not in summary: summary[category] = {\\"debit\\": 0.0, \\"credit\\": 0.0} if trans_type == \\"Debit\\": summary[category][\\"debit\\"] += amount elif trans_type == \\"Credit\\": summary[category][\\"credit\\"] += amount return summary"},{"question":"# Coding Assessment Question **Scenario**: You have been tasked to improve the existing `BinaryTree` class to support additional functionalities. Specifically, you need to add methods to perform an in-order traversal iteratively and recursively. Also, ensure that the class can correctly handle edge cases such as an empty tree or a tree with only a single node. **Requirements**: 1. **Tree Node Representation**: Use the `Node` class to represent each node in the binary tree. 2. **In-Order Traversal (Recursive & Iterative)**: Implement methods for both recursive and iterative in-order traversal. 3. **Edge Case Handling**: Ensure edge cases, such as an empty tree and a single-node tree, are handled appropriately. **Function Implementation**: 1. **recursive_inorder_traversal(node: \'Node\') -> List[int]** - Parameter: - `node`: The root node of the binary tree. - Returns a list of elements in in-order traversal using recursion. 2. **iterative_inorder_traversal() -> List[int]** - Returns a list of elements in in-order traversal using an iterative approach. 3. **Proper handling of edge cases**: - Ensure the implementation correctly handles an empty tree and a tree with a single node. **Input**: ```python # Creating the binary tree class Node: def __init__(self, key): self.left = None self.right = None self.val = key # Example Usage root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) # Tree structure: # 1 # / # 2 3 # / # 4 5 ``` **Output**: ```python # Expected Output for both recursive_inorder_traversal and iterative_inorder_traversal methods: # [4, 2, 5, 1, 3] # For an empty tree: # [] # For a tree with a single node: # [1] ``` **Constraints**: - The number of nodes in the binary tree can be up to 1000. - Node values are integers ranging from -10⁶ to 10⁶. Ensure your solution is tested with various tree structures and edge conditions to verify its robustness and correctness.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinaryTree: def __init__(self, root=None): self.root = root def recursive_inorder_traversal(self, node): Perform in-order traversal using recursion and return a list of node values. if node is None: return [] # In-order: left, root, right return (self.recursive_inorder_traversal(node.left) + [node.val] + self.recursive_inorder_traversal(node.right)) def iterative_inorder_traversal(self): Perform in-order traversal using iteration and return a list of node values. result, stack = [], [] current = self.root while stack or current: if current: stack.append(current) current = current.left else: current = stack.pop() result.append(current.val) current = current.right return result"},{"question":"# Problem Statement Given a list of integers, your task is to implement a function that returns a list of the unique elements in the order they first appear in the input list. If an element appears more than once in the input list, only include its first occurrence in the output list. # Function to Implement **Function**: `get_unique_elements(lst: List[int]) -> List[int]` # Input and Output Formats * **Input**: * `lst` (List[int]): A list of integers. * **Output**: * **List[int]**: A list containing the unique elements in the order they first appeared in the input list. # Constraints * The input list can be empty. * Elements of the input list are all integers. * The length of the list can be up to 10^5. * The integers can be both positive and negative, as well as zero. # Examples ```python assert get_unique_elements([1, 2, 2, 3, 4, 3, 5]) == [1, 2, 3, 4, 5] assert get_unique_elements([7, 8, 8, 8, 9, 7]) == [7, 8, 9] assert get_unique_elements([]) == [] assert get_unique_elements([1, 1, 1, 1, 1, 1, 1]) == [1] assert get_unique_elements([-1, -2, -2, -1, 0, 1, 0, 1, 2]) == [-1, -2, 0, 1, 2] ``` # Implementation Details * Use a set or any other appropriate data structure to keep track of elements that have already been seen. * Ensure the function is efficient with respect to both time and space complexity.","solution":"from typing import List def get_unique_elements(lst: List[int]) -> List[int]: seen = set() unique_elements = [] for num in lst: if num not in seen: seen.add(num) unique_elements.append(num) return unique_elements"},{"question":"# Scenario: You work for a company that provides automated solutions for generating reports. One of the requested reports involves analyzing customer purchase behavior by aggregating data from multiple CSV files. Each CSV file contains purchase records, and you need to process these files to provide summarized insights on total purchase amounts per customer. # Task: Write a Python function `aggregate_purchases` that takes in a list of file paths to CSV files and returns a dictionary where the keys are customer IDs and the values are the total purchase amounts. # Function Signature: ```python def aggregate_purchases(file_paths: list[str]) -> dict[str, float]: pass ``` # Input: - `file_paths` (list of str): List of absolute or relative paths to CSV files (e.g., [\\"data1.csv\\", \\"data2.csv\\"]). # Output: - Returns a dictionary with each customer ID as the key and the total purchase amount (float) as the value. # CSV File Structure: - Each CSV file has a header row with the columns: \\"customer_id\\" (str), \\"purchase_amount\\" (float). # Constraints: - The function should handle cases where some files might be missing or corrupted gracefully and skip those files. - Duplicate entries of the same customer within or across CSV files should be summed. - Use Python\'s built-in CSV module to read the files. - Assume each CSV file can fit into memory. # Example Usage: ```python # Assume \\"data1.csv\\" contains: # customer_id,purchase_amount # C001,250.5 # C002,150.0 # Assume \\"data2.csv\\" contains: # customer_id,purchase_amount # C002,100.5 # C003,300.0 file_paths = [\\"data1.csv\\", \\"data2.csv\\"] result = aggregate_purchases(file_paths) # Expected output: {\'C001\': 250.5, \'C002\': 250.5, \'C003\': 300.0} ```","solution":"import csv def aggregate_purchases(file_paths: list[str]) -> dict[str, float]: purchase_dict = {} for path in file_paths: try: with open(path, mode=\'r\', newline=\'\') as file: reader = csv.DictReader(file) for row in reader: customer_id = row[\'customer_id\'] purchase_amount = float(row[\'purchase_amount\']) if customer_id in purchase_dict: purchase_dict[customer_id] += purchase_amount else: purchase_dict[customer_id] = purchase_amount except (FileNotFoundError, IOError, ValueError, KeyError): # Gracefully skip the file if it\'s missing or corrupted continue return purchase_dict"},{"question":"# Linked List Reversal Challenge You are tasked with implementing functions to reverse a singly linked list. You should provide solutions to reverse the list iteratively and recursively. Implement the following functions: 1. `reverse_list_iter(head: ListNode) -> ListNode`: Reverses the linked list iteratively and returns the new head. 2. `reverse_list_recur(head: ListNode) -> ListNode`: Reverses the linked list recursively and returns the new head. # Expected Input and Output - Each function takes a `ListNode` object as input, representing the head of the linked list. - **Input constraint**: The list can have up to 10,000 nodes. Each node contains an integer data attribute. - The output is the new head of the reversed linked list, and the list itself should be reversed in place. # Example Suppose you have the following linked list: ``` 1 -> 2 -> 3 -> 4 -> 5 -> NULL ``` Iterative Reversal (expected output): ``` 5 -> 4 -> 3 -> 2 -> 1 -> NULL ``` Recursive Reversal (expected output): ``` 5 -> 4 -> 3 -> 2 -> 1 -> NULL ``` # Constraints: - You cannot use additional data structures (such as arrays or lists) to store nodes. - Ensure both functions are optimized for performance and do not introduce unnecessary overhead. Implement the functions ensuring they adhere to the above specifications and handle the given constraints effectively.","solution":"class ListNode: def __init__(self, data=0, next=None): self.data = data self.next = next def reverse_list_iter(head: ListNode) -> ListNode: prev = None current = head while current is not None: next_node = current.next current.next = prev prev = current current = next_node return prev def reverse_list_recur(head: ListNode) -> ListNode: if head is None or head.next is None: return head new_head = reverse_list_recur(head.next) head.next.next = head head.next = None return new_head"},{"question":"Problem Statement: Implement a function `count_subarrays_with_sum(arr: list[int], target: int) -> int` that takes a list of integers `arr` and an integer `target`, and returns the number of continuous subarrays whose sum equals the given `target`. # Requirements: 1. Use an efficient algorithm to avoid the exponential time complexity of a naive solution. Consider using a data structure or algorithm that optimally counts subarrays with a specific sum, such as the prefix sum technique combined with a hashmap. 2. Your function should return an integer representing the count of subarrays that match the target sum. # Constraints: - The input list `arr` consists of integers where `-10^4 <= arr[i] <= 10^4` - The length of `arr` is at most `10^5`. - The `target` sum is an integer within the range of `-10^9` to `10^9`. # Input: - `arr`: A list of integers. - `target`: An integer. # Output: - An integer representing the count of continuous subarrays whose sum equals `target`. # Example: **Input**: ```python arr = [1, 1, 1] target = 2 ``` **Output**: ```python 2 ``` **Input**: ```python arr = [1, 2, 3] target = 3 ``` **Output**: ```python 2 ``` **Input**: ```python arr = [-1, -1, 1, -1, 1] target = 0 ``` **Output**: ```python 4 ``` # Notes: Consider the trade-offs between time and space complexity when selecting your approach. Focus on achieving a solution with an optimal time complexity, ideally linear, like O(n). Use built-in data structures and features that facilitate quick calculations and efficient look-ups.","solution":"def count_subarrays_with_sum(arr, target): Returns the count of continuous subarrays whose sum equals the target. from collections import defaultdict count = 0 current_sum = 0 prefix_sums = defaultdict(int) prefix_sums[0] = 1 for num in arr: current_sum += num if current_sum - target in prefix_sums: count += prefix_sums[current_sum - target] prefix_sums[current_sum] += 1 return count"},{"question":"# Coding Challenge: Designing an Efficient Cache Replacement Algorithm As a software engineer working on a caching system, you are tasked with implementing an efficient cache replacement algorithm. Given the existing cache hits and misses, you need to optimize the cache update process by implementing the Least Recently Used (LRU) cache replacement policy. **Objective**: Implement a class that represents an LRU Cache. The class should include methods to access and update the cache, ensuring that the most recently used items are retained and the least recently used items are evicted when the cache reaches its maximum capacity. # Task **Class Signature**: ```python class LRUCache: def __init__(self, capacity: int): pass def get(self, key: int) -> int: pass def put(self, key: int, value: int) -> None: pass ``` **Inputs**: 1. `capacity (int)`: Maximum capacity of the cache. 2. `key (int)`: The key of the item being retrieved or added. 3. `value (int)`: The value of the item being added. **Outputs**: - **get**: Returns the value associated with the key if the key exists in the cache, otherwise returns -1. - **put**: Updates the value associated with the key if the key exists, otherwise adds the key-value pair to the cache. If the cache reaches its capacity, it should evict the least recently used item before inserting the new item. **Constraints**: - The cache will contain only non-negative integers for keys and values. - The capacity is a positive integer. # Example ```python cache = LRUCache(2) # Cache with capacity 2 cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) # Returns 1 cache.put(3, 3) print(cache.get(2)) # Returns -1 (not found) cache.put(4, 4) print(cache.get(1)) # Returns -1 (not found) print(cache.get(3)) # Returns 3 print(cache.get(4)) # Returns 4 ``` # Implementation Requirements - Implement the `LRUCache` class with the methods specified. - Use an efficient data structure to manage the order of elements and their lookup times. - Ensure that both `get` and `put` operations have an average time complexity of O(1). - Comprehensive test cases covering all the core functional requirements and edge cases.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 # Move the accessed key to the end to mark it as recently used self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: # Update the value and mark it as recently used self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: # Pop the first item from the cache (least recently used) self.cache.popitem(last=False)"},{"question":"# Question: **[Graph Theory] Maximum Network Flow** You are tasked with implementing a function to determine the maximum flow possible in a flow network. The network consists of nodes and directed edges where each edge has a certain capacity. The primary operations to support are: 1. **Maximum Flow Computation**: Determine the maximum amount of flow that can be sent from a source node `s` to a sink node `t`. # Implementation Details: **Function**: `max_flow(n: int, edges: list[tuple[int, int, int]], s: int, t: int) -> int` - `n` (int): The number of nodes in the network. - `edges` (list of tuples): Each tuple contains three integers `(u, v, w)` representing a directed edge from node `u` to node `v` with capacity `w`. - `s` (int): The source node from which the flow originates. - `t` (int): The sink node where the flow terminates. - Returns (int): The maximum flow from node `s` to node `t`. # Input and Output Formats: **Input**: - An integer `n` representing the number of nodes. - A list of tuples, each describing a directed edge with capacities. - Two integers `s` and `t` representing the source and sink nodes, respectively. **Output**: - An integer representing the maximum flow from the source `s` to the sink `t`. # Constraints: - (2 leq n leq 500) - (0 leq u, v < n) - (1 leq w leq 1000) - Multiple edges might exist between nodes, and cumulative flow should be considered. # Example: ```python n = 4 edges = [(0, 1, 1000), (1, 2, 1), (0, 2, 1000), (2, 3, 1000), (1, 3, 1000)] s = 0 t = 3 print(max_flow(n, edges, s, t)) # Output: 2000 ``` **Explanation**: - In the example, we have 4 nodes and 5 directed edges with specified capacities. - The maximum flow from node 0 (source) to node 3 (sink) is calculated based on the bottlenecks in the network. - In this example, the maximum possible flow from 0 to 3 can be 2000 units.","solution":"from collections import deque, defaultdict def bfs(capacity, s, t, parent): visited = set() queue = deque([s]) visited.add(s) while queue: u = queue.popleft() for v in capacity[u]: if v not in visited and capacity[u][v] > 0: # Check if not visited and there\'s available capacity queue.append(v) visited.add(v) parent[v] = u if v == t: return True return False def max_flow(n, edges, s, t): Implementation of the Edmonds-Karp algorithm for finding the maximum flow in a flow network. # Step 1: Set up the capacity matrix capacity = defaultdict(lambda: defaultdict(int)) for u, v, w in edges: capacity[u][v] += w # If multiple edges exist between u and v, sum their capacities parent = [-1] * n # This array is filled by BFS and to store path max_flow = 0 # Augment the flow while there is a path from source to sink while bfs(capacity, s, t, parent): # Find the maximum flow through the path found by BFS path_flow = float(\'Inf\') v = t while v != s: u = parent[v] path_flow = min(path_flow, capacity[u][v]) v = parent[v] # update residual capacities of the edges and reverse edges along the path v = t while v != s: u = parent[v] capacity[u][v] -= path_flow capacity[v][u] += path_flow v = parent[v] # Add path flow to overall flow max_flow += path_flow return max_flow"},{"question":"# Question: Custom Recursive Quick Sort Implement a custom variation of the recursive quick sort algorithm for a list of integers, which includes a condition to move certain values to the beginning of the list at the end of the sorting process. # Instructions: 1. **Function Signature**: Implement a function `custom_rec_quick_sort(collection: list[int], low: int, high: int, target_val: int) -> None` 2. **Parameters**: - `collection`: A list of integers that needs to be sorted. - `low`: The starting index of the list (typically 0). - `high`: The ending index of the list (typically `len(collection) - 1`). - `target_val`: An integer value that should be moved to the beginning of the list after sorting. 3. **Output**: The function should sort the collection in ascending order, and move any elements equal to `target_val` to the beginning of the list after sorting. 4. **Constraints**: - Do not use any additional data structures. - Handle edge cases such as empty arrays, arrays where all elements are the target value, etc. - Ensure the algorithm handles integer values correctly in the context of the target value. 5. **Performance**: Aim for an algorithm that has an average time complexity of O(n log n). # Example: ```python def custom_rec_quick_sort(collection: list[int], low: int, high: int, target_val: int) -> None: # Implementation here # Example Usage col = [3, 2, 1, 4, 3, 0, 2] target_val = 3 custom_rec_quick_sort(col, 0, len(col) - 1, target_val) print(col) # Expected Output: [3, 3, 0, 1, 2, 2, 4] ``` # Notes: * You can define and use helper functions similarly to `partition` and `quick_sort_rec` to implement the recursive quick sort. * After sorting, ensure that all elements equal to `target_val` are moved to the beginning in their original order from the sorted collection.","solution":"def partition(arr, low, high): i = low - 1 pivot = arr[high] for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i+1], arr[high] = arr[high], arr[i+1] return i + 1 def quick_sort_rec(arr, low, high): if low < high: pi = partition(arr, low, high) quick_sort_rec(arr, low, pi - 1) quick_sort_rec(arr, pi + 1, high) def custom_rec_quick_sort(collection: list[int], low: int, high: int, target_val: int) -> None: if not collection: return quick_sort_rec(collection, low, high) index = 0 for i in range(len(collection)): if collection[i] == target_val: collection.pop(i) collection.insert(index, target_val) index += 1"},{"question":"# Coding Assessment Question Scenario: In software development, it\'s common to work with data structures and their manipulation. One important concept is understanding how to efficiently manage and retrieve unique elements from a list, especially when the list is subject to frequent updates. Task: Write a Python function that takes a list of integers and returns a sorted list of the unique integers in ascending order. The function should handle large lists efficiently and accommodate frequent updates to the input list. Function Signature: ```python def get_unique_sorted(nums: List[int]) -> List[int]: ``` Input: * A list of integers `nums` (-10^6 ≤ nums[i] ≤ 10^6 for all i, 0 ≤ length of nums ≤ 10^6) Output: * A sorted list of unique integers in ascending order. Examples: ```python assert get_unique_sorted([4, 5, 6, 5, 4, 7]) == [4, 5, 6, 7] assert get_unique_sorted([1, 2, 2, 3, 3, 3]) == [1, 2, 3] assert get_unique_sorted([]) == [] assert get_unique_sorted([-1, -2, -3, -2, -1]) == [-3, -2, -1] assert get_unique_sorted([10, 9, 8, 7, 10, 8]) == [7, 8, 9, 10] ``` Notes: - Ensure that your function performs efficiently with large lists. - Avoid using built-in functions that immediately solve the problem; focus on the algorithmic approach. - Consider edge cases such as empty lists and lists with duplicate elements.","solution":"from typing import List def get_unique_sorted(nums: List[int]) -> List[int]: Returns a sorted list of the unique integers in ascending order. return sorted(set(nums))"},{"question":"# Question Context In many programming scenarios, particularly those involving data analysis or manipulation, it\'s crucial to efficiently determine the second smallest unique integer in a collection. This can be particularly useful in identifying outliers or patterns in data sets. Task Write a function `second_smallest` that returns the second smallest unique integer from a given list of integers. Function Signature ```python def second_smallest(arr: List[int]) -> int: ``` Input * `arr` – A list of integers, guaranteed to contain at least two unique elements. Output * Return the second smallest unique integer from the list. Constraints * The length of the list can range from `2` to `10^6`. * The integers can range from `-10^9` to `10^9`. Examples ```python assert second_smallest([4, 3, 1, 2, 5]) == 2 assert second_smallest([3, 3, 1, 2, 2]) == 2 assert second_smallest([-1, -1, 0, 1]) == 0 assert second_smallest([10, 3, 2, 2, 3]) == 3 assert second_smallest([7, -10, 5, 7, 3, 2, -10]) == 2 ``` Explanation * Iterate through the list to extract unique values and sort them. * Identify the second smallest unique number after sorting. * Consider edge cases where duplicates should not affect the identification of the second smallest unique value.","solution":"def second_smallest(arr): Returns the second smallest unique integer from the given list of integers. unique_values = sorted(set(arr)) if len(unique_values) < 2: raise ValueError(\\"The list must contain at least two unique integers.\\") return unique_values[1]"},{"question":"**Matrix Multiplication** You need to implement a function that multiplies two matrices represented as lists of lists. Each inner list corresponds to a row in the matrix. Function to Implement ```python def matrix_multiply(A, B): Multiply two matrices A and B. Each matrix is represented as a list of lists. Parameters: A (list of lists of floats): The first matrix to multiply. B (list of lists of floats): The second matrix to multiply. Returns: list of lists of floats: The resulting matrix product. pass ``` Input: * `A`: A list of `m` lists, each containing `n` floats. Represents an `m x n` matrix. * `B`: A list of `n` lists, each containing `p` floats. Represents an `n x p` matrix. Output: * Return a list of `m` lists, each containing `p` floats, representing the matrix product of `A` and `B`. Constraints: * `A`\'s number of columns (`n`) must match `B`\'s number of rows (`n`). * Ensure all matrix elements are valid floats. Performance Requirements: * Time Complexity: O(m * n * p) * Space Complexity: O(m * p) Example: ```python A = [ [1, 2, 3], [4, 5, 6] ] B = [ [7, 8], [9, 10], [11, 12] ] # Using the matrix_multiply function product = matrix_multiply(A, B) print(f\\"Resulting matrix product: {product}\\") ``` *Expected Output*: `Resulting matrix product: [[58, 64], [139, 154]]` *Note*: Do not use any third-party libraries or built-in matrix multiplication functions for this task.","solution":"def matrix_multiply(A, B): Multiply two matrices A and B. Each matrix is represented as a list of lists. Parameters: A (list of lists of floats): The first matrix to multiply. B (list of lists of floats): The second matrix to multiply. Returns: list of lists of floats: The resulting matrix product. # Number of rows in A m = len(A) # Number of columns in A (also number of rows in B) n = len(A[0]) # Number of columns in B p = len(B[0]) # Initialize the resulting matrix with zeros result = [[0 for _ in range(p)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): result[i][j] = sum(A[i][k] * B[k][j] for k in range(n)) return result"},{"question":"# Coding Assessment Question: Polynomial Root Finder Using Newton\'s Method Background Newton\'s Method (also known as the Newton-Raphson method) is an iterative root-finding algorithm that produces successively better approximations to the root (or zero) of a real-valued function. Given a differentiable function `f(x)` and its derivative `f\'(x)`, the method starts from an initial guess `x0` and iterates using the formula: [ x_{n+1} = x_n - frac{f(x_n)}{f\'(x_n)} ] until the difference between successive approximations is smaller than a specified tolerance. Task Implement Newton\'s Method to find a root of a given polynomial function. The polynomial will be represented as a list of its coefficients. Input * A list of float values `coefficients` representing the polynomial coefficients. For example, `[a_n, a_{n-1}, ..., a_1, a_0]` represents the polynomial ( a_n x^n + a_{n-1} x^{n-1} + ... + a_1 x + a_0 ). * A float value `initial_guess`, the starting point for Newton\'s Method. * A float value `tolerance`, indicating the error threshold for convergence. * An integer `max_iterations`, the maximum number of iterations to perform if convergence is slow. Output * A float representing the approximate root of the polynomial, or None if the method fails to converge within the maximum iterations. Constraints * The polynomial degree (length of the coefficients list - 1) will be at least 1. * Tolerance > 0 and should be small (e.g., 0.0001 or smaller). * max_iterations > 0 and will generally be large (e.g., 1000 or more). Example ```python def polynomial_function(coefficients, x): return sum(c * x**i for i, c in enumerate(reversed(coefficients))) def polynomial_derivative(coefficients, x): return sum(i * c * x**(i-1) for i, c in enumerate(reversed(coefficients)) if i != 0) def newtons_method(coefficients, initial_guess, tolerance, max_iterations): x = initial_guess for i in range(max_iterations): f_x = polynomial_function(coefficients, x) f_prime_x = polynomial_derivative(coefficients, x) if f_prime_x == 0: return None x_new = x - f_x / f_prime_x if abs(x - x_new) < tolerance: return x_new x = x_new return None # Test case coefficients = [1, 0, -4, 4] initial_guess = 1.5 tolerance = 0.0001 max_iterations = 1000 print(newtons_method(coefficients, initial_guess, tolerance, max_iterations)) # Expected Output: approximately the root of x^3 - 4x + 4 starting from 1.5 ``` Feel free to expand and adapt this solution to your specific needs.","solution":"def polynomial_function(coefficients, x): return sum(c * x**i for i, c in enumerate(reversed(coefficients))) def polynomial_derivative(coefficients, x): return sum(i * c * x**(i-1) for i, c in enumerate(reversed(coefficients)) if i != 0) def newtons_method(coefficients, initial_guess, tolerance, max_iterations): x = initial_guess for i in range(max_iterations): f_x = polynomial_function(coefficients, x) f_prime_x = polynomial_derivative(coefficients, x) if f_prime_x == 0: return None x_new = x - f_x / f_prime_x if abs(x - x_new) < tolerance: return x_new x = x_new return None"},{"question":"# Unique Character Counter Scenario A software developer is examining strings to ensure that the inputs to a function contain a unique set of characters. Your task is to create a function that takes a string and returns the count of unique characters in the string. Function Signature ```python def unique_char_count(s: str) -> int: pass ``` Input A string `s` where `1 ≤ len(s) ≤ 10^6`. Output An integer representing the count of unique characters in the string. Example ```python assert unique_char_count(\\"hello\\") == 4 # The unique characters are h, e, l, and o. assert unique_char_count(\\"abcd\\") == 4 # The unique characters are a, b, c, and d. assert unique_char_count(\\"aaaaa\\") == 1 # The unique character is a. ``` Constraints * You may assume that the input will always be a valid string containing only lowercase alphabets. * Aim for a solution that processes the string efficiently and scales well with the maximum input size. Guidelines * Utilize a data structure that allows for efficient membership checking and insertion (e.g., a set). * Traverse the string to build the set of unique characters. * Return the size of the set as the count of unique characters. * Ensure your implementation runs efficiently within the given constraints.","solution":"def unique_char_count(s: str) -> int: Returns the count of unique characters in the string s. return len(set(s))"},{"question":"# Problem Statement You are tasked with determining whether a given integer `n` can be expressed as the sum of two or more consecutive positive integers. Write a function `can_be_expressed` that takes an integer `n` and returns a boolean value indicating whether `n` can be represented as the sum of two or more consecutive positive integers. # Function Signature ```python def can_be_expressed(n: int) -> bool: pass ``` # Input - An integer `n` (1 ≤ n ≤ 10^9) # Output - A boolean value: `True` if `n` can be expressed as the sum of two or more consecutive positive integers, otherwise `False`. # Constraints - Use efficient algorithms to find the sum of consecutive integers to check expressibility. - Ensure the function completes within a reasonable time frame for large values of `n`. # Performance Requirements - Aim for the best possible time complexity, ideally O(sqrt(n)) or better. - Ensure space complexity is O(1). # Example ```python >>> can_be_expressed(15) True >>> can_be_expressed(10) True >>> can_be_expressed(7) False >>> can_be_expressed(21) True ``` # Notes - Consecutive positive integers imply that we\'re looking for sequences like `1, 2, 3, 4, 5...` or `4, 5, 6, 7, 8` etc. - Consider mathematical patterns and properties of sums to optimize your solution.","solution":"def can_be_expressed(n: int) -> bool: Determine if n can be expressed as the sum of two or more consecutive positive integers. # A number can be expressed as the sum of two or more consecutive positive integers if and only if it is not a power of 2 if n < 3: return False return (n & (n - 1)) != 0"},{"question":"Path Finding in a Weighted Grid You need to implement a function to find the shortest path from the top-left corner to the bottom-right corner of a weighted grid. The grid is represented by a 2D list where each cell contains a non-negative integer representing the cost to travel through that cell. Given the constraints of the grid dimensions, design your solution using the Dijkstra algorithm, ensuring optimal path calculation. Your task is to write a function `shortest_path` that returns the minimum cost to reach the bottom-right corner of the grid from the top-left corner. Requirements: 1. The function `shortest_path(grid: List[List[int]]) -> int` should take a 2D list representing the grid and return an integer representing the minimum cost. 2. The grid dimensions will be given by `m x n`, where `m` and `n` are both at most 100. 3. In the grid, you can only move to adjacent cells (right, down). # Input and Output Formats: 1. **Input**: - `grid` (List[List[int]]): A 2D list where each entry is a non-negative integer representing the travel cost. 2. **Output**: - An integer representing the minimum cost to reach the bottom-right corner of the grid from the top-left corner. # Constraints: - ( text{1} leq text{m}, text{n} leq 100 ) - ( text{0} leq text{grid}[i][j] leq 100 ) # Example: Input: ```python grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] ``` Output: ```python 7 ``` # Explanation: Following the path 1 -> 3 -> 1 -> 1 -> 1 -> 1 provides the minimum cost of 7. # Implementation: You can implement the function as follows: ```python from typing import List, Tuple import heapq def shortest_path(grid: List[List[int]]) -> int: m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0)] # right, down min_heap = [(grid[0][0], 0, 0)] # (cost, row, col) costs = {(0, 0): grid[0][0]} while min_heap: cost, r, c = heapq.heappop(min_heap) if (r, c) == (m - 1, n - 1): return cost for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n: new_cost = cost + grid[nr][nc] if (nr, nc) not in costs or new_cost < costs[(nr, nc)]: costs[(nr, nc)] = new_cost heapq.heappush(min_heap, (new_cost, nr, nc)) # Example usage: grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(shortest_path(grid)) # Output: 7 ``` Make sure to test your function with different grid sizes and values to ensure it works within the constraints and accurately calculates the shortest path.","solution":"from typing import List, Tuple import heapq def shortest_path(grid: List[List[int]]) -> int: Finds the shortest path from the top-left corner to the bottom-right corner in a weighted grid using Dijkstra\'s algorithm. m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0)] # right, down min_heap = [(grid[0][0], 0, 0)] # (cost, row, col) costs = {(0, 0): grid[0][0]} while min_heap: cost, r, c = heapq.heappop(min_heap) if (r, c) == (m - 1, n - 1): return cost for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n: new_cost = cost + grid[nr][nc] if (nr, nc) not in costs or new_cost < costs[(nr, nc)]: costs[(nr, nc)] = new_cost heapq.heappush(min_heap, (new_cost, nr, nc)) # Example usage: grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(shortest_path(grid)) # Output: 7"},{"question":"# Problem: Merge Two Sorted Arrays You have been tasked with merging two sorted arrays into a single sorted array. Write a function to accomplish this without using the built-in sorting functionalities. Problem Statement Given two sorted arrays `arr1` and `arr2`, write a function to merge them into a single sorted array. Implement the function `merge_sorted_arrays(arr1: list[int], arr2: list[int]) -> list[int]`: * **Input**: Two sorted arrays `arr1` and `arr2`. * **Output**: A single sorted array that contains all the elements from `arr1` and `arr2`. Constraints * The arrays can be of different lengths. * The elements in each array are integers within the range of ([-10^9, 10^9]). * The combined length of `arr1` and `arr2` will not exceed (10^6). Example ```python >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([-5, 0, 2], [-3, 4, 10]) [-5, -3, 0, 2, 4, 10] >>> merge_sorted_arrays([1, 10, 100], [0, 5, 50]) [0, 1, 5, 10, 50, 100] ``` Guidelines * **Edge Cases**: Consider cases where one or both arrays are empty. * **Performance**: Aim for a time complexity of (O(m + n)), where (m) and (n) are the lengths of `arr1` and `arr2` respectively. * **Memory**: Create a new array only once for optimal space complexity. * Ensure the function does not use any built-in sorting functions or libraries. Output your function in the following format: ```python def merge_sorted_arrays(arr1: list[int], arr2: list[int]) -> list[int]: # Your implementation goes here ```","solution":"def merge_sorted_arrays(arr1: list[int], arr2: list[int]) -> list[int]: Merges two sorted arrays into one sorted array. merged = [] i, j = 0, 0 len1, len2 = len(arr1), len(arr2) while i < len1 and j < len2: if arr1[i] < arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 while i < len1: merged.append(arr1[i]) i += 1 while j < len2: merged.append(arr2[j]) j += 1 return merged"},{"question":"# Longest Common Subsequence with Memoization You are required to implement an efficient version of the Longest Common Subsequence (LCS) problem using memoization to avoid redundant calculations and exponential time complexity. **Scenario**: A software development company is analyzing two versions of their codebase to determine the longest sequence of operations that occur in both versions. They\'ve provided two lists of operations for this purpose. Develop a function to determine the length of the longest common subsequence (LCS) between these two lists. **Function Specification**: ```python def longest_common_subsequence_memoization(list1: list, list2: list) -> int: :param list1: List of operations in the first version. :param list2: List of operations in the second version. :return: Length of the longest common subsequence. ``` **Input and Output Formats**: * Input: * `list1` – List of operations (non-empty strings) in the first version. * `list2` – List of operations (non-empty strings) in the second version. * Output: * An integer representing the length of the longest common subsequence. **Constraints**: * `1 <= len(list1), len(list2) <= 1000` * Each list contains non-empty strings with 1 to 100 characters. **Performance Requirements**: * Ensure your solution runs efficiently with the given constraints using memoization. **Examples**: ```python # Example 1 print(longest_common_subsequence_memoization( [\\"init\\", \\"add\\", \\"commit\\", \\"push\\"], [\\"init\\", \\"merge\\", \\"commit\\", \\"push\\"] )) # Output: 3 # Example 2 print(longest_common_subsequence_memoization( [\\"login\\", \\"edit\\", \\"save\\", \\"logout\\"], [\\"login\\", \\"edit\\", \\"delete\\", \\"logout\\"] )) # Output: 3 ``` Ensure your function handles edge cases properly and runs efficiently within the provided constraints.","solution":"def longest_common_subsequence_memoization(list1, list2): Returns the length of the longest common subsequence (LCS) between two lists. Utilizes memoization for efficiency. :param list1: List of operations in the first version. :param list2: List of operations in the second version. :return: Length of the longest common subsequence. memo = {} def lcs_helper(i, j): if i == len(list1) or j == len(list2): return 0 if (i, j) in memo: return memo[(i, j)] if list1[i] == list2[j]: memo[(i, j)] = 1 + lcs_helper(i + 1, j + 1) else: memo[(i, j)] = max(lcs_helper(i + 1, j), lcs_helper(i, j + 1)) return memo[(i, j)] return lcs_helper(0, 0)"},{"question":"# Problem Statement You are tasked with implementing a solution to find the n-th lexicographical permutation of a given list of unique numbers. The lexicographical permutations of a list are permutations in dictionary order and differ from arrangements based on the magnitude of the numbers. # Detailed Requirements 1. **Input**: - A list `numbers` of unique integers. - An integer `n` which denotes the position of the required permutation in lexicographical order. 2. **Output**: - A list of integers representing the n-th permutation in lexicographical order. 3. **Constraints**: - `1 ≤ len(numbers) ≤ 10` - `1 ≤ n ≤ factorial(len(numbers))` # Example Consider the list `[1, 2, 3]` which has six permutations in lexicographical order: 1. [1, 2, 3] 2. [1, 3, 2] 3. [2, 1, 3] 4. [2, 3, 1] 5. [3, 1, 2] 6. [3, 2, 1] Given `n = 4` the function should return `[2, 3, 1]`. # Instructions: 1. Implement the `find_nth_permutation(numbers, n)` function to calculate the n-th lexicographical permutation. 2. Utilize efficient methods or algorithms to determine the required permutation without generating all permutations explicitly. # Performance Your implementation should ensure it finds the permutation efficiently, especially for the upper constraint limits. ```python from math import factorial def find_nth_permutation(numbers, n): Find the n-th lexicographical permutation of the list of integers. :param numbers: List of unique integers. :param n: The position (1-based) of the desired permutation in lexicographical order. :return: The n-th permutation as a list of integers. result = [] k = n - 1 # Convert to 0-based index nums = sorted(numbers) while nums: f = factorial(len(nums) - 1) index = k // f result.append(nums.pop(index)) k %= f return result # Example usage print(find_nth_permutation([1, 2, 3], 4)) # Output: [2, 3, 1] ``` Test your function with various inputs to ensure correctness and efficiency.","solution":"from math import factorial def find_nth_permutation(numbers, n): Find the n-th lexicographical permutation of the list of integers. :param numbers: List of unique integers. :param n: The position (1-based) of the desired permutation in lexicographical order. :return: The n-th permutation as a list of integers. result = [] k = n - 1 # Convert to 0-based index nums = sorted(numbers) while nums: f = factorial(len(nums) - 1) index = k // f result.append(nums.pop(index)) k %= f return result"},{"question":"# Question: Minimum Window Subsequence You are given two strings `S` and `T`. Your task is to find the minimum window in `S` which contains all the characters (in order, including duplicates) in `T`. If there is no such window in `S` that covers all characters in `T`, return an empty string. Function Signature ```python def min_window_subsequence(S: str, T: str) -> str: pass ``` Input * A string `S` containing only lowercase English letters. * A string `T` containing only lowercase English letters. Output * The minimum window in `S` which contains all characters in order in `T` or an empty string if no such window exists. Constraints * The length of `S` is at most `10^4`. * The length of `T` is at most `100`. Examples ```python >>> min_window_subsequence(\\"abcdebdde\\", \\"bde\\") \\"bcde\\" >>> min_window_subsequence(\\"jmeqksfrsdcmsiwvaovztaqenprpvnbstl\\", \\"k\\") \\"k\\" >>> min_window_subsequence(\\"abdec\\", \\"ec\\") \\"ec\\" >>> min_window_subsequence(\\"abc\\", \\"xyz\\") \\"\\" >>> min_window_subsequence(\\"\\", \\"a\\") \\"\\" ``` Notes 1. There can be multiple possible answers; return the window that appears first. 2. Aim for both efficient time and space complexity when designing your solution. # Scenario In a document editor software, you need to highlight the shortest sequence of text where a particular formula (as a sequence of characters) appears in order. Implement the `min_window_subsequence` function to achieve this.","solution":"def min_window_subsequence(S: str, T: str) -> str: m, n = len(S), len(T) dp = [[-1] * n for _ in range(m)] # Base case for the first character of T for i in range(m): if S[i] == T[0]: dp[i][0] = i # Fill the dp array for j in range(1, n): prev = -1 for i in range(m): if prev != -1 and S[i] == T[j]: dp[i][j] = prev if dp[i][j - 1] != -1: prev = dp[i][j - 1] # Find the minimum window min_len = float(\'inf\') start_index = -1 for i in range(m): if dp[i][n - 1] != -1: if i - dp[i][n - 1] + 1 < min_len: min_len = i - dp[i][n - 1] + 1 start_index = dp[i][n - 1] return \\"\\" if start_index == -1 else S[start_index:start_index + min_len]"},{"question":"# Question You have been tasked with developing a library system that tracks books currently loaned out and allows for returning of borrowed books. The goal is to implement a system that can maintain the state of borrowed books, track the return dates, and capture the fine for late returns. The fine is calculated at 0.50 per day after the due date. Your task is to implement a class `Library` with the following methods: 1. `borrow_book(self, title: str, due_date: str) -> None`: Record that a book has been borrowed, providing the book\'s title and the due date (in \\"YYYY-MM-DD\\" format). 2. `return_book(self, title: str, return_date: str) -> float`: Process the return of a borrowed book, calculate any late fees, remove the book from the borrowed list, and return the total fine. Class Definition ```python class Library: def __init__(self): Initializes an empty Library instance. pass def borrow_book(self, title: str, due_date: str) -> None: Records the borrowing of a book with the given title and due date. Parameters: title: The title of the book being borrowed. due_date: The due date for returning the book, formatted as \\"YYYY-MM-DD\\". pass def return_book(self, title: str, return_date: str) -> float: Processes the return of a book and calculates the fine amount if it is returned late. Parameters: title: The title of the book being returned. return_date: The actual return date of the book, formatted as \\"YYYY-MM-DD\\". Returns: float: The calculated fine based on the days late. pass ``` Constraints * The due date and return date will always be valid dates in \\"YYYY-MM-DD\\" format. * A book returned on or before the due date incurs no fine. * The fine for a late return is 0.50 per day after the due date. * No books with the same title will be borrowed more than once without being returned. Example ```python library = Library() # Borrow two books library.borrow_book(\\"The Great Gatsby\\", \\"2023-10-10\\") library.borrow_book(\\"1984\\", \\"2023-10-15\\") # Return one book on time fine1 = library.return_book(\\"The Great Gatsby\\", \\"2023-10-10\\") # Expected fine: 0.0 # Return another book late fine2 = library.return_book(\\"1984\\", \\"2023-10-20\\") # Expected fine: 2.5 ``` Ensure that your implementation correctly tracks the borrowed books, calculates the fine based on the dates provided, and handles the return of books efficiently.","solution":"from datetime import datetime class Library: def __init__(self): Initializes an empty Library instance. self.borrowed_books = {} def borrow_book(self, title: str, due_date: str) -> None: Records the borrowing of a book with the given title and due date. Parameters: title: The title of the book being borrowed. due_date: The due date for returning the book, formatted as \\"YYYY-MM-DD\\". self.borrowed_books[title] = due_date def return_book(self, title: str, return_date: str) -> float: Processes the return of a book and calculates the fine amount if it is returned late. Parameters: title: The title of the book being returned. return_date: The actual return date of the book, formatted as \\"YYYY-MM-DD\\". Returns: float: The calculated fine based on the days late. due_date = self.borrowed_books.pop(title, None) if due_date is None: return 0.0 # or raise an error since the book was not borrowed due_date_dt = datetime.strptime(due_date, \\"%Y-%m-%d\\") return_date_dt = datetime.strptime(return_date, \\"%Y-%m-%d\\") if return_date_dt <= due_date_dt: return 0.0 else: late_days = (return_date_dt - due_date_dt).days fine = late_days * 0.50 return fine"},{"question":"# Task: Implement a Custom Filter Function Context You have been asked to implement a custom filtering mechanism in a list of integers based on a specified cutoff value. The aim is to familiarize students with iteration, condition checking, and list manipulation. Objective Write a function `custom_filter` that takes a list of integers and a cutoff value, and returns a new list containing only the integers from the original list that are greater than or equal to the cutoff value. # Function Signature ```python def custom_filter(values: list[int], cutoff: int) -> list[int]: pass ``` # Input * **values** (list[int]): A list of integers. * **cutoff** (int): The cutoff value used for filtering. # Output * **list[int]**: A new list containing only the integers from the original list that are greater than or equal to the cutoff value. # Constraints * The length of the values list will be in the range [0, 1000]. * Each element in the values list will be an integer in the range [-10000, 10000]. * The cutoff value will be an integer in the range [-10000, 10000]. # Example Scenarios Example 1 * **Input**: values = [1, 5, 8, 10, -2], cutoff = 5 * **Output**: [5, 8, 10] * **Explanation**: Only the elements that are greater than or equal to 5 are included in the output list. Example 2 * **Input**: values = [0, -3, 7, 12, 15], cutoff = 0 * **Output**: [0, 7, 12, 15] * **Explanation**: Only the elements that are greater than or equal to 0 are included in the output list. Example 3 * **Input**: values = [9, 4, 2, 6], cutoff = 10 * **Output**: [] * **Explanation**: No elements are greater than or equal to 10, hence the output list is empty. # Performance Requirements * The function should operate in O(n) time complexity, where n is the number of elements in the values list. # Points to Consider * Handle edge cases such as an empty list or a cutoff value that excludes all elements.","solution":"def custom_filter(values: list[int], cutoff: int) -> list[int]: Returns a list containing only the integers from the original list that are greater than or equal to the cutoff value. Args: values (list[int]): The list of integers to filter. cutoff (int): The cutoff value used for filtering. Returns: list[int]: A new list containing only the integers that are greater than or equal to the cutoff value. return [value for value in values if value >= cutoff]"},{"question":"# Context You are tasked with creating a simple reservation system for a library. The system needs to manage the reservations for study rooms where users can book a room for a specified time period. Each room can only be booked by one user at a time. # Problem Statement Write a function `reserve_room(room_id: int, start_time: str, end_time: str) -> str` that allows a user to book a study room. The function should check whether the room is already booked for the desired time period and either confirm the reservation or inform the user that the room is unavailable. Function Signature ```python def reserve_room(room_id: int, start_time: str, end_time: str) -> str: pass ``` Input - `room_id` (int): The ID of the room to be reserved. - `start_time` (str): The start time of the reservation in the format \\"YYYY-MM-DD HH:MM\\". - `end_time` (str): The end time of the reservation in the format \\"YYYY-MM-DD HH:MM\\". Output - (str): A message confirming the reservation or indicating that the room is unavailable. # Requirements 1. The function should handle overlapping reservations and prevent double booking. 2. Provide clear error messages if the input times are invalid (e.g., end time before start time, non-existent times). 3. Ensure that the reservation can only be made during library hours (e.g., 08:00 to 20:00). 4. Handle edge cases such as a room being booked at the very beginning or end of the available time. 5. All times are given in the local time zone, and the library operates in a single time zone. Example ```python # Assume this function is called with a reservation system backend that stores and retrieves reservations. print(reserve_room(101, \\"2023-11-20 09:00\\", \\"2023-11-20 10:00\\")) # Expected output: \\"Reservation confirmed for room 101 from 2023-11-20 09:00 to 2023-11-20 10:00\\" print(reserve_room(101, \\"2023-11-20 09:30\\", \\"2023-11-20 10:30\\")) # Expected output: \\"Room 101 is unavailable from 2023-11-20 09:30 to 2023-11-20 10:30\\" ``` # Constraints - Room IDs are positive integers. - The reservation time should not overlap with existing reservations for the same room. - Handles up to 1000 reservations for each room. # Notes 1. You may use a dictionary or database to store the room reservations, where the key is the room ID, and the value is a list of reservations (start time and end time tuples). 2. Make sure to validate the time format and the logical correctness of times (e.g., start time before end time). 3. The function should be modular and allow easy integration with a broader reservation system.","solution":"from datetime import datetime reservations = {} LIBRARY_OPEN_TIME = \\"08:00\\" LIBRARY_CLOSE_TIME = \\"20:00\\" def reserve_room(room_id, start_time, end_time): Reserve a room if it\'s available for the given time period. try: start_dt = datetime.strptime(start_time, \\"%Y-%m-%d %H:%M\\") end_dt = datetime.strptime(end_time, \\"%Y-%m-%d %H:%M\\") if start_dt >= end_dt: return \\"End time must be after start time\\" library_open_dt = datetime.strptime(f\\"{start_dt.strftime(\'%Y-%m-%d\')} {LIBRARY_OPEN_TIME}\\", \\"%Y-%m-%d %H:%M\\") library_close_dt = datetime.strptime(f\\"{start_dt.strftime(\'%Y-%m-%d\')} {LIBRARY_CLOSE_TIME}\\", \\"%Y-%m-%d %H:%M\\") if start_dt < library_open_dt or end_dt > library_close_dt: return \\"Reservation time must be within library hours (08:00 to 20:00)\\" if room_id not in reservations: reservations[room_id] = [] for reservation in reservations[room_id]: existing_start, existing_end = reservation if start_dt < existing_end and end_dt > existing_start: return f\\"Room {room_id} is unavailable from {start_time} to {end_time}\\" reservations[room_id].append((start_dt, end_dt)) reservations[room_id].sort() return f\\"Reservation confirmed for room {room_id} from {start_time} to {end_time}\\" except ValueError: return \\"Invalid time format. Please use \'YYYY-MM-DD HH:MM\'.\\""},{"question":"# Sorting Algorithm: Merge Sort Implementation Merge sort is a divide-and-conquer algorithm that sorts a list by dividing it into smaller sublists, sorting those sublists, and then merging them back together. The steps of the merge sort algorithm are as follows: 1. **Divide**: Divide the unsorted list into n sublists, each containing one element. 2. **Conquer**: Recursively sort the sublists. 3. **Merge**: Merge the sorted sublists to produce new sorted sublists until there is only one sorted list. # Task Implement the merge sort algorithm to sort an input list of integers in ascending order. Function Signature ```python def merge_sort(arr: list) -> list: Sorts a list of integers in ascending order using the merge sort algorithm. Parameters: arr (list): The list of integers to be sorted. Returns: list: A new list containing the sorted integers. Raises: TypeError: If arr is not a list or if any element within arr is not an integer. pass ``` # Constraints 1. The input list may have 0 or more elements. 2. Each element of the list should be an integer 3. If these constraints are not met, raise appropriate exceptions (`TypeError`). # Expected Output Format The function should return a new list of integers sorted in ascending order. # Examples ```python assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] assert merge_sort([10, -3, 0, 5, 22, 7]) == [-3, 0, 5, 7, 10, 22] assert merge_sort([]) == [] ``` # Hints 1. Define a helper function to merge two sorted sublists. 2. Use a recursive approach for divide and conquer. 3. To handle the merging, you can iterate over both sublists and compare the elements, ensuring the resulting list maintains order.","solution":"def merge_sort(arr: list) -> list: Sorts a list of integers in ascending order using the merge sort algorithm. Parameters: arr (list): The list of integers to be sorted. Returns: list: A new list containing the sorted integers. Raises: TypeError: If arr is not a list or if any element within arr is not an integer. if not isinstance(arr, list): raise TypeError(\\"Input should be a list\\") for elem in arr: if not isinstance(elem, int): raise TypeError(\\"All elements in the list should be integers\\") if len(arr) <= 1: return arr def merge(left, right): merged = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 while i < len(left): merged.append(left[i]) i += 1 while j < len(right): merged.append(right[j]) j += 1 return merged mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right)"},{"question":"**Context**: In programming, one often needs to generate random data that follow specified statistical properties. Generating Gaussian-distributed (or normally distributed) random values is a common requirement in various applications such as simulations, random sampling, and statistical modeling. **Objective**: Your task is to implement a function that generates a specified number of random values from a Gaussian distribution given a mean and a standard deviation. This function will help you understand statistical properties of distributions and how to work with probabilistic data. # Task Description: Implement the function `generate_gaussian_values(mean: float, std_dev: float, count: int) -> np.ndarray` that generates `count` random values following a Gaussian distribution with the specified `mean` and `standard deviation`. # Input Format: *A single argument with the following components: - `mean` (type: float): The mean of the Gaussian distribution. - `std_dev` (type: float): The standard deviation of the Gaussian distribution. - `count` (type: int): The number of random values to generate. # Output Format: * Returns a `numpy.ndarray` containing `count` random values drawn from the specified Gaussian distribution. # Constraints: 1. `mean` can be any floating-point value. 2. `std_dev` is a positive floating-point number. 3. 1 <= `count` <= (10^6). # Examples: ```python import numpy as np # Example 1 mean = 0 std_dev = 1 count = 5 print(generate_gaussian_values(mean, std_dev, count)) # Output: A numpy array with 5 values, e.g., [-1.2345, 0.6789, -0.1234, 1.4567, -0.9876] # Example 2 mean = 5 std_dev = 2 count = 3 print(generate_gaussian_values(mean, std_dev, count)) # Output: A numpy array with 3 values, e.g., [4.5678, 6.2345, 5.1234] ``` # Note: - The exact output in the examples will vary because it involves random number generation. Ensure that the values follow the requested Gaussian distribution with the specified mean and standard deviation.","solution":"import numpy as np def generate_gaussian_values(mean: float, std_dev: float, count: int) -> np.ndarray: Generates \'count\' random values from a Gaussian distribution with a given \'mean\' and \'standard deviation\'. Parameters: - mean: float, the mean of the Gaussian distribution. - std_dev: float, the standard deviation of the Gaussian distribution. - count: int, the number of random values to generate. Returns: - numpy.ndarray: A numpy array containing \'count\' random values. return np.random.normal(loc=mean, scale=std_dev, size=count)"},{"question":"Implement the function `calculate_word_frequencies` that reads a list of text files, calculates the word frequencies for each file, and returns a combined frequency dictionary for all files. 1. **Reading Files**: - The function should accept a list of file paths and read the content of each file. 2. **Word Frequency Calculation**: - Count the occurrences of each word in a case-insensitive manner. - Exclude common punctuation (.,!?-), but retain apostrophes within words (e.g., \\"don\'t\\"). 3. **Combining Frequencies**: - Merge the word frequency counts from each file into a single dictionary. - Ensure that the final dictionary contains the cumulative count of words from all files. Write the function `calculate_word_frequencies` with the following signature: ```python from typing import List, Dict def calculate_word_frequencies(file_paths: List[str]) -> Dict[str, int]: # Your implementation here ``` # Input: - `file_paths` (list of str): List of file paths to be read. # Output: - Returns a dictionary where keys are words and values are their corresponding frequency counts. # Constraints: - You may assume that all files exist and are accessible. - The function should be reasonably efficient for files up to a few hundred MB in size. # Examples: Assume we have two text files with the following contents: `file1.txt`: ``` Hello world! This is a test. ``` `file2.txt`: ``` Hello again, world. This test is simple. ``` ```python file_paths = [\\"file1.txt\\", \\"file2.txt\\"] result = calculate_word_frequencies(file_paths) print(result) ``` This code should print a dictionary similar to: ```python { \\"hello\\": 2, \\"world\\": 2, \\"this\\": 2, \\"is\\": 2, \\"a\\": 1, \\"test\\": 2, \\"again\\": 1, \\"simple\\": 1 } ``` Note that the final dictionary combines the word frequencies from both files and counts words in a case-insensitive manner with punctuation excluded.","solution":"import os import string from typing import List, Dict def calculate_word_frequencies(file_paths: List[str]) -> Dict[str, int]: frequencies = {} translation_table = str.maketrans(\\"\\", \\"\\", string.punctuation.replace(\\"\'\\", \\"\\")) for file_path in file_paths: with open(file_path, \'r\', encoding=\'utf-8\') as file: for line in file: line = line.translate(translation_table).lower() words = line.split() for word in words: if word in frequencies: frequencies[word] += 1 else: frequencies[word] = 1 return frequencies"},{"question":"# Coding Challenge: Maximal Rectangle in a Rectangular Grid # Question: You are given a rectangular grid (2D list) filled with 0s and 1s. Each cell in the grid can either be empty (0) or filled (1). Your task is to find the area of the largest rectangle containing only 1s. This problem involves determining the maximum area of a rectangle that can be formed from adjacent cells containing 1s in the given grid. **Function Signature**: ```python def maximal_rectangle(matrix: List[List[int]]) -> int: pass ``` **Parameters**: - `matrix` (List[List[int]]): A 2D list of integers, where each element is either 0 or 1, representing the grid. **Returns**: - `int`: The area of the largest rectangle containing only 1s. **Constraints**: - The matrix will have at least one row and one column. - The number of rows and columns will not exceed 200. **Performance Requirements**: - Aim for an efficient solution that handles the worst-case scenario within a reasonable time limit. **Example**: ```python matrix = [ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ] # Expected output: 6 (The largest rectangle contains six 1s in the third row) print(maximal_rectangle(matrix)) ``` **Hint**: Consider leveraging techniques used in finding the largest rectangle in a histogram by treating each row as a base and applying the algorithm row by row.","solution":"from typing import List def maximal_rectangle(matrix: List[List[int]]) -> int: if not matrix: return 0 def largest_histogram_area(heights: List[int]) -> int: stack = [] max_area = 0 heights.append(0) for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() return max_area max_area = 0 row_len = len(matrix[0]) heights = [0] * row_len for row in matrix: for i in range(row_len): heights[i] = heights[i] + 1 if row[i] == 1 else 0 max_area = max(max_area, largest_histogram_area(heights)) return max_area"},{"question":"# Scenario You are developing a feature for a library catalog system that allows users to search for books using keywords and retrieve relevant information. The system maintains a collection of books where each book contains a title, author, genre, publication year, and a list of keywords. Your task is to implement a search function that returns books matching all provided keywords. # Task Implement a function `search_books` that searches for and returns the titles of books that match the given keywords. # Function Signature ```python def search_books(catalog: List[Dict[str, Any]], keywords: List[str]) -> List[str]: ``` # Input 1. `catalog`: A list of dictionaries, where each dictionary represents a book with the following keys: - `\'title\'`: A string representing the book title. - `\'author\'`: A string representing the author\'s name. - `\'genre\'`: A string representing the genre of the book. - `\'year\'`: An integer representing the publication year. - `\'keywords\'`: A list of strings representing keywords associated with the book. 2. `keywords`: A list of strings representing keywords to search for. The function should return books that contain all the provided keywords. # Output A list of strings representing the titles of the books that match the search criteria. # Constraints - The length of `catalog` is at most 1000. - Each book\'s keyword list can be of varying lengths but will contain at least one keyword. - The `keywords` list for the search will contain between 1 and 10 keywords. - Keywords and titles are case-sensitive. - If no books match the search criteria, return an empty list. # Example ```python catalog = [ {\'title\': \'The Great Gatsby\', \'author\': \'F. Scott Fitzgerald\', \'genre\': \'Fiction\', \'year\': 1925, \'keywords\': [\'classic\', \'1920s\', \'American\']}, {\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'genre\': \'Fiction\', \'year\': 1960, \'keywords\': [\'classic\', \'law\', \'racism\']}, {\'title\': \'1984\', \'author\': \'George Orwell\', \'genre\': \'Dystopian\', \'year\': 1949, \'keywords\': [\'totalitarianism\', \'surveillance\', \'classic\']}, {\'title\': \'The Catcher in the Rye\', \'author\': \'J.D. Salinger\', \'genre\': \'Fiction\', \'year\': 1951, \'keywords\': [\'teenage\', \'rebellion\', \'classic\']} ] keywords = [\'classic\', \'Fiction\'] # Expected Output: [\'The Great Gatsby\', \'To Kill a Mockingbird\', \'The Catcher in the Rye\'] ``` # Notes 1. Your solution should handle cases where no books match the keywords by returning an empty list. 2. Optimize your solution for readability and performance. 3. In case of ties (multiple books with the same keywords), their order in the output list should match their order in the input catalog. # Evaluation - The function\'s correctness and efficiency in handling up to the maximum constraints will be evaluated. - Edge cases such as an empty catalog, no matching keywords, and varying keyword lengths should be considered in your implementation.","solution":"from typing import List, Dict, Any def search_books(catalog: List[Dict[str, Any]], keywords: List[str]) -> List[str]: result = [] for book in catalog: # Check if all keywords are in the book\'s keywords list if all(keyword in book[\'keywords\'] for keyword in keywords): result.append(book[\'title\']) return result"},{"question":"# Merge Two Sorted Linked Lists Context You are developing a scheduling application that requires frequent merging of sorted task lists for different users. Given two singly linked lists that are both sorted in non-decreasing order, you need to merge them into a single sorted linked list. Task Implement a function `merge_two_sorted_lists(l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]` that merges two sorted linked lists into one sorted linked list. Function Signature ```python from typing import Optional class ListNode: def __init__(self, val: int = 0, next: Optional[\'ListNode\'] = None): self.val = val self.next = next def merge_two_sorted_lists(l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]: # Your code here ``` Additional Requirements * You may not create any new nodes. Instead, rearrange the nodes of the two lists to form the merged list. Input/Output Format * **Input**: - `l1`: The head node of the first sorted linked list (`ListNode` or `None` if the list is empty). - `l2`: The head node of the second sorted linked list (`ListNode` or `None` if the list is empty). * **Output**: - The head node of the merged sorted linked list. Constraints * The number of nodes in both lists is in the range [0, 1000]. * -10^4 <= ListNode.val <= 10^4 Examples ```python # Example 1: l1 = ListNode(1, ListNode(2, ListNode(4))) l2 = ListNode(1, ListNode(3, ListNode(4))) merged = merge_two_sorted_lists(l1, l2) # The merged list should be: 1 -> 1 -> 2 -> 3 -> 4 -> 4 # Example 2: l1 = None l2 = ListNode(0) merged = merge_two_sorted_lists(l1, l2) # The merged list should be: 0 ``` Use the following helper function for testing your function: ```python def print_linked_list(head: Optional[ListNode]) -> None: current = head while current: print(current.val, end=\\" -> \\" if current.next else \\"n\\") current = current.next # Example Test if __name__ == \\"__main__\\": l1 = ListNode(1, ListNode(2, ListNode(4))) l2 = ListNode(1, ListNode(3, ListNode(4))) merged = merge_two_sorted_lists(l1, l2) print_linked_list(merged) ``` Note Make sure to handle cases where either or both of the input linked lists are empty.","solution":"from typing import Optional class ListNode: def __init__(self, val: int = 0, next: Optional[\'ListNode\'] = None): self.val = val self.next = next def merge_two_sorted_lists(l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]: dummy = ListNode() current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next if l1: current.next = l1 else: current.next = l2 return dummy.next"},{"question":"# Problem Statement You are required to implement a basic spell checker. Your task is to create a Python function that identifies spelling mistakes in a text based on a given dictionary of correct words. The function should output the misspelled words along with their line numbers and positions. Function Definition ```python def spell_checker( text: str, dictionary: set ) -> List[Tuple[int, int, str]]: Identify spelling mistakes in the given text. Parameters: - text (str): A string containing the text to be checked. - dictionary (set): A set of valid words considered as correctly spelled. Return: List of tuples, each containing the line number, position of the misspelled word in that line, and the misspelled word itself. ``` Requirements * **Input**: - `text` (str): A multiline string containing the text to be checked. Words are considered as sequences of alphabetic characters. - `dictionary` (set of str): A set containing correctly spelled words. * **Output**: A list of tuples. Each tuple contains: - Line number (int): The 1-based index of the line in which the misspelled word is found. - Position (int): The 1-based index of the word\'s position within the line. - Misspelled word (str): The misspelled word itself. * **Constraints**: - The text can have at most 1000 lines. - Each line of text can have at most 100 words. - Each word can have at most 50 characters. - The dictionary can contain at most 5000 words. Example ```python text = This is a smple text It cntains sme misspellings Please identify thm dictionary = {\\"this\\", \\"is\\", \\"a\\", \\"simple\\", \\"text\\", \\"it\\", \\"contains\\", \\"some\\", \\"misspellings\\", \\"please\\", \\"identify\\", \\"them\\"} spell_checker(text, dictionary) ``` **Output**: ``` [(1, 4, \'smple\'), (2, 2, \'cntains\'), (2, 3, \'sme\'), (3, 3, \'thm\')] ``` In this example, the function identifies words \'smple\', \'cntains\', \'sme\', and \'thm\' as misspelled and provides their positions in the text accordingly.","solution":"from typing import List, Tuple, Set def spell_checker( text: str, dictionary: Set[str] ) -> List[Tuple[int, int, str]]: Identify spelling mistakes in the given text. Parameters: - text (str): A string containing the text to be checked. - dictionary (set): A set of valid words considered as correctly spelled. Return: List of tuples, each containing the line number, position of the misspelled word in that line, and the misspelled word itself. misspelled_words = [] lines = text.split(\'n\') for line_no, line in enumerate(lines, start=1): words = line.split() for position, word in enumerate(words, start=1): # Check if the word is not in the dictionary word_lower = word.lower() if word_lower not in dictionary: misspelled_words.append((line_no, position, word)) return misspelled_words"},{"question":"# Coding Assessment Question: You are designing a system that can help manage and schedule tasks. One of the features required is to identify overlapping tasks in a given list of tasks. Each task is defined by a start time and an end time and is represented as a tuple `(start, end)`, where `start` and `end` are integers representing minutes since the beginning of the day (0 to 1439). Write a function to determine if there are any overlapping tasks in the list. Two tasks overlap if they share at least one minute. Function Signature: ```python def has_overlapping_tasks(tasks: List[Tuple[int, int]]) -> bool: Determine if there are any overlapping tasks in the given list. Args: tasks (List[Tuple[int, int]]): A list of tuples where each tuple represents a task with a start time and an end time. Returns: bool: True if there are overlapping tasks, False otherwise. ``` Input: - A list of tasks where each task is represented by a tuple `(start, end)`. - `start` and `end` are integers such that ( 0 leq text{start} < text{end} leq 1439 ). - The number of tasks can be up to ( 10^5 ). Output: - A boolean value, `True` if there are overlapping tasks, `False` otherwise. Example: ```python >>> has_overlapping_tasks([(0, 30), (25, 50), (60, 120)]) True >>> has_overlapping_tasks([(0, 30), (40, 50), (60, 120)]) False >>> has_overlapping_tasks([(10, 20), (20, 30)]) False >>> has_overlapping_tasks([(10, 20), (19, 29)]) True ``` Constraints: 1. Ensure that the solution efficiently handles up to ( 10^5 ) tasks. 2. Each task\'s start time is strictly less than its end time. Additional Notes: - Consider sorting the tasks by their start times to simplify the overlap detection. - Overlapping is defined by any common minute between any two tasks. Your task is to implement the function `has_overlapping_tasks` based on the given description and constraints.","solution":"from typing import List, Tuple def has_overlapping_tasks(tasks: List[Tuple[int, int]]) -> bool: Determine if there are any overlapping tasks in the given list. # Sort the tasks by their start time tasks.sort() # Iterate through the sorted tasks and check for overlapping for i in range(1, len(tasks)): # If the start time of the current task is less than the end time of the previous task if tasks[i][0] < tasks[i-1][1]: return True return False"},{"question":"# Fibonacci Sequence Generator with Caching You are tasked with writing a function that generates the Fibonacci sequence up to the nth term using caching to optimize performance. The function should also include input validation and handle edge cases. # Function Definition Implement the following function: ```python def generate_fibonacci(n: Union[int, float, str]) -> List[int]: pass ``` # Input Parameters * **n** (int, float, or str): The number of terms in the Fibonacci sequence to generate. # Output * **List of integers**: The Fibonacci sequence up to the nth term. # Constraints * If `n` is less than or equal to 0, the function should return an empty list. * If `n` is a string that cannot be converted into a valid number, return a list containing an empty string. * Ensure the function works with integers, floats, and possible string representations of numbers. * You must use caching (memoization) to optimize the function for efficiency. # Performance Requirements The function should efficiently handle values for `n` up to 1,000. # Example ```python # Example usage and output print(generate_fibonacci(5)) # Output: [0, 1, 1, 2, 3] print(generate_fibonacci(10.5)) # Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] print(generate_fibonacci(-5)) # Output: [] print(generate_fibonacci(\\"invalid\\")) # Output: [\'\'] print(generate_fibonacci(\'7\')) # Output: [0, 1, 1, 2, 3, 5, 8] ``` # Notes * The function should use built-in Python capabilities for mathematical operations and type conversions. * Use memoization techniques to store previously computed terms and improve performance. * Consider edge cases for input validation to ensure the function is robust. # Sample Implementation (Hidden) ```python def generate_fibonacci(n: Union[int, float, str]) -> List[int]: # Handle type conversion and validation try: n = int(float(n)) except ValueError: return [\'\'] if n <= 0: return [] # Memoization cache cache = {} def fib_memo(k): if k in cache: return cache[k] if k == 0: value = 0 elif k == 1: value = 1 else: value = fib_memo(k-1) + fib_memo(k-2) cache[k] = value return value return [fib_memo(i) for i in range(n)] ```","solution":"from typing import Union, List def generate_fibonacci(n: Union[int, float, str]) -> List[int]: # Handle type conversion and validation try: n = int(float(n)) except ValueError: return [\'\'] if n <= 0: return [] # Memoization cache cache = {} def fib_memo(k): if k in cache: return cache[k] if k == 0: value = 0 elif k == 1: value = 1 else: value = fib_memo(k-1) + fib_memo(k-2) cache[k] = value return value return [fib_memo(i) for i in range(n)]"},{"question":"# Context: You are working on a real-time messaging application, and your task is to implement a system to manage and display chat messages efficiently. The system needs to handle incoming messages, store them, and retrieve a specific range of messages when requested. # Task: Implement a Python class `ChatManager` with the following methods: 1. `__init__(self)`: Initializes the chat manager. 2. `add_message(self, username, message)`: Adds a new message to the chat. 3. `get_recent_messages(self, n)`: Retrieves the last `n` messages added, ordered from newest to oldest. 4. `get_messages_from(self, start, end)`: Retrieves messages in the range from index `start` to `end` (both inclusive). # Input: * `add_message(username, message)`: `username` (str) is the name of the user sending the message. `message` (str) is the content of the message. * `get_recent_messages(n)`: `n` (int) is the number of recent messages to retrieve. * `get_messages_from(start, end)`: `start` (int) is the starting index, and `end` (int) is the ending index for the range of messages to retrieve. # Output: * `add_message` returns `None`. * `get_recent_messages` returns a list of messages in the format `[{username: str, message: str}]`. * `get_messages_from` returns a list of messages in the format `[{username: str, message: str}]`. # Constraints: * Assume there are no duplicate messages. * The number of messages added will not exceed 100,000. * The indices for `get_messages_from` are zero-based. # Requirements: * Ensure the methods handle edge cases, such as requesting more messages than available or invalid index ranges. * Optimize the methods to retrieve messages efficiently. # Example: ```python chat = ChatManager() chat.add_message(\\"alice\\", \\"Hello!\\") chat.add_message(\\"bob\\", \\"Hi there!\\") chat.add_message(\\"alice\\", \\"How are you?\\") recent = chat.get_recent_messages(2) print(recent) # Output: [{\'username\': \'alice\', \'message\': \'How are you?\'}, {\'username\': \'bob\', \'message\': \'Hi there!\'}] messages = chat.get_messages_from(0, 1) print(messages) # Output: [{\'username\': \'alice\', \'message\': \'Hello!\'}, {\'username\': \'bob\', \'message\': \'Hi there!\'}] ```","solution":"class ChatManager: def __init__(self): self.messages = [] def add_message(self, username, message): Adds a new message to the chat. :param username: str, the name of the user sending the message :param message: str, the content of the message self.messages.append({\\"username\\": username, \\"message\\": message}) def get_recent_messages(self, n): Retrieves the last n messages added, ordered from newest to oldest. :param n: int, number of recent messages to retrieve :return: list of dicts in the format [{\'username\': str, \'message\': str}] return self.messages[-n:][::-1] def get_messages_from(self, start, end): Retrieves messages in the range from index start to end (both inclusive). :param start: int, starting index of the range :param end: int, ending index of the range :return: list of dicts in the format [{\'username\': str, \'message\': str}] return self.messages[start:end+1]"},{"question":"# Cryptocurrency Portfolio Tracker You are working on a cryptocurrency portfolio tracker that collects data about various cryptocurrencies and calculates the current value of a user\'s portfolio. Your task is to extend the existing code to fetch the price of a specific cryptocurrency from a given API and then compute the portfolio\'s total value. Requirements 1. **Function Implementation**: - Implement a function `fetch_crypto_price(api_url: str, currency: str) -> float`, which takes the API endpoint and the cryptocurrency symbol as inputs, and returns the current price of the cryptocurrency in USD. - Implement a function `portfolio_value(api_url: str, portfolio: dict) -> float`, which takes the API endpoint and a dictionary representing a user\'s cryptocurrency holdings, and returns the total value of the portfolio in USD. 2. **Input and Output Formats**: - **Input**: * `api_url` (string): The API endpoint for fetching cryptocurrency prices (e.g., \\"https://api.coingecko.com/api/v3/simple/price\\"). * `currency` (string): The symbol of the cryptocurrency (e.g., \\"bitcoin\\"). * `portfolio` (dict): A dictionary where keys are cryptocurrency symbols (e.g., \\"bitcoin\\", \\"ethereum\\") and values are the amount held. - **Output**: * `fetch_crypto_price`: A float representing the price of the cryptocurrency in USD. * `portfolio_value`: A float representing the total value of the portfolio in USD. 3. **Constraints**: - Ensure that your code handles: * Changes in the API response structure. * Non-200 HTTP responses. * Missing elements in the response. * Network latency by setting an appropriate timeout. 4. **Performance Requirements**: - Handle HTTP request retries to mitigate transient network issues. - Ensure that the solution is efficient in terms of time and space complexity. Code Base to Extend ```python #!/usr/bin/env python3 import requests def fetch_crypto_price(api_url: str, currency: str) -> float: Return the current price of `currency` in USD response = requests.get(f\\"{api_url}?ids={currency}&vs_currencies=usd\\", timeout=10) data = response.json() return data[currency][\'usd\'] def portfolio_value(api_url: str, portfolio: dict) -> float: Return the total value of the portfolio in USD total_value = 0.0 for currency, amount in portfolio.items(): price = fetch_crypto_price(api_url, currency) total_value += price * amount return total_value if __name__ == \\"__main__\\": API_URL = \\"https://api.coingecko.com/api/v3/simple/price\\" portfolio = { \\"bitcoin\\": 0.5, \\"ethereum\\": 2.0, \\"dogecoin\\": 1000.0 } print(\\"033[1m Cryptocurrency Portfolio Value 033[0mn\\") print(f\\"Total Value: {portfolio_value(API_URL, portfolio):,.2f}\\") ``` # Implementation Note - The implementation should consider edge cases such as non-existent cryptocurrencies in the portfolio, handling timeouts, retrying requests, and formatting issues. - To test the code, use the provided API endpoint \\"https://api.coingecko.com/api/v3/simple/price\\" which supports fetching cryptocurrency prices by symbol.","solution":"import requests def fetch_crypto_price(api_url: str, currency: str) -> float: Return the current price of `currency` in USD. The function makes an HTTP GET request to fetch the cryptocurrency price. Handles non-200 responses and other potential issues gracefully. try: response = requests.get(f\\"{api_url}?ids={currency}&vs_currencies=usd\\", timeout=10) response.raise_for_status() # raise exception for HTTP errors data = response.json() if currency in data and \'usd\' in data[currency]: return data[currency][\'usd\'] else: raise ValueError(f\\"Incorrect response structure: {data}\\") except requests.RequestException as e: raise RuntimeError(f\\"Error fetching price for {currency}: {e}\\") def portfolio_value(api_url: str, portfolio: dict) -> float: Return the total value of the portfolio in USD. Iterates over the portfolio dict to fetch current prices and sum up the values. total_value = 0.0 for currency, amount in portfolio.items(): price = fetch_crypto_price(api_url, currency) total_value += price * amount return total_value"},{"question":"# Investment Portfolio Analysis Objective Develop an `InvestmentPortfolio` application that allows users to manage and analyze their investments in stocks and bonds. The application should support adding unique investments, calculating the total value and returns of the portfolio, and ensuring that users input valid data for each investment type. Instructions 1. **Class Definition**: Write a class `InvestmentPortfolio` that: - Maintains a list of investments, including Stocks and Bonds. - Provides methods to add new investments. - Contains methods to calculate the total current value and total returns of the portfolio. - Ensures validation of inputs while adding new investments. 2. **Class Methods**: - `add_stock(symbol: str, purchase_price: float, current_price: float, shares: int) -> None`: Adds a Stock investment to the portfolio. - `add_bond(identifier: str, purchase_price: float, current_value: float, yield_rate: float) -> None`: Adds a Bond investment to the portfolio. - `total_value() -> float`: Returns the combined current value of all investments. - `total_returns() -> float`: Returns the combined returns of all investments based on their purchase and current prices. 3. **Validation**: - Ensure that negative values for prices, shares, and yield rates are not allowed. - Ensure all inputs are of the appropriate type (e.g., prices should be floats, shares should be integers). # Example Here\'s an example of how your `InvestmentPortfolio` can be used: ```python portfolio = InvestmentPortfolio() portfolio.add_stock(\\"AAPL\\", 150.00, 200.00, 10) portfolio.add_bond(\\"US-Treasury-10Y\\", 1000.00, 1050.00, 0.02) portfolio.add_stock(\\"GOOG\\", 1000.00, 1500.00, 5) print(\\"Total Value:\\", portfolio.total_value()) print(\\"Total Returns:\\", portfolio.total_returns()) ``` Constraints - Assume no investment can have negative purchase price, current price, or yield rate. - Maximum purchase price, current price, and total value for a single investment is 1,000,000 units. - The yield rate for bonds must be between 0 and 1.","solution":"class InvestmentPortfolio: def __init__(self): self.investments = [] def add_stock(self, symbol: str, purchase_price: float, current_price: float, shares: int) -> None: if purchase_price <= 0 or current_price < 0 or shares <= 0: raise ValueError(\\"Invalid values for stock investment\\") stock = { \'type\': \'stock\', \'symbol\': symbol, \'purchase_price\': purchase_price, \'current_price\': current_price, \'shares\': shares } self.investments.append(stock) def add_bond(self, identifier: str, purchase_price: float, current_value: float, yield_rate: float) -> None: if purchase_price <= 0 or current_value < 0 or not (0 <= yield_rate <= 1): raise ValueError(\\"Invalid values for bond investment\\") bond = { \'type\': \'bond\', \'identifier\': identifier, \'purchase_price\': purchase_price, \'current_value\': current_value, \'yield_rate\': yield_rate } self.investments.append(bond) def total_value(self) -> float: total = 0 for investment in self.investments: if investment[\'type\'] == \'stock\': total += investment[\'current_price\'] * investment[\'shares\'] elif investment[\'type\'] == \'bond\': total += investment[\'current_value\'] return total def total_returns(self) -> float: total = 0 for investment in self.investments: if investment[\'type\'] == \'stock\': total += (investment[\'current_price\'] - investment[\'purchase_price\']) * investment[\'shares\'] elif investment[\'type\'] == \'bond\': total += (investment[\'current_value\'] - investment[\'purchase_price\']) + (investment[\'purchase_price\'] * investment[\'yield_rate\']) return total"},{"question":"# Question: Implement a Text-Based Minesweeper Game As a way to test your understanding of game logic and 2D array manipulation, your task is to implement a simplified version of the Minesweeper game in Python. The game should be able to set up a board, place mines, and handle user interaction to reveal cells and mark mines. Steps to Solve: 1. Write a class `Minesweeper` that initializes a game board with a given size and number of mines. 2. Implement a method `place_mines()` to randomly place the specified number of mines on the board. 3. Implement a method `calculate_adjacent_mines()` to calculate the number of adjacent mines for each cell on the board. 4. Implement a method `reveal_cell()` to reveal a cell and recursively reveal adjacent cells if there are no adjacent mines. 5. Implement a method `mark_mine()` to allow the user to mark a cell as a suspected mine. 6. Implement a method `is_game_over()` to check whether the game is won (all non-mine cells revealed) or lost (a mine is revealed). # Specifications: Class: `Minesweeper` 1. **Initialization:** - Input: `self`, `size` (int), `num_mines` (int) - Initializes a size x size board with `num_mines` mines. 2. **Method: `place_mines`** - Input: `self` - Places mines on the board in random positions. 3. **Method: `calculate_adjacent_mines`** - Input: `self` - Calculates the number of mines adjacent to each cell. 4. **Method: `reveal_cell`** - Input: `self`, `row` (int), `col` (int) - Reveals the cell at (row, col). If the cell has no adjacent mines, recursively reveal adjacent cells. 5. **Method: `mark_mine`** - Input: `self`, `row` (int), `col` (int) - Marks the cell at (row, col) as a suspected mine. 6. **Method: `is_game_over`** - Input: `self` - Output: Returns `True` if the game is won or lost, otherwise `False`. # Example: ```python class Minesweeper: def __init__(self, size: int, num_mines: int): pass def place_mines(self): pass def calculate_adjacent_mines(self): pass def reveal_cell(self, row: int, col: int): pass def mark_mine(self, row: int, col: int): pass def is_game_over(self) -> bool: pass # Example Usage game = Minesweeper(size=5, num_mines=3) game.place_mines() game.calculate_adjacent_mines() game.reveal_cell(0, 0) game.mark_mine(1, 1) assert not game.is_game_over() ``` # Constraints: * The board size is at least 2x2 and at most 10x10. * The number of mines is less than the number of cells on the board. * The game should handle edge cases such as revealing all possible cells and marking mines incorrectly. This question requires implementing a classic problem that helps test the candidate\'s grasp over basic object-oriented programming, handling 2D array manipulations, and basic algorithms, aligning well with typical coding assessment scenarios.","solution":"import random class Minesweeper: def __init__(self, size: int, num_mines: int): self.size = size self.num_mines = num_mines self.board = [[\' \' for _ in range(size)] for _ in range(size)] self.mines = set() self.revealed = set() self.marked = set() self.game_over = False self.place_mines() self.calculate_adjacent_mines() def place_mines(self): while len(self.mines) < self.num_mines: row = random.randint(0, self.size - 1) col = random.randint(0, self.size - 1) if (row, col) not in self.mines: self.mines.add((row, col)) self.board[row][col] = \'M\' def calculate_adjacent_mines(self): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] for r in range(self.size): for c in range(self.size): if self.board[r][c] == \'M\': continue count = 0 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < self.size and 0 <= nc < self.size and self.board[nr][nc] == \'M\': count += 1 self.board[r][c] = str(count) def reveal_cell(self, row: int, col: int): if (row, col) in self.mines: self.game_over = True return self._reveal(row, col) def _reveal(self, row: int, col: int): if (row, col) in self.revealed or (row, col) in self.mines: return self.revealed.add((row, col)) if self.board[row][col] == \'0\': directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] for dr, dc in directions: nr, nc = row + dr, col + dc if 0 <= nr < self.size and 0 <= nc < self.size: self._reveal(nr, nc) def mark_mine(self, row: int, col: int): if (row, col) in self.marked: self.marked.remove((row, col)) else: self.marked.add((row, col)) def is_game_over(self) -> bool: if self.game_over: return True all_revealed = len(self.revealed) == self.size * self.size - self.num_mines return all_revealed"},{"question":"# Problem Statement: You are given a list of integers `nums` representing the number of pages in different chapters of a book. You need to divide the book into `k` contiguous chapters such that the maximum number of pages in any single part is minimized. Your task is to determine this minimum possible value of the maximum pages in any part. # Function Signature: ```python def min_pages_partition(nums: List[int], k: int) -> int: ``` # Input: * A list `nums` of size `n` where `1 <= n <= 1000` and each element is a positive integer representing the number of pages in a chapter. * An integer `k` where `1 <= k <= n`, representing the number of parts the book should be divided into. # Output: * An integer representing the minimum possible value of the maximum pages in any of the `k` parts. # Constraints: * The book must be divided into exactly k parts. * Each part must contain at least one chapter. # Example: ```python nums_1 = [10, 20, 30, 40, 50, 60] k_1 = 3 assert min_pages_partition(nums_1, k_1) == 90 # The book can be divided as [10, 20, 30, 40], [50], [60] nums_2 = [5, 5, 5, 5, 5, 5, 5] k_2 = 3 assert min_pages_partition(nums_2, k_2) == 15 # The book can be divided as [5, 5, 5], [5, 5], [5, 5] ``` # Notes: 1. To solve this problem, consider using a binary search algorithm combined with a helper function to validate the feasibility of a partition configuration. 2. Thoroughly test your function with edge cases, such as when each chapter has very few pages or when all chapters are evenly distributed.","solution":"from typing import List def min_pages_partition(nums: List[int], k: int) -> int: def can_partition(max_pages): current_sum = 0 partitions = 1 for pages in nums: if current_sum + pages > max_pages: partitions += 1 current_sum = pages if partitions > k: return False else: current_sum += pages return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_partition(mid): right = mid else: left = mid + 1 return left"},{"question":"# Scenario: You are developing a data analytics tool to process numerical data from various sources. As part of the tool\'s feature set, you need to implement a function that calculates the running median of a stream of numbers. The running median is the median of all numbers seen so far in the data stream. # Task: Implement a Python class `RunningMedian` that maintains the running median of a stream of numbers. This class should support adding new numbers to the stream and retrieving the current median efficiently. # Class Specification: Methods: - `__init__`: Initializes the data structures necessary for storing the numbers and calculating the median. - `add_number(number: int) -> None`: Adds a new number to the stream. - `get_median() -> float`: Returns the current median of the numbers in the stream. Constraints: - The median of an empty stream should be considered as 0. - The `add_number` method should have an average time complexity of O(log n). - The `get_median` method should have an average time complexity of O(1). - Handle edge cases where there are an odd or even number of elements in the stream. # Example: ```python # Example usage rm = RunningMedian() rm.add_number(5) print(rm.get_median()) # Output should be 5 rm.add_number(10) print(rm.get_median()) # Output should be 7.5 rm.add_number(1) print(rm.get_median()) # Output should be 5 ``` Expected Output: ```python 5 7.5 5 ```","solution":"import heapq class RunningMedian: def __init__(self): self.min_heap = [] # Holds the larger half self.max_heap = [] # Holds the smaller half def add_number(self, number: int) -> None: if not self.min_heap or number > self.min_heap[0]: heapq.heappush(self.min_heap, number) else: heapq.heappush(self.max_heap, -number) # Balance the heaps to ensure neither is more than one element larger if len(self.min_heap) > len(self.max_heap) + 1: heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) elif len(self.max_heap) > len(self.min_heap): heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) def get_median(self) -> float: if len(self.min_heap) == len(self.max_heap): if not self.min_heap: # Both are empty return 0.0 return (self.min_heap[0] - self.max_heap[0]) / 2.0 else: return float(self.min_heap[0])"},{"question":"# Problem Statement Implement a function that simulates a basic inventory management system for a small store. The system should be able to process a series of operations to add, remove, and update items within the inventory and return a summary report of the current inventory state. Requirements: 1. **Function Name**: `inventory_manager` 2. **Input**: - `operations`: A list of tuples, where each tuple represents an operation to be performed on the inventory. Each tuple consists of three elements: - The operation type: a string that can be \'add\', \'remove\', or \'update\'. - The item name: a string representing the name of the item. - The quantity: an integer representing the quantity involved in the operation. 3. **Output**: - A dictionary representing the final state of the inventory, where the keys are the item names and the values are their respective quantities. 4. **Constraints**: - If an item is added or updated, ensure the quantity is non-negative. - If an item is removed, ensure it exists in the inventory and the quantity to be removed does not exceed the current stock. - The operations should be processed in the order they appear in the input list. - Ignore operations that do not conform to the above constraints. Scenario You are managing the inventory for a small store. Each day, you receive a list of operations to update the inventory. Your task is to process these operations and maintain an accurate record of the inventory. Implement the function with the signature: ```python def inventory_manager( operations: list[tuple[str, str, int]] ) -> dict[str, int]: pass ``` Example: ```python operations = [ (\'add\', \'apple\', 10), (\'add\', \'banana\', 5), (\'remove\', \'apple\', 3), (\'update\', \'banana\', 10), (\'remove\', \'banana\', 15), (\'add\', \'carrot\', 7) ] print(inventory_manager(operations)) ``` Expected Output: ```python {\'apple\': 7, \'banana\': 10, \'carrot\': 7} ``` Considerations: - Ensure that invalid operations are skipped and only valid changes are recorded. - The resulting inventory should reflect the quantities after all the operations are processed. - Perform operations in O(n) time complexity where n is the number of operations.","solution":"def inventory_manager(operations): Manages the inventory based on given operations and returns the final inventory state. :param operations: list of tuple with (operation type, item name, quantity) :return: dictionary representing the inventory state. inventory = {} for operation in operations: op_type, item, quantity = operation if quantity < 0: continue if op_type == \'add\': if item in inventory: inventory[item] += quantity else: inventory[item] = quantity elif op_type == \'remove\': if item in inventory and inventory[item] >= quantity: inventory[item] -= quantity if inventory[item] == 0: del inventory[item] elif op_type == \'update\': if quantity >= 0: inventory[item] = quantity return inventory"},{"question":"# Coding Question: Implement a Simple JSON Configuration Merger Configuring complex systems often involves managing multiple configuration files across various environments. These configuration files are typically in JSON format and might have overlapping settings that need merging. Objective Write a Python function `merge_json_configs` that: 1. Takes a list of file paths pointing to JSON configuration files. 2. Reads and parses each JSON file. 3. Merges the configurations into a single dictionary, where: - Values from later files in the list override those from earlier ones. 4. Handles nested configurations by performing a deep merge. # Input A list of file paths containing JSON configurations: ```python file_paths = [\\"config1.json\\", \\"config2.json\\", \\"config3.json\\"] ``` # Output A single dictionary representing the merged configuration: ```json { \\"settingA\\": \\"valueFromLastFile\\", \\"nestedSetting\\": { \\"subSetting1\\": \\"subValueOverride\\", \\"subSetting2\\": \\"subValue2\\" }, ... } ``` # Constraints - Input JSON files can be arbitrarily nested. - Handle errors gracefully, such as files not existing or invalid JSON formats. - Assume well-formed JSON when valid. # Requirements - Use Python\'s built-in `json` module to read and parse JSON files. - Implement a deep merge to handle nested dictionaries without overwriting entire sub-dictionaries. - Ensure robust error handling for file IO and JSON parsing. # Example Given the following JSON files: `config1.json` ```json { \\"settingA\\": \\"value1\\", \\"nestedSetting\\": { \\"subSetting1\\": \\"subValue1\\" } } ``` `config2.json` ```json { \\"settingA\\": \\"value2\\", \\"nestedSetting\\": { \\"subSetting1\\": \\"subValueOverride\\", \\"subSetting2\\": \\"subValue2\\" } } ``` The output of `merge_json_configs([\\"config1.json\\", \\"config2.json\\"])` should be: ```json { \\"settingA\\": \\"value2\\", \\"nestedSetting\\": { \\"subSetting1\\": \\"subValueOverride\\", \\"subSetting2\\": \\"subValue2\\" } } ``` ```python import json import os from typing import List, Dict def deep_merge(dict1: Dict, dict2: Dict) -> Dict: for key, value in dict2.items(): if key in dict1 and isinstance(dict1[key], dict) and isinstance(value, dict): dict1[key] = deep_merge(dict1[key], value) else: dict1[key] = value return dict1 def merge_json_configs(file_paths: List[str]) -> Dict: merged_config = {} for file_path in file_paths: if not os.path.exists(file_path): continue with open(file_path, \'r\') as file: try: current_config = json.load(file) merged_config = deep_merge(merged_config, current_config) except json.JSONDecodeError: # Handle invalid JSON by skipping this file continue return merged_config # Example usage result = merge_json_configs([\\"config1.json\\", \\"config2.json\\"]) print(json.dumps(result, indent=4)) ``` This function reads multiple JSON configuration files in the order provided, merging them into one, where values from later files overwrite earlier ones, and maintains nested structure appropriately.","solution":"import json import os from typing import List, Dict def deep_merge(dict1: Dict, dict2: Dict) -> Dict: for key, value in dict2.items(): if key in dict1 and isinstance(dict1[key], dict) and isinstance(value, dict): dict1[key] = deep_merge(dict1[key], value) else: dict1[key] = value return dict1 def merge_json_configs(file_paths: List[str]) -> Dict: merged_config = {} for file_path in file_paths: if not os.path.exists(file_path): continue with open(file_path, \'r\') as file: try: current_config = json.load(file) merged_config = deep_merge(merged_config, current_config) except json.JSONDecodeError: # Handle invalid JSON by skipping this file continue return merged_config"},{"question":"# Context Bob is designing a system that processes large amounts of data using various tree-based structures. As part of his project, he needs you to implement a function that identifies all leaf nodes in a given binary tree. A leaf node is a node that has no children (i.e., both its left and right pointers are null). # Task Write a function `find_leaf_nodes` that accepts a binary tree represented by a root node and returns a list of all leaf nodes\' values. The function should efficiently traverse the tree to identify the leaf nodes. # Input - The binary tree is represented by a root node, where each node is an instance of the following TreeNode class: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` # Output - A list of integers representing the values of all leaf nodes in the binary tree. The list should be sorted in ascending order. # Example ```python # Construct the following binary tree: # 1 # / # 2 3 # /| | # 4 5 6 # | # 7 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5, TreeNode(7)) root.right.right = TreeNode(6) find_leaf_nodes(root) ``` Expected Output: ``` [4, 6, 7] ``` # Constraints - The tree can have up to 1000 nodes. # Performance Requirements - The function should traverse the tree once to identify all leaf nodes. Efficiently handle the traversal to ensure optimal performance for trees with the maximum number of nodes.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_leaf_nodes(root): if root is None: return [] leaves = [] def traverse(node): if node.left is None and node.right is None: leaves.append(node.value) if node.left: traverse(node.left) if node.right: traverse(node.right) traverse(root) return sorted(leaves)"},{"question":"# Question: Implement a Simple File System You need to design a basic file system with the following functionalities. A file system can contain files and directories, each of which can have their own set of files and directories inside them. **Features to Implement**: 1. **Create File/Directory**: Allow the creation of files and directories. 2. **Read File**: Enable reading the content of a file. 3. **Write File**: Allow writing content to a file, either by overwriting or appending. 4. **Delete File/Directory**: Enable deletion of files and directories. 5. **List Directory Contents**: List files and directories within a directory. # Class Definitions: ```python class SimpleFile: def __init__(self, name: str) -> None: \'\'\' Initialize a file object with a name and empty content. Args: name (str): The name of the file \'\'\' self.name = name self.content = \\"\\" def read(self) -> str: \'\'\' Return the content of the file. Returns: str: The content of the file. \'\'\' pass def write(self, data: str, mode: str = \'w\') -> None: \'\'\' Write data to the file. Args: data (str): The content to write into the file. mode (str): \'w\' for write (overwrite) or \'a\' for append. \'\'\' pass class SimpleDirectory: def __init__(self, name: str) -> None: \'\'\' Initialize a directory object with a name. Args: name (str): The name of the directory. \'\'\' self.name = name self.contents = {} def create_file(self, name: str) -> None: \'\'\' Create a new file within this directory. Args: name (str): The name of the new file. \'\'\' pass def create_directory(self, name: str) -> None: \'\'\' Create a new directory within this directory. Args: name (str): The name of the new directory. \'\'\' pass def delete(self, name: str) -> None: \'\'\' Delete a file or directory from this directory. Args: name (str): The name of the file or directory to delete. \'\'\' pass def list_contents(self) -> list[str]: \'\'\' List the names of the files and directories in this directory. Returns: list[str]: The list of names of contents in the directory. \'\'\' pass class SimpleFileSystem: def __init__(self) -> None: \'\'\' Initialize the file system with a root directory. \'\'\' self.root = SimpleDirectory(\\"root\\") def create_file(self, path: str) -> None: \'\'\' Create a new file at the specified path. Args: path (str): The path where the file should be created. \'\'\' pass def create_directory(self, path: str) -> None: \'\'\' Create a new directory at the specified path. Args: path (str): The path where the directory should be created. \'\'\' pass def delete(self, path: str) -> None: \'\'\' Delete a file or directory at the specified path. Args: path (str): The path to the file or directory to delete. \'\'\' pass def read_file(self, path: str) -> str: \'\'\' Read the content of a file at the specified path. Args: path (str): The path to the file to be read. Returns: str: The content of the file. \'\'\' pass def write_file(self, path: str, data: str, mode: str = \'w\') -> None: \'\'\' Write data to a file at the specified path. Args: path (str): The path to the file. data (str): The content to write into the file. mode (str): \'w\' for write (overwrite) or \'a\' for append. \'\'\' pass def list_directory(self, path: str) -> list[str]: \'\'\' List the contents of a directory at the specified path. Args: path (str): The path to the directory. Returns: list[str]: The list of names of contents in the directory. \'\'\' pass ``` Input Format: 1. For `create_file`: `(path)` where `path` is a string representing the full path to the file including the file name. 2. For `create_directory`: `(path)` where `path` is a string representing the full path to the directory. 3. For `delete`: `(path)` where `path` is a string representing the full path to the file or directory. 4. For `read_file`: `(path)` where `path` is a string representing the full path to the file. 5. For `write_file`: `(path, data, mode)` where `path` is a string representing the full path to the file, `data` is the string content to write, and `mode` is \'w\' for write (overwrite) or \'a\' for append. 6. For `list_directory`: `(path)` where `path` is a string representing the full path to the directory. Output Format: 1. For `read_file`: Returns the content of the file as a string. 2. For `list_directory`: Returns a list of strings, each representing the name of a file or directory. Constraints: - Assume all paths are absolute and start from the root directory. - Ensure proper handling of edge cases such as trying to read a non-existent file or trying to delete a non-existent directory. Example Usage: ```python # Creating an instance of SimpleFileSystem fs = SimpleFileSystem() # Creating directories and files fs.create_directory(\\"/home\\") fs.create_file(\\"/home/myfile.txt\\") # Writing to the file fs.write_file(\\"/home/myfile.txt\\", \\"Hello, World!\\", \\"w\\") # Reading the file print(fs.read_file(\\"/home/myfile.txt\\")) # Output: Hello, World! # Listing contents of the directory print(fs.list_directory(\\"/home\\")) # Output: [\'myfile.txt\'] # Deleting the file fs.delete(\\"/home/myfile.txt\\") # Listing contents of the directory again print(fs.list_directory(\\"/home\\")) # Output: [] ``` Make sure to implement the necessary error handling and validation checks to ensure the robustness of your file system implementation.","solution":"class SimpleFile: def __init__(self, name: str) -> None: self.name = name self.content = \\"\\" def read(self) -> str: return self.content def write(self, data: str, mode: str = \'w\') -> None: if mode == \'w\': self.content = data elif mode == \'a\': self.content += data else: raise ValueError(\\"Invalid mode. Use \'w\' for write or \'a\' for append.\\") class SimpleDirectory: def __init__(self, name: str) -> None: self.name = name self.contents = {} def create_file(self, name: str) -> None: if name in self.contents: raise FileExistsError(f\\"File or directory with name \'{name}\' already exists.\\") self.contents[name] = SimpleFile(name) def create_directory(self, name: str) -> None: if name in self.contents: raise FileExistsError(f\\"File or directory with name \'{name}\' already exists.\\") self.contents[name] = SimpleDirectory(name) def delete(self, name: str) -> None: if name not in self.contents: raise FileNotFoundError(f\\"File or directory with name \'{name}\' does not exist.\\") del self.contents[name] def list_contents(self) -> list[str]: return list(self.contents.keys()) class SimpleFileSystem: def __init__(self) -> None: self.root = SimpleDirectory(\\"root\\") def _traverse_to_path(self, path: str): parts = path.strip(\'/\').split(\'/\') current = self.root for part in parts[:-1]: if part not in current.contents or not isinstance(current.contents[part], SimpleDirectory): raise FileNotFoundError(f\\"Directory \'{part}\' not found in path.\\") current = current.contents[part] return current, parts[-1] def create_file(self, path: str) -> None: parent_dir, file_name = self._traverse_to_path(path) parent_dir.create_file(file_name) def create_directory(self, path: str) -> None: parent_dir, dir_name = self._traverse_to_path(path) parent_dir.create_directory(dir_name) def delete(self, path: str) -> None: parent_dir, name = self._traverse_to_path(path) parent_dir.delete(name) def read_file(self, path: str) -> str: parent_dir, file_name = self._traverse_to_path(path) if file_name not in parent_dir.contents or not isinstance(parent_dir.contents[file_name], SimpleFile): raise FileNotFoundError(f\\"File \'{file_name}\' not found.\\") return parent_dir.contents[file_name].read() def write_file(self, path: str, data: str, mode: str = \'w\') -> None: parent_dir, file_name = self._traverse_to_path(path) if file_name not in parent_dir.contents or not isinstance(parent_dir.contents[file_name], SimpleFile): raise FileNotFoundError(f\\"File \'{file_name}\' not found.\\") parent_dir.contents[file_name].write(data, mode) def list_directory(self, path: str) -> list[str]: if path == \\"/\\": return self.root.list_contents() parent_dir, dir_name = self._traverse_to_path(path) if dir_name not in parent_dir.contents or not isinstance(parent_dir.contents[dir_name], SimpleDirectory): raise FileNotFoundError(f\\"Directory \'{dir_name}\' not found.\\") return parent_dir.contents[dir_name].list_contents()"},{"question":"# Coding Challenge: Product of Array Except Self Problem Statement You are given an array of integers `nums`. Write a function `product_except_self(nums: List[int]) -> List[int]` that returns an array `output` such that `output[i]` is equal to the product of all the elements of `nums` except `nums[i]`. The challenge is to solve it **without** using division and in O(n) time complexity. Input - `nums`: A list of integers (1 ≤ len(nums) ≤ 10^5) Output - Returns a list of integers where each element at index `i` is the product of all elements of `nums` except `nums[i]`. Example ```python assert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] assert product_except_self([1, 2, 3, 0]) == [0, 0, 0, 6] assert product_except_self([-1, 1, 0, -3, 3]) == [0, 0, 9, 0, 0] ``` Detailed Steps 1. **Left Products**: Construct a list `left_products` where `left_products[i]` contains the product of all elements to the left of `i`. 2. **Right Products**: Construct a list `right_products` where `right_products[i]` contains the product of all elements to the right of `i`. 3. **Final Product Calculation**: Use both `left_products` and `right_products` to compute the result list such that each `output[i]` equals `left_products[i] * right_products[i]`. # Solution Template ```python from typing import List def product_except_self(nums: List[int]) -> List[int]: n = len(nums) # Initialize left and right product lists left_products = [1] * n right_products = [1] * n # Fill left products for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Fill right products for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Combine left and right products output = [1] * n for i in range(n): output[i] = left_products[i] * right_products[i] return output # Example usage # assert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] # assert product_except_self([1, 2, 3, 0]) == [0, 0, 0, 6] # assert product_except_self([-1, 1, 0, -3, 3]) == [0, 0, 9, 0, 0] ``` Good luck and Happy Coding!","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: n = len(nums) # Initialize the result array with 1s result = [1] * n # Compute the prefix products prefix_product = 1 for i in range(n): result[i] = prefix_product prefix_product *= nums[i] # Compute the suffix products and multiply with the prefix products suffix_product = 1 for i in range(n-1, -1, -1): result[i] *= suffix_product suffix_product *= nums[i] return result"},{"question":"# Coding Assessment Question Implement a function to simulate a simplified e-commerce order processing system. You need to design a function that accepts a list of orders and returns a summary of order statistics including the total number of orders, the total value of all orders, the average value of an order, and the highest and lowest order values. Function Signature ```python def process_orders(orders: list) -> dict: ``` Input Specifications: - **orders** (*list*): A list of dictionaries, each representing an order. Each dictionary contains the following keys: - **order_id** (*str*): The unique identifier for the order. - **customer_id** (*str*): The unique identifier for the customer who placed the order. - **order_value** (*float*): The total value of the order. Output Specifications: - **output** (*dict*): A dictionary containing the following keys and corresponding values: - **total_orders** (*int*): The total number of orders. - **total_value** (*float*): The total value of all orders combined. - **average_value** (*float*): The average value of an order. - **highest_value** (*float*): The highest order value. - **lowest_value** (*float*): The lowest order value. Example Usage: ```python orders = [ {\\"order_id\\": \\"001\\", \\"customer_id\\": \\"C01\\", \\"order_value\\": 250.75}, {\\"order_id\\": \\"002\\", \\"customer_id\\": \\"C02\\", \\"order_value\\": 100.50}, {\\"order_id\\": \\"003\\", \\"customer_id\\": \\"C01\\", \\"order_value\\": 150.25}, {\\"order_id\\": \\"004\\", \\"customer_id\\": \\"C03\\", \\"order_value\\": 200.00}, ] result = process_orders(orders) print(result) # Expected output: # { # \\"total_orders\\": 4, # \\"total_value\\": 701.50, # \\"average_value\\": 175.38, # \\"highest_value\\": 250.75, # \\"lowest_value\\": 100.50 # } ``` Constraints: - Ensure proper handling of edge cases, such as an empty list of orders. - The values for **average_value**, **highest_value**, and **lowest_value** should be rounded to two decimal places. - Implement error-checking to handle invalid data types in the input list. - Assume all order values are non-negative. This task tests your ability to process collections of data, perform statistical operations, and handle typical edge cases in data processing.","solution":"def process_orders(orders: list) -> dict: if not orders: return { \\"total_orders\\": 0, \\"total_value\\": 0.0, \\"average_value\\": 0.0, \\"highest_value\\": 0.0, \\"lowest_value\\": 0.0 } total_orders = len(orders) total_value = sum(order[\'order_value\'] for order in orders) average_value = total_value / total_orders highest_value = max(order[\'order_value\'] for order in orders) lowest_value = min(order[\'order_value\'] for order in orders) return { \\"total_orders\\": total_orders, \\"total_value\\": round(total_value, 2), \\"average_value\\": round(average_value, 2), \\"highest_value\\": round(highest_value, 2), \\"lowest_value\\": round(lowest_value, 2) }"},{"question":"Write a function that takes a list of integers and returns a dictionary with each unique integer in the list as a key, and the value being the number of times that integer appears in the list. This function should disregard any non-integer elements in the input list. # Function Signature ```python def count_occurrences(elements: list) -> dict[int, int]: ``` # Input * `elements`: A list of elements which may include integers and other types (e.g., strings, floats). # Output * Returns a dictionary where each key is a unique integer from the input list, and the value is the count of occurrences of that integer in the list. # Constraints * The input list may contain zero or more elements of varying types. * An empty list should return an empty dictionary. * Only integer elements in the input list should be counted, ignoring other types. # Examples ```python print(count_occurrences([1, 2, 2, 3, 3, 3])) # {1: 1, 2: 2, 3: 3} print(count_occurrences([1, \'a\', 1.1, 2, 2, 3])) # {1: 2, 2: 2, 3: 1} print(count_occurrences([])) # {} print(count_occurrences([\'x\', \'y\', \'z\'])) # {} print(count_occurrences([1, 2, 1, 1, 2, 3, 1, 4, 5, 1])) # {1: 5, 2: 2, 3: 1, 4: 1, 5: 1} ``` # Additional Requirements 1. Ensure the implementation handles lists with mixed data types correctly. 2. Validate that the function\'s output is a dictionary. # Notes * Only integer elements should be considered when constructing the count dictionary. * Non-integer elements should simply be ignored.","solution":"def count_occurrences(elements: list) -> dict: Takes a list of elements and returns a dictionary with each unique integer in the list as a key, and the value being the number of times that integer appears in the list. Non-integer elements are disregarded. result = {} for elem in elements: if isinstance(elem, int): if elem in result: result[elem] += 1 else: result[elem] = 1 return result"},{"question":"# Problem Statement You are provided with a list of strings, each string composed of words separated by spaces. Your task is to implement an algorithm that will count the frequency of each word across all the strings, ignoring case. The return should be a case-insensitive sorted list of tuples, where each tuple contains a word and its frequency, both in lower case. # Function Signature Implement the following function: ```python def word_frequency(strings: List[str]) -> List[Tuple[str, int]]: pass ``` # Input - `strings`: A list of strings where each string consists of words separated by spaces. All words are composed of alphabetic characters only. # Output - A list of tuples: each tuple contains a word (in lower case) and its frequency as an integer, sorted in ascending order by the word. # Constraints - Each string can contain between 1 and 1000 words. - All words consist of alphabetic characters and have a length between 1 and 20 characters. - The length of words in each string and the number of words means the text size can be large. # Example ```python strings = [ \\"Hello world\\", \\"World of Python\\", \\"hello HELLO world world\\" ] result = word_frequency(strings) print(result) ``` Output: ``` [ (\'hello\', 3), (\'of\', 1), (\'python\', 1), (\'world\', 4) ] ``` # Hints 1. Use a dictionary to keep track of word frequencies. 2. Convert all words to lower case to handle case insensitivity before counting. 3. Finally, sort the dictionary by keys (the words) and convert it into a list of tuples.","solution":"from typing import List, Tuple from collections import Counter def word_frequency(strings: List[str]) -> List[Tuple[str, int]]: Returns the frequency of each word across all strings, case-insensitive. Parameters: strings (List[str]): A list of strings with words separated by spaces. Returns: List[Tuple[str, int]]: A sorted list of tuples, each containing a word and its frequency. word_count = Counter() for string in strings: words = string.lower().split() word_count.update(words) return sorted(word_count.items())"},{"question":"# Coding Assessment Question **Background**: Data structures are fundamental to efficient algorithm implementation. One such data structure is the Circular Queue, which follows the FIFO (first in, first out) principle but wraps around to the beginning of the queue when the end is reached. This ensures better utilization of space. **Task**: Write a class `CircularQueue` in Python that implements a circular queue with fixed capacity. Your class should provide methods to enqueue an element, dequeue an element, and check if the queue is empty or full. # Requirements: 1. **Class Signature**: ```python class CircularQueue: def __init__(self, k: int): pass def enqueue(self, value: int) -> bool: pass def dequeue(self) -> int: pass def isEmpty(self) -> bool: pass def isFull(self) -> bool: pass ``` 2. **Methods**: - `__init__(self, k: int)`: Initializes the queue with a fixed size `k`. - `enqueue(self, value: int) -> bool`: Adds an element `value` to the queue. Returns `True` if successful, `False` if the queue is full. - `dequeue(self) -> int`: Removes and returns the front element. Returns `-1` if the queue is empty. - `isEmpty(self) -> bool`: Checks if the queue is empty. - `isFull(self) -> bool`: Checks if the queue is full. 3. **Constraints**: - The size of the queue (`k`) is a positive integer (1 <= k <= 1000). - The elements to be enqueued are integers. 4. **Performance**: - All operations should have an average time complexity of O(1). # Example: ```python q = CircularQueue(3) print(q.enqueue(1)) # Expected output: True print(q.enqueue(2)) # Expected output: True print(q.enqueue(3)) # Expected output: True print(q.enqueue(4)) # Expected output: False print(q.isFull()) # Expected output: True print(q.dequeue()) # Expected output: 1 print(q.isFull()) # Expected output: False print(q.isEmpty()) # Expected output: False print(q.dequeue()) # Expected output: 2 print(q.dequeue()) # Expected output: 3 print(q.isEmpty()) # Expected output: True print(q.dequeue()) # Expected output: -1 ``` # Notes: - Ensure your implementation is efficient, using appropriate data structures to maintain O(1) time complexity for queue operations. - Include error handling for edge cases such as dequeuing from an empty queue or enqueueing into a full queue.","solution":"class CircularQueue: def __init__(self, k: int): self.size = k self.queue = [None] * k self.front = -1 self.rear = -1 def enqueue(self, value: int) -> bool: if self.isFull(): return False if self.isEmpty(): self.front = 0 self.rear = 0 else: self.rear = (self.rear + 1) % self.size self.queue[self.rear] = value return True def dequeue(self) -> int: if self.isEmpty(): return -1 result = self.queue[self.front] self.queue[self.front] = None if self.front == self.rear: self.front = -1 self.rear = -1 else: self.front = (self.front + 1) % self.size return result def isEmpty(self) -> bool: return self.front == -1 def isFull(self) -> bool: return (self.rear + 1) % self.size == self.front"},{"question":"# Scenario You are building an application that processes and analyzes properties of strings. One interesting problem is to find the lexicographically smallest permutation of a given string that meets a certain condition. The condition is that the resulting permutation must have no repeating adjacent characters. Your task is to implement a function that computes this permutation or determines if it\'s impossible. # Task Write a function `smallest_non_repeating_permutation(s: str) -> str` that returns the lexicographically smallest permutation of the input string `s` such that no two adjacent characters are the same. If no such permutation exists, return the string \\"IMPOSSIBLE\\". # Input - `s` (str): The input string consisting only of lowercase English letters (1 ≤ len(s) ≤ 1000). # Output - Returns the lexicographically smallest permutation of `s` with no adjacent repeating characters, or \\"IMPOSSIBLE\\" if no such permutation exists. # Constraints - Optimize to handle the potential length of the string efficiently. # Example ```python assert smallest_non_repeating_permutation(\\"aabb\\") == \\"abab\\" assert smallest_non_repeating_permutation(\\"aaab\\") == \\"IMPOSSIBLE\\" assert smallest_non_repeating_permutation(\\"abc\\") == \\"abc\\" ``` # Implementation Notes - Consider using a priority queue to efficiently manage the lexicographically smallest characters. - Utilize a counter or frequency dictionary to ensure no character exceeds allowable repetition constraints. - Account for edge cases such as strings with only one unique character.","solution":"from collections import Counter import heapq def smallest_non_repeating_permutation(s: str) -> str: Returns the lexicographically smallest permutation of the input string `s` such that no two adjacent characters are the same. If no such permutation exists, returns \\"IMPOSSIBLE\\". char_count = Counter(s) max_char = max(char_count.values()) # If the max occurrence of any character is more than half of the string length if it\'s odd or (len(s) + 1) // 2 if it\'s even, # it\'s impossible to form a non-repeating permutation. if max_char > (len(s) + 1) // 2: return \\"IMPOSSIBLE\\" # Priority queue to get the smallest character first pq = [] for char, count in char_count.items(): heapq.heappush(pq, (-count, char)) result = [] prev_char, prev_count = \'\', 0 while pq: count, current_char = heapq.heappop(pq) result.append(current_char) # If the previous character count is still left, push it back into queue if prev_count < 0: heapq.heappush(pq, (prev_count, prev_char)) prev_char = current_char prev_count = count + 1 # Reduce the count of current character since it has been used return \'\'.join(result)"},{"question":"# Coding Question: You need to implement a function to determine if a given integer is a prime number. The function should be designed to handle large inputs efficiently. **Function Signature:** ```python def is_prime(number: int) -> bool: pass ``` # Input: - `number` (int): An integer for which the primality needs to be checked. # Output: - Returns `True` if the given number is a prime number, otherwise returns `False`. # Constraints: 1. The input `number` will be a non-negative integer. For non-integer inputs, raise a `TypeError` with a message \\"Input value must be an \'int\' type\\". 2. If `number` is less than 2, return `False`. # Performance Requirements: - The function should run in (O(sqrt{n})) time complexity, where (n) is the input number. - The space complexity should be (O(1)). # Test Cases: 1. `is_prime(0)` should return `False` 2. `is_prime(1)` should return `False` 3. `is_prime(2)` should return `True` 4. `is_prime(3)` should return `True` 5. `is_prime(4)` should return `False` 6. `is_prime(17)` should return `True` 7. `is_prime(25)` should return `False` 8. `is_prime(7919)` should return `True` 9. For non-integer inputs like `is_prime(17.5)`, the function should raise a `TypeError` with message: \\"Input value must be an \'int\' type\\". # Scenario: The problem of determining whether a number is prime is fundamental in various fields including cryptography, where large primes are essential for key generation. Optimizing this function could be pivotal in improving the efficiency and security of cryptographic algorithms. Implement the function ensuring it handles the edge cases and large inputs efficiently.","solution":"def is_prime(number: int) -> bool: Determines if the input integer number is a prime number. Parameters: - number (int): The integer to check for primality. Returns: - bool: True if number is prime, False otherwise. Raises: - TypeError: If the input is not an integer. if not isinstance(number, int): raise TypeError(\\"Input value must be an \'int\' type\\") if number < 2: return False if number == 2 or number == 3: return True if number % 2 == 0 or number % 3 == 0: return False i = 5 while i * i <= number: if number % i == 0 or number % (i + 2) == 0: return False i += 6 return True"},{"question":"# Coding Assessment Question Scenario You are developing a tool to manage and analyze inventory in a warehouse. Each product in the warehouse is recorded with a unique item code, name, quantity, and expiration date. The tool should allow for updating inventory levels, retrieving products based on some criteria, and generating reports on inventory status. Task Write a class `InventoryManager` that will: 1. Add new products to the inventory. 2. Update the quantity of an existing product. 3. Retrieve products that are expiring within a specified number of days. 4. Generate a report of the total quantity of items in the inventory by category (initial letter of item name). # Class Signature ```python class InventoryManager: def __init__(self): pass def add_product(self, item_code: str, name: str, quantity: int, expiration_date: str): pass def update_quantity(self, item_code: str, quantity: int): pass def products_expiring_soon(self, days: int) -> list[dict]: pass def inventory_report(self) -> dict: pass ``` # Methods 1. `add_product`: Adds a new product to the inventory. * `item_code`: Unique identifier for the item (string). * `name`: Name of the product (string). * `quantity`: Quantity of the product (integer). * `expiration_date`: Expiration date in \'YYYY-MM-DD\' format (string). 2. `update_quantity`: Updates the quantity of an existing product. * `item_code`: Unique identifier for the item (string). * `quantity`: Quantity to be updated (integer). 3. `products_expiring_soon`: Retrieves a list of products that will expire within the specified number of days. * `days`: Number of days within which products are expiring (integer). * Returns a list of dictionaries with keys `item_code`, `name`, `quantity`, and `expiration_date`. 4. `inventory_report`: Generates a report of the total quantity of items categorized by the initial letter of the item name. * Returns a dictionary with the initial letter as the key and the total quantity as the value. # Example ```python inventory = InventoryManager() inventory.add_product(\\"001\\", \\"Apple\\", 50, \\"2023-10-15\\") inventory.add_product(\\"002\\", \\"Banana\\", 30, \\"2023-10-10\\") inventory.add_product(\\"003\\", \\"Avocado\\", 20, \\"2023-10-20\\") inventory.update_quantity(\\"002\\", 10) expiring_soon = inventory.products_expiring_soon(7) print(expiring_soon) # Expected output: # [{\'item_code\': \'002\', \'name\': \'Banana\', \'quantity\': 10, \'expiration_date\': \'2023-10-10\'}] report = inventory.inventory_report() print(report) # Expected output: # {\'A\': 70, \'B\': 10} ``` # Notes * Date comparison should handle various month and year changes. * Efficient handling of inventory lookup and updates is crucial. * Include necessary validations (e.g., avoid negative quantities). # Constraints * The initial inventory is empty. * Ensure unique item codes for products. * Handle up to 10,000 distinct products efficiently.","solution":"import datetime class InventoryManager: def __init__(self): self.inventory = {} def add_product(self, item_code: str, name: str, quantity: int, expiration_date: str): if item_code in self.inventory: raise ValueError(\\"Item code already exists\\") self.inventory[item_code] = { \\"name\\": name, \\"quantity\\": quantity, \\"expiration_date\\": datetime.datetime.strptime(expiration_date, \\"%Y-%m-%d\\").date() } def update_quantity(self, item_code: str, quantity: int): if item_code not in self.inventory: raise ValueError(\\"Item code does not exist\\") self.inventory[item_code][\\"quantity\\"] += quantity if self.inventory[item_code][\\"quantity\\"] < 0: raise ValueError(\\"Resulting quantity cannot be negative\\") def products_expiring_soon(self, days: int) -> list[dict]: today = datetime.date.today() deadline = today + datetime.timedelta(days=days) expiring_products = [] for item_code, details in self.inventory.items(): if details[\\"expiration_date\\"] <= deadline: expiring_products.append({ \\"item_code\\": item_code, \\"name\\": details[\\"name\\"], \\"quantity\\": details[\\"quantity\\"], \\"expiration_date\\": details[\\"expiration_date\\"].isoformat() }) return expiring_products def inventory_report(self) -> dict: report = {} for details in self.inventory.values(): initial = details[\\"name\\"][0].upper() if initial not in report: report[initial] = 0 report[initial] += details[\\"quantity\\"] return report"},{"question":"# Repeated Substring Pattern Check You are given a string consisting of lowercase alphabetic characters. Your task is to write a function to determine if the string can be constructed by repeating some substring of it. Requirements: - Implement a function `repeated_substring_pattern(s: str) -> bool` that returns `True` if the string can be constructed by repeating some substring of it; otherwise, return `False`. - The substring must be non-empty and smaller than the original string. Input: - s: A string with lowercase alphabetic characters only (e.g., \\"abab\\"). Output: - Return a boolean `True` if the string can be constructed by repeating some substring; otherwise, `False`. Constraints: - 1 ≤ len(s) ≤ 1000 Example: ```python assert repeated_substring_pattern(\\"abab\\") == True assert repeated_substring_pattern(\\"aba\\") == False assert repeated_substring_pattern(\\"abcabcabcabc\\") == True ``` Notes: 1. Ensure the function handles edge cases such as single-character strings or strings with no repeating patterns. 2. Consider different lengths of possible repeating substrings to determine if they can rebuild the original string precisely. 3. Optimize your solution to avoid unnecessary recomputations and checks for larger strings.","solution":"def repeated_substring_pattern(s: str) -> bool: n = len(s) # Efficient checking by considering possible substring lengths for i in range(1, n // 2 + 1): if n % i == 0: substring = s[:i] if substring * (n // i) == s: return True return False"},{"question":"# Sorted Double-Ended Queue You are required to implement a data structure called `SortedDeque` that combines the properties of a double-ended queue and a sorted list. This structure should allow inserting elements while maintaining sorted order and provide efficient access to the smallest and largest elements. Implement the following methods for the `SortedDeque` class: Class Definition Your task is to implement the `SortedDeque` class with the following methods: - `add_element(data: int)`: Inserts an element into the deque while maintaining sorted order. If the deque exceeds 100 elements, raise an `OverFlowError`. - `pop_min() -> int`: Removes and returns the smallest element from the deque. Raise an `UnderFlowError` if the deque is empty. - `pop_max() -> int`: Removes and returns the largest element from the deque. Raise an `UnderFlowError` if the deque is empty. - `__str__() -> str`: Returns a string representation of the deque, with elements in sorted order. Requirements: 1. The deque should handle up to 100 elements. 2. Insertions should maintain sorted order without degrading performance significantly. 3. Efficiently manage retrieval of the smallest and largest elements. 4. Ensure dequeues handle underflow conditions gracefully. Constraints: - Elements are integers and should be stored in non-decreasing order for easy retrieval. - The number of elements in the deque should not exceed 100. ```python class OverFlowError(Exception): pass class UnderFlowError(Exception): pass class SortedDeque: def __init__(self): # Initialize your internal structure here self.deque = [] def add_element(self, data: int) -> None: if len(self.deque) >= 100: raise OverFlowError() # Add the element while maintaining sorted order self.deque.append(data) self.deque.sort() def pop_min(self) -> int: if not self.deque: raise UnderFlowError() return self.deque.pop(0) def pop_max(self) -> int: if not self.deque: raise UnderFlowError() return self.deque.pop(-1) def __str__(self) -> str: return str(self.deque) # Example usage: # sd = SortedDeque() # sd.add_element(10) # sd.add_element(20) # sd.add_element(5) # print(sd) # Output: [5, 10, 20] # assert sd.pop_min() == 5 # assert sd.pop_max() == 20 # assert sd.pop_min() == 10 # try: # sd.pop_min() # except UnderFlowError: # print(\\"Deque is empty\\") # try: # sd.pop_max() # except UnderFlowError: # print(\\"Deque is empty\\") ``` Ensure the class definition and methods meet the described functionality, handle edge cases, and maintain the complexity constraints.","solution":"class OverFlowError(Exception): pass class UnderFlowError(Exception): pass class SortedDeque: def __init__(self): self.deque = [] def add_element(self, data: int) -> None: if len(self.deque) >= 100: raise OverFlowError() self.deque.append(data) self.deque.sort() def pop_min(self) -> int: if not self.deque: raise UnderFlowError() return self.deque.pop(0) def pop_max(self) -> int: if not self.deque: raise UnderFlowError() return self.deque.pop(-1) def __str__(self) -> str: return str(self.deque)"},{"question":"# Coding Assessment Question Context Data structures, such as trees, are crucial for many advanced computing tasks. Understanding how to manipulate tree data structures is essential for optimizing searches, implementing network protocols, and improving data storage and retrieval. Problem Write a Python function `max_depth(root)` that calculates the maximum depth of a binary tree. The maximum depth is the number of nodes from the root node down to the farthest leaf node. Expected Input and Output * **Input:** - A binary tree node defined by the `TreeNode` class: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` * **Output:** - Returns the maximum depth (int) of the given binary tree. Constraints * The number of nodes in the tree is in the range `[0, 10^4]`. * The depth of the tree will not exceed 10^4. * You may use a recursive or iterative approach. Example ```python def max_depth(root: TreeNode) -> int: Returns the maximum depth of a binary tree. :param root: TreeNode: Root node of the binary tree. :return: int: The maximum depth of the binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> max_depth(root) 3 >>> max_depth(TreeNode()) # Single node tree 1 >>> max_depth(None) # Empty tree 0 # TODO: Implement this function pass # Tree structure for testing root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) print(max_depth(root)) # Output should be 3 print(max_depth(TreeNode())) # Output should be 1 print(max_depth(None)) # Output should be 0 ``` Your solution should demonstrate: * Clear understanding of tree traversal techniques. * Correct calculation of tree depth using either recursion or iteration. * Efficient handling of tree nodes within the constraints.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root: TreeNode) -> int: Returns the maximum depth of a binary tree. :param root: TreeNode: Root node of the binary tree. :return: int: The maximum depth of the binary tree. if not root: return 0 else: left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"# Problem Statement Write a function that validates whether a given string representing a mathematical expression is correctly parenthesized. A correctly parenthesized expression means that every opening parenthesis \'(\' has a corresponding closing parenthesis \')\' and the pairs of parentheses are properly nested. # Task Implement the `is_valid_parentheses` function to check if the input string has properly nested and balanced parentheses. # Function Signature ```python def is_valid_parentheses(expression: str) -> bool: Your implementation to validate the parentheses ``` # Input and Output * **Input**: A string `expression` which contains characters including \'(\', \')\', and possibly other characters (e.g., `expression = \\"(a+b)\\"`). * **Output**: A boolean that returns `True` if the parentheses in the expression are valid, and `False` otherwise. # Constraints * The input string length can be up to 10,000 characters. * The string may contain letters, digits, operators, and whitespaces apart from parentheses. # Example ```python >>> is_valid_parentheses(\\"(a+b)\\") True >>> is_valid_parentheses(\\"((a*b)+c)\\") True >>> is_valid_parentheses(\\"(a+b))\\") False >>> is_valid_parentheses(\\"((a+b)\\") False >>> is_valid_parentheses(\\"a+(b*c)-((d/e))\\") True >>> is_valid_parentheses(\\"\\") True ``` # Additional Notes * Focus on correctly identifying matching pairs and the proper nesting of parentheses. * You may assume the input string will not contain any other types of brackets (e.g., curly braces or square brackets).","solution":"def is_valid_parentheses(expression: str) -> bool: Validates if the given string has properly nested and balanced parentheses. :param expression: A string containing an expression with parentheses. :return: True if the parentheses are valid, False otherwise. stack = [] for char in expression: if char == \'(\': stack.append(char) elif char == \')\': if not stack or stack[-1] != \'(\': return False stack.pop() return len(stack) == 0"},{"question":"# Problem Statement You are tasked with implementing a function that generates Pascal\'s Triangle up to a given number of rows n and returns the sum of a specified row k. **Function Signature**: `def pascal_triangle_row_sum(n: int, k: int) -> int` # Input - **n**: An integer n (1 ≤ n ≤ 50) representing the number of rows of Pascal\'s Triangle to generate. - **k**: An integer k (0 ≤ k < n) representing the row index whose sum is to be returned. # Output - **int**: The sum of the elements in the k-th row of Pascal\'s Triangle. # Constraints - Ensure that `0 ≤ k < n`. - Use efficient algorithms to handle the upper limits of inputs effectively. - Utilize combinatorial properties or optimization techniques to avoid recomputing values excessively. # Examples 1. **Input**: `n = 5`, `k = 2` **Output**: `4` (because the 2nd row of Pascal\'s Triangle is [1, 2, 1] and its sum is 1 + 2 + 1 = 4) 2. **Input**: `n = 10`, `k = 3` **Output**: `8` (because the 3rd row of Pascal\'s Triangle is [1, 3, 3, 1] and its sum is 1 + 3 + 3 + 1 = 8) 3. **Input**: `n = 6`, `k = 0` **Output**: `1` (because the 0th row of Pascal\'s Triangle is [1] and its sum is 1) # Instructions 1. Implement the function `pascal_triangle_row_sum(n: int, k: int) -> int`. 2. Conduct unit tests to validate the function with various values of n and k, ensuring it correctly computes the sum of the desired row. 3. Optimize the algorithm for improved performance, specifically focusing on utilizing Pascal\'s Triangle properties to minimize operations. # Hints - Recall that the sum of elements in the k-th row of Pascal\'s Triangle is (2^k). - Ensure edge cases such as k = 0 are handled correctly.","solution":"def pascal_triangle_row_sum(n: int, k: int) -> int: Returns the sum of the elements in the k-th row of Pascal\'s Triangle. # The sum of the elements in the k-th row of Pascal\'s Triangle is 2^k return 2 ** k"},{"question":"# Problem Description You are given a string consisting of lowercase alphabets and integers. Write a function that returns the decoded string following a specified pattern. The pattern is that each segment of the input has the form of `[count]substring`, where `substring` is to be repeated `count` times. # Function Signature ```python def decode_string(s: str) -> str: ``` # Input * `s` (str): A string containing digits and lowercase alphabets in the specified pattern. # Output * (str): The decoded string after processing all the segments. # Constraints * The length of the string `s` will be in the range [1, 10^5]. * Each number in the string `s` will be between 1 and 300. * The input is guaranteed to be a valid encoded string. # Example Cases Example 1: ```python s = \\"3[a]2[bc]\\" output = \\"aaabcbc\\" ``` Example 2: ```python s = \\"2[abc]3[cd]ef\\" output = \\"abcabccdcdcdef\\" ``` Example 3: ```python s = \\"10[a]2[bc]\\" output = \\"aaaaaaaaaabcbc\\" ``` # Additional Information 1. You can assume the input string is always valid and follows the described pattern strictly. 2. Consider using a stack-based approach for managing nested decoding patterns. 3. Your function should efficiently handle strings up to the maximum length constraint.","solution":"def decode_string(s: str) -> str: Returns the decoded string following the specified pattern. stack = [] current_num = 0 current_string = [] for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string = [] current_num = 0 elif char == \']\': last_string, repeat_num = stack.pop() current_string = last_string + current_string * repeat_num else: current_string.append(char) return \'\'.join(current_string)"},{"question":"You are asked to implement the Merge Sort algorithm, a classic divide-and-conquer sorting method, and demonstrate how it is applied to an array of integers. Please follow the requirements below: # Scenario You are given an unsorted array of integers. You need to write a Python function to sort this array using the Merge Sort algorithm. # Function Signature ```python def merge_sort(arr: list) -> list: Sorts an array of integers using the Merge Sort algorithm. Parameters: - arr: A list of integers to be sorted. Returns: - A new list containing the sorted integers. ``` # Constraints 1. You may assume that the input list contains a reasonable number of integers (e.g., up to 10^5). 2. The function should not modify the original list but return a new sorted list. 3. The function should be implemented recursively. # Examples ```python # Sorting example unsorted_array = [38, 27, 43, 3, 9, 82, 10] sorted_array = merge_sort(unsorted_array) print(f\\"Sorted array: {sorted_array}\\") # Expected output: # Sorted array: [3, 9, 10, 27, 38, 43, 82] ``` # Performance Requirements - The solution should efficiently handle large arrays up to the specified limit. - Ensure the implementation is clear, maintainable, and follows a logical structure suitable for educational contexts. # Additional Notes - Ensure that your implementation accurately follows the divide-and-conquer approach of Merge Sort, splitting the array into smaller subarrays, recursively sorting them, and then merging the sorted subarrays back together.","solution":"def merge_sort(arr: list) -> list: Sorts an array of integers using the Merge Sort algorithm. Parameters: - arr: A list of integers to be sorted. Returns: - A new list containing the sorted integers. if len(arr) <= 1: return arr def merge(left: list, right: list) -> list: sorted_list = [] left_index = right_index = 0 while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"# Question: Count the Number of Islands You are given a 2D grid map of \'1\'s (land) and \'0\'s (water). An island is surrounded by water and formed by connecting adjacent lands horizontally or vertically. You are tasked with writing a function to count the number of islands in the given grid. Your task is to implement the function `num_islands` that determines the number of islands present in the grid using Depth-First Search (DFS). Function Signature ```python def num_islands(grid: List[List[str]]) -> int: Args: grid (List[List[str]]): A list of lists representing the 2D grid consisting of \'1\'s and \'0\'s. Returns: int: The number of islands present in the grid. ``` Example ```python demo_grid = [ [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\"] ] print(num_islands(demo_grid)) # Output: 3 demo_grid_2 = [ [\\"1\\", \\"1\\", \\"1\\", \\"1\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\", \\"1\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"] ] print(num_islands(demo_grid_2)) # Output: 1 ``` Constraints - Grid dimensions (number of rows and columns) are at most 300 rows and 300 columns. - Each cell in the grid is either \'1\' (land) or \'0\' (water). - Islands are defined only by horizontal and vertical connections (no diagonal connections). Notes - Make sure your implementation efficiently traverses the grid to count the islands. - Use Depth-First Search (DFS) to mark the visited land. - Ensure the function handles edge cases correctly, such as when the grid is empty or consists entirely of water.","solution":"from typing import List def num_islands(grid: List[List[str]]) -> int: if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) visited = set() def dfs(r, c): stack = [(r, c)] while stack: row, col = stack.pop() if (row, col) not in visited: visited.add((row, col)) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dr, dc in directions: nr, nc = row + dr, col + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == \'1\' and (nr, nc) not in visited: stack.append((nr, nc)) islands = 0 for r in range(rows): for c in range(cols): if grid[r][c] == \'1\' and (r, c) not in visited: # Start a new island dfs(r, c) islands += 1 return islands"},{"question":"# K-Nearest Neighbors (KNN) from Scratch You are required to implement the K-Nearest Neighbors algorithm from scratch and optimize it for classification tasks. Implement the following functions: 1. **compute_distance** - To compute the distance between two samples. 2. **get_neighbors** - To find the k-nearest neighbors of a given sample. 3. **predict_class** - To predict the class label for a new sample based on k-nearest neighbors. 4. **evaluate_accuracy** - To evaluate the classification accuracy on a test dataset. # Function Definitions Function 1: compute_distance ```python def compute_distance(sample1: list[float], sample2: list[float]) -> float: Compute the Euclidean distance between two samples. Args: - sample1 (list[float]): First sample vector. - sample2 (list[float]): Second sample vector. Returns: - float: Euclidean distance between the two samples. ``` Function 2: get_neighbors ```python def get_neighbors(training_samples: list[list[float]], test_sample: list[float], k: int) -> list[list[float]]: Find the k-nearest neighbors of the test sample. Args: - training_samples (list[list[float]]): The training samples dataset. - test_sample (list[float]): The sample to find neighbors for. - k (int): The number of neighbors to find. Returns: - list[list[float]]: The k-nearest neighbors of the test sample. ``` Function 3: predict_class ```python def predict_class(training_samples: list[list[float]], training_labels: list[int], test_sample: list[float], k: int) -> int: Predict the class of the test sample using k-nearest neighbors. Args: - training_samples (list[list[float]]): The training samples dataset. - training_labels (list[int]): The class labels for the training samples. - test_sample (list[float]): The sample to predict the class for. - k (int): The number of neighbors to consider. Returns: - int: The predicted class label. ``` Function 4: evaluate_accuracy ```python def evaluate_accuracy(training_samples: list[list[float]], training_labels: list[int], test_samples: list[list[float]], test_labels: list[int], k: int) -> float: Evaluate the classification accuracy of the KNN algorithm on a test dataset. Args: - training_samples (list[list[float]]): The training samples dataset. - training_labels (list[int]): The class labels for the training samples. - test_samples (list[list[float]]): The test samples dataset. - test_labels (list[int]): The actual class labels for the test samples. - k (int): The number of neighbors to consider. Returns: - float: The classification accuracy. ``` # Input and Output - **Input**: - training_samples: List of training sample vectors (each vector is a list of floats). - training_labels: List of integers representing the class labels for the training samples. - test_sample: List of floats representing a test sample vector to be classified. - test_samples: List of test sample vectors. - test_labels: List of integers representing the class labels for the test samples. - k: Integer representing the number of neighbors to use. - **Output**: - For classification, the predicted class label of the test sample. - For accuracy evaluation, the classification accuracy as a float value. # Constraints - The sample arrays contain only floats. - The label arrays contain only integers. - All input arrays have lengths within the range [1, 1000]. - The value of `k` is a positive integer and at most the length of the training samples. # Additional Notes - Ensure that your implementation is optimized for time and space complexities. - Handle edge cases such as identical distances and empty arrays. - Include comments and docstrings for code clarity. # Example Usage ```python training_samples = [[1.0, 2.0], [2.0, 3.0], [3.0, 4.0], [1.0, 1.0]] training_labels = [0, 1, 1, 0] test_sample = [1.5, 2.5] k = 3 # Predict the class of the test sample predicted_label = predict_class(training_samples, training_labels, test_sample, k) print(f\\"Predicted class label: {predicted_label}\\") # Evaluate the classification accuracy test_samples = [[1.0, 2.0], [2.0, 3.0], [3.0, 4.0], [1.0, 1.0]] test_labels = [0, 1, 1, 0] accuracy = evaluate_accuracy(training_samples, training_labels, test_samples, test_labels, k) print(f\\"Classification accuracy: {accuracy}\\") ```","solution":"import math from collections import Counter def compute_distance(sample1: list[float], sample2: list[float]) -> float: Compute the Euclidean distance between two samples. Args: - sample1 (list[float]): First sample vector. - sample2 (list[float]): Second sample vector. Returns: - float: Euclidean distance between the two samples. distance = 0 for x1, x2 in zip(sample1, sample2): distance += (x1 - x2) ** 2 return math.sqrt(distance) def get_neighbors(training_samples: list[list[float]], test_sample: list[float], k: int) -> list[int]: Find the k-nearest neighbors of the test sample. Args: - training_samples (list[list[float]]): The training samples dataset. - test_sample (list[float]): The sample to find neighbors for. - k (int): The number of neighbors to find. Returns: - list[int]: Indices of the k-nearest neighbors of the test sample. distances = [] for idx, sample in enumerate(training_samples): distance = compute_distance(sample, test_sample) distances.append((idx, distance)) distances.sort(key=lambda x: x[1]) neighbors = [distances[i][0] for i in range(k)] return neighbors def predict_class(training_samples: list[list[float]], training_labels: list[int], test_sample: list[float], k: int) -> int: Predict the class of the test sample using k-nearest neighbors. Args: - training_samples (list[list[float]]): The training samples dataset. - training_labels (list[int]): The class labels for the training samples. - test_sample (list[float]): The sample to predict the class for. - k (int): The number of neighbors to consider. Returns: - int: The predicted class label. neighbors = get_neighbors(training_samples, test_sample, k) neighbor_labels = [training_labels[i] for i in neighbors] most_common = Counter(neighbor_labels).most_common(1) return most_common[0][0] def evaluate_accuracy(training_samples: list[list[float]], training_labels: list[int], test_samples: list[list[float]], test_labels: list[int], k: int) -> float: Evaluate the classification accuracy of the KNN algorithm on a test dataset. Args: - training_samples (list[list[float]]): The training samples dataset. - training_labels (list[int]): The class labels for the training samples. - test_samples (list[list[float]]): The test samples dataset. - test_labels (list[int]): The actual class labels for the test samples. - k (int): The number of neighbors to consider. Returns: - float: The classification accuracy. correct_predictions = 0 for test_sample, true_label in zip(test_samples, test_labels): predicted_label = predict_class(training_samples, training_labels, test_sample, k) if predicted_label == true_label: correct_predictions += 1 accuracy = correct_predictions / len(test_samples) return accuracy"},{"question":"Sorting Strings by Custom Alphabet Order # Problem Statement: In some applications, strings need to be sorted according to a custom-defined alphabet order, differing from the usual lexicographical order. Given such a custom order and a list of strings, you need to sort the strings according to this new order. Write a function `custom_sort(strings: List[str], order: str) -> List[str]` that: - Takes a list of strings `strings` and a string `order` that defines the custom alphabet order. - Returns a new list of strings where the elements are sorted based on the custom alphabet order. # Function Signature: ```python from typing import List def custom_sort(strings: List[str], order: str) -> List[str]: pass ``` # Input: - A list of strings `strings` where each string contains lowercase alphabetical characters only. - A string `order` which is a permutation of \\"abcdefghijklmnopqrstuvwxyz\\" defining the custom order. # Output: - A list of strings sorted according to the custom alphabet order. # Constraints: - Ensure the provided `order` string is exactly 26 characters long and contains every letter from \'a\' to \'z\' exactly once. - The input list `strings` can have up to 10,000 strings, and each string can be up to 100 characters long. # Examples: ```python assert custom_sort([\\"apple\\", \\"banana\\", \\"cherry\\"], \\"abcdefghijklmnopqrstuvwxyz\\") == [\\"apple\\", \\"banana\\", \\"cherry\\"] assert custom_sort([\\"apple\\", \\"banana\\", \\"cherry\\"], \\"zyxwvutsrqponmlkjihgfedcba\\") == [\\"cherry\\", \\"banana\\", \\"apple\\"] assert custom_sort([\\"word\\", \\"world\\", \\"row\\"], \\"worldabcefghijkmnpqstuvxyz\\") == [\\"world\\", \\"word\\", \\"row\\"] ``` # Implementation Guidance: - Create a mapping from each character in the custom order to its index to use for comparison of strings. - Implement a custom comparator function that utilizes the above mapping to sort the strings according to the provided order. - Ensure the solution handles large lists and long strings efficiently. # Note: Pay attention to edge cases such as strings of varying lengths and identical strings to ensure the results are correctly ordered according to the custom alphabet.","solution":"from typing import List def custom_sort(strings: List[str], order: str) -> List[str]: # Create a dictionary to map each character to its custom order index order_dict = {char: index for index, char in enumerate(order)} # Define a custom sort key function def sort_key(string): return [order_dict[char] for char in string] # Sort the strings using the custom sort key return sorted(strings, key=sort_key) # Example usage # print(custom_sort([\\"apple\\", \\"banana\\", \\"cherry\\"], \\"zyxwvutsrqponmlkjihgfedcba\\"))"},{"question":"# Dynamic Array Operations You are required to implement a dynamic array that supports the following operations efficiently. A dynamic array automatically resizes itself as elements are added or removed, ensuring the array can grow or shrink in capacity. Functions to Implement: 1. `append(element: int) -> None` - **Input**: - `element` (int): The integer element to be added to the end of the dynamic array. - **Output**: None. The element should be added to the end of the array. 2. `insert(index: int, element: int) -> None` - **Input**: - `index` (int): The position at which to insert the new element. - `element` (int): The integer element to be inserted. - **Output**: None. The element should be inserted at the specified position, shifting subsequent elements to the right. 3. `remove(index: int) -> int` - **Input**: - `index` (int): The position of the element to be removed. - **Output**: The integer element that was removed from the array. 4. `get(index: int) -> int` - **Input**: - `index` (int): The position of the element to retrieve. - **Output**: The integer element at the specified position. 5. `size() -> int` - **Output**: The number of elements currently in the dynamic array. Additional Constraints: * The `index` for insertion, removal, and retrieval will be valid (within the range of current array indices). * The dynamic array should start with an initial capacity and resize (typically doubling the capacity) when the number of elements exceeds the current capacity. Performance Requirements: * Appending elements must have an average time complexity of O(1). * All other operations (insert, remove, get, size) must be implemented with time complexity of O(1) for retrieval and removal, and O(n) for insertion due to the potential shift of elements. Examples: ```python # Initialize the dynamic array array = DynamicArray() # Append elements array.append(1) array.append(2) array.append(3) assert array.size() == 3 # Insert an element array.insert(1, 4) assert array.get(1) == 4 assert array.get(2) == 2 # Remove an element removed_element = array.remove(1) assert removed_element == 4 assert array.get(1) == 2 # Get an element assert array.get(0) == 1 assert array.get(2) == 3 ``` Create an implementation that correctly handles the dynamic resizing and the required operations as specified.","solution":"class DynamicArray: def __init__(self): self._capacity = 2 self._size = 0 self._array = [0] * self._capacity def append(self, element: int) -> None: if self._size == self._capacity: self._resize() self._array[self._size] = element self._size += 1 def insert(self, index: int, element: int) -> None: if self._size == self._capacity: self._resize() for i in range(self._size, index, -1): self._array[i] = self._array[i - 1] self._array[index] = element self._size += 1 def remove(self, index: int) -> int: element = self._array[index] for i in range(index, self._size - 1): self._array[i] = self._array[i + 1] self._size -= 1 return element def get(self, index: int) -> int: return self._array[index] def size(self) -> int: return self._size def _resize(self): self._capacity *= 2 new_array = [0] * self._capacity for i in range(self._size): new_array[i] = self._array[i] self._array = new_array"},{"question":"# Roman Numeral Conversion As part of an ancient history project, you\'re required to create a tool that converts between Roman numerals and their decimal (integer) equivalents. Task Implement a function `roman_to_integer` to convert a Roman numeral to its decimal representation, and a function `integer_to_roman` to do the reverse. Function Signatures ```python def roman_to_integer(s: str) -> int: Converts a Roman numeral to an integer. Parameters: s (str): A string representing the Roman numeral. Returns: int: The integer equivalent of the Roman numeral. def integer_to_roman(num: int) -> str: Converts an integer to a Roman numeral. Parameters: num (int): An integer between 1 and 3999 (inclusive). Returns: str: The Roman numeral representation of the integer. ``` Requirements 1. **Roman to Integer**: - Handle the common Roman numeral symbols: {\'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000}. - Properly account for subtractive notation (e.g. \'IV\' for 4, \'IX\' for 9). 2. **Integer to Roman**: - Convert integers between 1 and 3999 into their Roman numeral equivalents. - Use standard symbols and combinations based on traditional Roman numeral rules. Input and Output - **Input**: - A string `s` representing a Roman numeral. - An integer `num` between 1 and 3999. - **Output**: - An integer equivalent if converting from Roman numeral. - A string representing the Roman numeral if converting from an integer. Example ```python print(roman_to_integer(\'MCMXCIV\')) # Output: 1994 print(integer_to_roman(1994)) # Output: \\"MCMXCIV\\" ``` Constraints - The Roman numeral input string will be a valid Roman numeral within the range from 1 to 3999. - The integer input will be within the inclusive range from 1 to 3999.","solution":"def roman_to_integer(s: str) -> int: Converts a Roman numeral to an integer. Parameters: s (str): A string representing the Roman numeral. Returns: int: The integer equivalent of the Roman numeral. roman_to_int_map = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_to_int_map[char] if value < prev_value: total -= value else: total += value prev_value = value return total def integer_to_roman(num: int) -> str: Converts an integer to a Roman numeral. Parameters: num (int): An integer between 1 and 3999 (inclusive). Returns: str: The Roman numeral representation of the integer. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] symbols = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_numeral = \\"\\" i = 0 while num > 0: for _ in range(num // val[i]): roman_numeral += symbols[i] num -= val[i] i += 1 return roman_numeral"},{"question":"# Coding Assessment Question Task Write a function that finds all \\"self-dividing numbers\\" within a given range. A self-dividing number is defined as a number that is divisible by each of its digits without any remainder. The function should return a list of all self-dividing numbers within the specified range, inclusive. Function Signature ```python def self_dividing_numbers(left: int, right: int) -> List[int]: ``` # Input - `left` (int): The starting integer of the range. - `right` (int): The ending integer of the range. # Output - `List[int]`: A list of self-dividing numbers within the specified range. # Constraints - `1 <= left <= right <= 10000` # Requirements * A self-dividing number must be divisible by each of its digits without leaving a remainder. * No digit in the number can be zero since division by zero is undefined. * The output list should be in ascending order. # Example Here is an example of how your function might be called and what the expected output would be: ```python assert self_dividing_numbers(1, 22) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22] ``` # Notes * You must include appropriate checks for each digit within the number to ensure it satisfies the self-dividing property. * You can assume the range constraints will always be given as valid integers where `left <= right`. This question is designed to assess your ability to manipulate and analyze numerical properties effectively while working within integer ranges.","solution":"from typing import List def is_self_dividing(n: int) -> bool: Check if a number is self-dividing. original = n while n > 0: digit = n % 10 if digit == 0 or original % digit != 0: return False n //= 10 return True def self_dividing_numbers(left: int, right: int) -> List[int]: Find all self-dividing numbers within the given range [left, right]. result = [] for num in range(left, right + 1): if is_self_dividing(num): result.append(num) return result"},{"question":"# Coding Assessment Question **Context**: You are writing a utility for a text processing application, and one of the feature requirements is a function to perform compression of a string using a simple Run-Length Encoding (RLE) algorithm. The RLE algorithm is a lossless data compression method where consecutive occurrences of the same data value are stored as a single data value and the count. **Task**: Write a function `run_length_encode` that performs run-length encoding on an input string. Function Signature: ```python def run_length_encode(s: str) -> str: ``` Parameters: * `s` (str): A non-empty string consisting of uppercase and lowercase English letters. Returns: * `str`: The run-length encoded string. Rules: * Consecutive characters are encoded as the character followed by the count. * If the count is 1, the character appears alone without the number. Examples: ```python >>> run_length_encode(\\"aabcccccaaa\\") \'a2bc5a3\' >>> run_length_encode(\\"aaaaaaaaaa\\") \'a10\' >>> run_length_encode(\\"abcd\\") \'abcd\' ``` # Constraints: * The input string consists of alphabetical characters only (both uppercase and lowercase). * The function should efficiently handle long strings up to lengths of 100,000 characters. * Ensure the solution is optimal in terms of time complexity. Hints: * You can use a loop to iterate through the string and construct the encoded string. * Think about how you can efficiently keep track of counts for consecutive characters. Additional Information: Run-Length Encoding is a simple form of data compression that can be useful for compressing sequences of the same value. Use this [Wikipedia page](https://en.wikipedia.org/wiki/Run-length_encoding) for further reading.","solution":"def run_length_encode(s: str) -> str: Perform Run-Length Encoding on the input string. if not s: return \\"\\" encoded_string = [] count = 1 # Iterate over the string, skipping the first character for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: # Append the character and the count if greater than 1 encoded_string.append(s[i - 1]) if count > 1: encoded_string.append(str(count)) count = 1 # Append the last character and count encoded_string.append(s[-1]) if count > 1: encoded_string.append(str(count)) return \\"\\".join(encoded_string)"},{"question":"**Permutation Cycles Detection** You are given a permutation of the integers from `1` to `N` where each element in the permutation denotes the index of the next element to visit in a cycle. Your task is to identify and return all the individual cycles present in this permutation. # Task 1. **Identify Cycles**: Write a function `find_cycles` that processes the given permutation and returns all the disjoint cycles within the permutation. # Requirements 1. **find_cycles**: - Input: List of integers representing the permutation. - Output: List of lists, where each inner list represents a cycle and contains the elements in the order they are visited. # Constraints - The input permutation will have exactly `N` elements where `1 ≤ N ≤ 10^5`. - Each element in the permutation is a unique integer from `1` to `N`. - Ensure efficient handling of cycles so that the function runs in `O(N)` time complexity. # Example ```python permutation = [5, 4, 2, 3, 1] print(find_cycles(permutation)) # Output: [[1, 5], [2, 4, 3]] ``` In this example: - Starting from `1`, the permutation points to `5`, which points back to `1`, forming the cycle: `[1, 5]`. - Starting from `2`, it points to `4`, which points to `3`, which points back to `2`, forming the cycle: `[2, 4, 3]`. Please implement this function efficiently.","solution":"def find_cycles(permutation): Identifies and returns all the disjoint cycles present in the permutation. Args: - permutation (List[int]): A list of integers representing the permutation. Returns: - List[List[int]]: A list containing all the permutation cycles. visited = [False] * len(permutation) cycles = [] for start in range(len(permutation)): if not visited[start]: cycle = [] current = start + 1 while not visited[current - 1]: cycle.append(current) visited[current - 1] = True current = permutation[current - 1] cycles.append(cycle) return cycles"},{"question":"# Scenario You are responsible for developing a function as part of a system that processes lists of integers. One key feature is to remove duplicate integers from the list while maintaining the original order of their first occurrences. # Task Implement a function `remove_duplicates(arr: list) -> list` that removes duplicate values from the list and retains the order of their first occurrence. # Function Signature ```python def remove_duplicates(arr: list) -> list: pass ``` # Input * `arr`: A list of integers, where (0 ≤ len(arr) ≤ 10^6) and each element (−10^9 ≤ arr[i] ≤ 10^9). # Output * Returns a list of integers with duplicates removed, preserving the order of the first occurrences. # Examples ```python >>> remove_duplicates([1, 2, 3, 1, 2, 4]) [1, 2, 3, 4] >>> remove_duplicates([4, 3, 2, 1, 2, 3, 4]) [4, 3, 2, 1] >>> remove_duplicates([]) [] >>> remove_duplicates([1, 1, 1, 1]) [1] >>> remove_duplicates([10**9, -10**9, 2, 10**9, 3, -10**9]) [1000000000, -1000000000, 2, 3] ``` # Constraints * Do not use any external libraries. * Ensure the function performs efficiently for large input sizes. * Handle cases with an empty list, and lists where all elements are the same.","solution":"def remove_duplicates(arr): seen = set() result = [] for item in arr: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"# Problem Statement You are tasked with writing a function to generate all possible mnemonics for a given phone number. In this context, a mnemonic is a sequence of characters that maps the digits of the phone number to different letters according to the classic telephone keypad (2=ABC, 3=DEF, 4=GHI, etc.). Given a string `phone_number`, write a function `generate_mnemonics` that returns a list of all possible mnemonics. The function should handle only valid phone numbers, which consist solely of digits from 2 to 9 (inclusive). Function Signature ```python def generate_mnemonics(phone_number: str) -> List[str]: pass ``` # Input * `phone_number` (str): The input phone number string. The string contains only digits from 2 to 9. # Output * List[str]: A list containing all possible mnemonics for the given phone number. # Constraints * The length of the `phone_number` will not exceed `10` characters. * The `phone_number` will only contain digits from `2` to `9`. # Example ```python print(generate_mnemonics(\'23\')) # Output: [\'AD\', \'AE\', \'AF\', \'BD\', \'BE\', \'BF\', \'CD\', \'CE\', \'CF\'] print(generate_mnemonics(\'7\')) # Output: [\'P\', \'Q\', \'R\', \'S\'] print(generate_mnemonics(\'\')) # Output: [] print(generate_mnemonics(\'234\')) # Output: [\'ADG\', \'ADH\', \'ADI\', \'AEG\', \'AEH\', \'AEI\', \'AFG\', \'AFH\', \'AFI\', \'BDG\', \'BDH\', \'BDI\', \'BEG\', \'BEH\', \'BEI\', \'BFG\', \'BFH\', \'BFI\', \'CDG\', \'CDH\', \'CDI\', \'CEG\', \'CEH\', \'CEI\', \'CFG\', \'CFH\', \'CFI\'] ``` # Note * Each digit in the input corresponds to a set of possible letters as per the telephone keypad: - 2: ABC - 3: DEF - 4: GHI - 5: JKL - 6: MNO - 7: PQRS - 8: TUV - 9: WXYZ **Performance Requirements**: The implemented function should handle the input efficiently, utilizing recursion or iterative approaches to generate permutations.","solution":"from typing import List def generate_mnemonics(phone_number: str) -> List[str]: # Mapping of digits to corresponding letters on a classic telephone keypad digit_to_letters = { \\"2\\": \\"ABC\\", \\"3\\": \\"DEF\\", \\"4\\": \\"GHI\\", \\"5\\": \\"JKL\\", \\"6\\": \\"MNO\\", \\"7\\": \\"PQRS\\", \\"8\\": \\"TUV\\", \\"9\\": \\"WXYZ\\" } # If the input phone number is empty, return an empty list if not phone_number: return [] # Helper function to perform DFS and generate mnemonics def dfs(index, current_combination): # If we have reached the end of the phone number, add the current combination to the results if index == len(phone_number): mnemonics.append(\\"\\".join(current_combination)) return # Get the corresponding letters for the current digit letters = digit_to_letters[phone_number[index]] for letter in letters: # Append the current letter and move to the next digit current_combination.append(letter) dfs(index + 1, current_combination) # Backtrack to explore other combinations current_combination.pop() mnemonics = [] dfs(0, []) return mnemonics"},{"question":"**Scenario**: You are tasked with implementing a function that can perform matrix multiplication on two compatible matrices. Given two matrices `A` (of size `m x n`) and `B` (of size `n x p`), your task is to return their product matrix `C` (of size `m x p`). **Instructions**: - Implement the function `matrix_multiply` that multiplies two matrices `A` and `B`. - Return the resulting matrix `C`. **Function Signature**: The function signature should be as follows: ```python def matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: # Implementation code goes here ``` # Expected Input and Output **Input**: - `A` (List[List[int]]): A `m x n` matrix where each element is an integer. - `B` (List[List[int]]): A `n x p` matrix where each element is an integer. **Output**: - Return the product matrix `C` (List[List[int]]) of size `m x p`. # Sample Input: ```python A = [ [1, 2], [3, 4], [5, 6] ] B = [ [7, 8, 9], [10, 11, 12] ] print(matrix_multiply(A, B)) # Output should be [[27, 30, 33], [61, 68, 75], [95, 106, 117]] ``` **Constraints**: - Matrices `A` and `B` will always be such that the number of columns in `A` equals the number of rows in `B`. - Matrix dimensions are within the range `[1, 100]`. - Each element of the matrix will be an integer within the range `[-100, 100]`. **Performance Requirements**: The solution should work efficiently within the constraints provided.","solution":"from typing import List def matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Multiplies two matrices A and B and returns the result matrix. Parameters: A (List[List[int]]): The first matrix of size m x n. B (List[List[int]]): The second matrix of size n x p. Returns: List[List[int]]: The resulting matrix of size m x p. m = len(A) n = len(A[0]) p = len(B[0]) # Initialize the result matrix C with zeros C = [[0 for _ in range(p)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): C[i][j] += A[i][k] * B[k][j] return C"},{"question":"# Coding Assessment Question Problem Statement You need to create a function that simulates a simplified version of a social media platform where users can follow each other. The goal is to implement a function that returns the list of people followed by a specified user and the list of people who follow that user. Implement the function `social_media_followers` which takes in the following parameters and returns the desired result. Function Signature ```python def social_media_followers(users: list[int], follows: list[tuple[int, int]], user_id: int) -> tuple[list[int], list[int]]: pass ``` Input - `users (list[int])`: A list of integers representing user IDs on the platform. - `follows (list[tuple[int, int]])`: A list of tuples where each tuple (a, b) indicates that user \'a\' follows user \'b\'. - `user_id (int)`: The user ID for whom the lists of followed users and followers need to be returned. Output - Returns a tuple containing: - A list of integers representing the user IDs followed by the specified user. - A list of integers representing the user IDs who follow the specified user. Constraints - All user IDs will be positive integers. - Each user ID will be unique. - The number of follows will be at most 10^6. - The users list will have at least 1 and at most 10^5 elements. - If the specified `user_id` does not exist in the users list, return two empty lists. Requirements - Ensure the implementation is efficient enough to handle up to the maximum input sizes. Example ```python users = [1, 2, 3, 4, 5] follows = [(1, 2), (2, 3), (3, 4), (4, 5), (2, 4), (1, 5)] result = social_media_followers(users, follows, 2) print(result) ``` Expected Output: ``` ([3, 4], [1]) ``` --- Notes 1. Handle cases where the specified `user_id` does not follow anyone or is not followed by anyone. 2. Ensure the lists do not contain duplicates and are sorted in ascending order. 3. The function should maintain optimal time complexity for searching and retrieving the followed users and followers. ---","solution":"def social_media_followers(users, follows, user_id): Returns the list of people followed by the specified user and the list of people who follow that user. if user_id not in users: return ([], []) followed_by_user = set() followers_of_user = set() for follower, followed in follows: if follower == user_id: followed_by_user.add(followed) if followed == user_id: followers_of_user.add(follower) return (sorted(followed_by_user), sorted(followers_of_user))"},{"question":"# Coding Question Problem Statement You are required to implement a function `flip_dict` that takes a dictionary and returns a new dictionary with the keys and values swapped. In the new dictionary, if multiple keys from the original dictionary have the same value, they should be combined into a list. Function Signature ```python def flip_dict(original: dict) -> dict: pass ``` Input and Output Requirements * **Input**: - `original` (dict): A dictionary with any type of keys and values. * **Output**: - Returns a new dictionary where each original value is a key, and each corresponding original key is a value (or list of values if multiple original keys share that value). Constraints * The function should handle dictionaries with basic data types, like integers and strings, as well as more complex data types. * The function should not mutate the original dictionary. Examples 1. `flip_dict({\'a\': 1, \'b\': 2, \'c\': 1})` should return `{1: [\'a\', \'c\'], 2: \'b\'}` 2. `flip_dict({1: \'apple\', 2: \'banana\', 3: \'apple\'})` should return `{\'apple\': [1, 3], \'banana\': 2}` 3. `flip_dict({\'x\': \'y\', \'z\': \'y\', \'a\': \'b\'})` should return `{\'y\': [\'x\', \'z\'], \'b\': \'a\'}` 4. `flip_dict({})` should return `{}` Ensure your implementation correctly handles edge cases and produces the required output format.","solution":"def flip_dict(original: dict) -> dict: flipped = {} for key, value in original.items(): if value in flipped: if isinstance(flipped[value], list): flipped[value].append(key) else: flipped[value] = [flipped[value], key] else: flipped[value] = key return flipped"},{"question":"# Knapsack Problem using Genetic Algorithm **Context**: You are tasked with solving the 0/1 Knapsack Problem using a Genetic Algorithm. The knapsack problem is a classic combinatorial optimization problem where you are given a set of items, each with a weight and a value, and you need to determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible. A Genetic Algorithm (GA) is an optimization technique inspired by the process of natural selection. # Your Task: Implement the core components of the Genetic Algorithm to solve the Knapsack Problem: 1. **Fitness Function**: Write a function to calculate the fitness of a given solution. 2. **Selection**: Write a function to select parent solutions for crossover based on their fitness. 3. **Crossover**: Write a function to perform crossover between two parent solutions to generate offspring. 4. **Mutation**: Write a function to mutate a solution. 5. **GA Algorithm**: Integrate the above components into the main genetic algorithm to find and return the optimal selection of items and their total value. # Function Signatures: ```python def fitness(solution: list[int], values: list[int], weights: list[int], max_weight: int) -> int: pass def selection( population: list[list[int]], fitness_scores: list[int], num_parents: int ) -> list[list[int]]: pass def crossover(parent1: list[int], parent2: list[int]) -> list[int]: pass def mutate(solution: list[int], mutation_rate: float) -> list[int]: pass def main( values: list[int], weights: list[int], max_weight: int, population_size: int, generations_num: int, mutation_rate: float ) -> tuple[list[int], int]: pass ``` # Constraints: 1. The maximum number of items will not exceed 50. 2. The weights and values of each item will be within the range [1, 100]. 3. `max_weight`, `population_size`, `generations_num` must be positive integers, and `mutation_rate` must be a positive float. # Input/Output Format: - **Input**: - `values`: A list of integers representing the values of the items. - `weights`: A list of integers representing the weights of the items. - `max_weight`: The maximum weight the knapsack can carry. - `population_size`: Number of solutions in the population. - `generations_num`: Number of generations to evolve. - `mutation_rate`: Probability of mutation occurring in a solution. - **Output**: - A tuple containing: - `best_solution`: List of integers representing the best found solution. - `best_value`: The total value of the best found solution. # Example: ```python values = [20, 5, 10, 40, 15, 25] weights = [1, 2, 3, 8, 7, 4] max_weight = 10 best_solution, best_value = main( values=values, weights=weights, max_weight=max_weight, population_size=10, generations_num=50, mutation_rate=0.01 ) print(f\\"Best Solution: {best_solution}\\") print(f\\"Best Value: {best_value}\\") ``` # Choose appropriate libraries if necessary, but the core logic should remain self-contained within the provided function signatures.","solution":"import random def fitness(solution, values, weights, max_weight): total_value = sum(v for v, s in zip(values, solution) if s) total_weight = sum(w for w, s in zip(weights, solution) if s) if total_weight > max_weight: return 0 # Invalid solution due to exceeding weight return total_value def selection(population, fitness_scores, num_parents): sorted_population = [sol for _, sol in sorted(zip(fitness_scores, population), reverse=True)] return sorted_population[:num_parents] def crossover(parent1, parent2): point = random.randint(1, len(parent1) - 1) return parent1[:point] + parent2[point:] def mutate(solution, mutation_rate): for i in range(len(solution)): if random.random() < mutation_rate: solution[i] = 1 - solution[i] return solution def generate_initial_population(population_size, num_items): return [[random.randint(0, 1) for _ in range(num_items)] for _ in range(population_size)] def main(values, weights, max_weight, population_size, generations_num, mutation_rate): num_items = len(values) population = generate_initial_population(population_size, num_items) for _ in range(generations_num): fitness_scores = [fitness(sol, values, weights, max_weight) for sol in population] parents = selection(population, fitness_scores, population_size // 2) next_population = [] while len(next_population) < population_size: parent1, parent2 = random.sample(parents, 2) offspring = crossover(parent1, parent2) offspring = mutate(offspring, mutation_rate) next_population.append(offspring) population = next_population final_fitness_scores = [fitness(sol, values, weights, max_weight) for sol in population] best_index = final_fitness_scores.index(max(final_fitness_scores)) best_solution = population[best_index] best_value = fitness(best_solution, values, weights, max_weight) return best_solution, best_value"},{"question":"# Context String manipulation is a fundamental skill in programming, involving various operations such as searching, replacing, and formatting strings. One common use case is reformatting text input to match a specific pattern or rule set. Regular expressions (regex) are a powerful tool for pattern matching and string manipulation, allowing for concise and flexible solutions to complex string operations. Python\'s `re` module provides robust support for regex operations, enabling efficient string matching and manipulation. Given a string representing a phone number, the task involves parsing the string to determine if it matches a valid phone number format and then converting it into a standardized format. # Task Implement a function `format_phone_number` that takes a string representing a phone number, validates it against a predefined pattern, and converts it into a standardized format. 1. **Function Signature**: ```python def format_phone_number(phone: str) -> Union[str, None]: pass ``` 2. **Parameters**: - `phone`: A string representing the phone number. 3. **Returns**: - A string representing the phone number in the standardized format `(XXX) XXX-XXXX` if valid, otherwise `None`. # Constraints - The phone number string may contain digits, spaces, dashes, or parentheses. - The valid phone number must have exactly 10 digits. - Ignore any non-numeric characters during validation. # Example Consider the following phone number inputs: ```python phone1 = \\"123-456-7890\\" phone2 = \\"(123) 456 7890\\" phone3 = \\"123 456--7890\\" phone4 = \\"12345\\" print(format_phone_number(phone1)) # Output: (123) 456-7890 print(format_phone_number(phone2)) # Output: (123) 456-7890 print(format_phone_number(phone3)) # Output: (123) 456-7890 print(format_phone_number(phone4)) # Output: None ``` # Implementation Details 1. Use Python\'s `re` module to strip non-numeric characters from the input string. 2. Validate that the resulting string has exactly 10 digits. 3. Convert the validated string into the format `(XXX) XXX-XXXX`. 4. Return the formatted string or `None` if validation fails. # Sample Implementation ```python import re from typing import Union def format_phone_number(phone: str) -> Union[str, None]: # Remove all non-numeric characters digits = re.sub(r\'D\', \'\', phone) # Validate if the string has exactly 10 digits if len(digits) != 10: return None # Format the string into (XXX) XXX-XXXX formatted = f\\"({digits[:3]}) {digits[3:6]}-{digits[6:]}\\" return formatted # Example Usage phone1 = \\"123-456-7890\\" phone2 = \\"(123) 456 7890\\" phone3 = \\"123 456--7890\\" phone4 = \\"12345\\" print(format_phone_number(phone1)) # Output: (123) 456-7890 print(format_phone_number(phone2)) # Output: (123) 456-7890 print(format_phone_number(phone3)) # Output: (123) 456-7890 print(format_phone_number(phone4)) # Output: None ```","solution":"import re from typing import Union def format_phone_number(phone: str) -> Union[str, None]: Formats a phone number string to the format (XXX) XXX-XXXX if valid, otherwise returns None. Parameters: phone (str): A string representing the phone number. Returns: Union[str, None]: A string in the format (XXX) XXX-XXXX if valid, else None. # Remove all non-numeric characters digits = re.sub(r\'D\', \'\', phone) # Validate if the string has exactly 10 digits if len(digits) != 10: return None # Format the string into (XXX) XXX-XXXX formatted = f\\"({digits[:3]}) {digits[3:6]}-{digits[6:]}\\" return formatted"},{"question":"# Question: Rotate Matrix You need to write a function `rotate_matrix(matrix: List[List[int]]) -> List[List[int]]` that takes a square 2D matrix and rotates it 90 degrees clockwise in place. # Constraints * The size of the matrix (number of rows and columns) will be at most 100. * Each element of the matrix is an integer within the range from `-1000` to `1000`. * The input matrix will always be square (i.e., the number of rows is equal to the number of columns). # Input * A 2D matrix (list of lists) where each inner list represents a row of the matrix. # Output * The modified matrix after being rotated 90 degrees clockwise. # Examples Example 1 ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] output = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` Example 2 ```python matrix = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] output = [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] ``` # Additional Notes * You should not return anything from your function; instead, modify the matrix in place. * Pay attention to edge cases where the matrix size is 0x0 or 1x1, where the rotation should leave the matrix unchanged. Implement the function `rotate_matrix(matrix: List[List[int]])`, ensuring it handles all specified requirements efficiently.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates a square 2D matrix 90 degrees clockwise in place. :param matrix: A list of lists representing the square matrix n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# VLAN Creation and Validation You are working at a network company where you need to configure multiple VLANs (Virtual Local Area Networks) on a network switch. VLANs allow separate network segments within the same physical network, improving network performance and security. Given a list of VLAN IDs, your task is to validate and ensure no duplicate VLAN IDs are created. Additionally, you should return a list of valid and unique VLAN IDs. # Input * The function `validate_vlans` will receive a list of integers, representing VLAN IDs. # Output * The function should return a sorted and deduplicated list of integers, representing the valid VLAN IDs. # Constraints * A VLAN ID should be a positive integer within the range 1 to 4094. * The number of VLAN IDs provided can range from 1 to 1000. # Example ```python def validate_vlans(vlan_ids): # Implement this function pass # Test cases print(validate_vlans([10, 20, 10, 30, 4095])) # Output should be [10, 20, 30] print(validate_vlans([1, 2, 3, 4, 5])) # Output should be [1, 2, 3, 4, 5] print(validate_vlans([100, 4090, 20, 4094])) # Output should be [20, 100, 4090, 4094] print(validate_vlans([-1, 0, 20, 30, 1])) # Output should be [1, 20, 30] ``` **Explanation**: 1. In the case of input `[10, 20, 10, 30, 4095]`: * Remove duplicates and invalid VLANs. * Valid VLANs: 10, 20, 30. * Sorted and deduplicated output: `[10, 20, 30]`. 2. In the case of input `[1, 2, 3, 4, 5]`: * All VLANs are within the valid range. * No duplicates to remove. * Sorted output: `[1, 2, 3, 4, 5]`. Your function should handle edge cases correctly, provide accurate validation and return the correct sorted and unique list of VLAN IDs.","solution":"def validate_vlans(vlan_ids): Returns a sorted and deduplicated list of valid VLAN IDs. A valid VLAN ID is a positive integer within the range 1 to 4094. # Filter out invalid VLAN IDs and remove duplicates by converting to a set. valid_vlan_set = {vlan_id for vlan_id in vlan_ids if 1 <= vlan_id <= 4094} # Return the sorted list of valid VLAN IDs. return sorted(valid_vlan_set)"},{"question":"# Coding Question Context You are working for a logistics company to optimize the route planning of their delivery trucks. The current implementation uses a brute force method to determine the optimal route and takes too long for large sets of delivery locations. They need a more efficient solution. Problem Given a list of delivery locations represented by their coordinates, write a Python function `min_distance_route` that returns the minimum distance required to visit each location exactly once and return to the starting point. Requirements 1. Your function should handle edge cases such as empty input lists and lists with a single location. 2. Aim for better performance compared to a brute force solution. Input and Output Formats * **Input**: A list of tuples representing the (x, y) coordinates of each delivery location. ```python def min_distance_route(locations: list) -> float: pass ``` * **Output**: A float representing the minimum distance required to visit all locations and return to the start. Constraints * The coordinates will be integers. * You must optimize the performance to improve geometric calculations over O(n!). Example ```python assert min_distance_route([(0, 0), (1, 1), (1, 0), (0, 1)]) == 4.0 # Optimal route covers all points assert min_distance_route([(0, 0), (2, 0), (2, 2), (0, 2)]) == 8.0 # Square perimeter is optimal assert min_distance_route([(0, 0)]) == 0.0 # Only one point, distance is zero assert min_distance_route([]) == 0.0 # No points, distance is zero assert min_distance_route([(0, 0), (0, 0), (0, 0)]) == 0.0 # Identical points, no distance required ``` **Note**: Ensure that your solution retains the core functionality while enhancing performance, and properly handles all specified edge cases.","solution":"from itertools import permutations import math def calculate_distance(p1, p2): Calculate the Euclidean distance between two points p1 and p2. return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def total_distance(route): Calculate the total distance of the given route including returning to the start point. distance = 0.0 for i in range(len(route) - 1): distance += calculate_distance(route[i], route[i + 1]) distance += calculate_distance(route[-1], route[0]) return distance def min_distance_route(locations): Returns the minimum distance required to visit each location exactly once and return to the starting point. if not locations: return 0.0 # No locations provided if len(locations) == 1: return 0.0 # Only one location # Try all permutations to find the minimal route distance min_distance = float(\'inf\') for perm in permutations(locations): current_distance = total_distance(perm) if current_distance < min_distance: min_distance = current_distance return min_distance"},{"question":"String Pattern Matching Given a text string and a pattern string, implement a function to check if the pattern exists in the text. The function should use the Knuth-Morris-Pratt (KMP) algorithm to efficiently perform the pattern matching. # Function Signature: ```python def kmp_search(text: str, pattern: str) -> bool: ``` # Input: 1. `text`: A string representing the text in which the pattern needs to be searched. 2. `pattern`: A string representing the pattern that needs to be searched in the text. # Output: * Return `True` if the pattern exists in the text, otherwise return `False`. # Constraints: * `1 <= len(text) <= 5 * 10^4` * `1 <= len(pattern) <= 10^3` # Example: ```python text = \\"abxabcabcaby\\" pattern = \\"abcaby\\" print(kmp_search(text, pattern)) # Output: True ``` # Notes: * The KMP algorithm preprocesses the pattern string to create a longest prefix suffix (LPS) array, which is used to skip characters while matching the pattern in the text. * The function should run efficiently within the provided constraints and avoid brute-force solutions. * Pay attention to edge cases such as the pattern being an empty string or longer than the text itself.","solution":"def kmp_search(text: str, pattern: str) -> bool: if not pattern: return True if not text: return False # Preprocess the pattern to generate the longest prefix suffix (LPS) array lps = [0] * len(pattern) j = 0 # length of previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[j]: j += 1 lps[i] = j i += 1 else: if j != 0: j = lps[j - 1] else: lps[i] = 0 i += 1 # Start searching using the KMP algorithm i = j = 0 # index for text[], index for pattern[] while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): return True # Found pattern at index (i-j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return False # Pattern not found"},{"question":"# Question: Parking Lot Fee Calculator Problem Statement: You are required to implement a Python function that calculates the parking fee based on the number of hours a vehicle has been parked in a parking lot. The parking lot fee structure is as follows: - The first hour is free. - For every additional hour after the first hour, the fee is 2.50 per hour (or part of an hour). Function Signature: ```python def calculate_fee(hours_parked: float) -> float: ``` Input: - **hours_parked** (float): The number of hours a vehicle has been parked. (0 ≤ hours_parked ≤ 24) Output: - Returns the parking fee (float) in dollars. Constraints: - If `hours_parked` is negative or exceeds 24 hours, raise a `ValueError` with the message \\"Invalid number of hours\\". Examples: ```python >>> calculate_fee(0) 0.0 >>> calculate_fee(1) 0.0 >>> calculate_fee(1.5) 2.5 >>> calculate_fee(2) 2.5 >>> calculate_fee(3) 5.0 >>> calculate_fee(24) 57.5 >>> calculate_fee(-1) Traceback (most recent call last): ... ValueError: Invalid number of hours >>> calculate_fee(25) Traceback (most recent call last): ... ValueError: Invalid number of hours ``` Implementation: Use Python and ensure your function correctly calculates the fee based on the given fee structure. Consider edge cases such as parking for exactly one hour or fractional hours.","solution":"def calculate_fee(hours_parked: float) -> float: if hours_parked < 0 or hours_parked > 24: raise ValueError(\\"Invalid number of hours\\") if hours_parked <= 1: return 0.0 additional_hours = hours_parked - 1 return 2.5 * (additional_hours // 1 + (1 if additional_hours % 1 > 0 else 0))"},{"question":"# Problem: Optimal Staircase Construction You are tasked with designing an optimal staircase made up of equal-sized square tiles. The staircase consists of steps, where the number of tiles in each step increases from the first step to the top step in multiples of two. Your goal is to compute how many tiles are needed for a staircase with `n` steps. # Task: Implement the function `staircase_tiles(n: int) -> int` which: - Takes an integer `n` as input, representing the number of steps in the staircase. - Returns the total number of tiles required to construct the staircase. # Input: - `n` (1 ≤ `n` ≤ 10^6): An integer representing the number of steps in the staircase. # Output: - An integer representing the total number of tiles needed to build the staircase. # Examples: - `staircase_tiles(1)` should return `1` (1 tile for the 1st step). - `staircase_tiles(2)` should return `5` (1 tile for the 1st step, 4 tiles for the 2nd step). - `staircase_tiles(3)` should return `14` (1 tile for the 1st step, 4 tiles for the 2nd step, 9 tiles for the 3rd step). # Explanation: - The total number of tiles required for `n` steps can be represented by the series sum of squares of the first `n` positive integers. # Formula: The formula for the sum of squares of the first `n` positive integers is given by: [ text{Sum} = frac{n times (n + 1) times (2n + 1)}{6} ] # Implementation: Implement this formula in the function to efficiently compute the number of tiles required for very large values of `n`. # Constraints: - Ensure your algorithm is optimized to handle the upper limit efficiently (up to 10^6 steps). # Pseudocode: Here is a pseudocode to help you understand the calculation: ```python def staircase_tiles(n): return n * (n + 1) * (2 * n + 1) // 6 ``` # Note: - Be cautious of integer overflow in languages that do not natively support large integers. - Ensure your solution is efficient and can handle large values of `n` within reasonable time limits.","solution":"def staircase_tiles(n: int) -> int: Calculates the total number of tiles required for a staircase with n steps. The number of tiles in each step is a perfect square starting from 1^2. Args: n (int): The number of steps in the staircase. Returns: int: The total number of tiles needed. return n * (n + 1) * (2 * n + 1) // 6"},{"question":"# Context: In this task, you will be required to implement a function that performs matrix factorization using Alternating Least Squares (ALS). ALS is a popular algorithm used in collaborative filtering for recommendation systems. # Function Specification: Implement a function `matrix_factorization_ALS(R: np.ndarray, K: int, steps: int, alpha: float, beta: float) -> Tuple[np.ndarray, np.ndarray]` that: * Takes as input: - `R`: a 2D numpy array representing the user-item rating matrix (missing ratings are represented by zeros). - `K`: an integer representing the number of latent features. - `steps`: an integer representing the number of iterations to perform. - `alpha`: a float representing the learning rate. - `beta`: a float representing the regularization parameter. * Returns: - Two 2D numpy arrays `P` and `Q`, where `P` is the user feature matrix and `Q` is the item feature matrix. Constraints: 1. The input matrix `R` will have dimensions (n_users, n_items). 2. The input matrix may contain zeros indicating missing ratings. 3. Use numpy for matrix operations. 4. The function should use gradients for updating the user and item feature matrices. Examples: ```python >>> R = np.array([ ... [5, 3, 0, 1], ... [4, 0, 0, 1], ... [1, 1, 0, 5], ... [1, 0, 0, 4], ... [0, 1, 5, 4], ... ]) >>> P, Q = matrix_factorization_ALS(R, K=2, steps=1000, alpha=0.02, beta=0.02) >>> np.round(np.dot(P, Q.T)) array([ [5, 3, 2, 1], [4, 3, 2, 1], [1, 1, 2, 5], [1, 1, 2, 4], [2, 1, 5, 4], ]) ``` # Requirements: 1. Initialize the user feature matrix `P` and the item feature matrix `Q` with small random values. 2. Implement the ALS update rules to iteratively enhance `P` and `Q`. 3. Ensure to minimize the regularized squared error between the actual and predicted ratings during each iteration. 4. Return the final matrices `P` and `Q` after the specified number of iterations. # Additional Information: * The predicted rating matrix can be obtained by taking the dot product of `P` and `Q`. # Implementation: Write your solution within the function signature provided below: ```python import numpy as np from typing import Tuple def matrix_factorization_ALS(R: np.ndarray, K: int, steps: int, alpha: float, beta: float) -> Tuple[np.ndarray, np.ndarray]: Perform matrix factorization using Alternating Least Squares (ALS) algorithm. Args: R: The user-item rating matrix. K: The number of latent features. steps: The number of iterations. alpha: The learning rate. beta: The regularization parameter. Returns: A tuple containing two matrices P and Q. # Your implementation here ```","solution":"import numpy as np from typing import Tuple def matrix_factorization_ALS(R: np.ndarray, K: int, steps: int, alpha: float, beta: float) -> Tuple[np.ndarray, np.ndarray]: Perform matrix factorization using Alternating Least Squares (ALS) algorithm. Args: R: The user-item rating matrix. K: The number of latent features. steps: The number of iterations. alpha: The learning rate. beta: The regularization parameter. Returns: A tuple containing two matrices P and Q. n_users, n_items = R.shape P = np.random.rand(n_users, K) Q = np.random.rand(n_items, K) for step in range(steps): for i in range(n_users): for j in range(n_items): if R[i, j] > 0: eij = R[i, j] - np.dot(P[i, :], Q[j, :].T) for k in range(K): P[i, k] = P[i, k] + alpha * (2 * eij * Q[j, k] - beta * P[i, k]) Q[j, k] = Q[j, k] + alpha * (2 * eij * P[i, k] - beta * Q[j, k]) eR = np.dot(P, Q.T) e = 0 for i in range(n_users): for j in range(n_items): if R[i, j] > 0: e = e + pow(R[i, j] - np.dot(P[i, :], Q[j, :].T), 2) for k in range(K): e = e + (beta / 2) * (pow(P[i, k], 2) + pow(Q[j, k], 2)) if e < 0.001: break return P, Q.T"},{"question":"# Problem: Smallest Subarray with Sum Greater than Given Value Given an array of integers and a value `x`, find the length of the smallest contiguous subarray of which the sum is greater than `x`. If no such subarray exists, return 0. Input: Input consists of: - An array of integers `arr` (1 ≤ len(arr) ≤ 10^5). - An integer `x` (1 ≤ x ≤ 10^9). Output: Output the length of the smallest contiguous subarray with sum greater than `x`. If no such subarray exists, return 0. Example: ```python arr = [1, 4, 45, 6, 0, 19] x = 51 ``` Output: ```python 3 ``` Explanation: The smallest subarray with sum greater than 51 is [4, 45, 6] with length 3. Function Signature ```python def smallest_subarray_with_sum_greater_than_x(arr: list[int], x: int) -> int: Find the length of the smallest contiguous subarray with sum greater than x. Args: arr (list of ints): The array of integers. x (int): The target sum value. Returns: int: The length of the smallest subarray, or 0 if no such subarray exists. ``` # Constraints: - The length of the input array `arr` will be between 1 and 100,000. - The values in `arr` will be between 1 and 1,000,000. - The value `x` will be between 1 and 10^9. # Example Usage: ```python if __name__ == \\"__main__\\": print(smallest_subarray_with_sum_greater_than_x([1, 4, 45, 6, 0, 19], 51)) # Output: 3 print(smallest_subarray_with_sum_greater_than_x([1, 10, 5, 2, 7], 9)) # Output: 1 print(smallest_subarray_with_sum_greater_than_x([1, 11, 100, 1, 0, 200], 280)) # Output: 4 ``` # Approach: 1. Initialize `min_length` to a large number to store the minimum length of valid subarray found. 2. Use the sliding window technique to find the smallest subarray: - Maintain a window sum and a start pointer. - Expand the window by adding elements to the sum and incrementing the end pointer. - Shrink the window from the start until the sum is smaller than or equal to the target `x`. - Track the minimum length of the window that satisfies the condition. Here\'s a possible implementation for the function: ```python def smallest_subarray_with_sum_greater_than_x(arr: list[int], x: int) -> int: n = len(arr) min_length = n + 1 current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum > x: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length <= n else 0 # Example of usage if __name__ == \\"__main__\\": print(smallest_subarray_with_sum_greater_than_x([1, 4, 45, 6, 0, 19], 51)) # Output: 3 ```","solution":"def smallest_subarray_with_sum_greater_than_x(arr: list[int], x: int) -> int: Find the length of the smallest contiguous subarray with sum greater than x. Args: arr (list of ints): The array of integers. x (int): The target sum value. Returns: int: The length of the smallest subarray, or 0 if no such subarray exists. n = len(arr) min_length = n + 1 current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum > x: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length <= n else 0 # Example of usage if __name__ == \\"__main__\\": print(smallest_subarray_with_sum_greater_than_x([1, 4, 45, 6, 0, 19], 51)) # Output: 3"},{"question":"# Question You are tasked with creating a simple text editor that supports basic text formatting commands. Your job is to implement a class that tracks the current state of the document and applies formatting operations based on given commands. Implement the `TextEditor` class with the following methods: - `append(text: str)`: Appends the given text to the document. - `undo()`: Reverts the document to its state before the last operation. Supports unlimited undo operations. - `bold(range: tuple)`: Applies bold formatting to the specified range (inclusive). - `italic(range: tuple)`: Applies italics formatting to the specified range (inclusive). - `print()`: Returns the current state of the document with applied formatting. # Function Signature ```python class TextEditor: def __init__(self): pass def append(self, text: str): pass def undo(self): pass def bold(self, range: tuple): pass def italic(self, range: tuple): pass def print(self) -> str: pass ``` # Example ```python editor = TextEditor() editor.append(\\"Hello, World!\\") editor.bold((7, 11)) assert editor.print() == \\"Hello, <b>World</b>!\\" editor.append(\\" How are you?\\") assert editor.print() == \\"Hello, <b>World</b>! How are you?\\" editor.undo() assert editor.print() == \\"Hello, <b>World</b>!\\" editor.italic((0, 4)) assert editor.print() == \\"<i>Hello</i>, <b>World</b>!\\" editor.undo() assert editor.print() == \\"Hello, <b>World</b>!\\" editor.undo() assert editor.print() == \\"Hello, World!\\" ``` # Notes * Assume the text consists only of printable ASCII characters and spaces. * Each formatting operation should wrap the specified range with appropriate HTML-like tags (`<b>` for bold and `<i>` for italics). * All ranges provided are zero-based and inclusive at both ends. * Maintain an efficient way to handle unlimited undo operations. * Ensure your implementation is robust and handles edge cases effectively.","solution":"class TextEditor: def __init__(self): self.history = [] self.document = \\"\\" def append(self, text: str): self.history.append(self.document) self.document += text def undo(self): if self.history: self.document = self.history.pop() def bold(self, range: tuple): self.history.append(self.document) start, end = range self.document = self.document[:start] + \\"<b>\\" + self.document[start:end+1] + \\"</b>\\" + self.document[end+1:] def italic(self, range: tuple): self.history.append(self.document) start, end = range self.document = self.document[:start] + \\"<i>\\" + self.document[start:end+1] + \\"</i>\\" + self.document[end+1:] def print(self) -> str: return self.document"},{"question":"# Coding Assessment Question Context: A network security company has tasked you with analyzing and understanding traffic patterns in a network consisting of numerous interconnected devices. One of the frequent tasks is to verify that a given directed graph, representing the network, contains no cycles. Implementing an efficient cycle detection algorithm will help ensure the reliability of their network monitoring software. Task: Write a Python function named `has_cycle` that takes a directed graph (in form of an adjacency list) as input and returns a boolean indicating whether the graph contains a cycle. Specifications: - **Function Name**: `has_cycle` - **Parameters**: - `graph` (dict): A dictionary where keys are nodes and values are lists of nodes representing directed edges. - **Returns**: A boolean, `True` if the graph contains at least one cycle, otherwise `False`. # Constraints: 1. The graph does not contain duplicate edges. 2. The graph can be disconnected. 3. The graph can have up to 1,000 nodes. # Example: ```python assert has_cycle({1: [2], 2: [3], 3: [4], 4: [2, 5], 5: []}) == True # Contains cycle: 2 -> 3 -> 4 -> 2 assert has_cycle({1: [2], 2: [3], 3: [4], 4: [5], 5: []}) == False assert has_cycle({}) == False # Empty graph, no cycle assert has_cycle({1: [], 2: [], 3: []}) == False # Disconnected graph, no cycles assert has_cycle({1: [2], 2: [3], 3: [1]}) == True # Simple cycle: 1 -> 2 -> 3 -> 1 ```","solution":"def has_cycle(graph): Determines if the given directed graph contains a cycle. :param graph: A dictionary representing the graph where keys are nodes and values are lists of nodes. :return: Boolean, True if the graph contains a cycle, otherwise False. def dfs(node, visited, rec_stack): visited.add(node) rec_stack.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: if dfs(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True rec_stack.remove(node) return False visited = set() rec_stack = set() for node in graph.keys(): if node not in visited: if dfs(node, visited, rec_stack): return True return False"},{"question":"# Scenario You\'ve been hired by a logistics company to improve their delivery scheduling system. One of your tasks is to develop a function that can determine the maximum number of parcels that can be delivered within a given number of days, under specific constraints. Each parcel has a scheduled delivery day, and the company can deliver up to a certain number of parcels per day. # Problem Statement Given an integer `days`, a list of integers `delivery_days` where each integer represents the scheduled delivery day of a parcel, and an integer `max_parcels_per_day`, write a function `max_deliveries(days: int, delivery_days: List[int], max_parcels_per_day: int) -> int` that returns the maximum number of parcels that can be delivered within the specified number of days. # Input * `days` (Integer): The total number of days available for deliveries (1 ≤ days ≤ 10^6). * `delivery_days` (List[int]): A list of integers where each integer represents the scheduled delivery day of a parcel (1 ≤ delivery_days[i] ≤ days). * `max_parcels_per_day` (Integer): The maximum number of parcels that can be delivered in a single day (1 ≤ max_parcels_per_day ≤ 1000). # Output * Return the maximum number of parcels that can be delivered within `days`. # Example ```python >>> max_deliveries(10, [1, 2, 2, 3, 7, 7, 7, 9, 10], 2) 8 >>> max_deliveries(5, [1, 2, 2, 2, 3, 4, 5, 5], 1) 5 >>> max_deliveries(7, [1, 2, 3, 4, 5, 6, 7], 3) 7 ``` # Constraints * The function should handle edge cases, such as when no parcels are scheduled for delivery or when all parcels are scheduled for delivery on the same day. * Aim for an optimal solution in terms of both time and space complexity. # Note Consider using data structures that can efficiently manage and count parcel deliveries per day, and ensure that the solution can handle large inputs within reasonable time limits.","solution":"from typing import List from collections import Counter def max_deliveries(days: int, delivery_days: List[int], max_parcels_per_day: int) -> int: Returns the maximum number of parcels that can be delivered within the given number of days with the specified constraints. delivery_counts = Counter(delivery_days) total_deliveries = 0 for day in range(1, days + 1): if day in delivery_counts: total_deliveries += min(delivery_counts[day], max_parcels_per_day) return total_deliveries"},{"question":"# Problem Statement You are required to implement a `MaxHeap` class with the following functionalities: insertion, deletion, searching for a value, and extracting the maximum value. The goal is to practice creating and manipulating a max-heap data structure. Implement methods in the `MaxHeap` class to handle: 1. Inserting multiple values. 2. Searching for a value. 3. Removing the root/max value. 4. Extracting the maximum value. # Function Specifications 1. **Insert Function** ```python def insert(self, *values) -> None: ``` - **Input**: A sequence of integers representing values to be added to the heap. - **Output**: None. - **Constraints**: No duplicates exist in the initial input. 2. **Search Function** ```python def search(self, value: int) -> int | None: ``` - **Input**: An integer value. - **Output**: The index of the value if it exists, else None. - **Constraints**: Returns None for non-existing elements or empty heap. 3. **Remove Max Function** ```python def remove_max(self) -> int: ``` - **Input**: None. - **Output**: The maximum value which is removed from the heap. - **Constraints**: Raises IndexError if the heap is empty. 4. **Extract Max Function** ```python def extract_max(self) -> int: ``` - **Input**: None. - **Output**: The maximum value, without removing it. - **Constraints**: Raises IndexError if the heap is empty. # Examples ```python h = MaxHeap() h.insert(20, 15, 10, 8, 5, 7, 6) assert h.search(15) == 1 assert h.extract_max() == 20 assert h.remove_max() == 20 assert h.extract_max() == 15 h.insert(50) assert h.extract_max() == 50 ```","solution":"class MaxHeap: def __init__(self): self.heap = [] def insert(self, *values) -> None: for value in values: self.heap.append(value) self._heapify_up(len(self.heap) - 1) def search(self, value: int) -> int | None: try: return self.heap.index(value) except ValueError: return None def remove_max(self) -> int: if not self.heap: raise IndexError(\\"remove_max(): empty heap\\") max_value = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return max_value def extract_max(self) -> int: if not self.heap: raise IndexError(\\"extract_max(): empty heap\\") return self.heap[0] def _heapify_up(self, index: int) -> None: parent_index = (index - 1) // 2 if index > 0 and self.heap[index] > self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index: int) -> None: child_index = 2 * index + 1 if child_index >= len(self.heap): return if child_index + 1 < len(self.heap) and self.heap[child_index + 1] > self.heap[child_index]: child_index += 1 if self.heap[child_index] > self.heap[index]: self.heap[child_index], self.heap[index] = self.heap[index], self.heap[child_index] self._heapify_down(child_index)"},{"question":"# Coding Assessment Question You are tasked with writing a function that processes a log file to summarize error occurrences. The log file contains multiple lines, each representing a log entry with a timestamp and a message. Your function will read the log file, identify error messages, and output the number of occurrences of each unique error message. 1. **Input**: * The file path (`str`) of the log file. 2. **Behavior**: * Open and read the log file line by line. * Identify log entries that contain the word \\"ERROR\\". * Count the occurrences of each unique error message. * Ignore the timestamp and focus only on the error message content. * Return a dictionary where the keys are the unique error messages, and the values are their respective counts. * Implement error handling to manage file read errors. 3. **Output**: * A dictionary with error messages as keys and their counts as values. 4. **Constraints**: * Assume log entries follow the format: `YYYY-MM-DD HH:MM:SS [ERROR] Error message`. * The log file is not excessively large and can fit into memory. * Handle unexpected errors gracefully without crashing. Here is an example function signature to get you started: ```python def summarize_error_messages(log_file_path: str) -> dict: pass ``` **Performance Requirements**: - The function should complete in O(n) time complexity where n is the number of lines in the log file. - The space complexity should be O(k) where k is the number of unique error messages. Write the `summarize_error_messages` function according to the stated requirements.","solution":"def summarize_error_messages(log_file_path: str) -> dict: Reads a log file and summarizes the occurrences of each unique error message. Args: log_file_path (str): The path to the log file. Returns: dict: A dictionary where the keys are error messages and the values are the counts of their occurrences. error_counts = {} try: with open(log_file_path, \'r\') as file: for line in file: if \\"[ERROR]\\" in line: # Extract error message by splitting the line error_message = line.split(\\"[ERROR]\\")[1].strip() if error_message in error_counts: error_counts[error_message] += 1 else: error_counts[error_message] = 1 except IOError: print(f\\"Error: Unable to read file {log_file_path}\\") return error_counts"},{"question":"# Problem Statement You are given a grid with `n` rows and `m` columns, where each cell contains a single character either \'.\' (dot) or \'*\' (asterisk). Your task is to find the number of connected components in the grid, where each connected component is defined as a maximal set of adjacent \'*\' cells. Two cells are considered adjacent if they share a common side (up, down, left, or right). Write a function that counts the number of connected components of \'*\' in the provided grid. # Requirements: 1. Implement a function `count_asterisk_components(grid: List[List[str]]) -> int`. 2. Adjacent cells are only considered as those directly above, below, left, or right (no diagonals). 3. The solution should efficiently handle grids of modest size (maximum dimensions 100x100). 4. You may use Python\'s standard library only. # Inputs and Outputs: - **Input**: A 2D list of characters (`List[List[str]]`) representing the grid. - **Output**: An integer representing the number of connected components. # Function Signature ```python from typing import List def count_asterisk_components(grid: List[List[str]]) -> int: pass ``` # Example ```python def count_asterisk_components(grid: List[List[str]]) -> int: ... # Example usage: grid = [ [\'*\', \'*\', \'.\', \'.\', \'.\'], [\'*\', \'.\', \'*\', \'*\', \'.\'], [\'.\', \'.\', \'*\', \'.\', \'*\'], [\'.\', \'.\', \'.\', \'.\', \'*\'] ] print(count_asterisk_components(grid)) # Expected output: 3 ``` # Constraints: 1. The grid dimensions (`n` x `m`) are such that 1 <= n, m <= 100. 2. Each cell in the grid contains either a \'.\' or a \'*\'. 3. No external libraries are allowed except the standard library. # Notes: - Consider using Depth-First Search (DFS) or Breadth-First Search (BFS) to explore connected components. - Ensure that you appropriately mark cells as visited to avoid counting them multiple times. - Handle edge cases such as empty grids or grids without any \'*\' character.","solution":"from typing import List def count_asterisk_components(grid: List[List[str]]) -> int: if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): stack = [(r, c)] while stack: x, y = stack.pop() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and grid[nx][ny] == \'*\': visited[nx][ny] = True stack.append((nx, ny)) count = 0 for i in range(rows): for j in range(cols): if grid[i][j] == \'*\' and not visited[i][j]: count += 1 visited[i][j] = True dfs(i, j) return count"},{"question":"# Scenario You are tasked with implementing a data structure that can efficiently handle dynamic updates along with answering various types of range queries on an array. Specifically, you need to support the following operations: # Task Implement a Segment Tree with Lazy Propagation to handle the following types of queries and updates efficiently: 1. **Range Sum Query**: Compute the sum of elements in a specified range. 2. **Range Update Query**: Increment all elements in a specified range by a given value. 3. **Point Update Query**: Update a specific element to a new value. # Input and Output Format * **Input**: 1. `arr` - A list of integers representing the initial array. 2. `queries` - A list of dictionary objects, each with: - `type` - One of `\'range_sum\'`, `\'range_update\'`, or `\'point_update\'`. - Additional parameters based on `type`: - For `\'range_sum\'`: `start`, `end` (range boundaries). - For `\'range_update\'`: `start`, `end` (range boundaries), `value` (increment value). - For `\'point_update\'`: `index`, `value` (new value). * **Output**: - A list of integers, each being the result of a corresponding `\'range_sum\'` query. `\'range_update\'` and `\'point_update\'` queries result in modifications to the array but do not output any values. # Constraints - The list `arr` will contain integers where (0 leq arr[i] leq 10^6). - The length of `arr` will be up to (10^5). - The number of queries will be up to (10^4). Your implementation should prioritize efficient query handling. # Example ```python from typing import List, Dict, Union Query = Dict[str, Union[str, int]] def segment_tree_lazy(queries: List[Query], arr: List[int]) -> List[int]: # Your implementation here to build the tree and handle queries pass # Example usage: test_array = [1, 3, 5, 7, 9, 11] test_queries = [ {\\"type\\": \\"range_sum\\", \\"start\\": 1, \\"end\\": 3}, {\\"type\\": \\"range_update\\", \\"start\\": 1, \\"end\\": 4, \\"value\\": 3}, {\\"type\\": \\"range_sum\\", \\"start\\": 1, \\"end\\": 3}, {\\"type\\": \\"point_update\\", \\"index\\": 2, \\"value\\": 6} ] print(segment_tree_lazy(test_queries, test_array)) # Expected output: [15, 24] ``` # Explanation: In the provided example: 1. The first `\'range_sum\'` query calculates the sum of elements in the range [1, 3], resulting in `3 + 5 + 7 = 15`. 2. The `\'range_update\'` query increments all elements in the range [1, 4] by 3, modifying the array to `[1, 6, 8, 10, 12, 11]`. 3. The second `\'range_sum\'` query recalculates the sum for the same range, now resulting in `6 + 8 + 10 = 24`. 4. The `\'point_update\'` query updates the element at index 2 to the value 6, leaving the array as `[1, 6, 6, 10, 12, 11]`. Ensure to handle each type of query efficiently, leveraging the Segment Tree with Lazy Propagation for optimal performance.","solution":"from typing import List, Dict, Union Query = Dict[str, Union[str, int]] class SegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (4 * self.n) self.lazy = [0] * (4 * self.n) self.build(arr, 0, 0, self.n - 1) def build(self, arr, node, start, end): if start == end: self.tree[node] = arr[start] else: mid = (start + end) // 2 self.build(arr, 2 * node + 1, start, mid) self.build(arr, 2 * node + 2, mid + 1, end) self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2] def update_range(self, start, end, l, r, value, node=0): if self.lazy[node] != 0: self.tree[node] += (end - start + 1) * self.lazy[node] if start != end: self.lazy[2 * node + 1] += self.lazy[node] self.lazy[2 * node + 2] += self.lazy[node] self.lazy[node] = 0 if start > end or start > r or end < l: return if start >= l and end <= r: self.tree[node] += (end - start + 1) * value if start != end: self.lazy[2 * node + 1] += value self.lazy[2 * node + 2] += value return mid = (start + end) // 2 self.update_range(start, mid, l, r, value, 2 * node + 1) self.update_range(mid + 1, end, l, r, value, 2 * node + 2) self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2] def query_range(self, start, end, l, r, node=0): if self.lazy[node] != 0: self.tree[node] += (end - start + 1) * self.lazy[node] if start != end: self.lazy[2 * node + 1] += self.lazy[node] self.lazy[2 * node + 2] += self.lazy[node] self.lazy[node] = 0 if start > end or start > r or end < l: return 0 if start >= l and end <= r: return self.tree[node] mid = (start + end) // 2 left_sum = self.query_range(start, mid, l, r, 2 * node + 1) right_sum = self.query_range(mid + 1, end, l, r, 2 * node + 2) return left_sum + right_sum def update_point(self, start, end, idx, value, node=0): if start == end: self.tree[node] = value else: mid = (start + end) // 2 if start <= idx <= mid: self.update_point(start, mid, idx, value, 2 * node + 1) else: self.update_point(mid + 1, end, idx, value, 2 * node + 2) self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2] def segment_tree_lazy(queries: List[Query], arr: List[int]) -> List[int]: st = SegmentTree(arr) result = [] for query in queries: if query[\\"type\\"] == \\"range_sum\\": sum_res = st.query_range(0, st.n - 1, query[\\"start\\"], query[\\"end\\"]) result.append(sum_res) elif query[\\"type\\"] == \\"range_update\\": st.update_range(0, st.n - 1, query[\\"start\\"], query[\\"end\\"], query[\\"value\\"]) elif query[\\"type\\"] == \\"point_update\\": st.update_point(0, st.n - 1, query[\\"index\\"], query[\\"value\\"]) return result"},{"question":"Directory and File Size Analysis **Objective:** Write a Python function `analyze_directory(directory_path: str) -> List[Tuple[str, int]]` which recursively scans all files in the specified directory and its subdirectories, and returns a list of tuples where each tuple contains the file path and its size in bytes. **Input:** * A string `directory_path` representing the absolute or relative path to the directory to be analyzed. **Output:** * A list of tuples, each containing: * The file path as a string relative to the input directory. * The file size in bytes as an integer. **Constraints:** * Do not include directories in the output list; only files should be included. * Ensure that hidden files (those starting with a dot) are also included in the analysis. * Your function must handle large directories efficiently and should not crash due to memory issues. **Context:** Imagine you are developing a tool for users to evaluate the space taken by files within their directories. This tool will help users identify large files and organize their disk space more efficiently by providing detailed size information. **Requirements:** 1. Your function should recursively scan the input directory and its subdirectories to list all file paths and their sizes. 2. The file paths in the output must be relative to the input directory rather than absolute paths. 3. Use efficient file handling techniques to ensure the program remains responsive even with directories containing thousands of files. 4. Implement proper error handling to manage scenarios where files or directories may not have appropriate read permissions. **Example Usage:** ```python result = analyze_directory(\\"path/to/directory\\") for file_path, file_size in result: print(f\\"File Path: {file_path}nFile Size: {file_size} bytes\\") ``` Expected output for input `analyze_directory(\\"path/to/directory\\")` could look like: ``` File Path: data/file1.txt File Size: 1024 bytes File Path: data/subdir/image.jpg File Size: 20480 bytes File Path: hidden/.hiddenfile File Size: 512 bytes ``` Note: Ensure that the function handles potential issues like permission errors gracefully and does not halt execution unexpectedly due to such errors.","solution":"import os from typing import List, Tuple def analyze_directory(directory_path: str) -> List[Tuple[str, int]]: Recursively scans all files in the specified directory and its subdirectories, and returns a list of tuples containing the file path (relative to the input directory) and its size in bytes. file_list = [] for root, dirs, files in os.walk(directory_path): for file in files: file_path = os.path.join(root, file) try: file_size = os.path.getsize(file_path) relative_path = os.path.relpath(file_path, directory_path) file_list.append((relative_path, file_size)) except OSError: # In case of permission error, skip the file. continue return file_list"},{"question":"# Problem Statement You are given a list of integers. Your task is to implement a function that sorts the list using the merge sort algorithm. # Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: This function should sort the list `arr` using merge sort algorithm and return the sorted list. ``` # Input & Output - **Input**: - A list of integers `arr` where 1 <= len(arr) <= 1000. - **Output**: - The function should return a new list of integers which is the sorted version of the input list. # Examples 1. **Example 1**: ```python arr = [38, 27, 43, 3, 9, 82, 10] print(merge_sort(arr)) ``` **Output**: ``` [3, 9, 10, 27, 38, 43, 82] ``` 2. **Example 2**: ```python arr = [1, 4, 2, 8, 5, 7] print(merge_sort(arr)) ``` **Output**: ``` [1, 2, 4, 5, 7, 8] ``` 3. **Example 3**: ```python arr = [10, -1, 2, 5, 0, 6, 4, -5] print(merge_sort(arr)) ``` **Output**: ``` [-5, -1, 0, 2, 4, 5, 6, 10] ``` # Constraints - The elements of the list `arr` can range from -10^5 to 10^5. - The length of the list `arr` will not exceed 1000 elements. # Notes - Ensure that the merge sort algorithm is implemented correctly, maintaining O(n log n) time complexity. - You may not use built-in sort functions. Implement the `merge_sort` function.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list"},{"question":"# Question: Implement and Enhance Selection Sort **Context:** Selection Sort is a simple in-place comparison-based sorting algorithm, known for its simplicity and ease of implementation. **Objective:** Your task is to implement the Selection Sort algorithm that not only sorts the array but also returns the number of comparisons made during the sorting process. **Function Signature:** ```python def selection_sort_enhanced(array: list) -> tuple: Sorts the array using Selection Sort algorithm and returns a tuple with sorted array and count of comparisons. Args: array (list): A list of elements to be sorted. Returns: tuple: A tuple containing the sorted array and an integer count of comparisons performed during sorting. pass ``` **Requirements:** * Implement Selection Sort to sort the array in-place. * Track and return the number of comparisons made during sorting. * Maintain the original Selection Sort properties while implementing the enhancements. **Input:** - A list of comparable elements, e.g., integers, floats. The input list can be of any length, including zero. **Output:** - A tuple with the first element being the sorted list and the second element an integer representing the number of comparisons made during sorting. **Constraints:** - The input list can have elements in any order, including sorted or reverse sorted. - Ensure minimal changes to the original Selection Sort properties. - Aim to keep the space complexity the same, O(1). **Examples:** ```python >>> selection_sort_enhanced([4, 3, 2, 1]) ([1, 2, 3, 4], 6) >>> selection_sort_enhanced([-4, 20, 0, -50, 100, -1]) ([-50, -4, -1, 0, 20, 100], 15) >>> selection_sort_enhanced([-.1, -.2, 1.3, -.8]) ([-0.8, -0.2, -0.1, 1.3], 6) >>> selection_sort_enhanced([]) ([], 0) ``` **Edge Cases to Consider:** - Empty array `[]` - Arrays with duplicate elements, e.g., `[3, 3, 1, 1]` - Arrays with all identical elements, e.g., `[1, 1, 1, 1]`","solution":"def selection_sort_enhanced(array): Sorts the array using Selection Sort algorithm and returns a tuple with sorted array and count of comparisons. Args: array (list): A list of elements to be sorted. Returns: tuple: A tuple containing the sorted array and an integer count of comparisons performed during sorting. n = len(array) comparison_count = 0 for i in range(n): min_idx = i for j in range(i + 1, n): comparison_count += 1 if array[j] < array[min_idx]: min_idx = j array[i], array[min_idx] = array[min_idx], array[i] return array, comparison_count"},{"question":"# Problem Statement A company needs a tool to help them monitor the even performance of their service clusters over time. They want you to create a function that returns the average of all even numbers in a given list. Your task is to write a function that computes this average efficiently, adhering to certain constraints and requirements. # Function Signature ```python def average_of_evens(numbers: List[int]) -> float: pass ``` # Input - A list of integers, `numbers` (1 ≤ len(numbers) ≤ 10^6, -10^6 ≤ numbers[i] ≤ 10^6). # Output - Return a float that represents the average of all even numbers in the list. If there are no even numbers, return 0. # Constraints - You must achieve an efficient solution using a single pass through the list. - Avoid using any additional data structures or excessive memory allocation. # Examples 1. **Example 1:** - Input: `numbers = [1, 2, 3, 4, 5, 6]` - Output: `4.0` - Explanation: The even numbers are 2, 4, and 6. Average = (2 + 4 + 6) / 3 = 4.0. 2. **Example 2:** - Input: `numbers = [1, 3, 5, 7]` - Output: `0.0` - Explanation: There are no even numbers in the list. 3. **Example 3:** - Input: `numbers = [2, 4, 6, 8, 10]` - Output: `6.0` - Explanation: The even numbers are 2, 4, 6, 8, and 10. Average = (2 + 4 + 6 + 8 + 10) / 5 = 6.0. # Performance Requirements Your solution should run efficiently with a time complexity of (O(n)) and a constant space complexity, (O(1)).","solution":"from typing import List def average_of_evens(numbers: List[int]) -> float: Returns the average of all even numbers in the given list. If there are no even numbers, returns 0. Parameters: numbers (List[int]): A list of integers. Returns: float: The average of all even numbers. total_sum = 0 count = 0 for number in numbers: if number % 2 == 0: total_sum += number count += 1 if count == 0: return 0.0 return total_sum / count"},{"question":"# Question You are required to implement a function to determine the next permutation of a given list of numbers in lexicographical order. If the given list is the largest permutation, your function should return the smallest permutation (i.e., sorted in ascending order). Function Signature ```python def next_permutation(nums: List[int]) -> List[int]: ``` Requirements: 1. **Function**: `next_permutation(nums: List[int]) -> List[int]` - The function should rearrange numbers to the next lexicographical permutation. - If the list is sorted in descending order, return the list sorted in ascending order (i.e., smallest permutation). - Handle lists containing duplicates. - Should operate in O(n) time complexity and use O(1) extra space where `n` is the number of elements in the list. Input - `nums`: A list of integers. Output - Returns a list of integers representing the next permutation in lexicographical order. Constraints - Each element in `nums` must be an integer. - The number of elements in `nums` can range from 1 to 10^4. Example ```python >>> next_permutation([1, 2, 3]) [1, 3, 2] >>> next_permutation([3, 2, 1]) [1, 2, 3] >>> next_permutation([1, 1, 5]) [1, 5, 1] ``` Scenario Consider implementing your solution while keeping in mind possible edge cases such as handling duplicate numbers, the smallest and largest possible permutations, and list sizes up to `10^4`. Ensure that your implementation is efficient and manages large input sizes effectively.","solution":"from typing import List def next_permutation(nums: List[int]) -> List[int]: Rearranges numbers to the next lexicographical permutation. If nums are sorted in descending order, returns the lowest permutation. # Find the longest non-increasing suffix and find the pivot pivot = len(nums) - 2 while pivot >= 0 and nums[pivot] >= nums[pivot + 1]: pivot -= 1 if pivot == -1: # The entire array is non-increasing which means it\'s the last permutation nums.reverse() return nums # Find the rightmost successor to the pivot for i in range(len(nums) - 1, pivot, -1): if nums[i] > nums[pivot]: nums[i], nums[pivot] = nums[pivot], nums[i] break # Reverse the suffix nums[pivot + 1:] = reversed(nums[pivot + 1:]) return nums"},{"question":"# List Operations **Context**: Manipulating lists is a fundamental skill in programming. Your goal is to implement a series of utility functions that perform various operations on lists of integers. **Tasks**: 1. `remove_duplicates(lst: List[int]) -> List[int]`: Removes duplicate elements from the list while preserving the order of the remaining elements. 2. `rotate_list(lst: List[int], k: int) -> List[int]`: Rotates the list to the right by `k` steps. 3. `chunk_list(lst: List[int], size: int) -> List[List[int]]`: Divides the list into chunks of the specified size. If the list cannot be evenly divided, the last chunk will contain the remaining elements. 4. `sum_pairwise(lst1: List[int], lst2: List[int]) -> List[int]`: Returns a list containing the pairwise sums of elements from two lists of the same length. 5. `find_missing_numbers(lst: List[int], n: int) -> List[int]`: Finds the missing numbers from 1 to `n` in the list. **Input and Output**: - **Input**: Each function takes a list of integers, and some functions take additional parameters (an integer). - **Output**: - For `remove_duplicates`, `rotate_list`, and `chunk_list`, return a list. - For `sum_pairwise`, return a list. - For `find_missing_numbers`, return a list. **Constraints**: - `1 <= len(lst) <= 10^4` - `0 <= lst[i] <= 10^4` - For `rotate_list`, `0 <= k <= 10^4` - For `chunk_list`, `1 <= size <= 10^4` - For `sum_pairwise`, `len(lst1) == len(lst2)` - For `find_missing_numbers`, `1 <= n <= 10^4` **Performance Requirements**: Aim for optimal performance appropriate for the function\'s complexity, with efficient use of time and space. **Examples**: ```python assert remove_duplicates([1, 3, 3, 2, 1]) == [1, 3, 2] assert rotate_list([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert chunk_list([1, 2, 3, 4, 5, 6, 7], 3) == [[1, 2, 3], [4, 5, 6], [7]] assert sum_pairwise([1, 2, 3], [4, 5, 6]) == [5, 7, 9] assert find_missing_numbers([2, 3, 7], 7) == [1, 4, 5, 6] ``` **Note**: Implement the following functions in a single file named `list_operations.py`. Make sure to import the necessary modules and handle edge cases as required.","solution":"from typing import List def remove_duplicates(lst: List[int]) -> List[int]: seen = set() result = [] for num in lst: if num not in seen: seen.add(num) result.append(num) return result def rotate_list(lst: List[int], k: int) -> List[int]: k = k % len(lst) if lst else 0 return lst[-k:] + lst[:-k] def chunk_list(lst: List[int], size: int) -> List[List[int]]: return [lst[i:i+size] for i in range(0, len(lst), size)] def sum_pairwise(lst1: List[int], lst2: List[int]) -> List[int]: return [x + y for x, y in zip(lst1, lst2)] def find_missing_numbers(lst: List[int], n: int) -> List[int]: return list(set(range(1, n+1)) - set(lst))"},{"question":"# Coding Assessment Question Context: You are developing an application that processes text data and extracts useful information. Often, you need to determine the similarity between two given strings. One effective method for this task is calculating the Levenshtein distance, which measures the minimum number of single-character edits required to transform one string into the other. Task: Implement a function `levenshtein_distance(s1, s2)` to calculate the Levenshtein distance between two strings. Requirements: - Implement a function `levenshtein_distance(s1, s2)`: - **Inputs**: - `s1` (str): The first string. - `s2` (str): The second string. - **Output**: An integer representing the Levenshtein distance between the two input strings. - **Constraints**: - String lengths are between 0 and 1000 (inclusive). - Both strings contain only lowercase letters (a-z). Performance Requirements: - The function should compute the Levenshtein distance efficiently within the given constraints. Examples: ```python >>> levenshtein_distance(\\"kitten\\", \\"sitting\\") 3 >>> levenshtein_distance(\\"flaw\\", \\"lawn\\") 2 >>> levenshtein_distance(\\"\\", \\"\\") 0 >>> levenshtein_distance(\\"horse\\", \\"ros\\") 3 >>> levenshtein_distance(\\"intention\\", \\"execution\\") 5 ``` Note: - Consider edge cases involving empty strings and strings of significantly different lengths. - Optimize your solution to handle the maximum input sizes efficiently.","solution":"def levenshtein_distance(s1, s2): Calculate the Levenshtein distance between two strings. Args: s1 (str): The first string. s2 (str): The second string. Returns: int: The Levenshtein distance between the two input strings. if len(s1) == 0: return len(s2) if len(s2) == 0: return len(s1) # Initialize the matrix dp = [[0 for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)] # Fill the initial values for i in range(len(s1) + 1): dp[i][0] = i for j in range(len(s2) + 1): dp[0][j] = j # Fill the dp matrix for i in range(1, len(s1) + 1): for j in range(1, len(s2) + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) return dp[len(s1)][len(s2)]"},{"question":"# Binary Tree Level Order Traversal Task Objective: Your task is to implement a `BinaryTree` class with a method `level_order_traversal` that performs a level order traversal (breadth-first traversal) of the binary tree and returns a list of the values in level order. Requirements: 1. Implement the `BinaryTree` class with a root node. 2. Implement the `Node` class to represent each node in the binary tree. 3. The `level_order_traversal` method should return a list containing the node values in the order they are visited. Class Definition: ```python class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BinaryTree: def __init__(self, root=None): self.root = root def level_order_traversal(self): if not self.root: return [] queue = [self.root] result = [] while queue: current_node = queue.pop(0) result.append(current_node.data) if current_node.left: queue.append(current_node.left) if current_node.right: queue.append(current_node.right) return result ``` Testing: - Create multiple test cases to validate behavior: 1. Trees of varying sizes. 2. Edge cases like an empty tree or a tree with only one node. 3. Trees with different structures and configurations. Example: ```python # Constructing the tree: # 1 # / # 2 3 # / # 4 5 6 root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.right = Node(6) tree = BinaryTree(root) print(tree.level_order_traversal()) # [1, 2, 3, 4, 5, 6] ``` **Output**: ```shell [1, 2, 3, 4, 5, 6] ``` Ensure to handle edge cases and verify that the traversal returns the correct level order sequence.","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BinaryTree: def __init__(self, root=None): self.root = root def level_order_traversal(self): if not self.root: return [] queue = [self.root] result = [] while queue: current_node = queue.pop(0) result.append(current_node.data) if current_node.left: queue.append(current_node.left) if current_node.right: queue.append(current_node.right) return result"},{"question":"# Problem Description You are given a `n x n` grid representing a garden. Each cell in the grid can contain either a plant, indicated by a `1`, or be empty, indicated by a `0`. The objective is to find the maximum number of plants that can be visited starting from any cell containing a `1` and moving to adjacent cells horizontally or vertically. Consider cells connected directly or indirectly to be part of the same contiguous group. # Function Signature ```python def max_plants_visited(grid: list[list[int]]) -> int: Determines the maximum number of plants that can be visited in a contiguous group in the garden. Parameters: grid (list[list[int]]): 2D list of integers representing the garden Returns: int: Maximum number of plants that can be visited in one contiguous group ``` # Input * A list of lists of integers `grid` of size `n x n`, where each element is either `1` or `0`. # Output * An integer representing the maximum number of plants that can be visited in one contiguous group. # Constraints * `1 <= n <= 10` * The elements of `grid` will be only `0` or `1`. # Example ```python # Example 1 print(max_plants_visited([ [1, 0, 1, 1], [1, 1, 0, 0], [0, 1, 1, 0], [1, 0, 0, 1] ])) # Expected Output: 5 # Example 2 print(max_plants_visited([ [0, 0, 0], [0, 1, 0], [0, 0, 0] ])) # Expected Output: 1 ``` # Instructions 1. Implement the `max_plants_visited` function that finds the largest contiguous group of `1`s in the grid. 2. You will be evaluated based on the correctness and efficiency of your implemented solution. 3. Write the function to handle edge cases such as completely empty grids or grids with no contiguous plants.","solution":"def max_plants_visited(grid): def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= n or grid[x][y] == 0: return 0 grid[x][y] = 0 # Mark it visited by setting it to 0 return 1 + dfs(x + 1, y) + dfs(x - 1, y) + dfs(x, y + 1) + dfs(x, y - 1) n = len(grid) max_plants = 0 for i in range(n): for j in range(n): if grid[i][j] == 1: max_plants = max(max_plants, dfs(i, j)) return max_plants"},{"question":"# Scenario As a part of the application\'s data security feature, you have been tasked to create a function that efficiently generates a list of prime numbers. These prime numbers will be used for various cryptographic operations across the application. # Coding Task Implement a function `generate_primes` that takes an integer `n` as input and returns a list of all prime numbers less than `n`. You must use the Sieve of Eratosthenes algorithm to ensure optimal performance. # Constraints 1. **Inputs**: - `n`: Integer, 2 ≤ n ≤ 10^7. 2. **Outputs**: - Return a list of all prime numbers less than `n` as integers. If there are no prime numbers, return an empty list. # Example ```python def generate_primes(n: int): # implementation required here assert generate_primes(10) == [2, 3, 5, 7] assert generate_primes(20) == [2, 3, 5, 7, 11, 13, 17, 19] assert generate_primes(2) == [] assert generate_primes(1) == [] assert generate_primes(30) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] ``` # Additional Requirements 1. **Efficient memory usage**: Employ memory-efficient techniques suitable for handling upper limit inputs. 2. Ensure proper handling of edge cases, for example when `n` is very close to its boundary values. Focus on writing clean and well-documented code that adheres to the performance requirements.","solution":"def generate_primes(n: int): Returns a list of all prime numbers less than n using the Sieve of Eratosthenes. Parameters: - n (int): an integer, 2 ≤ n ≤ 10^7 Returns: - List[int]: a list of all prime numbers less than n if n <= 2: return [] # Initialize a boolean array to track prime numbers is_prime = [True] * n is_prime[0] = is_prime[1] = False # 0 and 1 are not primes p = 2 while p * p <= n: if is_prime[p]: for multiple in range(p * p, n, p): is_prime[multiple] = False p += 1 return [num for num in range(n) if is_prime[num]]"},{"question":"# Question: Add a `to_postorder_list` Method to the BinaryTree Data Structure Given the `BinaryTree` class along with its associated methods and functionalities, your task is to enhance this class by adding a method that returns a list of the tree\'s elements in postorder traversal. **Definition**: Postorder traversal is a depth-first search where the nodes are recursively visited in this order: Left subtree, Right subtree, Root node. The task is broken down as follows: 1. Implement a method `to_postorder_list` in the `BinaryTree` class that returns a list of node values following postorder traversal. **Expected Input and Output**: * Input: None (Operates directly on the instance of the BinaryTree). * Output: List of node values in postorder traversal order. **Constraints**: * The tree can be empty, in such cases, return an empty list. * Ensure the solution is efficient and handle large trees gracefully. # Example ```python # Example of usage: binary_tree = BinaryTree.small_tree() print(binary_tree.to_postorder_list()) # Expected output might be: [left_subtree_values, right_subtree_values, root_value] binary_tree = BinaryTree.medium_tree() print(binary_tree.to_postorder_list()) # Expected output corresponding to postorder traversal of a medium-sized tree. ``` # Performance Requirements Your method should ideally run in O(n) time complexity, where n is the number of nodes in the tree, due to the necessity of visiting each node exactly once. The space complexity should also be considerate of the call stack space in recursion, which would be O(h), where h is the height of the tree. Your task: 1. Enhance the `BinaryTree` class per the requirements. 2. Write appropriate test cases to validate the solution. Good luck!","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.value = key class BinaryTree: def __init__(self, root=None): self.root = root @staticmethod def small_tree(): root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) return BinaryTree(root) @staticmethod def medium_tree(): root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.left = Node(6) root.right.right = Node(7) root.left.left.left = Node(8) root.left.left.right = Node(9) return BinaryTree(root) def to_postorder_list(self): def postorder(node): if not node: return [] return postorder(node.left) + postorder(node.right) + [node.value] return postorder(self.root)"},{"question":"# Task: Implement a Document Word Counter Background You need to develop a function that reads a text document, processes its content, and counts the occurrences of each word. The function should be able to ignore common stopwords and handle different punctuation marks and cases. Requirements 1. **Input**: * A single file path (string) pointing to a text document. * Example: `\\"document.txt\\"` 2. **Output**: * A dictionary where the keys are words and the values are their counts in the document. * Example: `{\'example\': 3, \'test\': 2, \'document\': 5}` 3. **Constraints**: * The function should ignore case (i.e., treat \\"Word\\" and \\"word\\" as the same). * Handle punctuation marks by stripping them from words. * Exclude common English stopwords (e.g., \\"and\\", \\"the\\", \\"is\\", etc.) from counting. * Ensure the function can handle large files efficiently. 4. **Performance**: * Optimize for speed and memory usage. * Aim to read the file and process its content in a single pass. Function Signature ```python def word_counter(file_path: str) -> dict[str, int]: pass ``` Example Usage ```python word_counts = word_counter(\\"document.txt\\") print(f\\"Word counts in the document:\\") for word, count in word_counts.items(): print(f\\"{word}: {count}\\") ```","solution":"import re from collections import defaultdict def word_counter(file_path: str) -> dict[str, int]: stopwords = { \'the\', \'and\', \'is\', \'in\', \'it\', \'of\', \'to\', \'a\', \'with\', \'as\', \'for\', \'on\', \'at\', \'by\', \'an\', \'be\', \'this\', \'that\', \'which\', \'or\', \'from\', \'but\', \'not\', \'are\', \'was\', \'were\', \'if\', \'you\', \'your\', \'we\', \'can\' } word_count = defaultdict(int) with open(file_path, \'r\', encoding=\'utf-8\') as file: for line in file: words = re.findall(r\'bw+b\', line.lower()) for word in words: if word not in stopwords: word_count[word] += 1 return dict(word_count)"},{"question":"# Problem Statement In this task, you are required to implement a function that detects the edges in an image using a different approach instead of using built-in edge detection methods. # Function Signature ```python def detect_edges(img_path: str, threshold: float) -> None: Detects edges in an image using Sobel operators and saves the result. Parameters: img_path (str): The path to the input image file. threshold (float): The threshold value for considering a pixel as an edge. Returns: None ``` # Input * `img_path` (str): A valid file path to the input image. * `threshold` (float): A threshold value for edge detection - pixel values above this threshold will be considered as edges. # Output * The function should save the edge-detected image to a file named `edges_output.png` in the current working directory. # Constraints * The function should raise a `ValueError` if the `threshold` is not within the range [0.0, 255.0]. * You may assume that the input image path is valid and the image load operation will succeed. # Performance Requirements * The implementation should efficiently handle images of size up to 4096x4096 pixels. # Example ```python # Detect edges in an image with a threshold of 100 and save as \'edges_output.png\' detect_edges(\\"image_data/lena.jpg\\", 100) ``` # Notes * You must use the `numpy` library to handle pixel manipulation. * You may use the `PIL` (Pillow) library for loading and saving images. * Ensure that the output image contains pixel values of either 0 or 255, representing non-edge and edge pixels respectively. # Hints * Convert the image to grayscale if it is not already in that format. * Apply the Sobel operator to compute the gradient magnitude. * Compare the gradient magnitude against the threshold to determine edge pixels. * Clip the final pixel values to [0, 255].","solution":"import numpy as np from PIL import Image import scipy.ndimage def detect_edges(img_path: str, threshold: float) -> None: Detects edges in an image using Sobel operators and saves the result. Parameters: img_path (str): The path to the input image file. threshold (float): The threshold value for considering a pixel as an edge. Returns: None if not (0.0 <= threshold <= 255.0): raise ValueError(\\"Threshold must be between 0.0 and 255.0\\") # Load the image img = Image.open(img_path).convert(\\"L\\") img_array = np.asarray(img) # Sobel operator to detect edges sobel_x = np.array([[ -1, 0, 1], [ -2, 0, 2], [ -1, 0, 1]]) sobel_y = np.array([[ -1, -2, -1], [ 0, 0, 0], [ 1, 2, 1]]) grad_x = scipy.ndimage.convolve(img_array, sobel_x) grad_y = scipy.ndimage.convolve(img_array, sobel_y) grad_magnitude = np.sqrt(grad_x**2 + grad_y**2) # Apply the threshold to get the edges edges = (grad_magnitude > threshold) * 255 edges = edges.astype(np.uint8) # Save the result edge_image = Image.fromarray(edges) edge_image.save(\\"edges_output.png\\")"},{"question":"# Coding Assessment Question In the world of competitive programming, you often deal with operations on subarrays. One of the frequent tasks is to determine if a subarray has a certain property or not. This problem is about finding the longest subarray within an array that consists of all even integers. Objective: Write a function `longest_even_subarray(arr: List[int]) -> int` that takes a list `arr` of integers and returns the length of the longest contiguous subarray consisting of only even numbers. Input: - `arr`: a list of integers where 1 <= len(arr) <= 10^5 and -10^9 <= arr[i] <= 10^9. Output: - Returns an integer representing the length of the longest contiguous subarray which consists solely of even numbers. Example: ```python assert longest_even_subarray([1, 2, 4, 6, 3, 8, 10, 12]) == 3 assert longest_even_subarray([1, 3, 5, 7, 9]) == 0 assert longest_even_subarray([2, 4, 6, 8, 10]) == 5 assert longest_even_subarray([]) == 0 assert longest_even_subarray([-4, 2, -6, 7, 10, -8]) == 3 ``` Constraints: - The solution should aim for a time complexity of O(n), where n is the length of the array `arr`. - The function should efficiently handle large input sizes typical in competitive programming environments. - The implementation should correctly identify sequences of even integers even if they include negative numbers.","solution":"def longest_even_subarray(arr): Returns the length of the longest contiguous subarray consisting of only even numbers. max_length = 0 current_length = 0 for num in arr: if num % 2 == 0: current_length += 1 else: max_length = max(max_length, current_length) current_length = 0 # Check at the end of the array max_length = max(max_length, current_length) return max_length"},{"question":"# Question: You are given a sorted array of unique integers and a target integer. Your task is to find the index of the target number in the array. If the target does not exist in the array, return the index where it would be if it were inserted in order. You must implement a binary search algorithm to achieve this. **Function Signature**: ```python def search_insert_position(nums: List[int], target: int) -> int: Finds the index of the target number in a sorted array of unique integers, or the index where it would be if inserted in order. :param nums: A sorted list of unique integers. :param target: An integer representing the target number. :return: An integer representing the index of the target, or the index where the target would be inserted. Example: >>> nums = [1, 3, 5, 6] >>> target = 5 >>> search_insert_position(nums, target) 2 >>> target = 2 >>> search_insert_position(nums, target) 1 Constraints: - 1 <= len(nums) <= 10^4 - -10^4 <= nums[i], target <= 10^4 ``` **Requirements**: 1. Implement the binary search algorithm to find the appropriate index. 2. Ensure the function handles edge cases (e.g., empty array). 3. The function should exhibit a time complexity of O(log n). **Example**: ```python >>> nums = [1, 3, 5, 6] >>> target = 7 >>> print(search_insert_position(nums, target)) 4 >>> nums = [1, 3, 5, 6] >>> target = 0 >>> print(search_insert_position(nums, target)) 0 ```","solution":"from typing import List def search_insert_position(nums: List[int], target: int) -> int: Finds the index of the target number in a sorted array of unique integers, or the index where it would be if inserted in order. :param nums: A sorted list of unique integers. :param target: An integer representing the target number. :return: An integer representing the index of the target, or the index where the target would be inserted. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"Coding Assessment Question Context You\'ve had practice with sorting algorithms and integer properties. Now let\'s put that knowledge into generating special sequences. Your task is to implement an algorithm that generates the first `n` numbers in the Fibonacci sequence iteratively and ensures it handles large ranges efficiently. The Task Using your knowledge of iterative methods and number sequences, implement an algorithm to return the first `n` Fibonacci numbers. Input A single integer `n` (0 ≤ n ≤ 10^5). Output A list containing the first `n` Fibonacci numbers. Performance Requirements - Your solution should be efficient: aim for O(n) time complexity and O(n) space complexity. # Implementation Guide 1. Implement the main function `fibonacci_sequence(n: int) -> List[int]`: * Handle edge cases where `n = 0`. * Initialize the starting values of the Fibonacci sequence. * Use an iterative approach to generate the sequence up to `n` numbers. * Return the list of Fibonacci numbers. 2. Test your implementation with various inputs to ensure correctness. # Example Usage ```python def fibonacci_sequence(n: int) -> List[int]: # Your code here # Example usage: print(fibonacci_sequence(0)) # Output: [] print(fibonacci_sequence(5)) # Output: [0, 1, 1, 2, 3] print(fibonacci_sequence(10)) # Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] ```","solution":"def fibonacci_sequence(n: int): Generates the first n Fibonacci numbers iteratively. Parameters: n (int): Number of Fibonacci numbers to generate. Returns: list: A list containing the first n Fibonacci numbers. if n == 0: return [] elif n == 1: return [0] sequence = [0, 1] for i in range(2, n): next_number = sequence[-1] + sequence[-2] sequence.append(next_number) return sequence"},{"question":"**Scenario**: You are developing an application that processes a large number of images simultaneously. To optimize the performance, you need to implement a Priority Queue that ensures images with a higher priority are processed first. Each image has a unique identifier, a priority level, and a processing time. **Task**: Create a class `PriorityQueue` that simulates the behavior of a priority queue for image processing. The class should support the following operations: 1. `insert(image_id: int, priority: int, processing_time: int)`: Inserts an image into the queue. 2. `process_next() -> Optional[Tuple[int, int, int]]`: Processes the next image in the queue based on priority and returns its details (image_id, priority, processing_time). If the queue is empty, return `None`. 3. `is_empty() -> bool`: Checks if the queue is empty. 4. `average_processing_time() -> float`: Returns the average processing time of all processed images, rounded to two decimal places. # Input * List of method calls on an instance of `PriorityQueue`. # Output * Results of each `process_next` method call, as well as the output of `average_processing_time`. # Example: ```python pq = PriorityQueue() pq.insert(1, 5, 10) pq.insert(2, 3, 15) pq.insert(3, 7, 5) pq.insert(4, 1, 20) print(pq.process_next()) # Output: (3, 7, 5) print(pq.process_next()) # Output: (1, 5, 10) print(pq.process_next()) # Output: (2, 3, 15) print(pq.is_empty()) # Output: False print(pq.process_next()) # Output: (4, 1, 20) print(pq.is_empty()) # Output: True print(pq.average_processing_time()) # Output: 12.50 ``` # Constraints: * Each `image_id`, `priority`, and `processing_time` are unique non-negative integers. * The priority queue may handle up to 10000 images. * Ensure the class methods are efficient in their operations. Implement the `PriorityQueue` class to demonstrate your understanding and proficiency in handling priority queues and managing processing times efficiently in a simulated environment.","solution":"import heapq from typing import List, Optional, Tuple class PriorityQueue: def __init__(self): self.queue = [] self.processed_images = [] def insert(self, image_id: int, priority: int, processing_time: int): heapq.heappush(self.queue, (-priority, image_id, processing_time)) def process_next(self) -> Optional[Tuple[int, int, int]]: if not self.queue: return None priority, image_id, processing_time = heapq.heappop(self.queue) self.processed_images.append(processing_time) return (image_id, -priority, processing_time) def is_empty(self) -> bool: return len(self.queue) == 0 def average_processing_time(self) -> float: if not self.processed_images: return 0.0 return round(sum(self.processed_images) / len(self.processed_images), 2)"},{"question":"# Problem Statement: You\'ve been hired by an agricultural technology company that wants to implement an efficient system to monitor and track weather patterns in different regions. Your task is to write a function that, given a list of daily temperatures over a period, determines the number of days you have to wait after each day to get a warmer temperature. If there is no future day with a higher temperature, the output should be 0 for that day. Develop a function `daily_temperatures(temperatures: list[int]) -> list[int]` that returns a list of integers representing how many days one has to wait to experience a warmer temperature. # Function Signature: ```python def daily_temperatures(temperatures: list[int]) -> list[int]: ``` # Input Format: * `temperatures`: A list of integers where `temperatures[i]` represents the temperature on the i-th day. # Output Format: * Return a list of integers where each element is the number of days you have to wait to get a warmer temperature. If no warmer temperature is predicted, the corresponding element should be 0. # Constraints: * 1 ≤ len(temperatures) ≤ 10^5 * -100 ≤ temperatures[i] ≤ 100 # Performance Requirements: * The solution should have a time complexity of (O(n)) and a space complexity of (O(n)), where `n` is the number of days (length of the `temperatures` list). # Example: ```python >>> temperatures = [73, 74, 75, 71, 69, 72, 76, 73] >>> daily_temperatures(temperatures) [1, 1, 4, 2, 1, 1, 0, 0] ``` # Explanation: In this example, the output list indicates the number of days to wait until a warmer temperature: - For day 0 (temperature 73), you have to wait 1 day for day 1 (temperature 74) which is warmer. - For day 1 (temperature 74), you have to wait 1 day for day 2 (temperature 75) which is warmer. - For day 2 (temperature 75), you have to wait 4 days for day 6 (temperature 76) which is warmer. - For day 3 (temperature 71), you have to wait 2 days for day 5 (temperature 72) which is warmer. - For day 4 (temperature 69), you have to wait 1 day for day 5 (temperature 72) which is warmer. - For day 5 (temperature 72), you have to wait 1 day for day 6 (temperature 76) which is warmer. - For day 6 (temperature 76), there are no future days with a higher temperature, so the output is 0. - For day 7 (temperature 73), there are no future days with a higher temperature, so the output is 0.","solution":"def daily_temperatures(temperatures: list[int]) -> list[int]: Given a list of daily temperatures, returns a list indicating the number of days you have to wait until a warmer temperature. If no warmer temperature is predicted, the result is 0. n = len(temperatures) answer = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: prev_i = stack.pop() answer[prev_i] = i - prev_i stack.append(i) return answer"},{"question":"# Additional Coding Assessment Question Problem Statement: Your task is to implement an optimized version of the provided `find_pythagorean_triplet` function, which finds the first Pythagorean triplet (a, b, c) such that `a^2 + b^2 = c^2` and `a + b + c = s`. The function should return the product `a * b * c`. A Pythagorean triplet consists of three positive integers `a`, `b`, and `c` such that `a < b < c`. If no such triplet exists, return -1. Input: - An integer `s` (3 <= s <= 3000). Output: - An integer representing the product `a * b * c` if a triplet exists; otherwise, -1. Constraints: - Input `s` will be a valid integer within the given range. - The solution must execute efficiently even for the largest possible input within the given constraints. Function Signature: ```python def find_pythagorean_triplet(s: int) -> int: pass ``` Example: ```python print(find_pythagorean_triplet(12)) # Output: 60 print(find_pythagorean_triplet(30)) # Output: 780 print(find_pythagorean_triplet(7)) # Output: -1 ``` Context: You need to find specific values quickly in a mathematical module of an educational software. The expected results need to be generated effectively while avoiding brute-force approaches that could lead to significant performance issues. # Requirements: - The function must handle all edge cases where no triplets exist. - Ensure the solution is optimized for execution speed. Hint: - Consider the properties and relationships of Pythagorean triplets. - Optimize the search range by leveraging the constraint `a + b + c = s` and appropriate bounds for `a` and `b`.","solution":"def find_pythagorean_triplet(s: int) -> int: Finds the first Pythagorean triplet (a, b, c) such that a^2 + b^2 = c^2 and a + b + c = s. Returns the product a * b * c, or -1 if no such triplet exists. for a in range(1, s // 3): for b in range(a + 1, s // 2): c = s - a - b if a * a + b * b == c * c: return a * b * c return -1"},{"question":"# Nested Directory Size Calculation You have been provided with a code snippet that calculates the size of files within a given directory. Using this as a foundation, extend the functionality to calculate the total size of files within nested directories. # Task 1. Define a function `calculate_directory_size(directory: str) -> int` that computes the total size of all files within the specified directory and its subdirectories. 2. Ensure that hidden files and directories (those starting with a dot) are also accounted for unless explicitly excluded. # Function Specifications - **Function `calculate_directory_size`**: - Takes one input, `directory`, which is the file path as a string. - Returns the total size of all files in the directory and its nested subdirectories as an integer (total size in bytes). # Input and Output Formats * **Input**: * `directory`: string representing the path to the directory whose size needs to be calculated. * **Output**: * Returns the total size of all files in bytes as an integer. # Constraints * Include all files within the provided directory unless the file type should be excluded based on further requirements. * Handle edge cases such as empty directories, directories with no read permissions, and other possible file system anomalies. # Example ```python # Assuming following file structure: # /example_directory # - file1.txt (500 bytes) # - dir1 # - file2.txt (300 bytes) # - file3.txt (700 bytes) # - dir2 # - file4.txt (200 bytes) # - dir3 # - file5.txt (400 bytes) # # Example implementation: print(calculate_directory_size(\\"/example_directory\\")) # Expected output: 2100 # The returned size must include all files in /example_directory and its subdirectories. ``` # Implementation Write thorough error checks and ensure the correctness of the calculations. Test your implementation to cover common edge cases and document your approach. Consider using the `os` module to traverse directory structures and fetch file information. Here is a starting point for your implementation: ```python import os def calculate_directory_size(directory: str) -> int: total_size = 0 for root, dirs, files in os.walk(directory): for file in files: filepath = os.path.join(root, file) try: total_size += os.path.getsize(filepath) except OSError: # Skip files that cannot be accessed continue return total_size # Example usage if __name__ == \\"__main__\\": print(calculate_directory_size(\\"/example_directory\\")) # Adjust the path as per your test environment ``` Ensure you test your function with directories containing various file types, different directory depths, and special cases such as symbolic links and hidden files.","solution":"import os def calculate_directory_size(directory: str) -> int: Calculates the total size of all files within the specified directory and its subdirectories, including hidden files. Parameters: directory (str): The path to the directory Returns: int: The total size of all files in bytes total_size = 0 for root, dirs, files in os.walk(directory): for file in files: filepath = os.path.join(root, file) try: total_size += os.path.getsize(filepath) except OSError: # Skip files that cannot be accessed continue return total_size"},{"question":"# Background You are working on a text processing tool that analyzes large volumes of text data. One of the key requirements is to identify and extract all unique words from a given body of text while preserving their order of first appearance. The tool should ignore punctuation and be case insensitive. # Task Implement a function `extract_unique_words` that extracts all unique words from a given string of text, preserving their order of first appearance and treating the text as case insensitive. Function Signature ```python def extract_unique_words(text: str) -> list[str]: pass ``` Input * `text`: A string containing the body of text, which may include letters, spaces, and punctuation marks. Output * Returns a list of unique words (case insensitive) in the order of their first appearance in the given text. Constraints * The length of the text input will not exceed (10^6) characters. * The text will only contain printable ASCII characters. Examples ```python print(extract_unique_words(\\"Hello, world! Hello...\\")) # Output: [\\"hello\\", \\"world\\"] print(extract_unique_words(\\"Python is great! Python, indeed, is great.\\")) # Output: [\\"python\\", \\"is\\", \\"great\\", \\"indeed\\"] print(extract_unique_words(\\"A man, a plan, a canal, Panama!\\")) # Output: [\\"a\\", \\"man\\", \\"plan\\", \\"canal\\", \\"panama\\"] print(extract_unique_words(\\"To be or not to be, that is the question.\\")) # Output: [\\"to\\", \\"be\\", \\"or\\", \\"not\\", \\"that\\", \\"is\\", \\"the\\", \\"question\\"] ``` These examples can guide you in testing and validating your implementation of the `extract_unique_words` function.","solution":"import re def extract_unique_words(text: str) -> list[str]: Takes a string text and extracts unique words checking case insensitivity. Punctuation is ignored and order of first appearance is preserved. # Convert text to lowercase text = text.lower() # Use regex to find words and ignore punctuation words = re.findall(r\'bw+b\', text) # Create an order-preserving dictionary to keep unique words seen = {} unique_words = [] for word in words: if word not in seen: seen[word] = True unique_words.append(word) return unique_words"},{"question":"# Problem Statement You are tasked with developing a simplified natural language processing tool to detect frequent words within a given body of text and check if they match a predefined set of keywords. Implement a function to achieve this. # Requirements Write a function `keyword_match(text: str, keywords: List[str]) -> List[bool]` that analyzes the given text to identify whether each keyword in the list of keywords appears in the text at least once. The function returns a list of booleans, where each boolean corresponds to whether the respective keyword is present in the text. # Input Format - `text`: A single string of length ( n ) (1 ≤ ( n ) ≤ 100,000). - `keywords`: A list of strings, where each string ( kw_i ) (1 ≤ ( kw_i ) ≤ 50). # Output Format - A list of booleans where each boolean indicates the presence (True) or absence (False) of the corresponding keyword from the `keywords` list in the `text`. # Constraints - Text and keywords are case insensitive. - Punctuation in the text should be ignored when matching keywords. - The text consists of spaces, alphabets, and punctuation marks. # Example ```python assert keyword_match(\\"This is a sample text, to demonstrate the task at hand.\\", [\\"sample\\", \\"demonstrate\\", \\"missing\\"]) == [True, True, False] assert keyword_match(\\"Natural language processing is fascinating.\\", [\\"language\\", \\"NATURAL\\", \\"science\\"]) == [True, True, False] ``` # Notes - Normalize the text and keywords to handle case insensitivity. - Consider removing punctuation from the text for accurate keyword matching. - Efficient string searching techniques will help to minimize the computational overhead given the constraints.","solution":"import re from typing import List def keyword_match(text: str, keywords: List[str]) -> List[bool]: Analyzes the given text to identify whether each keyword in the list of keywords appears in the text at least once. Returns a list of booleans, where each boolean corresponds to whether the respective keyword is present in the text. Parameters: text (str): The body of text in which to search for keywords. keywords (List[str]): The list of keywords to search for in the text. Returns: List[bool]: A list of booleans indicating the presence of each keyword in the text. # Normalize the text by converting to lowercase and removing punctuation normalized_text = re.sub(r\'[^ws]\', \'\', text.lower()) # Normalize the keywords by converting them to lowercase normalized_keywords = [keyword.lower() for keyword in keywords] # Check if each keyword is present in the normalized text keyword_presence = [keyword in normalized_text for keyword in normalized_keywords] return keyword_presence"},{"question":"# Problem Statement You are given two sorted lists of integers. Your task is to write a function `merge_sorted_lists` that merges these two lists into a single sorted list without duplicates. Your implementation should take advantage of the fact that the input lists are already sorted. # Input * Two sorted lists of integers, `list1` and `list2`, where (0 leq text{len(list1)}, text{len(list2)} leq 10^5). # Output * Return a single sorted list containing the unique elements from both input lists. # Function Signature ```python def merge_sorted_lists(list1: list, list2: list) -> list: pass ``` # Constraints * You must take advantage of the input lists being sorted to ensure an efficient merge. * Avoid using Python\'s built-in merging or set operations. # Example ```python >>> merge_sorted_lists([1, 3, 5], [2, 3, 6]) [1, 2, 3, 5, 6] >>> merge_sorted_lists([0, 4, 4, 10], [4, 7, 12]) [0, 4, 7, 10, 12] >>> merge_sorted_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_lists([1, 2, 2, 3], []) [1, 2, 3] ``` # Detailed Explanation * Implement the merge algorithm by iterating through both lists, taking advantage of their sorted nature to efficiently combine them into a new list. * Ensure that the resulting list contains unique elements by checking for duplicates as you merge the lists. * Consider edge cases such as empty lists or lists with all duplicate elements. * Aim for a time complexity of (O(n + m)), where (n) is the length of `list1` and (m) is the length of `list2`.","solution":"def merge_sorted_lists(list1: list, list2: list) -> list: Merge two sorted lists into a single sorted list without duplicates. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: if not merged_list or list1[i] != merged_list[-1]: merged_list.append(list1[i]) i += 1 elif list1[i] > list2[j]: if not merged_list or list2[j] != merged_list[-1]: merged_list.append(list2[j]) j += 1 else: if not merged_list or list1[i] != merged_list[-1]: merged_list.append(list1[i]) i += 1 j += 1 # Append remaining elements of list1 while i < len(list1): if not merged_list or list1[i] != merged_list[-1]: merged_list.append(list1[i]) i += 1 # Append remaining elements of list2 while j < len(list2): if not merged_list or list2[j] != merged_list[-1]: merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Problem Statement Implement a function `sum_of_gcd_pairs(n: int) -> int` that calculates the sum of all ( text{gcd}(i, j) ) for ( 1 leq i < j leq n ), where gcd stands for greatest common divisor. # Input * An integer ( n ) (( 1 leq n leq 10^5 )). # Output * An integer representing the sum of all ( text{gcd}(i, j) ) for ( 1 leq i < j leq n ). # Constraints * Ensure the function is efficient and can handle the upper limit. * Handle edge cases where ( n ) is at its minimum value. # Example ```python >>> sum_of_gcd_pairs(4) 10 >>> sum_of_gcd_pairs(1) 0 ``` # Explanation * For the first example (`n = 4`), the valid pairs with their gcd are: - (1, 2) -> gcd(1, 2) = 1 - (1, 3) -> gcd(1, 3) = 1 - (1, 4) -> gcd(1, 4) = 1 - (2, 3) -> gcd(2, 3) = 1 - (2, 4) -> gcd(2, 4) = 2 - (3, 4) -> gcd(3, 4) = 1 - Sum = 1 + 1 + 1 + 1 + 2 + 1 = 7 * For the second example (`n = 1`), there are no pairs to consider, so the result is 0.","solution":"from math import gcd def sum_of_gcd_pairs(n: int) -> int: Calculates the sum of the Greatest Common Divisor (GCD) for all pairs (i, j) where 1 <= i < j <= n. total_sum = 0 for i in range(1, n): for j in range(i + 1, n + 1): total_sum += gcd(i, j) return total_sum"},{"question":"# Problem Statement You are given a list of employees and their respective productivity scores. Each productivity score is an integer, and it represents the efficiency of the employee. The company plans to assign a team leader based on these scores. The team leader must be the employee with the highest productivity score. However, in cases where there are multiple employees with the highest productivity score, the employee with the smallest index (in the list) should be chosen as the team leader. Your task is to implement a function `find_team_leader(productivity_scores: list[int]) -> int` that returns the index of the team leader. # Function Signature ```python def find_team_leader(productivity_scores: list[int]) -> int: pass ``` # Input * `productivity_scores`: A list of integers where each integer represents the productivity score of an employee. # Output * An integer representing the index of the employee who will be the team leader. # Constraints * The `productivity_scores` list may have up to 10^5 elements. * Productivity scores are non-negative integers. # Example ```python productivity_scores1 = [85, 90, 78, 90, 88] print(find_team_leader(productivity_scores1)) # Output: 1 productivity_scores2 = [70, 85, 80, 85, 85] print(find_team_leader(productivity_scores2)) # Output: 1 productivity_scores3 = [60, 75, 85, 95, 95, 65] print(find_team_leader(productivity_scores3)) # Output: 3 ``` # Note The function should traverse the list efficiently, identifying the maximum productivity score and its corresponding index. In the event of a tie, it should select the index with the smallest value. Use of efficient algorithms and appropriate data structures is encouraged to handle large input sizes within a reasonable time frame.","solution":"def find_team_leader(productivity_scores: list[int]) -> int: Finds the index of the team leader based on productivity scores. The team leader is the employee with the highest productivity score, and in case of a tie, the employee with the smallest index is selected. :param productivity_scores: List of integers representing productivity scores. :return: Index of the team leader. max_score = -1 leader_index = -1 for index, score in enumerate(productivity_scores): if score > max_score: max_score = score leader_index = index return leader_index # Example usage print(find_team_leader([85, 90, 78, 90, 88])) # Output: 1 print(find_team_leader([70, 85, 80, 85, 85])) # Output: 1 print(find_team_leader([60, 75, 85, 95, 95, 65])) # Output: 3"},{"question":"# Scenario You have been asked to extend an existing Python library that handles basic text-based transformations. Your new task is to add a function that can \\"rotate\\" the case of alphabetic characters within a given string. Rotation in this context means shifting the case in a cyclic manner: lowercase letters become uppercase, uppercase letters change to lowercase. # Task Write a Python function `rotate_case(input_string: str) -> str` that takes a string as its input and returns a new string where every alphabetic character\'s case has been rotated. Non-alphabetic characters should remain unchanged. # Requirements - Assume that the input will be a valid string containing English alphabetic and non-alphabetic characters. - The function should handle both uppercase and lowercase characters correctly. - The function should preserve the position of all characters. # Input and Output - **Input**: - `input_string` (str): The string to be processed. - **Output**: The function returns a new string where the case of each alphabet character is rotated. # Examples - `rotate_case(\\"Hello World!\\")` should return `\\"hELLO wORLD!\\"` - `rotate_case(\\"Python3.8\\")` should return `\\"pYTHON3.8\\"` - `rotate_case(\\"123456\\")` should return `\\"123456\\"` # Code Template ```python def rotate_case(input_string: str) -> str: result = [] for char in input_string: if char.islower(): result.append(char.upper()) elif char.isupper(): result.append(char.lower()) else: result.append(char) return \'\'.join(result) # Example usage (do not include in submission): # print(rotate_case(\\"Hello World!\\")) ``` **Constraints**: - The function should be efficient and handle reasonably long strings without significant performance degradation.","solution":"def rotate_case(input_string: str) -> str: result = [] for char in input_string: if char.islower(): result.append(char.upper()) elif char.isupper(): result.append(char.lower()) else: result.append(char) return \'\'.join(result)"},{"question":"# Task: Implement a Circular Queue Develop a Python class `CircularQueue` that supports the following operations: 1. `enqueue(value)`: Adds an item to the queue. If the queue is full, it overwrites the oldest item in the queue. 2. `dequeue()`: Removes the oldest item from the queue and returns it. Returns `None` if the queue is empty. 3. `peek()`: Returns the oldest item without removing it from the queue. Returns `None` if the queue is empty. 4. `is_empty()`: Returns `True` if the queue is empty, otherwise returns `False`. 5. `is_full()`: Returns `True` if the queue is full, otherwise returns `False`. # Class Interface ```python class CircularQueue: def __init__(self, capacity: int) -> None: Initialize the Circular Queue with a given capacity. pass def enqueue(self, value: int) -> None: Adds an item to the queue. Overwrites the oldest item if the queue is full. pass def dequeue(self) -> int | None: Removes and returns the oldest item from the queue. Returns None if the queue is empty. pass def peek(self) -> int | None: Returns the oldest item without removing it. Returns None if the queue is empty. pass def is_empty(self) -> bool: Returns True if the queue is empty. pass def is_full(self) -> bool: Returns True if the queue is full. pass ``` # Constraints * `1 <= capacity <= 1000` * `0 <= value <= 10000` * `Since the number of operations can be large, your implementation should be efficient in time and space complexity`. # Example ```python # Testing the Circular Queue queue = CircularQueue(3) # Enqueuing values queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) assert queue.is_full() == True # Queue is full # Peeking value assert queue.peek() == 1 # Returns 1 # Dequeuing values assert queue.dequeue() == 1 # Returns 1 assert queue.is_full() == False # Queue is not full anymore queue.enqueue(4) # Add new value, queue should be full again assert queue.is_full() == True # Queue is full assert queue.peek() == 2 # Returns 2 assert queue.dequeue() == 2 # Returns 2 ```","solution":"class CircularQueue: def __init__(self, capacity: int) -> None: Initialize the Circular Queue with a given capacity. self.capacity = capacity self.queue = [None] * capacity self.head = 0 self.tail = 0 self.size = 0 def enqueue(self, value: int) -> None: Adds an item to the queue. Overwrites the oldest item if the queue is full. if self.is_full(): self.head = (self.head + 1) % self.capacity else: self.size += 1 self.queue[self.tail] = value self.tail = (self.tail + 1) % self.capacity def dequeue(self) -> int | None: Removes and returns the oldest item from the queue. Returns None if the queue is empty. if self.is_empty(): return None value = self.queue[self.head] self.head = (self.head + 1) % self.capacity self.size -= 1 return value def peek(self) -> int | None: Returns the oldest item without removing it. Returns None if the queue is empty. if self.is_empty(): return None return self.queue[self.head] def is_empty(self) -> bool: Returns True if the queue is empty. return self.size == 0 def is_full(self) -> bool: Returns True if the queue is full. return self.size == self.capacity"},{"question":"# String Compression and Decompression You are tasked with creating a pair of functions to compress and decompress strings using a simple RLE (Run-Length Encoding) approach. This problem will help you optimize storage or transmission of repetitive data. **Function Signatures**: ```python def compress_string(s: str) -> str: def decompress_string(s: str) -> str: ``` # Input - `s` (str): The input string that you want to compress or decompress. # Compression Logic - The `compress_string` function should identify consecutive repeated characters in the string and replace them with the character followed by the count of repetitions. For example, \\"aaabbcddd\\" should be compressed to \\"a3b2cd3\\". # Decompression Logic - The `decompress_string` function should take a compressed string produced by the `compress_string` function and return the original uncompressed string. - For example, \\"a3b2cd3\\" should be decompressed back to \\"aaabbcddd\\". # Output - The `compress_string` function should return the compressed version of the input string (`s`). - The `decompress_string` function should return the original uncompressed string. # Constraints - Both functions should handle only lowercase alphabets (\'a\' to \'z\'). - If a character appears only once, do not add a count after it (e.g., \\"abc\\" remains \\"abc\\" in the compressed form). - If the input string is empty, return an empty string. # Example ```python >>> compress_string(\\"aaabbcddd\\") \'a3b2cd3\' >>> decompress_string(\\"a3b2cd3\\") \'aaabbcddd\' >>> compress_string(\\"abc\\") \'abc\' >>> decompress_string(\\"abc\\") \'abc\' ```","solution":"def compress_string(s: str) -> str: if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) if count > 1: compressed.append(str(count)) count = 1 compressed.append(s[-1]) if count > 1: compressed.append(str(count)) return \\"\\".join(compressed) def decompress_string(s: str) -> str: if not s: return \\"\\" decompressed = [] i = 0 while i < len(s): char = s[i] count = 1 j = i + 1 while j < len(s) and s[j].isdigit(): j += 1 if j > i + 1: count = int(s[i + 1:j]) decompressed.append(char * count) i = j return \\"\\".join(decompressed)"},{"question":"# Fibonacci Sequence Sum and Statistics You have been assigned the task of calculating specific information related to the Fibonacci sequence up to a given number of terms. Objective: Develop a function `fibonacci_summary` that computes and returns: 1. The Fibonacci sequence up to `n` terms. 2. The sum of the sequence. 3. The average value of the sequence. # Input Format: A single integer `n` representing the number of terms in the Fibonacci sequence to generate. # Output Format: A dictionary with: - `\'sequence\'`: A list of integers representing the Fibonacci sequence up to `n` terms. - `\'sum\'`: The sum of the sequence (an integer). - `\'average\'`: The average value of the sequence (a float rounded to 2 decimal places). # Constraints: - `n` is a non-negative integer (0 <= n <= 50). # Performance Requirements: - The function should efficiently handle the constraints. # Function Signature: ```python def fibonacci_summary(n: int) -> dict: ``` # Example: ```python # Example 1 input: n = 5 output: {\'sequence\': [0, 1, 1, 2, 3], \'sum\': 7, \'average\': 1.40} # Example 2 input: n = 8 output: {\'sequence\': [0, 1, 1, 2, 3, 5, 8, 13], \'sum\': 33, \'average\': 4.12} ``` # Notes: - Handle the case where `n` is 0 by returning an empty sequence and appropriate sum and average values. - Ensure your implementation is efficient and can handle the upper limit of the input constraint. # Challenge: Write the implementation of the `fibonacci_summary` function as per the description above.","solution":"def fibonacci_summary(n: int) -> dict: Returns the Fibonacci sequence up to `n` terms, the sum of the sequence and the average value of the sequence. if n == 0: return {\'sequence\': [], \'sum\': 0, \'average\': 0.00} if n == 1: return {\'sequence\': [0], \'sum\': 0, \'average\': 0.00} # Initialize the first two terms of the Fibonacci sequence fib_sequence = [0, 1] while len(fib_sequence) < n: fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) fib_sum = sum(fib_sequence) fib_average = round(fib_sum / n, 2) return {\'sequence\': fib_sequence, \'sum\': fib_sum, \'average\': fib_average}"},{"question":"# Question **K-Most Frequent Elements** Given a list of integers, write a Python function to return the `k` most frequent elements. The function should return the elements in descending order of frequency. If two elements have the same frequency, order them by their first occurrence in the list. **Function Signature** ```python def k_most_frequent_elements(nums: list[int], k: int) -> list[int]: ... ``` # Expected Input and Output Format * **Input**: * `nums` (list of int): A list of integers. (1 <= len(nums) <= 10^5, -10^5 <= nums[i] <= 10^5) * `k` (int): The number of most frequent elements to return. (1 <= k <= len(nums)) * **Output**: * A list of `k` integers representing the most frequent elements in descending order of their frequencies. # Constraints * If `nums` or `k` is not valid, the function should raise a `ValueError`. * If `k` is greater than the unique elements in `nums`, the function should return all unique elements sorted by their frequency. # Scenario/Context Consider a scenario where a data analyst needs to quickly identify the most common items in a list of purchases made by customers. This functionality helps in identifying popular items and making data-driven inventory decisions. # Example **Example 1**: ```python >>> k_most_frequent_elements([1,1,1,2,2,3], 2) [1, 2] ``` **Example 2**: ```python >>> k_most_frequent_elements([4,1,-1,2,-1,2,3], 2) [-1, 2] ``` **Example 3**: ```python >>> k_most_frequent_elements([1, 1, 1, 2, 3, 2, 4, 4], 2) [1, 2] ``` **Example Edge Case**: ```python >>> k_most_frequent_elements([], 2) Traceback (most recent call last): ... ValueError: Invalid input: nums must not be empty ``` # Performance Considerations * Ensure optimal performance for large values of `len(nums)`. * Utilize efficient data structures to handle frequency counting and sorting. Submit your implementation as the `k_most_frequent_elements` function.","solution":"from collections import Counter def k_most_frequent_elements(nums: list[int], k: int) -> list[int]: Returns the k most frequent elements in descending order of frequency. If two elements have the same frequency, they are ordered by their first occurrence in the list. If nums or k is not valid, raises a ValueError. if not nums or k <= 0: raise ValueError(\\"Invalid input: nums must not be empty and k must be positive\\") # Count the frequency of each element frequency = Counter(nums) # Sort elements based on frequency first (desc), then by their first occurrence sorted_elements = sorted(frequency.keys(), key=lambda x: (-frequency[x], nums.index(x))) # Return the top k elements return sorted_elements[:k]"},{"question":"# Question: Implement an Optimized Matrix Multiplication Algorithm Context You are developing a mathematical library that requires efficient matrix operations. Matrix multiplication is a fundamental operation frequently used in various applications, from graphics transformations to scientific computing. Task Implement an optimized matrix multiplication algorithm that leverages Strassen\'s algorithm for large matrices but defaults to the classical approach for small matrices. # Requirements 1. **Function Signature**: `def optimized_matrix_multiplication(A: list[list[float]], B: list[list[float]]) -> list[list[float]]:` 2. **Input**: - Two 2D lists of floating-point numbers, `A` and `B`, representing matrices. - Matrices will be square and have dimensions that are powers of 2 (e.g., 2x2, 4x4, 8x8). - Example: `[[1.0, 2.0], [3.0, 4.0]]`, `[[5.0, 6.0], [7.0, 8.0]]` 3. **Output**: - A 2D list of floating-point numbers representing the product of matrices `A` and `B`. 4. **Constraints**: - Use Strassen\'s algorithm for matrices larger than 2x2. - For 2x2 matrices, use the classical multiplication method for simplicity and performance. - Consider edge cases such as empty matrices or matrices with all zeroes. # Performance Expectations - The method should be more efficient than the classical O(n^3) approach for large matrices. - Ensure that the algorithm handles matrices efficiently without excessive recursion depth or memory usage. Example ```python >>> A = [[1.0, 2.0], [3.0, 4.0]] >>> B = [[5.0, 6.0], [7.0, 8.0]] >>> optimized_matrix_multiplication(A, B) [[19.0, 22.0], [43.0, 50.0]] >>> C = [[1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], [9.0, 10.0, 11.0, 12.0], [13.0, 14.0, 15.0, 16.0]] >>> D = [[17.0, 18.0, 19.0, 20.0], [21.0, 22.0, 23.0, 24.0], [25.0, 26.0, 27.0, 28.0], [29.0, 30.0, 31.0, 32.0]] >>> optimized_matrix_multiplication(C, D) [[250.0, 260.0, 270.0, 280.0], [618.0, 644.0, 670.0, 696.0], [986.0, 1028.0, 1070.0, 1112.0], [1354.0, 1412.0, 1470.0, 1528.0]] >>> E = [[1.0]] >>> F = [[2.0]] >>> optimized_matrix_multiplication(E, F) [[2.0]] ```","solution":"def add_matrix(A, B): Add two matrices element-wise. n = len(A) return [[A[i][j] + B[i][j] for j in range(n)] for i in range(n)] def sub_matrix(A, B): Subtract matrix B from matrix A element-wise. n = len(A) return [[A[i][j] - B[i][j] for j in range(n)] for i in range(n)] def matrix_mult(A, B): n = len(A) if n == 1: return [[A[0][0] * B[0][0]]] elif n == 2: return [ [ A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1] ], [ A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1] ] ] else: half = n // 2 A11 = [[A[i][j] for j in range(half)] for i in range(half)] A12 = [[A[i][j] for j in range(half, n)] for i in range(half)] A21 = [[A[i][j] for j in range(half)] for i in range(half, n)] A22 = [[A[i][j] for j in range(half, n)] for i in range(half, n)] B11 = [[B[i][j] for j in range(half)] for i in range(half)] B12 = [[B[i][j] for j in range(half, n)] for i in range(half)] B21 = [[B[i][j] for j in range(half)] for i in range(half, n)] B22 = [[B[i][j] for j in range(half, n)] for i in range(half, n)] M1 = matrix_mult(add_matrix(A11, A22), add_matrix(B11, B22)) M2 = matrix_mult(add_matrix(A21, A22), B11) M3 = matrix_mult(A11, sub_matrix(B12, B22)) M4 = matrix_mult(A22, sub_matrix(B21, B11)) M5 = matrix_mult(add_matrix(A11, A12), B22) M6 = matrix_mult(sub_matrix(A21, A11), add_matrix(B11, B12)) M7 = matrix_mult(sub_matrix(A12, A22), add_matrix(B21, B22)) C11 = add_matrix(sub_matrix(add_matrix(M1, M4), M5), M7) C12 = add_matrix(M3, M5) C21 = add_matrix(M2, M4) C22 = add_matrix(sub_matrix(add_matrix(M1, M3), M2), M6) C = [] for i in range(half): C.append(C11[i] + C12[i]) for i in range(half): C.append(C21[i] + C22[i]) return C def optimized_matrix_multiplication(A, B): return matrix_mult(A, B)"},{"question":"# Coding Assessment Question Context You need to develop a utility to read and process a structured configuration file for a web application. The configuration file is in the YAML (Yet Another Markup Language) format and specifies various settings such as database connections, server ports, and feature flags. Your task is to extract this information and present it in a way that can be used programmatically. Question Write a Python function called `load_config` that reads a configuration file in YAML format and returns its contents as a nested dictionary. The function should handle different data types (strings, integers, lists, dictionaries) and ensure that any missing or malformed file paths are gracefully reported. The function should follow these steps: 1. Open the provided YAML file for reading. 2. Parse the YAML content to construct a nested dictionary structure. 3. Handle any file reading errors (e.g., file not found, permission errors) by returning an appropriate error message. 4. Ensure proper handling of YAML parsing errors by returning a different appropriate error message. Function Signature ```python def load_config(file_path: str) -> dict: pass ``` Input - `file_path` (str): The path to the YAML configuration file (e.g., \\"config/settings.yaml\\"). Output - A dictionary representation of the configuration file content. - In case of errors: - \\"File not found error\\": if the specified file does not exist. - \\"Permission error\\": if the file cannot be read due to permission issues. - \\"YAML parsing error\\": if the content cannot be parsed as valid YAML. Constraints - Use the `yaml` library for parsing YAML content. - Handle I/O errors using Python\'s built-in exception handling. - Ensure robust parsing and error handling for different types of malformed inputs. Example Suppose the configuration file (`config/settings.yaml`) contains: ```yaml server: host: \\"localhost\\" port: 8080 database: name: \\"app_db\\" user: \\"admin\\" password: \\"secret\\" features: enable_feature_x: true supported_languages: - \\"en\\" - \\"fr\\" ``` Example use case: ```python config = load_config(\\"config/settings.yaml\\") print(config) # Output: { # \'server\': {\'host\': \'localhost\', \'port\': 8080}, # \'database\': {\'name\': \'app_db\', \'user\': \'admin\', \'password\': \'secret\'}, # \'features\': {\'enable_feature_x\': True, \'supported_languages\': [\'en\', \'fr\']} # } ``` Guidelines - Use the `yaml` library (PyYAML) for parsing YAML. - Handle file and parsing exceptions to provide meaningful error messages. - Validate the structure and types of the content where appropriate.","solution":"import yaml def load_config(file_path: str) -> dict: Reads a YAML configuration file and returns its contents as a nested dictionary. Args: file_path (str): The path to the YAML configuration file. Returns: dict: The contents of the configuration file as a dictionary. Returns an error message string in case of an error. try: with open(file_path, \'r\') as file: try: return yaml.safe_load(file) except yaml.YAMLError: return \\"YAML parsing error\\" except FileNotFoundError: return \\"File not found error\\" except PermissionError: return \\"Permission error\\""},{"question":"# Coding Assessment Question **Context**: You are hired to develop an analytical tool for a library that processes and analyzes check-out data. The library wants to identify peak hours of book check-outs to optimize staffing and resources. Your task is to write a function that determines the busiest hour of the day in terms of book check-outs. # Task Write a function `busiest_hour` that processes a list of check-out timestamps and returns the hour with the highest check-out frequency. Each timestamp is in the format \\"YYYY-MM-DD HH:MM:SS\\". # Function Signature ```python def busiest_hour(timestamps: List[str]) -> int: ``` # Input - `timestamps` (List[str]): A list of strings where each string is a timestamp representing the check-out time of a book. The format of each timestamp is \\"YYYY-MM-DD HH:MM:SS\\". # Output - Returns an integer representing the hour (0-23) with the highest number of check-outs. # Constraints - The list of timestamps can be very large (up to 100,000 elements). - The timestamps are guaranteed to be formatted correctly. # Performance Requirements - The function should be optimized to handle large lists efficiently. # Examples ```python print(busiest_hour([\\"2023-10-04 13:45:30\\", \\"2023-10-04 14:15:00\\", \\"2023-10-04 13:05:45\\", \\"2023-10-04 14:30:59\\"])) ``` Expected Output: ``` 13 ``` ```python print(busiest_hour([\\"2023-10-04 00:45:30\\", \\"2023-10-04 01:15:00\\", \\"2023-10-04 00:05:45\\", \\"2023-10-04 23:59:59\\"])) ``` Expected Output: ``` 0 ``` # Additional Information 1. In case of a tie (i.e., multiple hours with the same highest frequency), return the earliest hour. 2. Ensure your solution is easy to understand and maintain, with clear comments explaining the key steps and logic used in the function.","solution":"from typing import List from collections import defaultdict def busiest_hour(timestamps: List[str]) -> int: Returns the hour with the highest check-out frequency from a list of check-out timestamps. Args: timestamps (List[str]): List of check-out timestamps in the format \\"YYYY-MM-DD HH:MM:SS\\". Returns: int: The hour (0-23) with the highest check-out frequency. hour_count = defaultdict(int) for timestamp in timestamps: hour = int(timestamp.split()[1].split(\\":\\")[0]) hour_count[hour] += 1 return max(hour_count, key=lambda x: (hour_count[x], -x))"},{"question":"# Problem Statement You are tasked with implementing a function to normalize a list of strings by its length. The function should process the list by capitalizing the first letter of each string and appending the string\'s length at the end of each word. This can be useful in data processing, logging, or formatting tasks where consistent and informative output is necessary. # Requirements Function Signature ```python def normalize_and_append_length(word_list: list) -> list: ``` Functionality Description - The function should accept a single parameter: * `word_list` (list): A list containing strings. - The function should return a list where: * Each string is capitalized (first letter in uppercase, remaining letters in lowercase). * The length of the string is appended at the end of each word. # Constraints 1. Each element in `word_list` must be a non-empty string. 2. The input `word_list` must be a list containing only strings. # Error Handling 1. Raise a `ValueError` if `word_list` is not a list. 2. Raise a `ValueError` if any element in `word_list` is not a string. # Performance Requirements - Ensure the function processes each string in linear time complexity, O(n), where n is the total length of all strings in the list. - Handle memory efficiently, using O(n) additional space. # Example Usage ```python >>> normalize_and_append_length([\\"hello\\", \\"world\\"]) [\'Hello5\', \'World5\'] >>> normalize_and_append_length([\\"python\\", \\"programming\\", \\"is\\", \\"fun\\"]) [\'Python6\', \'Programming11\', \'Is2\', \'Fun3\'] >>> normalize_and_append_length([\\"data\\", \\"SCIENCE\\"]) [\'Data4\', \'Science7\'] >>> normalize_and_append_length([\\"a\\", \\"b\\", \\"c\\"]) [\'A1\', \'B1\', \'C1\'] ``` Proper error handling should be in place: ```python >>> normalize_and_append_length(\\"hello world\\") Traceback (most recent call last): ... ValueError: Expected list as input, found <class \'str\'> >>> normalize_and_append_length([\\"hello\\", 123]) Traceback (most recent call last): ... ValueError: Expected all elements in list to be strings, found <class \'int\'> ``` # Explanation This function ensures consistent formatting and provides useful information (length of each word) directly appended to each string in the list, aiding in better readability and processing in various applications.","solution":"def normalize_and_append_length(word_list): This function normalizes a list of strings by capitalizing the first letter of each string and appending the string\'s length at the end of each word. Parameters: word_list (list): A list of strings to be normalized. Returns: list: A list of normalized strings with lengths appended. Raises: ValueError: If the input is not a list or contains non-string elements. if not isinstance(word_list, list): raise ValueError(f\\"Expected list as input, found {type(word_list)}\\") normalized_list = [] for word in word_list: if not isinstance(word, str): raise ValueError(f\\"Expected all elements in list to be strings, found {type(word)}\\") normalized_word = word.capitalize() + str(len(word)) normalized_list.append(normalized_word) return normalized_list"},{"question":"# Coding Assessment Question **Reconstructing the Original Array** Given an integer ( k ) and an array of integers representing the prefix sums of another array, your task is to reconstruct the original array. The prefix sum array ( P ) is defined as ( P[i] = A[0] + A[1] + ... + A[i] ). Implement the function `reconstruct_array(k: int, prefix_sums: List[int]) -> List[int]` that takes an integer ( k ) and a list of integers representing the prefix sums and returns the reconstructed original array of integers. Input * An integer ( k ) representing the size of the prefix sums array, ( (1 leq k leq 50) ). * A list of integers `prefix_sums` with ( k ) elements representing the prefix sums. Output * A list of integers representing the original array. Constraints * The given `prefix_sums` list will always be a valid prefix sums array. * All integers in the input list `prefix_sums` are between (-1000) and (1000). Examples 1. **Input**: `reconstruct_array(4, [1, 3, 6, 10])` **Output**: `[1, 2, 3, 4]` 2. **Input**: `reconstruct_array(5, [-1, 2, 5, 9, 14])` **Output**: `[-1, 3, 3, 4, 5]` 3. **Input**: `reconstruct_array(3, [5, 8, 7])` **Output**: `[5, 3, -1]` 4. **Input**: `reconstruct_array(1, [0])` **Output**: `[0]` Implement the function to accurately reconstruct the original array from the prefix sums. Ensure your function can handle the constraints effectively and accounts for edge cases.","solution":"from typing import List def reconstruct_array(k: int, prefix_sums: List[int]) -> List[int]: Given the prefix sums array, this function reconstructs the original array. if k == 0: return [] original_array = [prefix_sums[0]] for i in range(1, k): original_element = prefix_sums[i] - prefix_sums[i - 1] original_array.append(original_element) return original_array"},{"question":"# Sorting Algorithms Analysis Assessment Context You are expected to implement and compare the performance of classic sorting algorithms: Quick Sort, Merge Sort, and Heap Sort. This task tests your understanding of sorting mechanisms and efficiency analysis, as well as your ability to implement and optimize these algorithms in Python. Task 1. **Implement Sorting Algorithms**: - Implement Quick Sort, Merge Sort, and Heap Sort algorithms in Python. 2. **Performance Comparison**: - Measure and compare the execution time of each sorting algorithm on large, randomly generated datasets of varying sizes. - Provide code to generate these datasets and benchmark each sorting algorithm. Expected Function Implementation 1. **Sorting Algorithms**: ```python def quick_sort(arr: List[int]) -> List[int]: # Your Quick Sort implementation here def merge_sort(arr: List[int]) -> List[int]: # Your Merge Sort implementation here def heap_sort(arr: List[int]) -> List[int]: # Your Heap Sort implementation here ``` 2. **Performance Measurement**: ```python def measure_performance(sort_function: Callable[[List[int]], List[int]], data: List[int]) -> float: Measures the execution time of a sorting function on a given dataset. Parameters: sort_function (Callable[[List[int]], List[int]]): The sorting function to measure. data (List[int]): The dataset to sort. Returns: float: The execution time in seconds. import time start_time = time.time() sort_function(data.copy()) # Ensure the original data is not altered return time.time() - start_time ``` 3. **Dataset Generation and Benchmark**: ```python import random def generate_dataset(size: int, min_value: int = 0, max_value: int = 10000) -> List[int]: Generates a random dataset of integers within specified range. Parameters: size (int): The number of elements in the dataset. min_value (int): Minimum value of an element. Default is 0. max_value (int): Maximum value of an element. Default is 10000. Returns: List[int]: A list of randomly generated integers. return [random.randint(min_value, max_value) for _ in range(size)] def compare_sorting_algorithms(): sizes = [1000, 5000, 10000, 50000] sorting_algorithms = [quick_sort, merge_sort, heap_sort] for size in sizes: data = generate_dataset(size) print(f\\"Dataset Size: {size}\\") for sort_function in sorting_algorithms: time_taken = measure_performance(sort_function, data) print(f\\"{sort_function.__name__}: {time_taken:.6f} seconds\\") ``` Input and Output **Input**: - Random datasets of various sizes for sorting. - Sorting algorithm implementations as functions. **Output**: - Sorted dataset (though the primary focus is on execution time). - Benchmark results showing execution times for each algorithm across different dataset sizes. Constraints - Ensure the sorting algorithms handle large datasets efficiently. - Datasets should only contain integer values within the specified range. - Execution time measurement should be precise for performance comparison. Scenario Implement the required sorting algorithms, generate random datasets of varying sizes, and compare the performance of each sorting algorithm. Validate the correctness of each sorting algorithm and ensure accurate execution time measurements for precise benchmarking results.","solution":"from typing import List, Callable def quick_sort(arr: List[int]) -> List[int]: Sorts an array using the Quick Sort algorithm. if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right) def merge_sort(arr: List[int]) -> List[int]: Sorts an array using the Merge Sort algorithm. if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left: List[int], right: List[int]) -> List[int]: result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result def heap_sort(arr: List[int]) -> List[int]: Sorts an array using the Heap Sort algorithm. def heapify(arr, n, i): largest = i l = 2 * i + 1 r = 2 * i + 2 if l < n and arr[l] > arr[largest]: largest = l if r < n and arr[r] > arr[largest]: largest = r if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest) n = len(arr) for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0) return arr def measure_performance(sort_function: Callable[[List[int]], List[int]], data: List[int]) -> float: Measures the execution time of a sorting function on a given dataset. import time start_time = time.time() sort_function(data.copy()) return time.time() - start_time"},{"question":"# Scenario You are working with a system that processes large datasets containing geographical coordinates. Your task is to identify clusters of points that are geographically close to one another. The clustering algorithm you need to implement uses a form of Density-Based Spatial Clustering of Applications with Noise (DBSCAN). The goal is to identify clusters and label each data point with its cluster ID. Points that do not belong to any cluster should be labeled as noise. # Task Implement a function `dbscan` that clusters geographical points based on the input parameters using the DBSCAN algorithm. Your function should follow these high-level steps: 1. Calculate the distance between all pairs of points. 2. Identify core points, border points, and noise points based on the radius (`eps`) and minimum number of points (`min_points`) thresholds. 3. Assign cluster labels to core points and propagate these labels to border points. # Function Signature ```python def dbscan(points: List[Tuple[float, float]], eps: float, min_points: int) -> List[int]: ``` # Input 1. `points`: A list of tuples, where each tuple represents the (latitude, longitude) of a point. 2. `eps`: A float representing the maximum distance for two points to be considered neighbors. 3. `min_points`: An integer representing the minimum number of points required to form a dense region (core point). # Output A list of integers representing cluster labels for each input point. Noise points should be labeled as -1. # Constraints - The latitude and longitude values are in decimal degrees and are realistic values on Earth. - `eps` is a non-negative float. - `min_points` is a positive integer. - The number of points can range from 1 to 10000. # Example ```python points = [ (37.7749, -122.4194), (37.7740, -122.4190), (37.7745, -122.4180), (34.0522, -118.2437), (34.0520, -118.2430), (40.7128, -74.0060) ] eps = 0.002 min_points = 2 # Expected Output: [0, 0, 0, 1, 1, -1] ``` # Notes 1. Your implementation should correctly handle cases where all points are noise by returning a list of -1s. 2. Optimize your solution for performance and clarity. 3. Ensure to test with edge cases such as very small or very large values of `eps`, and varying data density.","solution":"from typing import List, Tuple from math import sqrt def euclidean_distance(p1: Tuple[float, float], p2: Tuple[float, float]) -> float: return sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def dbscan(points: List[Tuple[float, float]], eps: float, min_points: int) -> List[int]: labels = [-1] * len(points) cluster_id = 0 for i in range(len(points)): if labels[i] != -1: continue neighbors = get_neighbors(points, i, eps) if len(neighbors) < min_points: labels[i] = -1 else: expand_cluster(points, labels, i, neighbors, cluster_id, eps, min_points) cluster_id += 1 return labels def get_neighbors(points: List[Tuple[float, float]], idx: int, eps: float) -> List[int]: neighbors = [] for i, point in enumerate(points): if euclidean_distance(points[idx], point) <= eps: neighbors.append(i) return neighbors def expand_cluster(points: List[Tuple[float, float]], labels: List[int], idx: int, neighbors: List[int], cluster_id: int, eps: float, min_points: int): labels[idx] = cluster_id i = 0 while i < len(neighbors): neighbor_idx = neighbors[i] if labels[neighbor_idx] == -1: labels[neighbor_idx] = cluster_id elif labels[neighbor_idx] == -1: labels[neighbor_idx] = cluster_id neighbor_neighbors = get_neighbors(points, neighbor_idx, eps) if len(neighbor_neighbors) >= min_points: neighbors.extend(neighbor_neighbors) i += 1"},{"question":"# Problem Statement You are given a matrix of numbers where each row and column is sorted in ascending order. Implement an algorithm that searches for a specific integer in the matrix efficiently. Your task is to find the position of the integer, if it exists, and return it as a tuple of its coordinates `(row, col)`. If the integer is not found, return `(-1, -1)`. # Input Format 1. A 2D list `matrix` of integers where each row and column is sorted in ascending order. 2. An integer `target` to be searched for in the matrix. # Output Format - A tuple `(row, col)` representing the position of `target` in the matrix. - `(-1, -1)` if `target` is not present in the matrix. # Constraints * The number of rows `m` and columns `n` of the matrix will be in the range (1 leq m, n leq 300). * The elements of the matrix and the integer `target` will be in the range (-10^6 leq text{element}, target leq 10^6). # Performance Requirements * Your solution should run efficiently with a time complexity close to (O(m + n)). # Examples 1. **Input**: ``` matrix = [ [1, 4, 7, 11], [2, 5, 8, 12], [3, 6, 9, 16], [10, 13, 14, 17] ] target = 5 ``` **Output**: ``` (1, 1) ``` 2. **Input**: ``` matrix = [ [1, 4, 7, 11], [2, 5, 8, 12], [3, 6, 9, 16], [10, 13, 14, 17] ] target = 15 ``` **Output**: ``` (-1, -1) ``` 3. **Input**: ``` matrix = [] target = 3 ``` **Output**: ``` (-1, -1) ``` # Function Signature ```python def search_matrix(matrix: list[list[int]], target: int) -> tuple: # Your code here ``` # Notes - Ensure your implementation is optimized and handles all edge cases. - Prefer a solution that avoids iterating over every element in the matrix directly.","solution":"def search_matrix(matrix: list[list[int]], target: int) -> tuple: Searches for a target value in a row-wise and column-wise sorted matrix. if not matrix or not matrix[0]: return -1, -1 rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return row, col elif matrix[row][col] < target: row += 1 else: col -= 1 return -1, -1"},{"question":"# Coding Task: Evaluate a Polynomial Function # Background: A polynomial function of degree n can be expressed in the form `P(x) = a_n*x^n + a_(n-1)*x^(n-1) + ... + a_1*x + a_0`, where `a_n, a_(n-1), ..., a_1, a_0` are coefficients and `x` is the variable. Evaluating a polynomial for a specific value of `x` involves computing the sum of each coefficient times the appropriate power of `x`. # Task: Implement a function that evaluates a given polynomial at a specified value of `x`. The coefficients of the polynomial and the value of `x` will be provided as inputs. # Function Signature: ```python def evaluate_polynomial(coefficients: list[float], x: float) -> float: pass ``` # Input: - A list `coefficients` of real numbers, representing the polynomial coefficients `[a_n, a_(n-1), ..., a_1, a_0]`. - A real number `x` at which the polynomial should be evaluated. # Output: - A single real number, the result of evaluating the polynomial `P(x)` at the given value of `x`. # Examples: ```python >>> evaluate_polynomial([1, 0, -3, 1], 2) 3.0 # Evaluates the polynomial 1*2^3 + 0*2^2 - 3*2 + 1 = 3 >>> evaluate_polynomial([2, -4, 0, 3], -1) -3.0 # Evaluates the polynomial 2*(-1)^3 - 4*(-1)^2 + 0*(-1) + 3 = -3 ``` # Constraints: * The length of the list `coefficients` is between 1 and 1000. * Each coefficient is a real number in the range of -10^6 to 10^6. * The value of `x` is a real number in the range of -10^6 to 10^6. # Notes: - The function should handle edge cases such as an empty list of coefficients (return 0), single coefficient (constant polynomial), and x equal to zero.","solution":"def evaluate_polynomial(coefficients: list[float], x: float) -> float: Evaluates a polynomial at a specific value x. Parameters: coefficients (list of float): List of coefficients [a_n, a_(n-1), ..., a_1, a_0]. x (float): Value at which the polynomial is to be evaluated. Returns: float: Result of the polynomial evaluation. result = 0.0 degree = len(coefficients) - 1 for coef in coefficients: result += coef * (x ** degree) degree -= 1 return result"},{"question":"# Problem Statement You are given a string `s` consisting of lowercase alphabets. Your task is to find the number of contiguous substrings that start and end with the same character. # Input * A single string `s` where 1 <= len(s) <= 1000. # Output * An integer representing the number of substrings that start and end with the same character. # Constraints 1. The length of the string `s` is between 1 and 1000. 2. The string contains only lowercase English letters. # Example Example 1: ``` Input: \\"abcba\\" Output: 7 ``` * Explanation: - The substrings are [\\"a\\", \\"b\\", \\"c\\", \\"b\\", \\"a\\", \\"bcb\\", \\"abcba\\"]. Example 2: ``` Input: \\"aaaa\\" Output: 10 ``` * Explanation: - The substrings are [\\"a\\", \\"a\\", \\"a\\", \\"a\\", \\"aa\\", \\"aa\\", \\"aa\\", \\"aaa\\", \\"aaa\\", \\"aaaa\\"]. # Function Signature ```python def count_substrings(s: str) -> int: ``` # Detailed Explanation Your task is to implement the above function which counts all of the contiguous substrings in the given string that start and end with the same character. To do this efficiently, consider utilizing nested loops where the outer loop picks the starting character and the inner loop expands this substring until the end of the string while checking the condition. Make sure that you handle edge cases, such as the smallest and largest possible input sizes.","solution":"def count_substrings(s: str) -> int: Returns the number of contiguous substrings that start and end with the same character. count = 0 n = len(s) for i in range(n): for j in range(i, n): if s[i] == s[j]: count += 1 return count"},{"question":"# Flatten Nested Lists **Scenario**: Imagine you are tasked with building a data processing system where one of the key operations is flattening nested lists. Your system needs to take arbitrarily nested lists and produce a single flat list containing all the values in the order they appeared in the original structure. **Task**: Write a function `flatten_nested_lists(nested_list: list) -> list` that takes a nested list of arbitrary depth and returns a flat list containing all the elements in a single level. **Input**: * `nested_list` - A list that can contain integers and/or other lists of integers (which can themselves contain further lists). **Output**: * A single flat list containing all integers from the nested structure, in their original order. **Constraints**: * The elements within the nested lists are guaranteed to be either integers or other lists. * The input list can be empty or have any nesting depth. **Example**: ```python >>> flatten_nested_lists([1, [2, [3, 4]], 5, [[6]], [[[7]]], 8]) [1, 2, 3, 4, 5, 6, 7, 8] >>> flatten_nested_lists([1, [2, 3], 4, [5, [6, 7]], 8]) [1, 2, 3, 4, 5, 6, 7, 8] >>> flatten_nested_lists([]) [] >>> flatten_nested_lists([[[]], [], [1, [2], [], 3], 4, [[[[5]]]], [6, [], [[7], [8]]]]) [1, 2, 3, 4, 5, 6, 7, 8] ``` **Note**: - Ensure the original order of elements is preserved in the flattened list. - Consider a recursive approach to handle nested structures efficiently.","solution":"def flatten_nested_lists(nested_list): Flattens a nested list of arbitrary depth to a single flat list containing all elements. Params: nested_list (list): A list that may contain integers and/or other lists of integers. Returns: list: A flat list containing all integers from the nested structure, in their original order. flat_list = [] def flatten(inner_list): for item in inner_list: if isinstance(item, list): flatten(item) else: flat_list.append(item) flatten(nested_list) return flat_list"},{"question":"# Context: You are tasked with developing a small module for a financial application that implements basic account management functionalities, ensuring accurate fund tracking and transaction processing. # Task: Implement a `BankAccount` class with methods to handle deposits, withdrawals, and balance inquiries. The class should also maintain a record of all transactions. # Requirements: Input: - The class should be initialized with a `balance` (float) representing the starting balance of the account. Methods: - `deposit(amount: float)`: Adds the specified amount to the balance and records the transaction. - `withdraw(amount: float)`: Subtracts the specified amount from the balance if sufficient funds are available and records the transaction. Should raise an exception if there are insufficient funds. - `get_balance() -> float`: Returns the current balance. - `get_transactions() -> List[str]`: Returns a list of strings where each string represents a transaction record. Constraints: - Initial balance is guaranteed to be non-negative. - Each transaction (deposit or withdrawal) involves a positive amount of money. - Deposits and withdrawals should be recorded as strings in the format `\\"<operation>: <amount>\\"`, where `<operation>` is either \\"Deposit\\" or \\"Withdrawal\\" and `<amount>` is the transaction amount. Example: ```python account = BankAccount(100.0) account.deposit(50.0) account.withdraw(30.0) balance = account.get_balance() # Output: 120.0 transactions = account.get_transactions() # Output: [\'Deposit: 50.0\', \'Withdrawal: 30.0\'] ``` # Explanation: - The initial balance is 100.0. - After depositing 50.0, the new balance is 150.0. - After withdrawing 30.0, the new balance is 120.0. - The transaction history shows the deposit of 50.0 and withdrawal of 30.0. # Note: - Implement the `BankAccount` class with all the required methods. - Handle exceptions appropriately for edge cases (e.g., withdrawal with insufficient balance). - Ensure the balance and transaction records are stored and updated correctly.","solution":"class BankAccount: def __init__(self, balance: float): self.balance = balance self.transactions = [] def deposit(self, amount: float): if amount > 0: self.balance += amount self.transactions.append(f\\"Deposit: {amount}\\") else: raise ValueError(\\"Deposit amount must be positive\\") def withdraw(self, amount: float): if amount > 0: if self.balance >= amount: self.balance -= amount self.transactions.append(f\\"Withdrawal: {amount}\\") else: raise ValueError(\\"Insufficient funds\\") else: raise ValueError(\\"Withdrawal amount must be positive\\") def get_balance(self) -> float: return self.balance def get_transactions(self) -> list: return self.transactions"},{"question":"# **Coding Challenge: Balanced Parentheses in Mathematical Expressions** You are given a mathematical expression that consists of various types of parentheses, including round `()`, square `[]`, and curly `{}`. Your task is to determine if the expression contains balanced parentheses. An expression is considered balanced if: 1. Every opening parenthesis has a corresponding closing parenthesis of the same type. 2. Parentheses are correctly nested. **Problem Statement**: Write a function `is_balanced(expression: str) -> bool` that checks whether the given mathematical expression has balanced parentheses. # **Input Format** * A string `expression` containing mathematical symbols and parentheses. # **Output Format** * Returns `True` if the parentheses in the expression are balanced; otherwise, returns `False`. # **Constraints** * The length of the expression will not exceed 10^4 characters. * The expression will only contain valid mathematical symbols, digits, and parentheses. # **Example** * For `expression = \\"((1 + 2) * [3 / {4 - (5 + 6)}])\\"`: ```python print(is_balanced(\\"((1 + 2) * [3 / {4 - (5 + 6)}])\\")) # Output: True ``` * For `expression = \\"(1 + 2) * [3 / {4 - 5 + 6)}]\\"`: ```python print(is_balanced(\\"(1 + 2) * [3 / {4 - 5 + 6)}]\\")) # Output: False ``` # **Explanation** - In the first example, every opening parenthesis has a corresponding closing parenthesis and the parentheses are properly nested, so it returns `True`. - In the second example, there is a misalignment in the parentheses, particularly with the order of closing brackets, so it returns `False`. Make sure to test your function thoroughly with various edge cases to ensure its accuracy.","solution":"def is_balanced(expression: str) -> bool: Check if the mathematical expression has balanced parentheses. Parameters: expression (str): The mathematical expression containing parentheses. Returns: bool: True if the expression is balanced, False otherwise. stack = [] matching_parentheses = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} for char in expression: if char in matching_parentheses.values(): stack.append(char) elif char in matching_parentheses: if not stack or stack[-1] != matching_parentheses[char]: return False stack.pop() return not stack"},{"question":"# Context You are given a directory containing multiple text files, where each file contains a list of integers separated by newlines. # Problem Statement Write a function `find_common_integers(directory)` that finds all integers that appear in every file within the specified directory. # Input - `directory`: A string representing the path to the directory containing the text files. # Output - A list of integers that are present in every file. The list should be sorted in ascending order. # Constraints - The directory will contain less than or equal to 100 text files. - Each file will contain at most 1000 integers. - Each integer in the files will be within the range of [-10^6, 10^6]. # Example Let\'s assume the directory contains the following files: **file1.txt** ``` 1 2 3 4 ``` **file2.txt** ``` 2 3 4 5 ``` **file3.txt** ``` 3 4 5 6 ``` ```python >>> find_common_integers(\'directory_path\') [3, 4] ``` # Implementation ```python import os def find_common_integers(directory): from collections import defaultdict import glob file_pattern = os.path.join(directory, \\"*.txt\\") files = glob.glob(file_pattern) if not files: return [] integer_count = defaultdict(int) num_files = len(files) for file in files: with open(file) as f: integers_in_file = set(map(int, f.read().split())) for num in integers_in_file: integer_count[num] += 1 common_integers = [num for num, count in integer_count.items() if count == num_files] common_integers.sort() return common_integers ```","solution":"import os from collections import defaultdict import glob def find_common_integers(directory): Finds all integers that appear in every file within the specified directory. The directory contains text files with integers separated by newlines. file_pattern = os.path.join(directory, \\"*.txt\\") files = glob.glob(file_pattern) if not files: return [] integer_count = defaultdict(int) num_files = len(files) for file in files: with open(file) as f: integers_in_file = set(map(int, f.read().split())) for num in integers_in_file: integer_count[num] += 1 common_integers = [num for num, count in integer_count.items() if count == num_files] common_integers.sort() return common_integers"},{"question":"# Context Consider a scenario where you have a singly linked list containing integer values. You are required to implement a function that merges two sorted linked lists into a single sorted linked list. # Task Implement a method `merge_with(self, other: \'LinkedList\') -> \'LinkedList\'` within the `LinkedList` class that merges the current linked list with another linked list passed as an argument. Both linked lists are supposed to be sorted in non-decreasing order, and the resultant list should also be sorted in non-decreasing order. # Function Signature ```python class LinkedList: def merge_with(self, other: \'LinkedList\') -> \'LinkedList\': # Your code here ``` # Input - An instance of the `LinkedList` class `other` representing the other linked list to merge with. # Output - The function returns a new linked list that is the result of merging the two input linked lists. # Constraints - The lengths of the linked lists are in the range [0, 500]. - The linked lists contain integer values within the range [-10^3, 10^3]. # Example ```python >>> ll1 = LinkedList([1, 3, 5]) >>> ll2 = LinkedList([2, 4, 6]) >>> merged_list = ll1.merge_with(ll2) >>> tuple(merged_list) (1, 2, 3, 4, 5, 6) >>> str(merged_list) \'1 -> 2 -> 3 -> 4 -> 5 -> 6\' >>> ll1 = LinkedList([-1, 0, 2]) >>> ll2 = LinkedList([1, 3, 4]) >>> merged_list = ll1.merge_with(ll2) >>> tuple(merged_list) (-1, 0, 1, 2, 3, 4) >>> str(merged_list) \'-1 -> 0 -> 1 -> 2 -> 3 -> 4\' ``` # Notes - If one or both of the linked lists are empty, the result should be the non-empty list or an empty list if both are empty. - The function should not modify the original linked lists but return a new sorted linked list that combines elements from both input lists.","solution":"class Node: def __init__(self, value=0, next_node=None): self.value = value self.next = next_node class LinkedList: def __init__(self, values=[]): self.head = None if values: self.head = Node(values[0]) current = self.head for value in values[1:]: current.next = Node(value) current = current.next def __iter__(self): current = self.head while current: yield current.value current = current.next def __str__(self): values = list(map(str, self)) return \\" -> \\".join(values) def merge_with(self, other: \'LinkedList\') -> \'LinkedList\': dummy = Node() tail = dummy p1, p2 = self.head, other.head while p1 and p2: if p1.value <= p2.value: tail.next = p1 p1 = p1.next else: tail.next = p2 p2 = p2.next tail = tail.next if p1: tail.next = p1 elif p2: tail.next = p2 # Create a new linked list from the merged nodes. merged_list = LinkedList() merged_list.head = dummy.next return merged_list"},{"question":"# Task Write a function `is_valid_password` that checks if a given password meets the following criteria: 1. The password must be at least 8 characters long. 2. It must contain at least one lowercase letter. 3. It must contain at least one uppercase letter. 4. It must contain at least one digit. 5. It must contain at least one special character from the set `!@#%^&*()`. # Function Signature ```python def is_valid_password(password: str) -> bool: ``` # Input - A single input parameter `password` which is a string. # Output - The function should return `True` if the input string is a valid password according to the criteria, else `False`. # Constraints - The password can contain any printable ASCII character. - The function does not need to handle exceptions or error messages. # Examples ```python assert is_valid_password(\\"Password123!\\") == True assert is_valid_password(\\"password\\") == False assert is_valid_password(\\"PASSWORD123\\") == False assert is_valid_password(\\"Pass123\\") == False assert is_valid_password(\\"Pass!@#\\") == False assert is_valid_password(\\"P@ssw0rd\\") == True assert is_valid_password(\\"P@ssword!\\") == True assert is_valid_password(\\"Pass1234!\\") == True assert is_valid_password(\\"12345678\\") == False assert is_valid_password(\\"PASSWORD@1\\") == True ``` # Notes - Ensure that the function efficiently checks each criterion and accounts for various edge cases. - Focus on optimizing the checks for length, letter case, digit presence, and special characters. - Test the function thoroughly to cover different scenarios and edge cases.","solution":"import re def is_valid_password(password: str) -> bool: Returns True if the password meets the given criteria: - At least 8 characters long - Contains at least one lowercase letter - Contains at least one uppercase letter - Contains at least one digit - Contains at least one special character from !@#%^&*() Otherwise, returns False. if len(password) < 8: return False if not re.search(r\'[a-z]\', password): return False if not re.search(r\'[A-Z]\', password): return False if not re.search(r\'d\', password): return False if not re.search(r\'[!@#%^&*()]\', password): return False return True"},{"question":"# Sorting an Array of Strings by Their Integer Values **Context**: You have a list of strings, each representing a version number made up of integers separated by dots (e.g., \\"1.0.2\\", \\"1.0.10\\", \\"1.0.2.5\\"). The task is to sort these version numbers in ascending order based on their integer values. # Task: 1. **Parsing Function**: Implement a function to parse each version number string into a list of integers. 2. **Sorting Logic**: Use the parsed integer lists to sort the original strings in ascending order. 3. **Implement and Evaluate**: Implement the sorting algorithm and evaluate its performance by verifying the sorted order. # Inputs: - **version_list**: List of strings representing version numbers. # Expected Output: - Print the sorted list of version numbers. # Code Constraints: - Use Python standard libraries and functions. - Ensure your code handles parsing efficiently. - Include meaningful comments and print statements for analysis and debug purposes. Here is the skeleton of the program you need to implement: ```python def parse_version(version): Parse a version string into a list of integers. :param version: str :return: list of int return list(map(int, version.split(\'.\'))) def version_sort(version_list): Sort a list of version strings based on their integer values. :param version_list: list of str :return: sorted list of str return sorted(version_list, key=parse_version) def main(): versions = [\\"1.0.2\\", \\"1.0.10\\", \\"1.0.2.5\\", \\"1.1\\", \\"1.0\\"] print(\\"Original list of versions:\\") print(versions) sorted_versions = version_sort(versions) print(\\"Sorted list of versions:\\") print(sorted_versions) if __name__ == \\"__main__\\": main() ``` # Evaluation - You will be evaluated on correctly implementing the parsing and sorting logic. - Properly handling edge cases such as versions with different lengths. - Clear and concise code with appropriate function naming and comments.","solution":"def parse_version(version): Parse a version string into a list of integers. :param version: str :return: list of int return list(map(int, version.split(\'.\'))) def version_sort(version_list): Sort a list of version strings based on their integer values. :param version_list: list of str :return: sorted list of str return sorted(version_list, key=parse_version) def main(): versions = [\\"1.0.2\\", \\"1.0.10\\", \\"1.0.2.5\\", \\"1.1\\", \\"1.0\\"] print(\\"Original list of versions:\\") print(versions) sorted_versions = version_sort(versions) print(\\"Sorted list of versions:\\") print(sorted_versions) if __name__ == \\"__main__\\": main()"},{"question":"# Problem Statement Design a function `robot_movement(grid: List[List[int]], sr: int, sc: int, er: int, ec: int) -> int` that calculates the shortest path for a robot to move from the starting position `(sr, sc)` to the ending position `(er, ec)` within a `grid` filled with obstacles and free spaces. The robot can move up, down, left, or right, but cannot move through obstacles. # Objective Implement the function with the following constraints: 1. The function should be efficient enough to handle large grids (up to 1000x1000 cells). 2. Ensure the implementation correctly accounts for grid boundaries and obstacles. 3. The grid cell values are either 0 (free space) or 1 (obstacle). # Input and Output * **Input**: - A 2D list `grid` of integers representing the grid, where `grid[i][j]` is 0 or 1. - Integer `sr` and `sc` representing the starting row and column. - Integer `er` and `ec` representing the ending row and column. * **Output**: An integer representing the minimum number of steps required to reach the destination. If there is no valid path, return -1. # Constraints - The function should work within O(n * m) time complexity where n and m are the dimensions of the grid. - Ensure robust handling of various edge cases, including no possible path due to obstacles. # Example ```python >>> grid = [ ... [0, 0, 0, 0, 0], ... [0, 1, 1, 1, 0], ... [0, 0, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 0, 0] ... ] >>> robot_movement(grid, 0, 0, 4, 4) 8 >>> grid = [ ... [0, 0, 1], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> robot_movement(grid, 0, 0, 2, 2) 4 >>> grid = [ ... [0, 1], ... [1, 0] ... ] >>> robot_movement(grid, 0, 0, 1, 1) -1 ``` # Notes - Use Breadth-First Search (BFS) for an efficient solution. - Consider edge cases where start or end positions are obstacles. - The grid dimensions can vary but will always be at least 1x1. Apply thoughtful optimization to ensure performance remains within acceptable bounds for the maximum grid size.","solution":"from collections import deque from typing import List, Tuple def robot_movement(grid: List[List[int]], sr: int, sc: int, er: int, ec: int) -> int: This function calculates the shortest path for a robot to move from the starting position (sr, sc) to the ending position (er, ec) within a grid filled with obstacles and free spaces. The robot can move up, down, left, or right, but cannot move through obstacles. # Check if starting or ending position is an obstacle if grid[sr][sc] == 1 or grid[er][ec] == 1: return -1 rows, cols = len(grid), len(grid[0]) # Directions the robot can move: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # A queue to perform BFS queue = deque([(sr, sc, 0)]) # (current_row, current_column, current_distance) # A set to track visited cells visited = set() visited.add((sr, sc)) while queue: current_row, current_col, current_distance = queue.popleft() # Check if we have reached the destination if current_row == er and current_col == ec: return current_distance # Explore all possible directions for dr, dc in directions: new_row, new_col = current_row + dr, current_col + dc # Check if the new cell is within bounds and is not an obstacle or already visited if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited and grid[new_row][new_col] == 0: queue.append((new_row, new_col, current_distance + 1)) visited.add((new_row, new_col)) # If no path is found, return -1 return -1"},{"question":"# Problem Statement You are given a list of integers representing the amount of rain observed for consecutive days. Your task is to implement a function to compute the maximum amount of water that can be trapped between these bars after it rains. # Detailed Specification Function Signature ```python def trap_rain_water(heights: List[int]) -> int: ``` Input Format - `heights`: A list of integers, where the length of the list is between 0 and 10^4. Each element represents the height of the water bar. Output Format Return an integer representing the maximum amount of water that can be trapped. # Constraints - 0 <= len(heights) <= 10^4 - The elements of `heights` are non-negative integers and can be up to 10^5. # Example Example 1 ```python heights = [0,1,0,2,1,0,1,3,2,1,2,1] print(trap_rain_water(heights)) # Output: 6 ``` In this example, the maximum amount of water that can be trapped is 6 units. Example 2 ```python heights = [4,2,0,3,2,5] print(trap_rain_water(heights)) # Output: 9 ``` In this example, the maximum amount of water that can be trapped is 9 units. Example 3 ```python heights = [1,2,3,4,5] print(trap_rain_water(heights)) # Output: 0 ``` In this example, no water can be trapped between the bars. # Constraints Your implementation should handle the following constraints: - The function should handle arrays of various sizes up to 10^4 elements efficiently. - Consider edge cases such as empty arrays, arrays with only one element, and arrays where all elements are the same height. # Notes - Focus on an efficient algorithm that has a linear time complexity of O(N). - Ensure your function correctly identifies valleys where water can be trapped and calculates the total trapped water accordingly, even in edge cases.","solution":"from typing import List def trap_rain_water(heights: List[int]) -> int: if not heights: return 0 left_max, right_max = 0, 0 left, right = 0, len(heights) - 1 total_water = 0 while left < right: if heights[left] < heights[right]: if heights[left] >= left_max: left_max = heights[left] else: total_water += left_max - heights[left] left += 1 else: if heights[right] >= right_max: right_max = heights[right] else: total_water += right_max - heights[right] right -= 1 return total_water"},{"question":"# Context You are required to implement a custom hash table (also known as a hash map) in Python. Hash tables are data structures that provide efficient insertion, deletion, and lookup of key-value pairs. Your implementation should handle collisions using chaining (linked lists). # Objective Write a class `MyHashTable` that implements a hash table with the following functionalities: 1. **Initialization**: - `__init__(self, size: int) -> None`: Initialize the hash table with a given size. 2. **Insert Method**: - `put(self, key: int, value: int) -> None`: Insert a key-value pair into the hash table. 3. **Get Method**: - `get(self, key: int) -> Optional[int]`: Retrieve the value associated with the given key. Return `None` if the key is not found. 4. **Remove Method**: - `remove(self, key: int) -> None`: Remove the specified key and its associated value from the hash table. Do nothing if the key is not present. 5. **Hash Function**: - You may use the modulo operator with the table size to determine the hash value for a key. # Constraints - Keys and values should be non-negative integers. - Keys will be unique within the hash table. - The size of the hash table will be a positive integer provided at initialization. - The number of operations performed will not exceed (10^5). # Example Usage ```python hash_table = MyHashTable(10) hash_table.put(1, 10) hash_table.put(2, 20) hash_table.put(11, 30) print(hash_table.get(1)) # Output: 10 print(hash_table.get(11)) # Output: 30 print(hash_table.get(3)) # Output: None hash_table.remove(2) print(hash_table.get(2)) # Output: None ``` # Performance Requirements The solution must handle a large number of operations efficiently. Ensure that common edge cases, such as inserting duplicate keys and removing non-existing keys, are managed correctly. Implement the `MyHashTable` class below, ensuring robust handling of all specified methods for accurate and efficient data storage and retrieval.","solution":"class MyHashTable: def __init__(self, size: int) -> None: Initialize the hash table with a given size. self.size = size self.table = [[] for _ in range(size)] def put(self, key: int, value: int) -> None: Insert a key-value pair into the hash table. index = self._hash(key) for pair in self.table[index]: if pair[0] == key: pair[1] = value return self.table[index].append([key, value]) def get(self, key: int) -> int: Retrieve the value associated with the given key. Return None if the key is not found. index = self._hash(key) for pair in self.table[index]: if pair[0] == key: return pair[1] return None def remove(self, key: int) -> None: Remove the specified key and its associated value from the hash table. Do nothing if the key is not present. index = self._hash(key) for i, pair in enumerate(self.table[index]): if pair[0] == key: del self.table[index][i] return def _hash(self, key: int) -> int: Compute the hash value for a given key using modulo operation. return key % self.size"},{"question":"# Binary Tree Manipulation You are tasked with implementing a binary tree and performing various operations to manipulate and traverse the tree. Specifically, you will create functions that allow the insertion of nodes, traversal of the tree in different orders, and the search of nodes within the tree. Problem Statement Implement the following classes and functions in Python: 1. **`class TreeNode:`** - A class representing a node in the binary tree. - **Attributes**: - `val`: The value stored in the node. - `left`: A reference to the left child node (initially `None`). - `right`: A reference to the right child node (initially `None`). - **Methods**: - `__init__(self, val: int) -> None`: Constructor to initialize the node with a given value. 2. **`class BinaryTree:`** - A class representing the binary tree. - **Attributes**: - `root`: A reference to the root node of the tree (initially `None`). - **Methods**: - `__init__(self) -> None`: Constructor to initialize an empty tree. - `insert(self, val: int) -> None`: Inserts a node with value `val` into the binary tree. - `search(self, val: int) -> bool`: Searches for a node with value `val` in the binary tree and returns `True` if found, `False` otherwise. - `inorder_traversal(self) -> list`: Returns a list of node values in the tree in in-order traversal. - `preorder_traversal(self) -> list`: Returns a list of node values in the tree in pre-order traversal. - `postorder_traversal(self) -> list`: Returns a list of node values in the tree in post-order traversal. # Additional Details - Nodes are inserted based on binary search tree property: - If `val` is less than the current node\'s value, it goes to the left child. - If `val` is greater than the current node\'s value, it goes to the right child. - Traversal methods should be recursive. # Example ```python # create binary tree and insert nodes bt = BinaryTree() bt.insert(5) bt.insert(3) bt.insert(7) bt.insert(2) bt.insert(4) bt.insert(6) bt.insert(8) # check if value exists in tree print(bt.search(4)) # Output: True print(bt.search(9)) # Output: False # traverse the tree print(bt.inorder_traversal()) # Output: [2, 3, 4, 5, 6, 7, 8] print(bt.preorder_traversal()) # Output: [5, 3, 2, 4, 7, 6, 8] print(bt.postorder_traversal()) # Output: [2, 4, 3, 6, 8, 7, 5] ``` Ensure your implementation correctly handles edge cases such as inserting into an empty tree, searching a value that doesn\'t exist, and performing traversals on an empty tree.","solution":"class TreeNode: def __init__(self, val: int) -> None: self.val = val self.left = None self.right = None class BinaryTree: def __init__(self) -> None: self.root = None def insert(self, val: int) -> None: if self.root is None: self.root = TreeNode(val) else: self._insert_recursive(self.root, val) def _insert_recursive(self, node, val): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._insert_recursive(node.left, val) else: if node.right is None: node.right = TreeNode(val) else: self._insert_recursive(node.right, val) def search(self, val: int) -> bool: return self._search_recursive(self.root, val) def _search_recursive(self, node, val): if node is None: return False if node.val == val: return True elif val < node.val: return self._search_recursive(node.left, val) else: return self._search_recursive(node.right, val) def inorder_traversal(self) -> list: result = [] self._inorder_recursive(self.root, result) return result def _inorder_recursive(self, node, result): if node: self._inorder_recursive(node.left, result) result.append(node.val) self._inorder_recursive(node.right, result) def preorder_traversal(self) -> list: result = [] self._preorder_recursive(self.root, result) return result def _preorder_recursive(self, node, result): if node: result.append(node.val) self._preorder_recursive(node.left, result) self._preorder_recursive(node.right, result) def postorder_traversal(self) -> list: result = [] self._postorder_recursive(self.root, result) return result def _postorder_recursive(self, node, result): if node: self._postorder_recursive(node.left, result) self._postorder_recursive(node.right, result) result.append(node.val)"},{"question":"# Coding Assessment Question Scenario: You are responsible for building a university system that needs to maintain the relationships between students and the courses they have enrolled in. You need to implement a function that can determine a student\'s current enrollment status in a list of courses. Problem Statement: Implement a Python function `enrollment_status(student_courses: dict, student: str, course: str) -> str` that checks if a given student is enrolled in a specific course. Requirements: 1. The function should handle cases where the student does not exist in the system. 2. The function should return \\"Enrolled\\", \\"Not Enrolled\\", or \\"Student Not Found\\". 3. The input will be a dictionary where the keys are student names and the values are lists of courses they are enrolled in. 4. If the student does not exist in the dictionary, return \\"Student Not Found\\". 5. If the student is not enrolled in the specified course, return \\"Not Enrolled\\". 6. If the student is enrolled in the specified course, return \\"Enrolled\\". Input: - A dictionary `student_courses` where keys are strings (student names) and values are lists of strings (course names). - A string `student` representing the student\'s name. - A string `course` representing the course name. Output: - A string: \\"Enrolled\\", \\"Not Enrolled\\", or \\"Student Not Found\\" based on the student\'s enrollment status. Constraints: - The length of any student\'s list of courses will not exceed 1000. - The student name and course name will be non-empty strings and no longer than 100 characters. Function Signature: ```python def enrollment_status(student_courses: dict, student: str, course: str) -> str: ``` Example Cases: ```python student_courses = { \\"Alice\\": [\\"Math\\", \\"Physics\\", \\"Chemistry\\"], \\"Bob\\": [\\"Biology\\", \\"Math\\", \\"Art\\"], \\"Charlie\\": [\\"History\\", \\"Math\\"] } assert enrollment_status(student_courses, \\"Alice\\", \\"Math\\") == \\"Enrolled\\" assert enrollment_status(student_courses, \\"Alice\\", \\"Art\\") == \\"Not Enrolled\\" assert enrollment_status(student_courses, \\"Dorothy\\", \\"Math\\") == \\"Student Not Found\\" assert enrollment_status(student_courses, \\"Bob\\", \\"Art\\") == \\"Enrolled\\" assert enrollment_status(student_courses, \\"Charlie\\", \\"Physics\\") == \\"Not Enrolled\\" ``` Implement the `enrollment_status` function following the given requirements.","solution":"def enrollment_status(student_courses: dict, student: str, course: str) -> str: if student not in student_courses: return \\"Student Not Found\\" if course in student_courses[student]: return \\"Enrolled\\" return \\"Not Enrolled\\""},{"question":"# Question: Matrix Operations Implementation You have to design a class, `Matrix`, representing a two-dimensional array of integers. This matrix should support operations such as addition, subtraction, multiplication, and transpose. Each operation must adhere to standard matrix arithmetic rules. Your task: Implement the `Matrix` class with the following functionalities: 1. **Initialization**: - Initialize the matrix with a two-dimensional list of integers or a specific integer value. - If a specific integer value is used, create a square matrix where all elements are set to this value. 2. **Addition**: - `add(self, other: Matrix) -> Matrix`: Calculate and return a new matrix representing the sum of this matrix and another matrix. 3. **Subtraction**: - `subtract(self, other: Matrix) -> Matrix`: Calculate and return a new matrix representing the difference of this matrix and another matrix. 4. **Multiplication**: - `multiply(self, other: Matrix) -> Matrix`: Calculate and return a new matrix representing the product of this matrix and another matrix. 5. **Transpose**: - `transpose(self) -> Matrix`: Calculate and return the transpose of this matrix. 6. **String Representation**: - `__str__(self) -> str`: Provide a string representation of the matrix for easy printing. Requirements: * Name of the class: `Matrix` * Each method should handle invalid input or operations gracefully. * For addition and subtraction: * The matrices must have the same dimensions; otherwise, raise a `ValueError`. * For multiplication: * The number of columns in the first matrix must match the number of rows in the second matrix; otherwise, raise a `ValueError`. Example Scenarios & Edge Cases: 1. **Edge Cases**: * Operations on non-square matrices. * Addition, subtraction, and multiplication with mismatched dimensions. * Transposition of a non-square matrix. 2. **Example Usage**: ```python matrix1 = Matrix([[1, 2, 3], [4, 5, 6]]) matrix2 = Matrix([[7, 8, 9], [10, 11, 12]]) sum_matrix = matrix1.add(matrix2) print(sum_matrix) # Expected: [[8, 10, 12], [14, 16, 18]] diff_matrix = matrix1.subtract(matrix2) print(diff_matrix) # Expected: [[-6, -6, -6], [-6, -6, -6]] matrix3 = Matrix([[1, 2], [3, 4], [5, 6]]) product_matrix = matrix1.multiply(matrix3) print(product_matrix) # Expected: [[22, 28], [49, 64]] transposed_matrix = matrix1.transpose() print(transposed_matrix) # Expected: [[1, 4], [2, 5], [3, 6]] square_matrix = Matrix(2) print(square_matrix) # Expected: [[2, 2], [2, 2]] ``` Implement the class with all necessary methods and ensure that it passes testing for the edge cases and examples provided.","solution":"class Matrix: def __init__(self, data): if isinstance(data, int): self.data = [[data for _ in range(data)] for _ in range(data)] else: self.data = data self.rows = len(self.data) self.cols = len(self.data[0]) if self.rows > 0 else 0 def add(self, other): if self.rows != other.rows or self.cols != other.cols: raise ValueError(\\"Matrices must have the same dimensions for addition.\\") return Matrix([[self.data[i][j] + other.data[i][j] for j in range(self.cols)] for i in range(self.rows)]) def subtract(self, other): if self.rows != other.rows or self.cols != other.cols: raise ValueError(\\"Matrices must have the same dimensions for subtraction.\\") return Matrix([[self.data[i][j] - other.data[i][j] for j in range(self.cols)] for i in range(self.rows)]) def multiply(self, other): if self.cols != other.rows: raise ValueError(\\"Number of columns of the first matrix must be equal to the number of rows of the second matrix.\\") result = [] for i in range(self.rows): new_row = [] for j in range(other.cols): sum_product = sum(self.data[i][k] * other.data[k][j] for k in range(self.cols)) new_row.append(sum_product) result.append(new_row) return Matrix(result) def transpose(self): return Matrix([[self.data[j][i] for j in range(self.rows)] for i in range(self.cols)]) def __str__(self): return \'n\'.join([\' \'.join(map(str, row)) for row in self.data])"},{"question":"# Question Your task is to implement a function named `inversion_count` that counts the number of inversions in an array of numbers. An inversion is a pair of elements where the first is greater than the second but appears before it in the array. This exercise will help you understand divide-and-conquer strategies and their applications in sorting algorithms. # Requirements * **Function Signature**: `def inversion_count(arr: list[int | float]) -> int:` * **Parameters**: - `arr`: A list of integers or floats. * **Returns**: An integer representing the number of inversions in the array. # Constraints 1. The list `arr` will not be empty. 2. The function should be implemented using a recursive approach similar to merge sort and must have a time complexity of O(n log n). # Example ```python arr1 = [2, 4, 1, 3, 5] print(inversion_count(arr1)) # Output should be 3 arr2 = [5, 3, 2, 4, 1] print(inversion_count(arr2)) # Output should be 8 arr3 = [1, 2, 3, 4, 5] print(inversion_count(arr3)) # Output should be 0 ``` # Implementation Guidelines * Utilize a divide-and-conquer strategy similar to the merge sort algorithm. * Count inversions during the merge step by comparing elements from the two halves. * Recursively split the array into subarrays until each subarray has only one element. * Merge the subarrays while counting the inversions where elements from the right subarray are smaller than those from the left subarray. * Ensure efficiency by maintaining a time complexity of O(n log n).","solution":"def inversion_count(arr): Function that counts the number of inversions in an array using merge sort. def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 # Conditions are checked to ensure that i doesn\'t exceed mid and j doesn\'t exceed right while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count return merge_sort_and_count(arr, [0]*len(arr), 0, len(arr)-1)"},{"question":"# Question Scenario: You are developing a part of a larger application that involves handling special sequences within strings. Specifically, you need to write a function that replaces all occurrences of a given target substring within an input string with another specified replacement substring. Task: Implement the function `replace_substring` that takes three inputs: the original string, a target substring, and a replacement substring. The function should return a new string where all instances of the target substring within the original string are replaced with the replacement substring. Implementation: 1. Define the function `replace_substring(s: str, target: str, replacement: str) -> str`. 2. Ensure the function handles the following: * The target and replacement substrings can be of any length, including zero. * Input validation to ensure none of the inputs are None and that they are strings. * Consider edge cases where the target substring does not exist within the original string, or where the target and replacement substrings are the same. 3. Optimize for performance where possible, maintaining clarity and correctness. Input: * A string `s` representing the original input string. * A string `target` representing the substring to be replaced. * A string `replacement` representing the substring to replace the target with. Output: * A new string with all instances of the target substring replaced by the replacement substring. Constraints: * The input string length does not exceed 10^6 characters. * The target and replacement substrings\' lengths do not exceed 10^5 characters. * The length of `s` is at least as long as `target`. Examples: ```python >>> replace_substring(\\"hello world\\", \\"world\\", \\"there\\") \\"hello there\\" >>> replace_substring(\\"abc abc abc\\", \\"abc\\", \\"xyz\\") \\"xyz xyz xyz\\" >>> replace_substring(\\"aaaaa\\", \\"aa\\", \\"b\\") \\"bbba\\" >>> replace_substring(\\"no matches here\\", \\"nomatch\\", \\"replace\\") \\"no matches here\\" >>> replace_substring(\\"\\", \\"target\\", \\"replace\\") \\"\\" ``` Performance Requirements: The function should perform efficiently, especially with respect to the length of the input string and the target substring. It should handle typical cases with linear time complexity as much as possible, ensuring it can process large input quickly and effectively.","solution":"def replace_substring(s: str, target: str, replacement: str) -> str: Replaces all occurrences of target substring in the input string with the replacement substring. Parameters: - s: str, the original string - target: str, the substring to be replaced - replacement: str, the substring to replace with Returns: - str, the modified string with replacements made if not isinstance(s, str) or not isinstance(target, str) or not isinstance(replacement, str): raise ValueError(\\"All inputs must be of type str\\") if target == \\"\\": return s # If target is empty, we do nothing as we cannot replace an empty string return s.replace(target, replacement)"},{"question":"# Scenario You have been asked to develop a feature for a messaging application that ensures the order of user messages remains consistent across different devices and platforms. To achieve this, you need to implement a logical clock synchronization mechanism using Lamport Timestamps. Each message should have an associated timestamp that dictates its order in the sequence of messages. # Task Write a Python class `LogicalClock` that manages Lamport Timestamps for a distributed system. The class should support the following methods: 1. `send_event`: Increment the logical clock and return the new timestamp. 2. `receive_event`: Update the logical clock based on the received message timestamp and return the new timestamp. 3. `get_time`: Return the current value of the logical clock. # Requirements - Implement the class `LogicalClock` with the specified methods. - Ensure that the logical clock always provides a consistent ordering of events. - Use the Lamport Clock mechanism to update the timestamp properly when events are sent and received. # Constraints - The initial value of the logical clock should be 0. - The system should handle integer timestamps. - The timestamps should be consistent with the Lamport Clock rules. # Example ```python class LogicalClock: def __init__(self): self.time = 0 def send_event(self): self.time += 1 return self.time def receive_event(self, received_time): self.time = max(self.time, received_time) + 1 return self.time def get_time(self): return self.time # Example usage lc = LogicalClock() print(lc.send_event()) # Output: 1 print(lc.get_time()) # Output: 1 print(lc.receive_event(3)) # Output: 4 print(lc.get_time()) # Output: 4 print(lc.send_event()) # Output: 5 print(lc.receive_event(2)) # Output: 6 print(lc.get_time()) # Output: 6 ``` # Notes - Ensure that the class handles the initialization and updating of the logical clock correctly. - Test the provided methods with different sequences of events to verify the logical clocks are synced correctly.","solution":"class LogicalClock: def __init__(self): self.time = 0 def send_event(self): self.time += 1 return self.time def receive_event(self, received_time): self.time = max(self.time, received_time) + 1 return self.time def get_time(self): return self.time"},{"question":"# Roman Numeral Conversion **Context**: Working with Roman numerals is a common task in various coding assessments. The basic Roman numeral symbols are I (1), V (5), X (10), L (50), C (100), D (500), and M (1000). Certain numerals are combined in a special way for creating other values, e.g., IV (4) instead of IIII, IX (9) instead of VIIII. # Task: Write two functions `roman_to_integer` and `integer_to_roman` that convert Roman numerals to integers and integers to Roman numerals respectively. # Requirements: 1. **Input for `roman_to_integer`**: A string representing a Roman numeral. (e.g., \\"MCMXCIV\\") 2. **Output for `roman_to_integer`**: An integer representing the numerical value of the Roman numeral. 3. **Input for `integer_to_roman`**: An integer ranging from 1 to 3999. (e.g., 1994) 4. **Output for `integer_to_roman`**: A string representing the equivalent Roman numeral of the input integer. 5. **Constraints**: - The Roman numeral input will be a valid Roman numeral between 1 and 3999. - For the conversion table, the subtractive notation should be handled properly (e.g., IV, IX, XC, etc.). ```python def roman_to_integer(roman: str) -> int: Converts Roman numeral to an integer. :param roman: A string representing a Roman numeral. :return: Integer value of the Roman numeral. Example: >>> roman_to_integer(\\"MCMXCIV\\") 1994 >>> roman_to_integer(\\"LVIII\\") 58 pass def integer_to_roman(num: int) -> str: Converts an integer to a Roman numeral. :param num: An integer between 1 and 3999. :return: Roman numeral as a string. Example: >>> integer_to_roman(1994) \'MCMXCIV\' >>> integer_to_roman(58) \'LVIII\' pass if __name__ == \\"__main__\\": from doctest import testmod testmod() ``` Test your functions with provided examples and add more edge cases to ensure robustness.","solution":"def roman_to_integer(roman: str) -> int: Converts Roman numeral to an integer. :param roman: A string representing a Roman numeral. :return: Integer value of the Roman numeral. Example: >>> roman_to_integer(\\"MCMXCIV\\") 1994 >>> roman_to_integer(\\"LVIII\\") 58 roman_values = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(roman): value = roman_values[char] if value < prev_value: total -= value else: total += value prev_value = value return total def integer_to_roman(num: int) -> str: Converts an integer to a Roman numeral. :param num: An integer between 1 and 3999. :return: Roman numeral as a string. Example: >>> integer_to_roman(1994) \'MCMXCIV\' >>> integer_to_roman(58) \'LVIII\' value_to_roman = [ (1000, \'M\'), (900, \'CM\'), (500, \'D\'), (400, \'CD\'), (100, \'C\'), (90, \'XC\'), (50, \'L\'), (40, \'XL\'), (10, \'X\'), (9, \'IX\'), (5, \'V\'), (4, \'IV\'), (1, \'I\') ] roman = \\"\\" for value, symbol in value_to_roman: while num >= value: roman += symbol num -= value return roman"},{"question":"**Problem Statement**: Write a function `xor_sum` that calculates the sum of the bitwise XOR of all pairs of elements in an array. The XOR operation for any given pair `(a, b)` is defined as their bitwise XOR. Your goal is to find the sum of the XOR for all unique pairs `(i, j)` where `i < j`. # Function Signature ```python def xor_sum(arr: List[int]) -> int: pass ``` # Input: * An array `arr` of integers where each integer is in the range `[0, 10^6]`. * The length of `arr` will be in the range `[2, 1000]`. # Output: * Return an integer which is the sum of the bitwise XOR of all unique pairs `(i, j)` where `i < j`. # Example ```python >>> xor_sum([1, 2, 3]) 6 >>> xor_sum([1, 1, 1]) 0 >>> xor_sum([4, 5, 7]) 14 ``` # Explanation: * For the first example: - Unique pairs are: `(1,2)`, `(1,3)`, and `(2,3)` - XORs: `1 ^ 2 = 3`, `1 ^ 3 = 2`, `2 ^ 3 = 1` - Sum: `3 + 2 + 1 = 6` * For the second example: - Unique pairs are: `(1,1)`, `(1,1)`, and `(1,1)` - XORs: `1 ^ 1 = 0`, `1 ^ 1 = 0`, `1 ^ 1 = 0` - Sum: `0 + 0 + 0 = 0` * For the third example: - Unique pairs are: `(4,5)`, `(4,7)`, and `(5,7)` - XORs: `4 ^ 5 = 1`, `4 ^ 7 = 3`, `5 ^ 7 = 2` - Sum: `1 + 3 + 2 = 6` # Constraints: * Each element in `arr` will be in the range `[0, 10^6]`. * There will be at least 2 elements in the array and no more than 1000 elements. # Instructions 1. Implement the `xor_sum` function. 2. Ensure your solution handles edge cases where the array contains duplicate numbers or particularly large numbers. 3. Optimize your function for both time and space efficiency within the constraints.","solution":"from typing import List def xor_sum(arr: List[int]) -> int: Returns the sum of the bitwise XOR of all pairs (i, j) where i < j in the array arr. total_sum = 0 n = len(arr) for i in range(n): for j in range(i + 1, n): total_sum += arr[i] ^ arr[j] return total_sum"},{"question":"# Question: Sliding Window Maximum Scenario You are working as a software engineer at a company that processes real-time streaming data. To efficiently compute metrics over time, you need to develop a function that computes the maximum value in a sliding window for a given array. The window slides from the left to the right by one position at a time. Task Write a function `max_sliding_window` that takes an array of integers and a window size and returns a list of integers representing the maximum values in each sliding window position. Function Signature ```python def max_sliding_window(nums: List[int], k: int) -> List[int]: pass ``` Input * `nums`: List of integers (1 leq |nums| leq 2 times 10^5). * `k`: An integer (1 leq k leq |nums|). Output * A list of integers representing the maximum values in each sliding window position. Example ```python assert max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3) == [3, 3, 5, 5, 6, 7] assert max_sliding_window([9, 11], 2) == [11] assert max_sliding_window([4, -2], 1) == [4, -2] ``` Constraints * The input array elements will be within the range of (-10^9) to (10^9). * Ensure the implementation has an efficient time complexity, ideally (O(n)). Implementation Details * Use a deque or other data structure to efficiently track the maximum values. * Handle edge cases such as an empty array or a window size of 1. * Avoid excessive memory usage by optimizing operations inside the sliding window.","solution":"from collections import deque from typing import List def max_sliding_window(nums: List[int], k: int) -> List[int]: if not nums or k == 0: return [] # Initialize a deque to store indices deq = deque() max_vals = [] for i in range(len(nums)): # Remove elements not within the sliding window if deq and deq[0] < i - k + 1: deq.popleft() # Remove all elements which are less than nums[i] from the deque while deq and nums[deq[-1]] < nums[i]: deq.pop() # Add the current element index to the deque deq.append(i) # Append the maximum for the current window to the results list if i >= k - 1: max_vals.append(nums[deq[0]]) return max_vals"},{"question":"# Implementing a Custom String Pattern Matcher You are working as a software engineer at a company that deals with large volumes of textual data. One of your tasks is to develop a custom string pattern matcher. The provided function `custom_string_match` should determine whether a given pattern matches a specific input string, following certain custom rules. In this problem, you will need to implement the `custom_string_match` function according to the specified matching rules. Custom Matching Rules: 1. `.` (dot) matches any single character. 2. `*` (asterisk) matches zero or more of the preceding character. 3. Exact character matches. Note: - The matching should cover the entire input string (not partial). - The patterns and strings only contain lowercase letters and the special characters `.` and `*`. # Function Signature ```python def custom_string_match(pattern: str, text: str) -> bool: pass ``` # Inputs and Outputs **Function**: `custom_string_match` - **Input**: - `pattern` (str): The pattern string containing lowercase letters, `.` and `*`. - `text` (str): The input text to match against the pattern. - **Output**: - A boolean value indicating whether the input text matches the given pattern. # Example ```python # Example 1 pattern = \\"a*\\" text = \\"aaaa\\" assert custom_string_match(pattern, text) == True # Example 2 pattern = \\".*\\" text = \\"abc\\" assert custom_string_match(pattern, text) == True # Example 3 pattern = \\"c*a*b\\" text = \\"aab\\" assert custom_string_match(pattern, text) == True # Example 4 pattern = \\"a.b\\" text = \\"acb\\" assert custom_string_match(pattern, text) == True # Example 5 pattern = \\"a*b\\" text = \\"aaab\\" assert custom_string_match(pattern, text) == True # Example 6 pattern = \\"mis*is*p*.\\" text = \\"mississippi\\" assert custom_string_match(pattern, text) == False ``` # Requirements: 1. **Pattern Matching**: - Implement the function `custom_string_match(pattern, text)` to return true or false based on the matching rules. # Performance Requirements: - The implementation should efficiently handle strings of typical length used in textual data processing. - Optimizations should be considered to reduce complexity where possible.","solution":"def custom_string_match(pattern: str, text: str) -> bool: This function checks if the given text matches the given pattern according to custom rules. # Dynamic programming table where dp[i][j] means text[:i] matches pattern[:j] dp = [[False] * (len(pattern) + 1) for _ in range(len(text) + 1)] dp[0][0] = True # Populate for patterns with * for j in range(1, len(pattern) + 1): if pattern[j - 1] == \'*\' and j > 1: dp[0][j] = dp[0][j - 2] # Populate the dp table for i in range(1, len(text) + 1): for j in range(1, len(pattern) + 1): if pattern[j - 1] == \'.\' or pattern[j - 1] == text[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif pattern[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] # 0 preceding element if pattern[j - 2] == \'.\' or pattern[j - 2] == text[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] return dp[len(text)][len(pattern)]"},{"question":"# Problem Statement You are tasked with developing an algorithm that finds the mode(s) of a given list of integers. The mode of a set of values is the value(s) that appears most frequently. This task assesses your understanding of collections, frequency counting, and handling multiple modes. Function Specification Implement a function `find_modes` with the following signature: ```python def find_modes(numbers: list) -> list: Finds the mode(s) of a given list of integers. Args: numbers: A list of integers. Returns: A list of the mode(s). ``` Parameters - **numbers**: A list of integers where `0 <= len(numbers) <= 10^6` and each integer can be in the range `-10^6` to `10^6`. Returns - A list of integers representing the mode(s) of the input list. If multiple integers have the same highest frequency, return all of them in ascending order. Constraints - Ensure the input list falls within the specified limits. - Handle edge cases where the list could be empty. # Example ```python result = find_modes([1, 2, 2, 3, 3, 4]) print(result) # Output: [2, 3] result = find_modes([4, 5, 6, 6, 5, 5]) print(result) # Output: [5] result = find_modes([10]) print(result) # Output: [10] result = find_modes([]) print(result) # Output: [] ``` Performance Requirements - The function must be efficient and capable of handling the largest input within a reasonable time frame. - Utilize data structures and algorithms that offer optimal performance for counting and comparison tasks.","solution":"from collections import Counter def find_modes(numbers: list) -> list: Finds the mode(s) of a given list of integers. Args: numbers: A list of integers. Returns: A list of the mode(s). if not numbers: return [] count = Counter(numbers) max_frequency = max(count.values()) modes = [number for number, frequency in count.items() if frequency == max_frequency] return sorted(modes)"},{"question":"# Objective Implement a simplified filesystem class that manages directories and files with basic operations including creation, deletion, and display of structure. # Scenario In this problem, you need to implement a class `SimpleFileSystem` that simulates basic filesystem operations like adding files, creating directories, deleting files and directories, and listing contents. # Task - Implement the `SimpleFileSystem` class with the following methods: 1. `__init__(self) -> None`: Initializes the root directory. 2. `create_file(self, path: str) -> None`: Creates a new file at the specified path. 3. `create_directory(self, path: str) -> None`: Creates a new directory at the specified path. 4. `delete(self, path: str) -> None`: Deletes a file or directory at the specified path. 5. `list_contents(self, path: str) -> list[str]`: Lists all files and directories at the specified path. # Implementation Details 1. **Characteristics**: - The root directory is initialized on object creation. - Paths follow UNIX-like structure, e.g., `/`, `/home`, `/home/user/file.txt`. - Directories can contain nested files and directories. 2. **Input/Output**: - `__init__`: Initializes the filesystem object with a root directory (\'/\'). - Input: None - Output: None - `create_file`: Creates a new file at the specified path. - Input: path: str (e.g., `/home/user/file.txt`) - Output: None - `create_directory`: Creates a new directory at the specified path. - Input: path: str (e.g., `/home/user/docs`) - Output: None - `delete`: Deletes a file or directory at the specified path. - Input: path: str (e.g., `/home/user/file.txt`) - Output: None - `list_contents`: Lists all files and directories at the specified path. - Input: path: str (e.g., `/home/user`) - Output: list of file and directory names: list[str] 3. **Constraints**: - All paths are absolute, starting from the root directory. - Deleting a directory should remove all its contents recursively. - Assume path inputs are valid and parent directories exist when creating files and directories. # Example ```python fs = SimpleFileSystem() fs.create_directory(\'/home\') fs.create_directory(\'/home/user\') fs.create_file(\'/home/user/file.txt\') print(fs.list_contents(\'/\')) # [\'home\'] print(fs.list_contents(\'/home\')) # [\'user\'] print(fs.list_contents(\'/home/user\')) # [\'file.txt\'] fs.delete(\'/home/user/file.txt\') print(fs.list_contents(\'/home/user\')) # [] fs.delete(\'/home/user\') print(fs.list_contents(\'/home\')) # [] ``` 4. **Performance Requirements**: - The solution should efficiently handle operations on nested directories and numerous files without significant performance degradation. Creating such a filesystem class will test the candidate\'s ability to manage data structure operations and recursive functions, ensuring they can handle nested structures efficiently.","solution":"class SimpleFileSystem: def __init__(self): self.fs = {\'/\': {}} def _navigate_to(self, path: str): Helper method to navigate the given path and return the directory (or file) referenced by the path. current = self.fs[\'/\'] parts = path.strip(\'/\').split(\'/\') for part in parts: if part: if part in current: current = current[part] else: raise FileNotFoundError(f\\"Path not found: {path}\\") return current def create_file(self, path: str) -> None: parts = path.strip(\'/\').split(\'/\') file_name = parts.pop() current = self._navigate_to(\'/\' + \'/\'.join(parts)) if file_name in current: raise FileExistsError(f\\"File already exists: {path}\\") current[file_name] = None def create_directory(self, path: str) -> None: parts = path.strip(\'/\').split(\'/\') current = self.fs[\'/\'] for part in parts: if part not in current: current[part] = {} current = current[part] def delete(self, path: str) -> None: parts = path.strip(\'/\').split(\'/\') item_to_delete = parts.pop() parent = self._navigate_to(\'/\' + \'/\'.join(parts)) if item_to_delete in parent: del parent[item_to_delete] else: raise FileNotFoundError(f\\"Item to delete not found: {path}\\") def list_contents(self, path: str) -> list: directory = self._navigate_to(path) if isinstance(directory, dict): return sorted(directory.keys()) else: raise NotADirectoryError(f\\"Not a directory: {path}\\")"},{"question":"# Scenario You are developing a data processing module that analyzes time-series data. One critical function needed is to determine the longest contiguous subarray of the data where the differences between consecutive elements are the same. # Problem Statement Implement a Python function called `longest_uniform_subarray` that accepts a list of integers representing a time-series dataset and returns the length of the longest contiguous subarray where the differences between consecutive elements are equal. # Function Signature ```python def longest_uniform_subarray(nums: list[int]) -> int: ``` # Inputs * `nums`: A list of integers representing the time-series data. The list can be empty or contain any integer values. # Outputs * An integer representing the length of the longest contiguous subarray with uniform differences between consecutive elements. # Constraints * If the input list is empty, return 0. * The list can contain negative and positive integers. * The function should handle edge cases where the list contains less than two elements. * Aim to achieve a time complexity of O(n). # Example ```python assert longest_uniform_subarray([1, 2, 3, 4, 5, 7, 9]) == 5 # Subarray [1, 2, 3, 4, 5] assert longest_uniform_subarray([5, 5, 5, 5]) == 4 # Subarray [5, 5, 5, 5] assert longest_uniform_subarray([3, 6, 9, 12, 15, 20, 25]) == 5 # Subarray [3, 6, 9, 12, 15] assert longest_uniform_subarray([10, 6, 2, -2, -6]) == 5 # Subarray [10, 6, 2, -2, -6] assert longest_uniform_subarray([]) == 0 # Empty list # Lists with less than two elements assert longest_uniform_subarray([42]) == 1 # Single element list assert longest_uniform_subarray([-5]) == 1 # Single element list ``` Implement the `longest_uniform_subarray` function to meet the given requirements and optimize for performance. Write code that is efficient, clear, and handles edge cases appropriately.","solution":"def longest_uniform_subarray(nums: list[int]) -> int: if not nums: return 0 if len(nums) < 2: return len(nums) max_len = 1 current_len = 1 current_diff = None for i in range(1, len(nums)): diff = nums[i] - nums[i - 1] if diff == current_diff: current_len += 1 else: max_len = max(max_len, current_len) current_len = 2 # Reset with the current pair current_diff = diff max_len = max(max_len, current_len) return max_len"},{"question":"# Coding Challenge Question: Anagram Checker with Case and Whitespace Handling **Context**: In text analysis, an anagram is a rearrangement of the letters of one word or phrase to form another word or phrase, ignoring spaces and case differences. This assignment involves creating a function to determine if two given strings are anagrams of each other while accounting for case-insensitivity and ignoring whitespace. Problem Statement Implement a function `is_anagram(s1: str, s2: str) -> bool` that takes two strings and returns True if they are anagrams of each other. The function should: 1. Ignore spaces and be case-insensitive. 2. Validate that inputs are strings. 3. Return False if either input is not a string. Input * Two strings `s1` and `s2` representing the words or phrases to be compared. Output * A boolean value: `True` if the given strings are anagrams of each other, otherwise `False`. Constraints * The length of each string (`m` and `n`) can be 0 <= m, n <= 10^5. Expectations 1. Efficient handling of input validation and pre-processing. 2. Correct anagram detection considering case and whitespace. 3. Robust handling of invalid inputs and edge cases. Example ```python >>> is_anagram(\\"Listen\\", \\"Silent\\") True >>> is_anagram(\\"The eyes\\", \\"They see\\") True >>> is_anagram(\\"Hello\\", \\"Ole Hol\\") False >>> is_anagram(\\"Astronomer\\", 12345) False >>> is_anagram(\\"Dormitory\\", \\"Dirty room\\") True ``` Implementation Challenge * Optimize for performance given potentially large string lengths. * Appropriately handle case differences and ignore spaces during comparison. * Ensure the function robustly handles non-string inputs and edge cases. Feel free to define helper functions if needed.","solution":"def is_anagram(s1, s2): Returns True if s1 and s2 are anagrams, ignoring case and whitespace. Otherwise, returns False. # Validate input if not isinstance(s1, str) or not isinstance(s2, str): return False # Preprocess the strings: remove spaces and convert to lowercase s1_processed = \'\'.join(s1.split()).lower() s2_processed = \'\'.join(s2.split()).lower() # Compare sorted characters of both strings return sorted(s1_processed) == sorted(s2_processed)"},{"question":"# Question: Room Temperature Conversion Utility You are tasked with implementing a utility to convert room temperature between Celsius, Fahrenheit, and Kelvin. Create a `RoomTemperature` class with methods for setting the temperature in one scale and converting it to the other scales. Class: `RoomTemperature` ```python class RoomTemperature: def __init__(self, celsius: float): Initialize RoomTemperature with temperature in Celsius. Parameters: celsius (float): Room temperature in degrees Celsius. def to_fahrenheit(self) -> float: Convert the room temperature from Celsius to Fahrenheit. Returns: float: Temperature in degrees Fahrenheit. def to_kelvin(self) -> float: Convert the room temperature from Celsius to Kelvin. Returns: float: Temperature in Kelvin. def set_temperature(self, temperature: float, scale: str): Set room temperature based on specified scale. Parameters: temperature (float): Temperature to set. scale (str): The scale of the temperature (\'C\', \'F\', or \'K\'). - \'C\' for Celsius - \'F\' for Fahrenheit - \'K\' for Kelvin Raises: ValueError: If the scale is not one of \'C\', \'F\', or \'K\'. ``` # Constraints: 1. Temperature in Celsius will be a float. 2. Scale will be one of \'C\', \'F\', or \'K\'. If the scale is invalid, raise a `ValueError` with the message: \\"scale must be \'C\', \'F\', or \'K\'.\\" 3. The class should handle temperature conversions correctly, even at extreme values. # Temperature Conversions: 1. ( F = C times frac{9}{5} + 32 ) 2. ( K = C + 273.15 ) 3. ( C = (F - 32) times frac{5}{9} ) 4. ( C = K - 273.15 ) # Example: ```python room_temp = RoomTemperature(25) print(room_temp.to_fahrenheit()) # Expected output: 77.0 print(room_temp.to_kelvin()) # Expected output: 298.15 room_temp.set_temperature(77, \'F\') print(room_temp.to_celsius()) # Expected output: 25.0 print(room_temp.to_kelvin()) # Expected output: 298.15 room_temp.set_temperature(298.15, \'K\') print(room_temp.to_celsius()) # Expected output: 25.0 print(room_temp.to_fahrenheit()) # Expected output: 77.0 ``` # Additional Requirements: 1. The method names and class structure must adhere to standard class conventions in Python. 2. The `to_fahrenheit` and `to_kelvin` methods must return results rounded to two decimal places. This question ensures the candidate demonstrates the ability to handle class structures, method implementations, and mathematical conversions while adhering to Pythonic conventions, similar to the complexity and style of the provided example.","solution":"class RoomTemperature: def __init__(self, celsius: float): Initialize RoomTemperature with temperature in Celsius. Parameters: celsius (float): Room temperature in degrees Celsius. self.celsius = celsius def to_fahrenheit(self) -> float: Convert the room temperature from Celsius to Fahrenheit. Returns: float: Temperature in degrees Fahrenheit. return round(self.celsius * (9 / 5) + 32, 2) def to_kelvin(self) -> float: Convert the room temperature from Celsius to Kelvin. Returns: float: Temperature in Kelvin. return round(self.celsius + 273.15, 2) def set_temperature(self, temperature: float, scale: str): Set room temperature based on specified scale. Parameters: temperature (float): Temperature to set. scale (str): The scale of the temperature (\'C\', \'F\', or \'K\'). - \'C\' for Celsius - \'F\' for Fahrenheit - \'K\' for Kelvin Raises: ValueError: If the scale is not one of \'C\', \'F\', or \'K\'. if scale == \'C\': self.celsius = temperature elif scale == \'F\': self.celsius = (temperature - 32) * (5 / 9) elif scale == \'K\': self.celsius = temperature - 273.15 else: raise ValueError(\\"scale must be \'C\', \'F\', or \'K\'.\\") def to_celsius(self) -> float: Return the room temperature in Celsius. Returns: float: Temperature in Celsius. return round(self.celsius, 2)"},{"question":"# Scenario Consider a museum security system that monitors a series of rooms connected by corridors. The goal is to find the shortest path for a security employee to check all rooms starting from a designated room. Each corridor has an associated time required to move between the connected rooms. # Task Write a function `shortest_path_to_check_all_rooms(n: int, corridors: List[Tuple[int, int, int]], start: int) -> int` that takes: - `n`: an integer representing the number of rooms labeled from 0 to n-1, - `corridors`: a list of tuples where each tuple contains three integers `(u, v, w)` indicating a corridor between room `u` and room `v` with a travel time of `w`, and - `start`: an integer representing the starting room. The function should return the minimum time required for the security employee to visit every room at least once and return to the starting room using the shortest possible path. # Function Signature ```python def shortest_path_to_check_all_rooms(n: int, corridors: List[Tuple[int, int, int]], start: int) -> int: ``` # Input - `n`: An integer `1 <= n <= 12` representing the number of rooms. - `corridors`: A list of tuples where each tuple contains three integers `(u, v, w)` indicating a corridor between room `u` and room `v` with a travel time of `w`. The number of corridors is at least `n-1` and at most `(n*(n-1))/2`. The value of `w` is an integer between `1` and `100`. - `start`: An integer `0 <= start < n` representing the starting room. # Output - An integer representing the minimum time required to visit all rooms at least once and return to the starting room. # Constraints - There is guaranteed to be at least one path connecting all rooms. - All rooms are connected, meaning you can always reach any room from any other room. # Example ```python n = 4 corridors = [ (0, 1, 10), (0, 2, 15), (0, 3, 20), (1, 2, 35), (1, 3, 25), (2, 3, 30) ] start = 0 assert shortest_path_to_check_all_rooms(n, corridors, start) == 80 ``` In this example, one possible optimal route with minimal total travel time is: 0 -> 1 -> 3 -> 2 -> 0 with a total travel time of 10 + 25 + 30 + 15 = 80. # Implementation Details - Implement the function using a suitable algorithm (e.g., dynamic programming with bitmasking or a modified version of the Traveling Salesman Problem). - Ensure efficient handling of the constraints. - Consider typical edge cases, such as the smallest possible number of rooms and varying corridor lengths.","solution":"from typing import List, Tuple import itertools def shortest_path_to_check_all_rooms(n: int, corridors: List[Tuple[int, int, int]], start: int) -> int: # Create the adjacency matrix representing the graph INF = float(\'inf\') graph = [[INF]*n for _ in range(n)] for u, v, w in corridors: graph[u][v] = w graph[v][u] = w # We need to solve the Traveling Salesman Problem (TSP) where the salesman must visit # every node and return to the starting node with minimum cost. dp = [[INF]*n for _ in range(1<<n)] dp[1<<start][start] = 0 for mask in range(1<<n): for u in range(n): if mask & (1<<u): for v in range(n): if mask & (1<<v) == 0: dp[mask | (1<<v)][v] = min(dp[mask | (1<<v)][v], dp[mask][u] + graph[u][v]) ans = INF for u in range(n): ans = min(ans, dp[(1<<n) - 1][u] + graph[u][start]) return ans"},{"question":"# Coding Assessment Question: Implementing Memory Management for a Paging System **Scenario**: You are tasked with developing the memory management module for an operating system. The system uses paging for memory management, where processes are divided into fixed-size pages and loaded into memory frames. Your objective is to implement a function `page_fault_handler` that simulates the process of handling page faults and managing memory frames using the Least Recently Used (LRU) page replacement algorithm. **Objective**: You need to implement a function `page_fault_handler` which will take a list of page requests and handle them using the LRU algorithm. Additionally, you need to write helper functions for finding the least recently used page and updating the memory frames. Input: - `page_requests`: A list of integers representing the sequence of page requests made by the processes. - `number_of_frames`: An integer representing the number of available memory frames. Output: - An integer representing the total number of page faults that occurred during the page request sequence. - A list of integers representing the state of memory frames after handling all page requests. ```python from collections import deque class PagingSystem: def __init__(self, number_of_frames: int) -> None: self.number_of_frames = number_of_frames self.frames = [-1] * number_of_frames # Initialize memory frames self.page_faults = 0 self.lru_queue = deque() # Queue to keep track of LRU order self.frame_map = {} # Dictionary to keep track of pages in frames def page_fault_handler(self, page_requests: list[int]) -> tuple[int, list[int]]: Function to handle page faults using the LRU page replacement algorithm. for page in page_requests: if page not in self.frame_map: # Page fault occurs self.page_faults += 1 if len(self.lru_queue) < self.number_of_frames: # There is still space in frames for i in range(self.number_of_frames): if self.frames[i] == -1: self.frames[i] = page self.frame_map[page] = i break else: # Need to replace LRU page lru_page = self.lru_queue.popleft() lru_index = self.frame_map.pop(lru_page) self.frames[lru_index] = page self.frame_map[page] = lru_index else: # Page is already in memory, update LRU queue self.lru_queue.remove(page) self.lru_queue.append(page) return self.page_faults, self.frames if __name__ == \\"__main__\\": number_of_frames = 4 page_requests = [1, 3, 0, 3, 5, 6, 3] system = PagingSystem(number_of_frames) page_faults, final_frames = system.page_fault_handler(page_requests) print(f\\"Page Faults: {page_faults}\\") print(f\\"Final Memory Frames: {final_frames}\\") ``` Constraints: 1. The `number_of_frames` should be a positive integer. 2. The `page_requests` list can contain any integer values. 3. The given `page_requests` list will not be empty. Requirements: - Correctly implement `page_fault_handler` using the LRU page replacement algorithm. - Ensure your solution handles edge cases such as empty frames efficiently. - The solution should minimize the total number of page faults. **Note**: This question assesses your knowledge of memory management and your ability to implement and handle paging algorithms in an operating system context.","solution":"from collections import deque class PagingSystem: def __init__(self, number_of_frames: int) -> None: self.number_of_frames = number_of_frames self.frames = [-1] * number_of_frames # Initialize memory frames self.page_faults = 0 self.lru_queue = deque() # Queue to keep track of LRU order self.frame_map = {} # Dictionary to keep track of pages in frames def page_fault_handler(self, page_requests: list[int]) -> tuple[int, list[int]]: Function to handle page faults using the LRU page replacement algorithm. for page in page_requests: if page not in self.frame_map: # Page fault occurs self.page_faults += 1 if len(self.lru_queue) < self.number_of_frames: # There is still space in frames for i in range(self.number_of_frames): if self.frames[i] == -1: self.frames[i] = page self.frame_map[page] = i break else: # Need to replace LRU page lru_page = self.lru_queue.popleft() lru_index = self.frame_map.pop(lru_page) self.frames[lru_index] = page self.frame_map[page] = lru_index else: # Page is already in memory, update LRU queue self.lru_queue.remove(page) self.lru_queue.append(page) return self.page_faults, self.frames if __name__ == \\"__main__\\": number_of_frames = 4 page_requests = [1, 3, 0, 3, 5, 6, 3] system = PagingSystem(number_of_frames) page_faults, final_frames = system.page_fault_handler(page_requests) print(f\\"Page Faults: {page_faults}\\") print(f\\"Final Memory Frames: {final_frames}\\")"},{"question":"# Question: Find Missing Elements in Range You have recently joined a tech company as a software developer. One of your projects involves working with a range of integers for data processing. Your task is to identify any missing integers within a specific range that are not present in the given list. Implement a function `find_missing_elements(arr: list[int], range_start: int, range_end: int) -> list[int]` that finds all the integers within the inclusive range `[range_start, range_end]` that do not appear in the given list `arr`. # Input - A list of integers `arr`. - Two integers `range_start` and `range_end` defining the inclusive range `[range_start, range_end]`. # Output - A sorted list of integers representing the missing elements in the specified range. # Constraints - The input list can contain negative, positive, and zero values. - The range specified by `range_start` and `range_end` will have valid values such that `range_start <= range_end`. - The length of the list, `len(arr)`, can be at most 10^4. - The range defined by `range_start` and `range_end` will not exceed 2 * 10^4 in size. # Example ```python # Example 1 arr = [1, 3, 5, 7, 9] range_start = 1 range_end = 10 find_missing_elements(arr, range_start, range_end) # Expected Output: [2, 4, 6, 8, 10] # Example 2 arr = [-2, -1, 0, 1, 2] range_start = -3 range_end = 3 find_missing_elements(arr, range_start, range_end) # Expected Output: [-3, 3] # Example 3 arr = [10, 12, 15, 18] range_start = 10 range_end = 20 find_missing_elements(arr, range_start, range_end) # Expected Output: [11, 13, 14, 16, 17, 19, 20] # Example 4 arr = [] range_start = 5 range_end = 10 find_missing_elements(arr, range_start, range_end) # Expected Output: [5, 6, 7, 8, 9, 10] # Example 5 arr = [3, 5, 7] range_start = 3 range_end = 7 find_missing_elements(arr, range_start, range_end) # Expected Output: [4, 6] ``` # Notes - Ensure the implementation efficiently handles the input size and range size. - Consider edge cases such as an empty input list, full-range coverage, or no missing elements.","solution":"def find_missing_elements(arr, range_start, range_end): Finds missing elements in the given range that are not present in the array. Parameters: arr (list of int): List of integers range_start (int): Start of the range (inclusive) range_end (int): End of the range (inclusive) Returns: list of int: Sorted list of missing integers # Create a set of all numbers in the range full_range_set = set(range(range_start, range_end+1)) # Create a set from the input list arr_set = set(arr) # Find the difference between the full range and the input list set missing_elements = sorted(full_range_set - arr_set) return missing_elements"},{"question":"# Deep Copy for Complex Data Structures Implement a function to perform a deep copy of a nested dictionary structure that can contain integer values, lists, and other dictionaries. The purpose of this function is to create an exact replica of the given data structure but ensure that modifying the replica does not alter the original and vice versa. # Input * The function `deep_copy` will take a single argument `original_dict`, which is a dictionary. The dictionary can contain: * Integer values * Lists of integers or other dictionaries * Nested dictionaries # Output * The function should return a new dictionary that is a deep copy of `original_dict`. # Constraints * The dictionary will contain at most 10^3 keys. * The depth of nesting will not exceed 10. * Lists will contain at most 10^2 elements. * Integer values will be in the range -10^6 to 10^6. # Example ```python def deep_copy(original_dict): # Implement this function pass # Test cases input_dict1 = { \'a\': 1, \'b\': [1, 2, { \'c\': 3 }], \'d\': { \'e\': 4, \'f\': [5, 6] } } print(deep_copy(input_dict1)) # Expected output: {\'a\': 1, \'b\': [1, 2, {\'c\': 3}], \'d\': {\'e\': 4, \'f\': [5, 6]}} input_dict2 = {} print(deep_copy(input_dict2)) # Expected output: {} input_dict3 = { \'nested\': { \'list\': [1, 2, 3], \'empty_dict\': {} } } print(deep_copy(input_dict3)) # Expected output: {\'nested\': {\'list\': [1, 2, 3], \'empty_dict\': {}}} input_dict4 = { \'simple_key\': 1, \'nested_dict1\': { \'nested_dict2\': { \'nested_dict3\': { \'key\': 1234 } } } } print(deep_copy(input_dict4)) # Expected output: {\'simple_key\': 1, \'nested_dict1\': {\'nested_dict2\': {\'nested_dict3\': {\'key\': 1234}}}} ``` **Explanation**: 1. In the case of input_dict1: * The structure includes integers, lists, and another dictionary within a list. * The output should be an exact copy with no shared references. 2. In the case of input_dict2: * An empty dictionary should simply return an empty dictionary. 3. In the case of input_dict3: * The dictionary has nested structures and lists, which should be deep copied correctly. 4. In the case of input_dict4: * There are multiple layers of nested dictionaries, ensuring the function properly copies deep structures.","solution":"def deep_copy(original_dict): Returns a deep copy of the given dictionary. if isinstance(original_dict, dict): return {key: deep_copy(value) for key, value in original_dict.items()} elif isinstance(original_dict, list): return [deep_copy(element) for element in original_dict] else: return original_dict"},{"question":"# Question: Implementing a Simple Data Processing Pipeline Objective: To improve data analysis processes for a data science project, you are asked to develop a simple data processing pipeline. The pipeline will handle data loading, data cleaning, and basic analysis. Part 1: Implementing Data Loading 1. **Function: `load_data`** * Load data from a CSV file into a pandas DataFrame. * Ensure the function can handle files that may include missing values. ```python import pandas as pd def load_data(file_path: str) -> pd.DataFrame: Load data from a CSV file into a pandas DataFrame. Parameters: file_path (str): Path to the CSV file. Returns: pd.DataFrame: DataFrame containing the loaded data. pass # Your implementation ``` Part 2: Implementing Data Cleaning 2. **Function: `clean_data`** * Clean the data by filling missing values. * Use specified techniques to handle missing values: fill numerical columns with the mean and categorical columns with the mode. ```python def clean_data(df: pd.DataFrame) -> pd.DataFrame: Clean data by filling missing values. Parameters: df (pd.DataFrame): DataFrame containing the data to be cleaned. Returns: pd.DataFrame: DataFrame with missing values handled. pass # Your implementation ``` Part 3: Implementing Basic Analysis 3. **Function: `basic_analysis`** * Perform basic analysis by calculating summary statistics for numerical columns. * Calculate count, mean, standard deviation, min, 25th percentile, median, 75th percentile, and max for each numerical column. ```python def basic_analysis(df: pd.DataFrame) -> pd.DataFrame: Perform basic analysis by calculating summary statistics for numerical columns. Parameters: df (pd.DataFrame): DataFrame containing the data to be analyzed. Returns: pd.DataFrame: DataFrame with summary statistics for each numerical column. pass # Your implementation ``` Constraints & Requirements: * Ensure your implementation can handle large datasets efficiently. * Assume the dataset is not excessively large to fit into memory but optimize performance where possible. * Handle edge cases such as empty DataFrame or files with no numerical data gracefully. * Ensure the solution can be easily extended for more complex data processing tasks in the future. Example: ```python # Assume \'data.csv\' is a CSV file with appropriate data. df = load_data(\'data.csv\') clean_df = clean_data(df) analysis_result = basic_analysis(clean_df) print(clean_df) # Print cleaned data print(analysis_result) # Print summary statistics ``` Ensure your implementations cover edge cases, perform efficiently, and meet all specified criteria for robust data loading, cleaning, and analysis.","solution":"import pandas as pd def load_data(file_path: str) -> pd.DataFrame: Load data from a CSV file into a pandas DataFrame. Parameters: file_path (str): Path to the CSV file. Returns: pd.DataFrame: DataFrame containing the loaded data. try: df = pd.read_csv(file_path) except Exception as e: raise FileNotFoundError(f\\"Error loading data from {file_path}: {e}\\") return df def clean_data(df: pd.DataFrame) -> pd.DataFrame: Clean data by filling missing values. Parameters: df (pd.DataFrame): DataFrame containing the data to be cleaned. Returns: pd.DataFrame: DataFrame with missing values handled. for column in df.columns: if df[column].dtype in [\'float64\', \'int64\']: df[column].fillna(df[column].mean(), inplace=True) else: df[column].fillna(df[column].mode()[0], inplace=True) return df def basic_analysis(df: pd.DataFrame) -> pd.DataFrame: Perform basic analysis by calculating summary statistics for numerical columns. Parameters: df (pd.DataFrame): DataFrame containing the data to be analyzed. Returns: pd.DataFrame: DataFrame with summary statistics for each numerical column. summary = df.describe() return summary"},{"question":"# Problem Statement You are given a list of positive integers representing the heights of buildings in a skyline. Your task is to determine the maximum area of a rectangle that can be formed by any consecutive buildings. Each building has a width of 1 unit. Write a function `max_rectangle_area(heights: List[int]) -> int` which takes in a list of building heights and returns the maximum rectangular area that can be formed. # Function Signature ```python def max_rectangle_area(heights: List[int]) -> int: pass ``` # Input: - `heights` (List[int]): A list of positive integers where each integer represents the height of a building. # Output: - An integer representing the maximum rectangular area. # Constraints: - 1 ≤ len(heights) ≤ 10,000 - 1 ≤ heights[i] ≤ 10,000 for each i # Example ```python max_rectangle_area([2, 1, 5, 6, 2, 3]) -> 10 max_rectangle_area([2, 4]) -> 4 ``` # Notes: - The rectangle must be formed by consecutive buildings. - The function should handle edge cases, such as when the list contains only one building. - Optimal efficiency is expected, ideally with a O(n) solution. - The problem can be approached using a stack-based technique to manage the heights and compute the maximal rectangle efficiently. This question tests the ability to implement a stack-based solution and applies the concept of sliding window to discover the largest possible rectangle in a histogram, a common algorithmic problem.","solution":"from typing import List def max_rectangle_area(heights: List[int]) -> int: Returns the maximum rectangular area in a histogram given by heights. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"# Scenario You are developing a software module for a warehouse automation system. The system needs to keep track of inventory levels and check if reorders are necessary. # Objective Implement the function `should_reorder` that decides if a particular item in the warehouse needs to be reordered based on the current inventory level and the reorder threshold. # Function Signature ```python def should_reorder(inventory_level: int, reorder_threshold: int) -> bool: Determine if an item needs to be reordered. :param inventory_level: The current inventory level of the item. :param reorder_threshold: The inventory level threshold below which a reorder should be triggered. :return: True if the inventory level is less than or equal to the reorder threshold, False otherwise. ``` # Input 1. `inventory_level`: An integer representing the current inventory level of an item. 2. `reorder_threshold`: An integer representing the threshold level for reordering. # Output - A boolean value: True if the inventory level is less than or equal to the reorder threshold, False otherwise. # Constraints - Both `inventory_level` and `reorder_threshold` must be non-negative integers. - If either value is negative, the function should raise a `ValueError` with the message \\"Inventory level and reorder threshold must be non-negative integers\\". # Examples ```python assert should_reorder(5, 10) == True assert should_reorder(10, 5) == False assert should_reorder(7, 7) == True assert should_reorder(0, 1) == True try: should_reorder(-1, 10) except ValueError as e: assert str(e) == \\"Inventory level and reorder threshold must be non-negative integers\\" try: should_reorder(10, -5) except ValueError as e: assert str(e) == \\"Inventory level and reorder threshold must be non-negative integers\\" try: should_reorder(-1, -5) except ValueError as e: assert str(e) == \\"Inventory level and reorder threshold must be non-negative integers\\" ``` # Additional Notes - Ensure that the function correctly interprets the comparison between the current inventory level and the reorder threshold. - The function should handle edge cases such as having an inventory level of zero or a reorder threshold of zero.","solution":"def should_reorder(inventory_level: int, reorder_threshold: int) -> bool: Determine if an item needs to be reordered. :param inventory_level: The current inventory level of the item. :param reorder_threshold: The inventory level threshold below which a reorder should be triggered. :return: True if the inventory level is less than or equal to the reorder threshold, False otherwise. if inventory_level < 0 or reorder_threshold < 0: raise ValueError(\\"Inventory level and reorder threshold must be non-negative integers\\") return inventory_level <= reorder_threshold"},{"question":"# Question: Graph Coloring Problem Implementation You are tasked to implement a class, `Graph`, that represents an undirected graph and to provide a method to determine its minimum coloring using backtracking. Additionally, you need to implement methods to add edges, check for coloring validity, and visualize the graph with colors. Your task: Implement the `Graph` class with the following functionalities: 1. **Initialization**: - Initialize a graph with a given number of vertices. 2. **Add Edge**: - `add_edge(self, u: int, v: int) -> None`: Add an undirected edge between vertices `u` and `v`. 3. **Coloring**: - `is_safe(self, v: int, color: list, c: int) -> bool`: Check if assigning color `c` to vertex `v` is safe. - `graph_coloring_util(self, m: int, color: list, v: int) -> bool`: Utility function to solve the m-coloring problem using backtracking. - `graph_coloring(self, m: int) -> bool`: Determine if the graph can be colored with `m` colors. 4. **Visualizer**: - `show_coloring(self, color: list) -> None`: Print the vertices and their assigned colors. Requirements: * Name of the class: `Graph` * Each method should handle invalid input or operations gracefully. * The backtracking method should efficiently explore possible solutions to ensure the graph is properly colored. Example Scenarios & Edge Cases: 1. **Edge Cases**: * Adding an edge that includes a vertex out of range. * Attempting to color a graph with fewer colors than its chromatic number. 2. **Example Usage**: ```python g = Graph(4) g.add_edge(0, 1) g.add_edge(0, 2) g.add_edge(1, 2) g.add_edge(1, 3) m = 3 # Number of colors result = g.graph_coloring(m) if result: print(\\"Coloring possible with {} colors.\\".format(m)) g.show_coloring(result) else: print(\\"Coloring not possible with {} colors.\\".format(m)) # Expected Output: # Coloring possible with 3 colors. # Vertex 0 ---> Color 0 # Vertex 1 ---> Color 1 # Vertex 2 ---> Color 2 # Vertex 3 ---> Color 0 ``` Implement the class with all necessary methods and ensure that it passes testing for the examples provided and handles edge cases appropriately.","solution":"class Graph: def __init__(self, vertices): self.V = vertices self.graph = [[] for _ in range(vertices)] def add_edge(self, u, v): if u >= self.V or v >= self.V or u < 0 or v < 0: raise ValueError(\\"Vertex number out of range\\") self.graph[u].append(v) self.graph[v].append(u) def is_safe(self, v, color, c): for i in self.graph[v]: if color[i] == c: return False return True def graph_coloring_util(self, m, color, v): if v == self.V: # If all vertices are assigned a color then return true return True for c in range(1, m + 1): if self.is_safe(v, color, c): color[v] = c if self.graph_coloring_util(m, color, v + 1): return True color[v] = 0 # Backtrack return False def graph_coloring(self, m): color = [0] * self.V if not self.graph_coloring_util(m, color, 0): return False return color def show_coloring(self, color): for v in range(self.V): print(f\\"Vertex {v} ---> Color {color[v]}\\")"},{"question":"# Circular Queue Implementation A Circular Queue is a linear data structure that follows the First-In-First-Out (FIFO) principle, but unlike a standard queue, it wraps around upon reaching the end, allowing for efficient use of memory. You are required to implement a circular queue with the following functionalities: # Function Specifications **Method 1: `enqueue`** ```python def enqueue(self, value: int) -> bool: pass ``` * **Description**: Adds an element to the back of the queue. * **Input**: An integer `value` representing the element to be added. * **Output**: Returns `True` if the operation is successful, and `False` if the queue is full. **Method 2: `dequeue`** ```python def dequeue(self) -> bool: pass ``` * **Description**: Removes an element from the front of the queue. * **Input**: None. * **Output**: Returns `True` if the operation is successful, and `False` if the queue is empty. **Method 3: `isFull`** ```python def isFull(self) -> bool: pass ``` * **Description**: Checks whether the queue is full. * **Input**: None. * **Output**: Returns `True` if the queue is full, otherwise `False`. **Method 4: `isEmpty`** ```python def isEmpty(self) -> bool: pass ``` * **Description**: Checks whether the queue is empty. * **Input**: None. * **Output**: Returns `True` if the queue is empty, otherwise `False`. **Method 5: `Front`** ```python def Front(self) -> int: pass ``` * **Description**: Retrieves the front element of the queue. * **Input**: None. * **Output**: Returns the front element if the queue is not empty, otherwise returns `-1`. **Method 6: `Rear`** ```python def Rear(self) -> int: pass ``` * **Description**: Retrieves the last element of the queue. * **Input**: None. * **Output**: Returns the last element if the queue is not empty, otherwise returns `-1`. # Example Usage ```python cq = CircularQueue(3) print(cq.enqueue(1)) # Expected: True print(cq.enqueue(2)) # Expected: True print(cq.enqueue(3)) # Expected: True print(cq.enqueue(4)) # Expected: False print(cq.Rear()) # Expected: 3 print(cq.isFull()) # Expected: True print(cq.dequeue()) # Expected: True print(cq.enqueue(4)) # Expected: True print(cq.Rear()) # Expected: 4 ``` # Additional Constraints 1. You must implement the Circular Queue using an array (list in Python). 2. The maximum number of elements that can be held in the queue will be defined at the time of initialization. Implement the methods according to the specifications and ensure the efficiency and correctness of the Circular Queue operations.","solution":"class CircularQueue: def __init__(self, k: int): Initialize the queue with a fixed size k. self.queue = [None] * k self.head = 0 self.tail = 0 self.max_size = k self.count = 0 def enqueue(self, value: int) -> bool: Adds an element to the back of the queue. if self.isFull(): return False self.queue[self.tail] = value self.tail = (self.tail + 1) % self.max_size self.count += 1 return True def dequeue(self) -> bool: Removes an element from the front of the queue. if self.isEmpty(): return False self.queue[self.head] = None self.head = (self.head + 1) % self.max_size self.count -= 1 return True def isFull(self) -> bool: Checks whether the queue is full. return self.count == self.max_size def isEmpty(self) -> bool: Checks whether the queue is empty. return self.count == 0 def Front(self) -> int: Retrieves the front element of the queue. if self.isEmpty(): return -1 return self.queue[self.head] def Rear(self) -> int: Retrieves the last element of the queue. if self.isEmpty(): return -1 return self.queue[(self.tail - 1 + self.max_size) % self.max_size]"},{"question":"# Task: Design and Implement a Reinforcement Learning Agent for a Grid World Environment **Objective**: Create a reinforcement learning agent utilizing Q-learning to navigate a 10x10 grid world environment and reach a goal position. The agent should learn the optimal policy to reach the goal while avoiding obstables. **Environment Setup**: - The grid world is a 10x10 matrix where each cell can be empty, an obstacle, or the goal. - Start at position (0, 0) and the goal is at position (9, 9). - Define several obstacle positions (e.g., (2, 2), (3, 3), (5, 6), (7, 8)) that the agent must avoid. - The agent can move up, down, left, or right. Actions that would move the agent out of bounds or into an obstacle result in no movement. - Rewards: +10 for reaching the goal, -1 for each step taken, and -10 for hitting an obstacle. **Steps**: 1. Implement the grid world environment in Python. 2. Initialize the Q-table with zeros. 3. Define the ε-greedy policy for exploration and exploitation. 4. Implement the Q-learning algorithm to update the Q-values based on the agent\'s experience. **Requirements**: - Write the Python code to create the grid world and the agent. - Utilize the Q-learning algorithm with the option for hyperparameter tuning (learning rate, discount factor, exploration rate). - Implement functionality for tracking and plotting the agent\'s performance over time. - Print the final Q-table and the derived policy from the Q-values. **Input Format**: - Number of episodes for training. - Hyperparameters for learning rate, discount factor, and exploration rate. **Output Format**: - Final Q-table printed to the console. - Optimal policy derived from the Q-values printed to the console. - Plot of the learning curve (reward per episode) vs. episodes. **Constraints**: - The code should be executable within a reasonable time frame on standard environments. - Ensure the agent can handle different obstacle configurations by allowing dynamic inputs. **Performance Requirements**: - Aim for the agent to consistently reach the goal in the majority of episodes by the end of training. - Handle edge cases by considering random obstacle placements and dynamic grid size adjustments. **Sample Scenario**: You are building an AI for a path-planning robot to navigate through a factory layout represented as a grid. Using Q-learning, the robot must learn to reach a desired location while avoiding obstacles. You need to develop this agent to be adaptable to different grid configurations and to output its learned policy for navigation.","solution":"import numpy as np import random import matplotlib.pyplot as plt class GridWorld: def __init__(self, size=10, obstacles=None, goal=(9, 9)): self.size = size self.start = (0, 0) self.goal = goal self.obstacles = obstacles if obstacles is not None else [] self.state = self.start def reset(self): self.state = self.start return self.state def step(self, action): x, y = self.state if action == 0: # up next_state = (max(0, x - 1), y) elif action == 1: # down next_state = (min(self.size - 1, x + 1), y) elif action == 2: # left next_state = (x, max(0, y - 1)) elif action == 3: # right next_state = (x, min(self.size - 1, y + 1)) else: next_state = self.state if next_state in self.obstacles: reward = -10 next_state = self.state # No movement elif next_state == self.goal: reward = 10 else: reward = -1 self.state = next_state done = next_state == self.goal return next_state, reward, done class QLearningAgent: def __init__(self, env, learning_rate=0.1, discount_factor=0.99, exploration_rate=1.0, exploration_decay=0.995): self.env = env self.q_table = np.zeros((env.size, env.size, 4)) # Initialize Q-table with zeros self.learning_rate = learning_rate self.discount_factor = discount_factor self.exploration_rate = exploration_rate self.exploration_decay = exploration_decay def choose_action(self, state): if random.uniform(0, 1) < self.exploration_rate: return random.choice([0, 1, 2, 3]) # Explore: Random action else: x, y = state return np.argmax(self.q_table[x, y, :]) # Exploit: Best action based on Q-table def learn(self, state, action, reward, next_state): x, y = state next_x, next_y = next_state best_next_action = np.argmax(self.q_table[next_x, next_y, :]) td_target = reward + self.discount_factor * self.q_table[next_x, next_y, best_next_action] td_error = td_target - self.q_table[x, y, action] self.q_table[x, y, action] += self.learning_rate * td_error def train(self, episodes): rewards = [] for _ in range(episodes): state = self.env.reset() total_reward = 0 done = False while not done: action = self.choose_action(state) next_state, reward, done = self.env.step(action) self.learn(state, action, reward, next_state) state = next_state total_reward += reward rewards.append(total_reward) self.exploration_rate *= self.exploration_decay return rewards def get_policy(self): policy = np.zeros((self.env.size, self.env.size), dtype=int) for i in range(self.env.size): for j in range(self.env.size): policy[i, j] = np.argmax(self.q_table[i, j, :]) return policy # Example usage env = GridWorld(obstacles=[(2, 2), (3, 3), (5, 6), (7, 8)]) agent = QLearningAgent(env) rewards = agent.train(episodes=1000) plt.plot(rewards) plt.xlabel(\'Episodes\') plt.ylabel(\'Total Reward\') plt.show() print(\\"Final Q-Table\\") print(agent.q_table) print(\\"Derived Policy (0: Up, 1: Down, 2: Left, 3: Right)\\") print(agent.get_policy())"},{"question":"# String Rotation Checker Scenario A cybersecurity company needs to verify if a given string is a rotation of another string to secure communications. Your task is to write a function that determines whether one string is a rotation of another. Task 1. Write a function `is_rotation(s1: str, s2: str) -> bool` that takes two strings as input and returns a boolean indicating whether the second string is a rotation of the first string. 2. The function should be case-sensitive, meaning \'A\' and \'a\' are considered different characters. 3. The function should handle both strings efficiently. Input and Output Formats * **Input**: Two strings `s1` and `s2`. * **Output**: A boolean value `True` if `s2` is a rotation of `s1`, otherwise `False`. Constraints & Limitations * The input strings will have lengths of `0 <= len(s1), len(s2) <= 100`. * The function should directly return `False` if the lengths of the two strings are not the same. * An empty string is considered a rotation of another empty string. Example ```python >>> is_rotation(\'hello\', \'llohe\') True >>> is_rotation(\'hello\', \'olelh\') False >>> is_rotation(\'abcde\', \'deabc\') True >>> is_rotation(\'abc\', \'ab\') False >>> is_rotation(\'\', \'\') True ``` Performance Requirements * Aim for a solution with optimized time complexity, around O(n), where n is the length of the strings. Additional Notes Consider edge cases such as one or both strings being empty, strings of length one, and cases where the strings do not match in length.","solution":"def is_rotation(s1: str, s2: str) -> bool: Determines if s2 is a rotation of s1. if len(s1) != len(s2): return False concatenated = s1 + s1 return s2 in concatenated"},{"question":"Audio Signal Compression # Background: Continuing with your role at the audio processing firm, your next task is to implement a system that can compress an audio signal. Compression is essential to reduce storage space and bandwidth requirements without significantly degrading the audio quality. # Task: Implement a simple dynamic range compressor in Python that adjusts the amplitude of an audio signal to fit within a specified dynamic range. # Requirements: 1. You will be provided a base `AudioSignal` class and need to add a method `compress` within this class. 2. You will also create a function `dynamic_range_compression` to apply the compression to the signal. # Algorithm Implementation: 1. **AudioSignal Class**: * This class will hold the signal data (as a list of floats). * It should have a method called `compress`, which: * Accepts threshold, ratio, attack, and release parameters. * Applies the dynamic range compression to the signal data. * Returns the compressed signal data. 2. **Compression Function**: * Implement `dynamic_range_compression` function which: * Takes an `AudioSignal` instance and compression parameters. * Applies the compression algorithm to the signal. * Updates the signal data with compressed values. # Class and Function Definitions: ```python import math class AudioSignal: def __init__(self, data: list): self.data = data def compress(self, threshold: float, ratio: float, attack: float, release: float): # Applies the dynamic range compression to the signal data compressed_data = [] gain = 1.0 for sample in self.data: if abs(sample) > threshold: gain = threshold / abs(sample) + (1 - ratio) gain = max(min(gain, 1.0), 0.0) # Ensure the gain stays between 0 and 1 compressed_sample = sample * gain compressed_data.append(compressed_sample) return compressed_data def dynamic_range_compression(signal: AudioSignal, threshold: float, ratio: float, attack: float, release: float): # Apply the compression to the signal return signal.compress(threshold, ratio, attack, release) ``` # Input/Output: * **Input**: AudioSignal instance, compression parameters (threshold, ratio, attack, release). * Example: ```python signal = AudioSignal([1.0, 0.8, 0.6, 0.4, 0.2]) # Example signal data compressed_signal = dynamic_range_compression(signal, 0.5, 2.0, 0.01, 0.1) ``` * **Output**: List of floats representing the compressed signal. * Example Output: ```python [0.5, 0.4, 0.3, 0.2, 0.1] ``` # Constraints: * Use only native Python libraries. * Handle edge cases gracefully (e.g., signals with constant amplitude). * Ensure the compression parameters (threshold, ratio, attack, release) are within a reasonable range to avoid invalid operations.","solution":"import math class AudioSignal: def __init__(self, data: list): self.data = data def compress(self, threshold: float, ratio: float, attack: float, release: float): compressed_data = [] gain = 1.0 for sample in self.data: if abs(sample) > threshold: over = abs(sample) - threshold compressed_value = threshold + over / ratio compressed_sample = math.copysign(compressed_value, sample) else: compressed_sample = sample compressed_data.append(compressed_sample) return compressed_data def dynamic_range_compression(signal: AudioSignal, threshold: float, ratio: float, attack: float, release: float): # Validate compression parameters if not (0 < ratio <= 20): raise ValueError(\\"Ratio must be between 0 and 20\\") if not (0 <= threshold <= 1): raise ValueError(\\"Threshold must be between 0 and 1\\") compressed_data = signal.compress(threshold, ratio, attack, release) signal.data = compressed_data return signal.data"},{"question":"# Coding Assessment Question: Implementing the Rounding Function Context Rounding to the nearest integer is a common operation in many numerical applications. This exercise will help you demonstrate proficiency in handling rounding scenarios with different kinds of input by asking you to implement a rounding function that rounds a floating-point number to the nearest integer. Problem Statement Write a function `round_nearest(x: float) -> int` that returns the nearest integer to `x`. The rounding should follow the standard rules: round to the nearest integer, with ties (when the fractional part is exactly 0.5) rounding towards the even number. Input and Output * The input will be a floating-point number `x`. * The output should be an integer which is the nearest integer to `x`. Constraints * The input value `x` will be a valid floating-point number within the range of -10^6 to 10^6. * Do not use any external libraries such as `round`. Edge Cases * Consider how to handle negative numbers, zero, and numbers exactly halfway between two integers. * Ensure the implementation is efficient with O(1) time complexity. Example ```python def round_nearest(x: float) -> int: Return the nearest integer to x, rounding ties to the even number. :param x: the number to round :return: the nearest integer to x >>> round_nearest(1.5) 2 >>> round_nearest(2.5) 2 >>> round_nearest(-1.5) -2 >>> round_nearest(1.1) 1 >>> round_nearest(-1.1) -1 >>> round_nearest(0.0) 0 >>> round_nearest(2.0) 2 pass ``` Implement the function and ensure it passes all the provided tests.","solution":"def round_nearest(x: float) -> int: Return the nearest integer to x, rounding ties to the even number. :param x: the number to round :return: the nearest integer to x integer_part = int(x) fractional_part = x - integer_part if fractional_part > 0.5 or (fractional_part == 0.5 and integer_part % 2 != 0): return integer_part + 1 elif fractional_part < -0.5 or (fractional_part == -0.5 and integer_part % 2 != 0): return integer_part - 1 else: return integer_part"},{"question":"**Question: In-Depth Binary Search Tree Manipulation** **Context:** Bob is working on a project that involves extensive manipulation of binary search trees (BSTs). He is particularly interested in ensuring the tree remains balanced after a series of insertions and deletions to maintain optimal search performance. Bob decides to implement a self-balancing binary search tree, specifically an AVL Tree, which rebalances itself during insertions and deletions. **Task:** Your task is to implement an AVL Tree with the following specifications: 1. Implement the insertion and deletion operations that automatically rebalance the tree to maintain the AVL property. 2. Provide a method to search for a specific value in the tree. 3. Include a method to print the tree in-order to verify the tree\'s contents after a series of operations. **Function Signature:** ```python class AVLTree: def __init__(self): pass def insert(self, value: int) -> None: pass def delete(self, value: int) -> None: pass def search(self, value: int) -> bool: pass def in_order_traversal(self) -> list: pass ``` **Input:** - For `insert` and `delete`: `value` (an integer): The value to insert into or delete from the AVL tree. - For `search`: `value` (an integer): The value to search for in the AVL tree. **Output:** - For `insert` and `delete`: No return value. - For `search`: A boolean indicating whether the value exists in the AVL tree. - For `in_order_traversal`: A list containing the elements of the AVL tree in ascending order. **Constraints:** - The values are integers within the range of ([-10^9, 10^9]). - The AVL tree must balance itself after every insertion and deletion. **Examples:** 1. After inserting [10, 20, 30, 40, 50, 25] in sequence, the in-order traversal should output `[10, 20, 25, 30, 40, 50]`. 2. If you delete 40 from the AVL tree created in example 1, the in-order traversal should output `[10, 20, 25, 30, 50]`. 3. Searching for 25 in the tree from example 1 should return `True`. 4. Searching for 100 in the tree from example 1 should return `False`. 5. If the AVL tree is empty, the in-order traversal should return `[]`. **Additional Notes:** 1. Implement the AVL rotations (left, right, left-right, and right-left) as needed for rebalancing during insertions and deletions. 2. Ensure that the insertion and deletion methods maintain the AVL property. 3. Use recursion or an iterative approach as appropriate for the operations.","solution":"class AVLTree: class Node: def __init__(self, value): self.value = value self.left = None self.right = None self.height = 1 def __init__(self): self.root = None def insert(self, value): self.root = self._insert(self.root, value) def _insert(self, node, value): if not node: return self.Node(value) elif value < node.value: node.left = self._insert(node.left, value) else: node.right = self._insert(node.right, value) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and value < node.left.value: return self._right_rotate(node) if balance < -1 and value > node.right.value: return self._left_rotate(node) if balance > 1 and value > node.left.value: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and value < node.right.value: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def delete(self, value): self.root = self._delete(self.root, value) def _delete(self, node, value): if not node: return node if value < node.value: node.left = self._delete(node.left, value) elif value > node.value: node.right = self._delete(node.right, value) else: if not node.left: return node.right elif not node.right: return node.left temp = self._get_min_value_node(node.right) node.value = temp.value node.right = self._delete(node.right, temp.value) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and self._get_balance(node.left) >= 0: return self._right_rotate(node) if balance < -1 and self._get_balance(node.right) <= 0: return self._left_rotate(node) if balance > 1 and self._get_balance(node.left) < 0: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and self._get_balance(node.right) > 0: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def search(self, value): return self._search(self.root, value) def _search(self, node, value): if not node: return False if node.value == value: return True elif value < node.value: return self._search(node.left, value) else: return self._search(node.right, value) def in_order_traversal(self): result = [] self._in_order_traversal(self.root, result) return result def _in_order_traversal(self, node, result): if node: self._in_order_traversal(node.left, result) result.append(node.value) self._in_order_traversal(node.right, result) def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _get_min_value_node(self, node): if node is None or node.left is None: return node return self._get_min_value_node(node.left)"},{"question":"# Coding Assessment Question **Matrix Rotation by 90 Degrees** You are tasked with rotating a given ( N times N ) matrix by 90 degrees in the clockwise direction. Implement a function `rotate_matrix` that performs the rotation in-place. Function Signature ```python def rotate_matrix(matrix: list) -> None: ``` Input * `matrix` (list of lists of integers): A 2D list representing an ( N times N ) matrix. Output * The function should modify the input matrix in place and does not return anything. Constraints * The matrix will be square (i.e., ( N times N )). * ( 1 leq N leq 100 ) * Each element in the matrix is an integer. Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) print(matrix) # Output: [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` Detailed Explanation * The function should rotate the matrix by moving elements in a cyclic order. * For example, the top-left element should move to the top-right position, the top-right element should move to the bottom-right position, and so on. * One approach is to first transpose the matrix (convert rows to columns) and then reverse each row. # Suggested Implementation Steps 1. Transpose the matrix by swapping `matrix[i][j]` with `matrix[j][i]` for all ( i, j ). 2. Reverse each row of the transposed matrix to achieve the 90-degree clockwise rotation. Ensure your implementation correctly performs the rotation and modifies the matrix in place.","solution":"def rotate_matrix(matrix: list) -> None: Rotates the given N x N matrix by 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix: Swap elements across the diagonal for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row to get the final rotated matrix for row in matrix: row.reverse()"},{"question":"# Question: Rotate Matrix By 90 Degrees **Objective**: You are given an `n x n` 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Implement a Python function: ```python def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: ``` # Input: * `matrix (List[List[int]])`: The `n x n` 2D matrix, where `1 <= n <= 100`. # Output: * `List[List[int]]`: The `n x n` 2D matrix after rotating it by 90 degrees clockwise. # Constraints: * The integers in the matrix are between -1000 and 1000. * The matrix dimensions are between 1 and 100. # Performance: * Ensure that your implementation performs the transformation efficiently, respecting the given constraints. # Example: ```python # Example 1 matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Example Call rotated_matrix = rotate_matrix(matrix) print(rotated_matrix) ``` *Expected Output*: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` ```python # Example 2 matrix = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] # Example Call rotated_matrix = rotate_matrix(matrix) print(rotated_matrix) ``` *Expected Output*: ``` [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] ```","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotate the given NxN matrix by 90 degrees clockwise. n = len(matrix) rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated"},{"question":"# Coding Assessment Question You are working on implementing a basic playlist management system using a linked list. Your task is to enhance the `Playlist` class by adding two new operations: 1. `shuffle()` - Randomly shuffles the elements of the playlist. 2. `move_song_to_front(song)` - Moves a specified song to the front of the playlist. Implement the following methods with the exact signatures and constraints as shown. Expected Input and Output Formats: ```python import random class Playlist: ... def shuffle(self) -> None: Randomly shuffles the elements of the playlist. >>> pls = Playlist() >>> pls.add_song(\\"Song A\\") >>> pls.add_song(\\"Song B\\") >>> pls.add_song(\\"Song C\\") >>> pls.add_song(\\"Song D\\") >>> pls.shuffle() >>> pls.display() [\'Song C\', \'Song A\', \'Song B\', \'Song D\'] >>> def move_song_to_front(self, song: str) -> None: Moves a specified song to the front of the playlist. >>> pls = Playlist() >>> pls.add_song(\\"Song A\\") >>> pls.add_song(\\"Song B\\") >>> pls.add_song(\\"Song C\\") >>> pls.add_song(\\"Song D\\") >>> pls.move_song_to_front(\\"Song C\\") >>> pls.display() [\'Song C\', \'Song A\', \'Song B\', \'Song D\'] >>> ``` Constraints: - The `shuffle` method should use a random number generator to change the order of the elements. - The `move_song_to_front` method should handle cases where the specified song is not present in the playlist gracefully. - Songs in the playlist are unique. - Performance targets: - Shuffling the playlist in O(N) time complexity. - Moving a song to the front in O(1) time complexity for finding the node and O(N) for re-linking it. **Scenario/Context**: Your music app needs a way to randomly shuffle playlists for a better user experience and allow users to highlight and play their favorite songs first. Implement these features to provide users with more versatile playlist management options.","solution":"import random class Playlist: class Node: def __init__(self, song: str): self.song = song self.next = None def __init__(self): self.head = None def add_song(self, song: str) -> None: new_node = self.Node(song) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def display(self) -> list: result = [] current = self.head while current: result.append(current.song) current = current.next return result def shuffle(self) -> None: nodes = [] current = self.head while current: nodes.append(current) current = current.next random.shuffle(nodes) for i in range(len(nodes) - 1): nodes[i].next = nodes[i + 1] if nodes: nodes[-1].next = None self.head = nodes[0] def move_song_to_front(self, song: str) -> None: if not self.head or self.head.song == song: return prev, current = None, self.head while current and current.song != song: prev = current current = current.next if current: if prev: prev.next = current.next current.next = self.head self.head = current"},{"question":"**Context**: You are given a `Matrix` class that represents a 2D square matrix with methods for basic manipulations, such as setting and getting elements. Unfortunately, the class does not have a method for rotating the matrix 90 degrees clockwise. **Objective:** Implement the `rotate_90_clockwise` method in the provided `Matrix` class. This method must rotate the matrix 90 degrees clockwise effectively. This method must handle all standard cases, including when the matrix is empty or has just one element. The rotation should be done in-place with a constant space complexity. **Function Signature:** ```python def rotate_90_clockwise(self) -> None: Rotate the matrix 90 degrees clockwise in-place. Returns: None Examples: >>> matrix = Matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) >>> matrix.rotate_90_clockwise() >>> matrix.get_matrix() [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` **Constraints:** - The method should not use any extra space apart from a few pointers or temporary variables (i.e., O(1) space complexity). - The matrix should be rotated 90 degrees clockwise in O(n^2) time complexity where n is the dimension of the matrix. **Examples:** 1. Rotating a 3x3 matrix: ```python matrix = Matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) matrix.rotate_90_clockwise() assert matrix.get_matrix() == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` 2. Rotating an empty matrix: ```python matrix = Matrix([]) matrix.rotate_90_clockwise() assert matrix.get_matrix() == [] ``` 3. Rotating a 1x1 matrix: ```python matrix = Matrix([[1]]) matrix.rotate_90_clockwise() assert matrix.get_matrix() == [[1]] ```","solution":"class Matrix: def __init__(self, matrix): self.matrix = matrix def rotate_90_clockwise(self): Rotate the matrix 90 degrees clockwise in-place. n = len(self.matrix) for i in range(n // 2): for j in range(i, n - i - 1): temp = self.matrix[i][j] self.matrix[i][j] = self.matrix[n - j - 1][i] self.matrix[n - j - 1][i] = self.matrix[n - i - 1][n - j - 1] self.matrix[n - i - 1][n - j - 1] = self.matrix[j][n - i - 1] self.matrix[j][n - i - 1] = temp def get_matrix(self): return self.matrix"},{"question":"# Coding Assessment Question Requirements You are tasked with implementing an algorithm to find the median of a given list of integers using the Quickselect algorithm. Your task is to write a Python function `find_median(arr: list[int]) -> float` that computes the median value. Input * `arr`: A list of integers of odd or even length. Output * A float representing the median value of the list. Constraints - The input list can have a length between 1 and 10,000. - The input list can contain both positive and negative integers, as well as zero. Example ```python arr1 = [3, 2, 1, 5, 4] result1 = find_median(arr1) print(result1) # Expected output: 3.0 arr2 = [3, 2, 1, 4] result2 = find_median(arr2) print(result2) # Expected output: 2.5 ``` Performance Requirements Ensure that your solution handles the worst-case time complexity of O(n) using the Quickselect algorithm, which is efficient for finding the k-th smallest elements in an unsorted array. Context Quickselect is a selection algorithm to find the k-th smallest element in an unordered list. It is related to the Quicksort sorting algorithm. The median is a measure of central tendency that is less affected by outliers and provides a better understanding of the distribution of the input list. This algorithm is particularly useful for large datasets and real-time computing where efficiency is critical.","solution":"def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quickselect(arr, low, high, k): if low == high: return arr[low] pi = partition(arr, low, high) if pi == k: return arr[pi] elif pi < k: return quickselect(arr, pi + 1, high, k) else: return quickselect(arr, low, pi - 1, k) def find_median(arr): n = len(arr) if n % 2 == 1: return float(quickselect(arr, 0, n - 1, n // 2)) else: left_mid = quickselect(arr, 0, n - 1, n // 2 - 1) right_mid = quickselect(arr, 0, n - 1, n // 2) return (left_mid + right_mid) / 2.0"},{"question":"Subset Sum Problem: Find All Unique Combinations You are given a list of positive integers and a target sum. Your task is to find all unique combinations from the list where the sum of the elements in each combination equals the target sum. Each number in the list can be used as many times as needed. Implement the function `find_combinations` that will accept a list of integers and an integer target sum, and return a list of lists, where each list represents a unique combination that sums up to the target. Input: * `numbers` (List of positive integers) * `target` (integer) Output: * List of lists, where each list contains integers that sum up to the target Constraints: * Assume all numbers are positive integers. * The numbers in each combination should be returned in non-descending order. * Combinations themselves should also be returned in lexicographically sorted order. * Input list `numbers` can contain duplicates. * Your solution should aim for completeness and efficiency. Example: ```python >>> find_combinations([2, 3, 6, 7], 7) [[2, 2, 3], [7]] >>> find_combinations([2, 3, 5], 8) [[2, 2, 2, 2], [2, 3, 3], [3, 5]] ``` Guidelines: * Use a recursive approach to explore all possible combinations. * Avoid duplicate combinations by sorting the input list initially. * Ensure that your implementation handles edge cases such as when no combinations can sum up to the target. * You can assume that the input list and the target are reasonably small. Make sure your code is efficient and adheres to the outlined constraints.","solution":"def find_combinations(numbers, target): def backtrack(start, path, current_sum): if current_sum == target: result.append(path[:]) return if current_sum > target: return for i in range(start, len(numbers)): if i > start and numbers[i] == numbers[i - 1]: continue path.append(numbers[i]) backtrack(i, path, current_sum + numbers[i]) path.pop() numbers.sort() result = [] backtrack(0, [], 0) return result"},{"question":"# Prim\'s Algorithm for Minimum Spanning Tree You are required to implement Prim\'s algorithm from scratch to find the Minimum Spanning Tree (MST) of an undirected, weighted graph. Prim\'s algorithm is a greedy algorithm that constructs an MST by growing from a starting node and adding the lowest weight edges that connect a node in the tree to a node outside it. # Problem 1. **Implement the Graph Construction**: - Write a class `Graph` with methods to add edges and weights. - `Graph` should provide a way to represent an undirected, weighted graph. 2. **Implement Prim\'s Algorithm**: - Write a function `prim_mst(graph, start)` to find the MST of the graph. - `graph` is an instance of the `Graph` class, and `start` is the node from which Prim\'s algorithm begins. # Function Signatures ```python class Graph: def __init__(self, vertices: int): self.V = vertices self.adj = [] for _ in range(vertices): self.adj.append([]) def add_edge(self, u: int, v: int, weight: float) -> None: self.adj[u].append((v, weight)) self.adj[v].append((u, weight)) def prim_mst(graph: Graph, start: int) -> List[Tuple[int, int, float]]: # Implement this function ``` # Requirements 1. **Input**: - `Graph(vertices)`: initializes a graph with `vertices` number of vertices. - `add_edge(u, v, weight)`: adds an edge between vertices `u` and `v` with the given weight. - `prim_mst(graph, start)`: the graph instance and the starting vertex. 2. **Output**: - `prim_mst(graph, start)`: returns a list of tuples representing the edges in the MST. Each tuple contains two nodes and the weight of the edge: `(node1, node2, weight)`. 3. **Constraints**: - Graph contains positive edge weights. - There are no self-loops or multiple edges between the same pair of nodes. - The graph is connected. # Example Constructing the graph and finding the MST using Prim\'s Algorithm: ```python g = Graph(5) g.add_edge(0, 1, 2) g.add_edge(0, 3, 6) g.add_edge(1, 2, 3) g.add_edge(1, 3, 8) g.add_edge(1, 4, 5) g.add_edge(2, 4, 7) g.add_edge(3, 4, 9) result = prim_mst(g, 0) print(result) # Output: [(0, 1, 2), (1, 2, 3), (1, 4, 5), (0, 3, 6)] # Example output; actual may vary ``` # Additional Notes - Ensure the implementation handles edge cases such as an empty graph or graphs with single nodes. - The graph data structure should be flexible enough to handle various edge cases. - Optimize for both space and time complexity.","solution":"import heapq class Graph: def __init__(self, vertices: int): self.V = vertices self.adj = [[] for _ in range(vertices)] def add_edge(self, u: int, v: int, weight: float) -> None: self.adj[u].append((v, weight)) self.adj[v].append((u, weight)) def prim_mst(graph: Graph, start: int): mst = [] visited = [False] * graph.V min_heap = [(0, start, -1)] # (weight, vertex, parent) while min_heap: weight, u, parent = heapq.heappop(min_heap) if visited[u]: continue visited[u] = True if parent != -1: # Don\'t add the initial node mst.append((parent, u, weight)) for v, wt in graph.adj[u]: if not visited[v]: heapq.heappush(min_heap, (wt, v, u)) return mst"},{"question":"# Problem Statement You are given a dataset containing \\"Study Hours\\" and \\"Exam Scores\\" columns representing the number of hours students studied and their respective exam scores. The task is to predict the exam score based on the number of study hours using Polynomial Regression. Your function needs to: 1. Implement polynomial regression using the normal equation method to minimize the mean squared error. 2. Fit a polynomial of a given degree to the training data. 3. Calculate and return the Mean Absolute Error (MAE) on a provided validation dataset. # Function Signature ```python def polynomial_regression_predict(train_X, train_Y, val_X, val_Y, degree=2): :param train_X: List[float] - Study Hours feature for training :param train_Y: List[float] - Exam Scores target for training :param val_X: List[float] - Study Hours feature for validation :param val_Y: List[float] - Exam Scores target for validation :param degree: int - Degree of the polynomial to fit :return: float - Mean absolute error on validation data ``` # Constraints & Input Format - train_X and train_Y are lists where `len(train_X) == len(train_Y)` and `len(train_X) > 0`. - val_X and val_Y are lists where `len(val_X) == len(val_Y)` and `len(val_X) > 0`. - Each element in train_X, train_Y, val_X, and val_Y is a non-negative float. - The study hours in train_X and val_X are scaled between 0 and 12 hours, and exam scores are scaled between 0 and 100. # Example ```python train_X = [1, 2, 3, 4, 5] train_Y = [55, 60, 65, 70, 75] val_X = [6, 8] val_Y = [80, 90] mae = polynomial_regression_predict(train_X, train_Y, val_X, val_Y, degree=2) print(mae) # Expected output: a float value representing the mean absolute error ``` # Explanation 1. **Data Preprocessing**: Convert lists to numpy arrays and create polynomial features of the given degree. 2. **Normal Equation**: Solve the polynomial regression problem using the normal equation method to find the optimal weights. 3. **Prediction & MAE Calculation**: Use the learned polynomial model to make predictions on the validation set and calculate MAE.","solution":"import numpy as np def polynomial_regression_predict(train_X, train_Y, val_X, val_Y, degree=2): :param train_X: List[float] - Study Hours feature for training :param train_Y: List[float] - Exam Scores target for training :param val_X: List[float] - Study Hours feature for validation :param val_Y: List[float] - Exam Scores target for validation :param degree: int - Degree of the polynomial to fit :return: float - Mean absolute error on validation data # Convert lists to numpy arrays train_X = np.array(train_X) train_Y = np.array(train_Y) val_X = np.array(val_X) val_Y = np.array(val_Y) # Create polynomial features for training data X_poly = np.vander(train_X, degree + 1, increasing=True) # Calculate weights using normal equation method theta = np.linalg.inv(X_poly.T.dot(X_poly)).dot(X_poly.T).dot(train_Y) # Create polynomial features for validation data val_X_poly = np.vander(val_X, degree + 1, increasing=True) # Predict on validation data val_pred = val_X_poly.dot(theta) # Calculate Mean Absolute Error (MAE) mae = np.mean(np.abs(val_pred - val_Y)) return mae"},{"question":"# Array Manipulation with Minimum Swaps to Sort Context As an array manipulation expert, you are to improve the performance of a sorting algorithm in a highly constrained environment. You are tasked with writing a function that sorts an array with the minimum number of adjacent swaps needed to place every element in its correct position. Task You need to implement a function that determines the minimum number of swaps required to sort the given array in ascending order. Adjacent swaps mean you can only swap elements that are next to each other. Requirements 1. **Function Prototype**: Implement the function `minimum_adjacent_swaps_to_sort(arr: List[int]) -> int`. 2. **Input and Output**: - **Input**: - `arr` (List[int]): A list of integers to sort. - **Output**: An integer representing the minimum number of adjacent swaps required to sort the array. 3. **Constraints**: - The array can have a length ranging from 1 to 10^5. - The elements in the array are distinct integers within the range of 1 to 10^5. Expectations - Efficiently handle the array using a suitable algorithm. - The function should run in O(n log n) time complexity or better to handle large arrays effectively. - Clearly documented code for readability. Example Here is an example to guide you: ```python def minimum_adjacent_swaps_to_sort(arr: List[int]) -> int: n = len(arr) # Your implementation here ``` **Example Usage**: ```python arr = [4, 3, 1, 2] print(minimum_adjacent_swaps_to_sort(arr)) # Output: 3 ``` Use an efficient algorithm to keep track of element positions and determine the minimum swaps required to order the array correctly.","solution":"from typing import List def minimum_adjacent_swaps_to_sort(arr: List[int]) -> int: # We will implement the merge sort and count inversions def merge_sort_and_count(arr, temp_arr, left, right): if left < right: mid = (left + right) // 2 inv_count = merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count return 0 def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count n = len(arr) temp_arr = [0] * n return merge_sort_and_count(arr, temp_arr, 0, n - 1)"},{"question":"# Problem Statement Design and implement a `Matrix` class that can represent a 2D matrix and perform various operations on it. The class should handle both integer and float elements and support the following functionalities: 1. **Initialization**: Initialize the matrix with a 2D list where the number of columns in each row is consistent. 2. **Addition**: Implement a method to add two matrices if they have the same dimensions. 3. **Multiplication**: Implement a method to multiply two matrices if their dimensions are compatible for matrix multiplication. 4. **Transpose**: Implement a method to return the transpose of the matrix. 5. **Determinant Calculation**: Implement a method to calculate the determinant of the matrix (applicable only for square matrices). # Implementation Details - Create a `Matrix` class that: - Initializes with a 2D list and validates it. - Implements addition of two matrices. - Implements multiplication of two matrices. - Implements the transpose of the matrix. - Implements determinant calculation for square matrices. # Input & Output Formats - **Input**: - The matrix will be initialized with a 2D list. - `add(matrix: Matrix)` method will take another `Matrix` object and return the sum if dimensions match. - `multiply(matrix: Matrix)` method will take another `Matrix` object and return the product if dimensions are compatible. - `transpose()` method will return a new `Matrix` object representing the transposed matrix. - `determinant()` method will return a number representing the determinant if the matrix is square. - **Output**: - For addition and multiplication, return a `Matrix` object representing the result. - For transpose, return a `Matrix` object representing the transposed matrix. - For determinant, return a float or integer representing the determinant value. # Constraints - Elements of the matrix will be either integers or floats. - Matrices used for addition or multiplication must be compatible (dimensions should match for addition and dimensions should be appropriate for multiplication). - Determinant calculation is only for square matrices. # Example ```python # Assuming the Matrix class is implemented. m1 = Matrix([[1, 2], [3, 4]]) m2 = Matrix([[5, 6], [7, 8]]) sum_matrix = m1.add(m2) print(sum_matrix.data) # Expected output: [[6, 8], [10, 12]] product_matrix = m1.multiply(m2) print(product_matrix.data) # Expected output: [[19, 22], [43, 50]] transpose_matrix = m1.transpose() print(transpose_matrix.data) # Expected output: [[1, 3], [2, 4]] det = m1.determinant() print(det) # Expected output: -2.0 ``` # Performance Requirements - Ensure the implementation is efficient in terms of validating input dimensions and performing operations. - Handle exceptions gracefully when operations cannot be performed due to incompatible dimensions.","solution":"class Matrix: def __init__(self, data): if not data or not all(len(row) == len(data[0]) for row in data): raise ValueError(\\"All rows must have the same number of columns\\") self.data = data def add(self, other): if len(self.data) != len(other.data) or len(self.data[0]) != len(other.data[0]): raise ValueError(\\"Matrices are not of the same dimensions\\") return Matrix([ [self.data[i][j] + other.data[i][j] for j in range(len(self.data[0]))] for i in range(len(self.data)) ]) def multiply(self, other): if len(self.data[0]) != len(other.data): raise ValueError(\\"Incompatible dimensions for matrix multiplication\\") result = [[0] * len(other.data[0]) for _ in range(len(self.data))] for i in range(len(self.data)): for j in range(len(other.data[0])): for k in range(len(other.data)): result[i][j] += self.data[i][k] * other.data[k][j] return Matrix(result) def transpose(self): return Matrix(list(map(list, zip(*self.data)))) def determinant(self): if len(self.data) != len(self.data[0]): raise ValueError(\\"Determinant is defined only for square matrices\\") return self._determinant_recursive(self.data) def _determinant_recursive(self, matrix): if len(matrix) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(len(matrix)): det += ((-1) ** c) * matrix[0][c] * self._determinant_recursive(self._minor(matrix, 0, c)) return det def _minor(self, matrix, row, col): minor = [row[:col] + row[col + 1:] for row in (matrix[:row] + matrix[row + 1:])] return minor"},{"question":"# Problem Statement You are developing a simplified version of a text-based calculator that can evaluate basic arithmetic expressions only containing additions and subtractions. The arithmetic expression will only have non-negative integers. Write a function that takes such a string expression and returns the computed result as an integer. # Function Signature ```python def evaluate_expression(expression: str) -> int: Evaluate a simple arithmetic expression consisting of non-negative integers and addition/subtraction operations, and return the integer result. Parameters: - expression (str): A string containing the arithmetic expression. Returns: - int: The result of the arithmetic expression. pass ``` # Input - `expression` is a string containing a valid arithmetic expression: - The expression contains non-negative integers and the operators `+` or `-`. - The expression does not contain any spaces. - The length of the expression is at least 1 and at most 100. # Output - An integer that represents the computed result of the expression. # Constraints - ( 1 leq text{length of expression} leq 100 ) - The expression contains only `0-9`, `+`, `-`. # Example ```python evaluate_expression(\\"3+5-2\\") # Output: 6 evaluate_expression(\\"10-3+2\\") # Output: 9 evaluate_expression(\\"2+2+2+2\\") # Output: 8 ``` # Notes - The input expression will always be a valid sequence of numbers and operators. - You do not need to handle invalid expressions or error-checking of input format. - Operator precedence follows the conventional left-to-right evaluation (not considering multiplication/division or parentheses in this problem).","solution":"def evaluate_expression(expression: str) -> int: Evaluate a simple arithmetic expression consisting of non-negative integers and addition/subtraction operations, and return the integer result. Parameters: - expression (str): A string containing the arithmetic expression. Returns: - int: The result of the arithmetic expression. index = 0 length = len(expression) def parse_number(): nonlocal index num = 0 while index < length and expression[index].isdigit(): num = num * 10 + int(expression[index]) index += 1 return num result = parse_number() while index < length: op = expression[index] index += 1 num = parse_number() if op == \'+\': result += num elif op == \'-\': result -= num return result"},{"question":"# Problem Statement: You are given an array of integers and an integer `n`. Your task is to find the `n`-th smallest element in the array without sorting the entire array. # Function Signature: ```python def nth_smallest_element(arr: List[int], n: int) -> int: ``` # Input: * `arr` (List of integers): An unsorted list of integers. * `n` (an integer): The position (1-based index) of the desired smallest element in the array. # Output: * Returns the `n`-th smallest element in the given list. # Constraints: * The list `arr` will have at least `n` elements. * The elements in the list can be both positive and negative integers, and they are not necessarily distinct. * 1 ≤ `n` ≤ len(arr) * len(arr) will be ≤ 10^4. # Performance Requirements: * The solution should have an average-case time complexity better than O(n log n), aiming for O(n) to match the typical performance of a Quickselect algorithm. # Example: ```python assert nth_smallest_element([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], 5) == 3 assert nth_smallest_element([8, 7, 6, 5, 4, 3, 2, 1], 3) == 3 ``` # Notes: 1. Consider the Quickselect algorithm, which is a selection algorithm optimized for finding the k-th smallest elements. 2. Think about edge cases such as arrays with duplicate elements and varying ranges of numbers.","solution":"from typing import List def nth_smallest_element(arr: List[int], n: int) -> int: Returns the nth smallest element in the array without sorting the entire array. Implements the Quickselect algorithm. def partition(left, right, pivot_index): pivot_value = arr[pivot_index] # Move pivot to end arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left # Move all smaller elements to the left for i in range(left, right): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 # Move pivot to its final place arr[right], arr[store_index] = arr[store_index], arr[right] return store_index def select(left, right, k): if left == right: return arr[left] pivot_index = (left + right) // 2 pivot_index = partition(left, right, pivot_index) if k == pivot_index: return arr[k] elif k < pivot_index: return select(left, pivot_index - 1, k) else: return select(pivot_index + 1, right, k) return select(0, len(arr) - 1, n - 1)"},{"question":"# List Combination Checker You are working on a utility that ensures two lists have no overlapping elements. This function will be useful in various scenarios where you need to validate that the contents of two collections are distinct from each another. Objective Create a function that takes two lists as input and returns a boolean indicating whether they have no elements in common. Requirements 1. **Function Creation**: - Design a function named `no_overlap` that: - Accepts two lists as parameters. - Returns `True` if there are no common elements between the lists. - Returns `False` if there is at least one common element. 2. **Input and Output**: - **Input**: Two lists, which may contain elements of any hashable type. - **Output**: A boolean value. 3. **Constraints**: - Both lists can contain elements of any data type. - Elements in each list are unique. - Consider the performance for larger lists (linear time complexity). - Do not use third-party libraries. 4. **Edge Cases**: - Handle cases where one or both lists are empty. - Handle cases with varying types of elements in the lists. Example ```python def no_overlap(list1: list, list2: list) -> bool: Determine if two lists have no elements in common. >>> no_overlap([1, 2, 3], [4, 5, 6]) True >>> no_overlap([\'a\', \'b\', \'c\'], [\'d\', \'a\']) False >>> no_overlap([], [1]) True >>> no_overlap([\'apple\', \'orange\'], [\'pear\', \'banana\']) True >>> no_overlap([1, 2, \'apple\'], [3, 4, \'orange\']) True >>> no_overlap([1, 2, \'apple\'], [1, 2, \'apple\']) False set1 = set(list1) for item in list2: if item in set1: return False return True ``` Task Implement the specified function ensuring it passes all the given test cases. Consider edge cases and optimize for performance where possible.","solution":"def no_overlap(list1, list2): Determine if two lists have no elements in common. Args: list1 (list): The first list to compare. list2 (list): The second list to compare. Returns: bool: True if lists have no common elements, False otherwise. set1 = set(list1) for item in list2: if item in set1: return False return True"},{"question":"# Coding Assessment Question You are helping develop a library for processing time series data. One of the tasks is to create a function that performs data manipulation operations such as normalization, smoothing, and difference transformation on the time series data. You need to create a function `process_time_series` that takes in the following parameters: - `operation` (str): The type of manipulation to perform. It can be one of the following: - \\"normalize\\": Scale the data to have a mean of 0 and a standard deviation of 1. - \\"smooth\\": Apply a moving average with a specified window size. - \\"difference\\": Compute the difference between subsequent elements. - `data` (np.ndarray): A 1-dimensional numpy array representing the time series data. - `kwargs` (dict): Additional keyword arguments for specific operations. The function should return the manipulated data array. Input and Output Formats ```python def process_time_series(operation: str, data: np.ndarray, **kwargs) -> np.ndarray: pass # Example usage: data = np.array([3.0, 4.0, 6.0, 5.0, 3.0]) print(process_time_series(\\"normalize\\", data)) # Expected: [-0.5, 0.0, 1.0, 0.5, -1.0] data = np.array([10, 20, 30, 40, 50]) print(process_time_series(\\"smooth\\", data, window_size=3)) # Expected: [10.0, 20.0, 30.0, 30.0, 40.0] data = np.array([5, 8, 6, 10, 9]) print(process_time_series(\\"difference\\", data)) # Expected: [3, -2, 4, -1] ``` Constraints - If `operation` is `\\"normalize\\"`, ensure the result has a mean of 0 and a standard deviation of 1. - If `operation` is `\\"smooth\\"`, the `window_size` argument (an integer) must be provided via `kwargs`. - The `window_size` argument must be a positive odd integer. - If `window_size` exceeds the length of the data array, return the original array. - If `operation` is `\\"difference\\"`, compute the difference such that the result is one element shorter than the original array. - Handle edge cases such as empty arrays or arrays with insufficient data points. Requirements - Implement error handling for invalid operations or parameters. - Ensure numerical stability particularly during normalization. - Optimize for performance using efficient numpy operations where possible. # Note Use the provided example usages and expected outputs as a guide to implement and validate your solution.","solution":"import numpy as np def process_time_series(operation: str, data: np.ndarray, **kwargs) -> np.ndarray: Process the time series data according to the specified operation. Parameters: - operation (str): The type of manipulation to perform. One of \\"normalize\\", \\"smooth\\", \\"difference\\". - data (np.ndarray): A 1-dimensional numpy array representing the time series data. - kwargs (dict): Additional keyword arguments for specific operations. Returns: - np.ndarray: The manipulated data array. if operation not in [\\"normalize\\", \\"smooth\\", \\"difference\\"]: raise ValueError(\\"Invalid operation. Must be one of \'normalize\', \'smooth\', \'difference\'.\\") if operation == \\"normalize\\": if len(data) == 0: return data mean = np.mean(data) std = np.std(data) if std == 0: return np.zeros_like(data) return (data - mean) / std elif operation == \\"smooth\\": if \\"window_size\\" not in kwargs: raise ValueError(\\"Missing \'window_size\' argument for smoothing operation.\\") window_size = kwargs.get(\\"window_size\\") if not isinstance(window_size, int) or window_size <= 0 or window_size % 2 == 0: raise ValueError(\\"\'window_size\' must be a positive odd integer.\\") if len(data) == 0 or window_size > len(data): return data return np.convolve(data, np.ones(window_size) / window_size, mode=\'same\') elif operation == \\"difference\\": if len(data) < 2: return np.array([]) return np.diff(data)"},{"question":"# Question: List Comprehensions and Filtering You are required to implement two functions that utilize list comprehensions to perform specified operations on a list of numbers. Function 1: `filter_non_negative` Implement the function `filter_non_negative(numbers: List[int]) -> List[int]`. **Input:** - `numbers`: A list of integers. **Output:** - A list of integers that contains only the non-negative integers from the input list. **Constraints:** - The list may contain positive integers, zero, and negative integers. - The input list can be empty. **Example:** ```python assert filter_non_negative([-1, 0, 3, -42, 17]) == [0, 3, 17] assert filter_non_negative([7, -8, 9, -10, 11]) == [7, 9, 11] assert filter_non_negative([]) == [] ``` Function 2: `even_squares` Implement the function `even_squares(numbers: List[int]) -> List[int]`. **Input:** - `numbers`: A list of integers. **Output:** - A list of integers that contains the squares of the even integers from the input list. **Constraints:** - The list may contain positive integers, zero, and negative integers. - The input list can be empty. **Example:** ```python assert even_squares([1, 2, 3, 4, 5]) == [4, 16] assert even_squares([10, 13, 15, 20, 22]) == [100, 400, 484] assert even_squares([-2, 0, 5, -8, 3]) == [4, 0, 64] assert even_squares([]) == [] ``` **Edge Cases to Consider:** - Functions should correctly handle an empty list. - Functions should work efficiently with very large input lists. - Ensure proper handling of mixed positive and negative numbers.","solution":"from typing import List def filter_non_negative(numbers: List[int]) -> List[int]: Returns a list of non-negative integers from the given list. return [num for num in numbers if num >= 0] def even_squares(numbers: List[int]) -> List[int]: Returns a list of squares of the even integers from the given list. return [num ** 2 for num in numbers if num % 2 == 0]"},{"question":"# Problem Statement You are required to simulate a simple text-based battleship game, considering the following constraints and input formats. # Task: Write a function `battleship(board: List[List[str]], shots: List[Tuple[int, int]]) -> List[str]:` that simulates a series of shots on a battleship game board and returns the results of each shot in the form of \\"Hit\\" or \\"Miss\\". # Input * `board`: A 2D list of strings where each string is either \\"B\\" (indicating a part of a battleship) or \\".\\" (indicating water). The board will be a 5x5 grid. * `shots`: A list of tuples where each tuple contains two integers (x, y), representing a coordinate on the board where a shot is fired. Coordinates are 0-indexed. # Output * A list of strings where each string is either \\"Hit\\" or \\"Miss\\" corresponding to the results of each shot fired. # Constraints * The coordinates provided in `shots` will always be within the bounds of the board (0 ≤ x, y < 5). * The input board will be a valid 5x5 grid. * The function should handle multiple shots and return results in the order they were provided. # Example Input `board = [ [\'B\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'B\', \'B\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'B\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'B\'], [\'B\', \'.\', \'B\', \'B\', \'.\'] ]` `shots = [(0, 0), (1, 1), (2, 3), (4, 2), (3, 4), (4, 4)]` Output `[\'Hit\', \'Hit\', \'Hit\', \'Hit\', \'Hit\', \'Miss\']` Input `board = [ [\'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\'] ]` `shots = [(0, 0), (2, 2), (4, 4)]` Output `[\'Miss\', \'Miss\', \'Miss\']` # Implementation Notes - Writing concise and well-documented code is expected. - Consider using type hints and ensuring code readability. - The solution should be tested for various edge cases. # Function Signature ```python from typing import List, Tuple def battleship(board: List[List[str]], shots: List[Tuple[int, int]]) -> List[str]: pass ``` # Additional Requirements 1. Implement comprehensive validation to handle edge cases. 2. Ensure the function process shots efficiently. 3. Consider the readability and maintainability of the code.","solution":"from typing import List, Tuple def battleship(board: List[List[str]], shots: List[Tuple[int, int]]) -> List[str]: Simulates a series of shots on a battleship game board and returns the results of each shot. Parameters: board (List[List[str]]): A 5x5 game board where \'B\' indicates a part of a battleship and \'.\' indicates water. shots (List[Tuple[int, int]]): List of shot coordinates as tuples (x, y). Returns: List[str]: A list of results for each shot in the order they were taken, either \\"Hit\\" or \\"Miss\\". result = [] for x, y in shots: if board[x][y] == \'B\': result.append(\'Hit\') else: result.append(\'Miss\') return result"},{"question":"# Coding Challenge: Design a Real-Time Rate Limiter Context In distributed systems and web services, it\'s essential to control the rate of incoming requests to ensure fair usage and system stability. A rate limiter helps to cap the number of requests a user can send to a service within a specified time window. Task Implement a real-time rate limiter class `RateLimiter` that enforces a limiting policy on API requests. You will complete the following key methods: 1. **`is_allowed`** - Determines if a request from the given user should be allowed based on the rate limit policies. 2. **`add_request`** - Log the arrival of a new request for rate limiting purposes. Requirements 1. **Function Signatures**: - `is_allowed`: `(user_id: str) -> bool` - `add_request`: `(user_id: str) -> None` 2. **Attributes**: - `requests`: Dictionary to track the timestamps of requests for each user. - `max_requests`: Maximum number of allowed requests within the `time_window`. - `time_window`: Time window duration (in seconds) for rate limiting. 3. **Input/Output**: - Input: User ID and request timestamp. - Output: Boolean indicating if the request is allowed. 4. **Performance**: - Ensure efficient handling of requests and data structures. 5. **Constraints**: - User ID is a string of alphanumeric characters. - Timestamp is in seconds since epoch. - `max_requests` and `time_window` are positive integers. Example ```python if __name__ == \'__main__\': import time rate_limiter = RateLimiter(max_requests=5, time_window=60) user = \\"user_1\\" # Simulate 5 allowed requests for i in range(5): rate_limiter.add_request(user) print(rate_limiter.is_allowed(user)) # Expected True for all time.sleep(1) # Introduce some delay # This request should be denied rate_limiter.add_request(user) print(rate_limiter.is_allowed(user)) # Expected False time.sleep(60) # Wait until the time window resets # This request should be allowed again rate_limiter.add_request(user) print(rate_limiter.is_allowed(user)) # Expected True ``` ```python class RateLimiter: def __init__(self, max_requests: int, time_window: int) -> None: Initializes the RateLimiter with max allowed requests and time window. :param max_requests: Maximum allowed requests in the time window. :param time_window: Time window in seconds for rate limiting. self.requests = {} self.max_requests = max_requests self.time_window = time_window def add_request(self, user_id: str) -> None: Logs the request time for the given user. :param user_id: The ID of the user making the request. if user_id not in self.requests: self.requests[user_id] = [] self.requests[user_id].append(time.time()) def is_allowed(self, user_id: str) -> bool: Checks if the request from the given user is allowed based on the rate limit policy. :param user_id: The ID of the user making the request. :return: True if the request is allowed, False otherwise. current_time = time.time() if user_id not in self.requests: return True # Filter out requests outside the time window self.requests[user_id] = [timestamp for timestamp in self.requests[user_id] if current_time - timestamp <= self.time_window] # Check the number of requests in the current time window if len(self.requests[user_id]) < self.max_requests: return True return False ```","solution":"import time class RateLimiter: def __init__(self, max_requests: int, time_window: int) -> None: Initializes the RateLimiter with max allowed requests and time window. :param max_requests: Maximum allowed requests in the time window. :param time_window: Time window in seconds for rate limiting. self.requests = {} self.max_requests = max_requests self.time_window = time_window def add_request(self, user_id: str) -> None: Logs the request time for the given user. :param user_id: The ID of the user making the request. if user_id not in self.requests: self.requests[user_id] = [] self.requests[user_id].append(time.time()) def is_allowed(self, user_id: str) -> bool: Checks if the request from the given user is allowed based on the rate limit policy. :param user_id: The ID of the user making the request. :return: True if the request is allowed, False otherwise. current_time = time.time() if user_id not in self.requests: return True # Filter out requests outside the time window self.requests[user_id] = [timestamp for timestamp in self.requests[user_id] if current_time - timestamp <= self.time_window] # Check the number of requests in the current time window if len(self.requests[user_id]) < self.max_requests: return True return False"},{"question":"# Neural Network from Scratch: Feedforward and Backpropagation **Scenario**: Implement a basic neural network from scratch to understand the fundamental workings of feedforward, backpropagation, and gradient descent. This task will strengthen your knowledge of deep learning concepts and their practical implementation. **Task**: 1. **Understand** the basics of neural networks, including activation functions, loss functions, and gradient-based optimization. 2. **Implement** a `NeuralNetwork` class with the following features: - Allow customization of the network\'s architecture in terms of layers and neurons. - Implement forward propagation to calculate the output of the network. - Implement backward propagation to adjust the weights using gradient descent. - Incorporate activation functions like sigmoid, tanh, and ReLU. 3. Verify your implementation with provided test cases and ensure its correctness. **Function Signature**: ```python class NeuralNetwork: def __init__(self, layers: list, activation: str = \'sigmoid\', learning_rate: float = 0.01) -> None: def fit(self, X: np.ndarray, y: np.ndarray, epochs: int = 1000) -> None: def predict(self, X: np.ndarray) -> np.ndarray: ``` **Expected Input and Output**: 1. **init()**: - Parameters: - `layers` (list): List of integers representing the number of neurons in each layer, including input and output layers. - `activation` (str): Activation function to use (\'sigmoid\', \'tanh\', \'relu\'). - `learning_rate` (float): Learning rate for gradient descent. - Returns: None 2. **fit()**: - Parameters: - `X` (np.ndarray): Training features. - `y` (np.ndarray): Target values. - `epochs` (int): Number of epochs to train the network. - Returns: None 3. **predict()**: - Parameters: - `X` (np.ndarray): Features to predict. - Returns: - np.ndarray: Array of predictions. **Constraints and Limitations**: - Ensure your implementation handles different activation functions appropriately. - Test your implementation on small datasets to validate the correctness. - Ensure your code is efficiently processing by monitoring training performance. **Example Usage**: ```python import numpy as np from sklearn.datasets import make_moons from sklearn.model_selection import train_test_split from sklearn.preprocessing import OneHotEncoder # Example data X, y = make_moons(n_samples=1000, noise=0.2, random_state=42) y = y.reshape(-1, 1) encoder = OneHotEncoder(sparse=False) y = encoder.fit_transform(y) X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Initialize and train the neural network nn = NeuralNetwork(layers=[2, 5, 5, 2], activation=\'relu\', learning_rate=0.01) nn.fit(X_train, y_train, epochs=2000) # Predict and measure accuracy y_pred = nn.predict(X_test) accuracy = np.mean(np.argmax(y_pred, axis=1) == np.argmax(y_test, axis=1)) print(f\\"Accuracy: {accuracy:.2f}\\") ``` **Hints**: - Use numpy for matrix operations and numerical computation. - Implement forward propagation by iterating over each layer and applying the activation function. - Implement backward propagation by calculating the derivatives of the loss function with respect to each layer\'s weights and biases. - Consider implementing a helper method for each activation function and its derivative.","solution":"import numpy as np class NeuralNetwork: def __init__(self, layers, activation=\'sigmoid\', learning_rate=0.01): self.layers = layers self.activation = activation self.learning_rate = learning_rate self.weights = [] self.biases = [] # Initialize weights and biases for i in range(len(layers) - 1): self.weights.append(np.random.randn(layers[i], layers[i+1]) * 0.1) self.biases.append(np.zeros((1, layers[i+1]))) def _activate(self, z, deriv=False): if self.activation == \'sigmoid\': if deriv: return z * (1 - z) return 1 / (1 + np.exp(-z)) elif self.activation == \'tanh\': if deriv: return 1 - np.tanh(z) ** 2 return np.tanh(z) elif self.activation == \'relu\': if deriv: return np.where(z > 0, 1, 0) return np.maximum(0, z) else: raise ValueError(\\"Unsupported activation function\\") def _forward(self, X): a = X activations = [a] zs = [] for w, b in zip(self.weights, self.biases): z = np.dot(a, w) + b zs.append(z) a = self._activate(z) activations.append(a) return activations, zs def _backward(self, activations, zs, y): delta = activations[-1] - y deltas = [delta] for i in reversed(range(len(self.weights) - 1)): delta = np.dot(delta, self.weights[i+1].T) * self._activate(activations[i+1], deriv=True) deltas.insert(0, delta) grad_w = [] grad_b = [] for i in range(len(self.weights)): grad_w.append(np.dot(activations[i].T, deltas[i])) grad_b.append(np.sum(deltas[i], axis=0, keepdims=True)) return grad_w, grad_b def fit(self, X, y, epochs=1000): for epoch in range(epochs): activations, zs = self._forward(X) grad_w, grad_b = self._backward(activations, zs, y) for i in range(len(self.weights)): self.weights[i] -= self.learning_rate * grad_w[i] self.biases[i] -= self.learning_rate * grad_b[i] def predict(self, X): activations, _ = self._forward(X) return activations[-1]"},{"question":"# Coding Assessment Question You are required to implement a function that finds the next largest number using the same digits of a given integer. The function should return the smallest number greater than the given integer which can be formed using its digits. # Function Signature ```python def next_largest_number(n: int) -> int: pass ``` # Input * `n` (int): A positive integer. # Output * Return the next largest number that can be formed with the digits of `n`. * If no such number exists, return `-1`. # Constraints * The integer `n` is between 1 and 10^9 inclusive. # Example ```python assert next_largest_number(1234) == 1243 assert next_largest_number(4321) == -1 assert next_largest_number(53421) == 54123 ``` # Explanation Given `n = 1234`: - The next largest number that can be formed by rearranging its digits is `1243`. Given `n = 4321`: - The digits are in descending order, meaning there is no larger number possible, so the function returns `-1`. # Notes * You can use additional helper functions to complete your solution. * Always consider edge cases such as when all digits are the same or in descending order.","solution":"def next_largest_number(n: int) -> int: Finds the next largest number using the same digits of the given integer n. If no such number exists, returns -1. digits = list(str(n)) length = len(digits) # Step from right to left to find the first digit that is smaller than the digit next to it for i in range(length-2, -1, -1): if digits[i] < digits[i+1]: break else: return -1 # If no such digit is found, that means the number is in descending order # Find the smallest digit on the right of the i-th digit that is larger than digits[i] for j in range(length-1, i, -1): if digits[j] > digits[i]: break # Swap the i-th and j-th digit digits[i], digits[j] = digits[j], digits[i] # Reverse the digits after the i-th position digits[i+1:] = reversed(digits[i+1:]) return int(\\"\\".join(digits))"},{"question":"# Question: Title: Happy Number Identification Write a Python function `is_happy_number(n: int) -> bool` that takes an integer as input and returns whether the number is a happy number. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle that does not include 1. Those numbers for which this process ends in 1 are happy numbers. Function Signature: ```python def is_happy_number(n: int) -> bool: ``` Input: - an integer `n` (1 ≤ n ≤ 10^9) Output: - A boolean indicating whether `n` is a happy number. Constraints: 1. The function should handle inputs up to 1 billion efficiently. 2. Negative numbers and zero are not considered happy numbers. 3. Non-integer values should raise a `ValueError`. Example: ```python assert is_happy_number(19) == True assert is_happy_number(7) == True assert is_happy_number(18) == False assert is_happy_number(1) == True assert is_happy_number(25) == False ``` Performance requirements: The function should efficiently handle the input constraints and avoid infinite loops by detecting cycles in the transformation process. Scenario: You\'ve been asked to develop a feature for a mobile app that gamifies number properties. One of the tasks for users is to identify happy numbers from a given list. Your function will be called frequently as part of the game mechanics, so it needs to be both accurate and efficient in its implementation.","solution":"def is_happy_number(n: int) -> bool: Determines if a given number is a happy number. :param n: int - The number to be checked :return: bool - True if n is a happy number, False otherwise if n <= 0: return False def get_next(number): total_sum = 0 while number > 0: digit = number % 10 total_sum += digit ** 2 number //= 10 return total_sum seen_numbers = set() while n != 1 and n not in seen_numbers: seen_numbers.add(n) n = get_next(n) return n == 1"},{"question":"# Coding Assessment Task: Log File Processor for Error Analysis Context You work as a backend developer responsible for maintaining the server\'s health. One of your regular tasks is to analyze server logs to detect error patterns. Your goal is to create a tool to automate the identification of frequent errors in the server log files. Task Write a Python function `analyze_log(file_path: str) -> Dict[str, int]` that: 1. Takes the path to a log file as input. 2. Reads the log file and extracts error messages. 3. Counts the occurrence of each unique error message. 4. Returns a dictionary with error messages as keys and their counts as values. Input Format - `file_path` (str): A string representing the path to the log file. Output Format - A dictionary mapping error messages (str) to their frequency counts (int). Constraints - Log file size can vary, but should be handled efficiently. - Assume the log file is in plain text format with each line representing one log entry. - Error messages are lines that contain the word \\"ERROR\\" or \\"error\\". - Ignore case differences when counting error messages. Example Suppose the log file contains the following lines: ``` INFO: Service started successfully ERROR: Database connection failed INFO: User login detected ERROR: Database connection failed WARNING: High memory usage detected ERROR: User authentication failed ERROR: User authentication failed INFO: Data backup completed ``` For this log file, the function should return: ```python { \\"Database connection failed\\": 2, \\"User authentication failed\\": 2 } ``` Performance Requirements - The function should process log files efficiently, minimizing memory usage where possible. Notes - Use appropriate file handling techniques to read the file. - Implement case-insensitive error detection. - Proper error handling (such as file not found, permission errors) should be incorporated.","solution":"def analyze_log(file_path): Reads a log file and counts the occurrence of each unique error message. Error messages are considered to be lines containing the word \\"ERROR\\" or \\"error\\". The comparison is case-insensitive. Args: file_path (str): A string representing the path to the log file. Returns: dict: A dictionary with error messages as keys and their counts as values. error_counts = {} try: with open(file_path, \'r\') as file: for line in file: if \'error\' in line.lower(): error_message = \' \'.join(line.split()[1:]).strip() if error_message not in error_counts: error_counts[error_message] = 0 error_counts[error_message] += 1 except Exception as e: print(f\\"Error occurred while processing the file: {e}\\") return error_counts"},{"question":"**[Question 2]: Balanced Binary Search Tree Validation** You are given a binary tree, and you need to determine if it is a balanced binary search tree (BST). A balanced BST is defined as a BST where the height of the two subtrees of every node never differs by more than one and all the nodes follow the BST property. # Task 1. **Implement a function to validate the BST property**: Write a function `is_bst` that checks whether a binary tree satisfies the BST property. 2. **Implement a function to check tree height balance**: Write a function `check_height_balance` that checks whether a binary tree is height-balanced. 3. **Combine the functions**: Write a function `is_balanced_bst` that uses `is_bst` and `check_height_balance` to determine if the given binary tree is a balanced BST. # Requirements 1. **is_bst**: - Input: The root of the binary tree. - Output: `True` if the tree satisfies the BST property, otherwise `False`. 2. **check_height_balance**: - Input: The root of the binary tree. - Output: `True` if the tree is height-balanced, otherwise `False`. 3. **is_balanced_bst**: - Input: The root of the binary tree. - Output: `True` if the tree is a balanced BST, otherwise `False`. # Constraints - The binary tree will have at most `10^4` nodes. - Node values are integers between `-10^9` and `10^9`. - Ensure efficient handling of edge cases, including empty trees and single-node trees. # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example tree construction root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(3) root.left.right = TreeNode(7) root.right.right = TreeNode(18) # Define the functions def is_bst(node, lower=float(\'-inf\'), upper=float(\'inf\')): if not node: return True if node.val <= lower or node.val >= upper: return False return is_bst(node.left, lower, node.val) and is_bst(node.right, node.val, upper) def check_height_balance(node): def height_and_balance(node): if not node: return 0, True left_height, left_balanced = height_and_balance(node.left) right_height, right_balanced = height_and_balance(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return max(left_height, right_height) + 1, balanced return height_and_balance(node)[1] def is_balanced_bst(root): return is_bst(root) and check_height_balance(root) # Validate the example tree print(is_balanced_bst(root)) # Output: True or False depending on the tree structure ``` Please implement this functionality in the most efficient way possible.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_bst(node, lower=float(\'-inf\'), upper=float(\'inf\')): if not node: return True if node.val <= lower or node.val >= upper: return False return is_bst(node.left, lower, node.val) and is_bst(node.right, node.val, upper) def check_height_balance(node): def height_and_balance(node): if not node: return 0, True left_height, left_balanced = height_and_balance(node.left) right_height, right_balanced = height_and_balance(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return max(left_height, right_height) + 1, balanced return height_and_balance(node)[1] def is_balanced_bst(root): return is_bst(root) and check_height_balance(root)"},{"question":"# Library Book Lending System Develop a function to manage a library book lending system. Implement the function `lend_book(book_id: str, user_id: str, lend_date: str, due_date: str) -> str` to handle book lending operations. The function should: 1. Check if the book is already lent out to someone else. If it is, return a message saying the book is not available. 2. Lend the book to the user and mark it as lent in the system. 3. Maintain a record of the book\'s lending history, including the current user and the due date. The system should also provide the following support functions: - `is_book_available(book_id: str) -> bool`: Checks if a book is currently available. - `return_book(book_id: str) -> str`: Marks the book as returned and updates the lending history. - `get_book_status(book_id: str) -> str`: Returns the current status of the book (e.g., available, lent out, due date, current user). **Requirements:** 1. Use an in-memory data structure to keep track of the library\'s books and their lending status. 2. The function `lend_book` should handle cases where the book or user does not exist gracefully. 3. Ensure the data structure is designed to handle multiple users and books efficiently. **Input:** * `book_id` (str): A unique identifier for a book. * `user_id` (str): A unique identifier for a user. * `lend_date` (str): The date the book was lent out (YYYY-MM-DD). * `due_date` (str): The date the book is due to be returned (YYYY-MM-DD). **Output:** * (str): A message indicating the result of the lending operation (e.g., \\"Book lent successfully.\\", \\"Book not available.\\", \\"User or book does not exist.\\"). **Constraints:** * Each book can only be lent to one user at a time. * The lending period is determined by the `due_date`. * Handle edge cases such as invalid dates and book/user IDs gracefully. **Example:** ```python # Example usage: print(lend_book(\\"book123\\", \\"user456\\", \\"2023-10-21\\", \\"2023-11-21\\")) print(lend_book(\\"book123\\", \\"user789\\", \\"2023-10-22\\", \\"2023-11-22\\")) # Should return \\"Book not available.\\" print(is_book_available(\\"book123\\")) # Should return False print(get_book_status(\\"book123\\")) # Should return \\"Lent out to user456, due date: 2023-11-21\\" print(return_book(\\"book123\\")) # Should mark the book as available and clear the lending record ``` **Note:** - Assume the system can have up to 1000 books and 1000 users. - The dates provided are valid and in the correct format.","solution":"from datetime import datetime # In-memory data structure to keep track of books and their lending status library_inventory = {} user_registry = set() def lend_book(book_id: str, user_id: str, lend_date: str, due_date: str) -> str: # Check if book or user does not exist if book_id not in library_inventory: return \\"Book does not exist.\\" if user_id not in user_registry: return \\"User does not exist.\\" # Check if book is already lent out book_details = library_inventory[book_id] if book_details.get(\\"status\\") == \\"lent\\": return \\"Book not available.\\" # Lend the book to the user library_inventory[book_id] = { \\"status\\": \\"lent\\", \\"current_user\\": user_id, \\"lend_date\\": lend_date, \\"due_date\\": due_date } return \\"Book lent successfully.\\" def is_book_available(book_id: str) -> bool: return library_inventory.get(book_id, {}).get(\\"status\\") != \\"lent\\" def return_book(book_id: str) -> str: if book_id not in library_inventory: return \\"Book does not exist.\\" # Mark the book as returned library_inventory[book_id].update({ \\"status\\": \\"available\\", \\"current_user\\": None, \\"lend_date\\": None, \\"due_date\\": None }) return \\"Book returned successfully.\\" def get_book_status(book_id: str) -> str: if book_id not in library_inventory: return \\"Book does not exist.\\" book_details = library_inventory[book_id] if book_details.get(\\"status\\") == \\"lent\\": return f\\"Lent out to {book_details[\'current_user\']}, due date: {book_details[\'due_date\']}\\" return \\"Book is available.\\" # Mock setup of books and users def setup_library(books, users): for book in books: library_inventory[book] = { \\"status\\": \\"available\\", \\"current_user\\": None, \\"lend_date\\": None, \\"due_date\\": None } for user in users: user_registry.add(user)"},{"question":"# Scenario: As a software developer, you are tasked with implementing an algorithm to simulate a simplified version of a text editor\'s undo and redo functionality. The editor supports operations like inserting characters and deleting characters, with the ability to undo the last operation and redo an undone operation. # Task: Write a class, `TextEditor`, that implements a text editor with basic edit operations and supports undo and redo functionalities. # Class Signature: ```python class TextEditor: def __init__(self): pass def insert_char(self, c: str) -> None: pass def delete_char(self) -> None: pass def undo(self) -> None: pass def redo(self) -> None: pass def get_text(self) -> str: pass ``` # Input: - `c`: A single character string to be inserted. - Each class method should be invoked with appropriate arguments as shown in the example. # Output: - The `get_text` method should return the current state of the text as a string. # Example: ```python editor = TextEditor() editor.insert_char(\'a\') editor.insert_char(\'b\') editor.insert_char(\'c\') print(editor.get_text()) # Output: \'abc\' editor.delete_char() print(editor.get_text()) # Output: \'ab\' editor.undo() print(editor.get_text()) # Output: \'abc\' editor.redo() print(editor.get_text()) # Output: \'ab\' editor.undo() editor.undo() print(editor.get_text()) # Output: \'a\' editor.redo() print(editor.get_text()) # Output: \'ab\' ``` # Notes: - Ensure the text editor maintains all edit operations in sequence to support undo and redo. - Pay attention to edge cases, such as trying to undo when there\'s no operation to undo or redo when there\'s no operation to redo. - The insert operation inserts a character at the end of the text. - The delete operation removes the last character from the text if there is any character to delete. - The class should handle multiple and consecutive undo and redo operations efficiently.","solution":"class TextEditor: def __init__(self): self.text = [] self.operations = [] self.redo_stack = [] def insert_char(self, c: str) -> None: self.text.append(c) self.operations.append((\'insert\', c)) self.redo_stack.clear() def delete_char(self) -> None: if self.text: char = self.text.pop() self.operations.append((\'delete\', char)) self.redo_stack.clear() def undo(self) -> None: if self.operations: last_op, char = self.operations.pop() if last_op == \'insert\': self.text.pop() self.redo_stack.append((\'insert\', char)) else: # last_op is \'delete\' self.text.append(char) self.redo_stack.append((\'delete\', char)) def redo(self) -> None: if self.redo_stack: last_op, char = self.redo_stack.pop() if last_op == \'insert\': self.text.append(char) self.operations.append((\'insert\', char)) else: # last_op is \'delete\' self.text.pop() self.operations.append((\'delete\', char)) def get_text(self) -> str: return \'\'.join(self.text)"},{"question":"# Coding Assessment Question Context You are developing a financial analysis tool that includes various utilities for processing transaction data. One essential feature is calculating the running balance for a stream of transactions performed in sequence. Problem Statement **Task**: Implement a `calculate_running_balance` function in Python that computes the running balance for a list of transactions, and also implement a `format_balance_summary` function that provides a formatted summary of the balances. * **Function Specifications**: - **Function 1**: `calculate_running_balance` - **Input**: A list of integers (`transactions`) where each integer represents a transaction amount (positive for deposits and negative for withdrawals). - **Output**: A list of integers representing the running balance after each transaction. - **Function 2**: `format_balance_summary` - **Input**: A list of integers (`balances`). - **Output**: A formatted string summarizing the running balances. * **Constraints**: - The transaction list can be empty. - Each transaction can be negative or positive, and should be an integer. - The balance summary should list each running balance on a new line prefixed with the transaction count. * **Performance Requirements**: - The solution should have linear complexity, O(n), where n is the number of transactions. Example Usage ```python def calculate_running_balance(transactions: list) -> list: >>> calculate_running_balance([100, -50, 200, -150, 500]) [100, 50, 250, 100, 600] >>> calculate_running_balance([]) [] def format_balance_summary(balances: list) -> str: >>> print(format_balance_summary([100, 50, 250, 100, 600])) Balance Summary: Transaction 1: 100 Transaction 2: 50 Transaction 3: 250 Transaction 4: 100 Transaction 5: 600 # Your program should be able to execute the following if __name__ == \\"__main__\\": import doctest doctest.testmod() print(format_balance_summary(calculate_running_balance([100, -50, 200, -150, 500]))) ``` **Note**: Ensure your solution passes the provided doctest cases without modifications and adheres to the constraints and specifications listed.","solution":"def calculate_running_balance(transactions): if not transactions: return [] running_balance = [] current_balance = 0 for transaction in transactions: current_balance += transaction running_balance.append(current_balance) return running_balance def format_balance_summary(balances): summary_lines = [\\"Balance Summary:\\"] for i, balance in enumerate(balances, start=1): summary_lines.append(f\\"Transaction {i}: {balance}\\") return \\"n\\".join(summary_lines)"},{"question":"# Problem Statement You are given a staircase with `n` steps, and you can either climb 1 step, 2 steps, or 3 steps at a time. In how many distinct ways can you climb to the top? Implement the function `climb_stairs(n: int) -> int` that calculates the number of distinct ways to climb a staircase with `n` steps. For example: - `climb_stairs(3) = 4` - The possible ways are: (1, 1, 1), (1, 2), (2, 1), (3) - `climb_stairs(4) = 7` - The possible ways are: (1, 1, 1, 1), (1, 1, 2), (1, 2, 1), (2, 1, 1), (2, 2), (1, 3), (3, 1) # Function Signature ```python def climb_stairs(n: int) -> int: pass ``` # Input - `n` (1 ≤ n ≤ 50): An integer representing the number of steps in the staircase. # Output - An integer representing the number of distinct ways to climb to the top of the staircase. # Constraints - The result should be computed efficiently, considering both time and space complexities. - The function should handle cases efficiently up to the given constraints. # Example ```python assert climb_stairs(3) == 4 assert climb_stairs(4) == 7 ```","solution":"def climb_stairs(n: int) -> int: Calculate the number of distinct ways to climb a staircase with n steps. You can climb 1, 2, or 3 steps at a time. if n == 0: return 1 elif n == 1: return 1 elif n == 2: return 2 elif n == 3: return 4 # Dynamic programming to store the number of ways to reach each step dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 dp[2] = 2 dp[3] = 4 for i in range(4, n + 1): dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] return dp[n]"},{"question":"# Coding Assessment Question Context You are tasked with implementing a simple in-memory database that supports basic operations for storing, retrieving, and deleting key-value pairs. The database must also support transactions with commit and rollback functionalities. Task Implement the `SimpleDB` class with the following functionalities: 1. **Set**: Store a key-value pair in the database. 2. **Get**: Retrieve the value associated with a key. 3. **Delete**: Remove a key-value pair from the database. 4. **Begin**: Start a new transaction. 5. **Commit**: Commit the current transaction, making all changes permanent. 6. **Rollback**: Rollback the current transaction, discarding all changes made since the last `Begin`. Requirements - Implement the `SimpleDB` class with all the specified methods. - Ensure that `Set`, `Get`, and `Delete` operations are efficient with an average time complexity of O(1). - Transactions should be nested, meaning you can have multiple `Begin` calls resulting in stacked transactions. Example Usage ```python db = SimpleDB() db.set(\\"x\\", 10) print(db.get(\\"x\\")) # Output: 10 db.begin() db.set(\\"x\\", 20) print(db.get(\\"x\\")) # Output: 20 db.rollback() print(db.get(\\"x\\")) # Output: 10 db.begin() db.set(\\"x\\", 20) db.commit() print(db.get(\\"x\\")) # Output: 20 db.begin() db.delete(\\"x\\") db.rollback() print(db.get(\\"x\\")) # Output: 20 ``` Input/Output Format - **Set**: Accepts a key of type `str` and a value of any type. - **Get**: Returns the value associated with a key, or `None` if the key does not exist. - **Delete**: Removes the key-value pair associated with the given key from the database. - **Begin**: Starts a new transaction. - **Commit**: Commits all changes made since the last `Begin`, making them permanent. - **Rollback**: Discards all changes made since the last `Begin`. Constraints - Keys are strings and are guaranteed to be unique within the database. - Values can be of any type. Performance - Ensure that `Set`, `Get`, and `Delete` have an average time complexity of O(1). - Transactions should be managed efficiently, with considerations for nesting and rolling back to the correct state.","solution":"class SimpleDB: def __init__(self): self._data = {} self._transaction_stack = [] def set(self, key, value): if self._transaction_stack: # Store previous value of the key before change if key not in self._transaction_stack[-1]: previous_value = self._data.get(key, None) self._transaction_stack[-1][key] = previous_value self._data[key] = value def get(self, key): return self._data.get(key, None) def delete(self, key): if self._transaction_stack: # Store previous value of the key before delete if key not in self._transaction_stack[-1]: previous_value = self._data.get(key, None) self._transaction_stack[-1][key] = previous_value if key in self._data: del self._data[key] def begin(self): self._transaction_stack.append({}) def commit(self): if not self._transaction_stack: raise Exception(\\"No transaction to commit\\") self._transaction_stack.pop() def rollback(self): if not self._transaction_stack: raise Exception(\\"No transaction to rollback\\") changes = self._transaction_stack.pop() for key, value in changes.items(): if value is None: # key did not exist before, so delete it if key in self._data: del self._data[key] else: # revert to the previous value self._data[key] = value"},{"question":"# Implement a Cache System with a Time-based Expiry You are required to design a cache system that stores key-value pairs with a specified time-to-live (TTL). The cache should support operations such as insertion, retrieval, and deletion of key-value pairs, with an automatic expiry mechanism based on the TTL value. Implementation Details: 1. Implement a `Cache` class that should support: - `put(key: str, value: Any, ttl: int) -> None`: Insert a key-value pair into the cache with a time-to-live (TTL) in seconds. The key should expire and be removed from the cache when the TTL is reached. - `get(key: str) -> Optional[Any]`: Retrieve a value by its key. If the key does not exist or has expired, return `None`. - `remove(key: str) -> None`: Remove a key-value pair from the cache by its key. 2. Ensure that keys are automatically expired and removed from the cache after their TTL has elapsed. Constraints: - The keys in the cache are unique. - The cache should handle up to 10,000 key-value pairs. - TTL values are given in seconds and are positive integers. Example Usage: ```python >>> import time >>> cache = Cache() >>> cache.put(\\"key1\\", \\"value1\\", 2) >>> assert cache.get(\\"key1\\") == \\"value1\\" >>> time.sleep(3) >>> assert cache.get(\\"key1\\") is None >>> cache.put(\\"key2\\", \\"value2\\", 5) >>> assert cache.get(\\"key2\\") == \\"value2\\" >>> cache.remove(\\"key2\\") >>> assert cache.get(\\"key2\\") is None ``` Submit your implementation with the following function and class signature: ```python from typing import Optional, Any from threading import Thread import time class Cache: def __init__(self) -> None: self.store = {} self.ttl = {} def put(self, key: str, value: Any, ttl: int) -> None: pass def get(self, key: str) -> Optional[Any]: pass def remove(self, key: str) -> None: pass ``` Ensure you handle concurrency and efficient removal of expired keys.","solution":"from typing import Optional, Any import time import threading class Cache: def __init__(self) -> None: self.store = {} self.lock = threading.Lock() def put(self, key: str, value: Any, ttl: int) -> None: expire_time = time.time() + ttl with self.lock: self.store[key] = (value, expire_time) def get(self, key: str) -> Optional[Any]: with self.lock: if key in self.store: value, expire_time = self.store[key] if time.time() < expire_time: return value else: del self.store[key] return None def remove(self, key: str) -> None: with self.lock: if key in self.store: del self.store[key]"},{"question":"# Problem Statement: Balanced String Checker You work for a company that builds systems to analyze text data for various attributes. One of the leading tasks involves ensuring strings are balanced according to specific criteria. A string is considered balanced if, for all characters that appear in the string, their appearances are balanced by the presence of matching opening and closing symbols (e.g., parentheses, curly braces, and square brackets). **Objective:** Implement a function, `is_balanced_string`, that checks whether a given string of text is balanced in terms of parentheses `()`, curly braces `{}`, and square brackets `[]`. # Function: is_balanced_string **Input:** - `text: str` - A string containing characters including opening and closing symbols. **Output:** - `bool` - `True` if the input string is balanced, `False` otherwise. # Constraints: 1. The input string can contain any printable characters, but only `()`, `{}`, and `[]` are considered for balancing. 2. Your implementation must handle any edge cases like an empty string or strings with no balancing characters. 3. The solution should efficiently handle reasonably large strings up to 1000 characters. # Example: ```python def is_balanced_string(text: str) -> bool: # Your implementation here pass # Test cases: assert is_balanced_string(\\"This is a (balanced) string.\\") == True assert is_balanced_string(\\"This is not a {balanced string.\\") == False assert is_balanced_string(\\"{[()]}\\") == True assert is_balanced_string(\\"{[(])}\\") == False assert is_balanced_string(\\"No symbols at all!\\") == True ``` Your solution should correctly validate the balance of the strings provided and consider edge cases, such as strings with no parenthetical characters or mix-matched pairs. Optimizing for readability and performance will be key in handling larger inputs within the constraints efficiently. **Good Luck!**","solution":"def is_balanced_string(text: str) -> bool: Checks if the given string text is balanced in terms of parentheses (), curly braces {}, and square brackets []. Args: text (str): Input string containing characters to be checked Returns: bool: True if the string is balanced, otherwise False stack = [] opening = {\'(\': \')\', \'{\': \'}\', \'[\': \']\'} closing = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in text: if char in opening: stack.append(char) elif char in closing: if not stack or stack[-1] != closing[char]: return False stack.pop() return not stack"},{"question":"# Matrix Operations: Determining matrix symmetry # Scenario You are working on a project that involves numerous matrix operations. One common task is to ensure that a square matrix is symmetric before using it in certain mathematical calculations. # Task Write a Python function `is_symmetric_matrix` that determines whether a given square matrix is symmetric. A matrix is symmetric if it is equal to its transpose. # Function Signature ```python def is_symmetric_matrix(matrix: List[List[float]]) -> bool ``` # Input 1. `matrix` (List[List[float]]): A 2D list representing a square matrix of size `n x n`. # Output * Returns a `bool` indicating whether the given matrix is symmetric. # Constraints 1. 1 <= n <= 1000 (where `n` is the number of rows or columns in the square matrix) 2. Elements in the matrix are floating-point numbers and within the range ([-10^3, 10^3]). # Performance Requirement * The implemented solution should have a time complexity of (O(n^2)) where (n) is the number of rows (or columns) in the matrix. * Space complexity should be (O(1)) excluding the inputs. # Example ```python matrix1 = [ [1, 2, 3], [2, 4, 5], [3, 5, 6] ] matrix2 = [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ] result1 = is_symmetric_matrix(matrix1) print(f\\"Matrix 1 is symmetric: {result1}\\") # Expected: True result2 = is_symmetric_matrix(matrix2) print(f\\"Matrix 2 is symmetric: {result2}\\") # Expected: True matrix3 = [ [2, -1, 0], [-1, 2, -1], [0, -1, 3] ] result3 = is_symmetric_matrix(matrix3) print(f\\"Matrix 3 is symmetric: {result3}\\") # Expected: True matrix4 = [ [1, 2], [3, 4] ] result4 = is_symmetric_matrix(matrix4) print(f\\"Matrix 4 is symmetric: {result4}\\") # Expected: False ``` # Notes * A matrix is symmetric if (A[i][j] = A[j][i]) for all valid indices (i, j). * Ensure that your function efficiently handles the constraint limits. * Edge cases such as a (1x1) matrix should always return True since a single element matrix is symmetric by definition.","solution":"from typing import List def is_symmetric_matrix(matrix: List[List[float]]) -> bool: Determines whether a given square matrix is symmetric. A matrix is symmetric if it is equal to its transpose. :param matrix: A 2D list representing a square matrix of size `n x n`. :return: True if the matrix is symmetric, False otherwise. n = len(matrix) for i in range(n): for j in range(i, n): if matrix[i][j] != matrix[j][i]: return False return True"},{"question":"# Problem Statement You are asked to write a function `largest_subarray_sum(arr: List[int], k: int) -> int` that finds the largest sum of any contiguous subarray of length `k` from the given list `arr`. # Input - A list `arr` of integers. (-1000 ≤ arr[i] ≤ 1000) - An integer `k` representing the length of the subarrays to consider. (1 ≤ k ≤ len(arr) ≤ 1000) # Output - An integer representing the largest sum of any contiguous subarray of length `k`. # Example ```python >>> largest_subarray_sum([1, 4, 2, 10, 23, 3, 1, 0, 20], 4) 39 >>> largest_subarray_sum([100, 200, 300, 400], 2) 700 >>> largest_subarray_sum([-1, -2, -3, -4], 2) -3 ``` # Explanation 1. In the first example, the subarrays of length `4` are `[1, 4, 2, 10]`, `[4, 2, 10, 23]`, `[2, 10, 23, 3]`, `[10, 23, 3, 1]`, and `[23, 3, 1, 0]`. The sums of these subarrays are `17`, `39`, `38`, `37`, and `27`, respectively. The largest sum is `39`. 2. In the second example, the arrays `[100, 200]`, `[200, 300]`, and `[300, 400]` have sums `300`, `500`, and `700` respectively, with `700` being the largest. 3. In the third example, since all elements are negative, the largest sum of the length `2` subarrays is `-3`. # Constraints - The function should efficiently handle the upper limit constraints.","solution":"def largest_subarray_sum(arr, k): Finds the largest sum of any contiguous subarray of length k. :param arr: List[int] - The input list of integers :param k: int - The length of the contiguous subarray :return: int - The largest sum of any contiguous subarray of length k window_sum = sum(arr[:k]) max_sum = window_sum for i in range(k, len(arr)): window_sum += arr[i] - arr[i - k] max_sum = max(max_sum, window_sum) return max_sum"},{"question":"# Question: You are tasked with implementing an algorithm to determine the number of prime numbers less than a given integer `n`. To achieve this, you will write a function that counts the prime numbers up to but not including `n`. Function Signature ```python def count_primes(n: int) -> int: pass ``` # Input: - An integer `n` (1 ≤ n ≤ 10^7), the upper limit for counting prime numbers. # Output: - An integer representing the number of prime numbers less than `n`. # Constraints: - Expect inputs within the provided range; optimize your solution accordingly for large values of `n`. # Performance Requirements: - The solution should efficiently handle the upper-bound cases where `n` can be as large as (10^7). # Examples: - `count_primes(10) -> 4` (Prime numbers less than 10 are 2, 3, 5, and 7) - `count_primes(50) -> 15` - `count_primes(100) -> 25` # Additional Context: To solve this problem efficiently, you may use the Sieve of Eratosthenes algorithm, which enables prime counting in (O(n log log n)) time complexity. Algorithm Guidance: 1. Initialize a list of boolean values representing whether each number up to `n` is prime. 2. Iterate through potential primes and mark their multiples as non-prime. 3. Count the entries in the list that remain marked as prime. Ensure that your function handles the edge cases efficiently and adheres to the problem constraints for optimum performance.","solution":"def count_primes(n: int) -> int: Returns the number of prime numbers less than the given integer n. if n <= 2: return 0 # Initialize a boolean array to mark prime numbers is_prime = [True] * n is_prime[0] = is_prime[1] = False # Implement Sieve of Eratosthenes p = 2 while p * p < n: if is_prime[p]: for i in range(p * p, n, p): is_prime[i] = False p += 1 return sum(is_prime)"},{"question":"# Problem Statement A game company is implementing a new feature that allows players to unlock achievements based on reaching specific score milestones. As part of the development team, you have been asked to create a function that calculates the player\'s achieved milestone based on their score and a list of predefined milestones. # Function Signature ```python def find_milestone(score: int, milestones: list) -> int: Find the highest milestone the player has reached based on their score. Args: score (int): The player\'s current score. milestones (list of int): A list of increasing integers representing the score milestones. Returns: int: The highest milestone the player has reached. If no milestones are reached, return -1. ``` # Input * `score`: An integer (0 ≤ score ≤ 1,000,000) representing the player\'s current score. * `milestones`: A sorted list of integers (1 ≤ len(milestones) ≤ 1000 and 1 ≤ milestones[i] ≤ 1,000,000) representing the score milestones. # Output * An integer representing the highest milestone the player has reached based on their score. If no milestones are reached, return -1. # Constraints * The milestones list is guaranteed to be sorted in ascending order. * You should use an efficient search method to determine the highest milestone reached. # Examples ```python assert find_milestone(1300, [100, 500, 1000, 1500, 2000]) == 1000 assert find_milestone(200, [300, 400, 500, 600]) == -1 assert find_milestone(5000, [1000, 2000, 3000, 4000, 5000]) == 5000 ``` # Explanation * In the first example, the player\'s score is 1300, and the highest milestone less than or equal to 1300 is 1000. * In the second example, the player\'s score is 200, which is less than the first milestone (300), so no milestones are reached and the function returns -1. * In the third example, the player\'s score exactly matches the highest milestone (5000). # Additional Context Utilize binary search or a similar efficient algorithm to quickly determine the highest milestone that has been reached based on the player\'s score. Avoid linear scans through the milestones list to ensure optimal performance.","solution":"def find_milestone(score: int, milestones: list) -> int: Find the highest milestone the player has reached based on their score. Args: score (int): The player\'s current score. milestones (list of int): A list of increasing integers representing the score milestones. Returns: int: The highest milestone the player has reached. If no milestones are reached, return -1. lo, hi = 0, len(milestones) - 1 while lo <= hi: mid = (lo + hi) // 2 if milestones[mid] == score: return milestones[mid] elif milestones[mid] < score: lo = mid + 1 else: hi = mid - 1 return milestones[hi] if hi >= 0 else -1"},{"question":"# Problem Statement Write a function `find_kth_smallest_element(matrix: List[List[int]], k: int) -> int` that takes a 2D matrix with ( n ) rows and ( n ) columns of sorted integers (sorted in non-decreasing order both row-wise and column-wise) and an integer ( k ). The function should return the k-th smallest element in the matrix. # Input Format - A 2D list `matrix` of size ( n times n ) where ( n ) is the number of rows (and columns) in the matrix. - An integer ( k ) representing the k-th smallest element to find. # Output Format - An integer representing the k-th smallest element in the matrix. # Constraints - ( 1 leq n leq 300 ) - ( 1 leq text{matrix}[i][j] leq 10^9 ) - ( 1 leq k leq n^2 ) # Performance Requirements - Your implementation should efficiently handle the maximum constraints for time and space. # Examples 1. `find_kth_smallest_element([[1, 5, 9], [10, 11, 13], [12, 13, 15]], 8)` should return `13`. 2. `find_kth_smallest_element([[10, 20, 30], [15, 25, 35], [24, 29, 37]], 5)` should return `25`. 3. `find_kth_smallest_element([[1, 2], [1, 3]], 2)` should return `1`. # Additional Notes - Ensure that the function appropriately handles invalid cases by raising the specified exceptions: - If the matrix is not a square matrix, raise a `ValueError`. - If `k` is out of the valid range, raise an `IndexError`. # Function Signature ```python def find_kth_smallest_element(matrix: List[List[int]], k: int) -> int: pass ```","solution":"import heapq from typing import List def find_kth_smallest_element(matrix: List[List[int]], k: int) -> int: Returns the k-th smallest element in an n x n sorted matrix. Parameters: matrix (List[List[int]]): The input sorted matrix. k (int): The order of the smallest element to find. Returns: int: The k-th smallest element in the matrix. Raises: ValueError: If the input matrix is not square. IndexError: If k is out of valid range. n = len(matrix) # Check if the matrix is a square matrix for row in matrix: if len(row) != n: raise ValueError(\\"The provided matrix is not a square matrix.\\") # Check if k is within valid range if not (1 <= k <= n * n): raise IndexError(\\"k is out of valid range.\\") # Use a min-heap to keep track of the minimum elements min_heap = [] for r in range(min(k, n)): # Only add up to the first k rows heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract the smallest element from the heap k-1 times count = 0 while count < k: element, r, c = heapq.heappop(min_heap) count += 1 if c + 1 < len(matrix[r]): heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return element"},{"question":"# Question: Implementing and Balancing a Binary Search Tree You are tasked with implementing a Binary Search Tree (BST) in Python with an additional feature to balance the tree. You will need to create a class to handle various operations and ensure the tree remains balanced after a series of insertions and deletions. # Task: 1. **Implement the Binary Search Tree**: - Create a class `BalancedBST` with methods to: - Insert elements into the tree. - Remove elements from the tree. - Rebalance the tree to maintain efficient operations. - Search for elements in the tree. - Print the tree in different orders (in-order, pre-order, post-order). 2. **Analyze and Test**: - Analyze the efficiency of your algorithm in terms of time and space complexity. - Write appropriate unittests to ensure that the implementation handles edge cases and performs correctly. # Specifications: - **`BalancedBST` Class**: - `__init__(self)`: Initialize an empty BST. - `insert(self, value: int) -> None`: Insert the given integer value into the BST. - `delete(self, value: int) -> None`: Remove the given integer value from the BST. - `search(self, value: int) -> bool`: Search for the given integer value in the BST. - `balance(self) -> None`: Rebalance the BST. - `print_in_order(self) -> list[int]`: Return the elements of the BST in in-order traversal. - `print_pre_order(self) -> list[int]`: Return the elements of the BST in pre-order traversal. - `print_post_order(self) -> list[int]`: Return the elements of the BST in post-order traversal. # Input and Output - **Input**: - Integer values for insertion, deletion, and search operations. - **Output**: - Balanced BST after every insertion and deletion. - Boolean value for search operation indicating the presence of the searched element. - List of elements for tree traversal operations. # Constraints: - The BST operations must maintain a balance to ensure efficient search, insertion, and deletion times. - The value to be inserted, deleted, or searched for will be an integer. # Example: ```python # Initialize an empty BalancedBST bst = BalancedBST() # Insert elements bst.insert(10) bst.insert(5) bst.insert(20) bst.insert(3) bst.insert(7) bst.insert(30) # Search for an element print(bst.search(7)) # Output: True # Delete an element bst.delete(5) # Rebalance the BST bst.balance() # Print elements in different orders print(bst.print_in_order()) # Output: [3, 7, 10, 20, 30] print(bst.print_pre_order()) # Output: [10, 3, 7, 20, 30] print(bst.print_post_order()) # Output: [3, 7, 30, 20, 10] ``` # Deliverables: - The complete implementation of `BalancedBST`. - Analysis of the implemented code regarding its time and space complexity. - Unittests to validate correct operation of the BST for edge cases and general cases.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BalancedBST: def __init__(self): self.root = None def insert(self, value): self.root = self._insert(self.root, value) def _insert(self, node, value): if node is None: return TreeNode(value) elif value < node.value: node.left = self._insert(node.left, value) else: node.right = self._insert(node.right, value) return node def delete(self, value): self.root = self._delete(self.root, value) def _delete(self, node, value): if node is None: return node if value < node.value: node.left = self._delete(node.left, value) elif value > node.value: node.right = self._delete(node.right, value) else: if node.left is None: return node.right elif node.right is None: return node.left min_larger_node = self._get_min(node.right) node.value = min_larger_node.value node.right = self._delete(node.right, min_larger_node.value) return node def search(self, value): return self._search(self.root, value) is not None def _search(self, node, value): if node is None or node.value == value: return node if value < node.value: return self._search(node.left, value) return self._search(node.right, value) def balance(self): values = self.print_in_order() self.root = self._build_balanced_tree(values) def _build_balanced_tree(self, values): if not values: return None mid = len(values) // 2 node = TreeNode(values[mid]) node.left = self._build_balanced_tree(values[:mid]) node.right = self._build_balanced_tree(values[mid+1:]) return node def print_in_order(self): res = [] self._in_order(self.root, res) return res def _in_order(self, node, res): if node: self._in_order(node.left, res) res.append(node.value) self._in_order(node.right, res) def print_pre_order(self): res = [] self._pre_order(self.root, res) return res def _pre_order(self, node, res): if node: res.append(node.value) self._pre_order(node.left, res) self._pre_order(node.right, res) def print_post_order(self): res = [] self._post_order(self.root, res) return res def _post_order(self, node, res): if node: self._post_order(node.left, res) self._post_order(node.right, res) res.append(node.value) def _get_min(self, node): while node.left: node = node.left return node"},{"question":"Question: Implement a function to detect cycles in a directed graph using DFS You are given a directed graph represented as a dictionary where keys are node labels, and values are lists of adjacent nodes. Write a class `DirectedGraph` with the following methods: 1. **Constructor `__init__(self, graph: dict[str, list[str]])`**: - Initializes the graph. 2. **Method `detect_cycle(self) -> bool`**: - Returns `True` if there is a cycle in the graph, and `False` otherwise. # Example ```python graph_with_cycle = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"A\\"], } graph_without_cycle = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"C\\"], \\"C\\": [], } # Case 1: Graph with a cycle g1 = DirectedGraph(graph_with_cycle) print(g1.detect_cycle()) # Output: True # Case 2: Graph without a cycle g2 = DirectedGraph(graph_without_cycle) print(g2.detect_cycle()) # Output: False ``` # Constraints - The graph is directed and may or may not contain cycles. - All vertex names are unique and consist of uppercase or lowercase English letters. - The node letters are guaranteed to be valid keys in the graph dictionary. Use these constraints and aspects to guide your implementation process.","solution":"class DirectedGraph: def __init__(self, graph: dict[str, list[str]]): Initializes the directed graph. :param graph: A dictionary representing the graph where the keys are nodes and the values are lists of adjacent nodes. self.graph = graph def detect_cycle(self) -> bool: Detects if there is a cycle in the directed graph. :returns: True if a cycle is detected, False otherwise. def dfs(node, visited, rec_stack): visited[node] = True rec_stack[node] = True for neighbor in self.graph.get(node, []): if not visited[neighbor]: # If the neighbor hasn\'t been visited yet if dfs(neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: # If the neighbor is in the recursion stack return True rec_stack[node] = False # Remove the node from the recursion stack return False visited = {node: False for node in self.graph} rec_stack = {node: False for node in self.graph} for node in self.graph: if not visited[node]: # If the node hasn\'t been visited yet if dfs(node, visited, rec_stack): return True return False"},{"question":"# Count Primes Given an integer `n`, write a function that returns the number of prime numbers less than `n`. Function Signature: ```python def count_primes(n: int) -> int: pass ``` Input * `n` (Int): A non-negative integer (0 ≤ n ≤ 10^6). Output * An integer representing the number of prime numbers less than `n`. Constraints 1. The function should run efficiently for large values of `n`. Example ```python assert count_primes(10) == 4 # Primes are [2, 3, 5, 7] assert count_primes(0) == 0 # No prime numbers less than 0 assert count_primes(1) == 0 # No prime numbers less than 1 assert count_primes(2) == 0 # No prime numbers less than 2 assert count_primes(100) == 25 # Primes are [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] ``` # Explanation: * For an input of `n = 10`, the prime numbers less than 10 are [2, 3, 5, 7]. * The function should utilize algorithms like the Sieve of Eratosthenes for efficient prime counting for large `n`. Implementation Steps 1. If `n` is less than or equal to 2, immediately return 0 as no primes exist below 2. 2. Create a list to track prime status for each number up to `n-1`. 3. Use the Sieve of Eratosthenes to mark non-prime numbers in the list. 4. Count the number of `True` values in the list representing prime numbers less than `n` and return this count.","solution":"def count_primes(n: int) -> int: Returns the number of prime numbers less than n. if n <= 2: return 0 # Initialize a list to track the prime status is_prime = [True] * n is_prime[0] = is_prime[1] = False # 0 and 1 are not primes # Sieve of Eratosthenes for i in range(2, int(n**0.5) + 1): if is_prime[i]: for j in range(i * i, n, i): is_prime[j] = False # Count the number of primes return sum(is_prime)"},{"question":"# Sparse Matrix Multiplication Implementation **Context**: You are given two sparse matrices. A sparse matrix is a matrix in which most of the elements are zero. As such, using conventional matrix multiplication methods would be inefficient both in terms of time and space complexity. You aim to implement an efficient algorithm to multiply two sparse matrices. # Task: 1. **Input Parsing**: Implement a function to parse the input sparse matrices represented in a specific format. 2. **Sparse Matrix Multiplication**: Implement an efficient algorithm to multiply the two sparse matrices. 3. **Output Result**: Generate the resultant sparse matrix in the specified format. # Inputs: - **matrix1**: First sparse matrix represented as a list of tuples. Each tuple contains three values (i, j, val), where `i` is the row index, `j` is the column index, and `val` is the non-zero value at position (i, j). The matrix is guaranteed to be non-empty and valid. - **matrix2**: Second sparse matrix represented similarly to `matrix1`. # Expected Output: - Return the resultant sparse matrix in the same format as the input matrices. # Code Constraints: - Use efficient data structures to minimize space and time complexity. - Ensure your code can handle large sparse matrices. Here is the skeleton of the program you need to implement: ```python def parse_input(matrix): Convert the list of tuples representation to a sparse matrix dictionary. sparse_matrix = {} for i, j, val in matrix: if i not in sparse_matrix: sparse_matrix[i] = {} sparse_matrix[i][j] = val return sparse_matrix def multiply_sparse_matrices(matrix1, matrix2): Multiply two sparse matrices and return the result as a list of tuples. sparse_matrix1 = parse_input(matrix1) sparse_matrix2 = parse_input(matrix2) result = {} for i in sparse_matrix1: for k in sparse_matrix1[i]: if k in sparse_matrix2: for j in sparse_matrix2[k]: if i not in result: result[i] = {} if j not in result[i]: result[i][j] = 0 result[i][j] += sparse_matrix1[i][k] * sparse_matrix2[k][j] result_list = [(i, j, result[i][j]) for i in result for j in result[i] if result[i][j] != 0] return result_list def main(): matrix1 = [ (0, 0, 1), (0, 4, 2), (1, 1, 3), (3, 2, 4) ] matrix2 = [ (0, 1, 5), (1, 2, 6), (2, 0, 7), (4, 0, 8) ] result = multiply_sparse_matrices(matrix1, matrix2) print(\\"Resultant Sparse Matrix: \\") for entry in result: print(entry) if __name__ == \\"__main__\\": main() ``` # Evaluation - You will be evaluated on correctly parsing the input matrices and implementing the sparse matrix multiplication efficiently. - Properly handling edge cases and ensuring correctness of the resultant matrix format. - Clear and concise code with appropriate function naming and comments.","solution":"def parse_input(matrix): Convert the list of tuples representation to a sparse matrix dictionary. sparse_matrix = {} for i, j, val in matrix: if i not in sparse_matrix: sparse_matrix[i] = {} sparse_matrix[i][j] = val return sparse_matrix def multiply_sparse_matrices(matrix1, matrix2): Multiply two sparse matrices and return the result as a list of tuples. sparse_matrix1 = parse_input(matrix1) sparse_matrix2 = parse_input(matrix2) result = {} for i in sparse_matrix1: for k in sparse_matrix1[i]: if k in sparse_matrix2: for j in sparse_matrix2[k]: if i not in result: result[i] = {} if j not in result[i]: result[i][j] = 0 result[i][j] += sparse_matrix1[i][k] * sparse_matrix2[k][j] result_list = [(i, j, result[i][j]) for i in result for j in result[i] if result[i][j] != 0] return result_list"},{"question":"# Problem Statement Write a function `binary_search` to implement the binary search algorithm. The function should take a list of integers `collection` and an integer `target` as its inputs and return the index of the `target` if found. If the `target` is not found, the function should return `-1`. # Input Format - A single list `collection` of integers where ( 0 leq text{length of collection} leq 10^4 ). - Each integer in the list is in the range ( -10^9 leq x leq 10^9 ). - The list `collection` will be sorted in ascending order. - An integer `target` in the range ( -10^9 leq x leq 10^9 ). # Output Format - An integer representing the index of the `target` if found. - If the `target` is not found in the list, return `-1`. # Constraints - The function should run in ( O(log n) ) time complexity. - Do not use any built-in functions that directly perform binary search. # Example Input ```python collection = [1, 3, 5, 7, 9, 11] target = 5 ``` Output ```python 2 ``` Input ```python collection = [-12, -5, 0, 3, 8, 15, 20] target = 3 ``` Output ```python 3 ``` Input ```python collection = [2, 4, 6, 8, 10, 12, 14] target = 5 ``` Output ```python -1 ``` Note The assumption is that the input list is already sorted. The binary search algorithm reduces the search space by half with each step, leading to its efficiency ( O(log n) ). Ensure that the function handles edge cases, such as an empty list or a list with only one element, correctly.","solution":"def binary_search(collection, target): The function takes a list of integers \'collection\' and an integer \'target\', and returns the index of \'target\' if found, else returns -1. The input list \'collection\' is assumed to be sorted in ascending order. left = 0 right = len(collection) - 1 while left <= right: mid = (left + right) // 2 if collection[mid] == target: return mid elif collection[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Task You need to create a function to implement a simple `Cache`. This cache should store key-value pairs with a fixed capacity. Whenever the cache exceeds its capacity, it should evict the least recently used (LRU) item. # Function Signature ```python class SimpleCache: def __init__(self, capacity: int): pass def put(self, key: int, value: int) -> None: pass def get(self, key: int) -> int: pass def __str__(self) -> str: pass ``` # Requirements 1. **Initialization**: - The constructor should accept `capacity`, indicating the maximum number of key-value pairs the cache can store. - Initialize internal structures to manage the cache and track usage. 2. **Put**: - Stores the key-value pair in the cache. - If the cache exceeds its capacity, evicts the least recently used item before adding the new key-value pair. - If the key already exists, updates the value and marks it as most recently used. 3. **Get**: - Returns the value associated with the key. - Marks the key as most recently used. - Should return `-1` if the key is not found in the cache. 4. **String Representation**: - Implement `__str__` method to return the current state of the cache as a formatted string of key-value pairs, ordered from most to least recently used. # Example Usage ```python sc = SimpleCache(3) sc.put(1, 10) sc.put(2, 20) sc.put(3, 30) print(sc) # Should display: [(3, 30), (2, 20), (1, 10)] print(sc.get(2)) # 20 print(sc) # Should display: [(2, 20), (3, 30), (1, 10)] sc.put(4, 40) print(sc) # Should display: [(4, 40), (2, 20), (3, 30)], (1, 10) should be evicted print(sc.get(1)) # -1, since key 1 was evicted print(sc.get(3)) # 30 print(sc) # Should display: [(3, 30), (4, 40), (2, 20)] ``` # Constraints and Limits - The maximum cache capacity is 1000. - The keys are integers with values ranging from 0 to 10000. - The values are integers ranging from -100000 to 100000. - Any invalid operations (e.g., exceeding capacity, accessing non-existent keys) should be handled gracefully.","solution":"from collections import OrderedDict class SimpleCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.pop(key) elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) self.cache[key] = value def get(self, key: int) -> int: if key in self.cache: value = self.cache.pop(key) self.cache[key] = value return value return -1 def __str__(self) -> str: return str(list(self.cache.items()))"},{"question":"# Problem Scenario You are tasked with maintaining a list of tasks for a project. Each task is represented as a tuple containing the task name and its priority level, where a lower number indicates higher priority. To effectively manage the project, you need to sort the tasks based on their priority levels in ascending order. # Task Write a function `sort_tasks_by_priority(tasks: list) -> list`. Your function should: 1. Take as input a list of tuples, where each tuple represents a task consisting of a string (task name) and an integer (priority level). 2. Return a list of tasks sorted by their priority levels in ascending order. 3. Ensure that the original task order is preserved for tasks with the same priority level. # Expected Input and Output Input: * A list of tuples, `tasks`. - Example: `[(\\"task1\\", 3), (\\"task2\\", 1), (\\"task3\\", 2), (\\"task4\\", 1)]` Output: * A list of tuples sorted by priority levels. - Example: `[(\\"task2\\", 1), (\\"task4\\", 1), (\\"task3\\", 2), (\\"task1\\", 3)]` # Constraints: * The length of the list will be at most 5,000. * Task priorities will be non-negative integers. * Task names will be unique and non-empty strings. # Performance Requirements: * Your solution should efficiently handle the sorting within the given constraints. # Example ```python def sort_tasks_by_priority(tasks: list) -> list: # Implement the sorting logic as discussed pass # Example usage: print(sort_tasks_by_priority([(\\"task1\\", 3), (\\"task2\\", 1), (\\"task3\\", 2), (\\"task4\\", 1)])) # Output: [(\\"task2\\", 1), (\\"task4\\", 1), (\\"task3\\", 2), (\\"task1\\", 3)] ``` Provide your implementation of the `sort_tasks_by_priority()` function to sort tasks by their priority levels accordingly.","solution":"def sort_tasks_by_priority(tasks: list) -> list: Sorts a list of tasks by their priority levels in ascending order. Parameters: tasks (list): A list of tuples, where each tuple represents a task consisting of a string (task name) and an integer (priority level). Returns: list: A list of tasks sorted by priority levels in ascending order. return sorted(tasks, key=lambda x: x[1])"},{"question":"# Scenario Let\'s assume you are developing a tool for geospatial analysis that needs to determine whether points lie within specific geographic boundaries. This capability is essential for processing geographic data, identifying regions of interest, and performing spatial queries effectively. # Task Write a function `is_point_in_polygon` that verifies if a given point lies inside a polygon represented by a series of coordinates that form its vertices. You can implement the Ray-Casting algorithm for this task. # Expected Function Signature ```python def is_point_in_polygon(point: tuple, polygon: list) -> bool: pass ``` # Input - `point`: A tuple of two floats representing the x and y coordinates of the point (e.g., `(3.5, 7.2)`). - `polygon`: A list of tuples, where each tuple contains two floats representing the x and y coordinates of the polygon\'s vertices in order (e.g., `[(1.0, 1.0), (5.0, 1.0), (5.0, 5.0), (1.0, 5.0)]`). # Output - Returns `True` if the point is inside the polygon, and `False` otherwise. # Constraints - The polygon will always be a simple polygon (no self-intersections). - The polygon will have at least three vertices. - Coordinates can be positive or negative floating-point numbers. - Assume the point is neither on the boundary nor at the vertex of the polygon. # Example ```python assert is_point_in_polygon((3.0, 3.0), [(1.0, 1.0), (5.0, 1.0), (5.0, 5.0), (1.0, 5.0)]) == True assert is_point_in_polygon((6.0, 3.0), [(1.0, 1.0), (5.0, 1.0), (5.0, 5.0), (1.0, 5.0)]) == False assert is_point_in_polygon((-2.0, 4.0), [(-3.0, 1.0), (-1.0, 1.0), (-1.0, 4.0), (-3.0, 4.0)]) == True ``` # Notes 1. You can assume that floating-point arithmetic provides sufficient precision for determining point positions relative to polygon edges. 2. Do not use any external libraries; only built-in Python functionality is allowed.","solution":"def is_point_in_polygon(point: tuple, polygon: list) -> bool: Determines if a point is inside a polygon using the ray-casting algorithm. Args: point (tuple): The point to test, given as (x, y). polygon (list): A list of tuples representing the vertices of the polygon. Returns: bool: True if the point is inside the polygon, False otherwise. x, y = point n = len(polygon) inside = False px, py = polygon[0] for i in range(1, n + 1): cx, cy = polygon[i % n] if y > min(py, cy): if y <= max(py, cy): if x <= max(px, cx): if py != cy: xinters = (y - py) * (cx - px) / (cy - py) + px if px == cx or x <= xinters: inside = not inside px, py = cx, cy return inside"},{"question":"Context: In this task, you will further your skills in working with binary search algorithms and demonstrate your understanding of time complexity analysis. You are required to implement a binary search method within a sorted list of integers. Additionally, you will handle edge cases and implement optimizations for better search performance. # Task: 1. Implement a method `binary_search(self, target: int) -> int` that searches for a target integer within the sorted list stored in the class instance and returns its index if found. If the target is not found, return `-1`. 2. Implement a method `insert(self, value: int) -> None` that inserts a new integer into the correct position in the sorted list to maintain the order. 3. Implement a method `remove(self, value: int) -> bool` that removes the first occurrence of the specified integer from the sorted list. Return `True` if the element is successfully removed, otherwise return `False` if the value is not found. # Function Signature: ```python def binary_search(self, target: int) -> int: Searches for the target integer and returns its index, or -1 if not found. def insert(self, value: int) -> None: Inserts a new integer into the sorted list while maintaining order. def remove(self, value: int) -> bool: Removes the first occurrence of the specified integer from the sorted list. ``` # Input & Output Formats: * The `binary_search` method takes an integer `target` and returns the index (int) of the target or `-1` if not found. * The `insert` method takes an integer `value` and returns `None`. It modifies the list in place. * The `remove` method takes an integer `value` and returns a boolean indicating success or failure of the operation. # Constraints: * The `binary_search` method should have a time complexity of O(log n). * The `insert` method should handle edge cases such as inserting into an empty list or adding a duplicate value. * The `remove` method should handle removal of non-existent elements gracefully. # Performance Requirements: * The binary search should operate within O(log n) time complexity. * The insertion and removal methods should maintain the list\'s sorted order efficiently. # Example: ```python # Initialize sorted list sl = SortedList([1, 3, 5, 7, 9]) # Perform binary search for 5 print(sl.binary_search(5)) # Expected Output: 2 # Insert new value 6 sl.insert(6) print(sl.list) # Expected Output: [1, 3, 5, 6, 7, 9] # Remove value 3 print(sl.remove(3)) # Expected Output: True print(sl.list) # Expected Output: [1, 5, 6, 7, 9] # Try to remove value 10 print(sl.remove(10)) # Expected Output: False ```","solution":"class SortedList: def __init__(self, elements): self.list = elements def binary_search(self, target: int) -> int: Searches for the target integer and returns its index, or -1 if not found. left, right = 0, len(self.list) - 1 while left <= right: mid = (left + right) // 2 if self.list[mid] == target: return mid elif self.list[mid] < target: left = mid + 1 else: right = mid - 1 return -1 def insert(self, value: int) -> None: Inserts a new integer into the sorted list while maintaining order. if not self.list: self.list.append(value) return for i in range(len(self.list)): if self.list[i] >= value: self.list.insert(i, value) return self.list.append(value) def remove(self, value: int) -> bool: Removes the first occurrence of the specified integer from the sorted list. index = self.binary_search(value) if index != -1: self.list.pop(index) return True return False"},{"question":"# AVL Tree - Insertion and Height Calculation Background: An AVL Tree is a self-balancing binary search tree where the difference in heights of the left and right subtrees of any node is no more than one. The tree rotates to maintain balance during insertions, ensuring O(log n) time complexity for insertion and height calculation operations. Task: 1. **Insert into AVL Tree**: Implement code to insert a new key into an AVL Tree while maintaining its balanced property. 2. **Calculate Height**: Write a function to calculate and return the height of the AVL Tree after each insertion. Function Signatures: 1. `insert_avl(root: \'AVLNode\', key: int) -> \'AVLNode\'` * **Input**: * `root` - The root node of the AVL Tree. * `key` - The key to be inserted into the AVL Tree. * **Output**: * The new root node of the AVL Tree after the insertion and rebalancing. 2. `calculate_height(root: \'AVLNode\') -> int` * **Input**: * `root` - The root node of the AVL Tree. * **Output**: * The height of the AVL Tree. # AVL Tree Node Class: ```python class AVLNode: def __init__(self, key: int): self.key = key self.left = None self.right = None self.height = 1 # Initial height of the node ``` Constraints: * All keys are unique. * The number of insertions `n` is such that 1 ≤ n ≤ 1000. * The key values are integers within the range 1 ≤ key ≤ 10^5. Example: ```python # Create AVLNode structure and implement \'insert_avl\' and \'calculate_height\' functions. # Example insertions keys = [10, 20, 30, 40, 50, 25] root = None for key in keys: root = insert_avl(root, key) height = calculate_height(root) print(f\\"Inserted: {key}, Height: {height}\\") # Expected output will be heights of the AVL tree after each insertion showcasing rebalancing. # Output example might look like: # Inserted: 10, Height: 1 # Inserted: 20, Height: 2 # Inserted: 30, Height: 2 # Inserted: 40, Height: 3 # Inserted: 50, Height: 4 # Inserted: 25, Height: 3 ``` Notes: * You need to implement the necessary rotations (left, right, left-right, and right-left) to maintain AVL Tree balance after each insertion. * Ensure to update the height of each node after rebalancing the tree. * Carefully handle the height updating logic to ensure the tree remains balanced at all times.","solution":"class AVLNode: def __init__(self, key: int): self.key = key self.left = None self.right = None self.height = 1 # Initial height of the node def get_height(node): if not node: return 0 return node.height def update_height(node): if node: node.height = 1 + max(get_height(node.left), get_height(node.right)) def get_balance(node): if not node: return 0 return get_height(node.left) - get_height(node.right) def rotate_right(y: AVLNode) -> AVLNode: x = y.left T2 = x.right x.right = y y.left = T2 update_height(y) update_height(x) return x def rotate_left(x: AVLNode) -> AVLNode: y = x.right T2 = y.left y.left = x x.right = T2 update_height(x) update_height(y) return y def insert_avl(root: AVLNode, key: int) -> AVLNode: if not root: return AVLNode(key) if key < root.key: root.left = insert_avl(root.left, key) else: root.right = insert_avl(root.right, key) update_height(root) balance = get_balance(root) # Left Left Case if balance > 1 and key < root.left.key: return rotate_right(root) # Right Right Case if balance < -1 and key > root.right.key: return rotate_left(root) # Left Right Case if balance > 1 and key > root.left.key: root.left = rotate_left(root.left) return rotate_right(root) # Right Left Case if balance < -1 and key < root.right.key: root.right = rotate_right(root.right) return rotate_left(root) return root def calculate_height(root: AVLNode) -> int: return get_height(root)"},{"question":"Coding Assessment Question **Title**: Design and Implement a Circular Buffer **Objective**: To evaluate the student\'s understanding of data structures, specifically circular buffers, and their ability to implement such a structure in Python. Problem Statement: A circular buffer, also known as a ring buffer, is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end. This structure allows for efficient use of space and can be ideal for certain applications like buffering data streams. Your task is to design a CircularBuffer class that supports typical operations such as adding an item, removing an item, checking if the buffer is empty or full, and peeking at the next item to be removed without removing it. Here are the steps to complete the task: 1. Understand the required attributes for the `CircularBuffer` class. 2. Implement methods including: - `__init__(self, size: int)` - `is_full(self) -> bool` - `is_empty(self) -> bool` - `add(self, item: Any) -> None` - `remove(self) -> Any` - `peek(self) -> Any` 3. Ensure your implementation handles edge cases such as adding to a full buffer or removing from an empty buffer. Function Signatures ```python class CircularBuffer: def __init__(self, size: int): ... def is_full(self) -> bool: ... def is_empty(self) -> bool: ... def add(self, item: Any) -> None: ... def remove(self) -> Any: ... def peek(self) -> Any: ... ``` Input - The buffer size provided during initialization and the items added to the buffer through the `add` method. Output - Various methods will return different types of output: - `is_full`: Returns a `bool` indicating whether the buffer is full. - `is_empty`: Returns a `bool` indicating whether the buffer is empty. - `add`: Adds an item to the buffer and returns `None`. - `remove`: Removes and returns the next item from the buffer. - `peek`: Returns the next item to be removed from the buffer without removing it. Constraints - The buffer size provided during initialization must be a positive integer. - Methods should handle edge cases such as adding to a full buffer or removing from an empty buffer by raising appropriate exceptions. Examples ```python # Example 1: Basic operations buffer = CircularBuffer(3) assert buffer.is_empty() == True buffer.add(1) buffer.add(2) buffer.add(3) assert buffer.is_full() == True assert buffer.remove() == 1 assert buffer.remove() == 2 buffer.add(4) assert buffer.peek() == 3 assert buffer.remove() == 3 assert buffer.remove() == 4 assert buffer.is_empty() == True # Example 2: Adding to a full buffer buffer = CircularBuffer(2) buffer.add(1) buffer.add(2) try: buffer.add(3) except OverflowError as e: assert str(e) == \\"Buffer is full.\\" # Example 3: Removing from an empty buffer buffer = CircularBuffer(2) try: buffer.remove() except IndexError as e: assert str(e) == \\"Buffer is empty.\\" ``` **Notes** - Ensure your implementation includes proper exception handling for edge cases. - Use the principles of clean coding in Python and ensure your code follows good practices.","solution":"class CircularBuffer: def __init__(self, size: int): if size <= 0: raise ValueError(\\"Size must be greater than 0.\\") self.size = size self.buffer = [None] * size self.start = 0 self.end = 0 self.is_full_flag = False def is_full(self) -> bool: return self.is_full_flag def is_empty(self) -> bool: return (self.start == self.end) and not self.is_full_flag def add(self, item): if self.is_full(): raise OverflowError(\\"Buffer is full.\\") self.buffer[self.end] = item self.end = (self.end + 1) % self.size if self.end == self.start: self.is_full_flag = True def remove(self): if self.is_empty(): raise IndexError(\\"Buffer is empty.\\") item = self.buffer[self.start] self.buffer[self.start] = None self.start = (self.start + 1) % self.size self.is_full_flag = False return item def peek(self): if self.is_empty(): raise IndexError(\\"Buffer is empty.\\") return self.buffer[self.start]"},{"question":"# Question: You are tasked with writing a function `robot_moves` that determines the final position of a robot on a 2D plane after a series of movements. The robot starts at the origin point `(0, 0)` and can move up, down, left, or right controlled by a sequence of commands. **Function Signature**: ```python def robot_moves(commands: str) -> Tuple[int, int]: # implement the function ``` # Requirements: 1. **Input Format**: - `commands` : A string consisting of characters \'U\', \'D\', \'L\', and \'R\' that correspond to the movements Up, Down, Left, and Right respectively. 2. **Output Format**: - A tuple `(x, y)` representing the final position of the robot on the 2D plane. # Constraints: - The `commands` string length will be in the range `1` to `10^6`. # Performance Requirements: - The algorithm should execute efficiently for large input sizes. # Movements: - \'U\' (Up) : Increase the y-coordinate by 1. - \'D\' (Down) : Decrease the y-coordinate by 1. - \'L\' (Left) : Decrease the x-coordinate by 1. - \'R\' (Right) : Increase the x-coordinate by 1. # Example: ```python final_position = robot_moves(\\"UUDDLRLR\\") print(final_position) # Output should be (0, 0) ``` # Function Behavior: 1. Iterate through each command in the input string. 2. Adjust the x and y coordinates accordingly based on the command. 3. Return the final coordinates after processing all commands. # Additional Notes: - Ensure the solution handles the maximum possible length of the commands efficiently. - Consider edge cases where commands might be highly repetitive or lead the robot far from the origin. # Hints: * Utilizing a dictionary to map commands to their respective movements can simplify the implementation. * A counter for each direction can also be employed for optimized performance.","solution":"from typing import Tuple def robot_moves(commands: str) -> Tuple[int, int]: x, y = 0, 0 # Starting at the origin (0, 0) # Loop over each command character for command in commands: if command == \'U\': y += 1 elif command == \'D\': y -= 1 elif command == \'L\': x -= 1 elif command == \'R\': x += 1 return (x, y)"},{"question":"# Problem Statement In many applications, it is essential to perform matrix operations efficiently. One common operation is the multiplication of two matrices. Your task is to implement matrix multiplication without using any built-in library functions that perform matrix operations. # Implement the Function ```python def matrix_multiply(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: Multiplies two matrices and returns the resulting matrix. Parameters: - matrix_a (List[List[int]]): The first matrix. - matrix_b (List[List[int]]): The second matrix. Returns: - result (List[List[int]]): The resulting matrix after multiplication. Example: >>> matrix_a = [ ... [1, 2], ... [3, 4], ... ] >>> matrix_b = [ ... [5, 6], ... [7, 8], ... ] >>> matrix_multiply(matrix_a, matrix_b) [[19, 22], [43, 50]] >>> matrix_a = [ ... [2, 4, 1], ... [0, 1, 0], ... [1, 2, 3] ... ] >>> matrix_b = [ ... [1, 2], ... [3, 4], ... [5, 6] ... ] >>> matrix_multiply(matrix_a, matrix_b) [[19, 26], [3, 4], [22, 28]] Constraints: - The number of columns in `matrix_a` must be equal to the number of rows in `matrix_b`. - The matrices can contain any integer values. pass ``` # Requirements: 1. **Matrix Dimensions**: * Ensure the matrices are compatible for multiplication (the number of columns in `matrix_a` should equal the number of rows in `matrix_b`). 2. **Computation**: * Compute the resultant matrix by multiplying the rows of `matrix_a` with the columns of `matrix_b`. 3. **Edge Cases**: * Handle cases where matrices are not compatible for multiplication by raising an appropriate error or returning an empty list. Implement the `matrix_multiply` function as described. Use the provided test cases to ensure your function works correctly.","solution":"from typing import List def matrix_multiply(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: # Check if matrices can be multiplied if len(matrix_a[0]) != len(matrix_b): raise ValueError(\\"Number of columns in matrix_a must be equal to number of rows in matrix_b.\\") result = [[0 for _ in range(len(matrix_b[0]))] for _ in range(len(matrix_a))] for i in range(len(matrix_a)): for j in range(len(matrix_b[0])): for k in range(len(matrix_b)): result[i][j] += matrix_a[i][k] * matrix_b[k][j] return result"},{"question":"# Context: In a software system, managing employee schedules and ensuring no overlap between work shifts is crucial. This problem involves checking and managing overlapping time intervals for a set of employee work shifts. You will need to develop a function that identifies if any two shifts overlap. # Objective: Write a function `has_overlapping_shifts(shifts: List[Tuple[str, str]]) -> bool` that determines if there are any overlapping work shifts in a given list of schedules. Each shift is represented by a tuple of start and end times in the format \\"HH:MM\\". # Input: - A list of tuples `shifts`, where each tuple consists of two strings representing the start and end times (in 24-hour format) of an employee\'s work shift. # Output: - A boolean value: `True` if there are any overlapping shifts, `False` otherwise. # Constraints: - The format for each time string is \\"HH:MM\\", where HH is a two-digit hour (00 to 23) and MM is a two-digit minute (00 to 59). - `shifts` is a non-empty list that can have up to 1000 shifts. # Function Signature: ```python def has_overlapping_shifts(shifts: List[Tuple[str, str]]) -> bool: ``` # Examples: 1. `has_overlapping_shifts([(\\"09:00\\", \\"11:00\\"), (\\"10:00\\", \\"12:00\\"), (\\"11:00\\", \\"13:00\\")]) -> True` 2. `has_overlapping_shifts([(\\"08:00\\", \\"10:00\\"), (\\"10:00\\", \\"12:00\\"), (\\"12:00\\", \\"14:00\\")]) -> False` 3. `has_overlapping_shifts([(\\"14:00\\", \\"16:00\\"), (\\"15:00\\", \\"17:00\\"), (\\"16:00\\", \\"18:00\\")]) -> True` # Explanation: Your task is to determine if there are any overlapping work shifts among the provided list. Two shifts are considered overlapping if they share any common time duration. Implement your function to efficiently check for overlapping intervals. # Notes: - You may assume the input list is not empty and contains valid time intervals. - Consider edge cases, such as shifts that start exactly when another ends. - Optimize for performance given the potential size of the input list. # Implementation Plan: - Parse the start and end times of each shift. - Sort the shifts based on start time. - Compare each shift with the next one to check for overlaps. - Return `True` if any overlap is found; otherwise, return `False`. Create your implementation of the function and describe the logic used to ensure accurate and efficient detection of overlapping shifts.","solution":"from typing import List, Tuple def has_overlapping_shifts(shifts: List[Tuple[str, str]]) -> bool: Determines if there are any overlapping work shifts in the provided list. :param shifts: List of tuples, each containing start and end times (in \\"HH:MM\\" format) of work shifts. :return: True if any shifts overlap, False otherwise. # Convert times to a comparable format and sort shifts based on start times shifts = sorted(shifts, key=lambda shift: shift[0]) for i in range(len(shifts) - 1): # Compare the end time of the current shift with the start time of the next shift if shifts[i][1] > shifts[i + 1][0]: return True return False"},{"question":"# Question You have been assigned to implement several data manipulation and transformation functions for a data analysis pipeline. These functions are crucial for preprocessing and analyzing large datasets. Below is the detailed description of the functions you need to implement. 1. **Standardize Columns**: Write a function `standardize_columns(df: pd.DataFrame, columns: List[str]) -> pd.DataFrame` that standardizes the specified columns of the input DataFrame. 2. **Fill Missing Values**: Write a function `fill_missing_values(df: pd.DataFrame, strategy: str, columns: List[str] = None) -> pd.DataFrame` that fills missing values in the specified columns using the provided strategy (`\'mean\'`, `\'median\'`, `\'mode\'`). 3. **Min-Max Scaling**: Write a function `min_max_scaling(df: pd.DataFrame, columns: List[str]) -> pd.DataFrame` that scales the specified columns of the input DataFrame to a [0, 1] range. 4. **One-Hot Encoding**: Write a function `one_hot_encode(df: pd.DataFrame, columns: List[str]) -> pd.DataFrame` that performs one-hot encoding on the specified columns of the input DataFrame. 5. **Date Feature Extraction**: Write a function `extract_date_features(df: pd.DataFrame, date_column: str) -> pd.DataFrame` that extracts relevant features (year, month, day, weekday) from the specified date column in the input DataFrame. Ensure your functions are efficient and handle edge cases appropriately. The constraints and expected inputs/outputs for each function are provided below: 1. **Standardize Columns**: - **Input**: `df` (a pandas DataFrame), `columns` (list of column names to standardize). - **Output**: DataFrame with specified columns standardized (mean=0, std=1). 2. **Fill Missing Values**: - **Input**: `df` (a pandas DataFrame), `strategy` (one of `\'mean\'`, `\'median\'`, `\'mode\'`), `columns` (list of column names to fill, default is None, meaning all columns). - **Output**: DataFrame with missing values filled according to the strategy. 3. **Min-Max Scaling**: - **Input**: `df` (a pandas DataFrame), `columns` (list of column names to scale). - **Output**: DataFrame with specified columns scaled to [0, 1]. 4. **One-Hot Encoding**: - **Input**: `df` (a pandas DataFrame), `columns` (list of column names to one-hot encode). - **Output**: DataFrame with specified columns one-hot encoded and original columns removed. 5. **Date Feature Extraction**: - **Input**: `df` (a pandas DataFrame), `date_column` (name of the date column). - **Output**: DataFrame with new columns for each extracted date feature (year, month, day, weekday). Provide complete implementations of these functions with proper error handling, ensuring they produce correct results across a variety of datasets and input scenarios.","solution":"import pandas as pd import numpy as np from typing import List def standardize_columns(df: pd.DataFrame, columns: List[str]) -> pd.DataFrame: Standardizes the specified columns of the input DataFrame. df = df.copy() for column in columns: mean = df[column].mean() std = df[column].std() df[column] = (df[column] - mean) / std return df def fill_missing_values(df: pd.DataFrame, strategy: str, columns: List[str] = None) -> pd.DataFrame: Fills missing values in the specified columns using the provided strategy (\'mean\', \'median\', \'mode\'). df = df.copy() if columns is None: columns = df.columns.tolist() for column in columns: if strategy == \'mean\': fill_value = df[column].mean() elif strategy == \'median\': fill_value = df[column].median() elif strategy == \'mode\': fill_value = df[column].mode()[0] else: raise ValueError(\\"Strategy not recognized. Use \'mean\', \'median\' or \'mode\'.\\") df[column].fillna(fill_value, inplace=True) return df def min_max_scaling(df: pd.DataFrame, columns: List[str]) -> pd.DataFrame: Scales the specified columns of the input DataFrame to a [0, 1] range. df = df.copy() for column in columns: min_value = df[column].min() max_value = df[column].max() df[column] = (df[column] - min_value) / (max_value - min_value) return df def one_hot_encode(df: pd.DataFrame, columns: List[str]) -> pd.DataFrame: Performs one-hot encoding on the specified columns of the input DataFrame. df = df.copy() df = pd.get_dummies(df, columns=columns) return df def extract_date_features(df: pd.DataFrame, date_column: str) -> pd.DataFrame: Extracts relevant features (year, month, day, weekday) from the specified date column in the input DataFrame. df = df.copy() df[date_column] = pd.to_datetime(df[date_column]) df[\'year\'] = df[date_column].dt.year df[\'month\'] = df[date_column].dt.month df[\'day\'] = df[date_column].dt.day df[\'weekday\'] = df[date_column].dt.weekday return df"},{"question":"# Question: Write a function that identifies prime numbers within a given range `[a, b)` and returns them as a list. **Function Signature**: ```python def find_primes_in_range(a: int, b: int) -> List[int]: Identify prime numbers within a specified range [a, b). Arguments: a -- an integer specifying the start of the range (inclusive) b -- an integer specifying the end of the range (exclusive) Returns: List[int] -- a list of prime numbers within the range [a, b) ``` **Input**: 1. `a`: an integer representing the start of the range (inclusive). 2. `b`: an integer representing the end of the range (exclusive). **Output**: - A list containing all prime numbers in the range `[a, b)`. **Examples**: ```python >>> find_primes_in_range(10, 20) [11, 13, 17, 19] >>> find_primes_in_range(30, 40) [31, 37] ``` **Constraints**: - (0 leq a < b leq 10^6) - The function should be efficient even for large values of `a` and `b`. **Explanation**: - The function should identify all prime numbers within the specified range `[a, b)`. - A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. **Hints**: 1. **Use the Sieve of Eratosthenes**: Apply this efficient algorithm to precompute all primes up to `b - 1`. 2. **Prime Checking**: Utilize the precomputed primes to check for primality within the range `[a, b)`. 3. **Edge Cases**: Handle the case when the range has no prime numbers (e.g., `a = 14, b = 16`).","solution":"from typing import List def find_primes_in_range(a: int, b: int) -> List[int]: def sieve(n: int) -> List[int]: is_prime = [True] * (n + 1) p = 2 while (p * p <= n): if (is_prime[p] == True): for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 prime_list = [p for p in range(2, n + 1) if is_prime[p]] return prime_list primes = sieve(b - 1) return [p for p in primes if p >= a]"},{"question":"# String Compression Algorithm **Objective**: Implement a function to perform basic string compression using the counts of repeated characters. Requirements: 1. **Core Task**: Write a function that, given a string, compresses it such that consecutive occurrences of the same character are replaced with the character followed by the count of occurrences. 2. **Return Value**: The function should return the compressed string if it results in a shorter length than the original string. Otherwise, return the original string. 3. **Constraints**: - Assume the string consists of only uppercase and lowercase Latin letters (a-z). - The function should maintain case-sensitivity. - Handle edge cases and avoid unnecessary processing if the string length is 1 or 0. Function Signature: ```python def compress_string(s: str) -> str: pass ``` Example: ```python # Input compress_string(\\"aabcccccaaa\\") # Output \\"a2b1c5a3\\" # Input compress_string(\\"abcdef\\") # Output \\"abcdef\\" ``` When `compress_string(\\"aabcccccaaa\\")` is called, the function should return `\\"a2b1c5a3\\"`. When `compress_string(\\"abcdef\\")` is called, the function should return `\\"abcdef\\"` since the compressed string would not be shorter.","solution":"def compress_string(s: str) -> str: if len(s) <= 1: return s compressed = [] count = 1 previous_char = s[0] for i in range(1, len(s)): if s[i] == previous_char: count += 1 else: compressed.append(previous_char + str(count)) previous_char = s[i] count = 1 compressed.append(previous_char + str(count)) compressed_str = \'\'.join(compressed) return compressed_str if len(compressed_str) < len(s) else s"},{"question":"# Context: Cryptography relies heavily on the use of prime numbers. One common application is the use of prime numbers to generate keys in encryption algorithms. However, not every number is prime, and it is important to identify prime numbers efficiently, even for large values. # Task: Implement a function `is_prime` that determines whether a given integer is a prime number. # Input: 1. `num` (int): The integer to be checked. It can be any non-negative integer. # Output: - A boolean value: `True` if the number is prime, and `False` otherwise. # Constraints: - The input number `num` will be a non-negative integer. - Consider 0 and 1 as non-prime numbers. - Optimize the solution for larger values of `num` to ensure efficiency. # Examples: ```python def is_prime(num: int) -> bool: Determines if the given number is a prime. Parameters: - num : int : The integer number to be checked Returns: - bool : True if the number is prime, otherwise False # Check for small or specific values if num <= 1: return False if num <= 3: return True # Multiples of 2 and 3 are not primes if num % 2 == 0 or num % 3 == 0: return False # Check divisibility from 5 upwards i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True # Example test cases print(is_prime(2)) # Expected output: True print(is_prime(4)) # Expected output: False print(is_prime(17)) # Expected output: True print(is_prime(20)) # Expected output: False print(is_prime(97)) # Expected output: True ``` # Requirements: Implement the function `is_prime` as described and ensure it handles edge cases efficiently. Validate your solution with the provided examples.","solution":"def is_prime(num: int) -> bool: Determines if the given number is a prime. Parameters: - num : int : The integer number to be checked Returns: - bool : True if the number is prime, otherwise False # Handle edge cases if num <= 1: return False if num <= 3: return True # Eliminate common non-prime cases early if num % 2 == 0 or num % 3 == 0: return False # Check divisibility starting from i=5 and increment in steps of 6 i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True"},{"question":"# Problem Statement You are developing a system that generates unique identifiers for various entities within a large distributed application. Each identifier should be a short, alphanumeric string that is guaranteed to be unique. To accomplish this, you need to: 1. **Implement** a function `generate_id` that generates a new unique identifier every time it is called. 2. **Optimize** the identifier generation to minimize collisions and ensure uniqueness across a huge number of calls. # Function Signature ```python class IDGenerator: def __init__(self): pass def generate_id(self) -> str: pass ``` # Constraints * The ID should be a string of alphanumeric characters (both uppercase and lowercase letters, as well as digits). * The length of the ID should be between 6 and 12 characters. * The probability of ID collision should be extremely low, even with up to (10^6) unique IDs. # Example ```python id_gen = IDGenerator() # Example 1 id1 = id_gen.generate_id() print(id1) # Example output: \'a1B9gZ\' # Example 2 id2 = id_gen.generate_id() print(id2) # Example output: \'2gH4jK\' ``` # Requirements 1. **Uniqueness**: Ensure that every generated ID is unique within the bound of up to (10^6) IDs. 2. **Efficiency**: The generation algorithm should be optimized for performance. 3. **Validation**: Ensure no empty or excessively long IDs are produced.","solution":"import random import string class IDGenerator: def __init__(self): self.generated_ids = set() def generate_id(self) -> str: # Length of the ID is fixed between 6 to 12 characters length = random.randint(6, 12) # Alphanumeric characters allowed in ID characters = string.ascii_letters + string.digits while True: new_id = \'\'.join(random.choices(characters, k=length)) if new_id not in self.generated_ids: self.generated_ids.add(new_id) return new_id"},{"question":"# Problem Statement You are given a list of integers representing the population count of different regions in a country. Your task is to merge these populations into a single region, following these rules: 1. In each step, you can merge two regions into one. The cost of merging two regions is equal to the sum of their populations. 2. Your goal is to find the minimum total cost required to merge all regions into one. # Function Signature ```python def min_merge_cost(populations: List[int]) -> int: pass ``` # Input - A list of integers `populations` (2 ≤ len(populations) ≤ 10^5, 1 ≤ populations[i] ≤ 10^6) representing the initial population count of the regions. # Output - An integer representing the minimum total cost necessary to merge all regions into a single region. # Constraints - You should ensure that your solution is efficient and can handle large input sizes. # Example ```python assert min_merge_cost([4, 3, 2, 6]) == 29 assert min_merge_cost([1, 2, 3]) == 9 ``` # Explanation - For the first example, the optimal merging steps are: - Merge 2 and 3 for a cost of 5. - Merge the resulting 5 with 4 for a cost of 9. - Merge the resulting 9 with 6 for a cost of 15. - Total cost: 5 + 9 + 15 = 29. - For the second example, the optimal merging steps are: - Merge 1 and 2 for a cost of 3. - Merge the resulting 3 with 3 for a cost of 6. - Total cost: 3 + 6 = 9. Ensure that your implementation conforms to the given function signature. Write clean, efficient, and well-documented code.","solution":"from typing import List import heapq def min_merge_cost(populations: List[int]) -> int: Calculates the minimum total cost required to merge all regions into a single region. The cost of merging two regions is equal to the sum of their populations. Args: populations (List[int]): List of integer populations of each region. Returns: int: The minimum cost to merge all regions into one. # Create a min-heap from the populations list heapq.heapify(populations) total_cost = 0 # Continuously merge the two smallest populations until one population remains while len(populations) > 1: # Pop the two smallest populations smallest = heapq.heappop(populations) next_smallest = heapq.heappop(populations) # The cost to merge these two smallest populations cost = smallest + next_smallest # Add the merged population back into the heap heapq.heappush(populations, cost) # Add this merge cost to the total cost total_cost += cost return total_cost"},{"question":"Sort a List of Custom Objects by Multiple Attributes Given a list of custom objects, you are required to sort the list by multiple attributes. Each object represents a `Person`, and the class has three attributes: `name`, `age`, and `height`. # Objectives - Write a class `Person` that initializes with the attributes `name` (string), `age` (integer), and `height` (float). - Implement a method to perform the sorting of a list of `Person` objects. - The primary sort key should be `age` in ascending order, and the secondary sort key should be `height` in descending order. - Provide the necessary functions to facilitate the sorting process within Python\'s sorting mechanisms. # Input Format - A list of `Person` objects. # Output Format - A sorted list of `Person` objects based on the specified criteria. # Constraints - All names will be non-empty strings containing only alphabetic characters. - `0 < age <= 120` - `0.5 < height <= 3.0` # Performance Requirements - Aim for a **O(n log n)** time complexity where `n` is the number of `Person` objects in the list. # Example ```python class Person: def __init__(self, name, age, height): self.name = name self.age = age self.height = height def __repr__(self): return f\\"{self.name} ({self.age}, {self.height}m)\\" def sort_persons(persons): return sorted(persons, key=lambda p: (p.age, -p.height)) # Example usage people = [ Person(\\"Alice\\", 30, 1.65), Person(\\"Bob\\", 25, 1.85), Person(\\"Charlie\\", 25, 1.75), Person(\\"Dave\\", 35, 1.80) ] sorted_people = sort_persons(people) for person in sorted_people: print(person) ``` # Notes - Ensure that the sort implementation is efficient and leverages Python\'s built-in sorting functions. - Test edge cases such as lists with identical ages but different heights, and lists with the same ages and heights.","solution":"class Person: def __init__(self, name, age, height): self.name = name self.age = age self.height = height def __repr__(self): return f\\"{self.name} ({self.age}, {self.height}m)\\" def sort_persons(persons): return sorted(persons, key=lambda p: (p.age, -p.height))"},{"question":"# Question: Implement a Balanced Binary Search Tree (BST) and Support Duplicates You are required to implement a balanced binary search tree (BST) that supports duplicates. Your BST should ensure that for any node, the left sub-tree contains elements less than or equal to the node in value, and the right sub-tree contains elements greater than the node in value. Ensure the tree remains balanced after each insertion or deletion operation to maintain efficient search, insertion, and deletion operations. Task: Implement the class `BalancedBST` with the following methods: - `insert(value: int) -> None`: Inserts a value into the BST. - `delete(value: int) -> bool`: Deletes a value from the BST. Returns `True` if the value was found and deleted, `False` otherwise. - `contains(value: int) -> bool`: Checks if a value is present in the BST. Returns `True` if present, `False` otherwise. - `kth_smallest(k: int) -> int`: Returns the k-th smallest element in the BST (1-based index). # Constraints: - The values inserted into the BST are integers. - The number of operations on the BST (`insert`, `delete`, `contains`, and `kth_smallest`) will not exceed 10^5. - The operations must be optimized for performance (i.e., should ideally run in O(log n) time complexity for each operation where applicable). # Requirements: 1. **Class Signature**: ```python class BalancedBST: def __init__(self): # constructor for the BST def insert(self, value: int) -> None: # insert \'value\' into the BST def delete(self, value: int) -> bool: # delete \'value\' from the BST; # return True if successfully deleted, otherwise False def contains(self, value: int) -> bool: # return True if \'value\' is in the BST, otherwise False def kth_smallest(self, k: int) -> int: # return k-th smallest element (1-based index) ``` 2. **Input/Output**: - `insert(value: int) -> None` - `delete(value: int) -> bool` - `contains(value: int) -> bool` - `kth_smallest(k: int) -> int` # Example: ```python bst = BalancedBST() bst.insert(10) bst.insert(20) bst.insert(5) bst.insert(10) bst.insert(15) assert bst.contains(10) == True assert bst.contains(30) == False assert bst.kth_smallest(1) == 5 assert bst.kth_smallest(3) == 10 assert bst.delete(10) == True assert bst.contains(10) == True # Another 10 is still in the BST assert bst.delete(10) == True assert bst.contains(10) == False assert bst.kth_smallest(1) == 5 assert bst.delete(5) == True assert bst.kth_smallest(1) == 15 assert bst.delete(5) == False # 5 is already deleted ``` **Notes**: 1. If the problem cannot be solved due to invalid input constraints or any other reason, appropriate Exception handling or Error Messages should be incorporated. 2. You may need to use self-balancing tree algorithms like AVL or Red-Black Trees to ensure that the BST remains balanced after insertions and deletions.","solution":"import bisect class BalancedBST: def __init__(self): self.elements = [] def insert(self, value: int) -> None: bisect.insort(self.elements, value) def delete(self, value: int) -> bool: pos = bisect.bisect_left(self.elements, value) if pos < len(self.elements) and self.elements[pos] == value: self.elements.pop(pos) return True return False def contains(self, value: int) -> bool: pos = bisect.bisect_left(self.elements, value) return pos < len(self.elements) and self.elements[pos] == value def kth_smallest(self, k: int) -> int: if 1 <= k <= len(self.elements): return self.elements[k - 1] raise IndexError(\\"k is out of range\\")"},{"question":"# Subarray Sum Problem Given an integer array `nums`, you are to find the contiguous subarray (containing at least one number) which has the largest sum and return its sum along with the starting and ending index of the subarray. # Problem Statement Write a function `max_subarray_sum(nums: List[int]) -> Tuple[int, int, int]` that takes a list of integers and returns the sum of the subarray with the largest sum, as well as the starting and ending index of that subarray (both inclusive). # Requirements * Optimize the function to run in O(n) time complexity using an appropriate algorithm. * Handle both positive and negative numbers. # Input * A list of integers `nums` with length `n` where `1 <= n <= 10^5`. - The integers can range from `-10^5` to `10^5`. # Output * A tuple containing three integers: the maximum subarray sum, the start index of this subarray, and the end index of this subarray. # Constraints * The input array will always contain at least one element. # Performance Requirements * The implementation should be efficient and capable of handling large input sizes within reasonable time limits. # Scenario/Context The maximum subarray sum problem is a common exercise in understanding dynamic programming and greedy algorithms. It has practical applications in fields such as finance for maximum profit calculations and is a fundamental problem in computer science education. # Example ```python nums = [-2,1,-3,4,-1,2,1,-5,4] result = max_subarray_sum(nums) print(result) # Output: (6, 3, 6) because the maximum sum subarray is [4,-1,2,1] with sum 6. ``` Your implementation must ensure the output is not only correct but also includes the appropriate indices to identify the subarray within the original array.","solution":"from typing import List, Tuple def max_subarray_sum(nums: List[int]) -> Tuple[int, int, int]: Finds the contiguous subarray with the largest sum and returns the sum along with the starting and ending index of the subarray. if not nums: return 0, -1, -1 max_sum = current_sum = nums[0] start_index = end_index = 0 temp_start_index = 0 for i in range(1, len(nums)): if current_sum < 0: current_sum = nums[i] temp_start_index = i else: current_sum += nums[i] if current_sum > max_sum: max_sum = current_sum start_index = temp_start_index end_index = i return max_sum, start_index, end_index"},{"question":"Problem Statement A company needs a system to track the entry and exit times of its employees efficiently. They want to maintain a record of timestamps of employee entries and exits and calculate the total time each employee has spent within the company on any given day. You will implement a class `EmployeeTracker` to achieve this. # Requirements: 1. **enter(timestamp: int, employee_id: str) -> None**: - Records the entry of an employee identified by `employee_id` at the specified `timestamp`. - If the specified employee has already entered without exiting, raise a `ValueError` with the message \\"Employee has already entered.\\" 2. **exit(timestamp: int, employee_id: str) -> None**: - Records the exit of an employee identified by `employee_id` at the specified `timestamp`. - If the employee has not entered yet or has already exited for the current entry, raise a `ValueError` with the message \\"Invalid exit.\\" 3. **get_total_time(employee_id: str) -> int**: - Returns the total time the specified employee has spent inside the company for the current day. - If the employee has entered but not exited yet, the method should calculate the time up to the current timestamp (assume `timestamp = 24` for calculation purposes). # Constraints 1. Timestamps are integers ranging from 0 to 24. 2. An employee can only enter and exit once in the specified period (0 to 24). # Expected Input and Output Format * The `enter` method takes `timestamp: int` and `employee_id: str`. * The `exit` method takes `timestamp: int` and `employee_id: str`. * The `get_total_time` method takes `employee_id: str` and returns the total time as `int`. # Example ```python >>> tracker = EmployeeTracker() >>> tracker.enter(9, \\"E01\\") >>> tracker.exit(17, \\"E01\\") >>> tracker.get_total_time(\\"E01\\") 8 >>> tracker.enter(18, \\"E02\\") >>> tracker.get_total_time(\\"E02\\") 6 >>> tracker.exit(24, \\"E02\\") >>> tracker.get_total_time(\\"E02\\") 6 >>> tracker.enter(10, \\"E01\\") Traceback (most recent call last): ... ValueError: Employee has already entered. >>> tracker.exit(20, \\"E03\\") Traceback (most recent call last): ... ValueError: Invalid exit. ``` # Additional Instructions * Each employee\'s total time should be calculated using only their valid entries and exits. * Test your methods thoroughly to account for edge cases and ensure proper functionality under various scenarios. # Implementation Notes - You may use dictionaries to store the entry and exit times for each employee. - Ensure that your implementation handles the edge cases effectively.","solution":"class EmployeeTracker: def __init__(self): self.entry_times = {} self.exit_times = {} def enter(self, timestamp: int, employee_id: str) -> None: if employee_id in self.entry_times and employee_id not in self.exit_times: raise ValueError(\\"Employee has already entered.\\") self.entry_times[employee_id] = timestamp def exit(self, timestamp: int, employee_id: str) -> None: if employee_id not in self.entry_times or (employee_id in self.exit_times and self.exit_times[employee_id] is not None): raise ValueError(\\"Invalid exit.\\") self.exit_times[employee_id] = timestamp def get_total_time(self, employee_id: str) -> int: if employee_id not in self.entry_times: return 0 entry_time = self.entry_times[employee_id] exit_time = self.exit_times.get(employee_id, None) if exit_time is None: return 24 - entry_time return exit_time - entry_time"},{"question":"Problem Statement Write a function that determines the largest prime number less than or equal to a given positive integer `n`. The function should be implemented efficiently to handle large values. # Function Signature ```python def largest_prime(n: int) -> int: ``` # Input: - `n` (int): A positive integer. (Constraints: 1 ≤ n ≤ 10^6) # Output: - An integer which is the largest prime number less than or equal to `n`. # Example: ```python largest_prime(10) # Output: 7 largest_prime(29) # Output: 29 largest_prime(100) # Output: 97 ``` # Constraints: 1. Input will always be a positive integer. 2. The function should run efficiently even for the upper limit of `n`. 3. If `n` is a prime number, the function should return `n`. # Detailed Requirements: 1. If `n` is 2, the output should be 2. 2. The function should handle the edge case where `n` is 1 by returning 0 or throwing a suitable exception as there are no prime numbers less than or equal to 1. 3. Utilize an efficient algorithm such as the Sieve of Eratosthenes to precompute prime numbers up to the maximum value of `n`. 4. Ensure the solution efficiently handles the prime check and does not perform unnecessary computations. # Additional Context: Prime numbers are numbers that have only two divisors: 1 and themselves. Efficiently finding the largest prime number less than or equal to a given number is crucial in various fields such as cryptography, number theory, and computer security. The Sieve of Eratosthenes is an optimal algorithm for finding all prime numbers up to a specified integer, making it a suitable choice for this problem.","solution":"def largest_prime(n: int) -> int: Returns the largest prime number less than or equal to n. if n < 2: return 0 # Use the Sieve of Eratosthenes to find all prime numbers up to n is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False # 0 and 1 are not primes p = 2 while p * p <= n: if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 # Find the largest prime number less than or equal to n for i in range(n, 1, -1): if is_prime[i]: return i return 0"},{"question":"# Trie Implementation for Prefix Search A Trie (pronounced as \\"try\\") is a type of search tree used to store a dynamic set of strings, where keys are usually strings. Trie is used to search words efficiently by their prefixes. # Objective: Implement a Trie structure and a function to perform prefix search operations. # Context: Imagine you are building an autocomplete feature in a text editor or a search engine where suggestions are provided based on the prefixes typed by the user. Given a Trie, implement the missing function to search for words starting with a given prefix. # Function Signature: ```python def search_prefix(root: TrieNode, prefix: str) -> List[str]: pass ``` # Input: - `root`: The root node of the Trie (instance of `TrieNode`). - `prefix`: The prefix string to be searched in the Trie. # Output: - Returns a list of strings that start with the given prefix. The list can be in any order. # Constraints: - The Trie follows standard properties for storing strings. - The strings in the Trie consist of lowercase English letters (\'a\' to \'z\'). - The prefix string also consists of lowercase English letters. # Performance Requirements: - The prefix search operation must efficiently identify and collect all words starting with the given prefix. - Minimize the use of additional memory beyond the existing Trie structure. # Scenario: ```python class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): current_node = self.root for char in word: if char not in current_node.children: current_node.children[char] = TrieNode() current_node = current_node.children[char] current_node.is_end_of_word = True # Create a Trie and insert words into it trie = Trie() words = [\\"dog\\", \\"deer\\", \\"deal\\"] for word in words: trie.insert(word) # Example test cases: print(search_prefix(trie.root, \\"de\\")) # [\\"deer\\", \\"deal\\"] print(search_prefix(trie.root, \\"do\\")) # [\\"dog\\"] print(search_prefix(trie.root, \\"cat\\")) # [] ``` # Hints: 1. Traverse the Trie using the characters of the prefix to reach the node representing the prefix. 2. Collect all words that are formed starting from the prefix node using a depth-first search approach.","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): current_node = self.root for char in word: if char not in current_node.children: current_node.children[char] = TrieNode() current_node = current_node.children[char] current_node.is_end_of_word = True def search_prefix(root: TrieNode, prefix: str) -> List[str]: def dfs(node: TrieNode, prefix: str, path: str, results: List[str]): if node.is_end_of_word: results.append(path) for char, child in node.children.items(): dfs(child, prefix + char, path + char, results) current_node = root path = \\"\\" for char in prefix: if char not in current_node.children: return [] current_node = current_node.children[char] path += char results = [] dfs(current_node, prefix, path, results) return results"},{"question":"# Prime Pair Sequence Scenario You are working on a cryptographic algorithm that makes use of prime numbers. A specific sequence of prime number pairs is required, where every pair consists of two consecutive prime numbers. Task Write a function `prime_pairs_sequence` that takes an integer `n` and returns a list of exactly n pairs of consecutive prime numbers. Function Definition ```python def prime_pairs_sequence(n: int) -> list[tuple[int, int]]: ``` Input - An integer `n` where ( 1 leq n leq 1000 ) Output - A list of n tuples, each containing two consecutive prime numbers. - Example: `[(3, 5), (5, 7), (11, 13)]` Constraints - The output list must contain exactly n pairs of consecutive prime numbers starting from the smallest prime number (2). - Prime numbers are those numbers greater than 1 that have no positive divisors other than 1 and themselves. Performance Requirements - Aim for an efficient solution that handles the upper limit of prime pair calculation within reasonable time constraints. Validation Scenarios To validate your solution, it should pass these examples: ```python assert prime_pairs_sequence(3) == [(3, 5), (5, 7), (11, 13)] assert prime_pairs_sequence(5) == [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31)] ``` Special Cases - The function should handle the smallest input by returning a single pair of consecutive prime numbers when n is 1, e.g., `[(3, 5)]`.","solution":"def is_prime(num): Helper function to check if a given number is a prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def prime_pairs_sequence(n: int) -> list[tuple[int, int]]: Returns a list of n pairs of consecutive prime numbers. primes = [] prime_pairs = [] current = 2 # starting from the smallest prime number while len(prime_pairs) < n: if is_prime(current): primes.append(current) # Check if we have at least two primes to form a pair if len(primes) >= 2: if primes[-1] == primes[-2] + 2: # Check if consecutive primes are exactly 2 apart prime_pairs.append((primes[-2], primes[-1])) current += 1 return prime_pairs"},{"question":"# Data Structures and Algorithms Question: Implement a Circular Buffer Background A circular buffer, also known as a ring buffer, is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end. This structure is useful for buffering data streams, such as in asynchronous data processing or handling data from hardware devices. # Task 1. **Circular Buffer Implementation**: - Implement a class `CircularBuffer` that initializes a buffer with a fixed size. - Implement methods for adding elements to the buffer (`enqueue`) and removing elements from the buffer (`dequeue`). - Ensure that the buffer can overwrite the oldest data when it becomes full (`enqueue` should handle this). - Implement a method to get the current size of the buffer (`size`). 2. **Buffer Operations**: - Implement a method to get the current state of the buffer as a list (`__str__`). - Implement a method to peek at the front element without removing it (`peek`). Function Signatures ```python class CircularBuffer: def __init__(self, capacity: int): pass def enqueue(self, value: Any) -> None: pass def dequeue(self) -> Any: pass def peek(self) -> Any: pass def size(self) -> int: pass def __str__(self) -> str: pass ``` # Constraints * The buffer size `capacity` will be a positive integer greater than zero. * Handle edge cases gracefully, such as dequeueing from an empty buffer. * Ensure that the operations on the buffer are efficient. # Examples ```python cb = CircularBuffer(3) cb.enqueue(1) cb.enqueue(2) cb.enqueue(3) print(cb) # -> \'[1, 2, 3]\' cb.enqueue(4) print(cb) # -> \'[4, 2, 3]\' (1 is overwritten) print(cb.dequeue()) # -> 2 print(cb) # -> \'[4, None, 3]\' cb.enqueue(5) print(cb) # -> \'[4, 5, 3]\' print(cb.peek()) # -> 4 print(cb.size()) # -> 3 (number of elements in the buffer) print(cb.dequeue()) # -> 4 print(cb.dequeue()) # -> 3 print(cb.dequeue()) # -> 5 print(cb.size()) # -> 0 (buffer is empty now) ``` # Notes * Ensure your `CircularBuffer` class is well-documented with clear and concise docstrings. * Provide sufficient validation for operations, such as handling buffer overflows and underflows efficiently. * Optimize the performance of the methods where possible.","solution":"class CircularBuffer: def __init__(self, capacity: int): Initializes the circular buffer with the given capacity. :param capacity: The size of the circular buffer assert capacity > 0, \\"Capacity must be a positive integer\\" self.capacity = capacity self.buffer = [None] * capacity self.head = 0 self.tail = 0 self.count = 0 def enqueue(self, value): Adds an element to the circular buffer. If the buffer is full, the oldest element is overwritten. :param value: The value to add to the buffer if self.is_full(): self.head = (self.head + 1) % self.capacity else: self.count += 1 self.buffer[self.tail] = value self.tail = (self.tail + 1) % self.capacity def dequeue(self): Removes and returns the oldest element from the circular buffer. :return: The oldest element in the buffer or raises an exception if the buffer is empty if self.is_empty(): raise IndexError(\\"Dequeue from an empty buffer\\") value = self.buffer[self.head] self.buffer[self.head] = None self.head = (self.head + 1) % self.capacity self.count -= 1 return value def peek(self): Returns the oldest element without removing it from the buffer. :return: The oldest element in the buffer or raises an exception if the buffer is empty if self.is_empty(): raise IndexError(\\"Peek from an empty buffer\\") return self.buffer[self.head] def size(self): Returns the number of elements in the buffer. :return: The current size of the buffer return self.count def is_empty(self): Check if the buffer is empty. :return: True if the buffer is empty, otherwise False return self.count == 0 def is_full(self): Check if the buffer is full. :return: True if the buffer is full, otherwise False return self.count == self.capacity def __str__(self): Returns a string representation of the buffer. :return: A string representing the buffer return str(self.buffer)"},{"question":"# Coding Question Create a Python function that takes an encoded string where repetitions of substrings are represented as `k[encoded_string]` and returns its decoded version. The value `k` is a positive integer representing how many times the substring within the brackets should be repeated. # Function Signature ```python def decode_string(s: str) -> str: ``` # Input - `s` (str): The encoded string containing repetitions denoted as `k[encoded_string]`. # Output - A string representing the decoded version of the input string. # Constraints - The encoded string is guaranteed to be well-formed. - The brackets may be nested. - The integer `k` will be a positive integer which does not exceed 300, and there will not be more than 100 nested levels of brackets. # Example ```python assert decode_string(\\"3[a]2[bc]\\") == \\"aaabcbc\\" assert decode_string(\\"3[a2[c]]\\") == \\"accaccacc\\" assert decode_string(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\" ``` # Notes - The input string can contain characters other than `a-z` and other than the brackets and integer repetition indicators. - Consider edge cases where the input string could be smaller in size or not contain any encoded sections at all.","solution":"def decode_string(s: str) -> str: Decodes the encoded string where repetitions of substrings are represented as k[encoded_string]. stack = [] current_num = 0 current_string = \'\' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string, current_num = \'\', 0 elif char == \']\': last_string, num = stack.pop() current_string = last_string + num * current_string else: current_string += char return current_string"},{"question":"# Coding Assessment Question Context Consider a scenario where you are asked to manage a task scheduling system. Tasks are defined by their start time and end time, and you need to determine if all tasks can be executed without overlapping. Problem Statement Implement the following function: ```python def can_schedule(tasks: List[Tuple[int, int]]) -> bool: Determines whether all given tasks can be scheduled without overlap. Args: tasks (List[Tuple[int, int]]): A list of tuples where each tuple represents a task with a start and end time (start, end). Returns: bool: True if all tasks can be scheduled without overlap, else False. pass ``` Definition Two tasks are considered to overlap if one task starts before the other task ends. Input - `tasks`: A list of tuples where each tuple contains two integers (start, end) representing the start time and end time of a task. Output - A boolean indicating if all tasks can be scheduled without overlapping. Constraints - ( 0 leq text{start}, text{end} leq 10^4 ) - ( text{start} < text{end} ) Examples ```python # Example 1 tasks = [(1, 3), (3, 5), (4, 6)] assert can_schedule(tasks) == False # Example 2 tasks = [(1, 2), (3, 4), (5, 6)] assert can_schedule(tasks) == True ``` Notes 1. You should first sort the tasks based on their start times. 2. After sorting, check for any overlapping tasks by comparing the end time of the current task with the start time of the next task.","solution":"def can_schedule(tasks): Determines whether all given tasks can be scheduled without overlap. Args: tasks (List[Tuple[int, int]]): A list of tuples where each tuple represents a task with a start and end time (start, end). Returns: bool: True if all tasks can be scheduled without overlap, else False. # sort tasks based on the start time tasks.sort(key=lambda x: x[0]) # check for overlapping tasks for i in range(1, len(tasks)): if tasks[i][0] < tasks[i-1][1]: return False return True"},{"question":"# Question Context You are tasked with developing a simple caching system for a data processing application. The cache stores data based on access frequency; frequently accessed items should be prioritized and retained in the cache. Task Write a Python class `LFUCache` that implements a Least Frequently Used (LFU) cache with the following methods: - `__init__(self, capacity: int)`: Initializes the cache with a given capacity. - `get(self, key: int) -> int`: Retrieves the value associated with the given key if the key is present in the cache; otherwise, it returns -1. Each access operation must increase the access frequency of the key. - `put(self, key: int, value: int) -> None`: Inserts or updates the value of the given key in the cache. If the cache is full, it should remove the least frequently used item before inserting the new key-value pair. In case of a tie (multiple keys with the same frequency), the least recently used item among them should be evicted. Constraints - The operations must run in O(1) time on average. - The cache capacity will be a positive integer. Example ```python cache = LFUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # Access frequency of key 1 becomes 1 cache.put(3, 3) # Key 2 is evicted because both key 1 and key 2 have frequency 1, but key 2 is least recently used assert cache.get(2) == -1 # Key 2 is not in the cache assert cache.get(3) == 3 # Access frequency of key 3 becomes 1 cache.put(4, 4) # Key 1 is evicted; both keys 1 and 3 have frequency 1, but key 1 is least recently used assert cache.get(1) == -1 # Key 1 is not in the cache assert cache.get(3) == 3 # Key 3 is in the cache assert cache.get(4) == 4 # Key 4 is in the cache ``` Function Signature ```python class LFUCache: def __init__(self, capacity: int): pass def get(self, key: int) -> int: pass def put(self, key: int, value: int) -> None: pass ```","solution":"class LFUCache: def __init__(self, capacity: int): self.capacity = capacity self.min_frequency = 0 self.cache = {} self.key_frequency = {} self.frequency_keys = {} def _update_frequency(self, key): freq = self.key_frequency[key] self.key_frequency[key] += 1 self.frequency_keys[freq].remove(key) if not self.frequency_keys[freq]: del self.frequency_keys[freq] if self.min_frequency == freq: self.min_frequency += 1 new_freq = freq + 1 if new_freq not in self.frequency_keys: self.frequency_keys[new_freq] = set() self.frequency_keys[new_freq].add(key) def get(self, key: int) -> int: if key in self.cache: self._update_frequency(key) return self.cache[key] return -1 def put(self, key: int, value: int) -> None: if self.capacity == 0: return if key in self.cache: self.cache[key] = value self._update_frequency(key) return if len(self.cache) >= self.capacity: evict_key = self.frequency_keys[self.min_frequency].pop() if not self.frequency_keys[self.min_frequency]: del self.frequency_keys[self.min_frequency] del self.cache[evict_key] del self.key_frequency[evict_key] self.cache[key] = value self.key_frequency[key] = 1 self.min_frequency = 1 if 1 not in self.frequency_keys: self.frequency_keys[1] = set() self.frequency_keys[1].add(key)"},{"question":"# Context In a social media platform, users can follow each other, creating a directed graph where each node represents a user, and each directed edge represents a follow relationship. You are to identify influential users in this network, defined as users with the highest in-degrees (the number of followers). # Task You are to implement the function `find_influential_users(follows)` that takes: 1. `follows`: A list of tuples where each tuple `(a, b)` indicates that user `a` follows user `b`. The function should compute the in-degrees of each user and return a list of user IDs corresponding to the users who have the highest in-degrees. # Input Format - `follows` is a list of tuples where each tuple contains two integers representing the follower and the followee user IDs. - User IDs are 0-indexed integers. # Output Format - A list of integers representing the user IDs with the highest in-degrees. If multiple users have the same highest in-degree, return all of them in ascending order. # Constraints - ( 1 leq text{number of users} leq 10^5 ) - ( 0 leq text{user ID} leq 10^5 ) - Each follower-followee pair is unique and user IDs will be valid within the given range. # Example Input: ```python follows = [(0, 1), (2, 1), (3, 1), (1, 2), (4, 2), (5, 3)] ``` Output: ```python [1] ``` # Explanation User 1 has 3 followers (users 0, 2, and 3), which is the highest number of followers for any user. # Function Signature ```python def find_influential_users(follows: list[tuple[int, int]]) -> list[int]: pass ```","solution":"from collections import defaultdict def find_influential_users(follows): Returns a list of user IDs with the highest in-degrees based on the follow relationships. in_degree = defaultdict(int) # Build the in-degrees dictionary for follower, followee in follows: in_degree[followee] += 1 # Find the maximum in-degree max_in_degree = max(in_degree.values(), default=0) # Find all users with maximum in-degree influential_users = [user for user, degree in in_degree.items() if degree == max_in_degree] # Sort the list of influential users in ascending order return sorted(influential_users)"},{"question":"# String Manipulation and Pattern Matching In this programming task, you will work with strings and implement a custom method to solve a pattern matching problem. Your goal is to implement a specific method and verify its correctness. Problem Statement You are given a `PatternMatcher` class that currently lacks functionality. Implement the following additional feature: # Method: `find_pattern(pattern: str, s: str) -> List[int]` Given a pattern and a string, return a list of the starting indices of all occurrences of the pattern in the string. The pattern and string will only contain lowercase alphanumeric characters. # Expected Input and Output Formats * **Input**: The method will take two strings: `pattern` and `s`. * **Output**: A list of integers representing the starting indices of each match of the pattern in the string. # Constraints and Limitations: 1. The pattern length, `p`, and the string length, `n`, will have the relationship ( 1 leq p leq n leq 10^5 ). 2. Optimize the solution to run in ( O(n + p) ) time complexity. 3. Avoid using built-in search functions. Example Scenario ```python >>> pm = PatternMatcher() >>> pm.find_pattern(\'abc\', \'abcabcabc\') [0, 3, 6] >>> pm.find_pattern(\'a\', \'ababab\') [0, 2, 4] >>> pm.find_pattern(\'ab\', \'ababab\') [0, 2, 4] >>> pm.find_pattern(\'xyz\', \'abcabcabc\') [] ``` Use the function implementation to verify the correctness of your solution. # Implementation Complete the following method within the `PatternMatcher` class: ```python from typing import List class PatternMatcher: @staticmethod def find_pattern(pattern: str, s: str) -> List[int]: # Your code here ``` Ensure your tested implementation handles edge cases such as overlapping patterns and large input sizes efficiently. Evaluation Criteria * **Correctness**: The function should correctly identify all starting indices of the pattern within the string. * **Efficiency**: The solution should operate within the given constraints. * **Readability**: The code should be clean, and well-documented.","solution":"from typing import List class PatternMatcher: @staticmethod def find_pattern(pattern: str, s: str) -> List[int]: Given a pattern and a string, return a list of the starting indices of all occurrences of the pattern in the string. if not pattern or not s: return [] # KMP algorithm to find all occurrences def compute_lps_array(pat: str) -> List[int]: Compute the longest prefix suffix (LPS) array to be used in KMP algorithm. lps = [0] * len(pat) length = 0 # length of the previous longest prefix suffix i = 1 while i < len(pat): if pat[i] == pat[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps pat_len = len(pattern) str_len = len(s) lps = compute_lps_array(pattern) indices = [] i = 0 # index for s j = 0 # index for pattern while i < str_len: if pattern[j] == s[i]: i += 1 j += 1 if j == pat_len: indices.append(i - j) j = lps[j - 1] elif i < str_len and pattern[j] != s[i]: if j != 0: j = lps[j - 1] else: i += 1 return indices"},{"question":"# Problem Statement You are developing a software module to calculate and convert distances for an autonomous vehicle navigation system. The vehicle\'s sensor readings provide distances in centimeters, but the internal system requires these distances to be converted to meters and feet for different operations. Write a program that: 1. Takes a single input: `distance_cm` - a floating-point number representing the distance in centimeters. 2. Converts this distance to meters and feet. 3. Ensures the provided distance is non-negative, raising an appropriate error for invalid inputs. 4. Returns the converted distances in meters and feet. # Input Format * A single floating-point number representing `distance_cm` in centimeters. # Output Format * Print two lines: 1. The distance in meters. 2. The distance in feet. # Constraints * The input value must be non-negative. # Example Input ``` 100.0 ``` Output ``` Meters: 1.0 m Feet: 3.28084 ft ``` # Function Signature The implementation should include two distinct functions: ```python def convert_to_meters(distance_cm: float) -> float: pass def convert_to_feet(distance_cm: float) -> float: pass ``` # Requirements 1. Make sure that your functions handle invalid inputs gracefully by raising a `ValueError` with the message \\"Distance must be non-negative\\". 2. Use the provided input format and constraints to ensure correctness. 3. Ensure that you have clearly written and optimized code for performance.","solution":"def convert_to_meters(distance_cm: float) -> float: Converts a distance from centimeters to meters. Parameters: distance_cm (float): Distance in centimeters, should be non-negative. Returns: float: Distance in meters. Raises: ValueError: If distance_cm is negative. if distance_cm < 0: raise ValueError(\\"Distance must be non-negative\\") return distance_cm / 100.0 def convert_to_feet(distance_cm: float) -> float: Converts a distance from centimeters to feet. Parameters: distance_cm (float): Distance in centimeters, should be non-negative. Returns: float: Distance in feet. Raises: ValueError: If distance_cm is negative. if distance_cm < 0: raise ValueError(\\"Distance must be non-negative\\") return distance_cm / 30.48"},{"question":"# Matrix Multiplication Optimization with Strassen\'s Algorithm Background Matrix multiplication is a fundamental operation in many scientific computing and machine learning applications. Traditional matrix multiplication has a time complexity of (O(n^3)), which can be inefficient for large matrices. Strassen\'s algorithm, however, can multiply matrices in (O(n^{log_2 7}) approx O(n^{2.81})) time, offering potential speed improvements. Objective Implement a function to multiply two square matrices using Strassen\'s algorithm and compare its performance against the standard multiplication method. Problem Statement Write a function `strassen_matrix_multiplication` that takes two square matrices (2D numpy arrays) and returns their product using Strassen\'s algorithm. Additionally, implement a wrapper function to compare the execution time of Strassen\'s algorithm against a naive matrix multiplication approach. Function Signatures ```python def strassen_matrix_multiplication(A: np.ndarray, B: np.ndarray) -> np.ndarray: pass def compare_matrix_multiplication(A: np.ndarray, B: np.ndarray) -> dict: pass ``` Input * `A`: A square matrix represented as a 2D numpy array of shape `(n, n)`. * `B`: A square matrix represented as a 2D numpy array of shape `(n, n)`. Output For `strassen_matrix_multiplication`: * Returns a 2D numpy array representing the product of the matrices `A` and `B`. For `compare_matrix_multiplication`: * Returns a dictionary with the keys `\'naive\'` and `\'strassen\'`, each mapping to the respective execution times in seconds for multiplying `A` and `B` using the naive and Strassen\'s methods. Constraints * You may assume (n geq 1) and (n) is a power of 2 (padding with zeros if necessary for general cases). * The matrix elements will be integers within the range ([-100, 100]). * Use numpy for matrix operations. Requirements * Implement the 7 recursive multiplications and additions of Strassen\'s algorithm. * Handle matrix padding for non-power-of-2 dimensions within your implementation. * Use time measurements for performance comparison. Performance Considerations * The solution should handle matrix dimensions up to 2048x2048 efficiently. Example ```python import numpy as np A = np.array([ [1, 2], [3, 4] ]) B = np.array([ [5, 6], [7, 8] ]) C_strassen = strassen_matrix_multiplication(A, B) performance_comparison = compare_matrix_multiplication(A, B) # Example output for strassen_matrix_multiplication (values are illustrative): # C_strassen should roughly look like: # [ # [19, 22], # [43, 50] # ] # Example output for compare_matrix_multiplication (values are illustrative): # performance_comparison should roughly look like: # { # \'naive\': 0.0023, # \'strassen\': 0.0018 # } ```","solution":"import numpy as np import time def strassen_matrix_multiplication(A: np.ndarray, B: np.ndarray) -> np.ndarray: assert A.shape == B.shape, \'Matrices must be the same size\' assert A.shape[0] == A.shape[1], \'Matrices must be square\' n = A.shape[0] if n == 1: return A * B mid = n // 2 # Splitting the matrices into quadrants A11, A12, A21, A22 = A[:mid, :mid], A[:mid, mid:], A[mid:, :mid], A[mid:, mid:] B11, B12, B21, B22 = B[:mid, :mid], B[:mid, mid:], B[mid:, :mid], B[mid:, mid:] # Strassen’s formulas M1 = strassen_matrix_multiplication(A11 + A22, B11 + B22) M2 = strassen_matrix_multiplication(A21 + A22, B11) M3 = strassen_matrix_multiplication(A11, B12 - B22) M4 = strassen_matrix_multiplication(A22, B21 - B11) M5 = strassen_matrix_multiplication(A11 + A12, B22) M6 = strassen_matrix_multiplication(A21 - A11, B11 + B12) M7 = strassen_matrix_multiplication(A12 - A22, B21 + B22) C11 = M1 + M4 - M5 + M7 C12 = M3 + M5 C21 = M2 + M4 C22 = M1 + M3 - M2 + M6 # Combining the quadrants into a single matrix C = np.empty_like(A) C[:mid, :mid] = C11 C[:mid, mid:] = C12 C[mid:, :mid] = C21 C[mid:, mid:] = C22 return C def pad_matrix_to_power_of_two(A: np.ndarray) -> np.ndarray: n = A.shape[0] m = 2 ** np.ceil(np.log2(n)).astype(int) padded_A = np.zeros((m, m), dtype=A.dtype) padded_A[:n, :n] = A return padded_A def unpad_matrix(A: np.ndarray, original_size: int) -> np.ndarray: return A[:original_size, :original_size] def compare_matrix_multiplication(A: np.ndarray, B: np.ndarray) -> dict: A_pad = pad_matrix_to_power_of_two(A) B_pad = pad_matrix_to_power_of_two(B) start_time = time.time() naive_result = np.matmul(A, B) naive_time = time.time() - start_time start_time = time.time() strassen_result = strassen_matrix_multiplication(A_pad, B_pad) strassen_result = unpad_matrix(strassen_result, A.shape[0]) strassen_time = time.time() - start_time return { \'naive\': naive_time, \'strassen\': strassen_time }"},{"question":"# String Compression and Decompression Context: You need to work with string manipulation by compressing and decompressing data. This helps in minimizing the storage space required for strings and in efficient data transmission. Problem: 1. **String Compression**: - Write a function `compress_string(s: str) -> str` to compress a given string using the following rule: For a group of consecutive repeating characters, replace the group with the character followed by the number of times it appears consecutively. If a character does not repeat consecutively, it should not be followed by a number. 2. **String Decompression**: - Using the compressed string, write a function `decompress_string(s: str) -> str` to decompress it back to the original string. Requirements: 1. **`compress_string` Function**: - Input: A string `s` consisting of lowercase English letters. - Output: A compressed string where consecutive repeated characters are replaced by the character followed by its count. Single characters remain unchanged. - Examples: ```python >>> compress_string(\\"aabcccccaaa\\") \\"a2bc5a3\\" >>> compress_string(\\"abc\\") \\"abc\\" ``` 2. **`decompress_string` Function**: - Input: A compressed string `s` consisting of lowercase English letters and digits. - Output: The original string before compression. - Examples: ```python >>> decompress_string(\\"a2bc5a3\\") \\"aabcccccaaa\\" >>> decompress_string(\\"abc\\") \\"abc\\" ``` Constraints: - The input string for `compress_string` can have at most (10^4) characters. - The input string for `decompress_string` can have at most (10^4) characters. - Assume the compressed string format is always valid and follows the compression rules exactly. - Compression is case-sensitive (though only lowercase is specified for this problem). Good luck!","solution":"def compress_string(s: str) -> str: if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: if count > 1: compressed.append(s[i - 1] + str(count)) else: compressed.append(s[i - 1]) count = 1 # Append the last set of characters if count > 1: compressed.append(s[-1] + str(count)) else: compressed.append(s[-1]) return \'\'.join(compressed) def decompress_string(s: str) -> str: decompressed = [] i = 0 while i < len(s): if s[i].isdigit(): raise ValueError(\\"Invalid compressed format\\") char = s[i] j = i + 1 count = 0 while j < len(s) and s[j].isdigit(): count = count * 10 + int(s[j]) j += 1 if count == 0: decompressed.append(char) else: decompressed.append(char * count) i = j return \'\'.join(decompressed)"},{"question":"# Problem Statement: Managing Event Schedules Using Binary Search Trees Context: Scheduling and managing events efficiently is crucial in many applications. Given a list of events and their time intervals, one needs to efficiently manage these events to find conflicts, insert new events, and remove existing ones. Binary Search Trees (BST) can provide efficient solutions for such problems when extended suitably. Task: Implement an Event Scheduler using a Binary Search Tree (BST) that supports inserting events, detecting conflicts, and removing events. Each event is defined by a start time and an end time. Requirements: 1. **Class Signature:** ```python class EventScheduler: def __init__(self): Initialize the scheduler with an empty set of events. def insert_event(self, start: int, end: int) -> bool: Inserts an event with given start and end time. Returns True if the event was added successfully, False if it conflicts with an existing event. def remove_event(self, start: int, end: int) -> bool: Removes an event with the given start and end time. Returns True if the event was removed, False if no such event exists. def find_conflict(self, start: int, end: int) -> bool: Checks if an event with given start and end time conflicts with existing events. Returns True if a conflict is found, False otherwise. ``` 2. The BST should be self-balancing to ensure optimal performance (e.g., AVL tree or Red-Black tree). 3. The scheduler must handle overlapping event intervals effectively. Input: * **start** (int): The start time of the event. * **end** (int): The end time of the event. Output: * `insert_event`: Returns True if the event is inserted successfully, otherwise returns False. * `remove_event`: Returns True if the event is removed successfully, otherwise returns False. * `find_conflict`: Returns True if there is a conflict, otherwise returns False. Constraints: * (0 leq text{start} < text{end} leq 10^9) * The scheduler must handle a large number of events efficiently (e.g., up to (10^6) events). Example: ```python scheduler = EventScheduler() # Insert events print(scheduler.insert_event(10, 20)) # True print(scheduler.insert_event(15, 25)) # False (conflict with existing event) print(scheduler.insert_event(20, 30)) # True # Check conflicts print(scheduler.find_conflict(15, 25)) # True print(scheduler.find_conflict(25, 35)) # False # Remove events print(scheduler.remove_event(10, 20)) # True print(scheduler.remove_event(10, 20)) # False (already removed) ``` Notes: * Ensure that the scheduler handles overlapping intervals correctly when checking for conflicts and inserting new events. * Take edge cases into account, such as events that start or end at the same time. This problem requires efficient management of events through the use of a Binary Search Tree, focusing on conflict detection and the ability to handle high volumes of data competently. It tests the understanding of advanced data structures and their applications in real-world scenarios.","solution":"class TreeNode: def __init__(self, start, end): self.start = start self.end = end self.left = None self.right = None class EventScheduler: def __init__(self): self.root = None def insert_event(self, start: int, end: int) -> bool: Inserts an event with given start and end time. Returns True if the event was added successfully, False if it conflicts with an existing event. def insert(node, start, end): if node is None: return TreeNode(start, end) if start >= node.end: node.right = insert(node.right, start, end) elif end <= node.start: node.left = insert(node.left, start, end) else: return node # Conflict return node if self.find_conflict(start, end): return False self.root = insert(self.root, start, end) return True def remove_event(self, start: int, end: int) -> bool: Removes an event with the given start and end time. Returns True if the event was removed, False if no such event exists. def remove(node, start, end): if node is None: return node, False if start > node.end: node.right, removed = remove(node.right, start, end) elif end < node.start: node.left, removed = remove(node.left, start, end) elif node.start == start and node.end == end: if node.left is None: return node.right, True if node.right is None: return node.left, True # Find minimum node in the right subtree min_larger_node = node.right while min_larger_node.left: min_larger_node = min_larger_node.left node.start, node.end = min_larger_node.start, min_larger_node.end node.right, _ = remove(node.right, min_larger_node.start, min_larger_node.end) removed = True else: removed = False return node, removed self.root, removed = remove(self.root, start, end) return removed def find_conflict(self, start: int, end: int) -> bool: Checks if an event with given start and end time conflicts with existing events. Returns True if a conflict is found, False otherwise. def is_conflicting(node, start, end): if node is None: return False if start < node.end and end > node.start: return True if end <= node.start: return is_conflicting(node.left, start, end) else: return is_conflicting(node.right, start, end) return is_conflicting(self.root, start, end)"}]'),F={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},L={class:"search-container"},O={class:"card-container"},N={key:0,class:"empty-state"},R=["disabled"],z={key:0},P={key:1};function D(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",L,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",O,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",N,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",P,"Loading...")):(n(),i("span",z,"See more"))],8,R)):u("",!0)])}const j=c(F,[["render",D],["__scopeId","data-v-e73c098b"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/31.md","filePath":"drive/31.md"}'),Y={name:"drive/31.md"},V=Object.assign(Y,{setup(r){return(e,l)=>(n(),i("div",null,[x(j)]))}});export{B as __pageData,V as default};
