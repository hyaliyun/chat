import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},N={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const E=c(k,[["render",A],["__scopeId","data-v-4fb06735"]]),O=JSON.parse('[{"question":"# Red-Black Tree Node Retrieval Context You are working on a Red-Black Tree implementation as part of a larger software application requiring efficient order statistics operations. One operation frequently needed is to retrieve the k-th smallest element in the tree. Task Implement a function in the `RBTree` class to retrieve the k-th smallest element in the tree. You may use helper functions and should view the tree as adhering the constraints of the Red-Black Tree as implemented above. Function ```python def kth_smallest(self, k: int) -> int: Retrieve the k-th smallest element in the tree. :param k: The 1-based index of the desired element. :return: The value of the k-th smallest element. ``` Input and Output - **Input**: An integer `k`, representing the 1-based position of the desired element. - **Output**: The value of the k-th smallest element. Raise an exception if `k` is out of bounds. Constraints - The function should handle cases where `k` is less than 1 or greater than the number of elements in the tree. - You may assume the elements are distinct in the tree. - Consider edge cases such as an empty tree or k being larger than the size of the tree. Performance Requirements - The function should efficiently retrieve the k-th smallest element in O(log n) to O(n) time, where n is the number of nodes. Example ```python rb_tree = RBTree() nodes = [RBNode(10, 1), RBNode(20, 1), RBNode(5, 1), RBNode(1, 1), RBNode(15, 1)] for node in nodes: rb_tree.insert(node) assert rb_tree.kth_smallest(1) == 1 assert rb_tree.kth_smallest(3) == 10 assert rb_tree.kth_smallest(5) == 20 ``` Write the implementation for `kth_smallest` function in the given `RBTree` class.","solution":"class RBNode: def __init__(self, key, color, left=None, right=None, parent=None): self.key = key self.color = color # 0 for Black, 1 for Red self.left = left self.right = right self.parent = parent self.size = 1 # Initially every node is treated as a single-node tree class RBTree: def __init__(self): self.nil = RBNode(None, 0) self.root = self.nil def insert(self, z): y = self.nil x = self.root while x != self.nil: x.size += 1 # Increment size of subtree y = x if z.key < x.key: x = x.left else: x = x.right z.parent = y if y == self.nil: self.root = z elif z.key < y.key: y.left = z else: y.right = z z.left = self.nil z.right = self.nil z.color = 1 # Red self.fix_insert(z) def fix_insert(self, z): # Fixing logic omitted for brevity pass def kth_smallest(self, k): def inorder_traverse(node): if node == self.nil: return [] return inorder_traverse(node.left) + [node.key] + inorder_traverse(node.right) if k < 1 or k > self.root.size: raise IndexError(\\"k is out of bounds\\") result = inorder_traverse(self.root) return result[k - 1] # Example setup rb_tree = RBTree() nodes = [RBNode(10, 1), RBNode(20, 1), RBNode(5, 1), RBNode(1, 1), RBNode(15, 1)] for node in nodes: rb_tree.insert(node) print(rb_tree.kth_smallest(1)) # Should print 1 print(rb_tree.kth_smallest(3)) # Should print 10 print(rb_tree.kth_smallest(5)) # Should print 20"},{"question":"# Intersection of Two Singly Linked Lists Problem Statement: You are provided with two singly linked lists. Write a function that determines if the two lists intersect and returns the intersecting node. Intersection is defined by reference, not value. Function Signature: ```python def find_intersection(headA: Node, headB: Node) -> Optional[Node]: :param headA: The head node of the first linked list. :param headB: The head node of the second linked list. :return: The node at which the intersection of the two linked lists begins, or None if there is no intersection. ``` Input: * Two singly linked lists defined by their head nodes `headA` and `headB`. Output: * Return the intersecting node or `None` if there is no intersection. Constraints: * The lists should be traversed only once. * Use of extra space should be minimized. Example: ```python # Example 1: # listA: 1 -> 3 -> 5 # # 7 -> 9 -> 11 # / # listB: 2 -> 4 -> 6 # Intersection at node with value 7 # Example 2: # listA: 1 -> 2 -> 3 # listB: 4 -> 5 -> 6 # Intersection: None ``` Note: * The nodes themselves are considered for intersection, not their values.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def find_intersection(headA: Node, headB: Node) -> Node: :param headA: The head node of the first linked list. :param headB: The head node of the second linked list. :return: The node at which the intersection of the two linked lists begins, or None if there is no intersection. if not headA or not headB: return None # Two pointers for traversing the two lists ptrA, ptrB = headA, headB # Use two iterations to optimize traversing the lists while ptrA is not ptrB: # Move to the next node in each list, or switch to the start of the other list ptrA = ptrA.next if ptrA else headB ptrB = ptrB.next if ptrB else headA # Either intersection node or None return ptrA"},{"question":"--- **Scenario**: You are given an array of integers that you need to sort for a competitive programming contest. The input might not always be sorted, and efficiency is a key consideration to ensure your implemented algorithm runs within allowed time limits even for relatively large arrays. Equipped with the knowledge of Shell Sort, your task is to implement a more flexible version of this sorting algorithm that allows different gap sequences for optimization. # Problem Description: Implement the function `optimized_shell_sort` that sorts an array of integers in ascending order using Shell Sort algorithm. Your implementation should allow the use of three different types of gap sequences: 1. Default sequence (n/2, n/4, ..., 1 [as given in the provided code]). 2. Hibbard Sequence (1, 3, 7, 15, ..., 2^k-1) 3. Sedgewick Sequence (1, 5, 19, 41, 109, ...) # Function Signature: ```python def optimized_shell_sort(arr: List[int], sequence: str) -> List[int]: \'\'\' :param arr: A list of integers to be sorted. :param sequence: A string indicating the gap sequence to use: \'default\', \'hibbard\', or \'sedgewick\'. :return: A list of integers sorted in ascending order. \'\'\' ``` # Input: - `arr`: List of integers (length `n`, 1 ≤ `n` ≤ 10^5). - `sequence`: A string \'default\', \'hibbard\', or \'sedgewick\'. # Output: - A list of integers sorted in ascending order. # Constraints: - Ensure that your implementation performs within O(n^2) time complexity in the worst case. - Regardless of the chosen sequence, the function should be able to sort arrays up to 100,000 elements. # Example Usage: ```python print(optimized_shell_sort([23, 12, 1, 8, 34, 54, 2, 3], \'default\')) # Output: [1, 2, 3, 8, 12, 23, 34, 54] print(optimized_shell_sort([4, 2, 7, 1, 3], \'hibbard\')) # Output: [1, 2, 3, 4, 7] print(optimized_shell_sort([5, 3, 8, 6, 2], \'sedgewick\')) # Output: [2, 3, 5, 6, 8] ``` # Notes: - Carefully design gap sequences for \'hibbard\' and \'sedgewick\'. - Provide sufficient test cases to ensure the correctness of your implementation. - Consider performance implications for large arrays.","solution":"def optimized_shell_sort(arr, sequence): Sorts an array of integers using the Shell Sort algorithm with a specified gap sequence. :param arr: List of integers to be sorted. :param sequence: A string indicating the gap sequence to use: \'default\', \'hibbard\', or \'sedgewick\'. :return: A list of integers sorted in ascending order. def default_sequence(n): seq = [] gap = n // 2 while gap > 0: seq.append(gap) gap //= 2 return seq def hibbard_sequence(n): seq = [] k = 1 while (2**k - 1) < n: seq.append(2**k - 1) k += 1 return list(reversed(seq)) def sedgewick_sequence(n): seq = [] k = 0 while True: if k % 2 == 0: gap = 9 * (2**k - 2**(k//2)) + 1 else: gap = 8 * 2**k - 6 * 2**((k+1)//2) + 1 if gap < n: seq.append(gap) else: break k += 1 return list(reversed(seq)) if sequence == \'default\': gaps = default_sequence(len(arr)) elif sequence == \'hibbard\': gaps = hibbard_sequence(len(arr)) elif sequence == \'sedgewick\': gaps = sedgewick_sequence(len(arr)) else: raise ValueError(\\"Invalid sequence type. Choose from \'default\', \'hibbard\', or \'sedgewick\'.\\") for gap in gaps: for i in range(gap, len(arr)): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"In many programming challenges, determining specific digits at certain positions within a large sequence of concatenated numbers can be crucial. Your task is to implement a function that efficiently finds the nth digit in the infinite integer sequence \\"123456789101112...\\". **Function Signature**: ```python def find_nth_digit(n: int) -> int: pass ``` # Input - `n`: An integer representing the position of the digit in the sequence (1-indexed). # Output - Returns an integer representing the digit at the nth position. # Examples Example 1 ```python n = 3 print(find_nth_digit(n)) # Output: 3 ``` *Explanation*: The 3rd digit in the sequence \\"123456789...\\" is `3`. Example 2 ```python n = 11 print(find_nth_digit(n)) # Output: 0 ``` *Explanation*: The sequence begins as \\"12345678910...\\", so the 11th digit is `0`. Example 3 ```python n = 15 print(find_nth_digit(n)) # Output: 2 ``` *Explanation*: The sequence follows \\"123456789101112131415...\\", so the 15th digit is `2`. # Constraints - (1 leq n leq 2 times 10^9) # Requirements - The function should be efficient, ideally with logarithmic time complexity. - Handle large values of `n` gracefully without significant performance degradation. # Notes - The sequence is continuous and does not contain separation characters. - Consider using integer division (`//`) to avoid floating-point arithmetic issues where applicable.","solution":"def find_nth_digit(n: int) -> int: # Define variables for the current length of numbers and the current count of digits length = 1 count = 9 start = 1 # Find the range where the nth digit lies while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Find the exact number that contains the nth digit start += (n - 1) // length str_start = str(start) # Find the exact digit within the number result = str_start[(n - 1) % length] return int(result)"},{"question":"You are required to implement a MinStack: a special stack that, in addition to standard push and pop operations, supports a minimum operation that returns the smallest element in the stack. This should be efficiently supported in O(1) time complexity. # Requirements Implement the `MinStack` class with the following operations: 1. `push(value: int) -> None`: Pushes the value onto the stack. 2. `pop() -> int`: Removes and returns the value on the top of the stack. 3. `peek() -> int`: Returns the top element without removing it. 4. `get_min() -> int`: Returns the minimum element in the stack. # Constraints - All operations must be O(1) time complexity. - Assume the stack will not be empty when calling pop/peek/get_min operations. # Example ```python min_stack = MinStack() min_stack.push(5) min_stack.push(3) min_stack.push(7) min_stack.push(2) assert min_stack.get_min() == 2 assert min_stack.pop() == 2 assert min_stack.get_min() == 3 assert min_stack.peek() == 7 assert min_stack.get_min() == 3 min_stack.push(1) assert min_stack.get_min() == 1 ``` # Hints - Consider using an auxiliary stack to keep track of the minimum values.","solution":"class MinStack: def __init__(self): Initialize two stacks: one for the values and one for the minimum values. self.stack = [] self.min_stack = [] def push(self, value: int) -> None: Pushes the value onto the stack. Also updates the min_stack. self.stack.append(value) if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self) -> int: Removes and returns the value on the top of the stack. Also updates the min_stack if necessary. top = self.stack.pop() if top == self.min_stack[-1]: self.min_stack.pop() return top def peek(self) -> int: Returns the top element without removing it. return self.stack[-1] if self.stack else None def get_min(self) -> int: Returns the minimum element in the stack. return self.min_stack[-1] if self.min_stack else None"},{"question":"# Scenario You are working on a text processing module that needs to identify the first non-repeating character in various strings provided by users. Efficiently identifying such characters will help in various text analysis tasks, such as frequency analysis and unique element identification in large text datasets. # Task Write a function `first_unique_char_optimized(s)` that improves on the time complexity of the provided algorithm to find the index of the first non-repeating character in a given string. Your solution should be efficient and handle large inputs gracefully. # Input and Output Formats * **Input**: A string `s` which consists of lowercase English letters. * **Output**: Return the index of the first non-repeating character. If it doesn\'t exist, return -1. # Constraints * (1 leq text{length of } s leq 10^5) # Examples 1. Input: `s = \\"leetcode\\"` Output: `0` 2. Input: `s = \\"loveleetcode\\"` Output: `2` 3. Input: `s = \\"aabb\\"` Output: `-1` # Performance Requirements * Your implementation should aim for a time complexity of (O(n)) where (n) is the length of the string. * The space complexity should also be kept as low as possible, preferably (O(1)) additional space, not counting the input string.","solution":"def first_unique_char_optimized(s): Finds the index of the first non-repeating character in the given string. Parameters: s (str): The input string consisting of lowercase English letters. Returns: int: Index of the first non-repeating character. If there is no such character, return -1. # Create a dictionary to store the frequency of each character char_count = {} # Populate the dictionary with the frequency of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Loop through the string again to find the index of the first unique character for index, char in enumerate(s): if char_count[char] == 1: return index # If no unique character found, return -1 return -1"},{"question":"You are given a binary tree with integer values in its nodes, and you need to traverse and return the values in the in-order manner, but this time, you need to return a list which represents the level-wise in-order traversal, i.e., For each level of the tree, you will perform an in-order traversal and return nodes present at that level in in-order traversal manner. # Input The input will be provided as the root of a binary tree. # Output A list of lists, each inner list contains elements in in-order traversal for each respective level of the binary tree. # Example Consider the binary tree structure provided below: ``` 1 / 2 3 / / 4 5 6 7 ``` If the root of this tree is provided, the output should be: ``` [[1], [2, 3], [4, 5, 6, 7]] ``` # Constraints * You can assume the height of the binary tree does not exceed 1000 nodes. * The values of the nodes are unique. Implementation Requirements * Your solution should include both iterative and recursive method options for the traversal. # Function Signature ```python def level_wise_inorder_traversal(root: Node) -> List[List[int]]: pass ```","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def inorder_traversal(root, level, levels): Helper method to perform inorder traversal. if root is None: return # Ensure the current level exists in levels if len(levels) == level: levels.append([]) # Traverse left child inorder_traversal(root.left, level + 1, levels) # Add current node to its level list levels[level].append(root.value) # Traverse right child inorder_traversal(root.right, level + 1, levels) def level_wise_inorder_traversal(root): Given the root of a binary tree, return the values in the level-wise in-order traversal manner. levels = [] inorder_traversal(root, 0, levels) return levels"},{"question":"You are a professional diver exploring a coral reef. Along the reef, there are several treasure chests, each containing a certain amount of treasure. However, opening two adjacent chests would startle the fish and alert the reef\'s guard creatures. Given a list of non-negative integers representing the amount of treasure in each chest, determine the maximum amount of treasure you can collect without startling the fish by opening two adjacent chests. # Task Implement the function `maximum_treasure(chests)` that computes the maximum amount of treasure that can be collected. # Input * `chests`: A list of non-negative integers where `chests[i]` is the amount of treasure in the i-th chest. # Output * The function should return a single integer representing the maximum amount of treasure that can be collected. # Constraints * `0 <= len(chests) <= 1000` * `0 <= chests[i] <= 1000` # Example ```python def maximum_treasure(chests): last, now = 0, 0 for chest in chests: last, now = now, max(last + chest, now) return now # Example print(maximum_treasure([2, 3, 2])) # Output: 4 print(maximum_treasure([1, 2, 3, 1])) # Output: 4 print(maximum_treasure([5, 1, 1, 5])) # Output: 10 ``` In the first example, the best choice is to rob house 1 and house 3 for a total amount of 2 + 2 = 4. In the second example, the optimal solution is to rob house 1 and house 3 for a total amount of 1 + 3 = 4. # Notes Consider edge cases such as: * An empty list, which should result in 0. * A list with only one chest, which should return the value of that single chest. * Lists with maximum values to ensure it handles larger numbers effectively.","solution":"def maximum_treasure(chests): Returns the maximum amount of treasure that can be collected without opening two adjacent chests. last, now = 0, 0 for chest in chests: last, now = now, max(last + chest, now) return now"},{"question":"**Scenario**: Imagine that you\'re working on a legacy codebase dealing with sorting arrays of integers collected from a variety of sensors. Your task is to implement a sorting function, but due to an error-prone environment, you have been advised to use a stable and simple sorting algorithm. **Task**: Given the inherent instability of the sensor data, implement the `cocktail_shaker_sort` function. Ensure that your function is equipped to handle arrays of varying lengths, including edge cases like already sorted arrays and arrays with identical elements. # Function Signature ```python def cocktail_shaker_sort(arr: list) -> list: pass ``` # Input * `arr` (list): A list of integers to sort. The list can be empty, contain identical elements, or be already sorted. # Output * The function should return a new list with the integers sorted in non-decreasing order. # Constraints * The input list does not have a size limit but expect typical usage to be N <= 10^4. * The integers are within typical sensor value ranges, i.e., -10^6 <= value <= 10^6. # Example ```python assert cocktail_shaker_sort([3, 2, 0, -1, 5]) == [-1, 0, 2, 3, 5] assert cocktail_shaker_sort([1, 1, 1, 1]) == [1, 1, 1, 1] assert cocktail_shaker_sort([]) == [] assert cocktail_shaker_sort([2, 1, 3, 1, 2]) == [1, 1, 2, 2, 3] ``` # Performance Requirements * Given the time complexity is O(N^2), note that the solution should be efficient enough for typical usage up to 10^4 elements. # Additional Notes * Ensure that your function includes appropriate early termination conditions to optimize performance for already sorted arrays. * Your implementation should not alter the input list in place; it should return a new sorted list.","solution":"def cocktail_shaker_sort(arr: list) -> list: Sorts the input list using the cocktail shaker sort algorithm. Args: arr (list): A list of integers to sort. Returns: list: A new list with the integers sorted in non-decreasing order. if not arr: return [] n = len(arr) sorted_list = arr[:] start = 0 end = n - 1 while start < end: new_end = start for i in range(start, end): if sorted_list[i] > sorted_list[i + 1]: sorted_list[i], sorted_list[i + 1] = sorted_list[i + 1], sorted_list[i] new_end = i end = new_end new_start = end for i in range(end - 1, start - 1, -1): if sorted_list[i] > sorted_list[i + 1]: sorted_list[i], sorted_list[i + 1] = sorted_list[i + 1], sorted_list[i] new_start = i start = new_start + 1 return sorted_list"},{"question":"You are tasked with implementing a function to calculate the factorial of a given non-negative integer `n`, optionally computing it modulo a given positive integer `mod`. You need to handle this both iteratively and recursively. Specifically, you must write two functions: 1. `factorial_cust(n: int, mod: int = None) -> int`: Iteratively computes the factorial of `n`. If `mod` is provided, the function should return the factorial modulo `mod`. 2. `factorial_recur_cust(n: int, mod: int = None) -> int`: Recursively computes the factorial of `n`. If `mod` is provided, the function should return the factorial modulo `mod`. # Requirements * Your solution should handle edge cases where `n` is 0 or where `mod` is not provided. * You must ensure type and value checks for the inputs: * `n` must be a non-negative integer. * If provided, `mod` must be a positive integer. * Aim for efficient execution, keeping in mind the provided analysis. # Input * `n` (integer): A non-negative integer representing the value for which factorial is to be calculated. (0 <= n <= 10^5) * `mod` (integer, optional): A positive integer to be used for calculating the result modulo `mod`. # Output * Return the factorial of `n`. If `mod` is provided, return the factorial modulo `mod`. # Constraints * 0 <= `n` <= 10^5 * If `mod` is provided, it will be a positive integer. # Scenarios 1. factorial_cust(5) * Expected Output: 120 2. factorial_cust(5, 3) * Expected Output: 0 3. factorial_recur_cust(5) * Expected Output: 120 4. factorial_recur_cust(5, 3) * Expected Output: 0 # Example Usage ```python print(factorial_cust(5)) # Output: 120 print(factorial_cust(5, 3)) # Output: 0 print(factorial_recur_cust(5)) # Output: 120 print(factorial_recur_cust(5, 3)) # Output: 0 ``` Write your implementations for `factorial_cust` and `factorial_recur_cust` functions below:","solution":"def factorial_cust(n: int, mod: int = None) -> int: Iteratively computes the factorial of n. If mod is provided, returns the factorial modulo mod. if not isinstance(n, int) or n < 0: raise ValueError(\\"n must be a non-negative integer\\") if mod is not None and (not isinstance(mod, int) or mod <= 0): raise ValueError(\\"mod must be a positive integer\\") result = 1 for i in range(1, n + 1): result *= i if mod: result %= mod return result def factorial_recur_cust(n: int, mod: int = None) -> int: Recursively computes the factorial of n. If mod is provided, returns the factorial modulo mod. if not isinstance(n, int) or n < 0: raise ValueError(\\"n must be a non-negative integer\\") if mod is not None and (not isinstance(mod, int) or mod <= 0): raise ValueError(\\"mod must be a positive integer\\") if n == 0 or n == 1: return 1 result = n * factorial_recur_cust(n - 1, mod) if mod: result %= mod return result"},{"question":"You are given a list `lst` and a number `N`. Your task is to create a new list that contains each number of the list at most `N` times without reordering the elements. Function Signature ```python def delete_nth(array: List[int], n: int) -> List[int]: ``` Input * `array`: A list of integers `[a1, a2, ..., ak]` where `0 <= k <= 10^6`. * `n`: An integer `0 <= n <= 10^6`. Output * A new list containing each number of the input list at most `N` times, maintaining the original order. Constraints * Preserve the order of elements. * Implement an efficient solution with a time complexity of O(n). Performance Requirements * The function should run within acceptable time limits for large lists, meaning optimized for time complexity O(n). * Space complexity should also be considered, ideally O(n). # Examples 1. **Example 1**: ```python array = [1, 2, 3, 1, 2, 1, 2, 3] n = 2 delete_nth(array, n) ``` * Output: `[1, 2, 3, 1, 2, 3]` 2. **Example 2**: ```python array = [20, 37, 20, 21] n = 1 delete_nth(array, n) ``` * Output: `[20, 37, 21]` 3. **Example 3**: ```python array = [] n = 2 delete_nth(array, n) ``` * Output: `[]` Scenario You are working on a data filtering system where you need to ensure that certain values do not appear more than a specified number of times in the results. This could be useful in scenarios such as limiting the frequency of recommendations, filtering logs for repetitive entries, or managing subscriptions in user notifications.","solution":"from typing import List def delete_nth(array: List[int], n: int) -> List[int]: Returns a list such that each element appears at most n times without reordering. count_dict = {} result = [] for item in array: current_count = count_dict.get(item, 0) if current_count < n: result.append(item) count_dict[item] = current_count + 1 return result"},{"question":"As a software engineer, your task is to create an optimized version of the Insertion Sort algorithm. You will improve the provided baseline insertion sort algorithm by implementing a feature that ensures the function handles large, nearly sorted datasets efficiently. Implement the function `optimized_insertion_sort` that uses a binary search to find the insertion position within each iteration, reducing the number of comparisons necessary. Function Signature ```python def optimized_insertion_sort(arr: list) -> list: pass ``` Input * `arr`: A list of integers that needs to be sorted. Output * A new list of integers sorted in ascending order. Constraints * The function should handle arrays with lengths up to 10,000 elements efficiently. * Do not use any built-in sorting functions. Performance Requirements * Aim to improve the best-case scenario to maintain linearithmic (O(n log n)) performances when the input is nearly sorted. Example ```python # Example Input arr = [5, 2, 9, 1, 5, 6] # Function Call sorted_arr = optimized_insertion_sort(arr) # Example Output print(sorted_arr) # Output should be [1, 2, 5, 5, 6, 9] ``` Notes * Consider edge cases like an empty array, arrays with one element, and arrays with all elements being the same. * Ensure that your implementation is stable (i.e., it does not change the relative order of elements with equal keys).","solution":"def binary_search(arr, val, start, end): # We need to use binary search to find the correct insertion position while start < end: mid = (start + end) // 2 if arr[mid] < val: start = mid + 1 else: end = mid return start def optimized_insertion_sort(arr): This function sorts an array using an optimized version of insertion sort. It uses binary search to find the appropriate position for each element. # We make a copy of the array to avoid modifying the original sorted_arr = arr.copy() for i in range(1, len(sorted_arr)): val = sorted_arr[i] # Find the position where val fits in the sorted part j = binary_search(sorted_arr, val, 0, i) # Move all elements from the position of insertion to the right by one sorted_arr = sorted_arr[:j] + [val] + sorted_arr[j:i] + sorted_arr[i+1:] return sorted_arr"},{"question":"# Question: AVL Tree Implementation and Height Retrieval As part of your studies of self-balancing trees, you\'ve been given the task to extend an AVL Tree implementation. Your goal is to implement a method to retrieve the height of the AVL Tree at any given time after multiple insertions. An AVL Tree is a type of self-balancing binary search tree where the difference between the heights of the left and right subtrees cannot be more than one for all nodes. **Task**: Implement a function `get_tree_height` that, given a series of insertions into an AVL Tree, returns the height of the tree after all insertions. Function Signature ```python class AVLTree: AVL Tree implementation # Other class methods here... def insert(self, key): Inserts a key into the AVLTree and rebalances it if necessary. pass def get_tree_height(self): Returns the height of the AVL Tree. pass ``` Input * A list of integers representing keys to be inserted sequentially into the AVL Tree. Output * An integer representing the height of the AVL Tree after all insertions. Example: ```python # Initialize the AVL Tree avl_tree = AVLTree() # Insert elements inserts = [20, 4, 15, 70, 50, 100, 10] for key in inserts: avl_tree.insert(key) # Get the height of the tree print(avl_tree.get_tree_height()) # Expected output could be 3, considering balancing ``` Constraints: * The list of integers (keys) will be unique. * The number of insertions will be between 1 and 10^5. Performance Requirements: * Your solution should efficiently handle up to 10^5 insertions. Implement the AVL Tree class with the specified `insert` and `get_tree_height` methods, ensuring the tree remains balanced after each insertion.","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def get_height(self, node): if not node: return 0 return node.height def update_height(self, node): if node: node.height = 1 + max(self.get_height(node.left), self.get_height(node.right)) def get_balance(self, node): if not node: return 0 return self.get_height(node.left) - self.get_height(node.right) def rotate_right(self, z): y = z.left T3 = y.right y.right = z z.left = T3 self.update_height(z) self.update_height(y) return y def rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 self.update_height(z) self.update_height(y) return y def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): # Perform the normal BST insert if not node: return Node(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) # Update the height of this ancestor node self.update_height(node) # Get the balance factor balance = self.get_balance(node) # If the node becomes unbalanced, then there are 4 cases # Left Left Case if balance > 1 and key < node.left.key: return self.rotate_right(node) # Right Right Case if balance < -1 and key > node.right.key: return self.rotate_left(node) # Left Right Case if balance > 1 and key > node.left.key: node.left = self.rotate_left(node.left) return self.rotate_right(node) # Right Left Case if balance < -1 and key < node.right.key: node.right = self.rotate_right(node.right) return self.rotate_left(node) return node def get_tree_height(self): return self.get_height(self.root)"},{"question":"# Question: Base Conversion Utility You are tasked with writing an extended version of the base conversion utility, providing additional functionalities and handling a wider range of cases. This new version allows users to convert numbers between various numeral systems safely and efficiently. Function 1: `int_to_base` Implement a function `int_to_base(num, base)` that converts an integer `num` to its representation in the specified `base`. * **Input**: * `num` (int): The integer number to convert. * `base` (int): The base to convert the number to (between 2 and 36). * **Output**: * A string representing `num` in the specified `base`. * **Constraints**: * Implement error handling for invalid base values (less than 2 or greater than 36). Function 2: `base_to_int` Implement a function `base_to_int(str_to_convert, base)` that converts a string `str_to_convert` from the specified `base` to a decimal integer. * **Input**: * `str_to_convert` (str): The string representing the number in the specified base. * `base` (int): The base of the input string (between 2 and 36). * **Output**: * An integer that is the decimal conversion of the string. * **Constraints**: * Implement error handling for invalid base values. * Validate the input string to ensure it only contains characters valid for the given base. Example ```python # Example Usage: assert int_to_base(255, 16) == \\"FF\\" assert int_to_base(-255, 16) == \\"-FF\\" assert base_to_int(\\"FF\\", 16) == 255 assert base_to_int(\\"-FF\\", 16) == -255 ```","solution":"def int_to_base(num, base): if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" negative = num < 0 num = abs(num) result = \\"\\" while num: result = digits[num % base] + result num //= base if negative: result = \\"-\\" + result return result def base_to_int(str_to_convert, base): if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" str_to_convert = str_to_convert.upper() negative = str_to_convert.startswith(\'-\') if negative: str_to_convert = str_to_convert[1:] for char in str_to_convert: if char not in digits[:base]: raise ValueError(f\\"Character {char} is not valid for base {base}\\") result = 0 for char in str_to_convert: result = result * base + digits.index(char) if negative: result = -result return result"},{"question":"You are required to build a min binary heap with an additional feature: **Function to Return K Smallest Elements:** * You need to implement a method `k_smallest_elements(k)` which returns a list of the k smallest elements in the heap without removing them from the heap. # Requirements: - Implement the `k_smallest_elements(k)` method inside the `BinaryHeap` class. - You may make use of auxiliary space and helper functions if necessary. - The method should not alter the original heap. - Performance Expectations: Ideally, the time complexity should be better than O(N * log N). # Input Format * `k` (1 ≤ k ≤ N) - An integer representing the number of smallest elements to return. # Output Format * A list of k smallest elements from the heap. # Constraints * Consider the heap is already populated with random integers, like so: ```python heap = BinaryHeap() heap.insert(4) heap.insert(50) heap.insert(7) heap.insert(55) heap.insert(90) heap.insert(87) ``` # Example: ```python heap = BinaryHeap() heap.insert(4) heap.insert(50) heap.insert(7) heap.insert(55) heap.insert(90) heap.insert(87) k = 3 print(heap.k_smallest_elements(k)) # Output: [4, 7, 50] ``` Implementation Hint: You might need to utilize a secondary data structure to keep track of the smallest elements efficiently.","solution":"import heapq class BinaryHeap: def __init__(self): self.heap = [] def insert(self, element): heapq.heappush(self.heap, element) def k_smallest_elements(self, k): Returns the k smallest elements from the heap without removing them. # Copy the heap to avoid modifying the original heap temp_heap = self.heap[:] # Extract the k smallest elements using `heapq.nsmallest` method return heapq.nsmallest(k, temp_heap)"},{"question":"**Transitive Closure Calculation of a Directed Graph** # Objective You are given a directed graph, and your task is to compute its transitive closure. The graph is represented by an adjacency list, and the transitive closure should be represented as a binary matrix. # Inputs 1. An integer **V** representing the number of vertices in the graph. 2. A list of tuples **edges** where each tuple (u, v) represents a directed edge from vertex **u** to vertex **v**. # Outputs Return a 2D list (matrix) representing the transitive closure. The matrix should be `VxV` where the cell (i, j) is 1 if there is a path from vertex i to vertex j, otherwise 0. # Constraints 1. 1 ≤ V, number of vertices ≤ 100 2. 0 ≤ len(edges) ≤ V*(V-1) # Example Input ```python V = 4 edges = [(0, 1), (1, 2), (2, 3)] ``` Output ```python [ [1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1] ] ``` # Key Criteria - Ensure your solution is efficient. - Handle edge cases where no edges exist or the graph is disconnected. - Consider the depth of recursion if you choose to use DFS as per the example provided. ```python def transitive_closure(self, vertices, edges): Compute the transitive closure of a given directed graph. Parameters: vertices (int): Number of vertices. edges (list of tuples): List of directed edges in the graph. Returns: list(list(int)): The transitive closure matrix. # Your code goes here return closure # Example usage: # V = 4 # edges = [(0, 1), (1, 2), (2, 3)] # graph = Graph(V) # for source, target in edges: # graph.add_edge(source, target) # closure = graph.transitive_closure() # print(closure) ```","solution":"def transitive_closure(V, edges): Compute the transitive closure of a given directed graph. Parameters: V (int): Number of vertices. edges (list of tuples): List of directed edges in the graph. Returns: list(list(int)): The transitive closure matrix. # Create the adjacency matrix closure = [[0] * V for _ in range(V)] # Initialize the closure matrix based on the edges for i in range(V): closure[i][i] = 1 # Each vertex is reachable from itself for u, v in edges: closure[u][v] = 1 # Floyd-Warshall algorithm to compute the transitive closure for k in range(V): for i in range(V): for j in range(V): closure[i][j] = closure[i][j] or (closure[i][k] and closure[k][j]) return closure"},{"question":"Given a sorted list of lowercase characters `letters` and a target lowercase character `target`, write a function `find_next_greatest_letter` that returns the smallest character in the list that is larger than the target. The list is considered to be circular, meaning if the target character is larger than or equal to the largest character in the list, return the first character of the list. Input: * A list of lowercase characters `letters` (sorted in ascending order). * A lowercase character `target`. Output: * A single lowercase character, the smallest character in the list that is larger than the given target. Constraints: * The length of `letters` will be in the range [2, 10^4]. * `letters` contains only lowercase letters. * `letters` is sorted in non-decreasing order. * `letters` contains at least 2 distinct characters. # Example: ```python # Example 1 letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"a\\" # Expected Output: \\"c\\" # Example 2 letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"c\\" # Expected Output: \\"f\\" # Example 3 letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"d\\" # Expected Output: \\"f\\" # Example 4 letters = [\\"a\\", \\"b\\"] target = \\"z\\" # Expected Output: \\"a\\" ``` # Requirements: * Implement the function using binary search to ensure optimal performance with a time complexity of O(log N). * Do not use built-in functions that directly perform the required operation (like `bisect`). # Function Signature: ```python def find_next_greatest_letter(letters: List[str], target: str) -> str: pass ```","solution":"from typing import List def find_next_greatest_letter(letters: List[str], target: str) -> str: left, right = 0, len(letters) - 1 if target >= letters[-1]: return letters[0] while left < right: mid = (left + right) // 2 if letters[mid] > target: right = mid else: left = mid + 1 return letters[left]"},{"question":"# Task: Binary Tree Paths As a software developer, you often need to work with data structures like binary trees. In this task, your goal is to write a function that finds all the paths from the root to leaf nodes in a binary tree and returns these paths as a list of strings. Objectives: - Implement a function `binary_tree_paths` that takes the root of a binary tree and returns a list of strings representing all the paths from the root to the leaves. Function Signature: ```python def binary_tree_paths(root: TreeNode) -> List[str]: ``` Input: - `root (TreeNode)`: The root node of a binary tree. Each node contains: - `val (int)`: An integer value. - `left (TreeNode)`: A reference to the left child node, or `None` if there is no left child. - `right (TreeNode)`: A reference to the right child node, or `None` if there is no right child. Output: - `List[str]`: A list of strings, representing all root-to-leaf paths in the tree. Each path string is formed by joining the node values along the path with `\\"->\\"`. Constraints: - The number of nodes in the binary tree is in the range [0, 100]. - The values of the nodes are unique and in the range [-1000, 1000]. Scenario: Imagine you are a robot traversing from the root to the leaves of a binary tree. At each node, you log your step with the node\'s value and the direction (left or right) you take. When you reach a leaf, you record the entire path. This task will help in determining all the paths you recorded. Example: Given the binary tree: ``` 1 / 2 3 5 ``` `binary_tree_paths(root)` should return: ```python [\\"1->2->5\\", \\"1->3\\"] ``` Notes: - Use Depth-First Search (DFS) to traverse the tree and track the paths. - Consider edge cases such as an empty tree or a tree with only a single node.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val: int=0, left: Optional[\'TreeNode\']=None, right: Optional[\'TreeNode\']=None): self.val = val self.left = left self.right = right def binary_tree_paths(root: Optional[TreeNode]) -> List[str]: if not root: return [] def dfs(node: TreeNode, path: str, paths: List[str]): if not node.left and not node.right: paths.append(path) if node.left: dfs(node.left, path + \\"->\\" + str(node.left.val), paths) if node.right: dfs(node.right, path + \\"->\\" + str(node.right.val), paths) paths = [] dfs(root, str(root.val), paths) return paths"},{"question":"# Problem: Remove Duplicates from an Unsorted Linked List Given an unsorted singly linked list, implement a function to remove all duplicates such that each element appears only once. Function to Implement: ```python def remove_duplicates(head: Node) -> Node: # Your implementation here ``` Input: * `head`: The head of the linked list Output: * Returns the head of the modified linked list with duplicates removed. # Constraints: * Do *not modify* the Node class provided. * Optimize for time complexity wherever possible. # Example: Input: * Linked List: A -> A -> B -> C -> D -> C -> F -> G Output: * Linked List: A -> B -> C -> D -> F -> G Input: * Linked List: 5 -> 1 -> 5 -> 2 -> 2 -> 4 Output: * Linked List: 5 -> 1 -> 2 -> 4 # Performance Requirements: Your solution should take into account the trade-off between time and space complexity.","solution":"class Node: def __init__(self, value=None, next=None): self.value = value self.next = next def remove_duplicates(head: Node) -> Node: if not head: return head current = head seen = set() seen.add(current.value) while current.next: if current.next.value in seen: current.next = current.next.next else: seen.add(current.next.value) current = current.next return head # Utility function to create a linked list from a list def create_linked_list(arr): if not arr: return None head = Node(arr[0]) current = head for value in arr[1:]: current.next = Node(value) current = current.next return head # Utility function to convert a linked list to a list def linked_list_to_list(head): lst = [] current = head while current: lst.append(current.value) current = current.next return lst"},{"question":"# Question: Find the Nth Digit in a Concat Sequence Given an integer `n`, write a function `find_nth_digit(n)` that returns the nth digit of the sequence formed by concatenating all positive integers sequentially (e.g., 1, 2, 3, 4, 5, ...). Function Signature ```python def find_nth_digit(n: int) -> int: pass ``` Input * `n` (1 <= n <= 2 * 10^18): a positive integer representing the position in the concatenated sequence. Output * An integer between 0 and 9 inclusive representing the nth digit in the sequence. Examples 1. `find_nth_digit(3)` should return `3` because the first few digits are \\"123\\". 2. `find_nth_digit(11)` should return `0` because the first few digits are \\"12345678910\\", and the 11th digit is `0`. 3. `find_nth_digit(15)` should return `2` because the sequence is \\"123456789101112131415...\\", and the 15th digit is `2`. Constraints and Performance Requirements * The solution should be efficient with a time complexity of O(log n). Note Ensure that your implementation is optimized to handle very large values of `n`.","solution":"def find_nth_digit(n: int) -> int: # Define the initial length of digits and the number range length = 1 count = 9 start = 1 # Determine the range of numbers where the nth digit falls into while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Determine the exact number and the digit within that number start += (n - 1) // length s = str(start) return int(s[(n - 1) % length])"},{"question":"# Question Objective Implement an `OrderedQueue` class that preserves order within a queue data structure. Specifically, elements should remain sorted based on their values, with the lowest value at the front and the highest value at the back, while supporting standard queue operations (enqueue, dequeue, etc.). Task 1. **Implement the `OrderedQueue` class** with the following methods: * `enqueue(item)`: Adds an item to the queue ensuring the order is preserved. * `dequeue()`: Removes and returns the front item from the queue. * `peek()`: Returns the front element without removing it. * `is_empty()`: Checks if the queue is empty. * `size()`: Returns the total number of elements in the queue. 2. **Constraints**: * The queue only contains integers. * The `enqueue` operation should maintain the order, from the smallest at the front to the largest at the back of the queue. * Use additional data structures if necessary but maintain an ordered queue. 3. **Edge Cases**: * Attempting to `dequeue` or `peek` from an empty queue should raise an appropriate exception. * Ensure proper handling of duplicate values. 4. **Performance**: * Aim for an efficient implementation of the `enqueue` operation. ```python # Define the OrderedQueue class as per the above requirements class OrderedQueue: def __init__(self): self.items = [] def is_empty(self): return self.items == [] def enqueue(self, item): # Implement your code for enqueue here pass def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.items.pop(0) def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.items[0] def size(self): return len(self.items) # Example usage: # q = OrderedQueue() # q.enqueue(5) # q.enqueue(3) # q.enqueue(7) # assert q.peek() == 3 # smallest element # assert q.dequeue() == 3 # assert q.size() == 2 # assert not q.is_empty() ```","solution":"class OrderedQueue: def __init__(self): self.items = [] def is_empty(self): return not self.items def enqueue(self, item): # Add the item while maintaining the order if self.is_empty(): self.items.append(item) else: for i, current in enumerate(self.items): if item < current: self.items.insert(i, item) break else: self.items.append(item) def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.items.pop(0) def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.items[0] def size(self): return len(self.items)"},{"question":"# Sudoku Solver Challenge You are given a partially filled 9x9 Sudoku board. Each cell can contain a digit from 1 to 9 or be empty (denoted by \'.\'). The objective is to fill the empty cells such that every row, column, and 3x3 subgrid contains the digits 1 to 9 without repetition. Write a function `solve_sudoku(board: List[List[str]]) -> None` that modifies `board` in-place to reach the solution. Input - `board`: A list of lists representing the 9x9 Sudoku board. - `board[i][j]` can be a digit from 1 to 9 or \'.\' indicating empty cells. Output - The board should be modified in-place to a valid Sudoku solution. Constraints - The given board will have at least one solution. - You need to ensure to start from the cell with the fewest possible values using constraint propagation. Example ```python board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] solve_sudoku(board) print(board) # Expected output: The board should be modified to a valid solution, such as: # [ # [\\"5\\",\\"3\\",\\"4\\",\\"6\\",\\"7\\",\\"8\\",\\"9\\",\\"1\\",\\"2\\"], # [\\"6\\",\\"7\\",\\"2\\",\\"1\\",\\"9\\",\\"5\\",\\"3\\",\\"4\\",\\"8\\"], # [\\"1\\",\\"9\\",\\"8\\",\\"3\\",\\"4\\",\\"2\\",\\"5\\",\\"6\\",\\"7\\"], # [\\"8\\",\\"5\\",\\"9\\",\\"7\\",\\"6\\",\\"1\\",\\"4\\",\\"2\\",\\"3\\"], # [\\"4\\",\\"2\\",\\"6\\",\\"8\\",\\"5\\",\\"3\\",\\"7\\",\\"9\\",\\"1\\"], # [\\"7\\",\\"1\\",\\"3\\",\\"9\\",\\"2\\",\\"4\\",\\"8\\",\\"5\\",\\"6\\"], # [\\"9\\",\\"6\\",\\"1\\",\\"5\\",\\"3\\",\\"7\\",\\"2\\",\\"8\\",\\"4\\"], # [\\"2\\",\\"8\\",\\"7\\",\\"4\\",\\"1\\",\\"9\\",\\"6\\",\\"3\\",\\"5\\"], # [\\"3\\",\\"4\\",\\"5\\",\\"2\\",\\"8\\",\\"6\\",\\"1\\",\\"7\\",\\"9\\"] # ] ``` Note * Focus on efficiency by employing the heuristic to reduce the search space as much as possible. * You may assume that the provided board has a valid solution.","solution":"from typing import List def is_valid(board: List[List[str]], row: int, col: int, num: str) -> bool: Helper function to check whether placing a number in a specific cell is valid. # Check the row for j in range(9): if board[row][j] == num: return False # Check the column for i in range(9): if board[i][col] == num: return False # Check the 3x3 sub-box start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(3): for j in range(3): if board[start_row + i][start_col + j] == num: return False return True def solve_sudoku(board: List[List[str]]) -> bool: Backtracking approach to solve the Sudoku puzzle. for i in range(9): for j in range(9): if board[i][j] == \'.\': for num in map(str, range(1, 10)): if is_valid(board, i, j, num): board[i][j] = num if solve_sudoku(board): return True # Undo the move board[i][j] = \'.\' return False return True"},{"question":"Given a range of integers `[low, high]`, write a function named `find_power_sum_numbers` that finds all integers in this range such that the sum of its digits, each raised to the power of their positions (1-based indexing), equals the number itself. # Function Signature ```python def find_power_sum_numbers(low: int, high: int) -> List[int]: pass ``` # Input * An integer `low`: lower bound of the range (inclusive). * An integer `high`: upper bound of the range (inclusive). Constraints: * `1 <= low <= high <= 10^4` # Output * A list of integers within the range `[low, high]` satisfying the given property. # Example ```python assert find_power_sum_numbers(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert find_power_sum_numbers(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert find_power_sum_numbers(100, 150) == [135] ``` # Constraints * You are required to implement the solution in linear time complexity with respect to the range size. * An optimized approach will be appreciated. # Notes Make sure to handle edge cases like: * Lower and upper bounds are equal. * All numbers in the range are single-digit numbers.","solution":"from typing import List def sum_of_digits_powered(number: int) -> int: digits = str(number) return sum(int(digit) ** (index + 1) for index, digit in enumerate(digits)) def find_power_sum_numbers(low: int, high: int) -> List[int]: result = [] for num in range(low, high + 1): if num == sum_of_digits_powered(num): result.append(num) return result"},{"question":"# Question: Graph Path Finder You are working on a network analysis tool that helps users determine connectivity and paths in a network graph. Users can input a network graph, and your tool should return all possible paths between two specified nodes using both Depth-First Search and Breadth-First Search. Your task is to implement two functions using DFS and BFS to find paths from a starting node to a target node. Function Signatures ```python def find_paths_dfs(graph, start, target): Find all paths from start to target using Depth-First Search. Args: - graph: dict, an adjacency list of the graph - start: int, the starting node - target: int, the target node Returns: - List of lists, where each list is a path from start to target. pass def find_paths_bfs(graph, start, target): Find all paths from start to target using Breadth-First Search. Args: - graph: dict, an adjacency list of the graph - start: int, the starting node - target: int, the target node Returns: - List of lists, where each list is a path from start to target. pass ``` Input - `graph` is represented as an adjacency list, where keys are node identifiers and values are lists of adjacent nodes. - `start` and `target` are node identifiers within the graph. Output - Each function should return a list of paths (each path is represented as a list of node identifiers). Constraints - The graph is a directed graph and may contain cycles. - All node identifiers are unique and positive integers. - You need to find all possible paths from `start` to `target`. Scenario Example Consider the network graph represented as: ```python graph = { 1: [2, 3], 2: [4], 3: [4, 5], 4: [6], 5: [], 6: [] } ``` To determine the paths from node `1` to node `6`, both functions should return: ```python # Example output # find_paths_dfs(graph, 1, 6) -> [[1, 2, 4, 6], [1, 3, 4, 6]] # find_paths_bfs(graph, 1, 6) -> [[1, 2, 4, 6], [1, 3, 4, 6]] ``` You need to ensure your paths are reported in the order they were found (DFS in depth order, BFS in breadth order). **Note**: You can assume that the graph does not contain any single isolated nodes and no edges leading to `None`.","solution":"def find_paths_dfs(graph, start, target): Find all paths from start to target using Depth-First Search. Args: - graph: dict, an adjacency list of the graph - start: int, the starting node - target: int, the target node Returns: - List of lists, where each list is a path from start to target. def dfs(current, target, path, all_paths): if current == target: all_paths.append(path.copy()) return for neighbor in graph.get(current, []): path.append(neighbor) dfs(neighbor, target, path, all_paths) path.pop() all_paths = [] dfs(start, target, [start], all_paths) return all_paths def find_paths_bfs(graph, start, target): Find all paths from start to target using Breadth-First Search. Args: - graph: dict, an adjacency list of the graph - start: int, the starting node - target: int, the target node Returns: - List of lists, where each list is a path from start to target. from collections import deque all_paths = [] queue = deque([(start, [start])]) while queue: current, path = queue.popleft() if current == target: all_paths.append(path) else: for neighbor in graph.get(current, []): queue.append((neighbor, path + [neighbor])) return all_paths"},{"question":"Scenario: You are writing a text-processing library and need to implement a function that searches for a substring within a larger string. Your task is to implement a function that finds the index of the first occurrence of a given substring within a given string. This function should handle edge cases efficiently and avoid unnecessary computations where possible. Function Specification: - **Function Name**: `contain_string` - **Input**: - `haystack` (string): The string in which to search. - `needle` (string): The substring to search for. - **Output**: - Integer: The zero-based index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not a part of `haystack`. Constraints: - `0 <= len(haystack) <= 10^4` - `0 <= len(needle) <= 10^4` - Case sensitivity should be considered (i.e., \'A\' is different from \'a\'). Performance Requirements: - The solution should have a time complexity better than or equal to O(N*M) in the worst case, where `N` is the length of `haystack` and `M` is the length of `needle`. Example: ```python # Example 1 haystack = \\"hello\\" needle = \\"ll\\" Output: 2 # Example 2 haystack = \\"aaaaa\\" needle = \\"bba\\" Output: -1 # Example 3 haystack = \\"mississippi\\" needle = \\"issip\\" Output: 4 ```","solution":"def contain_string(haystack, needle): Returns the zero-based index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not a part of `haystack`. if not needle: return 0 if not haystack or len(needle) > len(haystack): return -1 return haystack.find(needle)"},{"question":"Coding Assessment Question You are given a rotated sorted array and a target value. Your task is to write a function that searches the target in this array. If found, return its index; otherwise, return -1. Your algorithm should have a runtime complexity of O(log n). # Function Signature ```python def search_in_rotated_sorted_array(nums: List[int], target: int) -> int: pass ``` # Input - `nums` (List[int]): A rotated sorted array of integers. - `target` (int): Target value to search. # Output - The function should return an integer, the index of `target` in `nums`. If `target` is not in the array, return -1. # Constraints - All integers in `nums` are unique. - The array length will be at most 10^4. - Elements in the array range from -10^4 to 10^4. # Example ```python # Example 1: assert search_in_rotated_sorted_array([4,5,6,7,0,1,2], 0) == 4 assert search_in_rotated_sorted_array([4,5,6,7,0,1,2], 3) == -1 # Example 2: assert search_in_rotated_sorted_array([1], 0) == -1 assess search_in_rotated_sorted_array([1, 3], 3) == 1 # Example 3: assert search_in_rotated_sorted_array([3, 1], 1) == 1 assert search_in_rotated_sorted_array([5,6,7,8,9,1,2,3,4], 6) == 1 ``` # Explanation - **Example 1**: The rotated sorted array is [4, 5, 6, 7, 0, 1, 2]. The target 0 is at the index 4. - **Example 2**: In the rotated array [1], the target 0 is not present, so the output is -1. - **Example 3**: The array [3, 1] is rotated at the pivot 3. The target 1 is at index 1. # Note - The provided algorithm examples can be used to derive the solution. Implement either the iterative or recursive approach and ensure that the solution follows the O(log n) requirement.","solution":"from typing import List def search_in_rotated_sorted_array(nums: List[int], target: int) -> int: Searches the target in a rotated sorted array. Parameters: nums (List[int]): Rotated sorted array of integers target (int): Target value to search Returns: int: Index of target in nums if found, else -1 left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid # Determine which part is sorted if nums[left] <= nums[mid]: # left part is sorted if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: # right part is sorted if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"You are required to implement a function to determine if a given binary tree is a valid Binary Search Tree (BST). # Requirements * **Function**: `def is_bst(root: TreeNode) -> bool:` * **Input**: A binary tree represented by its root node. Each node contains an integer value and references to its left and right children. * **Output**: Return `True` if the tree is a valid BST; otherwise, return `False`. # Constraints * The integer values can be positive, negative, or zero. * Tree nodes do not have to contain unique values; duplicate values are not allowed to maintain BST properties. * The tree can be skewed (left or right). # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example 1 # Input: # 2 # / # 1 3 # Output: True # Example 2 # Input: # 1 # / # 2 3 # Output: False ``` # Implementation Notes Students should ensure: 1. Perform an in-order traversal. 2. Keep track of the previously visited node to ensure the current node\'s value is greater. 3. Handle edge cases like empty tree, skewness, and large depth. Write an efficient algorithm focusing on minimizing the execution time and space used.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_bst(root: TreeNode) -> bool: def validate(node: TreeNode, low: float, high: float) -> bool: if not node: return True if node.val <= low or node.val >= high: return False return validate(node.left, low, node.val) and validate(node.right, node.val, high) return validate(root, float(\'-inf\'), float(\'inf\'))"},{"question":"**Matrix Multiplication** # Context Matrix multiplication is a cornerstone operation in mathematics and computer science, used in numerous fields from graphics transformations to solving complex equations. Your task is to implement a matrix multiplication algorithm following the traditional dot product method. # Task Write a Python function `multiply_matrices` that takes two 2-dimensional lists (matrices) and returns their product as a 2-dimensional list. The function should raise an exception if the matrices are not compatible for multiplication. # Function Signature ```python def multiply_matrices(multiplicand: list, multiplier: list) -> list: pass ``` # Input * `multiplicand`: A 2D list of integers representing the multiplicand matrix (dimensions (m times n)). * `multiplier`: A 2D list of integers representing the multiplier matrix (dimensions (n times p)). # Output * Returns a 2D list of integers representing the resulting matrix (dimensions (m times p)). # Constraints * (1 leq m, n, p leq 100) * Matrix elements are integers (-10^3 leq element leq 10^3) * Matrices are not guaranteed to be square but must be mathematically compatible (i.e., the number of columns in the multiplicand must equal the number of rows in the multiplier). # Example ```python multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [5, 6], [7, 8] ] result = multiply_matrices(multiplicand, multiplier) # Output: [[19, 22], [43, 50]] ``` # Notes * You should handle invalid matrix dimensions by raising an `Exception` with a relevant error message. * Consider optimizing for time and space where possible, but correctness is critical. **Tip** Test your function with edge cases like: * Compatibility check failures. * Empty matrices. * Single-element matrices.","solution":"def multiply_matrices(multiplicand: list, multiplier: list) -> list: Multiplies two matrices using the traditional dot product method. Parameters: multiplicand (list): A 2D list of integers representing the multiplicand matrix. multiplier (list): A 2D list of integers representing the multiplier matrix. Returns: list: A 2D list of integers representing the product of the two matrices. Raises: Exception: If the matrices are not compatible for multiplication. if not multiplicand or not multiplier: raise Exception(\\"Matrices cannot be empty.\\") # Get dimensions of the matrices m = len(multiplicand) n = len(multiplicand[0]) n2 = len(multiplier) p = len(multiplier[0]) # Check if the matrices can be multiplied if n != n2: raise Exception(\\"Matrices are not compatible for multiplication. Number of columns in multiplicand must be equal to number of rows in multiplier.\\") # Initialize the result matrix with zeros result = [[0 for _ in range(p)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Scenario You have been hired as a software engineer at a company that specializes in embedded systems development. One of the recurrent tasks involves optimizing certain algorithms by directly manipulating bits of integers. To assess your understanding and ability to implement such optimizations, you are provided the following task: # Task Implement a function named `remove_bit` that removes a bit at a specific position from a given integer. This manipulation should preserve the rest of the bits intact as if the targeted bit never existed. # Input - An integer `num` representing the number from which a bit needs to be removed. - An integer `i` representing the zero-based index of the bit that needs to be removed (0 being the least significant bit). # Output - An integer representing the new number formed after removing the bit from the given position. # Constraints - `num` is a non-negative integer in the range [0, 2^31 - 1]. - `i` is a valid index within the bit length of `num`. # Example ```python remove_bit(21, 2) # Output: 9 remove_bit(21, 4) # Output: 5 remove_bit(21, 0) # Output: 10 ``` # Explanation - `remove_bit(21, 2)`: 21 (in binary `10101`), removing the bit at position 2 results in `01001` which is 9 in decimal. - `remove_bit(21, 4)`: 21 (in binary `10101`), removing the bit at position 4 results in `00101` which is 5 in decimal. - `remove_bit(21, 0)`: 21 (in binary `10101`), removing the bit at position 0 results in `1010` which is 10 in decimal. # Notes Make sure to consider edge cases such as: - Removing the most significant bit. - Removing the least significant bit. - Handling the function efficiently for large integers up to 2^31 - 1. Write the function following this signature: ```python def remove_bit(num, i): # Your implementation goes here ```","solution":"def remove_bit(num, i): Removes the bit at position i from the given integer num. # Create a mask with all ones except for the bit at position i mask = (1 << i) - 1 # all bits below i are 1 and above are 0 lower_bits = num & mask # get all bits lower than i upper_bits = num >> (i + 1) # get all bits higher than i, shifted right to fill the gap of bit i return (upper_bits << i) | lower_bits # combine the upper bits shifted and lower bits"},{"question":"# Coding Assessment: Identifying Own Powers Sum Numbers Problem Statement: Implement a function `sum_dig_pow(low, high)` that finds and returns all numbers within the inclusive range `[low, high]` that match the following property: A number matches this property if it is equal to the sum of its digits raised to the power of their respective positions (1-based index). For example: * 89 is included since 8^1 + 9^2 = 8 + 81 = 89 * 135 is included since 1^1 + 3^2 + 5^3 = 1 + 9 + 125 = 135 Function Signature: ```python def sum_dig_pow(low: int, high: int) -> list: pass ``` # Input: * `low` (int): The lower bound of the range (inclusive), `1 <= low <= high`. * `high` (int): The upper bound of the range (inclusive), `low <= high <= 1000`. # Output: * A list of integers which fulfill the described properties within the given range `[low, high]`. # Constraints: * The function should be efficient to handle the upper constraint limits. * Avoid using any libraries or built-in functions that directly achieve the functionality in order to demonstrate understanding. # Example: ```python assert sum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert sum_dig_pow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] ``` # Explanation: The function should iterate through all numbers from `low` to `high`, inclusive. For each number, determine if it meets the criteria where the sum of its digits raised to the powers of their respective positions equals the number itself. Collect all such numbers and return them as a list.","solution":"def sum_dig_pow(low, high): Find all numbers in the range [low, high] that are equal to the sum of their digits each raised to the power of their respective positions. def is_own_power_sum(n): return n == sum(int(digit) ** (i + 1) for i, digit in enumerate(str(n))) return [num for num in range(low, high + 1) if is_own_power_sum(num)]"},{"question":"Sacrifice the Most Feared Adversary Context: You are given a kingdom\'s map represented as a directed graph. Each node represents a village, and each edge represents a road connecting two villages. The kingdom\'s special forces are tasked with finding the most efficient path to infiltrate the city of the feared adversary without being detected. Your mission is to ensure this by finding the shortest path from your position to the adversary\'s base. To simulate the problem, given a graph, your start village, and the adversary\'s village, write a function to find the shortest path. Beware, certain paths are known to be booby-trapped and lead to certain capture if traversed more than once. Input Format - A dictionary `graph` where keys are node names (strings) and values are lists of neighboring node names (strings). - A string `start` representing the name of the start node. - A string `end` representing the name of the end node. Output Format - A list of strings representing the sequence of nodes traversed in the shortest path from `start` to `end`. - If no path exists, return `None`. Constraints - Each node can have between 0 to 10 direct connections. - Graph does not contain negative cycles. - Assume the graph fits in memory (up to 100,000 nodes). Performance Requirements - The algorithm should efficiently handle graphs with tens of thousands of nodes. - Optimize for both time and memory usage. Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } start = \'A\' end = \'F\' print(find_shortest_path(graph, start, end)) # Expected Output: [\'A\', \'C\', \'F\'] ``` Solution Template Implement the solution in the function below: ```python def find_shortest_path(graph, start, end): # Your code here pass ```","solution":"from collections import deque def find_shortest_path(graph, start, end): Finds the shortest path in the graph from the start node to the end node. # Using BFS for shortest path in an unweighted graph if start == end: return [start] queue = deque([(start, [start])]) # Holds tuples of (current_node, path) visited = set() while queue: current_node, path = queue.popleft() visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor == end: return path + [neighbor] if neighbor not in visited: queue.append((neighbor, path + [neighbor])) visited.add(neighbor) return None"},{"question":"You are tasked with ensuring all input arrays provided to the `bitonic_sort` function are valid for the sorting algorithm. To do this, you need to write a helper function `validate_input` that checks whether the input size is a power of two. Additionally, modify the original `bitonic_sort` function to call `validate_input` before proceeding with the sorting process. # Requirements: 1. Implement the helper function `validate_input(arr)`: - Input: A list of integers `arr`. - Output: A boolean value `True` if the length of the list is a power of two, otherwise `False`. 2. Modify the `bitonic_sort` function to use `validate_input` to check the input array size. If the input is invalid, raise a `ValueError` with the message \\"Input size must be a power of two\\". # Input Format: - `arr`: A list of integers, where 1 <= len(arr) <= 10^6. # Output Format: - If the input is valid, return the sorted list in increasing order. - If the input is invalid, raise a `ValueError`. # Constraints: - The array should contain integers. - Implement the solution in Python. # Example: Example 1: **Input**: `[34, 7, 23, 32, 5, 62, 32, 18]` **Output**: `[5, 7, 18, 23, 32, 32, 34, 62]` Example 2: **Input**: `[3, 7, 2, 2]` **Output**: `[2, 2, 3, 7]` Example 3: **Input**: `[4, 7, 3]` **Output**: ValueError \\"Input size must be a power of two\\" You are expected to use the provided `bitonic_sort` code snippet and only add the required modifications and new helper function.","solution":"def validate_input(arr): Validate if the length of the list is a power of two. n = len(arr) return (n & (n - 1) == 0) and n != 0 def bitonic_sort(arr): Perform the bitonic sort on the input array. if not validate_input(arr): raise ValueError(\\"Input size must be a power of two\\") def compare_and_swap(a, i, j, direction): if (direction == 1 and a[i] > a[j]) or (direction == 0 and a[i] < a[j]): a[i], a[j] = a[j], a[i] def bitonic_merge(a, low, cnt, direction): if cnt > 1: k = cnt // 2 for i in range(low, low + k): compare_and_swap(a, i, i + k, direction) bitonic_merge(a, low, k, direction) bitonic_merge(a, low + k, k, direction) def bitonic_sort_recursive(a, low, cnt, direction): if cnt > 1: k = cnt // 2 bitonic_sort_recursive(a, low, k, 1) # sort in ascending order bitonic_sort_recursive(a, low + k, k, 0) # sort in descending order bitonic_merge(a, low, cnt, direction) # Start of the sort bitonic_sort_recursive(arr, 0, len(arr), 1) return arr"},{"question":"# Question: Modular Factorial Sum You are asked to calculate the sum of modular factorials for a series of numbers. Given an integer array `arr` containing n non-negative integers and a positive integer `mod`, write a function `modular_factorial_sum(arr, mod)` that returns the sum of factorials of each number in the array, modulo `mod`. Input: - `arr`: List of non-negative integers (`0 <= arr[i] <= 10^5`) - `mod`: A positive integer (`1 <= mod <= 10^9`) Output: - Return the sum of factorials of the array elements, each factorial taken modulo `mod`, then the sum itself taken modulo `mod`. Constraints: - Your function should handle arrays with up to `10^5` elements efficiently. - Consider edge cases such as empty arrays, single-element arrays, and maximum values of elements in the array. Example: ```python def modular_factorial_sum(arr, mod): # Your implementation here # Test cases print(modular_factorial_sum([1, 2, 3], 1000000007)) # Output: 9 (1! + 2! + 3! % 1000000007 = 1 + 2 + 6 = 9) print(modular_factorial_sum([0, 0, 0, 0], 7)) # Output: 4 (four 1\'s % 7 = 4) print(modular_factorial_sum([], 100)) # Output: 0 (sum of empty array is 0) ``` # Hints: 1. Implement a factorial function that calculates factorial with mod (iterative for better space handling). 2. Use this factorial function within your main function to sum the factorials of the array elements. 3. Take the final sum modulo `mod` before returning.","solution":"def modular_factorial_sum(arr, mod): def factorial(n, mod): result = 1 for i in range(2, n + 1): result = (result * i) % mod return result sum_of_fact = 0 for num in arr: sum_of_fact = (sum_of_fact + factorial(num, mod)) % mod return sum_of_fact"},{"question":"# Nearest Neighbor Algorithm Implementation You are tasked with implementing a function that utilizes the Nearest Neighbor algorithm. This algorithm will determine the point in a training set that is closest to a given input point based on Euclidean distance. # Implementation Details **Function Signature:** ```python def nearest_neighbor(x: tuple, tSet: dict) -> any: ``` **Inputs:** * `x` : A tuple representing the target point in n-dimensional space. * `tSet` : A dictionary where the keys are tuples representing points in n-dimensional space, and the values are the corresponding labels. **Output:** * The label of the nearest point (as identified in `tSet`) to the target point `x`. **Constraints:** - Both `x` and keys in `tSet` are tuples of the same dimension. - The `tSet` dictionary is non-empty. Handle the case where two or more points in the training set are equidistant to the target point deterministically by returning the first such point found. - The length of each tuple should be between 1 and 100. - Values in the tuples can be any real number between `-1000` and `1000`. # Example: Input: ```python x = (1, 2) tSet = { (0, 0): \'A\', (2, 2): \'B\', (3, 4): \'C\' } ``` Output: ``` \'B\' ``` # Explanation In this example, the point `(2,2)` is the closest to point `(1,2)` with a distance of 1. Thus the output is the label of the closest point `\'B\'`. **Edge Cases to Consider:** - What if all points in `tSet` are equidistant from `x`? - Handle potential assertion failures gracefully by using appropriate exception handling techniques. Implement the `nearest_neighbor` function that adheres to the above requirements and performs efficiently on large datasets.","solution":"import math def nearest_neighbor(x: tuple, tSet: dict) -> any: Given an n-dimensional point x and a training set tSet of n-dimensional points with labels, find the label of the point in tSet that is closest to x based on Euclidean distance. Args: x (tuple): A tuple representing the target point in n-dimensional space. tSet (dict): A dictionary where the keys are tuples representing points in n-dimensional space, and the values are the corresponding labels. Returns: any: The label of the nearest point in tSet to the target point x. def euclidean_distance(a, b): return math.sqrt(sum((a_i - b_i)**2 for a_i, b_i in zip(a, b))) nearest_label = None min_distance = float(\'inf\') for point, label in tSet.items(): distance = euclidean_distance(x, point) if distance < min_distance: min_distance = distance nearest_label = label return nearest_label"},{"question":"Implement a Doubly Linked List Implement a doubly linked list with the following functionalities: 1. **Initialization** - Create an empty list. 2. **Add Node**: * `add_at_head(value)`: Add a node with the specified value at the head of the list. * `add_at_tail(value)`: Add a node with the specified value at the tail of the list. 3. **Remove Node**: * `remove_node(value)`: Remove the first node with the specified value. 4. **Traversal**: * `get_values_forward()`: Return a list of node values in forward direction. * `get_values_backward()`: Return a list of node values in backward direction. Ensure your implementation handles edge cases such as an empty list and performing operations on single-element lists. The input will consist of multiple function calls as described above. Below is the function signature template to help you get started: ```python class DoublyLinkedList: def __init__(self): # Initialize your list pass def add_at_head(self, value): # Add node at head pass def add_at_tail(self, value): # Add node at tail pass def remove_node(self, value): # Remove node with specified value pass def get_values_forward(self): # Return list of values in forward direction pass def get_values_backward(self): # Return list of values in backward direction pass ``` # Input Format The input consists of multiple calls to the above-mentioned methods on a `DoublyLinkedList` instance. # Output Format For traversal methods, return the list of node values. For other methods, return an indication of the method\'s execution completion. # Example Input ```python dll = DoublyLinkedList() dll.add_at_head(10) dll.add_at_tail(20) dll.add_at_head(5) print(dll.get_values_forward()) # [5, 10, 20] print(dll.get_values_backward()) # [20, 10, 5] dll.remove_node(10) print(dll.get_values_forward()) # [5, 20] dll.remove_node(5) dll.remove_node(20) print(dll.get_values_forward()) # [] ``` Output ``` [5, 10, 20] [20, 10, 5] [5, 20] [] ``` # Constraints 1. All values will be integers. 2. The list size will be at most 10^5 nodes. 3. All operations need to be optimized to handle large list sizes.","solution":"class Node: def __init__(self, value=None, prev=None, next=None): self.value = value self.prev = prev self.next = next class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def add_at_head(self, value): new_node = Node(value) if not self.head: self.head = new_node self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def add_at_tail(self, value): new_node = Node(value) if not self.tail: self.head = new_node self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def remove_node(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next if current.next: current.next.prev = current.prev if current == self.head: self.head = current.next if current == self.tail: self.tail = current.prev return current = current.next def get_values_forward(self): values = [] current = self.head while current: values.append(current.value) current = current.next return values def get_values_backward(self): values = [] current = self.tail while current: values.append(current.value) current = current.prev return values"},{"question":"Scenario You are tasked with managing a list of product names and a set of key phrases (symbols) to be highlighted within these product names. Your goal is to identify and highlight the longest matching key phrase in each product name using square brackets. Problem Statement Write a function `highlight_phrases(product_names, key_phrases)` that takes in two lists: 1. `product_names`: A list of strings representing product names. 2. `key_phrases`: A list of strings representing key phrases to be highlighted. The function should return a list of product names where the longest matching key phrase in each product name is wrapped in square brackets. If a product name contains multiple key phrases, the longest one should be highlighted. Input * `product_names`: list of strings, where each string length (1 ≤ len ≤ 1000). * `key_phrases`: list of strings, where each string length (1 ≤ len ≤ 1000), and total number of key phrases (1 ≤ |key_phrases| ≤ 1000). Output A list of strings where each product name has the longest matching key phrase wrapped in square brackets. Constraints * If a product name matches multiple key phrases of the same length, highlight the one that appears first lexicographically. * Each product name will contain at most one key phrase to be highlighted. Example ```python product_names = [\\"Amazon\\", \\"Microsoft\\", \\"Google\\"] key_phrases = [\\"i\\", \\"Am\\", \\"cro\\", \\"Na\\", \\"le\\", \\"abc\\"] output = highlight_phrases(product_names, key_phrases) print(output) # Expected Output: [\\"[Am]azon\\", \\"Mi[cro]soft\\", \\"Goog[le]\\"] ``` Requirements * Optimize for time and space complexity. * Handle edge cases such as no matching key phrases in a product name. * Consider the performance for large datasets.","solution":"def highlight_phrases(product_names, key_phrases): def find_longest_phrase(product, phrases): longest_phrase = \\"\\" for phrase in phrases: if phrase in product: if (len(phrase) > len(longest_phrase)) or ( len(phrase) == len(longest_phrase) and phrase < longest_phrase ): longest_phrase = phrase return longest_phrase highlighted_products = [] for product in product_names: longest_phrase = find_longest_phrase(product, key_phrases) if longest_phrase: highlighted_product = product.replace(longest_phrase, f\\"[{longest_phrase}]\\") highlighted_products.append(highlighted_product) else: highlighted_products.append(product) return highlighted_products"},{"question":"You are given a singly linked list, and your task is to remove all duplicate elements from the list. You are required to implement two distinct methods for this function, each employing a different strategy. Method 1: Using Extra Space with a Set Implement the function `remove_dups(head: Node) -> Node` which uses a set to keep track of already seen elements and removes duplicates accordingly. Method 2: In-Place without Extra Space Implement the function `remove_dups_without_set(head: Node) -> Node` which does not use any extra space for tracking duplicates and removes duplicates purely through in-place traversal. # Function Signature ```python class Node: def __init__(self, val: Optional[Union[int, str]] = None): self.val = val self.next = None def remove_dups(head: Node) -> Node: pass def remove_dups_without_set(head: Node) -> Node: pass ``` # Input Format - `head` - The head node of the singly linked list. # Output Format - Return the head of the modified linked list with all duplicates removed. # Constraints - The list consists of nodes with integer or string values. - Maximum length of the linked list is 10^4. # Example **Input**: - A -> A -> B -> C -> D -> C -> F -> G **Output using `remove_dups`**: - A -> B -> C -> D -> F -> G **Output using `remove_dups_without_set`**: - A -> B -> C -> D -> F -> G # Requirements - Your implementation should handle edge cases such as an empty list. - Ensure the solution maintains the original relative order of non-duplicate elements. - Implement efficient and correct logic that meets described constraints.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups(head: Node) -> Node: if not head: return head current = head seen = set() seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head def remove_dups_without_set(head: Node) -> Node: if not head: return head current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next return head"},{"question":"Scenario You\'re working as a developer at a tech company, and your team is working on a digital record system. You have a list of record IDs where each ID appears exactly twice except for one that appears only once. Your task is to implement a function to find the unique record ID. Task Write a function `find_unique_record_id(record_ids)` that takes a list of integers `record_ids` and returns the unique record ID that appears only once, while every other ID appears exactly twice. Input: * `record_ids`: a list of integers (1 <= len(record_ids) <= 10^5), where each integer is between -10^6 and 10^6. Output: * An integer representing the unique record ID. Example: ```python find_unique_record_id([4, 1, 2, 1, 2]) ``` *Output:* `4` Constraints: * The function must have a linear runtime complexity. * The function should not use extra memory beyond a constant amount. Additional Notes: * Assume the input list will always have one unique ID, as per the problem constraints. * If the list is empty, return 0. Function Signature: ```python def find_unique_record_id(record_ids: List[int]) -> int: pass ```","solution":"from typing import List def find_unique_record_id(record_ids: List[int]) -> int: Returns the unique ID that appears only once in the list. Each other ID appears exactly twice. unique_id = 0 for record_id in record_ids: unique_id ^= record_id return unique_id"},{"question":"Question: Recursive Digit Sum Checker # Scenario You are working at a digital security company, and you have to design an algorithm to check whether a given number is a \\"magic number.\\" A \\"magic number\\" is defined as a number which when summing its digits repeatedly (until a single digit is obtained) results in 1. # Objective Write a function `is_magic_number(n: int) -> bool` that determines if a given number `n` is a magic number or not. # Input and Output Formats * **Input**: An integer `n` where -10^9 ≤ n ≤ 10^9. - If `n` is negative, consider its absolute value. * **Output**: A boolean value: `True` if `n` is a magic number, `False` otherwise. # Constraints 1. Must handle both positive and negative integers. 2. Recursion or loop must be used to repeat summing digits until a single digit is obtained. 3. Edge cases where `n` is a single digit should be considered directly. # Function Signature ```python def is_magic_number(n: int) -> bool: pass ``` # Examples 1. For n = 50113: - Process: 5 + 0 + 1 + 1 + 3 = 10 => 1 + 0 = 1 - Output: True 2. For n = 1234: - Process: 1 + 2 + 3 + 4 = 10 => 1 + 0 = 1 - Output: True 3. For n = 199: - Process: 1 + 9 + 9 = 19 => 1 + 9 = 10 => 1 + 0 = 1 - Output: True 4. For n = 111: - Process: 1 + 1 + 1 = 3 - Output: False # Notes * You may assume `n` can be a very large positive or negative number. * Consider all edge cases, especially for single digits and zero.","solution":"def is_magic_number(n: int) -> bool: Returns whether the given number n is a magic number. A magic number is defined as a number which sums its digits repeatedly until a single digit is obtained, and results in 1. # Handle negative input n = abs(n) while n >= 10: n = sum(int(digit) for digit in str(n)) return n == 1"},{"question":"You are given an unsorted list of integers. Implement the Bubble Sort algorithm to sort this list in non-decreasing order. For educational purposes, enhance the standard Bubble Sort implementation to keep and return a detailed log of each step (iteration) of the algorithm. # Task Write a function `detailed_bubble_sort(arr: List[int]) -> List[str]:` that performs the following: 1. Sorts the list using Bubble Sort. 2. Keeps a detailed log of each step (iteration) showing the state of the list after each swap. 3. Returns the log as a list of strings where each string corresponds to the state of the list after a swap. # Input Format - A single list of integers `arr` which needs sorting. (0 ≤ len(arr) ≤ 1000) - Each integer in `arr` is within the range of -10^6 to 10^6. # Output Format - A list of strings, where each string represents the state of the list after each swap. Format each string as a space-separated sequence of integers. # Example Input ```python arr = [3, 2, 1] ``` Output ```python [ \\"2 3 1\\", \\"2 1 3\\", \\"1 2 3\\" ] ``` Notes 1. If no swaps are made (i.e., the list is already sorted or contains a single element), return an empty list. 2. Maintain the relative order of equal elements as Bubble Sort is a stable sort. # Constraints - Your implementation must have a time complexity of O(N^2) and a space complexity of O(1).","solution":"from typing import List def detailed_bubble_sort(arr: List[int]) -> List[str]: Sorts the list `arr` using the Bubble Sort algorithm and logs every change in the list. Parameters: arr (List[int]): The list of integers to be sorted. Returns: List[str]: A list of strings representing the state of the list after each swap. n = len(arr) log = [] for i in range(n): # Track whether any swap was made in this iteration swapped = False for j in range(n - 1): if arr[j] > arr[j + 1]: # Swap the elements arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True # Log the current state of the array log.append(\\" \\".join(map(str, arr))) # If no swap was made, the array is sorted if not swapped: break return log"},{"question":"You are tasked with designing a subsystem for a travel optimization software that determines the minimum cost path to travel from the start station to the end station. The stations and travel costs between them are represented in an upper triangular cost matrix. Objective: Implement a function `min_cost_path(cost: List[List[int]]) -> int` that computes the minimum cost to travel from station 0 to station N-1. Function Signature: ```python def min_cost_path(cost: List[List[int]]) -> int: pass ``` Input Format: - **cost**: A 2D list of integers where `cost[i][j]` (for `i < j`) represents the cost to travel from station `i` to station `j`. If `i >= j`, `cost[i][j] = -1`. Output Format: - An integer which is the minimum cost to travel from station 0 to station N-1. Constraints: - The length of the cost matrix `cost` will be `n` where `2 <= n <= 10^2`. - All costs `cost[i][j]` are non-negative integers where `0 <= cost[i][j] <= 10^3`. Example: ```python cost = [ [0, 15, 80, 90], [-1, 0, 40, 50], [-1, -1, 0, 70], [-1, -1, -1, 0] ] assert min_cost_path(cost) == 65 ``` **Explanation**: The minimum cost to reach the last station (station 3) from the first (station 0) is 65, achieved via the path from station 0 -> 1 -> 3. Note: - Ensure that your implementation is efficient with respect to both time and space complexity. - Handle edge cases such as improper matrix values gracefully with appropriate validation and error handling.","solution":"from typing import List def min_cost_path(cost: List[List[int]]) -> int: Computes the minimum cost to travel from station 0 to station N-1. n = len(cost) min_cost = [float(\'inf\')] * n min_cost[0] = 0 for i in range(n): for j in range(i + 1, n): if cost[i][j] != -1: min_cost[j] = min(min_cost[j], min_cost[i] + cost[i][j]) return min_cost[-1]"},{"question":"**Scenario** In computer science, particularly in bitwise operations, identifying patterns in binary representations of integers is a common task. One such task is to check if an integer has alternating bits. This means we need to verify whether in the binary representation of a number, every bit is different from the adjacent bit. Consider a function that takes an integer as input and determines if it has alternating bits. The function should return `True` if the integer meets the condition, otherwise `False`. You are required to implement two functions: 1. A basic function, `has_alternative_bit`, using an iterative approach. 2. An optimized function, `has_alternative_bit_fast`, using bitwise manipulation for constant time checking. **Function Signatures:** ```python def has_alternative_bit(n: int) -> bool: pass def has_alternative_bit_fast(n: int) -> bool: pass ``` **Input:** * An integer `n` (0 <= n <= 10^9). **Output:** * A boolean value (`True` or `False`). **Constraints:** * Performance efficiency for both functions is a requirement. * Clearly handle the binary pattern of `n`, especially edge cases like 0 or 1. **Examples:** ```python print(has_alternative_bit(5)) # Output: True (binary 101) print(has_alternative_bit(7)) # Output: False (binary 111) print(has_alternative_bit(11)) # Output: False (binary 1011) print(has_alternative_bit(10)) # Output: True (binary 1010) print(has_alternative_bit_fast(5)) # Output: True (binary 101) print(has_alternative_bit_fast(7)) # Output: False (binary 111) print(has_alternative_bit_fast(11)) # Output: False (binary 1011) print(has_alternative_bit_fast(10)) # Output: True (binary 1010) ``` Implement the above functions and test them with various valid input scenarios to ensure correctness and efficiency.","solution":"def has_alternative_bit(n: int) -> bool: Check if the integer n has alternating bits using an iterative approach. last_bit = n & 1 n >>= 1 while n > 0: current_bit = n & 1 if current_bit == last_bit: return False last_bit = current_bit n >>= 1 return True def has_alternative_bit_fast(n: int) -> bool: Check if the integer n has alternating bits using bitwise manipulation for constant time checking. # Create a mask which is the result of n XOR (n shifted right by 1) # If n has alternating bits, mask has all bits set to 1 (e.g., 1111...). # Next, use (mask + 1) AND mask to check if result is zero. mask = n ^ (n >> 1) return (mask & (mask + 1)) == 0"},{"question":"# Stack Palindrome Checker **Objective**: Implement a function to check if a given string is a palindrome using a stack. A string is a palindrome if it reads the same backward as forward, ignoring spaces and punctuation. **Function Signature**: ```python def is_palindrome(s: str) -> bool: pass ``` **Input**: - A single string `s` containing alphanumeric characters, spaces, and punctuation (1 ≤ length of s ≤ 1000). **Output**: - Return `True` if the string is a palindrome, `False` otherwise. **Constraints**: - Ignore spaces, punctuation, and case while checking for palindrome. **Example**: ```python # Example 1 assert is_palindrome(\\"A man, a plan, a canal: Panama\\") == True # Example 2 assert is_palindrome(\\"race a car\\") == False # Example 3 assert is_palindrome(\\" \\") == True ``` **Requirements**: - Utilize a stack implementation (either the provided `ArrayStack` or `LinkedListStack`) to assist in solving the problem. - Ensure that the solution adheres to the time complexity boundaries expected by leveraging the stack operations efficiently.","solution":"def is_palindrome(s: str) -> bool: Checks if the given string is a palindrome using a stack. Ignores spaces, punctuation and is case insensitive. stack = [] filtered_chars = [char.lower() for char in s if char.isalnum()] for char in filtered_chars: stack.append(char) for char in filtered_chars: if char != stack.pop(): return False return True"},{"question":"# Coding Challenge: Enhanced Insertion Sort Problem Statement You are provided with an array of integers. Your task is to implement an enhanced version of the Insertion Sort algorithm that not only sorts the array but also: - Removes all duplicate elements during the sorting process. - Ensures the sorted array has only unique elements. You will write a function `insertion_sort_unique(arr)` that takes an array `arr` as input and returns a new sorted array with unique elements. Input * An array `arr` of integers with length `n` where (1 leq n leq 10^4). The integers can be negative or non-negative. Output * A list of integers sorted in ascending order and containing only unique elements. Constraints * You must implement the Insertion Sort algorithm. * The function should return the sorted list in ascending order with duplicates removed. * You should aim for a time complexity that is minimally O(n^2). Example ```python # Example Input: arr = [4, 2, 7, 2, 3, 1, 4, 8] # Example Output: [1, 2, 3, 4, 7, 8] ``` Instructions * Define the function `insertion_sort_unique(arr)`. * Ensure that the array is sorted in ascending order. * Include error handling for edge cases like an empty array or arrays with one element. * Optimize for readability and efficiency.","solution":"def insertion_sort_unique(arr): Returns a new list containing the elements of arr sorted in ascending order with duplicates removed. if not arr: return [] unique_list = [] for element in arr: if element not in unique_list: unique_list.append(element) # Insertion sort for i in range(1, len(unique_list)): key = unique_list[i] j = i - 1 while j >= 0 and key < unique_list[j]: unique_list[j + 1] = unique_list[j] j -= 1 unique_list[j + 1] = key return unique_list"},{"question":"# Double Stutter Function Implement a function that takes a stack and duplicates each element such that each element appears twice one after the other. You are to implement the below function: ```python def double_stutter(stack): Given a stack, double_stutter replaces every value in the stack with two occurrences of that value. :param stack: List[int] - Stack is represented as a list where the last element is the top of the stack. :return: None - The stack is modified in place. pass ``` # Input * `stack`: A list of integers representing the stack. This list can be empty. # Output * The function does not return any value. The stack is modified in place. # Constraints * The stack contains up to `10^4` integers. * Each integer in the stack is in the range `[-10^9, 10^9]`. # Example Given the stack: ``` stack = [3, 7, 1, 14, 9] ``` After calling `double_stutter(stack)`, the stack should be: ``` stack = [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` # Notes * The new stack should maintain the order of elements such that the first occurrence of an element comes before the duplicated occurrence. * You can use either an additional stack or a queue for aiding your implementation. * Consider edge cases like an empty stack or a stack containing only one element.","solution":"def double_stutter(stack): Given a stack, double_stutter replaces every value in the stack with two occurrences of that value. :param stack: List[int] - Stack is represented as a list where the last element is the top of the stack. :return: None - The stack is modified in place. i = 0 original_length = len(stack) while i < original_length: stack.insert(2 * i, stack[2 * i]) i += 1"},{"question":"# Scenario: You work for a software development firm that creates efficient and performance-critical software. You have been asked to implement a specific feature to manage permissions using bit manipulation. Permissions are represented as a single integer where each bit signifies a different permission toggle (1 for granted, 0 for denied). # Task: Write a Python class `PermissionManager` that uses the provided bit manipulation functions to manage user permissions. The class should include methods to get, set, clear, and update permissions following the specifics provided below. # Class Specification: Methods: 1. **`get_permission(self, permission_num, permission_index) -> bool`**: * **Input**: * `permission_num` (int): The integer representing the permissions bitmask. * `permission_index` (int): The index of the permission to check. * **Output**: * (bool): True if the permission is granted, False otherwise. 2. **`set_permission(self, permission_num, permission_index) -> int`**: * **Input**: * `permission_num` (int): The integer representing the permissions bitmask. * `permission_index` (int): The index of the permission to grant. * **Output**: * (int): The updated permissions bitmask. 3. **`clear_permission(self, permission_num, permission_index) -> int`**: * **Input**: * `permission_num` (int): The integer representing the permissions bitmask. * `permission_index` (int): The index of the permission to revoke. * **Output**: * (int): The updated permissions bitmask. 4. **`update_permission(self, permission_num, permission_index, value) -> int`**: * **Input**: * `permission_num` (int): The integer representing the permissions bitmask. * `permission_index` (int): The index of the permission to update. * `value` (bool): The new value of the permission (True for granted, False for revoked). * **Output**: * (int): The updated permissions bitmask. # Constraints: * Assume that `permission_index` is a non-negative integer within the range of the number of bits in the integer representation of `permission_num`. * Permissions are represented in a 32-bit signed integer range. # Example: ```python pm = PermissionManager() # Initial permissions: 0b1010 (10 in decimal) permission_num = 10 # Check if permission at index 1 is set print(pm.get_permission(permission_num, 1)) # Output: True # Grant permission at index 0 permission_num = pm.set_permission(permission_num, 0) print(bin(permission_num)) # Output: 0b1011 (11 in decimal) # Revoke permission at index 3 permission_num = pm.clear_permission(permission_num, 3) print(bin(permission_num)) # Output: 0b11 (3 in decimal) # Update permission at index 2 to True permission_num = pm.update_permission(permission_num, 2, True) print(bin(permission_num)) # Output: 0b111 (7 in decimal) ``` # Implementation: **You need to submit the implementation of the `PermissionManager` class with the specified methods.**","solution":"class PermissionManager: def get_permission(self, permission_num, permission_index) -> bool: Check if permission is granted at a specific index Args: permission_num (int): The integer representing the permissions bitmask permission_index (int): The index of the permission to check Returns: bool: True if the permission is granted, False otherwise return (permission_num & (1 << permission_index)) != 0 def set_permission(self, permission_num, permission_index) -> int: Grant permission at a specific index Args: permission_num (int): The integer representing the permissions bitmask permission_index (int): The index of the permission to grant Returns: int: The updated permissions bitmask return permission_num | (1 << permission_index) def clear_permission(self, permission_num, permission_index) -> int: Revoke permission at a specific index Args: permission_num (int): The integer representing the permissions bitmask permission_index (int): The index of the permission to revoke Returns: int: The updated permissions bitmask return permission_num & ~(1 << permission_index) def update_permission(self, permission_num, permission_index, value) -> int: Update permission at a specific index Args: permission_num (int): The integer representing the permissions bitmask permission_index (int): The index of the permission to update value (bool): The new value of the permission (True for granted, False for revoked) Returns: int: The updated permissions bitmask if value: return self.set_permission(permission_num, permission_index) else: return self.clear_permission(permission_num, permission_index)"},{"question":"You are given an unsorted list of integers. Implement the Gnome Sort algorithm to sort this list in ascending order. Write a function `gnome_sort(arr)` that takes a list of integers `arr` as input and returns a new list sorted in ascending order. # Function Signature ```python def gnome_sort(arr: List[int]) -> List[int]: ``` # Input - `arr` (List[int]): A list of integers. The length of the list is between 0 and 10^4. # Output - A list of integers sorted in ascending order. # Constraints - The input list can contain repeated elements. - The function must sort the array in place and return it. # Example ```python gnome_sort([34, 2, 78, 12, 45, 1]) # Returns [1, 2, 12, 34, 45, 78] gnome_sort([5, 3, 2, 6, 4, 1]) # Returns [1, 2, 3, 4, 5, 6] gnome_sort([]) # Returns [] gnome_sort([10, 20, 30]) # Returns [10, 20, 30] ``` # Explanation 1. **Example 1**: The function arranges the elements in ascending order by repeatedly swapping adjacent elements. 2. **Example 2**: Similar to the first example, bringing each smaller number forward by swapping. 3. **Example 3**: An empty list remains empty. 4. **Example 4**: A list that is already sorted remains the same. # Hints - Make sure to handle edge cases such as an empty list or a list with one element. - Focus on moving back to check previous elements when a swap occurs and proceeding forward otherwise.","solution":"def gnome_sort(arr): Sorts the array in place using Gnome Sort algorithm. pos = 0 while pos < len(arr): if pos == 0 or arr[pos] >= arr[pos - 1]: pos += 1 else: arr[pos], arr[pos - 1] = arr[pos - 1], arr[pos] pos -= 1 return arr"},{"question":"**Context**: You are part of a software development team working on a data analysis tool. One of the required features is to identify anomalies in the dataset where exactly two unique anomalies exist and every other data point appears exactly twice. **Task**: Write a Python function, `find_unique_elements(nums)`, that accepts an array of integers, `nums`, where exactly two elements appear only once and all other elements appear exactly twice. Your function should return the two elements that appear only once. **Specifications**: * **Function Signature**: `def find_unique_elements(nums):` * **Input**: - `nums`: a list of integers, where `2 ≤ len(nums) ≤ 3 * 10^4` and every element appears exactly twice except for two elements which appear only once. * **Output**: - Return a list of the two unique integers. * **Constraints**: - Time complexity must be O(N). - Space complexity must be O(1). - The order of the result does not matter. **Example**: ```python assert set(find_unique_elements([1, 2, 1, 3, 2, 5])) == {3, 5} # [3, 5] or [5, 3] assert set(find_unique_elements([2, 4, 6, 8, 10, 10, 8, 6, 4, 3])) == {2, 3} # [2, 3] or [3, 2] ``` **Notes**: - The input dataset is guaranteed to meet the condition where there are exactly two unique elements. **Performance**: - The function should run efficiently even on the upper limit of the input size. **Implementation**: Please use the XOR-based strategy discussed in the analysis to achieve the desired time and space complexity.","solution":"def find_unique_elements(nums): Returns the two unique elements that appear only once in the list nums. All other elements in nums appear exactly twice. # First pass: find the XOR of the two unique numbers xor_all = 0 for num in nums: xor_all ^= num # Find a set bit in xor_all (we use the rightmost set bit) rightmost_set_bit = xor_all & -xor_all # Second pass: divide the numbers into two groups and XOR to find the unique numbers unique1 = 0 unique2 = 0 for num in nums: if num & rightmost_set_bit: unique1 ^= num else: unique2 ^= num return [unique1, unique2]"},{"question":"# Longest Common Subsequence Challenge Context You are given two strings, `s1` and `s2`, where `s2` consists of unique characters. Your task is to implement a function that returns the length of the longest common substring (LCS) between the two strings. The substring must be contiguous and exist in the same order in both strings. Function Specification Implement the function `longest_common_substring_length(s1: str, s2: str) -> int`. **Input:** * `s1`: A string of length `n`, where `1 <= n <= 10^5`. * `s2`: A string of length `m`, where `1 <= m <= 10^5` and containing all unique characters. **Output:** * An integer representing the length of the longest common substring. **Performance Requirements:** * The expected time complexity is (O(n log n)). Constraints * The characters in `s2` are unique. * The length of `s1` and `s2` will not exceed (10^5). Examples Example 1: ```python s1 = \\"abcdxyz\\" s2 = \\"xyzabcd\\" assert longest_common_substring_length(s1, s2) == 4 # Explanation: The LCS is \\"abcd\\", length is 4. ``` Example 2: ```python s1 = \\"mnopabcdxyz\\" s2 = \\"abcdxyz\\" assert longest_common_substring_length(s1, s2) == 7 # Explanation: The LCS is \\"abcdxyz\\", length is 7. ``` Example 3: ```python s1 = \\"abcdef\\" s2 = \\"ghijkl\\" assert longest_common_substring_length(s1, s2) == 0 # Explanation: No common substring, length is 0. ``` **Note:** Ensure that your implementation handles large string lengths efficiently and considers all edge cases as discussed.","solution":"def longest_common_substring_length(s1, s2): Returns the length of the longest common substring between s1 and s2. def common_substring_length(mid): substr_seen = set(s1[i:i+mid] for i in range(len(s1) - mid + 1)) for j in range(len(s2) - mid + 1): if s2[j:j+mid] in substr_seen: return True return False low, high = 0, min(len(s1), len(s2)) while low < high: mid = (low + high + 1) // 2 if common_substring_length(mid): low = mid else: high = mid - 1 return low"},{"question":"**Question**: You are provided with a string that represents a message. Your task is to write a function to encode this message using the Atbash cipher. Each letter of the alphabet should be replaced by its reverse counterpart (\'a\' with \'z\', \'b\' with \'y\', and so forth). Non-alphabet characters should remain unchanged. Implement the function `atbash_cipher(message: str) -> str` which accepts a string message, encodes it using the Atbash cipher, and returns the encoded string. # Input: * `message` (1 ≤ |message| ≤ 1000): a string consisting of printable ASCII characters. # Output: * A string encoded using the Atbash cipher. # Example: ```python print(atbash_cipher(\\"Attack at dawn\\")) # Should output: \\"Zggzxp zg wzdm\\" print(atbash_cipher(\\"Hello, World!\\")) # Should output: \\"Svool, Dliow!\\" print(atbash_cipher(\\"123\\")) # Should output: \\"123\\" print(atbash_cipher(\\"ABC abc\\")) # Should output: \\"ZYX zyx\\" ``` # Constraints: * The function should handle both uppercase and lowercase letters. * Keep non-alphabet characters unchanged. # Notes: * Consider edge cases like empty strings or strings with only non-alphabet characters. * Ensure the function performs efficiently for the given input length.","solution":"def atbash_cipher(message: str) -> str: Encodes the message using the Atbash cipher. Parameters: message (str): The input message to be encoded. Returns: str: The encoded message. result = [] for char in message: if \'a\' <= char <= \'z\': result.append(chr(ord(\'a\') + ord(\'z\') - ord(char))) elif \'A\' <= char <= \'Z\': result.append(chr(ord(\'A\') + ord(\'Z\') - ord(char))) else: result.append(char) return \'\'.join(result)"},{"question":"# Insertion and Traversal in a Binary Search Tree Context You have been hired to build a system that manages unique user IDs in a sorted manner. To efficiently insert new IDs and fetch sequences of IDs in a sorted order, you decide to use a Binary Search Tree (BST). Task Implement a BST class that supports inserting user IDs and performing in-order traversal to return these IDs in sorted order. Requirements 1. **Implement the BST class:** - `insert(val)`: Inserts a value into the BST. - `in_order_traversal()`: Returns a list of all values in the BST in ascending order. Input and Output Formats 1. `insert(val)` - **Input**: `val` (int) - the integer value to be inserted into the tree. - **Output**: None 2. `in_order_traversal()` - **Output**: List of integer values in ascending order. Example ```python bst = BST() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(1) print(bst.in_order_traversal()) # Output: [1, 3, 5, 7] ``` Constraints - Values are unique integers. - Operations should be optimized to avoid worst-case linear time complexity if possible. Performance Requirements Ensure that the average-case time complexity for insert and traversal operations is O(log n) and O(n) respectively.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, node, key): if key < node.val: if node.left is None: node.left = TreeNode(key) else: self._insert_recursive(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert_recursive(node.right, key) def in_order_traversal(self): return self._in_order_recursive(self.root) def _in_order_recursive(self, node): res = [] if node: res = self._in_order_recursive(node.left) res.append(node.val) res = res + self._in_order_recursive(node.right) return res"},{"question":"# Problem: Find Unique Number in an Array Context: You are working as a software engineer and are tasked with developing a utility function that can process large sequences of numbers efficiently. Specifically, you need to determine a single unique number in an array where every element appears exactly twice, except for one unique element which appears only once. Objective: Implement a function `find_unique_number(nums)` that processes an array of integers, identifying and returning the single unique number that does not have a pairing. Function Signature: ```python def find_unique_number(nums: List[int]) -> int: ``` Input: * `nums`: A list of integers of size `n` (1 ≤ n ≤ 10^5). All integers appear in pairs except for one integer. Output: * Returns a single integer representing the unique element in the array. Constraints: * Your solution should have a linear runtime complexity (O(n)). * You should not use extra memory (constant space O(1)). Example: ```python >>> find_unique_number([2, 2, 1]) 1 >>> find_unique_number([4, 1, 2, 1, 2]) 4 >>> find_unique_number([1]) 1 ``` Additional Information: * Assume that the input list always has one unique element which doesn\'t match with any other elements. Hint: * Consider leveraging the XOR bitwise operation to achieve the desired outcome efficiently.","solution":"def find_unique_number(nums): Given a list of integers where every element appears exactly twice except for one, identify and return the single unique number. Args: nums (List[int]): List of integers Returns: int: The unique number unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Palindrome Validator with String Variations Context You are required to implement a function to verify whether a given string is a palindrome. A palindrome is a word, phrase, or other sequences of characters which reads the same backward and forward (ignoring spaces, punctuation, and case sensitivity). Task Implement the given function using any of the provided variations. Function Signature ```python def is_palindrome(s: str) -> bool: ``` Input * A single string `s` where `0 <= len(s) <= 10^5`. Output * Return `True` if the string is a palindrome after converting all upper-case letters into lower-case letters and ignoring non-alphanumeric characters. * Return `False` otherwise. Constraints * The function must handle spaces and punctuations properly. * Consider all letters case-insensitive. Performance Requirements * Optimal time complexity: O(n) * Optimal space complexity: O(1) to O(n) depending on the variant chosen. Example Scenarios ```python # Example 1 input_str = \\"A man, a plan, a canal: Panama\\" result = is_palindrome(input_str) # Expected Output: True # Example 2 input_str = \\"race a car\\" result = is_palindrome(input_str) # Expected Output: False # Example 3 input_str = \\"\\" result = is_palindrome(input_str) # Expected Output: True ``` # Note * Test cases should confirm the function’s behavior with edge cases including empty strings, strings with only non-alphanumeric characters, and extremely large strings. Implement and assess your solution for accuracy and efficiency. You may choose to adopt any of the described approaches or combine their principles to achieve the best results.","solution":"def is_palindrome(s: str) -> bool: Checks if the input string s is a palindrome, ignoring non-alphanumeric characters and case differences. # Using two-pointer technique for O(n) time complexity and O(1) space complexity. left, right = 0, len(s) - 1 while left < right: # Move left pointer to the right until an alphanumeric character is found while left < right and not s[left].isalnum(): left += 1 # Move right pointer to the left until an alphanumeric character is found while left < right and not s[right].isalnum(): right -= 1 # Compare characters in a case-insensitive way if s[left].lower() != s[right].lower(): return False # Move both pointers towards the center left += 1 right -= 1 return True"},{"question":"# Coding Challenge: Efficient Insertion in a Sorted Array Problem Statement You are given a sorted array of integers and a target integer. Your task is to write a function that returns the index where the target should be inserted to maintain the sorted order of the array. Function Signature ```python def search_insert(array: list[int], val: int) -> int: pass ``` Input - `array`: A list of integers sorted in ascending order. (0 ≤ len(array) ≤ 10^5) - `val`: An integer which represents the target value to be inserted. Output - Return an integer representing the index where the target value should be inserted. Example Usage ```python assert search_insert([1, 3, 5, 6], 5) == 2 assert search_insert([1, 3, 5, 6], 2) == 1 assert search_insert([1, 3, 5, 6], 7) == 4 assert search_insert([1, 3, 5, 6], 0) == 0 assert search_insert([], 4) == 0 ``` Constraints - You must achieve a runtime complexity of O(log n). - You must ensure that the function handles edge cases appropriately, such as when the array is empty or when the value is at the boundaries of the current elements in the array. Performance Requirements Your solution should be optimized for performance, especially taking into consideration the logarithmic time complexity. Also, focus on minimal space complexity usage.","solution":"def search_insert(array: list[int], val: int) -> int: Returns the index where the value should be inserted to maintain sorted order. left, right = 0, len(array) while left < right: mid = (left + right) // 2 if array[mid] < val: left = mid + 1 else: right = mid return left"},{"question":"Julius Caesar protected his confidential information by encrypting it using a cipher. Caesar\'s cipher shifts each letter by a specified number of letters. If the shift moves past the end of the alphabet, it wraps around to the front of the alphabet. **Task**: Write a function `enhanced_caesar_cipher(s: str, k: int) -> str` that performs a Caesar Cipher encryption on the given string `s` with a shift of `k`, where `k` can be any positive or negative integer (even those greater than 26). The function should maintain the case of letters and leave non-alphabetic characters unchanged. **Input Format**: - `s`: A string containing the message to be encrypted. - `k`: An integer specifying the shift. **Output Format**: - A string representing the encrypted message. **Constraints**: - `1 ≤ |s| ≤ 10^5` (where |s| is the length of the string). **Example**: ```python assert enhanced_caesar_cipher(\\"Hello, World!\\", 3) == \\"Khoor, Zruog!\\" assert enhanced_caesar_cipher(\\"abcXYZ\\", -3) == \\"xyzUVW\\" assert enhanced_caesar_cipher(\\"Attack at Dawn!\\", 52) == \\"Attack at Dawn!\\" assert enhanced_caesar_cipher(\\"Python 3.8\\", 4) == \\"Tdexsr 3.8\\" ``` **Performance Requirements**: - The solution should be efficient and handle the upper constraint (string length up to 100,000 characters) within reasonable time limits. **Edge Cases to Consider**: - Null input (empty string). - Input containing digits, punctuation, or special characters. - Large values of `k`.","solution":"def enhanced_caesar_cipher(s: str, k: int) -> str: def shift_char(c, k): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + k) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + k) % 26 + ord(\'A\')) else: return c k = k % 26 # Normalize shifts greater than 26 result = [shift_char(c, k) for c in s] return \'\'.join(result)"},{"question":"# Question: Implement a Modified Bucket Sort You are provided with an array of floating-point numbers within the range [0, 1). Your task is to implement the bucket sort algorithm to sort this array efficiently. You are also asked to optimize the sorting within buckets by choosing an efficient sorting algorithm. **Function Signature**: ```python def modified_bucket_sort(arr: List[float]) -> List[float]: ``` **Input**: - `arr`: A list of floating point numbers, where each element `0 <= arr[i] < 1`. **Output**: - A list of floating-point numbers sorted in ascending order. **Constraints**: - The length of `arr` will be at most 10^6. - The elements in `arr` are uniformly distributed over the range [0, 1). **Performance Requirements**: - Your implementation should aim for an average time complexity of (O(n)). **Scenario**: A company is collecting sensor data that record values as floating-point numbers between 0 and 1. The data needs to be processed and sorted to detect trends and patterns. You have been asked to develop a highly efficient algorithm tailored for this use case. # Example ```python # Sample Input arr = [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68] # Sample Output sorted_arr = [0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94] ``` **Note**: - Ensure that the function handles edge cases such as an already sorted array, a reversed array, and an array with duplicate values gracefully. - Your bucket sort should distribute the elements such that it balances the load on each bucket and sorts within each bucket efficiently. - Avoid using Python\'s built-in sort functions except for in-bucket sorting.","solution":"from typing import List def modified_bucket_sort(arr: List[float]) -> List[float]: if not arr: return [] n = len(arr) buckets = [[] for _ in range(n)] for value in arr: index = int(n * value) buckets[index].append(value) for bucket in buckets: bucket.sort() sorted_arr = [] for bucket in buckets: sorted_arr.extend(bucket) return sorted_arr"},{"question":"# Coding Challenge Context You have been tasked with sorting a list of numbers using a highly inefficient yet unique sorting algorithm, Stooge Sort. This challenge will help you understand how recursive sorting algorithms can work and their properties, even if they are not practical for use. Problem Statement Implement a function `stoogesort(arr, l, h)` that sorts an array `arr` in ascending order using Stooge Sort algorithm. Function Signature ```python def stoogesort(arr, l, h): # your code here ``` Input - `arr`: List of integers `[a1, a2, ..., an]` where (1 leq n leq 10^3) - `l`: Integer, the starting index (initially `0`) - `h`: Integer, the ending index (initially `len(arr) - 1`) Output - No explicit return. The function should sort the array in-place. Constraints - The list might contain duplicates. - Optimize for correctness rather than performance. Example ```python array = [5, 2, 6, 3, 9] stoogesort(array, 0, len(array) - 1) print(array) # Should output a sorted array: [2, 3, 5, 6, 9] ``` *Note: Make sure to handle edge cases such as empty array and single-element array properly.* Performance Requirements Given the high time complexity of the algorithm, this assessment primarily focuses on validation by correctness of the output rather than efficiency. Ensure the implementation is correctly following the Stooge Sort algorithm.","solution":"def stoogesort(arr, l, h): Sorts the array arr[l:h+1] using the Stooge Sort algorithm. if l >= h: return # If the first element is greater than the last, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are at least three elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(arr, l, h - t) stoogesort(arr, l + t, h) stoogesort(arr, l, h - t)"},{"question":"Task: Write a function that finds the index of zero that, when replaced with one, results in the longest continuous sequence of 1s in a provided binary array. Input: * A binary array `arr` (contains only 0s and 1s). Output: * An integer representing the index of the zero which should be replaced with one to get the longest continuous sequence of 1s. If the array contains no zeros, return -1. Constraints: * The input array will have a length `n`, such that `1 <= n <= 10^6`. * The values in the array will be either 0 or 1. Examples: 1. Example 1: * **Input**: `[1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1]` * **Output**: `3` 2. Example 2: * **Input**: `[1, 1, 1, 1, 1]` * **Output**: `-1` Scenario: Imagine you are working on optimizing data streams where continuous sequences of binary data are prevalent. You need to determine the most critical point to correct data corruption represented by zeros in a sequence, ensuring the longest possible sequence of ones for better performance. Function Signature: ```python def max_ones_index(arr: List[int]) -> int: # Your code here ``` Implement this function in Python, and make sure to handle edge cases effectively. Test your function thoroughly with a variety of cases to ensure robustness and correctness.","solution":"from typing import List def max_ones_index(arr: List[int]) -> int: Finds the index of zero which, when replaced with one, results in the longest continuous sequence of 1s in the binary array. If no zero exists in the array, return -1. n = len(arr) if 0 not in arr: return -1 max_count = 0 max_index = -1 left_count = 0 right_count = 0 for i in range(n): if arr[i] == 0: left_count = 0 right_count = 0 j = i - 1 while j >= 0 and arr[j] == 1: left_count += 1 j -= 1 j = i + 1 while j < n and arr[j] == 1: right_count += 1 j += 1 total_count = left_count + right_count + 1 if total_count > max_count: max_count = total_count max_index = i return max_index"},{"question":"**Objective**: Implement the Nearest Neighbor Search algorithm to find and return the nearest vector point from a given training set to a specific target vector. **Function Signature**: ```python def nearest_neighbor(x: Tuple[int], tSet: Dict[Tuple[int], Any]) -> Any: ``` **Input**: 1. `x` - A tuple of integers representing the target vector. 2. `tSet` - A dictionary with tuples of integers as keys (representing each vector) and associated values. **Output**: Return the value associated with the nearest vector in the training set `tSet` to the target vector `x`. **Constraints**: 1. Each vector (both keys in `tSet` and vector `x`) will have the same dimensionality. 2. There will be at least one vector in `tSet`. 3. The vectors will have integer values and at most 1000 dimensions. **Performance Requirements**: Your implementation should efficiently handle large dimensional inputs within reasonable time limits. **Example**: ```python x = (1, 2) tSet = { (1, 3): \'A\', (4, 5): \'B\', (1, 2): \'C\' } assert nearest_neighbor(x, tSet) == \'C\' ``` In this example, (1, 2) is exactly matching with a vector in the training set, so the nearest neighbor is itself. **Edge Cases to Consider**: 1. When the training set contains more than one vector equidistant from the target vector, return the one that appears first in the input dictionary traversal. Implement the function `nearest_neighbor` as described.","solution":"from typing import Tuple, Dict, Any import math def nearest_neighbor(x: Tuple[int], tSet: Dict[Tuple[int], Any]) -> Any: This function finds and returns the value associated with the vector in the training set that is nearest to the target vector x. The training set is represented as a dictionary where the keys are tuples of integers (vectors) and the values can be of any type. def euclidean_distance(a: Tuple[int], b: Tuple[int]) -> float: return math.sqrt(sum((ai - bi) ** 2 for ai, bi in zip(a, b))) nearest_vector = None min_distance = float(\'inf\') for vector, value in tSet.items(): distance = euclidean_distance(x, vector) if distance < min_distance: min_distance = distance nearest_vector = vector return tSet[nearest_vector]"},{"question":"You are tasked with enhancing a message compression system that uses the Run-Length Encoding (RLE) algorithm for both encoding and decoding messages. The system needs to be robust, efficient, and capable of handling a variety of edge cases. # Objective Implement two functions `encode_rle` and `decode_rle` to perform Run-Length Encoding and Decoding, respectively. # Function Signature ```python def encode_rle(input: str) -> str: ... def decode_rle(input: str) -> str: ... ``` # Input/Output Requirements `encode_rle` - **Input**: A string `input` consisting of any printable ASCII characters. - **Constraints**: (0 leq text{length of input} leq 10^6) - **Output**: A compressed string using RLE encoding. `decode_rle` - **Input**: A string `input` that is a valid RLE encoded string. - **Constraints**: (0 leq text{length of input} leq 10^6) - **Output**: The original, decompressed string. # Example Encode ```python input = \\"aaaabbbcc\\" encoded = encode_rle(input) # Output: \\"4a3b2c\\" ``` Decode ```python input = \\"4a3b2c\\" decoded = decode_rle(input) # Output: \\"aaaabbbcc\\" ``` # Additional Requirements 1. **Efficiency**: Ensure both functions work efficiently, even for the upper limit of input size. 2. **Edge Cases**: Address cases such as empty input, non-repetitive characters, etc. 3. Ensure that `decode_rle` only accepts valid RLE strings. Invalid inputs should result in an empty string or an appropriate error message. # Hint 1. Consider using a counter to keep track of consecutive characters for encoding. 2. For decoding, you may need to track digit sequences to reconstruct the original string. # Scenario You are developing a simple text compression tool to help users save space when storing or transmitting large text files. By implementing these functions, you’ll provide essential functionality to encode lengthy text data efficiently and recover the original data accurately.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded_string = [] count = 1 length = len(input) for i in range(1, length): if input[i] == input[i - 1]: count += 1 else: encoded_string.append(f\\"{count}{input[i-1]}\\") count = 1 encoded_string.append(f\\"{count}{input[-1]}\\") return \\"\\".join(encoded_string) def decode_rle(input: str) -> str: if not input: return \\"\\" decoded_string = [] length = len(input) i = 0 while i < length: count = 0 while i < length and input[i].isdigit(): count = count * 10 + int(input[i]) i += 1 if i < length and input[i].isalpha(): decoded_string.append(input[i] * count) i += 1 else: # invalid RLE string return \\"\\" return \\"\\".join(decoded_string)"},{"question":"# Context: You are a software developer working on a text normalization library that needs to support various functionalities, including checking if two texts can be transformed into each other using a consistent character mapping scheme. # Objective: Write a function `is_isomorphic(s, t)` that determines if two strings s and t are isomorphic. Two strings are considered isomorphic if the characters in s can be replaced with characters in t without altering the order of characters and no two characters from s map to the same character in t, though a character can map to itself. # Specifications: - **Function Signature**: `def is_isomorphic(s: str, t: str) -> bool` - **Input**: - `s` (string): a string of length n - `t` (string): a string of length n - **Output**: - A boolean value: `True` if s and t are isomorphic, otherwise `False` - **Constraints**: - Both input strings must have the same length (if they do not, the output should be `False`). - The input strings may contain any printable ASCII characters. # Examples: - Example 1: ```python s = \\"egg\\" t = \\"add\\" Output: True ``` - Example 2: ```python s = \\"foo\\" t = \\"bar\\" Output: False ``` - Example 3: ```python s = \\"paper\\" t = \\"title\\" Output: True ``` # Notes: - You may assume all inputs are valid and of fixed length (no need to handle different string lengths outside the function scope). - Efficient use of data structures such as hash maps for character mappings is encouraged to ensure optimal performance. # Challenge: Find an optimal solution that runs in linear time and utilizes additional space proportional to the size of the input strings.","solution":"def is_isomorphic(s: str, t: str) -> bool: if len(s) != len(t): return False # Dictionary to store mappings from characters of s to t s_to_t = {} # Dictionary to store mappings from characters of t to s t_to_s = {} for char_s, char_t in zip(s, t): if char_s in s_to_t: if s_to_t[char_s] != char_t: return False elif char_t in t_to_s: if t_to_s[char_t] != char_s: return False else: s_to_t[char_s] = char_t t_to_s[char_t] = char_s return True"},{"question":"Context You are working on a data analysis tool that identifies anomalies in large datasets. The tool processes arrays of numbers, where every number appears exactly twice except for two unique elements that appear exactly once. Efficiently identifying these unique elements is crucial for your analysis. Task Write a function: ```python def find_unique_numbers(nums: List[int]) -> List[int]: Given an array of integers, where exactly two elements appear only once and all the other elements appear exactly twice, return the two elements that appear only once. :param nums: List[int], the list of integers to process :return: List[int], a list containing the two unique integers ``` # Input - The input list `nums` will have the following properties: * Contains at least 2 elements. * Exactly two unique elements appear only once. * All other elements appear exactly twice. # Output - The function should return a list with the two unique integers. # Constraints - The solution must have a time complexity of O(N). - The solution must have a space complexity of O(1). # Examples Given the following input arrays, your function should produce the outputs: 1. `find_unique_numbers([1, 2, 1, 3, 2, 5])` should return `[3, 5]` or `[5, 3]`. 2. `find_unique_numbers([2, 3, 4, 2, 5, 4])` should return `[3, 5]` or `[5, 3]`. 3. `find_unique_numbers([1, 2, 2, 3])` should return `[1, 3]` or `[3, 1]`. # Requirements - Implement the function in Python. - Do not use any extra space apart from a couple of variables (constant space usage). - Leverage bitwise operations as necessary to ensure performance constraints are met.","solution":"from typing import List def find_unique_numbers(nums: List[int]) -> List[int]: Given an array of integers, where exactly two elements appear only once and all the other elements appear exactly twice, return the two elements that appear only once. :param nums: List[int], the list of integers to process :return: List[int], a list containing the two unique integers # XOR all the elements to get the XOR of the two unique numbers xor_all = 0 for num in nums: xor_all ^= num # Find a set bit in xor_all (differences bit) # This set bit will be different between the two unique numbers diff_bit = xor_all & -xor_all # Initialize the two unique numbers num1, num2 = 0, 0 # Split the numbers into two groups and xor separately for num in nums: if num & diff_bit: num1 ^= num else: num2 ^= num return [num1, num2]"},{"question":"# Mode Finding Function You are given a list of integers. Your task is to write a function `find_modes` that returns a list of the mode(s) of the given list. The mode is the number(s) that appear most frequently. If there are multiple modes, your function should return all of them in ascending order. Input * `arr`: A list of integers. Output * A list of integers representing the mode(s) of the input list in ascending order. Constraints * The input list may contain negative and positive integers. * The length of the list will be between 0 and 10^6. Requirements * The solution should efficiently handle large datasets within the given constraints. * Your implementation should have a time complexity of O(n) to ensure scalability. Example ```python assert find_modes([1, 1, 2, 2, 3, 4]) == [1, 2] assert find_modes([4, 4, 4, 2, 2, 3]) == [4] assert find_modes([]) == [] assert find_modes([5]) == [5] assert find_modes([-1, -2, -1, -2, -2, 3]) == [-2] ``` Implement the function `find_modes` in Python: ```python def find_modes(arr): # your code here ```","solution":"from collections import Counter def find_modes(arr): Returns a list of mode(s) of the given list of integers in ascending order. if not arr: return [] # Count the frequency of each element in the array frequency = Counter(arr) # Get the maximum frequency max_freq = max(frequency.values()) # Extract elements with the maximum frequency modes = [key for key, value in frequency.items() if value == max_freq] # Return the modes in ascending order return sorted(modes)"},{"question":"# Question: Implement an Enhanced RandomizedSet Problem Description You need to implement a variation of the RandomizedSet data structure that efficiently supports the following operations in average O(1) time: 1. `insert(val)`: Inserts an element `val` into the set if it is not already present. 2. `remove(val)`: Removes an element `val` from the set if it is present. 3. `random_element()`: Returns a random element from the current set of elements, ensuring each element has an equal probability of being selected. In addition to the above operations, implement the following: 4. `max_element()`: Return the maximum element currently in the set. 5. `min_element()`: Return the minimum element currently in the set. Constraints * `val` will be an integer within the range `[1, 10^9]`. * The number of operations will not exceed `10^6`. Function Signature ```python class EnhancedRandomizedSet: def __init__(self): Initialize your data structure here. def insert(self, val: int) -> None: Inserts an item val into the set if not already present. def remove(self, val: int) -> None: Removes an item val from the set if present. def random_element(self) -> int: Returns a random element from the current set of elements. def max_element(self) -> int: Returns the maximum element in the set. def min_element(self) -> int: Returns the minimum element in the set. # Example initialization and operations: rset = EnhancedRandomizedSet() rset.insert(1) rset.insert(5) rset.insert(3) print(rset.random_element()) # any of [1, 5, 3] rset.remove(5) print(rset.max_element()) # 3 print(rset.min_element()) # 1 ``` Additional Notes 1. Each method must run in constant average time, i.e., O(1). 2. You may utilize additional data structures to preserve the required time complexity. 3. Ensure proper handling of edge cases, such as requests from empty sets for random, max, or min elements. Testing Ensure that your implementation can handle large inputs efficiently and correctly: * Test with sequences of interleaved insertions and deletions. * Validate correct retrieval of random, max, and min elements under varying conditions. * Consider edge cases such as empty set operations and elements at the boundaries of the integer range.","solution":"import random class EnhancedRandomizedSet: def __init__(self): Initialize your data structure here. self.data = {} self.list = [] def insert(self, val: int) -> bool: Inserts an item val into the set if not already present. Returns True if the item was inserted, False otherwise. if val in self.data: return False self.data[val] = len(self.list) self.list.append(val) return True def remove(self, val: int) -> bool: Removes an item val from the set if present. Returns True if the item was removed, False otherwise. if val not in self.data: return False # Move the last element to the place idx of the element to delete last_elem = self.list[-1] idx = self.data[val] self.list[idx] = last_elem self.data[last_elem] = idx # Remove the last element self.list.pop() del self.data[val] return True def random_element(self) -> int: Returns a random element from the current set of elements. if not self.list: raise IndexError(\\"RandomizedSet is empty.\\") return random.choice(self.list) def max_element(self) -> int: Returns the maximum element in the set. if not self.list: raise ValueError(\\"RandomizedSet is empty.\\") return max(self.list) def min_element(self) -> int: Returns the minimum element in the set. if not self.list: raise ValueError(\\"RandomizedSet is empty.\\") return min(self.list)"},{"question":"# Question: Combination Sum Finder Problem Description You are given a set of candidate numbers (without duplicates) and a target number. Your task is to write a function `combination_sum(candidates, target)` that returns all unique combinations in candidates where the candidate numbers sum to the target. Requirements - The same repeated number may be chosen from candidates an unlimited number of times. - All numbers (including target) will be positive integers. - The solution set must not contain duplicate combinations. Example Given candidate set `[2, 3, 6, 7]` and target `7`, a solution set is: ``` [ [7], [2, 2, 3] ] ``` Function Signature ```python def combination_sum(candidates: List[int], target: int) -> List[List[int]]: pass ``` Constraints - The number of candidates `1 <= n <= 30`. - The value of each candidate and the target `1 <= candidate, target <= 40`. Your implementation must be efficient in terms of both time and space complexity, given the constraints. Consider potential edge cases and ensure the function is robust.","solution":"from typing import List def combination_sum(candidates: List[int], target: int) -> List[List[int]]: Finds all unique combinations in candidates where the candidate numbers sum to target. :param candidates: List of unique integers :param target: Target sum integer :return: List of lists, each containing a unique combination of numbers summing to target result = [] def backtrack(remain, comb, start): if remain == 0: # make a deep copy of the current combination result.append(list(comb)) return elif remain < 0: # exceed the scope, stop exploration. return for i in range(start, len(candidates)): # add the number into the combination comb.append(candidates[i]) # give the current number another chance, since we can reuse it backtrack(remain - candidates[i], comb, i) # backtrack, remove the number from the combination comb.pop() backtrack(target, [], 0) return result"},{"question":"**Problem Description**: You are given two binary trees `big` and `small`. Implement a function `is_subtree(big, small)` that checks if `small` is a subtree of `big`. A subtree of a tree `t` is a tree consisting of a node in `t` and all of its descendants in `t`. # Input - Two binary trees, `big` and `small`. Each tree node contains an integer value. # Output - Return `True` if `small` is a subtree of `big`, otherwise return `False`. # Constraints - The number of nodes in each tree is between `1` and `10^4`. - Each node\'s value is a unique integer. # Example Example 1: ``` big: 3 / 4 5 / 1 2 small: 4 / 1 2 Output: True ``` Example 2: ``` big: 3 / 4 5 / 1 2 / 0 small: 4 / 1 2 Output: False ``` # Implementation Craft a solution following the BFS and recursive DFS comparison principle. Utilize breadth-first search to navigate through the `big` tree nodes and a recursive approach to validate subtree equivalency. ```python import collections class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(big, small): if not small: return True # an empty tree is a subtree of any tree if not big: return False # a non-empty tree cannot be a subtree of an empty tree queue = collections.deque([big]) while queue: node = queue.popleft() if node and node.val == small.val: if compare_trees(node, small): return True if node: queue.append(node.left) queue.append(node.right) return False def compare_trees(p, q): if not p and not q: return True if not p or not q: return False return (p.val == q.val and compare_trees(p.left, q.left) and compare_trees(p.right, q.right)) ``` **Note**: You may structure the function as you see fit as long as it meets the input-output requirements and adheres to performance constraints.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(big, small): if not small: return True # an empty tree is a subtree of any tree if not big: return False # a non-empty tree cannot be a subtree of an empty tree def compare_trees(t1, t2): if not t1 and not t2: return True if not t1 or not t2: return False return t1.val == t2.val and compare_trees(t1.left, t2.left) and compare_trees(t1.right, t2.right) def dfs(node): if not node: return False if node.val == small.val and compare_trees(node, small): return True return dfs(node.left) or dfs(node.right) return dfs(big)"},{"question":"**Question: Implement and Enhance Comb Sort Algorithm** You are given an array of integers. Your task is to implement the comb sort algorithm as provided and enhance it to handle different scenarios more efficiently. # Function Signature ```python def enhanced_comb_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr`: A list of integers ((1 leq |arr| leq 10^4)) # Output * Returns a sorted list of integers in ascending order. # Constraints * May contain negative and positive integers. * It should handle already sorted arrays optimally. * Ensure to avoid performance degradation with large arrays. # Example ```python assert enhanced_comb_sort([4, 2, 7, 1, 3]) == [1, 2, 3, 4, 7] assert enhanced_comb_sort([10, -1, 2, 5]) == [-1, 2, 5, 10] assert enhanced_comb_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert enhanced_comb_sort([]) == [] ``` # Instructions: 1. Implement the comb sort algorithm provided above in the method `enhanced_comb_sort`. 2. Optimize the algorithm to efficiently handle edge cases such as sorted arrays and arrays with all identical elements. 3. The function should handle lists with up to (10^4) elements within a reasonable time frame.","solution":"from typing import List def enhanced_comb_sort(arr: List[int]) -> List[int]: def get_next_gap(gap: int) -> int: # Shrinks the gap by the shrink factor 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n shrink = 1.3 # Shrink factor sorted = False # Initially, we assume the array is not sorted while gap > 1 or not sorted: gap = get_next_gap(gap) sorted = True # Assume the list is sorted for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False # We found a misplacement, so assume it\'s not sorted return arr"},{"question":"# Question: Enhanced Shortest Path Finder with Skip Nodes **Scenario**: You are developing a navigation system for a campus map application. The map is represented as a graph with buildings as nodes and paths as edges. You need to find the shortest path between two buildings. However, some buildings are under construction and must be skipped during pathfinding. **Requirements**: Write a function that finds the shortest path between two nodes in a graph while allowing specific nodes to be skipped. **Function Signature**: ```python def find_shortest_path_with_skips(graph: dict, start: str, end: str, skips: list) -> list: pass ``` **Input**: * `graph`: A dictionary representing the graph where keys are node identifiers and values are lists of adjacent nodes. * `start`: The starting node identifier. * `end`: The destination node identifier. * `skips`: A list of node identifiers that must be skipped. **Output**: * A list representing the shortest path from `start` to `end` skipping the nodes in `skips`, or `None` if no path exists. **Constraints**: * All node identifiers are unique strings. * `start` and `end` are valid nodes within the graph. * Nodes in `skips` are also valid nodes within the graph. **Example**: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } # Example call find_shortest_path_with_skips(graph, \'A\', \'F\', [\'B\']) # Expected output: [\'A\', \'C\', \'F\'] ``` **Guidelines**: * Use an appropriate graph traversal algorithm. * Respect the nodes in the `skips` list by not including them in any paths. * Ensure the solution is optimized for performance considerations such as avoiding redundant calculations.","solution":"from collections import deque def find_shortest_path_with_skips(graph: dict, start: str, end: str, skips: list) -> list: Finds the shortest path from start to end in the graph, skipping specified nodes. :param graph: A dictionary representing the graph where keys are node identifiers and values are lists of adjacent nodes. :param start: The starting node identifier. :param end: The destination node identifier. :param skips: A list of node identifiers that must be skipped. :return: A list representing the shortest path from start to end skipping the nodes in skips, or None if no path exists. if start in skips or end in skips: return None skips_set = set(skips) queue = deque([(start, [start])]) visited = set() while queue: current_node, path = queue.popleft() if current_node in visited: continue visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor == end: return path + [end] if neighbor not in skips_set: queue.append((neighbor, path + [neighbor])) return None"},{"question":"# Incrementing a Number Represented as an Array of Digits Context: You are developing a utility for performing arithmetic on very large integers represented as arrays. One of the basic operations needed is incrementing such a number by one. This needs to handle the integer\'s digit array correctly, taking care of carry propagations where necessary. Task: Write a function `increment_array` that takes an array of digits `digits` representing a non-negative integer, and returns an array of digits representing the integer incremented by one. Input Format: - `digits`: A list of integers where each integer `digit` satisfies `0 <= digit <= 9`. Output Format: - A list of integers representing the incremented integer. Constraints: - The input array will not contain leading zeros unless they are representing the number `0`. - The length of the input array will be between 1 and 10^4. Example Input ```python digits = [1, 2, 3] ``` Example Output ```python [1, 2, 4] ``` Additional Example ```python digits = [9, 9, 9] ``` Additional Expected Output ```python [1, 0, 0, 0] ``` Performance Requirements: - The solution should have a time complexity of O(n), where n is the number of digits in the input array. - The solution should ideally have constant space complexity, excluding the input and output. Implement the function `increment_array` as specified above. ```python def increment_array(digits): pass # Your code here ```","solution":"def increment_array(digits): Increment the number represented by an array of digits by one. :param digits: List[int] - A list of integers where each integer digit satisfies 0 <= digit <= 9. :return: List[int] - A list of integers representing the incremented integer. n = len(digits) for i in range(n - 1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 # If we are here, it means we had a carry on all digits and we need an extra digit return [1] + [0] * n"},{"question":"You are given a binary tree defined by the following TreeNode class: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` **Task:** Write a Python function `min_depth_dfs` that computes the minimum depth of a binary tree using depth-first search (DFS), and another function `min_depth_bfs` that computes the minimum depth using breadth-first search (BFS). # Function Signatures ```python def min_depth_dfs(root: TreeNode) -> int: Compute the minimum depth of a binary tree using DFS. :param root: TreeNode representing the root of the binary tree. :return: The minimum depth as an integer. ``` ```python def min_depth_bfs(root: TreeNode) -> int: Compute the minimum depth of a binary tree using BFS. :param root: TreeNode representing the root of the binary tree. :return: The minimum depth as an integer. ``` # Input - `root`: The root node of a binary tree. # Output - The minimum depth of the binary tree. # Constraints - The number of nodes in the tree is in the range [0, 10^4]. - `-1000 <= Node.val <= 1000` # Example: Given the binary tree: ``` 3 / 9 20 / 15 7 ``` - For `min_depth_dfs(root)`, the output should be `2`. - For `min_depth_bfs(root)`, the output should be `2`. # Note: 1. Ensure your solution handles edge cases like an empty tree. 2. Consider the efficiency of your solution in terms of time and space complexity.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_depth_dfs(root: TreeNode) -> int: Compute the minimum depth of a binary tree using DFS. :param root: TreeNode representing the root of the binary tree. :return: The minimum depth as an integer. if not root: return 0 if not root.left and not root.right: return 1 if not root.left: return min_depth_dfs(root.right) + 1 if not root.right: return min_depth_dfs(root.left) + 1 return min(min_depth_dfs(root.left), min_depth_dfs(root.right)) + 1 def min_depth_bfs(root: TreeNode) -> int: Compute the minimum depth of a binary tree using BFS. :param root: TreeNode representing the root of the binary tree. :return: The minimum depth as an integer. if not root: return 0 queue = deque([(root, 1)]) while queue: node, depth = queue.popleft() if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1))"},{"question":"Context: You are working with a sequence of unique temperature readings taken at regular intervals over several days. The readings are sorted in ascending order. To generate a summary report, you need to condense consecutive sequences of readings into summarized ranges. Objective: Write a function that takes a sorted list of unique integers representing temperature readings and returns a list of strings summarizing the continuous ranges. Function Signature: ```python def summarize_ranges(temperatures: List[int]) -> List[str]: ``` Input: * `temperatures` (List[int]): A non-empty list of unique integers in ascending order representing temperature readings. Output: * `List[str]`: A list of strings where each string represents a continuous range of readings. Each range should be formatted as `\\"{start}-{end}\\"` if the range includes multiple numbers, or just `\\"{single}\\"` if the range includes exactly one number. Constraints: * The input list will always contain unique integers and be sorted in ascending order. * The length of the list will be between 1 and 10^4. Requirements: - The algorithm should run in O(n) time complexity with O(n) space complexity. Example: 1. Input: `[0, 1, 2, 4, 5, 7]` Output: `[\\"0-2\\", \\"4-5\\", \\"7\\"]` 2. Input: `[1, 2, 3, 5, 7, 8, 9]` Output: `[\\"1-3\\", \\"5\\", \\"7-9\\"]` Functions should handle any edge cases appropriately, such as a single-element list.","solution":"from typing import List def summarize_ranges(temperatures: List[int]) -> List[str]: Returns a list of strings summarizing continuous ranges of temperatures. Parameters: temperatures (List[int]): A sorted list of unique integers representing temperature readings. Returns: List[str]: A list of strings where each string represents a continuous range of readings. if not temperatures: return [] ranges = [] start = temperatures[0] end = temperatures[0] for temp in temperatures[1:]: if temp == end + 1: end = temp else: if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") start = temp end = temp if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") return ranges"},{"question":"Implement Extended Functionality for Segment Tree **Context**: You\'re a software engineer responsible for extending the functionality of a Segment Tree data structure used in a competitive coding environment. Your task is to implement additional methods that allow for efficient sum range queries over intervals, particularly including lazy propagation for range updates. This will enhance your data structure\'s performance during bulk range updates. **Task**: Extend the `SegmentTree` class to handle range updates efficiently using lazy propagation and implement a method to compute the sum of elements in any given range. **Function 1**: `update_range(l: int, r: int, value: int)` - **Input**: * `l` - start index of the range (inclusive, 0-based). * `r` - end index of the range (inclusive, 0-based). * `value` - value to add to each element in the range [l, r]. - **Output**: None. - **Details**: Update all elements in the array between indices `l` and `r` (inclusive) by adding `value`. **Function 2**: `range_sum(l: int, r: int) -> int` - **Input**: * `l` - start index of the range (inclusive, 0-based). * `r` - end index of the range (inclusive, 0-based). - **Output**: * **Returns** the sum of the elements in the array between indices `l` and `r` (inclusive). **Constraints**: - All inputs will fulfill the condition: `0 <= l <= r < n`, where `n` is the size of the array. **Example**: ```python arr = [2, 4, 5, 3, 4] mytree = SegmentTree(arr, lambda a, b: a + b) print(mytree.range_sum(1, 3)) # Output: 12 (4+5+3) mytree.update_range(1, 3, 2) # arr becomes [2, 6, 7, 5, 4] print(mytree.range_sum(1, 3)) # Output: 18 (6+7+5) ``` **Specifications**: * Implement the provided additional methods in a new class `LazySegmentTree` inheriting from `SegmentTree` or extending it as needed. * The `SegmentTree` initialization and operations should be retained. ```python class LazySegmentTree(SegmentTree): def __init__(self, arr, function): super().__init__(arr, function) self.lazy = [0] * (2 * self.size) def update_range(self, l, r, value): # Implement the lazy propagation range update logic pass def range_sum(self, l, r): # Implement the range sum query logic considering lazy updates pass ```","solution":"class SegmentTree: def __init__(self, arr, function): self.function = function self.n = len(arr) self.tree = [0] * (2 * self.n) self.build(arr) def build(self, arr): for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i << 1], self.tree[i << 1 | 1]) def update(self, pos, value): pos += self.n self.tree[pos] += value while pos > 1: pos >>= 1 self.tree[pos] = self.function(self.tree[pos << 1], self.tree[pos << 1 | 1]) def query(self, l, r): res = 0 l += self.n r += self.n + 1 while l < r: if l & 1: res = self.function(res, self.tree[l]) l += 1 if r & 1: r -= 1 res = self.function(res, self.tree[r]) l >>= 1 r >>= 1 return res class LazySegmentTree(SegmentTree): def __init__(self, arr, function): super().__init__(arr, function) self.lazy = [0] * (2 * self.n) def _apply(self, pos, value, length): self.tree[pos] += value * length if pos < self.n: self.lazy[pos] += value def _push(self, pos, length): for s in range(self.n.bit_length(), 0, -1): i = pos >> s if self.lazy[i] != 0: self._apply(i << 1, self.lazy[i], length >> s) self._apply(i << 1 | 1, self.lazy[i], length >> s) self.lazy[i] = 0 def update_range(self, l, r, value): l0, r0 = l, r length = 1 l += self.n r += self.n + 1 while l < r: if l & 1: self._apply(l, value, length) l += 1 if r & 1: r -= 1 self._apply(r, value, length) l >>= 1 r >>= 1 length <<= 1 self._push(l0 + self.n, r0 - l0 + 1) def range_sum(self, l, r): self._push(l + self.n, r - l + 1) return super().query(l, r)"},{"question":"# Question: Compute Totient Function for an Array of Numbers You have been given an array of integers. Your task is to implement a function that calculates Euler\'s Totient function (ϕ-function) for each number in the array. # Function Specification Function Name `compute_totients` Input * `nums`: List of positive integers. (1 <= len(nums) <= 10^5 and 1 <= nums[i] <= 10^6) Output * List of integers where the i-th element is the Euler\'s Totient of `nums[i]`. Example ```python assert compute_totients([1, 2, 3, 4, 5]) == [1, 1, 2, 2, 4] assert compute_totients([6, 7, 8, 9, 10]) == [2, 6, 4, 6, 4] ``` # Constraints * Your implementation should return results efficiently even for large inputs. * Consider memoization or any optimization technique to handle repeated computations. # Additional Information Euler\'s Totient function, ϕ(n), for a given integer n is the count of integers from 1 to n that are coprime with n. The numbers are considered coprime if their greatest common divisor (gcd) is 1. # Notes * You should handle edge cases such as very small numbers and large prime numbers. * Use techniques to ensure that the implementation can handle the upper limits of the constraints efficiently.","solution":"def compute_totients(nums): Computes the Euler\'s Totient function values for an array of numbers. Parameters: nums (list): List of positive integers. (1 <= len(nums) <= 10^5 and 1 <= nums[i] <= 10^6) Returns: list: List of integers where the i-th element is the Euler\'s Totient of nums[i]. max_val = max(nums) phi = list(range(max_val + 1)) for i in range(2, max_val + 1): if phi[i] == i: # i is a prime number for j in range(i, max_val + 1, i): phi[j] = phi[j] * (i - 1) // i result = [phi[num] for num in nums] return result"},{"question":"# Matrix Multiplication Implementation with Error Handling Background: Matrix multiplication is a fundamental operation in many mathematical and applied contexts, ranging from solving systems of linear equations to transformations in computer graphics. However, its proper implementation requires careful handling of dimensional compatibility and efficient computation to manage the computational complexity. Task: Write a Python function `matrix_multiply` that takes two two-dimensional lists (matrices) as inputs and returns their product. You must handle edge cases such as incompatible matrix dimensions by raising appropriate exceptions. Function Signature: ```python def matrix_multiply(multiplicand: list, multiplier: list) -> list: pass ``` Input: - `multiplicand`: A 2D list where each sublist represents a row of the first matrix. - `multiplier`: A 2D list where each sublist represents a row of the second matrix. Output: - A 2D list representing the product matrix. Constraints: - Each input matrix can be assumed to be rectangular (all rows of a matrix have the same number of elements). - The number of columns in the `multiplicand` must equal the number of rows in the `multiplier` for multiplication. Example: ```python # Example 1 multiplicand = [[1, 2], [3, 4]] multiplier = [[2, 0], [1, 2]] output = matrix_multiply(multiplicand, multiplier) # Expected Output: [[4, 4], [10, 8]] # Example 2 multiplicand = [[1, 0, 2], [-1, 3, 1]] multiplier = [[3, 1], [2, 1], [1, 0]] output = matrix_multiply(multiplicand, multiplier) # Expected Output: [[5, 1], [4, 2]] ``` Notes: - You should handle incompatible matrices by raising an Exception with a message \\"Multiplicand matrix not compatible with Multiplier matrix.\\" - Ensure to use efficient computational practices to avoid excessive time and space complexity where possible.","solution":"def matrix_multiply(multiplicand: list, multiplier: list) -> list: Multiplies two matrices and returns the product. Raises an exception if the matrices are not compatible for multiplication. # Number of rows in multiplicand rows_multiplicand = len(multiplicand) # Number of columns in multiplicand / number of rows in multiplier cols_multiplicand = len(multiplicand[0]) rows_multiplier = len(multiplier) # Number of columns in multiplier cols_multiplier = len(multiplier[0]) if cols_multiplicand != rows_multiplier: raise ValueError(\\"Multiplicand matrix not compatible with Multiplier matrix.\\") # Initialize the result matrix with zeros result = [[0 for _ in range(cols_multiplier)] for _ in range(rows_multiplicand)] # Perform the multiplication for i in range(rows_multiplicand): for j in range(cols_multiplier): for k in range(cols_multiplicand): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Integer Partition Count Given a positive integer `n`, write a function `integer_partition(n)` that returns the number of ways `n` can be decomposed into sums of non-negative integers. The function should comply with the following criteria: * The input `n` is a positive integer (1 ≤ n ≤ 100). * The output should be a single integer representing the number of partitions. # Function Signature ```python def integer_partition(n: int) -> int: pass ``` # Input * `n (int)`: a positive integer representing the number to be partitioned. # Output * Return a single integer, which is the count of decompositions of `n`. # Examples Example 1 ```plaintext Input: 4 Output: 5 Explanation: 4 can be partitioned as: 4 = 4 4 = 3 + 1 4 = 2 + 2 4 = 2 + 1 + 1 4 = 1 + 1 + 1 + 1 ``` Example 2 ```plaintext Input: 7 Output: 15 Explanation: 7 can be partitioned as: 7 = 7 7 = 6 + 1 7 = 5 + 2 7 = 5 + 1 + 1 7 = 4 + 3 7 = 4 + 2 + 1 7 = 4 + 1 + 1 + 1 7 = 3 + 3 + 1 7 = 3 + 2 + 2 7 = 3 + 2 + 1 + 1 7 = 3 + 1 + 1 + 1 + 1 7 = 2 + 2 + 2 + 1 7 = 2 + 2 + 1 + 1 + 1 7 = 2 + 1 + 1 + 1 + 1 + 1 7 = 1 + 1 + 1 + 1 + 1 + 1 + 1 ``` # Constraints * 1 ≤ n ≤ 100 # Performance Requirements * The solution should have a time complexity of O(n^2) and a space complexity of O(n^2).","solution":"def integer_partition(n: int) -> int: Returns the number of ways `n` can be decomposed into sums of non-negative integers. # Create a list for storing the count of partitions # p[k] will store the number of partitions of the integer k p = [0] * (n + 1) # There is exactly one way to partition 0: using no parts at all p[0] = 1 # Iterate over the parts for k in range(1, n + 1): for i in range(k, n + 1): p[i] += p[i - k] return p[n]"},{"question":"# Cycle Sort Coding Challenge You are required to implement the Cycle Sort algorithm. Given an array of unique integers, the function should sort the array using the Cycle Sort algorithm as defined. Implement the function `cycle_sort(arr)` that takes an array `arr` of integers and returns the sorted array. Input * An array `arr` containing `N` unique integers. Output * Return a sorted array of the same integers. Constraints * `1 ≤ N ≤ 1000` * The integers in the array will range from `-10^9` to `10^9`. Performance Requirements * Your solution should have a time complexity of O(N^2) on average. * It should utilize constant space (in-place sorting). Example ```python def cycle_sort(arr): cycle_sort Implements cycle sort given an array arr of unique integers. len_arr = len(arr) # Finding cycle to rotate. for cur in range(len_arr - 1): item = arr[cur] # Finding an index to put items in. index = cur for i in range(cur + 1, len_arr): if arr[i] < item: index += 1 # Case where there is no cycle if index == cur: continue # Putting the item immediately right after the duplicate item or on the right. while item == arr[index]: index += 1 arr[index], item = item, arr[index] # Rotating the remaining cycle. while index != cur: # Finding where to put the item. index = cur for i in range(cur + 1, len_arr): if arr[i] < item: index += 1 # After item is duplicated, put it in place or put it there. while item == arr[index]: index += 1 arr[index], item = item, arr[index] return arr # Test test_array = [4, 1, 3, 9, 7] print(cycle_sort(test_array)) # Output: [1, 3, 4, 7, 9] ``` Consider edge cases such as an already sorted array, an array with negative integers, and a large array to test the performance.","solution":"def cycle_sort(arr): cycle_sort Implements cycle sort given an array arr of unique integers. len_arr = len(arr) # Finding cycle to rotate. for cur in range(len_arr - 1): item = arr[cur] # Finding an index to put items in. index = cur for i in range(cur + 1, len_arr): if arr[i] < item: index += 1 # Case where there is no cycle if index == cur: continue # Putting the item immediately right after the duplicate item or on the right. while item == arr[index]: index += 1 arr[index], item = item, arr[index] # Rotating the remaining cycle. while index != cur: # Finding where to put the item. index = cur for i in range(cur + 1, len_arr): if arr[i] < item: index += 1 # After item is duplicated, put it in place or put it there. while item == arr[index]: index += 1 arr[index], item = item, arr[index] return arr"},{"question":"# Question: Problem Statement: You are given an undirected graph represented by an adjacency list. Implement a function `find_largest_clique` that returns the largest clique in the graph. A clique is a subset of vertices such that every two vertices in the subset are connected by an edge. Function Signature: ```python def find_largest_clique(edges: Dict[int, Set[int]]) -> List[int]: ``` Input: - `edges`: A dictionary where the keys are integers representing vertices and the values are sets of integers representing the adjacent vertices. Output: - Returns a list of integers representing the vertices in the largest clique found. If there are multiple cliques with the same size, return any one of them. Constraints: - The number of vertices in the graph is `1 <= V <= 100`. - The number of edges in the graph is `0 <= E <= V*(V-1)/2`. Example Input: ```python edges = { 0: {1, 2}, 1: {0, 2}, 2: {0, 1, 3}, 3: {2} } ``` Example Output: ```python [0, 1, 2] ``` Notes: - The graph is undirected and may contain no edges. - Aim to optimize the solution for both time and space complexity where possible, given the constraints. Solution Hints: - Utilize the Bron-Kerbosch algorithm for clique finding. - Pay attention to edge cases such as graphs with no edges or a single vertex.","solution":"from typing import Dict, Set, List def find_largest_clique(edges: Dict[int, Set[int]]) -> List[int]: def bron_kerbosch(R, P, X): nonlocal max_clique if not P and not X: if len(R) > len(max_clique): max_clique = R return for v in list(P): new_R = R | {v} new_P = P & edges[v] new_X = X & edges[v] bron_kerbosch(new_R, new_P, new_X) P.remove(v) X.add(v) max_clique = set() vertices = set(edges.keys()) bron_kerbosch(set(), vertices, set()) return list(max_clique) # Example usage: # edges = { # 0: {1, 2}, # 1: {0, 2}, # 2: {0, 1, 3}, # 3: {2} # } # print(find_largest_clique(edges)) # Output: [0, 1, 2]"},{"question":"Anagram Checker with Flexible Character Sets Objective Write a function that determines if two given strings are anagrams of each other. This time, the function has to handle all ASCII characters and be case insensitive. Function Signature ```python def are_anagrams(s1: str, s2: str) -> bool: ``` Input * **s1**: A string containing ASCII characters. * **s2**: A string containing ASCII characters. Output * **Return**: True if `s1` and `s2` are anagrams of each other, else return False. Constraints * The solution must consider all ASCII characters (`ord(c) -> [0, 255]`). * The function should be case insensitive (\'a\' and \'A\' are considered the same). Example ```python assert are_anagrams(\\"apple\\", \\"pleap\\") == True assert are_anagrams(\\"apple\\", \\"apPle\\") == True assert are_anagrams(\\"apple\\", \\"cherry\\") == False assert are_anagrams(\\"Listen\\", \\"Silent\\") == True assert are_anagrams(\\"Dormitory\\", \\"Dirty room\\") == True assert are_anagrams(\\"Hello, World!\\", \\"Wor!ld, Hello\\") == True ``` Additional Notes * Your implementation should handle varying character cases and non-alphabetic characters correctly. * You should aim for a time complexity of O(n) and a space complexity of O(1) relative to the input size.","solution":"def are_anagrams(s1: str, s2: str) -> bool: Returns True if s1 and s2 are anagrams of each other, ignoring case and considering all ASCII characters. # Normalize strings by converting to lowercase and ignoring spaces s1_normalized = \'\'.join(sorted(s1.lower().replace(\\" \\", \\"\\"))) s2_normalized = \'\'.join(sorted(s2.lower().replace(\\" \\", \\"\\"))) return s1_normalized == s2_normalized"},{"question":"# Question: Implement a Balanced Binary Search Tree Iterator You are given a binary search tree (BST) with `n` nodes. Your task is to implement an iterator for the BST, which returns the nodes\' values in ascending order. The iterator should take advantage of the properties of BSTs and must be optimized for both time and space efficiency. Function Definitions 1. **Class Constructor** ```python class BalancedBSTIterator: def __init__(self, root: TreeNode): Initialize your data structure here. Args: - root: TreeNode, the root of the binary search tree. pass ``` 2. **has_next method** ```python def has_next(self) -> bool: @return: True if there has the next smallest number, False otherwise. pass ``` 3. **next method** ```python def next(self) -> int: @return: The next smallest number in the BST. pass ``` # Constraints 1. The `has_next` function should return a boolean indicating whether there are more nodes to be visited. 2. The `next` function should return the next smallest number in the BST. 3. The space complexity should not exceed O(h), where h is the height of the tree. 4. Both methods should have efficient time complexity. # Input - The root node of the BST. # Output - For the `has_next` method, return `True` or `False`. - For the `next` method, return the next smallest node value. # Performance Requirements - Your solution should work efficiently even for large balanced BSTs where the height h is log(n). # Example ```python # Assuming TreeNode is defined as: class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Usage: # root = TreeNode(7) # root.left = TreeNode(3) # root.right = TreeNode(15) # root.right.left = TreeNode(9) # root.right.right = TreeNode(20) # iter = BalancedBSTIterator(root) # while iter.has_next(): # print(iter.next()) # Output: 3, 7, 9, 15, 20 ``` # Note - You must analyze the properties and potential edge cases of BST traversal. - Ensure your code handles empty trees and skewed trees effectively.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BalancedBSTIterator: def __init__(self, root: TreeNode): self.stack = [] self._push_left_branch(root) def _push_left_branch(self, node: TreeNode): while node: self.stack.append(node) node = node.left def has_next(self) -> bool: return len(self.stack) > 0 def next(self) -> int: if not self.has_next(): raise StopIteration(\\"No more elements in BST iterator\\") next_node = self.stack.pop() self._push_left_branch(next_node.right) return next_node.val"},{"question":"# Hailstone Sequence Simulation and Analysis Scenario Mathematics enthusiasts are interested in analyzing number sequences to discover patterns and conjectural behaviors. The Hailstone sequence (Collatz sequence) is one such sequence that has intrigued mathematicians for years. It\'s generated by taking any positive integer and applying a set of transformations until reaching the number 1. Your task is to extend the given function to not only generate the Hailstone sequence but also to analyze it. Specifically, you will need to determine and return the length of the sequence and the highest number reached. # Objective Write a function `analyze_hailstone(n)` which generates the Hailstone sequence starting at `n`, then returns: - The length of the sequence. - The highest number reached during the generation of the sequence. # Input and Output Input * An integer `n` (1 <= n <= 10^6) representing the starting point of the sequence. Output * A tuple `(length, max_value)` where: - `length` is the number of terms in the sequence starting at `n` and ending at 1. - `max_value` is the highest value encountered during the sequence generation. # Constraints - `1 <= n <= 10^6` - The function must run efficiently for values up to 1,000,000. # Example ```python def analyze_hailstone(n: int) -> (int, int): sequence = [n] max_value = n while n > 1: if n % 2 != 0: n = 3 * n + 1 else: n = n // 2 sequence.append(n) if n > max_value: max_value = n return (len(sequence), max_value) # Example Usage: print(analyze_hailstone(7)) # Output: (17, 52) ``` * In this example, starting with `n=7`, the sequence generated is [7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]. * Thus, the length of the sequence is 17, and the highest value reached is 52. Note: Your function should handle edge cases gracefully and ensure performance given the constraints.","solution":"def analyze_hailstone(n: int) -> (int, int): length = 1 max_value = n while n > 1: if n % 2 != 0: n = 3 * n + 1 else: n = n // 2 if n > max_value: max_value = n length += 1 return (length, max_value)"},{"question":"You are given an array of distinct integers. Your task is to sort this array in ascending order using the Cycle Sort algorithm. The algorithm should be implemented in a way that it minimizes the number of write operations to the array, which is a key advantage of the Cycle Sort. # Function Signature ```python def cycle_sort(arr: List[int]) -> List[int]: pass ``` # Input - `arr`: A list of integers, where (1 leq len(arr) leq 1000) and all elements are distinct. # Output - Returns a sorted list of integers in ascending order. # Constraints - All elements in `arr` are distinct. - The function should sort the array in place (without using extra space except for variables). # Performance Requirements - The algorithm should demonstrate O(N^2) time complexity and O(1) space complexity. # Example Example 1 ```python Input: arr = [3, 2, 1] Output: [1, 2, 3] ``` Example 2 ```python Input: arr = [1, 8, 3, 9, 6, 2, 7, 5, 4] Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] ``` # Additional Notes - Handle edge cases such as an empty array or an already sorted array. - Focus on minimizing the number of write operations to the array.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: writes = 0 # Cycle through the array to find cycles for cycle_start in range(0, len(arr) - 1): item = arr[cycle_start] # Find the position where we put the element pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Otherwise, put the item to the correct position while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"Problem Statement: Given two strings `s1` and `s2`, write a function `is_rotated_version` that determines if `s2` is a rotated version of `s1`. For instance: * `is_rotated_version(\\"hello\\", \\"llohe\\")` should return `True` because `llohe` can be obtained by rotating `hello` to the right by 2 positions. * `is_rotated_version(\\"hello\\", \\"helol\\")` should return `False`. Requirements: 1. Function Signature: `def is_rotated_version(s1: str, s2: str) -> bool:` 2. Input: - `s1`, `s2`: Strings of length `N` where `N` can be large. 3. Output: - Boolean `True` or `False` indicating if `s2` is a rotated version of `s1`. 4. Constraints: - The lengths of `s1` and `s2` can be in the range [0, 10^5]. Example: ```python assert is_rotated_version(\\"hello\\", \\"llohe\\") == True assert is_rotated_version(\\"hello\\", \\"helol\\") == False assert is_rotated_version(\\"abcde\\", \\"cdeab\\") == True assert is_rotated_version(\\"abcde\\", \\"abced\\") == False assert is_rotated_version(\\"waterbottle\\", \\"erbottlewat\\") == True assert is_rotated_version(\\"\\", \\"\\") == True assert is_rotated_version(\\"a\\", \\"\\") == False assert is_rotated_version(\\"\\", \\"a\\") == False ``` Performance Requirements: - Your solution should run in linear time, O(N), where N is the length of the strings. - The space complexity should be O(1) except the space used to create and store the arguments and concatenated string. Hint: - Consider how concatenating a string with itself might help you solve this problem efficiently.","solution":"def is_rotated_version(s1, s2): Determines if s2 is a rotated version of s1. Args: s1: str - The original string. s2: str - The string to check if it is a rotated version of s1. Returns: bool: True if s2 is a rotated version, False otherwise. # If lengths of s1 and s2 are not the same, s2 cannot be a rotated version of s1 if len(s1) != len(s2): return False # Concatenate s1 with itself concatenated = s1 + s1 # Check if s2 is a substring of the concatenated string return s2 in concatenated"},{"question":"# Scenario You are a software engineer at a startup working on a feature for a networking app, and one of your tasks is to efficiently reverse the order of messages. The messages are stored in a singly linked list where each node represents a message. To achieve this, you need to implement a function that reverses the list. # Task Implement the `reverse_list` function that reverses the given singly linked list. You should implement both the iterative and recursive solutions. # Function Signatures ```python def reverse_list(head: ListNode) -> ListNode: Reverse the singly linked list using iterative approach. :param head: Head of the singly linked list. :return: New head of the reversed singly linked list. def reverse_list_recursive(head: ListNode) -> ListNode: Reverse the singly linked list using recursive approach. :param head: Head of the singly linked list. :return: New head of the reversed singly linked list. ``` # Input Format - `head` is the head node of the singly linked list, where each node is defined as: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` # Output Format - Return the new head of the reversed singly linked list. # Constraints - 0 <= number of nodes in the list <= 10000 - Each node’s value will be an integer. # Example Consider a linked list: ``` 1 -> 2 -> 3 -> 4 ``` After reversal, it should look like: ``` 4 -> 3 -> 2 -> 1 ``` # Note You need to handle edge cases where the list might be empty or consist of just one node. Ensure your solution does not exceed time or space constraints.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head: ListNode) -> ListNode: Reverse the singly linked list using iterative approach. :param head: Head of the singly linked list. :return: New head of the reversed singly linked list. prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev def reverse_list_recursive(head: ListNode) -> ListNode: Reverse the singly linked list using recursive approach. :param head: Head of the singly linked list. :return: New head of the reversed singly linked list. if head is None or head.next is None: return head new_head = reverse_list_recursive(head.next) head.next.next = head head.next = None return new_head"},{"question":"# Matrix Transformations Context You\'re working on an application that processes visual data represented as 2D matrices. To optimize your algorithms, you need to design and implement efficient transformation functions that rotate and reflect the matrices. Task Implement the following functions to transform a given 2D square matrix without creating a new matrix each time (perform transformation in place). 1. **rotate_clockwise_in_place(matrix: List[List[int]]) -> None**: * Rotates the matrix 90 degrees clockwise. 2. **rotate_counterclockwise_in_place(matrix: List[List[int]]) -> None**: * Rotates the matrix 90 degrees counterclockwise. 3. **top_left_invert_in_place(matrix: List[List[int]]) -> None**: * Reflects the matrix along its main diagonal (top-left to bottom-right). 4. **bottom_left_invert_in_place(matrix: List[List[int]]) -> None**: * Reflects the matrix along a diagonal from the bottom-left to top-right. Input and Output Formats * The input is a 2D list of integers representing a square matrix (n x n dimensions), where 1 ≤ n ≤ 100. * The functions do not return anything but should alter the matrix in place. * You should handle any edge cases, including empty matrices or single element matrices. Constraints * Performance requirements: The functions should not use additional O(n^2) space for a new matrix and should aim to complete in O(n^2) time complexity. Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] rotate_clockwise_in_place(matrix) print(matrix) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3], # ] matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] top_left_invert_in_place(matrix) print(matrix) # Output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9], # ] ```","solution":"from typing import List def rotate_clockwise_in_place(matrix: List[List[int]]) -> None: Rotates the matrix 90 degrees clockwise in place. n = len(matrix) # First, transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then, reverse each row for i in range(n): matrix[i].reverse() def rotate_counterclockwise_in_place(matrix: List[List[int]]) -> None: Rotates the matrix 90 degrees counterclockwise in place. n = len(matrix) # First, transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then, reverse each column for j in range(n): for i in range(n // 2): matrix[i][j], matrix[n - 1 - i][j] = matrix[n - 1 - i][j], matrix[i][j] def top_left_invert_in_place(matrix: List[List[int]]) -> None: Reflects the matrix along its main diagonal (top-left to bottom-right) in place. n = len(matrix) for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] def bottom_left_invert_in_place(matrix: List[List[int]]) -> None: Reflects the matrix along a diagonal from the bottom-left to top-right in place. n = len(matrix) for i in range(n): for j in range(n - i - 1): matrix[i][j], matrix[n - j - 1][n - i - 1] = matrix[n - j - 1][n - i - 1], matrix[i][j]"},{"question":"Problem Statement You are given two positive integers, `a` and `b`. Your task is to implement a function that adds these two integers without using the `+` operator. Instead, you need to use bitwise operations to achieve the result. # Function Signature ```python def add_bitwise(a: int, b: int) -> int: pass ``` # Input * `a` and `b`: Two non-negative integers (0 leq a, b leq 10^9). # Output * An integer that is the sum of `a` and `b`. # Constraints * You must not use the `+` operator or any arithmetic operators like `-`, `*`, or `/`. * Only bitwise operations `[&, |, ^, <<, >>]` and control structures like loops can be used. # Performance Requirements * Your function should execute efficiently within the provided constraints, ideally in O(n) time complexity, where `n` is the number of bits required to represent the largest number. # Example Example 1: ```python print(add_bitwise(2, 3)) # Output: 5 ``` Example 2: ```python print(add_bitwise(15, 25)) # Output: 40 ``` # Notes * Ensure that your function handles edge cases like `a = 0` or `b = 0` correctly.","solution":"def add_bitwise(a: int, b: int) -> int: Add two integers using bitwise operations only. while b != 0: carry = a & b # AND operation to find the carry bits a = a ^ b # XOR operation to add without carry b = carry << 1 # shift carry to the left for the next higher bit position return a"},{"question":"# Bit Manipulation Challenge You are required to manipulate the bits of an integer as part of a low-level programming task. You will implement a set of functions to get, set, clear, and update specific bits in an integer. Function Definitions 1. **`get_bit(num: int, i: int) -> bool`**: * **Input**: - `num`: An integer whose bit you want to get. - `i`: The 0-based index of the bit to get (0 for the least significant bit). * **Output**: - Returns `True` if the ith bit of `num` is set (1), otherwise `False`. 2. **`set_bit(num: int, i: int) -> int`**: * **Input**: - `num`: An integer where you want to set a specific bit. - `i`: The 0-based index of the bit to set (0 for the least significant bit). * **Output**: - Returns the integer after setting the ith bit to 1. 3. **`clear_bit(num: int, i: int) -> int`**: * **Input**: - `num`: An integer where you want to clear a specific bit. - `i`: The 0-based index of the bit to clear (0 for the least significant bit). * **Output**: - Returns the integer after clearing the ith bit (setting it to 0). 4. **`update_bit(num: int, i: int, bit: bool) -> int`**: * **Input**: - `num`: An integer where you want to update a specific bit. - `i`: The 0-based index of the bit to update (0 for the least significant bit). - `bit`: The new value to set the ith bit to (either `True` for 1 or `False` for 0). * **Output**: - Returns the integer after updating the ith bit with the `bit` value. Constraints * 0 ≤ `num` ≤ 2^31 - 1 * 0 ≤ `i` < 31 * `bit` can be either `True` or `False`. Implement these functions and ensure they handle edge cases properly. Use these functions to write a function that toggles the ith bit of a given number `num`. **`toggle_bit(num: int, i: int) -> int`**: * **Input**: - `num`: An integer where you want to toggle a specific bit. - `i`: The 0-based index of the bit to toggle (0 for the least significant bit). * **Output**: - Returns the integer after toggling the ith bit. Example ```python assert get_bit(5, 0) == True # 5 is 101 in binary assert get_bit(5, 1) == False # 0th bit is set (1), 1st bit is not set (0) assert set_bit(5, 1) == 7 # 7 is 111 in binary assert clear_bit(5, 0) == 4 # 4 is 100 in binary assert update_bit(5, 1, True) == 7 # 7 is 111 in binary assert update_bit(5, 2, False) == 1 # 1 is 001 in binary assert toggle_bit(5, 0) == 4 # 5 (101) after toggling 0th bit becomes 4 (100) assert toggle_bit(5, 1) == 7 # 5 (101) after toggling 1st bit becomes 7 (111) ```","solution":"def get_bit(num: int, i: int) -> bool: Returns True if the ith bit of num is set (1), otherwise False. return (num & (1 << i)) != 0 def set_bit(num: int, i: int) -> int: Returns the integer after setting the ith bit to 1. return num | (1 << i) def clear_bit(num: int, i: int) -> int: Returns the integer after clearing the ith bit (setting it to 0). return num & ~(1 << i) def update_bit(num: int, i: int, bit: bool) -> int: Returns the integer after updating the ith bit with the bit value. return (num & ~(1 << i)) | ((1 if bit else 0) << i) def toggle_bit(num: int, i: int) -> int: Returns the integer after toggling the ith bit. return num ^ (1 << i)"},{"question":"# Context You are given a task to identify a special subset of numbers within a range. A number `n` is considered special if it can be expressed as the sum of its digits each raised to consecutive powers starting from 1. For example: - 89 is special because (8^1 + 9^2 = 89). - 135 is special because (1^1 + 3^2 + 5^3 = 135). # Task Write a function `special_numbers_in_range(low, high)` that returns a list of such special numbers within the inclusive range from `low` to `high`. # Function Signature ```python def special_numbers_in_range(low: int, high: int) -> list: pass ``` # Input - `low`: An integer, the lower bound of the range (1 ≤ low ≤ high). - `high`: An integer, the upper bound of the range (1 ≤ low ≤ high ≤ 10^6). # Output - A list of integers containing special numbers within the inclusive range [low, high]. # Constraints - You must ensure the function runs efficiently even for large ranges. - The range of `low` and `high` will be provided always such that (1 leq low leq high leq 10^6). # Example ```python assert special_numbers_in_range(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert special_numbers_in_range(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert special_numbers_in_range(80, 150) == [89, 135] ``` # Note Ensure your solution handles edge cases and performance bottlenecks efficiently, considering the given constraints.","solution":"def special_numbers_in_range(low, high): def is_special_number(num): str_num = str(num) return num == sum(int(str_num[i]) ** (i + 1) for i in range(len(str_num))) special_numbers = [] for num in range(low, high + 1): if is_special_number(num): special_numbers.append(num) return special_numbers"},{"question":"# Cycle Sort Challenge You are tasked with implementing a sorting algorithm known as **Cycle Sort**. This algorithm sorts an array by identifying cycles among the elements and rotating them into their correct positions. Objectives: 1. Implement the `cycle_sort` function that receives an array and sorts it in ascending order using the Cycle Sort algorithm. 2. Ensure the solution optimizes for in-place sorting, minimizing memory usage. Function Signature: ```python def cycle_sort(arr: List[int]) -> List[int]: ... ``` Input: - An array `arr` of integers where `1 ≤ len(arr) ≤ 1000`, and each value within the array fits within the bounds of `-10^6 ≤ arr[i] ≤ 10^6`. Output: - The function should return the sorted array. Constraints: - You may not use any built-in sorting functions. - The function should sort the array in place and return it. Example: ```python assert cycle_sort([4, 3, 2, 1]) == [1, 2, 3, 4] assert cycle_sort([1, 3, 9, 8, 2, 7, 5]) == [1, 2, 3, 5, 7, 8, 9] assert cycle_sort([-1, -3, -2, 0, 2, 1]) == [-3, -2, -1, 0, 1, 2] ``` Explanation: - In the first example, the array `[4, 3, 2, 1]` will be sorted by rotating elements within the detected cycles. - In the second example, the array `[1, 3, 9, 8, 2, 7, 5]` sorts to `[1, 2, 3, 5, 7, 8, 9]` by rearranging the elements. - In the third example, negative numbers are handled correctly and sorted to produce `[-3, -2, -1, 0, 1, 2]`. Notes: - Carefully ensure updates to the indices within cycles are handled correctly to prevent errors. - Measure efficiency by confirming the sorting is conducted in-place with O(1) extra space complexity. Good luck, and happy coding!","solution":"def cycle_sort(arr): Sorts an array in place using Cycle Sort algorithm. n = len(arr) writes = 0 for cycle_start in range(0, n - 1): item = arr[cycle_start] pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 if pos == cycle_start: continue while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"# Matrix Multiplication Coding Assessment Objective Write a function `matrix_multiply` that multiplies two given matrices and returns their product. Function Signature ```python def matrix_multiply(multiplicand: list, multiplier: list) -> list: ``` Input * `multiplicand`: A list of lists where each list represents a row of the matrix. * `multiplier`: A list of lists where each list represents a row of the matrix. Output * Returns a list of lists representing the product matrix. Constraints * Each sub-list (representing a row) in `multiplicand` and `multiplier` must have integers only. * The number of columns in `multiplicand` must equal the number of rows in `multiplier`. * Matrices can be empty, which should return an empty matrix. * The dimensions of both matrices will not exceed 100x100. Example ```python multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [5, 6], [7, 8] ] # Expected Output: # [ # [19, 22], # [43, 50] # ] result = matrix_multiply(multiplicand, multiplier) print(result) # Output should be [[19, 22], [43, 50]] ``` Notes * Do not use any external libraries to perform matrix multiplication; write the algorithm from scratch. * Handle edge cases, such as incompatible matrices, by raising an appropriate exception with a clear message.","solution":"def matrix_multiply(multiplicand, multiplier): Multiplies two matrices represented as lists of lists. Args: multiplicand (list): The first matrix operand. multiplier (list): The second matrix operand. Returns: list: The product of the two matrices. # Check if matrices are empty if not multiplicand or not multiplicand[0] or not multiplier or not multiplier[0]: return [] # Number of rows in multiplicand rows_a = len(multiplicand) # Number of columns in multiplicand / number of rows in multiplier cols_a = len(multiplicand[0]) # Number of columns in multiplier cols_b = len(multiplier[0]) # Check if multiplication is possible if cols_a != len(multiplier): raise ValueError(\\"Number of columns in multiplicand must equal number of rows in multiplier.\\") # Initialize the result matrix with zeros result = [[0 for _ in range(cols_b)] for _ in range(rows_a)] # Perform matrix multiplication for i in range(rows_a): for j in range(cols_b): for k in range(cols_a): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"Problem: Advanced FizzBuzz Variations Given a positive integer N, write a function that returns a list containing the numbers from 1 to N. However, there are multiple conditions you need to handle when populating this list: 1. Replace numbers that are multiples of 3 with the string \\"Fizz\\". 2. Replace numbers that are multiples of 5 with the string \\"Buzz\\". 3. Replace numbers that are multiples of both 3 and 5 with the string \\"FizzBuzz\\". 4. Replace numbers that are multiples of 7 with the string \\"Bazz\\". 5. Replace numbers that are multiples of both 3 and 7 with the string \\"FizzBazz\\". 6. Replace numbers that are multiples of both 5 and 7 with the string \\"BuzzBazz\\". 7. Replace numbers that are multiples of 3, 5, and 7 with the string \\"FizzBuzzBazz\\". Function signature: ```python def advanced_fizzbuzz(n: int) -> list: ``` # Parameters: * `n (int)`: The upper limit of the range (inclusive). * 1 ≤ N ≤ 10^5 # Returns: * `list`: A list with integers and strings representing the range 1 to N with replacements as per the rules mentioned above. # Example Input: ```python n = 21 ``` # Example Output: ```python [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', \'Bazz\', 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, \'Bazz\', \'FizzBuzz\', 16, 17, \'Fizz\', 19, \'Buzz\', \'FizzBazz\'] ``` # Constraints & Notes: * Handle typical constraints with efficient conditional checks. * Make sure your solution can handle large values of N efficiently within time and space limits (~1 second per execution for upper limits).","solution":"def advanced_fizzbuzz(n): result = [] for i in range(1, n+1): if i % 3 == 0 and i % 5 == 0 and i % 7 == 0: result.append(\\"FizzBuzzBazz\\") elif i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0 and i % 7 == 0: result.append(\\"FizzBazz\\") elif i % 5 == 0 and i % 7 == 0: result.append(\\"BuzzBazz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") elif i % 7 == 0: result.append(\\"Bazz\\") else: result.append(i) return result"},{"question":"# Context You are working on a machine learning project that involves comparing text documents represented as high-dimensional vectors. One common technique for comparing such vectors is the Cosine Similarity measure. You need to implement a function to compute this for any given pair of vectors. # Task Write a Python function to calculate cosine similarity between two 1D lists of the same length. If the input lists are of different lengths, your function should raise a `ValueError` with an appropriate message. # Requirements * Your function should be called `cosine_similarity`. * Input: two 1D lists of numerical values `vec1` and `vec2`. * Output: a float value representing the cosine similarity measure between the two lists. # Example ```python cosine_similarity([1, 1, 1], [1, 2, -1]) # Output: 0.47140452079103173 ``` # Constraints 1. Both input lists will have a maximum length of 10^6. 2. Elements in the lists are floats or integers ranging from -10^9 to 10^9. # Performance Your solution must be efficient in both time and space complexities, with time complexity O(n) and space complexity O(1).","solution":"import math def cosine_similarity(vec1, vec2): Calculate the cosine similarity between two vectors. Arguments: vec1 -- 1D list of numerical values vec2 -- 1D list of numerical values Returns: A float representing the cosine similarity between vec1 and vec2. Raises: ValueError -- if the input lists are of different lengths if len(vec1) != len(vec2): raise ValueError(\\"Input vectors must be of the same length\\") dot_product = sum(v1 * v2 for v1, v2 in zip(vec1, vec2)) magnitude_vec1 = math.sqrt(sum(v ** 2 for v in vec1)) magnitude_vec2 = math.sqrt(sum(v ** 2 for v in vec2)) if magnitude_vec1 == 0 or magnitude_vec2 == 0: return 0.0 return dot_product / (magnitude_vec1 * magnitude_vec2)"},{"question":"# Question: Manipulation of Sequence of Bits # Context You are tasked with implementing a utility to manipulate a sequence of bits within an array of integers. Each integer represents 32 bits. You need to provide functionalities to get, set, clear, and update specific bits across the integer array. This is useful in scenarios like memory management in low-level system programming or bitwise data encoding. # Task Write a function `manipulate_bits` that supports the following operations on a list of integers: 1. `get_bit(array, index)`: Retrieves the bit at the specified global index across the entire integer array. 2. `set_bit(array, index)`: Sets the bit at the specified index to `1`. 3. `clear_bit(array, index)`: Clears the bit at the specified index to `0`. 4. `update_bit(array, index, bit)`: Updates the bit at the specified index to the provided `bit` (either `0` or `1`). # Function Specification Function: manipulate_bits * **Parameters**: * `array` (List[int]): A list of integers representing the sequence of bits. * `operation` (str): The operation to perform, one of `\\"get\\"`, `\\"set\\"`, `\\"clear\\"`, `\\"update\\"`. * `index` (int): The global index of the bit to manipulate. * `bit` (Optional[int]): The value to update the bit to, either `0` or `1` if the operation is `\\"update\\"`. This parameter is ignored for other operations. * **Returns**: * For `get` operation, the function should return `1` or `0` indicating the value at the specified index. * For `set`, `clear`, `update` operations, nothing should be returned but the array should be modified in place. Constraints * Length of the array (N) is between 1 and 10^4. * Each integer in the array is a signed 32-bit integer. * The index is a non-negative integer that may be as large as `N * 32 - 1`. * For `update` operation, the bit parameter is guaranteed to be `0` or `1`. # Example: ```python array = [0b00000000_00000000_00000000_00000000, 0b00000000_00000000_00000000_00000000] manipulate_bits(array, \\"set\\", 31) # Sets the 31st bit (last bit in the first element). print(array) # Output should be: [2147483648, 0] manipulate_bits(array, \\"get\\", 31) # Returns 1 manipulate_bits(array, \\"clear\\", 31) # Clears the 31st bit. print(array) # Output should be: [0, 0] manipulate_bits(array, \\"update\\", 33, 1) # Updates the 1st bit of the second element to 1. print(array) # Output should be: [0, 2] ``` Implement the `manipulate_bits` function based on the described operations and constraints.","solution":"def manipulate_bits(array, operation, index, bit=None): Manipulates the bits in a list of integers based on the specified operation. Parameters: array (List[int]): A list of integers representing the sequence of bits. operation (str): The operation to perform, one of \\"get\\", \\"set\\", \\"clear\\", \\"update\\". index (int): The global index of the bit to manipulate. bit (Optional[int]): The value to update the bit to, either 0 or 1 if the operation is \\"update\\". Returns: For \\"get\\" operation, the function returns 1 or 0 indicating the value at the specified index. For \\"set\\", \\"clear\\", \\"update\\" operations, nothing is returned but the array is modified in place. array_index = index // 32 bit_index = index % 32 if operation == \\"get\\": return (array[array_index] >> bit_index) & 1 elif operation == \\"set\\": array[array_index] |= (1 << bit_index) elif operation == \\"clear\\": array[array_index] &= ~(1 << bit_index) elif operation == \\"update\\": if bit == 1: array[array_index] |= (1 << bit_index) elif bit == 0: array[array_index] &= ~(1 << bit_index)"},{"question":"You are required to implement a function that sorts an array of integers using the Exchange Sort algorithm. Write a function `exchange_sort(arr)` that takes as input: * `arr`: a list of integers The function should return a new list which is the sorted version of the input list in non-decreasing order. **Constraints**: 1. The length of `arr` (denoted as n) must satisfy (1 leq n leq 1000). 2. The integers in `arr` will range from (-10^6) to (10^6). **Example**: ``` Input: arr = [5, 3, 1, 4, 2] Output: [1, 2, 3, 4, 5] Input: arr = [10, -1, 2, -10, 0] Output: [-10, -1, 0, 2, 10] ``` Make sure your implementation accounts for the following: 1. Handle edge cases such as an already sorted array, an array with all identical elements, or very small arrays. 2. Ensure the function performs correctly and handle inputs within the provided constraint limits. 3. Validate the function to avoid incorrect results and ensure correctness.","solution":"def exchange_sort(arr): Sorts the input list of integers using Exchange Sort algorithm and returns the sorted list. n = len(arr) for i in range(n - 1): for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"# Context You are developing a search engine where you need to implement a feature to find the first occurrence of a query string (needle) within a large body of text (haystack). As part of this, you need to efficiently find if and where the query appears in the text. # Problem Statement Implement a function `find_substring(haystack, needle)` which takes two strings: `haystack` and `needle`. The function should return the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack`. # Function Signature ```python def find_substring(haystack: str, needle: str) -> int: ``` # Input * `haystack` (string): The text where the search is performed. * `needle` (string): The substring to search for in the `haystack`. # Output * (int): The index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not found. # Constraints * `0 <= len(haystack), len(needle) <= 10^4` # Edge Cases * If `needle` is an empty string, then the function should return `0`. * If `needle` is longer than `haystack`, return `-1`. * Consider performance for cases where `haystack` and `needle` are large. # Examples ```python find_substring(\\"hello\\", \\"ll\\") # Output: 2 find_substring(\\"aaaaa\\", \\"bba\\") # Output: -1 find_substring(\\"mississippi\\", \\"issip\\") # Output: 4 find_substring(\\"a\\", \\"a\\") # Output: 0 find_substring(\\"a\\", \\"aa\\") # Output: -1 ``` # Performance Requirements * Ensure the function runs efficiently within the constraints provided. * Aim for a clear and optimized solution, exploring potential enhancements to the naïve string comparison approach provided.","solution":"def find_substring(haystack: str, needle: str) -> int: Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. if not needle: return 0 len_haystack = len(haystack) len_needle = len(needle) if len_needle > len_haystack: return -1 for i in range(len_haystack - len_needle + 1): if haystack[i:i + len_needle] == needle: return i return -1"},{"question":"# Scenario-Based Coding Assessment: Implement Search, Insert and Delete in B-tree Context: You are tasked with implementing a B-tree for an advanced database system. This B-tree needs to efficiently support search, insertion, and deletion operations while ensuring balance. Your implementation must adhere to the key principles of a B-tree, including maintaining the minimum and maximum number of keys per node, handling node splitting and merging appropriately, and maintaining balanced height. Your task involves: 1. Implementing the `insert_key` method to ensure the tree remains balanced after insertion. 2. Implementing the `remove_key` method to properly remove keys while maintaining the tree’s balance. 3. Implementing the `find` method to search for keys efficiently. 4. Ensuring all changes preserve the B-tree properties. Implement the following methods: ```python class Node: Class of Node def __init__(self): self.keys = [] self.children = [] @property def is_leaf(self): Return if it is a leaf return len(self.children) == 0 class BTree: Class of BTree def __init__(self, t_val=2): self.min_numbers_of_keys = t_val - 1 self.max_number_of_keys = 2 * t_val - 1 self.root = Node() def insert_key(self, key): Insert a key into the B-tree # Your implementation here def _insert_to_nonfull_node(self, node: Node, key): Helper function to insert key into a non-full node # Your implementation here def find(self, key) -> bool: Search for a key in the B-tree # Your implementation here def remove_key(self, key): Remove a key from the B-tree # Your implementation here def _remove_key(self, node: Node, key) -> bool: Helper function to remove key from a node # Your implementation here ``` Requirements: 1. **Insert Key**: * Maintain B-tree properties after insertion. * Handle node splitting. 2. **Remove Key**: * Maintain B-tree properties after deletion. * Handle node merging and balancing. 3. **Find Key**: * Efficiently search for keys and return `True` if found, `False` otherwise. Constraints: * The tree degree `t_val` will always be 2 or more. * The keys are unique integers. * Implement the methods without altering the node class properties. Performance Expectation: * Your solution should maintain O(log n) complexity for insert, delete, and search operations. Example: ```python btree = BTree(t_val=3) btree.insert_key(10) btree.insert_key(20) assert btree.find(10) == True assert btree.find(15) == False btree.remove_key(10) assert btree.find(10) == False ``` Ensure your implementation passes this test case along with other edge cases covered in the analysis above.","solution":"class Node: Class of Node def __init__(self): self.keys = [] self.children = [] @property def is_leaf(self): Return if it is a leaf return len(self.children) == 0 class BTree: Class of BTree def __init__(self, t_val=2): self.min_numbers_of_keys = t_val - 1 self.max_number_of_keys = 2 * t_val - 1 self.root = Node() self.t = t_val def insert_key(self, key): Insert a key into the B-tree root = self.root if len(root.keys) == self.max_number_of_keys: # Root is full, split it new_root = Node() new_root.children.append(self.root) self._split_child(new_root, 0) self.root = new_root self._insert_to_nonfull_node(self.root, key) def _insert_to_nonfull_node(self, node: Node, key): if node.is_leaf: node.keys.append(key) node.keys.sort() else: # Find the child that needs to be inserted into i = len(node.keys) - 1 while i >= 0 and key < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == self.max_number_of_keys: self._split_child(node, i) if key > node.keys[i]: i += 1 self._insert_to_nonfull_node(node.children[i], key) def _split_child(self, parent: Node, index: int): t = self.t node = parent.children[index] new_node = Node() parent.keys.insert(index, node.keys[t-1]) parent.children.insert(index+1, new_node) new_node.keys = node.keys[t:] node.keys = node.keys[:t-1] if not node.is_leaf: new_node.children = node.children[t:] node.children = node.children[:t] def find(self, key) -> bool: Search for a key in the B-tree return self._find_in_node(self.root, key) def _find_in_node(self, node: Node, key) -> bool: i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if i < len(node.keys) and key == node.keys[i]: return True elif node.is_leaf: return False else: return self._find_in_node(node.children[i], key) def remove_key(self, key): Remove a key from the B-tree self._remove_key(self.root, key) def _remove_key(self, node: Node, key: int): t = self.t if key in node.keys: if node.is_leaf: node.keys.remove(key) else: index = node.keys.index(key) if len(node.children[index].keys) >= t: predecessor = self._get_predecessor(node.children[index]) node.keys[index] = predecessor self._remove_key(node.children[index], predecessor) elif len(node.children[index+1].keys) >= t: successor = self._get_successor(node.children[index+1]) node.keys[index] = successor self._remove_key(node.children[index+1], successor) else: self._merge_nodes(node, index) self._remove_key(node.children[index], key) else: i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if not node.is_leaf: if len(node.children[i].keys) < t: if i > 0 and len(node.children[i-1].keys) >= t: self._borrow_from_prev(node, i) elif i < len(node.keys) and len(node.children[i+1].keys) >= t: self._borrow_from_next(node, i) else: if i < len(node.keys): self._merge_nodes(node, i) else: self._merge_nodes(node, i-1) self._remove_key(node.children[i], key) def _borrow_from_prev(self, node: Node, index: int): child = node.children[index] sibling = node.children[index-1] child.keys.insert(0, node.keys[index-1]) if not child.is_leaf: child.children.insert(0, sibling.children.pop()) node.keys[index-1] = sibling.keys.pop() def _borrow_from_next(self, node: Node, index: int): child = node.children[index] sibling = node.children[index+1] child.keys.append(node.keys[index]) if not child.is_leaf: child.children.append(sibling.children.pop(0)) node.keys[index] = sibling.keys.pop(0) def _merge_nodes(self, node: Node, index: int): child = node.children[index] sibling = node.children.pop(index+1) child.keys.append(node.keys.pop(index)) child.keys.extend(sibling.keys) if not child.is_leaf: child.children.extend(sibling.children) def _get_predecessor(self, node: Node): current = node while not current.is_leaf: current = current.children[-1] return current.keys[-1] def _get_successor(self, node: Node): current = node while not current.is_leaf: current = current.children[0] return current.keys[0]"},{"question":"# Question: Implementation and Testing of RandomizedSet Given the following operations and the provided method descriptions, implement the `RandomizedSet` class: * `RandomizedSet`: Initializes the data structure. * `insert(int val) -> bool`: Inserts the item `val` into the set if it\'s not already present. Returns `True` if the item was successfully inserted, `False` otherwise. * `remove(int val) -> bool`: Removes the item `val` if it is present in the set. Returns `True` if the item was successfully removed, `False` otherwise. * `get_random() -> int`: Returns a random element from the current set of elements. Each element must have the same probability of being returned. Ensure to maintain an average time complexity of (O(1)) for all operations. # Constraints * Values to be inserted will fit within the integer range. * The operations will be performed in no particular order. # Example Execution Here\'s an example to guide you on expected behavior: ```python if __name__ == \\"__main__\\": rs = RandomizedSet() print(\\"insert 1: \\", rs.insert(1)) # Expected output: True print(\\"insert 2: \\", rs.insert(2)) # Expected output: True print(\\"insert 3: \\", rs.insert(3)) # Expected output: True print(\\"insert 4: \\", rs.insert(4)) # Expected output: True print(\\"remove 3: \\", rs.remove(3)) # Expected output: True print(\\"remove 3: \\", rs.remove(3)) # Expected output: False print(\\"remove 1: \\", rs.remove(1)) # Expected output: True print(\\"random: \\", rs.get_random()) # Expected output: 2 or 4 print(\\"random: \\", rs.get_random()) # Expected output: 2 or 4 print(\\"random: \\", rs.get_random()) # Expected output: 2 or 4 print(\\"random: \\", rs.get_random()) # Expected output: 2 or 4 ``` # Notes 1. Ensure your implementation is correct and handles all edge cases such as inserting duplicates or removing non-existent elements. 2. You can use Python\'s `random` module to help with `get_random`.","solution":"import random class RandomizedSet: def __init__(self): self.data_map = {} self.data_list = [] def insert(self, val: int) -> bool: if val in self.data_map: return False self.data_map[val] = len(self.data_list) self.data_list.append(val) return True def remove(self, val: int) -> bool: if val not in self.data_map: return False index = self.data_map[val] last_element = self.data_list[-1] self.data_list[index] = last_element self.data_map[last_element] = index self.data_list.pop() del self.data_map[val] return True def get_random(self) -> int: return random.choice(self.data_list)"},{"question":"# Longest Common Prefix - Advanced Implementation **Context**: You are given an array of strings and need to find the longest common prefix (LCP) amongst these strings. If no common prefix exists, return an empty string. **Objective**: Implement an efficient function to solve this problem using a trie data structure, which could improve performance by organizing strings in a prefix tree for efficient comparison. **Requirements**: 1. Implement a trie to insert all strings and determine the longest common prefix. 2. Ensure the solution handles various edge cases, including empty input, single string input, and input with no common prefix. **Function Signature**: ```python def longest_common_prefix_trie(strs: List[str]) -> str: pass ``` **Input**: * `strs` - A list of strings (0 <= len(strs) <= 200, 0 <= len(str) <= 200). **Output**: * Return the longest common prefix string. **Constraints**: - All strings consist of only lowercase English letters. **Performance Requirements**: - Efficient time complexity, ideally better than O(S), where S is the sum of all characters in all strings. - Manageable space complexity, utilizing a trie structure optimally. **Example**: ```python # Example 1 Input: [\\"flower\\",\\"flow\\",\\"flight\\"] Output: \\"fl\\" # Example 2 Input: [\\"dog\\",\\"racecar\\",\\"car\\"] Output: \\"\\" Explanation: There is no common prefix among the input strings. # Example 3 Input: [] Output: \\"\\" Explanation: The input list is empty. ``` **Hints**: - Consider how a trie can help in combining common prefixes and make comparisons efficient. - Handle edge cases appropriately, especially when managing an entirely empty input or single element arrays. Good Luck!","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def longest_common_prefix(self): prefix = [] node = self.root while node and len(node.children) == 1 and not node.is_end_of_word: char, next_node = next(iter(node.children.items())) prefix.append(char) node = next_node return \'\'.join(prefix) def longest_common_prefix_trie(strs: List[str]) -> str: if not strs: return \\"\\" trie = Trie() for word in strs: trie.insert(word) return trie.longest_common_prefix()"},{"question":"# Comb Sort Implementation and Analysis Problem Statement You are given a list of integers that needs to be sorted in ascending order using the comb sort algorithm. Implement the `comb_sort` function as specified below. Function Signature ```python def comb_sort(arr: list[int]) -> list[int]: pass ``` Input * A list of integers `arr` with 0 <= len(arr) <= 10^5. * The integers in `arr` may range from -10^9 to 10^9. Output * The function should return a new list of integers sorted in ascending order. Constraints * The function should run efficiently for lists up to the size of 10^5. * Your implementation should avoid any additional data structures with size proportional to the input list size. Example ```python # Example 1 print(comb_sort([9, 7, 3, 1, 2, 8])) # Output: [1, 2, 3, 7, 8, 9] # Example 2 print(comb_sort([5, 1, 4, 2, 8])) # Output: [1, 2, 4, 5, 8] # Example 3 print(comb_sort([0])) # Output: [0] # Example 4 print(comb_sort([])) # Output: [] # Example 5 print(comb_sort([5, 5, 5, 5])) # Output: [5, 5, 5, 5] ``` Additional Notes * Pay attention to the implementation details such as reducing the gap size correctly and ensuring that the sorting completes. * Any improvement in the gap sequence can be documented alongside the function, if you choose to implement it for potential performance gains.","solution":"def comb_sort(arr: list[int]) -> list[int]: Sorts a list of integers using the comb sort algorithm. def get_next_gap(gap): # Shrink gap by shrink factor of 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Factor Combination Generation Challenge Scenario You have been hired by a mathematical software company to improve their number-theory module. An essential function they need is capable of breaking down a number into all possible combinations of its factors greater than 1. The function should adhere to the requirement that factors must be greater than 1 and less than the number ( n ). Objective Implement a function `get_factor_combinations(n: int) -> List[List[int]]` that, given a positive integer ( n ), returns a list of all unique combinations of its factors. Input Format - An integer ( n ): Output Format - A list of lists, where each inner list represents a combination of factors of ( n ). Constraints - ( n ) is a positive integer. - The factors in each combination should be greater than 1 and less than ( n ). Examples *Example 1*: ```python Input: 1 Output: [] Explanation: 1 does not have any valid factor combinations greater than 1. ``` *Example 2*: ```python Input: 37 Output: [] Explanation: 37 is a prime number and doesn\'t have any valid factor combinations other than 1 and 37. ``` *Example 3*: ```python Input: 12 Output: [[2, 6], [2, 2, 3], [3, 4]] Explanation: The factor combinations of 12 are (2 * 6), (2 * 2 * 3), and (3 * 4). ``` *Example 4*: ```python Input: 32 Output: [[2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8]] Explanation: The factor combinations of 32 are (2 * 16), (2 * 2 * 8), (2 * 2 * 2 * 4), (2 * 2 * 2 * 2 * 2), (2 * 4 * 4), and (4 * 8). ``` Function Signature ```python def get_factor_combinations(n: int) -> List[List[int]]: # Your code here ``` Notes - Edge cases must be handled appropriately. - Ensure the function works efficiently for numbers up to around ( 10^6 ).","solution":"from typing import List def get_factor_combinations(n: int) -> List[List[int]]: def backtrack(start, path, remain): if remain == 1 and len(path) > 1: res.append(path[:]) return for i in range(start, remain + 1): if remain % i == 0: path.append(i) backtrack(i, path, remain // i) path.pop() res = [] backtrack(2, [], n) return res"},{"question":"# Problem: Digit Array Increment Context You are developing a function to increment a large number by 1. The number is represented as an array of digits, where the most significant digit is at the beginning of the list. This function is essential in scenarios such as precision arithmetic, simulation iterations or counts, and specific cryptographic applications where numbers exceed typical data type limits. Task Implement a function `increment_digits(digits)` which takes a list of non-negative integers (0-9) representing each digit of a number and increments the number by one. The return should be a new list of digits. Input * `digits`: A list of integers (0 <= digit <= 9) representing the digits of a non-negative integer. For example, the number 123 is represented as [1, 2, 3]. Output * A list of integers showing the incremented value. Constraints * You may assume that the list `digits` is non-null and contains at least one element. * The function should handle edge cases like leading/trailing zeros appropriately. * Aim for O(n) time complexity where n is the length of the input list. Example ```python assert increment_digits([1, 2, 3]) == [1, 2, 4] assert increment_digits([9, 9, 9]) == [1, 0, 0, 0] assert increment_digits([0]) == [1] assert increment_digits([9]) == [1, 0] ``` Please write the function `increment_digits(digits)` to solve the problem.","solution":"def increment_digits(digits): Increments a number represented by a list of digits by one. :param digits: List of digits representing the number. :return: List of digits representing the incremented number. n = len(digits) # Traverse the list from the end to the beginning for i in range(n - 1, -1, -1): if digits[i] < 9: # If the digit is less than 9, increment it by 1 and return the list digits[i] += 1 return digits else: # If the digit is 9, set it to 0 digits[i] = 0 # If all the digits were 9, we need an extra digit at the beginning return [1] + digits"},{"question":"# Rotated String Checker You are given two strings, `s1` and `s2`, and your task is to determine if `s2` is a rotated version of `s1`. A string is considered a rotated version of another if it can be obtained by performing a series of cyclic shifts. Input: * Two strings, `s1` and `s2`. Output: * A boolean value indicating whether `s2` is a rotated version of `s1`. Constraints: * The length of the strings will be between 0 and 10^5. * The characters in the strings are limited to lowercase English letters. Examples: 1. `is_rotated(\\"hello\\", \\"llohe\\")` should return `True`. 2. `is_rotated(\\"hello\\", \\"helol\\")` should return `False`. 3. `is_rotated(\\"\\", \\"\\")` should return `True`. 4. `is_rotated(\\"abcde\\", \\"cdeab\\")` should return `True`. 5. `is_rotated(\\"abcde\\", \\"abced\\")` should return `False`. Performance Requirements: * Your solution must operate in linear time, i.e., O(N), where N is the length of the string. * You should avoid using extra space exceeding the constraints. Scenario: Imagine you are coding the backend logic for a text-based game that involves circular phrase matching. To validate user inputs, you need to ensure that a given phrase is a valid rotation of another base phrase stored in your database. Implement a function that efficiently performs this check. Signature: ```python def is_rotated(s1: str, s2: str) -> bool: pass ```","solution":"def is_rotated(s1: str, s2: str) -> bool: Check if s2 is a rotated version of s1. if len(s1) != len(s2): return False return s2 in (s1 + s1)"},{"question":"Scenario You are developing software for a newer version of a classic mobile phone that uses a dial pad to type text messages. Each digit key on the phone\'s dial pad corresponds to a set of characters as follows: ``` 2: \\"abc\\" 3: \\"def\\" 4: \\"ghi\\" 5: \\"jkl\\" 6: \\"mno\\" 7: \\"pqrs\\" 8: \\"tuv\\" 9: \\"wxyz\\" ``` Problem Statement Write a program that takes a string of digits as input and returns all possible letter combinations that the number could represent. Each digit will correspond to a set of characters as given above, similar to the layout on old mobile phones. Function Signature ```python def letter_combinations(digits: str) -> List[str]: ``` Input - `digits`: A string composed of digits ranging from \'2\' to \'9\' (inclusive). Output - Returns a list of all possible letter combinations represented by the input digit string. The list should include all combinations in lexicographical order. Constraints - The input string can have a length between 0 and 9. - The input string will not contain digits outside \'2\'-\'9\'. Examples 1. Input: `\\"23\\"` Output: `[\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"]` 2. Input: `\\"\\"` Output: `[]` 3. Input: `\\"7\\"` Output: `[\\"p\\", \\"q\\", \\"r\\", \\"s\\"]` Additional Requirements - Your solution should handle the maximum constraints efficiently. - You should ensure proper handling of input edge cases. Good luck!","solution":"from typing import List def letter_combinations(digits: str) -> List[str]: if not digits: return [] phone = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(combination, next_digits): # If there are no more digits to check if len(next_digits) == 0: # The combination is complete, add it to results output.append(combination) # If there are still digits to check else: # Iterate over all letters which map the next available digit for letter in phone[next_digits[0]]: # Append the current letter to the combination and proceed # to the next digits backtrack(combination + letter, next_digits[1:]) output = [] backtrack(\\"\\", digits) return output"},{"question":"# Resizable Hash Table Implementation & Analysis As a software engineer, you have been tasked with implementing a Resizable Hash Table. Your implementation should efficiently handle key-value insertions, deletions, and retrievals. The table should dynamically resize when necessary to maintain optimal performance. **Task**: 1. Implement the complete `ResizableHashTable` class based on the provided `HashTable` class. 2. Ensure that the table resizes when it reaches a load factor of 0.75. 3. Provide the hash function, linear probing mechanism, and resizing logic. 4. Write a function that calculates the current load factor of the table. **Requirements**: - Implement the `ResizabeHashTable` class with the following methods: `put`, `get`, `del_`, and `load_factor`. - Ensure the table resizes correctly and maintains efficiency during operations. **Input/Output & Constraints**: - `put(key: int, value: Any) -> None`: Inserts the key-value pair into the table. If the key already exists, update its value. - `get(key: int) -> Any`: Retrieves the value for the given key or returns `None` if key is not found. - `del_(key: int) -> None`: Deletes the key-value pair from the table if it exists. - `load_factor() -> float`: Returns the current load factor of the table. - Keys are assumed to be integers. - Key range is not specified, but the table should handle typical integer ranges efficiently. **Example**: ```python ht = ResizableHashTable() ht.put(1, \\"value1\\") ht.put(2, \\"value2\\") assert ht.get(1) == \\"value1\\" assert ht.get(2) == \\"value2\\" ht.del_(1) assert ht.get(1) == None assert ht.load_factor() == 1 / 11 # if initial size is 11 ``` **Additional Testing**: - Validate the resizing process by inserting enough elements to trigger a resize. - Check for proper functioning after deletion to ensure no \\"tombstones\\" disrupt operations. You can use the `HashTable` class provided as a base but include necessary modifications to handle resizing efficiently.","solution":"class ResizableHashTable: def __init__(self, initial_capacity=8): self.capacity = initial_capacity self.size = 0 self.table = [None] * self.capacity def _hash(self, key): return key % self.capacity def _resize(self): old_table = self.table self.capacity *= 2 self.table = [None] * self.capacity self.size = 0 for entry in old_table: if entry is not None: self.put(entry[0], entry[1]) def put(self, key, value): if self.load_factor() >= 0.75: self._resize() index = self._hash(key) original_index = index first_loop = True while self.table[index] is not None and (first_loop or index != original_index): if self.table[index][0] == key: self.table[index] = (key, value) return index = (index + 1) % self.capacity first_loop = False self.table[index] = (key, value) self.size += 1 def get(self, key): index = self._hash(key) original_index = index first_loop = True while self.table[index] is not None and (first_loop or index != original_index): if self.table[index][0] == key: return self.table[index][1] index = (index + 1) % self.capacity first_loop = False return None def del_(self, key): index = self._hash(key) original_index = index first_loop = True while self.table[index] is not None and (first_loop or index != original_index): if self.table[index][0] == key: self.table[index] = None self.size -= 1 return index = (index + 1) % self.capacity first_loop = False def load_factor(self): return self.size / self.capacity"},{"question":"# Question: Reverse the Order of Characters in Each Word * **Scenario**: Write a function that takes a string as input and reverses the order of characters in each word. The order of the words in the string should remain the same. * **Function Signature**: `def reverse_each_word(string: str) -> str:` * **Input**: A string `string` consisting of words separated by whitespace. * **Output**: A string where each word has its characters reversed but the order of words remains unchanged. * **Performance Requirement**: The function should run in O(n) time complexity where n is the total number of characters in the input string. Example: ```python # Input string = \\"I am keon kim and I like pizza\\" # Output result = \\"I ma noek mik dna I ekil azzip\\" print(result) ``` Constraints: 1. The input string may have leading or trailing whitespace. 2. Words in the input string are separated by one or more spaces. 3. Punctuation marks are part of the words and should be reversed with the characters of the words. Additional Edge Cases: 1. Input string is empty: Should return an empty string. 2. Input string is all whitespace: Should return an empty string. Implement the function `reverse_each_word` such that it handles these scenarios efficiently and correctly.","solution":"def reverse_each_word(string: str) -> str: This function takes a string as input and reverses the order of characters in each word. The order of the words in the string remains the same. # Strip leading and trailing whitespace and split the string by one or more spaces words = string.strip().split() # Reverse each word and join them back together with a single space reversed_words = [word[::-1] for word in words] return \' \'.join(reversed_words)"},{"question":"# Question: Enhanced Pathfinding Algorithm in Graphs You are given a directed graph represented as an adjacency list, where each node points to a list of its neighbors. Your task is to implement an optimized function to find all shortest paths from a start node to an end node. Function Signature ```python def find_all_shortest_paths(graph: Dict[str, List[str]], start: str, end: str) -> List[List[str]]: ``` Input - `graph` (Dict[str, List[str]]): A dictionary where keys are node labels (strings) and values are lists of node labels (strings) representing directed edges. - `start` (str): The starting node label. - `end` (str): The ending node label. Output - A list of lists, where each list represents a shortest path (by node labels) from `start` to `end`. Constraints - Each node has a unique label. - There may be more than one shortest path of the same length. - The graph is directed (edges go one way). - The graph may contain cycles, but the shortest paths will never include cycles. Performance Requirements - Implement using an efficient approach to handle larger graphs. Aim for a time complexity of O(V + E). Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [] } assert find_all_shortest_paths(graph, \'A\', \'D\') == [[\'A\', \'B\', \'D\'], [\'A\', \'C\', \'D\']] ``` Approach * Utilize Breadth-First Search (BFS) to find the shortest path length from `start` to `end`. * Traverse the graph using BFS to build paths, keeping track of all paths that match the shortest path length. Write the function `find_all_shortest_paths` that adheres to the given constraints and example.","solution":"from collections import deque, defaultdict from typing import Dict, List def find_all_shortest_paths(graph: Dict[str, List[str]], start: str, end: str) -> List[List[str]]: # Helper function to reconstruct paths from parent mapping def build_paths(node, path, parents, all_paths): if node == start: all_paths.append(path[::-1]) return for parent in parents[node]: build_paths(parent, path + [parent], parents, all_paths) queue = deque([start]) parents = defaultdict(list) visited = {start: 0} minimum_length = float(\'inf\') paths = [] while queue: node = queue.popleft() current_distance = visited[node] if node == end and current_distance <= minimum_length: minimum_length = current_distance build_paths(node, [end], parents, paths) if current_distance >= minimum_length: continue for neighbor in graph.get(node, []): if neighbor not in visited or visited[neighbor] > current_distance + 1: visited[neighbor] = current_distance + 1 parents[neighbor].append(node) queue.append(neighbor) elif visited[neighbor] == current_distance + 1: parents[neighbor].append(node) return paths"},{"question":"Scenario You are working on securing a new cryptographic algorithm and need to compute the number of coprime integers for various integer values. One practical approach to achieve this involves using Euler\'s Totient Function. Task Implement a function `compute_totients_up_to(M)` which generates a list containing the totient values for all integers from 1 to M (inclusive). The function should use the principles of Euler\'s Totient Function algorithm. Function Signature ```python def compute_totients_up_to(M: int) -> List[int]: pass ``` Input: - **M (int)**: The upper limit integer (1 ≤ M ≤ 10^6). Output: - A **list of integers** where the i-th index of the list contains the value of ϕ(i+1). Examples: 1. **Input**: 5 **Output**: [1, 1, 2, 2, 4] *Explanation*: - ϕ(1) = 1 - ϕ(2) = 1 - ϕ(3) = 2 - ϕ(4) = 2 - ϕ(5) = 4 2. **Input**: 10 **Output**: [1, 1, 2, 2, 4, 2, 6, 4, 6, 4] **Constraints**: - Compute totients for all 1 <= i <= M efficiently. **Hint**: - Precomputation using sieve-like methods could be useful to achieve an efficient implementation.","solution":"from typing import List def compute_totients_up_to(M: int) -> List[int]: Computes the values of Euler\'s Totient function φ(n) for all integers from 1 to M. :param M: The upper limit integer (1 ≤ M ≤ 10^6). :return: A list of integers where the i-th index contains the value of φ(i+1). # Initialize a list of size M+1 to store totient values totients = list(range(M + 1)) # Use a sieve-like approach to compute the totient values for i in range(2, M + 1): if totients[i] == i: # i is a prime for j in range(i, M + 1, i): totients[j] *= (i - 1) totients[j] //= i # The problem requires the values from φ(1) to φ(M) return totients[1:]"},{"question":"**Objective**: Demonstrate your understanding of heap-based sorting algorithms by implementing a custom sorting function using a max heap. # Problem Description: Given an unsorted array of integers, your task is to implement a function that sorts the array in ascending order using the max heap sort algorithm. # Function Signature: ```python def custom_max_heap_sort(arr: List[int]) -> List[int]: ``` # Input: - `arr`: A list of integers (`1 <= len(arr) <= 10^5` and `-10^9 <= arr[i] <= 10^9`) # Output: - Returns a sorted list of integers in ascending order. # Constraints: - The array length is at most 100,000. - Each integer in the array lies between -1 billion and 1 billion. # Performance Requirements: - Your implementation must have a time complexity of O(n log n). - Space complexity should be O(1), meaning the sorting must be done in place without using additional space. # Examples: ```python # Example 1: # Input arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] # Output # [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] # Example 2: # Input arr = [10, 20, 15, 30, 40] # Output # [10, 15, 20, 30, 40] # Example 3: # Input arr = [5, 5, 5, 5, 5] # Output # [5, 5, 5, 5, 5] ``` # Implementation Note: Ensure that your function performs the necessary heap operations by following the principles of the max heap sort algorithm. You can define helper functions if necessary to manage heapification.","solution":"def custom_max_heap_sort(arr): Sorts an array in ascending order using the max heap sort algorithm. Args: arr (list): List of integers to sort. Returns: list: Sorted list of integers. # Helper function to heapify a subtree rooted at index i def heapify(n, i): largest = i # Initialize largest as root left = 2 * i + 1 # left = 2*i + 1 right = 2 * i + 2 # right = 2*i + 2 # See if left child of root exists and is greater than root if left < n and arr[i] < arr[left]: largest = left # See if right child of root exists and is greater than root if right < n and arr[largest] < arr[right]: largest = right # Change root, if needed if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # swap # Heapify the root heapify(n, largest) n = len(arr) # Build a maxheap for i in range(n // 2 - 1, -1, -1): heapify(n, i) # One by one extract elements for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap heapify(i, 0) return arr"},{"question":"# Question Context You have been tasked to implement a basic Binary Search Tree (BST) with insert, search, and delete functionalities. Problem Write a Python class `BinarySearchTree` that: 1. Adds a value to the BST using the `insert(val)` method. 2. Searches for a value in the BST using the `search(val)` method which returns `True` if the value is found and `False` otherwise. 3. Deletes a value from the BST using the `delete(val)` method. 4. Performs an in-order traversal and returns the elements as a list using `in_order_traversal()` method to verify the tree\'s order. Input and Output **Input Format**: - The `insert` method takes an integer, `val`, to be inserted. - The `search` method takes an integer, `val`, to be searched in the tree. - The `delete` method takes an integer, `val`, to be deleted from the tree. **Output Format**: - The `search` method returns a boolean value (`True` or `False`). - The `in_order_traversal` method returns a list of integers representing the in-order traversal of the BST. Constraints - Input values for methods will be integers. - Duplicate values should not be added to the tree. - The `delete` method should handle cases where the node to be deleted has zero, one, or two children. Example ```python tree = BinarySearchTree() tree.insert(50) tree.insert(30) tree.insert(70) tree.insert(20) tree.insert(40) tree.insert(60) tree.insert(80) # In-order Traversal print(tree.in_order_traversal()) # Output: [20, 30, 40, 50, 60, 70, 80] # Search for values print(tree.search(60)) # Output: True print(tree.search(25)) # Output: False # Deleting a value tree.delete(40) print(tree.in_order_traversal()) # Output: [20, 30, 50, 60, 70, 80] # Delete the root node tree.delete(50) print(tree.in_order_traversal()) # Output: [20, 30, 60, 70, 80] ```","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) elif key > root.val: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) # if key is equal to root.val, do not insert the duplicate. def search(self, key): return self._search(self.root, key) def _search(self, root, key): if root is None or root.val == key: return root is not None if key < root.val: return self._search(root.left, key) return self._search(root.right, key) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, root, key): if root is None: return root if key < root.val: root.left = self._delete(root.left, key) elif key > root.val: root.right = self._delete(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left temp = self._min_value_node(root.right) root.val = temp.val root.right = self._delete(root.right, temp.val) return root def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def in_order_traversal(self): res = [] self._in_order_traversal(self.root, res) return res def _in_order_traversal(self, root, res): if root is not None: self._in_order_traversal(root.left, res) res.append(root.val) self._in_order_traversal(root.right, res)"},{"question":"You are tasked with designing a function to clean up and normalize URLs by removing duplicate query string parameters and specified unwanted parameters. Your implementation should accurately handle URLs with various complexities, including those with special characters and encoded entities. # Function Specification Write a function called `normalize_url`: Input 1. **url** (str): The URL string to be normalized. 2. **params_to_strip** (list of str, optional): A list of query string parameters to remove. Defaults to an empty list. Output - **normalized_url** (str): The URL with duplicate query string parameters removed and any specified parameters stripped. # Requirements - The function must ensure no duplicate query string parameters exist. - The function must strip any query string parameters provided in the `params_to_strip` list. - Keep the first occurrence of a parameter when a parameter is duplicated. - If no query string is present, return the original URL. - Ignore the order of query parameters during comparison. # Example ```python normalize_url(\'www.example.com?a=1&b=2&a=2\', [\'b\']) # Returns \'www.example.com?a=1\' normalize_url(\'www.example.com?a=1&b=2&a=2\') # Returns \'www.example.com?a=1&b=2\' normalize_url(\'www.example.com\') # Returns \'www.example.com\' normalize_url(\'www.example.com?a=1&b=2\', [\'a\']) # Returns \'www.example.com?b=2\' ``` # Constraints - URL strings will have a maximum length of 1024 characters. - params_to_strip list will have at most 50 parameters. - Maintain the order of first occurrence for duplicate parameters. - Handle URL encoding and special characters correctly. # Hints - Consider using dictionaries to handle query string parameters. - Use Python\'s built-in libraries for URL parsing and reconstruction to ensure robustness.","solution":"from urllib.parse import urlparse, parse_qsl, urlencode, urlunparse def normalize_url(url, params_to_strip=None): Normalizes the URL by removing duplicate query string parameters and specified unwanted parameters. Parameters: - url (str): The URL string to be normalized. - params_to_strip (list of str, optional): A list of query string parameters to remove. Defaults to an empty list. Returns: - normalized_url (str): The URL with duplicate query string parameters removed and any specified parameters stripped. if params_to_strip is None: params_to_strip = [] # Parse the URL into components parsed_url = urlparse(url) # Parse query parameters and clean them query_params = parse_qsl(parsed_url.query, keep_blank_values=True) # Dictionary to collect the first occurrence of each parameter filtered_params = {} for key, value in query_params: if key not in filtered_params: filtered_params[key] = value # Remove unwanted parameters for param in params_to_strip: if param in filtered_params: del filtered_params[param] # Reconstruct the query string normalized_query = urlencode(filtered_params, doseq=True) # Rebuild the URL with the normalized query string normalized_url = urlunparse(( parsed_url.scheme, parsed_url.netloc, parsed_url.path, parsed_url.params, normalized_query, parsed_url.fragment )) return normalized_url"},{"question":"# Problem: Absolute File Path Resolver You have been tasked with creating a robust function that resolves a given file path to its full absolute path. This functionality is often used in file handling tasks such as ensuring that file operations work consistently regardless of how paths are provided (relative or absolute). Task: Write a function `resolve_file_path(path: str) -> str` that takes a string `path` representing a file path and returns its full absolute path. Requirements: 1. If the path contains `~`, it should be expanded to the user’s home directory. 2. The path should be converted to an absolute path. 3. Input validation: - Raise a `ValueError` if the input is not a string or is an empty string. - Raise a `FileNotFoundError` if the resolved path does not correspond to an existing file or directory. Input: - `path` (str): A file path which could be relative or absolute. Output: - (str): The full absolute path. Constraints: Assume the home directory can be accessed and expanded correctly. Example: ```python resolve_file_path(\'~/Documents/file.txt\') # Returns: \'/home/username/Documents/file.txt\' resolve_file_path(\'some/relative/path\') # Returns: \'full_absolute_path_to_current_directory/some/relative/path\' resolve_file_path(\'/absolute/path\') # Returns: \'/absolute/path\' ``` Performance: Handle typical file path lengths efficiently with O(N) time complexity for valid input paths, where N is the length of the input string. # Additional Notes: Ensure that your function is cross-platform, working consistently on Windows, Linux, and MacOS.","solution":"import os def resolve_file_path(path: str) -> str: Resolves a given file path to its full absolute path. Parameters: path (str): A string representing a file path. Returns: str: The full absolute path. Raises: ValueError: If the input is not a string or is an empty string. FileNotFoundError: If the resolved path does not correspond to an existing file or directory. if not isinstance(path, str) or not path: raise ValueError(\\"The input must be a non-empty string\\") # Expand the `~` to the user\'s home directory expanded_path = os.path.expanduser(path) # Convert the path to an absolute path absolute_path = os.path.abspath(expanded_path) # Check if the path exists if not os.path.exists(absolute_path): raise FileNotFoundError(f\\"The resolved path \'{absolute_path}\' does not exist\\") return absolute_path"},{"question":"# Dijkstra\'s Algorithm for Graphs with Negative Weights You are given a directed graph with potentially negative edge weights. While Dijkstra\'s algorithm does not handle negative weights, it can still be applied if we first preprocess the graph to convert it into a form where Dijkstra\'s can be applied correctly. # Task Write a function `shortest_path_with_negatives(graph, src)` that takes in: - `graph`: A list of tuples `(u, v, w)` representing a directed edge from node `u` to node `v` with weight `w`. Nodes are labeled from `0` to `n-1`, where `n` is the total number of unique nodes. - `src`: The source node from which the shortest paths are to be calculated. The function should return a list of distances where `dist[i]` represents the shortest distance from the source node `src` to node `i`. If node `i` is unreachable from the source, `dist[i]` should be `float(\'inf\')`. # Constraints - Ensure no cycles exist with negative weight, as this scenario will not be handled. - If the input graph contains any negative weight cycles, the function should raise a `ValueError`. # Example Input: ```python graph = [(0, 1, 2), (1, 2, 3), (2, 3, -2), (0, 3, 6)] src = 0 ``` Output: ```python [0, 2, 5, 3] ``` # Hint To handle the graph with negative weights, consider using the Bellman-Ford algorithm initially to detect any negative weight cycles and then adjust the edge weights before applying Dijkstra\'s algorithm. # Requirements Ensure an implementation of the algorithm with: - Edge case handling for unreachable nodes and negative weight cycles. - Efficient use of data structures to minimize time complexity where possible.","solution":"import heapq def shortest_path_with_negatives(graph, src): def bellman_ford_recursively_check_negative_cycle(preprocessed_graph): for iteration in range(len(nodes)): modified = False for (u, v, w) in preprocessed_graph: if distances[u] + w < distances[v]: distances[v] = distances[u] + w if iteration == len(nodes) - 1: return True modified = True if not modified: break return False nodes = set() for u, v, w in graph: nodes.add(u) nodes.add(v) distances = {node: float(\'inf\') for node in nodes} distances[src] = 0 for _ in range(len(nodes) - 1): for u, v, w in graph: if distances[u] + w < distances[v]: distances[v] = distances[u] + w if bellman_ford_recursively_check_negative_cycle(graph): raise ValueError(\\"Graph contains a negative-weight cycle\\") modified_weights = { (u, v): w + distances[u] - distances[v] for u, v, w in graph } def dijkstra(modified_weights, src): D = {node: float(\'inf\') for node in nodes} D[src] = 0 visited = set() pq = [(0, src)] while pq: (dist, current_vertex) = heapq.heappop(pq) if current_vertex in visited: continue visited.add(current_vertex) for (u, v) in modified_weights: if u == current_vertex: distance = dist + modified_weights[(u, v)] if distance < D[v]: D[v] = distance heapq.heappush(pq, (distance, v)) return D final_distances = dijkstra(modified_weights, src) result = [float(\'inf\')] * len(nodes) for node, distance in final_distances.items(): result[node] = distance for node, distance in distances.items(): if distance == float(\'inf\'): result[node] = float(\'inf\') else: result[node] = result[node] - distances[src] + distance return result"},{"question":"Finding the k-th to Last Element in a Linked List You are given a singly linked list, and your task is to implement a function to find and return the k-th to last element of the list. The function should be efficient and handle edge cases properly. Function Signature ```python def find_kth_to_last(head: Node, k: int) -> Union[Node, bool]: Find the k-th to last element of the linked list. Parameters: head (Node): The head node of the linked list. k (int): The position to find from the end. k is a non-negative integer. Returns: Node: The k-th to last node in the linked list. bool: If k is invalid (e.g., larger than the number of nodes in the list). ``` # Input * `head`: The head node of the singly linked list. * `k`: A non-negative integer representing the position from the end. # Output * The node that is the k-th to last element of the linked list. * Return `False` if `k` is invalid (i.e., larger than the number of nodes in the list or negative). # Constraints * You should not modify the linked list. * Aim for (O(n)) time complexity and (O(1)) space complexity in the optimal solution. # Assumptions * The input list contains at least one node. * (k) can be zero, in which case return the last node. # Example Consider the linked list: `A -> B -> C -> D -> E -> F -> G` * For (k = 2), the function should return the node with value \\"F\\". * For (k = 7), the function should return the node with value \\"A\\". * For (k = 8), the function should return `False` because (k) is larger than the number of nodes. # Notes * You can use the provided `Node` class for your linked list implementation: ```python class Node: def __init__(self, val=None): self.val = val self.next = None ```","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def find_kth_to_last(head: Node, k: int): if k < 0: return False slow = head fast = head # Move fast k steps ahead for _ in range(k): if fast is None: return False fast = fast.next # Move both slow and fast until fast reaches the end of the list while fast is not None and fast.next is not None: slow = slow.next fast = fast.next # If fast becomes None before k steps, return False if fast is None: return False return slow"},{"question":"You are required to sort an array of integers using the Gnome Sort algorithm. Implement the function `gnome_sort` that sorts the provided list in non-decreasing order. # Function Signature: ```python def gnome_sort(arr: List[int]) -> List[int]: ``` # Input: * **arr**: A list of integers (1 ≤ len(arr) ≤ 10^4) # Output: * Returns a list of integers sorted in non-decreasing order. # Constraints: * The input array can contain duplicate values. * The algorithm should not use additional data structures beyond the input list. * Your implementation should handle edge cases, including empty arrays and arrays with a single element. # Example: **Example 1:** ```python arr = [34, 2, 23, -5, 3] print(gnome_sort(arr)) # Output: [-5, 2, 3, 23, 34] ``` **Example 2:** ```python arr = [] print(gnome_sort(arr)) # Output: [] ``` **Example 3:** ```python arr = [1] print(gnome_sort(arr)) # Output: [1] ``` # Notes: 1. Ensure your implementation runs within the time limits for the given constraints. 2. Explain the thought process behind any optimization techniques you use, if any.","solution":"def gnome_sort(arr): Sorts the given list of integers using the Gnome Sort algorithm. index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Graph Traversal and Cycle Detection Context Imagine you are developing a system for analyzing social networks. One of your tasks is to determine whether there are cycles in the network, which might suggest cliques or unusual paths of connections. You have been given a directed graph representing user connections where each node is a user, and each directed edge indicates a follower relationship. Problem Statement Write a function `has_cycle(graph: dict) -> bool` to detect if there are cycles in the directed graph. Use DFS to perform the traversal and check for back edges indicating cycles. Input and Output Format - Input: A dictionary `graph` where the keys are node identifiers (integers) and values are lists of identifiers that the node points to. - Output: A boolean value `True` if there is at least one cycle in the graph, `False` otherwise. Constraints - The graph will have at most 1000 nodes. - Each node identifier is a non-negative integer. - The graph can be disconnected. Example ```python graph = { 0: [1, 2], 1: [2], 2: [0, 3], 3: [3] } assert has_cycle(graph) == True graph = { 0: [1], 1: [2], 2: [3], 3: [] } assert has_cycle(graph) == False ``` Requirements - Your implementation should have a time complexity of O(V + E). - Utilize depth-first search (DFS) and ensure you handle large recursion depths, possibly using iterative methods. Additional Notes Consider edge cases such as an empty graph, a single node pointing to itself, and large connected components without cycles.","solution":"def has_cycle(graph): Detect if there are cycles in the directed graph using DFS. :param graph: A dictionary where keys are node identifiers and values are lists of identifiers they point to. :return: Boolean value True if there is at least one cycle in the graph, False otherwise. def dfs(node, visited, rec_stack): # Mark the current node as visited and add it to the recursion stack visited[node] = True rec_stack[node] = True # Recur for all neighbors for neighbor in graph[node]: if not visited[neighbor]: if dfs(neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: return True # Remove the node from recursion stack rec_stack[node] = False return False # Initialization visited = {node: False for node in graph} rec_stack = {node: False for node in graph} # Check for cycle in different DFS trees for node in graph: if not visited[node]: if dfs(node, visited, rec_stack): return True return False"},{"question":"# Cosine Similarity for Document Analysis In data mining and natural language processing, measuring the similarity between texts is a fundamental task. A common technique to quantify this similarity is by treating texts as vectors of their word occurrences and using cosine similarity as the metric. **Task**: Implement the cosine similarity function described below to measure the similarity between two document vectors. ```markdown **Function Signature**: `def cosine_similarity(vec1: List[float], vec2: List[float]) -> float` **Input** - `vec1`, `vec2`: Two lists of floats representing the occurrence of words in two documents. Both lists are guaranteed to have the same length N (1 <= N <= 10^6). **Output** - A single floating-point number representing the cosine similarity between the two input vectors. **Constraints** - The elements of the vectors will be non-negative real numbers. **Example** ```python assert abs(cosine_similarity([1.0, 1.0, 1.0], [1.0, 2.0, -1.0]) - 0.47140452079103173) < 1e-6 assert abs(cosine_similarity([1.0, 0.0, 0.0], [0.0, 1.0, 0.0]) - 0.0) < 1e-6 assert abs(cosine_similarity([1.0, 1.0], [1.0, 1.0]) - 1.0) < 1e-6 ``` **Notes** 1. Your solution should handle edge cases like vectors with all elements being zero. 2. Efficiently handle large vectors possibly containing 1 million elements. 3. Ensure that your code adheres to a time complexity of O(N) for acceptable performance. **Additional Information** - The cosine similarity metric is particularly useful in the context of text similarity because the magnitude of word vectors can vary widely based on document length but cosine similarity focuses on the orientation. ```","solution":"from typing import List import math def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: dot_product = sum(a * b for a, b in zip(vec1, vec2)) norm_vec1 = math.sqrt(sum(a * a for a in vec1)) norm_vec2 = math.sqrt(sum(b * b for b in vec2)) if norm_vec1 == 0 or norm_vec2 == 0: return 0.0 return dot_product / (norm_vec1 * norm_vec2)"},{"question":"# Regular Expression Matching with limited operators **Context**: You are tasked with designing a function that can check if a given input string matches a pattern string. The pattern string may contain two special characters: - `.` which matches any single character. - `*` which matches zero or more of the preceding element. # Problem Statement: Implement a function `is_match(s: str, p: str) -> bool` that determines if the input string `s` matches the pattern `p`. # Input: - `s` (0 <= len(s) <= 200) : A string that needs to be checked. - `p` (0 <= len(p) <= 200) : A pattern string which may include `.` and `*`. # Output: - Return `True` if `s` matches the pattern `p`, otherwise return `False`. # Examples: ```python assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True assert is_match(\\"mississippi\\", \\"mis*is*p*.\\") == False ``` # Constraints: 1. You must use dynamic programming principles. 2. Your algorithm should be efficient with a polynomial time complexity not exceeding O(n*m), where `n` is the length of the string and `m` is the length of the pattern. 3. You should not use any libraries or modules for regex matching. **Note**: Ensure to handle edge cases, such as empty strings and patterns. # Function Signature: ```python def is_match(s: str, p: str) -> bool: pass ```","solution":"def is_match(s: str, p: str) -> bool: Returns whether the given string s matches the pattern p. The pattern may include: - \'.\' which matches any single character. - \'*\' which matches zero or more of the preceding element. # dp[i][j] will be True if s[0..i-1] matches p[0..j-1] dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] # Empty pattern matches empty string dp[0][0] = True # Deal with patterns like a*, a*b*, a*b*c* etc. for j in range(1, len(p) + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # Fill the dp table for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': # Matches zero instance of the previous character in pattern dp[i][j] = dp[i][j - 2] # Matches one or more instance of the previous character in pattern if p[j - 2] == \'.\' or p[j - 2] == s[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] return dp[len(s)][len(p)]"},{"question":"# Insertion Sort for Partially Sorted Arrays You are tasked with implementing a variant of the insertion sort algorithm that can efficiently handle partially sorted arrays. In specific, an array where a given number of elements are already sorted at the beginning (leading sorted section) and another section of the array remains unsorted. The goal is to complete the sorting process efficiently utilizing the initial sorted sequence. Function Signature ```python def efficient_insertion_sort(arr: List[int], sorted_until: int) -> List[int]: ... ``` Input * `arr` (List[int]): An array of integers. * `sorted_until` (int): An integer representing the number of initial elements that are already sorted in non-decreasing order. Output * (List[int]): The fully sorted array. Constraints * The `sorted_until` will be valid, i.e., `0 <= sorted_until <= len(arr)`. * All elements before `sorted_until` index are sorted in non-decreasing order. * The array may contain negative numbers, zero, and positive numbers, along with possible duplicates. Requirements * The algorithm should maintain the in-place property, i.e., it should have a space complexity of O(1). * The algorithm should aim to retain the best possible efficiency through the partially sorted nature of the array. Example ```python arr = [1, 2, 4, 3, 5, 6] sorted_until = 3 print(efficient_insertion_sort(arr, sorted_until)) # Output: [1, 2, 3, 4, 5, 6] ``` Edge Cases * An array that is already fully sorted. * Arrays where `sorted_until` is 0, meaning no portion is initially sorted. * An array of length 1.","solution":"from typing import List def efficient_insertion_sort(arr: List[int], sorted_until: int) -> List[int]: Perform insertion sort on an array that is partially sorted. Args: arr (List[int]): The input array. sorted_until (int): The number of initial elements that are already sorted. Returns: List[int]: The fully sorted array. for i in range(sorted_until, len(arr)): key = arr[i] j = sorted_until - 1 while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key sorted_until += 1 return arr"},{"question":"**Problem Statement**: You have been provided a partial implementation of a Binary Search Tree (BST), supporting operations such as insertion, searching, size calculation, and various traversal routines. For a more comprehensive assessment, you are required to extend this implementation to include methods for deleting nodes from the BST and finding the height of the tree. Your task is to implement the following additional methods: 1. `delete(data: int) -> bool`: This method should remove a node containing `data` from the BST, maintaining the properties of the BST. Return `True` if the node was deleted and `False` if the node with the given data was not found. 2. `height() -> int`: This method computes the height of the BST. The height of a BST is defined as the length of the longest path from the root to a leaf. An empty BST has a height of -1. **Input and Output**: - **delete(data: int)**: - **Input**: An integer `data`. - **Output**: A boolean indicating if the node was successfully deleted. - **height()**: - **Input**: None. - **Output**: An integer representing the height of the tree. **Constraints**: - The BST can contain any number of integer values, including none. - The value to be deleted will be a valid integer. **Example**: ```python tree = BST() tree.insert(20) tree.insert(10) tree.insert(30) tree.insert(25) tree.insert(35) # Initial height of the tree print(tree.height()) # Output: 2 # Deleting node with one child print(tree.delete(30)) # Output: True # Checking the height after deletion print(tree.height()) # Output: 2 # Deleting node with no child print(tree.delete(25)) # Output: True # Deleting node with two children print(tree.delete(10)) # Output: True # Deleting a node that is not present print(tree.delete(40)) # Output: False # Checking the height after multiple deletions print(tree.height()) # Output: 1 ```","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, data): if self.root is None: self.root = Node(data) else: self._insert(self.root, data) def _insert(self, node, data): if data < node.data: if node.left is None: node.left = Node(data) else: self._insert(node.left, data) else: if node.right is None: node.right = Node(data) else: self._insert(node.right, data) def delete(self, data): self.root, deleted = self._delete(self.root, data) return deleted def _delete(self, node, data): if node is None: return node, False if data < node.data: node.left, deleted = self._delete(node.left, data) elif data > node.data: node.right, deleted = self._delete(node.right, data) else: if node.left is None: return node.right, True elif node.right is None: return node.left, True temp = self._min_value_node(node.right) node.data = temp.data node.right, _ = self._delete(node.right, temp.data) deleted = True return node, deleted def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def height(self): return self._height(self.root) def _height(self, node): if node is None: return -1 left_height = self._height(node.left) right_height = self._height(node.right) return max(left_height, right_height) + 1"},{"question":"Find the Mode(s) in an Array Objective Write a function to determine the mode(s) of a given array. The mode is the value that appears most frequently in the array. If there are multiple modes, return all of them. Function Signature ```python def find_modes(arr: List[int]) -> List[int]: pass ``` Input - `arr`: A list of integers, where `0 <= len(arr) <= 10^5` and `-10^9 <= arr[i] <= 10^9`. Output - A list of integers representing the mode(s) of the array. The order of the mode(s) in the output list does not matter. Constraints - If the array is empty, return an empty list. - Consider efficient use of both time and space to handle large inputs effectively. Examples ```python assert find_modes([1, 1, 2, 2, 3, 4]) == [1, 2] assert find_modes([1, 2, 2, 1, 3, 3, 3]) == [3] assert find_modes([5]) == [5] assert find_modes([]) == [] assert find_modes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ``` Explanation of Example Outputs 1. For `[1, 1, 2, 2, 3, 4]`, both 1 and 2 appear twice. Hence the output is `[1, 2]`. 2. For `[1, 2, 2, 1, 3, 3, 3]`, the number 3 appears three times which is the maximum, so the output is `[3]`. 3. For `[5]`, the only element is 5, so the output is `[5]`. 4. For `[]`, the list is empty, so the output is `[]`. 5. For `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`, all elements appear once, hence all are modes, so the output is `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`.","solution":"from typing import List from collections import Counter def find_modes(arr: List[int]) -> List[int]: Find the mode(s) in an array: the value(s) that appear most frequently. if not arr: return [] frequency = Counter(arr) max_frequency = max(frequency.values()) modes = [key for key, value in frequency.items() if value == max_frequency] return modes"},{"question":"You are required to implement a function to calculate the binomial coefficient recursively. The binomial coefficient, denoted as ( C(n, k) ), gives the number of ways to choose k items from n items without regarding order. # Function Signature ```python def recursive_binomial_coefficient(n: int, k: int) -> int: ``` # Input * `n` (int): A non-negative integer representing the total number of items. * `k` (int): A non-negative integer representing the number of items to choose. # Output * Returns (int): The number of combinations, ( C(n, k) ). # Constraints and Limitations * `0 <= k <= n <= 500`: Ensure that `n` is greater than or equal to `k`. * Optimize for both time and space where possible. * Avoid redundant calculations by leveraging symmetry and other properties. # Example ```python >>> recursive_binomial_coefficient(5, 0) 1 >>> recursive_binomial_coefficient(8, 2) 28 >>> recursive_binomial_coefficient(10, 5) 252 ``` # Performance Requirements * The function should handle large values of `n` and `k` efficiently up to the constraint limits. # Additional Context - Utilize recursive properties and the symmetry ( C(n, k) = C(n, n-k) ) to minimize computational overhead. - Consider memoization if it significantly enhances performance without altering the expected function signature.","solution":"def recursive_binomial_coefficient(n: int, k: int) -> int: Calculate the binomial coefficient C(n, k) using a recursive approach with memoization. memo = {} def recurse(n, k): # Base cases if k == 0 or k == n: return 1 # Check if result is already calculated if (n, k) in memo: return memo[(n, k)] # Using the properties of binomial coefficients result = recurse(n - 1, k - 1) + recurse(n - 1, k) memo[(n, k)] = result return result return recurse(n, k)"},{"question":"# Question: Frequency Counter Implementation You are provided with a list of integers. Your task is to write a function `frequency_counter` that calculates the frequency of each unique number in the list and returns this information in the form of a dictionary. This type of algorithm is known as Histogram Counting. Function Signature `def frequency_counter(input_list: list) -> dict:` Input * A single parameter `input_list` which is a list of integers. Output * Returns a dictionary where the keys are the unique integers from the input list and the values are their respective counts in the list. Constraints 1. The input list can have up to `10^6` elements. 2. Each integer in the list will be between `-10^9` and `10^9`. Example ```python input_list = [2, 3, 5, 5, 5, 6, 4, 3, 7] # Expected Output: {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} input_list = [3, 3, 2, 1] # Expected Output: {1: 1, 2: 1, 3: 2} input_list = [] # Expected Output: {} ``` Performance Requirements - The solution must run in O(n) time complexity, where n is the number of elements in the input list. - The solution must operate within O(k) space complexity, where k is the number of unique elements in the list. Edge Cases to Consider - An empty list should return an empty dictionary. - Lists with identical or only a single element. You can verify your implementation by running additional test cases.","solution":"def frequency_counter(input_list): This function computes and returns the frequency of each unique number in the list. frequency = {} for num in input_list: if num in frequency: frequency[num] += 1 else: frequency[num] = 1 return frequency"},{"question":"You are designing a system that needs to handle large prime numbers. One way to ascertain whether a number is prime is through a probabilistic algorithm known as the Rabin-Miller primality test. Write a function `probable_prime(n: int, k: int) -> bool` that determines if the given integer `n` is probably prime using the Rabin-Miller primality test. The function should return `False` if `n` is definitively composite or `True` if `n` is probably prime (with a false positive rate of ( 4^{-k} )). # Input * `n` (int): The number to be tested ( ( n geq 5 ) ). * `k` (int): The number of testing rounds to reduce the probability of error. # Output * `True` if `n` is probably prime. * `False` if `n` is definitely composite. # Constraints * ( n ge 5 ) * ( 1 le k le 100 ) * The function should handle very large values of `n`, potentially up to ( 10^{18} ). # Example ```python def probable_prime(n: int, k: int) -> bool: # Your implementation here # Example Usage print(probable_prime(17, 5)) # Expected Output: True print(probable_prime(18, 5)) # Expected Output: False ``` Hints: 1. Factor ( n - 1 ) as ( 2^r cdot d ). 2. Use modular exponentiation to verify witnesses. 3. Multiple rounds of testing can increase confidence in primality.","solution":"import random def modular_exponentiation(base, exp, mod): result = 1 while exp > 0: if exp % 2 == 1: result = (result * base) % mod base = (base * base) % mod exp //= 2 return result def rabin_miller_test(n, d, r): a = random.randint(2, n - 2) x = modular_exponentiation(a, d, n) if x == 1 or x == n - 1: return True for _ in range(r - 1): x = (x * x) % n if x == n - 1: return True return False def probable_prime(n: int, k: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False d = n - 1 r = 0 while d % 2 == 0: r += 1 d //= 2 for _ in range(k): if not rabin_miller_test(n, d, r): return False return True"},{"question":"# Problem Context In a computing grid world, islands are formed by connecting horizontally or vertically adjacent lands. Each cell is either water (0) or land (1). You are required to dynamically track the number of islands as new lands are added step by step. # Task Implement the function `count_islands` that takes a grid size and a list of land positions added sequentially. At each added position, return the current number of islands. An island is defined as a group of `1`s (representing land) connected 4-directionally (top, left, right, bottom). # Function Signature ```python def count_islands(m: int, n: int, positions: List[List[int]]) -> List[int]: pass ``` # Input - `m` (int): Number of rows in the grid. - `n` (int): Number of columns in the grid. - `positions` (List[List[int]]): List of positions where a land is added sequentially. # Output - List of integers representing the number of islands after each addLand operation. # Constraints - 1 <= m, n <= 1000 - 1 <= len(positions) <= 1000 - Each position is within grid bounds (0 <= x < m, 0 <= y < n). # Example ```python m = 3 n = 3 positions = [[0, 0], [0, 1], [1, 2], [2, 1]] print(count_islands(m, n, positions)) # Output: [1, 1, 2, 3] ``` # Explanation - When [0, 0] is added, the grid becomes: ``` 1 0 0 0 0 0 0 0 0 ``` Number of islands: 1. - After adding [0, 1]: ``` 1 1 0 0 0 0 0 0 0 ``` Number of islands: 1. - Adding [1, 2]: ``` 1 1 0 0 0 1 0 0 0 ``` Number of islands: 2. - Adding [2, 1]: ``` 1 1 0 0 0 1 0 1 0 ``` Number of islands: 3. # Notes - Consider edge cases such as adding lands to positions already occupied. - Ensure optimal performance in both time and space given the constraints.","solution":"from typing import List class UnionFind: def __init__(self, size): self.parent = [-1] * size self.rank = [0] * size self.count = 0 # Number of connected components def find(self, i): if self.parent[i] != i: self.parent[i] = self.find(self.parent[i]) # Path compression return self.parent[i] def union(self, i, j): root_i = self.find(i) root_j = self.find(j) if root_i != root_j: # Union by rank if self.rank[root_i] > self.rank[root_j]: self.parent[root_j] = root_i elif self.rank[root_i] < self.rank[root_j]: self.parent[root_i] = root_j else: self.parent[root_j] = root_i self.rank[root_i] += 1 self.count -= 1 def set_parent(self, i): if self.parent[i] == -1: self.parent[i] = i self.count += 1 def count_islands(m: int, n: int, positions: List[List[int]]) -> List[int]: uf = UnionFind(m * n) result = [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for x, y in positions: index = x * n + y if uf.parent[index] == -1: uf.set_parent(index) for dx, dy in directions: nx, ny = x + dx, y + dy neighbor_index = nx * n + ny if 0 <= nx < m and 0 <= ny < n and uf.parent[neighbor_index] != -1: uf.union(index, neighbor_index) result.append(uf.count) else: # Land position already occupied, should not affect the island count result.append(uf.count) return result"},{"question":"Coding Assessment Question # Objective In this task, you are given access to a node in the middle of a singly linked list. Your objective is to delete this node efficiently. # Problem Statement Write a function `delete_middle_node(node)` which deletes the given node (which is neither the first node nor the last node) from the linked list. # Constraints 1. The given node is mid-linked, meaning it will always have a next node and is not the first node. 2. You cannot access the head of the list. 3. The operation should be performed in constant time, O(1). # Input/Output Format * **Input**: * A `Node` object that represents the node to be deleted. The `Node` class is predefined with `val` (value) and `next` (pointer) attributes. * **Output**: * The function should modify the linked list in place and does not need to return anything. # Function Signature ```python def delete_middle_node(node): pass ``` # Example Suppose the linked list is `1 -> 2 -> 3 -> 4 -> 5` and you are given the node with value `3`, the linked list should become `1 -> 2 -> 4 -> 5` after calling your function. ```python class Node: def __init__(self, x): self.val = x self.next = None # Helper function to create linked list from list def create_linked_list(vals): head = Node(vals[0]) current = head for val in vals[1:]: current.next = Node(val) current = current.next return head # Helper function to print linked list def print_linked_list(head): vals = [] while head: vals.append(head.val) head = head.next print(\\"->\\".join(map(str, vals))) # Test Case if __name__ == \\"__main__\\": linked_list_vals = [1, 2, 3, 4, 5] head = create_linked_list(linked_list_vals) # Print original list: print(\\"Original List: \\") print_linked_list(head) # Assuming node to delete is the third one with value 3 node_to_delete = head.next.next # Node with value 3 # Call delete function delete_middle_node(node_to_delete) # Print modified list: print(\\"Modified List: \\") print_linked_list(head) ``` # Notes - Consider edge cases such as assigning the `None` to the next of a deleted node when necessary. - Avoid any unnecessary traversals and ensure O(1) deletion time.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def delete_middle_node(node): Delete the given node from the linked list. The node is guaranteed to be neither the first nor the last node in the list. if node is None or node.next is None: return None # Copy the data from the next node to the current node node.val = node.next.val # Bypass the next node node.next = node.next.next"},{"question":"# Graph Cloning Challenge You are tasked with writing a function to clone an undirected graph. Each node in the graph contains a label and a list of its neighbors. The graph serialization will be done in the format provided in the examples below. Function Signature ```python def clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': ``` Input - `node` (UndirectedGraphNode): The starting node of the graph to be cloned. Output - Returns a new UndirectedGraphNode that represents the starting node of a cloned graph. Constraints - The label of each node is unique. - The number of nodes in the original graph will not exceed 1000. Performance Requirements - Your solution should have a time complexity of O(N + M), where N is the number of nodes, and M is the number of edges. - Memory usage should be linear relative to the number of nodes. # Example Given the graph: ``` 1 / / 0 --- 2 / _/ ``` Serialized as `{0,1,2#1,2#2,2}`. Expected Output: A cloned graph with the same structure: ``` 1 / / 0 --- 2 / _/ ``` # Implementation Guidelines 1. Implement both BFS and DFS approaches to clone the graph. 2. Handle cases where nodes have self-loops or are part of cycles. 3. Ensure that no duplicate nodes are created in the cloned graph. 4. Nodes with no neighbors should also be copied correctly. Algorithm Analysis You should correctly analyze and understand how the BFS and DFS graph traversal strategies are functioning and apply them effectively.","solution":"class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': if not node: return None # A dictionary to save the cloned nodes cloned_nodes = {} # DFS function to clone the graph def dfs(node): if node.label in cloned_nodes: return cloned_nodes[node.label] # Clone the current node clone = UndirectedGraphNode(node.label) cloned_nodes[node.label] = clone # Iterate over all the neighbors for neighbor in node.neighbors: clone.neighbors.append(dfs(neighbor)) return clone # Initiate DFS from the given node return dfs(node)"},{"question":"# Isomorphic Strings with Constraints Given two strings `s` and `t`, determine if they are isomorphic. Two strings are isomorphic if the characters in `s` can be replaced to get `t`. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. You are required to complete the function `is_isomorphic(s: str, t: str) -> bool`. Input: - `s` and `t` are strings, consisting exclusively of ASCII characters. - The lengths of `s` and `t` are at most 10^5. Output: - Return `True` if `s` and `t` are isomorphic. - Return `False` otherwise. Example 1: - Input: `s = \\"egg\\"`, `t = \\"add\\"` - Output: `True` Example 2: - Input: `s = \\"foo\\"`, `t = \\"bar\\"` - Output: `False` Example 3: - Input: `s = \\"paper\\"`, `t = \\"title\\"` - Output: `True` Constraints: 1. The function should handle strings up to a length of 10^5 efficiently. 2. The function should properly address edge cases such as empty strings and strings with repeated characters. 3. The implementation should be optimal in terms of time complexity to handle large inputs within reasonable computational limits.","solution":"def is_isomorphic(s: str, t: str) -> bool: Determine if two strings s and t are isomorphic. if len(s) != len(t): return False s_to_t_mapping = {} t_to_s_mapping = {} for char_s, char_t in zip(s, t): if char_s in s_to_t_mapping: if s_to_t_mapping[char_s] != char_t: return False else: s_to_t_mapping[char_s] = char_t if char_t in t_to_s_mapping: if t_to_s_mapping[char_t] != char_s: return False else: t_to_s_mapping[char_t] = char_s return True"},{"question":"Problem: You are tasked with implementing a **Playlist** manager for a music app where songs can be added, removed, and traversed efficiently. Given the dynamic nature of playlists, a **Doubly Linked List** is a suitable data structure for this purpose. Requirements: 1. Implement a class `DoublyLinkedList` that includes the following methods: * `add_song(song)`: Insert `song` (a string representing the song\'s title) to the end of the playlist. * `remove_song(song)`: Remove the first occurrence of `song` from the playlist. * `next_song()`: Advance the current song pointer to the next song in the playlist. * `prev_song()`: Move the current song pointer to the previous song in the playlist. * `current_song()`: Return the title of the currently playing song. If the playlist is empty, return `None`. Constraints: * Multiple songs with the same title may exist; only the first occurrence should be removed by `remove_song`. * All operations should perform efficiently within the prescribed time complexity bounds. * The playlist should initially start empty. Example: ```python playlist = DoublyLinkedList() playlist.add_song(\\"Song1\\") playlist.add_song(\\"Song2\\") playlist.add_song(\\"Song3\\") print(playlist.current_song()) # Output: \\"Song1\\" playlist.next_song() print(playlist.current_song()) # Output: \\"Song2\\" playlist.remove_song(\\"Song2\\") playlist.next_song() print(playlist.current_song()) # Output: \\"Song3\\" playlist.prev_song() print(playlist.current_song()) # Output: \\"Song1\\" ``` Performance Constraints: * Expected time complexity for `add_song` and `remove_song` should be O(1) for appending and O(n) for removal. * Expected time complexity for `next_song`, `prev_song`, and `current_song` should be O(1). Implement the `DoublyLinkedList` class and its methods to meet the above specifications.","solution":"class Node: def __init__(self, data): self.data = data self.prev = None self.next = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None self.current = None def add_song(self, song): new_node = Node(song) if not self.head: self.head = self.tail = self.current = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def remove_song(self, song): current_node = self.head while current_node: if current_node.data == song: if current_node.prev: current_node.prev.next = current_node.next if current_node.next: current_node.next.prev = current_node.prev if current_node == self.head: self.head = current_node.next if current_node == self.tail: self.tail = current_node.prev if self.current == current_node: self.current = current_node.next if current_node.next else current_node.prev return current_node = current_node.next def next_song(self): if self.current and self.current.next: self.current = self.current.next def prev_song(self): if self.current and self.current.prev: self.current = self.current.prev def current_song(self): return self.current.data if self.current else None"},{"question":"Alice and Bob want to establish a secret key using the Diffie-Hellman key exchange protocol. However, they need to ensure that the prime number p and the generator a they use are valid to guarantee the security of their key exchange. Write a function `secure_diffie_hellman(p, a, verbose=False)` that: 1. Validates if `p` is a prime number. 2. Checks if `a` is a primitive root of `p`. 3. If both validations pass, performs the Diffie-Hellman key exchange and returns whether Alice and Bob\'s shared keys match. 4. If the `verbose` parameter is set to `True`, print the steps and values involved in the key exchange process, including private keys, public keys, and shared keys of both Alice and Bob. # Function Signature ```python def secure_diffie_hellman(p: int, a: int, verbose: bool = False) -> bool: Determine if p is a prime number and a is its primitive root. Perform Diffie-Hellman key exchange if validation passes. :param p: int - The prime number to validate and use in key exchange. :param a: int - The primitive root to validate and use in key exchange. :param verbose: bool - Whether to print detailed process steps. :return: bool - True if shared keys match, otherwise False. ``` # Input * `p`: A large integer that needs to be prime. * `a`: An integer that needs to be a primitive root of `p`. * `verbose`: A boolean flag to print detailed steps if set to `True`. # Output * Returns `True` if the shared keys computed by Alice and Bob match, `False` otherwise. # Constraints * `1 <= p <= 10^9` * `1 <= a <= p-1` # Example ```python assert secure_diffie_hellman(23, 5, verbose=True) == True assert secure_diffie_hellman(23, 10) == False assert secure_diffie_hellman(97, 5) == True assert secure_diffie_hellman(97, 20) == False ``` # Requirements * You must use the provided prime_check, find_order, euler_totient, and find_primitive_root functions within your implementation. * Ensure that the code handles edge cases such as invalid prime and primitive root inputs. * Aim for optimized performance, especially when dealing with large values of `p`.","solution":"def is_prime(n): Check if the input number n is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_primitive_root(p): Find a primitive root for prime p. if not is_prime(p): return -1 factors = find_prime_factors(p - 1) for g in range(2, p): if all(pow(g, (p - 1) // factor, p) != 1 for factor in factors): return g return -1 def find_prime_factors(n): Find prime factors of a given number n. factors = set() while n % 2 == 0: factors.add(2) n //= 2 for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: factors.add(i) n //= i if n > 2: factors.add(n) return factors def secure_diffie_hellman(p, a, verbose=False): Determine if p is a prime number and a is its primitive root. Perform Diffie-Hellman key exchange if validation passes. :param p: int - The prime number to validate and use in key exchange. :param a: int - The primitive root to validate and use in key exchange. :param verbose: bool - Whether to print detailed process steps. :return: bool - True if shared keys match, otherwise False. if not is_prime(p): return False if find_primitive_root(p) != a: return False # Generate random private keys for Alice and Bob in range [1, p-2] alice_private_key = 6 # In practice should use random.randint(1, p-2) bob_private_key = 15 # In practice should use random.randint(1, p-2) # Compute public keys using the generator a alice_public_key = pow(a, alice_private_key, p) bob_public_key = pow(a, bob_private_key, p) # Compute shared keys alice_shared_key = pow(bob_public_key, alice_private_key, p) bob_shared_key = pow(alice_public_key, bob_private_key, p) if verbose: print(f\\"p = {p}, a = {a}\\") print(f\\"Alice\'s private key: {alice_private_key}\\") print(f\\"Bob\'s private key: {bob_private_key}\\") print(f\\"Alice\'s public key: {alice_public_key}\\") print(f\\"Bob\'s public key: {bob_public_key}\\") print(f\\"Alice\'s shared key: {alice_shared_key}\\") print(f\\"Bob\'s shared key: {bob_shared_key}\\") return alice_shared_key == bob_shared_key"},{"question":"You are a software engineer tasked with developing a system that processes sequences of log entries stored in a singly linked list format. Sometimes, the sequences need to be processed in reverse. Write a function, `reverse_list`, that reverses a singly linked list and meets specific constraints and performance requirements. # Function Signature ```python def reverse_list(head: ListNode) -> ListNode: ``` # Input * `head` (ListNode): The head of a singly linked list where each node contains an integer value and a pointer to the next node. # Output * Returns the new head of the reversed singly linked list. # Constraints * The number of nodes in the list will not exceed (10^5). * Each node\'s value will be within the range `[-10^9, 10^9]`. # Performance Requirements * The function should work in O(n) time complexity. * The function should use O(1) (constant) extra space for the iterative solution, but can use O(n) stack space for the recursive approach. # Examples 1. Input: `1 -> 2 -> 3 -> 4` Output: `4 -> 3 -> 2 -> 1` 2. Input: `NULL` Output: `NULL` 3. Input: `5` Output: `5` # Notes * Consider edge cases such as an empty list and a list with a single node. * Make sure the reversed linked list does not form a cycle. # Scenario Imagine you work on a logging server where the sequence of logs can be immense, and occasionally there is a need to process these logs from the end back to the start. Use the function to reverse the order of log messages efficiently, ensuring memory usage is kept at a minimum.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head: ListNode) -> ListNode: Reverses a singly linked list. Args: head (ListNode): The head of the singly linked list. Returns: ListNode: The new head of the reversed singly linked list. prev = None current = head while current: next_node = current.next # store the next node current.next = prev # reverse the current node\'s pointer prev = current # move prev to the current node current = next_node # move to the next node return prev # prev will be the new head of the reversed list"},{"question":"# Question: Longest Increasing Subsequence **Background Context:** You are analyzing the performance trends of a new stock over a period of time. Given the daily stock prices, you want to determine the longest sequence of days where the stock price was consistently increasing. # Task: Write a function `find_lis_length` that takes a list of integers (representing the stock prices over a period of days) and returns the length of the longest increasing subsequence. # Constraints: - The length of the input list will not exceed (10^5). - Each integer in the list will be a non-negative number not greater than (10^9). # Function Signature: ```python def find_lis_length(prices: List[int]) -> int: ``` # Input: - A list of integers `prices` where each integer represents the stock price on a particular day. # Output: - An integer representing the length of the longest increasing subsequence of stock prices. # Examples: 1. **Example 1:** **Input:** `[10, 9, 2, 5, 3, 7, 101, 18]` **Output:** `4` **Explanation:** The longest increasing subsequence is `[2, 3, 7, 101]`, so the length is 4. 2. **Example 2:** **Input:** `[3, 10, 2, 1, 20]` **Output:** `3` **Explanation:** The longest increasing subsequence is `[3, 10, 20]`, so the length is 3. # Constraints and Performance Notes: - Ensure your solution works efficiently for large inputs up to (10^5) elements. - Expected time complexity is (O(n log n)). Special Notes: - Focus on the correctness of handling large sequences and edge cases such as empty lists or lists with very similar values. - You may consider implementing an optimized approach using appropriate data structures to meet performance requirements. **Hint:** You may use data structures such as segment trees or consider the use of binary search to optimize the dynamic programming solution.","solution":"from typing import List import bisect def find_lis_length(prices: List[int]) -> int: Returns the length of the longest increasing subsequence. if not prices: return 0 lis = [] for price in prices: pos = bisect.bisect_left(lis, price) if pos == len(lis): lis.append(price) else: lis[pos] = price return len(lis)"},{"question":"Context: You are given a linked list, which may potentially contain a cycle. Your task is to find the node where the cycle begins, if one exists. Problem Statement: Implement a function `find_cycle_start(head)` that takes the head of a linked list and returns the node where the cycle begins. If there\'s no cycle, return `None`. # Function Signature: ```python class ListNode: def __init__(self, x): self.value = x self.next = None def find_cycle_start(head: ListNode) -> ListNode: # your code here ``` # Input: * `head` - The head node of a linked list. # Output: * The node at which the cycle begins, or `None` if no cycle exists. # Constraints: * The function should run in O(n) time complexity. * The function should use O(1) extra space. # Example Scenario: ```python # Example 1 # Input: A -> B -> C -> D -> E -> C (cycle starts at C) # Output: Node with value \'C\' # Example 2 # Input: 1 -> 2 -> 3 -> 4 -> 5 (no cycle) # Output: None # Example 3 # Input: 1 -> 2 -> 3 -> 4 -> 5 -> 1 (cycle starts at 1) # Output: Node with value \'1\' ``` Write unit tests to validate your solution by creating instances of linked lists with different cyclic and acyclic scenarios. **Performance Requirements**: Ensure that your implementation maintains O(n) time complexity and O(1) space complexity. Notes: * Consider edge cases like an empty list, a single node list, and a two-node cyclic list. * Pay attention to handling null pointers or end of lists appropriately to avoid runtime errors. **hint**: Use Floyd\'s Tortoise and Hare algorithm to solve this problem.","solution":"class ListNode: def __init__(self, x): self.value = x self.next = None def find_cycle_start(head: ListNode) -> ListNode: if not head or not head.next: return None slow = head fast = head # Phase 1: Determine whether a cycle exists while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break if not fast or not fast.next: return None # Phase 2: Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"Scenario You are developing an educational tool that helps students improve their typing skills by providing them with word exercises that focus on using specific rows of a QWERTY keyboard. To generate these exercises, you need a function that filters given words based on their characters resulting from different rows of the keyboard. Problem Statement Given a list of words, write a function named `find_keyboard_row` that returns only the words that can be typed using letters from a single row of an American QWERTY keyboard. The keyboard has the following rows: - Top row: **\\"qwertyuiop\\"** - Middle row: **\\"asdfghjkl\\"** - Bottom row: **\\"zxcvbnm\\"** Function Signature ```python def find_keyboard_row(words: List[str]) -> List[str]: pass ``` Input - `words`: A list of strings, each representing a word composed of alphabetic characters. Output - A list of strings, representing the words that can be typed using letters from one row of the keyboard. Constraints - Words are case-insensitive, meaning `\\"aSdFg\\"` should be treated the same as \\"asdfg\\". - The input list may contain upper and lowercase letters, but the returned words should maintain their original case as in the input list. - Ignore any non-alphabetic characters and consider only words (composed of alphabets A-Z/a-z). Example ```python Input: [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] Output: [\\"Alaska\\", \\"Dad\\"] ``` Requirements - Consider the time and space complexity. The function should run efficiently for large inputs. - Handle edge cases such as empty words or input lists gracefully without throwing errors.","solution":"from typing import List def find_keyboard_row(words: List[str]) -> List[str]: top_row = set(\\"qwertyuiop\\") middle_row = set(\\"asdfghjkl\\") bottom_row = set(\\"zxcvbnm\\") def can_be_typed(word, row): word_set = set(word.lower()) return word_set.issubset(row) result = [] for word in words: if ( can_be_typed(word, top_row) or can_be_typed(word, middle_row) or can_be_typed(word, bottom_row) ): result.append(word) return result"},{"question":"# Egg Dropping Puzzle Challenge **Scenario**: You are working for a company that develops highly durable products. To ensure quality, you must determine the highest floor from which a product (egg) can be dropped without breaking. Given a specific number of eggs and floors, you need to figure out the minimum number of attempts required to find this critical floor, regardless of which floor it is. **Problem Statement**: Given K eggs and N floors, write a function `find_min_attempts(K, N)` to determine the minimum number of attempts required in the worst case to find the highest safe floor. Function Signature ```python def find_min_attempts(K: int, N: int) -> int: pass ``` Input * `K` (1 ≤ K ≤ 100): The number of eggs. * `N` (1 ≤ N ≤ 10000): The number of floors. Output * An integer representing the minimum number of trials required in the worst case. Constraints * You must use dynamic programming to solve this problem efficiently. * Your solution should handle edge cases like `K = 1`, `N = 0`, etc. Performance Requirements * Time Complexity: O(K * N^2) at most. * Space Complexity: O(K * N) for the DP table. Examples: 1. **Input**: `K = 1`, `N = 2` **Output**: `2` **Explanation**: Drop the egg from floor 1. If it breaks, we know F = 0. Otherwise, drop from floor 2. If it breaks, F = 1; otherwise, F = 2. 2. **Input**: `K = 2`, `N = 6` **Output**: `3` **Explanation**: Using two eggs optimally to minimize the worst number of trials, you determine it in 3 moves. 3. **Input**: `K = 3`, `N = 14` **Output**: `4` **Explanation**: With three eggs, the critical floor can be determined in at most 4 attempts. **Note**: Consider edge cases and ensure your function handles large values within reasonable execution time.","solution":"def find_min_attempts(K: int, N: int) -> int: Function to find the minimum number of attempts needed in the worst case with K eggs and N floors. if N == 0 or N == 1: return N if K == 1: return N dp = [[0 for x in range(N + 1)] for x in range(K + 1)] for i in range(1, K + 1): dp[i][0] = 0 dp[i][1] = 1 for j in range(1, N + 1): dp[1][j] = j for i in range(2, K + 1): for j in range(2, N + 1): dp[i][j] = float(\'inf\') for x in range(1, j + 1): res = 1 + max(dp[i - 1][x - 1], dp[i][j - x]) if res < dp[i][j]: dp[i][j] = res return dp[K][N]"},{"question":"# Question: Implement String Reversal Function As part of a text processing library, you are required to implement a function to reverse a string. You will have to provide solutions using three different approaches: recursive, iterative, and Pythonic. Function Implementations: 1. Provide a recursive implementation: ```python def reverse_recursive(s: str) -> str: # Implement this function ``` 2. Provide an iterative implementation: ```python def reverse_iterative(s: str) -> str: # Implement this function ``` 3. Provide a Pythonic implementation: ```python def reverse_pythonic(s: str) -> str: # Implement this function ``` Input and Output Formats * **Input**: A single string `s`, with length 0 <= len(s) <= 1000. * **Output**: A single string which is the reversed version of `s`. Performance Requirements * Ensure each function is optimized to handle the maximum input size efficiently. Example ```python assert reverse_recursive(\\"hello\\") == \\"olleh\\" assert reverse_iterative(\\"world\\") == \\"dlrow\\" assert reverse_pythonic(\\"python\\") == \\"nohtyp\\" assert reverse_recursive(\\"\\") == \\"\\" assert reverse_iterative(\\"a\\") == \\"a\\" assert reverse_pythonic(\\"#^&*\\") == \\"*&^#\\" ``` # Context These functions will be part of a larger text processing library that needs efficient and reliable string reversal methods. Your task is to implement all three provided functions in a manner that they pass the above examples and adhere to the given constraints.","solution":"def reverse_recursive(s: str) -> str: Returns the reversed string using recursive approach. if len(s) == 0: return s else: return s[-1] + reverse_recursive(s[:-1]) def reverse_iterative(s: str) -> str: Returns the reversed string using iterative approach. reversed_string = \\"\\" for char in s: reversed_string = char + reversed_string return reversed_string def reverse_pythonic(s: str) -> str: Returns the reversed string using Pythonic slicing. return s[::-1]"},{"question":"You are given a graph represented as an adjacency list, along with a start node and an end node. Implement three functions to solve different pathfinding problems within the graph: 1. **find_path(graph, start, end, path=[])**: - Find any path between `start` and `end`. - Return the path as a list of nodes. - Return `None` if no path exists. 2. **find_all_path(graph, start, end, path=[])**: - Return all possible paths between `start` and `end`. - Return an empty list if no paths exist. 3. **find_shortest_path(graph, start, end, path=[])**: - Find the shortest path between `start` and `end`. - Return the shortest path as a list of nodes. - Return `None` if no path exists. # Input Format: - `graph`: A dictionary where keys are nodes and values are lists of adjacent nodes. - `start`: The starting node (string). - `end`: The destination node (string). # Output Format: - For **find_path**: A list of nodes representing the path from `start` to `end`. - For **find_all_path**: A list of lists, where each sub-list is a path from `start` to `end`. - For **find_shortest_path**: A list of nodes representing the shortest path from `start` to `end`. # Constraints: - Assume nodes in the graph are unique strings. - The graph is directed and may contain cycles. - Suitable for small to moderately large graphs (e.g., less than 1000 nodes). # Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'F\'], \'D\': [\'C\', \'E\'], \'E\': [\'F\'], \'F\': [\'C\'] } print(find_path(graph, \'A\', \'F\')) # Output: [\'A\', \'B\', \'E\', \'F\'] or any other valid path print(find_all_path(graph, \'A\', \'F\')) # Output: [[\'A\', \'B\', \'D\', \'C\', \'F\'], [\'A\', \'B\', \'E\', \'F\'], [\'A\', \'C\', \'F\']] print(find_shortest_path(graph, \'A\', \'F\')) # Output: [\'A\', \'C\', \'F\'] ``` Feel free to use any standard Python library and ensure code robustness by handling edge cases effectively.","solution":"def find_path(graph, start, end, path=[]): Finds any path from start to end in the graph. path = path + [start] if start == end: return path if start not in graph: return None for node in graph[start]: if node not in path: newpath = find_path(graph, node, end, path) if newpath: return newpath return None def find_all_paths(graph, start, end, path=[]): Finds all paths from start to end in the graph. path = path + [start] if start == end: return [path] if start not in graph: return [] paths = [] for node in graph[start]: if node not in path: newpaths = find_all_paths(graph, node, end, path) for newpath in newpaths: paths.append(newpath) return paths def find_shortest_path(graph, start, end, path=[]): Finds the shortest path from start to end in the graph. path = path + [start] if start == end: return path if start not in graph: return None shortest = None for node in graph[start]: if node not in path: newpath = find_shortest_path(graph, node, end, path) if newpath: if not shortest or len(newpath) < len(shortest): shortest = newpath return shortest"},{"question":"# Linked Lists Intersection Detection You are given two singly linked lists that potentially intersect at some point. Your task is to write a function that finds and returns the node where they intersect. If the two linked lists do not intersect, the function should return `None`. # Function Signature ```python def find_intersection(headA: Node, headB: Node) -> Node: ``` # Input * `headA` - a Node object representing the head of the first linked list. * `headB` - a Node object representing the head of the second linked list. # Output * Return the Node object where the two linked lists intersect. If they do not intersect, return `None`. # Constraints * A linked list node is defined as `class Node`, where each node has a unique identifier, and an attribute `next` pointing to the next node in the list. * Both linked lists are assumed to be non-circular. # Requirements * Time Complexity: O(n + m), where n and m are the lengths of the two linked lists. * Space Complexity: O(1) # Example Consider the following example: Linked lists structure: ``` List 1: 1 -> 3 -> 5 -> 7 -> 9 -> 11 ↘ List 2: 2 -> 4 -> 6 ``` * If the input is `headA` pointing to 1 and `headB` pointing to 2, the function should return the node with value `7`. # Notes * Ensure proper handling of edge cases, such as one or both lists being empty, no intersection, and all nodes being the same. * This problem requires detecting the first common node using efficient methods for traversing and comparing nodes. # Testing A sample test case has been provided for you to validate your implementation. ```python class TestSuite(unittest.TestCase): def test_intersection(self): # create linked list as: # 1 -> 3 -> 5 # # 7 -> 9 -> 11 # / # 2 -> 4 -> 6 a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f self.assertEqual(7, find_intersection(a1, a2).val) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def find_intersection(headA: Node, headB: Node) -> Node: Function to find the intersection point of two singly linked lists. if not headA or not headB: return None # Two pointers to traverse the lists pointerA = headA pointerB = headB while pointerA is not pointerB: pointerA = pointerA.next if pointerA else headB pointerB = pointerB.next if pointerB else headA return pointerA"},{"question":"**Scenario:** You have been tasked with developing a robust sorting algorithm for a data processing application that primarily handles small integer datasets. The existing library lacks efficient sorting for negative integers and sometimes processes arrays with both positive and negative numbers. Your goal is to implement a new sorting function that can handle this requirement efficiently. **Problem Statement:** Write a function `flexible_counting_sort(arr)` to sort an array of integers, which can include both negative and positive values. Your function should leverage the counting sort algorithm while addressing the peculiarities of mixed signed numbers. # Requirements: * The function should use the counting sort mechanism. * It should handle arrays with both negative and positive numbers efficiently. * The solution should maintain the stability of the sorted array. * The function must handle edge cases such as single-element arrays, empty arrays, and arrays with all identical elements. * Minimize additional space usage as much as possible. # Function Signature: ```python def flexible_counting_sort(arr: List[int]) -> List[int]: ``` # Input: * `arr`: A list of integers which may include both positive and negative numbers. # Output: * A list of integers sorted in non-decreasing order. # Constraints: * The array\'s length will be in the range of 0 <= len(arr) <= 10^5. * The array\'s values will be in the range of -10^5 <= arr[i] <= 10^5. # Example: ```python assert flexible_counting_sort([4, -2, -5, 1, 3, -1, 2, 0]) == [-5, -2, -1, 0, 1, 2, 3, 4] assert flexible_counting_sort([]) == [] assert flexible_counting_sort([7, 7, 7]) == [7, 7, 7] assert flexible_counting_sort([0]) == [0] ```","solution":"from typing import List def flexible_counting_sort(arr: List[int]) -> List[int]: if not arr: return [] min_val = min(arr) max_val = max(arr) range_of_elements = max_val - min_val + 1 # Initialize the count array with zeros count = [0] * range_of_elements output = [0] * len(arr) # Store the count of each element in the count array for num in arr: count[num - min_val] += 1 # Change count[i] so that count[i] now contains the actual # position of this element in the output array for i in range(1, len(count)): count[i] += count[i - 1] # Build the output array by placing the elements for i in range(len(arr) - 1, -1, -1): output[count[arr[i] - min_val] - 1] = arr[i] count[arr[i] - min_val] -= 1 return output"},{"question":"# Question: Bit Manipulation Challenge You are given two integers, A and B. You need to determine the minimal number of bits you would need to flip to convert integer A to integer B. For example, to convert the integer 29 (which in binary is 11101) to the integer 15 (which in binary is 01111), you need to flip 2 bits. Function Signature: ```python def count_flips_to_convert(a: int, b: int) -> int: ``` # Input * **a** (0 <= a <= 10^9): First integer. * **b** (0 <= b <= 10^9): Second integer. # Output * Returns the minimal number of bits you need to flip to convert `a` to `b`. # Constraints * Both integers are non-negative and within the range of a standard 32-bit signed integer. * Consider edge cases such as: - Both integers being the same. - The integers being at opposite ends of the possible integer values. Example ```python assert count_flips_to_convert(29, 15) == 2 assert count_flips_to_convert(1, 2) == 2 assert count_flips_to_convert(0, 0) == 0 assert count_flips_to_convert(0, 10**9) == count_of_1_bits(10**9) ``` **Note**: Provide the function count_of_1_bits as a sub-problem if required to count the number of 1s in a binary representation of an integer. Hints: 1. Utilize the XOR operation to identify differing bits. 2. Count the number of 1s in the resulting binary representation using efficient bitwise manipulation techniques. Good luck, and write clean, efficient code!","solution":"def count_flips_to_convert(a: int, b: int) -> int: Returns the minimal number of bits required to flip to convert integer `a` to integer `b`. xor = a ^ b count = 0 while xor: count += xor & 1 xor >>= 1 return count"},{"question":"You are given two sparse matrices A and B. Write a function `sparseMatrixMultiply(A, B)` that multiplies these two matrices, assuming that the column number of A is equal to the row number of B. The function should return the resultant matrix C. # Input - `A`: A list of lists where each inner list represents a row of the sparse matrix A. - `B`: A list of lists where each inner list represents a row of the sparse matrix B. # Output - `C`: A list of lists where each inner list represents a row of the resultant matrix C (result of multiplying A with B). # Constraints - You can assume that matrices A and B contain integers. - The dimensions of A and B are such that the number of columns in A equals the number of rows in B. # Performance Requirements - Your function should handle cases with large matrices efficiently by considering the sparsity of the matrices. # Example ```python A = [ [1, 0, 0], [-1, 0, 3] ] B = [ [7, 0, 0], [0, 0, 0], [0, 0, 1] ] print(sparseMatrixMultiply(A, B)) # Output: # [ # [7, 0, 0], # [-7, 0, 3] # ] ``` # Constraints 1 <= len(A), len(B) <= 100 1 <= len(A[0]), len(B[0]) <= 100 Implement the function `sparseMatrixMultiply`: ```python def sparseMatrixMultiply(A, B): :type A: List[List[int]] :type B: List[List[int]] :rtype: List[List[int]] # Your code here ```","solution":"def sparseMatrixMultiply(A, B): Multiplies two sparse matrices A and B. :type A: List[List[int]] :type B: List[List[int]] :rtype: List[List[int]] # Dimensions of the matrices m = len(A) n = len(A[0]) p = len(B[0]) # Resultant matrix with all zeros C = [[0] * p for _ in range(m)] # Performing matrix multiplication considering sparsity for i in range(m): for k in range(n): if A[i][k] != 0: # Only proceed if the element at A[i][k] is non-zero for j in range(p): if B[k][j] != 0: # Only proceed if the element at B[k][j] is non-zero C[i][j] += A[i][k] * B[k][j] return C"},{"question":"# Binary Search Tree: Balanced Insertion In this exercise, you are tasked to extend the existing Binary Search Tree (BST) implementation by ensuring that the tree remains balanced after each insertion. Implement a self-balancing Binary Search Tree using AVL (Adelson-Velsky and Landis) Tree. **Core Requirements**: 1. Modify the `insert` method to include balancing operations. 2. Implement rotations (left, right, left-right, right-left) needed to keep the tree balanced. 3. Ensure the tree maintains the AVL property after each insertion. # Function to Implement ```python class Node: def __init__(self, data): self.data = data self.left = None self.right = None self.height = 1 # Height is initialized to 1 for AVL property. class AVLTree: def __init__(self): self.root = None def insert(self, data): Insert data into the AVL tree and ensure the tree remains balanced. # Your code here def preorder(self, root): # Preorder traversal for testing pass def inorder(self, root): # Inorder traversal for testing pass def postorder(self, root): # Postorder traversal for testing pass ``` # Input and Output Ensure the following functions are correctly defined: `insert(data)`: - **Input**: Integer `data` to insert into the AVL tree. - **Output**: None. The tree should adjust itself to maintain the AVL property internally. `preorder(root)`: - **Input**: `root` node of the AVL tree. - **Output**: Prints preorder traversal (root, left, right) of the entire AVL tree. `inorder(root)`: - **Input**: `root` node of the AVL tree. - **Output**: Prints inorder traversal (left, root, right) of the entire AVL tree. `postorder(root)`: - **Input**: `root` node of the AVL tree. - **Output**: Prints postorder traversal (left, right, root) of the entire AVL tree. # Constraints * The tree should handle at least 10^4 insertions efficiently. * Balanced AVL tree rotation operations should be implemented to maintain the AVL property. # Example You are provided the testing framework. Write tests to validate your implementation of the AVL tree. ```python import unittest class TestAVLTree(unittest.TestCase): def setUp(self): self.tree = AVLTree() def test_insertion(self): # Add tests to insert values ensuring the AVL property. data = [10, 20, 30, 40, 50, 25] for value in data: self.tree.insert(value) self.assertEqual(self.tree.preorder(self.tree.root), [30, 20, 10, 25, 40, 50]) self.assertEqual(self.tree.inorder(self.tree.root), [10, 20, 25, 30, 40, 50]) self.assertEqual(self.tree.postorder(self.tree.root), [10, 25, 20, 50, 40, 30]) if __name__ == \'__main__\': unittest.main() ``` Focus on ensuring that the tree remains balanced after each insertion and preserves its AVL properties.","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None self.height = 1 # Height is initialized to 1 for AVL property. class AVLTree: def __init__(self): self.root = None def get_height(self, node): if not node: return 0 return node.height def get_balance(self, node): if not node: return 0 return self.get_height(node.left) - self.get_height(node.right) def right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = max(self.get_height(z.left), self.get_height(z.right)) + 1 y.height = max(self.get_height(y.left), self.get_height(y.right)) + 1 return y def left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = max(self.get_height(z.left), self.get_height(z.right)) + 1 y.height = max(self.get_height(y.left), self.get_height(y.right)) + 1 return y def insert(self, root, data): if not root: return Node(data) elif data < root.data: root.left = self.insert(root.left, data) else: root.right = self.insert(root.right, data) root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) if balance > 1 and data < root.left.data: return self.right_rotate(root) if balance < -1 and data > root.right.data: return self.left_rotate(root) if balance > 1 and data > root.left.data: root.left = self.left_rotate(root.left) return self.right_rotate(root) if balance < -1 and data < root.right.data: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def insert_data(self, data): self.root = self.insert(self.root, data) def preorder(self, root): res = [] if root: res.append(root.data) res = res + self.preorder(root.left) res = res + self.preorder(root.right) return res def inorder(self, root): res = [] if root: res = res + self.inorder(root.left) res.append(root.data) res = res + self.inorder(root.right) return res def postorder(self, root): res = [] if root: res = res + self.postorder(root.left) res = res + self.postorder(root.right) res.append(root.data) return res"},{"question":"You are designing a secure communication system that heavily relies on cryptographic algorithms. One essential component of your system is Euler\'s Totient Function. You need to implement this function to count how many positive integers up to a specified integer n are coprime to n. **Task:** Write a function `euler_totient(n)` that takes an integer n as input and returns the count of integers between 1 and n which are coprime to n. **Details:** - The function signature is `def euler_totient(n):` - **Input Format:** An integer n (1 ≤ n ≤ 10^6) - **Output Format:** An integer representing the count of integers between 1 and n which are coprime to n. - **Constraints:** Handle cases where n could be very large comfortably. **Example:** - `euler_totient(1)` should return `1` since 1 is coprime with itself. - `euler_totient(2)` should return `1` because only 1 is coprime with 2. - `euler_totient(5)` should return `4` since numbers 1, 2, 3, and 4 are coprime with 5. **Goal:** Ensure the implementation is correct and considers edge cases, performance bottlenecks, and handles the largest possible value of n efficiently. **Evaluation Criteria:** Your function will be evaluated on correctness, efficiency, and code clarity. Make sure to test your solution on various inputs including the edge cases such as small and large values of n.","solution":"def euler_totient(n): Returns the number of integers from 1 to n-1 that are coprime with n. if n == 1: return 1 result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result"},{"question":"Given a non-negative integer n, write a function to compute the n-th Fibonacci number. Your implementation must be efficient and scalable for large values of n. You must implement and compare three different methods: recursive, dynamic programming, and iterative. # Function Signature ```python def compute_fibonacci(n: int) -> tuple: Given a non-negative integer n, returns a tuple containing the n-th Fibonacci number computed by three different methods (recursive, dynamic programming, iterative) for comparison. Arguments: n: int -- a non-negative integer representing the index of the Fibonacci number to compute. Returns: tuple -- a tuple containing the n-th Fibonacci number computed using recursive, dynamic programming, and iterative approaches in the order mentioned (rec, dp, iter). pass ``` # Input - An integer `n` where 0 <= n <= 10^5. # Output - A tuple of three integers: the n-th Fibonacci number computed using the recursive, dynamic programming, and iterative approaches respectively. # Constraints - You must handle large values of n efficiently. - Avoid unnecessary recomputation in your recursive solution using memoization. - The function should assert if the input n is non-negative. # Examples ```python # Input: 5 # Output: (5, 5, 5) # Input: 10 # Output: (55, 55, 55) # Input: 20 # Output: (6765, 6765, 6765) `` # Additional Information - Explain in your implementation comments the differences in performance between the three approaches. - Highlight edge cases and how your function handles them.","solution":"def compute_fibonacci(n: int) -> tuple: Given a non-negative integer n, returns a tuple containing the n-th Fibonacci number computed by three different methods (recursive, dynamic programming, iterative) for comparison. Arguments: n: int -- a non-negative integer representing the index of the Fibonacci number to compute. Returns: tuple -- a tuple containing the n-th Fibonacci number computed using recursive, dynamic programming, and iterative approaches in the order mentioned (rec, dp, iter). assert n >= 0, \\"Input must be a non-negative integer\\" # Method 1: Recursive with memoization memo = {} def fib_recursive(k): if k in memo: return memo[k] if k <= 1: return k memo[k] = fib_recursive(k-1) + fib_recursive(k-2) return memo[k] fib_rec = fib_recursive(n) # Method 2: Dynamic Programming if n == 0: fib_dp = 0 elif n == 1: fib_dp = 1 else: dp = [0] * (n + 1) dp[1] = 1 for i in range(2, n + 1): dp[i] = dp[i-1] + dp[i-2] fib_dp = dp[n] # Method 3: Iterative if n == 0: fib_iter = 0 elif n == 1: fib_iter = 1 else: a, b = 0, 1 for i in range(2, n + 1): a, b = b, a + b fib_iter = b return (fib_rec, fib_dp, fib_iter)"},{"question":"# Question: Implement a RandomizedSet with Efficient Operations **Scenario**: You are tasked with maintaining a dynamic set that supports efficient operations and can quickly return a random element. To achieve this, implement a `RandomizedSet` class that allows insertion, deletion, and random selection of elements, all in average O(1) time complexity. **Function Implementations**: 1. `insert(self, val: int) -> bool`: Inserts an element `val` into the set if not already present. Returns `True` if the element was successfully added, otherwise `False`. 2. `remove(self, val: int) -> bool`: Removes an element `val` from the set if present. Returns `True` if the element was successfully removed, otherwise `False`. 3. `get_random(self) -> int`: Returns a random element from the current set of elements. All elements should have an equal probability of being returned. # Input and Output Formats: - The class should manage the insertion and deletion operations along with random access internally. - Use the following constraints: - All values are integers. - Elements are unique in the set. Example Usage: ```python # Initialize the set randomized_set = RandomizedSet() # Insert elements print(randomized_set.insert(1)) # Returns True print(randomized_set.insert(1)) # Returns False print(randomized_set.insert(2)) # Returns True # Remove elements print(randomized_set.remove(1)) # Returns True print(randomized_set.remove(3)) # Returns False # Get random element print(randomized_set.get_random()) # Should return 2 if only 2 is in the set ``` **Constraints**: - Assume `insert` and `remove` methods are called with valid integer values. - Handle the edge cases where random access is requested on an empty set gracefully with an appropriate return value or error handling mechanism. - Ensure the average time complexity for all operations is O(1).","solution":"import random class RandomizedSet: def __init__(self): self.num_to_idx = {} self.nums = [] def insert(self, val: int) -> bool: if val in self.num_to_idx: return False self.num_to_idx[val] = len(self.nums) self.nums.append(val) return True def remove(self, val: int) -> bool: if val not in self.num_to_idx: return False last_element = self.nums[-1] idx_to_remove = self.num_to_idx[val] self.nums[idx_to_remove] = last_element self.num_to_idx[last_element] = idx_to_remove self.nums.pop() del self.num_to_idx[val] return True def get_random(self) -> int: if not self.nums: raise ValueError(\\"The set is empty\\") return random.choice(self.nums)"},{"question":"Efficient Search Implementation **Scenario**: You have been given the task of optimizing the search functionality for a large uniformly distributed dataset. The current application, which uses binary search, performs adequately but needs enhancements to handle particular use cases with improved performance. Implement a function, `interpolation_search`, to efficiently search for a given key in a sorted array using the interpolation search algorithm. **Function Signature**: ```python def interpolation_search(array: List[int], search_key: int) -> int: pass ``` **Input**: * `array` (List[int]): A sorted list of integers, which may include negative and positive values. * `search_key` (int): The integer value to search for in the array. **Output**: * Returns the index of `search_key` if found in the array, otherwise returns `-1`. **Constraints**: * The array length will be between 0 and 10^5. * The array elements will lie between -10^9 and 10^9. * The search key will lie between -10^9 and 10^9. * All elements in the array are distinct. **Examples**: ```python assert interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) == 2 assert interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) == -1 assert interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) == -1 assert interpolation_search([], 10) == -1 assert interpolation_search([10, 20, 30], 10) == 0 ``` **Edge Cases to Consider**: * The function should handle cases where the array is empty. * When the search key is not present in the array. * When the search key is at the start or end of the array. **Guidelines**: 1. Use the formula provided in the code snippet to calculate the probable position. 2. Ensure that your implementation handles different edge cases like an empty array or key not present. 3. Optimize for performance and correctness as described in the scenario above.","solution":"from typing import List def interpolation_search(array: List[int], search_key: int) -> int: low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 # Probing the position with the formula pos = low + ((search_key - array[low]) * (high - low) // (array[high] - array[low])) # If the element is found at pos if array[pos] == search_key: return pos # If the search_key is larger, search in the right subarray if array[pos] < search_key: low = pos + 1 # If the search_key is smaller, search in the left subarray else: high = pos - 1 return -1"},{"question":"# Scenario A logistics startup tracks the delivery times (in minutes past midnight) of several delivery trucks and needs to sort these times for efficient scheduling. Given these times, you are required to implement a sorting algorithm as described below. # Task Write a function `sorted_delivery_times(times: List[int]) -> List[int]` that uses the Pigeonhole Sort algorithm to sort the given delivery times. # Input - A list of integers `times` where each integer represents a delivery time in minutes past midnight. # Output - A sorted list of delivery times in ascending order. # Constraints - The size of the list `times` will be between 1 and 1000. - Each element in `times` will be an integer between 0 and 1440 (since there are 1440 minutes in a day). # Performance Requirements - The solution should use the Pigeonhole Sort algorithm and run with a time complexity of O(n + Range), where n is the number of elements in the input list, and the range is the difference between the maximum and minimum delivery time. # Example ```python # Example 1 times = [180, 45, 1230, 900, 15] print(sorted_delivery_times(times)) # [15, 45, 180, 900, 1230] # Example 2 times = [1440, 0] print(sorted_delivery_times(times)) # [0, 1440] # Example 3 times = [120, 60, 30, 0] print(sorted_delivery_times(times)) # [0, 30, 60, 120] ``` # Implementation Implement the function `sorted_delivery_times` using the given Pigeonhole Sort algorithm.","solution":"def sorted_delivery_times(times): Sorts a list of delivery times using the Pigeonhole Sort algorithm. Args: times (List[int]): A list of delivery times in minutes past midnight. Returns: List[int]: The sorted list of delivery times in ascending order. if not times: return [] # Find the minimum and maximum values in the list min_time = min(times) max_time = max(times) # Create an array of \\"pigeonholes\\" for each possible time value within the range range_of_times = max_time - min_time + 1 pigeonholes = [0] * range_of_times # Populate the pigeonholes for time in times: pigeonholes[time - min_time] += 1 # Reconstruct the sorted list from the pigeonholes sorted_list = [] for i in range(range_of_times): while pigeonholes[i] > 0: sorted_list.append(i + min_time) pigeonholes[i] -= 1 return sorted_list"},{"question":"**Context:** You are working with a large dataset and you need a data structure that allows for efficient insertions, deletions, and search operations. To achieve this, you decide to use a Red-Black Tree (RB Tree), a balanced binary search tree that guarantees these operations in logarithmic time. **Question:** Implement a Red-Black Tree that supports the following operations: Insertion, Deletion, and Inorder Traversal. Specifically, you need to: 1. Implement the insertion method adhering to the red-black properties. 2. Implement the deletion method ensuring the tree remains balanced and follows the red-black properties. 3. Implement an inorder traversal method that returns nodes in ascending order of values. # Function Signatures: ```python class RBNode: def __init__(self, val, is_red, parent=None, left=None, right=None): self.val = val self.parent = parent self.left = left self.right = right self.color = is_red class RBTree: def __init__(self): self.root = None def insert(self, node: RBNode): Insert the given node into the Red-Black Tree. pass def delete(self, node: RBNode): Delete the given node from the Red-Black Tree. pass def inorder(self) -> list: Perform an inorder traversal of the Red-Black Tree. Return a list of nodes represented as dictionaries with their values and color. pass ``` # Constraints: - Assume node values are unique integers. - Colors are indicated using 0 for black and 1 for red. - The tree allows for dynamic updates with multiple insertions and deletions. # Example Usage: ```python rb = RBTree() nodes = [11, 2, 14, 1, 7, 15, 5, 8, 4] rb_nodes = [RBNode(val, 1) for val in nodes] # Inserting nodes for node in rb_nodes: rb.insert(node) print(rb.inorder()) # Should print nodes in ascending order with their colors. # Deleting a node rb.delete(rb_nodes[3]) # Deleting the node with value 1 print(rb.inorder()) # Should reflect the tree after deletion. ``` Your implementation should ensure the red-black properties are maintained after each insertion and deletion.","solution":"class RBNode: def __init__(self, val, is_red=True, parent=None, left=None, right=None): self.val = val self.parent = parent self.left = left self.right = right self.color = is_red # True for red, False for black class RBTree: def __init__(self): self.TNULL = RBNode(0) self.TNULL.color = False self.TNULL.left = None self.TNULL.right = None self.root = self.TNULL def insert(self, key): node = RBNode(key) node.parent = None node.val = key node.left = self.TNULL node.right = self.TNULL node.color = True parent_node = None current_node = self.root while current_node != self.TNULL: parent_node = current_node if node.val < current_node.val: current_node = current_node.left else: current_node = current_node.right node.parent = parent_node if parent_node == None: self.root = node elif node.val < parent_node.val: parent_node.left = node else: parent_node.right = node if node.parent == None: node.color = False return if node.parent.parent == None: return self.fix_insert(node) def fix_insert(self, k): while k.parent.color == True: if k.parent == k.parent.parent.right: u = k.parent.parent.left if u.color == True: u.color = False k.parent.color = False k.parent.parent.color = True k = k.parent.parent else: if k == k.parent.left: k = k.parent self.right_rotate(k) k.parent.color = False k.parent.parent.color = True self.left_rotate(k.parent.parent) else: u = k.parent.parent.right if u.color == True: u.color = False k.parent.color = False k.parent.parent.color = True k = k.parent.parent else: if k == k.parent.right: k = k.parent self.left_rotate(k) k.parent.color = False k.parent.parent.color = True self.right_rotate(k.parent.parent) if k == self.root: break self.root.color = False def delete(self, key): self._delete_node_helper(self.root, key) def _delete_node_helper(self, node, key): z = self.TNULL while node != self.TNULL: if node.val == key: z = node if node.val <= key: node = node.right else: node = node.left if z == self.TNULL: print(\\"Couldn\'t find key in the tree\\") return y = z y_original_color = y.color if z.left == self.TNULL: x = z.right self._rb_transplant(z, z.right) elif z.right == self.TNULL: x = z.left self._rb_transplant(z, z.left) else: y = self.minimum(z.right) y_original_color = y.color x = y.right if y.parent == z: x.parent = y else: self._rb_transplant(y, y.right) y.right = z.right y.right.parent = y self._rb_transplant(z, y) y.left = z.left y.left.parent = y y.color = z.color if y_original_color == False: self.fix_delete(x) def fix_delete(self, x): while x != self.root and x.color == False: if x == x.parent.left: s = x.parent.right if s.color == True: s.color = False x.parent.color = True self.left_rotate(x.parent) s = x.parent.right if s.left.color == False and s.right.color == False: s.color = True x = x.parent else: if s.right.color == False: s.left.color = False s.color = True self.right_rotate(s) s = x.parent.right s.color = x.parent.color x.parent.color = False s.right.color = False self.left_rotate(x.parent) x = self.root else: s = x.parent.left if s.color == True: s.color = False x.parent.color = True self.right_rotate(x.parent) s = x.parent.left if s.left.color == False and s.right.color == False: s.color = True x = x.parent else: if s.left.color == False: s.right.color = False s.color = True self.left_rotate(s) s = x.parent.left s.color = x.parent.color x.parent.color = False s.left.color = False self.right_rotate(x.parent) x = self.root x.color = False def _rb_transplant(self, u, v): if u.parent == None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def minimum(self, node): while node.left != self.TNULL: node = node.left return node def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y def inorder_helper(self, node, result): if node != self.TNULL: self.inorder_helper(node.left, result) result.append({\'val\': node.val, \'color\': 1 if node.color else 0}) self.inorder_helper(node.right, result) def inorder(self): result = [] self.inorder_helper(self.root, result) return result"},{"question":"You are tasked with implementing a custom stack that tracks the minimum element. Specifically, you need to enhance a stack so that it supports the basic stack operations (`push`, `pop`, `peek`, and `is_empty`), as well as an additional operation `get_min` which returns the minimum element in the stack in constant time. # Your task Implement the `MinStack` class, which extends either the `ArrayStack` or `LinkedListStack` class (defined in the given code snippets) and adds the `get_min` method. # Requirements: 1. **push(x)**: Push element `x` onto the stack. 2. **pop()**: Removes the element on the top of the stack. 3. **peek()**: Get the top element. 4. **is_empty()**: Returns whether the stack is empty. 5. **get_min()**: Retrieve the minimum element in the stack in constant time. # Input and Output format: - You will implement the `MinStack` class containing the following methods: ```python class MinStack: def __init__(self): # initialize your stack structure here pass def push(self, x: int) -> None: # code to push `x` onto the stack pass def pop(self) -> int: # code to remove the top element pass def peek(self) -> int: # code to get the top element pass def is_empty(self) -> bool: # code to check if the stack is empty pass def get_min(self) -> int: # code to retrieve the minimum element pass ``` # Constraints: - You must extend either the `ArrayStack` or `LinkedListStack`. - Operations must be performed in O(1) time complexity for `push`, `pop`, `peek`, `is_empty`, and `get_min`. - The stack will only contain integer values. # Example: ```python stack = MinStack() stack.push(-2) stack.push(0) stack.push(-3) print(stack.get_min()) # Returns -3 stack.pop() print(stack.peek()) # Returns 0 print(stack.get_min()) # Returns -2 ```","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, x: int) -> None: self.stack.append(x) # If the min_stack is empty or the new element is smaller than or equal to the top, push it to the min_stack. if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> int: if self.stack: top = self.stack.pop() # If the popped element is the same as the top of min_stack, pop it from min_stack. if top == self.min_stack[-1]: self.min_stack.pop() return top def peek(self) -> int: if self.stack: return self.stack[-1] def is_empty(self) -> bool: return len(self.stack) == 0 def get_min(self) -> int: if self.min_stack: return self.min_stack[-1]"},{"question":"# Challenge: You are given an undirected graph represented by an adjacency list. Write a function to determine if the graph is bipartite. You may assume that the graph is connected. Function Signature: ```python def is_bipartite(graph: Dict[int, List[int]]) -> bool: pass ``` Input: * `graph`: A dictionary where keys are vertex identifiers (integers), and values are lists of integers representing the adjacent vertices. * Vertex identifiers will be consecutive integers starting from 0. Output: * `True` if the graph is bipartite, `False` otherwise. Example: ```python input_graph = { 0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2] } print(is_bipartite(input_graph)) # Output: True ``` Constraints: * The number of vertices |V| will be at most 1000. * The number of edges |E| will be at most 10000. * No vertex will have more than 1000 edges. * The input will not necessarily be a connected graph, so account for all components. Notes: * Ensure you handle graphs with multiple connected components. * Consider graphs with no edges or just one vertex. * Optimize your solution to avoid unnecessary computations for large graphs. Good luck!","solution":"from typing import Dict, List from collections import deque def is_bipartite(graph: Dict[int, List[int]]) -> bool: color = {} for node in graph: if node not in color: queue = deque([node]) color[node] = 0 while queue: current = queue.popleft() current_color = color[current] for neighbor in graph[current]: if neighbor not in color: color[neighbor] = 1 - current_color queue.append(neighbor) elif color[neighbor] == current_color: return False return True"},{"question":"# Matrix Inversion Problem Given an ( n times n ) matrix, you need to write a Python function that returns the inverse of that matrix using the steps provided. If the matrix is not invertible, your function should return a specific error code based on the following conditions: - `-1` if the array is not a matrix. - `-2` if the matrix is not square. - `-3` if the matrix is too small (less than 2x2). - `-4` if the matrix is singular (determinant is zero). # Function Definition ```python def invert_matrix(matrix: list) -> list: Inverts a given n x n matrix. Returns an n x n inverted matrix or an error code if it is not invertible. Parameters: matrix (list): A list of lists representing the n x n matrix. Returns: list: An n x n matrix representing the inverse or an error code as described. ``` # Example ```python matrix = [ [4, 7], [2, 6] ] print(invert_matrix(matrix)) # Output: [[0.6, -0.7], [-0.2, 0.4]] ``` # Constraints - The matrix should be an ( n times n ) list of lists with integers or float values. - You must not use any built-in libraries for matrix operations or inversion. # Expected Input and Output - **Input**: The input consists of an ( n times n ) matrix represented as a list of lists. - **Output**: The output should be either an ( n times n ) matrix representing the inverse of the input matrix or an error code specified earlier. # Notes - Consider edge cases such as non-square matrices, singular matrices, or matrices of size less than 2x2. - Ensure to handle floating-point arithmetic carefully to avoid precision errors.","solution":"import copy def invert_matrix(matrix): def is_square(matrix): return all(len(row) == len(matrix) for row in matrix) def matrix_minor(matrix, i, j): minor = copy.deepcopy(matrix) minor = minor[:i] + minor[i+1:] for row in range(len(minor)): minor[row] = minor[row][:j] + minor[row][j+1:] return minor def matrix_det(matrix): if len(matrix) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(len(matrix)): det += ((-1) ** c) * matrix[0][c] * matrix_det(matrix_minor(matrix, 0, c)) return det def matrix_inverse(matrix): determinant = matrix_det(matrix) if determinant == 0: return -4 if len(matrix) == 2: return [ [matrix[1][1] / determinant, -1 * matrix[0][1] / determinant], [-1 * matrix[1][0] / determinant, matrix[0][0] / determinant] ] cofactors = [] for r in range(len(matrix)): cofactor_row = [] for c in range(len(matrix)): minor = matrix_minor(matrix, r, c) cofactor_row.append(((-1) ** (r + c)) * matrix_det(minor)) cofactors.append(cofactor_row) cofactors = [[cofactors[c][r] for c in range(len(cofactors))] for r in range(len(cofactors))] for r in range(len(cofactors)): for c in range(len(cofactors)): cofactors[r][c] = cofactors[r][c] / determinant return cofactors if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): return -1 if not is_square(matrix): return -2 if len(matrix) < 2 or len(matrix[0]) < 2: return -3 return matrix_inverse(matrix)"},{"question":"# Unique Integer Detection with Bit Manipulation Scenario In advanced data processing systems, redundancy is often exploited to ensure fault tolerance. However, equally important is the ability to identify unique errors or outliers. Imagine you are tasked with processing a stream of integer data where every integer is expected to appear exactly three times, except for a single integer that appears only once. Identifying this unique integer accurately and efficiently is critical for system reliability. Problem Statement Given a list of integers where every element appears three times except for one, which appears exactly once, write a function `find_unique_number(nums: List[int]) -> int` to find and return the single occurring integer. Input and Output Formats - **Input**: - `nums`: List of integers with the property described above (1 <= len(nums) <= 10^6, -2^31 <= nums[i] <= 2^31 - 1). - **Output**: - Returns the integer that appears exactly once. Constraints - The function should run in linear time, O(n). - No extra memory, such as additional data structures, should be used other than a few integer variables. Examples 1. **Example 1**: - Input: `nums = [2, 2, 3, 2]` - Output: `3` - Explanation: Every element appears three times except for 3 which appears only once. 2. **Example 2**: - Input: `nums = [0, 1, 0, 1, 0, 1, 99]` - Output: `99` - Explanation: Every element appears three times except for 99 which appears only once. 3. **Example 3**: - Input: `nums = [-2, -2, -2, -5]` - Output: `-5` - Explanation: Every element appears three times except for -5 which appears only once. Function Signature ```python def find_unique_number(nums: List[int]) -> int: # your implementation here pass ``` Solution Consideration You are required to use the principles of bit manipulation as illustrated in the provided code snippet. Ensure your solution follows the constraints and handles edge cases appropriately. Good luck!","solution":"from typing import List def find_unique_number(nums: List[int]) -> int: Find the element that appears only once in a list where all others appear three times. This function uses bitwise operators to keep track of bits appearing once and twice. one = 0 two = 0 for num in nums: # First appearance: add num to one. # Second appearance: remove num from one, add num to two. # Third appearance: remove num from two. two = two | (one & num) one = one ^ num three = one & two one = one & ~three two = two & ~three return one"},{"question":"# Scenario: You\'re working on a text analysis tool, and you need to implement an efficient pattern matching algorithm. You chose the Rabin-Karp algorithm due to its potential average-case efficiency. # Description: Implement the Rabin-Karp algorithm to search for the first occurrence of a word in a given text string. Your implementation should handle edge cases and efficiently compute the rolling hash values. # Task: Write a function `rabin_karp_search(word, text)` that returns the starting index of the first occurrence of `word` in `text`. If `word` is not found in `text`, return -1. # Input/Output: * **Input**: * `word` (str): The pattern to be searched (non-empty string with length up to 1000). * `text` (str): The text in which to search (string with length up to 100000). * **Output**: * (int): The starting index of the first occurrence. If the word is not found, return -1. # Constraints: * The function should handle large texts efficiently. * Assume lowercase English letters for `word` and `text`. # Example: ```python def rabin_karp_search(word, text): # Your implementation here # Example usage: print(rabin_karp_search(\\"abc\\", \\"defabc\\")) # Output: 3 print(rabin_karp_search(\\"xyz\\", \\"abcdef\\")) # Output: -1 print(rabin_karp_search(\\"a\\", \\"a\\")) # Output: 0 print(rabin_karp_search(\\"a\\", \\"\\")) # Output: -1 print(rabin_karp_search(\\"\\", \\"a\\")) # Output: -1 print(rabin_karp_search(\\"pattern\\", \\"this is a test for pattern matching\\")) # Output: 18 ``` # Requirements: * Implement the Rabin-Karp algorithm as described, utilizing a rolling hash. * Consider edge cases such as empty strings and negligible pattern lengths. * Optimize for performance with focus on reducing unnecessary computations and handling large inputs efficiently.","solution":"def rabin_karp_search(word, text): if not word or not text: return -1 word_len = len(word) text_len = len(text) if word_len > text_len: return -1 base = 256 prime_mod = 101 def compute_hash(s, length): h = 0 for i in range(length): h = (h * base + ord(s[i])) % prime_mod return h word_hash = compute_hash(word, word_len) text_hash = compute_hash(text[:word_len], word_len) highest_base = pow(base, word_len - 1, prime_mod) for i in range(text_len - word_len + 1): if word_hash == text_hash: if text[i:i + word_len] == word: return i if i < text_len - word_len: text_hash = (text_hash - ord(text[i]) * highest_base) * base + ord(text[i + word_len]) text_hash = text_hash % prime_mod if text_hash < 0: text_hash += prime_mod return -1"},{"question":"# Rotated Sorted Array Minimum Finder **Objective**: You are given a sorted array that has been rotated at an unknown pivot. Implement a function that finds the minimum element in the array. Your implementation must achieve O(log N) time complexity. **Context**: Given an array of unique integers that was originally sorted in ascending order, where some unknown pivot point has rotated the array, you are asked to find the minimum element quickly. **Function Signature**: ```python def find_min_ignore_duplicates(arr: List[int]) -> int: pass ``` **Input**: * `arr` (List[int]): A list of unique integers representing a rotated sorted array. * 1 <= len(arr) <= 10^5 * All integers in the array are unique. **Output**: * `int`: The minimum element in the array. **Constraints**: * You may assume no duplicate elements exist in the array. * The array size must be handled efficiently within the given constraints. **Performance Requirements**: * The function must be optimized to run in O(log N) time complexity. **Example**: ```python # Example 1: arr = [4, 5, 6, 7, 0, 1, 2] Output: 0 # Example 2: arr = [1] Output: 1 # Example 3: arr = [2, 3, 4, 5, 6, 1] Output: 1 # Example 4: arr = [3, 4, 5, 1, 2] Output: 1 ``` **Guidelines**: 1. Understand the behavior of binary search. 2. Think about how to adjust binary search to handle the rotated sorted condition. 3. Minimize your search space efficiently by comparing mid elements with high or low bounds. **Edge Cases to Test**: * The array with only one element. * The array not rotated at all. * The minimum element is at the pivot position.","solution":"from typing import List def find_min_ignore_duplicates(arr: List[int]) -> int: Finds the minimum element in a rotated sorted array. :param arr: List of unique integers representing a rotated sorted array. :return: The minimum element in the array. left, right = 0, len(arr) - 1 # If the array is not rotated (the smallest element is at index 0) if arr[left] < arr[right]: return arr[left] while left < right: mid = (left + right) // 2 # If mid element is greater than the rightmost element, # the minimum must be in the right part of the array if arr[mid] > arr[right]: left = mid + 1 else: # Otherwise, the minimum is in the left part including mid right = mid # When left == right, we have found the smallest element return arr[left]"},{"question":"You are tasked with implementing a function that simulates regular expression matching with support for `.` and `*`. The function should determine whether a given input string `s` matches a given pattern `p`. The matching should cover the entire input string. # Function Signature ```python def is_match(s: str, p: str) -> bool: ``` # Input * `s` (1 <= |s| <= 1000): A string containing the characters to be matched. * `p` (1 <= |p| <= 1000): A pattern string containing the characters to match against, which may include `.` and `*`. # Output * Returns `True` if string `s` matches pattern `p`. Otherwise, returns `False`. # Constraints * `.` Matches any single character. * `*` Matches zero or more of the preceding element. * The matching should cover the entire input string (not partial). # Example ```python assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"aa\\", \\"aa\\") == True assert is_match(\\"aaa\\", \\"aa\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"aa\\", \\".*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True ``` # Guidelines Provide an efficient implementation that leverages dynamic programming to address the problem. Consider the outlined edge cases and ensure your code handles them gracefully. Optimize for both correctness and performance.","solution":"def is_match(s: str, p: str) -> bool: m, n = len(s), len(p) # Initialize DP table with False dp = [[False] * (n + 1) for _ in range(m + 1)] # Empty string matches empty pattern dp[0][0] = True # Handle patterns like a*, a*b*, a*b*c*, etc. for j in range(1, n + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] if p[j - 2] == \'.\' or p[j - 2] == s[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] return dp[m][n]"},{"question":"# Anagram Tester In a game of competitive word rearrangement, players need to verify whether given pairs of words are anagrams of each other. An anagram of a word is another word formed by reordering the letters of the original word. You have been asked to develop the core functionality for this game. Task Write a function `are_anagrams` that takes two strings `s1` and `s2` and returns `True` if the strings are anagrams of each other, and `False` otherwise. # Requirements * You may only use lowercase English letters (\'a\' to \'z\'). * You must achieve time complexity of O(n), where n is the length of the longest string. * You must achieve space complexity of O(1) beyond the input data. # Constraints * 1 ≤ len(s1), len(s2) ≤ 10^5 * Both strings contain only lowercase English letters. # Input Format * `s1` (str): A string consisting of lowercase letters. * `s2` (str): A string consisting of lowercase letters. # Output Format * `bool`: `True` if `s1` and `s2` are anagrams, `False` otherwise. # Examples ``` are_anagrams(\\"apple\\", \\"pleap\\") -> True are_anagrams(\\"apple\\", \\"cherry\\") -> False are_anagrams(\\"listen\\", \\"silent\\") -> True are_anagrams(\\"forge\\", \\"forged\\") -> False ``` # Function Signature ```python def are_anagrams(s1: str, s2: str) -> bool: # Your code here ``` **Note**: Please handle edge cases such as different lengths of strings appropriately.","solution":"def are_anagrams(s1: str, s2: str) -> bool: Returns True if s1 and s2 are anagrams of each other, False otherwise. if len(s1) != len(s2): return False count = [0] * 26 # Since there are 26 lowercase English letters for char in s1: count[ord(char) - ord(\'a\')] += 1 for char in s2: count[ord(char) - ord(\'a\')] -= 1 for c in count: if c != 0: return False return True"},{"question":"Sparse Stream Recovery **Introduction**: You are given a real-time sensor network where values are monitored and reported. Occasionally, some readings are positive (+) and some are negative (-). Your task is to check if a stream of sensor readings results in exactly one unique non-zero value when all the values cancel each other out. If the stream results in only one single non-zero value at the end, return that value. Otherwise, return `None`. **Input Format**: A list of tuples where each tuple contains: 1. An integer value (`val`) which is strictly non-negative. 2. A character (`sign`) which can either be `+` or `-`. **Output Format**: An integer representing the unique value if the stream is 1-sparse, or `None` if no such unique value exists. **Constraints**: 1. The input stream length will be between 1 and 100,000 tuples. 2. Each value in the tuples will be an integer between 0 and 1,000,000. **Example**: ```python # Example 1: input_stream = [(4, \'+\'), (2, \'+\'), (2, \'-\'), (4, \'+\'), (3, \'+\'), (3, \'-\')] print(sparse_recovery(input_stream)) # Output: 4 # Example 2: input_stream = [(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\')] print(sparse_recovery(input_stream)) # Output: 2 # Example 3: input_stream = [(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (1, \'+\')] print(sparse_recovery(input_stream)) # Output: None ``` **Function Signature**: ```python def sparse_recovery(array): pass ``` **Note**: 1. Your function should efficiently determine with a single pass through the data whether it is 1-sparse. 2. Optimize for both time and space, considering the constraints of stream length and potential value sizes.","solution":"def sparse_recovery(array): Determines if the stream of sensor readings results in exactly one unique non-zero value when all values cancel each other out. Parameters: array (list of tuples): List where each tuple contains an integer value and a \'+\' or \'-\' sign. Returns: int or None: The unique non-zero value if the stream is 1-sparse, otherwise None. counter = {} for value, sign in array: if sign == \'+\': if value in counter: counter[value] += 1 else: counter[value] = 1 elif sign == \'-\': if value in counter: counter[value] -= 1 if counter[value] == 0: del counter[value] else: counter[value] = -1 if len(counter) == 1: return next(iter(counter)) else: return None"},{"question":"**Objective**: Demonstrate understanding of sorting algorithms and their efficiency. **Context**: Bogo Sort is an intentionally inefficient sorting algorithm that works by repeatedly shuffling the array until it happens to be in order. Despite its inefficiency, it provides a good educational example of how randomization can affect algorithm performance. **Task**: Write a function `efficient_bogo_sort(arr)` that attempts to improve upon the Bogo Sort algorithm. Rather than relying purely on random shuffling, your version should: 1. Recognize subarrays that are already sorted and avoid shuffling them. 2. Implement a mechanism to reduce the range of elements being shuffled, thereby minimizing pointless operations. **Function Signature**: ```python def efficient_bogo_sort(arr: [int]) -> [int]: pass ``` **Input**: - A list of integers `arr` with length `n` where 1 ≤ n ≤ 1000. **Output**: - Return a new list of integers that contains the sorted elements of `arr`. **Constraints**: - The input list can contain negative numbers and duplicates. - Do not use built-in sort functions or other high-efficiency sorting algorithms within `efficient_bogo_sort`. **Performance Requirements**: - Given that Bogo Sort is inherently inefficient, there are no stringent performance requirements. However, the solution should be measurably more efficient than naive Bogo Sort implementations on average. **Example**: ```python print(efficient_bogo_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5])) # Output should be [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] ``` > Hint: Consider implementing a function to check and retain sorted subarrays and only shuffle unsorted parts until the entire array is sorted.","solution":"import random def is_sorted(arr): Helper function to check if an array is sorted. return all(arr[i] <= arr[i+1] for i in range(len(arr) - 1)) def efficient_bogo_sort(arr): Attempts to improve upon the Bogo Sort algorithm by recognizing sorted subarrays and only shuffling the unsorted parts of the array until the whole array is sorted. if len(arr) <= 1: return arr while not is_sorted(arr): start, end = 0, len(arr) - 1 # Identify the sorted subarray at the beginning while start < len(arr) - 1 and arr[start] <= arr[start + 1]: start += 1 # Identify the sorted subarray at the end while end > 0 and arr[end] >= arr[end - 1]: end -= 1 # Shuffle the unsorted part if start < end: unsorted_part = arr[start:end + 1] random.shuffle(unsorted_part) arr[start:end + 1] = unsorted_part return arr"},{"question":"# Scenario You are working on a search feature for a large database that allows users to search through sorted lists quickly. One common query is finding the last occurrence of a specific value within these lists. To ensure optimal performance, your implementation needs to use the binary search technique. # Task Implement a function `find_last_occurrence` that locates the last occurrence of a specified value in a sorted integer array using the binary search algorithm. # Function Signature ```python def find_last_occurrence(arr: List[int], target: int) -> int: pass ``` # Input - `arr`: A list of integers sorted in non-decreasing order. - `target`: An integer value to find the last occurrence of. # Output - Return the index of the last occurrence of `target` in `arr`. - If `target` is not found in `arr`, return -1. # Constraints - The length of `arr` is in the range [0, 10^5]. - The elements in `arr` and `target` are in the range [-10^5, 10^5]. # Example ```python assert find_last_occurrence([1, 2, 2, 2, 3, 4, 5], 2) == 3 assert find_last_occurrence([1, 2, 2, 2, 3, 4, 5], 3) == 4 assert find_last_occurrence([1, 2, 2, 2, 3, 4, 5], 6) == -1 assert find_last_occurrence([], 2) == -1 ``` # Notes Ensure your implementation handles edge cases such as: - Empty arrays. - Arrays with all same values. - Arrays where the target is not present.","solution":"def find_last_occurrence(arr, target): Function to find the last occurrence of a specified value in a sorted list using binary search. :param arr: List of integers sorted in non-decreasing order. :param target: The integer value to find the last occurrence of. :return: The index of the last occurrence of target in arr, or -1 if the target is not found. lo, hi = 0, len(arr) - 1 result = -1 while lo <= hi: mid = (lo + hi) // 2 if arr[mid] == target: result = mid # Found target, update result with the current index lo = mid + 1 # Move right to find the last occurrence elif arr[mid] < target: lo = mid + 1 else: hi = mid - 1 return result"},{"question":"You are given a scenario where you need to work on large sparse vectors (vectors that contain many zero elements). Your task is to design a data structure and implement a function to compute the dot product of two such sparse vectors efficiently. Objective Implement the following two functions: 1. `vector_to_index_value_list(vector: List[float]) -> List[Tuple[int, float]]`: Convert a given sparse vector to a list of index-value pairs, where each pair represents a non-zero element in the vector. 2. `dot_product(iv_list1: List[Tuple[int, float]], iv_list2: List[Tuple[int, float]]) -> float`: Compute the dot product of two vectors given their index-value pair lists. Function Signatures ```python from typing import List, Tuple def vector_to_index_value_list(vector: List[float]) -> List[Tuple[int, float]]: pass def dot_product(iv_list1: List[Tuple[int, float]], iv_list2: List[Tuple[int, float]]) -> float: pass ``` Input & Output - **vector_to_index_value_list()**: - **Input**: A list of floats representing a sparse vector. - **Output**: A list of tuples, where each tuple contains an index (int) and value (float) representing non-zero elements in the input vector. - **dot_product()**: - **Input**: Two lists of index-value pairs representing non-zero elements of two sparse vectors. - **Output**: A float representing the dot product of the vectors. Constraints - The vectors can be very large (up to (10^6) elements), with most elements being zero. - Each vector can have up to (10^5) non-zero elements. Example ```python # Example 1 vector1 = [1.0, 2.0, 0.0, 0.0, 3.0] vector2 = [0.0, 2.0, 0.0, 4.0, 0.0] iv_list1 = vector_to_index_value_list(vector1) # iv_list1 should be [(0, 1.0), (1, 2.0), (4, 3.0)] iv_list2 = vector_to_index_value_list(vector2) # iv_list2 should be [(1, 2.0), (3, 4.0)] result = dot_product(iv_list1, iv_list2) # result should be 4.0 (since 2.0 * 2.0 + 0 + 0 = 4.0) # Example 2 vector1 = [0.0, 0.0, 0.0] vector2 = [0.0, 0.0, 0.0] iv_list1 = vector_to_index_value_list(vector1) # iv_list1 should be [] iv_list2 = vector_to_index_value_list(vector2) # iv_list2 should be [] result = dot_product(iv_list1, iv_list2) # result should be 0.0 ``` Note * Ensure your implementation handles edge cases, such as empty vectors or vectors with all zero elements. * Consider the time and space efficiency of your solution, especially for large input sizes.","solution":"from typing import List, Tuple def vector_to_index_value_list(vector: List[float]) -> List[Tuple[int, float]]: Converts a given sparse vector to a list of index-value pairs, where each pair represents a non-zero element in the vector. return [(i, val) for i, val in enumerate(vector) if val != 0] def dot_product(iv_list1: List[Tuple[int, float]], iv_list2: List[Tuple[int, float]]) -> float: Computes the dot product of two vectors given their index-value pair lists. index_value_map1 = dict(iv_list1) index_value_map2 = dict(iv_list2) result = 0.0 for index, value in index_value_map1.items(): if index in index_value_map2: result += value * index_value_map2[index] return result"},{"question":"# Question Context You are given a binary tree, and you need to find the deepest node that is the left child of its parent node. This problem aims to test your understanding of tree traversal and your ability to manage properties like depth during traversal. Task Write a function `find_deepest_left(root: TreeNode) -> Optional[int]` that takes the root node of a binary tree and returns the value of the deepest node that is the left child of its parent node. If no such node exists, return `None`. Function Signature ```python from typing import Optional class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def find_deepest_left(root: TreeNode) -> Optional[int]: # Your code here ``` Input * `root`: The root of the binary tree (it can be null). Output * The value of the deepest left child node (`int`) or `None` if no such node exists. Examples ```python # Example 1 # Input Tree: # 1 # / # 2 3 # / # 4 5 6 # # 7 # Output: 4 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.right = TreeNode(6) root.right.right.right = TreeNode(7) assert find_deepest_left(root) == 4 # Example 2 # Input Tree: # 1 # Output: None root = TreeNode(1) assert find_deepest_left(root) == None ``` Constraints * The number of nodes in the binary tree is in the range [0, 10^4]. * The values of the nodes are unique and in the range [-10^5, 10^5]. Notes * Consider edge cases such as a tree with no left children or a single-node tree. * Optimize for both time and space complexity.","solution":"from typing import Optional, Tuple class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def find_deepest_left(root: TreeNode) -> Optional[int]: if not root: return None # Helper function to perform DFS and track depth & whether node is left child def dfs(node: TreeNode, depth: int, is_left: bool) -> Tuple[int, int]: # returns (depth, value) if not node: return (-1, None) # If it\'s a left child and it\'s a leaf, return its depth and value if not node.left and not node.right and is_left: return (depth, node.val) left_depth_val = dfs(node.left, depth + 1, True) right_depth_val = dfs(node.right, depth + 1, False) # Return the deeper left child if left_depth_val[0] > right_depth_val[0]: return left_depth_val return right_depth_val # Start DFS from root deepest_left = dfs(root, 0, False) return deepest_left[1]"},{"question":"# Problem Description You are tasked with implementing a subset of operations on a B-tree data structure, often used in databases and filesystems. Specifically, you need to implement functions for insertion, deletion, and searching of keys in the B-tree. # BTree Class Methods **Method 1: `__init__(self, t_val=2)`** * **Description**: Initializes the B-tree with a specified degree, `t_val`. * **Input**: * `t_val` (int): The degree of the B-tree which determines the minimum number of keys in each node. * **Output**: N/A **Method 2: `insert_key(self, key)`** * **Description**: Insert a key into the B-tree, maintaining the properties of the B-tree. * **Input**: * `key` (int): The key to be inserted. * **Output**: N/A **Method 3: `remove_key(self, key)`** * **Description**: Remove a key from the B-tree, maintaining the properties of the B-tree. * **Input**: * `key` (int): The key to be removed. * **Output**: N/A **Method 4: `find(self, key)`** * **Description**: Search for a key in the B-tree. * **Input**: * `key` (int): The key to be searched. * **Output**: * `bool`: True if the key is found, otherwise False. **Method 5: `traverse_tree(self)`** * **Description**: Print all keys in the B-tree in sorted order. * **Input**: N/A * **Output**: N/A # Function Signature ```python class Node: def __init__(self): self.keys = [] self.children = [] @property def is_leaf(self): return len(self.children) == 0 class BTree: def __init__(self, t_val=2): self.min_numbers_of_keys = t_val - 1 self.max_number_of_keys = 2 * t_val - 1 self.root = Node() def insert_key(self, key): pass def remove_key(self, key): pass def find(self, key): pass def traverse_tree(self): pass ``` # Constraints 1. `t_val` will be a positive integer greater than 1. 2. Only unique integer keys will be inserted. # Example ```python btree = BTree(t_val=3) btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) btree.insert_key(6) btree.insert_key(12) btree.insert_key(30) btree.insert_key(7) btree.insert_key(17) print(btree.find(6)) # True print(btree.find(15)) # False btree.traverse_tree() # Output: 5 6 7 10 12 17 20 30 btree.remove_key(6) print(btree.find(6)) # False btree.traverse_tree() # Output: 5 7 10 12 17 20 30 ``` # Note You are not required to implement the internal private methods (e.g., `_split_child`, `_repair_tree`) directly unless necessary to maintain the B-tree properties. Ensure that your implementation of `insert_key`, `remove_key`, `find`, and `traverse_tree` are correct and efficient with respect to the B-tree properties and structure.","solution":"class Node: def __init__(self): self.keys = [] self.children = [] @property def is_leaf(self): return len(self.children) == 0 class BTree: def __init__(self, t_val=2): self.min_numbers_of_keys = t_val - 1 self.max_number_of_keys = 2 * t_val - 1 self.t = t_val self.root = Node() def insert_key(self, key): root = self.root if len(root.keys) == self.max_number_of_keys: new_root = Node() new_root.children.append(self.root) self._split_child(new_root, 0) self.root = new_root self._insert_non_full(self.root, key) def remove_key(self, key): self._remove(self.root, key) if not self.root.keys: if not self.root.is_leaf: self.root = self.root.children[0] else: self.root = Node() def find(self, key): return self._find(self.root, key) def traverse_tree(self): self._traverse(self.root) print() def _split_child(self, parent, index): child = parent.children[index] new_child = Node() parent.children.insert(index + 1, new_child) mid_index = len(child.keys) // 2 parent.keys.insert(index, child.keys[mid_index]) new_child.keys = child.keys[mid_index + 1:] child.keys = child.keys[:mid_index] if not child.is_leaf: new_child.children = child.children[mid_index + 1:] child.children = child.children[:mid_index + 1] def _insert_non_full(self, node, key): if node.is_leaf: node.keys.append(key) node.keys.sort() else: i = len(node.keys) - 1 while i >= 0 and key < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == self.max_number_of_keys: self._split_child(node, i) if key > node.keys[i]: i += 1 self._insert_non_full(node.children[i], key) def _find(self, node, key): i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if i < len(node.keys) and key == node.keys[i]: return True if node.is_leaf: return False return self._find(node.children[i], key) def _remove(self, node, key): t = self.t def remove_from_leaf(node, idx): del node.keys[idx] def remove_from_non_leaf(node, idx): k = node.keys[idx] if len(node.children[idx].keys) >= t: pred = node.children[idx] while not pred.is_leaf: pred = pred.children[-1] node.keys[idx] = pred.keys[-1] self._remove(node.children[idx], pred.keys[-1]) elif len(node.children[idx + 1].keys) >= t: succ = node.children[idx + 1] while not succ.is_leaf: succ = succ.children[0] node.keys[idx] = succ.keys[0] self._remove(node.children[idx + 1], succ.keys[0]) else: child = node.children[idx] sibling = node.children[idx + 1] node.keys.pop(idx) child.keys.append(k) child.keys.extend(sibling.keys) child.children.extend(sibling.children) node.children.pop(idx + 1) self._remove(child, key) idx = 0 while idx < len(node.keys) and node.keys[idx] < key: idx += 1 if idx < len(node.keys) and node.keys[idx] == key: if node.is_leaf: remove_from_leaf(node, idx) else: remove_from_non_leaf(node, idx) elif node.is_leaf: return else: flag = (idx == len(node.keys)) if len(node.children[idx].keys) < t: self._fill(node, idx) if flag and idx > len(node.keys): self._remove(node.children[idx - 1], key) else: self._remove(node.children[idx], key) def _fill(self, node, idx): t = self.t if idx != 0 and len(node.children[idx - 1].keys) >= t: self._borrow_from_prev(node, idx) elif idx != len(node.keys) and len(node.children[idx + 1].keys) >= t: self._borrow_from_next(node, idx) else: if idx != len(node.keys): self._merge(node, idx) else: self._merge(node, idx - 1) def _borrow_from_prev(self, node, idx): child = node.children[idx] sibling = node.children[idx - 1] child.keys.insert(0, node.keys[idx - 1]) if not sibling.is_leaf: child.children.insert(0, sibling.children.pop()) node.keys[idx - 1] = sibling.keys.pop() def _borrow_from_next(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys[idx]) if not sibling.is_leaf: child.children.append(sibling.children.pop(0)) node.keys[idx] = sibling.keys.pop(0) def _merge(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys.pop(idx)) child.keys.extend(sibling.keys) child.children.extend(sibling.children) node.children.pop(idx + 1) def _traverse(self, node): i = 0 for i in range(len(node.keys)): if not node.is_leaf: self._traverse(node.children[i]) print(node.keys[i], end=\' \') if not node.is_leaf: self._traverse(node.children[i + 1])"},{"question":"# Question: Implement an Algorithm to Insert a Node in a Binary Search Tree (BST) Scenario You are given the task of maintaining a sorted dataset in an extremely efficient manner. To achieve this goal, you choose to use a Binary Search Tree (BST). Your first step is to implement the insertion operation correctly to ensure the tree maintains its ordered properties. Objective Write a function `insert_into_bst(root: TreeNode, value: int) -> TreeNode` that inserts a new value into the BST and returns the root of the updated tree. Input - `root`: The root node of a binary search tree. If the tree is empty, `root` will be `None`. - `value`: An integer value to be inserted into the BST. Output - Return the `TreeNode` which is the root of the modified BST with the new value inserted. Constraints - The tree nodes contain unique values initially. - You\'ll ensure no duplicate values are added. - Follow the BST property while inserting the new node. Examples 1. **Example 1:** ``` Input: root = [4, 2, 7, 1, 3], value = 5 Output: [4, 2, 7, 1, 3, 5] Explanation: Insert 5 into the BST. The resultant tree should maintain the BST properties. ``` Initial Tree: 4 / 2 7 / 1 3 Resultant Tree: 4 / 2 7 / 1 3 5 2. **Example 2:** ``` Input: root = [], value = 42 Output: [42] Explanation: Insert 42 into the empty BST. ``` Note - The tree structure can be visualized as lists in specific orders (e.g., level-order for simplicity in representation). Code Template ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def insert_into_bst(root: TreeNode, value: int) -> TreeNode: # Add your implementation here pass ```","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def insert_into_bst(root: TreeNode, value: int) -> TreeNode: if not root: return TreeNode(value) if value < root.val: root.left = insert_into_bst(root.left, value) else: root.right = insert_into_bst(root.right, value) return root"},{"question":"# Bubble Sort Challenge You are tasked to implement the bubble sort algorithm to sort a list of integers in ascending order. Your implementation should be efficient and handle edge cases properly. # Function Signature ```python def bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` # Input - **arr**: A list of integers that needs to be sorted. - **simulation**: A boolean flag. If set to True, the function should print the array after each pass. Default value is False. # Output - Returns a list of integers sorted in ascending order. # Constraints - (0 leq text{len}(arr) leq 1000) - (-10^5 leq text{arr[i]} leq 10^5) # Performance Requirements - Time complexity should be analyzed and discussed in the solution. - The algorithm should handle edge cases such as an empty list or list with one element properly. # Example ```python print(bubble_sort([4, 3, 2, 1])) # Output: [1, 2, 3, 4] print(bubble_sort([10, 20, 30, 40])) # Output: [10, 20, 30, 40] print(bubble_sort([3, -1, 0, 2, 4], True)) # Should print: # iteration 0 : 3 -1 0 2 4 # iteration 1 : -1 3 0 2 4 # iteration 2 : -1 0 3 2 4 # iteration 3 : -1 0 2 3 4 # Output: [-1, 0, 2, 3, 4] print(bubble_sort([])) # Output: [] print(bubble_sort([5])) # Output: [5] ``` Ensure your implementation works efficiently even when `simulation` flag is set to True.","solution":"from typing import List def bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts the input array using the bubble sort algorithm. Args: arr (List[int]): A list of integers to be sorted. simulation (bool): If True, prints the array after each pass. Returns: List[int]: The sorted list in ascending order. n = len(arr) for i in range(n): swapped = False if simulation: print(f\\"Iteration {i}: {arr}\\") for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if not swapped: break return arr"},{"question":"# Ordered Stack Implementation Challenge Context You are tasked with managing a system where elements need to be processed based on a priority, with the highest priority elements processed first. To manage this, you need to implement a stack data structure that maintains its elements in sorted order, such that the highest priority (or largest value) is always on top of the stack. Task Implement an `OrderedStack` class that supports the following operations: - `push(item: int)`: Inserts an item into the stack while maintaining sorted order. - `pop() -> int`: Removes and returns the item at the top of the stack. - `peek() -> int`: Returns (but does not remove) the item at the top of the stack. - `size() -> int`: Returns the number of items in the stack. - `is_empty() -> bool`: Returns `True` if the stack is empty, `False` otherwise. Constraints - All operations should consider the edge case when the stack is empty. - Ensure that the stack maintains elements in descending order (highest value on top). - Optimize the `push` operation to handle up to (10^5) insertions efficiently. Input and Output Formats - `push(item: int)`: No output. - `pop() -> int`: Output the popped element. - `peek() -> int`: Output the element on top of the stack. - `size() -> int`: Output the current number of elements in the stack. - `is_empty() -> bool`: Output `True` or `False`. Example ```python stack = OrderedStack() stack.push(10) stack.push(5) stack.push(20) print(stack.pop()) # Output: 20 print(stack.peek()) # Output: 10 print(stack.size()) # Output: 2 print(stack.is_empty()) # Output: False ``` Implement the `OrderedStack` class based on the requirements:","solution":"import bisect class OrderedStack: def __init__(self): self.stack = [] def push(self, item: int): Inserts an item into the stack while maintaining sorted order. bisect.insort(self.stack, -item) def pop(self) -> int: Removes and returns the item at the top of the stack. if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return -self.stack.pop(0) def peek(self) -> int: Returns (but does not remove) the item at the top of the stack. if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return -self.stack[0] def size(self) -> int: Returns the number of items in the stack. return len(self.stack) def is_empty(self) -> bool: Returns True if the stack is empty, False otherwise. return len(self.stack) == 0"},{"question":"# Coding Exercise: Counting \'1\' Bits **Scenario**: In a digital signal processing system, it is often necessary to determine the Hamming weight of binary numbers, which represents the number of \'1\' bits in its binary form. This is an essential step in error detection algorithms and data compression techniques. Implement a function that takes an unsigned integer as input and returns the number of \'1\' bits in its binary representation. You should implement both a recursive approach and an iterative approach using Brian Kernighan\'s Algorithm. **Function Signature**: ```python def count_ones_recur(n: int) -> int: pass def count_ones_iter(n: int) -> int: pass ``` **Input**: - An unsigned integer `n`. **Output**: - An integer representing the number of \'1\' bits in the binary representation of `n`. **Constraints**: - The input integer will be within the range of a standard 32-bit unsigned integer. **Requirements**: - Implement both the recursive and iterative approaches. - Analyze and justify the time complexity of your implementations. **Examples**: ```python assert count_ones_recur(11) == 3 # Binary: 00000000000000000000000000001011 assert count_ones_iter(11) == 3 # Binary: 00000000000000000000000000001011 assert count_ones_recur(128) == 1 # Binary: 00000000000000000000000010000000 assert count_ones_iter(128) == 1 # Binary: 00000000000000000000000010000000 assert count_ones_recur(15) == 4 # Binary: 00000000000000000000000000001111 assert count_ones_iter(15) == 4 # Binary: 00000000000000000000000000001111 ``` # Notes: - Ensure your solution is efficient and handles edge cases such as `0` correctly. - Explain the time complexity and space complexity of both approaches in your implementation comments.","solution":"def count_ones_recur(n: int) -> int: Returns the number of \'1\' bits in the binary representation of the given number using a recursive approach. Time Complexity: O(log n) - Each recursive call removes one \'1\' bit from n. Space Complexity: O(log n) - Due to the recursion stack. if n == 0: return 0 else: return 1 + count_ones_recur(n & (n - 1)) def count_ones_iter(n: int) -> int: Returns the number of \'1\' bits in the binary representation of the given number using an iterative approach based on Brian Kernighan\'s Algorithm. Time Complexity: O(log n) - Each iteration removes one \'1\' bit from n. Space Complexity: O(1) - No additional space usage. count = 0 while n: n &= (n - 1) count += 1 return count"},{"question":"# Question: Filtering Array by Boundary Values You are required to implement a function that filters the values of an array based on given minimum and/or maximum boundary values. The function should traverse the array and retain only those elements that fall between the provided bounds, inclusive. Function Signature ```python def limited_array(arr, min_lim=None, max_lim=None): Filters the array \'arr\' to include only values between \'min_lim\' and \'max_lim\', inclusive. Parameters: arr (list of int): A list of integers to be filtered. min_lim (int or None): The minimum bound value. If None, it defaults to the minimum value in \'arr\'. max_lim (int or None): The maximum bound value. If None, it defaults to the maximum value in \'arr\'. Returns: list of int: A list containing elements from \'arr\' that are between \'min_lim\' and \'max_lim\'. ``` Input - A list of integers `arr` (0 <= len(arr) <= 10^6). - An integer `min_lim` which is the minimum boundary, or `None`. - An integer `max_lim` which is the maximum boundary, or `None`. Output - A list of integers from the input array that lie between `min_lim` and `max_lim` (both inclusive). Constraints - The array can be empty. - If `min_lim` is `None`, it should be treated as the minimum value in the array. - If `max_lim` is `None`, it should be treated as the maximum value in the array. - The elements in the output list should maintain their original order. Example ```python # Example 1 assert limited_array([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] # Example 2 assert limited_array([10, 20, 30, 40, 50, 60], 25, 55) == [30, 40, 50] # Example 3 assert limited_array([5, 10, 15, 20], 10, None) == [10, 15, 20] ``` Implement the `limited_array` function to achieve the above functionality, ensuring considerations for edge cases and maintaining efficient time complexity.","solution":"def limited_array(arr, min_lim=None, max_lim=None): Filters the array \'arr\' to include only values between \'min_lim\' and \'max_lim\', inclusive. Parameters: arr (list of int): A list of integers to be filtered. min_lim (int or None): The minimum bound value. If None, it defaults to the minimum value in \'arr\'. max_lim (int or None): The maximum bound value. If None, it defaults to the maximum value in \'arr\'. Returns: list of int: A list containing elements from \'arr\' that are between \'min_lim\' and \'max_lim\'. if not arr: return [] if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"You are tasked with implementing a modified radix sort to handle a list of positive integers efficiently. The sorting should follow the traditional radix sort principles but must also address specific efficiency concerns and edge cases described below. # Function Signature ```python def modified_radix_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` # Input 1. `arr`: A list of positive integers (0 ≤ arr[i] ≤ 10^9). 2. `simulation`: A boolean flag (default is `False`). If set to `True`, it prints the array at the end of each iteration during the sort for visualization purposes. # Output - Returns a list of sorted integers in ascending order. # Constraints/Limitations 1. You must handle arrays with 0, 1, or multiple elements. 2. Ensure that the function works efficiently for lists of length up to 10^6. 3. Minimize additional memory usage as much as possible. # Performance Requirements - Time Complexity: O(nk), where n is the number of elements and k is the number of digits in the maximum number. - Space Complexity: O(n), optimized from the conventional implementation where possible. # Example ```python # Example 1 arr = [170, 45, 75, 90, 802, 24, 2, 66] print(modified_radix_sort(arr, simulation=True)) # Expected Output after each iteration (simulation=True): # iteration 0 : 170 45 75 90 802 24 2 66 # iteration 1 : 170 90 802 2 24 45 75 66 # iteration 2 : 2 24 45 66 75 170 802 90 # Final Output: [2, 24, 45, 66, 75, 90, 170, 802] # Example 2 arr = [3, 3, 3, 3] print(modified_radix_sort(arr)) # Expected Output: [3, 3, 3, 3] # Example 3 arr = [] print(modified_radix_sort(arr)) # Expected Output: [] ``` # Notes - Your solution should avoid excessive memory use and handle all edge cases efficiently. - Remember to print the state of the array at each iteration if `simulation` is set to `True`.","solution":"from typing import List def modified_radix_sort(arr: List[int], simulation: bool = False) -> List[int]: if len(arr) <= 1: return arr max_val = max(arr) exp = 1 def counting_sort(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 for i in range(1, 10): count[i] += count[i - 1] for i in range(n - 1, -1, -1): index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 for i in range(n): arr[i] = output[i] while max_val // exp > 0: counting_sort(arr, exp) if simulation: print(f\\"iteration {exp // 10}: {arr}\\") exp *= 10 return arr"},{"question":"# Zigzag Level Order Traversal of a Binary Tree Scenario You are a software engineer tasked with implementing a feature that visualizes hierarchical data in a binary tree format. Specifically, the visualization needs to display the node values level by level, but alternating the display order with each new level. This alternating order, known as Zigzag Level Order Traversal, helps in understanding the structure more clearly. Task Write a function `zigzag_level(root)` that takes the root of a binary tree and returns a list of lists containing the zigzag level order traversal of its nodes\' values. Input and Output Formats * **Input**: * `root` - The root node of a binary tree. A node is defined by the following class: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` * **Output**: * A list of lists, where each list contains the values of the nodes at a particular level, in zigzag order. Constraints * The tree can have between 0 to 10,000 nodes. * Node values can be of any type that supports comparison (e.g., integers, strings). Performance Requirements The solution should have an average time complexity of O(n) and space complexity of O(n), where n is the number of nodes in the tree. Example Given binary tree defined as: ``` 3 / 9 20 / 15 7 ``` The zigzag level order traversal of its nodes\' values should return: ``` [ [3], [20, 9], [15, 7] ] ``` Function Signature ```python def zigzag_level(root: TreeNode) -> List[List[int]]: # Your code here ``` Testing Your Implementation - Test with an empty tree. - Test with a tree containing one node. - Test with trees where all nodes are only left children. - Test with a balanced tree.","solution":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzag_level(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] current_level = deque([root]) left_to_right = True while current_level: level_size = len(current_level) level_nodes = [] for _ in range(level_size): if left_to_right: node = current_level.popleft() if node.left: current_level.append(node.left) if node.right: current_level.append(node.right) else: node = current_level.pop() if node.right: current_level.appendleft(node.right) if node.left: current_level.appendleft(node.left) level_nodes.append(node.val) result.append(level_nodes) left_to_right = not left_to_right return result"},{"question":"# Scenario You are a software engineer working on optimizing a system for handling range queries on large datasets. Your task is to implement a segment tree that can efficiently support different types of range queries, such as sum, minimum, and maximum. # Task Implement a Segment Tree class that supports efficient range queries. # SegmentTree Class You need to implement the `SegmentTree` class with the following methods: 1. `__init__(self, arr, function)`: Constructor to initialize the segment tree from a given list `arr` and a function `function` that determines the operation (e.g., sum, min, max) for the segments. 2. `make_tree(self, i, l, r)`: Recursive method to build the segment tree. 3. `__query(self, i, L, R, l, r)`: Recursive helper method to handle the querying. 4. `query(self, L, R)`: Public method to query the segment tree for the function result over the range `[L, R]`. # Input Format 1. `arr`: A list of integers on which the segment tree is to be built. 2. `function`: A function that takes two integer arguments and returns an integer. This function will be used to combine segment results. # Output Format The methods should enable querying specific ranges and apply the function over those ranges. # Constraints * The length of `arr` will not exceed `10^6`. * The values of `arr[i]` will be in the range `[-10^9, 10^9]`. * Queries `L` and `R` will always be valid within the bounds of the array. # Example Usage ```python # Create a segment tree with a max function. mytree = SegmentTree([2, 4, 5, 3, 4], max) print(mytree.query(2, 4)) # Output: 5 print(mytree.query(0, 3)) # Output: 5 # Create a segment tree with a sum function. mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], sum) print(mytree.query(1, 5)) # Output: 57 print(mytree.query(0, 3)) # Output: 14 ``` Ensure that your implementation is efficient and handles all edge cases appropriately.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.arr = arr self.function = function self.tree = [None] * (4 * self.n) self.make_tree(0, 0, self.n - 1) def make_tree(self, i, l, r): if l == r: self.tree[i] = self.arr[l] else: mid = (l + r) // 2 self.make_tree(2 * i + 1, l, mid) self.make_tree(2 * i + 2, mid + 1, r) self.tree[i] = self.function(self.tree[2 * i + 1], self.tree[2 * i + 2]) def __query(self, i, L, R, l, r): if L > r or R < l: return None # Out of range if L <= l and R >= r: return self.tree[i] mid = (l + r) // 2 left_result = self.__query(2 * i + 1, L, R, l, mid) right_result = self.__query(2 * i + 2, L, R, mid + 1, r) if left_result is None: return right_result if right_result is None: return left_result return self.function(left_result, right_result) def query(self, L, R): return self.__query(0, L, R, 0, self.n - 1)"},{"question":"Implementation of Cocktail Shaker Sort with Custom Criteria Context: Given the knowledge of the Cocktail Shaker Sort algorithm, you are required to implement a variant of this sorting algorithm that will sort an array of integers. This variant will not only sort in ascending order but must account for certain criteria to demonstrate a deep understanding and an ability to modify and adapt algorithms. Task: Write a function `custom_cocktail_shaker_sort(arr, custom_criteria)` that sorts the array `arr` based on a specified custom criteria function. The `custom_criteria` function will decide the order of sorting when comparing two elements. Your implementation should perform the cocktail shaker sorting based on this custom comparison logic. Specifications: * **Input**: * `arr`: A list of integers to sort. * `custom_criteria`: A comparison function taking two arguments `x` and `y`, returning `True` if `x` should come before `y` and `False` otherwise. * **Output**: * A sorted list of integers based on the custom criteria. Constraints: * Your solution should handle edge cases including an empty array, an array with one element, and arrays with all elements identical. * Consider the time complexity, and aim to stick within the constraints of the given algorithm. Example: ```python def ascending_criteria(x, y): return x < y arr = [5, 2, 9, 1, 5, 6] sorted_arr = custom_cocktail_shaker_sort(arr, ascending_criteria) print(sorted_arr) # Output: [1, 2, 5, 5, 6, 9] def descending_criteria(x, y): return x > y sorted_arr_desc = custom_cocktail_shaker_sort(arr, descending_criteria) print(sorted_arr_desc) # Output: [9, 6, 5, 5, 2, 1] ``` Notes: - The `custom_criteria` input function will allow you to demonstrate comprehension of customizing the sort order beyond just simple ascending or descending orders, allowing more complex custom criteria. - Ensure to thoroughly handle edge cases and aim for a robust implementation.","solution":"def custom_cocktail_shaker_sort(arr, custom_criteria): Sorts an array of integers based on a custom criteria function using the Cocktail Shaker Sort algorithm. Arguments: arr -- a list of integers to be sorted custom_criteria -- a function that takes two arguments (x, y) and returns True if x should come before y, and False otherwise Returns: A sorted list of integers based on the custom criteria. if len(arr) <= 1: return arr n = len(arr) start = 0 end = n - 1 sorted = False while not sorted: sorted = True for i in range(start, end): if not custom_criteria(arr[i], arr[i+1]): arr[i], arr[i+1] = arr[i+1], arr[i] sorted = False if sorted: break sorted = True end -= 1 for i in range(end, start, -1): if not custom_criteria(arr[i-1], arr[i]): arr[i], arr[i-1] = arr[i-1], arr[i] sorted = False start += 1 return arr"},{"question":"Implement a function to compute the n-th Fibonacci number using different methods. Specifically, you need to implement the following versions: 1. Recursive (without memoization): This version should demonstrate understanding of basic recursion, despite being inefficient for large inputs. 2. Dynamic Programming (using a list to store computed values): This version must utilize a list to store intermediate results. 3. Iterative: This version should use an iterative approach to keep the space complexity at O(1). # Function Signature ```python def fib_recursive(n: int) -> int: Arguments: n -- A non-negative integer representing the position in the Fibonacci sequence. Returns: An integer which is the n-th Fibonacci number. def fib_list(n: int) -> int: Arguments: n -- A non-negative integer representing the position in the Fibonacci sequence. Returns: An integer which is the n-th Fibonacci number. def fib_iter(n: int) -> int: Arguments: n -- A non-negative integer representing the position in the Fibonacci sequence. Returns: An integer which is the n-th Fibonacci number. ``` # Constraints - The input `n` will be a non-negative integer in the range `[0, 100]`. - Do not use any external libraries. Only standard Python libraries are allowed. - Performance for the iterative and dynamic programming methods should be O(n). # Example ```python print(fib_recursive(10)) # Should output: 55 print(fib_list(10)) # Should output: 55 print(fib_iter(10)) # Should output: 55 ``` # Notes - Ensure that the input parameter `n` is validated to be a non-negative integer. - Consider edge cases such as `n = 0` and `n = 1` and large values of `n`. - Provide in-line comments to clarify key parts of your code.","solution":"def fib_recursive(n: int) -> int: Arguments: n -- A non-negative integer representing the position in the Fibonacci sequence. Returns: An integer which is the n-th Fibonacci number. if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") # Base cases if n == 0: return 0 if n == 1: return 1 # Recursive call return fib_recursive(n-1) + fib_recursive(n-2) def fib_list(n: int) -> int: Arguments: n -- A non-negative integer representing the position in the Fibonacci sequence. Returns: An integer which is the n-th Fibonacci number. if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n == 0: return 0 if n == 1: return 1 # Initialize a list to store Fibonacci numbers fibs = [0] * (n + 1) fibs[0] = 0 fibs[1] = 1 # Fill the list with Fibonacci numbers up to n for i in range(2, n + 1): fibs[i] = fibs[i - 1] + fibs[i - 2] return fibs[n] def fib_iter(n: int) -> int: Arguments: n -- A non-negative integer representing the position in the Fibonacci sequence. Returns: An integer which is the n-th Fibonacci number. if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n == 0: return 0 if n == 1: return 1 # Initialize variables to store the previous two Fibonacci numbers a, b = 0, 1 # Iterate up to n, updating the variables with the next Fibonacci number for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"Implement and Optimize Merge Sort You\'ve been assigned to enhance an existing sorting algorithm in a performance-critical system. The current implementation uses Merge Sort due to its predictable time complexity and stability properties. However, you need to re-implement it to optimize for memory usage and potentially improve performance. Task 1. **Implement** the Merge Sort algorithm. 2. **Optimize** it to reduce memory overhead by minimizing unnecessary array copies. 3. Ensure the implementation handles edge cases and maintains the algorithm\'s stable sort property. Implementation Details 1. **Function signature**: ```python def optimized_merge_sort(arr: list) -> list: ``` 2. **Input**: - `arr` (list of integers): The array to be sorted. 3. **Output**: - A new list of integers in non-decreasing order. 4. **Constraints**: * 1 <= len(arr) <= 10^5 * -10^6 <= arr[i] <= 10^6 5. **Performance Requirements**: * The sorting function should run in O(n log(n)) time complexity. * Aim to minimize auxiliary space usage as much as possible. Example: ```python assert optimized_merge_sort([3, 6, 1, 5, 3]) == [1, 3, 3, 5, 6] assert optimized_merge_sort([1]) == [1] assert optimized_merge_sort([]) == [] ```","solution":"def optimized_merge_sort(arr): Perform merge sort on the given array in a memory optimized way. if len(arr) <= 1: return arr def merge(left, right): result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 # Append remaining elements (if any) result.extend(left[i:]) result.extend(right[j:]) return result def merge_sort_recursive(arr): if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort_recursive(arr[:mid]) right = merge_sort_recursive(arr[mid:]) return merge(left, right) return merge_sort_recursive(arr)"},{"question":"# Decoding Nested Encoded Strings Scenario You are a software engineer working on a data compression system. One component of this system involves decoding strings encoded with a specific pattern. The encoded strings follow the pattern `k[encoded_string]`, where `encoded_string` is repeated exactly `k` times, and `k` is a positive integer. Objective Create a function that decodes an encoded string. The input string is always well-formed and valid. Requirements - Implement the function `decode_string(s)` that takes a single argument, `s`, which is the encoded string. - The function should return the decoded version of the string. Input and Output - **Input:** A string `s` following the encoding rule. - Example: `\\"3[a2[b]]\\"` - **Output:** A string, which is the decoded version. - Example: `\\"abbabbabb\\"` Constraints - The input string has no extra spaces, and square brackets are well-formed. - Original data does not contain any digits; digits are only for multiplier values. - Multiplier values are positive integers. Example ```python s = \\"3[a]2[bc]\\" # Expected output: \\"aaabcbc\\" s = \\"3[a2[c]]\\" # Expected output: \\"accaccacc\\" s = \\"2[abc]3[cd]ef\\" # Expected output: \\"abcabccdcdcdef\\" ``` function definition ```python def decode_string(s): :type s: str :rtype: str # Your implementation here pass ``` Considerations - Handle nested encoded patterns properly. - Ensure the implementation is efficient to handle larger inputs. - Test thoroughly, including edge cases such as an empty string, large multipliers, and deeply nested patterns.","solution":"def decode_string(s): Decodes an encoded string with the k[encoded_string] pattern. :param s: str, The encoded string :return: str, The decoded string stack = [] current_num = 0 current_string = \'\' for char in s: if char.isdigit(): # If the char is a digit, we append it to current_num. current_num = current_num * 10 + int(char) elif char == \'[\': # Push the current_string and current_num to the stack. stack.append((current_string, current_num)) # Reset current_string and current_num. current_string = \'\' current_num = 0 elif char == \']\': # Pop from the stack and get the last current_string and current_num. last_string, num = stack.pop() # Update current_string with the decoded substring. current_string = last_string + num * current_string else: # Append the current character to the current_string. current_string += char return current_string"},{"question":"**Title**: Robust Path Joining for URLs and File Paths **Objective**: Implement a function `robust_join(base, suffix)` in Python that joins base URLs or file paths intelligently, ensuring a single slash joins them together, regardless of their trailing or leading slashes. # Guidelines: 1. **Input**: - `base` (str): A non-empty string representing the base URL or file path. - `suffix` (str): A string representing the suffix to be appended to the base. 2. **Output**: A single string representing the concatenated path. 3. **Constraints**: - Do not use the `os.path.join` or similar utility functions directly. - Whitespaces should be removed from the beginning and end of `suffix`. - If `suffix` is an absolute path (starts with `/`), treat `suffix` as having the highest priority. 4. **Performance**: The function should operate efficiently with linear time complexity relative to the combined length of the strings. # Example Scenarios: Example 1 - **Input**: `base = \\"http://mywebsite.com/\\", suffix = \\"path/to/resource\\"` - **Output**: `\\"http://mywebsite.com/path/to/resource\\"` Example 2 - **Input**: `base = \\"C:/Users/Admin\\", suffix = \\"/Documents\\"` - **Output**: `\\"/Documents\\"` Example 3 - **Input**: `base = \\"folder/subfolder\\", suffix = \\"file.txt\\"` - **Output**: `\\"folder/subfolder/file.txt\\"` # Requirements: 1. Ensure the function handles the following scenarios: - Trailing slashes in `base`. - Leading slashes in `suffix`. - Leading and trailing whitespaces in `suffix`. - Absolute `suffix` paths. Implement the function `robust_join(base, suffix)`: ```python def robust_join(base, suffix): # Implement the function here pass # Sample Usage print(robust_join(\\"http://mywebsite.com/\\", \\"path/to/resource\\")) # Expect: \\"http://mywebsite.com/path/to/resource\\" print(robust_join(\\"C:/Users/Admin\\", \\"/Documents\\")) # Expect: \\"/Documents\\" print(robust_join(\\"folder/subfolder\\", \\"file.txt\\")) # Expect: \\"folder/subfolder/file.txt\\" ```","solution":"def robust_join(base, suffix): Joins a base URL or file path with a suffix ensuring a single slash between them. If the suffix starts with a slash, it is treated as an absolute path. Leading/trailing whitespaces in suffix are removed. base = base.rstrip(\'/\') suffix = suffix.strip() if suffix.startswith(\'/\'): return suffix else: return f\\"{base}/{suffix}\\""},{"question":"**Problem Statement:** Implement a function `simplify_polynomial` that takes as input a polynomial expression provided as a list of monomials, where each monomial is represented as a dictionary with the keys \\"variables\\" and \\"coefficient\\". The function should: 1. Simplify the polynomial by coalescing like terms. 2. Return the simplified polynomial as a list of dictionaries sorted by variable keys in ascending order. # Input Format: - A list of dictionaries where each dictionary represents a monomial. - Each dictionary contains: - `\\"variables\\"`: A dictionary of variable indexes to their power (e.g., `{1: 3, 2: 2}` for ( (a_1)^3(a_2)^2 )). - `\\"coefficient\\"`: A numerical coefficient. # Output Format: - A list of simplified monomials (dictionaries) where: - Monomials with the same variables and exponents are merged. - The resulting list is sorted by the variable keys in ascending order. # Constraints: - The input polynomial can contain up to 1000 monomials. - Each variable index will be a positive integer. - Coefficients can be integers or floating-point numbers. # Example: **Input:** ```python [ {\\"variables\\": {1: 1}, \\"coefficient\\": 2}, {\\"variables\\": {2: 3, 1: -1}, \\"coefficient\\": -1}, {\\"variables\\": {}, \\"coefficient\\": 3.14}, {\\"variables\\": {1: 1}, \\"coefficient\\": 3}, {\\"variables\\": {2: 3, 1: -1}, \\"coefficient\\": 1} ] ``` **Output:** ```python [ {\\"variables\\": {}, \\"coefficient\\": 3.14}, {\\"variables\\": {1: 1}, \\"coefficient\\": 5}, {\\"variables\\": {1: -1, 2: 3}, \\"coefficient\\": 0} ] ``` **Explanation:** - Simplify by adding like terms: (2(a_1)^1 + 3(a_1)^1 Rightarrow 5(a_1)^1) - ((-1)(a_1)^{-1}(a_2)^3 + 1(a_1)^{-1}(a_2)^3 Rightarrow 0) - The constant term (3.14) remains as is. - The sorted order is maintained during the merge.","solution":"def simplify_polynomial(polynomial): Simplifies a polynomial expression by coalescing like terms. Args: polynomial (list): A list of monomials where each monomial is represented as a dictionary with \'variables\' and \'coefficient\' keys. Returns: list: A list of simplified monomials (dictionaries) sorted by variable keys in ascending order. from collections import defaultdict # Create a dictionary to hold the combined terms combined_terms = defaultdict(float) for monomial in polynomial: # Convert the variables dictionary to a tuple of sorted items var_tuple = tuple(sorted(monomial[\'variables\'].items())) # Add the coefficient to the corresponding combined term combined_terms[var_tuple] += monomial[\'coefficient\'] # Create the final list of simplified monomials simplified_polynomial = [] for var_tuple, coeff in combined_terms.items(): if coeff != 0: # Ignore zero coefficients variables = dict(var_tuple) simplified_polynomial.append({\\"variables\\": variables, \\"coefficient\\": coeff}) # Sort the result by the variable key tuples simplified_polynomial.sort(key=lambda x: sorted(x[\\"variables\\"].items())) return simplified_polynomial"},{"question":"Context You are working in a data processing team focusing on natural language processing (NLP). One of your tasks involves evaluating the similarity between two documents represented as term frequency vectors. To accomplish this, you\'ll use the cosine similarity metric. Task Description Implement a Python function `cosine_similarity(vec1, vec2)` that calculates the cosine similarity between two given 1-dimensional lists (vectors). Both lists must have the same length. Your function must handle the following: 1. Calculate the L2 norm of each vector. 2. Compute the dot product of the two vectors. 3. Return the normalized dot product as the cosine similarity. If the input vectors are of different lengths, your function should raise a `ValueError` with an appropriate message. Function Signature ```python def cosine_similarity(vec1: list, vec2: list) -> float: pass ``` Input * `vec1`: A list of integers or floats. * `vec2`: A list of integers or floats, of the same length as `vec1`. Output * A float representing the cosine similarity between the two input vectors. Constraints * Both vectors will have lengths between 1 and 10^6. * Elements of the vectors will be integers or floats, with absolute values not exceeding 10^6. Examples ```python cosine_similarity([1, 1, 1], [1, 2, -1]) # output: 0.47140452079103173 cosine_similarity([3, 45, 7, 2], [2, 54, 13, 15]) # output: 0.97228425171235 cosine_similarity([0, 0, 0], [0, 0, 0]) # output: raises ValueError ``` Performance Requirement The solution should efficiently compute the cosine similarity, ensuring it handles input sizes up to 10^6 elements per vector without significant performance degradation.","solution":"import math def cosine_similarity(vec1: list, vec2: list) -> float: if len(vec1) != len(vec2): raise ValueError(\\"Vectors must be of the same length\\") dot_product = sum(a * b for a, b in zip(vec1, vec2)) norm_vec1 = math.sqrt(sum(a * a for a in vec1)) norm_vec2 = math.sqrt(sum(b * b for b in vec2)) if norm_vec1 == 0 or norm_vec2 == 0: raise ValueError(\\"One or both of the vectors is a zero vector\\") return dot_product / (norm_vec1 * norm_vec2)"},{"question":"You are given a stack representing a set of briefly arranged books. The task involves creating a function to switch successive pairs of books from the bottom of the pile. You are given two approaches to complete this task and must implement both. # Function Specifications 1. **Function 1: first_switch_pairs(stack)** 2. **Function 2: second_switch_pairs(stack)** Each function should take the stack (list) as input and switch pairs using different auxiliary storage mechanisms: * **first_switch_pairs**: Utilize an auxiliary stack. * **second_switch_pairs**: Utilize an auxiliary queue. # Input: * **stack**: A list of integers where the end of the list represents the top of the stack. # Output: * Returns a modified list representing the stack with pairs of items switched as described. # Constraints: * The stack can have any number of elements (including zero). # Example: ```python stack1 = [3, 8, 17, 9, 1, 10] # Output should be [8, 3, 9, 17, 10, 1] stack2 = [3, 8, 17, 9, 1] # Output should be [8, 3, 9, 17, 1] ``` # Requirements: 1. Ensure the functions handle edge cases like the stack having zero or one element. 2. Only use the specified auxiliary storage mechanisms for each function. 3. Do not alter the relative order outside of swapping pairs. 4. Ensure the functions can handle stacks of significant size efficiently.","solution":"def first_switch_pairs(stack): This function uses an auxiliary stack to switch successive pairs of elements. if len(stack) < 2: return stack aux_stack = [] # Move all elements from the original stack to the auxiliary stack while stack: aux_stack.append(stack.pop()) # Move elements back to the original stack while switching pairs while aux_stack: if len(aux_stack) >= 2: first = aux_stack.pop() second = aux_stack.pop() stack.append(second) stack.append(first) else: stack.append(aux_stack.pop()) return stack from collections import deque def second_switch_pairs(stack): This function uses an auxiliary queue to switch successive pairs of elements. if len(stack) < 2: return stack aux_queue = deque() # Move all elements from the original stack to the auxiliary queue while stack: aux_queue.appendleft(stack.pop()) # Move elements back to the original stack while switching pairs while aux_queue: if len(aux_queue) >= 2: first = aux_queue.popleft() second = aux_queue.popleft() stack.append(second) stack.append(first) else: stack.append(aux_queue.popleft()) return stack"},{"question":"**Scenario:** You have been tasked by a cryptography research team to implement a solution that decodes numeric messages. As part of this task, you need to determine the number of ways an encoded message can be decoded. A message containing letters from A-Z is being encoded to numbers using the following mapping: ``` \'A\' -> 1 \'B\' -> 2 ... \'Z\' -> 26 ``` Given an encoded message containing digits, determine the total number of ways to decode it. # Function Specification: **Function Name**: num_ways_to_decode * **Input**: * `encoded_message` (str): A string representing the encoded message (digits only). * **Output**: * `int`: The total number of ways to decode the message. # Constraints: * `1 <= len(encoded_message) <= 100` * The input string will contain only digits and no leading zeros. # Performance Requirements: * The solution should run in O(n) time complexity, where n is the length of `encoded_message`. * The space complexity should not exceed O(n). # Examples: 1. **Example 1:** ```python encoded_message = \\"12\\" print(num_ways_to_decode(encoded_message)) # Expected Output: 2, as \\"12\\" can be decoded as \\"AB\\" (1 2) or \\"L\\" (12) ``` 2. **Example 2:** ```python encoded_message = \\"226\\" print(num_ways_to_decode(encoded_message)) # Expected Output: 3, as \\"226\\" can be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6), or \\"BBF\\" (2 2 6) ``` 3. **Example 3:** ```python encoded_message = \\"06\\" print(num_ways_to_decode(encoded_message)) # Expected Output: 0, as \\"06\\" cannot be decoded because no letter corresponds to \\"0\\". ``` # Edge Cases: * **Input with leading zero:** \\"01\\" or \\"0\\" should return 0. * **Sudden invalid zero placement**: \\"230\\" or \\"1200\\". * **Very large valid sequence**: \\"1111111111\\". # Additional Notes: * Analyze your algorithm to ensure it handles invalid cases and remains efficient within the given constraints. * Consider both iterations and recursive paradigms if applicable. *Good Luck!*","solution":"def num_ways_to_decode(encoded_message): if not encoded_message or encoded_message[0] == \'0\': return 0 n = len(encoded_message) dp = [0] * (n + 1) dp[0] = 1 # Base case: an empty message has one way to be decoded. for i in range(1, n + 1): if encoded_message[i - 1] != \'0\': dp[i] += dp[i - 1] if i > 1 and \'10\' <= encoded_message[i - 2:i] <= \'26\': dp[i] += dp[i - 2] return dp[n]"},{"question":"# Task You are tasked with implementing a function that calculates the number of ways to choose `r` items from `n` items (nCr). The combination calculation should be optimized and efficient even for relatively large values of `n` and `r`. # Function Signature ```python def combination(n: int, r: int) -> int: pass ``` # Input * `n` (1 ≤ n ≤ 1000): Total number of items. * `r` (0 ≤ r ≤ n): Number of items to choose. # Output * Return the number of combinations, `n choose r`. # Constraints * The result is guaranteed to fit within a 64-bit signed integer. * Aim for an optimal approach using memoization or dynamic programming. # Examples ```python assert combination(5, 2) == 10 assert combination(10, 5) == 252 assert combination(100, 0) == 1 assert combination(100, 100) == 1 assert combination(50, 5) == 2118760 ``` # Scenario Imagine you\'re designing a lottery system where you need to calculate the number of possible combinations for participants. To ensure efficient computation, particularly for high-value tickets with many selections, you need a highly optimized way to calculate this factorial-based combinatorial number.","solution":"def combination(n: int, r: int) -> int: Calculate the number of ways to choose r items from n items (nCr). # Base cases if r > n: return 0 if r == 0 or r == n: return 1 # Calculating nCr using an optimized approach r = min(r, n-r) num = den = 1 for i in range(r): num *= (n - i) den *= (i + 1) return num // den"},{"question":"**Question**: You are tasked with writing a function that calculates the binomial coefficient, ( nCr ), which represents the number of ways to choose ( r ) items from ( n ) items without regard to order. # Function Signature: ```python def binomial_coefficient(n: int, r: int) -> int: ``` # Input: * The function takes two integers: * ( n ) - the total number of items (0 ≤ ( n ) ≤ 1000) * ( r ) - the number of items to choose (0 ≤ ( r ) ≤ 1000) # Output: * Return a single integer, the value of the binomial coefficient ( nCr ). # Constraints: * Your solution should be efficient and handle large values of ( n ) and ( r ). # Example: ```python assert binomial_coefficient(5, 2) == 10 assert binomial_coefficient(0, 0) == 1 assert binomial_coefficient(1000, 3) == 166167000 ``` # Note: * The function should handle edge cases such as ( n = r ), ( r = 0 ), and scenarios where ( r > n ) correctly. You should aim to implement a solution using the concept of memoization (as shown in the provided code snippets) to ensure your function runs efficiently even for large inputs.","solution":"def binomial_coefficient(n: int, r: int) -> int: Returns the binomial coefficient (n choose r). if r > n: return 0 if r == 0 or r == n: return 1 # Using a more efficient approach for the binomial coefficient # We use the property nCr = nC(n-r) to minimize calculations. r = min(r, n - r) c = 1 for i in range(r): c = c * (n - i) // (i + 1) return c"},{"question":"# Prime Number Range Finder You are given a function, `prime_check(n)`, which correctly identifies whether a number `n` is prime or not. Your task is to use this to implement a new function `find_primes_in_range(start, end)` that will find all prime numbers in a given inclusive range `[start, end]`. Function Signature ```python def find_primes_in_range(start: int, end: int) -> List[int]: pass ``` Input - `start` (int): The start of the range (inclusive). `1 <= start <= 10^6`. - `end` (int): The end of the range (inclusive). `start <= end <= 10^6`. Output - Returns a list of integers containing all prime numbers in the specified range. Constraints - Your solution should be efficient and must complete in a reasonable time frame considering the input constraints. Example ```python # The function call print(find_primes_in_range(10, 20)) # Should return: [11, 13, 17, 19] ``` Implement the function `find_primes_in_range` using the provided `prime_check(n)` function to determine which numbers in the specified range are prime.","solution":"from typing import List def prime_check(n: int) -> bool: Determines if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_primes_in_range(start: int, end: int) -> List[int]: Returns a list of prime numbers in the range [start, end]. primes = [] for num in range(start, end + 1): if prime_check(num): primes.append(num) return primes"},{"question":"Problem Statement You have been given a list of non-negative integers. Your task is to implement a sorting function using the radix sort algorithm to sort this list in ascending order. Additionally, the function should simulate each step of the sorting process and print the state of the list after each iteration (each pass through one digit position). # Function Signature ```python def enhanced_radix_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` # Input - `arr`: A list of non-negative integers (0 <= num <= 10**6) to be sorted. - `simulation`: A boolean flag (default is False). If set to True, the function should print the state of the list after each iteration (after each digit position is sorted). # Output - Returns the sorted list of integers in ascending order. # Constraints - The function should handle lists of sizes up to 10^5 elements. - Each element in the list will not exceed 10^6. # Example ```python arr = [170, 45, 75, 90, 802, 24, 2, 66] print(enhanced_radix_sort(arr, simulation=True)) # Sample Output: # iteration 0 : 170, 45, 75, 90, 802, 24, 2, 66 # iteration 1 : 170, 90, 802, 2, 24, 45, 66, 75 # iteration 2 : 2, 24, 45, 66, 75, 170, 802, 90 # iteration 3 : 2, 24, 45, 66, 75, 90, 170, 802 # [2, 24, 45, 66, 75, 90, 170, 802] ``` # Notes 1. Make sure to include necessary edge case handling such as an empty list or a list with all identical numbers. 2. Consider the performance impact and try to make your implementation as efficient as possible. Happy coding!","solution":"def enhanced_radix_sort(arr, simulation = False): def counting_sort(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = arr[i] // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 i -= 1 for i in range(n): arr[i] = output[i] max_val = max(arr) if arr else 0 exp = 1 iteration = 0 while max_val // exp > 0: counting_sort(arr, exp) if simulation: print(f\\"iteration {iteration} : {\', \'.join(map(str, arr))}\\") exp *= 10 iteration += 1 return arr"},{"question":"Balanced Binary Search Tree Insertions You\'re given a Binary Search Tree (BST) implementation as depicted in the analysis. However, as simple BSTs can become unbalanced and degrade the performance, it is critical to maintain balance to ensure optimal efficiency. **Task**: Implement the `AVL Tree` (a self-balancing Binary Search Tree) class, which has the same functionalities as the BST but ensures logarithmic time complexity by maintaining balance after every insertion. Implement the following methods: 1. `insert(data)` - Insert a node into the AVL tree and maintain the balance. 2. `search(data)` - Search if a specific data value exists in the tree. 3. `size()` - Return the number of elements in the tree. 4. `preorder()` - Return a list of elements in preorder traversal. 5. `inorder()` - Return a list of elements in inorder traversal. 6. `postorder()` - Return a list of elements in postorder traversal. **Constraints**: - The `insert` method must maintain balance during insertion using rotations. - Assume no duplicate values will be inserted. **Input/Output**: - **Input**: A series of methods calls with appropriate data. - **Output**: Outputs should be generated by calling methods on the AVL tree object. **Example**: `avl_tree = AVL()` - `avl_tree.insert(10)` - `avl_tree.insert(20)` - `avl_tree.insert(5)` - `avl_tree.insert(4)` - `avl_tree.insert(6)` - `avl_tree.search(4)` ➞ `True` - `avl_tree.size()` ➞ `5` - `avl_tree.inorder()` ➞ `[4, 5, 6, 10, 20]` **Scenario**: Your team is working on making statistical computations more efficient. By ensuring the tree remains balanced regardless of insert order, you enhance both the speed and reliability of search-related operations. AVL trees offer the balanced structure necessary for achieving consistently good performance.","solution":"class AVLNode: def __init__(self, key): self.key = key self.height = 1 self.left = None self.right = None class AVLTree: def insert(self, root, key): if not root: return AVLNode(key) elif key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.getHeight(root.left), self.getHeight(root.right)) balance = self.getBalance(root) if balance > 1 and key < root.left.key: return self.rightRotate(root) if balance < -1 and key > root.right.key: return self.leftRotate(root) if balance > 1 and key > root.left.key: root.left = self.leftRotate(root.left) return self.rightRotate(root) if balance < -1 and key < root.right.key: root.right = self.rightRotate(root.right) return self.leftRotate(root) return root def search(self, root, key): if not root: return False if root.key == key: return True if root.key < key: return self.search(root.right, key) return self.search(root.left, key) def size(self, root): if not root: return 0 return 1 + self.size(root.left) + self.size(root.right) def preorder(self, root, res): if root: res.append(root.key) self.preorder(root.left, res) self.preorder(root.right, res) return res def inorder(self, root, res): if root: self.inorder(root.left, res) res.append(root.key) self.inorder(root.right, res) return res def postorder(self, root, res): if root: self.postorder(root.left, res) self.postorder(root.right, res) res.append(root.key) return res def getHeight(self, root): if not root: return 0 return root.height def getBalance(self, root): if not root: return 0 return self.getHeight(root.left) - self.getHeight(root.right) def leftRotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.getHeight(z.left), self.getHeight(z.right)) y.height = 1 + max(self.getHeight(y.left), self.getHeight(y.right)) return y def rightRotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.getHeight(z.left), self.getHeight(z.right)) y.height = 1 + max(self.getHeight(y.left), self.getHeight(y.right)) return y class AVL: def __init__(self): self.root = None self.tree = AVLTree() def insert(self, key): self.root = self.tree.insert(self.root, key) def search(self, key): return self.tree.search(self.root, key) def size(self): return self.tree.size(self.root) def preorder(self): return self.tree.preorder(self.root, []) def inorder(self): return self.tree.inorder(self.root, []) def postorder(self): return self.tree.postorder(self.root, [])"},{"question":"# Context In many real-world applications, such as database management systems or network communications, binary trees need to be saved or transmitted efficiently. Your task is to implement the core functions to serialize and deserialize a binary tree. Serialization converts the tree to a single string, while deserialization restores the tree from that string. # Problem Statement Implement two functions: 1. `serialize(root: TreeNode) -> str`: This function takes the root of a binary tree and returns its serialized string representation. 2. `deserialize(data: str) -> TreeNode`: This function takes a serialized string representation of a binary tree and returns the root of the deserialized tree. # Input and Output Formats - `serialize` Function: * **Input**: A TreeNode `root` representing the root of the binary tree. * **Output**: A string representing the serialized binary tree. - `deserialize` Function: * **Input**: A string `data` representing the serialized binary tree. * **Output**: A TreeNode representing the root of the deserialized binary tree. # Constraints and Performance Requirements - The binary tree can have up to 1000 nodes. - Values stored in the tree nodes are integers. - Null nodes should be represented by `#`. - Elements are separated by spaces in the string representation. # Example Consider the following tree structure: ``` 1 / 2 3 / 4 5 ``` Serialization The serialized string representation of the above tree should be: `\\"1 2 # # 3 4 # # 5 # #\\"` Deserialization Given the serialized string `\\"1 2 # # 3 4 # # 5 # #\\"`, the deserialization function should reconstruct the binary tree as illustrated above. # Implementation Details - You must implement the TreeNode class (if not already provided in the environment) and the serialize and deserialize functions. - Consider edge cases such as an empty tree or trees with only single child nodes. **Note**: Do not use any global variables to maintain the state. Each function call should be independent.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Encodes a tree to a single string. def helper(node): if node is None: result.append(\\"#\\") else: result.append(str(node.val)) helper(node.left) helper(node.right) result = [] helper(root) return \\" \\".join(result) def deserialize(data): Decodes your encoded data to tree. def helper(): val = next(vals) if val == \\"#\\": return None node = TreeNode(int(val)) node.left = helper() node.right = helper() return node vals = iter(data.split()) return helper()"},{"question":"# Binary Tree Preorder Traversal with Additional Feature **Context**: Preorder traversal is fundamental in tree-related manipulations. However, in many practical applications, including visits in the traversal that meet a specific condition can be beneficial. Suppose we need to count the number of nodes that satisfy a given condition during the traversal. **Problem**: You are required to modify the preorder traversal algorithm to count the number of nodes that satisfy a certain condition during the traversal. **Implementation**: 1. **Function to Implement**: `def preorder_and_count(root: Node, condition: callable) -> (List[int], int):` 2. **Input**: * `root` (Node): Root node of the binary tree. * `condition` (callable): A function that takes an integer and returns a boolean. This will be used to test each node\'s value. 3. **Output**: * A tuple containing: - A list of values resulting from preorder traversal of the binary tree. - An integer count of the number of nodes whose values satisfy the condition. 4. **Constraints**: * The binary tree can have up to (10^5) nodes. * The node values are integers. * The condition function will run in (O(1)) time. **Examples**: ```python # Example of Node class and function class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right # Example tree # 5 # / # 3 8 # / # 2 4 9 root = Node(5, Node(3, Node(2), Node(4)), Node(8, None, Node(9))) # Example condition function def is_even(x): return x % 2 == 0 # Calling the implemented function preorder_and_count(root, is_even) ``` **Expected Output**: ```python ([5, 3, 2, 4, 8, 9], 3) ``` Explanation: - Preorder traversal: [5, 3, 2, 4, 8, 9] - Node values satisfying `is_even`: 2, 4, 8 - Count: 3","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def preorder_and_count(root: Node, condition: callable) -> (list, int): def preorder(node): if not node: return traversal.append(node.val) if condition(node.val): count[0] += 1 preorder(node.left) preorder(node.right) traversal = [] count = [0] preorder(root) return traversal, count[0]"},{"question":"# Gnome Sort Algorithm Implementation Challenge Given an array of integers, you need to implement the Gnome Sort algorithm to sort the array. This algorithm repeatedly compares adjacent elements and swaps them if they are in the wrong order. When a swap is made, it steps one element back to ensure all previous elements are in order before moving forward again. Your task is to complete the function to perform this sort. Function Signature ```python def gnome_sort(arr: List[int]) -> List[int]: # Implementation goes here ``` Input * A list of integers `arr` where `1 <= len(arr) <= 10^5` and `-10^5 <= arr[i] <= 10^5`. Output * A sorted list of integers in non-decreasing order. Examples 1. Input: `[34, 2, 10, -9]` Output: `[-9, 2, 10, 34]` 2. Input: `[3, 2, 1]` Output: `[1, 2, 3]` 3. Input: `[1, 2, 3, 4, 5]` Output: `[1, 2, 3, 4, 5]` Constraints * You must implement the sorting in-place. * Think about edge cases, including empty arrays, and how you will handle large arrays efficiently. Performance Requirements Your implementation should handle arrays up to the provided constraints within reasonable time limits (generally, within a few seconds for maximum constraints).","solution":"from typing import List def gnome_sort(arr: List[int]) -> List[int]: index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"You are tasked to extend the functionality of the given Monomial and Polynomial classes to include differentiation capabilities. Differentiation is a core operation in calculus representing the rate of change of a variable. Task Implement the following methods to differentiate Monomials and Polynomials: 1. `Monomial.differentiate(variable: int) -> Monomial` 2. `Polynomial.differentiate(variable: int) -> Polynomial` # Function Specifications Monomial.differentiate - **Input**: An integer variable representing the variable with respect to which differentiation is to be performed. - **Output**: A new Monomial instance representing the derivative of the current Monomial. - **Constraints**: Follow the rules of differentiation and handle edge cases like differentiating constants and non-existent variables. - **Exceptions**: Raise `ValueError` when differentiating a non-existent variable. Polynomial.differentiate - **Input**: An integer variable representing the variable with respect to which differentiation is to be performed. - **Output**: A new Polynomial instance representing the derivative of the current Polynomial. - **Constraints**: Utilize the differentiation method of Monomials for each Monomial in the Polynomial. - **Exceptions**: Raise `ValueError` when differentiating with respect to a non-existent variable. # Examples ```python # Example for Monomial differentiation m1 = Monomial({1:2}, 3) # Representing 3a_1^2 d_m1 = m1.differentiate(1) # Expected: Monomial({1:1}, 6) which is 6a_1 # Example for Polynomial differentiation p1 = Polynomial([{1:2}, {2:3}, 5]) # Representing a polynomial d_p1 = p1.differentiate(1) # Differentiate w.r.t variable \'a_1\' ``` You may assume the Monomial and Polynomial classes already follow the structure and methods defined in the provided code snippets. Extend these classes to implement the differentiation functionality.","solution":"class Monomial: def __init__(self, variables, coefficient): self.variables = variables # A dictionary {variable: exponent} self.coefficient = coefficient def differentiate(self, variable): if variable not in self.variables: raise ValueError(f\\"Variable a_{variable} does not exist in the monomial.\\") if self.variables[variable] == 0: return Monomial({}, 0) new_vars = self.variables.copy() new_vars[variable] -= 1 if new_vars[variable] == 0: del new_vars[variable] new_coefficient = self.coefficient * self.variables[variable] return Monomial(new_vars, new_coefficient) def __eq__(self, other): return self.variables == other.variables and self.coefficient == other.coefficient class Polynomial: def __init__(self, monomials): self.monomials = monomials # A list of Monomial objects def differentiate(self, variable): differentiated_monomials = [] for monomial in self.monomials: try: differentiated_monomials.append(monomial.differentiate(variable)) except ValueError: pass return Polynomial(differentiated_monomials) def __eq__(self, other): return self.monomials == other.monomials"},{"question":"# Scenario You are part of a robotics team in charge of programming a robot to navigate a grid-based maze. The goal is for the robot to start at the top-left corner and find the shortest path to the bottom-right corner, only stepping on allowed cells (cells with a value of 1). If there is no possible path, the robot should determine that and report appropriately. # Task Implement a function `maze_search(maze)` which takes a 2D list representing the maze as an input and returns the minimum number of steps needed for the robot to reach the bottom-right corner from the top-left corner. If there is no valid path, return -1. # Input Format - `maze`: a list of lists of integers. Each sublist represents a row in the maze grid where: - `1` represents an allowed cell the robot can step on. - `0` represents a blocked cell the robot cannot step on. # Output Format - An integer representing the minimum number of steps required to reach the target or -1 if there is no valid path. # Constraints - The maze (grid) will have at least 1 row and 1 column. - The number of rows and columns will not exceed 1000. # Performance Requirements - Your implementation should handle large grids efficiently using optimized searching techniques. # Example ```python # Example 1 maze = [ [1, 0, 1, 1, 1, 1], [1, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 1], [1, 1, 1, 0, 1, 1] ] print(maze_search(maze)) # Output: 14 # Example 2 maze = [ [1, 0, 0], [0, 1, 1], [0, 1, 1] ] print(maze_search(maze)) # Output: -1 ``` # Instructions - Provide a clear and concise implementation of the `maze_search` function. - Consider edge cases and validate inputs where necessary. - Ensure that your code is efficient and follows best coding practices.","solution":"from collections import deque def maze_search(maze): Finds the minimum number of steps to reach the bottom-right corner of the maze from the top-left corner. Returns -1 if no valid path exists. if not maze or not maze[0] or maze[0][0] == 0 or maze[-1][-1] == 0: return -1 rows, cols = len(maze), len(maze[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: r, c, steps = queue.popleft() if r == rows - 1 and c == cols - 1: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and maze[nr][nc] == 1: queue.append((nr, nc, steps + 1)) visited.add((nr, nc)) return -1"},{"question":"# Task: Implement a Median Finder using a Binary Heap Context You are to implement a class `MedianFinder` that keeps track of a list of numbers. The class should support the following methods: * `add_num(self, num: int) -> None`: Adds a number to the internal data structure. * `find_median(self) -> float`: Returns the median of all elements so far. The purpose is to maintain an efficient way to add numbers and calculate the median quickly. Implementation Details - Use two Binary Heaps: 1. A Max-Heap to store the smaller half of the list. 2. A Min-Heap to store the larger half of the list. - Balance the heaps such that the size difference between them is at most 1. Input and Output - `add_num(num: int)`: method to add a number to the rolling data structure. * **Arguments**: an integer number to be added. * **Output**: none. - `find_median()`: method to calculate and return the median of numbers added so far. * **Arguments**: none. * **Output**: a floating-point number representing the median. Constraints * The input numbers are all integers. * Total number of add operations will not exceed 10<sup>6</sup>. * The find_median operation will be called at least once after at least one call to add_num. Performance Requirements - Adding a number should take on average O(log N). - Finding the median should take O(1).","solution":"import heapq class MedianFinder: def __init__(self): Initialize two heaps: - max-heap for the smaller half (inverted min-heap in Python) - min-heap for the larger half self.small = [] # Max-heap (inverted to min-heap with negated values) self.large = [] # Min-heap def add_num(self, num: int) -> None: Add a number into the data structure. # Elements in `small` are negated to simulate a max-heap using min-heap if not self.small or num <= -self.small[0]: heapq.heappush(self.small, -num) else: heapq.heappush(self.large, num) # Balance heaps: `small` should have the same number of elements or one more than `large` if len(self.small) > len(self.large) + 1: heapq.heappush(self.large, -heapq.heappop(self.small)) elif len(self.large) > len(self.small): heapq.heappush(self.small, -heapq.heappop(self.large)) def find_median(self) -> float: Return the median of current data. if len(self.small) > len(self.large): return -self.small[0] else: return (-self.small[0] + self.large[0]) / 2.0"},{"question":"# Question You are given the task of implementing a function to count the number of digits in a given integer. # Function Definition ```python def count_digits(n: int) -> int: ``` # Input - `n`: an integer, which can be positive, negative, or zero. # Output - Returns an integer representing the number of digits in the input number. # Constraints - Do not convert the number to a string. - The function should handle any integer input within the range of standard 32-bit integers (-2,147,483,648 to 2,147,483,647). # Example ```python assert count_digits(0) == 1 assert count_digits(123456) == 6 assert count_digits(-789) == 3 assert count_digits(1000) == 4 ``` # Explanation 1. For `count_digits(0)`, the output is `1` because zero has only one digit. 2. For `count_digits(123456)`, the output is `6` because `123456` contains six digits. 3. For `count_digits(-789)`, the output is `3` because the number of digits in `789` is three (negatives are counted without the sign). 4. For `count_digits(1000)`, the output is `4` because `1000` contains four digits. Your solution should ensure that it runs efficiently with O(1) time complexity while adhering to the constraints specified.","solution":"def count_digits(n: int) -> int: Returns the number of digits in the integer n. if n == 0: return 1 count = 0 # Handle negative numbers if n < 0: n = -n while n > 0: count += 1 n //= 10 return count"},{"question":"# RSA Encryption and Decryption You are required to implement a key pair generation function and utilize it to carry out encryption and decryption using the RSA algorithm. **Function Specs**: 1. **generate_key(k: int) -> Tuple[int, int, int]** - Generates and returns an RSA key pair — public key (n, e) and private key d. - `k` is the number of bits in the modulus ( n ). 2. **encrypt(data: int, e: int, n: int) -> int** - Encrypts the given data using the public key. 3. **decrypt(data: int, d: int, n: int) -> int** - Decrypts the given encrypted data using the private key. # Input - An integer `k` for the number of bits in the modulus ( n ). - An integer `data` to be encrypted and decrypted. * Constraints: - (16 leq k leq 2048) - (0 leq data < 2^{k-1}) # Output - The function `generate_key` should return a tuple `(n, e, d)`. - The function `encrypt` should return an integer result of the encrypted data. - The function `decrypt` should return an integer result of the decrypted data. # Example ```python def test_rsa(): k = 16 n, e, d = generate_key(k) # Sample data for encryption and decryption data = 20 encrypted_data = encrypt(data, e, n) decrypted_data = decrypt(encrypted_data, d, n) assert decrypted_data == data, \\"The decrypted data does not match the original data.\\" print(\\"RSA encryption and decryption successful.\\") test_rsa() ``` # Notes - Assure primality checking within `generate_key`. - Handle edge cases such as invalid selections of `p` or `q`.","solution":"import random from sympy import isprime, mod_inverse from typing import Tuple def generate_prime_candidate(length): # Generates an odd integer randomly in the range from 2^(length-1) to 2^length. p = random.getrandbits(length) # Apply a mask to set MSB and LSB to 1 to ensure prime candidate of length \'length\' p |= (1 << (length - 1)) | 1 return p def generate_prime_number(length): p = 4 # Keep generating while the number is not prime while not isprime(p): p = generate_prime_candidate(length) return p def generate_key(k: int) -> Tuple[int, int, int]: Generates RSA key pair — public key (n, e) and private key d. e = 65537 # Commonly used prime number for public exponent # Generate two distinct prime numbers p and q p = generate_prime_number(k // 2) q = generate_prime_number(k // 2) while p == q: q = generate_prime_number(k // 2) n = p * q phi = (p - 1) * (q - 1) # Compute the private exponent d d = mod_inverse(e, phi) return (n, e, d) def encrypt(data: int, e: int, n: int) -> int: Encrypts the given data using the public key. return pow(data, e, n) def decrypt(data: int, d: int, n: int) -> int: Decrypts the given encrypted data using the private key. return pow(data, d, n)"},{"question":"# Question: Word Pattern Match You are tasked with implementing a function that determines if a given string follows a specified pattern. A full match means there is a bijection between a letter in the pattern and a non-empty word in the string. Function Signature: ```python def word_pattern(pattern: str, str: str) -> bool: ``` Input: * `pattern`: A string of lowercase letters representing the pattern. * `str`: A string of lowercase words separated by a single space. Output: * Return `True` if the `str` follows the specified `pattern`. * Return `False` otherwise. Examples: ```python assert word_pattern(\\"abba\\", \\"dog cat cat dog\\") == True assert word_pattern(\\"abba\\", \\"dog cat cat fish\\") == False assert word_pattern(\\"aaaa\\", \\"dog cat cat dog\\") == False assert word_pattern(\\"abba\\", \\"dog dog dog dog\\") == False ``` Constraints: * Pattern contains only lowercase letters. * The `str` is composed of lowercase words separated by single spaces. # Scenario Imagine you are developing a command interpreter that triggers specific actions based on pre-defined patterns of inputs. To ensure correct execution, you need to verify that the sequence of commands strictly follows the expected pattern. Detailed Requirements: Implement the function according to the steps, ensuring it accounts for edge cases such as: * Pattern length differs from the total number of words in the string. * Repeated characters in pattern incorrectly mapped to different words. * Correct one-to-one bijection is maintained. This function is critical in ensuring the integrity of command execution based on the recognized patterns.","solution":"def word_pattern(pattern: str, str: str) -> bool: words = str.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for p, w in zip(pattern, words): if p in char_to_word: if char_to_word[p] != w: return False else: if w in word_to_char: return False char_to_word[p] = w word_to_char[w] = p return True"},{"question":"Write a Python function `fibonacci_matrix(n: int) -> int` to compute the nth Fibonacci number using matrix exponentiation. # Input: * A single integer ( n ) (0 ≤ n ≤ 10^18) # Output: * The nth Fibonacci number. # Constraints: * The result should be returned modulo ( 10^9 + 7 ). # Function Signature ```python def fibonacci_matrix(n: int) -> int: pass ``` # Example ```python assert fibonacci_matrix(0) == 0 assert fibonacci_matrix(1) == 1 assert fibonacci_matrix(10) == 55 assert fibonacci_matrix(100) == 354224848179261915075 ``` # Performance Requirements * The implementation must be efficient considering the large potential size of ( n ). Ensure that (O(log{n})) time complexity is respected using matrix exponentiation. # Hints: 1. Utilize the transformation matrix for Fibonacci sequence, where the nth Fibonacci number can be derived from ( T^n cdot begin{bmatrix} F_1 F_0 end{bmatrix} ). 2. The transformation matrix to be used is: [ T = begin{bmatrix} 1 & 1 1 & 0 end{bmatrix} ] # Implementation Considerations: * Handle edge cases where ( n = 0 ) and ( n = 1 ) directly. * Efficiently use the matrix exponentiation principle to compute large powers.","solution":"def matrix_multiply(A, B, mod): Multiplies two 2x2 matrices A and B under modulo `mod`. return [ [(A[0][0] * B[0][0] + A[0][1] * B[1][0]) % mod, (A[0][0] * B[0][1] + A[0][1] * B[1][1]) % mod], [(A[1][0] * B[0][0] + A[1][1] * B[1][0]) % mod, (A[1][0] * B[0][1] + A[1][1] * B[1][1]) % mod] ] def matrix_power(matrix, n, mod): Computes the n-th power of a 2x2 matrix under modulo `mod`. result = [[1, 0], [0, 1]] # Identity matrix base = matrix while n > 0: if n % 2 == 1: result = matrix_multiply(result, base, mod) base = matrix_multiply(base, base, mod) n //= 2 return result def fibonacci_matrix(n: int) -> int: Computes the n-th Fibonacci number using matrix exponentiation. if n == 0: return 0 elif n == 1: return 1 MOD = 10**9 + 7 F = [[1, 1], [1, 0]] result = matrix_power(F, n - 1, MOD) return result[0][0] # F(n) is located at result matrix [0][0]"},{"question":"**Question**: Implement a function `k_th_from_end(head, k)` that returns the k-th node from the end of a singly linked list. The k-th node from the end is the node that is k nodes away from the last node of the list. Assume that k is always less than or equal to the length of the list and it’s a 1-indexed k (i.e., k=1 gives the last node). # Function Signature ```python def k_th_from_end(head: ListNode, k: int) -> ListNode: ``` # Input - `head`: The head node of the singly linked list. - `k`: An integer representing the position from the end (1-indexed). # Output - Return the k-th node from the end of the singly linked list. # Example ```python # Assume ListNode is a class representing a node in the linked list with attributes val and next. # Example: # List: 1 -> 2 -> 3 -> 4 -> 5, k=2 # The 2nd node from the end is 4. # Let\'s assume ListNode class is defined as follows: class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) print(k_th_from_end(head, 2).val) # Output: 4 ``` # Constraints * The length of the list is at least 1. * `1 <= k <= length of the list`. # Scenario/Context You are working with a linked list data structure and need to efficiently retrieve an element based on its relative position from the end, which is a frequent operation in various algorithms and real-world problems, such as buffer management in streaming applications. # Notes - Ensure that your implementation is efficient. - Handle cases where the length of the list is exactly k.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def k_th_from_end(head: ListNode, k: int) -> ListNode: Returns the k-th node from the end of a singly linked list. first = head second = head # Move first k steps ahead for i in range(k): first = first.next # Move both first and second until first reaches the end while first is not None: first = first.next second = second.next return second"},{"question":"Interval Merging with Advanced Interval Features Given the `Interval` class and the current implementation features described below, extend its functionality to include: 1. **Interval Intersection**: Write a method `intersection` that takes two intervals and returns their intersection as a new interval. If they do not overlap, return an interval with the same start and end point (empty interval). 2. **Interval Difference**: Write a method `difference` that takes two intervals and returns the difference (i.e., parts of the first interval not covered by the second interval) as a list of intervals. If the intervals do not overlap, return the original interval. Expected Input and Output Formats 1. **Intersection**: ```python def intersection(self, other: \'Interval\') -> \'Interval\': pass ``` *Input*: Interval (2, 6), Interval (5, 8) *Output*: Interval (5, 6) 2. **Difference**: ```python def difference(self, other: \'Interval\') -> List[\'Interval\']: pass ``` *Input*: Interval (1, 5), Interval (3, 4) *Output*: [Interval (1, 3), Interval (4, 5)] Constraints - Intervals only contain integers. - Assuming all intervals are valid with start < end. Requirements - Implement the methods within the `Interval` class. - Ensure the code handles edge cases effectively. - Optimize for readability and efficiency. # Scenario You are working on a calendar application where intervals represent busy time slots. Efficient merging and intersection of intervals can significantly improve scheduling tasks for users. Stub Code ```python class Interval: def __init__(self, start=0, end=0): self.start = start self.end = end def __repr__(self): return \\"Interval({}, {})\\".format(self.start, self.end) # Methods (includes __contains__, merge, etc.) def intersection(self, other: \'Interval\') -> \'Interval\': # TODO: Implement this method pass def difference(self, other: \'Interval\') -> List[\'Interval\']: # TODO: Implement this method pass ```","solution":"class Interval: def __init__(self, start=0, end=0): self.start = start self.end = end def __repr__(self): return \\"Interval({}, {})\\".format(self.start, self.end) def intersection(self, other: \'Interval\') -> \'Interval\': Returns the intersection of the current interval with another interval. If there is no intersection, return an interval with the same start and end point (empty interval). new_start = max(self.start, other.start) new_end = min(self.end, other.end) if new_start >= new_end: return Interval(new_start, new_start) # Empty interval else: return Interval(new_start, new_end) def difference(self, other: \'Interval\') -> list[\'Interval\']: Returns the difference between the current interval and another interval as a list of intervals representing the parts of the first interval not covered by the second interval. if other.end <= self.start or other.start >= self.end: return [Interval(self.start, self.end)] # No overlap results = [] if other.start > self.start: results.append(Interval(self.start, min(self.end, other.start))) if other.end < self.end: results.append(Interval(max(self.start, other.end), self.end)) return results"},{"question":"# Coding Challenge: Pattern Matching Objective Implement a function to determine if a given string follows a specific pattern represented by a sequence of characters. Problem Statement Given a pattern and a string, determine if the string follows the same pattern. Follow means a full match, ensuring a unique association between each character in the pattern and each word in the string. You are to implement a function `def word_pattern(pattern: str, input_str: str) -> bool` that satisfies the conditions. Input Format - `pattern`: a string of lowercase characters. - `input_str`: a string of lowercase words separated by a single space. Output Format - A boolean value (`True` or `False`) indicating whether the string follows the described pattern. Constraints - Each pattern character must map to a unique word. - Both pattern and input string are non-empty and well-formed. - No character in the pattern will map to more than one distinct word, and no word will map to more than one character. Example 1. **Input**: `pattern = \\"abba\\"`, `input_str = \\"dog cat cat dog\\"` **Output**: `True` 2. **Input**: `pattern = \\"abba\\"`, `input_str = \\"dog cat cat fish\\"` **Output**: `False` 3. **Input**: `pattern = \\"aaaa\\"`, `input_str = \\"dog cat cat dog\\"` **Output**: `False` 4. **Input**: `pattern = \\"abba\\"`, `input_str = \\"dog dog dog dog\\"` **Output**: `False` Guidance 1. Divide the input string into individual words. 2. Ensure the length of the pattern matches the number of words. 3. Use a hash map to establish the character-to-word mapping. 4. Verify no duplicate mappings or contradictions in established mappings.","solution":"def word_pattern(pattern: str, input_str: str) -> bool: Determine if the input string follows the pattern. words = input_str.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word and char_to_word[char] != word: return False if word in word_to_char and word_to_char[word] != char: return False char_to_word[char] = word word_to_char[word] = char return True"},{"question":"# Word Squares Generation with Prefix-based Backtracking You are given a list of unique words. A word square is a sequence of words such that the kth row and column read the exact same string, where 0 ≤ k < max(numRows, numColumns). Write a function `generate_word_squares(words)` that produces all possible word squares that can be built from the given list of words. Each word in the list has the same length. **Example 1:** ```plaintext Input: [\\"area\\",\\"lead\\",\\"wall\\",\\"lady\\",\\"ball\\"] Output: [ [\\"wall\\", \\"area\\", \\"lead\\", \\"lady\\" ], [\\"ball\\", \\"area\\", \\"lead\\", \\"lady\\" ] ] ``` **Input Format**: * A list of strings `words` where each string is composed of only lowercase English letters. * The length of each word is the same. **Output Format**: * A list of lists, where each inner list represents a word square. **Constraints**: * 1 ≤ number of words ≤ 1000 * 1 ≤ length of each word ≤ 5 * All words are unique. **Function Signature**: ```python def generate_word_squares(words) -> List[List[str]]: pass ``` **Performance Requirements**: Your solution should aim for O(N * M^L) time complexity, where N is the number of words and M is the word length. **Scenario**: Imagine you\'re designing a word puzzle where you want to suggest Word Squares to the players based on provided words. Your function `generate_word_squares` should effectively output all possible valid word squares. *Tip*: Use prefixes to optimize the backtracking search and prune invalid candidates early.","solution":"from typing import List, Dict def build_prefix_dict(words: List[str]) -> Dict[str, List[str]]: prefix_dict = {} for word in words: for i in range(len(word)): prefix = word[:i] if prefix in prefix_dict: prefix_dict[prefix].append(word) else: prefix_dict[prefix] = [word] return prefix_dict def backtrack(index: int, word_square: List[str], results: List[List[str]], prefix_dict: Dict[str, List[str]]): if index == len(word_square[0]): results.append(word_square[:]) return prefix = \'\'.join(word[index] for word in word_square) if prefix in prefix_dict: for candidate in prefix_dict[prefix]: word_square.append(candidate) backtrack(index + 1, word_square, results, prefix_dict) word_square.pop() def generate_word_squares(words: List[str]) -> List[List[str]]: if not words: return [] prefix_dict = build_prefix_dict(words) results = [] for word in words: backtrack(1, [word], results, prefix_dict) return results"},{"question":"# Question: Implement Huffman Encoding and Decoding in Python Given a text file, implement a Huffman encoding and decoding solution that compresses the text data and then decompresses it back to the original text. # Objective 1. Implement the Huffman encoding algorithm to compress a given text file. 2. Implement the Huffman decoding algorithm to decompress the encoded file back to the original text. 3. Ensure that encoded data is stored in a binary format. # Function Signatures ```python class HuffmanCoding: @staticmethod def encode_file(file_in_name: str, file_out_name: str) -> None: Compress the text data from file_in_name and write the compressed data to file_out_name. :param file_in_name: str, input text file name :param file_out_name: str, output binary file name to store encoded data @staticmethod def decode_file(file_in_name: str, file_out_name: str) -> None: Decompress the encoded data from file_in_name and write the original text to file_out_name. :param file_in_name: str, input binary file name containing encoded data :param file_out_name: str, output text file name to store the decoded text ``` # Constraints * You can assume that the input text file will contain standard ASCII characters. * The encoded output should be in a binary format, ensuring that it is read and written correctly. * The input text file size will not exceed 10 MB. # Example Usage ```python # Encoding HuffmanCoding.encode_file(\\"input.txt\\", \\"encoded.bin\\") # Decoding HuffmanCoding.decode_file(\\"encoded.bin\\", \\"decoded.txt\\") ``` # Requirements 1. **Frequency Calculation**: Count the frequency of each character in the input text. 2. **Huffman Tree Construction**: Build the Huffman tree based on character frequencies. 3. **Code Generation**: Generate the Huffman codes for each character. 4. **Encoding**: Use the generated codes to encode the input text and write the binary output to the file. 5. **Tree Storage**: Store the Huffman tree structure in the binary file to facilitate decoding. 6. **Decoding**: Read the encoded binary data and the Huffman tree to reconstruct the original text. # Evaluation Criteria * Correctness: The decoded text should match the original input text exactly. * Efficiency: Ensure that frequency counting, tree construction, encoding, and decoding are performed efficiently. * File Handling: Correct reading and writing of binary data and handling file IO errors. * Code Style: Clear and well-commented code to explain the thought process and steps involved.","solution":"import heapq import os from collections import Counter, defaultdict import pickle class HuffmanCoding: class Node: def __init__(self, char, freq): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq @staticmethod def encode_file(file_in_name: str, file_out_name: str) -> None: # Step 1: Calculate frequency of each character in the input file with open(file_in_name, \'r\') as file: text = file.read() frequency = HuffmanCoding.calculate_frequencies(text) # Step 2: Build Huffman Tree priority_queue = HuffmanCoding.build_priority_queue(frequency) root = HuffmanCoding.build_tree(priority_queue) # Step 3: Generate Huffman Codes huffman_codes = HuffmanCoding.generate_codes(root) # Step 4: Encode the text using Huffman Codes encoded_text = HuffmanCoding.encode_text(text, huffman_codes) # Step 5: Write encoded text and tree structure to binary file with open(file_out_name, \'wb\') as file: pickle.dump((root, encoded_text), file) @staticmethod def decode_file(file_in_name: str, file_out_name: str) -> None: # Step 1: Read encoded text and tree structure from binary file with open(file_in_name, \'rb\') as file: root, encoded_text = pickle.load(file) # Step 2: Decode the text using the Huffman Tree decoded_text = HuffmanCoding.decode_text(encoded_text, root) # Step 3: Write the decoded text to output file with open(file_out_name, \'w\') as file: file.write(decoded_text) @staticmethod def calculate_frequencies(text): return Counter(text) @staticmethod def build_priority_queue(frequencies): priority_queue = [] for char, freq in frequencies.items(): node = HuffmanCoding.Node(char, freq) heapq.heappush(priority_queue, node) return priority_queue @staticmethod def build_tree(priority_queue): while len(priority_queue) > 1: node1 = heapq.heappop(priority_queue) node2 = heapq.heappop(priority_queue) merged = HuffmanCoding.Node(None, node1.freq + node2.freq) merged.left = node1 merged.right = node2 heapq.heappush(priority_queue, merged) return heapq.heappop(priority_queue) @staticmethod def generate_codes(root): def _generate_codes_helper(node, current_code): if node is None: return if node.char is not None: codes[node.char] = current_code return _generate_codes_helper(node.left, current_code + \'0\') _generate_codes_helper(node.right, current_code + \'1\') codes = {} _generate_codes_helper(root, \\"\\") return codes @staticmethod def encode_text(text, codes): return \'\'.join([codes[char] for char in text]) @staticmethod def decode_text(encoded_text, root): decoded_text = [] current_node = root for bit in encoded_text: if bit == \'0\': current_node = current_node.left else: current_node = current_node.right if current_node.char is not None: decoded_text.append(current_node.char) current_node = root return \'\'.join(decoded_text)"},{"question":"# Question Problem Statement You are given a directed graph represented as an adjacency list. The graph does not contain any cycles (it is a DAG). Your task is to implement a function that returns one possible topological ordering of the vertices. Function Signature ```python def topological_sort(graph: Dict[Any, List[Any]]) -> List[Any]: pass ``` Inputs - `graph`: A dictionary where keys are nodes and values are lists of nodes that the key node has directed edges towards. For example, `{0: [1, 2], 1: [2], 2: [3], 3: []}`. Outputs - A list of nodes in one possible topological order. If the graph is empty, the function should return an empty list. Constraints - You can assume that the input graph is a DAG. - The graph may be disconnected. Example ```python graph = { 5: [2, 0], 4: [0, 1], 2: [3], 3: [1], 1: [], 0: [] } print(topological_sort(graph)) # Possible output: [5, 4, 2, 3, 1, 0] or any valid topological order ``` Notes - Ensure your solution handles disconnect graphs by considering each disconnected component independently. - Avoid cycles, as the graph is guaranteed to be a DAG. Evaluation - Your solution will be evaluated for correctness, clarity, and efficiency. - Ensure proper handling of edge cases such as empty graphs or graphs with single nodes.","solution":"def topological_sort(graph): Returns one possible topological ordering of the vertices in the given DAG. visited = set() result = [] def dfs(node): if node not in visited: visited.add(node) for neighbor in graph.get(node, []): dfs(neighbor) result.append(node) for node in graph: dfs(node) return result[::-1]"},{"question":"You are given the root of a binary tree. Your task is to write a function to compute the maximum depth of the binary tree. # Function Signature ```python def max_height(root: TreeNode) -> int: ``` # Input - `root` (TreeNode): The root node of the binary tree. # Output - `int`: The maximum depth of the binary tree. # Example ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None tree = TreeNode(1) tree.left = TreeNode(2) tree.right = TreeNode(3) tree.left.left = TreeNode(4) tree.left.right = TreeNode(5) height = max_height(tree) print(\\"height:\\", height) # Output: 3 ``` # Constraints - The number of nodes in the tree is in the range [0, 10^4]. - The values of the nodes are unique. # Notes 1. Ensure your solution runs with a time complexity of O(n) and space complexity of O(d), where n is the number of nodes and d is the height of the tree. 2. Handle edge cases such as an empty tree (`root` is `None`) and a tree with a single node correctly. # Scenario Imagine you are developing a feature for visualizing the depth of organizational hierarchies represented as a binary tree. Accurate computation of the maximum depth of such trees is crucial for better rendering and space allocation in the visual representation.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_height(root: TreeNode) -> int: Compute the maximum depth of the binary tree. Args: root (TreeNode): The root node of the binary tree. Returns: int: The maximum depth of the binary tree. if root is None: return 0 left_depth = max_height(root.left) right_depth = max_height(root.right) return 1 + max(left_depth, right_depth)"},{"question":"# Question: Stack Max Element Retrieval **Context**: Stacks are often required to keep track of a maximum element from time to time. This problem has applications in designing custom data structures required by systems to efficiently retrieve the maximum element, such as in stock span problems, managing rolling windows in large datasets, etc. **Task**: You are required to implement a special stack that supports the following operations: 1. `push(x)` – Push element x onto stack. 2. `pop()` – Remove the element on top of the stack and return it. 3. `top()` – Get the top element. 4. `get_max()` – Retrieve the maximum element in the stack. Implement this stack using a data structure that ensures the `get_max` operation is efficient. Specifically, get_max should be done in constant time, O(1). **Requirement**: - Your stack should maintain the last operation\'s time complexity, which is `push` and `pop` in O(1) time complexity. ```python class MaxStack: def __init__(self): Initialize your data structure here. pass def push(self, x: int) -> None: Push element x onto stack. pass def pop(self) -> int: Remove the element on the top of the stack and return it. pass def top(self) -> int: Get the top element. pass def get_max(self) -> int: Retrieve the maximum element in the stack. pass # Your MaxStack object will be instantiated and called as such: # obj = MaxStack() # obj.push(x) # param_2 = obj.pop() # param_3 = obj.top() # param_4 = obj.get_max() ``` # Constraints: * All elements are assumed to be integers. * The stack can have a very large number of elements (even millions). # Performance Requirements: Your solution must ensure that `get_max` is performed in constant time, O(1). # Example: ```python # Example usage: stack = MaxStack() stack.push(10) stack.push(5) stack.push(15) assert stack.get_max() == 15 # max element is 15 assert stack.pop() == 15 # pops 15 assert stack.get_max() == 10 # max element now is 10 assert stack.top() == 5 # top element is 5 ```","solution":"class MaxStack: def __init__(self): Initialize your data structure here. self.stack = [] self.max_stack = [] def push(self, x: int) -> None: Push element x onto stack. self.stack.append(x) if not self.max_stack or x >= self.max_stack[-1]: self.max_stack.append(x) def pop(self) -> int: Remove the element on the top of the stack and return it. if self.stack: top_element = self.stack.pop() if top_element == self.max_stack[-1]: self.max_stack.pop() return top_element def top(self) -> int: Get the top element. if self.stack: return self.stack[-1] def get_max(self) -> int: Retrieve the maximum element in the stack. if self.max_stack: return self.max_stack[-1] # Example usage: stack = MaxStack() stack.push(10) stack.push(5) stack.push(15) assert stack.get_max() == 15 # max element is 15 assert stack.pop() == 15 # pops 15 assert stack.get_max() == 10 # max element now is 10 assert stack.top() == 5 # top element is 5"},{"question":"# Objective Implement Kruskal\'s algorithm to find the Minimum Spanning Tree of an undirected graph. Your function should read multiple graphs from the input, compute the MST for each graph, and output the total weight of each MST. # Function Signature ```python def kruskal_mst(num_vertices: int, edges: List[Tuple[int, int, int]]) -> int: Calculate the weight of the minimum spanning tree (MST) using Kruskal\'s algorithm. Args: * num_vertices (int): The number of vertices in the graph. * edges (List[Tuple[int, int, int]]): The edges of the graph, where each edge is represented by a tuple (u, v, weight). Returns: * int: The total weight of the MST. ``` # Input and Output Formats * **Input**: * First line contains an integer `T` representing the number of test cases. * For each test case: * First line contains two integers `N` and `M` representing the number of vertices and edges respectively. * The following `M` lines each contain three integers `u`, `v`, and `weight` representing an edge between vertices `u` and `v` with weight `weight`. * **Output**: * For each test case, output a single integer representing the total weight of the MST. # Constraints * `1 <= N <= 1000` (number of vertices) * `1 <= M <= 20000` (number of edges) * `1 <= weight <= 1000` * Vertices are 1-indexed. # Example Input ``` 2 5 6 1 2 3 1 3 8 2 4 5 3 4 2 3 5 4 4 5 6 3 3 2 1 20 3 1 20 2 3 100 ``` # Example Output ``` 14 40 ``` # Explanation Each line contains the total weight of the MST for each graph given in the input.","solution":"from typing import List, Tuple def kruskal_mst(num_vertices: int, edges: List[Tuple[int, int, int]]) -> int: Calculate the weight of the minimum spanning tree (MST) using Kruskal\'s algorithm. Args: * num_vertices (int): The number of vertices in the graph. * edges (List[Tuple[int, int, int]]): The edges of the graph, where each edge is represented by a tuple (u, v, weight). Returns: * int: The total weight of the MST. # Helper functions def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 # Initialize the parent and rank for union-find parent = list(range(num_vertices + 1)) rank = [0] * (num_vertices + 1) # Kruskal\'s algorithm mst_weight = 0 # Sort edges based on weight edges.sort(key=lambda x: x[2]) for u, v, weight in edges: root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: union(parent, rank, root_u, root_v) mst_weight += weight return mst_weight"},{"question":"# Scenario You are writing a program to analyze combinatorial relationships in a large dataset. To do this efficiently, you need to calculate binomial coefficients for various pairs of n and k. However, you want to avoid deep recursion that could lead to stack overflow, especially for large inputs. # Task Implement a function `iterative_binomial_coefficient(n, k)` that calculates the binomial coefficient (C(n, k)) iteratively. This function should handle large values of n and k efficiently without the risks associated with recursion. # Function Signature ```python def iterative_binomial_coefficient(n: int, k: int) -> int: pass ``` # Input and Output * **Input**: * An integer ( n ) (0 ≤ n ≤ 10^5) - the number set. * An integer ( k ) (0 ≤ k ≤ n) - the size of the subset. * **Output**: * The binomial coefficient ( C(n, k) ). # Constraints 1. Ensure constraints (0 ≤ k ≤ n). 2. Optimize for large values of ( n ) and ( k ). 3. Avoid recursion to prevent stack overflow. # Example ```python iterative_binomial_coefficient(5, 0) -> 1 iterative_binomial_coefficient(8, 2) -> 28 iterative_binomial_coefficient(500, 300) -> 5054949849935535817667719165973249533761635252733275327088189563256013971725761702359997954491403585396607971745777019273390505201262259748208640 ``` # Additional Notes * Consider using the iterative approach and properties of symmetry ( C(n, k) = C(n, n-k) ) to reduce the computation. * Handle large intermediate values carefully to prevent integer overflow.","solution":"def iterative_binomial_coefficient(n: int, k: int) -> int: Calculate the binomial coefficient C(n, k) using an iterative approach. if k > n: return 0 if k == 0 or k == n: return 1 # Since C(n, k) = C(n, n-k) k = min(k, n - k) c = 1 for i in range(k): c = c * (n - i) // (i + 1) return c"},{"question":"# Question: You are given a text and a pattern. Implement a function `rabin_karp(pattern, text)` that returns the starting index of the first occurrence of the pattern in the text using the Rabin-Karp algorithm. If the pattern is not found in the text, return -1. # Function Signature: ```python def rabin_karp(pattern: str, text: str) -> int: pass ``` # Input: - `pattern (str)`: The substring to be searched within the text. - `text (str)`: The larger string where the search is performed. # Output: - `int`: The starting index of the first occurrence of the pattern, or -1 if the pattern is not found in the text. # Constraints: - The length of the text will not exceed 10^5 characters. - The length of the pattern will not exceed 10^3 characters. # Examples: ```python print(rabin_karp(\\"test\\", \\"this is a test string\\")) # Output: 10 print(rabin_karp(\\"not\\", \\"this is a test string\\")) # Output: -1 print(rabin_karp(\\"\\", \\"this\\")) # Output: -1 print(rabin_karp(\\"longerpattern\\", \\"short\\")) # Output: -1 ``` # Notes: - An empty pattern or text should return -1. - Ensure to handle cases where the pattern is longer than the text. - Optimize your implementation to work within the constraints efficiently.","solution":"def rabin_karp(pattern: str, text: str) -> int: Returns the starting index of the first occurrence of the pattern in the text using the Rabin-Karp algorithm. If the pattern is not found, returns -1. if not pattern or not text or len(pattern) > len(text): return -1 # Define the base and the modulus for hashing base = 256 modulus = 101 # Calculate the hash value of the pattern and the first window of text pattern_hash = 0 text_hash = 0 pattern_length = len(pattern) highest_power = 1 # base^(pattern_length-1) for i in range(pattern_length - 1): highest_power = (highest_power * base) % modulus for i in range(pattern_length): pattern_hash = (base * pattern_hash + ord(pattern[i])) % modulus text_hash = (base * text_hash + ord(text[i])) % modulus # Slide the pattern over text one character at a time for i in range(len(text) - pattern_length + 1): if pattern_hash == text_hash: # Check for actual matching when hash values match if text[i:i+pattern_length] == pattern: return i # Calculate hash value for the next window of text if i < len(text) - pattern_length: text_hash = (base * (text_hash - ord(text[i]) * highest_power) + ord(text[i + pattern_length])) % modulus # We might get negative value of text_hash, converting it to positive if text_hash < 0: text_hash += modulus return -1"},{"question":"You are tasked with implementing a secure communication system between two parties (Alice and Bob) using Diffie-Hellman Key Exchange. The system should ensure that both parties can share a common secret key securely over an insecure channel. Write a function `secure_communication(a: int, p: int) -> tuple` that performs the following tasks: 1. **Prime Checking**: Verify if `p` is a prime number using the `prime_check` algorithm. 2. **Primitive Root Verification**: Verify if `a` is a primitive root of `p` using the `find_primitive_root` algorithm. 3. **Key Exchange**: - Generate private and public keys for both Alice and Bob using `alice_private_key`, `alice_public_key`, `bob_private_key`, and `bob_public_key`. - Compute the shared secret key for both Alice and Bob using `alice_shared_key` and `bob_shared_key`. 4. **Consistency Check**: Ensure that the shared keys computed by Alice and Bob are identical. The function should return a tuple `(alice_shared_key: int, bob_shared_key: int)` representing the shared keys computed by Alice and Bob. Input Format: - `a` (int): A candidate primitive root. - `p` (int): A prime number. Output Format: - A tuple `(alice_shared_key: int, bob_shared_key: int)` representing the shared keys. Constraints: - `2 <= a < p <= 10^6` - Assume correct implementation of helper methods as provided. Example: ```python a = 5 p = 23 print(secure_communication(a, p)) # Output: (shared_key, shared_key) ``` Make sure to handle any errors or invalid inputs by raising appropriate errors. Assume that the helper methods are correctly implemented as provided.","solution":"import random def is_prime(n): Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_primitive_root(p): Find a primitive root of p. if p == 2: return 1 phi = p - 1 factors = set() n = phi i = 2 while i * i <= n: if n % i == 0: factors.add(i) while n % i == 0: n //= i i += 1 if n > 1: factors.add(n) for r in range(2, p): for factor in factors: if pow(r, phi // factor, p) == 1: break else: return r return -1 def secure_communication(a, p): if not is_prime(p): raise ValueError(\\"p must be a prime number\\") if find_primitive_root(p) != a: raise ValueError(\\"a must be a primitive root of p\\") alice_private_key = random.randint(2, p - 2) bob_private_key = random.randint(2, p - 2) alice_public_key = pow(a, alice_private_key, p) bob_public_key = pow(a, bob_private_key, p) alice_shared_key = pow(bob_public_key, alice_private_key, p) bob_shared_key = pow(alice_public_key, bob_private_key, p) if alice_shared_key != bob_shared_key: raise ValueError(\\"Shared keys do not match\\") return alice_shared_key, bob_shared_key"},{"question":"# Question Objective Write a Python function `verify_sorted_linked_list` that checks if a given singly linked list is sorted in non-decreasing order, and also returns the position where the sorting order is violated, if applicable. Function Signature ```python def verify_sorted_linked_list(head: \'ListNode\') -> Tuple[bool, Optional[int]]: pass ``` Input * `head` (ListNode): The head of the singly linked list. Output * Returns a tuple: * The first element is a boolean indicating if the list is sorted (`True` if sorted, `False` otherwise). * The second element is the 0-based index of the first node where the order is violated (or `None` if the list is sorted). Constraints * The linked list may contain any integer values. * The linked list length is in the range [0, 10^6]. Example ```python # ListNode definition for reference class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next # Example 1: # Input: 1 -> 2 -> 3 -> 4 # Output: (True, None) # Example 2: # Input: 1 -> 2 -> -1 -> 3 # Output: (False, 1) # Example 3: # Input: 3 -> 1 -> 2 -> 4 # Output: (False, 0) ``` Scenario You are given the head of a singly linked list and need to verify whether it is sorted in non-decreasing order. If it is not sorted, your function should return the position of the first node where the order is violated to assist in debugging or correction purposes.","solution":"from typing import Tuple, Optional class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def verify_sorted_linked_list(head: ListNode) -> Tuple[bool, Optional[int]]: if not head or not head.next: return (True, None) current = head index = 0 while current.next: if current.val > current.next.val: return (False, index) current = current.next index += 1 return (True, None)"},{"question":"# Scenario You are developing a mini-database for an online music streaming service where each song is identified by a unique numerical ID. You are required to efficiently store, retrieve, and manage information about the songs. # Task Implement a resizable hash table that maintains key-value pairs where the keys are song IDs, and the values are the song names. The hash table should dynamically resize and handle basic operations like insertion, deletion, and lookup efficiently. # Requirements 1. **Create a class `ResizableHashTable` that inherits from a provided `HashTable` class.** 2. **The `ResizableHashTable` should include the following methods:** - `put(key: int, value: str) -> None`: Inserts or updates the key-value pair. - `get(key: int) -> Union[str, None]`: Retrieves the value associated with the key. - `del_(key: int) -> None`: Deletes the key-value pair. - `__len__() -> int`: Returns the number of key-value pairs stored. 3. **The table should double in size when it is at least 2/3 full.** 4. **Implement the `__resize()` method to manage resizing and rehashing existing pairs.** # Constraints - The hash table should support keys as positive integers only. - The values are non-empty strings. - Initial size of the hash table should be 8. # Example Usage ```python music_db = ResizableHashTable() music_db.put(1, \\"Song A\\") music_db.put(2, \\"Song B\\") print(music_db.get(1)) # Output: \\"Song A\\" print(music_db.get(3)) # Output: None music_db.del_(2) print(music_db.get(2)) # Output: None print(len(music_db)) # Output: 1 ```","solution":"class HashTable: def __init__(self, initial_capacity=8): self.capacity = initial_capacity self.size = 0 self.table = [None] * self.capacity def _hash(self, key): return key % self.capacity class ResizableHashTable(HashTable): def __init__(self): super().__init__() def __resize(self): old_table = self.table self.capacity *= 2 self.table = [None] * self.capacity self.size = 0 for item in old_table: if item is not None: self.put(item[0], item[1]) def put(self, key: int, value: str) -> None: if self.size >= (2 * self.capacity) // 3: self.__resize() index = self._hash(key) while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = (key, value) return index = (index + 1) % self.capacity self.table[index] = (key, value) self.size += 1 def get(self, key: int): index = self._hash(key) start_index = index while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] index = (index + 1) % self.capacity if index == start_index: break return None def del_(self, key: int) -> None: index = self._hash(key) start_index = index while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = None self.size -= 1 rehash_index = (index + 1) % self.capacity while self.table[rehash_index] is not None: rehash_key, rehash_value = self.table[rehash_index] self.table[rehash_index] = None self.size -= 1 self.put(rehash_key, rehash_value) rehash_index = (rehash_index + 1) % self.capacity return index = (index + 1) % self.capacity if index == start_index: break def __len__(self) -> int: return self.size"},{"question":"# Binary Search Tree Implementation You are required to implement a Binary Search Tree (BST) class with the following functionalities: insertion, searching, deletion, in-order traversal, and finding the minimum and maximum values. Class Definition: ```python class BST: def __init__(self): self.root = None def insert(self, val: int) -> None: pass def search(self, val: int) -> bool: pass def delete(self, val: int) -> None: pass def inorder_traversal(self) -> list: pass def find_min(self) -> int: pass def find_max(self) -> int: pass ``` Input/Output: **insert(val: int) -> None**: - Inserts a value into the BST. - No output is needed. **search(val: int) -> bool**: - Searches for a value in the BST. - Outputs True if the value is found, otherwise False. **delete(val: int) -> None**: - Deletes a value from the BST if it exists. - No output is needed. **inorder_traversal() -> list**: - Performs an in-order traversal of the BST. - Outputs a list of values in non-decreasing order. **find_min() -> int**: - Finds the minimum value in the BST. - Outputs the minimum value. **find_max() -> int**: - Finds the maximum value in the BST. - Outputs the maximum value. Constraints: * Node values are unique within the BST. * Only integer values are inserted into the BST. * No duplicate values should be inserted. * Functions are expected to handle edge cases such as an empty tree and single-node tree. Example Usage: ```python # creating a BST instance bst = BST() # Inserting values bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) # Searching for values print(bst.search(5)) # Output: True print(bst.search(12)) # Output: False # In-order Traversal print(bst.inorder_traversal()) # Output: [3, 5, 7, 10, 15] # Finding minimum and maximum print(bst.find_min()) # Output: 3 print(bst.find_max()) # Output: 15 # Deleting values bst.delete(5) print(bst.inorder_traversal()) # Output: [3, 7, 10, 15] ``` **Note**: The implementation should ensure that the BST properties are maintained after each operation.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key: int) -> None: if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) elif key > root.val: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def search(self, key: int) -> bool: return self._search(self.root, key) def _search(self, root, key): if root is None: return False if root.val == key: return True elif key < root.val: return self._search(root.left, key) else: return self._search(root.right, key) def delete(self, key: int) -> None: self.root = self._delete(self.root, key) def _delete(self, root, key): if root is None: return root if key < root.val: root.left = self._delete(root.left, key) elif key > root.val: root.right = self._delete(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left temp_val = self._min_value_node(root.right).val root.val = temp_val root.right = self._delete(root.right, temp_val) return root def inorder_traversal(self) -> list: return self._inorder_traversal(self.root) def _inorder_traversal(self, root): res = [] if root is not None: res = self._inorder_traversal(root.left) res.append(root.val) res = res + self._inorder_traversal(root.right) return res def find_min(self) -> int: if self.root is None: raise ValueError(\\"BST is empty\\") return self._min_value_node(self.root).val def find_max(self) -> int: if self.root is None: raise ValueError(\\"BST is empty\\") return self._max_value_node(self.root).val def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def _max_value_node(self, node): current = node while current.right is not None: current = current.right return current"},{"question":"You are given two strings, `word1` and `word2`. Your task is to find the minimum number of delete operations required to make these two strings identical. To achieve this, implement a function using the dynamic programming approach to ensure optimal time and space complexity. # Function Signature ```python def minDistance(word1: str, word2: str) -> int: pass ``` # Input - `word1`: A string of length `m` where `1 <= m <= 1000`. - `word2`: A string of length `n` where `1 <= n <= 1000`. # Output - Returns an integer representing the minimum number of delete operations needed. # Constraints - The strings will consist only of lowercase English letters. # Example ```python # Example 1 word1 = \\"sea\\" word2 = \\"eat\\" assert minDistance(word1, word2) == 2 # Example 2 word1 = \\"leetcode\\" word2 = \\"etco\\" assert minDistance(word1, word2) == 4 ``` # Explanation In Example 1, the longest common subsequence is \\"ea\\", and we need to delete \'s\' from `word1` and \'t\' from `word2` to make them identical, resulting in two delete operations. In Example 2, the longest common subsequence is \\"eto\\", and we need to delete \'l\', \'d\', \'c\', and \'e\' from `word1` to make them identical. You should implement this function in an efficient manner such that it runs within the time and space constraints.","solution":"def minDistance(word1: str, word2: str) -> int: Returns the minimum number of delete operations needed to make `word1` and `word2` identical. # Lengths of the given words m, n = len(word1), len(word2) # Initialize the DP table that will store lengths of longest common subsequences dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The length of LCS lcs_length = dp[m][n] # The minimum deletions required min_deletions = (m - lcs_length) + (n - lcs_length) return min_deletions"},{"question":"# Run-Length Encoding and Decoding Context: Run-Length Encoding (RLE) is a simple and efficient algorithm commonly used for lossless data compression. It reduces the size of data by replacing sequences of repeating characters with a single character followed by the number of repeats. This technique is most effective when the data contains many consecutive repeated values. Problem: You are tasked to create a Python function that implements both encoding and decoding using RLE. Your task is to write two functions – one to encode a given string using the RLE approach, and another to decode a string encoded using RLE. Function Definitions: Write two functions: 1. `encode_rle(input: str) -> str`: - This function will take a string `input` as an argument and return the run-length encoded string. 2. `decode_rle(input: str) -> str`: - This function will take a run-length encoded string `input` as an argument and return the original uncompressed string. Example: 1. **Encoding Example:** ```python input_str = \\"aaabbcddd\\" encoded_str = encode_rle(input_str) print(encoded_str) ``` Output: ``` \\"3a2b1c3d\\" ``` 2. **Decoding Example:** ```python encoded_str = \\"3a2b1c3d\\" decoded_str = decode_rle(encoded_str) print(decoded_str) ``` Output: ``` \\"aaabbcddd\\" ``` Constraints: - The input string will contain only lowercase English letters. - The length of the input string will be between 1 and 1000. Requirements: - Ensure your solution handles edge cases such as empty strings, strings with no repeating characters, and long sequences of repeated characters efficiently. - Your implementation should ensure the RLE encoding is reversible, meaning decoding an encoded string should result in the original string.","solution":"def encode_rle(input: str) -> str: Encode the input string using Run-Length Encoding (RLE). Parameters: input (str): The string to be encoded. Returns: str: The run-length encoded string. if not input: return \\"\\" encoded_str = \\"\\" count = 1 for i in range(1, len(input)): if input[i] == input[i - 1]: count += 1 else: encoded_str += str(count) + input[i - 1] count = 1 encoded_str += str(count) + input[-1] # Finally add the last set of characters return encoded_str def decode_rle(input: str) -> str: Decode a run-length encoded string. Parameters: input (str): The run-length encoded string. Returns: str: The original string before encoding. decoded_str = \\"\\" count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) # Handles the case for multi-digit counts else: decoded_str += char * count count = 0 return decoded_str"},{"question":"# Atbash Cipher Implementation Objective: Write a function to encrypt a string using the Atbash cipher, which reverses the alphabet (A ↔ Z, B ↔ Y, etc.). The function should handle both uppercase and lowercase letters appropriately, while leaving non-alphabetic characters unchanged. Function Signature: ```python def atbash_cipher(text: str) -> str: Encrypts the provided text using the Atbash cipher. Parameters: text (str): The input text to encrypt. Returns: str: The encrypted text. ``` Input: - `text`: A string of up to 10^6 characters, including alphabetic characters, numbers, and special characters. Output: - A string where each alphabetic character in `text` is replaced by its reverse in the alphabet while non-alphabetic characters remain unchanged. Constraints: - The function should efficiently handle input strings of large sizes. Example: - Input: `\\"Attack at dawn\\"` - Output: `\\"Zggzxp zg wzdm\\"` Performance Requirements: - The function should complete in O(n) time complexity. Scenario: Imagine you are developing a simple text encryption tool that uses classical ciphers for encryption. As a first step, you decided to implement the Atbash cipher. Keep in mind the efficiency and correctness of your implementation, considering edge cases such as strings with non-alphabetic characters and different letter cases.","solution":"def atbash_cipher(text: str) -> str: Encrypts the provided text using the Atbash cipher. Parameters: text (str): The input text to encrypt. Returns: str: The encrypted text. def atbash_char(c): if \'A\' <= c <= \'Z\': return chr(ord(\'Z\') - (ord(c) - ord(\'A\'))) elif \'a\' <= c <= \'z\': return chr(ord(\'z\') - (ord(c) - ord(\'a\'))) else: return c return \'\'.join(atbash_char(c) for c in text)"},{"question":"# Task You are given a directed graph represented by the `DirectedGraph` class. Now, let\'s focus on implementing a feature to detect cycles within this directed graph. A cycle in a directed graph is a path that starts from a node and returns to the same node. # Problem Statement Write a function `has_cycle(graph: DirectedGraph) -> bool`, which takes a `DirectedGraph` object as input and returns `True` if there is at least one cycle in the graph, otherwise returns `False`. # Input - `graph`: An instance of `DirectedGraph`. # Output - Return `True` if the graph contains at least one cycle. - Return `False` if the graph does not contain any cycles. # Constraints - The graph will have at least one node. - Node names are unique strings. - Assume that there are no duplicate edges. # Example ```python # Sample graph with cycles sample_graph_data_with_cycle = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'] # A -> B -> C -> A creates a cycle } graph_with_cycle = DirectedGraph(sample_graph_data_with_cycle) print(has_cycle(graph_with_cycle)) # True # Sample graph without cycles sample_graph_data_without_cycle = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [] # No cycle, linear path } graph_without_cycle = DirectedGraph(sample_graph_data_without_cycle) print(has_cycle(graph_without_cycle)) # False ``` # Notes 1. **Edge Cases**: Consider graphs with nodes having no outgoing edges, self-loops, or complex interconnected nodes with multiple cycles. 2. **Performance Requirements**: Function should efficiently handle graphs with up to `10^3` nodes and `10^4` edges. # Explanation The function can be implemented using Depth-First Search (DFS). During DFS traversal, use recursion tracking stacks and visited status to detect back edges indicating cycles. Good luck!","solution":"class DirectedGraph: def __init__(self, adjacency_list): self.adjacency_list = adjacency_list def has_cycle(graph: DirectedGraph) -> bool: Detects cycles in a directed graph using DFS. Arguments: graph : DirectedGraph : The directed graph represented as an adjacency list. Returns: bool : True if the graph has at least one cycle, otherwise False. def dfs(node, visited, rec_stack): visited.add(node) rec_stack.add(node) for neighbor in graph.adjacency_list.get(node, []): if neighbor not in visited: if dfs(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True rec_stack.remove(node) return False visited = set() rec_stack = set() for node in graph.adjacency_list: if node not in visited: if dfs(node, visited, rec_stack): return True return False"},{"question":"# Question: Implement and Optimize Shell Sort **Context:** You are required to implement an optimized version of the Shell Sort algorithm. Shell Sort is known for its complexity due to the gap sequence used. By using a dynamic gap sequence, the sorting efficiency can be improved. **Task:** Write a Python function `optimized_shell_sort(arr: list) -> list` that sorts an input list of integers in non-decreasing order using the Shell Sort algorithm. Optimize your implementation by using the Hibbard gap sequence. **Hibbard Gap Sequence:** A geometric progression where the gaps are of the form (2^k - 1) for ( k = ... , 3, 2, 1). **Expected Input and Output:** * **Input**: A list of integers, `arr` (0 ≤ len(arr) ≤ 10^6, -10^9 ≤ arr[i] ≤ 10^9) * **Output**: A sorted list of integers in non-decreasing order. **Constraints:** * The algorithm must have an average case time complexity better than O(n^2). * Make sure your implementation handles large lists efficiently. **Performance Requirements:** * Your implementation should have a balanced performance such that it efficiently handles medium to large-sized datasets. Example: ```python assert optimized_shell_sort([12, 34, 54, 2, 3]) == [2, 3, 12, 34, 54] assert optimized_shell_sort([0, -1, 5, 3, -7]) == [-7, -1, 0, 3, 5] assert optimized_shell_sort([]) == [] assert optimized_shell_sort([5]) == [5] ```","solution":"def optimized_shell_sort(arr): Sorts a list of integers in non-decreasing order using the Shell Sort algorithm with Hibbard gap sequence. Args: arr (list): The input list of integers. Returns: list: A sorted list of integers in non-decreasing order. n = len(arr) gap = 1 gaps = [] # Generate the Hibbard gap sequence while gap < n: gaps.append(gap) gap = 2 * gap + 1 gaps.reverse() # Start with the largest gap for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Binary Search Implementation & Analysis Objective: Implement an optimized binary search algorithm and analyze its performance, handling edge cases comprehensively. Write a function `optimized_binary_search(array: List[int], query: int) -> int` that performs a binary search on a sorted list of integers named \'array\' to find the index of an element \'query\'. Return -1 if the element is not found. Input: * `array (List[int])`: A sorted list of integers. * `query (int)`: The integer value to be searched within the array. Output: * `int`: The index of the \'query\' in the \'array\'. Return -1 if the \'query\' is not found. Constraints: * The length of `array` (N) can be up to (10^6). * The values in `array` can range within standard 32-bit integers. * Consider both the iterative and recursive implementations. Performance Requirements: * Optimize for both time and space complexity, aiming for O(log N) time. * Minimize the overhead and manage recursion depth to prevent stack overflows. Example: ```python assert optimized_binary_search([1, 2, 3, 4, 5], 3) == 2 assert optimized_binary_search([1, 2, 3, 4, 5], 6) == -1 assert optimized_binary_search([], 3) == -1 assert optimized_binary_search([1], 1) == 0 ``` Additional Considerations: * Provide thorough docstrings and comments explaining the steps of your algorithm. * Ensure to handle edge cases like empty arrays and non-existent elements gracefully. * Reflect on your approach efficiency, emphasizing scenarios where your implementation might falter and how to overcome them.","solution":"from typing import List def optimized_binary_search(array: List[int], query: int) -> int: Perform a binary search on a sorted list of integers to find the index of the query element. Return -1 if the element is not found. Parameters: array (List[int]): A sorted list of integers. query (int): The integer value to be searched within the array. Returns: int: The index of the query in the array. Return -1 if the query is not found. left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] == query: return mid elif array[mid] < query: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Question **Priority Queue Implementation** You are required to implement a priority queue that supports both insertion of elements with specific priorities and extraction of the element with the highest priority. The priority queue must maintain the order of elements such that the element with the lowest (or highest) priority can be retrieved and removed efficiently. Function Specifications 1. **Function 1: push** * **Input**: `item` (any type), `priority` (numeric value, optional) * **Behavior**: Insert `item` into the priority queue with the given `priority`. If no priority is provided, treat the `item` itself as the priority. * **Output**: None 2. **Function 2: pop** * **Input**: None * **Behavior**: Remove and return the item with the lowest priority. * **Output**: `item` (the element with the highest priority) 3. **Function 3: size** * **Input**: None * **Behavior**: Return the current number of elements in the priority queue. * **Output**: Integer representing the size of the queue # Constraints * Elements can have numeric priorities. If no priority is specified during insertion, assume the element itself is the priority. * Ensure the `pop` operation handles an empty priority queue appropriately (return None or raise an appropriate exception). Performance Requirements * Push operation should not exhibit more than O(n) time complexity. * Pop operation should be O(1) time complexity. # Example ```python # PriorityQueue class initialized empty pq = PriorityQueue() # Push elements with priorities pq.push(\'task1\', 3) pq.push(\'task2\', 1) pq.push(\'task3\', 2) # Check size print(pq.size()) # Output: 3 # Pop elements (expecting the one with highest priority which is \'task2\') print(pq.pop()) # Output: \'task2\' print(pq.pop()) # Output: \'task3\' print(pq.pop()) # Output: \'task1\' # Size after popping all elements print(pq.size()) # Output: 0 ```","solution":"import heapq class PriorityQueue: def __init__(self): self._queue = [] self._index = 0 def push(self, item, priority=None): if priority is None: priority = item # heapq is a min-heap, we invert the priority to behave as a max-heap heapq.heappush(self._queue, (-priority, self._index, item)) self._index += 1 def pop(self): if self._queue: return heapq.heappop(self._queue)[2] return None def size(self): return len(self._queue)"},{"question":"# Question Description You are required to implement the `selection_sort` function which takes an array of integers and sorts it in ascending order using the Selection Sort algorithm. To ensure your function is correct and handles various edge cases appropriately, consider the following specifications. Function Signature ```python def selection_sort(arr: List[int], simulation: bool=False) -> List[int]: ``` Parameters * `arr` (List[int]): An array of integers to be sorted. * `simulation` (bool, optional): If set to `True`, the function should print the array\'s state after each iteration for simulation purposes. Default is `False`. Returns * List[int]: A new list which is the sorted version of the input array. Constraints 1. The array size `n` is such that `0 <= n <= 1000`. 2. Each element in the array is an integer in the range `-10^9` to `10^9`. Example ```python arr = [64, 25, 12, 22, 11] print(selection_sort(arr, simulation=True)) ``` Output: ``` Iteration 0 : 11 25 12 22 64 Iteration 1 : 11 12 25 22 64 Iteration 2 : 11 12 22 25 64 Iteration 3 : 11 12 22 25 64 Iteration 4 : 11 12 22 25 64 [11, 12, 22, 25, 64] ``` Additional Notes * Your function should ensure minimum operations within the inner loop, focusing on readability and correctness. * Handle edge cases such as arrays with all identical elements, empty arrays, and already sorted arrays. * You are encouraged to write additional helper functions if necessary, but the main logic should reside in `selection_sort`.","solution":"from typing import List def selection_sort(arr: List[int], simulation: bool=False) -> List[int]: n = len(arr) if n == 0: return [] # We create a copy of the array to not mutate the input array sorted_arr = arr[:] for i in range(n): # Find the minimum element in unsorted array min_idx = i for j in range(i + 1, n): if sorted_arr[j] < sorted_arr[min_idx]: min_idx = j # Swap the found minimum element with the first element sorted_arr[i], sorted_arr[min_idx] = sorted_arr[min_idx], sorted_arr[i] if simulation: print(f\\"Iteration {i} : {\' \'.join(map(str, sorted_arr))}\\") return sorted_arr"},{"question":"You are given a non-negative number represented as a list of digits stored in a big-endian format, where each element in the list stores a single digit. Your task is to write a function `increment_number` that increments this number by one and returns the resulting list of digits. # Function Signature ```python def increment_number(digits: List[int]) -> List[int]: pass ``` # Input - `digits`: a list of integers where each integer is between 0 and 9, inclusive. # Output - A list of integers representing the input number incremented by one. # Constraints - The input list `digits` will not be empty. - You must not use any built-in conversions between integers and strings. # Performance Requirements 1. The function should be efficient with a time complexity of O(n), where `n` is the length of the input list. 2. The space complexity should be O(1), i.e., modify the list in place if possible. # Example Example 1 - Input: `[1, 2, 3]` - Output: `[1, 2, 4]` Example 2 - Input: `[9, 9, 9]` - Output: `[1, 0, 0, 0]` Example 3 - Input: `[0]` - Output: `[1]` # Edge Cases 1. Consider inputs where all digits are the maximum value of 9. 2. Test the behavior where the most significant digit becomes 0 and needs to create a carry.","solution":"def increment_number(digits): Increment the number represented by the list of digits by one. Parameters: digits (List[int]): A list of integers where each integer is between 0 and 9 inclusive. Returns: List[int]: A list of integers representing the incremented number. n = len(digits) # Traverse the list in reverse order for i in range(n-1, -1, -1): if digits[i] < 9: # If the current digit is less than 9, we can simply increment it digits[i] += 1 return digits else: # If the current digit is 9, it becomes 0 and we carry over the increment digits[i] = 0 # If we exited the loop, it means all the digits were 9 and carry over has reached beyond the most significant digit return [1] + digits"},{"question":"You are tasked with implementing Prim\'s Algorithm to find the minimum spanning tree of a connected undirected graph. Your implementation should adhere to the problem constraints and handle edge cases effectively. Input Format * A dictionary `graph` where each key is a node, and the value is a list of lists. Each sub-list contains two elements: the cost (integer) to reach the adjacent node and the adjacent node represented by a string. Output Format * Return an integer representing the sum of the weights of the edges in the minimum spanning tree. Constraints 1. The graph contains at least 2 nodes. 2. The graph is connected (i.e., there is at least one path between any two nodes). 3. The edge weights are non-negative integers. Example ```python graph = { \'a\': [ [3, \'b\'], [8,\'c\'] ], \'b\': [ [3, \'a\'], [5, \'d\'] ], \'c\': [ [8, \'a\'], [2, \'d\'], [4, \'e\'] ], \'d\': [ [5, \'b\'], [2, \'c\'], [6, \'e\'] ], \'e\': [ [4, \'c\'], [6, \'d\'] ] } Output: 14 ``` **Explanation:** The MST includes the edges (a-b with cost 3), (c-d with cost 2), (d-e with cost 6), and (c-e with cost 4). The total cost is 3 + 2 + 4 + 5 = 14. # Function signature ```python def prims_minimum_spanning(graph: dict) -> int: pass ```","solution":"import heapq def prims_minimum_spanning(graph): if not graph: return 0 total_cost = 0 visited = set() min_heap = [(0, next(iter(graph)))] # Start from any node, cost to reach is 0 while min_heap: cost, node = heapq.heappop(min_heap) if node not in visited: visited.add(node) total_cost += cost for adj_cost, adj_node in graph[node]: if adj_node not in visited: heapq.heappush(min_heap, (adj_cost, adj_node)) return total_cost"},{"question":"# Question You are given an array of integers and a target value. Your objective is to write a function that finds the first occurrence of the target value in the array and returns its index. If the target isn\'t present, return -1. However, the array can contain negative numbers, and you need to consider the time efficiency. Your implemented function should have the same or better time complexity as the linear search. Write a function `find_element_index(arr, target)` to achieve this: Function Signature ```python def find_element_index(arr: list[int], target: int) -> int: ``` Input * `arr` (list of int): The list of integers which can include negative numbers. * `target` (int): The target integer value you need to find in the array. Output * (int): The index of the first occurrence of the target value if found, otherwise -1. Constraints * The array can contain up to 10^7 elements. * Each integer in the array is within the range of -10^9 to 10^9. Example ```python assert find_element_index([5, 3, -2, 0, 9, -2], -2) == 2 assert find_element_index([3, 8, 2], 5) == -1 assert find_element_index([], 1) == -1 ``` The function provided should handle all the edge cases and constraints efficiently, adhering to at most O(n) time complexity.","solution":"def find_element_index(arr, target): Finds the first occurrence of the target value in the array. Returns the index of the first occurrence or -1 if the target isn\'t present. for index, value in enumerate(arr): if value == target: return index return -1"},{"question":"# Binary Search Tree to Doubly Linked List Conversion Problem Statement You have a binary search tree (BST) where each node contains an integer value. You need to convert this BST into a sorted doubly linked list (DLL) in-place, meaning you should not use any extra space other than the implicit stack space due to recursion. Function Signature ```python def bst_to_dll(root: TreeNode) -> TreeNode: pass ``` - **Input**: * The input is the root of a binary search tree. - **Output**: * The function returns the head node of the resulting doubly linked list. Constraints: * The left pointer of each node should be used as a previous pointer in the DLL. * The right pointer of each node should be used as a next pointer in the DLL. * The DLL should be sorted in ascending order. * Minimize space usage (extra space other than what is used by the recursion stack is not allowed). Example: Consider the following BST: ``` 4 / 2 5 / 1 3 ``` The resulting doubly linked list should look like: ``` 1 <-> 2 <-> 3 <-> 4 <-> 5 ``` # Guidelines 1. Implement the function `bst_to_dll` using an in-order traversal approach. 2. Ensure that the left pointers in the tree are used as previous pointers and the right pointers are used as next pointers. 3. You may define a helper function inside `bst_to_dll` if necessary. # Example Usage: ```python # Example TreeNode class definition class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None # Function call example root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(5) root.left.left = TreeNode(1) root.left.right = TreeNode(3) # Convert the BST to DLL dll_head = bst_to_dll(root) # Print the doubly linked list current = dll_head while current: print(current.val, end=\\" <=> \\" if current.right else \\"\\") current = current.right # Output: 1 <=> 2 <=> 3 <=> 4 <=> 5 ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def bst_to_dll(root: TreeNode) -> TreeNode: if not root: return None # Helper function to perform in-order traversal and link nodes def inorder(node): nonlocal last, head if not node: return inorder(node.left) if last: last.right = node node.left = last else: head = node last = node inorder(node.right) head = last = None inorder(root) return head"},{"question":"# Sparse Vector Dot Product Context You are working on a project that involves processing very large datasets represented as vectors. Due to the high dimensionality and sparsity (most elements are zero), you need to implement a system that can efficiently store these vectors and compute their dot products. Task Write a function `sparse_vector_dot_product` that takes two vectors and performs the following steps: 1. Converts each vector to a sparse representation as a list of index-value pairs. 2. Computes the dot product of the two sparse vectors. Function Signature ```python def sparse_vector_dot_product(vector1: List[float], vector2: List[float]) -> float: # Your code here ``` Input - `vector1` and `vector2`: Two lists of floats representing the large sparse vectors. - (0 leq text{len}(vector1), text{len}(vector2) leq 10^6) - The vectors may contain negative, positive, and zero values. Output - A single float value representing the dot product of the two vectors. Constraints - If the input vectors are not of the same length, return `0`. - Leverage the sparsity of the vectors for efficient computation. Example ```python vector1 = [1.0, 0.0, 0.0, 2.0, 0.0] vector2 = [0.0, 2.0, 0.0, 1.0, 3.0] result = sparse_vector_dot_product(vector1, vector2) print(result) # Output should be 2.0 ``` Points to Consider - Focus on efficient conversion from a dense to sparse representation. - Ensure index alignment during the dot product calculation. - Handle edge cases such as vectors completely filled with zeros or vectors of different lengths.","solution":"from typing import List def sparse_vector_dot_product(vector1: List[float], vector2: List[float]) -> float: if len(vector1) != len(vector2): return 0.0 sparse_vector1 = [(i, v) for i, v in enumerate(vector1) if v != 0] sparse_vector2 = [(i, v) for i, v in enumerate(vector2) if v != 0] dict_vector2 = dict(sparse_vector2) dot_product = 0.0 for i, v in sparse_vector1: if i in dict_vector2: dot_product += v * dict_vector2[i] return dot_product"},{"question":"# Regular Expression Matching (Advanced) Context In software applications involving text validation, it is common to use regular expressions to define patterns that text data must conform to. Your task is to implement a robust function to determine whether a given text string matches a pattern string that includes special characters `.` and `*`. Problem Statement Write a function `is_match(s: str, p: str) -> bool` that checks if string `s` matches the pattern `p`. - The character `.` can match any single character. - The character `*` can match zero or more of the preceding element. Note that `*` must always come after another character (not be the first character in `p`). Input - `s`: A string containing only lowercase English letters. - `p`: A string containing only lowercase English letters and the special characters `.` and `*`. Output - Return `True` if `s` matches the pattern `p`, otherwise return `False`. Constraints - `0 <= len(s) <= 1000` - `0 <= len(p) <= 1000` Example ```python assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"aa\\", \\"aa\\") == True assert is_match(\\"aaa\\", \\"aa\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"aa\\", \\".*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True assert is_match(\\"mississippi\\", \\"mis*is*ip*.\\") == True ``` Note - Carefully consider the edge scenarios such as empty strings and patterns involving `*`. - Ensure that the function operates efficiently within the constraints provided.","solution":"def is_match(s: str, p: str) -> bool: Returns True if the whole string s matches the pattern p. dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] dp[0][0] = True for j in range(1, len(p) + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] if p[j - 2] == \'.\' or p[j - 2] == s[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] return dp[len(s)][len(p)]"},{"question":"# Mode Finder In statistics, the mode is the value that appears most frequently in a data set. Implement a function `find_modes` which receives a list of integers and returns a list of the most frequent value(s). In cases where multiple values have the same highest frequency, the function should return all those values. Function Signature ```python def find_modes(arr: List[int]) -> List[int]: ``` Input * A list `arr` of integers where `1 <= len(arr) <= 10^5`. The values in `arr` are guaranteed to be integers within the range `-10^6` to `10^6`. Output * A list of integers representing the most frequent value(s) in the input list. If there\'s a tie, all values with the highest frequency should be included in any order. Constraints * Optimize for time and space. * Handle edge cases, such as an empty array and arrays with only one element. Example ```python assert find_modes([1, 1, 2, 2, 3, 4]) == [1, 2] assert find_modes([5, 5, 5, 3, 3, 1]) == [5] ``` Explanation In the first example, both `1` and `2` appear twice and no other number appears more frequently, hence both are returned. In the second example, `5` appears three times, whereas others appear less frequently, thus `5` is returned. Your task is to implement the `find_modes` function that meets these criteria.","solution":"from typing import List from collections import Counter def find_modes(arr: List[int]) -> List[int]: if not arr: return [] counter = Counter(arr) max_frequency = max(counter.values()) modes = [key for key, value in counter.items() if value == max_frequency] return modes"},{"question":"# Base Conversion Challenge **Objective**: Write functions that convert integers to their representation in a specified base and convert back from a string representation in a specified base to an integer. Function Specifications 1. **Function Name**: `int_to_base` ```python def int_to_base(num, base: int) -> str: ``` **Parameters**: - `num` (int): The integer you want to convert. - `base` (int): The base to convert to, which can be between 2 and 36. **Returns**: - A string representing the integer `num` in the specified `base`. 2. **Function Name**: `base_to_int` ```python def base_to_int(str_to_convert: str, base: int) -> int: ``` **Parameters**: - `str_to_convert` (str): The string representation of the number in the specified base. - `base` (int): The base of the number represented by `str_to_convert`. **Returns**: - The integer value of the string representation in the specified `base`. Constraints - It is guaranteed that `base` will always be between 2 and 36 (inclusive). - The string `str_to_convert` will be a valid string representation for the given base. Examples ```python # Example 1 assert int_to_base(255, 16) == \'FF\' assert base_to_int(\'FF\', 16) == 255 # Example 2 assert int_to_base(-15, 2) == \'-1111\' assert base_to_int(\'-1111\', 2) == -15 # Example 3 assert int_to_base(12345, 36) == \'9IX\' assert base_to_int(\'9IX\', 36) == 12345 ``` # Additional Notes: - Ensure that your implementation correctly handles negative numbers. - Optimize your function for efficiency, considering edge cases, performance bottlenecks, and possible improvements.","solution":"def int_to_base(num, base: int) -> str: Converts an integer to its string representation in a specified base. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36, inclusive.\\") if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" is_negative = num < 0 num = abs(num) result = [] while num: result.append(digits[num % base]) num //= base if is_negative: result.append(\'-\') return \'\'.join(reversed(result)) def base_to_int(str_to_convert: str, base: int) -> int: Converts a string representation of a number in a specified base back to an integer. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36, inclusive.\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" str_to_convert = str_to_convert.upper() is_negative = str_to_convert[0] == \'-\' if is_negative: str_to_convert = str_to_convert[1:] num = 0 for char in str_to_convert: num = num * base + digits.index(char) return -num if is_negative else num"},{"question":"You are given a list of pairwise coprime positive integers `nums` and a list of corresponding remainders `rems`. Your task is to implement an optimized function to solve the system of congruences using the Chinese Remainder Theorem (CRT). Function Signature ```python def optimized_chinese_remainder(nums: List[int], rems: List[int]) -> int: ``` # Input - `nums`: List of integers, where each integer is >= 2 and pairwise coprime. - `rems`: List of integers, representing the remainders. Constraints: - Length of `nums` and `rems` will be equal. - All integers in `nums` will be greater than 1. # Output - Returns the smallest positive integer x that satisfies the system of linear congruences: [ x % nums[i] = rems[i] , text{for all} , i ] # Example ```python print(optimized_chinese_remainder([3, 5, 7], [2, 3, 2])) # Output: 23 ``` # Explanation In this problem: - We have three congruences: - (x % 3 = 2) - (x % 5 = 3) - (x % 7 = 2) - The smallest positive integer that satisfies all these congruences is 23. # Additional Notes - Consider optimizing the solution using the properties of modular arithmetic and the extended Euclidean algorithm to find modular inverses instead of a direct brute-force approach. - Handle all common edge cases and ensure your code performs efficiently for larger inputs.","solution":"from typing import List, Tuple def extended_gcd(a: int, b: int) -> Tuple[int, int, int]: Returns a tuple (g, x, y), where g is the greatest common divisor of a and b, and x and y are the coefficients of Bézout\'s identity, i.e., a*x + b*y = g if a == 0: return (b, 0, 1) else: g, x1, y1 = extended_gcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return (g, x, y) def optimized_chinese_remainder(nums: List[int], rems: List[int]) -> int: Solves the system of congruences using the Chinese Remainder Theorem. Given lists nums and rems, returns the smallest positive integer x such that x % nums[i] = rems[i] for all i. if not nums or not rems or len(nums) != len(rems): raise ValueError(\\"Input lists nums and rems must be of the same length and non-empty\\") # Product of all numbers product = 1 for num in nums: product *= num result = 0 for n_i, a_i in zip(nums, rems): p = product // n_i g, m_inv, _ = extended_gcd(p, n_i) # Ensure that gcd is 1 as nums are pairwise coprime if g != 1: raise ValueError(\\"Input list nums must be pairwise coprime\\") result += a_i * m_inv * p return result % product"},{"question":"# Question: Insert Position with Binary Search You are tasked with designing a function that maintains order in an array as new elements are inserted. Given a sorted array and a target value, your function should return the index where the target would be inserted to keep the array sorted. If the target is already present, return the correct index it is found at. Function Specification ```python def search_insert(array: List[int], val: int) -> int: Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. Parameters: array (List[int]): A sorted list of integers. val (int): The target integer to be inserted. Returns: int: The index where the target value should be inserted. ``` # Inputs - `array`: A list of integers, sorted in ascending order. The list can be empty or contain up to (10^6) elements. - `val`: An integer value that you need to find the correct insertion point for. The value fits in a 32-bit signed integer. # Outputs - Return an integer representing the insertion index for the target value within the sorted list. # Constraints - The array can have zero or more elements. - The function must run in (O(log n)) time complexity. # Examples Example 1 ```python array = [1, 3, 5, 6] val = 5 # Expected output: 2 # Explanation: The value 5 is found at index 2. ``` Example 2 ```python array = [1, 3, 5, 6] val = 2 # Expected output: 1 # Explanation: The value 2 would be inserted at index 1 to maintain order. ``` Example 3 ```python array = [1, 3, 5, 6] val = 7 # Expected output: 4 # Explanation: The value 7 would be inserted at the end, index 4. ``` Example 4 ```python array = [1, 3, 5, 6] val = 0 # Expected output: 0 # Explanation: The value 0 would be inserted at the beginning, index 0. ``` # Special Requirements - Your solution should handle large arrays efficiently. - Ensure boundary conditions (like inserting at the start or end) are handled correctly. - The code should not rely on external libraries for sorting or other operations.","solution":"from typing import List def search_insert(array: List[int], val: int) -> int: Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. Parameters: array (List[int]): A sorted list of integers. val (int): The target integer to be inserted. Returns: int: The index where the target value should be inserted. left, right = 0, len(array) while left < right: mid = (left + right) // 2 if array[mid] < val: left = mid + 1 else: right = mid return left"},{"question":"You are a software engineer tasked with implementing a serialization technique that encodes data using bit manipulation. You need to design a class `BitManipulator` that stores an integer and allows various bit manipulations. Your class will provide the following methods: 1. **get_bit(pos)**: Returns the bit at position `pos`. 2. **set_bit(pos)**: Sets the bit at position `pos` to 1. 3. **clear_bit(pos)**: Clears the bit at position `pos` (sets it to 0). 4. **update_bit(pos, bit)**: Sets the bit at position `pos` to `bit` (either 0 or 1). Attributes * **num**: The integer being manipulated. Methods ```python class BitManipulator: def __init__(self, num: int): Initialize the BitManipulator with an integer number. :param num: The integer to manipulate. def get_bit(self, pos: int) -> bool: Returns whether the bit at position `pos` is set (1) or not (0). :param pos: The position of the bit (0-indexed). :return: True if the bit is set, otherwise False. def set_bit(self, pos: int): Sets the bit at position `pos` to 1. :param pos: The position of the bit (0-indexed). def clear_bit(self, pos: int): Clears the bit at position `pos` (sets it to 0). :param pos: The position of the bit (0-indexed). def update_bit(self, pos: int, bit: int): Updates the bit at position `pos` to `bit` (0 or 1). :param pos: The position of the bit (0-indexed). :param bit: The new value of the bit (0 or 1). ``` Constraints 1. `pos` will be within the range of valid bit positions for a 32-bit signed integer. 2. `bit` will be either 0 or 1. 3. The internal storage integer (`num`) should be manipulated directly without using any additional data structures. Example Usage ```python bm = BitManipulator(0) bm.set_bit(2) print(bm.get_bit(2)) # Output: True bm.clear_bit(2) print(bm.get_bit(2)) # Output: False bm.update_bit(2, 1) print(bm.get_bit(2)) # Output: True bm.update_bit(2, 0) print(bm.get_bit(2)) # Output: False ``` Your task is to complete the implementation of the `BitManipulator` class so that it functions as specified.","solution":"class BitManipulator: def __init__(self, num: int): Initialize the BitManipulator with an integer number. :param num: The integer to manipulate. self.num = num def get_bit(self, pos: int) -> bool: Returns whether the bit at position `pos` is set (1) or not (0). :param pos: The position of the bit (0-indexed). :return: True if the bit is set, otherwise False. return (self.num & (1 << pos)) != 0 def set_bit(self, pos: int): Sets the bit at position `pos` to 1. :param pos: The position of the bit (0-indexed). self.num |= (1 << pos) def clear_bit(self, pos: int): Clears the bit at position `pos` (sets it to 0). :param pos: The position of the bit (0-indexed). self.num &= ~(1 << pos) def update_bit(self, pos: int, bit: int): Updates the bit at position `pos` to `bit` (0 or 1). :param pos: The position of the bit (0-indexed). :param bit: The new value of the bit (0 or 1). mask = ~(1 << pos) self.num = (self.num & mask) | (bit << pos)"},{"question":"# Valid Parentheses Checker Given a string `s` containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', write a function `is_valid` to determine if the input string is valid. An input string is valid if: 1. Open brackets are closed by the same type of brackets. 2. Open brackets are closed in the correct order. You must implement the function `is_valid(s: str) -> bool` to check if the input string meets the above criteria. Input * A string `s` consisting of characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. Output * Return `True` if the string is valid, otherwise return `False`. Constraints * The input string will have a length between 0 and 10^4. Examples * Example 1: * Input: s = \\"()\\" * Output: True * Example 2: * Input: s = \\"()[]{}\\" * Output: True * Example 3: * Input: s = \\"(]\\" * Output: False Notes * Consider all possible edge cases mentioned in the algorithm analysis, such as empty strings or incorrectly nested brackets. * Your implementation should leverage stack data structure to efficiently match and validate the brackets.","solution":"def is_valid(s: str) -> bool: Returns True if the input string s consisting of \'()\', \'[]\', and \'{}\' is valid. Otherwise, returns False. # Stack to keep track of opening brackets. stack = [] # Dictionary to keep track of matching brackets. matching_brackets = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} # Iterate through each character in the string for char in s: if char in matching_brackets: # Pop the top most element from the stack, or a dummy value if stack is empty top_element = stack.pop() if stack else \'#\' # If the top element does not match the corresponding opening bracket if matching_brackets[char] != top_element: return False else: # If it is an opening bracket, push to the stack stack.append(char) # If stack is empty, all opening brackets are properly matched return not stack"},{"question":"Scenario You are developing an application that frequently needs to analyze binary trees. One of the tasks is to determine the minimum depth of any given binary tree. Knowing the minimum depth helps in various operations like balancing the tree, determining insertion points, and optimizing query processing. Hence, you need to implement this functionality efficiently. Your task is to write a function that calculates the minimum depth of a binary tree using both recursive and iterative approaches. Function Signature You should implement two functions: 1. `min_depth(root: TreeNode) -> int` 2. `min_height(root: TreeNode) -> int` The `TreeNode` class is already defined as given below: ```python class TreeNode: def __init__(self, x: int): self.val = x self.left = None self.right = None ``` Expected Input and Output - **Input**: A binary tree given through its root node. - **Output**: An integer representing the minimum depth of the tree. Constraints - The number of nodes in the tree is in the range [0, 10^4]. - The values of the nodes are in the range [-10^4, 10^4]. Performance Requirements - Aim for a time complexity of O(n) where n is the number of nodes in the binary tree. - Aim for a space complexity of O(n) in the worst case scenario. Examples 1. Given the tree: ``` 3 / 9 20 / 15 7 ``` - The result of both functions should be `2`. 2. Given the tree: ``` 1 2 3 4 5 ``` - The result of both functions should be `5`. 3. For an empty tree, the result should be `0`. Code Template ```python class TreeNode: def __init__(self, x: int): self.val = x self.left = None self.right = None def min_depth(root: TreeNode) -> int: # TODO: Implement the recursive approach for finding minimum depth def min_height(root: TreeNode) -> int: # TODO: Implement the iterative approach for finding minimum depth ``` Task Write the two functions as specified to determine the minimum depth of a binary tree using both recursive and iterative approaches.","solution":"class TreeNode: def __init__(self, x: int): self.val = x self.left = None self.right = None def min_depth(root: TreeNode) -> int: Recursive approach to find the minimum depth of a binary tree. if not root: return 0 if not root.left and not root.right: return 1 if not root.left: return min_depth(root.right) + 1 if not root.right: return min_depth(root.left) + 1 return min(min_depth(root.left), min_depth(root.right)) + 1 def min_height(root: TreeNode) -> int: Iterative approach to find the minimum depth of a binary tree using level order traversal. if not root: return 0 from collections import deque queue = deque([(root, 1)]) # (node, current_depth) while queue: node, depth = queue.popleft() if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1))"},{"question":"# Tree Structure Printer Implement a robust function that interprets and prints a nested dictionary representing a tree structure. Your function should handle various data types in the tree nodes appropriately. # Objective The function should print the tree structure in the following format: ``` key -> value1 -> subvalue1 -> subvalue2 key2 -> value2 -> subvalue3 ``` # Input Format * An input dictionary where each key maps to a list of values. Each value can either be a string or another dictionary representing a nested structure. # Output Format * Print the tree nodes level by level, with proper indentation. # Constraints * The input dictionary will contain no more than 1000 nodes. * Each value list will contain up to 10 elements. * Assume all keys and values are of type string or dictionary. Example Input: ```python tree = { \'a\': [\'Adam\', {\'Book\': 4}], \'b\': [\'Bill\', {\'Computer\': 5, \'TV\': 6}, \'Jill\', {\'Sports\': 1}], \'c\': [\'Bill\', {\'Sports\': 3}], \'d\': [\'Adam\', {\'Computer\': 3}, \'Quin\', {\'Computer\': 3}], \'e\': [\'Quin\', {\'Book\': 5, \'TV\': 2}], \'f\': [\'Adam\', {\'Computer\': 7}] } ``` Expected Output: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` # Task Implement the function `tree_print(tree: dict) -> None`. Ensure it correctly handles nested dictionaries and prints the tree structure accordingly. ```python def tree_print(tree): for key in tree: print(key, end=\' \') tree_element = tree[key] for subElem in tree_element: print(\\" -> \\", end=\'\') if isinstance(subElem, dict): for sub_key, sub_value in subElem.items(): print(f\\"{sub_key} -> {sub_value}\\", end=\' \') else: print(subElem, end=\' \') print() # newline for nested structure print() # newline after each main key # Example usage: tree = { \'a\': [\'Adam\', {\'Book\': 4}], \'b\': [\'Bill\', {\'Computer\': 5, \'TV\': 6}, \'Jill\', {\'Sports\': 1}], \'c\': [\'Bill\', {\'Sports\': 3}], \'d\': [\'Adam\', {\'Computer\': 3}, \'Quin\', {\'Computer\': 3}], \'e\': [\'Quin\', {\'Book\': 5, \'TV\': 2}], \'f\': [\'Adam\', {\'Computer\': 7}] } tree_print(tree) ```","solution":"def tree_print(tree): def print_level(prefix, element): if isinstance(element, dict): for sub_key, sub_value in element.items(): print(f\\"{prefix} -> {sub_key} -> {sub_value}\\") else: print(f\\"{prefix} -> {element}\\") for key, values in tree.items(): for value in values: print_level(key, value)"},{"question":"# Binary Tree Mirroring You are required to implement a function that inverts a binary tree. Specifically, you should swap every left node with its corresponding right node recursively. The input will be a binary tree, and the output should be its mirror image (i.e., inverted tree). Given the following definition for a Binary Tree node: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` Implement the function: ```python def mirror_tree(root: TreeNode) -> TreeNode: # Your code here ``` Input * The input parameter `root` is the root of a binary tree. Output * The function should return the root of the new, inverted binary tree. Example Input: ```python 4 / 2 7 / / 1 3 6 9 ``` Output: ```python 4 / 7 2 / / 9 6 3 1 ``` Constraints * The number of nodes in the tree is in the range `[0, 1000]`. * `-100 <= Node.val <= 100` Notes * Consider edge cases where the tree is empty (i.e., `root` is `None`) or contains only a single node. * Recursion depth needs to be managed appropriately to avoid stack overflow in cases of highly unbalanced trees. Good luck!","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def mirror_tree(root: TreeNode) -> TreeNode: if not root: return None # swap left and right children root.left, root.right = root.right, root.left # recursively call mirror_tree on left and right children mirror_tree(root.left) mirror_tree(root.right) return root"},{"question":"# Question: Find the nth Digit **Objective**: Write a Python function to find the nth digit in the infinite sequence of integers concatenated together. **Scenario**: Imagine that all the positive integers are written sequentially in a string (e.g., \\"123456789101112...\\") without any spaces or delimiters. You need to determine what the nth digit in this infinite string would be. **Function Signature**: ```python def find_nth_digit(n: int) -> int: pass ``` **Input**: - `n` (1 ≤ n ≤ 2 * 10^9) - An integer n representing the position in the sequence. **Output**: - Returns an integer which is the nth digit in the concatenated number sequence. **Examples**: ```python print(find_nth_digit(3)) # Output: 3 print(find_nth_digit(11)) # Output: 0 print(find_nth_digit(15)) # Output: 2 print(find_nth_digit(21)) # Output: 5 ``` **Constraints**: - You must handle very large inputs efficiently in terms of both time and space. - Ensure your solution considers edge cases and performs necessary optimizations to handle minimal latencies. **Performance Requirement**: - The time complexity should ideally be logarithmic relative to `n`.","solution":"def find_nth_digit(n: int) -> int: length = 1 count = 9 start = 1 while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 start += (n - 1) // length return int(str(start)[(n - 1) % length])"},{"question":"# Sliding Window Maximum - Optimal Implementation You are given an array `nums` and an integer `k`, representing a sliding window size. The window moves from the left to the right end of the array, and you need to return a list of the maximum values in each window position. **Constraints**: * `1 <= len(nums) <= 10^5` * `1 <= k <= len(nums)` * `-10^4 <= nums[i] <= 10^4` **Input**: * `nums` : List[int] - The array to slide the window over. * `k` : int - The size of the sliding window. **Output**: * List[int] - A list of the maximum values from each window\'s position. # Example ```python nums = [1,3,-1,-3,5,3,6,7] k = 3 # Output: [3, 3, 5, 5, 6, 7] nums = [4,3,2,1] k = 2 # Output: [4, 3, 2] ``` # Solution Requirements 1. Implement function `max_sliding_window(nums: List[int], k: int) -> List[int]` with efficient O(n) time complexity. 2. Handle edge cases such as an empty array or window size greater than the array length internally within the function. # Context This algorithm can be commonly used in scenarios where real-time analysis of peaks in a rolling window is crucial, such as financial market trends or environmental monitoring over a time lapse.","solution":"from collections import deque from typing import List def max_sliding_window(nums: List[int], k: int) -> List[int]: Returns the list of the maximum values from each sliding window of size k in the array nums. if not nums or k <= 0: return [] deq = deque() result = [] for i, n in enumerate(nums): # Remove indexes of elements not within the sliding window if deq and deq[0] < i - k + 1: deq.popleft() # Remove indexes of all elements smaller than the current element while deq and nums[deq[-1]] < n: deq.pop() # Add current element at the end of the deque deq.append(i) # The first element in the deque is the largest element in the current sliding window if i >= k - 1: result.append(nums[deq[0]]) return result"},{"question":"# Question **Context**: You are developing a text recognition software that identifies repetitive patterns within strings. To test a core feature of your software, you need to create a function that determines if a given string can be constructed by repeating a substring of itself. **Function Signature**: ```python def can_be_repeated(s: str) -> bool: pass ``` **Input**: - A non-empty string `s` containing only lowercase alphabetic characters. **Output**: - Return `True` if the string can be constructed by repeating a substring, and `False` otherwise. **Constraints**: - The length of the string (`len(s)`) is at most 10^5. **Examples**: 1. `s = \\"abab\\"` → Output: `True` - Explanation: The string can be constructed by repeating the substring \\"ab\\". 2. `s = \\"aba\\"` → Output: `False` - Explanation: The string cannot be constructed by repeating any substring. 3. `s = \\"abcabcabcabc\\"` → Output: `True` - Explanation: The string can be constructed by repeating the substring \\"abc\\". **Performance Requirements**: - The function should be efficient in both time and space, ideally O(n) for both, where n is the length of the string. Implement the `can_be_repeated` function based on the provided constraints and examples.","solution":"def can_be_repeated(s: str) -> bool: Check if the string can be constructed by repeating a substring of itself. # Create a doubled version of the string doubled_s = s + s # Remove the first and the last character possible_substring = doubled_s[1:-1] # Check if the original string exists in the manipulated doubled string return s in possible_substring"},{"question":"# Question You work for a data processing company that frequently sorts large datasets of integers. Your task is to implement the radix sort algorithm for the company. However, you need to modify the radix sort algorithm provided in the code snippet to handle negative integers as well. # Description Given an array of integers, which may include both positive and negative numbers, write a function: ```python def extended_radix_sort(arr): # Your code here ``` This function should sort the array in ascending order using the radix sort algorithm with necessary modifications to handle negative numbers. # Example Input ```python arr = [170, 45, 75, -90, 802, 24, 2, 66, -10, -802] ``` Output ```python [-802, -90, -10, 2, 24, 45, 66, 75, 170, 802] ``` # Constraints 1. The input list can contain negative and positive integers. 2. The input list can be empty. 3. The length of the list can be up to 10^6. 4. The absolute value of any number in the list can be up to 10^9. # Requirements * The solution must perform sorting in O(nk) time complexity where `n` is the number of elements and `k` is the number of digits in the maximum absolute number. * The implementation should be able to handle the provided constraints efficiently. **Hint**: To handle negative numbers, separate the positive and negative numbers, perform radix sort on their absolute values separately, then recombine them.","solution":"def counting_sort(arr, exp): A helper function to perform counting sort based on the digit represented by exp (10^i). n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = abs(arr[i]) // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = abs(arr[i]) // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 i -= 1 for i in range(n): arr[i] = output[i] def radix_sort(arr): A helper function to perform radix sort on an array of non-negative integers. max_val = max(arr, key=abs) if arr else 0 exp = 1 while max_val // exp > 0: counting_sort(arr, exp) exp *= 10 def extended_radix_sort(arr): Sorts an array of integers, including negative integers, using the radix sort algorithm. if not arr: return arr positive_numbers = [num for num in arr if num >= 0] negative_numbers = [-num for num in arr if num < 0] radix_sort(positive_numbers) radix_sort(negative_numbers) sorted_arr = [-num for num in reversed(negative_numbers)] + positive_numbers return sorted_arr"},{"question":"# Matrix Power Calculation You are given a square matrix `A` of dimensions `d x d` and an integer `n`. Your task is to compute the matrix `A` raised to the power of `n` (A^n) efficiently. Write a function `matrix_power(A: list, n: int) -> list` that takes a list of lists `A` representing a square matrix and an integer `n`, and returns a new matrix which is the result of `A` raised to the power `n`. # Input * `A`: A list of lists, where each nested list represents a row of the matrix. Each element in the matrix is an integer. * `n`: An integer (0 <= n <= 10^9), the power to which the matrix `A` needs to be raised. # Output * The resultant matrix after raising `A` to the power `n`. # Constraints * The matrix dimensions `d x d` will not exceed `100 x 100`. * The integer elements within the matrix range from -1000 to 1000. * Expected output should be computed efficiently considering the potential size of `d` and `n`. # Example ```python def matrix_power(A: list, n: int) -> list: # Your code here # Example usage A = [ [1, 2], [3, 4] ] n = 2 print(matrix_power(A, n)) # Output: [[7, 10], [15, 22]] ``` # Explanation of Example: For the given 2x2 matrix `A` raised to the power of 2: [ A^2 = begin{bmatrix} 1 & 2 3 & 4 end{bmatrix} times begin{bmatrix} 1 & 2 3 & 4 end{bmatrix} = begin{bmatrix} 7 & 10 15 & 22 end{bmatrix} ] # Note: * Ensure that your implementation handles edge cases properly, such as the power being 0, where the result should be an identity matrix. * Aim for an optimized solution leveraging matrix exponentiation by repeated squaring technique to meet the constraints.","solution":"def matrix_multiply(A, B): # Matrix multiplication of A and B dim = len(A) C = [[0] * dim for _ in range(dim)] for i in range(dim): for j in range(dim): C[i][j] = sum(A[i][k] * B[k][j] for k in range(dim)) return C def identity_matrix(dim): # Create an identity matrix of dimension dim return [[1 if i == j else 0 for j in range(dim)] for i in range(dim)] def matrix_power(A, n): if n == 0: return identity_matrix(len(A)) elif n == 1: return A elif n % 2 == 0: half_power = matrix_power(A, n // 2) return matrix_multiply(half_power, half_power) else: return matrix_multiply(A, matrix_power(A, n - 1))"},{"question":"# Unique Permutations of a List with Duplicates You are tasked with writing a Python function that generates all unique permutations of a list that may contain duplicates. The function should ensure that only unique permutations are counted and returned. Function Specification: ```python def permute_unique(nums: List[int]) -> List[List[int]]: pass ``` Input * `nums`: A list of integers (`List[int]`) which may contain duplicates. The number of integers, N, satisfies `0 <= N <= 8`. Output * `List[List[int]]`: A list where each element is a unique permutation of the input list `nums`. Example ```python assert permute_unique([1, 1, 2]) == [ [1, 1, 2], [1, 2, 1], [2, 1, 1] ] ``` Constraints and Requirements * Your solution must handle lists with up to 8 elements due to the high computational complexity. * The permutations must be unique, and the order of elements in the permutations is significant. * Consider optimal performance to handle edge cases such as large numbers of duplicates effectively. # Context Imagine you are working on a project where you need to generate all possible unique configurations of a set of components, which may contain duplicate items. This utility can aid in enumerating all valid combinations to test against a set of constraints or requirements.","solution":"from typing import List from itertools import permutations def permute_unique(nums: List[int]) -> List[List[int]]: Generate all unique permutations of a list that may contain duplicates. unique_perms = set(permutations(nums)) return [list(perm) for perm in unique_perms]"},{"question":"# Binary Search Application: Find Rotation Point **Problem Statement:** You are given a list of words that are mostly alphabetical, except they start somewhere in the middle of the alphabet, reach the end, and then start from the beginning. In other words, it is a rotated version of a sorted list. Your task is to write a function to find the index of the rotation point (the point where the rotation happens) in the list. For example: ```python words = [\'kale\', \'kiwi\', \'lemon\', \'mango\', \'apple\', \'banana\', \'cherry\'] rotation_point = find_rotation_point(words) print(rotation_point) # Output should be 4 because \'apple\' is the smallest and is the rotation point. ``` **Function Signature:** ```python def find_rotation_point(words: List[str]) -> int: ``` **Input Format:** * A list of strings `words` - each string consists of lowercase English letters. The list is guaranteed to be a rotated version of a sorted list. **Output Format:** * Return an integer representing the index of the rotation point. **Constraints:** * The input list contains at least 2 elements and at most 10^5 elements. * All words are unique. **Example:** ```python words = [\'sphinx\', \'zebra\', \'apple\', \'banana\', \'carrot\'] assert find_rotation_point(words) == 2 words = [\'ptolemaic\', \'retrograde\', \'supplant\', \'undulate\', \'xenoepist\', \'asymptote\', \'babka\', \'banoffee\'] assert find_rotation_point(words) == 5 ``` **Notes:** * You must use the principles of Binary Search to achieve the expected time complexity of O(log n).","solution":"from typing import List def find_rotation_point(words: List[str]) -> int: Finds the index of the rotation point in the list of words. Args: words: A list of strings representing a rotated sorted list of words. Returns: Index of the rotation point. lower = 0 upper = len(words) - 1 while lower < upper: mid = (lower + upper) // 2 # If mid element is greater than the last element, rotation point must be to the right if words[mid] > words[upper]: lower = mid + 1 else: # Else, the rotation point is to the left (including mid) upper = mid return lower"},{"question":"You are tasked with implementing a basic Calculator that supports arithmetic operations using an **infix expression**. The Calculator should leverage the Stack Abstract Data Type (ADT) to handle operators and operands. # Function Signature ```python def evaluate_expression(expression: str) -> int: pass ``` # Input * `expression` (str): A valid infix arithmetic expression containing integers and operators `+`, `-`, `*`, `/`. The expression can have spaces which should be ignored. It is guaranteed to not have any unmatched parentheses and to only contain valid characters. # Output * Returns an integer which is the result of the evaluated expression. # Examples ```python assert evaluate_expression(\\"3 + 5\\") == 8 assert evaluate_expression(\\"10 + 2 * 6\\") == 22 assert evaluate_expression(\\"100 * 2 + 12\\") == 212 assert evaluate_expression(\\"100 * ( 2 + 12 )\\") == 1400 assert evaluate_expression(\\"100 * ( 2 + 12 ) / 14\\") == 100 ``` # Constraints * Only `+`, `-`, `*`, and `/` operators. * The result is guaranteed to fit in a 32-bit integer. * Division assumes integer division. # Performance Requirements * The function should handle expressions with up to 1000 characters efficiently. # Hints 1. You can use two stacks: one for operators and one for operands. 2. Consider how operator precedence and parentheses affect the order of operations. 3. Ensure to handle spaces appropriately. # Edge Cases * Ensure to handle division by zero gracefully. * Check for invalid expressions that may lead to empty stack operations. Good luck, and may the stacks be with you!","solution":"def evaluate_expression(expression: str) -> int: def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 def apply_operator(operands, operator): right = operands.pop() left = operands.pop() if operator == \'+\': operands.append(left + right) elif operator == \'-\': operands.append(left - right) elif operator == \'*\': operands.append(left * right) elif operator == \'/\': operands.append(int(left / right)) # ensure integer division def evaluate(expression): i = 0 operands = [] operators = [] while i < len(expression): if expression[i] == \' \': i += 1 continue elif expression[i] == \'(\': operators.append(expression[i]) elif expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = val * 10 + int(expression[i]) i += 1 operands.append(val) i -= 1 elif expression[i] == \')\': while operators and operators[-1] != \'(\': apply_operator(operands, operators.pop()) operators.pop() # remove \'(\' else: while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operands, operators.pop()) operators.append(expression[i]) i += 1 while operators: apply_operator(operands, operators.pop()) return operands[-1] return evaluate(expression)"},{"question":"# Binary Tree In-order Traversal In a binary tree, the in-order traversal visits nodes in the order of left subtree, root, and then right subtree. Your task is to implement both iterative and recursive in-order traversal functions for a given binary tree structure. Input You will be given the root node of a binary tree. Each node in the binary tree is an instance of the following `Node` class: ```python class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output Return a list of integers representing the in-order traversal of the binary tree. Constraints * The number of nodes in the binary tree is in the range `[0, 1000]`. * The value of each node is an integer within `[-1000, 1000]`. Examples ```python # Example 1: # Input: root = Node(2, Node(1), Node(3)) # Output: [1, 2, 3] # Example 2 # Input: root = Node(1, None, Node(2, Node(3), None)) # Output: [1, 3, 2] ``` Requirements 1. Implement the `inorder_iterative(root)` function to perform an iterative in-order traversal. 2. Implement the `inorder_recursive(root)` function to perform a recursive in-order traversal. Function Signatures ```python def inorder_iterative(root: Node) -> List[int]: # Your code here def inorder_recursive(root: Node) -> List[int]: # Your code here ```","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_iterative(root: Node) -> list: Perform an iterative in-order traversal of a binary tree. result = [] stack = [] current = root while current is not None or stack: # Reach the leftmost Node of the current Node while current is not None: stack.append(current) current = current.left # Current must be None at this point current = stack.pop() result.append(current.val) # Visit the right subtree current = current.right return result def inorder_recursive(root: Node) -> list: Perform a recursive in-order traversal of a binary tree. def helper(node: Node): if node: helper(node.left) traversal.append(node.val) helper(node.right) traversal = [] helper(root) return traversal"},{"question":"Context: Mathematicians are fascinated by numbers that reveal interesting properties under specific transformations. One such property is that of a \\"Eureka\\" number—where each digit of the number raised to consecutive powers sums up to the original number itself. Your task is to implement a function that finds all such numbers within a given range [low, high], inclusive. Function Specification Implement the function `find_eureka_numbers(low: int, high: int) -> List[int]`: - **Input**: - `low`: An integer, the lower bound of the range (inclusive). - `high`: An integer, the upper bound of the range (inclusive). - **Output**: - Return a list of integers that represent all \\"Eureka\\" numbers within the given range. Constraints: - `1 <= low <= high <= 10**6` - Maximum difference between `high` and `low` will be 10^5. Requirements: - The solution should handle the largest input limits efficiently. - Numerical calculations should be accurate and precise. Function Signature: ```python def find_eureka_numbers(low: int, high: int) -> List[int]: ``` Example: ```python assert find_eureka_numbers(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert find_eureka_numbers(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert find_eureka_numbers(90, 150) == [135] ``` Edge Cases: - Ensure the function handles the minimum and maximum values correctly. - Include tests for ranges where no \\"Eureka\\" numbers are present.","solution":"def find_eureka_numbers(low: int, high: int) -> list: Finds all \'Eureka\' numbers in the given range [low, high] inclusive. def is_eureka_number(num): digits = list(map(int, str(num))) power_sum = sum(digit**(i + 1) for i, digit in enumerate(digits)) return power_sum == num return [num for num in range(low, high + 1) if is_eureka_number(num)]"},{"question":"Enhanced Binary Search Tree Context: You are given the task of enhancing the functionality of a basic Binary Search Tree (BST). The BST has the fundamental operations of insert, search, size calculation, and different traversal methods already implemented. However, in real-world applications, maintaining the balance of the BST is crucial for performance consistency. Therefore, you are required to implement a self-balancing Binary Search Tree, specifically an AVL Tree. Problem Statement: Implement an AVL Tree which is a self-balancing Binary Search Tree. In an AVL Tree, the heights of the two child subtrees of any node differ by at most one. You need to implement the following methods: 1. **Insert**: Insert a new element into the AVL tree while maintaining its balanced property. 2. **Delete**: Remove an existing element from the AVL tree while maintaining its balanced property. 3. **Height**: Calculate the height of the AVL tree. 4. **Size**: Calculate the number of elements in the AVL tree. 5. **Traversal (Inorder, Preorder, Postorder)**: Similar to a basic BST. Requirements: - You must ensure that the tree remains balanced after every insertion and deletion. - You should handle duplicate insertions gracefully (i.e., do not insert duplicates). - Implement and use tree rotations (left, right, left-right, right-left) to maintain the balance. Function Signatures: ```python class AVLTree: def insert(self, data: int) -> None: pass def delete(self, data: int) -> None: pass def height(self) -> int: pass def size(self) -> int: pass def inorder(self) -> list: pass def preorder(self) -> list: pass def postorder(self) -> list: pass ``` Constraints: - The value of each node to be an integer. - Consider at least one rotation required after any insert/delete operation for large datasets (e.g., values between 1 and 10,000). Example: ```python avl = AVLTree() avl.insert(10) avl.insert(20) avl.insert(30) # The tree will rebalance itself after each insert operation assert avl.height() == 2 assert avl.size() == 3 assert avl.inorder() == [10, 20, 30] avl.delete(20) assert avl.inorder() == [10, 30] assert avl.height() == 1 assert avl.size() == 2 ``` Write your entire class definition with the required methods implemented to ensure the AVL Tree functionality.","solution":"class AVLTree: class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 def __init__(self): self.root = None def insert(self, key: int) -> None: self.root = self._insert(self.root, key) def _insert(self, root, key): if not root: return self.Node(key) elif key < root.key: root.left = self._insert(root.left, key) elif key > root.key: root.right = self._insert(root.right, key) else: return root root.height = 1 + max(self._get_height(root.left), self._get_height(root.right)) balance = self._get_balance(root) if balance > 1 and key < root.left.key: return self._right_rotate(root) if balance < -1 and key > root.right.key: return self._left_rotate(root) if balance > 1 and key > root.left.key: root.left = self._left_rotate(root.left) return self._right_rotate(root) if balance < -1 and key < root.right.key: root.right = self._right_rotate(root.right) return self._left_rotate(root) return root def delete(self, key: int) -> None: self.root = self._delete(self.root, key) def _delete(self, root, key): if not root: return root if key < root.key: root.left = self._delete(root.left, key) elif key > root.key: root.right = self._delete(root.right, key) else: if not root.left: return root.right elif not root.right: return root.left temp = self._get_min_value_node(root.right) root.key = temp.key root.right = self._delete(root.right, temp.key) if not root: return root root.height = 1 + max(self._get_height(root.left), self._get_height(root.right)) balance = self._get_balance(root) if balance > 1 and self._get_balance(root.left) >= 0: return self._right_rotate(root) if balance > 1 and self._get_balance(root.left) < 0: root.left = self._left_rotate(root.left) return self._right_rotate(root) if balance < -1 and self._get_balance(root.right) <= 0: return self._left_rotate(root) if balance < -1 and self._get_balance(root.right) > 0: root.right = self._right_rotate(root.right) return self._left_rotate(root) return root def height(self) -> int: if not self.root: return 0 return self.root.height def size(self) -> int: return self._size(self.root) def _size(self, node): if not node: return 0 return 1 + self._size(node.left) + self._size(node.right) def inorder(self) -> list: res = [] self._inorder(self.root, res) return res def _inorder(self, node, res): if node: self._inorder(node.left, res) res.append(node.key) self._inorder(node.right, res) def preorder(self) -> list: res = [] self._preorder(self.root, res) return res def _preorder(self, node, res): if node: res.append(node.key) self._preorder(node.left, res) self._preorder(node.right, res) def postorder(self) -> list: res = [] self._postorder(self.root, res) return res def _postorder(self, node, res): if node: self._postorder(node.left, res) self._postorder(node.right, res) res.append(node.key) def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _get_min_value_node(self, root): if root is None or root.left is None: return root return self._get_min_value_node(root.left)"},{"question":"Scenario: You are working on a system that analyzes geographical data. The system stores various geographically significant heights in meters above sea level in a Binary Search Tree (BST). Given a floating-point altitude as the target, your task is to find the height in the BST that is closest to this target value. Problem Statement: Write a function `closest_height` that, given the root of a non-empty Binary Search Tree (BST) and a floating-point target value, returns the integer value in the BST that is closest to the target. Function Signature: ```python def closest_height(root, target): :type root: TreeNode :type target: float :rtype: int ``` Inputs: - `root` (TreeNode): The root node of the non-empty BST. - `target` (float): The target floating-point value. Output: - An integer value representing the closest height in the BST to the target. Constraints: - The given tree is a valid binary search tree. - Only one unique value in the BST is the closest to the target. Example: ```python # Example BST: # 8 # / # 3 10 # / # 1 6 14 # / / # 4 7 13 # Input: root = [8,3,10,1,6,None,14,None,None,4,7,13], target = 9.1 # Output: 10 ``` Notes: - You are guaranteed to have only one unique value in the BST that is closest to the target. - Use proper tree node class definition for the input. TreeNode Class Definition: ```python class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def closest_height(root, target): :type root: TreeNode :type target: float :rtype: int closest = root.val current_node = root while current_node: if abs(current_node.val - target) < abs(closest - target): closest = current_node.val if target < current_node.val: current_node = current_node.left elif target > current_node.val: current_node = current_node.right else: break return closest"},{"question":"# Wiggle Sort Implementation Challenge You are working on a data modeling project where you need to arrange sensor data values in a specific alternating pattern. Write a function `wiggle_sort` that rearranges a given list of integers such that for every i (0 ≤ i < n - 1): - if i is even, nums[i] <= nums[i+1] - if i is odd, nums[i] >= nums[i+1] The function should modify the list in place and should not return anything. # Function Signature ```python def wiggle_sort(nums: List[int]) -> None: pass ``` # Input * `nums`: a list of integers, `1 <= len(nums) <= 10^4`. # Output * Modify the input list `nums` in place to satisfy the wiggle sort conditions. # Constraints * The function should run in O(n) time complexity and O(1) space complexity. # Example ```python nums = [3, 5, 2, 1, 6, 4] wiggle_sort(nums) print(nums) # Output should be [3, 5, 1, 6, 2, 4] or another valid wiggle sorted array ``` # Notes * There can be multiple correct outputs for the same input list. * Ensure that the function handles edge cases like arrays with identical elements and arrays with lengths of 1 or 2. # Scenario Imagine you are developing a simulation in which collected sensor values need to be processed for further analysis. These values must be arranged in a wiggle pattern to simulate specific constraints required for an experimental model. Your task is to implement and test the wiggle sort function to ensure accurate and efficient data preparation.","solution":"from typing import List def wiggle_sort(nums: List[int]) -> None: Modify the list nums in place to satisfy the wiggle sort conditions. for i in range(len(nums) - 1): if (i % 2 == 0 and nums[i] > nums[i + 1]) or (i % 2 == 1 and nums[i] < nums[i + 1]): nums[i], nums[i + 1] = nums[i + 1], nums[i]"},{"question":"# Square Root Approximation Implementation Background You are tasked with implementing an improved and more robust approach for approximating the square root of a given number, ( N ). This task makes frequent appearances in numerical analysis and various scientific computations where exact square roots are not a strict necessity, and a close approximation suffices. Objective Write a function that calculates the square root of a positive integer ( N ) with a specified precision ( P ). The function should accurately handle edge cases such as perfect squares, very small values of ( N ), and high precision requirements. Function Signature ```python def improved_square_root(n: int, precision: float=0.001) -> float: pass ``` Input * An integer ( N ) (1 ≤ N ≤ 10^6) — the number whose square root has to be computed. * A floating point number ( P ) (0 < P ≤ 0.1) — the allowed precision (epsilon). Output * Return a float representing the approximated square root of ( N ) that should be accurate within ( pm P ) of the actual square root of ( N ). Constraints * The function should run efficiently even for the upper limit values. * Handle special cases such as perfect squares efficiently. Examples ```python improved_square_root(5, 0.001) # Expected output: A number close to 2.236 improved_square_root(36, 0.0001) # Expected output: A number close to 6.0 improved_square_root(0.25, 0.00001) # Expected output: A number close to 0.5 ``` Explanation Your function should utilize iterative methods to find the square root, similar to Newton\'s Method, but should take care of edge cases and precision as mentioned. The algorithm iteratively improves an initial guess by averaging it with ( N ) divided by the guess until the difference between the square of the guess and ( N ) is within ( P ).","solution":"def improved_square_root(n: int, precision: float = 0.001) -> float: if n < 0: raise ValueError(\\"Cannot compute the square root of a negative number.\\") if n == 0: return 0.0 # Initial guess guess = n / 2.0 while abs(guess * guess - n) > precision: guess = (guess + n / guess) / 2.0 return guess"},{"question":"Background Scenario You are developing a software that processes mathematical expressions. One crucial feature is to validate the parentheses used in these expressions to ensure they are balanced and correctly nested. This validation is necessary as improper use of parentheses can lead to syntactical errors and incorrect computations. Task Write a function called `is_valid_expression` that takes a string `expression` containing characters \'(\', \')\', \'{\', \'}\', \'[\', \']\', and other alphanumeric characters. Your function should determine if the input string has balanced and correctly nested parentheses. Only the parentheses need to be validated; other characters can be ignored. Function Signature ```python def is_valid_expression(expression: str) -> bool: pass ``` Input and Output Formats - **Input**: A single string `expression`, which can be empty or contain up to 10^4 characters. - **Output**: Return `True` if the parentheses in the expression are valid; otherwise, `False`. Constraints - The string may contain characters besides \'(\', \')\', \'{\', \'}\', \'[\', \']\', including alphabetic and numeric characters. - The focus is solely on the parentheses and their correct nesting and closure. Examples ```python assert is_valid_expression(\\"()\\") == True assert is_valid_expression(\\"()[]{}\\") == True assert is_valid_expression(\\"(]\\") == False assert is_valid_expression(\\"([)]\\") == False assert is_valid_expression(\\"{[()]}\\") == True assert is_valid_expression(\\"a+b(c[d]e)f\\") == True assert is_valid_expression(\\"a(b{c[d]})f]\\") == False ``` Edge Cases to Consider - Empty string should return `True`. - Strings with only opening or only closing parentheses should return `False`. - Properly nested but sequentially invalid patterns like \\"([)]\\". Good luck!","solution":"def is_valid_expression(expression: str) -> bool: Checks if the given expression has balanced and correctly nested parentheses. stack = [] matching_parentheses = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in expression: if char in matching_parentheses.values(): stack.append(char) elif char in matching_parentheses.keys(): if stack == [] or matching_parentheses[char] != stack.pop(): return False return stack == []"},{"question":"# Question: Implement Enhanced Prim\'s Minimum Spanning Tree Algorithm Scenario: You are tasked with enhancing network connectivity in a newly developed smart city. The city\'s communication infrastructure must be optimized such that the total length of cable used to connect all city sectors is minimized while ensuring that every sector is interconnected. Given the city sectors and the cost associated with connecting pairs of them, you need to implement an efficient algorithm to calculate the minimum cost required to span all sectors. Task: Implement an optimized version of Prim\'s Minimum Spanning Tree algorithm to find the weight of the minimum spanning tree of a given connected graph. Your implementation should account for vertices denoted by either letters or integers. Function Signature: ```python def enhanced_prims_minimum_spanning(graph): pass ``` Input: - `graph`: A dictionary representing an undirected, weighted, connected graph. Each key represents a vertex, and each value is a list of lists where each inner list consists of two elements: the weight of the edge and the adjacent vertex. Output: - Returns an integer: The total weight of the minimum spanning tree. Constraints: - The graph will have at least 2 vertices. - Each edge weight is a non-negative integer. Example ```python graph = { \'a\': [[3, \'b\'], [8, \'c\']], \'b\': [[3, \'a\'], [5, \'d\']], \'c\': [[8, \'a\'], [2, \'d\'], [4, \'e\']], \'d\': [[5, \'b\'], [2, \'c\'], [6, \'e\']], \'e\': [[4, \'c\'], [6, \'d\']] } print(enhanced_prims_minimum_spanning(graph)) # Output: 14 ``` Notes: - Consider the graph to be undirected, and avoid considering the same edge twice. - Handle various edge cases, such as different starting nodes. - Use appropriate data structures to ensure efficient algorithm performance.","solution":"import heapq def enhanced_prims_minimum_spanning(graph): Implements Prim\'s algorithm to calculate the weight of the minimum spanning tree. :param graph: dict, representing the graph as adjacency list with weights :return: int, representing the total weight of the minimum spanning tree if not graph: return 0 total_weight = 0 start_node = next(iter(graph)) visited = set([start_node]) min_heap = [] # Initialize the heap with the edges of the start node for weight, neighbor in graph[start_node]: heapq.heappush(min_heap, (weight, neighbor)) while min_heap: weight, node = heapq.heappop(min_heap) if node not in visited: visited.add(node) total_weight += weight for next_weight, next_neighbor in graph[node]: if next_neighbor not in visited: heapq.heappush(min_heap, (next_weight, next_neighbor)) return total_weight"},{"question":"# Question: Implement a Custom Pancake Sort Variant As a software development challenge, you are tasked with implementing a customized variant of the Pancake Sort algorithm. This variant should additionally include a feature where a predefined threshold value splits the sorting process. Any elements greater than the threshold should be sorted first, followed by a subsequent sorting of the remaining elements. Requirements: * Write a function `custom_pancake_sort(arr, threshold)` which performs the described pancake sort. * **Input**: - `arr`: A list of integers to be sorted. - `threshold`: An integer threshold that dictates the sorting split. * **Output**: - Return a list where elements greater than `threshold` are sorted first (in ascending order), followed by the sorted remaining elements. * Elements equal to `threshold` can be part of either sorted subgroup, but must appear after all elements greater than `threshold`. # Constraints: * The array can have a length between 1 and 10^3. * Each integer in the array will be between -10^6 and 10^6. * The solution should maintain O(N^2) time complexity and O(1) space complexity inherent to pancake sort. # Example: ```python custom_pancake_sort([3, 6, 4, 7, 2, 5], 4) # Output: [5, 6, 7, 2, 3, 4] custom_pancake_sort([10, 9, 1, 2, 15, 20], 12) # Output: [15, 20, 10, 9, 1, 2] custom_pancake_sort([8, 4, 6, 2, 3, 5, 1], 5) # Output: [6, 8, 1, 2, 3, 4, 5] ``` # Notes: * You may use helper functions to flip parts of the list. * Ensure your function follows the prescribed time complexity.","solution":"def flip(arr, k): Helper function to flip the first k elements of the list. arr[:k] = arr[:k][::-1] def pancake_sort(arr, indices): Pancake sort the elements of arr specified by the indices. n = len(indices) for i in range(n, 1, -1): # Index of the maximum element in the unsorted part max_idx = max(range(i), key=lambda x: arr[indices[x]]) if max_idx != i - 1: # Flip the maximum element to the front flip(indices, max_idx + 1) # Flip it to its correct position flip(indices, i) def custom_pancake_sort(arr, threshold): Custom pancake sort variant. # Separate indices based on the threshold greater_indices = [i for i in range(len(arr)) if arr[i] > threshold] remaining_indices = [i for i in range(len(arr)) if arr[i] <= threshold] # Sort the subarrays using pancake sort pancake_sort(arr, greater_indices) pancake_sort(arr, remaining_indices) # Combine the sorted results sorted_arr = [arr[i] for i in greater_indices + remaining_indices] return sorted_arr"},{"question":"# Question: Topological Sorting of a Directed Acyclic Graph Context You are given a directed graph represented as an adjacency list where each node represents a task, and each directed edge represents a dependency. Your goal is to determine a valid linear ordering of tasks such that for any directed edge `u -> v`, task `u` must be completed before task `v`. Task Implement a function `topological_sort(graph)` that takes in an adjacency list representation of a directed acyclic graph and returns its topological order. Function Signature ```python def topological_sort(graph: dict) -> list: pass ``` Input - `graph`: A dictionary where the keys are nodes and the values are lists of nodes representing directed edges. For example, `{1: [2], 2: [3], 3: []}` represents a graph with edges `1 -> 2` and `2 -> 3`. Output - Return a list representing the topological order of the nodes. If there are multiple valid orderings, return any one. Constraints - The graph contains no cycles. - The graph can have up to `10^4` nodes and `10^5` edges. - Nodes are represented by integers. Example ```python graph = { 5: [2, 0], 4: [0, 1], 3: [1], 2: [3], 1: [], 0: [] } print(topological_sort(graph)) # one possible output: [5, 4, 2, 3, 1, 0] ``` Notes - Handle edge cases such as an empty graph, graph with no dependencies, and graph with multiple disconnected components. - Ensure that the implementation raises an appropriate error message in case the input graph contains cycles.","solution":"def topological_sort(graph): Returns the topological order of a directed acyclic graph. Args: graph: adjacency list representing the graph Returns: list: topological order of the nodes from collections import defaultdict, deque # Compute indegree of each node indegree = defaultdict(int) for node in graph: for neighbor in graph[node]: indegree[neighbor] += 1 # Queue for nodes with no incoming edges queue = deque([node for node in graph if indegree[node] == 0]) # Initialize the topological order list topo_order = [] while queue: current = queue.popleft() topo_order.append(current) # Decrease the indegree of neighbors for neighbor in graph[current]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If topo_order doesn\'t contain all nodes, there was a cycle if len(topo_order) != len(graph): raise ValueError(\\"Graph contains a cycle\\") return topo_order"},{"question":"You are required to implement a priority queue, where each element has a priority, and elements are dequeued based on their priority rather than their order in the queue. Elements with higher priority are dequeued before elements with lower priority. If two elements have the same priority, they are dequeued in their order of arrival (FIFO for same-priority elements). # Specifications Input and Output: - **Input**: A series of operations to be performed on the priority queue. - Operations include \\"enqueue(value, priority)\\", \\"dequeue()\\", and \\"peek()\\". - **Output**: For each \\"dequeue()\\" and \\"peek()\\" operation, return the value of the element from the queue. Constraints: - Priorities are non-negative integers. - Values can be any comparable data type (integers, strings, etc.). - The queue should handle at least 100,000 operations efficiently. # Performance Requirements: - The `enqueue`, `dequeue`, and `peek` operations should be efficient enough to handle the upper constraints smoothly. # Detailed Requirements **Class Name**: `PriorityQueue` **Methods**: 1. `enqueue(value, priority)`: Inserts an element with the given priority. 2. `dequeue()`: Removes and returns the highest priority element from the queue. 3. `peek()`: Returns the highest priority element without removing it. 4. `is_empty()`: Returns `True` if the queue is empty, `False` otherwise. 5. `__len__()`: Returns the number of elements in the queue. ```python class PriorityQueue: def __init__(self): Initialize your data structure here. # Placeholder for your implementation def enqueue(self, value, priority): Inserts an element with the given priority. :param value: Any, the value to be inserted :param priority: int, the priority of the value # Placeholder for your implementation def dequeue(self): Removes and returns the highest priority element from the queue. :return: Any, the value of the highest priority element # Placeholder for your implementation def peek(self): Returns the highest priority element without removing it. :return: Any, the value of the highest priority element # Placeholder for your implementation def is_empty(self): Returns `True` if the queue is empty, `False` otherwise. :return: bool, whether the queue is empty # Placeholder for your implementation def __len__(self): Returns the number of elements in the queue. :return: int, the number of elements in the queue. # Placeholder for your implementation ``` # Example ```python pq = PriorityQueue() pq.enqueue(\\"task1\\", 5) pq.enqueue(\\"task2\\", 10) pq.enqueue(\\"task3\\", 7) print(pq.peek()) # Output: \\"task2\\" print(pq.dequeue()) # Output: \\"task2\\" print(pq.peek()) # Output: \\"task3\\" print(pq.dequeue()) # Output: \\"task3\\" print(pq.dequeue()) # Output: \\"task1\\" print(pq.is_empty()) # Output: True ``` **Additional Notes**: - Ensure that your implementation can handle varying loads and priorities efficiently. - Handle edge cases such as operations on an empty queue gracefully. - Perform adequate testing to validate performance and correctness.","solution":"import heapq class PriorityQueue: def __init__(self): Initialize your data structure here. self.heap = [] self.counter = 0 # This is used to break ties in priorities def enqueue(self, value, priority): Inserts an element with the given priority. :param value: Any, the value to be inserted :param priority: int, the priority of the value # Use negative priority because heapq is a min-heap, and we want max-heap behavior heapq.heappush(self.heap, (-priority, self.counter, value)) self.counter += 1 def dequeue(self): Removes and returns the highest priority element from the queue. :return: Any, the value of the highest priority element if self.is_empty(): raise IndexError(\\"dequeue from an empty priority queue\\") return heapq.heappop(self.heap)[2] def peek(self): Returns the highest priority element without removing it. :return: Any, the value of the highest priority element if self.is_empty(): raise IndexError(\\"peek from an empty priority queue\\") return self.heap[0][2] def is_empty(self): Returns `True` if the queue is empty, `False` otherwise. :return: bool, whether the queue is empty return len(self.heap) == 0 def __len__(self): Returns the number of elements in the queue. :return: int, the number of elements in the queue. return len(self.heap)"},{"question":"You are required to implement the Stooge Sort algorithm on a list of integers. The Stooge Sort is a recursive sorting algorithm which is primarily theoretical due to its impractical time complexity but serves as an educational exercise. # Function Signature ```python def stoogesort(arr, l, h): ``` # Input - `arr`: A list of integers (`List[int]`) to be sorted. - `l`: The starting index (`int`) of the segment of the array that is to be sorted. - `h`: The ending index (`int`) of the segment of the array that is to be sorted. # Output - The `stoogesort` function should sort the list `arr` in place and should not return anything. # Constraints 1. The list `arr` will contain at least one element and at most 1000 elements. 2. Each element in the list will be an integer in the range `[-10^6, 10^6]`. 3. You should handle input validation internally if necessary (e.g. invalid index bounds). # Example ```python # Given the array and its segment bounds arr = [5, 4, 3, 2, 1] stoogesort(arr, 0, len(arr)-1) print(arr) # Output should be: [1, 2, 3, 4, 5] arr = [2, 3, 2, 5, 4, 1] stoogesort(arr, 0, len(arr)-1) print(arr) # Output should be: [1, 2, 2, 3, 4, 5] ``` # Notes - Ensure that your function correctly implements the Stooge Sort algorithm as described. - Consider edge cases, such as arrays with all identical elements or very short arrays. - Aim to keep your implementation as efficient as possible within the constraints of the algorithm.","solution":"def stoogesort(arr, l, h): Stooge Sort is a recursive sorting algorithm. It first checks if the value at `l` is greater than the value at `h`. If so, it swaps them. Then it applies the sorting process to the initial two-thirds of the array, the final two-thirds of the array, and then again to the initial two-thirds of the array. if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(arr, l, h - t) stoogesort(arr, l + t, h) stoogesort(arr, l, h - t) # Example usage: arr = [5, 4, 3, 2, 1] stoogesort(arr, 0, len(arr) - 1) print(arr) # Output should be: [1, 2, 3, 4, 5] arr = [2, 3, 2, 5, 4, 1] stoogesort(arr, 0, len(arr) - 1) print(arr) # Output should be: [1, 2, 2, 3, 4, 5]"},{"question":"# Question **Minimum Spanning Tree Using Kruskal\'s Algorithm** You are given a weighted, connected, undirected graph with `n` vertices and `m` edges. Your task is to implement the Kruskal\'s algorithm to find the sum of the weights of the edges in the minimum spanning tree (MST) of the graph. Your implementation should leverage the provided Disjoint Set data structure to efficiently manage the merging of sets. # Input Format 1. The first line contains two integers `n` and `m`, representing the number of vertices and edges, respectively. 2. The next `m` lines each contain three integers `u`, `v`, and `w`, representing an edge between vertices `u` and `v` with weight `w`. # Output Format Output a single integer, the sum of the weights of the edges in the MST. # Constraints - 1 ≤ n ≤ 1000 - 0 ≤ m ≤ 10,000 - 1 ≤ w ≤ 1000 - `u` and `v` are 1-indexed vertices # Example **Input** ``` 5 6 1 2 3 1 3 8 2 4 5 3 4 2 3 5 4 4 5 6 ``` **Output** ``` 14 ``` **Explanation**: The MST includes edges (1, 2), (2, 4), (4, 5), and (3, 4) with a total weight of 3 + 5 + 6 + 2 = 14. # Implementation Notes * You may use the provided `DisjointSet` class. * Ensure that the graph edges are correctly read and sorted before applying Kruskal’s algorithm. * Efficiently handle edge cases and ensure optimal performance for the expected input constraints.","solution":"class DisjointSet: A class to represent a disjoint-set data structure. def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n def find(self, u): Find the representative of the set containing u. if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): Union the sets containing u and v. root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_v] > self.rank[root_u]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def kruskal(n, edges): Implementation of Kruskal\'s algorithm to find the MST of a graph. edges.sort(key=lambda x: x[2]) # Sort edges based on weights disjoint_set = DisjointSet(n) mst_weight = 0 edge_count = 0 for u, v, weight in edges: if disjoint_set.find(u) != disjoint_set.find(v): disjoint_set.union(u, v) mst_weight += weight edge_count += 1 if edge_count == n - 1: break return mst_weight"},{"question":"# Problem Description: You are hired as a software engineer at a company that is developing a new set of cryptographic tools. One essential task is to efficiently perform exponentiation operations with very large numbers, including support for modular arithmetic which is commonly used in cryptography. Implement a function that calculates the exponentiation of a base raised to an exponent, optionally with a modulus. Provide both iterative and recursive implementations. # Function Signatures: ```python def power_iterative(base: int, exponent: int, modulus: int = None) -> int: def power_recursive(base: int, exponent: int, modulus: int = None) -> int: ``` # Input: - `base` (int): The base number of the exponentiation. - `exponent` (int): The exponent to raise the base to. - `modulus` (int, optional): If provided, the function should compute (base ^ exponent) % modulus. # Output: - Returns an integer which is the result of base raised to the power of exponent, optionally modulo the provided modulus. # Constraints: - (1 leq text{base} leq 10^9) - (0 leq text{exponent} leq 10^9) - (1 leq text{modulus} leq 10^9) # Requirements: - Your solution must be efficient and handle large integers without causing performance issues. - Your solution should correctly handle all edge cases, such as exponent being 0 or 1. # Example: ```python assert power_iterative(2, 10, 100) == 24 assert power_recursive(2, 10, 100) == 24 assert power_iterative(3, 0) == 1 assert power_recursive(3, 0) == 1 assert power_iterative(2, 5) == 32 assert power_recursive(2, 5) == 32 assert power_iterative(7, 3, 2) == 1 assert power_recursive(7, 3, 2) == 1 ```","solution":"def power_iterative(base: int, exponent: int, modulus: int = None) -> int: Iteratively calculates (base^exponent) % modulus. If modulus is not specified, it calculates base^exponent. result = 1 if modulus is not None: base %= modulus while exponent > 0: if exponent % 2 == 1: result = result * base if modulus is not None: result %= modulus base = base * base if modulus is not None: base %= modulus exponent //= 2 return result def power_recursive(base: int, exponent: int, modulus: int = None) -> int: Recursively calculates (base^exponent) % modulus. If modulus is not specified, it calculates base^exponent. if modulus is not None: base %= modulus if exponent == 0: return 1 half = power_recursive(base, exponent // 2, modulus) half = (half * half) % modulus if modulus is not None else half * half if exponent % 2 == 0: return half else: result = (half * base) % modulus if modulus is not None else half * base return result"},{"question":"Find the nth Digit in a Sequence Given an infinite sequence of natural numbers concatenated together (i.e., \\"123456789101112...\\"), write a function `find_nth_digit(n: int) -> int` that returns the nth digit of this sequence. Function Signature ```python def find_nth_digit(n: int) -> int: pass ``` Input - A single integer `n` where 1 <= n <= 10^18. Output - An integer representing the nth digit in the concatenated sequence. Performance Requirements - The function should run efficiently for very large values of `n`, ideally with a time complexity of O(log(n)). Constraints - You can assume that `n` will always be a valid positive integer within the provided range. - Do not construct the full sequence as it can be infeasible with large values of `n`. Example ```python assert find_nth_digit(1) == 1 assert find_nth_digit(9) == 9 assert find_nth_digit(10) == 1 assert find_nth_digit(11) == 0 assert find_nth_digit(189) == 9 assert find_nth_digit(190) == 1 assert find_nth_digit(191) == 0 ``` In the above examples: - For `n=1`, the digit is `1`. - For `n=9`, the digit is `9`. - For `n=10`, the digit is `1` (from the number `10`). - For `n=11`, the digit is `0` (from the number `10`). - For `n=189`, the digit is `9` (the last digit of `99`). - For `n=190`, the digit is `1` (from the number `100`). - For `n=191`, the digit is `0` (from the number `100`). Implement the function `find_nth_digit` with the provided signatures and constraints effectively.","solution":"def find_nth_digit(n: int) -> int: length = 1 count = 9 start = 1 # Find the length of the number where the nth digit is located while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Find the actual number where the nth digit belongs start += (n - 1) // length s = str(start) return int(s[(n - 1) % length])"},{"question":"# Unique Character String Construction **Problem Statement**: You are given a string consisting of lowercase and/or uppercase alphabetic characters. Write a function `unique_char_string` that removes any recurring characters and returns the resulting string containing only the first occurrences of each character. The order of first occurrences must be preserved. **Function Signature**: ```python def unique_char_string(s: str) -> str: pass ``` **Input**: - A single string `s` where 1 <= len(s) <= 10^5. **Output**: - A string containing only unique characters in the order they first appeared in `s`. **Constraints**: - Do not use any libraries or functions other than basic string and set operations. - Your solution should be optimized for time efficiency. **Performance Requirements**: - The final implementation should have an average time complexity of O(n), where n is the length of the string, to handle large inputs efficiently. **Example**: ```python assert unique_char_string(\\"banana\\") == \\"ban\\" assert unique_char_string(\\"apple\\") == \\"aple\\" assert unique_char_string(\\"Google\\") == \\"Gogle\\" assert unique_char_string(\\"aabbcc\\") == \\"abc\\" assert unique_char_string(\\"abc\\") == \\"abc\\" ``` **Hint**: Consider using a set to keep track of seen characters and building the output string by iterating through the input string once.","solution":"def unique_char_string(s: str) -> str: Returns a string with only the first occurrence of each character. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"You are the lead software engineer for a task management application that needs to schedule tasks based on their priority. You are given the implementation of a priority queue using a linear array which allows you to insert tasks with a given priority and extract the task with the lowest priority. Your task is to implement the following function in Python: ```python def schedule_tasks(tasks, priorities): tasks: List of integers representing tasks. priorities: List of integers representing priorities of corresponding tasks. Returns a list of tasks ordered by their execution schedule according to priority (lowest first). pass ``` # Requirements: 1. The `schedule_tasks` function takes two lists: - `tasks`: a list of tasks. - `priorities`: a list of integers where each element corresponds to the priority of the respective task in the `tasks` list. 2. Your function should use the `PriorityQueue` class provided in the code snippet. Insert each task with the corresponding priority and then extract tasks in the order they should be scheduled. 3. The output should be a list of tasks ordered by their priority, where the task with the lowest priority comes first. # Constraints: - The number of tasks, `n`, will be between 1 and 10^6. - Priorities will be integer values, which can be negative and positive. - Tasks will be unique integers for simplicity. # Performance Requirements: - Ensure the solution is optimized to handle edge cases where there might be up to 10^6 tasks. # Example Usage: ```python tasks = [1, 2, 3, 4] priorities = [2, 1, 3, 0] assert schedule_tasks(tasks, priorities) == [4, 2, 1, 3] ``` Your task is to complete the `schedule_tasks` function using the provided `PriorityQueue` class. Consider edge cases and ensure the solution is efficient.","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] def insert(self, task, priority): heapq.heappush(self.heap, (priority, task)) def extract_min(self): return heapq.heappop(self.heap)[1] def schedule_tasks(tasks, priorities): pq = PriorityQueue() for task, priority in zip(tasks, priorities): pq.insert(task, priority) scheduled_tasks = [] while pq.heap: scheduled_tasks.append(pq.extract_min()) return scheduled_tasks"},{"question":"# Question: Efficient Duplicate Removal You are given an array that may contain duplicates, and your task is to write a function that removes duplicates and returns a new array with unique elements. Your solution should aim to improve the time complexity to O(n). Function Signature: ```python def remove_duplicates_efficient(array: list) -> list: pass ``` Input: * `array` (list): An array of elements, where elements can be of any data type. Output: * A new list containing the unique elements from the input array, preserving the original order of first occurrence. Constraints: * The input array can contain up to `10^5` elements. * The elements in the array can be of mixed data types (integers, strings, booleans, etc.). Examples: ```python # Example 1 input = [1, 1, 1, 2, 2, 3, 4, 4, \\"hey\\", \\"hey\\", \\"hello\\", True, True] output = [1, 2, 3, 4, \'hey\', \'hello\', True] # Example 2 input = [\\"apple\\", \\"orange\\", \\"apple\\", \\"pear\\", \\"pear\\"] output = [\\"apple\\", \\"orange\\", \\"pear\\"] # Example 3 input = [True, False, True, False, True] output = [True, False] ``` Performance Requirements: * Achieve a time complexity of O(n). # Scenario: You are developing an application that processes user data collected from various sources into a central database. Each user\'s record might be duplicated multiple times. To ensure the uniqueness of records, you need an efficient algorithm for removing duplicates while preserving their original order. # Instructions: Implement the `remove_duplicates_efficient` function in Python according to the mentioned specifications.","solution":"def remove_duplicates_efficient(array: list) -> list: Removes duplicates from the array while preserving the order of first occurrence. seen = set() unique_array = [] for item in array: if item not in seen: seen.add(item) unique_array.append(item) return unique_array"},{"question":"# Pattern Matching You are given a pattern and a string. Write a function that determines if the string follows the same pattern. This means that there should be a bijection (one-to-one relationship) between the characters in the pattern and non-empty substrings of the string. Input: * `pattern` (string): A string consisting of lowercase letters, representing the pattern. * `string` (string): A string consisting of lowercase letters, which needs to be checked against the pattern. Output: * `bool`: Returns `True` if the string follows the given pattern; otherwise, returns `False`. Constraints: * Both `pattern` and `string` are non-empty and consist only of lowercase alphabetical characters. * The length of the `pattern` can range from 1 to 10. * The length of the `string` can range from 1 to 1000. Example: ```python pattern = \\"abab\\" string = \\"redblueredblue\\" # Returns: True pattern = \\"aaaa\\" string = \\"asdasdasdasd\\" # Returns: True pattern = \\"aabb\\" string = \\"xyzabcxzyabc\\" # Returns: False ``` Requirements: 1. Implement the function `pattern_match(pattern: str, string: str) -> bool`. 2. The function should correctly handle cases where multiple characters in the pattern map to the same substring. 3. Consider edge cases such as empty strings and patterns of varying lengths.","solution":"def pattern_match(pattern: str, string: str) -> bool: def backtrack(i, j, p_to_s, s_to_p): if i == len(pattern) and j == len(string): return True if i == len(pattern) or j == len(string): return False pattern_char = pattern[i] for k in range(j + 1, len(string) + 1): substring = string[j:k] if pattern_char in p_to_s: if p_to_s[pattern_char] == substring: if backtrack(i + 1, k, p_to_s, s_to_p): return True elif substring in s_to_p: continue else: p_to_s[pattern_char] = substring s_to_p[substring] = pattern_char if backtrack(i + 1, k, p_to_s, s_to_p): return True del p_to_s[pattern_char] del s_to_p[substring] return False return backtrack(0, 0, {}, {})"},{"question":"# Scenario You are a software engineer working on a high-performance database that frequently requires searching large, sorted datasets. You need to implement an efficient search function that finds an element in these datasets quickly while ensuring minimal performance overhead. # Task Write a function `optimized_jump_search` that searches for a target value in a sorted array using an optimized version of the jump search algorithm. The function should return the index of the target if found, otherwise it should return `-1`. # Input - `arr`: A list of integers sorted in ascending order (1 ≤ len(arr) ≤ 10^6). - `target`: An integer value to search for within `arr` (-10^6 ≤ target ≤ 10^6). # Output - An integer representing the index of the target in the array, or `-1` if the target is not found. # Constraints - The array is guaranteed to be sorted. - The optimal solution should consider both time and space efficiency. # Example ```python def optimized_jump_search(arr, target): import math length = len(arr) block_size = int(math.sqrt(length)) block_prev = 0 block= block_size if length == 0: return -1 if arr[length - 1] < target: return -1 while block <= length and arr[block - 1] < target: block_prev = block block += block_size while block_prev < min(block, length) and arr[block_prev] < target: block_prev += 1 if block_prev == min(block, length): return -1 if block_prev < length and arr[block_prev] == target: return block_prev return -1 # Test Cases print(optimized_jump_search([1, 3, 5, 7, 9], 7)) # Output: 3 print(optimized_jump_search([1, 3, 5, 7, 9], 2)) # Output: -1 print(optimized_jump_search([], 2)) # Output: -1 print(optimized_jump_search([1], 1)) # Output: 0 print(optimized_jump_search([1, 2, 3, 4, 5], 6)) # Output: -1 ``` You can use the provided code template to build your function. Ensure that it handles all edge cases and performs efficiently on large input sizes.","solution":"import math def optimized_jump_search(arr, target): Function to perform jump search on a sorted array. :param arr: List of sorted integers :param target: Integer value to search for :return: Index of the target in the array if found, otherwise -1 length = len(arr) if length == 0: return -1 block_size = int(math.sqrt(length)) current = 0 while current < length and arr[min(current + block_size, length) - 1] < target: current += block_size for i in range(current, min(current + block_size, length)): if arr[i] == target: return i return -1"},{"question":"You are tasked with implementing an alternative algorithm for the Set Cover problem. Given a universe of elements and a collection of subsets, each with an associated cost, your goal is to find a minimum cost subcollection of these subsets that covers all elements of the universe. # Requirements Implement a function named `dynamic_set_cover` that uses a dynamic programming approach to find the minimum cost subcollection of subsets that covers the universe. The function should have the following signature: ```python def dynamic_set_cover(universe: set, subsets: dict, costs: dict) -> list: Args: universe (set): A set representing the universe of elements. subsets (dict): A dictionary where keys are subset names and values are sets of elements. costs (dict): A dictionary where keys are subset names and values are their associated costs. Returns: list: A list of selected subset names that provide the minimum cost cover of the universe. ``` # Input - `universe`: A set of integers representing the universe. - `subsets`: A dictionary where keys are strings (subset names) and values are sets of integers (elements in the subset). - `costs`: A dictionary where keys are strings (subset names from `subsets`), and values are positive integers (costs associated with each subset). # Output - A list of strings representing the names of the subsets chosen to cover the universe at minimum cost. # Constraints - The input universe is non-empty. - Each subset in `subsets` is non-empty and contains elements from the `universe`. - The costs of subsets are positive integers. # Performance Requirements - Your algorithm should improve upon the time complexity of the brute-force optimal implementation. - Try to achieve the solution with polynomial time complexity where possible. # Edge Cases to Consider - Ensure your implementation handles cases where no set cover is possible by returning an empty list. - Subsets may overlap; ensure the cost-effectiveness is preserved. - The cost array will not contain zero or negative values. # Example ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {1, 2}, \'S2\': {2, 3, 4}, \'S3\': {4, 5}} costs = {\'S1\': 2, \'S2\': 4, \'S3\': 3} assert dynamic_set_cover(universe, subsets, costs) == [\'S1\', \'S2\', \'S3\'] # Example output ``` # Scenario You are an engineer working on a logistics optimization problem. Your goal is to select the most cost-effective routes (subsets) that cover all delivery points (universe). Each route has an associated cost depending on various factors like distance, fuel, and tolls. Your task is to ensure that by combining these routes, you cover all delivery points while minimizing the cost.","solution":"def dynamic_set_cover(universe: set, subsets: dict, costs: dict) -> list: Args: universe (set): A set representing the universe of elements. subsets (dict): A dictionary where keys are subset names and values are sets of elements. costs (dict): A dictionary where keys are subset names and values are their associated costs. Returns: list: A list of selected subset names that provide the minimum cost cover of the universe. # Convert universe elements to bitmasks to use in dynamic programming element_to_index = {elem: i for i, elem in enumerate(universe)} # Total subsets and universe size num_subsets = len(subsets) universe_size = len(universe) # Create a dp table to store minimum costs and sets leading to them dp = {0: (0, [])} # dp[state] = (minimum_cost, sets_used_to_get_to_state) # Initialize all other states with infinite cost for state in range(1, 1 << universe_size): dp[state] = (float(\'inf\'), []) # Iterate over each subset for subset_name, subset_elements in subsets.items(): subset_mask = sum(1 << element_to_index[elem] for elem in subset_elements) cost = costs[subset_name] for state in list(dp.keys()): new_state = state | subset_mask new_cost = dp[state][0] + cost if new_cost < dp[new_state][0]: dp[new_state] = (new_cost, dp[state][1] + [subset_name]) # The state 2^universe_size - 1 corresponds to the state covering all elements final_state = (1 << universe_size) - 1 min_cost, result_sets = dp[final_state] if min_cost == float(\'inf\'): return [] # No solution found return result_sets"},{"question":"# Question: Reverse a Custom Linked List You are provided with a linked list implementation and you are required to implement a function to reverse this linked list. Function Signature: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list_custom(head: ListNode) -> ListNode: pass ``` Input: The function will receive the head node of a singly linked list (`head`). A singly linked list node is defined using the class `ListNode`. Each node has an integer value `val` and a pointer to the next node. ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Output: The function should return the head node of the reversed linked list. Constraints: - The number of nodes in the linked list is in the range `[0, 10^4]`. - The value of nodes is `-10^5 <= Node.val <= 10^5`. Example: ```python # Example 1: # Input: 1 -> 2 -> 3 -> 4 -> 5 -> NULL # Output: 5 -> 4 -> 3 -> 2 -> 1 -> NULL head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) reversed_head = reverse_list_custom(head) # Print the reversed list to verify # Example 2: # Input: None # Output: None head = None reversed_head = reverse_list_custom(head) # Print the reversed list to verify ``` **Note**: The function should modify the linked list in place and should not create new nodes. You are expected to test the code with various edge cases to ensure robustness.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list_custom(head: ListNode) -> ListNode: Reverses a singly linked list. Args: head (ListNode): The head of the singly linked list. Returns: ListNode: The new head of the reversed singly linked list. prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"Context In cryptographic applications such as RSA, large numbers are often raised to large powers. Because direct computation can be infeasible due to the size of the numbers, efficient algorithms like binary exponentiation are used. Your task is to implement and test the binary exponentiation using both iterative and recursive approaches to verify your understanding. Task You are required to implement two functions `iterative_power` and `recursive_power` that each compute (a^n mod text{mod}). The computation should be efficient and should handle very large numbers effectively. Function descriptions 1. **`iterative_power(a: int, n: int, mod: int) -> int`** - Takes three parameters: - `a` (base integer) - `n` (exponent integer) - `mod` (the modulus under which the power is calculated) - Returns the result of (a^n mod text{mod}). 2. **`recursive_power(a: int, n: int, mod: int) -> int`** - Takes three parameters: - `a` (base integer) - `n` (exponent integer) - `mod` (the modulus under which the power is calculated) - Returns the result of (a^n mod text{mod}). Input - Three integers: (a) (0 ≤ (a) ≤ (10^9)), (n) (0 ≤ (n) ≤ (10^9)), and (mod) (1 ≤ (mod) ≤ (10^9)). Output - An integer representing the result of (a^n mod text{mod}). Constraints - Ensure both functions handle input constraints efficiently. - The functions must be capable of computing large powers within a reasonable time frame. Examples 1. **Input**: `iterative_power(2, 10, 1000)` - **Output**: `24` 2. **Input**: `recursive_power(3, 7, 13)` - **Output**: `3` 3. **Input**: `iterative_power(10, 100, 7)` - **Output**: `4` 4. **Input**: `recursive_power(5, 0, 17)` - **Output**: `1` Additional Notes - Ensure your code is optimized for handling very large numbers and avoids overflow by using modulus operations efficiently. - Input validation is not required; you can assume the inputs are within the specified constraints.","solution":"def iterative_power(a, n, mod): Computes a^n % mod using an iterative approach. result = 1 a = a % mod while n > 0: if n % 2 == 1: result = (result * a) % mod n = n >> 1 a = (a * a) % mod return result def recursive_power(a, n, mod): Computes a^n % mod using a recursive approach. if n == 0: return 1 half = recursive_power(a, n // 2, mod) half = (half * half) % mod if n % 2 != 0: half = (half * a) % mod return half"},{"question":"# Scenario You are working as a software engineer for a company that deals with advanced cryptographic systems and you need to solve a system of simultaneous congruences using the Chinese Remainder Theorem (CRT). The current brute-force method in the existing codebase needs to be optimized for better performance. Your task is to implement a more efficient solution. # Task Implement a function `solve_chinese_remainder(nums: List[int], rems: List[int]) -> int` that computes the smallest integer `x` that satisfies the Chinese Remainder Theorem for a given system of congruences: [ x equiv rems[i] (text{mod} nums[i]) ] for all `i` from 0 to `k-1`. Ensure that the `nums` list contains pairwise coprime integers. Input Format - `nums`: A list of `k` positive integers ((1 < text{nums}[i] leq 10^9)) representing the moduli. - `rems`: A list of `k` integers representing the remainders. Output Format - Return the smallest positive integer `x` that satisfies all the given congruences. Constraints - `nums` and `rems` have the same length `k` where (1 leq k leq 20). - All numbers in `nums` are pairwise coprime. Performance Requirements - The implementation should avoid the brute-force approach and be optimized for better runtime performance. Example # Input: ```python nums = [3, 5, 7] rems = [2, 3, 2] ``` # Output: ```python 23 ``` # Explanation: 23 is the smallest number that satisfies: [ 23 equiv 2 (text{mod} 3) ] [ 23 equiv 3 (text{mod} 5) ] [ 23 equiv 2 (text{mod} 7) ]","solution":"from typing import List def solve_chinese_remainder(nums: List[int], rems: List[int]) -> int: Solves the system of simultaneous congruences using the Chinese Remainder Theorem. Parameters: nums : List[int] : List of pairwise coprime integers (moduli) rems : List[int] : List of remainders Returns: int : The smallest positive integer x that satisfies all the given congruences. # Helper function: Extended Euclidean Algorithm to find the modular inverse def extended_gcd(a, b): if b == 0: return a, 1, 0 g, x1, y1 = extended_gcd(b, a % b) x = y1 y = x1 - (a // b) * y1 return g, x, y # Product of all nums product = 1 for num in nums: product *= num # Applying the Chinese Remainder Theorem result = 0 for num, rem in zip(nums, rems): p = product // num g, x, y = extended_gcd(p, num) # Adding the current term to the result result += rem * x * p return result % product"},{"question":"Scenario You are tasked to create a critical component for a financial analytics application designed to process large datasets of numerical information. One of the functionalities involves categorizing numbers based on their digit count. To ensure efficient processing, you need to implement a function that can quickly determine the digit count of any given integer. Problem Statement Write a Python function called `num_digits(n)` that calculates and returns the number of digits in a given integer `n`. Input - An integer `n` (can be positive, negative or zero). Output - An integer representing the number of digits in `n`. Constraints - The function should run in constant time, O(1). - Consider edge cases where `n` is zero or negative. Example 1. Input: `num_digits(12345)` Output: `5` 2. Input: `num_digits(-987)` Output: `3` 3. Input: `num_digits(0)` Output: `1` Additional Information - You can use Python\'s `math` module for log computations. - Avoid using string conversion methods to solve this problem. Implementation Your task is to complete the following function: ```python import math def num_digits(n): # Write your code here pass # Test cases print(num_digits(12345)) # Expected output: 5 print(num_digits(-987)) # Expected output: 3 print(num_digits(0)) # Expected output: 1 ``` Please include considerations for edge conditions and correctness in your implementation.","solution":"import math def num_digits(n): Returns the number of digits in the given integer n. if n == 0: return 1 n = abs(n) return math.floor(math.log10(n)) + 1"},{"question":"You are given a binary search tree (BST) where each node contains a unique integer value. Your task is to implement a class `BSTIterator` that allows controlled, in-order traversal of the BST using an iterative approach. The class should support the following methods: - `__init__(self, root: TreeNode)` - Initializes the iterator with the root node of the BST. - `has_next(self) -> bool` - Returns `True` if the BST has more elements for in-order traversal, `False` otherwise. - `next(self) -> int` - Returns the next element in the in-order traversal. **Input Format:** - You will be given the root node of a binary search tree. Each node will have the attributes: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` **Output Format:** - The `next` method should return an integer which is the next element in the in-order traversal of the BST. **Constraints:** - The total number of nodes in the BST will be in the range [1, 1000]. - Each node\'s value is a unique integer. - You are allowed to maintain the stack\'s height to be equal to the height of the tree. # Example ```python # Example BST: # 7 # / # 3 15 # / # 9 20 # Example Usage: # bst = TreeNode(7) # bst.left = TreeNode(3) # bst.right = TreeNode(15) # bst.right.left = TreeNode(9) # bst.right.right = TreeNode(20) # iterator = BSTIterator(bst) # iterator.next() # returns 3 # iterator.has_next() # returns True # iterator.next() # returns 7 # iterator.has_next() # returns True # iterator.next() # returns 9 # iterator.has_next() # returns True # iterator.next() # returns 15 # iterator.has_next() # returns True # iterator.next() # returns 20 # iterator.has_next() # returns False ``` # Notes: - Ensure that `next` and `has_next` operations are efficient and do not re-traverse nodes unnecessarily. - Handle the edge cases efficiently, including an empty tree and various configurations of the tree nodes.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class BSTIterator: def __init__(self, root: TreeNode): Initializes the iterator with the root node of the BST. self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): Helper function to add all elements up to the leftmost leaf (inclusive) to the stack. while root: self.stack.append(root) root = root.left def has_next(self) -> bool: Returns True if the BST has more elements for in-order traversal, False otherwise. return len(self.stack) > 0 def next(self) -> int: Returns the next element in the in-order traversal. # Pop the top of the stack (the current smallest element) topmost_node = self.stack.pop() # If the node has a right child, we push all the nodes from its right sub-tree # This is the next smallest element in the in-order traversal. if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val"},{"question":"You are given a list of integers where every element appears exactly twice, except for one element which appears exactly once. Your task is to find that single element which appears exactly once. Write a function: ```python def find_single_element(nums: List[int]) -> int: Returns the single element that appears once in the list. :param nums: A list of integers where every element appears twice except for one. :return: The single integer that appears once. ``` # Example ```python assert find_single_element([2, 2, 1]) == 1 assert find_single_element([4, 1, 2, 1, 2]) == 4 assert find_single_element([1]) == 1 ``` # Constraints * You must solve this problem with a linear runtime complexity, O(n). * You must not use any extra memory beyond a constant amount, O(1). * The list will contain at least one element. # Input Format * A list of integers, `nums`, where (1 leq len(nums) leq 3 * 10^4). # Output Format * Return the single integer that appears once in the list. If all elements appear twice, return 0. # Considerations * Make sure to handle the edge case of an empty array—although the constraints state at least one element, consider error-handling to prepare for practical coding scenarios. * Consider the performance optimization necessary due to the constraint on linear time complexity and constant space.","solution":"from typing import List def find_single_element(nums: List[int]) -> int: Returns the single element that appears once in the list. :param nums: A list of integers where every element appears twice except for one. :return: The single integer that appears once. single_element = 0 for num in nums: single_element ^= num return single_element"},{"question":"# Invert a Binary Tree **Scenario**: You are tasked by a project to write a function that can invert a binary tree. This operation will help in visualizing symmetric tree structures easily which is particularly useful in developing certain types of graphical interfaces and algorithms. **Objective**: Write a function `invertBinaryTree` that takes the root node of a binary tree and inverts it in place. **Function Signature**: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invertBinaryTree(root: TreeNode) -> None: # your code here ``` **Input**: * `root`: TreeNode - The root node of a binary tree where TreeNode is defined as above. The tree can be empty (i.e., root can be None). **Output**: * The function should return None. The binary tree should be modified in-place to be its inverted version. **Example**: ```python # Binary Tree before inversion # 4 # / # 2 7 # / / # 1 3 6 9 # Expected Binary Tree after inversion: # 4 # / # 7 2 # / / # 9 6 3 1 root = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(7, TreeNode(6), TreeNode(9))) invertBinaryTree(root) # Now root should be: # 4 # / # 7 2 # / / # 9 6 3 1 ``` **Constraints**: * The number of nodes in the tree is in the range [0, 1000]. * Each node will have a unique value. **Notes**: * Ensure proper handling of edge cases e.g., when the tree is empty. * Consider the time and space complexity in your implementation to avoid stack overflow for deep trees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invertBinaryTree(root: TreeNode) -> None: if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the left and right subtrees invertBinaryTree(root.left) invertBinaryTree(root.right)"},{"question":"# Context You have been hired to develop navigation algorithms for a modern city\'s public transport system. To accomplish this, you need to write functions that can efficiently find routes between stops on the network. # Task Implement three functions `find_path`, `find_all_paths`, and `find_shortest_path` to solve pathfinding problems in a directed graph representing the city\'s transport network. Each function should conform to the characteristics described. # Input The input will be provided in the following format: * `graph`: A dictionary representing an adjacency list of the graph where keys are node identifiers and values are lists of neighboring node identifiers. * `start`: An identifier of the start node. * `end`: An identifier of the end node. * `path`: A list to store the current traversal path (initially an empty list). # Output Each function should return: * `find_path`: A list representing a valid path from start to end node or None if no path is found. * `find_all_paths`: A list of lists, where each list is a valid path from start to end node or an empty list if no paths are found. * `find_shortest_path`: A list representing the shortest path from start to end node or None if no path is found. # Constraints * 1 <= Number of nodes <= 1000. * Nodes are represented by integers or strings. * You must not modify the given graph. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [\'C\'], \'E\': [\'F\'], \'F\': [\'C\'] } # Example calls print(find_path(graph, \'A\', \'D\')) # [\'A\', \'B\', \'D\'] print(find_all_paths(graph, \'A\', \'D\')) # [[\'A\', \'B\', \'D\'], [\'A\', \'B\', \'C\', \'D\'], [\'A\', \'C\', \'D\']] print(find_shortest_path(graph, \'A\', \'D\')) # [\'A\', \'B\', \'D\'] ``` # Hints 1. Use backtracking and recursion to build paths incrementally. 2. To optimize `find_shortest_path`, consider tracking visited nodes to avoid redundant work.","solution":"def find_path(graph, start, end, path=[]): path = path + [start] if start == end: return path if start not in graph: return None for node in graph[start]: if node not in path: new_path = find_path(graph, node, end, path) if new_path: return new_path return None def find_all_paths(graph, start, end, path=[]): path = path + [start] if start == end: return [path] if start not in graph: return [] paths = [] for node in graph[start]: if node not in path: new_paths = find_all_paths(graph, node, end, path) for new_path in new_paths: paths.append(new_path) return paths def find_shortest_path(graph, start, end, path=[]): path = path + [start] if start == end: return path if start not in graph: return None shortest = None for node in graph[start]: if node not in path: new_path = find_shortest_path(graph, node, end, path) if new_path: if not shortest or len(new_path) < len(shortest): shortest = new_path return shortest"},{"question":"# Matrix Transformation Challenge You are given a matrix (2D list). Implement a function to rotate the given matrix 90 degrees clockwise. Your function should handle edge cases such as empty matrices and matrices with inconsistent row lengths gracefully. Function Signature ```python def rotate_matrix_clockwise(matrix: List[List[int]]) -> List[List[int]]: pass ``` Input * **matrix**: A 2D list of integers representing the matrix, where `1 <= len(matrix) <= 100` and each row may have different lengths but not exceeding 100. Output * You should return a new 2D list that is the result of rotating the given matrix 90 degrees clockwise. Constraints 1. The input matrix can contain negative and positive integers. 2. Minimize space complexity by reusing memory as much as possible without modifying the input matrix. Examples ```python # Example 1 input_matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] output_matrix = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] # Example 2 input_matrix = [ [1, 2], [3, 4], [5, 6] ] output_matrix = [ [5, 3, 1], [6, 4, 2] ] # Example 3 input_matrix = [] output_matrix = [] ``` Implement the function `rotate_matrix_clockwise` to pass the above examples and any additional edge cases you can think of.","solution":"from typing import List def rotate_matrix_clockwise(matrix: List[List[int]]) -> List[List[int]]: if not matrix: return [] n = len(matrix) m = max(len(row) for row in matrix) # Initialize the rotated matrix with None values rotated_matrix = [[None for _ in range(n)] for _ in range(m)] for row_idx in range(n): for col_idx in range(len(matrix[row_idx])): rotated_matrix[col_idx][n - row_idx - 1] = matrix[row_idx][col_idx] # Remove trailing None values in each row for row in rotated_matrix: while row and row[-1] is None: row.pop() return rotated_matrix"},{"question":"# Problem Description You are building a text editor that includes a feature to check if a given string is a palindrome. For this, you need to implement a function `is_palindrome_sentence` to accurately determine if a sentence is a palindrome. For the purpose of this problem, a valid palindrome sentence is defined based on alphanumeric characters only and ignoring cases. # Function Signature ```python def is_palindrome_sentence(s: str) -> bool: pass ``` # Input - A single string `s` (0 <= length of s <= 10^5) # Output - Returns a boolean `True` if `s` is a palindrome, and `False` otherwise. # Constraints - Only alphanumeric characters should be considered. - Case should be ignored. # Examples ```python print(is_palindrome_sentence(\\"A man, a plan, a canal: Panama\\")) # Output: True print(is_palindrome_sentence(\\"race a car\\")) # Output: False print(is_palindrome_sentence(\\"\\")) # Output: True print(is_palindrome_sentence(\\"No lemon, no melon\\")) # Output: True ``` # Requirements - Your solution should not use extra space significantly more than O(1). - Optimize for the best possible time complexity. - Consider performance and edge cases. # Additional Notes - Think about the performance implications when the input string is very long. - Handle edge cases such as strings filled with punctuation or mixed punctuation and alphanumeric characters. - Ensure your function is robust against different input formats.","solution":"def is_palindrome_sentence(s: str) -> bool: Determine if a sentence is a palindrome, considering only alphanumeric characters and ignoring cases. Parameters: s (str): The input string. Returns: bool: True if the input string is a palindrome, False otherwise. filtered_chars = [char.lower() for char in s if char.isalnum()] return filtered_chars == filtered_chars[::-1]"},{"question":"# Question: Binary Tree Serialization and Deserialization You are required to implement two functions, `serialize` and `deserialize`, for a binary tree. These functions will help in converting a binary tree to a string representation and vice versa. This task tests your understanding of tree traversals, recursion, and string manipulation. Function Definitions 1. **serialize**: This function takes in a binary tree root and returns a serialized string. ```python def serialize(root: TreeNode) -> str: # Your code here ``` 2. **deserialize**: This function takes in a serialized string and returns the root of the binary tree. ```python def deserialize(data: str) -> TreeNode: # Your code here ``` Constraints - Use pre-order traversal for serialization. - Use `#` as a marker for null nodes in serialization. - Nodes’ values are integers (positive, negative, or zero). - Your functions should handle trees with up to 10^4 nodes efficiently. - The input string for `deserialize` is always valid per the serialization format. Examples ```python # Example 1: root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) serialized = serialize(root) # Expected: \\"1 2 # # 3 4 # # 5 # #\\" tree = deserialize(serialized) # Expected: TreeNode structure similar to \'root\' # Example 2: root = None serialized = serialize(root) # Expected: \\"#\\" tree = deserialize(serialized) # Expected: None (empty tree) ``` Notes - Focus on ensuring that the tree structure is accurately captured and reconstructed. - Pay attention to edge cases such as empty trees and highly unbalanced trees. - Ensure your code is optimized for performance, considering the size limit constraint.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Encodes a tree to a single string. def helper(node): if not node: return \\"#\\" left_serialized = helper(node.left) right_serialized = helper(node.right) return f\\"{node.val} {left_serialized} {right_serialized}\\" return helper(root) def deserialize(data): Decodes your encoded data to tree. def helper(data_list): if data_list[0] == \\"#\\": data_list.pop(0) return None root = TreeNode(int(data_list.pop(0))) root.left = helper(data_list) root.right = helper(data_list) return root data_list = data.split() return helper(data_list)"},{"question":"You are given an **undirected** graph described by (V) vertices and (E) edges. Each edge has a weight associated with it. Implement a function to find the sum of weights of the minimum spanning tree (MST) using Kruskal\'s algorithm. Use a Disjoint Set data structure to efficiently manage the merging of sets. # Function Signature ```python def find_mst_sum(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: pass ``` # Input * `vertex_count` (int): Number of vertices in the graph. * `edges` (List[Tuple[int, int, int]]): A list of edges where each edge is represented as a tuple (source, target, weight). Vertices are 1-indexed. # Output * Returns the integer sum of the weights of the MST. # Constraints * (1 leq vertex_count leq 1000) * (0 leq edge_count leq 5000) * (1 leq weight leq 10^6) # Example Input ```python vertex_count = 5 edges = [ (1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6) ] ``` Output ```python 14 ``` # Implementation Implement the function as described, ensuring that it handles the sorting of edges and the management of sets efficiently. Consider any special cases where the graph might be sparse or contain multiple edges with the same weight.","solution":"from typing import List, Tuple class DisjointSet: def __init__(self, vertex_count): self.parent = list(range(vertex_count)) self.rank = [0] * vertex_count def find(self, vertex): if self.parent[vertex] != vertex: self.parent[vertex] = self.find(self.parent[vertex]) return self.parent[vertex] def union(self, vertex1, vertex2): root1 = self.find(vertex1) root2 = self.find(vertex2) if root1 != root2: if self.rank[root1] > self.rank[root2]: self.parent[root2] = root1 elif self.rank[root1] < self.rank[root2]: self.parent[root1] = root2 else: self.parent[root2] = root1 self.rank[root1] += 1 def find_mst_sum(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: edges.sort(key=lambda edge: edge[2]) disjoint_set = DisjointSet(vertex_count + 1) mst_weight_sum = 0 mst_edges_count = 0 for u, v, weight in edges: if disjoint_set.find(u) != disjoint_set.find(v): disjoint_set.union(u, v) mst_weight_sum += weight mst_edges_count += 1 if mst_edges_count == vertex_count - 1: break return mst_weight_sum"},{"question":"# Question You are given an integer array `arr` and an integer `k`. Your task is to implement a function `max_sliding_window` that returns an array of the maximum values of each sub-array of size `k`. # Function Signature ```python def max_sliding_window(arr: List[int], k: int) -> List[int]: ``` # Input - `arr`: List[int] - An array of integers. - `k`: int - The length of each sub-array (window size). # Output - List[int] - An array containing the maximum value from each sliding window of size k. # Constraints 1. 1 ≤ len(arr) ≤ 10^5 2. -10^4 ≤ arr[i] ≤ 10^4 3. 1 ≤ k ≤ len(arr) # Example ```python assert max_sliding_window([1,3,-1,-3,5,3,6,7], 3) == [3,3,5,5,6,7] assert max_sliding_window([1,3,1,2,0,5], 3) == [3,3,2,5] ``` # Scenario You are developing a performance monitoring tool that analyzes the peak performance over a sliding window of time. Given a stream of performance metrics (in the form of integer values) and a window size, your task is to compute the peak performance values over these windows efficiently. # Notes - Ensure that the solution is efficient and scalable to handle the upper limits of the input constraints. - Consider edge cases such as `k` equal to the length of the array and when the function is provided with the smallest constraints.","solution":"from typing import List from collections import deque def max_sliding_window(arr: List[int], k: int) -> List[int]: Returns a list of the maximum values of each sub-array of size k. # Deque to store indices of array elements deq = deque() result = [] for i in range(len(arr)): # Remove elements not within the sliding window while deq and deq[0] < i - k + 1: deq.popleft() # Remove elements that are smaller than the current element # since they are not going to be the maximum in this window while deq and arr[deq[-1]] < arr[i]: deq.pop() # Add the current element index to the deque deq.append(i) # The maximum element of the window is the first element of the deque if i >= k - 1: result.append(arr[deq[0]]) return result"},{"question":"<|Analysis Begin|> # Algorithm Analysis Core Identification * **Algorithm/Data Structure**: Egg Dropping Puzzle, an optimization problem that uses Dynamic Programming. * **Complexity**: * Time Complexity: ( O(n^2 cdot k) ) where ( n ) is the number of floors and ( k ) is the number of eggs. * Space Complexity: ( O(n cdot k) ) due to the 2D array used for storing intermediate results. * **Principles**: The problem is approached by breaking it down into simpler subproblems and solving these subproblems to build up a solution to the original problem. The operations involve filling up a table `egg_floor` where the entry at `[i][j]` represents the minimum number of trials required for `i` eggs and `j` floors. Characteristics & Applications * **Properties**: * State Space: The problem\'s state is defined by the number of eggs and floors. * The solution involves minimizing the worst-case number of trials. * Uses dynamic programming to store and reuse intermediate results. * **Common Use Cases**: * Determining the critical breaking point of an object. * Understanding failure points in stress testing environments. * **Strengths/Limitations**: * **Strengths**: Efficient solution through intermediate result storage. * **Limitations**: Memory usage can be extensive for a large number of floors and eggs. Implementation Challenges * **Edge Cases**: * When there are zero floors or eggs. * Handling minimal possible scenarios such as 1 floor or 1 egg. * **Performance Bottlenecks**: * Nested loops particularly the `x` loop which leads to quadratic time complexity. * **Error Scenarios**: * Incorrectly initialized table entries. * Ignoring base cases of 1 floor & 1 egg which have straightforward solutions. * **Optimization Points**: * Reduce redundant calculations by efficient table-filling strategies. * Use mathematical insights (binary search-like) to reduce trial floors selection. <|Analysis End|> <|Question Begin|> # Problem Statement: Egg Dropping Puzzle Enhanced You are tasked with designing an optimal strategy to determine the highest floor from which an egg can be dropped without breaking, given a fixed number of floors ( N ) and a set number of identical eggs ( K ). The goal is to minimize the number of egg drops required to guarantee finding this critical floor in the worst-case scenario. # Function Signature: ```python def min_egg_drops(K: int, N: int) -> int: ``` # Input: * `K (1 <= K <= 1000)`: An integer representing the number of eggs. * `N (1 <= N <= 1000)`: An integer representing the number of floors. # Output: * Returns an integer representing the minimum number of egg drops required in the worst-case scenario to determine the critical floor. # Example: ```python assert min_egg_drops(1, 2) == 2 assert min_egg_drops(2, 6) == 3 assert min_egg_drops(3, 14) == 4 ``` # Explanation: * For `K = 1`, `N = 2`: Drop from floor 1, if it breaks we need zero more trials, if it doesn\'t we drop from floor 2, thus 2 drops. * For `K = 2`, `N = 6`: Optimal drops are used to minimize the worst-case scenario leading to the solution of 3 drops. * For `K = 3`, `N = 14`: More eggs allow for a more efficient reduction leading to 4 drops. # Constraints: * Solutions must be designed using dynamic programming. * Optimize for both time and space complexity to handle the upper constraint limits efficiently. # Hints: * Think in terms of filling up a DP table where entries represent the minimal number of trials required for given values of eggs and floors. * Base cases include scenarios with only one egg and scenarios with a minimal number of floors. Implement the `min_egg_drops` function based on the analysis and requirements provided.","solution":"def min_egg_drops(K, N): # Create a table to store results of subproblems dp = [[0 for x in range(N + 1)] for x in range(K + 1)] # Fill the table for one egg case with the base case results for j in range(1, N + 1): dp[1][j] = j # Fill the table for other cases for i in range(2, K + 1): for j in range(1, N + 1): dp[i][j] = float(\'inf\') for x in range(1, j + 1): res = 1 + max(dp[i - 1][x - 1], dp[i][j - x]) if res < dp[i][j]: dp[i][j] = res # The value in dp[K][N] contains the result return dp[K][N]"},{"question":"# Hamming Weight Calculation Scenario: You are working on optimizing a network error detection algorithm that frequently requires quick calculations of the number of \'1\' bits (Hamming weight) in 32-bit unsigned integers. To achieve this, you decide to leverage Brian Kernighan\'s Algorithm. Task: Write a function `hamming_weight` in Python that computes the number of \'1\' bits in a 32-bit unsigned integer using Brian Kernighan\'s Algorithm. Implement both iterative and recursive versions. Requirements: 1. **Function Signature**: ```python def hamming_weight(n: int) -> int: pass ``` 2. **Input**: * `n` (int): A 32-bit unsigned integer (0 <= n <= 2^32 - 1). 3. **Output**: * Returns an integer representing the number of \'1\' bits in the binary representation of `n`. 4. **Constraints**: * Your implementation should handle both very small and very large values efficiently. * Avoid stack overflow for the recursive function even for values with many \'1\' bits. 5. **Performance Requirements**: * The solution should have a time complexity of O(k), where k is the number of \'1\' bits in `n`. * The solution should have a space complexity of O(1) for the iterative approach. Examples: * Example 1: * Input: `n = 11` * Output: `3` * Explanation: Binary representation of 11 is `00000000000000000000000000001011`, which has three \'1\' bits. * Example 2: * Input: `n = 128` * Output: `1` * Explanation: Binary representation of 128 is `00000000000000000000000010000000`, which has one \'1\' bit. * Example 3: * Input: `n = 4294967295` * Output: `32` * Explanation: Binary representation of 4294967295 is `11111111111111111111111111111111`, which has thirty-two \'1\' bits. Additional Notes: Be sure to implement and verify both iterative and recursive versions of the function for completeness.","solution":"def hamming_weight(n: int) -> int: Calculates the number of \'1\' bits in the binary representation of a 32-bit unsigned integer using Brian Kernighan\'s Algorithm (iterative version). count = 0 while n: n &= n - 1 # Drop the lowest set bit count += 1 return count def hamming_weight_recursive(n: int) -> int: Recursive version to calculate the number of \'1\' bits in the binary representation of a 32-bit unsigned integer using Brian Kernighan\'s Algorithm. if n == 0: return 0 return 1 + hamming_weight_recursive(n & (n - 1))"},{"question":"# Custom Data Structure Implementation A company is looking to build a game where players can add, remove, and retrieve characters randomly from their collection. To support this functionality, you are tasked with designing a data structure that efficiently supports the following operations: - **insert_character(character)**: Adds the character to the collection if it is not already present. - **remove_character(character)**: Removes the character from the collection if it exists. - **get_random_character()**: Returns a random character from the current collection of characters. Each character should have an equal probability of being returned. Your task is to implement the `CharacterCollection` class with the specified methods. Ensure that each method operates in average O(1) time complexity. Expected Function Signatures ```python class CharacterCollection: def __init__(self): pass def insert_character(self, character: str) -> bool: pass def remove_character(self, character: str) -> bool: pass def get_random_character(self) -> str: pass ``` Input and Output 1. `insert_character(character: str) -> bool`: - Takes a string `character` as input. - Returns `True` if the character was successfully added. - Returns `False` if the character was already present. 2. `remove_character(character: str) -> bool`: - Takes a string `character` as input. - Returns `True` if the character was successfully removed. - Returns `False` if the character was not in the collection. 3. `get_random_character() -> str`: - Returns a random character from the current collection. - If the collection is empty, an error or exception should be handled gracefully. Constraints - The characters are strings and can contain any valid unicode characters. - The operations should handle both ASCII and Unicode characters. Example ```python # Example usage: cc = CharacterCollection() print(cc.insert_character(\\"Knight\\")) # True print(cc.insert_character(\\"Mage\\")) # True print(cc.insert_character(\\"Knight\\")) # False print(cc.remove_character(\\"Knight\\")) # True print(cc.remove_character(\\"Knight\\")) # False print(cc.get_random_character()) # \\"Mage\\" (since only \\"Mage\\" is left in the collection) ``` Implement the `CharacterCollection` class and ensure all methods meet the specified requirements.","solution":"import random class CharacterCollection: def __init__(self): self.char_list = [] self.char_set = set() def insert_character(self, character: str) -> bool: if character in self.char_set: return False self.char_list.append(character) self.char_set.add(character) return True def remove_character(self, character: str) -> bool: if character not in self.char_set: return False self.char_list.remove(character) self.char_set.remove(character) return True def get_random_character(self) -> str: if not self.char_list: raise ValueError(\\"Collection is empty\\") return random.choice(self.char_list)"},{"question":"# Question: Cycle Detection in a Directed Graph Background: You are working on a system that manages complex dependencies, and it is crucial to ensure that there are no cyclic dependencies to avoid deadlocks. You need to write a function to detect if any cycles exist in a given directed graph. Task: Implement the function `contains_cycle(graph)` that determines if the provided directed graph contains any cycles. Function Signature: ```python def contains_cycle(graph: Dict[str, List[str]]) -> bool: ``` Input: - `graph`: A dictionary where the keys are vertex identifiers (strings), and the values are lists of adjacent vertices (directed edges). Output: - Returns `True` if there is at least one cycle in the graph. - Returns `False` if there are no cycles in the graph. Constraints: 1. The graph will have at most 10^4 vertices. 2. Edges in the graph will remain within the bounds of the vertices provided. 3. Vertex identifiers will be unique strings. Example: ```python graph1 = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(contains_cycle(graph1)) # Output: True graph2 = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [] } print(contains_cycle(graph2)) # Output: False ``` Additional Notes: - Think carefully about how you manage the traversal states (WHITE, GRAY, BLACK) of each vertex to correctly identify cycles. - Be mindful of edge cases such as self-loops or disconnected graphs. - Optimize your solution to handle large graphs efficiently.","solution":"def contains_cycle(graph): def dfs(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): return True visiting.remove(node) visited.add(node) return False visiting = set() visited = set() for node in graph: if dfs(node): return True return False"},{"question":"# Question: Given an `n x n` integer matrix, implement functions to perform the following operations efficiently: 1. `rotate_clockwise(matrix)`: Rotate the matrix 90 degrees clockwise. 2. `rotate_counterclockwise(matrix)`: Rotate the matrix 90 degrees counterclockwise. 3. `top_left_invert(matrix)`: Invert the matrix from the top left as if transposing it. 4. `bottom_left_invert(matrix)`: Invert the matrix from the bottom left. Your task is to implement these functions and ensure they handle edge cases and performance bottlenecks effectively. **Function Definitions**: ```python def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: pass def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: pass def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: pass def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: pass ``` # Input: - matrix : List[List[int]] of size `n x n`, where `1 <= n <= 1000` # Output: - Each function should return a new `n x n` matrix after performing respective operations. # Constraints: - The input matrix will always be square. - The input matrix will contain integers. # Examples: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_clockwise(matrix) Output: [ [7, 4, 1], [8, 5, 2], [9, 3, 0] ] rotate_counterclockwise(matrix) Output: [ [3, 6, 9], [2, 5, 8], [1, 4, 7] ] top_left_invert(matrix) Output: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] bottom_left_invert(matrix) Output: [ [9, 6, 3], [8, 5, 2], [7, 4, 1] ] ``` Ensure your implementation considers the most efficient way to manipulate the matrices for each specified operation.","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): result[j][n - 1 - i] = matrix[i][j] return result def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): result[n - 1 - j][i] = matrix[i][j] return result def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): result[j][i] = matrix[i][j] return result def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): result[n - 1 - j][n - 1 - i] = matrix[i][j] return result"},{"question":"Given a binary tree, write a function `deepest_left_node` to find the deepest node that is the left child of its parent node. Implement this as a class method to make it suitable for object-oriented design. # Function Signature ```python class DeepestLeftNodeFinder: def __init__(self): pass def deepest_left_node(self, root: TreeNode) -> Optional[TreeNode]: # Your code here pass ``` # Input - `root` (TreeNode): The root of the binary tree. Each TreeNode consists of three attributes: - `val` (int): The value of the node. - `left` (TreeNode): The left child of the node. - `right` (TreeNode): The right child of the node. - Note: Binary tree may contain up to (10^4) nodes. # Output - (TreeNode|None): The deepest left child node, or `None` if there is no left child node. # Constraints - You may assume the binary tree does not contain duplicate values. # Example ```python # Initialize the binary tree as follows: root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.right = TreeNode(6) root.right.right.right = TreeNode(7) finder = DeepestLeftNodeFinder() deepest_node = finder.deepest_left_node(root) if deepest_node: print(deepest_node.val) # Output should be 4 else: print(\\"No left child node found\\") ``` # Notes - Ensure your solution accounts for optimal space utilization. - Handle edge cases gracefully, such as trees with no nodes, only one node, or no left children.","solution":"from typing import Optional class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right class DeepestLeftNodeFinder: def __init__(self): pass def deepest_left_node(self, root: Optional[TreeNode]) -> Optional[TreeNode]: if not root: return None queue = [(root, False, 0)] # (node, is_left, depth) deepest_left = None max_depth = -1 while queue: node, is_left, depth = queue.pop(0) if node: if is_left and (depth > max_depth): max_depth = depth deepest_left = node if node.left: queue.append((node.left, True, depth + 1)) if node.right: queue.append((node.right, False, depth + 1)) return deepest_left"},{"question":"# Linked List Deduplication Background: You are given a singly linked list where each element is a node containing a value and a reference to the next node in the list. Your task is to implement a function to remove all duplicate values from this linked list. You can use additional data structures if needed. Function Signature: ```python def remove_duplicates(head: Node) -> Node: pass ``` Input: - `head` (Node): The head of the singly linked list where each node contains: - `val` (int/str): The node\'s value. - `next` (Node): Reference to the next node in the list, or `None` if it is the last node. Output: - `Node`: The head of the modified linked list with all duplicates removed. Constraints: - You may assume that the linked list contains only non-negative integers or non-empty strings. - The linked list can have up to 10^4 nodes. Example: 1. For the linked list `A -> A -> B -> C -> D -> C -> F -> G`, the function should return `A -> B -> C -> D -> F -> G` after removing duplicates. 2. For the linked list `1 -> 2 -> 2 -> 3 -> 4 -> 4 -> 4 -> 5`, the function should return `1 -> 2 -> 3 -> 4 -> 5` after removing duplicates. Performance Requirements: - Aim for a solution with time complexity O(N). - If using extra memory, ensure space complexity is within acceptable limits (O(N)). Implement the `remove_duplicates` function considering both time efficiency and possible edge cases. Your solution will be tested against a variety of inputs to ensure correctness and performance.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head: Node) -> Node: if not head: return head seen = set() current = head prev = None while current: if current.val in seen: prev.next = current.next else: seen.add(current.val) prev = current current = current.next return head"},{"question":"Simulating Weather Patterns with Markov Chains Scenario You are developing a simplified weather simulation system for a game. The weather can be in one of three states: `Sunny`, `Cloudy`, or `Rainy`. The transition probabilities between these states are described using a Markov Chain. Question Write a function `simulate_weather(chain, initial_state, steps)` that simulates the weather over a given number of steps, starting from the provided initial state. The function should return a list of weather states after the simulation. Function Signature ```python def simulate_weather(chain: dict, initial_state: str, steps: int) -> list: ``` Inputs - `chain`: A dictionary representing the Markov Chain with states as keys and dictionaries of transition probabilities as values. - `initial_state`: A string representing the initial weather state. - `steps`: An integer representing the number of steps to simulate. Outputs - A list of strings representing the sequence of weather states for each step. Constraints - Each state will have defined transitions, and probabilities will sum to 1. - `steps` is a positive integer (1 ≤ steps ≤ 100). - `initial_state` will be a valid state in the `chain`. Example ```python weather_chain = { \'Sunny\': {\'Sunny\': 0.8, \'Cloudy\': 0.15, \'Rainy\': 0.05}, \'Cloudy\': {\'Sunny\': 0.2, \'Cloudy\': 0.6, \'Rainy\': 0.2}, \'Rainy\': {\'Sunny\': 0.1, \'Cloudy\': 0.4, \'Rainy\': 0.5} } initial_state = \'Sunny\' steps = 10 result = simulate_weather(weather_chain, initial_state, steps) # Sample output: [\'Sunny\', \'Sunny\', \'Cloudy\', \'Rainy\', \'Cloudy\', \'Sunny\', \'Sunny\', \'Cloudy\', \'Rainy\', \'Rainy\'] ``` Notes - Ensure correctness by validating the sum of probabilities for each state. - Handle possible errors gracefully and consider edge cases such as invalid states or improper probability distributions.","solution":"import random def simulate_weather(chain, initial_state, steps): Simulates the weather over a given number of steps using a Markov Chain. Parameters: chain (dict): A dictionary representing the Markov Chain. initial_state (str): The initial weather state. steps (int): Number of steps to simulate. Returns: list: A list of strings representing the weather states after each step. def pick_next_state(current_state, chain): states, probabilities = zip(*chain[current_state].items()) return random.choices(states, probabilities)[0] weather_states = [initial_state] current_state = initial_state for _ in range(steps - 1): next_state = pick_next_state(current_state, chain) weather_states.append(next_state) current_state = next_state return weather_states"},{"question":"# Question You are tasked with implementing a function that calculates the height of a binary search tree (BST). The height of a tree is defined as the number of levels it contains. For example, the height of a tree with a single node is 1, while the height of an empty tree is 0. # Detailed Requirements * **Function Signature**: `def height(root: Node) -> int` * **Input**: One parameter `root` of type `Node`, the root node of the binary search tree. * **Output**: An integer representing the height of the BST. * **Definition of `Node`**: ```python class Node: def __init__(self, key): self.left = None self.right = None self.val = key ``` * **Constraints**: * The tree can have at most 10^4 nodes. * Node values are unique integers. * **Performance Requirements**: The solution should aim for O(n) time complexity. # Scenario Imagine you are a developer for a database system that uses BST for indexing. To maintain efficient search operations, you need to regularly check the height of the tree to detect and handle imbalances. Implement the `height` function to facilitate this monitoring. # Example Consider the following BST structure: ``` 15 / 10 20 / / 8 12 18 25 ``` * The height of this tree is 3. # Implementation Guidelines 1. Begin by checking if the tree is empty. 2. Recursively calculate the height of the left and right subtrees. 3. Return the maximum height of both subtrees plus one to account for the root level.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def height(root: Node) -> int: Calculate the height of a binary search tree. :param root: The root node of the BST :return: The height of the BST if root is None: return 0 left_height = height(root.left) right_height = height(root.right) return max(left_height, right_height) + 1"},{"question":"# Remove Duplicates from a Linked List **Context**: You are tasked with cleansing data from a linked list by removing duplicate entries. This is a crucial step in ensuring the uniqueness of data elements for further processing. **Problem Statement**: Implement a function to remove duplicates from a linked list. **Function Signature**: ```python def remove_duplicates(head: Node) -> Node: ``` # Input: - `head` (Node): The head node of a singly linked list where each node contains an integer value. # Output: - Returns the head node of the linked list after removing duplicates. # Constraints: 1. Elements are within the range [-1000, 1000]. 2. The linked list can have at most 10,000 nodes. # Performance Requirements: - Ensure a solution without using extra space that adheres to time complexity constraints where possible. # Example: ```python class Node(): def __init__(self, val = None): self.val = val self.next = None def create_linked_list(elements): head = Node(elements[0]) current = head for element in elements[1:]: current.next = Node(element) current = current.next return head def linked_list_to_list(head): result = [] while head: result.append(head.val) head = head.next return result head = create_linked_list([1, 2, 3, 2, 1, 4]) head = remove_duplicates(head) print(linked_list_to_list(head)) # Output should be [1, 2, 3, 4] head = create_linked_list([4, 4, 4, 4]) head = remove_duplicates(head) print(linked_list_to_list(head)) # Output should be [4] head = create_linked_list([]) head = remove_duplicates(head) print(linked_list_to_list(head)) # Output should be [] head = create_linked_list([1]) head = remove_duplicates(head) print(linked_list_to_list(head)) # Output should be [1] ``` **Note**: Ensure to handle necessary edge cases and optimize for performance where possible. You may assume basic functionality of the Node class as provided.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates(head: Node) -> Node: Removes duplicates from an unsorted linked list. :param head: Node - the head of the linked list :return: Node - the head of the linked list after removing duplicates if not head: return head current = head seen = set() seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head def create_linked_list(elements): if not elements: return None head = Node(elements[0]) current = head for element in elements[1:]: current.next = Node(element) current = current.next return head def linked_list_to_list(head): result = [] while head: result.append(head.val) head = head.next return result"},{"question":"# Problem Title Refined Bucket Sort Implementation # Problem Statement You are tasked with refining and improving the `bucket_sort` function to optimize its performance. The current implementation uses insertion sort within the buckets, which can be inefficient if the distribution of elements is not uniform. Your task is to refactor the implementation to handle the following improvements: 1. Improve the distribution of elements into the buckets. 2. Replace the sorting algorithm used within the buckets with a more efficient sorting algorithm. 3. Handle edge cases effectively to avoid potential errors. # Input * An integer array `arr` where `0 <= arr[i] <= 10000`. * The length of the array `n`, where `1 <= n <= 10000`. # Output * A sorted list containing elements of `arr` in ascending order. # Performance Requirements * Your implementation should aim for an average-case time complexity of O(n log n). # Constraints * Avoid using the same sorting algorithm directly on the entire input array; instead, use it within buckets. * Handle cases where elements are very close to each other efficiently. # Function Signature ```python def bucket_sort(arr: List[int]) -> List[int]: pass ``` # Example Example 1: ```python Input: [29, 25, 30, 30, 35, 10, 25, 12] Output: [10, 12, 25, 25, 29, 30, 30, 35] ``` Example 2: ```python Input: [5, 1, 4, 3, 2] Output: [1, 2, 3, 4, 5] ``` # Notes * You may choose an appropriate sorting algorithm for sorting the buckets. * Consider edge cases such as arrays with all elements being the same or arrays with only one element.","solution":"from typing import List def bucket_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return arr min_value = min(arr) max_value = max(arr) # Number of buckets bucket_count = 10 # Array of buckets buckets = [[] for _ in range(bucket_count)] # Distribute elements into buckets for num in arr: index = (num - min_value) * (bucket_count - 1) // (max_value - min_value + 1) buckets[index].append(num) # Sort individual buckets using TimSort (Python\'s built-in sort is O(n log n)) sorted_arr = [] for bucket in buckets: sorted_arr.extend(sorted(bucket)) return sorted_arr"},{"question":"# Hash Table Enhancement Challenge You are required to implement an enhanced version of the `ResizableHashTable` class, incorporating a more sophisticated collision resolution mechanism and optimized resizing strategy. **Problem Description**: Implement an optimized resizing and collision handling in the `EnhancedHashTable` class, derived from the `ResizableHashTable` class. Your implementation should: 1. Use **quadratic probing** instead of linear probing for collision resolution. 2. Optimize the resizing process by ensuring that upon resizing, the new size is the next prime number greater than double the current size. # Expected Functions & Constraints: 1. **```put(key, value)```**: Adds a new key-value pair. New collision resolution and resizing strategies should be applied. 2. **```get(key)```**: Retrieves the value associated with the key. 3. **```del_(key)```**: Deletes the key-value pair associated with the key. 4. **```__resize()```**: This method should find the next prime number greater than double the current size for the new hash table size. - Each function should still maintain an average time complexity of O(1). - Space complexity should remain O(n), where n is the number of elements in the hash table. - Use a pre-defined `_is_prime(number)` helper function to determine if a number is prime and implement a helper function to find the next prime. # Input and Output: * Input: - `put(key: int, value: Any)`: Adds or updates key-value pair. - `get(key: int) -> Any`: Returns the value associated with the key or None if key is not found. - `del_(key: int)`: Deletes the key-value pair associated with the key. * Output: - Returns None for all the operations. # Performance Requirements: - Your hash table should dynamically resize with appropriate rehashing as it grows or shrinks. **Implementation Skeleton**: ```python class EnhancedHashTable(ResizableHashTable): def __init__(self): super().__init__() def put(self, key, value): # Override with quadratic probing and optimized resizing pass def __resize(self): # Override to resize to next prime number greater than double the current size pass def _rehash(self, old_hash, i): Quadratic probing return (old_hash + i**2) % self.size def _is_prime(self, number): Helper function to check if a number is prime pass def _next_prime(self, current_size): Helper function to find the next prime greater than current_size pass ``` # Notes: - Implement the methods ensuring compliance with given complexity requirements. - Ensure proper resizing, and efficient collision resolution.","solution":"class ResizableHashTable: # Please assume this class contains the base methods and structure for a resizable hash table pass class EnhancedHashTable(ResizableHashTable): def __init__(self): self.size = 7 self.table = [None] * self.size self.count = 0 def put(self, key, value): if self.count >= len(self.table) // 2: self.__resize() idx = self.__hash(key) i = 0 while self.table[idx] is not None and self.table[idx][0] != key: i += 1 idx = (self.__hash(key) + i**2) % self.size self.table[idx] = (key, value) self.count += 1 def get(self, key): idx = self.__hash(key) i = 0 while self.table[idx] is not None: if self.table[idx][0] == key: return self.table[idx][1] i += 1 idx = (self.__hash(key) + i**2) % self.size return None def del_(self, key): idx = self.__hash(key) i = 0 while self.table[idx] is not None: if self.table[idx][0] == key: self.table[idx] = None self.count -= 1 return i += 1 idx = (self.__hash(key) + i**2) % self.size def __resize(self): old_table = self.table new_size = self._next_prime(2 * self.size) self.size = new_size self.table = [None] * self.size self.count = 0 for item in old_table: if item is not None: self.put(item[0], item[1]) def __hash(self, key): return key % self.size def _is_prime(self, number): if number <= 1: return False if number <= 3: return True if number % 2 == 0 or number % 3 == 0: return False i = 5 while i * i <= number: if number % i == 0 or number % (i + 2) == 0: return False i += 6 return True def _next_prime(self, current_size): next_prime = current_size while True: next_prime += 1 if self._is_prime(next_prime): return next_prime"},{"question":"Context You are given a 2D grid initialized with the following possible values: - -1: Represents a wall or an obstacle. - 0: Represents a gate. - INF: (Infinity value) Represents an empty room. Use the value `2147483647` to represent infinity. Your task is to fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, leave the room with the value `INF`. Input - A 2D grid `rooms` of size `m x n`, where `m` is the number of rows and `n` is the number of columns. Output - The modified 2D grid where each empty room is filled with the shortest distance to a gate. Constraints - `m` and `n` are positive integers within the range `[1, 1000]`. - The grid will contain at least one gate. Example ```plaintext Input: [ [2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647] ] Output: [ [3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4] ] ``` Requirements 1. Implement the function `walls_and_gates(rooms)` that modifies the input grid in-place. 2. Ensure minimum time complexity of O(m * n). 3. Avoid redundant calculations and ensure optimal space usage. Performance Given the constraints, ensure that your solution efficiently handles large grids and maintains optimal performance.","solution":"def walls_and_gates(rooms): Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, leave the room with the value INF. if not rooms: return m, n = len(rooms), len(rooms[0]) queue = [] # Initialize the BFS queue with all gates (0s). for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) # Define the directions for moving in the grid: up, down, left, right. directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Perform BFS from each gate to discover the shortest distance to each gate. while queue: x, y = queue.pop(0) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and rooms[nx][ny] == 2147483647: rooms[nx][ny] = rooms[x][y] + 1 queue.append((nx, ny))"},{"question":"# Question Scenario You are given a dataset of student grades that need to be sorted to prepare for generating progress reports. However, the data arrives in relatively arbitrary order, and you need a sorting algorithm that performs well for such cases without using excessive memory. Task Implement a function `my_shell_sort(arr)` that performs Shell Sort on a given list of student grades provided as floating-point numbers between 0 and 100. Input * A list `arr` of `n` floating-point numbers (0 <= arr[i] <= 100, where 1 <= n <= 10^6). Output * A list with the elements of `arr` sorted in non-decreasing order. Constraints * No use of Python\'s built-in sorting functions. * Must handle up to 10^6 elements efficiently. Function Signature ```python def my_shell_sort(arr: List[float]) -> List[float]: ``` Example Input: [88.5, 57.2, 91.3, 85.0, 78.0, 57.2] Output: [57.2, 57.2, 78.0, 85.0, 88.5, 91.3] Notes * Consider how different initial gap sequences affect performance. * Handle cases with duplicate elements correctly.","solution":"from typing import List def my_shell_sort(arr: List[float]) -> List[float]: Shell Sort implementation to sort an array of floating-point numbers. n = len(arr) gap = n // 2 while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 return arr"},{"question":"# Merge Two Sorted Linked Lists Problem Statement: You are given the heads of two sorted linked lists, `l1` and `l2`. Your task is to merge these two lists into a single sorted linked list. The merged list should be created by splicing together the nodes of the two input lists. Finally, return the head of the merged linked list. # Input: * Two sorted linked lists\' heads `l1` and `l2` - Each linked list node has a single integer value and a next pointer. - The list may contain any integer values (both positive and negative). # Output: * A single linked list with all nodes from `l1` and `l2` in a sorted order. # Constraints: * The number of nodes in both linked lists is in the range `[0, 10^4]`. * `-10^5 <= Node.val <= 10^5` # Example: Example 1: ``` Input: l1 = 1 -> 2 -> 4, l2 = 1 -> 3 -> 4 Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 ``` Example 2: ``` Input: l1 = None, l2 = None Output: None ``` Example 3: ``` Input: l1 = None, l2 = 0 -> 2 Output: 0 -> 2 ``` # Requirements: Implement the following function: ```python class Node: def __init__(self, x): self.val = x self.next = None def merge_sorted_lists(l1: Node, l2: Node) -> Node: # Write your implementation here pass ``` - You need to ensure that your solution runs efficiently in terms of both time and space, matching the given complexities: - Time Complexity: O(n + m) - Space Complexity: O(1) for the iterative solution and O(n + m) for the recursive solution. # Notes: 1. Begin by defining the Node class. 2. Consider edge cases like one or both lists being empty. 3. Implement and return a new sorted merged linked list handling the provided constraints.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sorted_lists(l1: Node, l2: Node) -> Node: # Create a dummy node to act as the head of the merged list dummy = Node() current = dummy # Traverse both lists and merge them in a sorted manner while l1 and l2: if l1.val <= l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # Attach any remaining nodes if l1: current.next = l1 elif l2: current.next = l2 # The merged list is now pointed to by the dummy\'s next return dummy.next"},{"question":"# Binary Exponentiation Challenge Scenario You are a software developer tasked with developing a feature for a cryptographic application that involves frequent calculations of large exponentiations with moduli. To ensure efficiency, you plan to use binary exponentiation. Task Write a Python function `optimized_power(base: int, exponent: int, modulo: int = None) -> int` that computes `base` raised to the power `exponent`, optionally modulo `modulo`, using binary exponentiation. The function should handle edge cases and be efficient both in terms of time and space complexity. Function Signature ```python def optimized_power(base: int, exponent: int, modulo: int = None) -> int: # Your implementation here pass ``` Input * `base` (int): The base number which must be computed, -10^9 <= base <= 10^9. * `exponent` (int): The exponent to raise the base to, 0 <= exponent <= 10^9. * `modulo` (int, optional): The number by which to take the modulus. If None, no modulo is applied. Output * (int): The result of computing `base` raised to the power `exponent`, optionally modulo `modulo`. Constraints * Your solution should run efficiently in O(log n) time complexity. * Avoid unnecessary large intermediate values which might cause overflows. Examples ```python print(optimized_power(2, 10)) # Output: 1024 print(optimized_power(2, 10, 1000)) # Output: 24 print(optimized_power(2, 0)) # Output: 1 print(optimized_power(0, 0)) # Output: 1 (handle this edge case as 1) print(optimized_power(2, 1000000000, 1000000007)) # Should complete efficiently ```","solution":"def optimized_power(base: int, exponent: int, modulo: int = None) -> int: Computes base raised to the power exponent, optionally modulo modulo, using binary exponentiation. if exponent == 0: # Any number raised to the power 0 is 1 return 1 result = 1 current_base = base if modulo is None else base % modulo while exponent > 0: if exponent % 2 == 1: result = (result * current_base) if modulo is None else (result * current_base) % modulo current_base = (current_base * current_base) if modulo is None else (current_base * current_base) % modulo exponent //= 2 return result"},{"question":"# Implementing Union-Find for Dynamic Social Network Connectivity Context: Imagine you are designing a social networking application where users can connect with each other, forming a network of friends. In this application, you need to implement a feature that allows you to keep track of connected components, i.e., groups of users where each user is connected directly or indirectly to every other user within the same group. Task: Your task is to implement a Union-Find data structure to manage the connectivity of users. You will implement methods to: 1. **Add User**: Add a user to the network. 2. **Connect Users**: Connect two users, forming a friendship link. 3. **Check Connection**: Determine if two users are in the same connected component. Function Specifications: 1. **add_user(user_id: int) -> None**: - **Input**: An integer `user_id` representing a new user. - **Output**: None. - **Description**: Adds a new user to the network, initializing their own set. 2. **connect_users(user_id1: int, user_id2: int) -> None**: - **Input**: Two integers `user_id1` and `user_id2` representing two users. - **Output**: None. - **Description**: Connects the two users by merging their sets. 3. **are_connected(user_id1: int, user_id2: int) -> bool**: - **Input**: Two integers `user_id1` and `user_id2` representing two users. - **Output**: Returns a boolean. - **Description**: Returns `True` if the two users are part of the same connected component, `False` otherwise. Constraints: * Users are identified by unique integers. * You can assume the total number of unique users will not exceed `10^5`. Performance Requirements: * All operations should be optimized to nearly constant time complexity using path compression and union by size/rank. Example: ```python uf = UnionFind() # Adding users uf.add_user(1) uf.add_user(2) uf.add_user(3) uf.add_user(4) # Connecting users uf.connect_users(1, 2) uf.connect_users(3, 4) # Checking connections print(uf.are_connected(1, 2)) # Output: True print(uf.are_connected(1, 3)) # Output: False # Connecting more users uf.connect_users(2, 3) print(uf.are_connected(1, 4)) # Output: True ```","solution":"class UnionFind: def __init__(self): self.parent = {} self.size = {} def add_user(self, user_id: int) -> None: if user_id not in self.parent: self.parent[user_id] = user_id self.size[user_id] = 1 def find(self, user: int) -> int: if self.parent[user] != user: self.parent[user] = self.find(self.parent[user]) return self.parent[user] def connect_users(self, user_id1: int, user_id2: int) -> None: root1 = self.find(user_id1) root2 = self.find(user_id2) if root1 != root2: if self.size[root1] > self.size[root2]: self.parent[root2] = root1 self.size[root1] += self.size[root2] else: self.parent[root1] = root2 self.size[root2] += self.size[root1] def are_connected(self, user_id1: int, user_id2: int) -> bool: return self.find(user_id1) == self.find(user_id2)"},{"question":"# Context A Binary Search Tree (BST) can be traversed in different orders to achieve different results. One common traversal method is the in-order traversal, which processes nodes in ascending order for BSTs. # Problem Statement Given a binary search tree, implement both an iterative and a recursive function to perform in-order traversal. Your functions should return a list of values in the correct in-order sequence. # Function Signature ```python def inorder_iterative(root: Node) -> list[int]: pass def inorder_recursive(root: Node) -> list[int]: pass ``` # Input - `root`: The root node of the binary search tree, which can be `None` if the tree is empty. # Output - A list of integers, containing the node values in in-order traversal order. # Example ```python # Example Tree Structure: # 100 # / # 50 150 # / / # 25 75 125 175 n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert inorder_iterative(n1) == [25, 50, 75, 100, 125, 150, 175] assert inorder_recursive(n1) == [25, 50, 75, 100, 125, 150, 175] ``` # Constraints 1. The number of nodes in the tree is in the range [0, 10^4]. 2. Node values are unique. 3. Assume non-null nodes. # Performance Requirements - The solution should effectively handle large trees with up to 10^4 nodes within reasonable time and memory limits. # Notes - Focus on correct in-order traversal and handle all edge cases. - Ensure code readability and proper documentation for understanding logic.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_iterative(root: Node) -> list[int]: Perform in-order traversal of the BST iteratively. Return a list of node values in in-order sequence. result = [] stack = [] current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_recursive(root: Node) -> list[int]: Perform in-order traversal of the BST recursively. Return a list of node values in in-order sequence. result = [] def _inorder(node): if not node: return _inorder(node.left) result.append(node.val) _inorder(node.right) _inorder(root) return result"},{"question":"You need to implement a function to detect cycles in a directed graph. A cycle in a directed graph is a path that starts and ends at the same vertex and has at least one edge. # Function Signature ```python def has_cycle(graph: DirectedGraph) -> bool: :param graph: DirectedGraph - The directed graph instance to check for cycles. :return: bool - True if the graph contains a cycle, otherwise False. ``` # Input - `graph`: An instance of `DirectedGraph` that contains nodes represented by strings and edges between these nodes. # Output - Returns `True` if the graph contains a cycle, otherwise `False`. # Constraints - Each node name will be a string. - The maximum number of nodes ( V ) will be 1000. - The maximum number of edges ( E ) will be 10000. - The graph might be disconnected. # Example ```python graph_data = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'] } graph = DirectedGraph(graph_data) assert has_cycle(graph) == True graph_data2 = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [] } graph2 = DirectedGraph(graph_data2) assert has_cycle(graph2) == False ``` # Explanation 1. In the first graph, a cycle (A -> B -> C -> A) exists. 2. In the second graph, no cycle exists. Use Depth First Search (DFS) to detect back edges, which indicate the presence of a cycle. Implement this function using the provided `DirectedGraph` data structure.","solution":"class DirectedGraph: def __init__(self, adjacency_list): self.adjacency_list = adjacency_list def _dfs(vertex, visited, rec_stack, graph): visited.add(vertex) rec_stack.add(vertex) for neighbor in graph.adjacency_list.get(vertex, []): if neighbor not in visited: if _dfs(neighbor, visited, rec_stack, graph): return True elif neighbor in rec_stack: return True rec_stack.remove(vertex) return False def has_cycle(graph: DirectedGraph) -> bool: Detects if there\'s a cycle in the directed graph. :param graph: DirectedGraph - The directed graph instance to check for cycles. :return: bool - True if the graph contains a cycle, otherwise False. visited = set() rec_stack = set() for vertex in graph.adjacency_list.keys(): if vertex not in visited: if _dfs(vertex, visited, rec_stack, graph): return True return False"},{"question":"You are given a binary array `arr` which contains only 0s and 1s. Your task is to write a function `best_zero_to_one_replace(arr)` that determines which zero in the array should be replaced with a one to obtain the longest sequence of continuous ones. If there is no zero in the array, your function should return -1. # Input Format - A list `arr` where `1 <= len(arr) <= 10^6` and each element is either 0 or 1. # Output Format - Return the index of the zero that should be replaced to form the longest continuous sequence of ones. If there is no zero in the array, return -1. # Example ```python arr = [1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1] print(best_zero_to_one_replace(arr)) # Output: 3 arr = [1, 1, 1, 1] print(best_zero_to_one_replace(arr)) # Output: -1 ``` # Constraints - The function should run in O(n) time complexity. - The function should use O(1) additional space. - The input list `arr` will always contain at least one element. # Edge Cases - The array consists of entirely 1s. - The array consists of entirely 0s. - The length of the array is 1. Write your function below: ```python def best_zero_to_one_replace(arr): # Your code here ```","solution":"def best_zero_to_one_replace(arr): Determines which zero in the array should be replaced with a one to obtain the longest sequence of continuous ones. If there is no zero in the array, return -1. max_count = 0 max_index = -1 left, right = 0, 0 zero_index = -1 found_zero = False while right < len(arr): if arr[right] == 1: right += 1 else: if not found_zero: zero_index = right found_zero = True right += 1 else: while arr[left] == 1: left += 1 left += 1 zero_index = right right += 1 if found_zero: current_count = right - left if current_count > max_count: max_count = current_count max_index = zero_index return max_index"},{"question":"**Scenario**: You are a software engineer tasked with optimizing a legacy codebase. One function in particular, which processes linked lists, requires a significant performance improvement. The function takes a singly linked list and swaps every two adjacent nodes while maintaining the order and connection of the list. **Your Task**: Write a Python function `swap_pairs` that takes the head of a singly linked list and returns a new head of the list after swapping every two adjacent nodes. # Function Signature ```python class Node: def __init__(self, x): self.val = x self.next = None def swap_pairs(head: Node) -> Node: pass ``` # Input - `head` (Node): The head node of a singly linked list. # Output - (Node): The new head of the modified list with every two adjacent nodes swapped. # Constraints - You must use only constant space. - You may not modify the values in the list, only nodes itself can be changed. - The function should handle lists of all lengths, including empty and single-node lists. # Examples 1. Input: `1->2->3->4` Output: `2->1->4->3` 2. Input: `1->2->3` Output: `2->1->3` 3. Input: `1` Output: `1` 4. Input: `empty list` Output: `empty list` # Notes - Ensure your function passes edge cases, such as lists with an odd number of nodes or only one node. - Focus on maintaining an optimal performance both in time and space complexity.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def swap_pairs(head: Node) -> Node: if not head or not head.next: return head # Initialize pointers dummy = Node(0) dummy.next = head prev = dummy while prev.next and prev.next.next: first = prev.next second = prev.next.next # Swap the nodes first.next = second.next second.next = first prev.next = second # Move the prev pointer two nodes ahead prev = first return dummy.next"},{"question":"# Question: Serialize and Deserialize BINARY SEARCH TREE Given the provided implementations `serialize` and `deserialize` for general binary trees, modify these functions to specifically serialize and deserialize a binary search tree (BST). Ensure the invariants of the BST (left children are less than the parent node, right children are greater) are maintained during both operations. **Function Specifications:** 1. `def serialize_bst(root: TreeNode) -> str`: * **Input**: The root of the BST. * **Output**: A string representing the serialized BST. 2. `def deserialize_bst(data: str) -> TreeNode`: * **Input**: A string representation of a BST. * **Output**: The root of the reconstructed BST. # Constraints - Assume all values in the BST are unique. - You may assume the input string for `deserialize_bst` is always valid. - The tree can have up to 10,000 nodes. # Example 1. Given the BST: ``` 5 / 3 8 / 1 4 9 ``` The result of `serialize_bst` should produce a string that when passed to `deserialize_bst` will reconstruct the original BST. **Note**: Provide a brief explanation of how your solution ensures the BST properties.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize_bst(root: TreeNode) -> str: def preorder(node): return f\\"{node.val} \\" + preorder(node.left) + preorder(node.right) if node else \\"\\" return preorder(root).strip() def deserialize_bst(data: str) -> TreeNode: if not data: return None pre_order = list(map(int, data.split())) def build_bst(pre_order, bound): if not pre_order or pre_order[0] > bound: return None val = pre_order.pop(0) root = TreeNode(val) root.left = build_bst(pre_order, val) root.right = build_bst(pre_order, bound) return root return build_bst(pre_order, float(\'inf\')) # Explanation: # The `serialize_bst` function uses preorder traversal to convert the tree to a string. # The `deserialize_bst` function uses the preorder list to reconstruct the tree while maintaining # the BST properties by ensuring left nodes are less than the parent and right nodes are greater."},{"question":"# Question: Calculate the Number of Combinations Given two integers `n` and `r`, write a function `calculate_combinations(n, r)` that returns how many ways we can choose `r` items from `n` items. Your solution should be efficient, taking advantage of memoization or other optimization techniques to handle larger inputs. Function Signature ```python def calculate_combinations(n: int, r: int) -> int: ``` Input * `n` (int): The total number of items (`0 ≤ n ≤ 10^3`). * `r` (int): The number of items to choose (`0 ≤ r ≤ n`). Output * (int): The number of ways to choose `r` items from `n` items. Constraints * `n` and `r` are non-negative integers. * If `r > n`, the function should return 0. Performance Requirements * The function should efficiently handle up to the maximum input constraints leveraging memoization, iterative solutions, or dynamic programming. Example ```python assert calculate_combinations(5, 2) == 10 assert calculate_combinations(10, 5) == 252 assert calculate_combinations(0, 0) == 1 ``` Hint Use dynamic programming or an iterative approach to build up the solution rather than relying solely on recursion.","solution":"def calculate_combinations(n: int, r: int) -> int: Returns the number of ways to choose r items from n items. if r > n: return 0 # Using dynamic programming with a bottom-up approach C = [[0 for _ in range(r+1)] for _ in range(n+1)] for i in range(n+1): for j in range(min(i, r)+1): # Base cases if j == 0 or j == i: C[i][j] = 1 else: # Use previously computed values C[i][j] = C[i-1][j-1] + C[i-1][j] return C[n][r]"},{"question":"# Question Consider a task where you need to determine if a given non-empty string can be constructed by taking a substring of it and appending multiple copies of the substring together. Your task is to implement a function `is_repeated_substring_pattern(s: str) -> bool` that: 1. **Input**: * A single non-empty string `s`, consisting only of lowercase English letters. * The length of `s` will be at least 1 and at most `30,000`. 2. **Output**: * Returns `True` if the string can be constructed by repeating a substring of it; otherwise, returns `False`. 3. **Constraints**: * Optimize the solution to handle the upper limits of input size effectively, keeping both time and space complexity in mind. 4. **Performance Requirement**: * Time Complexity: O(n) * Space Complexity: O(n) # Examples ```python assert is_repeated_substring_pattern(\\"abab\\") == True assert is_repeated_substring_pattern(\\"aba\\") == False assert is_repeated_substring_pattern(\\"abcabcabcabc\\") == True assert is_repeated_substring_pattern(\\"a\\") == False ``` # Implementation Tip - Consider concatenating the string with itself and checking the presence of the original string within the modified one after slicing.","solution":"def is_repeated_substring_pattern(s: str) -> bool: Checks if the given string can be constructed by repeating a substring of it. if not s: return False doubled_s = s + s return s in doubled_s[1:-1]"},{"question":"Find All Paths in a Directed Graph Objective You are given a directed graph represented by nodes and edges. Your task is to write a function to find all possible paths from a given starting node to a given ending node in the graph. Function Signature ```python def find_all_paths(graph: DirectedGraph, start: str, end: str) -> List[List[str]]: Find all paths from the start node to the end node in the graph. :param graph: DirectedGraph object representing the graph. :param start: The start node name as a string. :param end: The end node name as a string. :return: A list of paths, where each path is represented as a list of node names. ``` Input Format * `graph`: An instance of `DirectedGraph` representing the directed graph. * `start`: A string representing the name of the starting node. * `end`: A string representing the name of the ending node. Output Format * A list of lists. Each list represents a path from the start node to the end node. Each path is a list of node names in the order they are traversed. Constraints * The graph may contain cycles. * Nodes and edges are unique. * If no path exists, return an empty list. Performance Requirements * The solution should efficiently handle graphs with up to (10^3) nodes and (10^4) edges. Example ```python # Define the graph graph_data = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"D\\"], \\"D\\": [\\"B\\"], \\"E\\": [\\"F\\"], \\"F\\": [\\"C\\"] } graph = DirectedGraph(graph_data) start = \\"A\\" end = \\"D\\" # Expected output: [[\\"A\\", \\"B\\", \\"C\\", \\"D\\"], [\\"A\\", \\"C\\", \\"D\\"]] print(find_all_paths(graph, start, end)) ``` Scenario You are a software engineer in a company that builds navigation and mapping software. Your team needs a utility to find all possible routes between two points in a city\'s road network, represented as a directed graph. This function will be used to display alternative routes to users. Your job is to implement the `find_all_paths` function that meets the specifications and handles various edge cases including cycles in the graph.","solution":"from typing import List, Dict class DirectedGraph: def __init__(self, graph_data: Dict[str, List[str]]): self.graph = graph_data def find_all_paths(graph: DirectedGraph, start: str, end: str) -> List[List[str]]: def dfs(current, path): if current == end: paths.append(path) return for neighbor in graph.graph.get(current, []): if neighbor not in path: # Avoid cycles by not revisiting nodes in the current path dfs(neighbor, path + [neighbor]) paths = [] dfs(start, [start]) return paths"},{"question":"You are given a stack data structure which supports the usual push and pop operations. Your task is to write a function `is_sorted(stack)` that determines whether the elements in the stack are in non-decreasing order from bottom to top. The function should return `True` if the stack is sorted, and `False` otherwise. Input - A list of integers representing the stack where the first element of the list is the bottom of the stack and the last element is the top of the stack. Output - A boolean value `True` if the stack is sorted in non-decreasing order, otherwise `False`. Constraints - The stack can contain up to 10^5 elements. - The integers can be negative or positive. Performance Requirements - The solution should have a time complexity of O(n) and a space complexity of O(n). # Example 1. Given the stack: `[1, 2, 3, 4, 5, 6]`, the function should return `True`. 2. Given the stack: `[6, 5, 4, 3, 2, 1]`, the function should return `False`. 3. Given the stack: `[1, 2, 3, 3, 5, 6]`, the function should return `True`. # Notes - You are expected to solve this using a function-based approach. - The function should not modify the original stack but may use additional space for temporary storage. # Function Signature ```python def is_sorted(stack: List[int]) -> bool: # your implementation here ```","solution":"def is_sorted(stack): Determines whether the elements in the stack are in non-decreasing order from bottom to top. Args: stack (list): A list of integers representing the stack where the first element is the bottom and the last element is the top. Returns: bool: True if the stack is sorted in non-decreasing order, otherwise False. # Iterate through the elements in the stack and check if each element is less than or equal to the next one for i in range(len(stack) - 1): if stack[i] > stack[i + 1]: return False return True"},{"question":"Stack Sorted Checker Context You are working as a software engineer at a logistics company. One of your tasks is to ensure that cargo containers are arranged in order of increasing weight from bottom to top in a stacking system. For simplicity, you are given a software representation of the container stack using Python lists, where the bottom of the stack is at index 0 and the top of the stack is at the last index. Your team needs a function to validate if each stack of cargo containers is sorted correctly before any further processing. Objective Write a function `is_sorted(stack)` that accepts a stack represented as a Python list. The function should return `True` if the containers (elements) in the stack are sorted in ascending order from the bottom of the stack to the top. Otherwise, it should return `False`. Function Signature ```python def is_sorted(stack: list) -> bool: ``` Input * `stack`: A list of integers representing container weights where the first element is at the bottom and the last element is at the top. Output * A boolean value (`True` or `False`) indicating whether the stack is sorted in ascending order. Constraints * The elements in the stack can be any integer value. * The function should handle an empty stack or a stack with a single element gracefully. Example ```python # Test Cases # Test Case 1 # Stack: bottom [6, 3, 5, 1, 2, 4] top # Not sorted, should return False assert is_sorted([6, 3, 5, 1, 2, 4]) == False # Test Case 2 # Stack: bottom [1, 2, 3, 4, 5, 6] top # Sorted, should return True assert is_sorted([1, 2, 3, 4, 5, 6]) == True # Test Case 3 # Stack: bottom [1] top # Single element, should return True assert is_sorted([1]) == True # Test Case 4 # Stack: bottom [] top # Empty stack, should return True assert is_sorted([]) == True print(\\"All test cases passed!\\") ``` Note * The function should restore the original stack by the end of execution. * Ensure to consider the space and time efficiency of your solution.","solution":"def is_sorted(stack: list) -> bool: Function to check if the stack is sorted in ascending order from the bottom of the stack to the top. if not stack: return True # An empty stack is considered sorted for i in range(1, len(stack)): if stack[i] < stack[i-1]: return False return True"},{"question":"Context You are working on a low-level data manipulation task in an embedded system. One of the requirements is to insert specific bits at designated positions in an integer\'s binary representation efficiently. Task Implement two functions, `insert_one_bit` and `insert_mult_bits`, which insert one bit and multiple bits, respectively, at specified positions in an integer. Function Definitions 1. **insert_one_bit** ```python def insert_one_bit(num: int, bit: int, i: int) -> int: Inserts a single bit at the specified position in a binary number. Parameters: num (int): The original number. bit (int): The bit to insert (0 or 1). i (int): The position to insert the bit. Returns: int: The new number with the bit inserted. # Your code here ``` 2. **insert_mult_bits** ```python def insert_mult_bits(num: int, bits: int, length: int, i: int) -> int: Inserts multiple bits at the specified position in a binary number. Parameters: num (int): The original number. bits (int): The bits to insert (in binary format). length (int): The number of bits to insert. i (int): The position to insert the bits. Returns: int: The new number with the bits inserted. # Your code here ``` Constraints - `num` is a non-negative integer. - `bit` can be either 0 or 1. - `i` represents a valid bit position in the binary representation of `num`. - For `insert_mult_bits`, `bits` is a binary number with the specified length. - The position `i` is such that the new bits do not overflow the integer\'s capacity. Example ```python # Examples for insert_one_bit print(insert_one_bit(21, 1, 2)) # Output: 45 print(insert_one_bit(21, 0, 2)) # Output: 41 # Examples for insert_mult_bits print(insert_mult_bits(5, 7, 3, 1)) # Output: 47 print(insert_mult_bits(5, 7, 3, 0)) # Output: 47 ``` You need to ensure that your implementation correctly handles the insertion of bits without affecting the other bits position beyond what is necessary.","solution":"def insert_one_bit(num: int, bit: int, i: int) -> int: Inserts a single bit at the specified position in a binary number. Parameters: num (int): The original number. bit (int): The bit to insert (0 or 1). i (int): The position to insert the bit. Returns: int: The new number with the bit inserted. if bit not in [0, 1]: raise ValueError(\\"bit must be 0 or 1\\") # Create a mask to clear the bit at position i mask = ~(1 << i) # Clear the bit at position i num_cleared = num & mask # Set the bit at position i new_num = num_cleared | (bit << i) return new_num def insert_mult_bits(num: int, bits: int, length: int, i: int) -> int: Inserts multiple bits at the specified position in a binary number. Parameters: num (int): The original number. bits (int): The bits to insert (in binary format). length (int): The number of bits to insert. i (int): The position to insert the bits. Returns: int: The new number with the bits inserted. if bits >= (1 << length): raise ValueError(\\"bits must be a binary number with the specified length\\") # Create a mask to clear the corresponding length of bits at position i mask = ~(((1 << length) - 1) << i) # Clear the bits at position i num_cleared = num & mask # Insert the new bits at position i new_num = num_cleared | (bits << i) return new_num"},{"question":"# Prime Number Filter You are given a list of integers and your task is to filter out the prime numbers using the provided efficient prime-checking algorithm. Function Signature ```python def filter_primes(number_list: List[int]) -> List[int]: Given a list of integers, return a new list containing only the prime numbers. :param number_list: List[int] - A list containing integer numbers. :return: List[int] - A list containing only the prime numbers from number_list. ``` Input * A list of integers `number_list` where (1 leq |number_list| leq 10^5). * Each integer (n) in `number_list` is such that ( -10^9 leq n leq 10^9). Output * Return a list containing only prime numbers from the input list. The order of primes in the output list must be the same as their order in the input list. Constraints * Consider performance; the solution should handle the input size efficiently. * Be mindful of edge cases like negative numbers, zero, and one which are not primes. Example ```python number_list = [10, 15, 2, 3, 5, 30, 31, 37, 0, -7, 101] # should return [2, 3, 5, 31, 37, 101] print(filter_primes(number_list)) ``` Note Utilize the `prime_check` function provided. You are not required to implement the primality test; rather, focus on integrating and utilizing it within your filtering function.","solution":"from typing import List def is_prime(n: int) -> bool: Efficient prime-checking algorithm to determine if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False limit = int(n**0.5) + 1 for i in range(3, limit, 2): if n % i == 0: return False return True def filter_primes(number_list: List[int]) -> List[int]: Given a list of integers, return a new list containing only the prime numbers. return [num for num in number_list if is_prime(num)]"},{"question":"Context You are given an array of integers that you need to sort in non-decreasing order. While there are many efficient sorting algorithms available, we want you to use Gnome Sort for this purpose to assess your understanding of this particular sorting method. Task Implement the Gnome Sort algorithm in Python. Assume that the input array can contain any integer values, including duplicates and negative numbers. Function Signature ```python def gnome_sort(arr: List[int]) -> List[int]: ``` Input * `arr`: A list of integers, where (1 leq |arr| leq 10^3). Output * A list of integers sorted in non-decreasing order. Constraints * Do not use any in-built sorting functions. * You must implement the Gnome Sort algorithm as described. Example ```python assert gnome_sort([34, 2, 78, -4, 14, 13, -45, 0]) == [-45, -4, 0, 2, 13, 14, 34, 78] assert gnome_sort([5, 3, 2, 2, 8, 6, 1]) == [1, 2, 2, 3, 5, 6, 8] ``` Notes The algorithm should handle: - Arrays with negative values. - Arrays with duplicate values. - Arrays of various sizes within the given constraints.","solution":"from typing import List def gnome_sort(arr: List[int]) -> List[int]: Implementing Gnome Sort algorithm to sort a list of integers in non-decreasing order. index = 0 n = len(arr) while index < n: if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Rotate Array **Context:** You are given an array of integers and an integer `k` denoting the number of steps by which the array should be rotated to the right. You need to implement an efficient in-place array rotation function. Instructions: 1. **Input Format**: * An array of integers `array` where 1 <= len(array) <= 10^5. * An integer `k` where 0 <= k <= 10^9. 2. **Output Format**: * The modified array after rotating it `k` times to the right. 3. **Performance Requirements**: * Your solution should be efficient with a time complexity of O(n) and a space complexity of O(1). 4. **Constraints**: * You must implement the rotation in-place, using O(1) extra space. 5. **Edge Cases**: * Consider and handle cases where `k` is greater than the length of the array. 6. **Note**: * Write the function as `rotate_in_place(array, k)`. ```python def rotate_in_place(array, k): Rotate array to the right by \'k\' steps in-place. :type array: List[int] :type k: int :rtype: void Do not return anything, modify array in-place instead. # Write your code here. pass # Example Usage: # Input: array = [1, 2, 3, 4, 5, 6, 7], k = 3 # Expected Output: [5, 6, 7, 1, 2, 3, 4] # Explanation: Rotating the array [1, 2, 3, 4, 5, 6, 7] three steps to the right results in [5, 6, 7, 1, 2, 3, 4]. ```","solution":"def rotate_in_place(array, k): Rotate array to the right by \'k\' steps in-place. :type array: List[int] :type k: int :rtype: void Do not return anything, modify array in-place instead. n = len(array) k = k % n # Because rotating the array n times results in the same array # Define a helper function to reverse parts of the array def reverse(arr, start, end): while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 # Reverse the entire array reverse(array, 0, n - 1) # Reverse the first k elements reverse(array, 0, k - 1) # Reverse the rest of the array reverse(array, k, n - 1)"},{"question":"# Binary Exponentiation Implementation Task As part of your work at a cybersecurity firm, you are tasked with developing efficient algorithms for large number computations critical in encryption processes. One such algorithm is binary exponentiation, which helps in raising numbers to very large powers efficiently. Your task is to implement an iterative and a recursive approach to binary exponentiation that can also handle large number moduli computations. **Function Definitions**: 1. `def power(a: int, n: int, mod: int = None) -> int` - Iterative approach - Parameters: - `a` (int): The base number. - `n` (int): The exponent. - `mod` (int, optional): The modulus (if provided, the computation should return `a^n % mod`). 2. `def power_recur(a: int, n: int, mod: int = None) -> int` - Recursive approach - Parameters: - `a` (int): The base number. - `n` (int): The exponent. - `mod` (int, optional): The modulus (if provided, the computation should return `a^n % mod`). **Expected Input and Output Formats**: - Inputs: - `a`: An integer representing the base. - `n`: A non-negative integer representing the exponent. - `mod`: An optional positive integer for modulus operation. - Outputs: - An integer representing the result of the exponentiation operation, modulo `mod` if provided. **Constraints**: - `1 <= a <= 10^9` - `0 <= n <= 10^9` - `1 <= mod <= 10^9` (if provided) **Performance Requirements**: - The time complexity should be O(log(n)). - The space complexity for the iterative approach should be O(1), and for the recursive approach should be O(log(n)) due to the recursive stack. **Notes**: - Ensure that your function handles edge cases such as `n = 0` and correctly returns `1` for any base. - Test your implementation with both large and small values, with and without the modulus. Write your implementation for both `power` and `power_recur` functions. Test the functions with various inputs to ensure accuracy. **Example**: ```python print(power(2, 10)) # Expected Output: 1024 print(power(2, 10, 100)) # Expected Output: 24 print(power_recur(2, 10)) # Expected Output: 1024 print(power_recur(2, 10, 100)) # Expected Output: 24 ```","solution":"def power(a: int, n: int, mod: int = None) -> int: Iterative approach to compute a^n % mod using binary exponentiation. result = 1 base = a % mod if mod else a while n > 0: if n % 2 == 1: # If n is odd result = (result * base) % mod if mod else (result * base) base = (base * base) % mod if mod else (base * base) n //= 2 return result % mod if mod else result def power_recur(a: int, n: int, mod: int = None) -> int: Recursive approach to compute a^n % mod using binary exponentiation. if n == 0: return 1 half = power_recur(a, n // 2, mod) half = (half * half) % mod if mod else (half * half) if n % 2 != 0: # If n is odd half = (half * a) % mod if mod else (half * a) return half"},{"question":"# Scenario You\'ve been tasked by a developer tool company to implement a feature that generates all valid combinations of a certain number of pairs of parentheses. This functionality is crucial for generating test cases for the code analysis part of their platform. # Problem Statement Write a function `generate_parentheses(n: int) -> List[str]` that will return all combinations of `n` pairs of well-formed parentheses. Ensure that your solution efficiently handles scenarios where `n` can be as high as 10 but still guarantees that all possible valid combinations are generated. Input * An integer `n` (1 <= n <= 10), denoting the number of pairs of parentheses. Output * A list of strings, where each string represents a valid combination of `n` pairs of well-formed parentheses. Constraints * All parentheses sequences must be well-formed. Example Input: ```python n = 3 ``` Output: ```python [ \\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\" ] ``` Additional Context Your implementation should be capable of handling the maximum constraint efficiently and without excessive use of memory. Provide a solution using backtracking, and justify any optimizations or adjustments made.","solution":"from typing import List def generate_parentheses(n: int) -> List[str]: Generates all combinations of well-formed parentheses for a given number of pairs. Args: n (int): Number of pairs of parentheses. Returns: List[str]: List of strings, each string is a valid combination of `n` pairs of parentheses. def backtrack(s=\'\', left=0, right=0): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s+\'(\', left+1, right) if right < left: backtrack(s+\')\', left, right+1) result = [] backtrack() return result"},{"question":"# Cycle Sort Assessment Problem As a manager of a warehouse, you have an inventory system that assists in organizing items using their serial numbers. Your goal is to ensure that all items in the warehouse are sorted by their serial numbers in ascending order to streamline item retrieval. You decided to use Cycle Sort because it minimizes the number of write operations to the inventory storage medium, which has a limited write endurance. Write a function `warehouse_sort(serial_numbers)` that sorts a list of item serial numbers using Cycle Sort. # Function Signature ```python def warehouse_sort(serial_numbers: List[int]) -> List[int]: pass ``` # Input * `serial_numbers` (List[int]): a list of integers representing the serial numbers of the items in the warehouse. # Output * Returns the sorted list of serial numbers in ascending order. # Constraints * The length of `serial_numbers` is between 1 and 10^4. * Each serial number is a non-negative integer less than or equal to 10^9. * Minimize the number of write operations. # Example ```python # Example 1 serial_numbers = [3, 1, 5, 2, 4] print(warehouse_sort(serial_numbers)) # Output: [1, 2, 3, 4, 5] # Example 2 serial_numbers = [1, 1, 1, 1] print(warehouse_sort(serial_numbers)) # Output: [1, 1, 1, 1] # Example 3 serial_numbers = [4, 3, 2, 1] print(warehouse_sort(serial_numbers)) # Output: [1, 2, 3, 4] ``` # Notes * The method should maintain the fundamental properties of Cycle Sort and handle edge cases effectively. * Review and address possible performance bottlenecks and error scenarios as explained in the provided analysis.","solution":"from typing import List def warehouse_sort(serial_numbers: List[int]) -> List[int]: Sort a list of serial numbers using Cycle Sort algorithm to minimize write operations. n = len(serial_numbers) # Loop through the array to determine the cycle starting point for cycle_start in range(0, n - 1): item = serial_numbers[cycle_start] # Find the position where we put the element pos = cycle_start for i in range(cycle_start + 1, n): if serial_numbers[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Otherwise, put the item there or right after any duplicates while item == serial_numbers[pos]: pos += 1 serial_numbers[pos], item = item, serial_numbers[pos] # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if serial_numbers[i] < item: pos += 1 while item == serial_numbers[pos]: pos += 1 serial_numbers[pos], item = item, serial_numbers[pos] return serial_numbers"},{"question":"# Coding Assessment: Next Perfect Square Finder Objective: Design and implement a function that determines the next perfect square of a given number if the given number itself is a perfect square. The function should handle both valid perfect square numbers and invalid (non-perfect square) numbers. Scenario: Imagine you are building a mathematical utility that needs to quickly determine the next higher perfect square for various inputs to optimize certain computational steps in your algorithm. Function Signature: ```python def find_next_perfect_square(n: int) -> int: pass ``` Input: * `n` (integer): A non-negative integer which may or may not be a perfect square. Output: * An integer representing the next perfect square if `n` is a perfect square. * `-1` if `n` is not a perfect square. Constraints: * The function must complete in O(1) time. * The function must handle inputs in the range [0, 10^12]. Performance Requirements: * The function should efficiently identify and return the next perfect square without unnecessary computation. Example: 1. `find_next_perfect_square(121)` should return `144` since 121 is a perfect square (11^2) and the next perfect square is 144 (12^2). 2. `find_next_perfect_square(625)` should return `676` since 625 is a perfect square (25^2) and the next perfect square is 676 (26^2). 3. `find_next_perfect_square(114)` should return `-1` since 114 is not a perfect square. Expected Edge Case Handling: - If `n` is `0`, the next perfect square is `1`. - For very large numbers close to the upper limit of the input constraint.","solution":"import math def find_next_perfect_square(n: int) -> int: Determines the next perfect square of a given number if the given number is itself a perfect square. Returns -1 if the given number is not a perfect square. if n < 0: return -1 sqrt_n = math.isqrt(n) if sqrt_n * sqrt_n == n: next_perfect_square = (sqrt_n + 1) ** 2 return next_perfect_square else: return -1"},{"question":"Context You are given a binary tree and asked to perform an in-order traversal. The in-order traversal involves visiting the nodes of the tree in the following order: left subtree, root node, and right subtree. # Task Write a function `inorder_traversal` that takes the root node of a binary tree and returns a list of values representing the in-order traversal of the tree. # Function Signature ```python def inorder_traversal(root: Optional[Node]) -> List[int]: pass ``` # Input * `root`: The root node of a binary tree. Each node contains an integer `val`, and pointers to `left` and `right` subtrees. # Output * A list of integers representing the nodes\' values in an in-order traversal. # Constraints * The number of nodes in the tree is in the range [0, 10^4]. * `-10^5 <= Node.val <= 10^5` # Performance Requirements * The solution should have a time complexity of O(n), where n is the number of nodes in the tree. * The space complexity should be O(h), where h is the height of the tree. # Example ```python class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example tree: # 100 # / # 50 150 # / / # 25 75 125 175 n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert inorder_traversal(n1) == [25, 50, 75, 100, 125, 150, 175] ``` # Guidelines * You may solve this problem either iteratively using a stack or recursively. * Ensure your solution handles edge cases such as an empty tree. * Consider memory and stack usage for large input sizes.","solution":"from typing import Optional, List class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root: Optional[Node]) -> List[int]: def inorder(node: Optional[Node], nodes: List[int]): if node: inorder(node.left, nodes) nodes.append(node.val) inorder(node.right, nodes) result = [] inorder(root, result) return result"},{"question":"You are given two words, `word1` and `word2`. Your task is to implement a function `min_distance` that computes the minimum number of delete operations needed to make these two words the same. **Function Signature**: ```python def min_distance(word1: str, word2: str) -> int: pass ``` # Input * `word1`: A string of length n (0 <= n <= 1000). * `word2`: A string of length m (0 <= m <= 1000). # Output * An integer representing the minimum number of delete operations required to make `word1` and `word2` identical. # Constraints * The strings contain only lowercase English letters. # Example 1. **Input**: `word1 = \\"sea\\"`, `word2 = \\"eat\\"` **Output**: `2` - **Explanation**: One possible series of operations is to delete \'s\' from \\"sea\\" and delete \'t\' from \\"eat\\" to make both strings \\"ea\\". 2. **Input**: `word1 = \\"leetcode\\"`, `word2 = \\"etco\\"` **Output**: `4` - **Explanation**: One possible series of operations is to delete \'l\', \'e\', \'d\', \'e\' from \\"leetcode\\" and no deletions in \\"etco\\" to make both strings \\"etco\\". # Description To solve this problem, participants need to: 1. Implement the LCS (Longest Common Subsequence) algorithm to find the length of the longest subsequence that appears in both strings. 2. Compute the number of delete operations needed from the length of the LCS. # Implementation Notes - The implementation should use a dynamic programming approach for efficiency. - Participants should be mindful of edge cases like empty strings and non-overlapping characters.","solution":"def min_distance(word1: str, word2: str) -> int: def longest_common_subsequence(word1, word2): n, m = len(word1), len(word2) dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m] lcs_length = longest_common_subsequence(word1, word2) return len(word1) + len(word2) - 2 * lcs_length"},{"question":"**Scenario**: You are working on a software that deals with large sets of matrix operations, specifically matrix multiplication in scientific computing. To optimize the performance of these operations, you need to ensure that the matrix multiplication is performed in the most efficient order. **Problem Description**: Given an input array where each element represents the dimension of a matrix (i.e., the first element is the number of rows in the first matrix, the second element is the number of columns in the first matrix which is also the number of rows of the second matrix, and so forth), write a function to find the minimum number of scalar multiplications needed to multiply the sequence of matrices. **Function Signature**: ```python def matrix_chain_order(array: List[int]) -> Tuple[int, List[List[int]]]: ``` **Parameters**: - `array`: A list of integers representing the dimensions of the matrices. **Returns**: - A tuple where the first element is an integer representing the minimum number of scalar multiplications needed to multiply the sequence of matrices. - The second element is a 2D list, representing the optimal split points for parenthesizing the multiplication. **Example**: ```python array = [30, 35, 15, 5, 10, 20, 25] result = matrix_chain_order(array) print(result[0]) # Output: 15125 print(result[1]) # Output: # [[0, 0, 0, 0, 0, 0, 0], # [0, 0, 15750, 7875, 9375, 11875, 15125], # [0, 0, 0, 2625, 4375, 7125, 10500], # [0, 0, 0, 0, 750, 2500, 5375], # [0, 0, 0, 0, 0, 1000, 3500], # [0, 0, 0, 0, 0, 0, 5000], # [0, 0, 0, 0, 0, 0, 0]] ``` **Constraints**: 1. The length of the `array` is at least 2 and at most 100. 2. The dimensions represented by integers in `array` will be positive integers not exceeding 1000. **Note**: You should also implement a helper function `print_optimal_solution(optimal_solution: List[List[int]], i: int, j: int) -> None` to print the optimal order of matrix multiplication using the solution matrix produced by the `matrix_chain_order` function. **Additional Task**: Write a main function to demonstrate the usage of `matrix_chain_order` and `print_optimal_solution` functions with at least two test cases including edge cases.","solution":"from typing import List, Tuple def matrix_chain_order(array: List[int]) -> Tuple[int, List[List[int]]]: n = len(array) - 1 m = [[0 for _ in range(n + 1)] for _ in range(n + 1)] s = [[0 for _ in range(n + 1)] for _ in range(n + 1)] for length in range(2, n + 1): # length of subchain being considered for i in range(1, n - length + 2): j = i + length - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + array[i - 1] * array[k] * array[j] if q < m[i][j]: m[i][j] = q s[i][j] = k return m[1][n], s def print_optimal_solution(s: List[List[int]], i: int, j: int) -> None: if i == j: print(f\\"A{i}\\", end=\\"\\") else: print(\\"(\\", end=\\"\\") print_optimal_solution(s, i, s[i][j]) print_optimal_solution(s, s[i][j] + 1, j) print(\\")\\", end=\\"\\") # Main function to demonstrate usage if __name__ == \\"__main__\\": arrays = [ [30, 35, 15, 5, 10, 20, 25], # Example case [10, 20, 30, 40, 30] # Additional case ] for array in arrays: min_operations, optimal_splits = matrix_chain_order(array) print(f\\"Array: {array}\\") print(f\\"Minimum number of multiplications: {min_operations}\\") print(\\"Optimal parenthesization: \\", end=\\"\\") print_optimal_solution(optimal_splits, 1, len(array) - 1) print(\\"n\\" + \\"-\\"*50)"},{"question":"# Question: Implement Radix Sort with Handling for Negative Numbers Given a list of integers, write a function `radix_sort_with_negatives` to sort the list in ascending order using Radix Sort. The standard Radix Sort works well for non-negative integers, but your implementation should be able to handle negative integers as well. Function Signature ```python def radix_sort_with_negatives(arr: List[int], simulation: bool = False) -> List[int]: pass ``` Input - `arr`: List of integers which may include negative numbers. - `simulation`: Boolean value (default `False`). If set to `True`, the function should print the intermediate steps of sorting for each digit place. Output - Returns a new list of integers sorted in ascending order. Constraints - The number of elements in the list `n` will be in the range: [0, 10^5]. - Each element in the list will be in the range: [-10^9, 10^9]. Example ```python # Example 1 arr = [170, 45, 75, -45, -75, 90, -802, 24, 2, 66] print(radix_sort_with_negatives(arr, simulation=True)) # Output: [-802, -75, -45, 2, 24, 45, 66, 75, 90, 170] # Example 2 arr = [0, -1, -2, 3, 2, 1] print(radix_sort_with_negatives(arr)) # Output: [-2, -1, 0, 1, 2, 3] ``` Instructions 1. Implement the base Radix Sort algorithm considering only non-negative numbers. 2. Handle negative numbers by separating them from non-negative numbers. Sort the negative numbers using Radix Sort, then combine the sorted negative numbers (in reverse) with the sorted non-negative numbers. 3. If `simulation` is set to `True`, print the intermediate lists after each pass of sorting by digit place. 4. Your solution should perform the sorting in `O(nk)` time complexity and use `O(n+k)` space complexity.","solution":"def counting_sort(arr, exp, simulation): n = len(arr) output = [0] * n count = [0] * 10 # Count occurrences for i in range(n): index = abs(arr[i]) // exp count[index % 10] += 1 # Compute cumulative count for i in range(1, 10): count[i] += count[i - 1] # Build output array i = n - 1 while i >= 0: index = abs(arr[i]) // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 i -= 1 for i in range(n): arr[i] = output[i] if simulation: print(f\\"After sorting with exp={exp}: {arr}\\") def radix_sort_with_negatives(arr, simulation=False): if len(arr) == 0: return arr # Separate positives and negatives negatives = [x for x in arr if x < 0] positives = [x for x in arr if x >= 0] # Perform radix sort on positives if positives: max_num = max(positives) exp = 1 while max_num // exp > 0: counting_sort(positives, exp, simulation) exp *= 10 # Perform radix sort on absolute values of negatives if negatives: max_num = abs(min(negatives)) exp = 1 while max_num // exp > 0: counting_sort(negatives, exp, simulation) exp *= 10 negatives = negatives[::-1] # Reverse the negatives to get correct order return negatives + positives"},{"question":"# Question: Full Binary Tree Construction and Inorder Traversal Problem Statement: You are required to construct a full binary tree from the given preorder and postorder traversals. A full binary tree is defined as a tree where every node has either zero or two children. Once the tree is constructed, you need to generate and output the inorder traversal of the tree. Input Format: 1. A list of integers representing the preorder traversal of the tree. 2. A list of integers representing the postorder traversal of the tree. Output Format: 1. A list of integers representing the inorder traversal of the constructed binary tree. Constraints: 1. All elements in the preorder and postorder lists are unique. 2. The size of preorder and postorder lists will be equal and will contain between 1 and 1000 elements, inclusive. Requirements: 1. You must use a recursive approach to construct the binary tree. 2. The expected time complexity should aim to improve upon the naive O(n^2) complexity, using optimizations where possible. Example: Input: ``` preorder = [1, 2, 4, 8, 9, 5, 3, 6, 7] postorder = [8, 9, 4, 5, 2, 6, 7, 3, 1] ``` Output: ``` [8, 4, 9, 2, 5, 1, 6, 3, 7] ``` Notes: 1. In the example, the constructed binary tree is: 1 / 2 3 / / 4 5 6 7 / 8 9 2. The inorder traversal of this tree is `[8, 4, 9, 2, 5, 1, 6, 3, 7]`. Submission: Implement the function `construct_inorder(pre, post)` that takes the preorder and postorder traversal lists and returns the inorder traversal list. ```python class TreeNode: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def construct_inorder(pre, post): # Implement the code to construct and return the inorder traversal of the tree pass ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def construct_tree(pre, post): if not pre or not post: return None root_val = pre[0] root = TreeNode(root_val) if len(pre) == 1: return root # Find the index of the left child value in postorder list: left_child_val = pre[1] left_subtree_size = post.index(left_child_val) + 1 # Construct left and right subtrees: root.left = construct_tree(pre[1:left_subtree_size + 1], post[:left_subtree_size]) root.right = construct_tree(pre[left_subtree_size + 1:], post[left_subtree_size:-1]) return root def inorder_traversal(root): return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) if root else [] def construct_inorder(pre, post): root = construct_tree(pre, post) return inorder_traversal(root)"},{"question":"You are given the lengths of two sides of a right-angled triangle. Implement a function `find_missing_side` that accurately determines the length of the third side. The function should take three arguments, `opposite` (opposite side), `adjacent` (adjacent side), and `hypotenuse` (hypotenuse side). One of these will be marked as unknown, represented by the string \\"?\\" in the input. Your function needs to handle the computational logic gracefully and avoid common pitfalls that can lead to erroneous results. It should return the computed length as a float, or raise an appropriate error for invalid inputs. Function Signature ```python def find_missing_side(opposite: Union[float, str], adjacent: Union[float, str], hypotenuse: Union[float, str]) -> float: pass ``` Example Inputs & Outputs ```python # Example 1 find_missing_side(3, 4, \\"?\\") # Returns: 5.0 # Example 2 find_missing_side(3, \\"?\\", 5) # Returns: 4.0 # Example 3 find_missing_side(\\"?\\", 4, 5) # Returns: 3.0 # Example 4 (Invalid input) find_missing_side(3, 4, 7) # Should raise a ValueError ``` Input Constraints * Only one of `opposite`, `adjacent`, or `hypotenuse` will be \\"?\\". * The input will be either a positive float or \\"?\\". * Hypotenuse should always be greater than or equal to both other sides when given. Performance Requirements * Time complexity should be O(1). * Space complexity should be O(1). **Note**: Proper error handling is essential for invalid inputs like zero or negative lengths, non-numeric values, or physical impossibility (e.g., hypotenuse smaller than one of the other sides). # Evaluation Criteria * Correct implementation of the Pythagorean theorem. * Proper edge-case handling for physically invalid triangle configurations. * Robust input validation and error handling.","solution":"from typing import Union import math def find_missing_side(opposite: Union[float, str], adjacent: Union[float, str], hypotenuse: Union[float, str]) -> float: # Input validation sides = [opposite, adjacent, hypotenuse] if sides.count(\\"?\\") != 1: raise ValueError(\\"Exactly one side must be unknown and represented by \'?\'\\") num_sides = [side for side in sides if isinstance(side, (int, float))] if any(side <= 0 for side in num_sides): raise ValueError(\\"Side lengths must be positive values\\") # Assigning values to a, b, c based on opposite, adjacent, and hypotenuse input a = opposite if opposite != \\"?\\" else None b = adjacent if adjacent != \\"?\\" else None c = hypotenuse if hypotenuse != \\"?\\" else None if c and (a and c < a or b and c < b): raise ValueError(\\"Hypotenuse should be the largest side\\") # Calculate the missing side using the Pythagorean theorem if a is None: a = math.sqrt(c**2 - b**2) elif b is None: b = math.sqrt(c**2 - a**2) elif c is None: c = math.sqrt(a**2 + b**2) else: raise ValueError(\\"One side must be unknown\\") # Returning the computed length return a if a is not None and opposite == \\"?\\" else b if b is not None and adjacent == \\"?\\" else c"},{"question":"# Problem: Optimizing Edit Distance Calculation Objective You are working on a system to optimize spell-check for an extensive library of books. The goal is to minimize the space used by the edit distance algorithm while ensuring that the system can still accurately compute the distance between any two given words. Task Implement a function to compute the edit distance between two strings `word_a` and `word_b` using space optimization techniques. Function Signature ```python def optimized_edit_distance(word_a: str, word_b: str) -> int: pass ``` Input * `word_a` (string): The first word (1 ≤ |word_a| ≤ 2000) * `word_b` (string): The second word (1 ≤ |word_b| ≤ 2000) Output * Returns an integer which is the edit distance between the two given words. Constraints * Solve the problem with a space complexity better than O(|word_a| * |word_b|). Aim to achieve O(min(|word_a|, |word_b|)). Example ```python assert optimized_edit_distance(\'kitten\', \'sitting\') == 3 assert optimized_edit_distance(\'flaw\', \'lawn\') == 2 ``` Hint Focus on reducing the space complexity by using a rolling array technique, where only two arrays (current and previous) are used rather than maintaining the entire 2-dimensional DP table.","solution":"def optimized_edit_distance(word_a: str, word_b: str) -> int: Computes the edit distance between two strings word_a and word_b using space optimization. len_a, len_b = len(word_a), len(word_b) if len_a < len_b: word_a, word_b = word_b, word_a len_a, len_b = len_b, len_a previous = list(range(len_b + 1)) current = [0] * (len_b + 1) for i in range(1, len_a + 1): current[0] = i for j in range(1, len_b + 1): if word_a[i - 1] == word_b[j - 1]: current[j] = previous[j - 1] else: current[j] = min(previous[j - 1], previous[j], current[j - 1]) + 1 previous, current = current, previous return previous[len_b]"},{"question":"# Question: Histogram of Character Frequencies Given a string, write a function `char_histogram(s: str) -> dict` that returns a dictionary representing the frequency of each character in the string. Input - `s` (1 ≤ len(s) ≤ 10^5): A string containing any printable ASCII characters. Output - A dictionary where the keys are characters from the input string and the values are their respective frequencies. Constraints - The function should have a time complexity of O(n), where n is the length of the string. - The function should have a space complexity of O(k), where k is the number of distinct characters in the string. # Examples Example 1 ```python s = \\"hello\\" char_histogram(s) ``` Output: ```python {\'h\': 1, \'e\': 1, \'l\': 2, \'o\': 1} ``` Example 2 ```python s = \\"mississippi\\" char_histogram(s) ``` Output: ```python {\'m\': 1, \'i\': 4, \'s\': 4, \'p\': 2} ``` Example 3 ```python s = \\"\\" char_histogram(s) ``` Output: ```python {} ``` # Explanation - In the first example, the function returns a dictionary with the frequency of each character in the word \\"hello\\". - In the second example, the frequency of each character in the word \\"mississippi\\" is returned. - In the third example, as the input string is empty, the function returns an empty dictionary. Edge Cases - Input string is empty. - Input string contains all identical characters. - Input string contains a mix of alphabets, digits, punctuation, and whitespace. Implement the function `char_histogram(s: str) -> dict` to solve the problem based on the provided constraints and examples.","solution":"def char_histogram(s: str) -> dict: Returns a dictionary representing the frequency of each character in the string. Parameters: s (str): The input string containing printable ASCII characters. Returns: dict: A dictionary where the keys are characters from the input string and the values are their respective frequencies. frequency = {} for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"As a part of evaluating your understanding of fundamental data structures, you are required to implement a stack. You have been provided with two implementations — one using an array and the other using a linked list. In this assignment, you will focus on the array-based implementation. Task Implement the `MinArrayStack` class which extends the provided `ArrayStack` class to support the following additional operations: * **get_min()**: Returns the smallest element currently present in the stack without modifying the stack. Constraints 1. The stack will only contain integers. 2. You must maintain O(1) time complexity for the `get_min()` operation. 3. You can use extra space to keep track of the minimum element, but the space complexity should still be O(n). # Input and Output Format * The `push`, `pop`, and `peek` methods will function as specified in the `ArrayStack` implementation. * The `get_min()` method expects no parameters and returns an integer. # Example Usage ```python s = MinArrayStack(5) s.push(3) s.push(5) print(s.get_min()) # Output: 3 s.push(2) s.push(1) print(s.get_min()) # Output: 1 s.pop() print(s.get_min()) # Output: 2 s.pop() print(s.peek()) # Output: 5 print(s.get_min()) # Output: 3 ``` Implementation Write the required `MinArrayStack` class that includes: * An `__init__` method to initialize the stack. * A `get_min` method to return the minimum element. ```python class MinArrayStack(ArrayStack): def __init__(self, size=10): super().__init__(size) self._min_stack = [] def push(self, value): super().push(value) if not self._min_stack or value <= self._min_stack[-1]: self._min_stack.append(value) def pop(self): value = super().pop() if value == self._min_stack[-1]: self._min_stack.pop() return value def get_min(self): if not self._min_stack: raise IndexError(\\"Stack is empty\\") return self._min_stack[-1] ```","solution":"class ArrayStack: def __init__(self, size=10): # Initialize the stack with a fixed size self._stack = [] self._size = size self._top = -1 def push(self, value): if self._top >= self._size - 1: raise OverflowError(\\"Stack overflow\\") self._stack.append(value) self._top += 1 def pop(self): if self._top == -1: raise IndexError(\\"Stack underflow\\") value = self._stack.pop() self._top -= 1 return value def peek(self): if self._top == -1: raise IndexError(\\"Stack is empty\\") return self._stack[self._top] def is_empty(self): return self._top == -1 def is_full(self): return self._top == self._size - 1 class MinArrayStack(ArrayStack): def __init__(self, size=10): super().__init__(size) self._min_stack = [] def push(self, value): super().push(value) if not self._min_stack or value <= self._min_stack[-1]: self._min_stack.append(value) def pop(self): value = super().pop() if value == self._min_stack[-1]: self._min_stack.pop() return value def get_min(self): if not self._min_stack: raise IndexError(\\"Stack is empty\\") return self._min_stack[-1]"},{"question":"# Hailstone Sequence Generator Objective You need to implement a function that generates the hailstone sequence starting from a given integer `n` using the rules of the Collatz Conjecture. Function Specification ```python def hailstone(n: int) -> List[int]: Generate the hailstone sequence for the given integer n. Parameters: n (int): The starting point of the hailstone sequence. Returns: List[int]: A list containing the hailstone sequence starting from n and ending at 1. ``` Input - **n (int)**: Starting integer (1 <= n <= 1,000,000) Output - **List[int]**: List containing the hailstone sequence starting from `n` and ending at `1`. Constraints - You should handle the input constraints within your function. - The sequence will always terminate at 1 based on the rules provided. Example ```python print(hailstone(5)) # Output: [5, 16, 8, 4, 2, 1] print(hailstone(1)) # Output: [1] ``` # Description Develop a Python function `hailstone` that computes and returns the hailstone sequence starting from the provided integer `n` following the described rules. Ensure that your function handles both small and large values of `n` efficiently. Requirements - Your solution should be optimized for performance within the given constraints. - Consider edge cases and ensure your function handles them appropriately.","solution":"from typing import List def hailstone(n: int) -> List[int]: Generate the hailstone sequence for the given integer n. Parameters: n (int): The starting point of the hailstone sequence. Returns: List[int]: A list containing the hailstone sequence starting from n and ending at 1. sequence = [] while n != 1: sequence.append(n) if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 sequence.append(1) # The sequence always ends with 1 return sequence"},{"question":"# Coding Challenge: Find Self-Powering Numbers in a Range You are provided with an algorithm that finds all numbers in a given range [low, high] where each number satisfies the property: \\"The sum of the digits raised to their consecutive powers equals the number itself\\". Task Write a function `find_self_powering_numbers(low, high)` that returns a list of such numbers within the given range [low, high] (inclusive). Function Signature ```python def find_self_powering_numbers(low: int, high: int) -> List[int]: ``` Input * Two integers `low` and `high` specifying the range, where low <= high. Output * A list of integers that satisfy the stated property within the given range. Constraints * 1 <= low <= high <= 10^6 Example ```python assert find_self_powering_numbers(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert find_self_powering_numbers(1, 135) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89, 135] ``` Performance Requirements Your program should be efficient enough to process the given range within a reasonable time frame. # Notes 1. Ensure your implementation optimally handles ranges that include large numbers. 2. Consider potential improvements or optimizations where feasible.","solution":"from typing import List def find_self_powering_numbers(low: int, high: int) -> List[int]: def is_self_powering_number(n: int) -> bool: digits = [int(digit) for digit in str(n)] sum_of_powers = sum(digit ** (index + 1) for index, digit in enumerate(digits)) return sum_of_powers == n result = [] for num in range(low, high + 1): if is_self_powering_number(num): result.append(num) return result"},{"question":"# Ternary Search Implementation You are provided with an array of integers sorted in ascending order. Your task is to implement the ternary search algorithm to find a given integer within this array. The ternary search algorithm works by dividing the array into three parts and progressively narrowing the search range. **Function Signature:** ```python def ternary_search(left: int, right: int, key: int, arr: list[int]) -> int: pass ``` **Input:** * `left` (int): The initial left boundary index for the search range. * `right` (int): The initial right boundary index for the search range. * `key` (int): The integer value to be searched in the array. * `arr` (list[int]): A list of integers sorted in ascending order. **Output:** * Returns the index of the `key` in the array if found. Returns `-1` if the `key` is not present in the array. **Example:** ```python arr = [2, 3, 4, 10, 40, 44, 59] assert ternary_search(0, len(arr)-1, 10, arr) == 3 assert ternary_search(0, len(arr)-1, 44, arr) == 5 assert ternary_search(0, len(arr)-1, 7, arr) == -1 ``` **Constraints:** * The array will be sorted and will contain distinct integers. * The function should handle arrays with varying lengths, including empty arrays. **Note:** * Ensure optimized execution with a non-recursive approach to avoid potential stack overflow issues. * Be mindful of typical edge cases, such as an array of length one or two and key values that may not be present in the array. Write a function `ternary_search` in Python to implement the ternary search algorithm based on the provided specifications.","solution":"def ternary_search(left: int, right: int, key: int, arr: list[int]) -> int: while right >= left: mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"# Scenario You are working on a tree-based navigation system, and it is essential to ensure that the binary trees representing the routes are balanced. This will guarantee that operations like search, insertion, and deletion are efficient. # Problem Statement Write a function to determine if a given binary tree is height-balanced. A binary tree is height-balanced if the depths of the two subtrees of every node never differ by more than one. # Input * `root` (TreeNode): The root of the binary tree. A TreeNode is defined as: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` # Output * `bool`: Return `True` if the tree is balanced, and `False` otherwise. # Constraints * The number of nodes in the tree is in the range `[0, 10^4]`. * -10^4 <= Node value <= 10^4 # Examples 1. Given the tree: ``` 3 / 9 20 / 15 7 ``` Return `True`. 2. Given the tree: ``` 1 / 2 2 / 3 3 / 4 4 ``` Return `False`. # Implementation Implement the function `is_balanced(root: TreeNode) -> bool`. # Hints 1. Utilize a helper function that returns -1 if any subtree is unbalanced; otherwise, it returns the depth of the subtree. 2. Depending on the depth returned by the helper function, determine if the tree is balanced.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_balanced(root: TreeNode) -> bool: def check_balance(node: TreeNode) -> int: if not node: return 0 left_depth = check_balance(node.left) right_depth = check_balance(node.right) if left_depth == -1 or right_depth == -1 or abs(left_depth - right_depth) > 1: return -1 return max(left_depth, right_depth) + 1 return check_balance(root) != -1"},{"question":"**Problem Statement:** You are tasked with optimizing an extremely inefficient sorting algorithm for educational purposes. You\'re given an array of integers and need to sort this array using the Bogo Sort algorithm. However, the algorithm should include a mechanism to efficiently stop execution if the array size or number of iterations exceeds a provided threshold. Write a Python function `advanced_bogo_sort(arr: List[int], max_iterations: int) -> Tuple[List[int], int, bool]` that performs the following: 1. Sorts the array using a Bogo Sort mechanism. 2. Stops and returns if the number of iterations exceeds `max_iterations`. 3. Returns a tuple containing: - The resulting array (sorted or partially sorted). - The total number of iterations performed. - A boolean indicating if the sort was successful (True if array is sorted, False if max_iterations was reached). **Input:** - `arr`: List of integers to be sorted. - `max_iterations`: An integer indicating the maximum number of iterations allowed. **Output:** - Returns a tuple (`sorted_array`, `iterations`, `is_sorted`): - `sorted_array`: The sorted array or the array after stopping early. - `iterations`: The number of iterations that were performed. - `is_sorted`: True if the array was successfully sorted, False if it stopped early due to the maximum iterations constraint. **Constraints:** - The array should have at most 100 elements. **Function Signature:** ```python from typing import List, Tuple def advanced_bogo_sort(arr: List[int], max_iterations: int) -> Tuple[List[int], int, bool]: pass ``` **Example:** ```python arr = [3, 1, 2, 4] max_iterations = 1000 advanced_bogo_sort(arr, max_iterations) # Example output: # ([1, 2, 3, 4], 14, True) ``` Ensure your implementation considers edge cases and includes appropriate stopping conditions to avoid unnecessary infinite loops.","solution":"from typing import List, Tuple import random def advanced_bogo_sort(arr: List[int], max_iterations: int) -> Tuple[List[int], int, bool]: def is_sorted(arr: List[int]) -> bool: for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True iterations = 0 while iterations < max_iterations: if is_sorted(arr): return (arr, iterations, True) random.shuffle(arr) iterations += 1 return (arr, iterations, is_sorted(arr))"},{"question":"# Trimmed Mean Calculation You are tasked to implement a trimmed mean calculation for a set of data points. The trimmed mean is a measure of central tendency where you remove a specified percentage of the lowest and highest values from the dataset and then calculate the average of the remaining values. # Detailed Requirements: - **Function Name**: `trimmean` - **Input**: - A list of integers `arr` representing the data points. - A floating-point number `per` representing the percentage of values to trim from both ends (symmetric trimming). - **Output**: A floating-point number representing the trimmed mean of the given data. # Constraints: - The list can contain up to `10^6` elements. - The percentage `per` will be a positive float up to 100. - The list will contain at least 1 element. # Performance Requirements: - The implementation should be efficient with a time complexity of O(n log n) or better, where n is the number of elements in the list. # Example Usage: ```python # Example 1 arr = [1, 2, 3, 4, 100] per = 40 # Explanation: Trim 20% from each end, removing the first and last element. Remaining elements are [2, 3, 4]. # Average of [2, 3, 4] is (2+3+4)/3 = 3.0 print(trimmean(arr, per)) # Output: 3.0 # Example 2 arr = [6, 3, 7, 8, 5, 9, 1, 4] per = 50 # Explanation: Trim 25% from each end, removing [1, 3] and [8, 9]. Remaining elements are [4, 5, 6, 7]. # Average of [4, 5, 6, 7] is (4+5+6+7)/4 = 5.5 print(trimmean(arr, per)) # Output: 5.5 ``` # Additional Notes: - Carefully consider edge cases such as very high or very low percentages, small array sizes, and potentially all elements being removed. - Ensure the solution handles both even and odd lengths of the array robustly. Implement the `trimmean` function ensuring it adheres to the constraints and efficiently computes the trimmed mean.","solution":"def trimmean(arr, per): Calculate the trimmed mean of a list of integers. Parameters: arr (list of int): The list of integers to calculate the trimmed mean from. per (float): The percentage of values to trim from both ends. Returns: float: The trimmed mean of the remaining values. n = len(arr) trim_count = int(n * per / 100 / 2) # Sort the array sorted_arr = sorted(arr) # Remove the lowest and highest values trimmed_arr = sorted_arr[trim_count:n - trim_count] # Calculate the mean of the remaining values if len(trimmed_arr) == 0: return 0.0 return sum(trimmed_arr) / len(trimmed_arr)"},{"question":"You are given a list of integers and two optional limit values `min_lim` and `max_lim`. Your task is to implement a function `filter_range` that returns a list of integers containing only those elements from the input list that lie within the range specified by `min_lim` and `max_lim`, inclusive. If `min_lim` or `max_lim` is not provided, treat them as negative and positive infinity, respectively. Function Signature ```python def filter_range(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: pass ``` Input - `arr`: A list of integers (1 <= len(arr) <= 10^6). - `min_lim`: An integer representing the minimum limit (optional). - `max_lim`: An integer representing the maximum limit (optional). Output - A list of integers containing elements from `arr` that are greater than or equal to `min_lim` and less than or equal to `max_lim`. Constraints - If `min_lim` is not provided, treat it as negative infinity. - If `max_lim` is not provided, treat it as positive infinity. Example ```python # Example 1 arr = [1, 2, 3, 4, 5] min_lim = 2 max_lim = 4 assert filter_range(arr, min_lim, max_lim) == [2, 3, 4] # Example 2 arr = [5, 3, 8, 6, 2] min_lim = 4 max_lim = None assert filter_range(arr, min_lim) == [5, 8, 6] # Example 3 arr = [10, 20, 30, 40] min_lim = None max_lim = 25 assert filter_range(arr, None, max_lim) == [10, 20] # Example 4 arr = [] min_lim = 0 max_lim = 10 assert filter_range(arr, min_lim, max_lim) == [] ``` Scenario Imagine you are working with a dataset of temperatures recorded every minute for a week. You need to filter out the extreme values to focusing only on the normal temperature range (say between 15°C and 25°C). Use the `filter_range` function to clean this data before further analysis.","solution":"from typing import List, Optional def filter_range(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: if min_lim is None: min_lim = float(\'-inf\') if max_lim is None: max_lim = float(\'inf\') result = [x for x in arr if min_lim <= x <= max_lim] return result"},{"question":"# Linked List Cycle Detection You are given a linked list which may/may not contain a cycle. Your task is to find the first node of cycle in it if a cycle exist, otherwise return `None`. Function Signature ```python def first_cyclic_node(head: \'Node\') -> \'Node\': ``` Input * `head` (Node): The head of the linked list. Output * `Node`: The first node in the cycle if a cycle exists, otherwise return `None`. Constraints * Do not modify the linked list. * Do not use extra space (constant space complexity required). # Scenario Consider you are working on a networking project where you need to detect cycles in data packets which are structured as linked lists. Implement the function `first_cyclic_node` using Floyd\'s cycle-finding algorithm to detect the point where the cycle begins. Examples 1. For the linked list: A -> B -> C -> D -> E -> C (cycle back to C), * Output: Node with value \'C\'. 2. For the linked list: 1 -> 2 -> 3 -> 4 -> 5 (no cycle), * Output: None. Implementation Details You are provided with a `Node` class. ```python class Node: def __init__(self, x): self.val = x self.next = None ``` <p>Complete the implementation of the `first_cyclic_node` function and ensure that it passes the given test suite provided below: ```python import unittest class TestSuite(unittest.TestCase): def test_first_cyclic_node(self): # create linked list => A -> B -> C -> D -> E -> C head = Node(\'A\') head.next = Node(\'B\') curr = head.next cyclic_node = Node(\'C\') curr.next = cyclic_node curr = curr.next curr.next = Node(\'D\') curr = curr.next curr.next = Node(\'E\') curr = curr.next curr.next = cyclic_node self.assertEqual(\'C\', first_cyclic_node(head).val) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, x): self.val = x self.next = None def first_cyclic_node(head: \'Node\') -> \'Node\': Detects the start of the cycle in a linked list using Floyd\'s cycle-finding algorithm. If there is no cycle, returns None. slow = head fast = head # Detect whether there is a cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected break else: # No cycle found return None # Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"You are provided with a binary tree and your task is to implement a function `longest_consecutive` that finds the length of the longest consecutive sequence path. # Function Signature: ```python def longest_consecutive(root): :type root: TreeNode :rtype: int ``` # Input: - `root` (TreeNode): The root of the binary tree. A TreeNode is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output: - Returns an integer indicating the length of the longest consecutive sequence path in the tree. # Constraints: - The tree will have at most 10^5 nodes. - The value of each node will be in the range [-10^4, 10^4]. # Example: ```python # Example 1 root = TreeNode(1, None, TreeNode(3, TreeNode(2), TreeNode(4, None, TreeNode(5)))) assert longest_consecutive(root) == 3 # Example 2 root = TreeNode(2, None, TreeNode(3, TreeNode(2, TreeNode(1)))) assert longest_consecutive(root) == 2 ``` # Explanation: - In Example 1, the longest consecutive sequence path is [3, 4, 5], so the function returns 3. - In Example 2, the longest consecutive sequence path is [2, 3], so the function returns 2. The provided code snippet that you need to debug and complete ensures that the maximum length of the consecutive sequence is correctly tracked and updated during the DFS traversal. Ensure your implementation correctly passes the `max_len` reference to be able to set the found maximum length appropriately.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_consecutive(root): def dfs(node, parent_val, length): if not node: return length if node.val == parent_val + 1: length += 1 else: length = 1 left_length = dfs(node.left, node.val, length) right_length = dfs(node.right, node.val, length) return max(length, left_length, right_length) return dfs(root, root.val - 1, 0) if root else 0"},{"question":"# Binary Min Heap Implementation and Extension You have been provided with the class structure of a binary min heap. Your task is to extend this implementation and add a new method to retrieve the k smallest elements from the heap without modifying the original heap structure. Input and Output Format: - Implement a method `k_smallest_elements(k)` within the `BinaryHeap` class. - **Input**: Integer `k` where `1 <= k <= current_size`. - **Output**: List of the k smallest elements. # Constraints: - Do not directly modify the original heap. - Assume the heap property is maintained throughout the use of this method. # Function Signature: ```python class BinaryHeap: # Existing methods here def k_smallest_elements(self, k: int) -> List[int]: pass ``` # Example: ```python heap = BinaryHeap() heap.insert(4) heap.insert(50) heap.insert(7) heap.insert(55) heap.insert(90) heap.insert(87) print(heap.k_smallest_elements(3)) # Output: [4, 7, 50] ``` Explanation: The example demonstrates inserting several elements into the binary heap and then retrieving the 3 smallest elements, which should be [4, 7, 50] in sorted order.","solution":"import heapq from typing import List class BinaryHeap: def __init__(self): self.heap = [] self.current_size = 0 def insert(self, k): heapq.heappush(self.heap, k) self.current_size += 1 def k_smallest_elements(self, k: int) -> List[int]: if k > self.current_size: raise ValueError(\\"k cannot be greater than the number of elements in the heap\\") # Make a copy of the heap to avoid modifying the original heap copied_heap = self.heap[:] smallest_elements = [] for _ in range(k): smallest_elements.append(heapq.heappop(copied_heap)) return smallest_elements"},{"question":"# Sudoku Board Validation Function As part of a Sudoku puzzle solver, you are required to implement validation functions that ensure the given Sudoku board is a valid solution. The validation should check: 1. Each row contains all numbers from 1 to 9 exactly once. 2. Each column contains all numbers from 1 to 9 exactly once. 3. Each of the nine 3x3 sub-grids contains all numbers from 1 to 9 exactly once. 4. Boards containing one or more zeros are considered to be invalid solutions. You will implement the validation in three different ways to demonstrate different programming techniques: using dictionary, list, and set. # Function Specification 1. **Function Name**: `valid_solution_hashtable(board)` - **Input**: A 9x9 two-dimensional list `board` representing the Sudoku board. - **Output**: A boolean value `True` if the board is a valid Sudoku solution, `False` otherwise. 2. **Function Name**: `valid_solution(board)` - **Input**: A 9x9 two-dimensional list `board` representing the Sudoku board. - **Output**: A boolean value `True` if the board is a valid Sudoku solution, `False` otherwise. 3. **Function Name**: `valid_solution_set(board)` - **Input**: A 9x9 two-dimensional list `board` representing the Sudoku board. - **Output**: A boolean value `True` if the board is a valid Sudoku solution, `False` otherwise. # Example ```python board1 = [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ] board2 = [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 0, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ] print(valid_solution_hashtable(board1)) #=> True print(valid_solution_hashtable(board2)) #=> False print(valid_solution(board1)) #=> True print(valid_solution(board2)) #=> False print(valid_solution_set(board1)) #=> True print(valid_solution_set(board2)) #=> False ``` **Constraints**: - Each element in the board is an integer between 0 and 9 inclusive. - The board is a 9x9 grid.","solution":"def valid_solution_hashtable(board): Validate the Sudoku board using a hashtable (dictionary). def check_groups(groups): for group in groups: tally = {} for number in group: if number == 0 or number in tally: return False tally[number] = True return True rows = board cols = [[board[row][col] for row in range(9)] for col in range(9)] grids = [ [board[row + i][col + j] for i in range(3) for j in range(3)] for row in range(0, 9, 3) for col in range(0, 9, 3) ] return check_groups(rows) and check_groups(cols) and check_groups(grids) def valid_solution(board): Validate the Sudoku board using lists. def check_groups(groups): for group in groups: if sorted(group) != list(range(1, 10)): return False return True rows = board cols = [[board[row][col] for row in range(9)] for col in range(9)] grids = [ [board[row + i][col + j] for i in range(3) for j in range(3)] for row in range(0, 9, 3) for col in range(0, 9, 3) ] return check_groups(rows) and check_groups(cols) and check_groups(grids) def valid_solution_set(board): Validate the Sudoku board using sets. def check_groups(groups): for group in groups: if set(group) != set(range(1, 10)): return False return True rows = board cols = [[board[row][col] for row in range(9)] for col in range(9)] grids = [ [board[row + i][col + j] for i in range(3) for j in range(3)] for row in range(0, 9, 3) for col in range(0, 9, 3) ] return check_groups(rows) and check_groups(cols) and check_groups(grids)"},{"question":"# Coding Problem: **Title**: Optimized Insertion Sort with Exceptions Handling **Description**: Albert is a software engineer who is aware of the basic implementation of the insertion sort algorithm. However, he needs to enhance it to handle edge cases more gracefully and also optimize performance where possible. Your task is to implement an optimized insertion sort function called `optimized_insertion_sort` that not only sorts the provided list but also manages exceptions for edge cases such as null inputs and handles unique optimization points. **Requirements**: 1. If the input list is `None`, raise a `ValueError` with the message `\\"Input list cannot be None\\"`. 2. Handle empty lists and single-element lists. 3. Sort the list in non-decreasing order. 4. Optimize the number of comparisons through binary search when finding the correct insertion point within the already sorted sublist (Note: You do not need to optimize the shifting of elements). 5. The function must also support a `print_steps` parameter (default: `False`). When `True`, print the list state after each iteration in the insertion sort. **Function Definition**: ```python def optimized_insertion_sort(arr, print_steps=False): Sorts input list `arr` using an optimized version of insertion sort. :param arr: List[int] - A list of integers to be sorted. :param print_steps: bool - Flag to output the list after each insertion iteration. :return: List[int] - Sorted list of integers. :raises: ValueError - If the input list is None. pass ``` **Example Usage**: ```python # Example 1: print(optimized_insertion_sort([4, 3, 2, 1])) # Output: [1, 2, 3, 4] # Example 2: print(optimized_insertion_sort([])) # Output: [] # Example 3: print(optimized_insertion_sort([5], print_steps=True)) # Output: # [5] # [5] # Example 4: try: optimized_insertion_sort(None) except ValueError as e: print(e) # Output: # Input list cannot be None ``` **Constraints**: * The input list will contain up to (10^4) elements. * Each element in the list will be a non-negative integer and can be as large as (10^6).","solution":"def optimized_insertion_sort(arr, print_steps=False): Sorts input list `arr` using an optimized version of insertion sort. :param arr: List[int] - A list of integers to be sorted. :param print_steps: bool - Flag to output the list after each insertion iteration. :return: List[int] - Sorted list of integers. :raises: ValueError - If the input list is None. if arr is None: raise ValueError(\\"Input list cannot be None\\") n = len(arr) if n <= 1: return arr def binary_search(sub_arr, val): Helper function to perform binary search for insertion point. low, high = 0, len(sub_arr) - 1 while low <= high: mid = (low + high) // 2 if sub_arr[mid] <= val: low = mid + 1 else: high = mid - 1 return low for i in range(1, n): key = arr[i] j = i - 1 # Find the correct position by binary search pos = binary_search(arr[:i], key) # Shift elements right to make room for insertion while j >= pos: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if print_steps: print(arr) return arr"},{"question":"Implement a function `decode_string` that decodes an encoded string as per the given format rules: `k[encoded_string]`, where `encoded_string` is repeated exactly `k` times. The input string is always well-formed and does not contain any digits outside the repeat counts. # Function Signature ```python def decode_string(s: str) -> str: ``` # Input - `s`: A string containing the encoded format. # Output - A decoded string. # Constraints - 1 <= len(s) <= 30. - `s` consists of lowercase English letters, digits, and square brackets `[]`. - The repeat count `k` is a positive integer. - The input string `s` is always balanced and well-formed. # Examples ```python assert decode_string(\\"3[a]2[bc]\\") == \\"aaabcbc\\" assert decode_string(\\"3[a2[c]]\\") == \\"accaccacc\\" assert decode_string(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\" ``` # Notes - Ensure to manage nested encoded strings effectively. - Pay attention to input validities, including correct parsing of multi-digit repeat counts. - The function should handle recursive decoding without using any libraries for parsing strings.","solution":"def decode_string(s: str) -> str: def helper(index): decoded_str = [] k = 0 while index < len(s): if s[index].isdigit(): k = k * 10 + int(s[index]) elif s[index] == \'[\': index, decoded_content = helper(index + 1) decoded_str.append(k * decoded_content) k = 0 elif s[index] == \']\': return index, \'\'.join(decoded_str) else: decoded_str.append(s[index]) index += 1 return \'\'.join(decoded_str) return helper(0)"},{"question":"# Coding Assignment **Scenario**: You are developing a data processing pipeline where input data often contains duplicate values. To ensure efficiency and accuracy, you need a robust method to remove these duplicates. Task Write a function `remove_duplicates_optimized` to remove duplicates from an array while maintaining the order of first occurrence of each element. Aim to optimize both time and space complexity, considering the constraints and edge cases mentioned. Function Signature ```python def remove_duplicates_optimized(array): \\" Remove duplicates from an array. Parameters: - array: A list of elements that may contain duplicates. Returns: - A list containing the unique elements from the array, preserving the original order of their first occurrence. ``` Input * `array` (list): The list of elements which may contain duplicates. Elements may be of various data types (integers, strings, boolean). Output * Returns a list containing only unique elements, preserving the order of their first occurrence. Constraints * The input array can have a length up to 10^6. * Focus on optimizing time complexity to O(n). Example ```python # Example 1: input_array = [1, 1, 1, 2, 2, 3, 4, 4, \\"hey\\", \\"hey\\", \\"hello\\", True, True] print(remove_duplicates_optimized(input_array)) # Expected Output: [1, 2, 3, 4, \\"hey\\", \\"hello\\", True] # Example 2: input_array = [1, 2, 3, 4, 5] print(remove_duplicates_optimized(input_array)) # Expected Output: [1, 2, 3, 4, 5] # Example 3: input_array = [] print(remove_duplicates_optimized(input_array)) # Expected Output: [] ``` Notes - Ensure your solution handles edge cases like empty arrays and mixed data types. - Consider performance impacts and optimize where possible.","solution":"def remove_duplicates_optimized(array): Remove duplicates from an array while maintaining the order of first occurrence. Parameters: - array: A list of elements that may contain duplicates. Returns: - A list containing the unique elements from the array, preserving the original order of their first occurrence. seen = set() result = [] for element in array: if element not in seen: seen.add(element) result.append(element) return result"},{"question":"# Question: Frequency-Limited List Reorganization You are given a list of integers `lst` and an integer `N`. Your task is to write a function that reorganizes the list such that each distinct integer appears at most `N` times, while maintaining the original order of elements. Function Signature ```python def reorganize_list(lst: List[int], N: int) -> List[int]: pass ``` # Input * `lst`: A list of integers, where (1 leq text{len(lst)} leq 10^5) and (-10^6 leq text{lst[i]} leq 10^6) * `N`: An integer denoting the maximum allowed occurrences of each element, (1 leq N leq 10^5) # Output * A list containing elements from the original list such that no element appears more than `N` times. # Constraints * The original order of elements must be preserved. * The resulting list should not contain any element more than `N` times. # Examples ```python # Example 1 lst = [1,2,3,1,2,1,2,3] N = 2 # Output: [1, 2, 3, 1, 2, 3] # Example 2 lst = [20, 37, 20, 21] N = 1 # Output: [20, 37, 21] # Example 3 lst = [1,1,3,3,7,2,2,2,2] N = 3 # Output: [1, 1, 3, 3, 7, 2, 2, 2] ``` # Notes * Focus on ensuring optimal time complexity. * Avoid using the naive approach of counting elements inside a loop to prevent performance degradation.","solution":"from typing import List def reorganize_list(lst: List[int], N: int) -> List[int]: count = {} result = [] for num in lst: if num not in count: count[num] = 0 if count[num] < N: result.append(num) count[num] += 1 return result"},{"question":"# Anagram Checker - Optimized Context You are tasked with creating a utility function for a text processing software that checks if two input strings are anagrams, i.e., if they contain the same characters in any order. This is crucial for the software to detect variations in the text due to letter reordering. Task Write a function `optimized_anagram(s1, s2)` that receives two strings and determines if they are anagrams of each other. The function should handle any valid string inputs, including those with uppercase letters and non-alphabetic characters. Input - **Two strings, `s1` and `s2`**: No length constraints; can contain any printable characters. Output - **A boolean**: `True` if the strings are anagrams, otherwise `False`. Constraints & Considerations - Your solution should handle upper and lower case letters as distinct characters. - Non-alphabet characters should be considered in anagram checks as per their ASCII values. - Ensure the solution performs efficiently even for long strings. Example ```python assert optimized_anagram(\\"A gentleman\\", \\"Elegant man!\\") == True assert optimized_anagram(\\"apple\\", \\"peach\\") == False assert optimized_anagram(\\"123\\", \\"321\\") == True assert optimized_anagram(\\"hello\\", \\"billion\\") == False ``` Notes - You may use Python\'s standard libraries. - Consider edge cases where strings are of different lengths or contain spaces, punctuation, or numbers. - Explain any assumptions or preconditions in your comments. Good luck!","solution":"def optimized_anagram(s1, s2): Check if two strings are anagrams of each other. Parameters: s1 (str): First string. s2 (str): Second string. Returns: bool: True if s1 and s2 are anagrams, False otherwise. # If the lengths of the strings are different, they cannot be anagrams if len(s1) != len(s2): return False from collections import Counter # Compare the frequency count of characters in both strings return Counter(s1) == Counter(s2)"},{"question":"# Topological Sort Implementation You are given a directed graph as an adjacency list where each node points to a list of other nodes it has directed edges to. Write a function to perform a topological sort on this graph using Depth-First Search (DFS). If the graph contains a cycle, raise a `ValueError`. Function Signature: ```python def topological_sort(graph: Dict[Any, List[Any]]) -> List[Any]: pass ``` Input: - `graph`: A dictionary representing the directed graph where keys are nodes and values are lists of nodes to which the key node has outgoing edges. Output: - Returns a list of nodes in topologically sorted order. Constraints: - The graph can contain between 1 and 10^5 nodes. - Each node and edge will have a distinct identifier, which can be an integer or a string. - Raise a `ValueError` if the graph contains a cycle. Example: ```python graph = { \'A\': [\'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'E\'], \'D\': [\'F\'], \'E\': [\'H\', \'F\'], \'F\': [], \'G\': [\'E\', \'H\'], \'H\': [] } topological_sort(graph) # Output could be: [\'G\', \'B\', \'D\', \'A\', \'C\', \'E\', \'H\', \'F\'] # (Other valid outputs are possible depending on the order of traversal) ``` Notes: - The input graph is guaranteed to be directed. - Outputs can have multiple correct answers due to different valid topological orderings.","solution":"def topological_sort(graph): Perform a topological sort on a directed graph using DFS. :param graph: dict representing the directed graph where keys are nodes and values are lists of nodes to which the key node has outgoing edges. :returns: list of nodes in topologically sorted order. :raises ValueError: if the graph contains a cycle. visited = {} result = [] temp_mark = set() def dfs(node): if node in temp_mark: raise ValueError(\\"Graph contains a cycle\\") if node not in visited: temp_mark.add(node) for neighbor in graph.get(node, []): dfs(neighbor) temp_mark.remove(node) visited[node] = True result.append(node) for node in graph: if node not in visited: dfs(node) return result[::-1]"},{"question":"You are tasked with writing a function that converts an integer to its Roman numeral representation. The function should adhere to the standard Roman numeral conventions and be efficient. # Requirements * Implement a function `int_to_roman(num: int) -> str` that converts an integer to a Roman numeral. * The input number is guaranteed to be in the range from 1 to 3999. # Input * An integer `num` within the range [1, 3999]. # Output * A string representing the Roman numeral equivalent of the input integer. # Constraints * The input will be a valid integer within the range [1, 3999]. * You must adhere to the standard Roman numeral conventions for representation. # Example 1. **Input**: `3` **Output**: `\\"III\\"` 2. **Input**: `4` **Output**: `\\"IV\\"` 3. **Input**: `9` **Output**: `\\"IX\\"` 4. **Input**: `58` **Output**: `\\"LVIII\\"` 5. **Input**: `1994` **Output**: `\\"MCMXCIV\\"` # Additional Notes * Roman numerals are usually written largest to smallest from left to right. * The numeral for four is not \\"IIII\\"; instead, the number four is written as \\"IV\\". * The numeral for nine is not \\"VIIII\\"; instead, the number nine is written as \\"IX\\". * Use combinations of these symbols when constructing Roman numerals: * I, V, X, L, C, D, M. # Hint Think about using combined symbols for thousands, hundreds, tens, and units separately and concatenate them to get the final result.","solution":"def int_to_roman(num): Convert an integer to a Roman numeral. :param num: Integer in the range from 1 to 3999 :return: Roman numeral representation as a string val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_numeral = \'\' for i in range(len(val)): count = num // val[i] roman_numeral += syb[i] * count num -= val[i] * count return roman_numeral"},{"question":"# Shell Sort Coding Question Scenario Imagine you are tasked with developing a software module to sort a list of product prices for an online store. Your goal is to implement the Shell Sort algorithm to sort these prices efficiently. Considering the diverse range of prices, your implementation should optimize for both small and medium-sized arrays. Task Description Implement a function `shell_sort(arr: List[int]) -> List[int]` that sorts a given list of integers representing product prices in ascending order using the Shell Sort algorithm. Input Format * A list of integers `arr` where `1 ≤ len(arr) ≤ 10^4` and each element `0 ≤ arr[i] ≤ 10^6`. Output Format * Return a list of integers sorted in ascending order. Constraints * Your implementation must use the Shell Sort algorithm. * Focus on optimizing the algorithm using a suitable gap sequence for better efficiency. * Your solution should handle edge cases like empty lists or lists that are already sorted. Performance Requirements * Aim to achieve a performance better than O(n^2) for most practical input sizes, potentially leveraging more sophisticated gap sequences. Function Signature ```python from typing import List def shell_sort(arr: List[int]) -> List[int]: # Your code here pass ``` Example ```python assert shell_sort([23, 12, 1, 8, 34, 54, 2, 3]) == [1, 2, 3, 8, 12, 23, 34, 54] assert shell_sort([]) == [] assert shell_sort([4, 1, 3, 9, 6]) == [1, 3, 4, 6, 9] ``` Implement the Shell Sort function adhering to the guidelines and constraints mentioned above.","solution":"from typing import List def shell_sort(arr: List[int]) -> List[int]: Sorts a list of integers in ascending order using the Shell Sort algorithm. n = len(arr) gap = n // 2 # Generate the gap sequence and perform insertion sort while gap > 0: for i in range(gap, n): temp = arr[i] j = i # Perform gapped insertion sort while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 return arr"},{"question":"Scenario You are developing a feature for an analytics tool that processes event logs. A common operation is to find the most recent occurrence of a specific event. Given that events are sorted in chronological order, your task is to create a function that efficiently finds the last occurrence of an event code in the sorted list of logs. Task Implement a function `last_occurrence(logs, event_code)` that identifies the index of the last occurrence of `event_code` in the sorted list `logs`. Input Format - `logs` (List[int]): A sorted list of integers representing event codes. - `event_code` (int): The event code to find in the log. Output Format - (int): The index of the last occurrence of `event_code` in `logs`. If `event_code` is not found, return `-1`. Constraints - The list `logs` is sorted in ascending order. - The list `logs` can contain up to (10^6) elements. - Event codes are integer values in the range [-10^6, 10^6]. Example ```python # Example 1 logs = [1, 2, 2, 2, 3, 4, 5] event_code = 2 # Output: 3 # Example 2 logs = [1, 2, 2, 2, 3, 4, 5] event_code = 6 # Output: -1 # Example 3 logs = [] event_code = 2 # Output: -1 ``` Constraints: * Optimize for O(log n) time complexity using binary search principles. * Ensure your solution handles edge cases appropriately.","solution":"def last_occurrence(logs, event_code): Finds the index of the last occurrence of event_code in the sorted list logs. Parameters: logs (List[int]): A sorted list of integers representing event codes. event_code (int): The event code to find in the log. Returns: int: The index of the last occurrence of event_code in the logs, or -1 if not found. left, right = 0, len(logs) - 1 result = -1 while left <= right: mid = (left + right) // 2 if logs[mid] == event_code: result = mid left = mid + 1 # Continue searching to the right elif logs[mid] < event_code: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Context: You\'re tasked with implementing a flexible platform for managing task priorities. For this, you need an efficient data structure to handle dynamic insertion and removal of tasks based on their priority levels. The tasks must be quickly accessible and modifiable to ensure smooth functioning. # Task: Implement the **BinaryHeap** class to maintain a minimum heap property. You will use the heap to manage task priorities, where each task has a priority level, and lower values signify higher priority. # Requirements: 1. **Insert a Task**: Add a task to the heap ensuring that the min-heap property is maintained. 2. **Remove the Minimum Task**: Remove and return the task with the highest priority from the heap. 3. **Peek Minimum Task**: Return the task with the highest priority without removing it. # Implementation: 1. Implement the `insert` method to add a new task. 2. Implement the `remove_min` method to remove the highest priority task. 3. Implement the `peek_min` method to return the highest priority task. # Expected Input/Output: * **insert(task_priority: int)**: * Input: Integer `task_priority` which represents the priority of the task to be inserted. * Output: None * **remove_min() -> int**: * Input: None * Output: Integer representing the priority of the removed task. * **peek_min() -> int**: * Input: None * Output: Integer representing the priority of the highest-priority task (without removing it). **Constraints**: * The heap can handle up to 10^5 tasks. * Task priority values are integers within the range [1, 10^6]. # Example: Operations: 1. insert(3) 2. insert(10) 3. insert(1) 4. remove_min() -> 1 5. insert(5) 6. peek_min() -> 3 ```python class BinaryHeap(AbstractHeap): def __init__(self): self.current_size = 0 self.heap = [(0)] def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i//2] = self.heap[i//2], self.heap[i] i = i // 2 def insert(self, val): pass # Implement this def min_child(self, i): if 2 * i + 1 > self.current_size: return 2 * i if self.heap[2 * i] > self.heap[2 * i + 1]: return 2 * i + 1 return 2 * i def perc_down(self, i): while 2 * i <= self.current_size: min_child = self.min_child(i) if self.heap[i] > self.heap[min_child]: self.heap[i], self.heap[min_child] = self.heap[min_child], self.heap[i] i = min_child def remove_min(self): pass # Implement this def peek_min(self): pass # Implement this ``` # Notes: * Ensure efficiency in implementation. * Handle edge cases like empty heap scenarios appropriately.","solution":"class BinaryHeap: def __init__(self): self.current_size = 0 self.heap = [0] def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i//2] = self.heap[i//2], self.heap[i] i = i // 2 def insert(self, val): self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def min_child(self, i): if 2 * i + 1 > self.current_size: return 2 * i if self.heap[2 * i] > self.heap[2 * i + 1]: return 2 * i + 1 return 2 * i def perc_down(self, i): while 2 * i <= self.current_size: min_child = self.min_child(i) if self.heap[i] > self.heap[min_child]: self.heap[i], self.heap[min_child] = self.heap[min_child], self.heap[i] i = min_child def remove_min(self): if self.current_size == 0: return None root = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() self.perc_down(1) return root def peek_min(self): if self.current_size == 0: return None return self.heap[1]"},{"question":"# Problem Description You are given a positive integer `n`. The task is to find the nth digit of the infinite integer sequence [1, 2, 3, ... ]. # Function Signature ```python def find_nth_digit(n: int) -> int: ``` # Input - `n` (1 ≤ n ≤ 2 * 10^9): A positive integer representing the position in the infinite sequence. # Output - Return a single integer representing the nth digit of the sequence. # Constraints - Handle single and multiple-digit numbers properly. - Ensure optimal performance within the given constraints. # Examples ```python print(find_nth_digit(3)) # Output: 3 print(find_nth_digit(11)) # Output: 0 print(find_nth_digit(190))# Output: 1 print(find_nth_digit(1000))# Output: 3 ``` # Detailed Explanation For `find_nth_digit(11)`, the sequence starts with: ``` 1, 2, 3, 4, 5, 6, 7, 8, 9, 1(0), 11, 12, ... ``` The 11th digit is `0`. **Hint**: Use the lengths of numbers (`1-9`, `10-99`, ... ) and decrement `n` by the corresponding digit length products until you narrow down to the exact target digit. # Considerations - Ensure the function handles edge cases such as `n = 1`, large values of `n`, and boundaries between different digit lengths. - Aim for a solution that is efficient in both time and space complexity.","solution":"def find_nth_digit(n: int) -> int: # Initialize the length group parameters length = 1 count = 9 start = 1 # Determine the range in the infinite sequence where the n-th digit lies while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Find the exact number that contains the n-th digit start += (n - 1) // length # Find the exact digit in the number return int(str(start)[(n - 1) % length])"},{"question":"# Maximum Network Flow Challenge Context You are working as a network engineer and have been tasked with optimizing the transportation of goods over a network of pipelines. Each pipeline has a maximum capacity indicating the maximum flow of goods it can handle per unit time. Your objective is to determine the maximum flow from the source to the sink nodes in the network. Task Implement a function to compute the maximum flow in a network using Dinic\'s algorithm. The network is represented by a capacity matrix where `capacity[i][j]` represents the maximum flow from node `i` to node `j`. Your task is to ensure the correct computation by leveraging the Dinic\'s algorithm approach as outlined in the provided snippets. Function Signature ```python def max_flow_dinics(capacity: List[List[int]], source: int, sink: int) -> int: pass ``` Input 1. `capacity`: A two-dimensional list representing the capacity of each edge in the network. 2. `source`: An integer representing the source node. 3. `sink`: An integer representing the sink node. Output An integer representing the maximum flow from the source to the sink in the given capacity network. Constraints * 1 <= number of nodes <= 500 * 0 <= capacity[i][j] <= 1,000,000 * `source` and `sink` will always be valid nodes within the range of the number of nodes. * The network may have cycles, but no self-loops (e.g., `capacity[i][i] = 0`). Example ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 print(max_flow_dinics(capacity, source, sink)) # Output should be 23 ``` Note: Ensure your implementation is efficient and can handle the upper limits of nodes and capacity values as specified in the constraints.","solution":"from typing import List from collections import deque def bfs_level_graph(capacity, level, source, sink): queue = deque([source]) level[source] = 0 while queue: u = queue.popleft() for v in range(len(capacity)): if level[v] < 0 and capacity[u][v] > 0: level[v] = level[u] + 1 queue.append(v) if v == sink: return True return False def send_flow(u, flow, sink, level, capacity, start): if u == sink: return flow while start[u] < len(capacity): v = start[u] if level[v] == level[u] + 1 and capacity[u][v] > 0: current_flow = min(flow, capacity[u][v]) temp_flow = send_flow(v, current_flow, sink, level, capacity, start) if temp_flow > 0: capacity[u][v] -= temp_flow capacity[v][u] += temp_flow return temp_flow start[u] += 1 return 0 def max_flow_dinics(capacity: List[List[int]], source: int, sink: int) -> int: total_flow = 0 n = len(capacity) while True: level = [-1] * n if not bfs_level_graph(capacity, level, source, sink): break start = [0] * n while True: flow = send_flow(source, float(\'Inf\'), sink, level, capacity, start) if flow <= 0: break total_flow += flow return total_flow"},{"question":"You\'re given an array `nums` of positive integers and an integer `target`, your task is to implement the function: ```python def num_combinations(nums, target): Args: nums: List[int] -- list of positive integers without duplicates target: int -- target sum to achieve with combinations of elements from nums Returns: int -- number of possible combinations that add up to target pass ``` The function should return the number of possible combinations that add up to `target`, where different sequences are considered distinct. For instance, given `nums = [1, 2, 3]` and `target = 4`, the possible combination ways are: - (1, 1, 1, 1) - (1, 1, 2) - (1, 2, 1) - (1, 3) - (2, 1, 1) - (2, 2) - (3, 1) Therefore the function should return `7`. Constraints: 1. The length of `nums` will be in the range [1, 50]. 2. The values in `nums` will be in the range [1, 100]. 3. The value of `target` will be in the range [1, 1000]. # Follow-up Questions: 1. How would you modify your approach if negative numbers are allowed in the `nums` array? 2. What limitations need to be added to ensure correct implementation if negatives are allowed? # Example ```python nums = [1, 2, 3] target = 4 print(num_combinations(nums, target)) # Output: 7 ```","solution":"def num_combinations(nums, target): Args: nums: List[int] -- list of positive integers without duplicates target: int -- target sum to achieve with combinations of elements from nums Returns: int -- number of possible combinations that add up to target dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for num in nums: if i - num >= 0: dp[i] += dp[i - num] return dp[target]"},{"question":"You are tasked with enhancing a simple compression algorithm, Run-Length Encoding (RLE). Implement both the encoding and decoding functions of this algorithm. Your implementation should follow the principles of the existing RLE methods, but also incorporate handling of edge cases and any improvements you deem necessary. **Function Specifications**: 1. **Function name**: `encode_rle` - **Input**: A string `input` containing the data to be encoded. - **Output**: A string representing the encoded data. 2. **Function name**: `decode_rle` - **Input**: A string `input` containing the encoded data. - **Output**: A string representing the decoded original data. **Constraints and Performance Requirements**: - The input string length will not exceed 10⁵ characters. - Handle cases with repeated and distinct characters. - Ensure that encoding and decoding operations are efficient. **Scenario**: Imagine you are working with an old system that uses a limited bandwidth to transmit data. To optimize the transmission, you decide to use Run-Length Encoding. Implement the encoding and decoding functions to facilitate this data compression and decompression. # Sample Input/Output: **Sample Input 1**: ```python input = \\"aaabbbcccca\\" encoded = encode_rle(input) print(encoded) # Expected Output: \\"3a3b4c1a\\" decoded = decode_rle(encoded) print(decoded) # Expected Output: \\"aaabbbcccca\\" ``` **Sample Input 2**: ```python input = \\"abcd\\" encoded = encode_rle(input) print(encoded) # Expected Output: \\"1a1b1c1d\\" decoded = decode_rle(encoded) print(decoded) # Expected Output: \\"abcd\\" ``` Write your code in Python following the specifications and constraints mentioned above.","solution":"def encode_rle(input): Encodes the input string using Run-Length Encoding (RLE). Parameters: input (str): The string to be encoded. Returns: str: The Run-Length Encoded string. if not input: return \\"\\" encoded = [] count = 1 prev_char = input[0] for char in input[1:]: if char == prev_char: count += 1 else: encoded.append(f\\"{count}{prev_char}\\") prev_char = char count = 1 encoded.append(f\\"{count}{prev_char}\\") return \'\'.join(encoded) def decode_rle(input): Decodes the input string from its Run-Length Encoded form. Parameters: input (str): The Run-Length Encoded string. Returns: str: The original decoded string. if not input: return \\"\\" decoded = [] count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) else: decoded.append(char * count) count = 0 return \'\'.join(decoded)"},{"question":"# Question Title: Implement and Optimize Gnome Sort You are tasked with sorting an array using the Gnome Sort algorithm, and your goal is to not only implement it but also improve its average-case performance while maintaining its simplicity and in-place nature. Problem Statement: Write a function `optimized_gnome_sort(arr)` that sorts an array of integers in non-decreasing order using an optimized version of Gnome Sort. Function Signature: ```python def optimized_gnome_sort(arr: List[int]) -> List[int]: ``` Input: * `arr`: A list of integers, which can contain duplicate values. The list can be empty or have up to 1000 elements. Output: * Returns a list of integers sorted in non-decreasing order. Constraints: * The function must use principles of Gnome Sort but with enhanced average-case performance. Examples: ```python assert optimized_gnome_sort([34, 2, 10, -9]) == [-9, 2, 10, 34] assert optimized_gnome_sort([5, 3, 2, 2, 3, 1]) == [1, 2, 2, 3, 3, 5] assert optimized_gnome_sort([]) == [] assert optimized_gnome_sort([1]) == [1] ``` Notes: Implementing optimizations might involve: * Limiting unnecessary comparisons. * Reducing the number of swaps. Explain briefly any optimizations you implement in comments within your code.","solution":"from typing import List def optimized_gnome_sort(arr: List[int]) -> List[int]: Sorts the array using an optimized version of Gnome Sort algorithm. n = len(arr) index = 0 while index < n: if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: # Swap elements if they are out of order arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"Context: In software systems where different modules depend on each other, it\'s crucial to ensure there are no cyclic dependencies that could lead to deadlocks or halts. Hence, detecting such cycles in dependency graphs becomes critical. Problem Statement: Given a directed graph representing dependencies between software modules, write an efficient function to determine if there is a cycle. You should implement the following function: ```python def detect_cycle_in_dependencies(dependency_graph): Determines if there is a cycle in the provided dependency graph. :param dependency_graph: A dictionary representing a directed graph. Keys are nodes and values are lists of nodes representing dependencies. :return: True if there is at least one cycle, otherwise False. pass ``` Input: - `dependency_graph`: A dictionary where keys are nodes (module names) and values are lists of nodes that the key node depends on. Output: - Return `True` if the graph contains a cycle, otherwise return `False`. Constraints: - The graph will have at least one node. - Node names will be unique strings. - Dependence is directional, meaning if `A` depends on `B`, it doesn’t imply `B` depends on `A`. Examples: ```python # Example 1 dependency_graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(detect_cycle_in_dependencies(dependency_graph)) # Output: True # Example 2 dependency_graph = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'D\'], \'D\': [] } print(detect_cycle_in_dependencies(dependency_graph)) # Output: False ``` Additional Notes: - Consider adding necessary helper functions and imports. - You may use the template provided in the initial analysis snippet for reference but should not directly copy it; instead, aim for a self-contained implementation. Expected Performance: - Ensure the solution can handle cases up to 10^4 nodes and 10^5 edges efficiently.","solution":"def detect_cycle_in_dependencies(dependency_graph): Determines if there is a cycle in the provided dependency graph. :param dependency_graph: A dictionary representing a directed graph. Keys are nodes and values are lists of nodes representing dependencies. :return: True if there is at least one cycle, otherwise False. visited = set() rec_stack = set() def has_cycle(v): visited.add(v) rec_stack.add(v) for neighbor in dependency_graph.get(v, []): if neighbor not in visited: if has_cycle(neighbor): return True elif neighbor in rec_stack: return True rec_stack.remove(v) return False for node in dependency_graph: if node not in visited: if has_cycle(node): return True return False"},{"question":"As an experienced software developer, you are tasked with developing a customized sorting function for a specific application that requires a modified sorting mechanism. Given an array of integers, implement a function called `custom_exchange_sort` which follows a modified version of the exchange sort algorithm provided above. The modified version should sort the array in descending order while applying an optimization to reduce unnecessary comparisons: 1. After each pass through the outer loop, avoid comparing already sorted elements. 2. The sorting should be done \'in place\' without using extra memory. # Function Signature ```python def custom_exchange_sort(arr: List[int]) -> List[int]: ``` # Input - A list of integers `arr` of length `n` where 1 ≤ n ≤ 10^5 and -10^9 ≤ arr[i] ≤ 10^9. # Output - The function should return the sorted list in descending order. # Constraints - The function should sort the list without consuming extra memory. - The function should handle large arrays efficiently within the given constraints. # Performance Requirements - Aim for an effective sorting even though the algorithm has an inherent time complexity of O(n^2). # Examples # Example 1: ```python custom_exchange_sort([64, 34, 25, 12, 22, 11, 90]) ``` Output: ```python [90, 64, 34, 25, 22, 12, 11] ``` # Example 2: ```python custom_exchange_sort([1, 1, 1, 1, 1]) ``` Output: ```python [1, 1, 1, 1, 1] ``` # Example 3: ```python custom_exchange_sort([-1, 4, 0, -10, 8, 7]) ``` Output: ```python [8, 7, 4, 0, -1, -10] ``` # Notes - Ensure your solution is efficient and adheres to the provided constraints and requirements. - Provide edge case handling to cover possible inputs appropriately.","solution":"from typing import List def custom_exchange_sort(arr: List[int]) -> List[int]: n = len(arr) for i in range(n-1): swapped = False for j in range(n-1, i, -1): if arr[j] > arr[j-1]: arr[j], arr[j-1] = arr[j-1], arr[j] swapped = True if not swapped: break return arr"},{"question":"You are given an undirected graph represented by a node. Each node in this graph contains a unique label and a list of its neighbors. The graph may contain self-loops (edges from a node to itself) and may be disconnected (not all nodes are reachable from each other). Your task is to implement a function that creates and returns a deep copy of this graph using an efficient graph traversal technique. **Function Signature**: ```python def clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': pass ``` # Input: - `node`: The starting node of the undirected graph. It can be `None` if the graph is empty. # Output: - The function must return the starting node of the copied graph. # Constraints: - Nodes are uniquely labeled. - The graph can have up to `1000` nodes. - Each node can have up to `100` neighbors. # Requirements: 1. Present all code within the function. 2. Use a graph traversal technique (BFS or DFS) to ensure that all nodes and edges are correctly copied. 3. Ensure that the copy maintains the same connections (including cycles) as the original graph. 4. Your solution must be efficient and handle edge cases such as nodes with no neighbors, self-loops, and disconnected components. # Example: Here\'s an example of how the graph might be represented and how your function should work. Consider the graph: ``` 1 / / 0 --- 2 / _/ ``` 1. Node `0` is connected to nodes `1` and `2`. 2. Node `1` is connected to node `2`. 3. Node `2` is connected to itself (self-loop). If the input node represents node `0`, your function should return the starting node of a new graph which is an exact copy of the original one. Ensure your solution handles the following scenarios: 1. Empty graph (`node` is `None`). 2. Graph with self-loops. 3. Graph with multiple disconnected components. # Note: - You may not use any external libraries or modules other than `collections.deque`. Provide your implementation for the `clone_graph` function below: ```python def clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': # Write your implementation here pass ```","solution":"class UndirectedGraphNode: def __init__(self, label: int): self.label = label self.neighbors = [] def clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': if not node: return None node_map = {} def dfs(node): if node in node_map: return node_map[node] copy = UndirectedGraphNode(node.label) node_map[node] = copy for neighbor in node.neighbors: copy.neighbors.append(dfs(neighbor)) return copy return dfs(node)"},{"question":"**RSA Key Generation and Encryption-Decryption** **Objective**: Implement the missing part of the RSA encryption-decryption system and ensure correct functionality by generating RSA keys, and using them to encrypt and decrypt data. **Scenario**: You are developing a system for secure communication between clients and servers. Your task is to expand the provided RSA implementation to cover key generation, encryption, and decryption comprehensively. **Detailed Requirements**: 1. Implement the RSA key pair generation. - Use dedicated functions to generate large prime numbers. - Ensure the encryption and decryption key pair is mathematically valid and secure. 2. Implement functions for: - `encrypt(data, e, n)`: Encrypts provided data using key `e`, `n`. - `decrypt(data, d, n)`: Decrypts provided data using key `d`, `n`. **Function Specifications**: 1. **generate_key(k, seed=None)**: - **Input**: * `k` (int): Number of bits for the modulus `n`. * `seed` (optional int): Seed for random number generation for reproducibility. - **Output**: * A tuple `(n, e, d)`: RSA public modulus `n`, public exponent `e`, and private exponent `d`. 2. **encrypt(data, e, n)**: - **Input**: * `data` (int/str): The data to encrypt. * `e` (int): The public encryption key. * `n` (int): The public modulus. - **Output**: * `encrypted_data` (int): The encrypted data. 3. **decrypt(encrypted_data, d, n)**: - **Input**: * `encrypted_data` (int): The data to decrypt. * `d` (int): The private decryption key. * `n` (int): The public modulus. - **Output**: * `data` (int/str): The decrypted data. **Performance Requirements**: * Ensure that the key generation can handle RSA keys with a minimum bit-length of 512. * Use efficient algorithms wherever possible (e.g., Extended Euclidean for inverse, Miller-Rabin for prime testing). **Constraints**: * `k` should be no less than 512. * Prime number generation should use efficient checks. **Examples**: 1. **Key Generation and Encryption/Decryption**: ```python n, e, d = generate_key(512) data = 12345 encrypted_data = encrypt(data, e, n) decrypted_data = decrypt(encrypted_data, d, n) assert decrypted_data == data ``` Ensure your implementation correctly adheres to the RSA algorithm principles and security requirements.","solution":"import random from math import gcd from sympy import isprime def generate_prime(bits): Generate a prime number with the given number of bits. while True: p = random.getrandbits(bits) if isprime(p): return p def modinv(a, m): Return the modular inverse of a modulo m. m0, x0, x1 = m, 0, 1 if m == 1: return 0 while a > 1: q = a // m m, a = a % m, m x0, x1 = x1 - q * x0, x0 if x1 < 0: x1 += m0 return x1 def generate_key(k, seed=None): Generate RSA public and private keys. Args: - k (int): Number of bits for the modulus n. - seed (optional int): Seed for random generation. Returns: - (n, e, d): Tuple of RSA modulus n, public exponent e, and private exponent d. if seed: random.seed(seed) # Generate two distinct prime numbers, p and q p = generate_prime(k // 2) q = generate_prime(k // 2) while q == p: q = generate_prime(k // 2) n = p * q phi = (p - 1) * (q - 1) # Choose e such that 1 < e < phi and gcd(e, phi) = 1 e = 65537 # Common value for e in RSA while gcd(e, phi) != 1: e = random.randrange(2, phi) # Compute d, the modular multiplicative inverse of e modulo phi d = modinv(e, phi) return n, e, d def encrypt(data, e, n): Encrypt data using RSA public key (e, n). Args: - data (int): Data to encrypt. - e (int): Public exponent. - n (int): Modulus. Returns: - int: Encrypted data. return pow(data, e, n) def decrypt(encrypted_data, d, n): Decrypt data using RSA private key (d, n). Args: - encrypted_data (int): Data to decrypt. - d (int): Private exponent. - n (int): Modulus. Returns: - int: Decrypted data. return pow(encrypted_data, d, n)"},{"question":"# Scenario: You are tasked with developing a highly efficient code for finding the start and end indices of a target value within a sorted array. This array can contain duplicate elements. The goal is to leverage binary search to reduce search time complexity. # Problem Statement You are given an array of integers `nums` sorted in ascending order and an integer `target`. Your task is to return an array of the starting and ending position of the given `target` value. If the target is not found in the array, return `[-1, -1]`. # Input * A list of integers `nums`, sorted in ascending order. * An integer `target`. # Output * A list of two integers representing the starting and ending positions of the target value in the sorted array. If the target is not found, return `[-1, -1]`. # Constraints * The array can contain up to `10^5` integers. * Elements in `nums` are in the range of `[-10^9, 10^9]`. * The `target` is also within the range `[-10^9, 10^9]`. # Performance Requirement * The solution should aim for an optimal performance with a combination of binary search and linear-time complexity segment for the worst case scenario. # Example * Input: `nums = [5,7,7,8,8,8,10]`, `target = 8` * Output: `[3, 5]` * Input: `nums = [5,7,7,8,8,8,10]`, `target = 11` * Output: `[-1, -1]` # Task Implement the function `search_range(nums, target)` which takes the sorted array `nums` and an integer `target` as inputs and returns the starting and ending positions of the target. # Notes * Ensure your solution accounts for edge cases and optimizes performance. * Do not use pre-defined library functions to directly get the result. ```python def search_range(nums, target): :type nums: List[int] :type target: int :rtype: List[int] # Implement your optimized solution here ```","solution":"def search_range(nums, target): def find_left_most(): left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] < target: left = mid + 1 else: right = mid - 1 return left def find_right_most(): left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid - 1 return right left_most = find_left_most() if left_most >= len(nums) or nums[left_most] != target: return [-1, -1] right_most = find_right_most() return [left_most, right_most]"},{"question":"ZigZag Iterator Enhancement You are tasked with extending the functionality of the `ZigZagIterator` to handle any number of input lists instead of just two. The iterator should still function in a zigzag manner, but it needs to be generalized to handle multiple lists. It should alternate between lists in a round-robin fashion until all lists are exhausted. # Objective Implement a class `GeneralZigZagIterator` that takes multiple lists and iterates over them in a zigzag order. # Implementation Details - **Class Name**: `GeneralZigZagIterator` - **Constructor**: ```python def __init__(self, lists: List[List[int]]): Initialize your data structure here. :type lists: List[List[int]] pass ``` - **Methods**: ```python def next(self) -> int: :rtype: int pass def has_next(self) -> bool: :rtype: bool pass ``` # Constraints - Each list provided as input may contain between 0 and 1000 elements. - The elements of each list are integers within the range [0, 10000]. - The total number of input lists will not exceed 100. # Example ```python lists = [[1, 2], [3, 4, 5, 6], [7, 8, 9]] iterator = GeneralZigZagIterator(lists) result = [] while iterator.has_next(): result.append(iterator.next()) print(result) # Output: [1, 3, 7, 2, 4, 8, 5, 9, 6] ``` # Implementation Notes - Ensure the `GeneralZigZagIterator` handles varying lengths of lists. - Your implementation should not assume all lists have elements remaining while iterating. - You may utilize additional data structures to maintain state as needed.","solution":"from collections import deque from typing import List class GeneralZigZagIterator: def __init__(self, lists: List[List[int]]): Initialize your data structure here. :type lists: List[List[int]] # Filter out empty lists and zip with their respective iterator self.queue = deque((iter(lst), len(lst)) for lst in lists if lst) def next(self) -> int: :rtype: int if self.queue: current_iter, current_len = self.queue.popleft() value = next(current_iter) current_len -= 1 if current_len: self.queue.append((current_iter, current_len)) return value else: raise StopIteration def has_next(self) -> bool: :rtype: bool return bool(self.queue)"},{"question":"# 0/1 Knapsack Problem with Optimized Dynamic Programming You are given a set of items, each with a specific value and weight, and a knapsack with a fixed capacity. Your task is to implement a function that determines the maximum value of items that can be placed into the knapsack without exceeding its capacity. Function Signature ```python def get_maximum_value(items, capacity): items: List[Item] - A list of items, each with a \'value\' and \'weight\' attribute. capacity: int - The maximum weight the knapsack can carry. Returns: int - The maximum value achievable with the given items and knapsack capacity. ``` Input * `items` - A list where each element is an instance of the `Item` class, which has two attributes: * `value` (an integer) - The value of the item. * `weight` (an integer) - The weight of the item. * `capacity` - An integer representing the maximum capacity of the knapsack. Output * An integer representing the maximum summarized value of items that can be put in the knapsack. Constraints 1. The number of items `n` is in the range [1, 100]. 2. The capacity `m` of the knapsack is in the range [1, 10^4]. 3. Values and weights are positive integers. Performance Requirements Your solution should efficiently handle the upper limits of input sizes. Example ```python from typing import List class Item: def __init__(self, value, weight): self.value = value self.weight = weight def get_maximum_value(items: List[Item], capacity: int) -> int: # Your implementation here pass # Example 1: capacity = 5 items = [Item(60, 5), Item(50, 3), Item(70, 4), Item(30, 2)] print(get_maximum_value(items, capacity)) # Output: 80 # Example 2: capacity = 10 items = [Item(20, 2), Item(50, 3), Item(30, 4)] print(get_maximum_value(items, capacity)) # Output: 70 ``` **Note**: Ensure that you handle edge cases such as an empty item list (`items = []`) and zero knapsack capacity (e.g., `capacity = 0`).","solution":"from typing import List class Item: def __init__(self, value, weight): self.value = value self.weight = weight def get_maximum_value(items: List[Item], capacity: int) -> int: This function finds the maximum value that can be placed into the knapsack with the given capacity by using the 0/1 Knapsack dynamic programming approach. n = len(items) # Initialize a list to store the maximum value for each capacity up to \'capacity\' dp = [0] * (capacity + 1) for item in items: # Traverse dp array from right to left to consider the same item only once for weight in range(capacity, item.weight - 1, -1): dp[weight] = max(dp[weight], dp[weight - item.weight] + item.value) return dp[capacity]"},{"question":"Enhanced Exchange Sort Context You are a software engineer tasked to enhance an existing sorting algorithm to make it more efficient while retaining its simplicity. The current implementation is as follows: ```python def exchange_sort(arr): Reference : https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort Complexity : O(n^2) arr_len = len(arr) for i in range(arr_len-1): for j in range(i+1, arr_len): if(arr[i] > arr[j]): arr[i], arr[j] = arr[j], arr[i] return arr ``` Task Modify the existing `exchange_sort` function to improve its efficiency by adding an early exit mechanism, which stops the sorting process if the array is already sorted before finishing all iterations. Requirements * **Function Signature**: `def exchange_sort_enhanced(arr: list) -> list` * **Input**: A list of integers, `arr`. * **Output**: The sorted list of integers in ascending order. * **Constraints**: * The function should return a sorted list with an optimized number of comparisons. * Do not use built-in sorting functions. * Maintain O(1) space complexity, i.e., sort the array in place. Edge Cases Consider and handle the following scenarios: * An empty array. * An array with one element. * An already sorted array. * An array with elements sorted in descending order. Example ```python assert exchange_sort_enhanced([]) == [] assert exchange_sort_enhanced([1]) == [1] assert exchange_sort_enhanced([3, 2, 1]) == [1, 2, 3] assert exchange_sort_enhanced([1, 2, 3]) == [1, 2, 3] assert exchange_sort_enhanced([5, 2, 9, 1, 5, 6]) == [1, 2, 5, 5, 6, 9] ```","solution":"def exchange_sort_enhanced(arr): Enhanced Exchange Sort with early exit mechanism. arr_len = len(arr) for i in range(arr_len - 1): swapped = False for j in range(i + 1, arr_len): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] swapped = True # If no elements were swapped in the inner loop, the array is sorted if not swapped: break return arr"},{"question":"You are given a list of integers and a target value. Your task is to write a function that searches for the first occurrence of the target value in the list and returns its index. If the target value is not found, the function should return -1. The list can contain any integer values, positive or negative, and is not sorted in any particular order. # Function Signature ```python def find_target_index(nums: List[int], target: int) -> int: ``` # Input * `nums` (List[int]): A list of integers, where `0 <= len(nums) <= 10^6`. * `target` (int): An integer that is the target value to search for. # Output * Returns the index of the first occurrence of `target` in `nums`, or `-1` if `target` is not found. # Constraints * The function should have a time complexity of O(n). # Examples ```python assert find_target_index([1, 2, 3, 4, 5], 3) == 2 assert find_target_index([5, 4, 3, 2, 1], 5) == 0 assert find_target_index([1, 2, 3, 1, 2, 3], 3) == 2 assert find_target_index([1, 2, 3], 4) == -1 assert find_target_index([], 1) == -1 ``` # Notes * Consider edge cases such as an empty list or the target not being present in the list. * Ensure your solution is efficient and handles the maximum input size within the provided constraint.","solution":"from typing import List def find_target_index(nums: List[int], target: int) -> int: Finds the first occurrence of the target value in the list and returns its index. If the target value is not found, returns -1. Parameters: nums (List[int]): A list of integers. target (int): The target value to search for. Returns: int: The index of the first occurrence of the target value, or -1 if not found. for index, value in enumerate(nums): if value == target: return index return -1"},{"question":"You are tasked with implementing a function to insert a value into its proper position in a sorted array. The function should leverage an efficient search and insertion mechanism to maintain the order. # Function Signature ```python def insert_value(sorted_array: List[int], value: int) -> List[int]: pass ``` # Input * `sorted_array` (List[int]): A list of integers that is sorted in non-decreasing order. * `value` (int): An integer value to be inserted into the array. # Output * Returns a new list of integers that includes the `value` inserted into its proper position, maintaining the sort order. # Constraints * The function should handle arrays of length 0 to 10^6. * The input array will always be sorted. # Performance Requirements * The overall insertion should not exceed O(n) complexity, where n is the number of elements in the array. * Utilize O(1) additional space aside from the input and output lists. # Example Usage ```python assert insert_value([1, 3, 5, 6], 5) == [1, 3, 5, 5, 6] assert insert_value([1, 3, 5, 6], 2) == [1, 2, 3, 5, 6] assert insert_value([1, 3, 5, 6], 7) == [1, 3, 5, 6, 7] assert insert_value([1, 3, 5, 6], 0) == [0, 1, 3, 5, 6] assert insert_value([], 4) == [4] ``` # Notes * Ensure the function handles edge cases such as inserting into an empty array, array with one element, and target values at the boundaries of the current array.","solution":"from typing import List def insert_value(sorted_array: List[int], value: int) -> List[int]: Insert value into its proper position in a sorted array. Parameters: sorted_array (List[int]): A list of sorted integers. value (int): The integer to insert into the sorted list. Returns: List[int]: A new list with the value inserted while maintaining the sort order. # Edge case: if the array is empty, simply return a list with the value if not sorted_array: return [value] # Find the position to insert using binary search for efficiency left, right = 0, len(sorted_array) while left < right: mid = (left + right) // 2 if sorted_array[mid] < value: left = mid + 1 else: right = mid # Create and return a new list with the value inserted return sorted_array[:left] + [value] + sorted_array[left:]"},{"question":"# Heap Sort Implementation Heap Sort is a comparison-based sorting algorithm that uses a binary heap data structure to sort elements. You are required to implement two variants of the heap sort algorithm: 1. **max_heap_sort**: Use this to sort an array in ascending order by repeatedly creating a max heap and moving the largest element to the end of the array each time. 2. **min_heap_sort**: Similar to max_heap_sort but uses a min heap, ensuring the smallest elements bubble to the top and are then incrementally sorted. Your task is to implement both variants of heap sort functions. The given snippets provide you with the implementation context; you need to ensure the functions are complete based on those. Task Implement the following functions: 1. `max_heap_sort(arr: List[int], simulation: bool = False) -> List[int]` 2. `min_heap_sort(arr: List[int], simulation: bool = False) -> List[int]` The `simulation` flag, when set to `True`, should print the state of the array at each significant step of the algorithm. Otherwise, it should sort silently. Input Format - A list of integers `arr`. Output Format - A list of integers sorted in ascending order. Constraints - 1 ≤ len(arr) ≤ 10^5 - -10^6 ≤ arr[i] ≤ 10^6 Example ```python # Example for max_heap_sort arr = [3, 19, 1, 14, 8, 7] sorted_arr = max_heap_sort(arr) print(sorted_arr) # Expected output: [1, 3, 7, 8, 14, 19] # Example for min_heap_sort arr = [3, 19, 1, 14, 8, 7] sorted_arr = min_heap_sort(arr) print(sorted_arr) # Expected output: [1, 3, 7, 8, 14, 19] ``` Note: Do not use any in-built sorting functions for the solution. Implement the sorting mechanism manually as described above.","solution":"from typing import List def max_heapify(arr: List[int], n: int, i: int, simulation: bool = False): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] > arr[largest]: largest = left if right < n and arr[right] > arr[largest]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] if simulation: print(f\\"max_heapify (swap): {arr}\\") max_heapify(arr, n, largest, simulation) def max_heap_sort(arr: List[int], simulation: bool = False) -> List[int]: n = len(arr) for i in range(n // 2 - 1, -1, -1): max_heapify(arr, n, i, simulation) if simulation: print(f\\"build_max_heap: {arr}\\") for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] if simulation: print(f\\"swap_max: {arr}\\") max_heapify(arr, i, 0, simulation) return arr def min_heapify(arr: List[int], n: int, i: int, simulation: bool = False): smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] < arr[smallest]: smallest = left if right < n and arr[right] < arr[smallest]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] if simulation: print(f\\"min_heapify (swap): {arr}\\") min_heapify(arr, n, smallest, simulation) def min_heap_sort(arr: List[int], simulation: bool = False) -> List[int]: n = len(arr) for i in range(n // 2 - 1, -1, -1): min_heapify(arr, n, i, simulation) if simulation: print(f\\"build_min_heap: {arr}\\") for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] if simulation: print(f\\"swap_min: {arr}\\") min_heapify(arr, i, 0, simulation) arr.reverse() # This step is needed to get the ascending order return arr"},{"question":"Scenario You have been hired by a financial institution to help them implement a system that organizes their financial transaction records. The transactions need to be displayed in ascending order based on the transaction amounts. However, the institution insists on using a traditional and simple approach for their initial implementation. Task Implement a function `sort_transactions` that uses the Exchange Sort algorithm to sort a list of transactions. Each transaction is represented as a dictionary with the key `\'amount\'`. The function should sort the list in ascending order based on the transaction amounts. Function Signature ```python def sort_transactions(transactions: List[Dict[str, Any]]) -> List[Dict[str, Any]]: ``` Input * `transactions`: A list of dictionaries where each dictionary represents a transaction with at least an `\'amount\'` key. Example: ```python transactions = [ {\'id\': 1, \'amount\': 100, \'type\': \'debit\'}, {\'id\': 2, \'amount\': 50, \'type\': \'credit\'}, {\'id\': 3, \'amount\': 150, \'type\': \'debit\'} ] ``` Output * A list of transactions sorted in ascending order based on the `\'amount\'` key. Constraints * The list can contain between `0` and `10^3` transactions. * Each transaction\'s amount is a non-negative integer. Example ```python transactions = [ {\'id\': 1, \'amount\': 100, \'type\': \'debit\'}, {\'id\': 2, \'amount\': 50, \'type\': \'credit\'}, {\'id\': 3, \'amount\': 150, \'type\': \'debit\'} ] sorted_transactions = sort_transactions(transactions) # Output should be: # [ # {\'id\': 2, \'amount\': 50, \'type\': \'credit\'}, # {\'id\': 1, \'amount\': 100, \'type\': \'debit\'}, # {\'id\': 3, \'amount\': 150, \'type\': \'debit\'} # ] ``` Notes * Ensure your solution uses the Exchange Sort algorithm. * Consider edge cases such as an empty list, a single transaction, or multiple transactions with the same amount.","solution":"def sort_transactions(transactions): Sorts the list of transactions in ascending order based on the transaction amounts using the Exchange Sort algorithm. Args: transactions (List[Dict[str, Any]]): A list of transactions where each transaction is represented as a dictionary with an \'amount\' key. Returns: List[Dict[str, Any]]: A list of transactions sorted by the \'amount\' key in ascending order. n = len(transactions) for i in range(n - 1): for j in range(i + 1, n): if transactions[i][\'amount\'] > transactions[j][\'amount\']: transactions[i], transactions[j] = transactions[j], transactions[i] return transactions"},{"question":"# Scenario You have been asked to integrate an anagram verification feature into a text analysis software. While the given code snippet is a good starting point, your goal is to enhance it for robustness and efficiency. Implement this feature while considering edge cases and optimization opportunities. # Objective Write a function, `enhanced_is_anagram(s, t)`, that determines if string `t` is an anagram of string `s`. # Specifications * **Function Name**: `enhanced_is_anagram` * **Input**: Two strings `s` and `t` (assume only lowercase alphabets) * **Output**: Boolean (`True` if `t` is an anagram of `s`, `False` otherwise) * **Constraints**: - The function should run in O(n) time complexity. - Space complexity should remain O(1) (considering a fixed character set of lowercase alphabets). # Examples *Example 1*: ```python Input: s = \\"listen\\", t = \\"silent\\" Output: True ``` *Example 2*: ```python Input: s = \\"hello\\", t = \\"bello\\" Output: False ``` # Implementation Tips 1. Check if the lengths of the two strings are not equal upfront. 2. Use a single loop to count characters, adjusting counts accordingly to avoid redundant loops. 3. Ensure to handle edge cases, such as empty strings. You can assume that the input strings will contain only lowercase alphabets.","solution":"def enhanced_is_anagram(s, t): Determines if string t is an anagram of string s. :param s: First string :param t: Second string :return: Boolean indicating whether t is an anagram of s # Anagrams must be of the same length if len(s) != len(t): return False # Count characters in both strings count = [0] * 26 # Since there are 26 letters in the alphabet for char_s, char_t in zip(s, t): count[ord(char_s) - ord(\'a\')] += 1 count[ord(char_t) - ord(\'a\')] -= 1 # If all counts are zero, then the strings are anagrams return all(x == 0 for x in count)"},{"question":"You are given the task to implement a Priority Queue using a Min Heap data structure in Python. Priority Queue is an extension of the basic queue having the following properties: 1. Each element is associated with a priority. 2. An element with higher priority is dequeued before an element with lower priority. 3. If two elements have the same priority, they are served according to their order in the queue (i.e., FIFO for elements of the same priority). A Min Heap is a complete binary tree data structure where the key of a parent node is less than or equal to the keys of its children and the smallest key is at the root. # Task Implement the following methods of a Priority Queue using a Min Heap: * `insert(item, priority)`: Insert an item with its priority to the priority queue. * `extract_min()`: Remove the item with the minimum priority and return it. * `peek_min()`: Return the item with the minimum priority without removing it. * `is_empty()`: Return True if the priority queue is empty, otherwise return False. * `size()`: Return the number of items in the priority queue. # Constraints 1. All priorities are distinct integers. 2. There could be at most 10^5 operations performed on the priority queue. # Example ```python pq = PriorityQueue() pq.insert(\'task1\', 3) pq.insert(\'task2\', 2) pq.insert(\'task3\', 5) pq.insert(\'task4\', 1) print(pq.peek_min()) # Output: \'task4\' print(pq.extract_min()) # Output: \'task4\' print(pq.peek_min()) # Output: \'task2\' print(pq.size()) # Output: 3 print(pq.is_empty()) # Output: False ``` # Your Function Template ```python class PriorityQueue: def __init__(self): # Initialize the PriorityQueue with an empty array pass def insert(self, item, priority): # Implement insert operation pass def extract_min(self): # Implement extract_min operation pass def peek_min(self): # Implement peek_min operation pass def is_empty(self): # Implement is_empty check pass def size(self): # Implement size check pass ``` Write complete definitions for these methods.","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] self.count = 0 # Add a counter to maintain FIFO order for same priority elements def insert(self, item, priority): # Insert the tuple (priority, count, item) into the heap heapq.heappush(self.heap, (priority, self.count, item)) self.count += 1 def extract_min(self): if self.is_empty(): return None return heapq.heappop(self.heap)[2] def peek_min(self): if self.is_empty(): return None return self.heap[0][2] def is_empty(self): return len(self.heap) == 0 def size(self): return len(self.heap)"},{"question":"**Objective**: Implement a function that checks if a given string follows a specified pattern using bijective mapping. **Context**: You are designing a form validation feature where certain fields must follow strict formatting patterns. For one such field, the pattern is described using letters, and the actual string values are words separated by spaces. You need to ensure there is a one-to-one correspondence between each letter in the pattern and each word in the string. **Task**: Write a function `validate_pattern(pattern: str, string: str) -> bool` that returns `True` if the string follows the pattern, and `False` otherwise. **Expected Input and Output**: * **Input**: - `pattern` (string): a sequence of lowercase letters. - `string` (string): words separated by a single space. * **Output**: - `True` or `False`. **Constraints**: * `pattern` contains only lowercase letters. * `string` contains lowercase letters and is separated by spaces. * Both inputs are non-empty. **Scenario or Context**: Your web application must ensure data validation in user-submitted forms. If the user submits a form where certain fields have specific format restrictions indicated by a pattern of characters, your function will ensure that this format is followed correctly. **Performance Requirements**: The solution should operate efficiently within the typical constraints of web form processing where inputs are moderately sized. **Examples**: ```python validate_pattern(\\"abba\\", \\"dog cat cat dog\\") # Output: True validate_pattern(\\"abba\\", \\"dog cat cat fish\\") # Output: False validate_pattern(\\"aaaa\\", \\"dog cat cat dog\\") # Output: False validate_pattern(\\"abba\\", \\"dog dog dog dog\\") # Output: False ``` **Edge Cases**: 1. Handle cases where the number of pattern characters and words do not match. 2. Ensure characters in the pattern map uniquely to words in the string.","solution":"def validate_pattern(pattern: str, string: str) -> bool: Check if the string follows the given pattern with bijective mapping. :param pattern: A string pattern of lowercase letters. :param string: A string of words separated by spaces. :return: True if the string follows the pattern, False otherwise. # Split the string by spaces to get individual words words = string.split() # If the number of pattern characters and words do not match, return False if len(pattern) != len(words): return False # Create mappings from pattern to words and words to pattern pattern_to_word = {} word_to_pattern = {} for p, w in zip(pattern, words): if p not in pattern_to_word: pattern_to_word[p] = w if w not in word_to_pattern: word_to_pattern[w] = p if pattern_to_word[p] != w or word_to_pattern[w] != p: return False return True"},{"question":"You are given an array of integers `freq` representing frequencies of certain events. You need to implement a class `EfficientFrequencyTable` that supports the following operations efficiently: 1. **get_frequency_sum(i)**: Returns the sum of frequencies from index `0` to index `i` (0-based). 2. **update_frequency(i, val)**: Updates the frequency at index `i` to `val`. The operations should be optimized such that each of them runs in O(log n) time. # Class Implementation You should implement the following methods in the `EfficientFrequencyTable` class: 1. **__init__(self, freq: List[int]) -> None**: Constructor to initialize the object with given frequency list `freq`. 2. **get_frequency_sum(self, i: int) -> int**: Method to return the cumulative frequency sum from start to index `i`. 3. **update_frequency(self, i: int, val: int) -> None**: Method to update the frequency at index `i` to `val`. # Input and Output Format * The constructor receives a list of integers `freq`. * The `get_frequency_sum(i)` method receives an integer `i` and returns an integer representing the sum of frequencies from `0` to `i`. * The `update_frequency(i, val)` method receives two integers `i`, the index to be updated, and `val`, the new frequency value. # Example ```python freq = [2, 1, 1, 3, 2, 3, 4, 5, 6, 7, 8, 9] eft = EfficientFrequencyTable(freq) print(eft.get_frequency_sum(5)) # This should print 12 eft.update_frequency(3, 6) print(eft.get_frequency_sum(5)) # This should print 15 ``` # Constraints 1. `0 <= i < len(freq)` 2. `-10^9 <= val <= 10^9` 3. `len(freq) <= 10^5` # Performance Requirements The solution should be efficient with a time complexity of O(log n) for both `get_frequency_sum` and `update_frequency` methods.","solution":"class EfficientFrequencyTable: def __init__(self, freq): Initializes the data structure with the given frequency array using a Fenwick Tree (Binary Indexed Tree). self.n = len(freq) self.tree = [0] * (self.n + 1) self.arr = freq[:] for i in range(self.n): self._add(i, self.arr[i]) def _add(self, i, val): Helper function to add value to the Fenwick Tree i += 1 # Fenwick Tree is 1-indexed while i <= self.n: self.tree[i] += val i += i & -i def _sum(self, i): Helper function to get sum from the Fenwick Tree i += 1 # Fenwick Tree is 1-indexed s = 0 while i > 0: s += self.tree[i] i -= i & -i return s def get_frequency_sum(self, i): Returns the sum of frequencies from index 0 to i (0-based) using the Fenwick Tree return self._sum(i) def update_frequency(self, i, val): Updates the frequency at index i to val. Also updates the Fenwick Tree. delta = val - self.arr[i] self.arr[i] = val self._add(i, delta)"},{"question":"# Interpolation Search Enhancement The existing implementation of the interpolation search performs well on uniformly distributed data. However, it can be enhanced by adding additional checks to handle non-uniformly distributed arrays better and avoid potential performance pitfalls. Objective Your task is to enhance the provided interpolation search algorithm with added optimizations and checks. Specifically: 1. Verify that the array has no identical consecutive elements in the search range to avoid zero-division errors. 2. Apply a fallback mechanism, such as binary search, if a certain threshold of iterations or recursion depth is reached, indicating non-uniform distribution. Function Specifications ```python def enhanced_interpolation_search(array: List[int], search_key: int) -> int: :param array: The array to be searched (must be sorted in ascending order). :param search_key: The key to be searched in the array. :returns: Index of search_key in array if found, else -1. Enhancements: - Check for identical consecutive elements to avoid division by zero. - Apply binary search as a fallback if performance criteria are not met. - The enhanced function should run robustly both on uniformly and non-uniformly distributed data. Examples: >>> enhanced_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) 2 >>> enhanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) -1 >>> enhanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) -1 ``` Constraints - The array can have up to (10^6) elements. - Array elements and the search key are integers in the range ([-10^9, 10^9]). - The array may not be uniformly distributed. Your Task Implement the `enhanced_interpolation_search` function with the described enhancements. Ensure your function is efficient and handles edge cases effectively.","solution":"def fallback_binary_search(array, search_key, low, high): while low <= high: mid = (low + high) // 2 if array[mid] == search_key: return mid elif array[mid] < search_key: low = mid + 1 else: high = mid - 1 return -1 def enhanced_interpolation_search(array, search_key, max_iterations = 100): low = 0 high = len(array) - 1 iterations = 0 while low <= high and search_key >= array[low] and search_key <= array[high]: # Avoid division by zero for identical consecutive elements if array[high] == array[low]: if array[low] == search_key: return low else: break # Interpolation formula pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) # Boundary check if pos < low or pos > high: break iterations += 1 if iterations > max_iterations: # Fallback to binary search if max iterations exceeded return fallback_binary_search(array, search_key, low, high) if array[pos] == search_key: return pos elif array[pos] < search_key: low = pos + 1 else: high = pos - 1 return fallback_binary_search(array, search_key, low, high)"},{"question":"You are given an integer represented by the variable `num` and you have to insert bits into specific positions within this integer. Using bit manipulation, implement the following functions: 1. Inserting a Single Bit: Implement the function `insert_one_bit(num: int, bit: int, i: int) -> int` that inserts a single bit (`0` or `1`) at position `i` in `num`. **Function Signature**: ```python def insert_one_bit(num: int, bit: int, i: int) -> int: pass ``` **Input**: - `num`: an integer, the number in which you want to insert the bit (non-negative). - `bit`: either `0` or `1`, the bit to be inserted. - `i`: the position (0-indexed) at which the bit should be inserted. **Output**: - Returns an integer with the bit inserted at the specified position. **Examples**: ```python assert insert_one_bit(21, 1, 2) == 45 # 21 (10101) -> 45 (101101) assert insert_one_bit(21, 0, 2) == 41 # 21 (10101) -> 41 (101001) assert insert_one_bit(21, 1, 5) == 53 # 21 (10101) -> 53 (110101) assert insert_one_bit(21, 1, 0) == 43 # 21 (10101) -> 43 (101011) ``` 2. Inserting Multiple Bits: Implement the function `insert_mult_bits(num: int, bits: int, length: int, i: int) -> int` that inserts multiple bits at position `i` in `num` where `bits` is an integer representing the bits to be inserted and `length` is the number of bits to insert. **Function Signature**: ```python def insert_mult_bits(num: int, bits: int, length: int, i: int) -> int: pass ``` **Input**: - `num`: an integer, the number in which you want to insert the bits (non-negative). - `bits`: an integer, the bits to be inserted. - `length`: integer, the number of bits in `bits` to insert. - `i`: the position (0-indexed) at which the bits should be inserted. **Output**: - Returns an integer with the bits inserted at the specified position. **Examples**: ```python assert insert_mult_bits(5, 7, 3, 1) == 47 # 5 (101) -> 47 (101111) assert insert_mult_bits(5, 7, 3, 0) == 47 # 5 (101) -> 47 (101111) assert insert_mult_bits(5, 7, 3, 3) == 61 # 5 (101) -> 61 (111101) ``` **Constraints**: 1. `num` will be a non-negative integer. 2. `bit` will be either `0` or `1`. 3. `i` will be a non-negative integer. 4. `bits` will be a non-negative integer. 5. `length` will be a positive integer. 6. Ensure to handle the edge cases like inserting at the start or end of the number. You are expected to demonstrate a strong understanding of bit manipulation to solve this problem effectively.","solution":"def insert_one_bit(num: int, bit: int, i: int) -> int: Inserts a single bit (0 or 1) at position i in the integer num. if bit not in (0, 1): raise ValueError(\\"bit must be 0 or 1\\") mask1 = (num & ((1 << i) - 1)) # Lower part of num mask2 = (num & (~((1 << i) - 1))) << 1 # Upper part of num shifted by 1 inserted_num = mask2 | (bit << i) | mask1 return inserted_num def insert_mult_bits(num: int, bits: int, length: int, i: int) -> int: Inserts multiple bits, represented by the integer bits, at position i in the integer num. mask1 = (num & ((1 << i) - 1)) # Lower part of num mask2 = (num & (~((1 << i) - 1))) << length # Upper part of num shifted by length inserted_num = mask2 | (bits << i) | mask1 return inserted_num"},{"question":"# ZigZag Iterator for Multiple Lists You are tasked with implementing a generalized version of the ZigZag Iterator that can handle an arbitrary number of lists rather than just two. Objective Your task is to complete the class `ZigZagIteratorMultiple` by implementing the methods `next()` and `has_next()`. The iterator should return elements from the provided lists in a round-robin fashion until all the lists are exhausted. Function Specifications ```python class ZigZagIteratorMultiple: def __init__(self, lists): Initialize your data structure here. :type lists: List[List[int]] pass def next(self): :rtype: int pass def has_next(self): :rtype: bool pass ``` Implementation Requirements - **__init__(self, lists)**: - **Input**: A list of lists where each individual list contains integers. - **next(self)**: - **Output**: Returns the next integer in the zigzag order. - **Behavior**: Throws an error or handles the call gracefully if there are no more elements to return. - **has_next(self)**: - **Output**: Returns a boolean value indicating whether there are more elements to return. Constraints - Do not modify the input lists once the iterator is created. - The number of lists `n` and the total number of elements across all lists could be large, so efficiency matters. Example Scenarios 1. **Scenario**: - Inputs: `[[1, 2, 3], [4, 5, 6, 7], [8, 9]]` - Outputs: 1, 4, 8, 2, 5, 9, 3, 6, 7 2. **Scenario**: - Inputs: `[[], [1, 2], [3, 4, 5, 6]]` - Outputs: 1, 3, 2, 4, 5, 6 Edge Cases to Consider - Some lists are empty. - All lists are empty. - Lists with different lengths. Example Usage ```python l1 = [1, 2, 3] l2 = [4, 5, 6, 7] l3 = [8, 9] iterator = ZigZagIteratorMultiple([l1, l2, l3]) while iterator.has_next(): print(iterator.next()) ```","solution":"class ZigZagIteratorMultiple: def __init__(self, lists): Initialize your data structure here. :type lists: List[List[int]] self.data = [lst for lst in lists if lst] # Filter out empty lists self.pointers = [0] * len(self.data) # pointers for each list self.index = 0 # Current list index def next(self): :rtype: int if not self.has_next(): raise Exception(\'No more elements\') # While the current list is exhausted, move to the next one while self.pointers[self.index] >= len(self.data[self.index]): self.index = (self.index + 1) % len(self.data) # Get the element to return result = self.data[self.index][self.pointers[self.index]] # Update the pointer for the current list self.pointers[self.index] += 1 # Move to the next list for the next call self.index = (self.index + 1) % len(self.data) return result def has_next(self): :rtype: bool # Check pointers for all lists to see if any has elements left return any(self.pointers[i] < len(self.data[i]) for i in range(len(self.data)))"},{"question":"You are required to implement a crucial part of a search engine\'s autocomplete feature. Your task is to design and implement a data structure that can efficiently add and search words, allowing search queries to include wildcards. # Detailed Requirements Your data structure should support the following operations: 1. **add_word(word)**: Adds a word to the data structure. 2. **search(word)**: Searches the data structure for a word. The word may contain the wildcard character \'.\', which can match any letter. # Input/Output Specifications - **Input**: - `add_word(word)`: A string `word` consisting of lower-case English letters. - `search(word)`: A string `word` that may include \'.\' as a wildcard character and consists of lower-case English letters. - **Output**: - `add_word(word)`: No output. - `search(word)`: Returns `True` if the word (with wildcards considered) exists in the data structure, otherwise returns `False`. # Constraints - All input strings are non-empty and have a length of at most 100 characters. - The maximum number of words in the data structure won\'t exceed 10^5. # Example ```python # Initialize the data structure dictionary = WordDictionary() # Add words dictionary.add_word(\\"bad\\") dictionary.add_word(\\"dad\\") dictionary.add_word(\\"mad\\") # Search words print(dictionary.search(\\"pad\\")) # Output: False print(dictionary.search(\\"bad\\")) # Output: True print(dictionary.search(\\".ad\\")) # Output: True print(dictionary.search(\\"b..\\")) # Output: True ``` # Additional Information - The search queries must handle edge cases such as empty strings and wildcard searches effectively. - You must ensure that your solution is time-efficient to handle large input sizes within acceptable performance limits. - Pay attention to the memory usage considering the constraints. You do not need to validate the inputs; assume they meet the constraints provided.","solution":"class WordDictionary: def __init__(self): self.trie = {} def add_word(self, word): node = self.trie for char in word: if char not in node: node[char] = {} node = node[char] node[\'#\'] = True def search(self, word): return self._search_in_node(word, self.trie) def _search_in_node(self, word, node): for i, char in enumerate(word): if char == \'.\': for x in node: if x != \'#\' and self._search_in_node(word[i+1:], node[x]): return True return False else: if char not in node: return False node = node[char] return \'#\' in node"},{"question":"# Background: You are given the task to sort a list of floating-point numbers that fall within the range [0, 1) using Bucket Sort. The Bucket Sort algorithm works by distributing the elements into a number of buckets, then sorting these individual buckets, and finally concatenating them back together in sorted order. # Problem Statement: Write a function `bucket_sort_floats(arr)` that sorts a list of floating-point numbers using the bucket sort algorithm. The function should improve upon the given code snippet by addressing its limitations, particularly ensuring efficient space utilization, and handling any potential edge cases to ensure robustness. # Function Signature: ```python def bucket_sort_floats(arr: List[float]) -> List[float]: pass ``` # Input: - `arr`: A list of floating-point numbers where each number is in the range [0, 1). # Output: - A list of floating-point numbers sorted in non-decreasing order. # Constraints: 1. All elements of `arr` are floating-point numbers in the range [0, 1). 2. The length of the list, `len(arr)`, can be up to 10^5. # Performance: - Aim to achieve average case time complexity of O(n + k) where n is the number of elements and k is the number of buckets. # Examples: Example 1: ```python arr = [0.25, 0.36, 0.58, 0.41, 0.72, 0.39, 0.90, 0.16] print(bucket_sort_floats(arr)) # Output: [0.16, 0.25, 0.36, 0.39, 0.41, 0.58, 0.72, 0.90] ``` Example 2: ```python arr = [0.78, 0.45, 0.29, 0.20, 0.86, 0.08, 0.39, 0.66] print(bucket_sort_floats(arr)) # Output: [0.08, 0.20, 0.29, 0.39, 0.45, 0.66, 0.78, 0.86] ``` # Implementation Tip: Ensure that: - The bucket allocation step efficiently divides the array across buckets. - Use an efficient sorting algorithm within each bucket to handle large number of elements.","solution":"from typing import List def bucket_sort_floats(arr: List[float]) -> List[float]: if not arr: return [] # Number of buckets n = len(arr) buckets = [[] for _ in range(n)] for val in arr: index = int(val * n) buckets[index].append(val) # Sort individual buckets for bucket in buckets: bucket.sort() # Concatenate all buckets result = [] for bucket in buckets: result.extend(bucket) return result"},{"question":"You are given a directed graph as an edge list and the number of vertices it contains. Implement a function to determine if there is a path from a specified source node to a target node using Depth-First Search (DFS). Return `True` if such a path exists and `False` otherwise. # Input: * `num_vertices` (int): The number of vertices in the graph. * `edges` (List[Tuple[int, int]]): List of tuples where each tuple represents a directed edge from the first vertex to the second. * `source` (int): The starting vertex for the path search. * `target` (int): The target vertex to reach. # Output: * `bool`: Return `True` if there is a path from `source` to `target`, `False` otherwise. # Constraints: * All vertex labels are assumed to be valid and within the range from `0` to `num_vertices - 1`. * `0<= num_vertices <= 10^5` * `0<= number of edges <= 5 * 10^5` # Requirements: 1. **Performance**: Ensure the function works efficiently for large inputs within the given constraints. 2. **Edge Cases**: * The graph has no edges. * The source and the target vertices are the same. * The target vertex is unreachable from the source. * Cyclic graphs. # Example: ```python def is_reachable(num_vertices, edges, source, target): # Implement function here edges = [ (0, 1), (1, 2), (2, 3), (3, 4), (4, 5) ] num_vertices = 6 source = 0 target = 5 # Expected Output: True print(is_reachable(num_vertices, edges, source, target)) edges = [ (0, 1), (1, 2), (3, 4), (4, 5) ] num_vertices = 6 source = 0 target = 5 # Expected Output: False print(is_reachable(num_vertices, edges, source, target)) ```","solution":"def is_reachable(num_vertices, edges, source, target): Determines if there is a path from source to target in a directed graph using DFS. :param num_vertices: Number of vertices in the graph :param edges: List of tuples where each tuple represents a directed edge :param source: The starting vertex for the path search :param target: The target vertex to reach :return: True if there is a path from source to target, otherwise False # Create adjacency list for the graph graph = {i: [] for i in range(num_vertices)} for u, v in edges: graph[u].append(v) # Perform DFS visited = set() stack = [source] while stack: node = stack.pop() if node == target: return True if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: stack.append(neighbor) return False"},{"question":"**Context**: An online store uses an \\"anagram-based obfuscation\\" method to store user passwords for added security. To verify access, the system needs to ensure that the stored password is indeed an anagram of the input provided by the user. **Problem Statement**: You are given two strings `s` and `t`. Write a function to determine if `t` is an anagram of `s`. **Function Specification**: ```python def is_anagram(s: str, t: str) -> bool: :param s: first string :param t: second string :return: Boolean value indicating whether t is an anagram of s ``` **Input Format**: - Two strings, `s` and `t`, where `1 <= len(s), len(t) <= 10^5`. The strings will contain only lowercase English alphabet characters. **Output Format**: - Return `True` if `t` is an anagram of `s`, and `False` otherwise. **Constraints**: - Both strings will contain only lowercase English letters. **Performance Requirements**: - Aim to achieve O(n) time complexity and O(1) additional space complexity, where n is the length of the strings. **Additional Notes**: - You should handle edge cases where strings are not of the same length early in your function to save processing time. Here’s the expected behavior: ```python assert is_anagram(\\"anagram\\", \\"nagaram\\") == True assert is_anagram(\\"rat\\", \\"car\\") == False assert is_anagram(\\"\\", \\"\\") == True assert is_anagram(\\"a\\", \\"b\\") == False assert is_anagram(\\"ab\\", \\"ba\\") == True ```","solution":"def is_anagram(s: str, t: str) -> bool: :param s: first string :param t: second string :return: Boolean value indicating whether t is an anagram of s if len(s) != len(t): return False from collections import Counter return Counter(s) == Counter(t)"},{"question":"<|Analysis Begin|> # Algorithm/Data Structure Analysis Core Identification * **Algorithm/Data Structure**: * **Name**: Path Sum in Binary Tree * **Type**: Tree traversal algorithm * **Main Purpose**: To determine whether there is a root-to-leaf path in a binary tree such that the sum of the node values along the path equals a given value. * **Complexity**: * **Time Complexity**: O(N), where N is the number of nodes in the binary tree. The algorithm needs to visit each node at least once. * **Space Complexity**: - Recursive DFS: O(H), where H is the height of the binary tree (due to the recursion stack). - Iterative DFS with stack: O(H), where H is the height of the binary tree. - BFS with queue: O(W), where W is the maximum width of the binary tree. * **Principles**: - The algorithm involves traversing the binary tree to find any root-to-leaf path that sums up to a given value. - Three methods are provided: 1. **Recursive DFS**: This uses recursion to traverse the tree depth-first. 2. **Iterative DFS with stack**: This uses a stack to simulate the recursion stack and traverse the tree depth-first. 3. **Iterative BFS with queue**: This uses a queue to traverse the tree breadth-first. Characteristics & Applications * **Properties**: - The algorithm checks multiple traversal paths and verifies if the sum is equal to the provided target sum. - Recursive DFS is straightforward but can lead to a deep recursion stack. - Iterative DFS and BFS may offer better control over memory usage in specific scenarios. * **Common Use Cases**: - Determine the presence of specific paths in a binary tree with given constraints. - Useful for solving problems involving tree path sums, such as root-to-leaf path calculations in various practical applications (e.g., financial calculations, game development). * **Strengths/Limitations**: - **Strengths**: - Handles binary trees of arbitrary shapes and sizes. - Multiple methods provided, offering flexibility based on the problem constraints. - **Limitations**: - Recursive DFS can lead to stack overflow for very deep trees. - BFS might consume more memory than DFS in the case of wide binary trees. Implementation Challenges * **Edge Cases**: - An empty tree (root is None). - Single node trees where the node\'s value matches or does not match the sum. - Trees with multiple paths, some of which may or may not add up to the given sum. * **Performance Bottlenecks**: - Deep recursion can lead to stack overflow. - Wide trees can consume significant memory when using BFS due to large queues. * **Error Scenarios**: - Failing to handle null nodes correctly. - Incorrectly decrementing the sum while traversing the tree. * **Optimization Points**: - Optimizing memory usage by choosing the appropriate traversal method. - Implementing tail-recursion to optimize recursive DFS. <|Analysis End|> <|Question Begin|> # Task Description You are given a binary tree and a target sum. Your task is to implement a function that determines if the tree has a root-to-leaf path such that the sum of the values of the nodes in the path equals the given sum. You need to implement the following function: ```python def has_path_sum(root, target_sum): :param root: TreeNode :param target_sum: int :return: bool pass ``` # Input Format - `root`: The root node of the binary tree. Each `TreeNode` has the following attributes: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - `target_sum`: An integer representing the sum to be checked along the root-to-leaf path. # Output Format - The function should return `True` if there exists a root-to-leaf path with the sum equal to `target_sum`. Otherwise, it should return `False`. # Constraints - The number of nodes in the tree is in the range [0, 1000]. - -10^4 <= Node value <= 10^4 - -10^4 <= target_sum <= 10^4 # Performance Requirements Your solution should strive for a time complexity of O(N) where N is the number of nodes in the binary tree and a space complexity of O(H) where H is the height of the binary tree. # Examples Example 1 *Input*: ```python root = TreeNode(5) root.left = TreeNode(4) root.right = TreeNode(8) root.left.left = TreeNode(11) root.left.left.left = TreeNode(7) root.left.left.right = TreeNode(2) root.right.left = TreeNode(13) root.right.right = TreeNode(4) root.right.right.right = TreeNode(1) target_sum = 22 ``` *Output*: `True` *Explanation*: The root-to-leaf path 5 -> 4 -> 11 -> 2 sums to 22. Example 2 *Input*: ```python root = TreeNode(1) root.left = TreeNode(2) target_sum = 1 ``` *Output*: `False` *Explanation*: There is no root-to-leaf path that sums to 1. Example 3 *Input*: ```python root = None target_sum = 10 ``` *Output*: `False` *Explanation*: The tree is empty, hence no path exists. # Notes - Ensure to handle edge cases such as an empty tree, single-node trees, etc. - Consider both recursive and iterative approaches to solve the problem although you\'re required to implement one function as the final solution.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root, target_sum): Determines if the binary tree has a root-to-leaf path such that the sum of the values of the nodes in the path equals target_sum. :param root: TreeNode :param target_sum: int :return: bool if not root: return False # If we reach a leaf node, check if the current sum equals target_sum if not root.left and not root.right: return root.val == target_sum # Recursively check the left and right sub-trees with the adjusted sum target_sum -= root.val return has_path_sum(root.left, target_sum) or has_path_sum(root.right, target_sum)"},{"question":"# Scenario You are working on a new feature for a word-processing application that provides smart abbreviations for long words. The goal is to generate all possible abbreviations for any given word. An abbreviation of a word is a sequence where some characters of the word are replaced with those characters\' counts of consecutive replacements. # Problem Statement Write a function `generate_abbreviations(word: str) -> List[str]` that takes in a single string `word` and returns a list of all possible abbreviations of `word`. Each abbreviation must consist of characters of the word and/or numbers representing counts of consecutive characters. # Input - `word` (string): The word for which abbreviations are to be generated. * Length of word: 0 <= length <= 12 * The word contains only lowercase English letters. # Output - List of strings: All possible abbreviations of the input `word`. # Constraints 1. The function should consider all characters of the word. 2. Consecutive characters in the word can appear either as themselves or as a count. 3. The function should handle recursive depths effectively for long words but, do not expect words longer than 12 characters. # Examples ```python assert generate_abbreviations(\\"word\\") == [\'word\', \'wor1\', \'wo1d\', \'wo2\', \'w1rd\', \'w1r1\', \'w2d\', \'w3\', \'1ord\', \'1or1\', \'1o1d\', \'1o2\', \'2rd\', \'2r1\', \'3d\', \'4\'] assert generate_abbreviations(\\"\\") == [\\"\\"] assert generate_abbreviations(\\"a\\") == [\\"a\\", \\"1\\"] assert generate_abbreviations(\\"ab\\") == [\\"ab\\", \\"a1\\", \\"1b\\", \\"2\\"] ``` # Performance Requirements - The solution should work within reasonable time limits for words up to 12 characters. Implement the function: ```python def generate_abbreviations(word: str) -> List[str]: # Your implementation here ```","solution":"def generate_abbreviations(word: str): Generate all possible abbreviations of the input word. :param word: A string input for which to generate abbreviations. :return: A list of all possible abbreviations. def backtrack(pos, cur, count): if pos == len(word): res.append(cur + (str(count) if count > 0 else \'\')) else: # Skip this character (increase the count) backtrack(pos + 1, cur, count + 1) # Include this character (add the count if there was one) backtrack(pos + 1, cur + (str(count) if count > 0 else \'\') + word[pos], 0) res = [] backtrack(0, \\"\\", 0) return res"},{"question":"# Matrix Multiplication You are required to implement a function that multiplies two 2D matrices (lists of lists) and returns the resulting matrix. Ensure that the matrices are compatible for multiplication, otherwise, your function should raise a meaningful exception. Input - Two 2D matrices (lists of lists), `multiplicand` and `multiplier`. - `multiplicand`: List[List[int]] - `multiplier`: List[List[int]] Output - A 2D matrix (List[List[int]]) which is the product of the input matrices. Constraints - 1 <= |multiplicand|, |multiplier| <= 100 - Each matrix element can be any integer. - The number of columns in `multiplicand` must match the number of rows in `multiplier`. Example 1. Example Scenario: - **Input**: multiplicand = [[1, 2], [3, 4]], multiplier = [[2, 0], [1, 3]] - **Output**: [[4, 6], [10, 12]] 2. Edge Case: - **Input**: multiplicand = [[1]], multiplier = [[2]] - **Output**: [[2]] Function Signature ```python def multiply(multiplicand: list, multiplier: list) -> list: pass ``` Guidelines 1. Ensure input matrices\' compatibility for multiplication. 2. Raise a meaningful exception if they are incompatible. 3. Implement the matrix multiplication using a nested loop structure. 4. Optimize your code if possible to avoid performance bottlenecks for large matrices.","solution":"def multiply(multiplicand: list, multiplier: list) -> list: Multiplies two 2D matrices (lists of lists) and returns the resulting matrix. Parameters: multiplicand (list): The first matrix to be multiplied. multiplier (list): The second matrix to be multiplied. Returns: list: The resulting matrix from the multiplication. Raises: ValueError: If the number of columns in `multiplicand` does not match the number of rows in `multiplier`. # Number of rows and columns in the multiplicand rows_multiplicand = len(multiplicand) cols_multiplicand = len(multiplicand[0]) # Number of rows and columns in the multiplier rows_multiplier = len(multiplier) cols_multiplier = len(multiplier[0]) # Raise an exception if the number of columns in multiplicand does not match the number of rows in multiplier if cols_multiplicand != rows_multiplier: raise ValueError(\\"Incompatible matrices for multiplication. The number of columns in the multiplicand must match the number of rows in the multiplier.\\") # Initialize the resultant matrix with zeros result = [[0 for _ in range(cols_multiplier)] for _ in range(rows_multiplicand)] # Perform matrix multiplication for i in range(rows_multiplicand): for j in range(cols_multiplier): for k in range(cols_multiplicand): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Question: Dijkstra\'s Algorithm Implementation with Priority Queue You are given a weighted, directed graph represented by an adjacency list. Implement Dijkstra\'s algorithm to find the shortest path from a given source node to all other nodes using a priority queue for efficient minimum distance retrieval. Input: * `vertex_count` (int): Number of vertices in the graph. * `edges` (List[Tuple[int, int, int]]): List of tuples where each tuple (u, v, w) represents a directed edge from vertex `u` to vertex `v` with weight `w`. * `src` (int): The source vertex from which to calculate shortest paths. Output: * `distances` (List[int]): List of integers where the `i-th` entry represents the shortest distance from the source node to the `i-th` node. Constraints: * ( 1 leq text{vertex_count} leq 1000 ) * ( 0 leq u, v < text{vertex_count} ) * ( 0 leq w leq 10000 ) * All input nodes must be non-negative integers. Example: ```python vertex_count = 5 edges = [ (0, 1, 10), (0, 4, 5), (1, 2, 1), (2, 3, 4), (4, 1, 3), (4, 2, 9), (4, 3, 2) ] src = 0 # Output should be: [0, 8, 9, 7, 5] ``` Task: Implement the function `dijkstra(vertex_count, edges, src)` that returns the shortest distance from the source node to all other nodes using Dijkstra\'s algorithm with a priority queue.","solution":"import heapq from collections import defaultdict from typing import List, Tuple def dijkstra(vertex_count: int, edges: List[Tuple[int, int, int]], src: int) -> List[int]: # Create adjacency list graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) # Initialize distances array with infinity distances = [float(\'inf\')] * vertex_count distances[src] = 0 # Create a priority queue and add the source node with distance 0 priority_queue = [(0, src)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If the distance is greater than the recorded distance, skip it if current_distance > distances[current_node]: continue # Explore neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"Implementing the Atbash Cipher Context The Atbash cipher is a simple substitution cipher originally used for the Hebrew alphabet but can be adapted to work with any alphabet. It encrypts by swapping letters in symmetric positions: the first letter is replaced by the last, the second by the second to last, and so on. Task Implement a function that takes a string and returns its Atbash cipher equivalent. Your function should handle both uppercase and lowercase alphabets and leave all other characters unchanged. Function Signature: ```python def atbash(s: str) -> str: pass ``` Input - A single string `s` (1 ≤ len(s) ≤ 1000). The string can contain any printable ASCII characters. Output - A single string containing the Atbash cipher translation of the input string. Examples Example 1: ```text Input: \\"Hello, World!\\" Output: \\"Svool, Dliow!\\" ``` Example 2: ```text Input: \\"Attack at dawn\\" Output: \\"Zggzxp zg wzdm\\" ``` Constraints - Handle both uppercase and lowercase letters. - Non-alphabetic characters should remain unchanged. Considerations - Ensure your solution is efficient and runs in O(n) time complexity. - Consider edge cases like input strings with no alphabetic characters, and strings with mixed-case alphabets.","solution":"def atbash(s: str) -> str: result = [] for char in s: if \'a\' <= char <= \'z\': result.append(chr(ord(\'z\') - (ord(char) - ord(\'a\')))) elif \'A\' <= char <= \'Z\': result.append(chr(ord(\'Z\') - (ord(char) - ord(\'A\')))) else: result.append(char) return \'\'.join(result)"},{"question":"# Context Exchange Sort is a basic sorting algorithm that operates by repeatedly iterating through the list and swapping unsorted elements. Despite its simplicity, Exchange Sort is inefficient for large datasets due to its O(n^2) time complexity. # Task Your task is to implement a more efficient sorting algorithm that still maintains simplicity and clarity. Implement the Merge Sort algorithm to sort a list of integers. Merge Sort is a classic Divide-and-Conquer algorithm which recursively splits the list into smaller sublists until each sublist contains a single element, then merges the sublists back together in sorted order. # Function Signature Implement the following function: ```python def merge_sort(arr): Sorts the input list using the Merge Sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: list: A new list containing the sorted integers. pass ``` # Input * A single list `arr` containing `n` integers where `0 <= n <= 10^5`. * Each integer in `arr` is in the range `[-10^9, 10^9]`. # Output * Return a new list that is sorted in ascending order. # Constraints * Your solution should have a time complexity of O(n log n). * Use an iterative or recursive implementation of Merge Sort. # Examples ```python print(merge_sort([])) # Output: [] print(merge_sort([1])) # Output: [1] print(merge_sort([3, 1, 2])) # Output: [1, 2, 3] print(merge_sort([5, 3, 8, 6, 2])) # Output: [2, 3, 5, 6, 8] ```","solution":"def merge_sort(arr): Sorts the input list using the Merge Sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: list: A new list containing the sorted integers. if len(arr) <= 1: return arr def merge(left, right): result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right)"},{"question":"# Task You are responsible for implementing a priority queue using the concepts of the Abstract Queue and Linked List described above. A priority queue is an abstract data type where each element is assigned a priority and elements are dequeued based on their priority (higher priority elements are dequeued before lower priority elements). If two elements have the same priority, they follow the FIFO principle. # Details 1. Implement the `PriorityQueue` class inheriting from `AbstractQueue`. 2. Use a max-heap or min-heap internally to manage priorities efficiently. 3. Ensure that all methods (`enqueue`, `dequeue`, `peek`, `__iter__`) conform to the interface defined in `AbstractQueue`. # Requirements: - **enqueue(value, priority)**: Inserts an item with a given priority. - **dequeue()**: Removes and returns the item with the highest priority. - **peek()**: Returns the item with the highest priority without removing it. - **is_empty()**: Returns `True` if the queue is empty; otherwise, returns `False`. - **__iter__()**: Iterate over elements in the priority order. # Complexity Targets: - `enqueue`: O(log n) - `dequeue`: O(log n) - `peek`: O(1) # Example: ```python pq = PriorityQueue() pq.enqueue(\'task1\', 3) pq.enqueue(\'task2\', 2) pq.enqueue(\'task3\', 5) print(pq.peek()) # Output: \'task3\' print(pq.dequeue()) # Output: \'task3\' print(pq.dequeue()) # Output: \'task1\' print(pq.dequeue()) # Output: \'task2\' ``` # Constraints: - Elements are assumed to be non-negative integers or strings. - No duplicate priorities will be provided for simplicity. # Evaluation Criteria: - Correct implementation of priority queue according to the defined functionality. - Proper handling of edge cases (e.g., empty queue operations). - Efficiency of the data structure adherence to complexity targets.","solution":"import heapq class PriorityQueue: def __init__(self): self._heap = [] self._counter = 0 # Tie-breaker to maintain FIFO order for same-priority items def enqueue(self, value, priority): # Using a min-heap, invert priority to handle as max-heap entry = (-priority, self._counter, value) self._counter += 1 heapq.heappush(self._heap, entry) def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from an empty priority queue\\") return heapq.heappop(self._heap)[-1] def peek(self): if self.is_empty(): raise IndexError(\\"peek from an empty priority queue\\") return self._heap[0][-1] def is_empty(self): return len(self._heap) == 0 def __iter__(self): sorted_items = sorted(self._heap, key=lambda x: (x[0], x[1])) return (x[-1] for x in sorted_items)"},{"question":"# Preorder Tree Traversal with Detailed Edge Case Handling Problem Statement You are provided with a binary tree and you need to implement the preorder traversal algorithm in both iterative and recursive fashions. Your task is to write two functions `preorder_iterative` and `preorder_recursive` which perform the preorder traversal of a binary tree and return a list of node values in the preorder sequence. Input Format Both functions will receive a `root` node of the binary tree. Each node contains: * `val` (integer): value of the node. * `left` (Node or None): reference to the left child. * `right` (Node or None): reference to the right child. * You must ensure the handling of the following edge cases within the input: * The tree is empty (root is None). * The tree has only one node. * The tree is completely unbalanced (e.g., a linked list shape). Output Format Both functions should return a list of integers representing the values of the nodes in the preorder sequence. Function Definitions ```python def preorder_iterative(root: Node) -> List[int]: Perform an iterative preorder traversal and return the values in preorder sequence. :param root: Root node of the binary tree :return: List of node values in preorder sequence pass def preorder_recursive(root: Node) -> List[int]: Perform a recursive preorder traversal and return the values in preorder sequence. :param root: Root node of the binary tree :return: List of node values in preorder sequence pass ``` Examples Given the tree: ``` 1 / 2 3 / 4 5 ``` * `preorder_iterative(root)` should return `[1, 2, 4, 5, 3]` * `preorder_recursive(root)` should return `[1, 2, 4, 5, 3]` Constraints * You must handle large trees efficiently. * The input tree\'s structure can be assumed valid, but tree can be empty.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def preorder_iterative(root): Perform an iterative preorder traversal and return the values in preorder sequence. if not root: return [] stack, result = [root], [] while stack: node = stack.pop() result.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return result def preorder_recursive(root): Perform a recursive preorder traversal and return the values in preorder sequence. if not root: return [] result = [root.val] result.extend(preorder_recursive(root.left)) result.extend(preorder_recursive(root.right)) return result"},{"question":"# Priority Queue Implementation with Extended Features A priority queue efficiently manages a list of elements each with a priority, allowing quick access to the element with the highest or lowest priority. Current implementation shows a priority queue using a linear array, allowing O(n) insertion and O(1) extraction of the minimum priority element. Your Task: Extend the current implementation of the `PriorityQueue` class with the following features: 1. **Remove Specific Element**: Implement a method `remove(item)` that removes a specific element from the queue. This should run in O(n). 2. **Change Priority**: Implement a method `change_priority(item, new_priority)` that changes the priority of a specific item if it exists in the queue, maintaining the priority order. This should run as efficiently as possible. # Function Definitions: 1. **remove(item)** - **Input**: `item` (desired element to be removed) - **Output**: None (Simply removes the element if it exists) - **Constraints**: If the element does not exist, do nothing. 2. **change_priority(item, new_priority)** - **Input**: `item` (desired element whose priority is to be changed), `new_priority` (new priority value) - **Output**: None (Repositions the element as per new priority) - **Constraints**: If the element does not exist, do nothing. Ensure the queue maintains the correct order after priority change. Implement these methods based on the given class structure. Example: ```python pq = PriorityQueue([\'a\', \'b\', \'c\'], [2, 3, 1]) print(pq) # PriorityQueue([b: 3, a: 2, c: 1]) pq.remove(\'a\') print(pq) # PriorityQueue([b: 3, c: 1]) pq.change_priority(\'c\', 4) print(pq) # PriorityQueue([c: 4, b: 3]) ``` # Constraints: - Assume items are unique. - Priority can be any comparable type (int, float).","solution":"class PriorityQueue: def __init__(self, items, priorities): self.queue = list(zip(items, priorities)) self.queue.sort(key=lambda x: x[1], reverse=True) def __repr__(self): return \\"PriorityQueue([\\" + \\", \\".join(f\\"{item}: {priority}\\" for item, priority in self.queue) + \\"])\\" def remove(self, item): Removes the specified item from the queue if it exists. self.queue = [x for x in self.queue if x[0] != item] def change_priority(self, item, new_priority): Changes the priority of the specified item and maintains the queue order. for i, (current_item, _) in enumerate(self.queue): if current_item == item: self.queue[i] = (item, new_priority) break self.queue.sort(key=lambda x: x[1], reverse=True)"},{"question":"Scenario You are working with geographical data and need to find the k closest points to a particular location on a map. To achieve this, you decide to use a max heap to maintain the closest points efficiently. Problem Statement Write a function `k_closest(points, k, origin=(0, 0))` that accepts the following parameters: - `points`: a list of tuples where each tuple represents the coordinates of a point on a 2D plane. - `k`: an integer representing the number of closest points to return. - `origin`: a tuple representing the coordinates of the reference point (default is (0, 0)). The function should return a list of the k closest points to the origin. Input and Output Formats * **Input**: * `points`: List of tuples, e.g., `[(1, 1), (2, 2), (3, 3)]` * `k`: Integer, e.g., `2` * `origin`: Tuple (optional), default is `(0, 0)` * **Output**: * List of tuples, e.g., `[(1, 1), (2, 2)]` Constraints 1. The length of `points` will be between 1 and 10^5. 2. -1000 ≤ coordinates of `points` and `origin` ≤ 1000. 3. 1 ≤ k ≤ len(points). Performance Requirements * The function should have a time complexity of O(k + (n-k) log k). * The space complexity should be O(k). Example ```python # Example 1 points = [(1, 2), (3, 4), (-1, -1), (-2, -3)] k = 2 origin = (0, 0) # Expected Output: [(-1, -1), (1, 2)] # Example 2 points = [(5, 5), (6, -6), (-5, -5), (-6, 6)] k = 3 # Expected Output: [(-5, -5), (5, 5), (-6, 6)] ``` Implement the function `k_closest(points, k, origin=(0, 0))` that fulfills the requirements.","solution":"import heapq import math def k_closest(points, k, origin=(0, 0)): def distance(point): return math.sqrt((point[0] - origin[0]) ** 2 + (point[1] - origin[1]) ** 2) max_heap = [] for point in points: dist = -distance(point) if len(max_heap) < k: heapq.heappush(max_heap, (dist, point)) else: heapq.heappushpop(max_heap, (dist, point)) return [point for _, point in max_heap]"},{"question":"# **Cycle Detection in Directed Graph** As a team of software developers, you are tasked with implementing a system that ensures any given set of processes does not fall into a deadlock situation. Processes and their dependencies can be represented as a directed graph where a vertex represents a process and a directed edge from vertex A to vertex B indicates that process A is dependent on process B. # **Objective** Write a function named `contains_cycle` that determines if a given directed graph contains a cycle or not. # **Function Signature** ```python def contains_cycle(graph: Dict[str, List[str]]) -> bool: ``` # **Input** - `graph` (dictionary): A dictionary where the keys are string vertex names and the values are lists of strings representing adjacency lists of outgoing edges. # **Output** - A boolean value: * `True` if the graph contains a cycle. * `False` if the graph does not contain a cycle. # **Constraints** - All vertex names are unique. - Self-loops and multi-edges are allowed. # **Example** ```python graph1 = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } graph2 = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'D\'], \'D\': [] } print(contains_cycle(graph1)) # Output: True print(contains_cycle(graph2)) # Output: False ``` # **Explanation** - **Graph1** contains a cycle in which vertex \'B\' depends on \'E\', which in turn depends back on \'B\'. - **Graph2** is a simple linear graph without any cycles. # **Performance Requirements** - The function should efficiently handle graphs with up to 10^5 vertices and 10^6 edges.","solution":"def contains_cycle(graph): def dfs(vertex): if vertex in visiting: return True if vertex in visited: return False visiting.add(vertex) for neighbor in graph.get(vertex, []): if dfs(neighbor): return True visiting.remove(vertex) visited.add(vertex) return False visiting = set() visited = set() for vertex in graph: if dfs(vertex): return True return False"},{"question":"# Problem: Optimize Fibonacci Calculation You are given three methods to compute the n-th Fibonacci number: recursive, list-based dynamic programming, and iterative. Each method has different performance characteristics. Your task is to combine these methods into a hybrid solution that intelligently chooses the best-suited method based on the input size. Requirements 1. Implement a function `fib_hybrid(n)` that selects the most efficient algorithm based on the input size `n`. 2. Use the recursive approach for small n (e.g., n < 10). 3. Use the list-based dynamic method for intermediate values (e.g., 10 <= n <= 50). 4. Use the iterative method for large n (e.g., n > 50). 5. Ensure that your function handles edge cases, including: - Negative values of n (should raise an appropriate error). - Very large values of n in the optimal time and space complexity. Function Signature ```python def fib_hybrid(n): Computes the n-th Fibonacci number by selecting the optimal algorithm. Arguments: n: int -- the index of the Fibonacci number to compute Returns: int -- the n-th Fibonacci number pass ``` Input Format - A single integer `n` (0 <= n <= 10^5) Output Format - A single integer representing the n-th Fibonacci number. Constraints - The function must execute in a reasonable amount of time according to the size of `n`. Example ```python print(fib_hybrid(5)) # Output: 5 print(fib_hybrid(20)) # Output: 6765 print(fib_hybrid(100)) # Output: 354224848179261915075 ``` Explanation - For `n = 5`, the function calls a recursive method and returns Fibonacci(5) = 5. - For `n = 20`, the function uses dynamic programming to return Fibonacci(20) = 6765. - For `n = 100`, the function iteratively computes Fibonacci(100) = 354224848179261915075.","solution":"def fib_recursive(n): if n <= 1: return n return fib_recursive(n-1) + fib_recursive(n-2) def fib_dynamic(n): if n == 0: return 0 fib_list = [0, 1] for i in range(2, n + 1): fib_list.append(fib_list[-1] + fib_list[-2]) return fib_list[n] def fib_iterative(n): if n == 0: return 0 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b def fib_hybrid(n): if n < 0: raise ValueError(\\"n must be a non-negative integer\\") if n < 10: return fib_recursive(n) elif n <= 50: return fib_dynamic(n) else: return fib_iterative(n)"},{"question":"Given a binary tree, implement a function to perform an in-order traversal and return the list of node values. You must provide two solutions: one iterative and one recursive. # Function Signature ```python def inorder_iterative(root: Node) -> List[int]: pass def inorder_recursive(root: Node) -> List[int]: pass ``` # Input - `root`: The root node of a binary tree (`Node`), where `Node` is defined as: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output - Return a list containing node values in in-order traversal order. # Constraints - The number of nodes in the tree is in the range `[0, 1000]`. - Node values are unique. # Performance Requirements - Both solutions should have O(n) time complexity. - Iterative solution should have O(h) space complexity. - Recursive solution should handle stack depths for up to 1000 nodes. # Context Using in-order traversal helps to retrieve elements of the tree in a sorted manner if the tree is a Binary Search Tree (BST). For balanced trees, the in-order traversal ensures that the nodes are accessed in a non-decreasing order. # Example ```python # Example tree structure: # 1 # / # 2 3 # / # 4 5 n1 = Node(1) n2 = Node(2) n3 = Node(3) n4 = Node(4) n5 = Node(5) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 assert inorder_iterative(n1) == [4, 2, 5, 1, 3] assert inorder_recursive(n1) == [4, 2, 5, 1, 3] ```","solution":"from typing import List class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def inorder_iterative(root: Node) -> List[int]: result = [] stack = [] current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_recursive(root: Node) -> List[int]: result = [] def inorder(node: Node): if node is not None: inorder(node.left) result.append(node.val) inorder(node.right) inorder(root) return result"},{"question":"You are given a binary tree and your task is to implement a function that returns the preorder traversal of its nodes\' values in an iterative manner. **Function Signature:** ```python def iterative_preorder_traversal(root: Node) -> List[int]: pass ``` # Input - `root` (Node): A Node representing the root of the binary tree. Each node has an integer value, and left and right pointers to its child nodes. # Output - Returns a List of integers representing the preorder traversal. # Constraints - The number of nodes in the tree is in the range [0, 10^4]. - Node values are integers and can be positive or negative. # Example ```python # Example binary tree: # 1 # / # 2 3 # / # 4 5 node4 = Node(4) node5 = Node(5) node2 = Node(2, node4, node5) node3 = Node(3) root = Node(1, node2, node3) result = iterative_preorder_traversal(root) print(result) # Output: [1, 2, 4, 5, 3] ``` # Description Implement the `iterative_preorder_traversal` function using an iterative approach with a stack to print the preorder traversal of the given binary tree. Ensure to carefully manage the stack operations to maintain the correct traversal order (root -> left -> right). # Edge Cases to Consider - The input tree is empty. - The tree consists of a single node. - The tree is skewed heavily to one side. # Notes: - Do not use recursion; only iterative solutions using stack should be provided.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def iterative_preorder_traversal(root: Node) -> list: if not root: return [] stack = [root] result = [] while stack: node = stack.pop() if node: result.append(node.val) # right child is pushed first so that left is processed first if node.right: stack.append(node.right) if node.left: stack.append(node.left) return result"},{"question":"# Question: You are given an integer array `arr` that you need to sort using the insertion sort algorithm. Your task is to implement a function `enhanced_insertion_sort` which sorts the array in ascending order and includes an optimization for detecting already sorted subarrays to reduce unnecessary comparisons. Function Signature ```python def enhanced_insertion_sort(arr: List[int]) -> List[int]: pass ``` Input * `arr`: A list of integers `[-1000 <= arr[i] <= 1000]` with `1 <= len(arr) <= 1000`. Output * A sorted list of integers in ascending order. Constraints * You should focus on optimizing the algorithm to handle already sorted sections efficiently. Example ```python assert enhanced_insertion_sort([5, 2, 9, 1, 5, 6]) == [1, 2, 5, 5, 6, 9] assert enhanced_insertion_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert enhanced_insertion_sort([4, 3, 2, 10, 12, 1, 5, 6]) == [1, 2, 3, 4, 5, 6, 10, 12] ``` Explanation In the above example, the function should correctly handle: 1. Standard unsorted array (`[5, 2, 9, 1, 5, 6]`). 2. Already sorted array (`[1, 2, 3, 4, 5]`), where the optimization should reduce unnecessary comparisons. 3. Partly sorted array with large and small values mixed (`[4, 3, 2, 10, 12, 1, 5, 6]`).","solution":"from typing import List def enhanced_insertion_sort(arr: List[int]) -> List[int]: Sorts the array using an optimized insertion sort algorithm. n = len(arr) for i in range(1, n): key = arr[i] j = i - 1 # skip unnecessary comparisons if the subarray is already sorted if arr[j] <= key: continue # Move elements of arr[0..i-1], that are greater than key, # to one position ahead of their current position while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"# Question: Implement a Minimum Stack Given the abstract class `AbstractStack` and its two implementations `ArrayStack` and `LinkedListStack`, your task is to implement a subclass `MinStack` that supports the following additional functionalities: 1. `get_min()`: Returns the minimum element in the stack in O(1) time complexity. Your `MinStack` should provide the functionalities of a regular stack (`push`, `pop`, `peek`, `is_empty`) along with an efficient way to track and retrieve the current minimum element. **Input/Output Specifications**: * Function signature for `get_min(self) -> int` method. * Your `MinStack` should inherit from `AbstractStack`. **Constraints**: * Assume the stack contains only integers. * You should handle exceptions when operations like `pop`, `peek`, or `get_min` are called on an empty stack. # Example ```python stack = MinStack() stack.push(3) stack.push(5) print(stack.get_min()) # Output: 3 stack.push(2) stack.push(1) print(stack.get_min()) # Output: 1 stack.pop() print(stack.get_min()) # Output: 2 stack.pop() print(stack.peek()) # Output: 5 ``` # Notes: 1. You may implement `MinStack` as an Array-backed or Linked-List-backed stack, whichever you prefer. 2. Ensure to handle edge cases and provide an efficient solution.","solution":"class AbstractStack: def push(self, item): raise NotImplementedError def pop(self): raise NotImplementedError def peek(self): raise NotImplementedError def is_empty(self): raise NotImplementedError class ArrayStack(AbstractStack): def __init__(self): self.stack = [] def push(self, item): self.stack.append(item) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.stack.pop() def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def is_empty(self): return len(self.stack) == 0 class MinStack(ArrayStack): def __init__(self): super().__init__() self.min_stack = [] def push(self, item): super().push(item) if not self.min_stack or item <= self.get_min(): self.min_stack.append(item) def pop(self): item = super().pop() if item == self.get_min(): self.min_stack.pop() return item def get_min(self): if self.is_empty(): raise IndexError(\\"get_min from empty stack\\") return self.min_stack[-1]"},{"question":"# Key Exchange with Enhanced Security Alice and Bob want to share a secret key through an insecure channel by leveraging the Diffie-Hellman key exchange method. Implement a function `secure_diffie_hellman(p, a)` that verifies if the given `p` is a prime and `a` is a primitive root of `p` before performing the key exchange. Instruction: 1. If `p` is not a prime number or `a` is not a primitive root of `p`, return `None`. 2. Alice and Bob should generate their private and public keys according to the Diffie-Hellman key exchange method. 3. Compute the shared secret key and ensure both parties derive the same shared secret. 4. Return `True` if the shared keys match, otherwise `False`. Input: * `p` (int): A large prime number. * `a` (int): A primitive root of `p`. Output: * (bool | None): - Return `True` if the shared keys computed by Alice and Bob are identical. - Return `False` if they are different. - Return `None` if `p` is not prime or `a` is not a primitive root of `p`. Constraints: * Ensure the prime check and primitive root identification are robust for large values. * Performance expectations are O(log secret) for key generation and check steps. Example: ```python def secure_diffie_hellman(p, a): # Your implementation here # Example usage p = 23 a = 5 print(secure_diffie_hellman(p, a)) # It should print True if the provided inputs are correct ``` The algorithm should exhibit the concepts discussed in the provided analysis including checking the primality and primitive root condition before performing the secure key exchange.","solution":"import random from sympy import isprime, primerange def is_primitive_root(a, p): Check if a is a primitive root of prime p or not. if not isprime(p): return False required_set = set(num for num in range(1, p)) actual_set = {pow(a, d, p) for d in range(1, p)} return required_set == actual_set def secure_diffie_hellman(p, a): if not isprime(p) or not is_primitive_root(a, p): return None # Generate private keys for Alice and Bob alice_private = random.randint(1, p-1) bob_private = random.randint(1, p-1) # Generate public keys alice_public = pow(a, alice_private, p) bob_public = pow(a, bob_private, p) # Generate shared keys alice_shared_secret = pow(bob_public, alice_private, p) bob_shared_secret = pow(alice_public, bob_private, p) # Verify shared secret keys return alice_shared_secret == bob_shared_secret"},{"question":"# Problem Description You are given a partially filled 9x9 Sudoku board. Your task is to complete the board such that every row, column, and 3x3 sub-box contains each digit from 1 to 9 exactly once. # Rules 1. Every number (1-9) must appear exactly once in each row. 2. Every number (1-9) must appear exactly once in each column. 3. Every number (1-9) must appear exactly once in each of the 3x3 sub-boxes of the grid. # Input - A 9x9 list of lists, `board`, where empty cells are represented by `\'.\'`. # Output - Fill the board in-place such that it represents a valid Sudoku solution. # Constraints 1. The given board is a 9x9 grid. 2. The board has at least one solution always. # Function Signature ```python def solveSudoku(board: List[List[str]]) -> None: # Your code here ``` # Example ```python board = [[\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"]] solveSudoku(board) # This should update the \'board\' to a valid Sudoku state. ``` # Solution Requirements 1. Write a function `solveSudoku` that modifies the given board. 2. The solution should be efficient in terms of computation, leveraging any possible optimizations to reduce runtime. # Notes - You may define helper methods if needed. - You can assume the input will always lead to a solvable puzzle. - Do not return any value; modify the board in-place. - Ensure your solution is well-structured and follows the coding best practices.","solution":"from typing import List def solveSudoku(board: List[List[str]]) -> None: def is_valid(board, row, col, num): # Check if num exists in the row if num in board[row]: return False # Check if num exists in the column for i in range(9): if board[i][col] == num: return False # Check if num exists in the 3x3 sub-box start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(3): for j in range(3): if board[start_row + i][start_col + j] == num: return False return True def solve(board): for row in range(9): for col in range(9): if board[row][col] == \'.\': for num in map(str, range(1, 10)): if is_valid(board, row, col, num): board[row][col] = num if solve(board): return True board[row][col] = \'.\' return False return True solve(board)"},{"question":"You are given an array of integers and a function (either sum, min, or max). Implement a `SegmentTree` class that allows for efficient range queries and point updates. The class should support the following methods: 1. **Constructor `__init__(self, arr: List[int], function: Callable[[int, int], int])`**: - Initializes the segment tree from the given array `arr` using the provided `function`. 2. **Method `query(self, L: int, R: int) -> int`**: - Returns the result of the function applied over the range `[L, R]` in the array. 3. **Method `update(self, index: int, value: int) -> None**: - Updates the element at position `index` in the array to `value` and propagates the change through the segment tree. # Input Format - The constructor will receive: - `arr`: A list of integers (1 ≤ len(arr) ≤ 10^5). - `function`: A function that takes two integers as input and returns an integer. - The `query` method will receive: - `L`: The starting index of the range (0 ≤ L < len(arr)). - `R`: The ending index of the range (L ≤ R < len(arr)). - The `update` method will receive: - `index`: The index to be updated (0 ≤ index < len(arr)). - `value`: The new value to be set at the index. # Output Format - The `query` method should return an integer corresponding to the function result over the specified range. - The `update` method does not return any value. # Example ```python # Construct a segment tree for range sum queries arr = [1, 3, 5, 7, 9, 11] function = sum tree = SegmentTree(arr, function) # Query the sum from index 1 to 3 assert tree.query(1, 3) == 15 # 3 + 5 + 7 # Update the element at index 2 to 10 tree.update(2, 10) # Query the sum again from index 1 to 3 assert tree.query(1, 3) == 20 # 3 + 10 + 7 # Construct a segment tree for range max queries arr = [1, 3, 5, 7, 9, 11] function = max tree = SegmentTree(arr, function) # Query the max from index 1 to 3 assert tree.query(1, 3) == 7 # max of (3, 5, 7) ``` # Constraints 1. The function provided will always be either `sum`, `min`, or `max`. 2. It is guaranteed that `query` and `update` calls will always be made with valid indices. 3. All values in the array and queries will be integers within the range of a valid 32-bit integer.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.function = function self.tree = [0] * (2 * self.n) self.build_tree(arr) def build_tree(self, arr): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = arr[i] # Build tree bottom-up for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, index, value): # Update the value in the leaves pos = self.n + index self.tree[pos] = value # Update values on the path to the root while pos > 1: pos //= 2 self.tree[pos] = self.function(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, L, R): res = None L += self.n R += self.n while L <= R: if L % 2 == 1: res = self.tree[L] if res is None else self.function(res, self.tree[L]) L += 1 if R % 2 == 0: res = self.tree[R] if res is None else self.function(res, self.tree[R]) R -= 1 L //= 2 R //= 2 return res"},{"question":"Scenario Suppose you have been given a dataset of integer values representing ages of people in a population. The ages are in the range [0, 100). Due to some analysis needs, you are required to sort these ages using a custom bucket sort algorithm. Each bucket will contain ages within a certain range, and you will use insertion sort to sort the elements within each bucket. Task Write a Python function `custom_bucket_sort(ages: List[int], buckets_range: int) -> List[int]` that: * Takes in a list of integers `ages` representing ages. * Takes an integer `buckets_range` which determines the range of ages that each bucket will hold (e.g., a value of 10 means each bucket will hold ages spanning 10 years). Your function should: 1. Determine the number of buckets based on `buckets_range`. 2. Distribute the ages into respective buckets. 3. Sort each bucket using insertion sort. 4. Concatenate the sorted buckets to get the final sorted list. Constraints * Each element in ages lies in the range [0, 100). * The `buckets_range` is a positive integer and a divisor of 100. Inputs and Outputs * **Input**: * `ages`: List of integers (0 ≤ age < 100) * `buckets_range`: Integer (1 ≤ buckets_range ≤ 100) * **Output**: * List of ages sorted in non-decreasing order. Example ```python def custom_bucket_sort(ages: List[int], buckets_range: int) -> List[int]: # Your code here # Example print(custom_bucket_sort([23, 45, 22, 18, 35, 13, 67], 10)) # Output: [13, 18, 22, 23, 35, 45, 67] ```","solution":"from typing import List def insertion_sort(arr: List[int]) -> List[int]: for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def custom_bucket_sort(ages: List[int], buckets_range: int) -> List[int]: if not ages: return [] # Number of buckets num_buckets = 100 // buckets_range buckets = [[] for _ in range(num_buckets)] # Distribute ages into buckets based on `buckets_range` for age in ages: index = age // buckets_range buckets[index].append(age) # Sort each bucket and concatenate the results sorted_ages = [] for bucket in buckets: sorted_ages.extend(insertion_sort(bucket)) return sorted_ages"},{"question":"# Scenario: You have recently taken a class where various sorting algorithms were discussed. One of the algorithms discussed was Bogo Sort, a highly inefficient and academic sorting method. To illustrate its inefficiency, you are to implement this algorithm but also create a function to estimate the probability distribution of the sort completing within a given number of shuffles. # Task: Implement a function `bogo_sort_simulation(arr, max_shuffles, simulation=False)` that attempts to sort an array using the Bogo Sort algorithm. Additionally, the function should return the number of shuffles performed and a Boolean indicating whether sorting was achieved within the given maximum shuffles. # Function Signature: ```python def bogo_sort_simulation(arr: list, max_shuffles: int, simulation=False) -> (list, int, bool): ``` # Input: - `arr` (list): The list of numbers to sort. - `max_shuffles` (int): The maximum number of shuffles to attempt before stopping. - `simulation` (bool): A flag for printing each shuffle iteration, set to False by default. # Output: - (sorted_list, shuffles, success): A tuple containing the sorted list, the number of shuffles performed, and a Boolean indicating whether the sort was successful within the given shuffles. # Constraints: - The list `arr` can have up to 20 elements, where each element is an integer within the range ([-10^9, 10^9]). - The maximum number of shuffles won\'t exceed 10^6. # Requirements: - Ensure that the function handles edge cases like empty lists, already sorted lists, and lists with duplicate elements efficiently. - Print each shuffle only if `simulation` is set to True. # Example: ```python arr = [3, 2, 1] max_shuffles = 1000 simulation = True result = bogo_sort_simulation(arr, max_shuffles, simulation) print(result) # Output: ([1, 2, 3], <shuffles_count>, <success>) ```","solution":"import random def is_sorted(arr): Helper function to check if the array is sorted. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def bogo_sort_simulation(arr, max_shuffles, simulation=False): Attempts to sort an array using the bogo sort algorithm. Parameters: arr (list): The list of numbers to sort. max_shuffles (int): The maximum number of shuffles to attempt before stopping. simulation (bool): A flag for printing each shuffle iteration, set to False by default. Returns: tuple: A tuple containing the sorted list, the number of shuffles performed, and a Boolean indicating whether the sort was successful within the given shuffles. shuffles = 0 while shuffles < max_shuffles: if is_sorted(arr): return (arr, shuffles, True) random.shuffle(arr) shuffles += 1 if simulation: print(f\'Shuffle {shuffles}: {arr}\') return (arr, shuffles, is_sorted(arr))"},{"question":"# Question Statement You are working on a large data processing application that needs to frequently sort datasets of varying sizes. To ensure robust and efficient sorting, you will implement a classic sorting algorithm known as Merge Sort. # Task Write a function `merge_sort(arr)` that takes a list of integers `arr` and returns a new list with the elements sorted in non-decreasing order. # Input - A python list `arr` of integers (0 <= len(arr) <= 10^5) # Output - A python list with the elements of `arr` sorted in non-decreasing order. # Constraints - You must use merge sort to sort the list. - Aim to achieve an O(n log n) time complexity. # Example **Example 1:** ```python Input: [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] Output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] ``` **Example 2:** ```python Input: [] Output: [] ``` **Example 3:** ```python Input: [1] Output: [1] ``` # Additional Notes - Make sure to handle edge cases such as empty arrays and single-element arrays. - Your implementation should use a helper function to merge subarrays. - Avoid unnecessary copying of arrays and ensure in-place merging where possible. - Be mindful of the space complexity and try to minimize it where possible.","solution":"def merge_sort(arr): Sorts the array using the merge sort algorithm. Parameters: arr (list): List of integers to be sorted. Returns: list: New list with elements sorted in non-decreasing order. # Base case: if the list is empty or has one element, return it if len(arr) <= 1: return arr # Split the array into two halves mid = len(arr) // 2 left_half = arr[:mid] right_half = arr[mid:] # Recursively sort the two halves left_sorted = merge_sort(left_half) right_sorted = merge_sort(right_half) # Merge the sorted halves and return the result return merge(left_sorted, right_sorted) def merge(left, right): Merges two sorted lists into one sorted list. Parameters: left (list): Left sorted list. right (list): Right sorted list. Returns: list: Merged sorted list. merged = [] left_index, right_index = 0, 0 # Compare the elements of the two lists and merge them while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: merged.append(left[left_index]) left_index += 1 else: merged.append(right[right_index]) right_index += 1 # Append any remaining elements from the left and right lists merged.extend(left[left_index:]) merged.extend(right[right_index:]) return merged"},{"question":"You have been provided with a class `Graph` that represents a directed graph using adjacency lists. The class includes a function `transitive_closure` which computes the transitive closure of the graph using Depth-First Search (DFS). Your task is to extend the functionality provided in the class to include methods for finding the strongly connected components (SCCs) of the graph. Strongly connected components of a directed graph are subgraphs where every vertex is reachable from every other vertex in the same subgraph. Function To Implement: ```python class Graph: def find_sccs(self): This function should find and return all strongly connected components in the graph. Returns: A list of lists, where each sublist represents a strongly connected component. pass ``` Input: - The methods `__init__` and `add_edge` already exist in the Graph class and should be utilized. - The graph can have up to 10,000 vertices and 100,000 edges. Output: - The function should return a list of strongly connected components - each component represented as a list of vertex indices. Constraints: - The graph can be disconnected or strongly connected. - Consider edge cases where the graph has zero or one vertex. Example: ```python # Create a graph given in the above diagram g = Graph(5) g.add_edge(1, 0) g.add_edge(0, 2) g.add_edge(2, 1) g.add_edge(0, 3) g.add_edge(3, 4) print(g.find_sccs()) # Output could be a list such as [[0, 1, 2], [3], [4]] ``` Additional Information: - You may use any standard algorithm to find SCCs (e.g., Kosaraju\'s or Tarjan\'s algorithm). - Ensure that your implementation focuses on efficiency.","solution":"class Graph: def __init__(self, vertices): self.graph = [[] for _ in range(vertices)] self.V = vertices def add_edge(self, u, v): self.graph[u].append(v) def find_sccs(self): Finds and returns all strongly connected components in the graph. Returns: A list of lists, where each sublist represents a strongly connected component. def dfs(v, visited, stack): visited[v] = True for nbr in self.graph[v]: if not visited[nbr]: dfs(nbr, visited, stack) stack.append(v) def transpose(): g_t = Graph(self.V) for i in range(self.V): for nbr in self.graph[i]: g_t.add_edge(nbr, i) return g_t def dfs_util(v, visited, component): visited[v] = True component.append(v) for i in g_t.graph[v]: if not visited[i]: dfs_util(i, visited, component) stack = [] visited = [False] * self.V for i in range(self.V): if not visited[i]: dfs(i, visited, stack) g_t = transpose() visited = [False] * self.V sccs = [] while stack: i = stack.pop() if not visited[i]: component = [] dfs_util(i, visited, component) sccs.append(component) return sccs"},{"question":"# Bitwise Manipulation for Memory Optimization You are working on a memory-constrained IoT device where efficient data storage is crucial. You\'ve been assigned a task to manage a series of flags (boolean values) stored within an 8-bit register (an integer between 0 and 255). Each bit in this register represents an on/off state for various sensors attached to the device. Write a function, `set_sensor_state`, that takes three parameters: 1. `register` (an integer between 0 and 255): the current state of all sensors. 2. `sensor_index` (an integer between 0 and 7): the index of the sensor whose state we need to update. 3. `state` (a boolean value): the new state of the sensor. The function should return a new integer representing the updated state of all sensors after applying the new state. # Function Signature ```python def set_sensor_state(register: int, sensor_index: int, state: bool) -> int: pass ``` # Input - `register`: an integer in the range [0, 255] - `sensor_index`: an integer in the range [0, 7] - `state`: a boolean value (True for ON, False for OFF) # Output - An integer representing the updated state of all sensors. # Constraints - You must use bitwise operations to manipulate the sensor states. - Efficiently handle the updates in O(1) time complexity. # Example ```python assert set_sensor_state(0b00001111, 7, True) == 0b10001111 assert set_sensor_state(0b11111111, 2, False) == 0b11111011 ``` # Explanation - In the first example, the initial state is `00001111` (all sensors off except the first 4). Setting the sensor at index 7 to ON results in `10001111`. - In the second example, the initial state is `11111111` (all sensors on). Setting the sensor at index 2 to OFF results in `11111011`.","solution":"def set_sensor_state(register: int, sensor_index: int, state: bool) -> int: Sets the state of the sensor at sensor_index in the register. Args: - register (int): The current state of all sensors as an 8-bit integer (0-255). - sensor_index (int): The index of the sensor to update (0-7). - state (bool): The new state of the sensor (True for ON, False for OFF). Returns: - int: The updated register state as an 8-bit integer (0-255). if state: # Set the bit at sensor_index to 1 (turn ON) return register | (1 << sensor_index) else: # Set the bit at sensor_index to 0 (turn OFF) return register & ~(1 << sensor_index)"},{"question":"# Scenario You are working on a library management system. The book collection in the library is organized as a Binary Search Tree (BST) based on unique book ID numbers. You need to implement a function that, given a book ID, returns the successor book ID in ascending order in the BST. The successor of a given book ID is the book ID that comes immediately after it when all the book IDs are sorted in ascending order. # Function to Implement ```python def find_successor(root, book_id): Finds the inorder successor of the given book ID in the BST. Parameters: root (TreeNode): The root of the Binary Search Tree. book_id (int): The book ID for which the successor needs to be found. Returns: int: The successor book ID if exists, otherwise -1. ``` # Input * `root`: The root node of the BST, represented as a TreeNode object. * `book_id`: An integer representing the book ID. # Output * An integer representing the successor book ID. If the given book ID has no successor, return -1. # Constraints * The number of nodes in the tree will not exceed 10^4. # Example Suppose the BST is structured as follows: 20 / 10 30 15 1. `find_successor(root, 10)` should return `15`. 2. `find_successor(root, 15)` should return `20`. 3. `find_successor(root, 30)` should return `-1`. # Notes * You can assume the `TreeNode` class is already defined, where each node has `val`, `left`, and `right` attributes. * If the given book ID does not exist in the tree, the function should behave as if the book ID has no successor and return `-1`.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_successor(root, book_id): Finds the inorder successor of the given book ID in the BST. Parameters: root (TreeNode): The root of the Binary Search Tree. book_id (int): The book ID for which the successor needs to be found. Returns: int: The successor book ID if exists, otherwise -1. successor = -1 current = root while current: if book_id < current.val: successor = current.val current = current.left else: current = current.right return successor"},{"question":"# Question: Switch Successive Pairs in a Stack You have two functions that switch successive pairs in a stack using different auxiliary storages - a stack and a queue, respectively. Your goal is to implement a new function `third_switch_pairs` that takes a stack as input and switches successive pairs of elements in the stack using recursive approach. # Specifications * **Function Signature**: `third_switch_pairs(stack: List[int]) -> List[int]` * **Input**: * A list of integers representing the elements of a stack. The bottom of the stack is at index 0, and the top of the stack is at the last index. * **Output**: * The modified stack with successive pairs of elements switched. If the stack has an odd number of elements, the topmost element remains unchanged. * **Constraints**: * You may only use O(1) auxiliary space for recursion purposes. * The implementation should restrain itself from using iterative constructs like `while` or `for`. # Example ```python stack = [3, 8, 17, 9, 1, 10] # After switching successive pairs # Expected output: [8, 3, 9, 17, 10, 1] stack = [3, 8, 17, 9, 1] # After switching successive pairs # Expected output: [8, 3, 9, 17, 1] ``` # Additional Notes * Ensure your function operates without modifying the input stack directly outside the scope of recursive function calls. * Consider edge cases where the stack is empty or contains only one element. # Function Template ```python def third_switch_pairs(stack): Switch successive pairs of elements in a stack using recursion. :param stack: List[int] - The stack represented as a list of integers :return: List[int] - The modified stack with pairs switched # Your implementation here ```","solution":"def third_switch_pairs(stack): Switch successive pairs of elements in a stack using recursion. :param stack: List[int] - The stack represented as a list of integers :return: List[int] - The modified stack with pairs switched def helper(index): # Base case: If we reached the end or there\'s a single element left, stop. if index >= len(stack) - 1: return # Swap the pair stack[index], stack[index + 1] = stack[index + 1], stack[index] # Recur to the next pair helper(index + 2) # Call the helper function starting from the bottom of the stack helper(0) return stack"},{"question":"# Challenging Coding Assessment **Context**: In computational analysis, sorting algorithms are fundamental due to their wide range of applications in various domains like databases, search engines, and more. Understanding and implementing different sorting algorithms helps in recognizing their suitability and performance characteristics in different scenarios. **Problem Statement**: Implement the Comb Sort algorithm in Python, which sorts an array of integers in ascending order. Your implementation should maintain the core principles of Comb Sort, including the initial large gap comparisons and gradual reduction of the gap size. **Function Signature**: ```python def comb_sort(arr: List[int]) -> List[int]: ``` **Input**: - `arr`: A list of integers (e.g., [-1, 3, 0, 4, 5, 9, -2]) **Output**: - Returns a new list of integers, sorted in ascending order. **Constraints**: - The function should handle lists up to 10^6 elements efficiently. - The original list should not be modified. - You may assume all input elements are integers. **Performance Requirements**: - Aim for an average case time complexity of (O(n log n)). **Example**: ```python assert comb_sort([10, 7, 3, 1, 9, 7, 4, 3]) == [1, 3, 3, 4, 7, 7, 9, 10] assert comb_sort([]) == [] assert comb_sort([1]) == [1] assert comb_sort([2, 1]) == [1, 2] ``` **Instructions**: 1. Implement the `comb_sort` function following the provided function signature. 2. Ensure your solution is efficient and handles edge cases described above. 3. Write comprehensive tests to validate the correctness and performance of your implementation.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Implements the Comb Sort algorithm to sort a list of integers in ascending order. This function does not modify the original list; it returns a new sorted list. def get_next_gap(gap): # Shrink gap by the factor of 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) new_arr = arr.copy() gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if new_arr[i] > new_arr[i + gap]: new_arr[i], new_arr[i + gap] = new_arr[i + gap], new_arr[i] swapped = True return new_arr"},{"question":"You are tasked with enhancing a B-Tree implementation provided in the code snippets. The current implementation supports searching, insertion, and deletion operations. However, it lacks functionality for balancing the tree during complex deletions where nodes may fall below the minimum number of keys. Task: Your task is to complete the implementation of the `BTree` class, ensuring it correctly maintains the tree balance across deletions. # Requirements: 1. Implement a `repair_tree` method that rebalances the B-Tree during deletions: - **Rotate left/right** if adjacent siblings have enough keys to share. - **Merge nodes** when siblings also have the minimum number of keys after deleting a key. 2. Modify the `remove_key` method to use `repair_tree` when necessary. # Function Signature ```python class BTree: ... def _repair_tree(self, node: Node, child_index: int) -> bool: Rebalances the tree expanding or merging nodes as needed during deletion. Arguments: - node: Node -- The node containing children that might need rebalancing. - child_index: int -- The index of the child to check and potentially rebalance. Returns: - bool -- True if a rebalancing action took place, otherwise False. ... def remove_key(self, key): Initiates the process to remove a key from the B-Tree. Arguments: - key: int -- The key to remove from the B-Tree. ... ``` # Input/Output Formats - **Input**: An integer key to be removed. - **Output**: The specified key should be removed from the B-Tree, while maintaining the tree\'s properties. # Constraints: - The B-Tree must remain balanced after insertion and deletion. - The implementation must handle edge cases, such as: - Deleting from leaves and internal nodes. - Balancing when an entire level might be removed due to underflow. # Example ```python btree = BTree(t_val=3) keys = [10, 20, 5, 6, 12, 30, 7, 17] for key in keys: btree.insert_key(key) btree.traverse_tree() # Output: [5, 6, 7, 10, 12, 17, 20, 30] btree.remove_key(6) btree.traverse_tree() # Output: [5, 7, 10, 12, 17, 20, 30] btree.remove_key(17) btree.traverse_tree() # Output: [5, 7, 10, 12, 20, 30] ``` # Additional Notes: - Comprehensive unit tests should be written to cover all edge cases. - Ensure efficient management of node pointers and memory.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t self.leaf = leaf self.keys = [] self.children = [] def find_key(self, k): for i, key in enumerate(self.keys): if k == key: return i elif k < key: return i return len(self.keys) def remove_key(self, key): idx = self.find_key(key) if idx < len(self.keys) and self.keys[idx] == key: if self.leaf: self.keys.pop(idx) else: self._remove_from_non_leaf(idx) else: if self.leaf: return flag = (idx == len(self.keys)) if len(self.children[idx].keys) < self.t: self._fill(idx) if flag and idx > len(self.keys): self.children[idx-1].remove_key(key) else: self.children[idx].remove_key(key) def _remove_from_non_leaf(self, idx): key = self.keys[idx] if len(self.children[idx].keys) >= self.t: pred = self._get_pred(idx) self.keys[idx] = pred self.children[idx].remove_key(pred) elif len(self.children[idx+1].keys) >= self.t: succ = self._get_succ(idx) self.keys[idx] = succ self.children[idx+1].remove_key(succ) else: self._merge(idx) self.children[idx].remove_key(key) def _get_pred(self, idx): current = self.children[idx] while not current.leaf: current = current.children[-1] return current.keys[-1] def _get_succ(self, idx): current = self.children[idx+1] while not current.leaf: current = current.children[0] return current.keys[0] def _fill(self, idx): if idx != 0 and len(self.children[idx-1].keys) >= self.t: self._borrow_from_prev(idx) elif idx != len(self.keys) and len(self.children[idx+1].keys) >= self.t: self._borrow_from_next(idx) else: if idx != len(self.keys): self._merge(idx) else: self._merge(idx-1) def _borrow_from_prev(self, idx): child = self.children[idx] sibling = self.children[idx-1] child.keys.insert(0, self.keys[idx-1]) if not child.leaf: child.children.insert(0, sibling.children.pop()) self.keys[idx-1] = sibling.keys.pop() def _borrow_from_next(self, idx): child = self.children[idx] sibling = self.children[idx+1] child.keys.append(self.keys[idx]) if not child.leaf: child.children.append(sibling.children.pop(0)) self.keys[idx] = sibling.keys.pop(0) def _merge(self, idx): child = self.children[idx] sibling = self.children[idx+1] child.keys.append(self.keys[idx]) child.keys.extend(sibling.keys) if not child.leaf: child.children.extend(sibling.children) self.keys.pop(idx) self.children.pop(idx+1) class BTree: def __init__(self, t): self.t = t self.root = BTreeNode(t, True) def insert_key(self, key): if len(self.root.keys) == 2 * self.t - 1: new_root = BTreeNode(self.t, False) new_root.children.append(self.root) self._split_child(new_root, 0) self.root = new_root self._insert_non_full(self.root, key) def _insert_non_full(self, node, key): if node.leaf: node.keys.append(key) node.keys.sort() else: idx = node.find_key(key) if len(node.children[idx].keys) == 2 * self.t - 1: self._split_child(node, idx) if key > node.keys[idx]: idx += 1 self._insert_non_full(node.children[idx], key) def _split_child(self, parent, idx): t = self.t node = parent.children[idx] new_node = BTreeNode(t, node.leaf) parent.children.insert(idx + 1, new_node) parent.keys.insert(idx, node.keys[t - 1]) new_node.keys = node.keys[t:] node.keys = node.keys[:t - 1] if not node.leaf: new_node.children = node.children[t:] node.children = node.children[:t] def remove_key(self, key): if not self.root: return self.root.remove_key(key) if len(self.root.keys) == 0: if self.root.leaf: self.root = None else: self.root = self.root.children[0] def traverse_tree(self): return self._traverse_tree(self.root) def _traverse_tree(self, node): if node: result = [] for i in range(len(node.keys)): if not node.leaf: result.extend(self._traverse_tree(node.children[i])) result.append(node.keys[i]) if not node.leaf: result.extend(self._traverse_tree(node.children[len(node.keys)])) return result else: return []"},{"question":"You have been given an array of integers. Your task is to implement a data structure that supports the following operations efficiently: 1. **update(index, value)**: Update the element at the given index to a new value. 2. **prefix_sum(index)**: Get the sum of elements from the start of the array to the given index. # Input Format * The first line of the input consists of an integer `n`, the length of the array. * The second line consists of `n` integers representing the elements of the array. * The following lines contain a series of operations, where each operation is either `1 index value` (update operation) or `2 index` (prefix sum operation). - `1 index value`: Update the element at the given `index` (0-based) to `value`. - `2 index`: Get the prefix sum of the elements up to `index` (0-based). # Output Format For each `2 index` operation, return the corresponding prefix sum. # Constraints * `1 <= n <= 10^5` * `0 <= array[i] <= 10^9` * `0 <= index < n` * The number of operations does not exceed `10^5`. # Example Input ``` 6 1 3 5 7 9 11 2 3 1 3 10 2 3 2 4 ``` Output ``` 16 19 28 ``` # Explanation 1. The given array is `[1, 3, 5, 7, 9, 11]`. 2. The prefix sum up to index 3 is `1 + 3 + 5 + 7 = 16`. 3. After updating the element at index 3 to 10, the new array is `[1, 3, 5, 10, 9, 11]`. 4. The prefix sum up to index 3 is now `1 + 3 + 5 + 10 = 19`. 5. The prefix sum up to index 4 is `1 + 3 + 5 + 10 + 9 = 28`.","solution":"class EfficientArray: def __init__(self, array): self.array = array self.n = len(array) self.bit = [0] * (self.n + 1) for i in range(self.n): self._update_bit(i, array[i]) def _update_bit(self, index, value): index += 1 while index <= self.n: self.bit[index] += value index += index & -index def update(self, index, value): diff = value - self.array[index] self.array[index] = value self._update_bit(index, diff) def prefix_sum(self, index): result = 0 index += 1 while index > 0: result += self.bit[index] index -= index & -index return result"},{"question":"You have been given an array of integers. Your task is to implement the Selection Sort algorithm to sort this array in ascending order. Your function must not use any built-in sorting functions and should work in-place. Function Signature ```python def selection_sort(arr: List[int]) -> List[int]: pass ``` Input * `arr`: A list of integers (0 ≤ len(arr) ≤ 10^3; -10^3 ≤ arr[i] ≤ 10^3). Output * A list of integers sorted in ascending order. Constraints * Try to minimize the number of swaps to enhance performance. * Ensure that the function handles edge cases such as an empty array or arrays with one element. Example ```python assert selection_sort([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64] assert selection_sort([]) == [] assert selection_sort([5]) == [5] assert selection_sort([2, 1, 2, 1, 3]) == [1, 1, 2, 2, 3] ``` Notes The problem is designed to test understanding of a fundamental sorting algorithm and its implementation details. The purpose is to assess the comprehension of nested loops and in-place sorting techniques.","solution":"from typing import List def selection_sort(arr: List[int]) -> List[int]: Sorts an array of integers in ascending order using the selection sort algorithm. This function works in-place and does not use any built-in sorting functions. Parameters: arr (List[int]): The list of integers to be sorted. Returns: List[int]: The sorted list of integers. n = len(arr) for i in range(n): # Assume the min value is at the i-th position min_idx = i # Iterate from i+1 to end of array to find the actual min value for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j # Swap only if the min value found is not already at the i-th position if min_idx != i: arr[i], arr[min_idx] = arr[min_idx], arr[i] return arr"},{"question":"Identifying Two Unique Numbers **Scenario**: You are tasked with creating a function to identify exactly two unique numbers in an array where every other number appears exactly twice. This task is crucial in various data processing applications, including error detection and cryptography, where identifying outliers or anomaly detection plays a critical role. **Problem Statement**: Write a function that takes an array `nums` of integers where exactly two elements appear only once and all the other elements appear exactly twice. The function should return the two elements that appear only once. **Function Signature**: ```python def find_unique_numbers(nums: List[int]) -> List[int]: pass ``` # Requirements 1. **Input**: - `nums`: A list of integers, where `1 <= len(nums) <= 10^5` and all elements except two appear exactly twice. 2. **Output**: - A list of the two unique integers. 3. **Expected Time Complexity**: O(N) 4. **Expected Space Complexity**: O(1) 5. **Order of results**: The order of the integers in the output does not matter. # Example: ```python assert find_unique_numbers([1, 2, 1, 3, 2, 5]) in [[3, 5], [5, 3]] ``` **Hints**: 1. Investigate how XOR operation can help in solving this problem. 2. Consider dividing the entire set of numbers into two subsets. # Constraints: - The array will always contain exactly two unique elements. - The rest of the elements will appear in pairs. Implement this function to demonstrate your understanding of bitwise operations and efficient data structure handling in Python.","solution":"from typing import List def find_unique_numbers(nums: List[int]) -> List[int]: # XOR all the numbers. After this step, the result will be the XOR of the two unique numbers. xor_result = 0 for num in nums: xor_result ^= num # Get the rightmost set bit in xor_result. This bit will differ between the two unique numbers. rightmost_set_bit = xor_result & -xor_result # Divide the numbers into two groups and XOR separately. num1, num2 = 0, 0 for num in nums: if num & rightmost_set_bit: num1 ^= num else: num2 ^= num return [num1, num2]"},{"question":"# Unique Permutations Problem Context You are generating configurations for a scientific experiment where only unique sequences of operations matter. Given a list of potential operations that might contain duplicates, you need to generate all possible unique sequences to ensure each configuration is evaluated without redundancy. Task Write a function `unique_permutations(nums)` that returns all unique permutations of the input list `nums`. The input list may contain duplicates, and the output should include only distinct permutations. Input * A list of integers `nums` where - (10^{-9} leq nums[i] leq 10^9). * The length of `nums` will not exceed 8 for practical concerns of time complexity. Output * A list of lists, where each sublist represents a unique permutation of the input list. Constraints * Ensure that the function implements efficient handling of duplicates to avoid redundant calculations. * Do not use built-in permutation functions from modules such as `itertools`. Example ```python unique_permutations([1,1,2]) ``` Should return: ```python [ [1, 1, 2], [1, 2, 1], [2, 1, 1] ] ``` Notes * Consider edge cases like an empty list or lists with all identical elements. * Ensure that the solution is optimized for time and space within the given constraints. Write the function definition below:","solution":"def unique_permutations(nums): Returns all unique permutations of the list nums. def backtrack(start): if start == len(nums): result.append(nums[:]) return seen = set() for i in range(start, len(nums)): if nums[i] not in seen: seen.add(nums[i]) nums[start], nums[i] = nums[i], nums[start] backtrack(start + 1) nums[start], nums[i] = nums[i], nums[start] result = [] nums.sort() backtrack(0) return result"},{"question":"**String Reversal Challenge** You are given a string and are required to reverse its characters. Implement a function to reverse the string using the iterative method. # Function Signature ```python def reverse_string(s: str) -> str: pass ``` # Inputs: * `s` (str): The input string to be reversed. It can contain letters, digits, and special characters. # Output: * A string which is the reverse of the input string. # Constraints: * The length of the string will be between 0 and 10^6. # Performance Requirements: * The solution should have a time complexity of O(n) and space complexity of O(n), where n is the length of the string. # Example: ```python assert reverse_string(\\"hello\\") == \\"olleh\\" assert reverse_string(\\"Algorithms\\") == \\"smhtiroglA\\" assert reverse_string(\\"12345!\\") == \\"!54321\\" assert reverse_string(\\"\\") == \\"\\" ``` # Hints: * Consider converting the string to a list to perform in-place swaps. * Ensure to handle edge cases such as empty strings properly.","solution":"def reverse_string(s: str) -> str: Reverses the input string using an iterative method. Args: s (str): The input string to be reversed. Returns: str: The reversed string. # Convert the string to a list to manipulate it in place chars = list(s) # Initialize pointers for the start and end of the list left, right = 0, len(chars) - 1 # Swap characters from the ends towards the center while left < right: # Swap the characters chars[left], chars[right] = chars[right], chars[left] # Move pointers towards the center left += 1 right -= 1 # Convert the list back to a string and return return \'\'.join(chars)"},{"question":"# Question: Byte Order Conversion and Sequential Operations Context: In the world of data transmission and storage, integer values often need to be converted to byte sequences to ensure consistent data representation across various systems. This process becomes essential especially when systems of different endianness communicate or store data interchangeably. Objective: For this task, you are required to combine the integer-to-byte and byte-to-integer conversion functions into a single function that performs sequential operations. The function should take an integer, convert it to bytes in the specified endian format, and then convert it back to an integer. Requirements: 1. **Function Signature**: Implement a function `sequential_conversion(num: int, endian: str) -> int`. 2. **Inputs**: - `num`: A non-negative integer. - `endian`: A string that can be either `\\"big\\"` or `\\"little\\"`, indicating the byte order for conversions. 3. **Output**: - The output should be an integer resulting from converting `num` to bytes and back to integer using the specified endian format. Constraints: 1. `0 <= num <= 2**64 - 1` 2. Endian value can only be `\\"big\\"` or `\\"little\\"`. Example: ```python assert sequential_conversion(305419896, \'big\') == 305419896 assert sequential_conversion(305419896, \'little\') == 305419896 assert sequential_conversion(0, \'big\') == 0 assert sequential_conversion(0, \'little\') == 0 ``` Considerations: 1. Ensure that functions handle the edge cases, such as very small numbers and the largest value within the constraint. 2. Optimize for performance in terms of both time and space complexity. 3. Implement proper error handling for invalid inputs, but assume input validity as described in constraints for this task.","solution":"def sequential_conversion(num: int, endian: str) -> int: Convert an integer to bytes and back to integer using the specified endian format. Parameters: num (int): The integer to convert. endian (str): The endian format, either \'big\' or \'little\'. Returns: int: The resulting integer after conversion to bytes and back. if endian not in [\'big\', \'little\']: raise ValueError(\\"Endian format must be either \'big\' or \'little\'\\") # Convert the integer to bytes byte_length = (num.bit_length() + 7) // 8 or 1 byte_sequence = num.to_bytes(byte_length, endian) # Convert the byte sequence back to integer result = int.from_bytes(byte_sequence, endian) return result"},{"question":"Subset Generator Using Backtracking Given a set of distinct integers `nums`, write a function `generate_subsets` that returns all possible subsets (the power set) of the given set. The function should make use of a backtracking approach. # Requirements: - The function should handle the subsets in a recursive manner. - The solution set must not contain duplicate subsets. - The function should be robust to handle empty input arrays. # Input: - A list of distinct integers `nums` (1 <= len(nums) <= 10^6, -10^6 <= nums[i] <= 10^6). # Output: - A list of lists, where each list is a subset of the input list. # Constraints: - The output list can be in any order. - The length of the output list should be exactly `2^n` where `n` is the length of the input list. - Use a recursive approach to generate the subsets. # Example: ```python def generate_subsets(nums): # Your code here # Example 1: print(generate_subsets([1,2,3])) # Expected Output: # [ # [], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3] # ] # Example 2: print(generate_subsets([])) # Expected Output: # [ # [] # ] # Example 3: print(generate_subsets([1])) # Expected Output: # [ # [], [1] # ] ``` # Performance Requirements: - Your algorithm should have a time complexity of `O(2^n)`, but take care of stack overflows due to recursion depth for reasonably large inputs.","solution":"def generate_subsets(nums): def backtrack(start, path): subsets.append(path) for i in range(start, len(nums)): backtrack(i + 1, path + [nums[i]]) subsets = [] backtrack(0, []) return subsets"},{"question":"# Insertion Sort with Early Termination Background: You are asked to implement a modified version of the Insertion Sort algorithm. This version should include an early termination feature that stops the sorting process if the array is detected to be already sorted before the entire process completes. Task: Write a function `modified_insertion_sort(arr)` that sorts an array of integers using the insertion sort algorithm with an added early termination condition. Function Signature: ```python def modified_insertion_sort(arr: List[int]) -> List[int]: pass ``` Input: * `arr`: A list of integers. (1 leq len(arr) leq 10^5 ) and ( -10^9 leq arr[i] leq 10^9) Output: * Return the sorted list. Constraints: * Your solution must have an early termination condition and handle edge cases like an already sorted array, a reversely sorted array, and empty arrays or arrays with one element efficiently. * The solution should maintain the properties of the insertion sort algorithm. Example: ```python assert modified_insertion_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert modified_insertion_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] assert modified_insertion_sort([3, 1, 4, 1, 5, 9]) == [1, 1, 3, 4, 5, 9] assert modified_insertion_sort([]) == [] assert modified_insertion_sort([7]) == [7] ```","solution":"from typing import List def modified_insertion_sort(arr: List[int]) -> List[int]: Sorts an array using insertion sort with an early termination condition. n = len(arr) if n <= 1: return arr for i in range(1, n): key = arr[i] j = i - 1 # Move elements of arr[0..i-1] that are greater than key to one position ahead of their current position while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key # Early termination check if arr == sorted(arr): break return arr"},{"question":"# Prompt You are tasked with implementing a secure communication system using RSA encryption. You need to write functions that: 1. Generate RSA keys. 2. Encrypt a message using the public key. 3. Decrypt a message using the private key. Requirements 1. The **generate_key** function should: * Take an integer `k` representing the key size in bits. * Return a tuple `(n, e, d)` where `n` is the modulus, `e` is the encryption exponent, and `d` is the decryption exponent. * Ensure `n` (the product of two large primes) is of `k` bits size. 2. The **encrypt** function should: * Take a plaintext integer `data`, and the public key components `e` and `n`. * Return an encrypted integer. 3. The **decrypt** function should: * Take a ciphertext integer `data`, and the private key components `d` and `n`. * Return the decrypted integer. Constraints * The key size `k` should be at least 16 bits for practical reasons although modern encryption typically uses at least 2048 bits. * Assume the plaintext data is a non-negative integer less than `n`. * Ensure the encryption and decryption functions work correctly even if `k` is relatively small (e.g., 16 or 32 bits) for testing purposes. # Example ```python n, e, d = generate_key(16) data = 20 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data # should be True ``` Write the following functions: ```python import random def generate_key(k, seed=None): # Your implementation here def encrypt(data, e, n): # Your implementation here def decrypt(data, d, n): # Your implementation here ```","solution":"import random import sympy def generate_key(k, seed=None): if seed is not None: random.seed(seed) # Generate two distinct prime numbers p and q p = sympy.randprime(2**(k//2 - 1), 2**(k//2)) q = sympy.randprime(2**(k//2 - 1), 2**(k//2)) while p == q: q = sympy.randprime(2**(k//2 - 1), 2**(k//2)) n = p * q phi = (p - 1) * (q - 1) # Choose an encryption exponent e e = 65537 while sympy.gcd(e, phi) != 1: e = random.randint(2, phi - 1) # Compute the decryption exponent d d = pow(e, -1, phi) return (n, e, d) def encrypt(data, e, n): return pow(data, e, n) def decrypt(data, d, n): return pow(data, d, n)"},{"question":"# Scenario You work for a company developing a predictive text API, and you\'ve been asked to implement a component that models user typing as a Markov chain. The goal is to predict the next typed character based on the current one. # Problem Statement Given a Markov chain represented by a dictionary, write a function that simulates k transitions from a given start state. Each transition involves randomly selecting the next state based on the provided probabilities. # Function Signature ```python def simulate_markov_chain(chain: dict, start: str, k: int) -> list: pass ``` # Input * `chain`: A dictionary where keys are states (strings) and values are dictionaries. Inner dictionaries contain states that can be transitioned to and their probabilities. * `start`: A string representing the initial state. * `k`: An integer representing the number of transitions to simulate. # Output * A list of strings representing the sequence of states visited during the simulation. # Constraints * The total number of states in the chain ≤ 100. * The total number of possible transitions from any state ≤ 10. * Transition probabilities for each state will sum to 1.0. * The input Markov chain is valid. # Example ```python chain = { \'A\': {\'A\': 0.6, \'B\': 0.4}, \'B\': {\'A\': 0.3, \'B\': 0.7} } print(simulate_markov_chain(chain, \'A\', 5)) # Possible output: [\'A\', \'B\', \'B\', \'B\', \'A\'] (actual output may vary due to randomness) ``` # Additional Notes * Ensure that your function handles the edge case where `k` is zero by returning an empty list. * Consider using helper functions like `__choose_state` to ensure modular design.","solution":"import random def simulate_markov_chain(chain: dict, start: str, k: int) -> list: Simulates k transitions in a Markov chain starting from a given state. Args: - chain (dict): Markov chain represented by a dictionary where keys are states and values are dictionaries of next states with their transition probabilities. - start (str): Initial state from which to start the simulation. - k (int): Number of transitions to simulate. Returns: - list: Sequence of states visited during the simulation. def __choose_state(transitions): Chooses the next state based on the transition probabilities. Args: - transitions (dict): A dictionary where keys are states and values are their transition probabilities. Returns: - str: Chosen next state. states = list(transitions.keys()) probabilities = list(transitions.values()) return random.choices(states, weights=probabilities, k=1)[0] current_state = start result = [] for _ in range(k): result.append(current_state) current_state = __choose_state(chain[current_state]) return result"},{"question":"Context You are tasked with a problem where you need to find digits in a large, virtually infinite sequence of integers concatenated together, like `123456789101112...`. The sequence is formed by joining all positive integers in order. Objective Write a function `find_nth_digit(n)` that finds the nth digit in this sequence. Your function should be efficient in both time and space. Function Signature ```python def find_nth_digit(n: int) -> int: pass ``` Input * `n`: An integer representing the position within the infinite sequence. (1 ≤ n ≤ 10^18) Output * Return the integer value representing the nth digit in the sequence. Constraints * You must ensure your solution handles very large values of `n` efficiently, given the constraints. Examples ```python assert find_nth_digit(3) == 3 # The sequence is \\"12345678910...\\", the 3rd digit is 3. assert find_nth_digit(11) == 0 # The sequence is \\"123456789101112...\\", the 11th digit is 0. assert find_nth_digit(15) == 2 # The sequence is \\"12345678910111213...\\", the 15th digit is 2. ``` Explanation 1. The sequence of concatenated numbers starts as \\"123456789101112131415...\\". 2. For example: - To find the 11th digit, count digits in \\"12345678910\\": the 11th digit is \'0\'. - To find the 15th digit: First 9 digits are \'123456789\', next 6 digits are from the number 10 and 11; thus \'12\' is the 15th digit. Notes - Consider edge cases, such as when `n` is 1 or extremely large values of `n`. - Ensure your function returns the correct results within reasonable time for large inputs.","solution":"def find_nth_digit(n: int) -> int: # Determine the number of digits the nth digit falls into digit_length = 1 count = 9 index = 1 # This will be tracking from 1 (1 to 9), 10 (10-99), 100 (100-999) while n > digit_length * count: n -= digit_length * count digit_length += 1 count *= 10 index *= 10 # Find the exact number and digit num = index + (n - 1) // digit_length num_str = str(num) digit_index = (n - 1) % digit_length return int(num_str[digit_index])"},{"question":"Implement a Secure Atbash Cipher Function Objective Create an improved version of the Atbash cipher that includes basic validation and can handle erroneous inputs gracefully. Task Implement the function `secure_atbash(s: str) -> str` that adheres to the traditional Atbash cipher with enhancements for error handling and non-alphabetic characters. Requirements - Maintain the functionality of reversing alphabets (\'A\' to \'Z\' and \'a\' to \'z\'). - Ensure that non-alphabetic characters remain unchanged. - Ignore characters that are not printable ASCII. - Raise a descriptive error if the input string contains non-ASCII characters. Input - **s**: A string (`str`) that can include alphabetic characters, punctuation, spaces, and numbers. Output - A string (`str`) where alphabetic characters are replaced with their Atbash counterparts, while other characters remain unchanged. Constraints - The input string should not exceed 1000 characters. Example - `secure_atbash(\\"Attack at dawn!\\")` returns `Zggzxp zg wzdm!` - `secure_atbash(\\"123 #*!\\")` returns `123 #*!` - `secure_atbash(\\"Gr@de 100%\\")` returns `Ti@wv 100%` # Notes - Printable ASCII characters are in the range from 32 to 126. - Use appropriate exception handling techniques for robustness. Performance Requirements - Must run within linear time complexity O(n).","solution":"def secure_atbash(s: str) -> str: Applies the Atbash cipher on the input string `s` with error handling Args: s (str): Input string Returns: str: Ciphered string with non-alphabetic characters unchanged Raises: ValueError: if input has non-ASCII characters if any(ord(c) > 127 for c in s): raise ValueError(\\"Input string contains non-ASCII characters.\\") def atbash_char(c): if \'A\' <= c <= \'Z\': return chr(ord(\'Z\') - (ord(c) - ord(\'A\'))) elif \'a\' <= c <= \'z\': return chr(ord(\'z\') - (ord(c) - ord(\'a\'))) else: return c return \'\'.join(atbash_char(c) for c in s)"},{"question":"# Interval Operations You are given a custom data structure `Interval`, a class to represent a range of real numbers between `start` and `end`. Your task is to enhance an interval merging functionality and add a method to check whether at least one interval completely covers another interval in a list of intervals. Task 1. **Merging Intervals**: Enhance the `merge_intervals` method to take an additional list of intervals and merge it with the current list. 2. **Interval Coverage**: Implement `is_covered` method to check if at least one interval completely covers another interval in a given list of intervals. Input and Output * Given an interval list, each element represented as a tuple (start, end): * `intervals`: list of tuples [(start1, end1), (start2, end2), ...]. * For merging intervals: * **Input**: * A list of intervals `intervals` and another list of intervals `other_intervals`. * **Output**: * The merged list of intervals. * For checking coverage: * **Input**: * A list of intervals `intervals`. * **Output**: * Boolean (`True/False`) indicating if at least one interval completely covers another interval. Constraints * The intervals have integer boundaries. * Ensure efficiency, particularly needing a solution that efficiently handles large lists of intervals. Example ```python intervals1 = [(1, 3), (5, 7), (2, 4)] intervals2 = [(6, 8), (10, 12)] # For merging where on merging the two intervals lists, overlapping intervals should be merged result = merge_intervals(intervals1, intervals2) print(result) # Expected: [(1, 4), (5, 8), (10, 12)] # For checking if any interval is fully covered by another intervals3 = [(1, 5), (2, 3), (6, 9)] result = is_covered(intervals3) print(result) # Expected: True, because interval [2, 3] is covered by [1, 5]. intervals4 = [(1, 3), (4, 6), (7, 8)] result = is_covered(intervals4) print(result) # Expected: False ``` __Note__: * Ensure to handle the edge cases like: * Overlapping single elements. * Completely non-overlapping intervals. * Reverse intervals where `start` is greater than `end`.","solution":"class Interval: def __init__(self, intervals): self.intervals = sorted(intervals, key=lambda x: x[0]) def merge_intervals(self, other_intervals): combined = self.intervals + sorted(other_intervals, key=lambda x: x[0]) combined.sort(key=lambda x: x[0]) merged = [] for interval in combined: if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: merged[-1] = (merged[-1][0], max(merged[-1][1], interval[1])) return merged def is_covered(self): for i in range(len(self.intervals)): for j in range(len(self.intervals)): if i != j and self.intervals[i][0] <= self.intervals[j][0] and self.intervals[i][1] >= self.intervals[j][1]: return True return False"},{"question":"# Closest Value in Binary Search Tree You are provided a non-empty Binary Search Tree (BST) and a target value. Your task is to write a function that finds the value in the BST that is closest to the target value. Requirements: 1. **Input**: - `root`: The root node of the BST (nodes have values represented as integers). - `target`: A floating point number, the target value. 2. **Output**: - An integer, value in the BST closest to the target. 3. **Constraints**: - The BST is guaranteed to contain at least one node. - There will be only one unique value in the BST that is closest to the target. Function Signature: ```python def closest_value(root, target): :type root: TreeNode :type target: float :rtype: int ``` # Example: ```plaintext Given: . 4 / 2 5 / 1 3 Input: root = [4,2,5,1,3], target = 3.714286 Output: 4 ``` # Scenario: You are developing an automated trading system that requires extremely fast lookup of price data closest to given values. The price data over time is stored in a Binary Search Tree (BST) for efficient retrieval and update operations. Your task is to implement the closest value search in that BST model to feed downstream processes that rely on nearest neighbor data. **Hint**: Use the properties of BST to narrow down the search and recursively find the closest value.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def closest_value(root, target): :type root: TreeNode :type target: float :rtype: int closest = root.val while root: # Update closest if the current node is closer to the target if abs(root.val - target) < abs(closest - target): closest = root.val # Move left or right in the BST based on the target value if target < root.val: root = root.left else: root = root.right return closest"},{"question":"# Context A new data processing center needs a highly optimized sorting system to handle large volumes of transaction data. Overhead due to sorting time is critical and should be minimized using parallel processing techniques. One algorithm that fits well with parallel processing is the **Bitonic Sort**. # Problem Statement Implement the `bitonic_sort` function to sort an array of integers using the Bitonic Sort algorithm. Your implementation should be capable of sorting in both ascending and descending orders. The input array must have a size that is a power of two. If not, the function should raise a `ValueError`. # Function Signature ```python def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: pass ``` # Input Format - `arr`: An array of integers with a length that is a power of two. - `reverse`: A boolean flag indicating the sort order. `False` means ascending order, and `True` means descending order. Default is `False`. # Output Format - A new sorted array. # Constraints - The length of the array is guaranteed to be a power of two. - Elements of the array are integers within the range `[-10^9, 10^9]`. # Example ```python assert bitonic_sort([3, 7, 2, 8, 5, 6, 1, 4]) == [1, 2, 3, 4, 5, 6, 7, 8] assert bitonic_sort([3, 7, 2, 8, 5, 6, 1, 4], reverse=True) == [8, 7, 6, 5, 4, 3, 2, 1] ``` # Implementation Hints - Use the `compare` function to make sure that elements follow the bitonic order after each pass. - Recursively split and merge the array as described in the algorithm analysis. - Carefully handle cases where recursive depth might be large. # Constraints Handling You should ensure that your function raises a `ValueError` when the input array size is not a power of two. # Notes Although the bitonic sort can be optimized for parallel processing, your task is to implement a sequential version in Python.","solution":"from typing import List def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: if not (len(arr) and (len(arr) & (len(arr) - 1)) == 0): raise ValueError(\\"Array length must be a power of two.\\") def compare_and_swap(arr, i, j, direction): if (arr[i] > arr[j]) == direction: arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 for i in range(low, low + k): compare_and_swap(arr, i, i + k, direction) bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort_recursive(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 bitonic_sort_recursive(arr, low, k, True) bitonic_sort_recursive(arr, low + k, k, False) bitonic_merge(arr, low, cnt, direction) sort_direction = not reverse bitonic_sort_recursive(arr, 0, len(arr), sort_direction) return arr"},{"question":"You are tasked with implementing a variation of a Hash Table using linear probing for collision resolution. In linear probing, if a collision occurs, you check the next slot in the table (next index). If that slot is also occupied, you continue checking subsequent slots until you find an empty one. This approach helps to keep the table more compact and avoids the overhead of linked lists used in separate chaining. # Requirements 1. **Hash Table Class**: `LinearProbingHashTable` - **Methods and Attributes**: * `__init__(self, size=11)`: Initializes the hash table with the given size. * `put(self, key, value)`: Inserts a key-value pair into the hash table. * `get(self, key)`: Retrieves the value associated with the given key. * `del_(self, key)`: Deletes the key-value pair from the table. * `hash(self, key)`: Computes the hash index for a given key. * `rehash(self, key)`: Computes the next slot in case of a collision. * `__len__(self)`: Returns the number of key-value pairs in the table. * `__getitem__(self, key)`: Enables `value = table[key]` syntax. * `__delitem__(self, key)`: Enables `del table[key]` syntax. * `__setitem__(self, key, value)`: Enables `table[key] = value` syntax. # Input and Output Formats 1. `__init__(self, size=11)`: Initializes an empty hash table. * **Input**: `size` (integer) - The initial size of the hash table. * **Output**: `None`. 2. `put(self, key, value)`: Inserts or updates the key-value pair. * **Input**: - `key` (any) - The key to be inserted. - `value` (any) - The value associated with the key. * **Output**: `None`. 3. `get(self, key)`: Retrieves the value for the given key. * **Input**: `key` (any) - The key whose value is to be retrieved. * **Output**: The value associated with the key if it exists, otherwise `None`. 4. `del_(self, key)`: Deletes the key-value pair from the hash table. * **Input**: `key` (any) - The key to be deleted. * **Output**: `None`. 5. `hash(self, key)`: Computes the hash index. * **Input**: `key` (any). * **Output**: An integer representing the computed hash index. 6. `rehash(self, old_hash)`: Computes the next slot index during collisions. * **Input**: `old_hash` (integer) - The last hash index checked. * **Output**: An integer representing the next probe index. Ensure your solution handles common edge cases and maintains efficient average-case performance.","solution":"class LinearProbingHashTable: def __init__(self, size=11): self.size = size self.table = [None] * size self.keys = [None] * size self.count = 0 def hash(self, key): return hash(key) % self.size def rehash(self, old_hash): return (old_hash + 1) % self.size def put(self, key, value): idx = self.hash(key) start_idx = idx while self.table[idx] is not None and self.keys[idx] != key: idx = self.rehash(idx) if idx == start_idx: raise Exception(\\"HashTable is full\\") if self.keys[idx] is None: self.count += 1 self.table[idx] = value self.keys[idx] = key def get(self, key): idx = self.hash(key) start_idx = idx while self.keys[idx] is not None: if self.keys[idx] == key: return self.table[idx] idx = self.rehash(idx) if idx == start_idx: break return None def del_(self, key): idx = self.hash(key) start_idx = idx while self.keys[idx] is not None: if self.keys[idx] == key: self.keys[idx] = None self.table[idx] = None self.count -= 1 return idx = self.rehash(idx) if idx == start_idx: return def __len__(self): return self.count def __getitem__(self, key): return self.get(key) def __setitem__(self, key, value): self.put(key, value) def __delitem__(self, key): self.del_(key)"},{"question":"# Scenario: You are tasked with analyzing the connectivity of a city\'s one-way road network. The city planners need to know if it\'s possible to travel from any location to any other location using the roads in both directions. This will help them ensure that the city\'s road network is robust and well-connected. # Task: Implement a function that determines if a given directed graph is strongly connected. You should use the Graph class provided to model the city\'s road network. # Function Signature: ```python def is_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: ``` # Input: - `vertex_count` (int): The number of vertices (locations) in the graph. - `edges` (List[Tuple[int, int]]): A list of tuples where each tuple (a, b) represents a one-way road from location `a` to location `b`. # Output: - Returns `True` if the graph is strongly connected, `False` otherwise. # Constraints: - All vertices are labeled from 0 to `vertex_count - 1`. - The number of vertices `vertex_count` is between 1 and 10^4. - The number of edges is between 0 and 5 * 10^4. # Example: ```python vertex_count = 5 edges = [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4), (4, 1)] print(is_strongly_connected(vertex_count, edges)) # Output: True vertex_count = 5 edges = [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4)] print(is_strongly_connected(vertex_count, edges)) # Output: False ``` # Notes: - You should modify and use the provided Graph class. - Focus on ensuring your solution is within acceptable time and space complexity limits. - Handle edge cases such as empty graphs, isolated nodes, and unidirectional paths appropriately.","solution":"from typing import List, Tuple class Graph: def __init__(self, vertex_count): self.vertex_count = vertex_count self.adj_list = [[] for _ in range(vertex_count)] self.rev_list = [[] for _ in range(vertex_count)] def add_edge(self, u, v): self.adj_list[u].append(v) self.rev_list[v].append(u) def dfs(self, v, visited, graph): visited[v] = True for neighbour in graph[v]: if not visited[neighbour]: self.dfs(neighbour, visited, graph) def is_strongly_connected(self): # Step 1: Perform DFS starting from the first vertex visited = [False] * self.vertex_count self.dfs(0, visited, self.adj_list) # Check if all vertices are visited in the first DFS if any(not v for v in visited): return False # Step 2: Perform DFS on the transposed graph visited = [False] * self.vertex_count self.dfs(0, visited, self.rev_list) # Check if all vertices are visited in the second DFS return not any(not v for v in visited) def is_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: graph = Graph(vertex_count) for u, v in edges: graph.add_edge(u, v) return graph.is_strongly_connected()"},{"question":"# Linked List Implementation Challenge Scenario You are tasked with implementing a ticketing system that uses a waiting list to manage the order of ticket requests. The waiting list should allow requests to be added and removed dynamically, and for simplicity, the waiting list will be implemented using a doubly linked list due to its bidirectional traversal capability. Task Implement a **DoublyLinkedList** class that supports the following operations: - **append(value)**: Add an element to the end of the list. - **prepend(value)**: Add an element to the beginning of the list. - **delete(value)**: Remove the first occurrence of the specified element from the list. - **find(value)**: Check whether the specified element exists in the list. - **display()**: Return a list of all elements in the linked list from head to tail. Constraints - Assume values are integers for simplicity. - If attempting to delete a value not present in the list, raise a `ValueError`. - If finding a value not present in the list, return `False`. - The list should accommodate any number of elements up to available memory limits. Input/Output - **append(value)**: No output. - **prepend(value)**: No output. - **delete(value)**: No output. - **find(value)**: Returns `True` if value is found, else `False`. - **display()**: Returns a list of elements from head to tail. Here is the initial skeleton for the class: ```python class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def append(self, value): # Implement this method pass def prepend(self, value): # Implement this method pass def delete(self, value): # Implement this method pass def find(self, value): # Implement this method pass def display(self): # Implement this method pass ``` Please implement the defined methods for the **DoublyLinkedList** class.","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def append(self, value): new_node = DoublyLinkedListNode(value) if self.head is None: self.head = new_node self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def prepend(self, value): new_node = DoublyLinkedListNode(value) if self.head is None: self.head = new_node self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def delete(self, value): current = self.head while current is not None: if current.value == value: if current.prev: current.prev.next = current.next else: self.head = current.next if current.next: current.next.prev = current.prev else: self.tail = current.prev return current = current.next raise ValueError(f\\"Value {value} not found in the list\\") def find(self, value): current = self.head while current is not None: if current.value == value: return True current = current.next return False def display(self): elements = [] current = self.head while current is not None: elements.append(current.value) current = current.next return elements"},{"question":"You have been asked to extend the functionality of a queue data structure. Specifically, you need to implement a `PriorityQueue` where each element in the queue has a priority, and elements are dequeued based on their priority—higher priority elements are dequeued before lower priority elements. You need to implement this using a heap data structure for efficient insertions and deletions. # Task Implement the `PriorityQueue` class with the following methods: 1. **`__init__(self)`**: Initialize the priority queue. 2. **`enqueue(self, item, priority)`**: Add an item to the queue with a given priority. 3. **`dequeue(self)`**: Remove and return the item with the highest priority. 4. **`peek(self)`**: Return the item with the highest priority without removing it. 5. **`is_empty(self)`**: Check if the queue is empty. 6. **`size(self)`**: Return the number of items in the queue. # Input Format * `enqueue`: Accepts an item and its priority. * `dequeue`: No parameters. * `peek`: No parameters. * `is_empty`: No parameters. * `size`: No parameters. # Output Format * `enqueue`: No output. * `dequeue`: Returns the item with the highest priority. * `peek`: Returns the item with the highest priority. * `is_empty`: Returns a boolean value indicating whether the queue is empty. * `size`: Returns an integer representing the number of items in the queue. # Constraints * Assume the priority is an integer where a higher number indicates higher priority. * Implement using heap data structure for efficient operations. # Example ```python pq = PriorityQueue() pq.enqueue(\\"item1\\", 1) pq.enqueue(\\"item2\\", 2) pq.enqueue(\\"item3\\", 3) print(pq.peek()) # Output: \\"item3\\" print(pq.dequeue()) # Output: \\"item3\\" print(pq.size()) # Output: 2 print(pq.is_empty()) # Output: False print(pq.dequeue()) # Output: \\"item2\\" print(pq.dequeue()) # Output: \\"item1\\" print(pq.is_empty()) # Output: True ``` # Implementation Define the `PriorityQueue` class and complete the implementation based on the provided task description.","solution":"import heapq class PriorityQueue: def __init__(self): self._queue = [] def enqueue(self, item, priority): heapq.heappush(self._queue, (-priority, item)) def dequeue(self): if self.is_empty(): return None return heapq.heappop(self._queue)[1] def peek(self): if self.is_empty(): return None return self._queue[0][1] def is_empty(self): return len(self._queue) == 0 def size(self): return len(self._queue)"},{"question":"Scenario You are developing a software to recommend products based on past online browsing activity. To improve user experience, your software should quickly identify the best matching product from a sorted list (Binary Search Tree) closest to a target rating given by the user. Your task is to implement a function that efficiently finds and returns the closest rating to a user\'s preferred rating from a given Binary Search Tree of product ratings. Task Write a function **closest_value** that takes in the root of a Binary Search Tree (BST) containing product ratings and a target rating, and returns the rating in the BST that is closest to the target. Function Signature ```python def closest_value(root, target): :type root: TreeNode :type target: float :rtype: int ``` Input * **root**: The root node of the BST (guaranteed to be non-empty). * **target**: A floating point number representing the target rating. Output * An integer representing the rating in the BST closest to the target. Constraints * **Nodes property**: Each node\'s left child contains only nodes with values less than the parent node\'s value, and each node\'s right child only nodes with values greater than the parent node\'s value. * **Uniqueness**: There is only one unique value in the BST that is closest to the target. * **Range**: Node values are integers within the range [-10^9, 10^9]. Example ```python # Example BST structure # 4 # / # 2 5 # / # 1 3 root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(5) root.left.left = TreeNode(1) root.left.right = TreeNode(3) print(closest_value(root, 3.714286)) # Should return 4 ``` Requirements * Ensure the algorithm handles deep BSTs (height can be up to n in the worst case). * Consider both recursive and iterative solutions depending on performance.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def closest_value(root, target): Finds the closest value to the target rating from a given BST. :param root: TreeNode, the root of the BST. :param target: float, the target rating. :return: int, the closest rating in the BST. closest = root.val while root: if abs(target - root.val) < abs(target - closest): closest = root.val root = root.left if target < root.val else root.right return closest"},{"question":"# Context A company uses a road network to transport goods between warehouses and retail stores. The network is modeled as a directed graph where nodes represent warehouses and stores, while edges represent roads with specific capacities. Your task is to compute the maximum transportation capacity (maximum flow) from a central warehouse (source) to a main retail store (sink). # Task Implement the Dinic\'s algorithm to compute the maximum flow from the source to the sink in the given network. The graph will be represented by a capacity matrix where the value at `capacity[i][j]` represents the capacity of the edge from node `i` to node `j`. If no edge exists, the capacity is zero. # Input - `capacity` (List[List[int]]): A 2D list of integers representing the capacity of edges between nodes. - `source` (int): The index of the source node. - `sink` (int): The index of the sink node. # Output - `int`: The maximum possible flow from the source node to the sink node. # Constraints - The graph will have at most 500 nodes. - Each edge capacity will be a non-negative integer. - The source and sink nodes will always be valid nodes in the graph. # Requirements The solution should have O(V^2E) time complexity, where V is the number of vertices and E is the number of edges. # Example ```python # Sample Input capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 # Expected Output print(max_flow(capacity, source, sink)) # Should print 23 ``` # Implementation Write a function `max_flow` that returns the maximum flow from source to sink using Dinic\'s algorithm: ```python from queue import Queue def dinic_bfs(capacity, flow, level, source, sink): vertices = len(capacity) queue = Queue() queue.put(source) level[source] = 0 while not queue.empty(): front = queue.get() for nxt in range(vertices): if level[nxt] == -1 and flow[front][nxt] < capacity[front][nxt]: level[nxt] = level[front] + 1 queue.put(nxt) return level[sink] != -1 def dinic_dfs(capacity, flow, level, idx, sink, work, current_flow = float(\'Inf\')): if idx == sink: return current_flow vertices = len(capacity) while work[idx] < vertices: nxt = work[idx] if level[nxt] == level[idx] + 1 and flow[idx][nxt] < capacity[idx][nxt]: available_flow = min(current_flow, capacity[idx][nxt] - flow[idx][nxt]) tmp = dinic_dfs(capacity, flow, level, nxt, sink, work, available_flow) if tmp > 0: flow[idx][nxt] += tmp flow[nxt][idx] -= tmp return tmp work[idx] += 1 return 0 def max_flow(capacity, source, sink): vertices = len(capacity) flow = [[0] * vertices for _ in range(vertices)] total_flow = 0 while True: level = [-1] * vertices work = [0] * vertices if not dinic_bfs(capacity, flow, level, source, sink): break while True: flow_amount = dinic_dfs(capacity, flow, level, source, sink, work) if flow_amount == 0: break total_flow += flow_amount return total_flow ``` # Note Be sure to pre-process your input to handle scenarios where there are no direct paths or large disparities in edge capacities to optimize the processing.","solution":"from collections import deque def dinic_bfs(capacity, flow, level, source, sink): vertices = len(capacity) queue = deque([source]) level[source] = 0 while queue: front = queue.popleft() for nxt in range(vertices): if level[nxt] == -1 and flow[front][nxt] < capacity[front][nxt]: level[nxt] = level[front] + 1 queue.append(nxt) return level[sink] != -1 def dinic_dfs(capacity, flow, level, idx, sink, ptr, current_flow): if idx == sink: return current_flow while ptr[idx] < len(capacity): nxt = ptr[idx] if level[nxt] == level[idx] + 1 and flow[idx][nxt] < capacity[idx][nxt]: available_flow = min(current_flow, capacity[idx][nxt] - flow[idx][nxt]) temp_flow = dinic_dfs(capacity, flow, level, nxt, sink, ptr, available_flow) if temp_flow > 0: flow[idx][nxt] += temp_flow flow[nxt][idx] -= temp_flow return temp_flow ptr[idx] += 1 return 0 def max_flow(capacity, source, sink): vertices = len(capacity) flow = [[0] * vertices for _ in range(vertices)] total_flow = 0 while True: level = [-1] * vertices if not dinic_bfs(capacity, flow, level, source, sink): break ptr = [0] * vertices while True: flow_amount = dinic_dfs(capacity, flow, level, source, sink, ptr, float(\'Inf\')) if flow_amount == 0: break total_flow += flow_amount return total_flow"},{"question":"# ZigZag Iterator You are given two lists of integers. Your task is to implement a `ZigZagIterator` class that will enable you to iterate over these lists in a zigzag fashion. Specifically, it should alternate between elements from the first and second list, continuing this process until all elements from both lists have been accessed. Class Definition: ```python class ZigZagIterator: def __init__(self, v1, v2): Initialize the iterator with two lists: v1 and v2. :type v1: List[int] :type v2: List[int] pass def next(self): Returns the next element in the iteration. :rtype: int pass def has_next(self): Returns whether there are more elements in the iteration. :rtype: bool pass ``` Constraints: 1. The input lists can each have a length between 0 and 10^4. 2. The elements of the input lists are integers in the range [-10^6, 10^6]. Example Usage: ```python l1 = [1, 2] l2 = [3, 4, 5, 6] it = ZigZagIterator(l1, l2) while it.has_next(): print(it.next()) # Output should be: 1, 3, 2, 4, 5, 6 in order. ``` Implement the `ZigZagIterator` class as defined. Ensure your implementation is efficient and can handle the constraints specified.","solution":"class ZigZagIterator: def __init__(self, v1, v2): Initialize the iterator with two lists: v1 and v2. :type v1: List[int] :type v2: List[int] self.data = [v1, v2] self.indices = [0, 0] self.turn = 0 def next(self): Returns the next element in the iteration. :rtype: int # Find the current list with elements remaining while self.indices[self.turn] >= len(self.data[self.turn]): self.turn = (self.turn + 1) % 2 result = self.data[self.turn][self.indices[self.turn]] self.indices[self.turn] += 1 self.turn = (self.turn + 1) % 2 # Switch turns return result def has_next(self): Returns whether there are more elements in the iteration. :rtype: bool return self.indices[0] < len(self.data[0]) or self.indices[1] < len(self.data[1])"},{"question":"# Queue Implementation Using Deque Scenario A large-scale movie library system requires maintaining a queue of user requests for movies. The system serves these requests in a First In, First Out (FIFO) manner and needs high efficiency due to the volume of operations. You must implement a `DequeQueue` class using double-ended queues (deque) from Python\'s collections module to manage these requests. The deque provides an efficient way to handle both ends of the queue without the need for array resizing or linked list pointer management. Requirements Implement the following methods for the `DequeQueue` class: - `enqueue(self, value)`: Add an element to the rear of the queue. - `dequeue(self)`: Remove and return the front element of the queue. - `peek(self)`: Return the front element without removing it. - `is_empty(self)`: Check if the queue is empty. - `__len__(self)`: Return the number of elements in the queue. - `__iter__(self)`: Iterate over the elements in the queue from front to rear. Constraints - The queue should handle a large number of operations efficiently. - Assume the input elements are integers. - The queue should be able to dynamically expand without any limits. Input Format - Method calls to the `DequeQueue` object. Output Format - Returns of the `dequeue`, `peek`, `is_empty`, and `__len__` methods. Example Usage ```python queue = DequeQueue() queue.enqueue(5) queue.enqueue(10) print(queue.dequeue()) # Output: 5 print(queue.peek()) # Output: 10 print(queue.is_empty()) # Output: False print(len(queue)) # Output: 1 for value in queue: print(value) # Output: 10 ```","solution":"from collections import deque class DequeQueue: def __init__(self): self.queue = deque() def enqueue(self, value): Add an element to the rear of the queue. self.queue.append(value) def dequeue(self): Remove and return the front element of the queue. if not self.is_empty(): return self.queue.popleft() else: raise IndexError(\\"dequeue from an empty queue\\") def peek(self): Return the front element without removing it. if not self.is_empty(): return self.queue[0] else: raise IndexError(\\"peek from an empty queue\\") def is_empty(self): Check if the queue is empty. return len(self.queue) == 0 def __len__(self): Return the number of elements in the queue. return len(self.queue) def __iter__(self): Iterate over the elements in the queue from front to rear. return iter(self.queue)"},{"question":"# Prime Number Generation and Analysis You are tasked with implementing a function that generates a list of all prime numbers up to a specified limit. Your function should then return both the list of prime numbers and the count of primes found. Function Signature ```python def prime_numbers_up_to(limit: int) -> Tuple[List[int], int]: Generates a list of prime numbers up to a given limit and returns the list and the count of primes. Parameters: limit (int): The upper boundary for generating prime numbers. Returns: Tuple[List[int], int]: A tuple containing the list of prime numbers and the total count of these primes. ``` Expected Input and Output * **Input**: An integer `limit` where `1 <= limit <= 10^6`. * **Output**: A tuple consisting of a list of primes and an integer representing the count of primes in the list. Constraints * Your algorithm must run efficiently for `limit` values up to 1,000,000. * Your algorithm should utilize the prime-checking function provided for this purpose. Example ```python assert prime_numbers_up_to(10) == ([2, 3, 5, 7], 4) assert prime_numbers_up_to(20) == ([2, 3, 5, 7, 11, 13, 17, 19], 8) ``` Guidelines 1. You must use the `prime_check()` function provided in your solution. 2. Consider edge cases such as `limit` being very small or very large. 3. Ensure that your solution handles constraints effectively to avoid performance bottlenecks.","solution":"from typing import List, Tuple def prime_numbers_up_to(limit: int) -> Tuple[List[int], int]: Generates a list of prime numbers up to a given limit and returns the list and the count of primes. Parameters: limit (int): The upper boundary for generating prime numbers. Returns: Tuple[List[int], int]: A tuple containing the list of prime numbers and the total count of these primes. if limit < 2: return ([], 0) sieve = [True] * (limit + 1) sieve[0], sieve[1] = False, False # 0 and 1 are not prime numbers for start in range(2, int(limit**0.5) + 1): if sieve[start]: # If start is a prime for multiple in range(start*start, limit + 1, start): sieve[multiple] = False primes = [num for num in range(2, limit + 1) if sieve[num]] return primes, len(primes)"},{"question":"# Topological Sorting Challenge You are given a directed graph representing tasks and their dependencies. Each task is represented as a vertex, and a directed edge from vertex `u` to vertex `v` indicates that task `u` must be completed before task `v`. **Objective**: Write a function `topological_sort(graph)` that takes this graph as input and returns a list representing a valid topological order of the tasks. If a cycle is detected in the graph, raise a `ValueError` with the message \\"cycle\\". # Input Format * The input graph is represented as a dictionary where the keys are task IDs (integers or strings) and the values are lists of task IDs that depend on the key task. # Output Format * A list of task IDs representing the topological order. # Constraints * The graph is guaranteed to have at least one vertex. * The task IDs are unique. * The graph does not necessarily have any edges; it can have isolated vertices. * If the graph contains a cycle, raise a `ValueError` with the message \\"cycle\\". # Example Input ```python { \'a\': [\'b\', \'c\'], \'b\': [\'d\'], \'c\': [\'d\'], \'d\': [] } ``` Output ```python [\'a\', \'b\', \'c\', \'d\'] ``` Input ```python { \'a\': [\'b\'], \'b\': [\'c\'], \'c\': [\'a\'] } ``` Output ```python ValueError: cycle ``` # Note Your function should handle edge cases and detect cycles effectively. Ensure to explain your approach and consider any potential optimization during implementation.","solution":"def topological_sort(graph): Performs a topological sort on a directed graph. :param graph: A dictionary where keys are task IDs and values are lists of task IDs that depend on the key task. :return: A list of task IDs representing the topological order. :raises ValueError: If a cycle is detected in the graph. from collections import defaultdict, deque # Initialize in-degrees of all vertices in_degree = defaultdict(int) # Populate in-degree of each vertex for u in graph: if u not in in_degree: in_degree[u] = 0 for v in graph[u]: in_degree[v] += 1 # Collect all vertices with in-degree of 0 queue = deque([node for node in in_degree if in_degree[node] == 0]) topological_order = [] while queue: node = queue.popleft() topological_order.append(node) # Decrease the in-degree of neighboring vertices for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Check if the topological sort contains all the vertices if len(topological_order) != len(in_degree): raise ValueError(\\"cycle\\") return topological_order"},{"question":"You are given the class definition for the Union-Find (or Disjoint Set) data structure, which efficiently handles union and find operations on disjoint sets. You need to implement a new method within the class `Union` that will determine if adding a new connection between two elements will form a cycle in the undirected graph formed by these connections. # Function Signature ```python class Union: def will_form_cycle(self, element1, element2) -> bool: Determine if adding a connection between element1 and element2 will form a cycle in the graph. Args: element1: An integer representing one element in the connection. element2: An integer representing the other element in the connection. Returns: A boolean: True if adding the connection will form a cycle, False otherwise. pass ``` # Input/Output Format: - **Input**: - `element1` and `element2`: Integers representing the elements to connect. - **Output**: - Returns `True` if the connection forms a cycle, otherwise returns `False`. # Constraints: 1. You may assume `element1` and `element2` are always valid nodes that have been added to the union-find structure. 2. Elements are characterized by unique positive integers. # Example ```python uf = Union() uf.add(1) uf.add(2) uf.add(3) print(uf.will_form_cycle(1, 2)) # Output: False uf.unite(1, 2) print(uf.will_form_cycle(1, 2)) # Output: True uf.unite(2, 3) print(uf.will_form_cycle(1, 3)) # Output: True print(uf.will_form_cycle(4, 5)) # Output: should handle gracefully even if elements are not in union-find ``` # Hints: - Utilize the `root` method to find the root of the elements. - Check if the roots of `element1` and `element2` are already the same before performing `unite`.","solution":"class Union: def __init__(self): self.parent = {} self.rank = {} def add(self, x): if x not in self.parent: self.parent[x] = x self.rank[x] = 0 def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def unite(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 def will_form_cycle(self, element1, element2) -> bool: Determine if adding a connection between element1 and element2 will form a cycle in the graph. Args: element1: An integer representing one element in the connection. element2: An integer representing the other element in the connection. Returns: A boolean: True if adding the connection will form a cycle, False otherwise. root1 = self.find(element1) root2 = self.find(element2) return root1 == root2"},{"question":"# Question Prompt: Strongly Connected Components Identification Background In many real-world applications like social networks, web page analysis, and electronic circuits, we often need to identify groups of interrelated nodes in a directed graph where every node is reachable from every other node in the group. These groups are referred to as Strongly Connected Components (SCCs). One of the most efficient algorithms to discover SCCs is **Tarjan\'s Algorithm**. This algorithm leverages depth-first search (DFS) and operates with linear time complexity O(V + E), making it suitable for large graphs. Task You are required to implement a function that uses Tarjan\'s Algorithm to find all strongly connected components in a given directed graph. Function Signature ```python def find_sccs(graph: Dict[int, List[int]]) -> List[List[int]]: ``` Input - `graph`: A dictionary where keys are node integers and values are lists of integers representing directed edges from the key node to other nodes. Output - Returns a list of lists, where each list contains node integers forming a strongly connected component sorted in ascending order. Constraints - The graph will have at most 1000 nodes. - Nodes are labeled from 0 to N-1. - The graph may have multiple edges and self-loops. Example ```python graph = { 0: [1], 1: [2], 2: [0, 3], 3: [4], 4: [5, 7], 5: [6], 6: [4], 7: [] } find_sccs(graph) ``` Expected Output: ```python [[0, 1, 2], [3], [4, 5, 6], [7]] ``` Explanation The given graph has four strongly connected components: - Nodes `[0, 1, 2]` form a cycle. - Node `[3]` is isolated after outgoing edge to `[4]`. - Nodes `[4, 5, 6]` form another cycle. - Node `[7]` is isolated with no outgoing edges.","solution":"def find_sccs(graph): Uses Tarjan\'s Algorithm to find all strongly connected components in a given directed graph. Args: graph (dict): A dictionary with node integers as keys and a list of integers representing directed edges from the key node to other nodes. Returns: List[List[int]]: A list of lists where each list contains node integers forming a strongly connected component sorted in ascending order. # Initialize Tarjan\'s Algorithm structures index = 0 stack = [] indices = {} lowlinks = {} on_stack = {} sccs = [] def strongconnect(node): nonlocal index, stack, indices, lowlinks, on_stack, sccs # Set the depth index for node to the smallest unused index indices[node] = index lowlinks[node] = index index += 1 stack.append(node) on_stack[node] = True # Consider successors of node for successor in graph.get(node, []): if successor not in indices: # Successor has not yet been visited; recurse on it strongconnect(successor) lowlinks[node] = min(lowlinks[node], lowlinks[successor]) elif on_stack[successor]: # Successor is in stack and hence in the current SCC lowlinks[node] = min(lowlinks[node], indices[successor]) # If node is a root node, pop the stack and generate an SCC if lowlinks[node] == indices[node]: scc = [] while True: w = stack.pop() on_stack[w] = False scc.append(w) if w == node: break sccs.append(sorted(scc)) # Start DFS from each node for node in graph: if node not in indices: strongconnect(node) return sorted(sccs, key=lambda scc: scc[0])"},{"question":"# Question Title: Find the Single Number in an Array Description: You are given an array of integers where every element appears exactly twice, except for one element which appears exactly once. Your task is to find the element that appears only once. Your algorithm should have O(n) time complexity and O(1) space complexity. Function Signature: ```python def find_single_number(nums: List[int]) -> int: pass ``` Input: - `nums`: A list of integers, `List[int]`. Every integer appears twice except for one, which appears exactly once. - You can assume that there is at least one element in the list. Output: - Returns the integer that appears exactly once. Constraints: - `1 <= len(nums) <= 3 * 10^4` - Each element in the array appears twice except for one element which appears once. - The elements are all integers within the range of [-10^6, 10^6]. Example: ```python assert find_single_number([2, 2, 1]) == 1 assert find_single_number([4, 1, 2, 1, 2]) == 4 assert find_single_number([1]) == 1 ``` Scenario: Imagine you are processing a list of transaction IDs from multiple accounts, where each account processes its transactions in pairs (debit and credit). However, due to a system malfunction, one transaction was recorded without its corresponding pair. Find the transaction ID that does not have a pair.","solution":"def find_single_number(nums): Given a list of integers where every element appears exactly twice except for one element which appears exactly once, find the element that appears only once. # XOR solution for finding the unique element unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Question: Implement a Probabilistic Primality Test You are required to implement the Rabin-Miller primality test to determine if a given number is probably prime or definitely composite. The input will be an integer `n` (greater than or equal to 2) and an integer `k` representing the number of iterations for the test. Your function should return `True` if the number is probably prime and `False` if the number is definitely composite. # Function Signature: ```python def is_probably_prime(n: int, k: int) -> bool: pass ``` # Input: - An integer `n` (2 ≤ `n` ≤ 10^12): the number to test for primality. - An integer `k` (1 ≤ `k` ≤ 100): the number of iterations for the test. # Output: - A boolean value indicating `True` if the number is probably prime, and `False` if it is definitely composite. # Constraints: - You should handle small numbers (n = 2, 3) explicitly and return `True` directly. - Use efficient modulus and power functions. - The algorithm should be optimized to handle large inputs efficiently. # Example: ```python assert is_probably_prime(7919, 5) == True # 7919 is a known prime number assert is_probably_prime(15, 3) == False # 15 is a composite number (3 * 5) assert is_probably_prime(2, 5) == True # 2 is explicitly prime ``` # Scenario: Alice is building a cryptographic application that requires prime numbers for secure key generation. She needs a way to check whether a large number is prime. Implementing the Rabin-Miller primality test will help her quickly identify probable prime numbers to use.","solution":"import random def is_probably_prime(n: int, k: int) -> bool: Implements the Rabin-Miller primality test to determine if a number n is probably prime, performing k iterations of the test. if n in (2, 3): return True if n <= 1 or n % 2 == 0: return False # Find d such that d*2^r = n-1 r, d = 0, n - 1 while d % 2 == 0: d //= 2 r += 1 # Helper function for modular exponentiation def power_mod(base, exponent, mod): result = 1 base = base % mod while exponent > 0: if exponent % 2 == 1: result = (result * base) % mod exponent = exponent >> 1 base = (base * base) % mod return result # Perform Rabin-Miller test k times for _ in range(k): a = random.randrange(2, n - 1) x = power_mod(a, d, n) if x == 1 or x == n - 1: continue for _ in range(r - 1): x = power_mod(x, 2, n) if x == n - 1: break else: return False return True"},{"question":"# Matrix Rotation by 90 Degrees (Clockwise) Given a n x n 2D matrix, write a function to rotate the matrix by 90 degrees (clockwise). The rotation should be performed in-place, meaning you need to modify the input matrix directly without using any extra space for another matrix. **Function Signature**: ```python def rotate(mat: List[List[int]]) -> None: pass ``` # Constraints: 1. The matrix must be square (n x n). 2. The modification must be done in-place, without using extra space proportional to the matrix size. # Input: * `mat`: a list of lists of integers representing the n x n matrix. # Output: * The function does not return anything. The matrix should be modified in-place. # Example: ```python mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate(mat) print(mat) ``` Output: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` # Additional Notes: - Consider different edge cases such as: * Empty matrix (e.g., `[]`) * Single element matrix (e.g., `[[1]]`) * Matrices with even and odd dimensions. The goal is to demonstrate an understanding of in-place matrix manipulation and the ability to transform it efficiently.","solution":"from typing import List def rotate(mat: List[List[int]]) -> None: Rotates the given NxN matrix in-place by 90 degrees clockwise. n = len(mat) for layer in range(n // 2): first = layer last = n - layer - 1 for i in range(first, last): offset = i - first top = mat[first][i] # save top # left -> top mat[first][i] = mat[last - offset][first] # bottom -> left mat[last - offset][first] = mat[last][last - offset] # right -> bottom mat[last][last - offset] = mat[i][last] # top -> right mat[i][last] = top"},{"question":"Implement Ternary Search Context: Ternary search is particularly useful for finding an element in a sorted array. It is similar to binary search but divides the array into three parts instead of two at each step. Your task is to write a function to perform ternary search on a sorted array. Function Signature: ```python def ternary_search(arr: List[int], key: int) -> int: Args: arr : List[int] : a sorted list of integers key : int : the integer to search for in the array Returns: int : the index of the key in the array, or -1 if the key is not found ``` Input: * `arr` (List[int]): A list of integers sorted in ascending order (1 <= |arr| <= 10^5). * `key` (int): The integer value being searched for in the array (-10^9 <= key <= 10^9). Output: * The function should return the index of the `key` in the array if found. * If the `key` is not present, return -1. Constraints: * The array will have at most 10^5 elements. * The elements of the array and the `key` can be negative or positive integers. Examples: 1. `ternary_search([1, 2, 3, 4, 5], 3)` should return `2`. 2. `ternary_search([1, 2, 3, 4, 5], 6)` should return `-1`. 3. `ternary_search([], 5)` should return `-1`. Implement the `ternary_search` function using the principles of the ternary search algorithm described.","solution":"from typing import List def ternary_search(arr: List[int], key: int) -> int: Perform a ternary search on a sorted array to find the index of a key. Args: arr : List[int] : a sorted list of integers key : int : the integer to search for in the array Returns: int : the index of the key in the array, or -1 if the key is not found left, right = 0, len(arr) - 1 while left <= right: third = (right - left) // 3 mid1 = left + third mid2 = right - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"Scenario You are managing a playlist of songs stored as a singly linked list. Due to user preferences, you occasionally need to remove a contiguous block of songs from the playlist. Task Implement a function `remove_range` that accepts the head of a singly linked list and two integer indices, `start` and `end`. The function should remove all elements from the linked list within the inclusive index range [start, end]. Function Signature ```python def remove_range(head: ListNode, start: int, end: int) -> ListNode: ``` Input * `head`: The head node of the singly linked list. * `start`: An integer representing the starting index. * `end`: An integer representing the ending index. Output * The head node of the modified singly linked list. Constraints * 0 ≤ `start` ≤ `end` < length of the list. * The list will contain at least one node. * The function should handle in-place removals. Example ```python # Given List: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 # Calling remove_range(head, 3, 7) # Resulting List: 1 -> 2 -> 3 -> 9 class ListNode: def __init__(self, x): self.val = x self.next = None # define your linked list elements and test cases accordingly. ``` Performance Your solution should efficiently handle lists containing up to 10^5 elements within reasonable running time.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def remove_range(head: ListNode, start: int, end: int) -> ListNode: if start > end: return head dummy = ListNode(0) dummy.next = head prev, current = dummy, head index = 0 while current and index < start: prev = current current = current.next index += 1 connection = prev while current and index <= end: current = current.next index += 1 connection.next = current return dummy.next"},{"question":"You are tasked to sort an array consisting of only three distinct integers, 0, 1, and 2. The integers represent the colors red, white, and blue respectively. Your goal is to sort the array in-place so that all occurrences of 0 (red) come first, followed by all occurrences of 1 (white), and all occurrences of 2 (blue) at the end. You must implement the `sort_colors` function without using the built-in sort() function of the library. Function Signature ```python def sort_colors(nums: List[int]) -> None: Modify nums in-place to sort it as specified. ``` Input * `nums`: A list of non-negative integers (0s, 1s, and 2s) with a length ranging from 0 to 10^5. Output * The function should not return anything but modify the list `nums` in-place. Constraints * Do not use the library\'s sort function. * Ensure the implementation runs in O(n) time complexity and O(1) space complexity. Example ```python nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output: [0, 0, 1, 1, 2, 2] nums = [2, 0, 1] sort_colors(nums) print(nums) # Output: [0, 1, 2] nums = [0] sort_colors(nums) print(nums) # Output: [0] nums = [1, 0, 1] sort_colors(nums) print(nums) # Output: [0, 1, 1] ``` # Scenario Imagine you are writing a function for an online store that categorizes products in three different categories represented by integers. Your objective is to ensure the products are shown in a specific order (categories 0, 1, and then 2) to enhance user experience based on popularity and sales data. Implement the function to achieve this!","solution":"from typing import List def sort_colors(nums: List[int]) -> None: Modify nums in-place to sort it in the order of 0s, 1s, and then 2s. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: # nums[mid] == 2 nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"You are given two integers, `num1` and `num2`. Your task is to implement the Extended Euclidean Algorithm to find integers `s`, `t`, and `g` such that: [ num1 times s + num2 times t = g ] where `g` is the Greatest Common Divisor (GCD) of `num1` and `num2`. # Input * Two integers, `num1` and `num2`, where ( -10^9 leq num1, num2 leq 10^9 ). # Output * Three integers, `s`, `t`, and `g`. # Function Signature ```python def extended_gcd(num1: int, num2: int) -> Tuple[int, int, int]: pass ``` # Constraints 1. Both `num1` and `num2` can be negative. 2. `num1` and `num2` can also be zero, but not simultaneously. 3. You must handle large integers efficiently. 4. The result should be exact integers. # Example Example 1: Input: `num1 = 30, num2 = 20` Output: `(1, -1, 10)` Explanation: (30 times 1 + 20 times -1 = 10). Example 2: Input: `num1 = 101, num2 = 103` Output: `(-51, 50, 1)` Explanation: (101 times -51 + 103 times 50 = 1). # Scenario: This function is critical in many cryptographic algorithms, particularly for finding modular inverses which are essential for encryption and decryption processes. Implementations or applications involving encryption keys, digital certificates, or any cybersecurity feature often require proper handling of large numbers, making the understanding and execution of the Extended Euclidean Algorithm essential.","solution":"from typing import Tuple def extended_gcd(num1: int, num2: int) -> Tuple[int, int, int]: This function implements the Extended Euclidean Algorithm to find integers s, t, and g such that num1 * s + num2 * t = g where g is the gcd of num1 and num2. if num2 == 0: return (1, 0, num1) else: s1, t1, gcd = extended_gcd(num2, num1 % num2) s = t1 t = s1 - (num1 // num2) * t1 return (s, t, gcd)"},{"question":"# Question **Increment Array Representation** You are provided with a non-negative number represented as an array of digits. Write a function that adds one to the given number, where the digits are stored in big-endian order (most significant digit at the head of the list). Function Signature: ```python def increment_number(digits: List[int]) -> List[int]: Arguments: digits : List[int] : A list of non-negative single-digit integers representing a non-negative number. Returns: List[int] : A list of non-negative single-digit integers representing the number incremented by one. ``` # Input * A list of integer digits, `digits`, where each element `0 <= digits[i] <= 9`. * `1 <= len(digits) <= 10^6` # Output * A list of integer digits representing the incremented number. # Constraints * The resultant list should maintain the same format, representing the number in big-endian order. * The returned list should contain only single-digit positive integers. # Performance Requirements * The time complexity should be O(n), where n is the length of the input list `digits`. * Memory usage should be optimized to O(1) auxiliary space, not counting the output. # Example Example 1 # Input ```python digits = [1, 2, 3] ``` # Output ```python [1, 2, 4] ``` Example 2 # Input ```python digits = [9, 9, 9] ``` # Output ```python [1, 0, 0, 0] ``` Example 3 # Input ```python digits = [0] ``` # Output ```python [1] ``` # Constraints Your implementation should handle the edge cases such as: * An input array consisting of all nines. * Leading zeros in the input array should not be present. * Avoid excessive memory usage for very large lists.","solution":"from typing import List def increment_number(digits: List[int]) -> List[int]: Increments the integer represented by the list of digits by one. Arguments: digits : List[int] : A list of non-negative single-digit integers representing a non-negative number. Returns: List[int] : A list of non-negative single-digit integers representing the number incremented by one. n = len(digits) # Traverse the list of digits starting from the last element for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 # If all digits are 9, we need one additional digit at the front return [1] + [0] * n"},{"question":"# Linked Lists Intersection Detection **Scenario**: You are given two singly linked lists that potentially merge at some point. Your task is to determine the node at which they merge, if any. **Function to Implement**: ```python def intersection(h1: Node, h2: Node) -> Node: Find the intersection point of two linked lists. Parameters: h1 (Node): The head of the first linked list. h2 (Node): The head of the second linked list. Returns: Node: The intersection node or `None` if there is no intersection. # Your code goes here ``` **Input Format**: * `h1` and `h2` are head nodes of the two linked lists. **Output Format**: * Return the intersecting node (Node object) if the linked lists intersect. * Return `None` if there is no intersection. **Constraints**: * Assume that the lists are singly linked and acyclic. * The nodes may only intersect once. * Nodes are identified uniquely by their addresses, not by their values. **Examples**: 1. Given the following linked lists: ``` 1 -> 3 -> 5 7 -> 9 -> 11 / 2 -> 4 -> 6 ``` The intersection occurs at node with value `7`. Input: `h1` and `h2` are heads of above structure. Output: Node with value `7`. 2. Given the following linked lists: ``` 1 -> 2 -> 3 4 -> 5 -> 6 ``` There is no intersection. Input: `h1` and `h2` are heads of above structure. Output: `None`. **Unit Testing**: Use the following template to write test cases and ensure correctness: ```python import unittest class TestIntersection(unittest.TestCase): def test_intersection(self): # Example 1 a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f self.assertEqual(intersection(a1, a2).val, 7) # Example 2 a3 = Node(1) b3 = Node(2) c3 = Node(3) d2 = Node(4) e2 = Node(5) f2 = Node(6) a3.next = b3 b3.next = c3 d2.next = e2 e2.next = f2 self.assertIsNone(intersection(a3, d2)) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def intersection(h1: Node, h2: Node) -> Node: Find the intersection point of two linked lists. Parameters: h1 (Node): The head of the first linked list. h2 (Node): The head of the second linked list. Returns: Node: The intersection node or `None` if there is no intersection. if not h1 or not h2: return None p1, p2 = h1, h2 while p1 != p2: p1 = p1.next if p1 else h2 p2 = p2.next if p2 else h1 return p1"},{"question":"# Question: Enhanced Greatest Common Divisor Implementation with Applications You are asked to implement a function that computes the greatest common divisor (GCD) of two non-negative integers using multiple approaches, ensuring optimization and error handling. Utilize bitwise operations but maintain robustness of Euclid’s algorithm. Function Signature ```python def enhanced_gcd(a: int, b: int) -> int: Enhanced function to compute the greatest common divisor of two non-negative integers. :param a: A non-negative integer. :param b: A non-negative integer. :return: An integer representing the greatest common divisor of a and b. ``` # Input and Output * **Input**: - An integer `a` (0 <= a <= 10^9). - An integer `b` (0 <= b <= 10^9). * **Output**: - An integer representing the greatest common divisor of integers `a` and `b`. # Constraints * Both `a` and `b` are non-negative integers not exceeding 10^9. * Ensure your solution handles edge cases like when either of the numbers is zero. # Performance Requirements * The solution should efficiently handle the upper limit of input constraints. # Example ```python # Example 1 a = 48 b = 18 # GCD: 6 print(enhanced_gcd(a, b)) # Output: 6 # Example 2 a = 0 b = 10 # GCD: 10 print(enhanced_gcd(a, b)) # Output: 10 ``` # Scenario/Context This function is essential in many areas such as simplifying fractions, computational number theory, and cryptographic algorithms. Implementing it in an optimized manner using bitwise operations and ensuring edge cases enhances its utility in high-performance and large-scale applications.","solution":"def enhanced_gcd(a: int, b: int) -> int: Enhanced function to compute the greatest common divisor of two non-negative integers. :param a: A non-negative integer. :param b: A non-negative integer. :return: An integer representing the greatest common divisor of a and b. # Special case when either of the number is zero if a == 0: return b if b == 0: return a # Using the binary GCD algorithm (Stein\'s Algorithm) # Find the common power of 2 shift = 0 while ((a | b) & 1) == 0: a >>= 1 b >>= 1 shift += 1 # Now both a and b are odd. Swap if necessary to ensure a <= b. while (a & 1) == 0: a >>= 1 while b != 0: while (b & 1) == 0: b >>= 1 if a > b: a, b = b, a b = b - a return a << shift"},{"question":"Scenario You are working on a project involving data manipulation using linked lists. One of the tasks you need to perform is reversing a segment of a singly linked list between given positions. This will require a modification of the standard linked list reversal algorithm to work only within the given segment. Problem Statement Given the head of a singly linked list and two integers `m` and `n` where `1 ≤ m ≤ n ≤ length of list`, reverse the nodes from position `m` to `n`. Function Specification You need to implement the following function: ```python def reverse_between(head: ListNode, m: int, n: int) -> ListNode: :param head: ListNode - The head of the singly linked list :param m: int - Starting position for the reverse segment (1-based index) :param n: int - Ending position for the reverse segment (1-based index) :return: ListNode - The head of the modified list ``` Input - The `head` of a singly linked list. - Two integers `m` and `n` specifying the start and end positions of the segment to reverse. Output - The `head` of the modified linked list after reversing the segment between positions `m` and `n`. Constraints - The length of the list is at most 10^4. - `1 ≤ m ≤ n ≤ length of list`. Example ```python # Example Usage # Define the linked list 1 -> 2 -> 3 -> 4 -> 5 head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) # Reverse the segment from position 2 to 4 new_head = reverse_between(head, 2, 4) # The modified linked list should be 1 -> 4 -> 3 -> 2 -> 5 print_list(new_head) # This should print: 1 -> 4 -> 3 -> 2 -> 5 ``` # Additional Information - Assume you have a basic implementation of the `ListNode` class. - You can include helper functions as needed. - Ensure your solution is optimized for both time and space complexity.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_between(head: ListNode, m: int, n: int) -> ListNode: if not head or m == n: return head dummy = ListNode(0) dummy.next = head prev = dummy # Move `prev` to the (m-1)th node for _ in range(m - 1): prev = prev.next # `start` will be the mth node start = prev.next # `then` will be the (m+1)th node then = start.next # Reverse nodes between m and n for _ in range(n - m): start.next = then.next then.next = prev.next prev.next = then then = start.next return dummy.next"},{"question":"Problem Statement: You are given a directed graph representing city routes, where each node is a city and each directed edge represents a one-way route between two cities. Implement a function `find_all_paths` that takes a graph, a start city, and a destination city, and returns all possible paths from the start city to the destination city. # Function Signature ```python def find_all_paths(graph: DirectedGraph, start: str, destination: str) -> List[List[str]]: ``` # Input - `graph`: An instance of the `DirectedGraph` class representing the city routes. - `start`: A string representing the name of the starting city. - `destination`: A string representing the name of the destination city. # Output - A list of lists, where each inner list represents a path from the start city to the destination city. Each path is represented as a list of city names. # Constraints - The graph contains no more than 1000 nodes and no more than 5000 edges. - The start and destination cities are guaranteed to exist in the graph. - There may be multiple paths or no path between the start and the destination. # Examples ```python # Example graph input city_routes = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"C\\", \\"D\\"], \\"C\\": [\\"D\\"], \\"D\\": [\\"E\\"], \\"E\\": [] } graph = DirectedGraph(city_routes) # Example call to the function print(find_all_paths(graph, \\"A\\", \\"D\\")) # Expected output: [[\\"A\\", \\"B\\", \\"C\\", \\"D\\"], [\\"A\\", \\"B\\", \\"D\\"], [\\"A\\", \\"C\\", \\"D\\"]] ``` # Guidelines - Your solution should efficiently handle the constraints. - Ensure you avoid infinite loops in the case of cyclic graphs. - Consider edge cases like disconnected nodes and self-loops.","solution":"from typing import List, Dict, Any class DirectedGraph: def __init__(self, graph: Dict[str, List[str]]): self.graph = graph def find_all_paths(graph: DirectedGraph, start: str, destination: str) -> List[List[str]]: all_paths = [] def dfs(current_city: str, path: List[str]): if current_city == destination: all_paths.append(list(path)) return for neighbor in graph.graph.get(current_city, []): if neighbor not in path: # To avoid cycles path.append(neighbor) dfs(neighbor, path) path.pop() dfs(start, [start]) return all_paths"},{"question":"# Factor Combination Finder **Scenario**: You work on a team developing a number theory application that requires extracting all possible factor combinations of a number. Your task is to implement a function that takes an integer and returns all unique combinations of its factors. **Requirements**: Write a function `factor_combinations(n: int) -> List[List[int]]` that finds all factor combinations for a given integer `n` such that: - Each combination\'s product equals `n`. - Factors are greater than 1 and less than `n`. **Input**: - A single integer `n` where `n > 0`. **Output**: - A list of lists, where each inner list represents a combination of factors whose product is `n`. **Constraints**: - You may assume the input integer `n` will always be positive. **Example**: ```markdown Input: 12 Output: [[2, 6], [2, 2, 3], [3, 4]] Input: 32 Output: [[2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8]] ``` **Implementation Notes**: - Ensure that you handle edge cases like very small prime numbers (e.g., 1 has no valid factors). - Optimize your solution to handle larger numbers as efficiently as possible without deep recursion pitfalls.","solution":"from typing import List def factor_combinations(n: int) -> List[List[int]]: def backtrack(start, target, path, result): if target == 1: if len(path) > 1: result.append(path[:]) return for i in range(start, target + 1): if target % i == 0: path.append(i) backtrack(i, target // i, path, result) path.pop() result = [] backtrack(2, n, [], result) return result"},{"question":"# Question: Counting Connected Components In this problem, you are given an undirected graph defined by `N` nodes and `E` edges. Your task is to write a Python function `count_connected_components(N, edges)` that counts the number of connected components in the graph. # Function Signature ```python def count_connected_components(N: int, edges: List[Tuple[int, int]]) -> int: ``` # Input * `N` (1 ≤ N ≤ 10^5): An integer representing the number of nodes in the graph. * `edges`: A list of tuples, where each tuple contains two integers denoting an edge between two nodes (1 ≤ node ≤ N). # Output * An integer representing the number of connected components in the given graph. # Example ```python assert count_connected_components(7, [(1,2), (2,4), (4,5), (5,6), (3,7)]) == 2 assert count_connected_components(6, [(1,2), (2,3), (4,5)]) == 3 assert count_connected_components(3, [(1,2), (2,3)]) == 1 assert count_connected_components(4, [(1,2), (1,3)]) == 2 ``` # Constraints * Nodes are numbered from 1 to N. * The graph can be disconnected. * There won\'t be any duplicate edges. * The graph does not contain self-loops (edges from a node to itself). # Hints 1. Initialize an adjacency list for the graph. 2. Create a `visited` list to keep track of the visited nodes. 3. Implement a DFS function to traverse connected components. 4. Count the number of times you call the DFS function from the main loop to determine the number of connected components.","solution":"from typing import List, Tuple def count_connected_components(N: int, edges: List[Tuple[int, int]]) -> int: def dfs(node): stack = [node] while stack: current = stack.pop() if not visited[current]: visited[current] = True for neighbor in graph[current]: if not visited[neighbor]: stack.append(neighbor) # Creating an adjacency list graph = {i: [] for i in range(1, N+1)} for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (N + 1) components_count = 0 # Going through each node and performing DFS if it is not visited for node in range(1, N + 1): if not visited[node]: dfs(node) components_count += 1 return components_count"},{"question":"# Pangram Checker Extension Scenario You are developing a text analysis tool, and one of the features is to identify if a provided input string is a pangram. To improve efficiency, you need to modify the current solution to utilize a more optimal approach. Additionally, you should consider an extended feature to handle not just the English alphabet but any specified set of characters. Task Implement a function `check_pangram_extended(input_string, character_set)` that determines if the input string contains all characters from the specified `character_set`. Function Signature ```python def check_pangram_extended(input_string: str, character_set: str) -> bool: pass ``` Input * `input_string` (str): The string to analyze. * `character_set` (str): The set of characters that must be present in the input string for it to be considered a pangram. Output * Returns `True` if the input string contains at least one of each character from the `character_set`. * Returns `False` otherwise. Constraints * You may assume that both `input_string` and `character_set` consist only of printable ASCII characters. * Both input strings will have lengths between 1 and 10^4. Example ```python assert check_pangram_extended(\\"The quick brown fox jumps over the lazy dog\\", \\"abcdefghijklmnopqrstuvwxyz\\") == True assert check_pangram_extended(\\"Hello World!\\", \\"abcdefghijklmnopqrstuvwxyz\\") == False assert check_pangram_extended(\\"1234567890!@#%^&*()_+\\", \\"1234567890\\") == True ``` Performance Requirements * Your solution should be optimized for performance, particularly for large input strings.","solution":"def check_pangram_extended(input_string: str, character_set: str) -> bool: Determines if the input_string contains all characters from the specified character_set. Args: input_string (str): The string to analyze. character_set (str): The set of characters that must be present in the input string for it to be considered a pangram. Returns: bool: True if the input string contains at least one of each character from the character_set, False otherwise. character_set = set(character_set) input_string_set = set(input_string) return character_set.issubset(input_string_set)"},{"question":"Scenario You are working for a logistics company that needs to determine the most valuable combination of packages that can be shipped without exceeding a weight limit. You are given a list of packages, each with a specific value and weight, and you need to write a function to determine the maximum total value of the packages that can be included in a shipment with a given weight capacity. Function Specification **Function Name**: `maximum_shipment_value` **Input**: - A list of tuples, each representing a package in the format `(value, weight)`. Each value and weight are positive integers. - An integer `capacity` which represents the maximum weight capacity of the shipment. **Output**: - An integer representing the maximum total value of packages that can fit in the shipment without exceeding the given capacity. **Constraints**: - The number of packages `n` will be between 1 and 1000. - The weight capacity `m` will be between 1 and 1000. - The value of each package will be between 1 and 1000. - The weight of each package will be between 1 and 1000. **Example**: - Input: `packages = [(60, 5), (50, 3), (70, 4), (30, 2)]`, `capacity = 5` - Output: `80` (The value of items 50 and 30 can both be fit in the knapsack) **Instructions**: Write a function `maximum_shipment_value(packages, capacity)` that returns the maximum total value that does not exceed the given capacity. ```python def maximum_shipment_value(packages, capacity): # Implementation here pass ``` **Note**: You should not import any additional libraries or modules to solve this problem.","solution":"def maximum_shipment_value(packages, capacity): Determines the maximum total value of the packages that can be included in a shipment without exceeding the weight capacity using the 0/1 knapsack dynamic programming approach. Parameters: packages (list of tuples): A list of (value, weight) representing each package. capacity (int): The maximum weight capacity of the shipment. Returns: int: The maximum total value of packages that can fit in the shipment. n = len(packages) dp = [[0] * (capacity + 1) for _ in range(n + 1)] for i in range(1, n + 1): (value, weight) = packages[i-1] for w in range(capacity + 1): if weight <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight] + value) else: dp[i][w] = dp[i-1][w] return dp[n][capacity]"},{"question":"# Question: Check Bipartite Graph Context: In certain applications like scheduling and job assignments, it\'s essential to determine whether a graph can be partitioned into two distinct sets such that no two vertices within the same set are adjacent. This type of graph is known as a bipartite graph. Task: Write a function `is_bipartite(graph)` that determines if a given graph (represented by its adjacency list) is bipartite. Function Signature: ```python def is_bipartite(graph: List[List[int]]) -> bool: Determine if the given graph is bipartite. :param graph: List[List[int]] - An adjacency list of the graph. :return: bool - True if the graph is bipartite, False otherwise. ``` Input: * `graph`: A list of lists, where `graph[u]` is a list of vertices adjacent to vertex `u`. Output: * Return `True` if the graph is bipartite, otherwise return `False`. Constraints: * The number of vertices `n` in the graph will have `1 <= n <= 1000`. * The number of edges `e` in the graph can be up to `n * (n - 1) / 2`. Example: ```python graph = [ [1, 3], [0, 2], [1, 3], [0, 2] ] assert is_bipartite(graph) == True graph = [ [1, 2, 3], [0, 2], [0, 1, 3], [0, 2] ] assert is_bipartite(graph) == False ``` Notes: * The provided adjacency list will not contain self-loops (i.e., `graph[i]` will not include `i`). * If the graph is disconnected, the function should check for bipartite nature within each component. Good luck and happy coding!","solution":"from typing import List def is_bipartite(graph: List[List[int]]) -> bool: Determine if the given graph is bipartite. :param graph: List[List[int]] - An adjacency list of the graph. :return: bool - True if the graph is bipartite, False otherwise. n = len(graph) colors = [-1] * n def bfs(start): queue = [start] colors[start] = 0 # Start coloring with 0 while queue: node = queue.pop(0) current_color = colors[node] for neighbor in graph[node]: if colors[neighbor] == -1: # If not colored colors[neighbor] = 1 - current_color # Color with opposite color queue.append(neighbor) elif colors[neighbor] == current_color: # If same color found on adjacent return False return True # Check all components of the graph for i in range(n): if colors[i] == -1: # If the node is not yet visited if not bfs(i): return False return True"},{"question":"# Palindrome Checking with Various Constraints Problem Statement You need to implement a function `is_complex_palindrome(s)` that takes a string `s` as input and returns a Boolean value indicating whether the string is a complex palindrome or not. The string is considered a complex palindrome if: 1. It reads the same backward as forward. 2. Only alphanumeric characters are considered (ignoring spaces and punctuation). 3. Case is ignored. In addition to the basic palindrome check, your function must also handle the following constraints: 1. The function should be optimized for large inputs (strings up to 10^6 characters). 2. Handle edge cases: - Empty strings should be considered valid palindromes. - Strings with only non-alphanumeric characters should be handled gracefully. Your implementation should use the two-pointer approach for optimal space complexity. Input and Output - **Input**: A string `s` containing at most 10^6 characters. - **Output**: Return `True` if `s` is a complex palindrome, otherwise `False`. Function Signature ```python def is_complex_palindrome(s: str) -> bool: # Your implementation here ``` Constraints - `1 <= len(s) <= 10^6` - The string can contain letters, digits, spaces, and punctuation marks. Example ```python assert is_complex_palindrome(\\"A man, a plan, a canal: Panama\\") == True assert is_complex_palindrome(\\"race a car\\") == False assert is_complex_palindrome(\\"\\") == True assert is_complex_palindrome(\\".,?!;\\") == True ``` Additional Notes - Focus on minimizing the memory usage of your function given the large input size. - Ensure your function\'s time complexity remains linear, O(n).","solution":"def is_complex_palindrome(s: str) -> bool: Returns True if the given string is a complex palindrome. Considers only alphanumeric characters and ignores cases. left, right = 0, len(s) - 1 while left < right: # Move left pointer to the next alphanumeric character while left < right and not s[left].isalnum(): left += 1 # Move right pointer to the previous alphanumeric character while left < right and not s[right].isalnum(): right -= 1 if s[left].lower() != s[right].lower(): return False left += 1 right -= 1 return True"},{"question":"# Problem: Sudoku Validator with Custom Overlays You are tasked with implementing a function to validate whether a given 9x9 Sudoku board is a valid solution. Instead of traditional row, column, and sub-grid checks, you are also provided with additional overlays (groups of cells to be validated) that should contain unique numbers as well. # Function Signature ```python def custom_valid_solution(board: List[List[int]], overlays: List[List[Tuple[int, int]]]) -> bool: pass ``` # Input 1. `board`: A 2D list representing a 9x9 Sudoku board. Each cell contains an integer from 0 to 9, where 0 represents an empty cell. 2. `overlays`: A list of overlays. Each overlay is a list of tuples, where each tuple contains the coordinates (row, col) of the cells that must contain unique numbers from 1 to 9. # Output * Return `True` if the given board is a valid Sudoku solution under traditional rules and additional overlays, otherwise `False`. # Constraints: * The board is guaranteed to be a 9x9 grid. * Each cell in the board contains an integer between 0 and 9 (inclusive). * Boards containing 0s are invalid solutions. * Each overlay contains between 1 and 9 unique cells in the form of (row, col) tuples. # Example ```python from typing import List, Tuple board = [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ] overlays = [ [(0, 1), (1, 2), (2, 0)], [(3, 3), (4, 4), (5, 5)] ] assert custom_valid_solution(board, overlays) == True # Extra test case where the board has a duplicated number in the last row. board[8][8] = 8 assert custom_valid_solution(board, overlays) == False ``` # Explanation The function `custom_valid_solution` should not only validate the traditional Sudoku constraints but also ensure that the numbers in the given overlays are unique. The first overlay will consider cells from (0,1), (1,2), and (2,0), and the second overlay considers cells from (3,3), (4,4), and (5,5). Both overlays, along with the rows, columns, and 3x3 grids, must have unique numbers for the board to be valid.","solution":"from typing import List, Tuple def custom_valid_solution(board: List[List[int]], overlays: List[List[Tuple[int, int]]]) -> bool: def is_valid_group(group: List[int]) -> bool: seen = set() for num in group: if num == 0 or num in seen: return False seen.add(num) return True # Validate rows and columns for i in range(9): row = board[i] col = [board[j][i] for j in range(9)] if not is_valid_group(row) or not is_valid_group(col): return False # Validate 3x3 sub-grids for box_row in range(3): for box_col in range(3): box = [] for i in range(3): for j in range(3): box.append(board[box_row*3 + i][box_col*3 + j]) if not is_valid_group(box): return False # Validate overlays for overlay in overlays: overlay_values = [board[row][col] for row, col in overlay] if not is_valid_group(overlay_values): return False return True"},{"question":"# GCD, LCM, and Trailing Zeros Analysis and Implementation Scenario: You are tasked with developing a basic math utility library for a software application. Your utility should be able to compute the Greatest Common Divisor (GCD), the Lowest Common Multiple (LCM) of two integers, and determine the number of trailing zeros in the binary representation of an integer. # Requirements 1. **GCD Function**: - Implement a function to compute the GCD of two numbers using _Euclid\'s Algorithm_. - Input: Two integers `a` and `b` - Output: Integer representing the GCD of `a` and `b` 2. **LCM Function**: - Implement a function to compute the LCM of two numbers. - Input: Two integers `a` and `b` - Output: Integer representing the LCM of `a` and `b` 3. **Trailing Zeros Function**: - Implement a function to compute the number of trailing zeros in the binary representation of a number. - Input: A single integer `x` - Output: Integer representing the number of trailing zeros in `x`\'s binary representation # Constraints - The input integers `a` and `b` for GCD and LCM are non-negative and not both zero. - The input integer `x` for trailing zeros calculation is non-negative. - Avoid using built-in functions that directly compute these results. # Performance Requirement - All functions should have a time complexity better than or equal to O(log n) where `n` is the size of the input. # Function Signatures ```python def gcd(a: int, b: int) -> int: pass def lcm(a: int, b: int) -> int: pass def trailing_zero(x: int) -> int: pass ``` # Example Usage - **GCD Calculation**: ```python print(gcd(54, 24)) # Output: 6 ``` - **LCM Calculation**: ```python print(lcm(4, 5)) # Output: 20 ``` - **Trailing Zeros Calculation**: ```python print(trailing_zero(40)) # Output: 3 ``` Your task is to implement these functions such that they fulfill the requirements and constraints outlined above.","solution":"def gcd(a: int, b: int) -> int: Compute the Greatest Common Divisor (GCD) of two numbers using Euclid\'s Algorithm. while b: a, b = b, a % b return a def lcm(a: int, b: int) -> int: Compute the Lowest Common Multiple (LCM) of two numbers. if a == 0 or b == 0: return 0 return abs(a * b) // gcd(a, b) def trailing_zero(x: int) -> int: Compute the number of trailing zeros in the binary representation of a number. if x == 0: return 0 count = 0 while x & 1 == 0: x >>= 1 count += 1 return count"},{"question":"# Scenario You are developing a feature for a text editor to enable users to check if a piece of text is a palindrome. The editor should ignore all non-alphanumeric characters and treat uppercase and lowercase letters as equivalent. # Problem Statement Write a function `is_editor_palindrome(s: str) -> bool` that receives a string `s` and returns `True` if the string is a palindrome considering only alphanumeric characters and ignoring case, otherwise returns `False`. # Input and Output - Input: A string `s` which may include spaces, punctuation, and alphanumeric characters. - Output: A boolean value, `True` if the string is a palindrome, `False` otherwise. # Constraints - The string length will not exceed 10<sup>6</sup> characters. - Only consider ASCII alphanumeric characters. # Example 1. `is_editor_palindrome(\\"A man, a plan, a canal: Panama\\")` should return `True`. 2. `is_editor_palindrome(\\"race a car\\")` should return `False`. 3. `is_editor_palindrome(\\"\\")` should return `True`. # Note You should aim to implement your solution with optimal time and space complexity. Consider edge cases such as empty strings, strings with only punctuation, and single-character strings.","solution":"def is_editor_palindrome(s: str) -> bool: Returns True if the given string is a palindrome considering only alphanumeric characters and ignoring the case, otherwise returns False. # Filter out non-alphanumeric characters and convert to lowercase. filtered_chars = [char.lower() for char in s if char.isalnum()] # Compare the filtered list with its reverse. return filtered_chars == filtered_chars[::-1]"},{"question":"# Scenario You\'re tasked with enhancing the given Binary Search Tree (BST) implementation. The existing implementation supports basic operations like insertion, searching, size calculation, and traversal. Your goal is to implement two additional important functions: `delete` and `find_min`. # Requirements Task 1: Implement the `delete` function Write a method to delete a node with the specified value from the BST. This method should correctly handle: * Nodes with no children (leaf nodes) * Nodes with one child * Nodes with two children (use the in-order successor to replace the deleted node) Task 2: Implement the `find_min` function Write a method to find the minimum value in the BST. This method should traverse the left children until it reaches the leftmost node. # Function Specifications 1. delete(data) * **Input**: An integer `data` to be deleted from the BST. * **Output**: None (the tree should be updated in place). 2. find_min() * **Input**: None * **Output**: The minimum value in the BST. # Constraints * Assume all values to be inserted are unique. * The BST will have at least one value before any delete operations. * Assume the input to `delete` will be a value that exists in the BST. # Example Assume the initial tree is as follows: ``` 10 / 6 15 / / 4 9 12 24 / 7 18 30 ``` * Calling `delete(15)` should transform the tree to: ``` 10 / 6 18 / / 4 9 12 24 7 30 ``` * Calling `find_min()` should return `4` for the given tree. # Testing Complete the implementation and test it with various scenarios ensuring all edge cases are covered.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.val: if node.left is None: node.left = TreeNode(key) else: self._insert(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert(node.right, key) def find_min(self): current = self.root while current.left is not None: current = current.left return current.val def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, root, key): if root is None: return root if key < root.val: root.left = self._delete(root.left, key) elif key > root.val: root.right = self._delete(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left min_val_node = self._find_min_node(root.right) root.val = min_val_node.val root.right = self._delete(root.right, root.val) return root def _find_min_node(self, node): current = node while current.left is not None: current = current.left return current"},{"question":"You are given a set of labeled vectors (training set) and an unknown vector for which you need to determine the label using the Nearest Neighbor Algorithm. **Functional Requirements**: - Implement a function `nearest_neighbor_classification(x, tSet)` where: - `x`: A tuple of numerical values representing a vector. - `tSet`: A dictionary where keys are tuples representing training vectors and values are their corresponding labels. - The function should return the label of the nearest training vector to `x`. # Constraints 1. The vectors in `x` and `tSet` will have the same length. 2. The training set `tSet` will contain at least one vector. 3. You must use Euclidean distance as the distance metric. # Input/Output Formats **Input**: ```python x: Tuple[float, ...] tSet: Dict[Tuple[float, ...], Any] ``` **Output**: ```python Any # The label corresponding to the nearest neighbor vector in the training set ``` # Example **Input**: ```python x = (1.0, 2.0) tSet = { (1.1, 2.1): \'A\', (1.2, 3.1): \'B\', (0.9, 1.9): \'C\' } ``` **Output**: ``` C ``` # Additional Information Your solution should consider edge cases such as: - Identical vectors in the training set and the input vector. - Training sets with very close but not identical distances. # Performance Requirements The algorithm must efficiently handle large training sets (e.g., thousands of vectors) within reasonable time limits.","solution":"import math def euclidean_distance(v1, v2): return math.sqrt(sum((a - b) ** 2 for a, b in zip(v1, v2))) def nearest_neighbor_classification(x, tSet): Returns the label of the nearest training vector to x using Euclidean distance. Parameters: x (tuple): A numeric tuple representing the vector to classify. tSet (dict): A dictionary with keys as numeric tuples (training vectors) and values as their corresponding labels. Returns: The label corresponding to the nearest neighbor vector in the training set. nearest_label = None min_distance = float(\'inf\') for train_vector, label in tSet.items(): distance = euclidean_distance(x, train_vector) if distance < min_distance: min_distance = distance nearest_label = label return nearest_label"},{"question":"**Objective:** Implement a function that generates all possible subsets of a given set of distinct integers using an iterative approach. **Context:** You are tasked with generating subsets for a configuration problem. Given a set of features, you need to analyze every possible combination of them for comprehensive testing. **Function Signature:** ```python def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: :param nums: List of distinct integers :return: Set containing all subsets represented as tuples ``` **Input:** * A list of distinct integers `nums` with the constraint that the length of `nums` will be in the range [0, 10]. **Output:** * A set of tuples, where each tuple represents a subset of the input list `nums`. **Constraints:** * The input list `nums` will contain no duplicate elements. * The elements will be distinct and within the range of -10^3 to 10^3. **Performance Requirements:** * Aim for O(n * 2^n) time complexity and O(n * 2^n) space complexity due to the inherent nature of subset generation. **Example:** ```python nums = [1, 2, 3] generate_subsets(nums) # Should return: # { # (), (1,), (2,), (3,), (1, 2,), (1, 3,), (2, 3,), (1, 2, 3) # } ``` **Additional Challenge:** Make sure your implementation is efficient enough to handle the upper limit of input constraints within physical memory limits. **Assessment Criteria:** * Correctness: The function should return all subsets correctly. * Efficiency: The function should be efficient in terms of time and space. * Edge Cases: Consider edge cases like empty input and single-element lists.","solution":"from typing import List, Set, Tuple def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: Generates all possible subsets of a given set of distinct integers using an iterative approach. :param nums: List of distinct integers :return: Set containing all subsets represented as tuples result = {()} for num in nums: new_subsets = set() for subset in result: new_subsets.add(subset + (num,)) result.update(new_subsets) return result"},{"question":"You are given an array of distinct integers. Your task is to implement the `cycle_sort` function that sorts the array using the Cycle Sort algorithm. The function should sort the array in-place and return the sorted array. # Function Signature ```python def cycle_sort(arr: List[int]) -> List[int]: ``` # Input * `arr`: A list of distinct integers, with length `n` (1 <= n <= 10^4) # Output * A sorted list of integers. # Example ```python assert cycle_sort([4, 2, 3, 1]) == [1, 2, 3, 4] assert cycle_sort([10, 7, 8, 9, 1, 5]) == [1, 5, 7, 8, 9, 10] ``` # Constraints * The input list will only contain distinct integers. * Implement the function with in-place sorting without using extra space for another array. # Additional Requirements * You should aim for minimal write operations to the list. * Clearly document your code and include necessary comments to show the steps involved in the Cycle Sort algorithm.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: Sorts the array in-place using Cycle Sort algorithm and returns the sorted array. writes = 0 # Loop through the array to find cycles to rotate. for cycle_start in range(0, len(arr) - 1): item = arr[cycle_start] # Find where to put the item. pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 # If the item is already in the correct position, continue. if pos == cycle_start: continue # Otherwise, put the item there or right after any duplicates. while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle. while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"You are tasked with creating a function to rotate a 2D matrix 180 degrees utilizing two intermediate 90-degree rotations performed in succession. # Function Signature ```python def rotate_180(matrix: List[List[int]]) -> List[List[int]]: pass ``` # Input * **`matrix`**: A list of lists where each sublist represents a row of the 2D matrix. The matrix can be of any dimension (nxm). # Output * The function should return a new matrix which is rotated by 180 degrees. # Constraints * 1 ≤ n, m ≤ 1000 * Elements of the matrix are integers (-1000 ≤ element ≤ 1000) # Example Input ``` matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_180(matrix) ``` # Example Output ``` [ [9, 8, 7], [6, 5, 4], [3, 2, 1] ] ``` # Explanation The example matrix after rotating 180 degrees: Initial: ``` 1 2 3 4 5 6 7 8 9 ``` After rotating 180 degrees: ``` 9 8 7 6 5 4 3 2 1 ``` # Notes * You must handle edge cases such as empty matrices. * Ensure that the function runs efficiently within the provided constraints. # Performance Requirements The function should run in O(n*m) time complexity and use O(n*m) space.","solution":"from typing import List def rotate_90(matrix: List[List[int]]) -> List[List[int]]: Rotate the matrix 90 degrees clockwise # Transpose the matrix and then reverse each row return [list(reversed(col)) for col in zip(*matrix)] def rotate_180(matrix: List[List[int]]) -> List[List[int]]: Rotate the matrix 180 degrees # Perform two 90-degree rotations rotated_once = rotate_90(matrix) rotated_twice = rotate_90(rotated_once) return rotated_twice"},{"question":"# String Reversal Algorithms Context: You are tasked to implement and compare various string reversal functions in Python. These functions accept a single string as input and return the reversed version of that string. This specifically tests your understanding of recursion, iteration, and Python\'s slicing mechanisms. Task: Implement the following string reversal methods adhering to their specific techniques. 1. **recursive_reverse(s)**: Implement string reversal using recursion. 2. **iterative_reverse(s)**: Implement string reversal using an iterative approach. 3. **pythonic_reverse(s)**: Implement string reversal using Python’s built-in `reversed()` function. 4. **ultra_pythonic_reverse(s)**: Implement string reversal using Python’s slicing feature. Function Definitions: ```python def recursive_reverse(s: str) -> str: # Your code here pass def iterative_reverse(s: str) -> str: # Your code here pass def pythonic_reverse(s: str) -> str: # Your code here pass def ultra_pythonic_reverse(s: str) -> str: # Your code here pass ``` Constraints: - `0 <= len(s) <= 10^5` Detailed Requirements: 1. **recursive_reverse** - Must use recursion to reverse the string. - Consider recursion limits with very large inputs. 2. **iterative_reverse** - Swap characters from both ends moving towards the center. 3. **pythonic_reverse** - Utilize Python’s `reversed()` function. 4. **ultra_pythonic_reverse** - Use Python slicing to reverse the string. Input/Output Examples: ```python print(recursive_reverse(\\"hello\\")) # \\"olleh\\" print(iterative_reverse(\\"world\\")) # \\"dlrow\\" print(pythonic_reverse(\\"python\\")) # \\"nohtyp\\" print(ultra_pythonic_reverse(\\"abcd\\"))# \\"dcba\\" print(ultra_pythonic_reverse(\\"\\")) # \\"\\" print(recursive_reverse(\\"a\\")) # \\"a\\" ``` Note: Ensure that the code runs efficiently within the constraints.","solution":"def recursive_reverse(s: str) -> str: if len(s) == 0: return s else: return s[-1] + recursive_reverse(s[:-1]) def iterative_reverse(s: str) -> str: str_list = list(s) start, end = 0, len(str_list) - 1 while start < end: str_list[start], str_list[end] = str_list[end], str_list[start] start += 1 end -= 1 return \'\'.join(str_list) def pythonic_reverse(s: str) -> str: return \'\'.join(reversed(s)) def ultra_pythonic_reverse(s: str) -> str: return s[::-1]"},{"question":"You are given an array of integers representing the initial frequencies of elements. Your task is to implement a Fenwick Tree (Binary Indexed Tree) that supports the following operations efficiently: 1. `update_freq(index, value)`: Update the frequency of the element at `index` to `value`. 2. `prefix_sum(index)`: Return the sum of frequencies from the start up to the given `index`. # Function Specifications: Update Function: ```python def update_freq(index: int, value: int) -> None: pass ``` - **Input**: - `index`: An integer representing the position in the array (0-based). - `value`: An integer representing the new value to set at that position. - **Output**: - This function should not return anything. - **Constraints**: - 0 <= `index` < n (length of the array). - -10^9 <= `value` <= 10^9 Prefix Sum Function: ```python def prefix_sum(index: int) -> int: pass ``` - **Input**: - `index`: An integer representing the position in the array (0-based). - **Output**: - An integer representing the sum of the frequencies from the start up to `index`. - **Constraints**: - 0 <= `index` < n - Ensure that operations are efficient (O(log n) time complexity). # Example: ```python # Given initial array: [3,2,-1,6,5,4,-3,3,7,2,3] # Creating the Fenwick Tree: ft = Fenwick_Tree([3,2,-1,6,5,4,-3,3,7,2,3]) # Getting the prefix sum up to index 5 (0-based): print(ft.prefix_sum(5)) # Output: Expected sum = 19 # Updating the frequency at index 4 with the value 1: ft.update_freq(4, 1) # Getting the updated prefix sum up to index 5 (0-based) after the update: print(ft.prefix_sum(5)) # Output: Expected sum = 15 ``` # Important Points: - Make sure to handle edge cases such as empty arrays. - Consider various scenarios where updates might affect the structure of your tree. **Hint**: Use the `Fenwick_Tree` class provided in the code snippets to assist with constructing your solution.","solution":"class Fenwick_Tree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (self.n + 1) self.arr = arr[:] for i in range(self.n): self._update_tree(i, arr[i]) def _update_tree(self, index, value): index += 1 while index <= self.n: self.tree[index] += value index += index & -index def update_freq(self, index, value): original_value = self.arr[index] diff = value - original_value self.arr[index] = value self._update_tree(index, diff) def prefix_sum(self, index): index += 1 result = 0 while index > 0: result += self.tree[index] index -= index & -index return result"},{"question":"# Combination Calculation with Constraints You are tasked with writing a function to compute the binomial coefficient ( C(n, r) ), which represents the number of ways to choose ( r ) items from ( n ) items. Given the constraints on both time and space, you need to use a dynamic programming approach without recursion to avoid deep stack issues. # Function Signature ```python def combination(n: int, r: int) -> int: pass ``` # Input - **n** (integer): A non-negative integer representing the total number of items (1 ≤ n ≤ 1000). - **r** (integer): A non-negative integer representing the number of items to choose (0 ≤ r ≤ n). # Output - **int**: The binomial coefficient ( C(n, r) ). # Constraints - Use an iterative dynamic programming approach. - Aim for a time complexity of ( O(n times r) ) and space complexity of ( O(r) ). # Example ```python print(combination(5, 2)) # Output: 10 print(combination(10, 5)) # Output: 252 ``` # Description 1. Use an iterative approach to build up the binomial coefficients using a 1-dimensional list. 2. Implement the DP relation: - ( C(n, r) = C(n-1, r-1) + C(n-1, r) ) This problem will test your understanding of dynamic programming and combinatorial counting, as well as your ability to optimize algorithmic solutions for performance constraints.","solution":"def combination(n: int, r: int) -> int: Computes the binomial coefficient C(n, r) using an iterative dynamic programming approach. if r > n: return 0 if r == 0 or r == n: return 1 # Initialize a list for storing intermediate results for k from 0 to r dp = [0] * (r + 1) dp[0] = 1 # C(n, 0) is 1 for any n for i in range(1, n + 1): # Start from the end to keep using the previous values for j in range(min(i, r), 0, -1): dp[j] += dp[j - 1] return dp[r]"},{"question":"# Array Filtering with Dynamic Limits Scenario: In data preprocessing for a machine learning model, you often need to filter numerical data based on dynamic criteria such as thresholds determined by specific statistical properties (e.g., lower quartile, upper quartile). Given an array, you need to return a subset of elements that fall within specific bounds. Task: Write a Python function `dynamic_filter(arr, min_lim=None, max_lim=None)` that takes an input list `arr` and optional boundary values `min_lim` and `max_lim`. The function should return a new list containing elements from `arr` that are greater than or equal to `min_lim` and less than or equal to `max_lim`. If `min_lim` or `max_lim` is not provided, use the smallest or largest value in the array, respectively. Requirements: 1. Function signature: `def dynamic_filter(arr, min_lim=None, max_lim=None):` 2. Input: * `arr` - A list of integers. * `min_lim` - An integer or None (optional). * `max_lim` - An integer or None (optional). 3. Output: * A list of integers with elements within the specified range. 4. Constraints: * If `arr` is empty, the function should return an empty list. * The function should handle cases where `min_lim` is greater than `max_lim` gracefully by returning an empty list. * Elements in the returned list should maintain their original order. 5. Performance: * The solution should handle arrays of up to 10^6 elements efficiently. Example: ```python assert dynamic_filter([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert dynamic_filter([10, 20, 30, 40, 50], 15, 35) == [20, 30] assert dynamic_filter([5, 4, 3, 2, 1], 3, None) == [5, 4, 3] assert dynamic_filter([], 1, 10) == [] assert dynamic_filter([1, 2, 3], 4, 1) == [] ``` Implement the `dynamic_filter` function to pass the provided test cases and meet the requirements outlined.","solution":"def dynamic_filter(arr, min_lim=None, max_lim=None): Filters array based on provided min_lim and max_lim. If min_lim or max_lim is not provided, default to smallest or largest value in arr, respectively. If arr is empty, return an empty list. If min_lim > max_lim, return an empty list. if not arr: return [] min_val = min(arr) max_val = max(arr) if min_lim is None: min_lim = min_val if max_lim is None: max_lim = max_val if min_lim > max_lim: return [] return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"**Scenario**: You are given a collection of user transactions where some transactions may be identical. As part of a data-cleaning process, you need to remove duplicate transactions while maintaining the order of their first occurrence. **Task**: Write a function `remove_duplicates_optimized` that removes duplicates from an array while improving the time complexity to O(n). Your function should use an auxiliary data structure to achieve this. **Function Signature**: ```python def remove_duplicates_optimized(array): pass ``` **Input Format**: - A list of elements which can be integers, strings, booleans, etc. **Output Format**: - A new list with all duplicates removed, preserving the order of their first occurrence. **Constraints**: - The elements\' order in the output list should be the same as their first occurrence in the input list. - The solution should aim for O(n) time complexity. **Example**: ```python Input: [1, 1, 2, 3, \'foo\', \'foo\', \'bar\', True, True, False] Output: [1, 2, 3, \'foo\', \'bar\', True, False] ``` **Performance Requirements**: - Your solution must not exceed O(n) time complexity.","solution":"def remove_duplicates_optimized(array): Removes duplicates from an array while maintaining the order of their first occurrence. seen = set() result = [] for item in array: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"Scenario You are working on a network security project and need to determine the number of active (1) bits in network masks represented as unsigned integers. Given the critical nature of network configurations, you need to ensure an efficient counting mechanism that operates quickly even for sparse bit configurations. Task Implement a function that takes an unsigned integer as input and returns the number of \'1\' bits it has, also known as the Hamming weight. Use the principles of Brian Kernighan\'s algorithm for your implementation. # Function Signature ```python def count_ones(n: int) -> int: pass ``` Input - `n`: an unsigned integer (assumed to be non-negative). Output - An integer representing the number of \'1\' bits in the binary representation of `n`. Constraints - The input integer will be non-negative and fit within a standard 32-bit unsigned integer range (0 to 2^32 - 1). # Examples - `count_ones(11)` returns `3` (binary representation is `00000000000000000000000000001011`) - `count_ones(0)` returns `0` (binary representation is `00000000000000000000000000000000`) - `count_ones(128)` returns `1` (binary representation is `00000000000000000000000010000000`) # Performance Requirements Ensure your implementation is efficient, making use of Brian Kernighan\'s algorithm\'s property of taking O(k) time, where k is the number of \'1\' bits.","solution":"def count_ones(n: int) -> int: Returns the number of \'1\' bits in the binary representation of n. Uses Brian Kernighan\'s algorithm for efficiency. count = 0 while n: n = n & (n - 1) count += 1 return count"},{"question":"# Cholesky Decomposition Enhanced You are required to implement an enhanced cholesky decomposition method that not only checks for positive definiteness but also handles different matrix dimensions and provides better reporting when decomposition fails. Input - A 2D list of floats, representing a Hermitian positive-definite matrix A of the form `List[List[float]]`. Output - If successful, return a 2D list of floats representing the lower triangular matrix V such that ( V cdot V^* = A ). - If the matrix cannot be decomposed, return a string explaining the cause of failure: `Invalid matrix dimensions` or `Matrix is not positive-definite`. Constraints - The matrix will be of size `n x n` where ( 2 leq n leq 100 ). - The matrix elements will be floats. Example: # Input: ```python A = [[4.0, 12.0, -16.0], [12.0, 37.0, -43.0], [-16.0, -43.0, 98.0]] ``` # Output: ```python [[2.0, 0.0, 0.0], [6.0, 1.0, 0.0], [-8.0, 5.0, 3.0]] ``` # Input: ```python A = [[1.0, 2.0], [2.0, 1.0]] ``` # Output: ```python \'Matrix is not positive-definite\' ``` # Task: Implement the function in Python. ```python import math def enhanced_cholesky_decomposition(A): :param A: Hermitian positive-definite matrix of type List[List[float]] :return: matrix of type List[List[float]] if A can be decomposed, otherwise a string with the error message. n = len(A) for ai in A: if len(ai) != n: return \'Invalid matrix dimensions\' V = [[0.0] * n for _ in range(n)] for j in range(n): sum_diagonal_element = 0 for k in range(j): sum_diagonal_element += math.pow(V[j][k], 2) sum_diagonal_element = A[j][j] - sum_diagonal_element if sum_diagonal_element <= 0: return \'Matrix is not positive-definite\' V[j][j] = math.sqrt(sum_diagonal_element) for i in range(j + 1, n): sum_other_element = 0 for k in range(j): sum_other_element += V[i][k] * V[j][k] V[i][j] = (A[i][j] - sum_other_element) / V[j][j] return V ```","solution":"import math def enhanced_cholesky_decomposition(A): :param A: Hermitian positive-definite matrix of type List[List[float]] :return: matrix of type List[List[float]] if A can be decomposed, otherwise a string with the error message. n = len(A) # Check if A is a square matrix for ai in A: if len(ai) != n: return \'Invalid matrix dimensions\' # Initialize the lower triangular matrix V V = [[0.0] * n for _ in range(n)] for j in range(n): sum_diagonal_element = 0 for k in range(j): sum_diagonal_element += V[j][k] ** 2 sum_diagonal_element = A[j][j] - sum_diagonal_element if sum_diagonal_element <= 0: return \'Matrix is not positive-definite\' V[j][j] = math.sqrt(sum_diagonal_element) for i in range(j + 1, n): sum_other_element = 0 for k in range(j): sum_other_element += V[i][k] * V[j][k] V[i][j] = (A[i][j] - sum_other_element) / V[j][j] return V"},{"question":"You are given a list of integers and a positive integer N. Your task is to implement a function `limit_occurrences(lst: List[int], N: int) -> List[int]` that returns a new list in which each integer in the input list appears no more than N times. The order of elements in the new list should remain the same as the input list. # Input * `lst` - A list of integers. (0 <= len(lst) <= 10^6, -10^6 <= lst[i] <= 10^6) * `N` - An integer representing the maximum number of occurrences for each integer in the returned list. (0 <= N <= 10^6) # Output * A list of integers where each integer appears no more than N times. # Example ```python limit_occurrences([1,2,3,1,2,1,2,3], 2) # Output: [1, 2, 3, 1, 2, 3] limit_occurrences([1,1,1,2,2,3], 1) # Output: [1, 2, 3] limit_occurrences([4, 5, 6], 0) # Output: [] ``` # Constraints and Considerations * Ensure your function handles large inputs efficiently. * Consider edge cases such as an empty list, N zero (return an empty list), and lists with all unique elements. * The function should maintain the original order of elements as much as possible.","solution":"from typing import List def limit_occurrences(lst: List[int], N: int) -> List[int]: if N == 0: return [] count = {} result = [] for num in lst: if num in count: if count[num] < N: result.append(num) count[num] += 1 else: count[num] = 1 result.append(num) return result"},{"question":"Context: You are working on a large social network application which needs to be able to quickly answer the question of whether two users are in the same group of friends. A user can send friend requests to other users to become friends. When two users become friends, their friends list merge, thus if you are a friend of one user, you become friends with the other user\'s friends too. To efficiently manage and query these group relationships, you\'ll implement and use the Union-Find data structure. Task: Implement the Union-Find data structure to support the following operations: 1. `addUser(user)`: Add a new user to the network. 2. `areFriends(user1, user2)`: Return `True` if the two users are in the same friend group, otherwise `False`. 3. `makeFriends(user1, user2)`: Merge the friend groups of these two users. Input/Output: * **addUser(user: int) -> None**: Adds a new user with the given identifier to the network. * **areFriends(user1: int, user2: int) -> bool**: Returns a boolean indicating whether `user1` and `user2` are in the same friend group. * **makeFriends(user1: int, user2: int) -> None**: Merges the friend groups of `user1` and `user2`. You need to ensure the operations answer correctly and efficiently. Function Signatures: ```python class UnionFind: def __init__(self): # Initialize your data structure here pass def addUser(self, user: int) -> None: # Add user to the Union-Find structure pass def areFriends(self, user1: int, user2: int) -> bool: # Check if two users are in the same connected component pass def makeFriends(self, user1: int, user2: int) -> None: # Union two user\'s connected components pass ``` Constraints: 1. All user IDs will be unique integers. 2. You may assume that `user1` and `user2` have already been added to the Union-Find data structure when calling `makeFriends` or `areFriends`. 3. All operations should be efficiently implemented. Write your code to pass the following test cases: ```python uf = UnionFind() uf.addUser(1) uf.addUser(2) uf.addUser(3) assert not uf.areFriends(1, 2) uf.makeFriends(1, 2) assert uf.areFriends(1, 2) assert not uf.areFriends(2, 3) uf.makeFriends(2, 3) assert uf.areFriends(1, 3) ``` Note: Be mindful of edge cases, efficiency, and correctness while implementing the above task.","solution":"class UnionFind: def __init__(self): self.parent = {} self.rank = {} def addUser(self, user: int) -> None: if user not in self.parent: self.parent[user] = user self.rank[user] = 0 def find(self, user: int) -> int: if self.parent[user] != user: self.parent[user] = self.find(self.parent[user]) return self.parent[user] def areFriends(self, user1: int, user2: int) -> bool: return self.find(user1) == self.find(user2) def makeFriends(self, user1: int, user2: int) -> None: root1 = self.find(user1) root2 = self.find(user2) if root1 != root2: if self.rank[root1] > self.rank[root2]: self.parent[root2] = root1 elif self.rank[root1] < self.rank[root2]: self.parent[root1] = root2 else: self.parent[root2] = root1 self.rank[root1] += 1"},{"question":"# Context: Transforming Integer Representations In digital systems, sometimes you need to translate one configuration of binary data to another in the most efficient manner. For instance, in error detection and correction protocols, understanding how many bits differ between two binary representations is crucial. # Problem Statement **Objective:** Write a function `count_flips_to_convert` to determine the minimal number of bits that need to be flipped to convert an integer `A` to integer `B`. Input - Two integers `A` and `B`. Output - An integer representing the number of differing bits (flips required). # Function Signature ```python def count_flips_to_convert(a: int, b: int) -> int: ``` Example ```python # Input A = 29 # (in binary: 11101) B = 15 # (in binary: 01111) # Output 2 ``` Explanation - Binary representation of `A` is `11101`. - Binary representation of `B` is `01111`. - The differing bits positions between these two are the second and third from the right, thus requiring 2 flips. # Constraints and Assumptions - The integers `A` and `B` are non-negative. - You can assume the input values will fit within standard 32-bit signed integer range. - Aim for an efficient solution both in time and space complexity. # Notes: - Ensure to handle edge cases where `A` and `B` might be identical (resulting in zero flips). - Consider the performance implications when dealing with large integers that might have up to 32 bits.","solution":"def count_flips_to_convert(a: int, b: int) -> int: This function calculates the minimal number of bits that need to be flipped to convert integer `a` to integer `b`. # XOR a and b to find differing bits xor_result = a ^ b # Count the number of 1s in the result which indicates differing bits count = 0 while xor_result: # Increment count for each 1 found count += xor_result & 1 # Right shift to check next bit xor_result >>= 1 return count"},{"question":"Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. The LCA is defined as the lowest node in the tree that has both nodes as descendants (a node can be a descendant of itself). Function Signature ```python def lca(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: pass ``` Input * `root`: The root node of the binary tree. * `p`: First node * `q`: Second node Output * Return the LCA node. Constraints * All Node values are unique. * `p` and `q` are different and both values are guaranteed to be in the tree. # Example Example 1 ```plaintext Input: _______3______ / ___5__ ___1__ / / 6 _2 0 8 / 7 4 p = 5, q = 1 Output: 3 ``` Example 2 ```plaintext Input: _______3______ / ___5__ ___1__ / / 6 _2 0 8 / 7 4 p = 5, q = 4 Output: 5 ``` # Additional Requirements: 1. Your algorithm must run with a time complexity of O(N) where N is the number of nodes in the tree. 2. You should handle edge cases such as single-node trees and cases where the tree is highly unbalanced. **Hint**: Use recursive depth-first search (DFS) to explore all nodes, starting from the root towards the leaves, and employ backtracking to determine the lowest common ancestor.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def lca(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: Find the lowest common ancestor (LCA) of two given nodes in a binary tree. The LCA is defined as the lowest node that has both p and q as descendants. # Base case: if the root is None or root is one of p or q if root is None or root == p or root == q: return root # Recursively find LCA in the left subtree and right subtree left = lca(root.left, p, q) right = lca(root.right, p, q) # If both left and right are not None, then p and q are in different subtrees # So, the current root is the LCA if left is not None and right is not None: return root # If left is not None, return left; otherwise, return right return left if left is not None else right"},{"question":"Implement CircularQueue We have provided you with two types of Queue implementations: one based on a dynamic array (`ArrayQueue`) and one based on linked list nodes (`LinkedListQueue`). Now, embed the principles and knowledge by implementing a circular queue, another common and advanced queue variant. CircularQueue: A **CircularQueue** is an advanced type of primary queue but follows the circular (cyclic) nature instead of a linear structure. In this queue, the last position is connected back to the first position to make a circle. Requirements: * The CircularQueue should have a fixed size. * It should support the initialization, enqueue, dequeue, peek, is_empty, and is_full methods. * Try to offer all operations with O(1) time complexity. Function Signature: - `__init__(self, capacity: int)` - `enqueue(self, value: int) -> None` - `dequeue(self) -> int` - `peek(self) -> int` - `is_empty(self) -> bool` - `is_full(self) -> bool` # Constraints: 1. You may assume the `enqueue` will not be called if the queue is full, and `dequeue` or `peek` will not be called if the queue is empty. 2. Only implement the CircularQueue class, you are free to leverage Python\'s list and any other standard data structures but not pre-built queue libraries or collections. # Example: ```python cq = CircularQueue(3) cq.enqueue(1) cq.enqueue(2) assert cq.dequeue() == 1 assert cq.peek() == 2 assert not cq.is_full() cq.enqueue(3) cq.enqueue(4) assert cq.is_full() ``` # Your Task: Create the **CircularQueue** class with the specified methods and ensure it adheres to the constraints.","solution":"class CircularQueue: def __init__(self, capacity: int): self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = -1 self.size = 0 def enqueue(self, value: int) -> None: if self.is_full(): raise OverflowError(\\"Queue is full\\") self.rear = (self.rear + 1) % self.capacity self.queue[self.rear] = value self.size += 1 def dequeue(self) -> int: if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.size -= 1 return value def peek(self) -> int: if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def is_empty(self) -> bool: return self.size == 0 def is_full(self) -> bool: return self.size == self.capacity"},{"question":"Coding Assessment Question # Problem Description You are working for an e-commerce company that often needs to search for specific price points within sorted price data. The data is large and uniformly distributed. To optimize the search operation, you decide to implement the Interpolation Search algorithm. # Task Write a function `interpolation_search_price` that searches for a specific price in a sorted list of prices using the Interpolation Search algorithm. # Function Signature ```python def interpolation_search_price(prices: List[int], target_price: int) -> int: ``` # Input - `prices`: A list of integers `List[int]`, representing sorted prices in ascending order where 0 ≤ prices[i] ≤ 10^6, and 1 ≤ len(prices) ≤ 10^5. - `target_price`: An integer `target_price`, representing the price to search for within the list, where 0 ≤ target_price ≤ 10^6. # Output - Return an integer, the index of `target_price` in the list if found; otherwise, return -1. # Constraints - The list is guaranteed to be sorted in ascending order. - The values are uniformly distributed. # Performance Requirements - The solution should be efficient and leverage the properties of Interpolation Search to handle large input sizes effectively. # Example ```python from typing import List def interpolation_search_price(prices: List[int], target_price: int) -> int: # your implementation here # Example 1 assert interpolation_search_price([5, 10, 12, 15, 19, 21, 30, 35, 50, 62], 30) == 6 # Example 2 assert interpolation_search_price([5, 10, 12, 15, 19, 21, 30, 35, 50, 62], 21) == 5 # Example 3 assert interpolation_search_price([5, 10, 12, 15, 19, 21, 30, 35, 50, 62], 100) == -1 # Example 4 assert interpolation_search_price([5, 10, 12, 15, 19, 21, 30, 35, 50, 62], 0) == -1 # Example 5 assert interpolation_search_price([], 30) == -1 ``` # Explanation - In the first example, the target price `30` is present at index `6`. - In the second example, the target price `21` is present at index `5`. - In the third example, the target price `100` is not present; hence return `-1`. - The fourth example shows the target price `0` is not present; hence return `-1`. - The fifth example considers an empty list which should return `-1`.","solution":"from typing import List def interpolation_search_price(prices: List[int], target_price: int) -> int: low = 0 high = len(prices) - 1 while low <= high and target_price >= prices[low] and target_price <= prices[high]: if low == high: if prices[low] == target_price: return low return -1 pos = low + int(((float(high - low) / (prices[high] - prices[low])) * (target_price - prices[low]))) if prices[pos] == target_price: return pos if prices[pos] < target_price: low = pos + 1 else: high = pos - 1 return -1"},{"question":"You are tasked with enhancing a priority queue for a task scheduling system. The existing priority queue implemented using a linear array has suboptimal insertion performance. Your goal is to implement a more efficient priority queue using a heap data structure (min-heap). In a min-heap, the element with the lowest priority is at the root, allowing both insertion and extraction operations to be performed efficiently. # Requirements 1. Implement a priority queue using a min-heap. 2. Provide the following methods in your priority queue implementation: - `size()`: Return the number of items in the priority queue. - `push(item, priority)`: Insert an item with the given priority into the priority queue. - `pop()`: Remove and return the item with the lowest priority. # Input/Output Format - `push(item, priority)` will be called with `item` being any data and `priority` being an integer representing its priority. - `pop()` will return the item with the lowest priority. - `size()` will return the current number of items in the queue. # Constraints - The queue will contain at most 10^5 items. - Priority values are integers and can be negative. # Performance Requirements - Insertion and extraction operations should be efficient, ideally O(log n). # Example ```python pq = MinHeapPriorityQueue() pq.push(\\"task1\\", 2) pq.push(\\"task2\\", 1) pq.push(\\"task3\\", 3) print(pq.pop()) # Outputs: \\"task2\\" print(pq.pop()) # Outputs: \\"task1\\" print(pq.size()) # Outputs: 1 ``` # Notes - You need to ensure that the heap property is maintained after each insertion and extraction. - Handle edge cases such as popping from an empty queue appropriately.","solution":"import heapq class MinHeapPriorityQueue: def __init__(self): self.heap = [] self.count = 0 def size(self): Returns the number of items in the priority queue. return len(self.heap) def push(self, item, priority): Insert an item with the given priority into the priority queue. heapq.heappush(self.heap, (priority, self.count, item)) self.count += 1 def pop(self): Remove and return the item with the lowest priority. if self.size() > 0: return heapq.heappop(self.heap)[2] else: raise IndexError(\\"pop from an empty priority queue\\")"},{"question":"You are given a text processing task where you need to reverse the order of words in a string. Write a function `reverse_words` which takes a single string as input and reverses the order of the words. The function should utilize an in-place reversal algorithm as much as possible to optimize both time and space efficiency. # Input and Output Format * **Input**: A single string `sentence` containing words separated by spaces. * **Output**: A single string where the words appear in reverse order compared to the input sentence. # Constraints - The input string will only contain lowercase alphabets and spaces. - There will be no leading or trailing spaces, and the words will be separated by a single space. # Example **Input**: ``` \\"I love programming\\" ``` **Output**: ``` \\"programming love I\\" ``` # Performance Requirements - Time Complexity should be O(n), where n is the length of the input string. - Space Complexity should be O(1) additional space, not counting the space for the input and output.","solution":"def reverse_words(sentence): Reverses the order of words in the given sentence. :param sentence: A string containing words separated by spaces :return: A string where the words appear in reverse order # Convert string to a list of characters to manipulate in place sentence_list = list(sentence) n = len(sentence_list) # Helper function to reverse a section of the list in place def reverse_section(start, end): while start < end: sentence_list[start], sentence_list[end] = sentence_list[end], sentence_list[start] start += 1 end -= 1 # First, reverse the entire sentence to handle the word order reverse_section(0, n - 1) # Next, reverse each word in place start = 0 for end in range(n + 1): if end == n or sentence_list[end] == \' \': reverse_section(start, end - 1) start = end + 1 return \'\'.join(sentence_list)"},{"question":"# Pattern Matching Backtracking You need to write a function `pattern_match(pattern, string)` that determines if a given string follows the same pattern as specified. Function Signature ```python def pattern_match(pattern: str, string: str) -> bool: ``` # Input - `pattern`: A string containing only lowercase letters representing the pattern. - `string`: A string containing only lowercase letters which needs to be checked against the pattern. # Output - Returns `True` if the string follows the pattern, `False` otherwise. # Constraints - The pattern string and the input string contain only lowercase English letters. - Both strings have lengths between 1 and 50. # Performance Requirements - Expected to handle average cases efficiently. - Consider optimized backtracking strategies for avoiding redundant calculations. # Example ```python pattern = \\"abab\\" string = \\"redblueredblue\\" pattern_match(pattern, string) # should return True pattern = \\"aaaa\\" string = \\"asdasdasdasd\\" pattern_match(pattern, string) # should return True pattern = \\"aabb\\" string = \\"xyzabcxzyabc\\" pattern_match(pattern, string) # should return False ``` --- Scenario: Imagine that you are developing a template system where users can define small textual templates to match complex email bodies. To encode and match these templates, you need to ensure that each part of the email body follows a predefined pattern. Write your function to validate if a given email text fits the specified pattern template.","solution":"def pattern_match(pattern: str, string: str) -> bool: def backtrack(pattern_idx, str_idx, pattern_map, used_substrings): if pattern_idx == len(pattern) and str_idx == len(string): return True if pattern_idx == len(pattern) or str_idx == len(string): return False pattern_char = pattern[pattern_idx] if pattern_char in pattern_map: substring = pattern_map[pattern_char] if not string.startswith(substring, str_idx): return False return backtrack(pattern_idx + 1, str_idx + len(substring), pattern_map, used_substrings) else: for i in range(str_idx, len(string)): substring = string[str_idx:i + 1] if substring in used_substrings: continue pattern_map[pattern_char] = substring used_substrings.add(substring) if backtrack(pattern_idx + 1, i + 1, pattern_map, used_substrings): return True del pattern_map[pattern_char] used_substrings.remove(substring) return False return backtrack(0, 0, {}, set())"},{"question":"You are tasked with developing a software module for a recommendation system. Part of this system involves calculating the similarity between user preferences represented as high-dimensional vectors. You are to implement a function that calculates the cosine similarity between two vectors, `vec1` and `vec2`. # Function Signature ```python def cosine_similarity(vec1: list[int], vec2: list[int]) -> float: ``` # Input - `vec1`: List of integers representing the first vector. - `vec2`: List of integers representing the second vector. - The vectors are guaranteed to be the same length. # Output - Returns a float value representing the cosine similarity between the two vectors. # Constraints - The maximum length of the vectors: 10^6 - Each vector component\'s absolute value: ≤ 10^3 # Example ```python cosine_similarity([1, 1, 1], [1, 2, -1]) # Output: 0.47140452079103173 ``` # Notes - If both vectors are zero vectors, return a similarity of 1.0 (since they are perfectly aligned conceptually). # Requirements - The implementation should be efficient to handle large vectors up to the maximum constraint. - Properly handle edge cases where vectors contain zero values.","solution":"import math def cosine_similarity(vec1: list[int], vec2: list[int]) -> float: Calculate the cosine similarity between two vectors. Args: vec1 (list[int]): First vector. vec2 (list[int]): Second vector. Returns: float: Cosine similarity between vec1 and vec2. dot_product = sum(a * b for a, b in zip(vec1, vec2)) magnitude_vec1 = math.sqrt(sum(a ** 2 for a in vec1)) magnitude_vec2 = math.sqrt(sum(b ** 2 for b in vec2)) if magnitude_vec1 == 0 and magnitude_vec2 == 0: return 1.0 if magnitude_vec1 == 0 or magnitude_vec2 == 0: return 0.0 return dot_product / (magnitude_vec1 * magnitude_vec2)"},{"question":"# Primality Testing Challenge You are tasked with implementing an enhanced primality test function for a larger-scale cryptographic application. The application requires checking the primality of very large numbers efficiently and with a high degree of certainty. Objective: Write a function `is_probably_prime(n: int, k: int) -> bool` that determines whether an integer ( n ) is probably prime using the Rabin-Miller primality test. Function Signature: ```python def is_probably_prime(n: int, k: int) -> bool: ``` Parameters: - `n` (int): The number to be tested, ( n geq 2 ). - `k` (int): The number of iterations (witnesses) to test, ( k geq 1 ). Returns: - `(bool)`: True if ( n ) is probably prime, False if ( n ) is composite. Constraints: - The function must handle very large integers (up to at least 10^18). - Minimize the probability of error in classification to an acceptable level by appropriately choosing ( k ). Performance Requirements: - The implementation should efficiently handle the probabilistic nature of the algorithm to operate within reasonable time for large ( n ). Notes: - You may assume the random number generator produces a uniform distribution within the specified ranges. - Pay attention to the edge cases where ( n ) is very small or when particular numbers ( n ) have properties that could affect the output. Example Usage: ```python print(is_probably_prime(561, 5)) # False, 561 is a Carmichael number (composite) print(is_probably_prime(17, 4)) # True, 17 is prime print(is_probably_prime(1009, 10)) # True, 1009 is prime ``` Hint: You may refer to the analysis section for understanding the key concepts of Rabin-Miller primality test regarding core operational steps, properties, and common scenarios.","solution":"import random def is_probably_prime(n: int, k: int) -> bool: Perform the Rabin-Miller primality test. Returns True if n is probably prime, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False # Write n as 2^r * d + 1 with d odd r, d = 0, n - 1 while d % 2 == 0: r += 1 d //= 2 # Witness loop for _ in range(k): a = random.randint(2, n - 2) x = pow(a, d, n) if x == 1 or x == n - 1: continue for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: break else: return False return True"},{"question":"# Question: Modified Binary Search in Rotated Sorted Array Scenario You are given an array of integers sorted in ascending order is rotated at some pivot unknown to you beforehand and a target integer to search for in the array. Task Write a function `find_element_in_rotated_array` that takes in: 1. `arr` (List[int]): A list of integers that is sorted in ascending order and then rotated. 2. `target` (int): The target value you are searching for in the array. The function should return the index of `target` if it is found in the array, otherwise, it should return `-1`. Your solution must ensure an algorithm runtime complexity of ( O(log n) ). Function Signature ```python def find_element_in_rotated_array(arr: List[int], target: int) -> int: pass ``` Input * An array `arr` of integers, where ( 1 leq text{len(arr)} leq 10^4 ) and each element is distinct. * An integer `target`. Output * An integer index of the target if found; otherwise, `-1`. Example ```python # Example 1: arr = [4, 5, 6, 7, 0, 1, 2] target = 0 assert find_element_in_rotated_array(arr, target) == 4 # Example 2: arr = [4, 5, 6, 7, 0, 1, 2] target = 3 assert find_element_in_rotated_array(arr, target) == -1 # Example 3: arr = [1] target = 0 assert find_element_in_rotated_array(arr, target) == -1 ``` Constraints * The array must be handled in an efficient manner with a runtime complexity of ( O(log n) ).","solution":"from typing import List def find_element_in_rotated_array(arr: List[int], target: int) -> int: Searches for the target element in a rotated sorted array. Args: arr (List[int]): A list of integers, sorted in ascending order and rotated. target (int): The target value to search for. Returns: int: The index of the target if found, otherwise -1. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid if arr[left] <= arr[mid]: # Left half is sorted if arr[left] <= target < arr[mid]: right = mid - 1 else: left = mid + 1 else: # Right half is sorted if arr[mid] < target <= arr[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"You have been given the dimensions of a sequence of matrices, and your task is to determine the minimum number of scalar multiplications needed to multiply the sequence of matrices together. Also, you need to print the optimal order of multiplication. The matrices will be multiplied in the order they are given, and you need to find the least expensive multiplication order. # Input - An array of integers `array` of length (n) where the (i^{th}) and ((i+1)^{th}) elements together denote the dimensions of the (i^{th}) matrix. # Output - An integer denoting the minimum number of scalar multiplications needed. - The optimal order to multiply these matrices. # Constraints - (2 leq n leq 100) - Elements of `array` are positive integers. # Example ```Python def matrix_chain_order(array): # Your code here def print_optimal_solution(optimal_solution, i, j): # Your code here def main(): array = [30, 35, 15, 5, 10, 20, 25] length = len(array) matrix, optimal_solution = matrix_chain_order(array) print(\\"Minimum number of multiplications required:\\", matrix[1][length - 1]) print(\\"Optimal Parenthesization:\\") print_optimal_solution(optimal_solution, 1, length - 1) main() ``` # Explanation: For the given array `[30, 35, 15, 5, 10, 20, 25]`: - The matrices are: - (A1) of dimension (30 times 35) - (A2) of dimension (35 times 15) - (A3) of dimension (15 times 5) - (A4) of dimension (5 times 10) - (A5) of dimension (10 times 20) - (A6) of dimension (20 times 25) The output should show the minimum scalar multiplications and the optimal parenthesization pattern. # Notes - Do not use any libraries that provide direct solutions. - Ensure your solution handles edge cases effectively. - The main function provided should remain unchanged except for adding additional test cases if needed.","solution":"def matrix_chain_order(array): Function to determine the minimum number of scalar multiplications needed to multiply the sequence of matrices together and to find the optimal order of multiplication. n = len(array) # m[i][j] stores the minimum number of scalar multiplications needed to compute the matrix chain product A[i]...A[j] m = [[0 for _ in range(n)] for _ in range(n)] # s[i][j] is used to store the index of the matrix that achieved the optimal cost when computing the matrix chain product A[i]...A[j] s = [[0 for _ in range(n)] for _ in range(n)] for l in range(2, n): # l is the chain length for i in range(1, n - l + 1): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + array[i - 1] * array[k] * array[j] if q < m[i][j]: m[i][j] = q s[i][j] = k return m, s def print_optimal_solution(s, i, j): Function to print the optimal order of matrix multiplication using the auxiliary table s. if i == j: print(f\\"A{i}\\", end=\\"\\") else: print(\\"(\\", end=\\"\\") print_optimal_solution(s, i, s[i][j]) print_optimal_solution(s, s[i][j] + 1, j) print(\\")\\", end=\\"\\") def main(): array = [30, 35, 15, 5, 10, 20, 25] length = len(array) matrix, optimal_solution = matrix_chain_order(array) print(\\"Minimum number of multiplications required:\\", matrix[1][length - 1]) print(\\"Optimal Parenthesization:\\", end=\\" \\") print_optimal_solution(optimal_solution, 1, length - 1) print() if __name__ == \\"__main__\\": main()"},{"question":"# Problem: Validate Keyboard Row Words Scenario You are designing a typing practice application that validates whether certain words can be typed using letters from only one row on a standard American keyboard. This is to help typists become familiar with keyboard layouts and improve their typing efficiency. Problem Statement Implement a function `validate_keyboard_row_words(words: List[str]) -> List[str]` that, given a list of words, returns the words that can be typed using letters of the alphabet on only one row of an American keyboard. Input Format * A list of strings `words` where each string is a word. Output Format * A list of strings containing the words that can be typed using only one row of the keyboard. Constraints * The words are composed of alphabetic characters only. * Case insensitive: words like \\"Hello\\" and \\"hello\\" should be considered the same in terms of the characters they contain. * The input list can contain up to 10,000 words, with each word up to 100 characters long. Example ```python # Input words = [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] # Output [\\"Alaska\\", \\"Dad\\"] ``` Requirements * Ensure your implementation works efficiently within the provided constraints. * Handle both uppercase and lowercase letters in the input. Additional Edge Cases to Consider: * The case where the input list is empty should return an empty list. * Words that span multiple rows should not be included in the output. * If no words match the criteria, the result should be an empty list.","solution":"from typing import List def validate_keyboard_row_words(words: List[str]) -> List[str]: Returns the words that can be typed using letters of the alphabet on only one row of an American keyboard. rows = [ set(\\"qwertyuiop\\"), set(\\"asdfghjkl\\"), set(\\"zxcvbnm\\") ] def is_one_row(word): lower_word = word.lower() return any(all(ch in row for ch in lower_word) for row in rows) return [word for word in words if is_one_row(word)]"},{"question":"Context You\'re working as a software engineer at a company that processes large data batches using stack-based systems. One of the requirements is to periodically reorder the data in such a way that pairs of elements are switched. Due to constraints on processing time and memory usage, you need an efficient solution. Problem Statement Write a function `switch_pairs` that takes a list representing a stack and switches successive pairs of elements starting from the bottom of the stack. Implement two versions of this function: 1. `switch_pairs_with_stack`: Uses an auxiliary stack for intermediate storage. 2. `switch_pairs_with_queue`: Uses an auxiliary queue for intermediate storage. Function Signatures ```python def switch_pairs_with_stack(stack: list) -> list: # Your implementation goes here pass def switch_pairs_with_queue(stack: list) -> list: # Your implementation goes here pass ``` Input * A single input parameter `stack`, which is a list of integers representing a stack (bottom of the stack is at the beginning of the list). Output * The function should return a list representing the stack after switching successive pairs of elements. Constraints * The size of the stack can range from 0 to 10^6 elements. * You must ensure the solution handles both even and odd numbers of elements correctly. * Minimize additional space usage and optimize for time complexity. Examples **Example 1:** ```python stack = [3, 8, 17, 9, 1, 10] print(switch_pairs_with_stack(stack)) # Output: [8, 3, 9, 17, 10, 1] print(switch_pairs_with_queue(stack)) # Output: [8, 3, 9, 17, 10, 1] ``` **Example 2:** ```python stack = [3, 8, 17, 9, 1] print(switch_pairs_with_stack(stack)) # Output: [8, 3, 9, 17, 1] print(switch_pairs_with_queue(stack)) # Output: [8, 3, 9, 17, 1] ```","solution":"from collections import deque def switch_pairs_with_stack(stack): Switch successive pairs of elements in the stack using an auxiliary stack. aux_stack = [] result_stack = [] # Move elements to auxiliary stack and swap pairs while len(stack) > 1: first = stack.pop(0) second = stack.pop(0) aux_stack.append(second) aux_stack.append(first) if stack: aux_stack.append(stack.pop(0)) # Move elements back to the result stack while aux_stack: result_stack.append(aux_stack.pop(0)) return result_stack def switch_pairs_with_queue(stack): Switch successive pairs of elements in the stack using an auxiliary queue. aux_queue = deque() result_stack = [] # Move elements to auxiliary queue and swap pairs while len(stack) > 1: first = stack.pop(0) second = stack.pop(0) aux_queue.append(second) aux_queue.append(first) if stack: aux_queue.append(stack.pop(0)) # Move elements back to the result stack while aux_queue: result_stack.append(aux_queue.popleft()) return result_stack"},{"question":"# ZigZag Iterator You are required to implement a dynamic ZigZag iterator that will iterate elements from multiple lists in a round-robin fashion. Specifically, your implementation should be able to support `n` lists instead of only 2. # Objective: Implement a `ZigZagIteratorV2` class with the following methods: - `__init__(self, list_of_lists: List[List[int]])`: Initialize the iterator with a variable number of lists. - `next(self) -> int`: Return the next element from the combined lists in a round-robin fashion. - `has_next(self) -> bool`: Return `True` if there is at least one remaining element in any of the lists, otherwise return `False`. # Input: - You will receive a list of lists of integers, e.g., `[[1, 2], [3, 4, 5, 6], [7, 8, 9]]`. # Output: - Your iterator should output integers in a round-robin manner e.g., 1, 3, 7, 2, 4, 8, 5, 9, 6 for the provided list. # Constraints: - Assume that elements within lists are non-negative integers. - The total number of elements (sum of lengths of all lists) will not exceed 10^4. # Example: ```python list_of_lists = [[1, 2], [3, 4, 5, 6], [7, 8, 9]] iterator = ZigZagIteratorV2(list_of_lists) result = [] while iterator.has_next(): result.append(iterator.next()) print(result) # Output: [1, 3, 7, 2, 4, 8, 5, 9, 6] ``` # Implementation: ```python class ZigZagIteratorV2: def __init__(self, list_of_lists): Initialize your data structure here. :type list_of_lists: List[List[int]] self.queue = [l for l in list_of_lists if l] def next(self): :rtype: int if not self.has_next(): raise StopIteration(\\"No more elements\\") lst = self.queue.pop(0) ret = lst.pop(0) if lst: self.queue.append(lst) return ret def has_next(self): :rtype: bool return bool(self.queue) ``` Note: Ensure your implementation handles edge cases such as lists with different lengths and empty lists.","solution":"from collections import deque from typing import List class ZigZagIteratorV2: def __init__(self, list_of_lists: List[List[int]]): Initialize the ZigZagIterator with a list of lists. self.queues = deque([deque(lst) for lst in list_of_lists if lst]) def next(self) -> int: Return the next element from the combined lists in a round-robin fashion. if not self.has_next(): raise StopIteration(\\"No more elements\\") current_queue = self.queues.popleft() next_element = current_queue.popleft() if current_queue: self.queues.append(current_queue) return next_element def has_next(self) -> bool: Return True if there is at least one remaining element in any of the lists, otherwise return False. return bool(self.queues)"},{"question":"# Heap Sort Toggle Implementation **Objective**: Write a function `toggle_heap_sort` that can switch between using a max-heap and min-heap for sorting an array. **Context**: You are given the tasks to sort an array using Heap Sort, and depending on user preference, you need to choose between Max-Heap and Min-Heap strategies. **Function Signature**: ```python def toggle_heap_sort(arr, use_max_heap=True, simulation=False): Sorts an array in ascending order using either max-heap or min-heap. Parameters: - arr (List[int]): The input array to be sorted. - use_max_heap (bool): A flag to toggle between max-heap (True) and min-heap (False). - simulation (bool): A flag to print the array state at key steps. Returns: - List[int]: The sorted array in ascending order. ``` **Input**: * `arr`: A list of integers. * `use_max_heap`: A boolean flag. * If `True`, sort using max-heap. * If `False`, sort using min-heap. * `simulation`: A boolean flag. * If `True`, print the state of the array at key steps. **Output**: A sorted list of integers in ascending order. **Constraints**: * `1 <= len(arr) <= 1000` * `-10^5 <= arr[i] <= 10^5` for `1 <= i <= len(arr)` **Examples**: ```python assert toggle_heap_sort([4, 10, 3, 5, 1], use_max_heap=True) == [1, 3, 4, 5, 10] assert toggle_heap_sort([4, 10, 3, 5, 1], use_max_heap=False) == [1, 3, 4, 5, 10] assert toggle_heap_sort([1], use_max_heap=True) == [1] assert toggle_heap_sort([1], use_max_heap=False) == [1] assert toggle_heap_sort([], use_max_heap=False) == [] ``` **Task**: Implement the `toggle_heap_sort` function based on the provided constraints and examples. Ensure the function correctly toggles between max-heap and min-heap sorting strategies.","solution":"def max_heapify(arr, n, i, simulation): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] > arr[largest]: largest = left if right < n and arr[right] > arr[largest]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] if simulation: print(f\\"Max-heapify: {arr}\\") max_heapify(arr, n, largest, simulation) def min_heapify(arr, n, i, simulation): smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] < arr[smallest]: smallest = left if right < n and arr[right] < arr[smallest]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] if simulation: print(f\\"Min-heapify: {arr}\\") min_heapify(arr, n, smallest, simulation) def heap_sort(arr, use_max_heap, simulation): n = len(arr) for i in range(n // 2 - 1, -1, -1): if use_max_heap: max_heapify(arr, n, i, simulation) else: min_heapify(arr, n, i, simulation) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] if simulation: print(f\\"Swap: {arr}\\") if use_max_heap: max_heapify(arr, i, 0, simulation) else: min_heapify(arr, i, 0, simulation) if not use_max_heap: arr.reverse() def toggle_heap_sort(arr, use_max_heap=True, simulation=False): Sorts an array in ascending order using either max-heap or min-heap. Parameters: - arr (List[int]): The input array to be sorted. - use_max_heap (bool): A flag to toggle between max-heap (True) and min-heap (False). - simulation (bool): A flag to print the array state at key steps. Returns: - List[int]: The sorted array in ascending order. arr_copy = arr[:] heap_sort(arr_copy, use_max_heap, simulation) return arr_copy"},{"question":"Write a function, `optimized_comb_sort`, that sorts an array of integers using an optimized version of the Comb Sort algorithm. The optimization should involve using a different shrink factor and handling small arrays more efficiently. # Input: - An array of integers `arr` of length `n`. # Output: - The function should return the sorted array. # Constraints: - `1 ≤ n ≤ 10^5` - `-10^9 ≤ arr[i] ≤ 10^9` for `0 ≤ i < n` # Requirements: 1. Implement the optimized Comb Sort algorithm with a shrink factor that you find effective based on your experiments. 2. For arrays with length ≤ 10, use insertion sort instead of comb sort. 3. Ensure the function operates efficiently within the given constraints. # Example: ```python >> optimized_comb_sort([5, 3, 8, 4, 2]) => [2, 3, 4, 5, 8] >> optimized_comb_sort([1]) => [1] ``` **Hint**: Improving the shrink factor and incorporating insertion sort for small arrays can significantly enhance performance.","solution":"def insertion_sort(arr): A utility function to perform insertion sort on the input array. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def optimized_comb_sort(arr): Sorts an array of integers using an optimized version of the Comb Sort algorithm. For small arrays, it uses insertion sort instead. n = len(arr) if n <= 10: insertion_sort(arr) return arr # Comb sort implementation with optimized shrink factor shrink_factor = 1.3 gap = n sorted_flag = False while not sorted_flag: gap = int(gap / shrink_factor) if gap <= 1: gap = 1 sorted_flag = True for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted_flag = False return arr"},{"question":"# Topological Sort Implementation **Context**: You are the lead developer of a project management tool that helps in visualizing project tasks and their dependencies. To determine the order of execution for the tasks, you need to perform a topological sort on the given set of tasks and their dependencies. **Problem Statement**: You are given a directed acyclic graph (DAG) representing project tasks and their dependencies. Implement a Python function to perform a topological sort on the given graph. **Function Signature**: ```python def topological_sort(graph: Dict[int, List[int]]) -> List[int]: pass ``` **Input**: * `graph`: A dictionary where each key represents a task, and the corresponding value is a list of tasks that must be completed before the key task. The graph is guaranteed to be a DAG. **Output**: * A list of integers representing the tasks in a topologically sorted order. **Constraints**: 1. The graph will not have cycles. 2. The graph may be disconnected. 3. The number of tasks (vertices) will be at most 1000. **Example**: ```python graph = { 5: [2, 0], 4: [0, 1], 2: [3], 3: [1], 1: [], 0: [] } print(topological_sort(graph)) # Output could be [5, 4, 2, 3, 1, 0] or any other valid topological order ``` **Explanation**: * In the given example, the graph represents dependencies between tasks: * Task 5 depends on tasks 2 and 0. * Task 4 depends on tasks 0 and 1. * Task 2 depends on task 3. * Task 3 depends on task 1. * Tasks 1 and 0 have no dependencies. * A valid topological sort orders the tasks such that each task comes after its dependencies. **Implementation Details**: * You can utilize either a recursive DFS-based approach or an iterative approach for topological sorting. * Ensure that your implementation efficiently handles the input size constraints.","solution":"def topological_sort(graph): Perform a topological sort on a given directed acyclic graph (DAG). Parameters: graph (dict): A dictionary where each key represents a task, and the value is a list of tasks that must be completed before the key task. Returns: List[int]: A list of tasks in a topologically sorted order. def dfs(node): nonlocal is_possible if not is_possible: return # mark the current node as being processed visited[node] = 1 if node in graph: for neighbor in graph[node]: if visited[neighbor] == 0: dfs(neighbor) elif visited[neighbor] == 1: is_possible = False return # mark the current node as processed visited[node] = 2 top_order.append(node) visited = {node: 0 for node in graph} # 0 = unvisited, 1 = visiting, 2 = visited top_order = [] is_possible = True for node in graph: if visited[node] == 0: dfs(node) return top_order[::-1] if is_possible else []"},{"question":"Determine if a Graph is Bipartite You are given an undirected graph represented by an adjacency matrix. Your task is to write a function that determines whether the given graph is bipartite or not. A graph is bipartite if the set of vertices can be divided into two disjoint and independent sets U and V such that every edge connects a vertex in U to a vertex in V. Function Signature ```python def is_bipartite_graph(adj_matrix: List[List[int]]) -> bool: pass ``` # Input * `adj_matrix`: A list of lists where `adj_matrix[i][j] = 1` indicates an edge between vertex `i` and vertex `j`, and `adj_matrix[i][j] = 0` indicates no edge. # Output * Return `True` if the graph is bipartite, otherwise return `False`. # Constraints * The number of vertices `n` in the graph is such that (0 leq n leq 100). * The adjacency matrix `adj_matrix` is a square matrix of size `n x n`. * The values in `adj_matrix` are either `0` or `1`. # Examples ```python # Example 1 adj_matrix = [ [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0] ] print(is_bipartite_graph(adj_matrix)) # Should print: True # Example 2 adj_matrix = [ [0, 1, 1], [1, 0, 1], [1, 1, 0] ] print(is_bipartite_graph(adj_matrix)) # Should print: False # Example 3 adj_matrix = [ [0] ] print(is_bipartite_graph(adj_matrix)) # Should print: True ``` # Explanation * Example 1: The graph can be divided into two sets {0, 2} and {1, 3} where all edges are between these sets. * Example 2: The graph cannot be divided into two such sets as it contains a cycle of odd length, which implies non-bipartiteness. * Example 3: A single node with no edges is trivially bipartite.","solution":"from typing import List from collections import deque def is_bipartite_graph(adj_matrix: List[List[int]]) -> bool: n = len(adj_matrix) if n == 0: return True colors = [-1] * n for start in range(n): if colors[start] == -1: queue = deque([start]) colors[start] = 0 while queue: node = queue.popleft() for neighbor in range(n): if adj_matrix[node][neighbor] == 1: if colors[neighbor] == -1: # Color with opposite color colors[neighbor] = 1 - colors[node] queue.append(neighbor) elif colors[neighbor] == colors[node]: # If the neighbor has the same color, the graph is not bipartite return False return True"},{"question":"Scenario: You are developing a text search function for an editor application. This function should be able to efficiently find the first occurrence of a target substring within a larger text body. For simplicity, this function will only find the first exact occurrence. Task: Write a Python function `find_substring_position(haystack: str, needle: str) -> int` that implements the search functionality. Your function should return the index of the first occurrence of `needle` in `haystack` or -1 if `needle` is not part of `haystack`. Specifications: 1. The function name should be `find_substring_position`. 2. The function should take two parameters - `haystack` (the text to search within) and `needle` (the substring to search for), both of which are strings. 3. The function should return an integer representing the index of the first occurrence of `needle` in `haystack` or -1 if `needle` is not part of `haystack`. 4. If `needle` is an empty string, the function should return 0. 5. You can assume all inputs will be non-null strings. Performance Requirement: - Aim for an optimal solution with minimum time complexity. Constraints: - The length of haystack and needle will not exceed 10^4 characters. **Examples:** 1. `find_substring_position(\\"hello\\", \\"ll\\")` should return `2`. 2. `find_substring_position(\\"aaaaa\\", \\"bba\\")` should return `-1`. 3. `find_substring_position(\\"\\", \\"\\")` should return `0`. 4. `find_substring_position(\\"abc\\", \\"\\")` should return `0`. 5. `find_substring_position(\\"abc\\", \\"d\\")` should return `-1`. Good luck, and pay attention to edge cases for thorough testing!","solution":"def find_substring_position(haystack: str, needle: str) -> int: Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Returns 0 if needle is an empty string. if needle == \\"\\": return 0 return haystack.find(needle)"},{"question":"# Scenario: You are working on a system where bit-level manipulation is crucial for performance and memory optimization. The system requires precise control over the bit patterns to handle tasks such as encoding and flagging certain features within an integer efficiently. # Task: Write a function `insert_one_bit(num, bit, i)` and `insert_mult_bits(num, bits, length, i)` that inserts bits into the given integer `num` at a specific position `i`. # Function Specification: Function: `insert_one_bit` **Parameters**: - `num` (int): The original number. - `bit` (int): The bit to insert (either 0 or 1). - `position` (int): The zero-indexed position where the bit would be inserted. **Returns**: - (int): The number after the bit has been inserted. **Constraints**: - The value of `bit` will always be 0 or 1. - Position `i` will be a valid insertion index based on the length of the binary representation of `num`. Function: `insert_mult_bits` **Parameters**: - `num` (int): The original number. - `bits` (int): The bits to be inserted (represented as an integer). - `length` (int): Length of bits to be inserted. - `position` (int): The zero-indexed position where the bits would be inserted. **Returns**: - (int): The number after the bits have been inserted. **Constraints**: - The `bits` value must fit within the given length. - Position `i` must be a valid position within the binary representation of `num`. Examples: For `insert_one_bit(num, bit, i)`: 1. `insert_one_bit(21, 1, 2)` returns `45` (binary: 10101 becomes 101101). 2. `insert_one_bit(21, 0, 2)` returns `41` (binary: 10101 becomes 101001). 3. `insert_one_bit(21, 1, 5)` returns `53` (binary: 10101 becomes 110101). For `insert_mult_bits(num, bits, length, i)`: 1. `insert_mult_bits(5, 7, 3, 1)` returns `47` (binary: 101 becomes 101111). 2. `insert_mult_bits(5, 7, 3, 0)` returns `47` (binary: 101 becomes 101111). 3. `insert_mult_bits(5, 7, 3, 3)` returns `61` (binary: 101 becomes 111101). You are required to handle all edge cases and ensure your solution is efficient and scalable. **Hint**: Utilize bitwise operations to efficiently manipulate the bits without looping over each bit individually.","solution":"def insert_one_bit(num, bit, position): Inserts a single bit at the specified position in the binary representation of num. Parameters: num (int): The original number. bit (int): The bit to insert (either 0 or 1). position (int): The zero-indexed position where the bit would be inserted. Returns: int: The number after the bit has been inserted. if bit not in (0, 1): raise ValueError(\\"Bit must be either 0 or 1\\") # Left half of the number (shift to the right of the insertion position) left_part = num >> position # Right half of the number (portion that remains as is) right_part = num & ((1 << position) - 1) # Merge everything together return (left_part << (position + 1)) | (bit << position) | right_part def insert_mult_bits(num, bits, length, position): Inserts multiple bits into the given integer num at a specific position. Parameters: num (int): The original number. bits (int): The bits to be inserted (represented as an integer). length (int): Length of bits to be inserted. position (int): The zero-indexed position where the bits would be inserted. Returns: int: The number after the bits have been inserted. if bits >= (1 << length): raise ValueError(\\"Bits value exceeds the specified length\\") # Left half of the number (shift to the right of the insertion position) left_part = num >> position # Right half of the number (portion that remains as is) right_part = num & ((1 << position) - 1) # Merge everything together return (left_part << (position + length)) | (bits << position) | right_part"},{"question":"Scenario You are working on optimizing a database that frequently requires repeated sorting operations on large sets of data entries. Due to the nature of the hardware, reducing the number of write operations can significantly enhance performance and longevity. The cycle sort algorithm, known for its minimal write operations, seems ideal for this task despite its higher time complexity for large datasets. Task Implement a function `cycle_sort` that sorts a given list of integers using the cycle sort algorithm. Specifications * **Function Name**: `cycle_sort` * **Input**: A list of integers `arr` * Constraints: 1 ≤ len(arr) ≤ 10^5, -10^6 ≤ arr[i] ≤ 10^6. * **Output**: The sorted list of integers in non-decreasing order. * **Performance Requirements**: The function should perform in O(N^2) time complexity in the worst case and use O(1) additional space. * **Edge Cases**: * All elements are identical. * The input list is already sorted. * The list is empty or has one element. Example ```python # Example 1 input_arr = [3, 1, 2] output_arr = [1, 2, 3] # Example 2 input_arr = [5, 5, 5] output_arr = [5, 5, 5] # Example 3 input_arr = [1, 2, 3] output_arr = [1, 2, 3] ``` You are expected to write the function `cycle_sort` such that it meets the criteria outlined above. Use no additional libraries or modules beyond Python\'s standard functions. ```python def cycle_sort(arr): # Your implementation here pass # Testing the function print(cycle_sort([3, 1, 2])) # Expected: [1, 2, 3] print(cycle_sort([5, 5, 5])) # Expected: [5, 5, 5] ```","solution":"def cycle_sort(arr): Sorts a list using cycle sort algorithm with minimal write operations. n = len(arr) # Traverse the array to find cycles to rotate. for cycle_start in range(n - 1): item = arr[cycle_start] # Find where to place the item. pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position, continue. if pos == cycle_start: continue # Otherwise, put the item there or right after any duplicates. while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] # Rotate the rest of the cycle. while pos != cycle_start: pos = cycle_start # Find where to put the element. for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # Put the element to its correct position or right after any duplicates. while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"# Shell Sort Optimization Description Shell Sort is an in-place comparison-based sorting algorithm. However, its efficiency largely depends on the choice of the gap sequence. The provided implementation uses a simple gap sequence, which may not be optimal. Your task is to improve the performance of the Shell Sort algorithm by implementing it using Ciura\'s gap sequence. Ciura\'s Gap Sequence The sequence starts with [1, 4, 10, 23, 57, 132, 301, 701, 1750]. For arrays larger than 1750 elements, you should continue the sequence by multiplying the last gap by 2.25 and taking the floor value until it exceeds the array size. Task Write a function named `optimized_shell_sort` that sorts an array of integers using Shell Sort with Ciura\'s gap sequence. Implementation Details * **Function Signature**: `def optimized_shell_sort(arr: List[int]) -> List[int]:` * **Input**: A list of integers `arr` where 1 <= len(arr) <= 10^6. * **Output**: A list of integers sorted in non-decreasing order. Constraints * The integers in the list can be both positive and negative. * You must use Ciura\'s gap sequence. Example 1. **Input**: `[8, 5, 7, 3, 2]` **Output**: `[2, 3, 5, 7, 8]` 2. **Input**: `[22, 11, 99, 88, 9]` **Output**: `[9, 11, 22, 88, 99]` Additional Information Make sure your code runs efficiently within the given constraints. It\'s important to handle edge cases such as empty lists and lists with a single element.","solution":"from typing import List def optimized_shell_sort(arr: List[int]) -> List[int]: Sorts an array of integers using Shell Sort with Ciura\'s gap sequence. if not arr: return arr n = len(arr) ciura_gaps = [1, 4, 10, 23, 57, 132, 301, 701, 1750] # Extend Ciura\'s gap sequence if necessary while ciura_gaps[-1] < n: ciura_gaps.append(int(ciura_gaps[-1] * 2.25)) for gap in reversed(ciura_gaps): for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Context: You\'ve been hired as a software engineering intern for a small tech company. Your first task is to enhance the efficiency of their current sorting algorithm for better performance. The current system uses Bubble Sort, which is known for its simplicity but lacks performance. # Problem Statement: Implement a modified version of the Bubble Sort algorithm called `optimized_bubble_sort` that incorporates the following optimizations: 1. Stop the algorithm if no elements were swapped during a full pass through the list. 2. In addition to sorting the array in ascending order, the function must be able to sort in descending order as well. # Function Signature: ```python def optimized_bubble_sort(arr, order=\\"ascending\\", simulation=False): ``` # Input: 1. `arr`: List of integers that need to be sorted. 2. `order` (optional): A string that can either be \\"ascending\\" (default) or \\"descending\\" indicating the desired order of sorting. 3. `simulation` (optional): A boolean value (default is `False`). If `True`, print the array\'s state after each iteration (similar to the provided bubble_sort function). # Output: * Return the sorted list in the specified order. # Constraints: * You may assume that all elements in the list are integers. * The array length will be at most 10,000 elements. * Minimize the number of swaps and passes through the list wherever possible. # Example: ```python print(optimized_bubble_sort([64, 34, 25, 12, 22, 11, 90])) # Output: [11, 12, 22, 25, 34, 64, 90] print(optimized_bubble_sort([64, 34, 25, 12, 22, 11, 90], order=\\"descending\\")) # Output: [90, 64, 34, 25, 22, 12, 11] print(optimized_bubble_sort([3, 1, 2], simulation=True)) # Expected Output on Console: # iteration 0 : 3 1 2 # iteration 1 : 1 3 2 # iteration 2 : 1 2 3 # Output: [1, 2, 3] ``` # Notes: - Ensure your function is efficiently optimized for minimal passes. - Consider any additional edge cases and handle them appropriately.","solution":"def optimized_bubble_sort(arr, order=\\"ascending\\", simulation=False): Sorts an array in ascending or descending order using the optimized version of bubble sort. Parameters: arr (list): List of integers that need to be sorted. order (str): Sorting order, either \\"ascending\\" (default) or \\"descending\\". simulation (bool): If True, print the array\'s state after each iteration (default is False). Returns: list: Sorted list in the specified order. n = len(arr) ascending = order == \\"ascending\\" for i in range(n): swapped = False for j in range(0, n-i-1): if (ascending and arr[j] > arr[j+1]) or (not ascending and arr[j] < arr[j+1]): arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if simulation: print(f\\"iteration {i} :\\", \\" \\".join(map(str, arr))) if not swapped: break return arr"},{"question":"**Scenario**: You are a software engineer tasked with implementing a part of a library for a software that interacts with binary search trees (BST). Your function will find the in-order successor of a given node in the BST. # Problem Statement Given a binary search tree (BST) and a node, implement a function `successor(root: Optional[TreeNode], node: Optional[TreeNode]) -> Optional[TreeNode]` that finds the in-order successor of the given node. The in-order successor of a node in a BST is the node with the smallest key that is larger than the given node\'s key. # Input * `root` - The root node of the BST. (Type: TreeNode | None) * `node` - The node whose in-order successor needs to be found. (Type: TreeNode | None) # Output * Returns the in-order successor node if it exists, otherwise returns `None`. # Constraints - The number of nodes in the tree is in the range [1, 10^4]. - -10^5 <= Node.val <= 10^5 - All the values in the BST are unique. # Function Signature ```python def successor(root: Optional[TreeNode], node: Optional[TreeNode]) -> Optional[TreeNode]: # Your code here ``` # Example ```python # Example structure of TreeNode class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None # Example Usage root = TreeNode(20) root.left = TreeNode(10) root.right = TreeNode(30) root.left.left = TreeNode(5) root.left.right = TreeNode(15) node = root.left # node with value 10 # Finding in-order successor of node with value 10 successor_node = successor(root, node) print(successor_node.val) # Output should be 15, as it is the in-order successor of 10 ``` # Explanation In the example provided, the BST is: ``` 20 / 10 30 / 5 15 ``` The in-order successor of the node with value 10 is the node with value 15. # Points to Consider 1. Handle edge cases such as when the BST is empty or the node itself does not exist. 2. Ensure that the function correctly handles unbalanced BSTs. 3. Analyze the performance for very large trees and aim for optimal efficiency in both time and space.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def successor(root, node): Finds the in-order successor of a given node in a BST. :param root: The root of the BST :param node: The node whose in-order successor is to be found :return: The in-order successor node if it exists, otherwise None if not node: return None # If the node has a right child, the successor is the leftmost child of the right subtree successor = None if node.right: successor = node.right while successor.left: successor = successor.left return successor # Otherwise, traverse the tree from root to find the successor current = root while current: if node.val < current.val: successor = current current = current.left elif node.val > current.val: current = current.right else: break return successor"},{"question":"**Scenario**: You have designed a system that processes sales records stored in a singly linked list. Each node in the list holds a sales figure. Before processing these records, you need to ensure that the records are sorted in non-decreasing order (from smallest to largest). # Task: Implement a function `check_sorted_sales(head)` that determines whether a given singly linked list of sales figures is sorted in non-decreasing order. If the list is sorted, the function should return `True`. If not, the function should return `False`. # Input: * `head`: The head node of a singly linked list where each node contains an integer value representing a sales figure. # Output: * Return `True` if the linked list is sorted in non-decreasing order, `False` otherwise. **Function Signature**: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def check_sorted_sales(head: ListNode) -> bool: # Your implementation here pass ``` # Constraints: 1. The linked list may contain any number of elements, including zero. 2. Elements in the linked list may be repetitive. # Examples: 1. For a linked list represented as `1 -> 2 -> 3 -> 4`, the function should return `True`. 2. For a linked list represented as `1 -> 2 -> -1 -> 3`, the function should return `False`. 3. For an empty linked list, the function should return `True`. 4. For a linked list represented as `5 -> 5 -> 5`, the function should return `True`. Note: * You do not need to handle malformed input such as cyclic lists. * Assume the ListNode class is defined and provided as shown in the function signature.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def check_sorted_sales(head: ListNode) -> bool: if not head: return True current = head while current.next: if current.val > current.next.val: return False current = current.next return True"},{"question":"# Graph Traversal with Constraints You are given a large-scale social network represented as a graph. Each node is a user, and each edge represents a connection (friendship) between two users. Your task is to write a function that uses both DFS and BFS to return specific results based on traversal constraints. **Problem Statement:** Implement two functions, `constrained_dfs(graph, start, constraint)` and `constrained_bfs(graph, start, constraint)`, which will traverse the graph starting from the `start` node. The traversal should only consider nodes that satisfy a given `constraint`. # Function Signature ```python def constrained_dfs(graph: dict, start: int, constraint: callable) -> set: pass def constrained_bfs(graph: dict, start: int, constraint: callable) -> set: pass ``` # Input * `graph`: A dictionary where keys are node identifiers and values are lists of neighboring node identifiers. * `start`: The starting node identifier for the traversal. * `constraint`: A callable that takes a node identifier as an argument and returns `True` if the node satisfies the condition, `False` otherwise. # Output * Both functions should return a set containing all nodes that were visited and satisfied the constraint. # Constraints * The graph can have up to 10^5 nodes and 2*10^5 edges. * Node identifiers are assumed to be integers. * The constraint function can vary and may involve complex checks, so ensure that the traversal respects the given constraint efficiently. # Example **Input:** ```python graph = { 1: [2, 3], 2: [4, 5], 3: [6], 4: [7], 5: [], 6: [], 7: [] } def constraint(node): return node % 2 == 0 # Example constraint allowing only even nodes. print(constrained_dfs(graph, 1, constraint)) # Expected Output: {2, 4, 6} print(constrained_bfs(graph, 1, constraint)) # Expected Output: {2, 4, 6} ``` **Explanation:** In the provided graph, starting from node 1, only nodes satisfying the constraint (being even) are considered in the traversal.","solution":"def constrained_dfs(graph, start, constraint): visited = set() result = set() def dfs(node): if node in visited: return visited.add(node) if constraint(node): result.add(node) for neighbor in graph.get(node, []): dfs(neighbor) dfs(start) return result def constrained_bfs(graph, start, constraint): visited = set() result = set() queue = [start] while queue: node = queue.pop(0) if node in visited: continue visited.add(node) if constraint(node): result.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: queue.append(neighbor) return result"},{"question":"You are tasked with implementing a function that performs matrix chain multiplication using dynamic programming. The goal is to determine the minimum number of scalar multiplications needed to multiply a given chain of matrices. # Function Signature: ```python def matrix_chain_order(p: List[int]) -> Tuple[int, List[List[int]]]: Find the minimum cost of multiplying the given chain of matrices. Args: p -- A list where the ith matrix has dimensions p[i-1] x p[i]. Returns: A tuple containing: - The minimum cost of multiplying the given chain of matrices. - A 2D list representing the optimal split points. ``` # Input: - `p` (List[int]): A list of integers where the `i-th` matrix has dimensions `p[i-1] x p[i]`. # Output: - Returns a tuple: - The first element is an integer representing the minimum cost of scalar multiplications. - The second element is a 2D list containing the optimal split points. # Constraints: - `2 <= len(p) <= 100` (p represents dimensions for at least one matrix) - `1 <= p[i] <= 500` # Example: ```python p = [30, 35, 15, 5, 10, 20, 25] result = matrix_chain_order(p) # Expected Output: (15125, [[0, 0, 0, 0, 0, 0, 0], [0, 0, 15750, 7875, 9375, 11875, 15125], # [0, 0, 0, 2625, 4375, 7125, 10500], # [0, 0, 0, 0, 750, 2500, 5375], # [0, 0, 0, 0, 0, 1000, 3500], # [0, 0, 0, 0, 0, 0, 5000], # [0, 0, 0, 0, 0, 0, 0]]) ``` # Explanation: - The minimum number of scalar multiplications needed to multiply the chain of matrices is 15125. - The 2D list (second part of the tuple) contains the optimum costs for multiplying matrices for all subproblems. # Notes: - Implement a helper function `print_optimal_solution(sol, i, j)` to print the optimal order of operations if needed.","solution":"from typing import List, Tuple def matrix_chain_order(p: List[int]) -> Tuple[int, List[List[int]]]: n = len(p) - 1 m = [[0] * (n + 1) for _ in range(n + 1)] s = [[0] * (n + 1) for _ in range(n + 1)] for l in range(2, n + 1): # l is chain length for i in range(1, n - l + 2): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j] if q < m[i][j]: m[i][j] = q s[i][j] = k return m[1][n], s"},{"question":"# Radix Sort Implementation and Stress Test Objective: Write a function to implement radix sort and apply it to sort a list of non-negative integers. Additionally, enhance the algorithm to handle a large dataset efficiently and ensure it performs within acceptable limits. Function Signature: ```python def radix_sort(arr: List[int], simulation: bool=False) -> List[int]: pass ``` Inputs: * `arr`: A list of non-negative integers (0 <= arr[i] <= 10^9). * `simulation`: A boolean indicating if the function should print each iteration result for debugging (default is False). Output: * Returns a new list containing the sorted integers. Constraints: * Use radix sort specifically. * Handle up to 10^6 integers efficiently. * Simulation mode should work effectively for small datasets. Scenario: Your company needs to implement an efficient sorting mechanism for its large dataset of customer order IDs, which are unique non-negative integers. Additionally, during the development phase, the ability to simulate and visualize each sorting iteration is crucial for debugging and validation purposes. Specifications: * Implement the radix sort function described and ensure it meets the required performance. * Ensure stability and correctness of the sort. * Provide performance analysis by testing your solution with a dataset of 10^6 random integers to validate its efficiency. Example: ```python # Input arr = [170, 45, 75, 90, 802, 24, 2, 66] # Expected output sorted_arr = [2, 24, 45, 66, 75, 90, 170, 802] enhanced_sorted_arr = radix_sort(arr) assert enhanced_sorted_arr == sorted_arr ``` Submit your solution with documentation explaining your approach, handling of edge cases, and performance analysis on large datasets.","solution":"from typing import List def counting_sort(arr: List[int], exp: int, simulation: bool) -> List[int]: n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = arr[i] // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] for i in range(n-1, -1, -1): index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 for i in range(n): arr[i] = output[i] if simulation: print(f\\"After sorting on exp {exp}: {arr}\\") return arr def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: if len(arr) == 0: return arr max1 = max(arr) exp = 1 while max1 // exp > 0: arr = counting_sort(arr, exp, simulation) exp *= 10 return arr"},{"question":"# Question Statement: You are assigned to implement the Atbash cipher, a classical encryption method that maps each letter in the alphabet to its reverse. Given an input string, your task is to return the encrypted version of the string using the Atbash cipher. # Function Signature: ```python def atbash_cipher(text: str) -> str: ``` # Input: * `text`: A string `text` (0 ≤ len(text) ≤ 10^6) consisting of printable ASCII characters. # Output: * Return a string representing the encrypted version of the input string using the Atbash cipher. # Constraints: * The Atbash cipher transforms \'A\' to \'Z\', \'B\' to \'Y\', ... , \'Z\' to \'A\' for uppercase letters. * It transforms \'a\' to \'z\', \'b\' to \'y\', ... , \'z\' to \'a\' for lowercase letters. * Non-alphabetic characters (spaces, punctuation, digits, etc.) should remain unchanged. * The function should be optimized to handle strings of up to 1 million characters efficiently. # Examples: ```python assert atbash_cipher(\\"Attack at dawn\\") == \\"Zggzxp zg wzdm\\" assert atbash_cipher(\\"Hello World!\\") == \\"Svool Dliow!\\" assert atbash_cipher(\\"123 ABC xyz\\") == \\"123 ZYX cba\\" assert atbash_cipher(\\"\\") == \\"\\" ``` # Scenario/Context: Beth is working on encrypting secret messages for a historical reenactment. The reenactments require the use of ancient ciphers, like the Atbash cipher, to encode transcripts. For a practice exercise, Beth\'s task is to implement the Atbash cipher for various historical texts provided by her professor. # Performance Requirements: * The solution should process the input string in linear time relative to its length. * Efficient string handling is critical for large inputs up to 1 million characters.","solution":"def atbash_cipher(text: str) -> str: def translate(ch): if \'A\' <= ch <= \'Z\': return chr(ord(\'Z\') - (ord(ch) - ord(\'A\'))) elif \'a\' <= ch <= \'z\': return chr(ord(\'z\') - (ord(ch) - ord(\'a\'))) else: return ch return \'\'.join(translate(ch) for ch in text)"},{"question":"Problem Statement Implement an enhanced bucket sort that optimizes performance for various data distributions. Instead of using fixed bucket sizes, dynamically size each bucket to balance the load more effectively. Use merge sort within each bucket for improved efficiency. # Function Signature ```python def advanced_bucket_sort(arr: List[float]) -> List[float]: ``` # Input - `arr`: A list of floating point numbers where `0 <= arr[i] <= 1` representing the range of input. # Output - A list of sorted floating point numbers in ascending order. # Constraints - The input list can be empty which should return an empty list. - The values in the array are uniformly distributed between 0 and 1. # Example ```python assert advanced_bucket_sort([0.78, 0.32, 0.54, 0.01, 0.95, 0.12]) == [0.01, 0.12, 0.32, 0.54, 0.78, 0.95] ``` # Guidelines 1. Dynamically size the buckets based on input range. 2. Use merge sort within each bucket for sorting. 3. Handle edge cases by ensuring the function works for empty arrays and properly sized buckets. 4. Ensure the function has a time complexity better than O(n^2) for most cases. # Additional Notes - **Performance Requirements**: Aim for an average-case time complexity close to O(n log n). - **Edge Case Scenarios**: Include unit tests covering empty lists, single-element lists, and lists with uniformly distributed values.","solution":"from typing import List def merge_sort(arr: List[float]) -> List[float]: if len(arr) > 1: mid = len(arr) // 2 L = arr[:mid] R = arr[mid:] merge_sort(L) merge_sort(R) i = j = k = 0 while i < len(L) and j < len(R): if L[i] < R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 while i < len(L): arr[k] = L[i] i += 1 k += 1 while j < len(R): arr[k] = R[j] j += 1 k += 1 return arr def advanced_bucket_sort(arr: List[float]) -> List[float]: if not arr: return [] n = len(arr) buckets = [[] for _ in range(n)] for num in arr: index = int(num * n) if index == n: index = n - 1 buckets[index].append(num) sorted_arr = [] for bucket in buckets: if bucket: sorted_arr.extend(merge_sort(bucket)) return sorted_arr"},{"question":"# Scenario An online platform requires users to create strong passwords that meet certain criteria for security purposes. A password is considered strong if it has a length of at least 6 characters and includes at least one digit, one lowercase letter, one uppercase letter, and one special character from the set `!@#%^&*()-+`. # Task Write a function `strong_password(n: int, password: str) -> int` that takes in two parameters: 1. `n`: an integer representing the length of the password. 2. `password`: a string representing the typed password. The function should return the minimum number of characters needed to be added to the password to make it strong. # Input Format - An integer `n`, representing the length of the password (1 <= n <= 100). - A string `password`, the password typed by the user, consisting of characters which could be a lowercase/uppercase English alphabet, a digit, or a special character. # Constraints - The length of the password will be at most 100 characters. - The password may contain any combination of lowercase letters, uppercase letters, digits, and special characters `!@#%^&*()-+`. # Output Format Return an integer representing the minimum number of characters that need to be added to the password to make it strong. # Sample Input ```plaintext strong_password(3, \\"Ab1\\") ``` # Sample Output ```plaintext 3 ``` *Explanation*: The current password length is 3. It contains an uppercase letter \'A\', a lowercase letter \'b\', and a digit \'1\'. It needs to add at least three characters to meet the length requirement and include at least one special character. Example additions could be `hk`, making it a strong password `Ab1hk`. ```plaintext strong_password(11, \\"#Algorithms\\") ``` # Sample Output ```plaintext 1 ``` *Explanation*: The current password length is 11. It includes a special character `#`, lowercase letters, and uppercase letters. It only needs one digit to be considered strong. Adding a digit \'5\' satisfies the requirement. # Implementation ```python def strong_password(n, password): count_error = 0 # Check for digit if not any(char.isdigit() for char in password): count_error += 1 # Check for lowercase letter if not any(char.islower() for char in password): count_error += 1 # Check for uppercase letter if not any(char.isupper() for char in password): count_error += 1 # Check for special character if not any(char in \\"!@#%^&*()-+\\" for char in password): count_error += 1 # Ensure minimum length of 6 characters additional_chars_needed = max(count_error, 6 - n) return additional_chars_needed ``` Test your function with various inputs to ensure all edge cases are handled.","solution":"def strong_password(n, password): count_error = 0 # Check for digit if not any(char.isdigit() for char in password): count_error += 1 # Check for lowercase letter if not any(char.islower() for char in password): count_error += 1 # Check for uppercase letter if not any(char.isupper() for char in password): count_error += 1 # Check for special character if not any(char in \\"!@#%^&*()-+\\" for char in password): count_error += 1 # Ensure minimum length of 6 characters additional_chars_needed = max(count_error, 6 - n) return additional_chars_needed"},{"question":"Implement an Enhanced Cycle Sort **Context**: Cycle Sort is an intriguing sorting algorithm known for its minimal number of write operations. Your task is to implement a variation of Cycle Sort that effectively handles elements in non-distinct arrays (arrays with duplicates) and ensures that the algorithm avoids unnecessary writes when the array consists of elements in a cycle already. **Task**: Write a function `enhanced_cycle_sort(arr)` that sorts an array of integers using a modified version of the Cycle Sort algorithm. This enhanced version should: 1. Handle arrays with duplicate elements correctly. 2. Avoid unnecessary writes by checking if the element is already in its correct position. **Function Signature**: ```python def enhanced_cycle_sort(arr: List[int]) -> List[int]: pass ``` **Input**: * `arr` (List[int]): An unsorted list of integers that may contain duplicates. **Output**: * Returns a sorted list of integers. **Constraints**: * The function should work for arrays of size up to 10^4. * Values within the array are within the range of -10^6 to 10^6. **Performance Requirements**: * Aim for write operations to be minimal. **Example**: ```python arr = [4, 3, 2, 1, 4] sorted_arr = enhanced_cycle_sort(arr) print(sorted_arr) # Output: [1, 2, 3, 4, 4] ``` **Notes**: * Ensure to handle edge cases such as an array with all identical elements, an already sorted array, and an array sorted in descending order. * Provide clear comments and documentation to support your implementation logic.","solution":"def enhanced_cycle_sort(arr): Sorts a list of integers using the Cycle Sort algorithm, enhanced to handle duplicates and minimize unnecessary writes. n = len(arr) writes = 0 # Traverse the array to find cycles to rotate. for cycle_start in range(n - 1): item = arr[cycle_start] # Find the position where we put the item. pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position, skip it. if pos == cycle_start: continue # Ignore all duplicate elements. while pos < n and arr[pos] == item: pos += 1 # Put the item at the right position. if pos < n and arr[pos] != item: arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle. while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # Ignore all duplicate elements. while pos < n and arr[pos] == item: pos += 1 # Put the item at the right position. if pos < n and arr[pos] != item: arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"# Question: Implement a Robust URL Domain Extractor Context As part of a web scraping application, you need to normalize and categorize URLs by their domain names. This requires extracting the domain names from various patterns of URLs. Your task is to implement a function that will correctly parse and return the domain name from a given URL. Problem Statement Write a function `extract_domain_name(url: str) -> str` that takes a URL string as input and returns the domain name extracted from it. Input * A single string `url`: Contains a valid URL, which could start with protocols like `http://`, `https://`, may have `www.`, and should end up without exceptions. Output * A single string representing the domain name extracted from the URL. Constraints * Do not use libraries such as `re` (regular expressions) or `urllib` to parse the URL. * The function should handle URLs with and without `www`. * The function should handle standard protocol prefixes (`http`, `https`). * Assume the input URL will always be correctly formed. Examples ```python assert extract_domain_name(\\"http://github.com/SaadBenn\\") == \\"github\\" assert extract_domain_name(\\"http://www.zombie-bites.com\\") == \\"zombie-bites\\" assert extract_domain_name(\\"https://www.cnet.com\\") == \\"cnet\\" assert extract_domain_name(\\"http://google.co.uk\\") == \\"google\\" assert extract_domain_name(\\"https://mail.example.com\\") == \\"example\\" ``` Notes * Pay special attention to edge cases like subdomains and keep the function optimized for performance. * Ensure your code is clean and well-documented, explaining your thought process and choices.","solution":"def extract_domain_name(url: str) -> str: Extracts the domain name from a given URL. # Remove protocol (http, https) if present if url.startswith(\\"http://\\"): url = url[len(\\"http://\\"):] elif url.startswith(\\"https://\\"): url = url[len(\\"https://\\"):] # Remove \'www.\' if present if url.startswith(\\"www.\\"): url = url[len(\\"www.\\"):] # Extract domain name domain_parts = url.split(\'.\') domain_name = domain_parts[0] # Check if there is any subdomain if len(domain_parts) > 2 and domain_parts[1] not in [\'com\', \'co\', \'org\', \'net\']: domain_name = domain_parts[1] return domain_name"},{"question":"You have been provided with the structure for a Binary Tree Node and both iterative and recursive methods for Inorder traversal of the binary tree. Understanding and being able to manipulate tree traversal algorithms is important for solving a variety of computational problems, especially those related to hierarchical data. Given the Node class and the provided implementations of `inorder` and `inorder_rec`, implement a new function `inorder_with_sum` that performs the inorder traversal of the tree and also returns the sum of all node values. Your function should handle both iterative and recursive approaches to traverse the tree, calculate the sum, and return both the list of node values in inorder traversal and the sum of the values. # Function Signature ```python def inorder_with_sum(root): Perform inorder traversal of a binary tree and return the traversal list and sum of node values. Parameters: root (Node): The root node of the binary tree. Returns: tuple: A tuple containing the inorder traversal list of node values and the sum of the node values. ``` # Input and Output * **Input Format**: * A binary tree represented by its root node. * **Output Format**: * A tuple containing: 1. A list of node values in inorder traversal. 2. The sum of all node values. # Constraints * Node values can be any integer (positive or negative). * The number of nodes in the binary tree will be at most 1000. # Example ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right if __name__ == \'__main__\': n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert inorder_with_sum(n1) == ([25, 50, 75, 100, 125, 150, 175], 700) ``` In this example, the tree is a binary search tree, and the inorder traversal should return the nodes in ascending order. The sum, in this case, is the addition of all node values.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def inorder_with_sum(root): def inorder_recursive(node): if node is None: return [], 0 left_values, left_sum = inorder_recursive(node.left) right_values, right_sum = inorder_recursive(node.right) return left_values + [node.val] + right_values, left_sum + node.val + right_sum return inorder_recursive(root) # Iterative approach is also implemented for the complete solution def inorder_with_sum_iterative(root): if root is None: return [], 0 stack, result, total_sum = [], [], 0 current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) total_sum += current.val current = current.right return result, total_sum"},{"question":"# Problem: Implement and Verify a Binary Search Tree with Additional Functionality You are tasked to implement a Binary Search Tree (BST) that supports the following functionality: 1. Insertion of values. 2. Searching for values. 3. Calculating the size of the tree. 4. Performing preorder, inorder, and postorder tree traversals. In addition to this, you need to implement two new functions: 1. **Deletion** of a node with a specified value from the tree. 2. **Height Calculation** to determine the height of the tree. # Function Definitions: Implement the following functions within the `BST` class: 1. **delete(value: int) -> bool** - Deletes a node with the specified value from the tree. - Returns `True` if the deletion was successful, `False` if the value was not found. 2. **height() -> int** - Returns the height of the tree (defined as the number of edges on the longest path from the root to a leaf). # Input: - For `delete(value)`: An integer value that needs to be deleted. - For `height()`: No input required. # Output: - For `delete(value)`: Boolean indicating success or failure of deletion. - For `height()`: Integer indicating the height of the tree. # Constraints: - All node values are unique. - The BST should handle typical edge cases effectively (e.g., deleting from an empty tree, deleting leaf nodes, deleting nodes with only one child, deleting nodes with two children). # Example: ```python tree = BST() tree.insert(10) tree.insert(5) tree.insert(15) tree.insert(3) tree.insert(7) assert tree.search(7) == True assert tree.search(20) == False assert tree.size() == 5 assert tree.delete(7) == True assert tree.delete(7) == False assert tree.height() == 2 # Preorder Traversal: [10, 5, 3, 15] # Inorder Traversal: [3, 5, 10, 15] # Postorder Traversal: [3, 5, 15, 10] print(\\"All tests passed.\\") ``` # Note: - You are required to add appropriate unit tests to verify the correct implementation of `delete` and `height` functions, similar to those provided for `insert`, `search`, and `size` earlier.","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = Node(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.left = Node(value) else: self._insert(node.left, value) else: if node.right is None: node.right = Node(value) else: self._insert(node.right, value) def search(self, value): return self._search(self.root, value) def _search(self, node, value): if node is None: return False if node.value == value: return True elif value < node.value: return self._search(node.left, value) else: return self._search(node.right, value) def size(self): return self._size(self.root) def _size(self, node): if node is None: return 0 return 1 + self._size(node.left) + self._size(node.right) def delete(self, value): self.root, deleted = self._delete(self.root, value) return deleted def _delete(self, node, value): if node is None: return node, False if value < node.value: node.left, deleted = self._delete(node.left, value) elif value > node.value: node.right, deleted = self._delete(node.right, value) else: if node.left is None: return node.right, True elif node.right is None: return node.left, True temp = self._find_min(node.right) node.value = temp.value node.right, _ = self._delete(node.right, temp.value) return node, True return node, deleted def _find_min(self, node): current = node while current.left is not None: current = current.left return current def height(self): return self._height(self.root) def _height(self, node): if node is None: return -1 left_height = self._height(node.left) right_height = self._height(node.right) return 1 + max(left_height, right_height) def preorder_traversal(self): result = [] self._preorder_traversal(self.root, result) return result def _preorder_traversal(self, node, result): if node is None: return result.append(node.value) self._preorder_traversal(node.left, result) self._preorder_traversal(node.right, result) def inorder_traversal(self): result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, node, result): if node is None: return self._inorder_traversal(node.left, result) result.append(node.value) self._inorder_traversal(node.right, result) def postorder_traversal(self): result = [] self._postorder_traversal(self.root, result) return result def _postorder_traversal(self, node, result): if node is None: return self._postorder_traversal(node.left, result) self._postorder_traversal(node.right, result) result.append(node.value)"},{"question":"# Advanced Fenwick Tree Application Scenario You are developing a competitive gaming statistics application. The application records the number of games won by each player every day. You\'re tasked with efficiently maintaining the win counts and processing queries on them. Task Implement a class `GameStats` using a Fenwick Tree (Binary Indexed Tree) to manage the following functionalities efficiently: 1. **Initial Record Construction**: Initialize the win records for players on the first day. 2. **Daily Wins Update**: Update the win count for any player on a given day. 3. **Total Wins Query**: Calculate the total number of wins for the top `k` players. Function Signatures * `__init__(self, wins: List[int]) -> None`: Initializes the class with the initial win records of `n` players. * `update_win(self, player_index: int, wins: int) -> None`: Updates the win count for the player at index `player_index` by adding `wins`. * `total_wins(self, top_k: int) -> int`: Computes the total number of wins for the top `k` players (1-based index). Constraints * `1 <= n <= 10^5` (number of players) * `0 <= wins <= 100` (win count per update) * `0 <= player_index < n` * `1 <= top_k <= n` * Updates and queries can happen multiple times, and you need to ensure the operations are efficient. Example ```python # Initial win records wins = [3, 0, 2, 7, 0, 5, 1] gs = GameStats(wins) gs.update_win(3, 3) # Player at index 3 now has 10 wins total_wins_top_3 = gs.total_wins(3) # Total wins for top 3 players (indices 0, 2, and 3) print(total_wins_top_3) # Output should be 15 (3 + 2 + 10) ``` Constraints to Note * The input and outputs are integers. * Handle scenarios where updates or queries are at the maximum array length efficiently without exceeding time limits.","solution":"class FenwickTree: def __init__(self, n): self.size = n self.tree = [0] * (n + 1) def update(self, i, delta): while i <= self.size: self.tree[i] += delta i += i & -i def sum(self, i): total = 0 while i > 0: total += self.tree[i] i -= i & -i return total def range_sum(self, left, right): return self.sum(right) - self.sum(left - 1) class GameStats: def __init__(self, wins): self.wins = [0] + wins # Fenwick Tree is 1-indexed self.size = len(wins) self.tree = FenwickTree(self.size) for i in range(1, self.size + 1): self.tree.update(i, self.wins[i]) def update_win(self, player_index, wins): delta = wins self.wins[player_index + 1] += delta self.tree.update(player_index + 1, delta) def total_wins(self, top_k): return self.tree.range_sum(1, top_k)"},{"question":"Implement a resizable hash table that includes an optimization method for better hash collision handling and resizing strategy. Requirements: 1. **Class**: `OptimizedHashTable` 2. **Methods**: - **put(key, value)**: Inserts the key-value pair into the hash table. If the key already exists, update its value. - **get(key)**: Fetches the value associated with the key. Returns `None` if the key does not exist. - **del(key)**: Deletes the key-value pair if the key exists. - **resize()**: Doubles the hash table size if filled >= 2/3, considering quadratic probing as the rehashing technique. - **length()**: Returns the number of key-value pairs in the hash table. 3. **Hashing Mechanism**: - Use quadratic probing for collision resolution. 4. **Constraints**: - The initial size of the hash table is 8. - Keys are non-negative integers. Input/Output Examples: - **Example 1**: ```python table = OptimizedHashTable() table.put(1, \'A\') table.put(2, \'B\') assert table.get(1) == \'A\' table.del(1) assert table.get(1) == None assert table.length() == 1 ``` - **Example 2**: ```python table = OptimizedHashTable() for i in range(6): table.put(i, i) assert table.length() == 6 table.put(8, \'new_value\') # Should trigger resizing assert table.length() == 7 ``` Notes: - Do not use any external libraries except for basic data structures provided by the language. - Ensure that the hash table handles collisions efficiently with the constraint of quadratic probing. - Test edge cases including inserting, fetching, and deleting with boundary conditions and very few elements. # Coding Task: Implement the `OptimizedHashTable` class with the specified methods, ensuring the performance remains optimal with quadratic probing and efficient resizing.","solution":"class OptimizedHashTable: def __init__(self): self.size = 8 # initial capacity self.count = 0 self.table = [None] * self.size def put(self, key, value): if self.count >= 2 * self.size // 3: self.resize() index = self.hash(key) orig_index = index i = 1 while self.table[index] is not None and self.table[index][0] != key: index = (orig_index + i * i) % self.size i += 1 if self.table[index] is None: self.count += 1 self.table[index] = (key, value) def get(self, key): index = self.hash(key) orig_index = index i = 1 while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] index = (orig_index + i * i) % self.size i += 1 return None def del_key(self, key): index = self.hash(key) orig_index = index i = 1 while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = None self.count -= 1 return index = (orig_index + i * i) % self.size i += 1 def resize(self): old_table = self.table self.size *= 2 self.table = [None] * self.size self.count = 0 for entry in old_table: if entry is not None: self.put(entry[0], entry[1]) def length(self): return self.count def hash(self, key): return key % self.size"},{"question":"# Matrix Chain Multiplication Optimal Order Context: In many applications involving linear algebra, such as graphics processing, scientific computing, and database systems, optimizing the multiplication order of matrices is crucial to reduce computational expense. Matrix Chain Multiplication is a problem that tackles this by determining the most efficient way to multiply a given sequence of matrices. Problem Statement: You are given an array of dimensions representing a sequence of matrices such that the ith matrix has dimensions `p[i-1] x p[i]`. Your task is to write a function that computes the minimum cost (in terms of scalar multiplications) to multiply the entire sequence and also the optimal order of multiplications. Function Signature: ```python def matrix_chain_order(arr: List[int]) -> Tuple[int, List[List[int]]]: pass ``` Input: - `arr`: A list of `n` integers where the length of the array is `n`. Output: - Returns a tuple containing: 1. An integer representing the minimum number of scalar multiplications needed. 2. A 2D list showing the optimal order of matrix multiplications. Example: ```python array = [30, 35, 15, 5, 10, 20, 25] result = matrix_chain_order(array) print(result) # Output: (15125, [[0, 0, 0, 0, 0, 0, 0], [0, 0, 15750, 7875, 9375, 11875, 15125], ...]) ``` The output should explain that 15125 scalar multiplications are required to multiply the sequence, and the 2D list should show the cost matrix. Constraints: - `2 <= len(arr) <= 100` - `1 <= p[i] <= 500` Additional Notes: - Implement a helper function to reconstruct and print the optimal multiplication order from the `sol` matrix. Testing and Edge Cases: - Test with the smallest possible input `(ex: [10, 20])`. - Test with large inputs to handle performance scaling.","solution":"from typing import List, Tuple def matrix_chain_order(arr: List[int]) -> Tuple[int, List[List[int]]]: n = len(arr) - 1 m = [[0 for _ in range(n)] for _ in range(n)] s = [[0 for _ in range(n)] for _ in range(n)] for L in range(2, n + 1): for i in range(n - L + 1): j = i + L - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + arr[i] * arr[k + 1] * arr[j + 1] if q < m[i][j]: m[i][j] = q s[i][j] = k return m[0][n-1], s def reconstruct_optimal_order(s: List[List[int]], i: int, j: int) -> str: if i == j: return f\\"A{i+1}\\" else: k = s[i][j] left_order = reconstruct_optimal_order(s, i, k) right_order = reconstruct_optimal_order(s, k + 1, j) return f\\"({left_order} x {right_order})\\""},{"question":"# Question: Implement Bucket Sort with Improved Secondary Sorting Context You are working as a software engineer at a company that deals with large datasets. The datasets contain numerical information which needs to be sorted efficiently. Bucket Sort is one of the algorithms you consider due to its efficiency with uniformly distributed data. However, you recognize that the secondary sorting algorithm used can significantly impact performance. Task Implement the `bucket_sort` function using Merge Sort instead of Insertion Sort for sorting the elements within each bucket. Merge Sort has a better worst-case time complexity of O(n log n), which should improve the performance of the overall algorithm. Function Signature ```python def bucket_sort(arr: List[int]) -> List[int]: pass ``` Input - `arr` (List[int]): List of integers to be sorted. Output - Returns a sorted list of integers. Constraints - 1 <= len(arr) <= 10^5 - 0 <= arr[i] <= 10^6 for all 0 <= i < len(arr) Performance Requirements - The optimized bucket sort should handle the upper constraint efficiently. Example ```python >>> bucket_sort([29, 25, 3, 49, 9, 37, 21, 43]) [3, 9, 21, 25, 29, 37, 43, 49] ``` Note - Ensure the implementation sorts the elements within each bucket using Merge Sort. - Consider edge cases such as an empty array or array with identical elements.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left: List[int], right: List[int]) -> List[int]: result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result def bucket_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return [] # Find the maximum value in the array to determine the range of values max_value = max(arr) bucket_count = len(arr) buckets = [[] for _ in range(bucket_count)] # Distribute the elements into buckets for num in arr: index = num * bucket_count // (max_value + 1) buckets[index].append(num) # Sort each bucket using merge sort for i in range(bucket_count): buckets[i] = merge_sort(buckets[i]) # Concatenate all sorted buckets sorted_array = [] for bucket in buckets: sorted_array.extend(bucket) return sorted_array"},{"question":"# Question: Efficient Alternative to Bogo Sort The Bogo Sort algorithm is an intentionally inefficient sorting algorithm that shuffles the array until it is sorted. Your task is to implement an efficient sorting algorithm, Quick Sort, to sort an array of integers efficiently. Quick Sort Algorithm Brief: 1. Choose a pivot element from the array. 2. Partition the array into two halves: - Elements less than the pivot. - Elements greater than or equal to the pivot. 3. Recursively apply the above steps to the sub-arrays. Requirements: 1. Implement `quick_sort` function which takes an array of integers as input and returns the sorted array. 2. The function should follow the Quick Sort algorithm. # Function Signature ```python def quick_sort(arr: list[int]) -> list[int]: pass ``` # Input - `arr`: A list of integers `arr[0], arr[1], ..., arr[n-1]` (0 ≤ n ≤ 1000). # Output - A new list of integers sorted in ascending order. # Constraints - The array can contain duplicate integers. - Performance expectations require your solution to run efficiently even with the maximum input size. # Example ```python # Input arr = [3, 6, 8, 10, 1, 2, 1] # Output [1, 1, 2, 3, 6, 8, 10] ``` # Edge Cases - An empty array should return an empty array. - An array with a single element should return the same array. Good luck and ensure your solution is efficient for larger arrays!","solution":"def quick_sort(arr: list[int]) -> list[int]: Sorts an array using the Quick Sort algorithm. if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] # Choosing the middle element as the pivot left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"# Radix Sort Implementation Challenge You are implementing a sorting algorithm for an online gaming platform that needs to sort user scores efficiently. The scores are always non-negative integers and can range up to millions. Your task is to implement the Radix Sort algorithm to sort a list of these scores. Function Signature ```python def radix_sort(arr): # Your implementation here ``` Input - `arr` : A list of non-negative integers representing user scores. (0 ≤ arr[i] ≤ 10^6, 1 ≤ len(arr) ≤ 10^5) Output - The function should return a sorted list of integers. Constraints - You can assume the maximum integer in the list is 10^6. - Optimize for both time and space efficiency. - You should not use Python\'s built-in sorting functions. # Example ```python input_list = [170, 45, 75, 90, 802, 24, 2, 66] sorted_list = radix_sort(input_list) print(sorted_list) # Output: [2, 24, 45, 66, 75, 90, 170, 802] ``` # Notes - Handle any potential edge cases such as empty inputs, single element inputs, and inputs with all identical elements. - Ensure your implementation adheres to the constraints provided, focusing on both time and space efficiency. # Explanation Your solution should sequentially process each digit from the least significant to the most significant, using an auxiliary array to sort based on the current digit\'s values and incrementally refining the order of the list.","solution":"def radix_sort(arr): Perform radix sort on the given list of non-negative integers. if len(arr) == 0: return arr # Find the maximum number to determine the number of digits max_num = max(arr) # Function to do counting sort based on the digit represented by exp def counting_sort_based_on_digit(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 # Store count of occurrences of each digit for i in range(n): index = arr[i] // exp count[index % 10] += 1 # Change count[i] so that count[i] contains the actual position # of the digit in the output array for i in range(1, 10): count[i] += count[i-1] # Build the output array for i in range(n-1, -1, -1): index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 # Copy the output array to arr, so that arr now contains # sorted numbers according to the current digit for i in range(n): arr[i] = output[i] # Do counting sort for every digit exp = 1 # Initialize to 1 for the least significant digit while max_num // exp > 0: counting_sort_based_on_digit(arr, exp) exp *= 10 return arr"},{"question":"# Set Cover Problem with Constraints Consider the set cover problem depicted in the provided snippets. Your task is to extend the greedy algorithm such that it can handle cases where each set can only be chosen a fixed number of times (bounded). Problem Given: * A universe `U` of elements. * A collection of subsets `S` of `U`, where each subset `Si ∈ S` contains a certain number of elements from `U`. * A dictionary `costs` representing the cost of each subset. * A dictionary `limits` that specifies the maximum number of times each subset can be chosen. Write a function `bounded_greedy_set_cover` that finds a subcollection of `S` with the minimum cost that covers all elements of `U`. Each subset can be chosen at most the number of times specified in `limits`. Input * `universe`: A set of elements. * `subsets`: A dictionary where keys are subset names and values are sets e.g., `{S1: {1, 2}, S2: {2, 3, 4}}`. * `costs`: A dictionary where keys are subset names and values are the cost of the subset e.g., `{S1: 5, S2: 10}`. * `limits`: A dictionary where keys are subset names and values are the maximum number of times each subset can be chosen e.g., `{S1: 1, S2: 2}`. Output * A list representing the chosen subsets. Constraints 1. Each subset can be chosen at most the number of times specified in the `limits` dictionary. 2. If it is not possible to cover the universe, return `None`. Example ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} limits = {\'S1\': 1, \'S2\': 1, \'S3\': 1} # Expected Output: # => [\'S2\', \'S3\'] ``` Function Signature ```python def bounded_greedy_set_cover(universe, subsets, costs, limits): pass ```","solution":"def bounded_greedy_set_cover(universe, subsets, costs, limits): Find a subcollection of subsets with the minimum cost that covers all elements of the universe. Each subset can be chosen at most the number of times specified in limits. Args: - universe: set, the universal set of elements. - subsets: dict, keys are subset names and values are sets of elements. - costs: dict, keys are subset names and values are the cost of the subset. - limits: dict, keys are subset names and values are the maximum number of times each subset can be chosen. Returns: - list, the names of chosen subsets. If it is not possible to cover the universe, return None. # Initialize the result and coverage result = [] covered = set() # Create a copy of the limits to track remaining limits remaining_limits = limits.copy() while covered != universe: # Find the subset that provides the best cost-effectiveness best_subset = None best_cost_effectiveness = float(\'inf\') for subset in subsets: if remaining_limits[subset] > 0: additional_coverage = len(subsets[subset] - covered) if additional_coverage > 0: cost_effectiveness = costs[subset] / additional_coverage if cost_effectiveness < best_cost_effectiveness: best_cost_effectiveness = cost_effectiveness best_subset = subset if best_subset is None: return None # Not possible to cover the universe with the given constraints # Add the best subset to the result result.append(best_subset) covered.update(subsets[best_subset]) remaining_limits[best_subset] -= 1 return result"},{"question":"# Shell Sort Implementation Challenge Consider the sorting algorithm Shell Sort, which is an optimization over insertion sort. Shell sort uses a concept of \\"gaps\\" to compare elements far apart and gradually reduces the gap size until it uses insertion sort for a final pass. Objective: Write a function `optimize_shell_sort` that sorts an array of integers using Shell sort. However, to improve the efficiency of the implementation, use a more sophisticated gap sequence known as the **Sedgewick sequence**. The Sedgewick sequence is defined by: ``` h(k) = 1, 5, 19, 41, 109, ... k_2 = 9 * 4^k - 9 * 2^k + 1 k_3 = 4^k - 3 * 2^k + 1 ``` Where `k_2` and `k_3` should produce all unique values in the sequence in ascending order. Function Signature: ```python def optimize_shell_sort(arr: List[int]) -> List[int]: # Your code here ``` # Input: - `arr`: A list of integers that need to be sorted (1 <= len(arr) <= 10^6, -10^9 <= arr[i] <= 10^9) # Output: - Return the sorted list in non-decreasing order. # Constraints: - Optimize for best possible average-case performance using Sedgewick\'s gap sequence for the Shell sort algorithm. - Your implementation should handle up to 1 million elements efficiently. # Example: ```python arr = [23, 12, 4, 56, 78, 1, -1] print(optimize_shell_sort(arr)) # Output: [-1, 1, 4, 12, 23, 56, 78] ``` You are required to handle edge cases and ensure your solution is optimized for large datasets using the more efficient gap sequence discussed.","solution":"from typing import List def optimize_shell_sort(arr: List[int]) -> List[int]: Sorts an array using Shell Sort with the Sedgewick gap sequence. def generate_sedgewick_gaps(n): gaps = [] k = 0 while True: gap2 = 9 * 4**k - 9 * 2**k + 1 gap3 = 4**k - 3 * 2**k + 1 if gap2 < n and gap2 not in gaps: gaps.append(gap2) if gap3 < n and gap3 not in gaps and gap3 > 0: gaps.append(gap3) if gap2 >= n and gap3 >= n: break k += 1 gaps.sort(reverse=True) return gaps n = len(arr) if n <= 1: return arr gaps = generate_sedgewick_gaps(n) for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"Coding Task: Enhanced RSA Key Generation with Optimized Primality Test # Objective Implement an optimized RSA key generation function with improved primality testing using the Miller-Rabin algorithm. # Scenario The current `generate_key` function can be time-consuming due to inefficient primality testing. To enhance the efficiency of the RSA key generation process, implement a function using the Miller-Rabin primality test. # Task Modify the `generate_key` function to: 1. Use the Miller-Rabin algorithm for primality testing. 2. Ensure the function remains efficient and reliable for generating large prime numbers. # Function Signature ```python def generate_key(k, seed=None): ... ``` # Input and Output * **Input**: 1. `k` (int): Number of bits in `n`, the RSA modulus. 2. `seed` (optional, int): Seed for random number generation (for reproducibility). * **Output**: * Returns a tuple `(n, e, d)`: - `n` (int): RSA modulus. - `e` (int): Public exponent. - `d` (int): Private exponent. # Constraints * `k` is an integer greater than or equal to 16. * Prime numbers generated should adhere to standard security requirements. * Ensure the chosen public exponent `e` is a commonly used value (e.g., `65537`). # Performance Requirements * The function should efficiently handle key sizes up to `2048` bits. * Primality test should be reliable to prevent weaknesses. # Example ```python n, e, d = generate_key(16, seed=42) data = 20 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data ``` # Implementation Notes 1. Implement a helper function for the Miller-Rabin primality test. 2. Use optimized libraries if necessary (e.g., using Python’s `random` for reproducibility).","solution":"import random def is_prime(n, k=40): Return True if n is a probable prime using the Miller-Rabin test. if n in (2, 3): return True if n % 2 == 0 or n == 1: return False # Write (n - 1) as 2^r * d r, d = 0, n - 1 while d % 2 == 0: r += 1 d //= 2 for _ in range(k): a = random.randint(2, n - 2) x = pow(a, d, n) if x == 1 or x == n - 1: continue for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: break else: return False return True def generate_prime_candidate(length): Generate an odd integer randomly p = random.getrandbits(length) p |= (1 << length - 1) | 1 # Ensure p is of the right length and odd return p def generate_prime_number(length): Return a prime number candidate of the specified length p = 4 while not is_prime(p, 40): p = generate_prime_candidate(length) return p def gcd(a, b): while b != 0: a, b = b, a % b return a def modinv(a, m): Return the modular inverse of a modulo m m0, x0, x1 = m, 0, 1 if m == 1: return 0 while a > 1: q = a // m m, a = a % m, m x0, x1 = x1 - q * x0, x0 return x1 + m0 if x1 < 0 else x1 def generate_key(k, seed=None): Generate RSA keys of bit length k if seed is not None: random.seed(seed) e = 65537 while True: p = generate_prime_number(k // 2) q = generate_prime_number(k // 2) n = p * q if len(bin(n)) - 2 == k: # Check bit length of n break phi = (p - 1) * (q - 1) if gcd(e, phi) != 1: return generate_key(k, seed) # Ensure gcd(e, phi) = 1 d = modinv(e, phi) return (n, e, d)"},{"question":"**Context/Scenario**: You are working on a feature for a game where players\' scores are frequently updated and stored on a stack. To maintain fairness, you need to occasionally remove the player with the lowest score from the stack. However, you must ensure the order of the remaining scores remains unchanged. **Task**: Write a function `remove_min(stack: List[int]) -> List[int]` that removes the smallest value from the given stack while preserving the order of the other elements. **Function Signature**: ```python from typing import List def remove_min(stack: List[int]) -> List[int]: pass ``` **Input/Output Example**: ```python stack = [2, 8, 3, -6, 7, 3] remove_min(stack) # Expected output: [2, 8, 3, 7, 3] stack = [7, 7, 7, 7] remove_min(stack) # Expected output: [7, 7, 7] stack = [10, 20, 30, -10, 40, -10] remove_min(stack) # Expected output: [10, 20, 30, 40, -10] ``` **Constraints**: * The stack will contain from 1 to 10^5 elements. * Each element in the stack will be an integer within the range -10^9 to 10^9. **Requirements**: * Preserve the order of the remaining elements. * Minimize the use of additional memory if possible. * The function should handle empty stack inputs by returning an empty stack. Good luck!","solution":"from typing import List def remove_min(stack: List[int]) -> List[int]: if not stack: return stack # Find the minimum value in the stack min_value = min(stack) # Remove the first occurrence of the minimum value stack.remove(min_value) return stack"},{"question":"Objective Write a Python function that computes the sum of all values in a binary tree. Each path from the root to a leaf node should be interpreted as a number formed by concatenating node values along the path. Function Definition ```python def sum_tree_paths(root: TreeNode) -> int: Calculate the sum of all numbers formed by root-to-leaf paths in the tree. Args: root (TreeNode): The root of the binary tree. Returns: int: The sum of all numbers formed by root-to-leaf paths. pass ``` Input - `root`: A TreeNode object representing the root of a binary tree. Each node contains an integer value. Output - An integer representing the sum of all numbers formed by root-to-leaf paths. Constraints - The tree will have at most 1000 nodes. - Each node value is a single digit (0-9). Example Consider the binary tree: ``` 1 / 2 3 ``` - The paths are \\"12\\" and \\"13\\". - The sum is 12 + 13 = 25. - Hence, `sum_tree_paths(root)` should return 25. Another binary tree: ``` 4 / 9 0 / 5 1 ``` - The paths are \\"495\\", \\"491\\", and \\"40\\". - The sum is 495 + 491 + 40 = 1026. - Hence, `sum_tree_paths(root)` should return 1026. Explanation - Each path from root to leaf forms a number. - Convert each path to its numerical form and sum all such numbers. - Implement it using DFS approach to traverse all paths from root to leaf.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_tree_paths(root: TreeNode) -> int: def dfs(node, current_number): if not node: return 0 current_number = current_number * 10 + node.val if not node.left and not node.right: return current_number left_sum = dfs(node.left, current_number) right_sum = dfs(node.right, current_number) return left_sum + right_sum return dfs(root, 0)"},{"question":"Context You are given a large text document, and you need to find all occurrences of certain phrases within this document. The Knuth-Morris-Pratt (KMP) algorithm is a powerful and efficient tool for this task due to its linear time complexity. Problem Statement Implement the Knuth-Morris-Pratt (KMP) string matching algorithm that finds all start indexes of a pattern string within a text string. Task Write a function `find_pattern_occurrences` that uses the KMP algorithm to find all start indices in the text where the pattern occurs. Function Signature ```python def find_pattern_occurrences(text: str, pattern: str) -> List[int]: pass ``` Input - `text` (str): The text string in which to search for the pattern. - `pattern` (str): The pattern string to search for in the text. Output - List[int]: A list of starting indices where the pattern is found in the text. Constraints - The input strings can contain any printable ASCII characters. - 1 <= len(text), len(pattern) <= 10^5 - The text length will be at least as long as the pattern length. Example ```python find_pattern_occurrences(\'hello there hero!\', \'he\') # Output: [0, 7, 12] ``` Notes - Ensure the implementation handles edge cases such as empty text or patterns appropriately. - Aim for an optimized solution with a linear time complexity of O(N + M).","solution":"from typing import List def find_pattern_occurrences(text: str, pattern: str) -> List[int]: Uses the Knuth-Morris-Pratt (KMP) algorithm to find all start indices in the text where the pattern occurs. def build_lps(pattern: str) -> List[int]: lps = [0] * len(pattern) j = 0 for i in range(1, len(pattern)): if pattern[i] == pattern[j]: j += 1 lps[i] = j else: if j != 0: j = lps[j-1] i -= 1 # Decrement i to check this character again after updating j else: lps[i] = 0 return lps if not text or not pattern or len(pattern) > len(text): return [] lps = build_lps(pattern) result = [] i, j = 0, 0 while i < len(text): if text[i] == pattern[j]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] else: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"# Anagram Checker for Mixed Case and Special Characters Context You work as a software engineer, and your team is developing a text analysis tool. One of the functionalities needed is to check if two texts are anagrams, considering mixed case and non-alphabetic characters without differentiating between upper and lower case. Objective Write a function `is_strong_anagram(s: str, t: str) -> bool` that determines if the string `t` is an anagram of the string `s`. The function: 1. Ignores casing (i.e., \'A\' and \'a\' are considered the same). 2. Ignores non-alphabetic characters (i.e., \'a!b@c#\' should be considered as \'abc\'). Input - `s`: a string containing alphanumeric and special characters, with mixed case. - `t`: a string containing alphanumeric and special characters, with mixed case. Output - Returns `True` if `t` is an anagram of `s`, and `False` otherwise. Constraints - Consider only the English alphabet for the anagram check. - Both strings `s` and `t` will have lengths of at most 1000 characters. Example ```python print(is_strong_anagram(\\"anagram!\\", \\"marga@na\\")) # Output: True print(is_strong_anagram(\\"rat!\\", \\"car@\\")) # Output: False ``` Additional Performance Requirements - The solution should run efficiently within the given constraints. Implement the function as specified above.","solution":"def is_strong_anagram(s: str, t: str) -> bool: Determines if t is an anagram of s considering only alphabetic characters and ignoring case. Args: s (str): The first string. t (str): The second string. Returns: bool: Whether t is an anagram of s. def clean_string(string: str) -> str: # Remove non-alphabetic characters and convert to lowercase return \'\'.join(char.lower() for char in string if char.isalpha()) s_cleaned = clean_string(s) t_cleaned = clean_string(t) return sorted(s_cleaned) == sorted(t_cleaned)"},{"question":"# Gnome Sort Implementation and Analysis You have been tasked to implement the Gnome Sort algorithm to sort an array of integers. Gnome Sort is an in-place and stable sorting algorithm with a time complexity that can vary from linear to quadratic depending upon the initial arrangement of the elements. Function Signature ```python def gnome_sort(arr): # Your code here ``` Expected Input and Output Formats - **Input**: A list of integers, `arr`. - Constraints: - The length of `arr` is between 0 and 10^5. - The integer values in `arr` are within -10^9 and 10^9. - **Output**: A sorted list of integers in non-decreasing order. Requirements - The function must sort the array in-place, meaning you should not use extra space proportional to the size of the input. - Handle edge cases appropriately, such as empty arrays or arrays with all identical elements. Example ```python gnome_sort([34, 2, 78, 23]) # Output: [2, 23, 34, 78] gnome_sort([10, 20, 5, 15, 25, 30]) # Output: [5, 10, 15, 20, 25, 30] gnome_sort([5, -1, -10, 56, 23, 3]) # Output: [-10, -1, 3, 5, 23, 56] ``` **Performance Requirements**: - Your implementation should aim to minimize the number of comparisons and swaps. - The function should perform optimally within given constraints for different types and sizes of input arrays. **Brief Scenario**: Imagine you are tasked with designing a module for an educational tool that demonstrates the workings of various sorting algorithms. As part of this module, you are required to implement the Gnome Sort algorithm. Your implementation should handle various edge cases efficiently and perform competitively against other sorting algorithms for demonstration purposes.","solution":"def gnome_sort(arr): Sorts the list arr in-place using the Gnome Sort algorithm. index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"As a software engineer at a data processing firm, you\'re tasked with implementing an optimized sorting solution to sort customer IDs. Every customer ID is a unique integer; however, these IDs can sometimes be quite large and may include negative numbers. Your job is to implement a version of Counting Sort that can handle integer ranges that include negative numbers and optimize for memory usage and performance. # Function Description Implement the function `efficient_counting_sort(arr: List[int]) -> List[int]` that sorts an array of integers, including the possibility of negative values. # Input - A list of integers `arr`, where `1 <= len(arr) <= 10^6`. - Integers in `arr` can range from `-10^6` to `10^6`. # Output - A list of integers, which is the sorted version of input list `arr`. # Constraints - Ensure the algorithm runs efficiently even for large arrays. - Handle negative values appropriately. # Example ```python assert efficient_counting_sort([4, -2, 0, 10, 7, -5, 3]) == [-5, -2, 0, 3, 4, 7, 10] assert efficient_counting_sort([-1, -3, -2, 2, 1, 0]) == [-3, -2, -1, 0, 1, 2] assert efficient_counting_sort([]) == [] ``` # Hints - Consider adjusting the range of values to be positive if negative values are encountered. - Use a count array to keep track of occurrences and cumulative counts. - Ensure the memory usage is within acceptable limits for large input sizes.","solution":"from typing import List def efficient_counting_sort(arr: List[int]) -> List[int]: if not arr: return [] # Find the maximum and minimum value in the array max_val = max(arr) min_val = min(arr) # Range of the count array range_of_values = max_val - min_val + 1 # Create count array and initialize it with zeros count = [0] * range_of_values # Populate the count array for number in arr: count[number - min_val] += 1 # Transform count array to store the cumulative sum for i in range(1, len(count)): count[i] += count[i - 1] # Sort the array using the count array output = [0] * len(arr) for number in reversed(arr): output[count[number - min_val] - 1] = number count[number - min_val] -= 1 return output"},{"question":"Absolute Path Resolution Context You are developing a file management system that requires consistent and absolute file paths to function correctly. To ensure this, you need to write a utility function that takes a file path (which could be relative or containing user directory indicators like \\"~\\") and returns its absolute path. Task Write a Python function `resolve_path(path: str) -> str` that takes a single string argument `path` representing a file path and returns its absolute path. Input - `path`: A string representing the file path. It could be a relative path, an absolute path, or contain user directory indicators. Output - A string representing the absolute path of the given file. Constraints - The `path` can be an empty string, a relative path, or an absolute path. - The `path` does not guarantee that the file actually exists; only the path resolution is necessary. Example ```python # Example 1 input_path = \'~/documents/file.txt\' output_path = resolve_path(input_path) print(output_path) # Outputs: \'/home/username/documents/file.txt\' (assuming \\"/home/username\\") # Example 2 input_path = \'relative/path/to/file.txt\' output_path = resolve_path(input_path) print(output_path) # Outputs: \'/current/directory/relative/path/to/file.txt\' (assuming current directory is \\"/current/directory\\") ``` Hints - Consider using Python\'s `os` module, specifically the `os.path.abspath` and `os.path.expanduser` functions. Unit Test Requirement Provide a set of unit tests that verify the function works correctly for the given edge cases: 1. Paths already absolute. 2. Nonexistent yet properly formatted paths. 3. Paths containing user directory indicators.","solution":"import os def resolve_path(path: str) -> str: Resolves the given file path to its absolute path, expanding user directory indicators if present. # Expand user directory indicators (e.g., \\"~\\") expanded_path = os.path.expanduser(path) # Resolve the absolute path absolute_path = os.path.abspath(expanded_path) return absolute_path"},{"question":"Counting Sort with Negative Numbers You are given an array of integers `arr` containing both positive and negative integers. Your task is to implement the `counting_sort` function that sorts this array in non-descending order using the counting sort algorithm. Input Format * An integer array `arr` of size `n`, where `1 <= n <= 10^6` and `-10^6 <= arr[i] <= 10^6`. Output Format * A sorted integer array in non-descending order. Constraints * The algorithm should run in O(n + k) time complexity, where k is the range of elements in `arr`. Examples Example 1: ``` Input: arr = [3, -1, -9, 2, 10, 0] Output: [-9, -1, 0, 2, 3, 10] ``` Example 2: ``` Input: arr = [] Output: [] ``` Example 3: ``` Input: arr = [5] Output: [5] ``` Notes * Ensure that your code handles negative numbers correctly. * Pay attention to edge cases such as empty arrays and single-element arrays.","solution":"def counting_sort(arr): if not arr: return arr # Find the minimum and maximum values to determine the range of the input min_val = min(arr) max_val = max(arr) # Shift array values to start from 0 shift = -min_val # Create the count array with the size of the range count = [0] * (max_val - min_val + 1) # Store the count of each element for num in arr: count[num + shift] += 1 # Reconstruct the sorted array sorted_arr = [] for i, c in enumerate(count): sorted_arr.extend([i - shift] * c) return sorted_arr"},{"question":"# Unique Character String Construction Context: You are working on a text processing application that needs to filter out any reoccurring characters from given strings and return a new string comprising only the first occurrences of each character. This is critical for data cleaning processes where unique identifiers or tokens are required from raw text data. Problem Statement: Write a function `unique_characters_string(s: str) -> str` that takes a string `s` as input, deletes any reoccurring characters, and returns a new string with the unique characters from the original string appearing in the order of their first occurrence. Input: * A string `s` (0 <= len(s) <= 10^5), which may contain alphabetic characters and/or numbers. Output: * A new string with unique characters from the input string appearing in the order of their first occurrence. Constraints: * The input string may be empty. * The function should operate with a time complexity of O(n) where `n` is the length of the input string. * The result string should maintain the first occurrence order of characters from the input string. Example Cases: ```python assert unique_characters_string(\\"google\\") == \\"gole\\" assert unique_characters_string(\\"ababab\\") == \\"ab\\" assert unique_characters_string(\\"1234321\\") == \\"1234\\" assert unique_characters_string(\\"\\") == \\"\\" assert unique_characters_string(\\"a\\") == \\"a\\" ``` Note: * Consider edge cases such as empty strings, strings with all unique characters, and strings with completely identical characters. * Aim for an efficient implementation avoiding unnecessary space or time overhead.","solution":"def unique_characters_string(s: str) -> str: This function returns a string comprising only the first occurrences of each character from the input string. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Directed Graph Scenario You are tasked with enhancing a directed graph implementation by adding utility methods that demonstrate your understanding of graph traversal and manipulation. Problem: 1. **Depth-First Search (DFS)**: Implement a method `depth_first_search` that performs a depth-first search starting from a given node and returns a list of nodes in the order they were visited. 2. **Topological Sort**: Implement a method `topological_sort` that returns a topologically sorted list of the graph’s nodes if the graph is a Directed Acyclic Graph (DAG). Specifications: 1. **depth_first_search**: - **Input**: A node from which to start the DFS traversal. - **Output**: A list of nodes in the order they were visited. 2. **topological_sort**: - **Input**: None. - **Output**: A list of nodes in topologically sorted order if the graph is a DAG. Otherwise, return `None`. Constraints: - The graph may contain cycles. - Nodes are identified by unique strings. - Assume graph initialization and edge addition processes are correct. # Example: ```python graph_data = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"D\\"], \\"C\\": [\\"D\\"], \\"D\\": [\\"E\\"], \\"E\\": [] } graph = DirectedGraph(graph_data) # Sample usage: result_dfs = graph.depth_first_search(\\"A\\") print(result_dfs) # Example output: [\\"A\\", \\"B\\", \\"D\\", \\"E\\", \\"C\\"] result_topo_sort = graph.topological_sort() print(result_topo_sort) # Example output: [\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\"] ``` # Implementation Note: Use the provided `Node` and `DirectedEdge` classes as part of your solution.","solution":"class DirectedGraph: def __init__(self, graph_data): self.graph = graph_data def depth_first_search(self, start_node): visited = set() result = [] def dfs(node): if node not in visited: visited.add(node) result.append(node) for neighbor in self.graph.get(node, []): dfs(neighbor) dfs(start_node) return result def topological_sort(self): visited = set() stack = [] temp_mark = set() def visit(node): if node in temp_mark: return False if node not in visited: temp_mark.add(node) for neighbor in self.graph.get(node, []): if not visit(neighbor): return False temp_mark.remove(node) visited.add(node) stack.append(node) return True for node in self.graph: if node not in visited: if not visit(node): return None stack.reverse() return stack"},{"question":"# Problem Description You are tasked with implementing a data structure for efficient string storage and search operations. This data structure should support the following functionalities: 1. **Inserting strings**. 2. **Searching for a complete string**. 3. **Checking if there is any string that starts with a given prefix**. You are required to implement a class `Trie` that has methods `insert`, `search`, and `starts_with` as specified below. All input strings will be composed of lowercase English letters (`a`-`z`). # Function Signatures ```python class Trie: def __init__(self): # Initialize your data structure here. def insert(self, word: str) -> None: # Inserts a word into the trie. def search(self, word: str) -> bool: # Returns if the word is in the trie. def starts_with(self, prefix: str) -> bool: # Returns if there is any word in the trie that starts with the given prefix. ``` # Example Usage ```python trie = Trie() trie.insert(\\"apple\\") assert trie.search(\\"apple\\") == True # returns True assert trie.search(\\"app\\") == False # returns False assert trie.starts_with(\\"app\\") == True # returns True trie.insert(\\"app\\") assert trie.search(\\"app\\") == True # returns True ``` # Constraints - All strings will have lengths in the range [1, 2000] - The total number of calls to `insert`, `search`, and `starts_with` will not exceed 3 × 10⁴ Your implementation should minimize unnecessary computations and adhere to the stated time and space complexities. # Edge Cases to Consider 1. Empty strings (if allowed by constraints). 2. Repeated insertions of the same word. 3. Searching or prefix checking non-existent entries.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"Context You are tasked with optimizing and implementing a function to move all zeros in a given list of elements to the end while preserving the order of non-zero elements. This often arises in data organization tasks or when working on preprocessing data for machine learning algorithms. Problem Statement Implement the function `move_zeros_in_place(array)` that modifies a given list `array` in place, moving all zeros to the end and preserving the relative order of non-zero elements. Your solution should aim to optimize space complexity. Specifications * **Function Signature**: `def move_zeros_in_place(array: list) -> None` * **Parameters**: * `array`: A list of elements of any data type. * **Modifications**: The function must modify the list in place without returning a new list. * **Constraints**: * The list can contain elements of any type. * Take care of boolean values explicitly as `False == 0`. Example ```python move_zeros_in_place([False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"]) # After function call, array should be modified to: # [False, 1, 1, 2, 1, 3, \'a\', 0, 0] ``` Requirements * Time complexity must be O(n). * Space complexity should be O(1), meaning no use of extra lists or arrays proportional to the size of the input. # Challenge Provide the implementation of the `move_zeros_in_place` function that respects the specified constraints. Ensure to handle edge cases, such as mixed data types and no zeros present in the array.","solution":"def move_zeros_in_place(array: list) -> None: Modifies the list in place by moving all zeros to the end while preserving the order of non-zero elements. # Position to place the next non-zero element. insert_position = 0 for i in range(len(array)): # Consider explicit check for True because True == 1 in Python. # Additionally, check for types to distinguish from non-integer values like `False`. if array[i] != 0 or array[i] is False: array[insert_position] = array[i] insert_position += 1 # Replace remaining positions with zeros. for i in range(insert_position, len(array)): array[i] = 0"},{"question":"Context You have been tasked to sort a list of integers by implementing a Gnome Sort algorithm. Gnome Sort, while not the most efficient, is notable for its simplicity and educational value in understanding how sorting algorithms work. Problem Statement Implement the `gnome_sort` function to sort a given list of integers in non-decreasing order. Your implementation should be in Python and should adhere to the principles of the Gnome Sort algorithm provided. Function Signature ```python def gnome_sort(arr: List[int]) -> List[int]: # your code here ``` Input Format * A single list `arr` of integers where `1 <= len(arr) <= 10^5` and each element in the list is within the range `-10^9` to `10^9`. Output Format * Return the sorted list of integers in non-decreasing order. Constraints * The sorting should be performed in place (i.e., without using additional lists). * The algorithm should handle edge cases such as empty lists and lists with repeating elements correctly. Performance Requirements * Given that Gnome Sort is typically O(n^2) in the worst case, it\'s suitable for reasonable-sized inputs within given constraints. However, ensure your solution is optimal for best-case scenarios which should run in linear time O(n). Example ```python # Example 1 arr = [5, 3, 2, 4, 1] print(gnome_sort(arr)) # Output: [1, 2, 3, 4, 5] # Example 2 arr = [] print(gnome_sort(arr)) # Output: [] # Example 3 arr = [2, 3, 2, 2, 3] print(gnome_sort(arr)) # Output: [2, 2, 2, 3, 3] ```","solution":"from typing import List def gnome_sort(arr: List[int]) -> List[int]: Sorts the list of integers in non-decreasing order using Gnome Sort algorithm. index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"Context You are working on a text editor feature that helps users with automatic parenthesis matching. To ensure that all parentheses in expressions are correctly nested and matched, you need to implement a validation function. Problem Statement You are given a string `s` containing only the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. Write a function `is_valid(s: str) -> bool` that determines if the string is valid. A string is considered valid if: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order. Input and Output * **Input**: A string `s` of length 1 <= |s| <= 10^4 containing only characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. * **Output**: Return `True` if the string is valid, otherwise return `False`. Constraints * You must consider all possible edge cases and ensure your solution works within the limits mentioned. Example ```python assert is_valid(\\"()\\") == True assert is_valid(\\"()[]{}\\") == True assert is_valid(\\"(]\\") == False assert is_valid(\\"((]]\\") == False assert is_valid(\\"{([])}\\") == True assert is_valid(\\"{[(])}\\") == False ``` Additional Task Optimize your solution to run efficiently and maintain the best time complexity achievable based on the given constraints.","solution":"def is_valid(s: str) -> bool: Determine if the parentheses string is valid. stack = [] matching_bracket = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in matching_bracket: top_element = stack.pop() if stack else \'#\' if matching_bracket[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"**Context:** You are developing a search functionality for a database with uniformly distributed values. A highly efficient search algorithm is required to minimize search times for large datasets. **Problem Statement:** Implement the `interpolation_search` function to locate a given search key within a sorted array of integers. Your implementation should harness the principles of interpolation search discussed above. The function signature and behavior are outlined below. **Function Signature:** ```python def interpolation_search(array: List[int], search_key: int) -> int: :param array: A sorted list of integers. :param search_key: The integer value to be searched in the array. :return: The index of the search_key in the array if found, else returns -1. ``` # Requirements: 1. Input: * `array`: A list of integers sorted in non-decreasing order. * `search_key`: An integer representing the value you need to search in the array. 2. Output: * Return the index of `search_key` if found in `array`, otherwise return -1. 3. Constraints: * The array may contain up to (10^5) elements. * The values in the array are in the range of (-10^6) to (10^6). * The `search_key` is an integer within the same value range. 4. Performance: * Your solution should aim for (O(log log n)) time complexity for uniformly distributed arrays. # Examples: ```python assert interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) == 2 assert interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) == -1 assert interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) == -1 assert interpolation_search([4, 8, 15, 16, 23, 42], 23) == 4 assert interpolation_search([4, 8, 15, 16, 23, 42], 100) == -1 ``` Consider all edge cases and ensure that your implementation handles arrays effectively, whether the search key is in bounds, out of bounds, or absent.","solution":"from typing import List def interpolation_search(array: List[int], search_key: int) -> int: low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 pos = low + ((search_key - array[low]) * (high - low) // (array[high] - array[low])) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Task Description: You are to implement two functions `encode` and `decode` which are designed to handle the conversion of a list of strings to a single string and back respectively. Here are the details for each function: Functions: 1. `encode(strs: List[str]) -> str` - This function accepts a list of strings and returns a single encoded string. 2. `decode(s: str) -> List[str]` - This function accepts a single encoded string and returns the original list of strings. Constraints: - All strings in the list are alphanumeric. - Strings do not contain the colon character `\':\'`. # Input: Both functions will handle the following inputs: - `encode`: A list of strings, `strs`. - `decode`: A single encoded string, `s`. # Output: - `encode`: Returns a single string which is the encoded version of the list. - `decode`: Returns a list of strings which were originally used to create the encoded string. # Scenario: You are developing a messaging service where each message is a list of individual words. To minimize the complexity, you decide to encode each list of user messages into a single string before sending them over the network. You later decode these strings back to the original list of words for further processing and display. # Example: ```python # Example usage: # Original list of strings original_list = [\\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\"] # Encoding the list of strings encoded_string = encode(original_list) print(encoded_string) # Output format might look something like \\"5:hello5:world4:this2:is1:a4:test\\" # Decoding the string back to the list of strings decoded_list = decode(encoded_string) print(decoded_list) # Output should be [\\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\"] ``` Additional Requirements: 1. Ensure the algorithms handle edge cases such as empty string and string lengths of varying orders. 2. The solution must efficiently handle length parsing and avoid unnecessary complications. Your implementation must ensure that `encode(decode(s)) == s` and `decode(encode(strs)) == strs`.","solution":"def encode(strs): Encodes a list of strings to a single string. encoded = \'\'.join(f\'{len(s)}:{s}\' for s in strs) return encoded def decode(s): Decodes a single string to a list of strings. i, n = 0, len(s) decoded = [] while i < n: j = s.find(\':\', i) if j == -1: break length = int(s[i:j]) i = j + 1 + length decoded.append(s[j + 1:i]) return decoded"},{"question":"# Question: Implement a Chained Hash Table Implement a hash table that uses separate chaining for collision resolution. In separate chaining, each position (bucket) in the hash table array contains a linked list of key-value pairs that map to the same bucket index. Function Requirements: 1. **Class Definition**: Define a `ChainedHashTable` class that supports the following operations: - **put(key, value)**: Store the key-value pair in the hash table. - **get(key)**: Retrieve the value associated with the given key. - **del_(key)**: Remove the key-value pair identified by the given key. - **__len__()**: Return the number of key-value pairs stored in the hash table. - **resize()**: Resize the hash table to double its current capacity and rehash all entries. 2. **Input/Output**: - `put`: Inputs are `key` (non-negative integer) and `value` (any data type). No output. - `get`: Input is `key`. Output is the associated value or `None` if the key is not present. - `del_`: Input is `key`. No output. - `__len__`: No input. Output is the number of stored key-value pairs. - `resize`: No input or output. 3. **Constraints**: - Keys are non-negative integers. - Use linked lists for chaining. Example: ```python hash_table = ChainedHashTable(size=3) hash_table.put(1, \'one\') hash_table.put(4, \'four\') print(hash_table.get(1)) # Output: \'one\' print(len(hash_table)) # Output: 2 hash_table.del_(1) print(hash_table.get(1)) # Output: None hash_table.put(7, \'seven\') hash_table.put(8, \'eight\') hash_table.resize() print(len(hash_table)) # Output: 3 ``` Implementation Notes: - Define a helper class `Node` to store each key-value pair and linked list node. - Ensure the hash table resizes smoothly and rehashes existing entries.","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.next = None class ChainedHashTable: def __init__(self, size=8): self.size = size self.table = [None] * size self.count = 0 def _hash(self, key): return key % self.size def put(self, key, value): index = self._hash(key) node = self.table[index] while node: if node.key == key: node.value = value return node = node.next new_node = Node(key, value) new_node.next = self.table[index] self.table[index] = new_node self.count += 1 # Check load factor and resize if needed if self.count / self.size > 0.75: self.resize() def get(self, key): index = self._hash(key) node = self.table[index] while node: if node.key == key: return node.value node = node.next return None def del_(self, key): index = self._hash(key) node = self.table[index] prev = None while node: if node.key == key: if prev: prev.next = node.next else: self.table[index] = node.next self.count -= 1 return prev = node node = node.next def __len__(self): return self.count def resize(self): new_size = self.size * 2 new_table = [None] * new_size for item in self.table: node = item while node: index = node.key % new_size new_node = Node(node.key, node.value) new_node.next = new_table[index] new_table[index] = new_node node = node.next self.table = new_table self.size = new_size"},{"question":"# Binary Search Challenge In this exercise, you will implement the binary search algorithm to find the position of a target value within a sorted array of integers. Your function should efficiently perform the search using the principles of binary search. Function Signature Write a function `binary_search(array: List[int], target: int) -> int`. Input 1. `array`: A list of integers sorted in ascending order (1 <= len(array) <= 10^5, -10^6 <= array[i] <= 10^6). 2. `target`: An integer representing the target value to search for (-10^6 <= target <= 10^6). Output Return the index of `target` in `array`, if `target` is present. Otherwise, return `-1`. Constraints 1. Ensure that your algorithm runs in logarithmic time complexity O(log(n)). 2. Use an iterative approach to minimize space complexity. Example ```python binary_search([1, 3, 5, 7, 9], 5) # Output: 2 binary_search([1, 3, 5, 7, 9], 2) # Output: -1 binary_search([], 1) # Output: -1 binary_search([2], 2) # Output: 0 ``` Note - The function should handle edge cases such as an empty array, target being the first element, target being the last element, and target not being found in the array. Good luck!","solution":"def binary_search(array, target): Perform binary search to find the target in the sorted array. If found, return the index of the target, otherwise return -1. left, right = 0, len(array) - 1 while left <= right: mid = left + (right - left) // 2 if array[mid] == target: return mid elif array[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"Scenario You have been hired by a data storage company that needs to develop efficient and simple methods for compressing repetitive data in their systems to save space. They use Run-Length Encoding (RLE) to compress repeating characters in their data stream. This method serves well for their requirement, but they now need you to write custom variants of these functions which not only encode data but also provide more insight into performance. Problem Implement a function `transform_rle` that performs run-length encoding like the `encode_rle`, but also tracks the highest frequency of a single character in the input string. The function should return a tuple with the encoded string and the highest frequency count. Implement a function `restore_rle` that performs run-length decoding like the `decode_rle`, but it should also work with the modified tuple format to restore the original string. Function Signature The function signatures should be: ```python def transform_rle(input: str) -> (str, int): Encodes the input string using Run-Length Encoding and returns the encoded string along with the highest frequency of a single character. :param input: The input string to be encoded. :return: A tuple containing the encoded string and the highest frequency count. pass def restore_rle(encoded_tuple: (str, int)) -> str: Decodes a string that was encoded with the transform_rle function. :param encoded_tuple: A tuple containing the encoded string and the highest frequency count. :return: The original string. pass ``` Example ```python # Example Usage encoded, max_freq = transform_rle(\\"aaabbccccdd\\") print(encoded) # Output: \\"3a2b4c2d\\" print(max_freq) # Output: 4 original = restore_rle((encoded, max_freq)) print(original) # Output: \\"aaabbccccdd\\" ``` Constraints * The input string will only contain alphanumeric characters. * The functions should handle any length of an input string efficiently. --- Your Task Implement the `transform_rle` and `restore_rle` functions to meet the above requirements. Be mindful of handling edge cases and ensure your functions are optimized for performance. Include comments to explain your logic and any assumptions made.","solution":"def transform_rle(input: str) -> (str, int): Encodes the input string using Run-Length Encoding and returns the encoded string along with the highest frequency of a single character. :param input: The input string to be encoded. :return: A tuple containing the encoded string and the highest frequency count. if not input: return \\"\\", 0 encoded_str = [] max_freq = 0 count = 1 char = input[0] for i in range(1, len(input)): if input[i] == char: count += 1 else: encoded_str.append(f\\"{count}{char}\\") if count > max_freq: max_freq = count char = input[i] count = 1 # for the last group encoded_str.append(f\\"{count}{char}\\") if count > max_freq: max_freq = count return \\"\\".join(encoded_str), max_freq def restore_rle(encoded_tuple: (str, int)) -> str: Decodes a string that was encoded with the transform_rle function. :param encoded_tuple: A tuple containing the encoded string and the highest frequency count. :return: The original string. encoded, _ = encoded_tuple decoded_str = [] i = 0 while i < len(encoded): count_str = [] while encoded[i].isdigit(): count_str.append(encoded[i]) i += 1 count = int(\\"\\".join(count_str)) char = encoded[i] decoded_str.append(char * count) i += 1 return \\"\\".join(decoded_str)"},{"question":"# Question: Scenario: You are tasked with creating a function to find the next higher number with the same set of digits of a given number. This function can be particularly useful in combinatorial problems and number manipulation tasks where subsequent permutations are necessary. Instructions: Write a function `next_bigger(num)` that takes an integer `num` as input and returns the next higher number that uses the exact same set of digits. If no such number exists, return `-1`. Input: * An integer `num` (1 ≤ num ≤ 10^9). Output: * An integer representing the next higher permutation of the digits of `num`, or `-1` if no such permutation exists. Example: ```python Input: 38276 Output: 38627 Input: 99999 Output: -1 ``` Constraints: 1. You may assume the input number is strictly positive. 2. The input number will not have more than 9 digits due to constraints similar to typical integer value upper bounds. Requirements: * The function must run in O(n) time complexity where `n` is the number of digits. * The function must use O(n) space complexity to manage the digits. Write the function using the template provided below: ```python def next_bigger(num): # Implement your solution here pass # You can write additional helper functions if needed. ```","solution":"def next_bigger(num): digits = list(str(num)) n = len(digits) # Start from the end of the number and find the first digit that is smaller than the digit next to it for i in range(n-2, -1, -1): if digits[i] < digits[i+1]: break else: # If no such digit is found, the number is the highest permutation return -1 # Find the smallest digit on the right side of the found digit which is larger than the found digit for j in range(n-1, i, -1): if digits[j] > digits[i]: break # Swap the found digit and j digits[i], digits[j] = digits[j], digits[i] # Reverse the digits after the position i digits = digits[:i+1] + digits[i+1:][::-1] return int(\\"\\".join(digits))"},{"question":"Design and implement an improved version of the Insertion Sort algorithm. Given an array of integers, your task is to sort the array in non-decreasing order using the Insertion Sort algorithm. Additionally, you should implement the following enhancements: 1. Modify the algorithm to detect if the array is already sorted at any point and exit early if so. 2. Implement an efficient way to handle arrays with a high number of duplicate values by skipping unnecessary comparisons. 3. Provide a simulation mode that outputs the state of the array after each iteration through the array. Write a function `optimized_insertion_sort` with the following signature: ```python def optimized_insertion_sort(arr, simulation=False): # Your implementation here ``` Input - `arr` (List[int]): A list of integers to be sorted. - `simulation` (bool): An optional parameter. If `True`, print the state of the array after each iteration. Output - A list of integers sorted in non-decreasing order. Constraints - The input list `arr` will have a length between 0 and 10⁴. - Each integer in the array will be in the range of -10⁶ to 10⁶. Example ```python print(optimized_insertion_sort([4, 2, 3, 1], simulation=True)) # Expected output with simulation: # iteration 0 : 4 2 3 1 # iteration 1 : 2 4 3 1 # iteration 2 : 2 3 4 1 # iteration 3 : 2 3 4 1 # iteration 4 : 1 2 3 4 # Sorted array: [1, 2, 3, 4] print(optimized_insertion_sort([1, 2, 3, 4], simulation=False)) # Expected output: [1, 2, 3, 4] print(optimized_insertion_sort([1], simulation=False)) # Expected output: [1] ``` Ensure that your function is well-tested, handles edge cases efficiently and performs gracefully with large datasets.","solution":"def optimized_insertion_sort(arr, simulation=False): Sorts an array in non-decreasing order using insertion sort algorithm. Detects if the array is already sorted and exits early if so. Handles arrays with high number of duplicate values efficiently by skipping unnecessary comparisons. Provides a simulation mode that outputs the state of the array after each iteration. n = len(arr) if n < 2: return arr for i in range(1, n): key = arr[i] j = i - 1 already_sorted = True while j >= 0 and arr[j] > key: already_sorted = False arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if simulation: print(f\\"iteration {i} : {\' \'.join(map(str, arr))}\\") if already_sorted and all(arr[k] <= arr[k + 1] for k in range(i, n - 1)): break return arr"},{"question":"Rotated String Check Objective: Implement a function to determine if a given string `s2` is a rotated version of another string `s1`. Function Signature: ```python def is_rotated(s1: str, s2: str) -> bool: pass ``` Input: * `s1` - A string (1 ≤ |s1| ≤ 10^5). * `s2` - A string (0 ≤ |s2| ≤ 10^5). Output: * Return a boolean value. * Return `True` if `s2` is a rotated version of `s1`; otherwise, return `False`. Constraints: * Both strings can contain lowercase alphabets. * Consider the function\'s performance for strings near the upper limit of the length constraint. Example: ```python assert is_rotated(\\"hello\\", \\"llohe\\") == True assert is_rotated(\\"hello\\", \\"helol\\") == False assert is_rotated(\\"aaa\\", \\"aaa\\") == True assert is_rotated(\\"waterbottle\\", \\"erbottlewat\\") == True assert is_rotated(\\"abc\\", \\"cab\\") == True assert is_rotated(\\"abc\\", \\"bca\\") == True assert is_rotated(\\"abc\\", \\"bac\\") == False assert is_rotated(\\"\\", \\"\\") == True assert is_rotated(\\"a\\", \\"a\\") == True assert is_rotated(\\"ab\\", \\"ba\\") == True ``` Complete the function ensuring to handle edge cases and optimize for performance concerning time and space complexity.","solution":"def is_rotated(s1: str, s2: str) -> bool: Determine if s2 is a rotated version of s1. Args: s1 (str): Original string s2 (str): String to check if rotated version of s1 Returns: bool: True if s2 is a rotated version of s1, False otherwise if len(s1) != len(s2): return False if not s1 and not s2: return True return s2 in s1 + s1"},{"question":"You are tasked with implementing a `MinHeap` to manage a priority queue used in a scheduling application. The priority queue should always allow quick access to the smallest (most urgent) task. Your implementation should support the following operations: 1. **Insert Task**: Add a new task to the heap with its associated priority value. 2. **Remove Next Task**: Remove and return the task with the smallest priority value. Each task is represented by an integer priority (the smaller the integer, the higher the priority) and a string description. # Your Task: 1. **Insert Operation**: Implement the insert operation which adds a new task with a given priority and description to the min heap. 2. **Remove Min Operation**: Implement the remove_min operation which removes and returns the task with the smallest priority value. 3. **Heap Property Maintenance**: Ensure that the heap property is maintained after every insertion and removal operation. Function Specifications: ```python class MinHeap: def __init__(self): Initialize the heap. pass def insert(self, priority: int, task: str): Insert a new task with a specified priority into the heap. :param priority: The priority of the task (integer) :param task: The description of the task (string) :return: None pass def remove_min(self) -> tuple: Remove and return the task with the smallest priority. :return: A tuple containing (priority, task) pass ``` Example: ```python # Initialize the heap heap = MinHeap() # Insert tasks heap.insert(4, \\"Task 1\\") heap.insert(1, \\"Task 2\\") heap.insert(3, \\"Task 3\\") heap.insert(2, \\"Task 4\\") # Remove tasks with the smallest priority first print(heap.remove_min()) # Output: (1, \\"Task 2\\") print(heap.remove_min()) # Output: (2, \\"Task 4\\") print(heap.remove_min()) # Output: (3, \\"Task 3\\") print(heap.remove_min()) # Output: (4, \\"Task 1\\") ``` Constraints: - Task priority is an integer within the range [1, 10^5]. - Task description is a non-empty string of length within [1, 100].","solution":"import heapq class MinHeap: def __init__(self): Initialize the heap. self.heap = [] def insert(self, priority: int, task: str): Insert a new task with a specified priority into the heap. :param priority: The priority of the task (integer) :param task: The description of the task (string) :return: None heapq.heappush(self.heap, (priority, task)) def remove_min(self) -> tuple: Remove and return the task with the smallest priority. :return: A tuple containing (priority, task) if not self.heap: return None return heapq.heappop(self.heap)"},{"question":"# Question You have been provided a HashTable class that implements a basic hash map using linear probing for collision resolution and a ResizableHashTable class that extends the HashTable class to support dynamic resizing. Your task is to implement a function that determines the frequency of specific integer keys over multiple insertions, deletions, and lookups in a ResizableHashTable. Write a function `key_frequency(operations, keys_to_check)` that takes: 1. **operations**: A list of tuples where each tuple represents an operation to be performed on the hash table. Each tuple can be: - `(\\"put\\", key, value)` - To insert or update the `key` with the given `value`. - `(\\"get\\", key)` - To retrieve the value associated with the `key`. - `(\\"del\\", key)` - To delete the `key` from the hash table. - `(\\"in\\", key)` - To check if the `key` is in the hash table. The order of operations must be strictly followed as provided in the list. 2. **keys_to_check**: A list of keys for which you need to determine the frequency of operations performed on them. The function should return a dictionary where each key in `keys_to_check` maps to its frequency of operations in the given list of operations. Example ```python operations = [ (\\"put\\", 1, \\"a\\"), (\\"put\\", 2, \\"b\\"), (\\"get\\", 1), (\\"get\\", 3), (\\"del\\", 2), (\\"in\\", 1), (\\"in\\", 2), (\\"put\\", 1, \\"c\\"), ] keys_to_check = [1, 2, 3] print(key_frequency(operations, keys_to_check)) # Expected output: {1: 4, 2: 3, 3: 1} ``` Constraints - All keys for `put`, `get`, and `del` operations will be integers. - `operations` list will contain at most `10^4` operations. - `keys_to_check` list will contain at most `10^3` keys. - Keys provided in `keys_to_check` may or may not be present in the hash table.","solution":"def key_frequency(operations, keys_to_check): freq = {key: 0 for key in keys_to_check} for operation in operations: op_type, key = operation[0], operation[1] if key in freq: freq[key] += 1 return freq"},{"question":"# Scenario You are a software engineer at a startup that manages a large database of user records. You frequently need to search for specific user records based on unique identifiers (ids). The user ids are stored in an array that gets updated regularly, but it is not sorted. Your task is to implement a function that helps quickly find the position of a given user id in the array. # Task Write a function `search_user_id` that uses a linear search algorithm to find the index of a given user id in the provided array of user ids. # Function Signature ```python def search_user_id(user_ids, search_id): pass ``` # Input * `user_ids` - A list of integers representing user ids. (1 <= len(user_ids) <= 10^5) * `search_id` - An integer representing the user id to be searched. # Output * Returns the index of `search_id` in the `user_ids` array if it exists. * If `search_id` is not found in the array, return -1. # Constraints * The elements in the `user_ids` array are distinct. * The array can be very large, but guaranteed to fit in memory. # Example ```python # Example 1 print(search_user_id([5, 3, 8, 1, 2], 8)) # Output: 2 # Example 2 print(search_user_id([5, 3, 8, 1, 2], 4)) # Output: -1 ```","solution":"def search_user_id(user_ids, search_id): Returns the index of search_id in user_ids array if it exists. If search_id is not found, returns -1. for index, current_id in enumerate(user_ids): if current_id == search_id: return index return -1"},{"question":"Rotated String Check Scenario In a cyclic shift detection system, one of the checker modules needs a function that verifies if a string is a rotated version of another string. This is crucial for identifying pattern anomalies in sequential data streams. Objective Write a function named `check_rotated_string` that takes two strings, `s1` and `s2`, and returns a boolean indicating if `s2` is a rotated version of `s1`. Function Signature ```python def check_rotated_string(s1: str, s2: str) -> bool: # Your code here pass ``` Input - `s1`: A string representing the original sequence. - `s2`: A string representing the potentially rotated sequence. Output - A boolean (`True` or `False`) indicating whether `s2` is a rotated version of `s1`. Constraints - Both `s1` and `s2` will only contain printable ASCII characters. - The length of `s1` and `s2` will not exceed 10^5 characters. Performance Requirements - The function should operate in linear time complexity, O(N), where N is the length of the strings. Example ```python assert check_rotated_string(\\"hello\\", \\"llohe\\") == True assert check_rotated_string(\\"hello\\", \\"helol\\") == False assert check_rotated_string(\\"abcde\\", \\"cdeab\\") == True assert check_rotated_string(\\"abcde\\", \\"abced\\") == False assert check_rotated_string(\\"\\", \\"\\") == True assert check_rotated_string(\\"a\\", \\"a\\") == True assert check_rotated_string(\\"a\\", \\"b\\") == False assert check_rotated_string(\\"abc\\", \\"bca\\") == True assert check_rotated_string(\\"abc\\", \\"cab\\") == True assert check_rotated_string(\\"abcd\\", \\"dabc\\") == True assert check_rotated_string(\\"abcd\\", \\"dcba\\") == False ``` Notes - Consider cases where both strings are empty. - Handle edge cases where strings have different lengths. - Ensure your implementation is efficient and does not unnecessarily consume memory.","solution":"def check_rotated_string(s1: str, s2: str) -> bool: Returns True if s2 is a rotated version of s1, otherwise False. # Check if lengths of s1 and s2 are different if len(s1) != len(s2): return False # Concatenate s1 with itself doubled_s1 = s1 + s1 # Check if s2 is a substring of the doubled string return s2 in doubled_s1"},{"question":"# Balanced Binary Tree Check You are tasked with verifying if a given binary tree is balanced. A binary tree is considered balanced if, at every node, the height difference between the left and right subtrees is at most one. Function Signature ```python def is_balanced(root: TreeNode) -> bool: ``` Parameters - `root` (TreeNode): The root node of the binary tree. Returns - `bool`: Returns `True` if the binary tree is balanced, and `False` otherwise. Scenario Given a binary tree, determine if it is balanced. Utilize an optimal algorithm to check for balance that runs in O(N) time complexity. Avoid using the O(N^2) approach. Constraints - The number of nodes in the tree is within the range `[0, 10^4]`. - The values of the nodes are integers within the range `[-10^5, 10^5]`. - You must handle balanced and unbalanced trees efficiently. Examples 1. For the tree below: ``` 1 / 2 3 / 4 5 ``` - Input: `root = TreeNode(1, left=TreeNode(2, left=TreeNode(4), right=TreeNode(5)), right=TreeNode(3))` - Output: `True` 2. For the tree below: ``` 1 / 2 / 3 ``` - Input: `root = TreeNode(1, left=TreeNode(2, left=TreeNode(3)))` - Output: `False`","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: def check_balance(node): if node is None: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 height = 1 + max(left_height, right_height) return height, balanced _, balanced = check_balance(root) return balanced"},{"question":"# RSA Encryption Challenge You are required to implement an RSA encryption and decryption system. The task involves generating RSA keys, encrypting a message, and decrypting it back to the original message using the provided keys. Function Signature ```python def generate_key(k: int) -> Tuple[int, int, int]: pass def encrypt(data: int, e: int, n: int) -> int: pass def decrypt(data: int, d: int, n: int) -> int: pass ``` Input Format 1. An integer `k` for key length in bits for `generate_key`. 2. An integer `data` representing the message for `encrypt` and `decrypt`. 3. A tuple `(e, n)` for `encrypt` representing the public key. 4. A tuple `(d, n)` for `decrypt` representing the private key. Output Format 1. For `generate_key`, return a tuple of three integers `(n, e, d)`: - `n`: modulus for both the public and the private keys - `e`: the exponent for the public key - `d`: the exponent for the private key 2. For `encrypt`, return the encrypted integer. 3. For `decrypt`, return the decrypted integer. Constraints * Key length `k` should be greater than 1. * Ensure `data` is a non-negative integer less than `n`. * The functions should handle large numbers efficiently. Example Usage ```python # Generate RSA keys with a bit length of 16 n, e, d = generate_key(16) # Encrypt a message using the public key (e, n) data = 42 encrypted_data = encrypt(data, e, n) # Decrypt the message using the private key (d, n) decrypted_data = decrypt(encrypted_data, d, n) # Validate that the decrypted message matches the original assert decrypted_data == data ``` Notes 1. Implement the RSA key generation using two large random prime numbers. 2. Ensure proper handling of the modular multiplicative inverse. 3. Utilize efficient algorithms for large number arithmetic.","solution":"import random from typing import Tuple from sympy import isprime from sympy.ntheory.generate import nextprime def generate_key(k: int) -> Tuple[int, int, int]: Generate RSA keys of bit length k. assert k > 1, \\"Key length k should be greater than 1.\\" # Generate two large random prime numbers of bit length k/2 p = nextprime(random.getrandbits(k//2)) q = nextprime(random.getrandbits(k//2)) # Compute modulus n n = p * q # Compute Euler\'s totient function φ(n) phi = (p - 1) * (q - 1) # Choose an integer e such that 1 < e < φ(n) and gcd(e, φ(n)) = 1 e = 3 while True: if e < phi and isprime(e) and gcd(e, phi) == 1: break e = nextprime(e) # Compute the modular multiplicative inverse d of e mod φ(n) d = modinv(e, phi) return n, e, d def gcd(a, b): while b != 0: a, b = b, a % b return a def modinv(a, m): m0, x0, x1 = m, 0, 1 if m == 1: return 0 while a > 1: q = a // m m, a = a % m, m x0, x1 = x1 - q * x0, x0 if x1 < 0: x1 += m0 return x1 def encrypt(data: int, e: int, n: int) -> int: Encrypt the integer data with public key (e, n). assert 0 <= data < n, \\"Data should be within the range [0, n).\\" return pow(data, e, n) def decrypt(data: int, d: int, n: int) -> int: Decrypt the integer data with private key (d, n). return pow(data, d, n)"},{"question":"Design and implement a min-heap data structure from scratch, ensuring to maintain the heap property throughout insertions and deletions. The min-heap must be implemented using an array. You will need to implement the following functionalities: 1. **insert(val)**: Insert a value into the heap. 2. **remove_min()**: Remove and return the smallest value from the heap. 3. **find_min()**: Return the smallest value without removing it from the heap. 4. **size()**: Return the number of elements in the heap. 5. **is_empty()**: Return True if the heap is empty, False otherwise. Input and Output Formats * **insert(val)**: * *Input*: An integer `val`. * *Output*: None. * **remove_min()**: * *Output*: The smallest element from the heap. Return a specific error code or message if the heap is empty. * **find_min()**: * *Output*: The smallest element from the heap. Return a specific error code or message if the heap is empty. * **size()**: * *Output*: An integer representing the number of elements in the heap. * **is_empty()**: * *Output*: Boolean value, True if heap is empty, otherwise False. Constraints * You must use a list (array) to represent the heap. * Duplicate values are allowed. * The heap should dynamically resize as elements are added or removed. * Each function should execute in O(log N) time, where N is the number of elements in the heap. Example ``` heap = BinaryHeap() print(heap.is_empty()) # True heap.insert(4) heap.insert(50) heap.insert(7) heap.insert(2) print(heap.size()) # 4 print(heap.find_min()) # 2 print(heap.remove_min()) # 2 print(heap.find_min()) # 4 print(heap.remove_min()) # 4 print(heap.size()) # 2 print(heap.is_empty()) # False ``` Ensure your implementation covers various edge cases, such as removing from an empty heap and handling of duplicate values correctly.","solution":"class BinaryHeap: def __init__(self): self.heap = [] def insert(self, val): self.heap.append(val) self._heapify_up(len(self.heap) - 1) def remove_min(self): if self.is_empty(): return \'Heap is empty\' if len(self.heap) == 1: return self.heap.pop() root = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return root def find_min(self): if self.is_empty(): return \'Heap is empty\' return self.heap[0] def size(self): return len(self.heap) def is_empty(self): return len(self.heap) == 0 def _heapify_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index): smallest = index left_child = 2 * index + 1 right_child = 2 * index + 2 if left_child < len(self.heap) and self.heap[left_child] < self.heap[smallest]: smallest = left_child if right_child < len(self.heap) and self.heap[right_child] < self.heap[smallest]: smallest = right_child if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest)"},{"question":"# Scenario You are given access to a social network data set where each user is represented as a node, and each connection between users is represented as an undirected edge. Your task is to identify the number of separate, connected subgroups within this network. # Problem Description Given an undirected graph represented as an adjacency list, write a function `count_connected_groups` that determines the number of connected components (subgraphs). # Input * An integer `n` representing the number of nodes. * An integer `m` representing the number of edges. * A list of tuples where each tuple `(u, v)` represents an edge between the nodes u and v. # Output * An integer representing the number of connected components in the graph. # Constraints 1. (1 leq n leq 10^5) 2. (0 leq m leq 10^5) 3. (1 leq u, v leq n) # Example ```python def count_connected_groups(n, edges): Function to count connected groups in an undirected graph. Parameters: n (int) : Number of nodes. edges (list of tuples) : List of edges (pairs of nodes). Returns: int : Number of connected components. # YOUR CODE HERE # Example test case nodes = 7 edges = [(1, 2), (2, 4), (4, 5), (5, 6), (3, 7)] print(count_connected_groups(nodes, edges)) # Output: 2 ``` # Explanation In the given example, nodes and edges can be visualized as: ``` 1 3------------7 | | 2--------4 | | | | 6--------5 ``` The graph forms two separate connected components. Hence, the output is 2.","solution":"def count_connected_groups(n, edges): Function to count connected groups in an undirected graph. Parameters: n (int) : Number of nodes. edges (list of tuples) : List of edges (pairs of nodes). Returns: int : Number of connected components. from collections import defaultdict, deque # Create an adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) count = 0 def bfs(start): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) for i in range(1, n + 1): if not visited[i]: bfs(i) count += 1 return count"},{"question":"# Problem: Stack Element Duplicator You are given a stack of integers. Your task is to create a function `stutter_stack` that takes this stack as an input and modifies it such that every original element in the stack is replaced with two consecutive occurrences of that element, preserving the original order. **Function Signature**: ```python def stutter_stack(stack: list) -> list: ``` **Parameters**: * `stack` (list): A list of integers representing a stack (with the last element being the top of the stack). **Returns**: * A list representing the modified stack where each element is duplicated. **Constraints**: * Do not use any other data structures with higher space complexity than the provided stack. **Examples**: 1. Input: `[3, 7, 1, 14, 9]` Output: `[3, 3, 7, 7, 1, 1, 14, 14, 9, 9]` 2. Input: `[]` Output: `[]` **Notes**: * Aim to handle all edge cases efficiently, such as empty stacks or stacks with only one element. * Try to implement an efficient solution with respect to both time and space complexity.","solution":"def stutter_stack(stack: list) -> list: Modifies the input stack such that every original element in the stack is replaced with two consecutive occurrences of that element, preserving the original order. Args: stack (list): A list of integers representing a stack (with the last element being the top of the stack). Returns: list: The modified stack where each element is duplicated. result = [] while stack: element = stack.pop() result.append(element) result.append(element) while result: stack.append(result.pop()) stack.append(result.pop()) return stack"},{"question":"# Question: Implement and Extend a Markov Chain Given the partial implementation of a Markov Chain, complete the following tasks: 1. **`simulate_chain` Function**: Write a function `simulate_chain` that simulates the Markov Chain for a given number of steps and returns the sequence of states. ```python def simulate_chain(chain, initial_state, steps): Simulates a Markov Chain from an initial state for a specific number of steps. Parameters: chain (dict): The Markov Chain represented as a dictionary. initial_state (str): The starting state. steps (int): Number of steps to simulate. Returns: List[str]: Sequence of states visited during the simulation. # Implementation here ``` 2. **Edge Case Management**: Enhance the provided `next_state` function to ensure robustness when encountering undefined states or missing transition probabilities. ```python def next_state(chain, current_state): Given a Markov-Chain, randomly chooses the next state given the current state. Handles edge cases where the current state has no defined transitions. Parameters: chain (dict): The Markov Chain represented as a dictionary. current_state (str): The current state. Returns: str or None: The next state if valid transitions exist, otherwise `None`. next_state_map = chain.get(current_state) if not next_state_map: return None # Handle missing state transitions return __choose_state(next_state_map) ``` # Constraints: * `steps` should be a non-negative integer. * The `chain` dictionary will be non-empty and contain a few state transitions. * Probabilities for transitions are guaranteed to sum to 1 for valid transitions.","solution":"import random def next_state(chain, current_state): Given a Markov-Chain, randomly chooses the next state given the current state. Handles edge cases where the current state has no defined transitions. Parameters: chain (dict): The Markov Chain represented as a dictionary. current_state (str): The current state. Returns: str or None: The next state if valid transitions exist, otherwise `None`. next_state_map = chain.get(current_state) if not next_state_map: return None # Handle missing state transitions return __choose_state(next_state_map) def __choose_state(next_state_map): Helper function to choose the next state based on transition probabilities. Parameters: next_state_map (dict): A dictionary of next states with their respective probabilities. Returns: str: The chosen next state. states = list(next_state_map.keys()) probabilities = list(next_state_map.values()) return random.choices(states, probabilities)[0] def simulate_chain(chain, initial_state, steps): Simulates a Markov Chain from an initial state for a specific number of steps. Parameters: chain (dict): The Markov Chain represented as a dictionary. initial_state (str): The starting state. steps (int): Number of steps to simulate. Returns: List[str]: Sequence of states visited during the simulation. state_sequence = [initial_state] current_state = initial_state for _ in range(steps): current_state = next_state(chain, current_state) if current_state is None: break state_sequence.append(current_state) return state_sequence"},{"question":"<|Analysis Begin|> # Algorithm Analysis Core Identification * **Algorithm/Data Structure**: The algorithm is known as the **Sliding Window Maximum**. * **Type**: This is an algorithm that leverages a deque (double-ended queue) data structure. * **Main Purpose**: To find the maximum elements in each sub-array (or window) of length `k` in a given array. Complexity * **Time Complexity**: O(n), where n is the length of the array. This is because each element is processed exactly twice (once when added and once when removed from the deque). * **Space Complexity**: O(k), where k is the length of the window, due to the storage of indices in the deque. Principles * **Core Operational Steps**: 1. Maintain a deque to store indices of array elements in the current window. 2. Remove indices of elements smaller than the current element from the back of the deque. 3. Add the current index to the back of the deque. 4. Remove the front element from the deque if it is out of the window range. 5. Append the current maximum (the front element of the deque) to the result list once the window size reaches `k`. # Characteristics & Applications Properties * The deque always contains indices in decreasing order of their corresponding array values. * Only indices of the current window are maintained in the deque. Common Use Cases * Finding maximum values in a sliding window is useful in many scenarios, such as in time series analysis, signal processing, and in scenarios where we need to process moving averages or maximums efficiently. Strengths/Limitations * **Strengths**: This algorithm is highly efficient with linear time complexity and is suitable for scenarios requiring frequent range maximum queries. * **Limitations**: Its efficiency depends on the length of the window `k` being substantially smaller than `n` to maintain its space complexity. # Implementation Challenges Edge Cases * When the array length is smaller than `k`. * When the array contains duplicate elements. * The array has a mix of large negative and positive values. Performance Bottlenecks * The performance could degrade with extremely large arrays if the window size `k` approaches `n`. Error Scenarios * Incorrect results can occur if boundary conditions are not handled correctly, e.g., indices falling out of the current window range. Optimization Points * For very small `k`, straightforward comparisons may suffice. * For very large `n` relative to `k`, additional optimizations in deque operations might be considered for specific cases. <|Analysis End|> <|Question Begin|> # Coding Assessment Question You are given an array `arr` and a positive integer `k`. Your task is to implement a function `max_sliding_window(arr, k)` that finds the maximum elements in each of the sub-arrays of length `k`. The function should return a list of these maximum values. Function Signature ```python def max_sliding_window(arr: List[int], k: int) -> List[int]: # implementation ``` Input * `arr`: A list of integers. * `k`: A positive integer representing the length of each sub-array (window). Output * A list of integers representing the maximum values from each sub-array of length `k`. Constraints * The length of `arr` is at least 1. * `1 <= k <= len(arr)`. * Elements of `arr` are integers. Requirements * Time Complexity: O(n), where n is the length of `arr`. * Space Complexity: O(k), where k is the length of each window. Example ```python # Given the following input: arr = [1, 3, -1, -3, 5, 3, 6, 7] k = 3 # The function should return: [3, 3, 5, 5, 6, 7] # Explanation: # The sliding windows are as follows: # [1, 3, -1] -> max is 3 # [3, -1, -3] -> max is 3 # [(-1), -3, 5] -> max is 5 # [(-3), 5, 3] -> max is 5 # [5, 3, 6] -> max is 6 # [3, 6, 7] -> max is 7 ``` # Additional Notes * Ensure to handle edge cases, such as arrays entirely of negative numbers or arrays with repeated elements. * Consider the efficiency of your implementation with respect to both time and space complexity.","solution":"from collections import deque from typing import List def max_sliding_window(arr: List[int], k: int) -> List[int]: n = len(arr) if n * k == 0: return [] if k == 1: return arr deq = deque() max_values = [] for i in range(n): # Remove elements outside the current window if deq and deq[0] <= i - k: deq.popleft() # Remove elements smaller than the current element from the back of the deque while deq and arr[deq[-1]] < arr[i]: deq.pop() # Add current element at the back of the deque deq.append(i) # Start adding max to the result list when the first window is completed if i >= k - 1: max_values.append(arr[deq[0]]) return max_values"},{"question":"# Question Problem Statement Write a function `is_anagram_extended(s1: str, s2: str) -> bool` that determines if two strings are anagrams. The function should be extended to handle: 1. Case insensitivity (i.e., \\"Apple\\" and \\"apple\\" should be treated as anagrams). 2. Any printable ASCII characters (i.e., not limited to lowercase English letters). Input and Output Formats * **Input**: * `s1` (str): The first input string. * `s2` (str): The second input string. * **Output**: * `bool`: `True` if the strings are anagrams, `False` otherwise. Constraints * Strings can contain any printable ASCII characters. * Consider case insensitivity. * Assume the strings are not exceedingly long (e.g., within typical user input or text file lengths). Performance Requirements * The solution should run in linear time relative to the length of the strings. Example ```python assert is_anagram_extended(\\"apple\\", \\"Pleap\\") == True assert is_anagram_extended(\\"apple\\", \\"Cherry\\") == False assert is_anagram_extended(\\"Listen!\\", \\"Silent!\\") == True assert is_anagram_extended(\\"Dormitory\\", \\"Dirty room\\") == False ``` Function Signature ```python def is_anagram_extended(s1: str, s2: str) -> bool: # Implementation goes here ``` # Implementation Notes * Normalize both strings to lowercase. * Count character frequencies for the entire ASCII range. * Compare frequency counts to determine if the two strings are anagrams.","solution":"def is_anagram_extended(s1: str, s2: str) -> bool: Determine if two strings are anagrams, considering case insensitivity and any printable ASCII characters. # Normalize the strings to lowercase s1, s2 = s1.lower(), s2.lower() # Early exit if the lengths are different if len(s1) != len(s2): return False # Create a count dictionary for both strings count_dict = {} # Count characters from the first string for char in s1: count_dict[char] = count_dict.get(char, 0) + 1 # Subtract character count from the dictionary for the second string for char in s2: if char not in count_dict: return False count_dict[char] -= 1 if count_dict[char] < 0: return False return True"},{"question":"**Title**: Efficient Computation of Combinations (n choose r) **Task**: Write a function `efficient_combination(n, r)` that efficiently computes the combination `C(n, r)` - the number of ways to choose `r` items from `n` items. You should use dynamic programming to achieve this. **Function Signature**: ```python def efficient_combination(n: int, r: int) -> int: ``` **Input**: - `n`: An integer representing the total number of items (1 ≤ n ≤ 1000). - `r`: An integer representing the number of items to choose (0 ≤ r ≤ n). **Output**: - An integer representing the number of ways to choose `r` items from `n` items. **Constraints**: - Optimize for both time and space complexity. - Use dynamic programming principles to avoid the pitfalls of recursive methods without memoization. **Example**: ```python assert efficient_combination(5, 2) == 10 assert efficient_combination(10, 0) == 1 assert efficient_combination(10, 10) == 1 assert efficient_combination(10, 5) == 252 ``` **Notes**: - Ensure the solution handles edge cases effectively. - Consider using an iterative approach to avoid recursion depth limits for large values of `n`. **Scenario**: Imagine you are designing a lottery system where participants must choose a certain number of tickets. To ensure the system can handle queries efficiently, you need to implement a method to quickly calculate the number of possible ticket combinations.","solution":"def efficient_combination(n, r): Compute C(n, r) using dynamic programming. if r > n: return 0 if r == 0 or r == n: return 1 dp = [[0]*(r+1) for _ in range(n+1)] for i in range(n+1): for j in range(min(i, r)+1): if j == 0 or j == i: dp[i][j] = 1 else: dp[i][j] = dp[i-1][j-1] + dp[i-1][j] return dp[n][r]"},{"question":"# Anagram Detection Enhancement Objective Write a function that determines if two strings are anagrams, taking into account case insensitivity and extended character sets including digits and special symbols. Problem Description Two strings are considered anagrams if they can be rearranged to form each other. Extend the given anagram detection algorithm to support uppercase and lowercase letters, digits, and special characters. The comparison should be case-insensitive. Function Signature ```python def enhanced_anagram(s1: str, s2: str) -> bool: pass ``` Input Format - `s1` and `s2`: Two strings containing alphanumeric characters and special symbols. Output Format - Returns `True` if the two strings are anagrams, otherwise returns `False`. Constraints - Strings can be of any length from 0 to 10^6. - The algorithm should handle mixed case letters and special characters. - Optimize for time and space complexity considering the extended character set. Examples ```python print(enhanced_anagram(\\"apple\\", \\"Pleap\\")) # Output: True print(enhanced_anagram(\\"Hello, World!\\", \\"Wor,ld! Hello\\")) # Output: True print(enhanced_anagram(\\"123\\", \\"321\\")) # Output: True print(enhanced_anagram(\\"apple\\", \\"pear\\")) # Output: False print(enhanced_anagram(\\"apple\\", \\"aple\\")) # Output: False ``` Hints - Consider using a dictionary to count character occurrences for an arbitrary character set. - Normalize the case of characters before counting.","solution":"def enhanced_anagram(s1, s2): Returns True if s1 and s2 are anagrams, otherwise False. The function is case insensitive and considers digits and special characters. from collections import Counter # Normalize the cases to be case insensitive s1 = s1.lower() s2 = s2.lower() # Count the frequency of each character in both strings return Counter(s1) == Counter(s2)"},{"question":"# Shell Sort Implementation Challenge You have been tasked to implement Shell Sort using an optimal gap sequence to improve its performance. Given an array of integers, sort it in non-decreasing order using Shell Sort with the provided gap sequence. Gap Sequence: You should use the Tokuda gap sequence which is known to give better performance for Shell Sort. The sequence can be generated using the formula: (g_k = lceil(9 cdot (9/4)^k - 4)/5rceil) for (k geq 1). Compute the gap values until they exceed the length of the array. Use these values in decreasing order to perform the Shell Sort. # Function Signature ```python def shell_sort_opt(arr: List[int]) -> List[int]: # Your code here ``` # Input * `arr` (List[int]): A list of integers to be sorted. # Output * List[int]: The sorted list of integers in non-decreasing order. # Constraints * The length of the array will be between 1 and (10^6). * The integers in the array will be in the range of -(10^6) to (10^6). # Performance Requirements * Aim for an average-case time complexity of (O(n log n)) by using an efficient gap sequence. * Utilize in-place sorting to maintain (O(1)) space complexity. # Example ```python input: [8, 5, 3, 6, 9, 2] output: [2, 3, 5, 6, 8, 9] input: [20, -4, 6, 7, 0] output: [-4, 0, 6, 7, 20] ```","solution":"import math from typing import List def shell_sort_opt(arr: List[int]) -> List[int]: Sorts the array using Shell Sort with Tokuda\'s optimal gap sequence. if not arr: return arr n = len(arr) # Generate the Tokuda gap sequence gaps = [] k = 0 while True: gap = math.ceil((9 * (9 / 4) ** k - 4) / 5) if gap > n: break gaps.append(gap) k += 1 # Perform shell sort using the gap sequence for gap in reversed(gaps): # Do a gapped insertion sort for this gap size. for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"**Problem Statement:** Given two words, `word_a` and `word_b`, your task is to implement a function that calculates the minimum number of single-character insertions, deletions, and substitutions required to transform `word_a` into `word_b`. # Constraints: * The inputs `word_a` and `word_b` will each have a length of at most 1000 characters. * Only ASCII characters will be used in the input strings. # Input: * A string `word_a` of length up to 1000. * A string `word_b` of length up to 1000. # Output: * An integer representing the minimum edit distance between the two input strings. # Example: ```python assert edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert edit_distance(\\"flaw\\", \\"lawn\\") == 2 assert edit_distance(\\"\\", \\"test\\") == 4 assert edit_distance(\\"abc\\", \\"abc\\") == 0 ``` # Function Signature: ```python def edit_distance(word_a: str, word_b: str) -> int: pass ``` # Detailed Requirements: 1. Initialize a 2-dimensional list to store intermediate results. 2. Populate the base cases where one of the strings is empty. 3. Use nested loops to fill up the table according to the recurrence relation: ```python edit(i, j) = min(edit(i-1, j) + 1, # Deletion edit(i, j-1) + 1, # Insertion edit(i-1, j-1) + cost) # Substitution ``` 4. Consider that the cost is 0 if the characters being compared are the same; otherwise, it is 1. 5. Return the value at `edit[length_a][length_b]` which represents the minimum edit distance between `word_a` and `word_b`.","solution":"def edit_distance(word_a: str, word_b: str) -> int: len_a = len(word_a) len_b = len(word_b) # Create a table to store results of subproblems dp = [[0 for x in range(len_b+1)] for x in range(len_a+1)] # Fill dp[][] in bottom up manner for i in range(len_a+1): for j in range(len_b+1): # If first string is empty, the only option is to insert all characters of second string if i == 0: dp[i][j] = j # If second string is empty, the only option is to remove all characters of first string elif j == 0: dp[i][j] = i # If last characters are the same, ignore the last character and recur for the remaining elif word_a[i-1] == word_b[j-1]: dp[i][j] = dp[i-1][j-1] # If last character is different, consider all possibilities and find the minimum else: dp[i][j] = 1 + min(dp[i-1][j], # Remove dp[i][j-1], # Insert dp[i-1][j-1]) # Replace return dp[len_a][len_b]"},{"question":"# Coding Problem: Optimized Factorial Calculation with Modulo # Context: You are tasked with calculating the factorial of a large number, which is an essential requirement in combinatorial computations. Given the potential for large values, the calculation should consider the modulo operation to keep the result within manageable limits. # Objective: Implement an optimized function to compute the factorial of a given number, incorporating both iterative and recursive approaches. # Function Signature: ```python def optimized_factorial(n, mod=None): Calculates factorial of n with optional modulo. Uses memoization to optimize the recursive method. Params: - n (int): A non-negative integer for which the factorial is to be calculated. - mod (int, optional): An optional positive integer for modulo operation. Returns: - int: The factorial of n, optionally modulo `mod`. ``` # Input: - `n`: A non-negative integer (0 <= n <= 10^5). - `mod`: An optional positive integer (1 <= mod <= 10^9). # Output: - The factorial of `n`, potentially modulo `mod`. # Constraints: - Factorial numbers grow very quickly, so handle large integers efficiently. - The function should raise a `ValueError` for invalid inputs (negative integers, non-integers, and invalid modulo). # Example: ```python print(optimized_factorial(5)) # Output: 120 print(optimized_factorial(5, 7)) # Output: 1 print(optimized_factorial(0)) # Output: 1 ``` # Requirements: 1. Implement both iterative and recursive calculations within the same function. 2. Leverage memoization in the recursive approach to avoid recomputation. 3. Ensure that mod is applied correctly throughout the calculations to keep the intermediate results manageable. 4. Handle edge cases such as n = 0 and invalid inputs gracefully. # Additional Challenge (Bonus): Improve the performance to handle the upper bounds of n efficiently.","solution":"def optimized_factorial(n, mod=None): Calculates factorial of n with optional modulo. Uses memoization to optimize the recursive method. Params: - n (int): A non-negative integer for which the factorial is to be calculated. - mod (int, optional): An optional positive integer for modulo operation. Returns: - int: The factorial of n, optionally modulo `mod`. if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if mod is not None and (not isinstance(mod, int) or mod <= 0): raise ValueError(\\"Modulo must be a positive integer.\\") # Memoization storage memo = {0: 1} def recursive_factorial(x): if x in memo: return memo[x] result = x * recursive_factorial(x - 1) if mod: result %= mod memo[x] = result return result def iterative_factorial(y): result = 1 for i in range(1, y + 1): result *= i if mod: result %= mod return result # Choose between recursive or iterative approach if n <= 20: return recursive_factorial(n) else: return iterative_factorial(n)"},{"question":"# Context: You are developing a secure communication system and need to ensure efficient encryption by calculating large powers with a modulus operation. To test the robustness of your implementation, you have to deal with extremely large exponents which need to be handled efficiently without causing overflow. # Problem Statement: Implement a function `modular_exponentiation` that calculates the result of raising a base `a` to a power `n` and then taking modulo `mod`. # Function Signature: ```python def modular_exponentiation(a: int, n: int, mod: int) -> int: Calculate (a ^ n) % mod using binary exponentiation. Parameters: a (int): base number. n (int): exponent. mod (int): modulus. Returns: int: result of (a ^ n) % mod. pass ``` # Input: - `a` (1 ≤ |a| ≤ 10^9): The base integer. - `n` (0 ≤ n ≤ 10^18): The exponent. - `mod` (1 ≤ mod ≤ 10^9): The modulus. # Output: - An integer representing the result of `(a ^ n) % mod`. # Constraints: 1. The implementation should run efficiently with a time complexity of O(log(n)). 2. You should handle large values of `n` up to 10^18 without causing overflow. 3. You need to ensure the solution is optimized to work within the given constraints without exceeding the memory limits. # Example: ```python assert modular_exponentiation(2, 10, 1000) == 24 assert modular_exponentiation(2, 0, 1000) == 1 assert modular_exponentiation(2, 5, 13) == 6 ``` # Hints: 1. Use the technique of binary exponentiation to achieve an efficient solution. 2. Ensure to apply the modulo operation correctly at appropriate steps to keep the numbers manageable.","solution":"def modular_exponentiation(a: int, n: int, mod: int) -> int: Calculate (a ^ n) % mod using binary exponentiation. Parameters: a (int): base number. n (int): exponent. mod (int): modulus. Returns: int: result of (a ^ n) % mod. result = 1 a = a % mod # Update `a` if it is more than or equal to `mod` while n > 0: if n % 2 == 1: # If `n` is odd, multiply `a` with result result = (result * a) % mod # `n` must be even now n = n >> 1 # `n` = n // 2 a = (a * a) % mod # Change `a` to `a^2 % mod` return result"},{"question":"**Context**: You have been assigned the task of developing a simplified search tool for a small project. The biggest constraint is that the tool must be able to search through unsorted data because sorting is not feasible due to time constraints. **Task**: Write a function named `linear_search_index` that takes two arguments, a list of integers and the search query integer. The function should return the index of the first occurrence of the search query in the list. If the query is not found, return -1. The function should be robust enough to handle empty lists and lists with duplicate entries. **Function Signature**: ```python def linear_search_index(nums: List[int], query: int) -> int: pass ``` **Input Format**: - `nums`: List of integers, can contain negative or positive values and can be of any length (including empty). - `query`: An integer to be searched for in the list `nums`. **Output Format**: - Integer indicating the index of the first occurrence of `query` in `nums` or -1 if not found. **Constraints**: - The list `nums` can have a length of up to 10^6. - Each element of `nums` is an integer in the range (−10^9 to 10^9). - The search query `query` is also an integer within the same range. **Example**: ```python assert linear_search_index([1, 3, 5, 7, 9], 7) == 3 assert linear_search_index([4, 2, 1, 7, 8, 7, 10], 7) == 3 assert linear_search_index([5, 5, 5, 5], 5) == 0 assert linear_search_index([], 1) == -1 assert linear_search_index([8, 15, 23, 42, 108], 99) == -1 ``` **Explanation**: - In the first example, `7` is found at index `3`. - In the second example, `7` first appears at index `3`. - In the third example, `5` appears multiple times but only the first occurrence at index `0` is returned. - In the fourth example, the list is empty, so `-1` is returned. - In the fifth example, `99` is not in the list, so `-1` is returned. Implement the function considering the complexity analysis and edge cases discussed.","solution":"from typing import List def linear_search_index(nums: List[int], query: int) -> int: Returns the index of the first occurrence of the search query in the list. If the query is not found, returns -1. for index, num in enumerate(nums): if num == query: return index return -1"},{"question":"# B-tree Data Structure Implementation As a database software engineer, you have been assigned to manage a B-tree data structure that efficiently handles a large volume of data for a high-performance database system. Your task is to implement the core B-tree functionalities: insertion, deletion, and search. The B-tree should maintain the following invariants: 1. Every node (except root) contains at least `t - 1` keys and at most `2*t - 1` keys. 2. The root node can contain at least 1 key and at most `2*t - 1` keys. 3. All leaves have the same depth. Required Functions 1. **Insertion**: Implement the method `insert_key(key)` to insert a new key into the B-tree. 2. **Deletion**: Implement the method `remove_key(key)` to remove a key from the B-tree. 3. **Search**: Implement the method `find(key)` to search a key in the B-tree. It should return `True` if the key is found, and `False` otherwise. 4. **Traversal**: Implement the method `traverse_tree()` to traverse and print the keys in the B-tree in non-decreasing order. Input and Output Formats * **Insert Key**: * Input: `key` (Integer) * Output: None * **Remove Key**: * Input: `key` (Integer) * Output: None * **Search Key**: * Input: `key` (Integer) * Output: `True` or `False` * **Traverse Tree**: * Input: None * Output: Print the keys in non-decreasing order Constraints * Degree `t` should be greater than 1. * Keys will be unique and non-negative integers. You must ensure that the data structure operates efficiently even under the constraints of large input sizes.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node, else False self.keys = [] # list of keys self.children = [] # list of child node pointers class BTree: def __init__(self, t): self.root = None # root node self.t = t # Minimum degree def traverse_tree(self): if self.root is not None: self._traverse(self.root) print() def _traverse(self, node): i = 0 while i < len(node.keys): if not node.leaf: self._traverse(node.children[i]) print(node.keys[i], end=\\" \\") i += 1 if not node.leaf: self._traverse(node.children[i]) def find(self, k): return self._find(self.root, k) if self.root is not None else False def _find(self, node, k): i = 0 while i < len(node.keys) and k > node.keys[i]: i += 1 if i < len(node.keys) and node.keys[i] == k: return True if node.leaf: return False return self._find(node.children[i], k) def insert_key(self, k): if self.root is None: self.root = BTreeNode(self.t, True) self.root.keys = [k] else: if len(self.root.keys) == 2 * self.t - 1: s = BTreeNode(self.t, False) s.children.append(self.root) self._split_child(s, 0) self._insert_non_full(s, k) self.root = s else: self._insert_non_full(self.root, k) def _insert_non_full(self, node, k): i = len(node.keys) - 1 if node.leaf: node.keys.append(0) while i >= 0 and k < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = k else: while i >= 0 and k < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == 2 * self.t - 1: self._split_child(node, i) if k > node.keys[i]: i += 1 self._insert_non_full(node.children[i], k) def _split_child(self, node, i): t = self.t y = node.children[i] z = BTreeNode(t, y.leaf) node.children.insert(i + 1, z) node.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t:2 * t - 1] y.keys = y.keys[0:t - 1] if not y.leaf: z.children = y.children[t:2 * t] y.children = y.children[0:t] def remove_key(self, k): if self.root is None: return self._remove(self.root, k) if len(self.root.keys) == 0: if not self.root.leaf: self.root = self.root.children[0] else: self.root = None def _remove(self, node, k): t = self.t idx = self._find_key(node, k) if idx < len(node.keys) and node.keys[idx] == k: if node.leaf: node.keys.pop(idx) else: self._remove_from_non_leaf(node, idx) else: if node.leaf: return flag = (idx == len(node.keys)) if len(node.children[idx].keys) < t: self._fill(node, idx) if flag and idx > len(node.keys): self._remove(node.children[idx - 1], k) else: self._remove(node.children[idx], k) def _remove_from_non_leaf(self, node, idx): k = node.keys[idx] t = self.t if len(node.children[idx].keys) >= t: pred = self._get_pred(node, idx) node.keys[idx] = pred self._remove(node.children[idx], pred) elif len(node.children[idx + 1].keys) >= t: succ = self._get_succ(node, idx) node.keys[idx] = succ self._remove(node.children[idx + 1], succ) else: self._merge(node, idx) self._remove(node.children[idx], k) def _get_pred(self, node, idx): current = node.children[idx] while not current.leaf: current = current.children[len(current.keys)] return current.keys[len(current.keys) - 1] def _get_succ(self, node, idx): current = node.children[idx + 1] while not current.leaf: current = current.children[0] return current.keys[0] def _fill(self, node, idx): t = self.t if idx != 0 and len(node.children[idx - 1].keys) >= t: self._borrow_from_prev(node, idx) elif idx != len(node.keys) and len(node.children[idx + 1].keys) >= t: self._borrow_from_next(node, idx) else: if idx != len(node.keys): self._merge(node, idx) else: self._merge(node, idx - 1) def _borrow_from_prev(self, node, idx): child = node.children[idx] sibling = node.children[idx - 1] for i in range(len(child.keys) - 1, -1, -1): child.keys[i + 1] = child.keys[i] if not child.leaf: for i in range(len(child.children) - 1, -1, -1): child.children[i + 1] = child.children[i] child.keys[0] = node.keys[idx - 1] if not child.leaf: child.children[0] = sibling.children[len(sibling.keys)] node.keys[idx - 1] = sibling.keys.pop() child.keys.insert(0, sibling.keys.pop()) def _borrow_from_next(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys[idx]) if not child.leaf: child.children.append(sibling.children[0]) node.keys[idx] = sibling.keys.pop(0) if not sibling.leaf: sibling.children.pop(0) def _merge(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys.pop(idx)) for i in range(len(sibling.keys)): child.keys.append(sibling.keys[i]) if not child.leaf: for i in range(len(sibling.children)): child.children.append(sibling.children[i]) node.children.pop(idx + 1) def _find_key(self, node, k): idx = 0 while idx < len(node.keys) and node.keys[idx] < k: idx += 1 return idx"},{"question":"# Matrix Exponentiation - Efficient Algorithm You are tasked with implementing the matrix exponentiation algorithm efficiently using the concepts from matrix multiplication and identity matrix creation. Given a square matrix of size `d x d` and an integer `n`, compute the matrix raised to the power `n` using repeated squaring. Function Signature ```python def efficient_matrix_exponentiation(matrix: list, n: int) -> list: pass ``` Input 1. `matrix`: A list of lists (nested list) where each sublist represents a row of the square matrix. The size of the matrix is `d x d` where `1 <= d <= 100`. 2. `n`: An integer, the power to which the matrix must be raised, where `0 <= n <= 10^9`. Output - Returns a list of lists representing the matrix raised to the power `n`. Constraints - The matrix contains integers where `-100 <= element <= 100`. - Performance is crucial; consider the complexity provided in the analysis. # Example ```python matrix = [ [1, 2], [3, 4] ] n = 2 result = efficient_matrix_exponentiation(matrix, n) # result should be: # [ # [7, 10], # [15, 22] # ] ``` # Notes - If `n == 0`, return the identity matrix of the same dimension. - Use the given helper functions or create optimized versions if needed. Objective Implement the `efficient_matrix_exponentiation` function ensuring optimal performance and correct handling of edge cases.","solution":"def efficient_matrix_exponentiation(matrix, n): Computes the matrix raised to the power n using efficient matrix exponentiation. def matrix_multiply(A, B): Multiplies two matrices A and B. d = len(A) result = [[0] * d for _ in range(d)] for i in range(d): for j in range(d): for k in range(d): result[i][j] += A[i][k] * B[k][j] return result def identity_matrix(size): Creates an identity matrix of given size. return [[1 if i == j else 0 for j in range(size)] for i in range(size)] def matrix_power(matrix, n): Efficiently computes matrix to the power of n using repeated squaring. if n == 0: return identity_matrix(len(matrix)) elif n == 1: return matrix else: half_power = matrix_power(matrix, n // 2) half_power_squared = matrix_multiply(half_power, half_power) if n % 2 != 0: return matrix_multiply(half_power_squared, matrix) else: return half_power_squared return matrix_power(matrix, n)"},{"question":"# Matrix Multiplication Function Write a Python function `matrix_multiply(A, B)` that multiplies two two-dimensional matrices `A` and `B`. Function Signature ```python def matrix_multiply(A: list, B: list) -> list: pass ``` Input * `A`: A list of lists where each inner list represents a row of the first matrix. It contains integers. * `B`: A list of lists where each inner list represents a row of the second matrix. It contains integers. Output * Return a new list of lists representing the product of the two given matrices. Constraints * Matrices `A` and `B` will have dimensions that are compatible for multiplication. * Both matrices will contain integers in the range of [-100, 100]. * Elements of matrices will fit within the standard 32-bit integer range. Example ```python A = [ [1, 2], [3, 4] ] B = [ [5, 6], [7, 8] ] matrix_multiply(A, B) # Should return: # [ # [19, 22], # [43, 50] # ] ``` Explanation * Row 1 of Matrix A x Column 1 of Matrix B = 1*5 + 2*7 = 5 + 14 = 19 * Row 1 of Matrix A x Column 2 of Matrix B = 1*6 + 2*8 = 6 + 16 = 22 * Continue for remaining rows and columns. Notes * Your function should raise an `Exception` with the message `\\"Incompatible matrices\\"` if the matrices cannot be multiplied due to dimension mismatch. * Aim for a solution that is clear and easy to understand, even if it is not the most optimized.","solution":"def matrix_multiply(A, B): Multiplies two matrices A and B. Args: A (list of lists of int): The first matrix to be multiplied. B (list of lists of int): The second matrix to be multiplied. Returns: list of lists of int: The resulting matrix product. Raises: Exception: If the matrices cannot be multiplied due to incompatible dimensions. # Get the number of rows and columns for A and B rows_A, cols_A = len(A), len(A[0]) rows_B, cols_B = len(B), len(B[0]) # Check if the matrices can be multiplied if cols_A != rows_B: raise Exception(\\"Incompatible matrices\\") # Initialize the result matrix with zeroes result = [[0 for _ in range(cols_B)] for _ in range(rows_A)] # Perform the matrix multiplication for i in range(rows_A): for j in range(cols_B): for k in range(cols_A): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"# Scenario: You are working at a software company that handles large financial transactions. As part of the system, you need to develop a feature that can multiply very large numbers represented as strings, since the transactions can be very large and using traditional integer types might result in overflow or inadequate precision. # Task: Write a function `multiply(num1: str, num2: str) -> str` that takes two non-negative integers represented as strings (`num1` and `num2`) and returns their product also as a string. # Constraints: * The length of both `num1` and `num2` is less than 110. * Both `num1` and `num2` contain only digits 0-9. * Both `num1` and `num2` do not contain any leading zero (except when the number itself is zero). # Performance Requirements: * The solution should have a time complexity of O(n * m) where n and m are the lengths of `num1` and `num2` respectively. * Space complexity should be O(n + m) due to holding the intermediate results. # Example: ```plaintext multiply(\\"123\\", \\"456\\") -> \\"56088\\" multiply(\\"0\\", \\"789\\") -> \\"0\\" multiply(\\"99\\", \\"99\\") -> \\"9801\\" multiply(\\"111\\", \\"0\\") -> \\"0\\" ``` # Notes: - You **must not** use any built-in BigInteger library or convert the inputs directly to integer types. # Requirements: * Input: num1 and num2 - non-negative integers represented as strings of digits with length < 110. * Output: The product of `num1` and `num2` as a string. Function Signature: ```python def multiply(num1: str, num2: str) -> str: ``` # Questions for Consideration: 1. How do you handle multiplication when one of the numbers is \'0\'? 2. How can you efficiently handle the carrying during addition of products? 3. What is the best way to accumulate the intermediate sums to build the final product as a string? Implement your solution in Python below: ```python def multiply(num1: str, num2: str) -> str: # Your code goes here ```","solution":"def multiply(num1: str, num2: str) -> str: if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" n1, n2 = len(num1), len(num2) result = [0] * (n1 + n2) for i in reversed(range(n1)): for j in reversed(range(n2)): product = int(num1[i]) * int(num2[j]) temp_sum = result[i + j + 1] + product result[i + j + 1] = temp_sum % 10 result[i + j] += temp_sum // 10 # Convert result list to string, and strip leading zeros result_string = \'\'.join(map(str, result)).lstrip(\'0\') return result_string if result_string else \\"0\\""},{"question":"You are tasked with enhancing a system that performs real-time analysis of streaming data. Specifically, you need to implement a more efficient version of the `MovingAverage` class. The current implementation recalculates the sum of the elements in the window every time a new element is added, which can be inefficient for large window sizes. Your task is to optimize this to ensure that each operation `next` takes constant time. Your task: Implement the `MovingAverage` class with the following API: 1. **`__init__(self, size: int)`**: Initializes an instance of the MovingAverage class with a window size `size`. 2. **`next(self, val: int) -> float`**: Adds `val` to the moving window and returns the moving average of the last `size` elements. # Constraints: - The window size `size` will be at least 1 and at most 10^4. - The elements passed to `next` will be integers between -10^4 and 10^4. - At most 10^5 calls will be made to the `next` method. # Input/Output: - **Input**: - An integer `size` for the window on initialization. - Multiple integer values through the `next` method. - **Output**: - The moving average as a float for each call to `next`. # Performance Requirements: - Your implementation should ensure that adding an element and calculating the moving average happens in `O(1)` time on average. # Example: ```python m = MovingAverage(3) print(m.next(1)) # Output: 1.0 print(m.next(10)) # Output: 5.5 print(m.next(3)) # Output: 4.67 print(m.next(5)) # Output: 6.0 ``` # Edge Cases to Consider: - Initial fewer elements than the window size. - Handling of negative values or zero.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): self.size = size self.window = deque() self.window_sum = 0 self.count = 0 def next(self, val: int) -> float: self.count += 1 # Add new value to the window self.window.append(val) self.window_sum += val # Maintain the size of the window if self.count > self.size: removed = self.window.popleft() self.window_sum -= removed self.count -= 1 # Calculate and return the moving average return self.window_sum / self.count"},{"question":"Context You are tasked with creating a feature for a data processing system that can filter out unwanted values from a dataset of numerical readings. This system must allow users to set a minimum and/or maximum filter range to clean data before further analysis or storing it. Problem Statement Write a function `filtered_data(dataset, lower_bound, upper_bound)` that filters out the values from the given dataset that fall outside the specified `lower_bound` and `upper_bound`. If `lower_bound` or `upper_bound` is `None`, that bound is considered to be unlimited. Function Signature ```python def filtered_data(dataset, lower_bound=None, upper_bound=None): pass ``` Input * `dataset`: A list of numerical values (e.g., `[10, 20, 30, 40, 50]`). * `lower_bound`: An integer or float, the lower bound for filtering (inclusive). If `None`, do not apply any lower bound. * `upper_bound`: An integer or float, the upper bound for filtering (inclusive). If `None`, do not apply any upper bound. Output * Returns a list of numerical values filtered according to the provided bounds. Constraints * The dataset can be empty. * Elements in the dataset are guaranteed to be comparable (no mixed types). * You must optimize for readability and efficiency. * You may assume the dataset fits into memory. Examples 1. `filtered_data([1, 2, 3, 4, 5], None, 3)` should return `[1, 2, 3]`. 2. `filtered_data([10, 20, 30, 40, 50], 15, 45)` should return `[20, 30, 40]`. 3. `filtered_data([1, 2, 3, 4, 5], 10, None)` should return `[]`. 4. `filtered_data([], None, 100)` should return `[]`. Notes * If both `lower_bound` and `upper_bound` are `None`, the original dataset should be returned unchanged. * If all elements fall outside the bound(s), return an empty list. Write your function implementation below:","solution":"def filtered_data(dataset, lower_bound=None, upper_bound=None): Filters out the values from the dataset that fall outside the specified lower_bound and upper_bound. Args: - dataset: A list of numerical values. - lower_bound: An integer or float, the lower bound for filtering (inclusive). If None, no lower bound is applied. - upper_bound: An integer or float, the upper bound for filtering (inclusive). If None, no upper bound is applied. Returns: - A list of numerical values filtered according to the provided bounds. if lower_bound is None and upper_bound is None: return dataset filtered = [] for value in dataset: if (lower_bound is not None and value < lower_bound): continue if (upper_bound is not None and value > upper_bound): continue filtered.append(value) return filtered"},{"question":"# AVL Tree Insertion and Deletion You are given the structure of an AVL tree that supports insertion, rotation, and in-order traversal operations. Extend this class to support deletion of a node with a given key while maintaining the AVL tree properties. Objective: Implement a method `delete(self, key: int)` to remove a node with the given key from the AVL tree. Ensure the tree remains balanced after the node is removed. # Input format: * A series of operations to be performed on the AVL tree, starting with insertion of keys and followed by deletions. All keys are distinct integers. # Output format: * An in-order traversal of the AVL tree after the final operation (either insertion or deletion). # Constraints: * Key values are limited to integer values within the range ([-10^4, 10^4]). * The number of operations will not exceed (10^3). # Performance requirements: - Your implementation should maintain (O(log n)) average-case time complexity for insertions and deletions. # Example: ```python # Example usage: avl = AvlTree() avl.insert(10) avl.insert(20) avl.insert(30) avl.insert(40) avl.insert(50) avl.insert(25) avl.delete(20) print(avl.in_order_traverse()) # Output: [10, 25, 30, 40, 50] ``` Note: * Ensure that the AVL tree remains balanced after each deletion operation. * Handle the edge cases like deleting a non-existent key gracefully.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def insert(self, root, key): if not root: return TreeNode(key) elif key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) if balance > 1 and key < root.left.key: return self.right_rotate(root) if balance < -1 and key > root.right.key: return self.left_rotate(root) if balance > 1 and key > root.left.key: root.left = self.left_rotate(root.left) return self.right_rotate(root) if balance < -1 and key < root.right.key: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def delete(self, root, key): if not root: return root if key < root.key: root.left = self.delete(root.left, key) elif key > root.key: root.right = self.delete(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left temp = self.get_min_value_node(root.right) root.key = temp.key root.right = self.delete(root.right, temp.key) if root is None: return root root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) if balance > 1 and self.get_balance(root.left) >= 0: return self.right_rotate(root) if balance > 1 and self.get_balance(root.left) < 0: root.left = self.left_rotate(root.left) return self.right_rotate(root) if balance < -1 and self.get_balance(root.right) <= 0: return self.left_rotate(root) if balance < -1 and self.get_balance(root.right) > 0: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def get_height(self, root): if not root: return 0 return root.height def get_balance(self, root): if not root: return 0 return self.get_height(root.left) - self.get_height(root.right) def left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def get_min_value_node(self, root): if root is None or root.left is None: return root return self.get_min_value_node(root.left) def in_order_traverse(self, root, result=None): if result is None: result = [] if root: self.in_order_traverse(root.left, result) result.append(root.key) self.in_order_traverse(root.right, result) return result # Wrapper class to interact with the AvlTree class class AVL: def __init__(self): self.root = None self.tree = AvlTree() def insert(self, key): self.root = self.tree.insert(self.root, key) def delete(self, key): self.root = self.tree.delete(self.root, key) def in_order_traverse(self): return self.tree.in_order_traverse(self.root)"},{"question":"You have been provided with a function that approximates the square root of a positive integer ( N ) using the Babylonian method. Your task is to extend this function to handle a list of numbers and return their respective square root approximations, each with a maximum absolute error ( epsilon ). # Requirements: 1. **Function Name**: `batch_square_root` 2. **Input**: A list of positive integers `numbers`, and an optional precision factor `epsilon` (default is 0.001). 3. **Output**: A list of approximate square roots for each of the input numbers. # Constraints: - ( 1 leq N leq 10^6 ) - ( 0 < epsilon leq 0.01 ) # Function Signature: ```python def batch_square_root(numbers: list, epsilon: float = 0.001) -> list: pass ``` # Example: ```python numbers = [4, 16, 25, 100] epsilon = 0.01 # Expected output: # [2.0 (approx.), 4.0 (approx.), 5.0 (approx.), 10.0 (approx.)] approx_roots = batch_square_root(numbers, epsilon) ``` # Notes: - Ensure that each calculated square root has a maximum absolute error of ( epsilon ). - Optimize for performance, considering the typical use case of processing large lists. - Handle edge cases where value of `epsilon` might be very small.","solution":"def babylonian_sqrt(N, epsilon=0.001): guess = N / 2.0 while True: next_guess = (guess + N / guess) / 2.0 if abs(next_guess - guess) < epsilon: return next_guess guess = next_guess def batch_square_root(numbers, epsilon=0.001): return [babylonian_sqrt(num, epsilon) for num in numbers]"},{"question":"Digit Counting Function As part of a larger application, you are tasked with implementing a utility function to determine the number of digits in a given integer. You are required to implement this function efficiently in O(1) time complexity. # Function Signature ```python def digit_count(n: int) -> int: Returns the number of digits in the given integer. :param n: An integer (can be positive, negative, or zero) :return: Number of digits in the integer ``` # Input - `n` (int): An integer which can be positive, negative, or zero. # Output - An integer representing the number of digits in the input integer. # Constraints - The function should run in constant time complexity O(1). - Do not use string conversion methods as part of the solution. # Examples ```python print(digit_count(12345)) # Output: 5 print(digit_count(-12345)) # Output: 5 print(digit_count(0)) # Output: 1 print(digit_count(999999999)) # Output: 9 ``` # Notes - Ensure handling of edge cases like zero and negative numbers. - Consider the properties of logarithms in your solution.","solution":"import math def digit_count(n: int) -> int: Returns the number of digits in the given integer. :param n: An integer (can be positive, negative, or zero) :return: Number of digits in the integer if n == 0: return 1 return int(math.log10(abs(n))) + 1"},{"question":"Given a singly linked list, write a function to determine if the list contains a cycle. A cycle occurs if a node\'s next reference points to any previous node in the list. You should solve this problem using a Floyd’s Tortoise and Hare algorithm. You must ensure your solution uses constant space and linear time complexity. Function Signature ```python def has_cycle(head: Node) -> bool: ``` Input * `head` (`Node`): The head node of a singly linked list. Output * `bool`: Returns `True` if there is a cycle in the linked list, `False` otherwise. Constraints * The number of nodes in the list can be as large as a typical machine’s memory can handle. * Nodes are compared by their memory addresses. Example ```python class Node: def __init__(self, x): self.val = x self.next = None # Example 1 # Input: 1 -> 2 -> 3 -> 4 -> 2 (cycle here) # Output: True n1 = Node(1) n2 = Node(2) n3 = Node(3) n4 = Node(4) n1.next = n2 n2.next = n3 n3.next = n4 n4.next = n2 # cycle print(has_cycle(n1)) # True # Example 2 # Input: 1 -> 2 -> 3 -> 4 (no cycle) # Output: False n1.next = n2 n2.next = n3 n3.next = n4 n4.next = None # no cycle print(has_cycle(n1)) # False ``` Notes * Your function must perform the task in linear time complexity and use constant space. * Consider edge cases such as an empty list or a single node pointing to itself. Good luck and ensure your code is clean and efficient!","solution":"class Node: def __init__(self, x): self.val = x self.next = None def has_cycle(head: Node) -> bool: Determine if the linked list contains a cycle using Floyd\'s Tortoise and Hare algorithm. :param head: Node - The head node of a singly linked list. :return: bool - Returns True if there is a cycle in the linked list, False otherwise. if not head or not head.next: return False slow = head fast = head.next while fast and fast.next: if slow == fast: return True slow = slow.next fast = fast.next.next return False"},{"question":"Implement a function `reverse_string(s)` that reverses a given input string `s`. Your function should efficiently handle strings of varying lengths using an iterative approach with the two-pointer technique. Input Format - A single string `s` with a length constraint: `1 <= len(s) <= 10^4`. Output Format - A single string that is the reverse of `s`. Constraints - The string `s` consists of printable ASCII characters. Performance Requirements - Your solution must run in O(n) time and use O(1) additional space (excluding the space used to store the input and output). # Example ``` Input: \\"hello\\" Output: \\"olleh\\" Input: \\"A man, a plan, a canal, Panama!\\" Output: \\"!amanaP ,lanac a ,nalp a ,nam A\\" ``` # Edge Cases - Single-character strings should return the same string. - Empty string should return an empty string. # Implementation Notes - Utilize an iterative approach, efficiently swapping characters in place to achieve the desired result.","solution":"def reverse_string(s): Reverses the input string s using an iterative approach with the two-pointer technique. Args: s (str): The string to be reversed. Returns: str: The reversed string. # Convert string to list to allow in-place modifications s_list = list(s) # Initialize two pointers left, right = 0, len(s_list) - 1 # Swap characters until the pointers meet in the middle while left < right: # Swap characters at left and right pointers s_list[left], s_list[right] = s_list[right], s_list[left] # Move the pointers towards the center left += 1 right -= 1 # Convert list back to string and return return \'\'.join(s_list)"},{"question":"**Insertion Sort Algorithm Implementation with Enhancements** Context You\'ve been tasked with enhancing the basic Insertion Sort algorithm to handle some special cases and provide more flexibility in its application. Objective Write a function `custom_insertion_sort` that extends the basic functionality of the provided Insertion Sort algorithm by incorporating the following enhancements: 1. **Early Termination:** If the array becomes sorted before completing all iterations, the algorithm should terminate early. 2. **Handling Negative Numbers:** Ensure the algorithm correctly handles arrays containing negative numbers. 3. **Output Details:** Optionally output detailed states of the array at each step of the sorting process for educational or debugging purposes (controlled by a parameter). Requirements * **Function Signature**: ```python def custom_insertion_sort(arr: list, simulation: bool = False) -> list: ``` * **Input**: * `arr`: A list of integers (which may include negative numbers). * `simulation`: A boolean flag indicating whether to output the array\'s state at each step. * **Output**: * A list of integers sorted in non-decreasing order. * **Constraints**: * The input list can contain duplicates and negative numbers. * 0 <= len(arr) <= 10^3 Example ```python # Example 1 assert custom_insertion_sort([3, 1, 2], True) == [1, 2, 3] # Output Simulation: # iteration 0 : 3 1 2 # iteration 1 : 1 3 2 # iteration 2 : 1 2 3 # Example 2 assert custom_insertion_sort([-1, -3, -2, 0, 2], False) == [-3, -2, -1, 0, 2] # Example 3 assert custom_insertion_sort([1, 2, 3, 4, 5], True) == [1, 2, 3, 4, 5] # Output Simulation: # iteration 0 : 1 2 3 4 5 ``` **Note**: * Implement early termination to optimize performance on already sorted arrays. * Ensure the function maintains sorting stability.","solution":"def custom_insertion_sort(arr: list, simulation: bool = False) -> list: Sorts a list of integers using an enhanced Insertion Sort algorithm. Features: Early termination, handles negative numbers, and optional simulation mode. Parameters: - arr: list of integers to be sorted. - simulation: optional boolean to print array state at each step. Returns: - sorted list of integers. n = len(arr) for i in range(1, n): key = arr[i] j = i - 1 sorted_before_step = True while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 sorted_before_step = False arr[j + 1] = key if simulation: print(f\'iteration {i} : {\\" \\".join(map(str, arr))}\') # Early termination check if sorted_before_step and i == n - 1: break return arr"},{"question":"# Coding Challenge: Digit Array Increment You are given an array `digits` where each element is a single digit representing a large non-negative integer. The array is arranged in a way such that the most significant digit is at the beginning of the list. Your task is to write a function `increment_digits` that computes an increment of one to the entire number. **Function Signature**: ```python def increment_digits(digits: List[int]) -> List[int]: pass ``` Input * `digits` (1 <= len(digits) <= 1000): A list containing non-negative integers representing digits `[0-9]`. Output * Return the resulting list of digits after adding one to the input number. Example ```python assert increment_digits([1, 2, 3]) == [1, 2, 4] assert increment_digits([4, 3, 2, 1]) == [4, 3, 2, 2] assert increment_digits([9]) == [1, 0] assert increment_digits([9, 9, 9]) == [1, 0, 0, 0] ``` Constraints * You must handle carry operations efficiently. * The digits should be modified in place if possible to optimize space complexity. Implement the `increment_digits` function to satisfy the examples above and meet the specified constraints.","solution":"from typing import List def increment_digits(digits: List[int]) -> List[int]: Increment the integer represented by the list of digits by one and return the new list of digits. n = len(digits) # Traverse from the end to the beginning for i in range(n - 1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits else: digits[i] = 0 # If all digits were 9, we would have rolled over to a new place value return [1] + digits"},{"question":"# Question: Implement and Extend Gnome Sort You are given a simplistic sorting algorithm called Gnome Sort. While the implementation is provided, your task is to extend its functionality to handle various edge cases and optimize its performance for specific input types. Task 1. Implement the `gnome_sort` function with the same logic detailed below: ```python def gnome_sort(arr): n = len(arr) index = 0 while index < n: if index == 0 or arr[index] >= arr[index-1]: index += 1 else: arr[index], arr[index-1] = arr[index-1], arr[index] index -= 1 return arr ``` 2. Write a function to handle and test the following cases: * An already sorted array. * An array with all identical elements. * An array in reverse order. * An array with a single element or no elements. 3. Optimize the Gnome Sort to minimize redundant operations without compromising its fundamental methodology. 4. Ensure your implementation: * Handles edge cases effectively. * Does not use more advanced sorting techniques directly. Input * An integer array `arr` of length up to 10^4. Output * The sorted array in non-decreasing order. Constraints * The input array can contain negative integers. * The length of the array will be between 0 and 10^4 elements. Example ```python # Example 1 Input: [34, 2, 23, -4, 7] Output: [-4, 2, 7, 23, 34] # Example 2 Input: [1, 1, 1, 1, 1] Output: [1, 1, 1, 1, 1] # Example 3 Input: [] Output: [] # Example 4 Input: [10] Output: [10] ```","solution":"def gnome_sort(arr): Perform gnome sort on the input list and return the sorted list. Args: arr (list): The list to be sorted. Returns: list: The sorted list. n = len(arr) index = 0 while index < n: if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr def optimized_gnome_sort(arr): Perform an optimized gnome sort on the input list and return the sorted list. Args: arr (list): The list to be sorted. Returns: list: The sorted list. n = len(arr) index = 0 last_swap_index = 0 # This will help to avoid redundant operations. while index < n: if index == 0 or arr[index] >= arr[index - 1]: if index == last_swap_index: index += 1 else: last_swap_index = index index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"You are required to write a function that converts an integer to bytes representation in both big-endian and little-endian formats, and vice versa. Then you must verify that converting from integer to bytes and back to integers yields the original value in both endian formats. **Objective**: Demonstrate an understanding of integer-to-byte conversion algorithms and validate the correct implementation via round-trip conversions. Task 1. Implement the following functions: - `int_to_bytes_big_endian(num: int) -> bytes` - `int_to_bytes_little_endian(num: int) -> bytes` - `bytes_big_endian_to_int(bytestr: bytes) -> int` - `bytes_little_endian_to_int(bytestr: bytes) -> int` 2. Ensure these functions adhere to the big-endian and little-endian byte orders: - **Big-endian**: Most significant byte first. - **Little-endian**: Least significant byte first. 3. Write a verification function: - `verify_conversion(num: int) -> bool` The `verify_conversion` function should: - Convert the given integer `num` to bytes using both big-endian and little-endian formats. - Convert those bytes back to an integer. - Confirm that the resulting integers match the original integer. Requirements - Function `int_to_bytes_big_endian` should use `collections.deque` for efficiency in inserting bytes at the beginning. - Functions should handle typical integer ranges without raising errors. - Provide an explanation if handling the number zero or extremely large integers differently. Input - Two non-negative integers ranging from 0 to 2^32 - 1. Output - Boolean `True` if conversion functions are correct; otherwise `False`. Example ```python def int_to_bytes_big_endian(num: int) -> bytes: # Your implementation here pass def int_to_bytes_little_endian(num: int) -> bytes: # Your implementation here pass def bytes_big_endian_to_int(bytestr: bytes) -> int: # Your implementation here pass def bytes_little_endian_to_int(bytestr: bytes) -> int: # Your implementation here pass def verify_conversion(num: int) -> bool: # Your implementation here pass # Example usage print(verify_conversion(305419896)) # Should print: True print(verify_conversion(0)) # Should print: True ``` **Constraints**: - You may assume input values are non-negative integers. - Performance should be considered for large values within the provided range.","solution":"from collections import deque def int_to_bytes_big_endian(num: int) -> bytes: Converts an integer to its byte representation in big-endian format. if num == 0: return b\'x00\' result = deque() while num: result.appendleft(num & 0xff) num >>= 8 return bytes(result) def int_to_bytes_little_endian(num: int) -> bytes: Converts an integer to its byte representation in little-endian format. if num == 0: return b\'x00\' result = bytearray() while num: result.append(num & 0xff) num >>= 8 return bytes(result) def bytes_big_endian_to_int(bytestr: bytes) -> int: Converts a bytes object in big-endian format back to an integer. result = 0 for byte in bytestr: result = (result << 8) | byte return result def bytes_little_endian_to_int(bytestr: bytes) -> int: Converts a bytes object in little-endian format back to an integer. result = 0 for i, byte in enumerate(bytestr): result |= byte << (i * 8) return result def verify_conversion(num: int) -> bool: Verifies the conversion of an integer to bytes and back to an integer in both big-endian and little-endian formats. big_endian_bytes = int_to_bytes_big_endian(num) little_endian_bytes = int_to_bytes_little_endian(num) big_endian_int = bytes_big_endian_to_int(big_endian_bytes) little_endian_int = bytes_little_endian_to_int(little_endian_bytes) return big_endian_int == num and little_endian_int == num"},{"question":"# Coding Task Context You are working with a stack of integers and need to perform an operation that will replace every value in the stack with two occurrences of the same value. You need to implement this operation in two different ways: using an auxiliary stack and using an auxiliary queue. Problem Statement Write two functions, `first_stutter` and `second_stutter`, that perform the described operation using a stack and a queue respectively. Function Signatures ```python def first_stutter(stack: List[int]) -> List[int]: pass def second_stutter(stack: List[int]) -> List[int]: pass ``` Input - A list of integers representing the stack, where the last element in the list is considered the top of the stack. Output - A list of integers, where each element in the input stack is replaced by two occurrences of the same value, maintaining the same order. Constraints - You may assume that the input stack contains at most 1000 integers. - The values in the stack range from -10^6 to 10^6. - Do not use any additional data structures besides those explicitly allowed in the problem statement. Examples ```python # Example 1: input_stack = [3, 7, 1, 14, 9] output_stack = [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] assert first_stutter(input_stack) == output_stack assert second_stutter(input_stack) == output_stack # Example 2: input_stack = [5, -6, 12] output_stack = [5, 5, -6, -6, 12, 12] assert first_stutter(input_stack) == output_stack assert second_stutter(input_stack) == output_stack # Example 3: input_stack = [] output_stack = [] assert first_stutter(input_stack) == output_stack assert second_stutter(input_stack) == output_stack # Example 4: input_stack = [7] output_stack = [7, 7] assert first_stutter(input_stack) == output_stack assert second_stutter(input_stack) == output_stack ``` Performance Requirements - The implemented solution should run in linear time, O(n), and use O(n) additional space in the worst-case scenario where n is the number of elements in the stack. Edge Cases to Consider 1. An empty stack. 2. A stack with only one element. 3. A stack with repeated elements. 4. A large stack nearing the upper constraint of 1000 elements. Please write your functions while adhering strictly to the constraints and requirements specified.","solution":"from typing import List from collections import deque def first_stutter(stack: List[int]) -> List[int]: This function replaces every value in the stack with two occurrences of the same value using an auxiliary stack. aux_stack = [] while stack: element = stack.pop() aux_stack.append(element) aux_stack.append(element) # Reverse back into the original stack while aux_stack: stack.append(aux_stack.pop()) return stack def second_stutter(stack: List[int]) -> List[int]: This function replaces every value in the stack with two occurrences of the same value using an auxiliary queue. queue = deque() while stack: element = stack.pop() queue.appendleft(element) queue.appendleft(element) # Return the elements back into the stack stack.extend(queue) return stack"},{"question":"# Question: Symbol Matching in Words Given an array of words and an array of symbols, your task is to write a function `insert_symbols` that processes each word and surrounds the longest matching symbol within the word with square brackets. If a word matches more than one symbol, the symbol with the longest length should be chosen. If no symbol matches, the word should remain unchanged. Input: - `words`: A list of strings, where each string is a word. - `symbols`: A list of strings, where each string is a symbol. Output: - A list of strings where each word has the longest matching symbol surrounded by square brackets. Constraints: - Each word and each symbol will only contain alphabetical characters. - The length of `symbols` will be between 1 and 1000 (inclusive). - The length of `words` will be between 1 and 1000 (inclusive). - The length of each word and symbol will be between 1 and 100 (inclusive). Performance Requirement: The solution should strive for efficiency, both in terms of time and space complexity. Example: ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] print(insert_symbols(words, symbols)) # Output: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` Function Signature: ```python def insert_symbols(words: List[str], symbols: List[str]) -> List[str]: pass ``` Requirements: - Clearly define the algorithm steps. - Ensure the function handles edge cases effectively. - Explain the usage of any data structure or algorithm if required.","solution":"from typing import List def insert_symbols(words: List[str], symbols: List[str]) -> List[str]: Surrounds the longest matching symbol within each word from words list with square brackets. Args: words (List[str]): The list of words to process. symbols (List[str]): The list of symbols to look for. Returns: List[str]: A list of words with the longest matching symbol surrounded by square brackets. # Sort symbols by their length in descending order to prioritize longer symbols symbols = sorted(symbols, key=len, reverse=True) result = [] for word in words: matched_word = word for symbol in symbols: if symbol in word: matched_word = word.replace(symbol, f\'[{symbol}]\', 1) break result.append(matched_word) return result"},{"question":"# Implementing a Custom Resizable Hash Table Background: You are tasked with building a custom hash table that supports dynamic resizing. You must implement the hash table with linear probing for collision management and ensure it resizes itself when the load factor exceeds 2/3. The hash table should support typical operations such as insertion, retrieval, and deletion of key-value pairs. Task: Implement a class `ResizableHashTable` that extends the functionality of a basic hash table. Ensure your implementation follows these guidelines: 1. **Initial Setup**: The hash table should have a minimum size of `8`. 2. **Methods to Implement**: - `put(self, key: int, value: Any) -> None`: Insert a key-value pair into the hash table. - `get(self, key: int) -> Any`: Retrieve the value associated with the key, or `None` if the key does not exist. - `del_(self, key: int) -> None`: Delete the key-value pair associated with the key. 3. **Resizing**: When the load factor (number of elements / table size) exceeds 2/3, double the size of the hash table and rehash all elements. Input and Output: * **Input**: Operations to be performed as a list of tuples. Each tuple represents a single operation: - `(\\"put\\", key, value)`: Insert or update the key-value pair. - `(\\"get\\", key)`: Retrieve the value for the key. - `(\\"del\\", key)`: Delete the key-value pair. * **Output**: For each \\"get\\" operation, output the corresponding value or `None`. - For \\"put\\" and \\"del\\" operations, nothing should be returned. # Example: ```python operations = [(\\"put\\", 1, \\"a\\"), (\\"put\\", 2, \\"b\\"), (\\"get\\", 1), (\\"del\\", 1), (\\"get\\", 1)] ht = ResizableHashTable() results = ht.process_operations(operations) print(results) # Output: [\\"a\\", None] ``` Implementation: 1. Define the `ResizableHashTable` class. 2. Implement the methods `put`, `get`, and `del_`. 3. Implement the private method `_resize` to handle dynamic resizing. 4. Implement `process_operations` method to perform the operations consecutively and return results for \\"get\\" operations. You may assume that inputs for keys and values are valid and within a reasonable range for testing purposes.","solution":"class ResizableHashTable: def __init__(self): self.capacity = 8 self.size = 0 self.table = [None] * self.capacity def _hash(self, key): return key % self.capacity def _resize(self): old_table = self.table new_capacity = 2 * self.capacity self.table = [None] * new_capacity self.capacity = new_capacity for item in old_table: if item is not None and item != \\"DELETED\\": key, value = item self.put(key, value) def put(self, key, value): if self.size >= (2 * self.capacity) // 3: self._resize() index = self._hash(key) while self.table[index] is not None: if self.table[index] == \\"DELETED\\" or self.table[index][0] == key: break index = (index + 1) % self.capacity if self.table[index] is None or self.table[index] == \\"DELETED\\": self.size += 1 self.table[index] = (key, value) def get(self, key): index = self._hash(key) while self.table[index] is not None: if self.table[index] != \\"DELETED\\" and self.table[index][0] == key: return self.table[index][1] index = (index + 1) % self.capacity return None def del_(self, key): index = self._hash(key) while self.table[index] is not None: if self.table[index] != \\"DELETED\\" and self.table[index][0] == key: self.table[index] = \\"DELETED\\" self.size -= 1 return index = (index + 1) % self.capacity def process_operations(self, operations): result = [] for op in operations: if op[0] == \\"put\\": self.put(op[1], op[2]) elif op[0] == \\"get\\": result.append(self.get(op[1])) elif op[0] == \\"del\\": self.del_(op[1]) return result"},{"question":"# Question: In this coding assessment, you are required to implement a Red-Black Tree from scratch. A Red-Black Tree is a self-balancing binary search tree where nodes have an extra bit for denoting the color of the node, either red or black. To maintain balance, the tree must adhere to several properties, including ensuring no two consecutive red nodes appear on any path from the root to the leaves. Task: Implement the following methods of a Red-Black Tree: 1. **Inserting a node** 2. **Deleting a node** 3. **In-order traversal of the tree** Your implementation should ensure that all Red-Black Tree properties are maintained after every insertion and deletion. Method Signature: ```python class RBNode: def __init__(self, val, is_red, parent=None, left=None, right=None): pass class RBTree: def __init__(self): self.root = None def insert(self, value: int) -> None: Insert a new node with the given value into the tree, maintaining Red-Black Tree properties. pass def delete(self, value: int) -> None: Delete the node with the given value from the tree, maintaining Red-Black Tree properties. pass def inorder(self) -> list: Return the in-order traversal of the tree as a list of values. pass ``` Input: - For **insert(value)** method: An integer representing the value to be inserted. - For **delete(value)** method: An integer representing the value to be deleted. - For **inorder()** method: No input. Output: - **insert(value)** method: No output but changes the tree structure internally. - **delete(value)** method: No output but changes the tree structure internally. - **inorder()** method: A list of integers representing the in-order traversal of the tree values. Constraints: 1. All input values for insert and delete will be distinct and within integer range. 2. Methods will be called multiple times in any sequence. 3. Implementations must handle self-balancing to maintain Red-Black properties. Example: ```python # Example invoking the RBTree class rb = RBTree() rb.insert(10) rb.insert(20) rb.insert(15) print(rb.inorder()) # Output: [10, 15, 20] rb.delete(15) print(rb.inorder()) # Output: [10, 20] ``` Evaluate the robustness and correctness of your implementation thoroughly.","solution":"class RBNode: def __init__(self, val, is_red=True, parent=None, left=None, right=None): self.val = val self.is_red = is_red # True for red, False for black self.parent = parent self.left = left self.right = right class RBTree: def __init__(self): self.NIL_LEAF = RBNode(val=None, is_red=False) self.root = self.NIL_LEAF def insert(self, value: int) -> None: new_node = RBNode(val=value, left=self.NIL_LEAF, right=self.NIL_LEAF) self._bst_insert(self.root, new_node) self._fix_insert(new_node) def _bst_insert(self, root, node): if self.root == self.NIL_LEAF: self.root = node node.is_red = False node.parent = None else: if node.val < root.val: if root.left == self.NIL_LEAF: root.left = node node.parent = root else: self._bst_insert(root.left, node) else: if root.right == self.NIL_LEAF: root.right = node node.parent = root else: self._bst_insert(root.right, node) def _rotate_left(self, node): right_node = node.right node.right = right_node.left if right_node.left != self.NIL_LEAF: right_node.left.parent = node right_node.parent = node.parent if node.parent == None: self.root = right_node elif node == node.parent.left: node.parent.left = right_node else: node.parent.right = right_node right_node.left = node node.parent = right_node def _rotate_right(self, node): left_node = node.left node.left = left_node.right if left_node.right != self.NIL_LEAF: left_node.right.parent = node left_node.parent = node.parent if node.parent == None: self.root = left_node elif node == node.parent.right: node.parent.right = left_node else: node.parent.left = left_node left_node.right = node node.parent = left_node def _fix_insert(self, node): while node != self.root and node.parent.is_red: if node.parent == node.parent.parent.left: uncle = node.parent.parent.right if uncle.is_red: node.parent.is_red = False uncle.is_red = False node.parent.parent.is_red = True node = node.parent.parent else: if node == node.parent.right: node = node.parent self._rotate_left(node) node.parent.is_red = False node.parent.parent.is_red = True self._rotate_right(node.parent.parent) else: uncle = node.parent.parent.left if uncle.is_red: node.parent.is_red = False uncle.is_red = False node.parent.parent.is_red = True node = node.parent.parent else: if node == node.parent.left: node = node.parent self._rotate_right(node) node.parent.is_red = False node.parent.parent.is_red = True self._rotate_left(node.parent.parent) self.root.is_red = False def _transplant(self, u, v): if u.parent == None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def _tree_minimum(self, node): while node.left != self.NIL_LEAF: node = node.left return node def delete(self, value: int) -> None: node = self._find_node(self.root, value) if node == self.NIL_LEAF: return # Value not found in the tree original_color = node.is_red if node.left == self.NIL_LEAF: x = node.right self._transplant(node, node.right) elif node.right == self.NIL_LEAF: x = node.left self._transplant(node, node.left) else: y = self._tree_minimum(node.right) original_color = y.is_red x = y.right if y.parent == node: x.parent = y else: self._transplant(y, y.right) y.right = node.right y.right.parent = y self._transplant(node, y) y.left = node.left y.left.parent = y y.is_red = node.is_red if not original_color: self._fix_delete(x) def _fix_delete(self, x): while x != self.root and not x.is_red: if x == x.parent.left: sibling = x.parent.right if sibling.is_red: sibling.is_red = False x.parent.is_red = True self._rotate_left(x.parent) sibling = x.parent.right if not sibling.left.is_red and not sibling.right.is_red: sibling.is_red = True x = x.parent else: if not sibling.right.is_red: sibling.left.is_red = False sibling.is_red = True self._rotate_right(sibling) sibling = x.parent.right sibling.is_red = x.parent.is_red x.parent.is_red = False sibling.right.is_red = False self._rotate_left(x.parent) x = self.root else: sibling = x.parent.left if sibling.is_red: sibling.is_red = False x.parent.is_red = True self._rotate_right(x.parent) sibling = x.parent.left if not sibling.left.is_red and not sibling.right.is_red: sibling.is_red = True x = x.parent else: if not sibling.left.is_red: sibling.right.is_red = False sibling.is_red = True self._rotate_left(sibling) sibling = x.parent.left sibling.is_red = x.parent.is_red x.parent.is_red = False sibling.left.is_red = False self._rotate_right(x.parent) x = self.root x.is_red = False def _find_node(self, root, value): if root == self.NIL_LEAF or value == root.val: return root if value < root.val: return self._find_node(root.left, value) return self._find_node(root.right, value) def inorder(self) -> list: res = [] self._inorder_helper(self.root, res) return res def _inorder_helper(self, node, res): if node != self.NIL_LEAF: self._inorder_helper(node.left, res) res.append(node.val) self._inorder_helper(node.right, res)"},{"question":"# Coding Problem: Remove Reoccurring Characters from a String Problem Statement You are given a string `s` consisting of ASCII characters. Write a function `remove_reoccurring_characters(s)` that processes the string to remove all reoccurring characters but keeps the first occurrence of each character. The function should return the updated string. Input * A single string `s` containing any printable ASCII characters. * `1 <= len(s) <= 10^6` Output * A string with reoccurring characters removed, retaining the first occurrence of each character. Constraints * The solution should be efficient with a time complexity of O(n). * The solution should use O(n) extra space in the worst case. Examples ```python remove_reoccurring_characters(\\"google\\") # Output: \\"gole\\" remove_reoccurring_characters(\\"racecar\\") # Output: \\"race\\" remove_reoccurring_characters(\\"aabbcc\\") # Output: \\"abc\\" remove_reoccurring_characters(\\"\\") # Output: \\"\\" ``` Scenario Imagine you are a software engineer working at a tech company. You are tasked with creating a utility that ensures that strings stored in your database do not contain any reoccurring characters. This utility will help in normalizing data entries and avoid any redundancy issues. Implement the function as follows: ```python def remove_reoccurring_characters(s: str) -> str: # Your code here ```","solution":"def remove_reoccurring_characters(s: str) -> str: seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# 1. Postorder Traversal Challenge Given the structure of a binary tree, design a Python function to perform a postorder traversal of the binary tree. Input Format: - A binary tree represented by its root node. Output Format: - A list of node values in postorder traversal order. Constraints: - The number of nodes in the binary tree can be up to (10^4). - Node values are unique integers. Examples: Example 1: ```plaintext Input: [1, None, 2, 3] 1 2 / 3 Output: [3, 2, 1] ``` Example 2: ```plaintext Input: [1, 2, 3, 4, 5, 6] 1 / 2 3 / 4 5 6 Output: [4, 5, 2, 6, 3, 1] ``` # Function Signature ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def postorder(root: Node) -> [int]: pass def postorder_rec(root: Node) -> [int]: pass ``` Implement both `postorder` (iterative) and `postorder_rec` (recursive) functions to perform postorder traversal on the given binary tree and return the list of node values.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def postorder(root: Node) -> [int]: Perform an iterative postorder traversal of the binary tree. if root is None: return [] stack, res = [root], [] visited = set() while stack: node = stack[-1] if node in visited: res.append(node.val) stack.pop() else: visited.add(node) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return res def postorder_rec(root: Node) -> [int]: Perform a recursive postorder traversal of the binary tree. def traverse(node: Node) -> [int]: return traverse(node.left) + traverse(node.right) + [node.val] if node else [] return traverse(root)"}]'),S={name:"App",components:{PoemCard:E},data(){return{searchQuery:"",visibleCount:4,poemsData:O,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},C={class:"search-container"},F={class:"card-container"},z={key:0,class:"empty-state"},L=["disabled"],R={key:0},Y={key:1};function j(r,e,l,p,s,a){const f=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",C,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",F,[(n(!0),i(b,null,v(a.displayedPoems,(o,m)=>(n(),w(f,{key:m,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",z,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",Y,"Loading...")):(n(),i("span",R,"See more"))],8,L)):u("",!0)])}const B=c(S,[["render",j],["__scopeId","data-v-3704e3de"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/44.md","filePath":"guide/44.md"}'),P={name:"guide/44.md"},H=Object.assign(P,{setup(r){return(e,l)=>(n(),i("div",null,[x(B)]))}});export{M as __pageData,H as default};
