import{_ as p,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},E={class:"review-content"};function S(r,e,l,c,a,s){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",E,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const A=p(k,[["render",S],["__scopeId","data-v-5792a424"]]),N=JSON.parse('[{"question":"# Context: Imagine you are developing software for a library to manage a dynamic catalog of books. You decide to use a Binary Search Tree (BST) to store and quickly retrieve book IDs. However, before implementing the full system, you need to ensure your BST is robust and handles all typical operations effectively. # Task: You are required to implement additional functionality for the `BST` class provided in the code snippet. Specifically, implement a method to delete a node from the BST. Ensure your method maintains the BST properties after deletion. # Detailed Requirements: 1. **Function Name**: `delete(self, data)` 2. **Inputs**: * `data` (int) - The value to be deleted from the BST. 3. **Outputs**: * `True` if the value was successfully deleted. * `False` if the value was not found in the tree. 4. **Constraints**: * The tree does not contain duplicate values. * The tree can handle up to 10,000 nodes efficiently. 5. **Edge Cases to Consider**: * Deleting from an empty tree. * Deleting a leaf node, node with one child, and node with two children. * Deleting the root node. * Ensure children nodes are properly reassigned to maintain the BST properties. 6. **Performance Requirement**: The deletion operation should maintain average-case O(log N) complexity. # Testing: Extend the `TestSuite` class provided to include tests for the `delete` function. Ensure that: * You test the deletion of values that are present and not present in the tree. * After deletion, the BST properties are maintained. # Example: ```python tree = BST() tree.insert(20) tree.insert(10) tree.insert(30) tree.insert(5) tree.insert(15) assert tree.delete(20) == True # Root node assert tree.search(20) == False assert tree.delete(5) == True # Leaf node assert tree.search(5) == False assert tree.delete(15) == True # Node with one child assert tree.search(15) == False assert tree.delete(100) == False # Node not in the tree ```","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, node, key): if key < node.val: if node.left is None: node.left = TreeNode(key) else: self._insert_recursive(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert_recursive(node.right, key) def search(self, key): return self._search_recursive(self.root, key) def _search_recursive(self, node, key): if not node: return False if key == node.val: return True elif key < node.val: return self._search_recursive(node.left, key) else: return self._search_recursive(node.right, key) def delete(self, key): self.root, deleted = self._delete_recursive(self.root, key) return deleted def _delete_recursive(self, node, key): if not node: return node, False if key < node.val: node.left, deleted = self._delete_recursive(node.left, key) elif key > node.val: node.right, deleted = self._delete_recursive(node.right, key) else: # Node found if not node.left: return node.right, True elif not node.right: return node.left, True temp_val = self._min_value_node(node.right) node.val = temp_val.val node.right, _ = self._delete_recursive(node.right, temp_val.val) return node, True return node, deleted def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current"},{"question":"# Missing Number Finder **Objective**: Implement a function to determine the missing number in a given sequence of unique integers ranging from 0 to n. Scenario You are tasked with verifying and correcting a sequence of IDs assigned from a range [0..n] that might be missing a single number. You need to ensure data integrity by identifying this missing number efficiently. Function Signature ```python def find_missing_number(nums: List[int]) -> int: ``` Input * `nums` (List[int]): A list of unique integers where each element is within the range `[0..n-1]`. The sequence may be missing one number, or it may be complete (in which case the next number, `n` should be returned). Output * `int`: The missing number in the range `[0..n]`. Constraints 1. `1 ≤ len(nums) ≤ 10^5` 2. All elements in `nums` are unique. 3. Elements ranges from `0` to `n`. Example ```python # Example 1: nums = [3, 0, 1] # Missing number is 2 # Output: 2 # Example 2: nums = [0, 1, 2, 3, 4, 6, 7, 5] # The sequence is missing number 8, hence it’s 8. # Output: 8 ``` **Note**: Ensure that your implementation handles large inputs efficiently.","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Find the missing number in the sequence of unique integers ranging from 0 to n. Args: nums (List[int]): List of unique integers where each element is within the range [0..n-1]. Returns: int: The missing number in the range [0..n]. n = len(nums) expected_sum = n * (n + 1) / 2 actual_sum = sum(nums) return int(expected_sum - actual_sum)"},{"question":"# Bucket and Enhanced Sorting In this task, you\'ll demonstrate your understanding of an advanced sorting technique by implementing Bucket Sort with a twist. The Bucket Sort algorithm provided uses a simple insertion sort for sorting individual buckets. Your goal is to enhance this by substituting the insertion sort with a more efficient sorting algorithm of your choice (e.g., Merge Sort, Quick Sort). # Problem Statement Implement the `bucket_sort` function which sorts an array of integers using the principle of bucket sorting. Each bucket should be sorted using Merge Sort instead of Insertion Sort for better performance. # Function Signature ```python def bucket_sort(arr: List[int]) -> List[int]: ``` # Input * `arr`: A list of integers `arr` where `1 <= len(arr) <= 10000` and `-10000 <= arr[i] <= 10000`. # Output * Returns a sorted list in non-decreasing order. # Example ```python bucket_sort([29, 25, 3, 49, 9, 37, 21, 43]) # Output: [3, 9, 21, 25, 29, 37, 43, 49] ``` # Constraints * The input list can contain negative numbers. * Use merge sort to sort the elements within each bucket. # Additional Notes * Consider edge cases such as an empty array or an array with duplicate elements. * Ensure your solution efficiently handles the upper limit of the constraints.","solution":"from typing import List import math def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left: List[int], right: List[int]) -> List[int]: result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result def bucket_sort(arr: List[int]) -> List[int]: if not arr: return [] # Determine minimum and maximum values min_value, max_value = min(arr), max(arr) bucket_count = len(arr) # Create buckets buckets = [[] for _ in range(bucket_count)] # Map values into buckets for num in arr: index = math.floor((num - min_value) / (max_value - min_value + 1) * bucket_count) buckets[index].append(num) # Sort each bucket and concatenate results sorted_arr = [] for bucket in buckets: sorted_arr.extend(merge_sort(bucket)) return sorted_arr"},{"question":"# Modular Exponential Function with Validation In cryptography and number theory, efficient computation of large powers modulo some number is crucial. You have been tasked to improve upon and implement the given `modular_exponential` function with additional validations. # Problem Statement: Implement a function `secure_modular_exponential(base, exponent, mod)` that calculates `(base ^ exponent) % mod` efficiently, ensuring proper input validations and handling edge cases correctly. # Input: * `base` (integer): The base integer, can be negative or positive. * `exponent` (integer): The exponent integer, must be non-negative. * `mod` (integer): The modulus, must be a positive integer. # Output: * An integer representing `(base ^ exponent) % mod`. # Constraints: * `0 <= base <= 10^9` * `0 <= exponent <= 10^9` * `1 <= mod <= 10^9` # Requirements: 1. **Input Validation**: * Raise `ValueError` if `exponent` is negative. * Raise `ValueError` if `mod` is not a positive integer. 2. **Performance**: * Ensure the implementation is efficient and runs in O(log n) time where n is the exponent. # Example: ```python >>> secure_modular_exponential(2, 10, 1000) 24 >>> secure_modular_exponential(2, -10, 1000) ValueError: Exponent must be non-negative >>> secure_modular_exponential(2, 10, 0) ValueError: Modulus must be a positive integer. ``` # Function signature: ```python def secure_modular_exponential(base, exponent, mod): pass ``` # Evaluation Criteria: * Correctness of input validation. * Efficiency and accuracy of the implemented algorithm. * Handling of edge cases. * Adherence to the specified constraints and requirements.","solution":"def secure_modular_exponential(base, exponent, mod): Computes (base ^ exponent) % mod efficiently with input validation. Args: base (int): The base integer. exponent (int): The exponent integer, must be non-negative. mod (int): The modulus, must be a positive integer. Returns: int: Result of (base ^ exponent) % mod. Raises: ValueError: If exponent is negative or if mod is not a positive integer. if exponent < 0: raise ValueError(\\"Exponent must be non-negative.\\") if mod <= 0: raise ValueError(\\"Modulus must be a positive integer.\\") result = 1 base = base % mod while exponent > 0: if exponent % 2 == 1: result = (result * base) % mod exponent = exponent >> 1 base = (base * base) % mod return result"},{"question":"# Coding Assessment: Insertion Sort with Early Exit and Binary Search Question You are tasked with improving the performance of the traditional insertion sort algorithm by implementing two optimizations: 1. **Early Exit**: During each pass, check if no elements were swapped indicating the array is already sorted. If so, exit the sorting process early. 2. **Binary Search for Positioning**: Use binary search to find the correct position to insert the current element, reducing the number of comparisons. Implement the function `optimized_insertion_sort` using the specified optimizations. Your function should return a sorted array and also print each iteration (partial state of the array) similar to the existing insertion sort function provided. Function Signature ```python def optimized_insertion_sort(arr: list, simulation=False) -> list: pass ``` Input * `arr` (List[int]): List of integers to be sorted. * `simulation` (bool, optional): If set to `True`, the function should print the array at each iteration. Output * List[int]: Sorted list of integers in non-decreasing order. Constraints * Performance: Should handle arrays up to size 1000 efficiently. * You may assume all elements in the array are integers. Example ```python arr = [4, 3, 2, 10, 12, 1, 5, 6] print(optimized_insertion_sort(arr, simulation=True)) ``` Output: ``` iteration 0 : 3 4 2 10 12 1 5 6 iteration 1 : 2 3 4 10 12 1 5 6 iteration 2 : 2 3 4 10 12 1 5 6 iteration 3 : 2 3 4 10 12 1 5 6 iteration 4 : 2 3 4 10 12 1 5 6 iteration 5 : 1 2 3 4 10 12 5 6 iteration 6 : 1 2 3 4 5 10 12 6 iteration 7 : 1 2 3 4 5 6 10 12 [1, 2, 3, 4, 5, 6, 10, 12] ``` **Hint**: Consider implementing a helper function to perform the binary search for the correct position.","solution":"def binary_search(arr, val, start, end): # Perform binary search to find the position for val in arr while start < end: mid = (start + end) // 2 if arr[mid] < val: start = mid + 1 else: end = mid return start def optimized_insertion_sort(arr, simulation=False): n = len(arr) for i in range(1, n): current_value = arr[i] correct_position = binary_search(arr, current_value, 0, i) # Shift all elements to make room for the current value for j in range(i, correct_position, -1): arr[j] = arr[j - 1] arr[correct_position] = current_value # Print the current state of the array if simulation is enabled if simulation: print(f\\"iteration {i-1} : {\' \'.join(map(str, arr))}\\") # Early exit: check if the array is already sorted already_sorted = True for k in range(n - 1): if arr[k] > arr[k + 1]: already_sorted = False break if already_sorted: break return arr"},{"question":"Objective Your task is to implement the encode and decode functions. These functions are designed to encode a list of strings into a single string for ease of transmission or storage, and then decode it back to the original list of strings. Implementation Details * **Function Signatures**: ```python def encode(strs: List[str]) -> str: pass def decode(s: str) -> List[str]: pass ``` * **Expected Input and Output Formats**: * **encode**: - Input: List of strings. - Output: A single encoded string. * **decode**: - Input: A single encoded string. - Output: List of strings. Constraints & Limitations 1. The input list for `encode` may contain up to 10^4 strings. 2. Each string in the input list can be up to 10^4 characters. 3. The encoded string will not exceed 10^6 characters. 4. The colon (\\":\\") is used as a delimiter and should not be part of the strings to be encoded. Scenario You are building a messaging application where messages need to be sent as lists of strings. However, for network transmission, these lists need to be converted to single strings and then converted back on the receiving end. Implementing encoding and decoding functions will help achieve this serialization. Requirements * Efficient implementation with time-complexity of O(n) for both encoding and decoding. Examples * **Example 1**: ```python strs = [\\"hello\\", \\"world\\"] encoded_str = encode(strs) print(encoded_str) # \\"5:hello5:world\\" decoded_list = decode(encoded_str) print(decoded_list) # [\\"hello\\", \\"world\\"] ``` * **Example 2**: ```python strs = [\\"one\\", \\"\\"] encoded_str = encode(strs) print(encoded_str) # \\"3:one0:\\" decoded_list = decode(encoded_str) print(decoded_list) # [\\"one\\", \\"\\"] ``` Your implementation should pass the above examples and handle other edge cases appropriately.","solution":"from typing import List def encode(strs: List[str]) -> str: Encode a list of strings to a single string. Each string is prefixed by its length followed by a colon (\\":\\"). encoded_str = \'\'.join(f\\"{len(s)}:{s}\\" for s in strs) return encoded_str def decode(s: str) -> List[str]: Decode a single string to a list of strings. decoded_list = [] i = 0 while i < len(s): # Find the position of the delimiter \':\' colon_pos = s.find(\':\', i) # Length of the string str_len = int(s[i:colon_pos]) # String starts after the colon_pos decoded_str = s[colon_pos + 1 : colon_pos + 1 + str_len] decoded_list.append(decoded_str) # Move to the next string position i = colon_pos + 1 + str_len return decoded_list"},{"question":"# Polynomial Simplification and Evaluation As a budding mathematician, you have decided to automate the processing of polynomial expressions. You already have a `Polynomial` class that you can use, but you need to enhance it with additional capabilities. Specifically, you want to ensure that your polynomials are simplified and can be evaluated efficiently. # Problem Statement Your task is to implement the following method in the `Polynomial` class: ```python def simplify(self) -> Polynomial: Simplifies the polynomial by combining like terms and removing any monomials that reduce to zero. Returns: Polynomial: A new `Polynomial` object that represents the simplified version of the original polynomial. ``` **Input Format**: - A `Polynomial` object is initialized with a list of monomials, where each monomial can be an int, float, Fraction, or another Monomial. **Output Format**: - The `simplify` method should return a new `Polynomial` object with no redundant terms and all like terms combined. **Constraints**: - Ensure that the polynomial simplifies correctly and edge cases are handled robustly (such as handling zeroes and combining like terms). - Handle cases with zero coefficients and zero exponentiated terms effectively by eliminating them. **Example**: ```python polynomial = Polynomial([ Monomial({1:1}, 2), Monomial({2:3, 1:-1}, -1), Monomial({1:1}, 3) ]) simplified_polynomial = polynomial.simplify() print(simplified_polynomial) # Should output a simplified version of the polynomial ``` # Notes: - Your implementation should ensure that any redundant monomials are eliminated and that like terms are correctly combined. - Aim for a method that runs efficiently even with larger polynomials. - Make use of the existing methods and properties of `Monomial` and `Polynomial` classes wherever possible.","solution":"from fractions import Fraction from collections import defaultdict class Monomial: def __init__(self, variables, coefficient): Initializes a monomial. Args: variables (dict): A dictionary where keys are variable identifiers (e.g., variable exponents) and values are their powers. coefficient (int, float, Fraction): The coefficient of the monomial. self.variables = variables self.coefficient = coefficient def __eq__(self, other): return self.variables == other.variables and self.coefficient == other.coefficient def __hash__(self): return hash(frozenset(self.variables.items())) def __repr__(self): return f\\"{self.coefficient} * {self.variables}\\" def can_combine(self, other): Checks if two monomials can be combined (i.e., they have the same variables and powers). return self.variables == other.variables class Polynomial: def __init__(self, monomials): Initializes a polynomial. Args: monomials (list of Monomial): A list of Monomial objects. self.monomials = monomials def simplify(self): Simplifies the polynomial by combining like terms and removing any monomials that reduce to zero. Returns: Polynomial: A new `Polynomial` object that represents the simplified version of the original polynomial. combined = defaultdict(Fraction) for monomial in self.monomials: var_tuple = frozenset(monomial.variables.items()) combined[var_tuple] += monomial.coefficient simplified_monomials = [Monomial(dict(vars), coeff) for vars, coeff in combined.items() if coeff != 0] return Polynomial(simplified_monomials) def __repr__(self): return \\" + \\".join(map(str, self.monomials)) if self.monomials else \\"0\\""},{"question":"**Title**: Enhanced Sorting Algorithm Implementation **Objective**: Write a function to implement an enhanced sorting algorithm that efficiently sorts an array of integers. The function should be more effective than the provided Bogo Sort and exhibit better average case performance. # Problem Statement Given an array of integers `arr[]`, your task is to write a function `enhanced_sort(arr)` that sorts the array in non-decreasing order using a more efficient algorithm than Bogo Sort. You should not use predefined sorting functions or libraries but rather implement one of the fundamental sorting algorithms (such as Merge Sort, Quick Sort, or Heap Sort). # Requirements 1. **Input**: - An array `arr` of integers, with length `n` (1 ≤ n ≤ 10^5). 2. **Output**: - The sorted array in non-decreasing order. 3. **Constraints**: - Using a better average performance algorithm than Bogo Sort is crucial. - Ensure sorted arrays perform efficiently even towards the worst-case scenarios. 4. **Performance**: - The solution should aim for O(n log n) average time complexity. # Function Signature ```python def enhanced_sort(arr: List[int]) -> List[int]: pass ``` # Example ```python # Example 1 arr = [64, 34, 25, 12, 22, 11, 90] print(enhanced_sort(arr)) # Output: [11, 12, 22, 25, 34, 64, 90] # Example 2 arr = [5, 1] print(enhanced_sort(arr)) # Output: [1, 5] ``` # Context Imagine you are working on an application that requires sorting a large dataset of user records. Bogo Sort has been observed to perform unreasonably slow for larger or even moderately sized datasets. You need to come up with an enhanced sorting technique to ensure the application runs efficiently and user experience is not hindered. # Evaluation Criteria - Correctness of the sorted output. - Adherence to expected performance constraints. - Code readability and structure. - Handling of edge cases efficiently.","solution":"from typing import List def enhanced_sort(arr: List[int]) -> List[int]: Implementing quicksort, which has an average case time complexity of O(n log n). def quick_sort(arr, low, high): if low < high: pivot_index = partition(arr, low, high) quick_sort(arr, low, pivot_index - 1) quick_sort(arr, pivot_index + 1, high) def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] < pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 quick_sort(arr, 0, len(arr) - 1) return arr"},{"question":"# Problem: Efficient Path Finder in Large Graphs You are given a directed graph represented as an adjacency list, where each key is a node and the corresponding value is a list of nodes directly reachable from it. Your task is to implement a function `efficient_shortest_path(graph, start, end)` that finds the shortest path between two nodes using a more efficient approach compared to the recursive backtracking method outlined below the code. # Function Signature ```python def efficient_shortest_path(graph: Dict[str, List[str]], start: str, end: str) -> Optional[List[str]]: pass ``` # Input - `graph` (Dictionary[str, List[str]]): A dictionary where keys are node identifiers and values are lists of directly reachable nodes from the key. - `start` (str): The starting node identifier. - `end` (str): The destination node identifier. # Output - Returns a list of node identifiers representing the shortest path from `start` to `end`. If no path exists, return `None`. # Constraints - The graph is directed. - There may be cycles in the graph. - Node identifiers are unique and alphanumeric. - The graph is large so your solution should be optimized for performance. # Scenario In developing city traffic systems, you are employed to create a system that calculates the shortest possible route for emergency services to travel from one location to another as quickly as possible. The city map is complex and involves thousands of intersections (nodes) and roads (edges). Your task is to efficiently calculate the optimal path that minimizes travel distance (number of intersections passed). # Performance Goals - Aim for a solution with a time complexity close to O(V + E). - Optimize for memory usage to handle large graphs efficiently. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'D\'], \'F\': [\'C\'] } start = \'A\' end = \'D\' # Example Output: [\'A\', \'B\', \'D\'] (or any other shortest path) ``` # Additional Requirements - Add comments to explain your implementation steps. - Make sure to handle edge cases such as no path exists, the start and end being the same, and graphs with cycles.","solution":"from collections import deque from typing import Dict, List, Optional def efficient_shortest_path(graph: Dict[str, List[str]], start: str, end: str) -> Optional[List[str]]: Finds the shortest path in a directed graph between start and end nodes. Uses Breadth-First Search (BFS) for efficient discovery of the shortest path. if start == end: return [start] # Queue for BFS with (current_path) -> (current_node) queue = deque([[start]]) visited = set() # Set to track visited nodes while queue: path = queue.popleft() # Current path node = path[-1] # Current node if node in visited: continue visited.add(node) for neighbor in graph.get(node, []): new_path = path + [neighbor] if neighbor == end: return new_path queue.append(new_path) return None"},{"question":"You are tasked with implementing the radix sort algorithm that sorts a list of integers. The algorithm should process individual digits, starting from the least significant digit to the most significant digit, efficiently handling a variety of input scenarios. # Requirements 1. Implement the function `radix_sort(arr)` that takes a list of integers `arr` and sorts it in ascending order. 2. Do not use any built-in sorting functions or libraries for sorting. 3. The implementation must work for non-negative integers only. 4. The function should handle cases efficiently, including a large number of small integers and a small number of large integers. # Input Format - A list of integers `arr` where `1 <= len(arr) <= 10^5` and `0 <= arr[i] < 10^18`(non-negative integers). # Output Format - A sorted list of integers in ascending order. # Constraints - The solution should have an average time complexity of O(nk) and space complexity of O(n). # Example ```python # Input arr = [170, 45, 75, 90, 802, 24, 2, 66] # Output radix_sort(arr) => [2, 24, 45, 66, 75, 90, 170, 802] ``` # Notes - Ensure to consider edge cases, such as empty lists and lists with one element. - The function should not modify the original list; instead, it should return a new sorted list. # Additional Challenge For added complexity, modify the function to handle an optional boolean parameter `simulation`. If `simulation` is set to `True`, the function will print out the list after each iteration of digit-based sorting.","solution":"def counting_sort(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 return output def radix_sort(arr, simulation=False): if len(arr) == 0: return [] max_value = max(arr) exp = 1 while max_value // exp > 0: arr = counting_sort(arr, exp) if simulation: print(arr) exp *= 10 return arr"},{"question":"# Problem: Connected Component Finder You are given a graph represented as an undirected edge list. Your task is to identify the number of connected components in the graph using the Union-Find data structure. # Function Signature ```python def count_components(n: int, edges: List[List[int]]) -> int: ``` # Input - `n`: An integer representing the number of nodes in the graph (nodes are numbered from 0 to n-1). - `edges`: A list of lists of form [[u1, v1], [u2, v2], ...] where each pair [ui, vi] represents an undirected edge between nodes `ui` and `vi`. # Output - An integer representing the number of connected components. # Constraints - (1 leq n leq 10^4) - (0 leq text{edges.length} leq 10^4) - No duplicate edges and no self-loops (i.e., no edge of the form [u, u]). # Performance Requirements The solution must be efficient, leveraging the Union-Find structure to achieve near-constant time complexity per operation. # Example ```python assert count_components(5, [[0, 1], [1, 2], [3, 4]]) == 2 assert count_components(3, [[0, 1], [1, 2], [2, 0]]) == 1 ``` # Explanation 1. For the graph with `n = 5` and edges `[[0, 1], [1, 2], [3, 4]]`, the connected components are {0, 1, 2} and {3, 4}, leading to 2 connected components. 2. For the graph with `n = 3` and edges `[[0, 1], [1, 2], [2, 0]]`, all nodes {0, 1, 2} are interconnected, resulting in 1 connected component.","solution":"from typing import List def count_components(n: int, edges: List[List[int]]) -> int: # Helper function to find root of a node def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) # path compression return parent[i] # Helper function to union two subsets def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: # Union by rank if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 # Initialize Union-Find parent = [i for i in range(n)] rank = [0] * n # Iterate over all edges and union the nodes for edge in edges: union(parent, rank, edge[0], edge[1]) # Count how many unique roots there are unique_roots = len({find(parent, i) for i in range(n)}) return unique_roots"},{"question":"# Password Strengthener Given the criteria for a strong password, implement the `strong_password` function which determines the minimum number of additional characters required to make a given password strong. Criteria for a Strong Password: 1. The password must be at least 6 characters long. 2. It must contain at least one digit. 3. It must contain at least one lowercase English character. 4. It must contain at least one uppercase English character. 5. It must contain at least one special character from the set `!@#%^&*()-+`. Input Format: * The first input line is an integer `n` (1 ≤ n ≤ 100), representing the length of the password `password`. * The second input line is a string `password` consisting of `n` characters which can either be lowercase/uppercase English letters, digits, or special characters. Output Format: * Return the minimum number of characters to be added to make the password strong. Example: * Input: ```plaintext 3 Ab1 ``` * Output: ```plaintext 3 ``` (Explanation: She can make the password strong by adding 3 characters, for example, `hk`, turning the password into `Ab1hk`.) * Input: ```plaintext 11 #Algorithms ``` * Output: ```plaintext 1 ``` (Explanation: The password isn\'t strong, but she can make it strong by adding a single digit.) Constraints: * 1 ≤ password.length ≤ 100 * Password only contains numbers, lowercase, uppercase characters, and special characters from the set `!@#%^&*()-+`. You need to implement the following function: ```python def strong_password(n, password): # Return the minimum number of characters to make the password strong ```","solution":"def strong_password(n, password): Determines the minimum number of additional characters required to make the given password strong. :param n: (int) Length of the password :param password: (string) The password to check :return: (int) Minimum number of characters to be added to make the password strong requires_digit = True requires_lower = True requires_upper = True requires_special = True special_characters = \\"!@#%^&*()-+\\" for char in password: if char.isdigit(): requires_digit = False elif char.islower(): requires_lower = False elif char.isupper(): requires_upper = False elif char in special_characters: requires_special = False requirements = sum([requires_digit, requires_lower, requires_upper, requires_special]) return max(requirements, 6 - n)"},{"question":"Objective: Implement a function that takes two non-negative integers and computes their greatest common divisor (GCD) using both Euclidean method and a variant with bitwise operators. Problem Statement: Write the following three functions: 1. `gcd(a, b)`: Computes the greatest common divisor (GCD) of two non-negative integers `a` and `b` using Euclidean Algorithm. 2. `gcd_bit(a, b)`: Computes the greatest common divisor (GCD) of two non-negative integers `a` and `b` using bitwise operators. 3. `trailing_zero(x)`: Computes the number of trailing zeroes in the binary representation of an integer `x`. Function Signatures: ```python def gcd(a: int, b: int) -> int: pass def gcd_bit(a: int, b: int) -> int: pass def trailing_zero(x: int) -> int: pass ``` Constraints: - Non-negative integers `a` and `b`. - The functions should handle edge cases like when `a` or `b` is zero but should not allow negative or non-integer inputs (you can assume callers handle input validation). - Both algorithms should have a time complexity of O(log(min(a, b))). Example: ```python assert gcd(48, 18) == 6 assert gcd_bit(48, 18) == 6 assert trailing_zero(40) == 3 ``` Notes: - Even though `gcd` and `gcd_bit` functions ultimately solve the same problem, the algorithms differ in their approach. Ensure both methods are implemented independently. - The `trailing_zero` function is essential for the `gcd_bit` implementation; it counts the number of trailing zeros in the binary representation of a number.","solution":"def gcd(a: int, b: int) -> int: Computes the greatest common divisor (GCD) of two non-negative integers a and b using the Euclidean Algorithm. while b != 0: a, b = b, a % b return a def trailing_zero(x: int) -> int: Computes the number of trailing zeroes in the binary representation of an integer x. count = 0 while x != 0 and (x & 1) == 0: count += 1 x >>= 1 return count def gcd_bit(a: int, b: int) -> int: Computes the greatest common divisor (GCD) of two non-negative integers a and b using bitwise operators. if a == 0: return b if b == 0: return a # Count the number of trailing zeros shift = min(trailing_zero(a), trailing_zero(b)) # Divide a and b by 2^shift a >>= trailing_zero(a) b >>= trailing_zero(b) while b != 0: b >>= trailing_zero(b) if a > b: a, b = b, a b -= a return a << shift"},{"question":"Context You are working on a data stream processing system where you need to filter out excessive occurrences of certain elements, maintaining the original order as they appear. Task Implement a function `limit_duplicates(lst: List[int], n: int) -> List[int]` that takes a list of integers `lst` and an integer `n` as input, and returns a new list containing each element of `lst` at most `n` times, without reordering the elements. Input * `lst`: A list of integers. * `n`: An integer representing the maximum number of occurrences allowed for each element. Output * A list of integers, filtered according to the described rules. Constraints 1. `0 <= len(lst) <= 10^5` 2. `1 <= n <= 10^5` 3. `-10^9 <= lst[i] <= 10^9` (for any element in the list) Requirements * Your implementation should be efficient, with a time complexity of O(n). Example ```python assert limit_duplicates([1, 2, 3, 1, 2, 1, 2, 3], 2) == [1, 2, 3, 1, 2, 3] assert limit_duplicates([1, 1, 1, 1, 1], 3) == [1, 1, 1] assert limit_duplicates([], 2) == [] assert limit_duplicates([1, 2, 3, 4], 0) == [] assert limit_duplicates([4, 5, 6], 1) == [4, 5, 6] ``` Constraints to Consider * Ensure that all edge cases are handled (e.g., empty lists, single-element lists, lists with all elements the same). Note You may use the collections module for efficiently tracking element occurrences.","solution":"from typing import List from collections import defaultdict def limit_duplicates(lst: List[int], n: int) -> List[int]: Returns a list containing each element of lst at most n times, without reordering the elements. counts = defaultdict(int) result = [] for num in lst: if counts[num] < n: result.append(num) counts[num] += 1 return result"},{"question":"# Question: Inorder Traversal Implementation In the given binary tree structure, implement an inorder traversal without using any additional libraries. You can choose to implement it either iteratively or recursively, but keep the following constraints in mind: * Your code should be able to handle a binary tree of up to 10,000 nodes efficiently. * Ensure your implementation correctly handles all edge cases including but not limited to: empty trees, single-node trees, and trees with missing children. # Input Format A binary tree is represented by its root node, implemented using the provided `Node` class. Each `Node` object has properties: * `val`: Value of the node (integer). * `left`: Left child (reference to another `Node` object or `None`). * `right`: Right child (reference to another `Node` object or `None`). # Output Format Return a list of integer values representing the inorder traversal of the binary tree. # Example ```python # Example tree: # 100 # / # 50 150 # / / # 25 75 125 175 n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert inorder(n1) == [25, 50, 75, 100, 125, 150, 175] assert inorder_rec(n1) == [25, 50, 75, 100, 125, 150, 175] def inorder_rec(root): # Implementation here def inorder(root): # Implementation here ``` Implement the `inorder` iterative function and the `inorder_rec` recursive function to pass the example test case. # Constraints * The number of nodes in the tree will be between 0 and 10,000. * Node values are unique and integers between -10^9 and 10^9.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_rec(root): Recursive inorder traversal def helper(node): if node is None: return [] return helper(node.left) + [node.val] + helper(node.right) return helper(root) def inorder(root): Iterative inorder traversal result = [] stack = [] current = root while current is not None or stack: while current is not None: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result"},{"question":"# Scenario You are a security consultant for a high-profile client planning to invest in a series of properties. Each property has a certain value, and your client wants to maximize their investment return by selectively securing properties in a way that no two secured properties are adjacent, to avoid detection by competitors. Given a list representing the value of each property, design an algorithm to help your client determine the maximum value they can secure while adhering to this constraint. # Task Write a function `max_secure_investment(values)` that takes a list of non-negative integers `values`, where each integer represents the value of a property in a sequence of properties. The function should return the maximum value that can be secured without securing two adjacent properties. # Input * `values`: A list of non-negative integers representing the value of each property. # Output * An integer representing the maximum secured value. # Constraints * The length of `values` will be between 0 and 10000. * Each value in the list will be between 0 and 1000. # Performance Requirements * The solution should have a time complexity of O(n) and a space complexity of O(1). # Example ```python def max_secure_investment(values): last, now = 0, 0 for value in values: last, now = now, max(last + value, now) return now # Example test cases print(max_secure_investment([2, 7, 9, 3, 1])) # Output: 12 print(max_secure_investment([2, 1, 1, 2])) # Output: 4 ``` Use the given function template and complete the implementation to solve the problem as described.","solution":"def max_secure_investment(values): Returns the maximum value that can be secured without securing two adjacent properties. :param values: List of non-negative integers representing values of properties. :return: Integer representing the maximum secured value. if not values: return 0 last, now = 0, 0 for value in values: last, now = now, max(last + value, now) return now"},{"question":"Title: Implement LCM and Modular Inverse using GCD Context: You are developing a software that requires frequent computation of the least common multiple (LCM) and modular inverse using the greatest common divisor (GCD). The GCD computations need to be efficient and utilize bitwise operations for optimal performance. Question: 1. Write a Python function `lcm_optimized(a, b)` that computes the least common multiple of two non-negative integers `a` and `b` using the optimized GCD function provided (`gcd_bit`). 2. Write a Python function `modular_inverse(a, m)` that computes the modular inverse of a positive integer `a` modulo `m`. The modular inverse is an integer `x` such that (a*x) % m == 1. Use the Extended Euclidean algorithm for computing the modular inverse. Input: * Function `lcm_optimized(a, b)`: - Two non-negative integers `a` and `b` where 0 ≤ a, b ≤ 10^9. * Function `modular_inverse(a, m)`: - Two integers `a` (1 ≤ a ≤ 10^9) and `m` (2 ≤ m ≤ 10^9). Output: * Function `lcm_optimized(a, b)`: - Return an integer representing the least common multiple of `a` and `b`. * Function `modular_inverse(a, m)`: - Return the integer `x` such that `(a * x) % m == 1`. If the modular inverse does not exist, return -1. Constraints: * Avoid using built-in functions for GCD. * Ensure that both functions are optimized for large inputs. Example: ```python def gcd_bit(a, b): # Provided optimized GCD function def trailing_zero(x): count = 0 while x and not x & 1: count += 1 x >>= 1 return count tza = trailing_zero(a) tzb = trailing_zero(b) a >>= tza b >>= tzb while b: if a < b: a, b = b, a a -= b a >>= trailing_zero(a) return a << min(tza, tzb) def lcm_optimized(a, b): # Write your implementation here pass def modular_inverse(a, m): # Write your implementation here pass ``` # Example: ```python print(lcm_optimized(15, 20)) # Output: 60 print(modular_inverse(3, 11)) # Output: 4 ``` Note: For the modular inverse: - Use the Extended Euclidean algorithm to find coefficients x and y such that `a*x + m*y = gcd(a, m)`. - If `gcd(a, m)` is not 1, then the modular inverse does not exist.","solution":"def gcd_bit(a, b): # Provided optimized GCD function utilizing bitwise operations def trailing_zero(x): count = 0 while x and not x & 1: count += 1 x >>= 1 return count if a == 0: return b if b == 0: return a tza = trailing_zero(a) tzb = trailing_zero(b) a >>= tza b >>= tzb while b: if a < b: a, b = b, a a -= b a >>= trailing_zero(a) return a << min(tza, tzb) def lcm_optimized(a, b): if a == 0 or b == 0: return 0 gcd = gcd_bit(a, b) return abs(a * b) // gcd def modular_inverse(a, m): def extended_gcd(a, b): if a == 0: return b, 0, 1 gcd, x1, y1 = extended_gcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return gcd, x, y gcd, x, _ = extended_gcd(a, m) if gcd != 1: return -1 else: return x % m"},{"question":"# Scenario You are working on enhancing a caching system that operates as a key-value store for frequently accessed data. Currently, you have a basic Separate Chaining Hash Table implemented, but you need to add some additional features to streamline operations within this cache. This will involve implementing methods for retrieving all keys, resizing the hash table to handle load factor efficiently, and extending functionality to update values directly via object attribute setting. # Task **Separate Chaining Hash Table Enhancement**: * Implement a method `keys()` that returns a list of all keys present in the hash table. * Write a `resize(self, new_size)` method to change the size of the hash table and rehash all existing elements. * Implement `__setattr__(self, key, value)` to directly support setting values via object attributes if keys are already present in the table. For example, assuming `cache` is an instance of the hash table and \'some_key\' is an existing key, `cache.some_key = \'new_value\'` should update the value of \'some_key\'. # Function Signature ```python class SeparateChainingHashTable: ... def keys(self) -> List: Returns a list of all keys in the hash table. Returns: List: a list of keys. pass def resize(self, new_size: int) -> None: Resize the hash table to the new size and rehash all elements. Parameters: new_size (int): new size of the hash table. pass def __setattr__(self, key, value) -> None: Update the value of a key directly via setting attributes. Parameters: key: key to update. value: new value to set. pass ``` Constraints * Keys are strings and values can be any data type. * The hash table should resize when the load factor exceeds 0.7 or reduces to below 0.2. # Metrics Ensure that the above methods handle edge cases and have an average case time complexity of O(1) for insertion and lookup after implementation. # Example Usage ```python cache = SeparateChainingHashTable() cache.put(\'a\', 1) cache.put(\'b\', 2) print(cache.keys()) # Output: [\'a\', \'b\'] cache.resize(20) cache.a = 100 print(cache.get(\'a\')) # Output: 100 ```","solution":"class SeparateChainingHashTable: def __init__(self, initial_size=10): self.size = initial_size self.table = [[] for _ in range(self.size)] self.count = 0 self.load_factor_threshold = 0.7 def put(self, key, value): if self.count / self.size > self.load_factor_threshold: self.resize(2 * self.size) index = self._hash(key) for pair in self.table[index]: if pair[0] == key: pair[1] = value return self.table[index].append([key, value]) self.count += 1 def get(self, key): index = self._hash(key) for pair in self.table[index]: if pair[0] == key: return pair[1] return None def _hash(self, key): return hash(key) % self.size def keys(self): Returns a list of all keys in the hash table. all_keys = [] for bucket in self.table: for pair in bucket: all_keys.append(pair[0]) return all_keys def resize(self, new_size: int): Resize the hash table to the new size and rehash all elements. old_table = self.table self.size = new_size self.table = [[] for _ in range(self.size)] self.count = 0 for bucket in old_table: for pair in bucket: self.put(pair[0], pair[1]) def __setattr__(self, key, value) -> None: Update the value of a key directly via setting attributes. if key in [\\"size\\", \\"table\\", \\"count\\", \\"load_factor_threshold\\"]: super().__setattr__(key, value) return if key in self.keys(): self.put(key, value) else: raise AttributeError(f\\"\'SeparateChainingHashTable\' object has no attribute \'{key}\'\\")"},{"question":"# Problem: Find the Two Unique Numbers Description You are given an array of integers `nums` where exactly two elements appear only once, and all the other elements appear exactly twice. Your task is to find the two elements that appear only once. Your solution should have O(N) time complexity and O(1) space complexity. Function Signature ```python def find_two_unique_numbers(nums: List[int]) -> List[int]: ``` Input - `nums`: A list of integers, with a length between 2 and 10^5. Exactly two elements appear only once, and all the other elements appear exactly twice. Output - A list containing the two integers that appear only once. Constraints - Time Complexity: O(N) - Space Complexity: O(1) Example ```python find_two_unique_numbers([1, 2, 1, 3, 2, 5]) # Output: [3, 5] or [5, 3] ``` Context Suppose you are implementing a data deduplication service where you need to identify two unique identifiers from a batch of data where all other identifiers are duplicates. Use the above function to ensure you correctly identify these unique identifiers efficiently.","solution":"from typing import List def find_two_unique_numbers(nums: List[int]) -> List[int]: Find the two unique numbers in an array where every other number appears exactly twice. :param nums: List[int] - array of integers :return: List[int] - list containing the two unique integers xor = 0 for num in nums: xor ^= num # Find rightmost set bit in xor (which will be different between the two unique numbers) rightmost_set_bit = xor & -xor unique1, unique2 = 0, 0 for num in nums: if num & rightmost_set_bit: unique1 ^= num else: unique2 ^= num return [unique1, unique2]"},{"question":"# Problem Scenario You have been assigned to develop a feature for a dynamic search application where users frequently add and remove search keys from a dataset. To keep the dataset sorted and support efficient search operations, you decide to use a Binary Search Tree (BST). # Task Write a `BST` class that supports the following operations: - `insert(val)`: Inserts a value into the BST. - `delete(val)`: Removes a value from the BST if it exists. - `find(val)`: Checks if a value exists in the BST and returns `True` if it does, otherwise `False`. Your BST should be implemented using the given `TreeNode` class. TreeNode Class ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None ``` Expected Input and Output Formats - `insert(val)` inserts `val` (an integer) into the BST. - `delete(val)` deletes `val` (an integer) from the BST if found. - `find(val)` returns `True` if the value exists in the BST, otherwise `False`. Constraints - The `val` will be an integer. - The BST should handle edge cases such as inserting into or deleting from an empty tree. - Ensure that the tree remains a valid BST after each operation.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val): if self.root is None: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._insert(node.left, val) elif val > node.val: if node.right is None: node.right = TreeNode(val) else: self._insert(node.right, val) def delete(self, val): self.root = self._delete(self.root, val) def _delete(self, node, val): if not node: return node if val < node.val: node.left = self._delete(node.left, val) elif val > node.val: node.right = self._delete(node.right, val) else: if not node.left: return node.right elif not node.right: return node.left temp = self._min_value_node(node.right) node.val = temp.val node.right = self._delete(node.right, temp.val) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def find(self, val): return self._find(self.root, val) def _find(self, node, val): if node is None: return False if val == node.val: return True elif val < node.val: return self._find(node.left, val) else: return self._find(node.right, val)"},{"question":"Given a 2D grid map of \'1\'s (land) and \'0\'s (water), count the number of islands using Depth-First Search (DFS) instead of Breadth-First Search (BFS). An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. # Input - A list of list of integers `grid`, where `grid[i][j]` is either `1` (land) or `0` (water). The grid will always be non-empty. # Output - An integer representing the number of islands. # Constraints - `1 <= grid.length, grid[i].length <= 300` # Implementation Requirements - You must write a function `count_islands(grid)` that employs Depth-First Search (DFS) to solve the problem. # Example ```python Example 1: Input: grid = [ [1, 1, 1, 1, 0], [1, 1, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0] ] Output: 1 Example 2: Input: grid = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1] ] Output: 3 ``` # Code Template Here is a starting point for your implementation: ```python def count_islands(grid): def dfs(x, y): # Implement the DFS logic pass row = len(grid) col = len(grid[0]) num_islands = 0 for i in range(row): for j in range(col): if grid[i][j] == 1: # Perform DFS from the current cell dfs(i, j) num_islands += 1 return num_islands ```","solution":"def count_islands(grid): def dfs(x, y): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 0: return grid[x][y] = 0 # Mark this cell as visited by sinking the island dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) row = len(grid) col = len(grid[0]) num_islands = 0 for i in range(row): for j in range(col): if grid[i][j] == 1: dfs(i, j) num_islands += 1 return num_islands"},{"question":"# Josephus Problem - Function Implementation A group of people is seated in a circular fashion denoted as a list of unique identifiers. Starting from the first person, every third person (counted from the current person) is removed from the circle. The counting restarts immediately after the removed person. This process repeats until all people are removed from the circle. Implement the function `josephus(int_list: List[int], skip: int) -> List[int]` that performs the above operation and returns the list of people in the order they were removed. Input - `int_list`: A list of integers representing the people seated in a circle. `1 <= len(int_list) <= 10^5` - `skip`: An integer representing the step count for skipping people before the next removal. `skip >= 1` Output - A list of integers representing the order in which people were removed from the circle. Constraints - Ensure that your solution performs efficiently for larger inputs. - Avoid using excessive memory and handle edge cases gracefully. # Example ```python assert josephus([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) == [3, 6, 9, 4, 8, 5, 2, 7, 1] assert josephus([1, 2, 3], 2) == [2, 1, 3] ``` # Requirements - Ensure the function adheres to the time and space complexity suitable for large inputs. - Include edge-case handling in your implementation. Implement the function `josephus` based on the provided description.","solution":"from typing import List def josephus(int_list: List[int], skip: int) -> List[int]: Returns the order of people removed in the Josephus problem. :param int_list: List of unique identifiers representing people in a circle :param skip: An integer representing the step count for removal :return: A list of integers representing the removal order result = [] index = 0 while int_list: index = (index + skip - 1) % len(int_list) result.append(int_list.pop(index)) return result"},{"question":"You are required to implement the function to traverse a binary tree in level order. The function should return a nested list where each sublist represents the node values at that particular level of the tree. This traversal is also known as Breadth-First Search (BFS). Function Signature ```python def level_order(root: TreeNode) -> List[List[int]]: ``` # Input Format * `root`: The root node of the binary tree. It could be `None` indicating an empty tree. # Output Format * A list of lists, where each inner list contains the values of nodes at that depth level from left to right. # Constraints * The number of nodes in the tree will be in the range [0, 10^4]. * The tree node values are integers and could be positive, negative, or 0. # Performance Requirements * The solution should execute in O(N) time complexity, where N is the total number of nodes in the binary tree. * The space complexity should be O(N) in the worst case. # Example Example 1: Input Tree: ``` 3 / 9 20 / 15 7 ``` Function Call: ```python level_order(root) ``` Expected Output: ```python [ [3], [9,20], [15,7] ] ``` Example 2: Input Tree: ``` 1 ``` Function Call: ```python level_order(root) ``` Expected Output: ```python [ [1] ] ``` # Edge Cases 1. When the tree is empty, i.e., `root` is `None`, the function should return an empty list `[]`. # Notes - The binary tree node is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - Do not use any other library or functions except standard Python libraries.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = [root] while queue: level = [] next_queue = [] for node in queue: level.append(node.val) if node.left: next_queue.append(node.left) if node.right: next_queue.append(node.right) result.append(level) queue = next_queue return result"},{"question":"# Scenario A company requires an efficient system for managing its inventory records. The inventory must support quick searches, additions, and traversals to quickly generate lists for different segments or operations. Implement a Binary Search Tree to handle this dynamic set of inventory records. # Task Implement the following methods in a Binary Search Tree data structure: 1. `Insert(data)`: Inserts a data element into the BST. 2. `Search(data)`: Searches for a data element in the BST, returning True if the element is found, False otherwise. 3. `Size()`: Returns the number of elements in the BST. 4. Traversals: Implement the traversal methods: - `Preorder(root)`: Visit nodes in root-first, left, right order. - `Inorder(root)`: Visit nodes in left, root, right order. - `Postorder(root)`: Visit nodes in left, right, root order. # Expected Input and Output - **Input**: For `Insert` and `Search`, an integer value `data` to be inserted or searched. - **Output**: For `Insert`, return True if insertion is successful, False otherwise (for duplicate values). For `Search`, return True if the data is found, False otherwise. For `Size`, return the total number of elements in the BST. For traversal methods, print the elements in the respective order. # Constraints - Do not allow duplicate values in the tree. - The tree can contain any integer value. # Implementation Requirements - You must use a Node class to represent each node in the tree. - Make sure to perform operations recursively. - Handle edge cases such as empty trees and inserting/searching for values that are not present. # Example ```python # Initializing BST and performing operations bst = BST() bst.insert(10) bst.insert(5) bst.insert(20) print(bst.size()) # Output: 3 print(bst.search(5)) # Output: True print(bst.search(15)) # Output: False bst.inorder(bst.get_root()) # Output: 5 10 20 ```","solution":"class Node: def __init__(self, data): self.left = None self.right = None self.data = data class BST: def __init__(self): self.root = None self._size = 0 def insert(self, data): if self.root is None: self.root = Node(data) self._size += 1 return True else: return self._insert_rec(self.root, data) def _insert_rec(self, node, data): if data == node.data: return False elif data < node.data: if node.left is None: node.left = Node(data) self._size += 1 return True else: return self._insert_rec(node.left, data) else: if node.right is None: node.right = Node(data) self._size += 1 return True else: return self._insert_rec(node.right, data) def search(self, data): return self._search_rec(self.root, data) def _search_rec(self, node, data): if node is None: return False if data == node.data: return True elif data < node.data: return self._search_rec(node.left, data) else: return self._search_rec(node.right, data) def size(self): return self._size def get_root(self): return self.root def inorder(self, node): if node: self.inorder(node.left) print(node.data, end=\' \') self.inorder(node.right) def preorder(self, node): if node: print(node.data, end=\' \') self.preorder(node.left) self.preorder(node.right) def postorder(self, node): if node: self.postorder(node.left) self.postorder(node.right) print(node.data, end=\' \')"},{"question":"As a data scientist working on a text prediction model, you need to simulate a Markov Chain based on a given dictionary of state transitions. You have already learned how Markov Chains work and now need to implement your understanding into a specific function. Given a Markov Chain described as a dictionary and an initial state, write two functions: 1. **`transition_matrix(chain)`**: This function should take the Markov Chain as input and preprocess it into a format that optimizes the selection of next states. 2. **`simulate_chain(chain, initial_state, steps)`**: This function should simulate the state transitions for a given number of steps, starting from the initial state, and return a list of states encountered during the simulation. Function Specifications 1. `transition_matrix(chain)`: - **Input**: A dictionary where keys are states and values are another dictionary of transition probabilities. - **Output**: A processed transition matrix optimized for quick state transitions. 2. `simulate_chain(chain, initial_state, steps)`: - **Input**: - `chain`: The original Markov Chain as a dictionary. - `initial_state`: A string representing the starting state. - `steps`: An integer representing the number of steps to simulate. - **Output**: A list of states encountered from the initial_state over the given number of steps. - **Constraints**: - The number of states and transitions can be large, but the total state transition dictionary size will not exceed 10^6 entries. - The transitions for each state will sum up to 1. Example ```python chain = { \'A\': {\'A\': 0.6, \'B\': 0.4}, \'B\': {\'A\': 0.4, \'B\': 0.6} } initial_state = \'A\' steps = 5 trans_matrix = transition_matrix(chain) states = simulate_chain(trans_matrix, initial_state, steps) print(states) # Example Output: [\'A\', \'B\', \'B\', \'A\', \'B\'] ``` In your implementation, consider edge cases where the input might have missing states or improper transition sums. Your task is to ensure the functions handle such cases gracefully.","solution":"import random def transition_matrix(chain): Prepares a transition matrix from the given Markov Chain. Args: chain (dict): A dictionary representing the Markov chain with state transitions. Returns: dict: A processed transition matrix optimized for quick state transitions. trans_matrix = {} for state, transitions in chain.items(): cumulative_prob = 0.0 interval_list = [] for next_state, prob in transitions.items(): cumulative_prob += prob interval_list.append((cumulative_prob, next_state)) trans_matrix[state] = interval_list return trans_matrix def simulate_chain(chain, initial_state, steps): Simulates the Markov Chain for a given number of steps starting from the initial state. Args: chain (dict): A dictionary representing the Markov Chain transition matrix. initial_state (str): The starting state for the simulation. steps (int): The number of steps to simulate. Returns: list: List of states encountered during the simulation. current_state = initial_state result = [current_state] for _ in range(steps): next_intervals = chain[current_state] rand_val = random.random() for interval, state in next_intervals: if rand_val <= interval: current_state = state result.append(current_state) break return result"},{"question":"# Max Path Sum in a Binary Tree Problem Statement You are given the root of a binary tree. Your task is to write a function `max_path_sum(root)` that returns the maximum path sum. A \\"path\\" in this context is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Input * `root`: The root node of a binary tree, where each node contains an integer value `val`. Output * An integer representing the maximum path sum possible. Constraints * The number of nodes in the tree is in the range `[0, 3 * 10^4]`. * `-1000 <= Node.val <= 1000` Example ``` Input: 1 / 2 3 Output: 6 Explanation: The optimal path is 2 -> 1 -> 3, resulting in a sum of 6. ``` Edge Cases to Consider * The tree has only one node. * The tree contains negative values. * Balancing between left-heavy, right-heavy, and balanced trees in terms of path sums. Your function should be efficient in both time and space. It needs to process nodes efficiently even for large trees up to 30,000 nodes.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root): Returns the maximum path sum in the binary tree. def helper(node): nonlocal max_sum if not node: return 0 left_max = max(0, helper(node.left)) # max path sum on the left child right_max = max(0, helper(node.right)) # max path sum on the right child # Price to start a new path where `node` is the highest node price_newpath = node.val + left_max + right_max # Update max_sum if it\'s better to start a new path max_sum = max(max_sum, price_newpath) # For recursion: return the max gain if continue the same path return node.val + max(left_max, right_max) max_sum = float(\'-inf\') helper(root) return max_sum"},{"question":"# Pancake Sorting with Edge Cases Handling You are given an array of integers that may contain duplicate values. Your task is to implement the `pancake_sort` function which sorts the array using Pancake Sort. Ensure to handle all possible edge cases effectively. Function Signature ```python def pancake_sort(arr: List[int]) -> List[int]: Sorts the array `arr` using Pancake Sort. Parameters: arr: List[int] - a list of integers to be sorted Returns: List[int] - the sorted list ``` Input - An array of integers `arr` where: - `1 <= len(arr) <= 1000` - `-10^6 <= arr[i] <= 10^6` Output - A sorted array in ascending order. Constraints - You must sort the array in place. - You should consider and handle edge cases, and ensure that the solution is robust. Example ```python # Example 1 arr = [3, 2, 4, 1] print(pancake_sort(arr)) # Output: [1, 2, 3, 4] # Example 2 arr = [1, 2, 3] print(pancake_sort(arr)) # Output: [1, 2, 3] # Example 3 arr = [] print(pancake_sort(arr)) # Output: [] # Example 4 arr = [2, 2, 2] print(pancake_sort(arr)) # Output: [2, 2, 2] ``` Additionally, provide a brief description of how your implementation considers edge cases, such as empty array, already sorted array, all elements being the same, etc.","solution":"def pancake_sort(arr): Sorts the array `arr` using Pancake Sort. Parameters: arr: List[int] - a list of integers to be sorted Returns: List[int] - the sorted list def flip(sublist, k): Reverse the order of the first k elements of the given sublist (from 0 to k-1). return sublist[:k][::-1] + sublist[k:] for curr_size in range(len(arr), 1, -1): # Find index of the maximum element in arr[0..curr_size-1] max_index = 0 for i in range(1, curr_size): if arr[i] > arr[max_index]: max_index = i if max_index != curr_size - 1: # Move maximum element to the front by flipping arr upto max_index + 1 arr = flip(arr, max_index + 1) # Then move maximum element to the end by flipping arr upto curr_size arr = flip(arr, curr_size) return arr"},{"question":"# **Problem Statement: Implement Min Binary Heap with Extended Capabilities** You are required to implement a min binary heap with the capabilities to support prioritized element removal, and also track the current size of the heap. Additionally, the extended heap should provide functionality to directly get the minimum element without removing it. **Specifications**: - Class name: `ExtendedBinaryHeap` - Extend the provided `BinaryHeap` class. - Your class should support the following methods: 1. **`insert(self, val: int) -> None`** - Adds an element to the heap while maintaining the min-heap property. 2. **`remove_min(self) -> int`** - Removes and returns the minimum element (root) while maintaining the min-heap property. 3. **`get_min(self) -> int`** - Returns the minimum element without removing it. Returns `None` if heap is empty. 4. **`size(self) -> int`** - Returns the current number of elements in the heap. **Input/Output Format**: 1. **insert**: * Input: A single integer to be inserted into the heap. * Output: None 2. **remove_min**: * Input: None * Output: The smallest element (root) if heap is non-empty; should handle cases when the heap is empty. 3. **get_min**: * Input: None * Output: Returns minimum element (root) without removal if heap is non-empty; should return `None` when the heap is empty. 4. **size**: * Input: None * Output: Number of elements in the heap. **Constraints**: - All insertions will be non-negative integer values. - Heap will not start with any initial elements. **Example Scenario**: ```python heap = ExtendedBinaryHeap() heap.insert(10) heap.insert(5) heap.insert(3) print(heap.get_min()) # Output: 3 print(heap.size()) # Output: 3 print(heap.remove_min()) # Output: 3 print(heap.get_min()) # Output: 5 print(heap.size()) # Output: 2 ``` Handle errors effectively and ensure your code is optimized for the described operations.","solution":"class ExtendedBinaryHeap: def __init__(self): self.heap = [] def insert(self, val: int) -> None: self.heap.append(val) self._bubble_up(len(self.heap) - 1) def remove_min(self) -> int: if len(self.heap) == 0: raise IndexError(\\"remove_min from an empty heap\\") if len(self.heap) == 1: return self.heap.pop() min_value = self.heap[0] self.heap[0] = self.heap.pop() self._bubble_down(0) return min_value def get_min(self) -> int: if len(self.heap) == 0: return None return self.heap[0] def size(self) -> int: return len(self.heap) def _bubble_up(self, index): parent_idx = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_idx]: self.heap[index], self.heap[parent_idx] = self.heap[parent_idx], self.heap[index] self._bubble_up(parent_idx) def _bubble_down(self, index): smallest = index left_child_idx = 2 * index + 1 right_child_idx = 2 * index + 2 if left_child_idx < len(self.heap) and self.heap[left_child_idx] < self.heap[smallest]: smallest = left_child_idx if right_child_idx < len(self.heap) and self.heap[right_child_idx] < self.heap[smallest]: smallest = right_child_idx if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._bubble_down(smallest)"},{"question":"You are given a list of positive integers `nums` and a target integer `target`. Your task is to write a function that computes the number of possible unique combinations of elements in `nums` that sum up exactly to `target`. Each number in `nums` can be used multiple times in the combination. The order of elements in the combination matters, meaning different orders of the same combination should be counted as distinct. Write a function `combination_sum` that implements this using a dynamic programming approach. You need to provide both a top-down and bottom-up implementation in your solution. Function Signatures ```python def combination_sum_topdown(nums: List[int], target: int) -> int: pass def combination_sum_bottom_up(nums: List[int], target: int) -> int: pass ``` Input * `nums`: A list of positive integers without duplicates (1 ≤ |nums| ≤ 200). * `target`: A positive integer (1 ≤ target ≤ 1000). Output * An integer indicating the number of possible combinations that add up to `target`. Constraints * All input numbers are positive integers. * Duplicates in the combination are allowed, but different sequences of the same numbers are counted as different combinations. Example ```python nums = [1, 2, 3] target = 4 # The possible combination ways are: # (1, 1, 1, 1) # (1, 1, 2) # (1, 2, 1) # (1, 3) # (2, 1, 1) # (2, 2) # (3, 1) combination_sum_topdown(nums, target) -> 7 combination_sum_bottom_up(nums, target) -> 7 ``` Follow-up 1. If negative numbers are allowed in the given array, how does it change the problem? 2. What limitation do we need to add to the question to allow negative numbers? # Requirements 1. Implement and test both the top-down and bottom-up solutions. 2. Address the follow-up questions.","solution":"from typing import List def combination_sum_topdown(nums: List[int], target: int) -> int: mem = {} def helper(remain): if remain == 0: return 1 if remain in mem: return mem[remain] count = 0 for num in nums: if remain >= num: count += helper(remain - num) mem[remain] = count return count return helper(target) def combination_sum_bottom_up(nums: List[int], target: int) -> int: dp = [0] * (target + 1) dp[0] = 1 # There\'s one way to make target 0, by choosing nothing. for t in range(1, target + 1): for num in nums: if t >= num: dp[t] += dp[t - num] return dp[target]"},{"question":"# Coding Assessment: Subtree Validation Objective Write a function to determine if one binary tree is a subtree of another binary tree. Problem Definition Two binary trees are given: 1. `big`, a potentially large binary tree. 2. `small`, a binary tree which you need to validate as a subtree of `big`. A binary tree `t` is a subtree of `s` if there exists a node in `s` such that the subtree of `s` with that node as the root is identical to `t`. Function Signature ```python def is_subtree(big, small): pass ``` Input - `big`: A reference to the root of the larger binary tree. - `small`: A reference to the root of the smaller binary tree. Output - Return `True` if `small` is a subtree of `big`; otherwise, return `False`. Example ```python # Example 1 s = TreeNode(3) s.left = TreeNode(4) s.right = TreeNode(5) s.left.left = TreeNode(1) s.left.right = TreeNode(2) t = TreeNode(4) t.left = TreeNode(1) t.right = TreeNode(2) print(is_subtree(s, t)) # Output: True # Example 2 s = TreeNode(3) s.left = TreeNode(4) s.right = TreeNode(5) s.left.left = TreeNode(1) s.left.right = TreeNode(2) s.left.right.left = TreeNode(0) t = TreeNode(4) t.left = TreeNode(1) t.right = TreeNode(2) print(is_subtree(s, t)) # Output: False ``` Constraints - Consider the properties of a binary tree (each node has at most 2 children). - Evaluate both structure and node values for subtree matching. - Optimize for large trees where possible. Performance Requirements - Aim for an efficient solution that minimizes unnecessary comparisons. Note: You may assume you have access to the `TreeNode` class where each node has a `val`, `left`, and `right` attributes.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(big, small): Determine if `small` is a subtree of `big`. if not small: return True # An empty tree is always a subtree if not big: return False # Non-empty tree cannot be a subtree of an empty tree if is_same_tree(big, small): return True return is_subtree(big.left, small) or is_subtree(big.right, small) def is_same_tree(s, t): Check if two binary trees are identical. if not s and not t: return True if not s or not t: return False return s.val == t.val and is_same_tree(s.left, t.left) and is_same_tree(s.right, t.right)"},{"question":"# Problem: Implement an Enhanced Min Heap Design and implement a Min Heap class with the following enhancements: 1. Write unit tests to verify the functionality of each heap operation. 2. Integrate a `find_min` method to return the minimum value without removing it. 3. Augment the `insert` method to support batch insertion. 4. Optimize the `perc_up` and `perc_down` methods to reduce the number of swaps. 5. Include a method to validate if the array representation still maintains the heap property. # Requirements Methods - `insert(val: int)`: Insert a single value into the heap. - `batch_insert(vals: List[int])`: Insert multiple values into the heap at once. - `remove_min() -> int`: Remove and return the minimum value from the heap. - `find_min() -> int`: Return the minimum value without removing it from the heap. - `validate_heap() -> bool`: Return True if the array representation maintains the heap property, False otherwise. # Input and Output - **Input**: For single insertions, an integer value; for batch insertions, a list of integer values. - **Output**: For removal methods, return the removed value. For the `validate_heap` method, return a boolean indicating the heap\'s correctness. # Constraints - Assume that all inputs are valid integers. - The heap should handle at least 10,000 elements efficiently. # Sample Usage ```python min_heap = EnhancedMinHeap() # Insert elements min_heap.insert(10) min_heap.insert(5) min_heap.insert(30) # Check min element (should be 5) assert min_heap.find_min() == 5 # Remove min element (should be 5) assert min_heap.remove_min() == 5 # Validate the heap property assert min_heap.validate_heap() == True # Batch insert elements min_heap.batch_insert([1, 2, 3, 4]) # Check min element (should be 1) assert min_heap.find_min() == 1 # Validate the heap property assert min_heap.validate_heap() == True ``` - Implement the `EnhancedMinHeap` class.","solution":"class EnhancedMinHeap: def __init__(self): self.heap = [] def insert(self, val): self.heap.append(val) self._perc_up(len(self.heap) - 1) def batch_insert(self, vals): for val in vals: self.insert(val) def remove_min(self): if len(self.heap) == 0: return None if len(self.heap) == 1: return self.heap.pop() root = self.heap[0] self.heap[0] = self.heap.pop() self._perc_down(0) return root def find_min(self): if len(self.heap) == 0: return None return self.heap[0] def validate_heap(self): n = len(self.heap) for i in range(n): left = 2 * i + 1 right = 2 * i + 2 if left < n and self.heap[i] > self.heap[left]: return False if right < n and self.heap[i] > self.heap[right]: return False return True def _perc_up(self, idx): while (idx - 1) // 2 >= 0: parent = (idx - 1) // 2 if self.heap[idx] < self.heap[parent]: self.heap[idx], self.heap[parent] = self.heap[parent], self.heap[idx] idx = parent def _perc_down(self, idx): while (2 * idx + 1) < len(self.heap): smallest = self._min_child(idx) if self.heap[idx] > self.heap[smallest]: self.heap[idx], self.heap[smallest] = self.heap[smallest], self.heap[idx] idx = smallest def _min_child(self, idx): if (2 * idx + 2) >= len(self.heap): return 2 * idx + 1 if self.heap[2 * idx + 1] < self.heap[2 * idx + 2]: return 2 * idx + 1 return 2 * idx + 2"},{"question":"# Problem Description: You are given an array containing n elements where each element is an integer that represents a color using the values: 0 (red), 1 (white), and 2 (blue). Your task is to sort these colors in such a way that elements are ordered as red, white, and blue respectively. # Function Signature: ```python def sort_colors(nums: List[int]) -> None: ``` # Input: - `nums`: A list of integers where each integer is either 0, 1, or 2. # Output: - The function should modify the input list in-place so that it is sorted in the order of red (0), white (1), and blue (2). # Constraints: - Do not use the built-in sort function. - The input list is non-empty and contains only 0s, 1s, and 2s. - The solution must have a linear time complexity O(n) and use constant space O(1). # Example: ```python nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output: [0, 0, 1, 1, 2, 2] nums = [1, 0, 2, 1, 0] sort_colors(nums) print(nums) # Output: [0, 0, 1, 1, 2] ``` # Explanation: The input list will be modified in-place, such that the final array will have all instances of 0s first, followed by all instances of 1s, and then all instances of 2s. # Notes: - Ensure to handle all specified constraints and edge cases. - The function should be efficient in both time and space complexity.","solution":"from typing import List def sort_colors(nums: List[int]) -> None: Sort the list of colors in place where: 0 = red, 1 = white, 2 = blue red, white, blue = 0, 0, len(nums) - 1 while white <= blue: if nums[white] == 0: nums[red], nums[white] = nums[white], nums[red] red += 1 white += 1 elif nums[white] == 1: white += 1 else: nums[white], nums[blue] = nums[blue], nums[white] blue -= 1"},{"question":"You are tasked with writing a function that performs a linear search, but with an additional requirement: your function should be able to search not just for individual elements but also for subarrays within the larger array. # Function Signature ```python def linear_search_subarray(array, subarray): Find the starting index of the first occurrence of the given subarray in the array. If the subarray couldn\'t be found, returns -1. :param array: List of elements within the main array. :param subarray: List of elements representing the subarray to search for. :return: Integer index of the start of the subarray if found, else -1. ``` # Input * `array`: A list of integers, which can be empty. * `subarray`: A list of integers, which may also be empty. # Output * An integer representing the index of the first occurrence of the subarray within the array. If the subarray is not found, return -1. # Constraints * The elements of both `array` and `subarray` will be integers. * The function should efficiently handle arrays and subarrays of length up to 10^5. # Example ```python assert linear_search_subarray([1, 2, 3, 4, 5], [3, 4]) == 2 assert linear_search_subarray([1, 2, 3, 4, 5], [6]) == -1 assert linear_search_subarray([1, 2, 2, 2, 3], [2, 2]) == 1 ``` # Implementation Notes 1. If the subarray is longer than the array, return -1. 2. Consider edge cases such as: - Subarray being empty. - Array being empty. - Multiple occurrences of the subarray within the array, but only return the index of the first one. # Performance Expectations The solution should aim for a linear-time complexity relative to the length of the array and subarray, i.e., O(n * m), where n is the length of the array and m is the length of the subarray.","solution":"def linear_search_subarray(array, subarray): Find the starting index of the first occurrence of the given subarray in the array. If the subarray couldn\'t be found, returns -1. :param array: List of elements within the main array. :param subarray: List of elements representing the subarray to search for. :return: Integer index of the start of the subarray if found, else -1. if not subarray: return 0 if not array else 0 len_array, len_subarray = len(array), len(subarray) for i in range(len_array - len_subarray + 1): if array[i:i+len_subarray] == subarray: return i return -1"},{"question":"Scenario In a software system that processes and verifies the similarity of text data, identifying structural similarity between patterns of character sequences is crucial. You are tasked with designing a function to determine if two given strings are isomorphic. Challenge Write a Python function `is_isomorphic(s, t)` that determines if the two input strings `s` and `t` are isomorphic. Two strings are isomorphic if the characters in one string can be replaced to get the other string. This means there is a one-to-one mapping between every character in `s` to a character in `t`. Specifications - **Input**: Two strings `s` and `t`, where `1 <= len(s), len(t) <= 5 * 10^4`. - **Output**: Return a boolean value (`True` or `False`) indicating if the strings are isomorphic. Constraints - All occurrences of a character must map to the same character. - No two characters may map to the same character, but a character may map to itself. - Handle typical edge cases including different string lengths and large inputs efficiently. Example ```python def is_isomorphic(s, t): # Your code here pass print(is_isomorphic(\\"egg\\", \\"add\\")) # Output: True print(is_isomorphic(\\"foo\\", \\"bar\\")) # Output: False print(is_isomorphic(\\"paper\\", \\"title\\"))# Output: True ``` The expected function handles edge cases and performs efficiently for strings with up to 50,000 characters. Ensure your implementation processes the inputs correctly within the performance constraints.","solution":"def is_isomorphic(s, t): Determines if two strings s and t are isomorphic. if len(s) != len(t): return False # Create two dictionaries to store the mappings s_to_t = {} t_to_s = {} for char_s, char_t in zip(s, t): if char_s in s_to_t: if s_to_t[char_s] != char_t: return False else: s_to_t[char_s] = char_t if char_t in t_to_s: if t_to_s[char_t] != char_s: return False else: t_to_s[char_t] = char_s return True"},{"question":"# Hailstone Sequence Analysis and Shortest Path to One Context The hailstone sequence generates a sequence of numbers starting from an integer `n` and following specified rules until it reaches 1. This sequence can be unexpectedly long or short due to its unpredictable nature. Task Implement a function that not only generates the hailstone sequence for a given `n` but also counts the number of steps to reach 1 and returns both the sequence and the step count. Function Signature ```python def hailstone_analysis(n: int) -> tuple: Generates the hailstone sequence and counts steps to 1. Parameters: n (int): The starting value of the sequence. Returns: tuple: A tuple containing: - A list of integers representing the hailstone sequence. - An integer representing the total number of steps to reach 1. ``` Constraints * `n` should be a positive integer (1 ≤ n ≤ 10^6). Examples ```python print(hailstone_analysis(7)) # Output: ([7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1], 16) print(hailstone_analysis(1)) # Output: ([1], 0) ``` Requirements * Ensure the function handles the edge case where `n = 1`. * Optimize for large `n` to avoid excessive memory usage or stack overflows. * Verify that the function correctly calculates the number of steps. * Document and test the function thoroughly.","solution":"def hailstone_analysis(n: int) -> tuple: Generates the hailstone sequence and counts steps to 1. Parameters: n (int): The starting value of the sequence. Returns: tuple: A tuple containing: - A list of integers representing the hailstone sequence. - An integer representing the total number of steps to reach 1. if n < 1: raise ValueError(\\"n should be a positive integer (1 ≤ n ≤ 10^6).\\") sequence = [] steps = 0 while n != 1: sequence.append(n) if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 steps += 1 sequence.append(1) # Append the final 1 to the sequence return sequence, steps"},{"question":"# Context: Imagine you\'re working in a team developing a low-level library for data integrity checking. One of the essential functionalities is to determine how many bits are different between two integer values. Given the following problem description, implement the required function. # Problem Description: Write a function named `count_flips_to_convert` that determines the minimal number of bits you must flip to convert integer `a` to integer `b`. # Requirements: * **Input**: * `a` (int): The first integer. * `b` (int): The second integer. * **Output**: * (int): The number of bits that must be flipped to convert `a` to `b`. # Constraints: * All input integers are non-negative. * The function must operate within `O(k)` time complexity, where `k` is the number of bits in the binary representation of the inputs. # Example: * Input: `29`, `15` * Binary forms: `29` (11101), `15` (01111) * Expected Output: `2` * Explanation: The third most significant bit and the least significant bit differ. # Function Signature: ```python def count_flips_to_convert(a: int, b: int) -> int: pass ``` Ensure your implementation covers edge cases, manages performance efficiently, and includes necessary comments to explain your logic.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Determines the minimal number of bits you must flip to convert integer `a` to integer `b`. Parameters: a (int): The first integer. b (int): The second integer. Returns: int: The number of bits that must be flipped to convert `a` to `b`. # XOR both numbers. The result will have bits set to 1 where `a` and `b` differ. xor_result = a ^ b # Count the number of set bits in the XOR result. count = 0 while xor_result: count += xor_result & 1 xor_result >>= 1 return count"},{"question":"# Question: Implement a Function to Remove Duplicates from an Array Problem Description: You are given a list that may contain duplicates. Write a Python function `optimized_remove_duplicates` that removes any duplicates from this list and returns a new list with unique elements, maintaining the original order of their first occurrence. Function Signature: ```python def optimized_remove_duplicates(array: List[Any]) -> List[Any]: pass ``` Input: * The function will receive a list `array` with elements of any data type. * `array` has a length of at most (10^6) elements. Output: * The function must return a list with duplicates removed while preserving the order of first appearance. Constraints: * Use an efficient approach with a time complexity of O(n). * Handle mixed data types within the list. * Preserve the order of first occurrences from the input list. Example: ```python # Example 1 array = [1, 1, 1, 2, 2, 3, 4, 4, \\"hey\\", \\"hey\\", \\"hello\\", True, True] print(optimized_remove_duplicates(array)) # Output: [1, 2, 3, 4, \'hey\', \'hello\', True] # Example 2 array = [\'apple\', \'banana\', \'banana\', \'carrot\', \'apple\'] print(optimized_remove_duplicates(array)) # Output: [\'apple\', \'banana\', \'carrot\'] ```","solution":"from typing import List, Any def optimized_remove_duplicates(array: List[Any]) -> List[Any]: Removes duplicates from the array while preserving the order of first occurrence. seen = set() unique_array = [] for item in array: if item not in seen: seen.add(item) unique_array.append(item) return unique_array"},{"question":"Finding the Extra Letter # Context You\'re working on a text processing system and need to identify discrepancies between two versions of text. Specifically, you need to find out which letter was added to the new version of the text. Given two strings, `s` and `t`, where `t` is generated by shuffling `s` and adding one more letter at a random position, determine the added letter. # Task Write a function `find_difference(s: str, t: str) -> str` that returns the letter that was added to string `t`. # Input - `s`: A string containing lowercase letters with length `n` (1 ≤ n ≤ 10⁵). - `t`: A string containing lowercase letters with length `n + 1`. # Output - Returns a single character, which is the letter added to `t`. # Constraints - Both strings consist of only lowercase letters. - String `t` is generated by random shuffling of string `s` and then adding one more random lowercase letter. # Performance Requirements - The solution should be efficient with a time complexity of O(n) and space complexity of O(1). # Example ```python # Example 1: s = \\"abcd\\" t = \\"abecd\\" # Output: \'e\' # Example 2: s = \\"xyz\\" t = \\"xyaz\\" # Output: \'a\' ``` # Notes - Implement the function using the XOR operation for optimal performance. - Consider edge cases such as strings with repeated characters and verify correctness accordingly.","solution":"def find_difference(s: str, t: str) -> str: Find the letter added to t compared to s. result = 0 for char in s: result ^= ord(char) for char in t: result ^= ord(char) return chr(result)"},{"question":"You are given a list of integers which you need to sort in ascending order. Implement the `comb_sort` function that performs the sorting using the Comb Sort algorithm. The goal of this function is to use a combination of a shrinking gap towards adjacent comparison to sort the array efficiently. # Function Signature: ```python def comb_sort(arr: List[int]) -> List[int]: pass ``` # Input: - `arr`: A list of integers. (0 ≤ len(arr) ≤ 10^6, -10^9 ≤ arr[i] ≤ 10^9) # Output: - Returns a list of integers sorted in ascending order. # Constraints: - You have to implement the sorting algorithm with minimal auxiliary space (in-place sorting). - Attention must be given to handling large datasets efficiently. # Example: ```python # Example 1: input: [5, 1, 4, 2, 8] output: [1, 2, 4, 5, 8] # Example 2: input: [] output: [] # Example 3: input: [3, 3, 3, 3, 3] output: [3, 3, 3, 3, 3] ``` # Additional Information: - Arrays may contain negative numbers as well as positive. - Ensure to aim for the best possible time complexity. - Consider edge cases like empty arrays and arrays with all identical elements. # Performance Requirements: - Your solution should handle inputs efficiently keeping space complexity O(1) and aiming for best achievable average time complexity.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Sorts the array using the comb sort algorithm. def get_next_gap(gap): # Shrink gap by Shrink factor gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True # Keep running while gap is more than 1 and last iteration caused a swap while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Context In various applications such as cryptography, it\'s vital to determine if a number is prime with high confidence while maintaining computational efficiency. The Rabin-Miller primality test is employed for such scenarios due to its probabilistic nature, providing a quick yet reliable assessment of primality. # Problem Implement the function `check_prime_list(numbers, k)` that takes as input a list of integers `numbers` and an integer `k` (accuracy parameter), and returns a list of boolean values. Each boolean value corresponds to whether the respective integer in `numbers` is prime, using the Rabin-Miller primality test with `k` iterations. # Input * `numbers`: List of integers to test for primality: (List[int]) * `k`: Number of iterations for the Rabin-Miller test (a positive integer): (int) # Output * List of boolean values indicating primality for each corresponding integer from the input list. # Function Signature ```python def check_prime_list(numbers: List[int], k: int) -> List[bool]: ``` # Example ```python print(check_prime_list([2, 3, 4, 5, 16, 17, 18, 19], 5)) # Output: [True, True, False, True, False, True, False, True] ``` # Constraints * The input list `numbers` can contain up to (10^6) integers. * Each integer in `numbers` is in the range (2) to (10^{12}). * The accuracy parameter `k` is in the range (1) to (25). # Notes 1. Numbers less than 5 should be handled correctly. 2. Ensure efficient handling of large numbers to meet the performance requirements. 3. Aim to optimize the algorithm within given constraints to handle up to (10^6) integers efficiently. # Implementation Guidance You can reuse the `is_prime` function in your implementation and adapt it to process multiple integers based on the provided constraints.","solution":"import random from typing import List def miller_rabin_test(d, n): a = 2 + random.randint(1, n - 4) x = pow(a, d, n) if x == 1 or x == n - 1: return True while d != n - 1: x = (x * x) % n d *= 2 if x == 1: return False if x == n - 1: return True return False def is_prime(n: int, k: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False d = n - 1 while d % 2 == 0: d //= 2 for _ in range(k): if not miller_rabin_test(d, n): return False return True def check_prime_list(numbers: List[int], k: int) -> List[bool]: return [is_prime(num, k) for num in numbers]"},{"question":"**Scenario**: An urban planner needs to find the optimal location for a new facility such that the total walking distance to all residential buildings is minimized. You are given a city grid represented as a 2D array where: - `0` represents an empty land, - `1` represents a building, and - `2` represents an obstacle that cannot be passed through. Write a function called `optimal_facility_location` that computes the shortest total distance from an optimal filling point to all buildings. If no such point exists, return `-1`. Your function should consider the following: 1. A facility can only be placed on empty land (`0`). 2. Movement is only allowed in four directions: up, down, left, and right. 3. All buildings must be reachable from the chosen empty plot. **Function signature**: ```python def optimal_facility_location(grid: List[List[int]]) -> int: pass ``` **Constraints**: - The grid size will be between `1x1` and `50x50` inclusive. - There will be at least one building. **Input**: A 2D list of integers representing the city grid. **Output**: An integer representing the minimum total walking distance to all buildings, or `-1` if no such point exists. # Examples: 1. Given the following grid: ```python grid = [ [1, 0, 2, 0, 1], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0] ] optimal_facility_location(grid) == 7 ``` 2. Given the following grid: ```python grid = [ [1, 0], [2, 0] ] optimal_facility_location(grid) == 1 ``` 3. Given the following grid: ```python grid = [ [1, 2, 1], [2, 0, 2] ] optimal_facility_location(grid) == -1 ``` **Explanation**: - For the first example, placing the facility at position `(1,2)` results in a minimum total distance of 7. - For the second example, placing the facility at position `(1, 1)` results in a minimum total distance of 1. - For the third example, no empty plot can reach all buildings, thus returning `-1`. Ensure your implementation adheres to the performance constraints and handles edge cases effectively.","solution":"from typing import List from collections import deque def optimal_facility_location(grid: List[List[int]]) -> int: n, m = len(grid), len(grid[0]) def bfs(start_i, start_j): visited = [[False] * m for _ in range(n)] queue = deque([(start_i, start_j, 0)]) total_distance = 0 buildings_reached = 0 while queue: x, y, dist = queue.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]: visited[nx][ny] = True if grid[nx][ny] == 0: queue.append((nx, ny, dist + 1)) elif grid[nx][ny] == 1: total_distance += (dist + 1) buildings_reached += 1 return total_distance if buildings_reached == total_buildings else float(\'inf\') total_buildings = sum(row.count(1) for row in grid) min_distance = float(\'inf\') for i in range(n): for j in range(m): if grid[i][j] == 0: distance = bfs(i, j) min_distance = min(min_distance, distance) return -1 if min_distance == float(\'inf\') else min_distance"},{"question":"# Question You are given an array of integers `nums` where exactly two elements appear only once, and all the other elements appear exactly twice. Implement a function `findUniqueElements` to find the two elements that appear only once in the array. The function should achieve this in linear time complexity O(N) and constant space complexity O(1). Function Signature ```python def findUniqueElements(nums: List[int]) -> List[int]: pass ``` Input - `nums`: A list of integers where the length of `nums` will be between 2 and 10^5. - It is guaranteed that exactly two elements will appear only once, and all other elements will appear exactly twice. Output - The function should return a list of two integers that appear only once in any order. Constraints - Time Complexity: O(N) - Space Complexity: O(1) - You must not use any additional structures such as hash sets or dictionaries. Example ```python assert findUniqueElements([1, 2, 1, 3, 2, 5]) in [[3, 5], [5, 3]] assert findUniqueElements([4, 4, 6, 7]) in [[6, 7], [7, 6]] ``` Notes - This problem revolves around bit manipulation and XOR operations. - The order of the elements in the result list does not matter. Hints - Consider how XOR operation could help in isolating the unique elements. - Remember XOR properties where `x ^ x = 0` and `x ^ 0 = x`.","solution":"def findUniqueElements(nums): Returns the two unique elements in the list where all other elements appear twice. # Initial pass to XOR all elements xor_all = 0 for num in nums: xor_all ^= num # Find a set bit in xor_all (rightmost set bit) rightmost_set_bit = xor_all & -xor_all # Separate elements into two groups and XOR them unique1 = 0 unique2 = 0 for num in nums: if num & rightmost_set_bit: unique1 ^= num else: unique2 ^= num return [unique1, unique2]"},{"question":"# Binary Search Tree Operations and Applications You are provided with an implementation of a Binary Search Tree (BST). Your task is to extend the functionality of this BST in the following ways: 1. **Delete Operation**: - Implement a method `delete(self, data)` that removes a node with the specified `data` from the BST. Ensure that the tree remains a valid BST after the deletion. 2. **Height Calculation**: - Implement a method `height(self)` that returns the height of the BST. The height of an empty tree is defined to be -1, and the height of a single-node tree is 0. 3. **Level Order Traversal**: - Implement a method `level_order(self, root)` that prints the level order traversal of the tree. Level order traversal is also known as Breadth-First Search (BFS). 4. **Rebalancing Mechanism** (Optional, for extra credit): - Implement a method `rebalance(self)` that rebalances the BST to ensure that its height is minimized. # Input and Output Function definitions: - `delete(self, data)`: Removes the node containing `data` and returns `True` if the operation was successful, otherwise `False`. - `height(self)`: Returns the integer height of the tree. - `level_order(self, root)`: Prints the nodes of the BST in level-order. # Constraints - The tree contains unique integer values. - Avoid duplicates in the tree. # Performance Requirements - Ensure that all implemented methods are efficient and perform well in a variety of scenarios, including edge cases such as highly unbalanced trees. # Example The existing methods will be used in the test cases. Add the following test cases to verify your implementation: ```python class ExtendedTestSuite(unittest.TestCase): def setUp(self): self.tree = BST() self.tree.insert(10) self.tree.insert(15) self.tree.insert(6) self.tree.insert(4) self.tree.insert(9) self.tree.insert(12) self.tree.insert(24) self.tree.insert(7) self.tree.insert(20) self.tree.insert(30) self.tree.insert(18) def test_delete(self): self.assertTrue(self.tree.delete(24)) self.assertFalse(self.tree.search(24)) self.assertEqual(10, self.tree.size()) def test_height(self): self.assertEqual(4, self.tree.height()) def test_level_order(self): expected_output = \\"10 6 15 4 9 12 24 7 20 30 18\\" from io import StringIO import sys captured_output = StringIO() sys.stdout = captured_output self.tree.level_order(self.tree.get_root()) sys.stdout = sys.__stdout__ self.assertEqual(expected_output, captured_output.getvalue().strip()) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, data): self.left = None self.right = None self.data = data class BST: def __init__(self): self.root = None def insert(self, data): if self.root is None: self.root = Node(data) else: self._insert_recursive(self.root, data) def _insert_recursive(self, node, data): if data < node.data: if node.left is None: node.left = Node(data) else: self._insert_recursive(node.left, data) else: if node.right is None: node.right = Node(data) else: self._insert_recursive(node.right, data) def search(self, data): return self._search_recursive(self.root, data) def _search_recursive(self, node, data): if node is None: return False if data == node.data: return True elif data < node.data: return self._search_recursive(node.left, data) else: return self._search_recursive(node.right, data) def delete(self, data): self.root, deleted = self._delete_recursive(self.root, data) return deleted def _delete_recursive(self, node, data): if node is None: return node, False if data < node.data: node.left, deleted = self._delete_recursive(node.left, data) elif data > node.data: node.right, deleted = self._delete_recursive(node.right, data) else: # Node to be deleted found deleted = True if node.left is None: return node.right, deleted elif node.right is None: return node.left, deleted succ = self._find_min(node.right) node.data = succ.data node.right, _ = self._delete_recursive(node.right, succ.data) return node, deleted def _find_min(self, node): while node.left is not None: node = node.left return node def height(self): return self._height_recursive(self.root) def _height_recursive(self, node): if node is None: return -1 left_height = self._height_recursive(node.left) right_height = self._height_recursive(node.right) return max(left_height, right_height) + 1 def level_order(self, root): if root is None: return queue = [] queue.append(root) order = [] while queue: node = queue.pop(0) order.append(node.data) if node.left is not None: queue.append(node.left) if node.right is not None: queue.append(node.right) print(\\" \\".join(map(str, order))) def get_root(self): return self.root"},{"question":"# Cycle Sort Implementation and Validation Objective Implement the cycle sort algorithm and validate its functionality with various edge cases. Instructions You are given an array of integers. Your task is to implement the cycle sort algorithm to sort the array in ascending order. Ensure your implementation handles possible edge cases effectively. Specifications * **Function**: `def cycle_sort(arr: List[int]) -> List[int]:` * **Input**: - `arr` (List[int]): A list of integers (can be empty, contain duplicates, or be pre-sorted). * **Output**: - Returns a new list with the elements sorted in ascending order. * **Constraints**: - The input list can have a maximum length of (10^3). - Each integer in the list will be in the range ([-10^5, 10^5]). Example Cases 1. **Example 1**: * Input: `[3, 5, 2, 1, 4]` * Output: `[1, 2, 3, 4, 5]` 2. **Example 2**: * Input: `[4, 3, 2, 1]` * Output: `[1, 2, 3, 4]` 3. **Example 3**: * Input: `[1, 2, 3, 4, 5]` * Output: `[1, 2, 3, 4, 5]` 4. **Example 4**: * Input: `[1, 1, 1, 1]` * Output: `[1, 1, 1, 1]` 5. **Example 5**: * Input: `[]` * Output: `[]` Performance Expectations The implementation should handle the given constraints effectively. Testing will include searching for correct functionality and handling of edge cases.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: Sorts an array of integers using the cycle sort algorithm and returns the sorted array. # Copy the array so that we don\'t alter the original one. result = arr[:] # Cycle Sort implementation n = len(result) for cycle_start in range(0, n - 1): item = result[cycle_start] # Find the position where we put the element pos = cycle_start for i in range(cycle_start + 1, n): if result[i] < item: pos += 1 # If the item is already in the correct position, continue if pos == cycle_start: continue # Skip duplicates while item == result[pos]: pos += 1 # Put the item to the right position if pos != cycle_start: result[pos], item = item, result[pos] # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if result[i] < item: pos += 1 while item == result[pos]: pos += 1 if item != result[pos]: result[pos], item = item, result[pos] return result"},{"question":"You are required to implement a function to invert a square matrix (n x n) using the cofactor expansion method. Your function should handle the edge cases and return appropriate error messages for invalid inputs. # Function Signature ```python def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: pass ``` # Input - `matrix` (List[List[float]]): A square matrix (n x n), where 2 ≤ n ≤ 10. # Output - Returns the inverse of the given matrix, if invertible. - If the matrix is non-square or singular, return an error message according to the following: - [[\\"Invalid matrix: array is not a matrix\\"]] if the array is not a matrix. - [[\\"Invalid matrix: matrix is not square\\"]] if the matrix is not square. - [[\\"Invalid matrix: matrix is too small\\"]] if the matrix is smaller than 2x2. - [[\\"Invalid matrix: matrix is singular (determinant = 0)\\"]] if the matrix is singular. # Constraints - Use floating-point arithmetic for matrix operations. - You are allowed to use standard Python libraries and functions. # Example Example 1: **Input**: ```python matrix = [ [4, 7], [2, 6] ] ``` **Output**: ```python [ [0.6, -0.7], [-0.2, 0.4] ] ``` Example 2: **Input**: ```python matrix = [ [1, 2, 3], [0, 1, 4], [5, 6, 0] ] ``` **Output**: ```python [ [-24.0, 18.0, 5.0], [20.0, -15.0, -4.0], [-5.0, 4.0, 1.0] ] ``` Example 3: **Input**: ```python matrix = [ [1, 2], [2, 4] ] ``` **Output**: ```python [ [\\"Invalid matrix: matrix is singular (determinant = 0)\\"] ] ``` # Note - Ensure your implementation is efficient and handles all edge cases effectively. - You may assume the input matrix contains valid numerical data, and there\'s no need for element-wise validation.","solution":"from typing import List def determinant(matrix: List[List[float]], n: int) -> float: Recursive function to calculate the determinant of a square matrix. if n == 1: return matrix[0][0] if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(n): sub_matrix = [[matrix[r][cc] for cc in range(n) if cc != c] for r in range(1, n)] sign = (-1) ** c det += sign * matrix[0][c] * determinant(sub_matrix, n - 1) return det def get_cofactor(matrix: List[List[float]], p: int, q: int, n: int) -> List[List[float]]: Function to get a cofactor of the matrix. cofactor_matrix = [] for r in range(n): if r != p: row = [matrix[r][c] for c in range(n) if c != q] cofactor_matrix.append(row) return cofactor_matrix def adjoint(matrix: List[List[float]]) -> List[List[float]]: Function to get the adjoint of the matrix. n = len(matrix) if n == 1: return [[1]] adj = [[0] * n for _ in range(n)] for r in range(n): for c in range(n): cofactor = get_cofactor(matrix, r, c, n) sign = (-1) ** (r + c) adj[c][r] = sign * determinant(cofactor, n - 1) return adj def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: if not all(isinstance(row, list) and len(row) == len(matrix) for row in matrix): return [[\\"Invalid matrix: array is not a matrix\\"]] n = len(matrix) if n < 2: return [[\\"Invalid matrix: matrix is too small\\"]] det = determinant(matrix, n) if det == 0: return [[\\"Invalid matrix: matrix is singular (determinant = 0)\\"]] adj = adjoint(matrix) inv_matrix = [[adj[r][c] / det for c in range(n)] for r in range(n)] return inv_matrix"},{"question":"# Question **Context**: You have been hired by a company to assist in improving the performance of their internal sorting system. They currently use Bubble Sort, which is proving inefficient for their needs. **Prompt**: Given an unsorted list of integers, implement the Comb Sort algorithm to sort the list in ascending order. Your solution should follow the Comb Sort principles of initially using a large gap and reducing it progressively until it becomes 1. **Function Signature**: ```python def comb_sort(arr: List[int]) -> List[int]: ``` **Input**: - A list of integers `arr` of length `n` (0 ≤ n ≤ 10^6). **Output**: - Return a list of integers sorted in ascending order. **Constraints**: - The algorithm should handle large lists efficiently. - Consider edge cases such as an empty list or a list with a single element. # Examples **Example 1**: ```python input: [34, 7, 23, 32, 5, 62] output: [5, 7, 23, 32, 34, 62] ``` **Example 2**: ```python input: [] output: [] ``` **Example 3**: ```python input: [1] output: [1] ``` # Instructions 1. Write a function named `comb_sort` that takes a list of integers and returns the sorted list. 2. Implement the algorithm based on the explanation provided. 3. Ensure the code is optimized for performance, especially for large inputs. 4. Test your function with the provided examples and additional edge cases to ensure accuracy.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Sorts a list of integers using Comb Sort algorithm. def get_next_gap(gap): gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n sorted = False while gap != 1 or not sorted: gap = get_next_gap(gap) sorted = True for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False return arr"},{"question":"# Run-Length Encoding and Decoding You are tasked to implement the run-length encoding and decoding algorithms that compress and decompress strings by converting sequences of repeated characters into sequences that record the number of repetitions followed by the character. **Requirements**: 1. Implement a function `encode_rle(input_str: str) -> str` such that it compresses the input string using Run-Length Encoding (RLE). The function should run in O(n) time complexity and O(n) space complexity. 2. Implement a function `decode_rle(encoded_str: str) -> str` such that it decompresses an RLE-encoded string back to its original form. The function should run in O(n) time complexity and O(m) space complexity. **Input and Output Formats**: - The `encode_rle` function takes a single string `input_str` containing the characters to be compressed. - The `decode_rle` function takes a single string `encoded_str` containing the RLE-encoded data to be decompressed. - Both functions should return the resultant compressed or decompressed strings respectively. **Constraints**: - The input string for encoding will contain only alphanumeric characters. - The encoded string will be valid, meaning it will follow the pattern of integers followed by characters. **Example**: ```python # Example 1 input_str = \\"aaabbccccdaa\\" encoded_str = encode_rle(input_str) print(encoded_str) # Output: \\"3a2b4c1d2a\\" decoded_str = decode_rle(encoded_str) print(decoded_str) # Output: \\"aaabbccccdaa\\" # Example 2 input_str = \\"xyz\\" encoded_str = encode_rle(input_str) print(encoded_str) # Output: \\"1x1y1z\\" decoded_str = decode_rle(encoded_str) print(decoded_str) # Output: \\"xyz\\" ``` **Edge Cases to Consider**: - Empty input string. - Input strings with no repeated characters. - Input strings with very long sequences of the same character. - Ensure the `decode_rle` handles malformed encoded strings gracefully, if necessary.","solution":"def encode_rle(input_str: str) -> str: Compress the input string using Run-Length Encoding (RLE). if not input_str: return \\"\\" encoded_str = [] count = 1 for i in range(1, len(input_str)): if input_str[i] == input_str[i - 1]: count += 1 else: encoded_str.append(f\\"{count}{input_str[i - 1]}\\") count = 1 encoded_str.append(f\\"{count}{input_str[-1]}\\") return \'\'.join(encoded_str) def decode_rle(encoded_str: str) -> str: Decompress the RLE-encoded string back to its original form. if not encoded_str: return \\"\\" decoded_str = [] count = 0 for char in encoded_str: if char.isdigit(): count = count * 10 + int(char) else: decoded_str.append(char * count) count = 0 return \'\'.join(decoded_str)"},{"question":"# Greedy Set Cover Problem with Additional Constraints Given a universe of elements and a collection of subsets, each associated with a cost, your task is to implement an optimized greedy algorithm to find the minimum cost subcollection of subsets that covers all elements of the universe. However, each subset can cover up to 3 elements only. # Details: **Function Signature**: ```python def optimized_greedy_set_cover(universe, subsets, costs): pass ``` # Input: - **universe** (a set of unique integers): Elements that must be covered. - **subsets** (a dictionary): Contains subset names as keys and the sets of elements as values. - **costs** (a dictionary): Contains subset names as keys and their corresponding costs as values. # Output: - A list of subset names that form the minimum cost set cover, complying with the additional constraint. - If no valid set cover exists, return an empty list. # Constraints: - Each subset can cover a maximum of 3 elements. - Guarantee that the universe can be covered by the given subsets. # Example: ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}, \'S4\': {1, 2, 3}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3, \'S4\': 7} result = optimized_greedy_set_cover(universe, subsets, costs) print(result) # Expected: [] since no subset can cover more than 3 elements ``` # Explanation: Your task is to return a list of subset names that represents the minimum cost subcollection which covers all elements in `universe`, considering the additional constraint that a subset can cover a maximum of 3 elements. If a valid cover cannot be found, return an empty list.","solution":"def optimized_greedy_set_cover(universe, subsets, costs): Returns the minimum cost subcollection of subsets that covers all elements of the universe. Each subset can cover up to 3 elements only. If no valid set cover exists, return an empty list. if any(len(subset) > 3 for subset in subsets.values()): return [] covered = set() selected_subsets = [] while covered != universe: best_subset = None best_cost_effectiveness = float(\'inf\') for subset_name, subset_elements in subsets.items(): if subset_name in selected_subsets: continue new_elements_covered = len(subset_elements - covered) if new_elements_covered > 0: cost_effectiveness = costs[subset_name] / new_elements_covered if cost_effectiveness < best_cost_effectiveness: best_cost_effectiveness = cost_effectiveness best_subset = subset_name if not best_subset: return [] # No valid set cover found. selected_subsets.append(best_subset) covered.update(subsets[best_subset]) return selected_subsets"},{"question":"# Context: You are working on a project that requires transferring binary trees between different systems. To do this efficiently, you\'ve decided to serialize the tree into a string format that can be easily deserialized back into the original tree structure. You need to ensure that the serialization and deserialization processes handle all possible cases, including edge cases effectively. # Task: Implement the serialization and deserialization functions for a binary tree. # Input/Output Format: * **Serialization Function**: ```python def serialize(root: TreeNode) -> str: ``` * **Input**: A root node of the binary tree (`TreeNode`). * **Output**: A string representation of the binary tree. * **Deserialization Function**: ```python def deserialize(data: str) -> TreeNode: ``` * **Input**: A string representation of the binary tree. * **Output**: The root node of the reconstructed binary tree (`TreeNode`). # Constraints: * The tree nodes contain integer values. * The string format for serialization does not contain any leading or trailing spaces and uses \\"#\\" to represent null nodes. * The functions should efficiently handle trees with up to 10^4 nodes. # Examples: ```python # Example 1: # Input Tree: # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) serialized = serialize(root) # Expected Output: \\"1 2 # # 3 4 # # 5 # #\\" deserialized = deserialize(serialized) # Expected Output: root node of the tree [1, 2, 3, None, None, 4, 5] (structure maintained) # Example 2: # Input Tree: None (empty tree) root = None serialized = serialize(root) # Expected Output: \\"#\\" deserialized = deserialize(serialized) # Expected Output: None (empty tree) ``` Ensure your implementation handles all specified cases correctly and efficiently.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root: TreeNode) -> str: Serialize a binary tree to a string. def helper(node): if node: vals.append(str(node.val)) helper(node.left) helper(node.right) else: vals.append(\\"#\\") vals = [] helper(root) return \' \'.join(vals) def deserialize(data: str) -> TreeNode: Deserialize a string to a binary tree. def helper(): val = next(vals) if val == \\"#\\": return None node = TreeNode(int(val)) node.left = helper() node.right = helper() return node vals = iter(data.split()) return helper()"},{"question":"# B-Tree Implementation Enhancement You are provided with an implementation of a B-Tree data structure. Your task is to write a function `depth` that computes the maximum depth (height) of this B-Tree. The depth of a tree is defined as the longest path from the root node to any leaf node. # Function Signature ```python def depth(self) -> int: pass ``` # Input * Your function doesn\'t take any parameters. `self` refers to the instance of the `BTree` class. # Output * Returns an integer representing the maximum depth of the B-Tree. # Constraints * Assume that the B-Tree is properly initialized and contains at least one node. # Performance Requirements * Your implementation should ensure the depth calculation efficiency matches O(log n) complexity typically expected from tree operations. # Example Assume you have a `BTree` structure created as described in the provided code snippet. If the tree is constructed as: ``` [10, 20] / | [5, 6] [15] [30, 40, 50] ``` In this example, the expected output for depth would be `2`. # Scenario Consider a scenario where your B-Tree is used in a database indexing system. Efficiently evaluating the depth can help optimize certain index-related operations. ```python # Example Implementation Call btree = BTree(t_val=3) btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) btree.insert_key(6) btree.insert_key(15) btree.insert_key(30) btree.insert_key(40) btree.insert_key(50) print(btree.depth()) # Output should be 2 ```","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node self.keys = [] # List of keys in this node self.children = [] # List of child pointers class BTree: def __init__(self, t): self.t = t # Minimum degree self.root = BTreeNode(t, leaf=True) def insert_key(self, key): # Basic insertion logic (omitted for simplicity) pass def _depth(self, node): if node.leaf: return 0 else: return 1 + max(self._depth(child) for child in node.children) def depth(self) -> int: Computes the maximum depth (height) of the B-Tree. Depth is the number of edges from the root node to the deepest leaf. if self.root is None: return 0 return self._depth(self.root) # Example usage (not part of the solution): # btree = BTree(t=3) # btree.insert_key(10) # btree.insert_key(20) # btree.insert_key(5) # btree.insert_key(6) # btree.insert_key(15) # btree.insert_key(30) # btree.insert_key(40) # btree.insert_key(50) # print(btree.depth()) # Expected output: 2"},{"question":"Scenario You are developing a feature for a data analysis tool that requires generating all possible subsets from a given set of distinct integers. This feature is crucial for combinatorial data analysis, allowing the user to explore all potential groupings of a given dataset. Task Write a Python function `generate_subsets(nums)` that takes a list of distinct integers `nums` and returns all possible subsets (the power set). **Function Signature:** ```python def generate_subsets(nums: List[int]) -> List[List[int]]: pass ``` Input and Output - **Input**: A list of distinct integers `nums`. - **Output**: A list of lists, where each inner list represents a subset of `nums`. The output must include the empty subset `[]`. Examples 1. **Example 1:** - Input: `nums = [1, 2, 3]` - Output: `[[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]` 2. **Example 2:** - Input: `nums = [0]` - Output: `[[], [0]]` Constraints - All elements in `nums` are distinct. - 1 <= len(nums) <= 10 - -10 <= nums[i] <= 10 Performance Requirements - Time Complexity: O(2^n), where n is the length of `nums`. - Space Complexity: O(2^n * n), for storing all subsets. You should ensure that your implementation handles edge cases, such as an empty list and a single element list. Approach Hints - Consider using backtracking with recursion to explore all subset combinations. - Alternatively, think about iteratively building subsets.","solution":"from typing import List def generate_subsets(nums: List[int]) -> List[List[int]]: result = [[]] for num in nums: new_subsets = [] for subset in result: new_subsets.append(subset + [num]) result.extend(new_subsets) return result"},{"question":"# Question: Implement a Better OrderedStack Given the implementation of an OrderedStack which maintains an ordered stack where the highest value is always at the top, modify and enhance the class to also support an `insert` operation which maintains the order more efficiently. Your Tasks: 1. Implement the `insert` method with better time efficiency. 2. Ensure that all stack operations (`push`, `pop`, `peek`, `size`, and `is_empty`) still adhere to the original functionality and constraints. Method Definitions: * `insert(self, item: int) -> None`: Inserts the item into the stack such that the stack maintains its ordered property. The function should not utilize the simple pop and push logic from temporary stack as shown in the original `push` method. Constraints: 1. No duplicate values are allowed in the stack. 2. All stack operations including `insert` should ideally achieve better than O(n^2) performance for multiple insertions. Input: The input will consist of a series of integers to insert into the stack. Output: The output should confirm the integer values inserted in the stack, all operations performed, and the ordered status of the stack after all insertions. Example: ```python s = EnhancedOrderedStack() s.insert(3) s.insert(5) s.insert(1) print(s.items) # Should output [1, 3, 5] in ascending order with 5 being accessible at the top ``` Notes: * Ensure consistent order is maintained. * Handle empty stack scenarios gracefully. * We\'re aiming for improved time complexity for multiple insertions while maintaining proper order. ```python class EnhancedOrderedStack: def __init__(self): self.items = [] def is_empty(self): return self.items == [] def insert(self, item): # Your optimized implementation goes here pass def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items.pop() def peek(self): return self.items[len(self.items) - 1] def size(self): return len(self.items) ```","solution":"class EnhancedOrderedStack: def __init__(self): self.items = [] def is_empty(self): return self.items == [] def insert(self, item): if item in self.items: return # No duplicates allowed # Find the correct position to insert `item` to keep stack ordered left, right = 0, len(self.items) - 1 while left <= right: mid = (left + right) // 2 if self.items[mid] < item: left = mid + 1 else: right = mid - 1 self.items.insert(left, item) def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items.pop() def peek(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items[-1] def size(self): return len(self.items)"},{"question":"# Question You are working with a social media data graph where each node represents a user and each directed edge represents a \\"follows\\" relationship from one user to another. You are tasked with identifying the number of strongly connected communities within this graph. A strongly connected community is defined such that each user within the community can reach every other user in the same community via the \\"follows\\" relationships. **Task**: Implement a function `find_strongly_connected_components(V: int, edges: List[Tuple[int, int]]) -> int`, where: * `V` represents the number of users (vertices) in the graph. * `edges` is a list of directed edges representing the \\"follows\\" relationships between users. Your function should return the number of strongly connected communities in the graph. **Input**: * `V` (1 ≤ V ≤ 10^4): The number of vertices in the graph. * `edges` (0 ≤ len(edges) ≤ 5*10^4): List of directed edges, where each edge is represented by a pair (u, v). **Output**: * Return a single integer: the number of strongly connected components in the graph. **Constraints**: * Each user (vertex) can follow multiple other users but there are no self-loops. **Example**: ```python print(find_strongly_connected_components(6, [(0, 2), (1, 0), (2, 3), (3, 1), (3, 4), (4, 5), (5, 4)])) # Output: 2 # Explanation: # 1st strong component: 0 -> 2 -> 3 -> 1 -> 0 # 2nd strong component: 4 -> 5 -> 4 ``` **Hints**: 1. Use Kosaraju\'s algorithm which involves two DFS passes. 2. Pay attention to reversing the graph\'s edges and ensuring the correct order of processing nodes in the second DFS.","solution":"from typing import List, Tuple, Dict def find_strongly_connected_components(V: int, edges: List[Tuple[int, int]]) -> int: def dfs(graph: Dict[int, List[int]], v: int, visited: List[bool], stack: List[int]): visited[v] = True for neighbour in graph[v]: if not visited[neighbour]: dfs(graph, neighbour, visited, stack) stack.append(v) def reverse_graph(edges: List[Tuple[int, int]], V: int) -> Dict[int, List[int]]: reversed_graph = {i: [] for i in range(V)} for u, v in edges: reversed_graph[v].append(u) return reversed_graph def fill_order(graph: Dict[int, List[int]], V: int, visited: List[bool]) -> List[int]: stack = [] for i in range(V): if not visited[i]: dfs(graph, i, visited, stack) return stack def dfs_util(graph: Dict[int, List[int]], v: int, visited: List[bool]): visited[v] = True for neighbour in graph[v]: if not visited[neighbour]: dfs_util(graph, neighbour, visited) # 1. Create a graph from the given edge list graph = {i: [] for i in range(V)} for u, v in edges: graph[u].append(v) # 2. Fill vertices in stack according to their finishing times visited = [False] * V stack = fill_order(graph, V, visited) # 3. Create a reversed graph reversed_graph = reverse_graph(edges, V) # 4. Process all vertices in order defined by Stack visited = [False] * V count = 0 while stack: i = stack.pop() if not visited[i]: dfs_util(reversed_graph, i, visited) count += 1 return count"},{"question":"**Red-Black Tree Maintenance** You are given the implementation of a Red-Black tree with basic insertion and deletion operations. Your task is to extend the functionality of this Red-Black tree with the following additional operations: 1. **find(value)**: Find and return the node with the given value in the tree. If value does not exist, return `None`. 2. **height()**: Calculate and return the height of the tree. 3. **get_black_height()**: Calculate and return the black height (number of black nodes) of the tree. # Function Signatures ```python def find(self, value) -> RBNode: # Finds and returns the node with the given value pass def height(self) -> int: # Returns the height of the tree pass def get_black_height(self) -> int: # Returns the black height of the tree pass ``` # Input - Your methods will have the tree as represented in the provided `RBTree` class and will interact with nodes defined by the `RBNode` class. # Output - **find(value)**: Should return the node with `value`. - **height()**: Should return the integer height of the tree. - **get_black_height()**: Should return the integer black height of the tree. # Constraints - Your solution must maintain the tree\'s balance properties. - Assume all input values are valid based on the given tree structure. # Example ```python rb = RBTree() elements = [10, 20, 30, 15, 25] for el in elements: node = RBNode(el, 1) rb.insert(node) # Example find operation found_node = rb.find(15) assert found_node.val == 15 # Example height operation assert rb.height() == 3 # Example black height operation assert rb.get_black_height() == 2 ``` # Additional Information - The height of the tree is defined as the length of the longest path from the root to any leaf. - The black height of the tree is the number of black nodes on the path from the root to a leaf. Ensure your implementation is efficient and maintains the Red-Black tree properties after each operation.","solution":"class RBNode: def __init__(self, val, color=1): self.val = val self.color = color # \'0\' for black and \'1\' for red self.parent = None self.left = None self.right = None class RBTree: def __init__(self): self.NIL_LEAF = RBNode(None, color=0) self.root = self.NIL_LEAF def insert(self, node): node.left = self.NIL_LEAF node.right = self.NIL_LEAF node.color = 1 parent = None current = self.root while current != self.NIL_LEAF: parent = current if node.val < current.val: current = current.left else: current = current.right node.parent = parent if parent is None: self.root = node elif node.val < parent.val: parent.left = node else: parent.right = node if node.parent is None: node.color = 0 return if node.parent.parent is None: return self._fix_insert(node) def _fix_insert(self, node): while node.parent.color == 1: if node.parent == node.parent.parent.right: u = node.parent.parent.left if u.color == 1: u.color = 0 node.parent.color = 0 node.parent.parent.color = 1 node = node.parent.parent else: if node == node.parent.left: node = node.parent self._rotate_right(node) node.parent.color = 0 node.parent.parent.color = 1 self._rotate_left(node.parent.parent) else: u = node.parent.parent.right if u.color == 1: u.color = 0 node.parent.color = 0 node.parent.parent.color = 1 node = node.parent.parent else: if node == node.parent.right: node = node.parent self._rotate_left(node) node.parent.color = 0 node.parent.parent.color = 1 self._rotate_right(node.parent.parent) if node == self.root: break self.root.color = 0 def _rotate_left(self, node): tmp = node.right node.right = tmp.left if tmp.left != self.NIL_LEAF: tmp.left.parent = node tmp.parent = node.parent if node.parent is None: self.root = tmp elif node == node.parent.left: node.parent.left = tmp else: node.parent.right = tmp tmp.left = node node.parent = tmp def _rotate_right(self, node): tmp = node.left node.left = tmp.right if tmp.right != self.NIL_LEAF: tmp.right.parent = node tmp.parent = node.parent if node.parent is None: self.root = tmp elif node == node.parent.right: node.parent.right = tmp else: node.parent.left = tmp tmp.right = node node.parent = tmp def find(self, value): current = self.root while current != self.NIL_LEAF and current.val != value: if value < current.val: current = current.left else: current = current.right if current != self.NIL_LEAF: return current return None def height(self): def _height(node): if node == self.NIL_LEAF: return 0 left_height = _height(node.left) right_height = _height(node.right) return 1 + max(left_height, right_height) return _height(self.root) def get_black_height(self): def _black_height(node): if node == self.NIL_LEAF: return 0 left_black_height = _black_height(node.left) right_black_height = _black_height(node.right) return max(left_black_height, right_black_height) + (1 if node.color == 0 else 0) return _black_height(self.root)"},{"question":"Knapsack Problem Optimization Context You are working as a consultant for a resource allocation company. Your task is to recommend which projects to fund given a limited budget to maximize overall project value. Problem Statement Given the capacity of the knapsack (budget) and items specified by their values and weights (project returns and costs), write a function `get_maximum_value` that returns the maximum summarized value of the items that can be fit in the knapsack. # Function Signature ```python def get_maximum_value(items: List[Item], capacity: int) -> int: ``` # Input and Output Formats - **Input**: - `items`: List of `Item` objects, where each item has a `value` and `weight` attribute (non-negative integers). - `capacity`: Integer representing the capacity of the knapsack (budget) (non-negative integer). - **Output**: - Integer representing the maximum value obtainable within the given capacity. # Constraints - The number of items does not exceed 10^3. - The value and weight of each item do not exceed 10^3. - The total capacity of the knapsack does not exceed 10^3. # Requirements - **Performance**: The solution should run efficiently within the provided constraints. # Example ```python # Define the Item class used within the function class Item: def __init__(self, value, weight): self.value = value self.weight = weight items = [Item(60, 5), Item(50, 3), Item(70, 4), Item(30, 2)] capacity = 5 # Expected output: 80, because selecting items with value 50 and 30 fits into the knapsack print(get_maximum_value(items, capacity)) # Output: 80 ``` Notes - The solution should consider edge cases clearly. - Ensure no modification of the input lists happens inadvertently within the function.","solution":"from typing import List class Item: def __init__(self, value, weight): self.value = value self.weight = weight def get_maximum_value(items: List[Item], capacity: int) -> int: n = len(items) # Create a 2D DP array dp = [[0] * (capacity + 1) for _ in range(n + 1)] # Build table dp[][] in bottom up manner for i in range(1, n + 1): for w in range(capacity + 1): if items[i-1].weight <= w: dp[i][w] = max(dp[i-1][w], items[i-1].value + dp[i-1][w - items[i-1].weight]) else: dp[i][w] = dp[i-1][w] # The maximum value that fits into the knapsack of capacity `capacity` return dp[n][capacity]"},{"question":"# Problem: Dynamic Range Sum and Update You are given an initial array of integers, and you need to perform two types of operations on it: 1. **Update**: Update the value of an element at a given index. 2. **Sum Query**: Find the sum of elements from the start of the array to a given index. Implement a class `DynamicArray` that supports these operations efficiently using a Fenwick Tree (Binary Indexed Tree) data structure. Class Definition: ```python class DynamicArray: def __init__(self, initial_array: List[int]): Initialize the DynamicArray with the provided initial array. def update(self, index: int, value: int) -> None: Update the element at the given index in the array to the new value. def prefix_sum(self, index: int) -> int: Return the sum of elements from the start of the array to the given index (inclusive). ``` Input: * `initial_array`: A list of integers representing the initial array state. Output: * For the `update` method: None. * For the `prefix_sum` method: An integer representing the sum of elements from the start of the array up to the specified index. Constraints: * `1 <= len(initial_array) <= 200,000` * `-10^9 <= initial_array[i] <= 10^9` Example: ```python # Initialize DynamicArray with an initial array dyn_array = DynamicArray([1, 2, 3, 4, 5]) # Update the value at index 2 to 6 dyn_array.update(2, 6) # Query the prefix sum up to index 4 (should return the sum: 1 + 2 + 6 + 4 + 5 = 18) print(dyn_array.prefix_sum(4)) # Output: 18 # Update the value at index 0 to 10 dyn_array.update(0, 10) # Query the prefix sum up to index 2 (should return the sum: 10 + 2 + 6 = 18) print(dyn_array.prefix_sum(2)) # Output: 18 ``` Implement the `DynamicArray` class so that all operations (both updates and prefix sum queries) run in O(log n) time complexity.","solution":"class DynamicArray: def __init__(self, initial_array): Initialize the DynamicArray with the provided initial array. self.n = len(initial_array) self.array = initial_array[:] self.bit = [0] * (self.n + 1) for idx, value in enumerate(initial_array): self._update_bit(idx + 1, value) def _update_bit(self, index, value): while index <= self.n: self.bit[index] += value index += index & -index def update(self, index, value): Update the element at the given index in the array to the new value. diff = value - self.array[index] self.array[index] = value self._update_bit(index + 1, diff) def _prefix_sum_bit(self, index): sum_ = 0 while index > 0: sum_ += self.bit[index] index -= index & -index return sum_ def prefix_sum(self, index): Return the sum of elements from the start of the array to the given index (inclusive). return self._prefix_sum_bit(index + 1)"},{"question":"# RandomizedSet Data Structure Implementation Challenge **Context**: Suppose you are developing a system that requires efficient management of a dynamic set of elements. The requirements include inserting elements, removing specific elements, and fetching a random element with uniform probability efficiently. **Problem Statement**: Implement a class named `RandomizedSet` that meets the following requirements: 1. **Insert an element**: If the element is not already in the set, insert it. 2. **Remove an element**: If the element is in the set, remove it. 3. **Fetch a random element**: Return a randomly chosen element from the current set of elements. Each element must have the same probability of being returned. **Constraints**: - All operations (`insert`, `remove`, `get_random`) must achieve average O(1) time complexity. - There will be at most 2<sup>31</sup> - 1 calls to each function. - The elements will be integers within the range of a 32-bit signed integer. # Function Signatures: ```python class RandomizedSet: def __init__(self): # Initializes the data structure. pass def insert(self, val: int) -> bool: # Inserts an item val into the set if not already present. Returns True if the item was not present, False otherwise. pass def remove(self, val: int) -> bool: # Removes an item val from the set if present. Returns True if the item was present, False otherwise. pass def get_random(self) -> int: # Returns a random element from the current set of elements. Each element must have the same probability of being returned. pass ``` **Example Usage**: ```python rs = RandomizedSet() print(rs.insert(1)) # Expected output: True print(rs.insert(2)) # Expected output: True print(rs.insert(1)) # Expected output: False print(rs.remove(1)) # Expected output: True print(rs.remove(1)) # Expected output: False print(rs.get_random()) # Expected output: Either 2 print(rs.insert(3)) # Expected output: True print(rs.insert(4)) # Expected output: True print(rs.get_random()) # Expected output: 2 or 3 or 4 ``` # Analysis of Code Provide an analysis of your implementation, describing how it handles edge cases, maintains average O(1) complexity, and ensures uniform randomness.","solution":"import random class RandomizedSet: def __init__(self): Initializes an empty data structure. self.data = {} self.elements = [] def insert(self, val: int) -> bool: Inserts an item val into the set if not already present. Returns True if the item was not present, otherwise returns False. if val in self.data: return False self.data[val] = len(self.elements) self.elements.append(val) return True def remove(self, val: int) -> bool: Removes an item val from the set if present. Returns True if the item was present, otherwise returns False. if val not in self.data: return False index = self.data[val] last_element = self.elements[-1] self.elements[index] = last_element self.data[last_element] = index self.elements.pop() del self.data[val] return True def get_random(self) -> int: Returns a random element from the current set of elements. Each element must have the same probability of being returned. return random.choice(self.elements)"},{"question":"# Duplicate Removal with Optimized Performance Scenario You are tasked with writing a function that removes duplicates from an array. However, the existing algorithm has a significant performance bottleneck as the input size grows. You need to optimize this algorithm while maintaining the order of first occurrences of elements. Given the following constraints: 1. The input array may contain elements of different data types (integers, strings, booleans). 2. The quantity of elements in the input array can be very large (up to 10^6 elements). Instructions Write a function `remove_duplicates_optimized(array)` that removes any duplicates from the array while preserving the order of first appearances, and achieves optimal performance. # Input - `array`: A list containing elements of various types (int, str, bool) and has a size of up to 10^6 elements. # Output - A list containing only unique elements from the input array, with their first occurrence order maintained. # Constraints - The input array can be empty. - The input array will have elements of diverse types. # Expected Performance Your function should work efficiently even for the maximum input size, ideally with a time complexity better than O(n^2). # Example ```python Input: [1, 1, 1, 2, 2, 3, 4, 4, \\"hey\\", \\"hey\\", \\"hello\\", True, True] Output: [1, 2, 3, 4, \'hey\', \'hello\', True] ``` ```python Input: [\\"a\\", \\"b\\", \\"a\\", \\"c\\", \\"b\\", \\"c\\", \\"a\\"] Output: [\\"a\\", \\"b\\", \\"c\\"] ``` ```python Input: [5, \\"test\\", 5, \\"example\\", True, \\"test\\", False] Output: [5, \\"test\\", \\"example\\", True, False] ```","solution":"def remove_duplicates_optimized(array): Removes duplicates from the list while preserving the order of first occurrences. Parameters: array (list): List containing elements of various types with potential duplicates. Returns: list: A list containing only unique elements in their first occurrence order. seen = set() result = [] for item in array: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"# Euler\'s Totient Function Implementation and Extension Euler\'s totient function, also known as the phi-function (ϕ(n)), counts the number of integers between 1 and (n) inclusive, which are coprime to (n) (Two numbers are coprime if their greatest common divisor (GCD) equals 1). Given an integer (n), we aim to implement and extend the function to not only return the value of (ϕ(n)) but also the list of integers that are coprime to (n). **Function Signature**: ```python def extended_euler_totient(n: int) -> Tuple[int, List[int]]: ``` **Parameters**: - `n` (int): A positive integer ( n geq 1 ). **Returns**: - Tuple containing: - An integer representing the value of (ϕ(n)). - A list of integers that are coprime with (n). **Constraints**: - (1 leq n leq 10^6) **Example**: ```python assert extended_euler_totient(1) == (1, [1]) assert extended_euler_totient(6) == (2, [1, 5]) assert extended_euler_totient(10) == (4, [1, 3, 7, 9]) ``` **Notes**: 1. Consider edge cases, such as the smallest possible ( n ). 2. Ensure optimal performance to handle upper limits of the input range efficiently. **Requirement**: Implement the complete function to return both (ϕ(n)) and the list of coprimes. # Example Scenario: You are developing a cryptographic system that requires knowing the count and identity of numbers coprime to a given ( n ). This function forms the foundational step to ensure secure key generation by leveraging number theory principles.","solution":"from typing import List, Tuple def gcd(a: int, b: int) -> int: Compute the greatest common divisor of a and b using the Euclidean algorithm. while b: a, b = b, a % b return a def extended_euler_totient(n: int) -> Tuple[int, List[int]]: Computes Euler\'s Totient function value for n and also provides the list of integers less than or equal to n that are coprime with n. Args: n (int): A positive integer n >= 1. Returns: Tuple containing: - An integer representing the value of ϕ(n). - A list of integers that are coprime with n. coprimes = [i for i in range(1, n + 1) if gcd(n, i) == 1] return len(coprimes), coprimes"},{"question":"# Scenario You are working on a data transformation task where you need to process a collection of nested arrays. Your goal is to flatten these arrays into a single, one-dimensional array. This flattened array should maintain the order of elements as they appear in a depth-first traversal of the input. # Problem Statement Write a function `flatten_array` that takes a nested array as input and returns a single flattened array. Additionally, write a generator function `flatten_array_gen` that yields the elements one by one in a flattened manner. # Function Specifications 1. `flatten_array(input_arr: List[Any]) -> List[Any]` - **Input**: A nested list `input_arr`. - **Output**: A single flattened list. 2. `flatten_array_gen(iterable: Iterable) -> Iterator[Any]` - **Input**: A nested iterable `iterable`. - **Output**: An iterator that yields elements in a flattened manner. # Constraints - The input array can contain elements of any type (integers, floats, strings, lists, etc.). - Maintain the original order of elements as they appear in the nested structure. - Do not use any built-in flatten or chain functions from libraries. # Examples ```python # Example for flatten_array assert flatten_array([1, [2, [3, [4, 5]]], 6]) == [1, 2, 3, 4, 5, 6] assert flatten_array([[1, 2, [3]], 4]) == [1, 2, 3, 4] assert flatten_array([]) == [] # Example for flatten_array_gen assert list(flatten_array_gen([1, [2, [3, [4, 5]]], 6])) == [1, 2, 3, 4, 5, 6] assert list(flatten_array_gen([[1, 2, [3]], 4])) == [1, 2, 3, 4] assert list(flatten_array_gen([])) == [] ``` # Notes - Carefully consider edge cases such as empty lists or lists containing different types of elements. - For the generator implementation, ensure that elements are yielded in the correct order. - Write clear and efficient code with comments explaining each step where necessary.","solution":"from typing import List, Any, Iterable, Iterator def flatten_array(input_arr: List[Any]) -> List[Any]: Flattens a nested list into a single list. flattened_list = [] def flatten(sublist): for item in sublist: if isinstance(item, list): flatten(item) else: flattened_list.append(item) flatten(input_arr) return flattened_list def flatten_array_gen(iterable: Iterable) -> Iterator[Any]: Flattens a nested iterable into a generator to yield each item. for item in iterable: if isinstance(item, list): yield from flatten_array_gen(item) else: yield item"},{"question":"# Question You are implementing a connectivity checker for a network represented as a directed graph. Given a list of edges representing the connections in the network and a pair of nodes (source and target), you need to determine if there is a path from the source node to the target node using Depth First Search (DFS). Input 1. An integer `n` (0 ≤ n ≤ 10^3), representing the number of nodes in the graph. 2. A list of pairs `(u, v)` where each pair represents a directed edge from node `u` to node `v`. (0 ≤ u, v < n) 3. Two integers, `source` and `target` (0 ≤ source, target < n), representing the start and end nodes for the path query. Output A boolean value `True` if there is a path from `source` to `target`, otherwise `False`. Example ```python # Example Input: n = 5 edges = [(0, 1), (0, 2), (1, 2), (2, 0), (2, 3), (3, 3)] source = 1 target = 3 # Example Output: True ``` Function Signature ```python def is_path_exists(n: int, edges: list, source: int, target: int) -> bool: pass ``` Constraints * Do not use any libraries outside of standard Python libraries. * Your solution should have a time complexity of O(V + E).","solution":"def is_path_exists(n: int, edges: list, source: int, target: int) -> bool: from collections import defaultdict # Create an adjacency list adjacency_list = defaultdict(list) for u, v in edges: adjacency_list[u].append(v) # Function to perform DFS def dfs(node): if node == target: return True visited.add(node) for neighbor in adjacency_list[node]: if neighbor not in visited: if dfs(neighbor): return True return False # Initialize visited set visited = set() return dfs(source)"},{"question":"# Question: Ternary Search Implementation You are tasked with implementing the `ternary_search` function, which searches for a target value within a sorted array. Unlike binary search, ternary search splits the array into three segments. **Function Signature**: ```python def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: ``` **Input**: * `left` (int): The starting index of the search range. * `right` (int): The ending index of the search range. * `key` (int): The value you are searching for. * `arr` (List[int]): A list of integers sorted in ascending order. **Output**: * Return the index of `key` if found within the bounds from `left` to `right`. * If `key` is not found, return `-1`. **Constraints**: * Assume that the `arr` is sorted in ascending order. * Consider the size of the array can be large, so ensure your solution is optimized for both time and space complexity. **Examples**: ```python assert ternary_search(0, 9, 5, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 4 assert ternary_search(0, 5, 1, [10, 20, 30, 40, 50, 60]) == -1 assert ternary_search(0, 6, 50, [10, 20, 30, 40, 50, 60]) == 4 assert ternary_search(0, 8, 30, [10, 20, 30, 30, 30, 40, 50, 60]) == 2 ``` # Requirements 1. Ensure the function performs efficiently even for large arrays. 2. All inputs are valid and the methods must handle edge cases (e.g., empty array, non-existing keys). Implement the function `ternary_search` following the provided guidelines.","solution":"from typing import List def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: while right >= left: mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"# Robbery Planning Challenge You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. The only constraint stopping you from robbing each of them is that adjacent houses have a security system connected and will automatically contact the police if two adjacent houses are broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Write a function `max_money_to_rob(houses)` that: - Accepts a list of non-negative integers `houses`, where `houses[i]` is the amount of money in the i-th house. - Returns a single integer, the maximum amount of money you can rob without triggering the police alarm. **Input Format**: - A list of non-negative integers `houses` (0 ≤ len(houses) ≤ 10^5, 0 ≤ houses[i] ≤ 10^4) **Output Format**: - A single integer representing the maximum amount of money that can be robbed. **Constraints**: - You are not allowed to rob two adjacent houses. - Edge cases such as an empty list should be handled appropriately. **Example**: ```plaintext Input: [2, 7, 9, 3, 1] Output: 12 Input: [1, 2, 3, 1] Output: 4 ``` # Explanation: - In the first example, you can rob house 1 (2) + house 3 (9) + house 5 (1) = 12. - In the second example, you can rob house 1 (1) + house 3 (3) = 4. **Note**: - Make sure your implementation is efficient with a linear time complexity and constant space complexity.","solution":"def max_money_to_rob(houses): Calculate the maximum amount of money that can be robbed from a list of houses without robbing two adjacent houses. if not houses: return 0 if len(houses) == 1: return houses[0] n = len(houses) dp = [0] * n dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[-1]"},{"question":"Task You are given a partially implemented Binary Search Tree (BST) class which includes insertion, searching, and traversal (Inorder, Preorder, Postorder). Your task is to implement an efficient method to delete a node in the BST. Scenario Consider a scenario where you are developing a basic filesystem indexer using a BST. You need to support deletion of files (nodes) while maintaining the properties of the BST intact. # Method Signature ```python def delete(self, data: int) -> bool: Removes the node containing `data` from the BST. Returns True if deletion was successful, False if `data` was not found. ``` # Input * **data**: An integer representing the value of the node to delete from the BST. # Expected Output * Return `True` if the node was successfully deleted, `False` if the node was not found. # Constraints - The BST does not contain duplicate values. - All values are positive integers. # Example ```python # Create BST bst = BST() bst.insert(10) bst.insert(15) bst.insert(6) bst.insert(4) bst.insert(9) # Test deleting bst.delete(15) # Returns True, 15 successfully deleted # Value 30 does not exist in BST bst.delete(30) # Returns False ``` # Notes - Ensure to handle edge cases such as deleting the root node, nodes with one child, and leaf nodes. - The BST should remain valid after the deletion.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if root is None: return Node(key) elif key < root.val: root.left = self._insert(root.left, key) else: root.right = self._insert(root.right, key) return root def search(self, key): return self._search(self.root, key) def _search(self, root, key): if root is None or root.val == key: return root if root.val < key: return self._search(root.right, key) return self._search(root.left, key) def inorder(self): return self._inorder(self.root) def _inorder(self, root): return self._inorder(root.left) + [root.val] + self._inorder(root.right) if root else [] def preorder(self): return self._preorder(self.root) def _preorder(self, root): return [root.val] + self._preorder(root.left) + self._preorder(root.right) if root else [] def postorder(self): return self._postorder(self.root) def _postorder(self, root): return self._postorder(root.left) + self._postorder(root.right) + [root.val] if root else [] def delete(self, data): self.root, deleted = self._delete(self.root, data) return deleted def _delete(self, root, key): if root is None: return root, False if key < root.val: root.left, deleted = self._delete(root.left, key) elif key > root.val: root.right, deleted = self._delete(root.right, key) else: deleted = True if root.left is None: return root.right, deleted elif root.right is None: return root.left, deleted temp = self._min_value_node(root.right) root.val = temp.val root.right, _ = self._delete(root.right, temp.val) return root, deleted def _min_value_node(self, root): current = root while current.left is not None: current = current.left return current"},{"question":"**Scenario:** You are working as a software engineer in a logistics company that needs to optimize the loading of trucks with valuable items without exceeding their weight limits. Given a set of items, each with a specified weight and value, and a truck with a maximum weight capacity, you need to determine the maximum value of items that can be loaded onto the truck. # Problem Statement Implement a function `get_maximum_value(items, capacity)` that takes a list of items (each represented as a tuple of `(value, weight)`) and an integer `capacity` representing the truck\'s maximum weight capacity. The function should return the maximum summarized value of the items that can be fit in the truck. **Input:** - `items`: List of tuples, where each tuple contains two integers `(value, weight)`. - `capacity`: Integer representing the maximum weight the truck can carry. **Output:** - Integer representing the maximum value of items that can be carried in the truck. # Function Signature ```python def get_maximum_value(items: List[Tuple[int, int]], capacity: int) -> int: ``` # Example Input: ```python capacity = 5 items = [(60, 5), (50, 3), (70, 4), (30, 2)] ``` Output: ```python 80 ``` **Explanation**: The items with values 50 (weight: 3) and 30 (weight: 2) can both be fit in the truck, making the maximum value 80. # Constraints - All values and weights are positive integers. - Items list will have at most 1000 items. - Capacity will be at most 10,000. **Note:** - Optimize your function to handle edge cases where the list of items is empty or the capacity is zero. - Handle cases where items have weights greater than the capacity effectively by ignoring such items without causing errors.","solution":"from typing import List, Tuple def get_maximum_value(items: List[Tuple[int, int]], capacity: int) -> int: # Initialize a list to store the maximum value at each capacity from 0 to capacity dp = [0] * (capacity + 1) # Iterate through each item (value, weight) for value, weight in items: # Traverse the dp array from right to left considering the current item\'s weight for c in range(capacity, weight - 1, -1): dp[c] = max(dp[c], dp[c - weight] + value) return dp[capacity]"},{"question":"You are given a sorted array of integers in increasing order and a target integer. Your task is to find the index of the last occurrence of the target integer in the array using an efficient algorithm of O(log n) time complexity. Return -1 if the target is not present in the array. Implement the function `last_occurrence(array: List[int], query: int) -> int`. # Input Format: - `array`: A list of integers sorted in increasing order (0 ≤ len(array) ≤ 10^5). - `query`: An integer to search for in the array. # Output Format: - Return an integer representing the index of the last occurrence of `query` in `array`. - If the `query` is not found, return -1. # Constraints: - The list `array` is sorted in non-decreasing order. - The list may contain duplicates. - The input list length is at most 10^5. # Examples: Example 1: Input: ```python array = [1, 2, 2, 2, 3, 4] query = 2 ``` Output: ```python 3 ``` Explanation: The last occurrence of 2 is at index 3. Example 2: Input: ```python array = [5, 6, 6, 7, 8, 8, 10] query = 8 ``` Output: ```python 5 ``` Explanation: The last occurrence of 8 is at index 5. Example 3: Input: ```python array = [5, 6, 6, 7, 8, 8, 10] query = 11 ``` Output: ```python -1 ``` Explanation: 11 is not in the list, so return -1. # Notes: - Make sure your solution is efficient and runs in O(log n) time complexity. - Consider edge cases where the `query` is at the boundaries of the array or not present at all.","solution":"from typing import List def last_occurrence(array: List[int], query: int) -> int: Returns the index of the last occurrence of query in the sorted array. If query is not found, returns -1. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid left = mid + 1 # Look for further occurrences on the right side elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Question: Implement Secure Key Exchange with Diffie-Hellman Scenario: Two users, Alice and Bob, want to communicate securely over an open network. They decide to use the Diffie-Hellman Key Exchange protocol to establish a shared secret key. Your Task: You are required to implement a function to simulate the Diffie-Hellman Key Exchange process. Key components include generating prime numbers, finding primitive roots, and computing public and shared keys. Function Definition: ```python def secure_diffie_hellman_exchange(p: int, a: int) -> (int, int): Perform Diffie-Hellman Key Exchange and return both shared keys (Alice\'s and Bob\'s). :param p: A large prime number. :param a: A primitive root of p. :return: Tuple containing shared keys of Alice and Bob. pass ``` Requirements: 1. Implement the prime checking and ensure `p` is a prime number. 2. Find all primitive roots of `p` and ensure `a` is a primitive root. 3. Simulate the private and public key generation for both Alice and Bob. 4. Compute the shared secret keys for both Alice and Bob. 5. Ensure the shared keys computed by Alice and Bob are identical. Input and Output: - **Input**: - `p`: An integer representing a large prime number. - `a`: An integer representing a primitive root of `p`. - **Output**: - A tuple containing two integers, representing the shared keys computed by Alice and Bob. Example: ```python p = 23 a = 5 alice_shared_key, bob_shared_key = secure_diffie_hellman_exchange(p, a) # Expected: Both shared keys should be identical. ``` Constraints: - (2 leq p leq 10^6) - `p` must be a prime number. - `a` must be a primitive root of `p`. Performance: - Ensure the solution works efficiently within the given constraints. Notes: - Make sure to handle cases where `p` is not prime or `a` is not a primitive root. - The solution should validate the inputs before proceeding with key exchange.","solution":"def is_prime(n): Check if number n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_primitive_root(p): Find a primitive root for prime p. if not is_prime(p): return None phi = p - 1 factors = set() n = phi i = 2 while i * i <= n: if n % i == 0: factors.add(i) while n % i == 0: n //= i i += 1 if n > 1: factors.add(n) for r in range(2, p): flag = False for factor in factors: if pow(r, phi // factor, p) == 1: flag = True break if not flag: return r return None def secure_diffie_hellman_exchange(p: int, a: int) -> (int, int): Perform Diffie-Hellman Key Exchange and return both shared keys (Alice\'s and Bob\'s). :param p: A large prime number. :param a: A primitive root of p. :return: Tuple containing shared keys of Alice and Bob. if not is_prime(p): raise ValueError(\\"p must be a prime number\\") if a != find_primitive_root(p): raise ValueError(\\"a must be a primitive root of p\\") # Alice picks a private key a_private (randomly) a_private = 6 # This should be randomly generated in real applications a_public = pow(a, a_private, p) # A = a^a_private % p # Bob picks a private key b_private (randomly) b_private = 15 # This should be randomly generated in real applications b_public = pow(a, b_private, p) # B = a^b_private % p # Generate the shared secret key alice_shared_key = pow(b_public, a_private, p) bob_shared_key = pow(a_public, b_private, p) return alice_shared_key, bob_shared_key"},{"question":"# Nearest Neighbors Classification Given a dataset, implement the k-Nearest Neighbor (k-NN) algorithm for classifying points in a 2D space. The function should take two essential inputs: 1. A dataset containing labeled points. 2. A new point to classify. The goal is to classify the new point based on the majority label of its k nearest neighbors from the dataset. Function Signature ```python def classify_point(dataset: dict, new_point: tuple, k: int) -> int: Classifies the new_point based on the k nearest neighbors in the dataset. Args: dataset (dict): A dictionary where keys are tuples representing 2D points, and values are the labels (0 or 1) for those points. new_point (tuple): A tuple representing the 2D point to classify. k (int): The number of nearest neighbors to consider for classification. Returns: int: The label (0 or 1) assigned to the new_point. pass ``` Example ```python # Example dataset with points and their labels (0 or 1) dataset = { (1, 1): 0, (2, 2): 0, (3, 3): 1, (6, 6): 1, (7, 7): 1 } new_point = (4, 4) k = 3 assert classify_point(dataset, new_point, k) == 1 ``` Constraints 1. `dataset` must be a dictionary where keys are tuples of length 2 and values are integers (0 or 1). 2. `new_point` must be a tuple of length 2. 3. `k` must be a positive integer, and `k` ≤ len(dataset). Notes 1. Handle edge case where `k` is greater than the dataset size by considering all the points. 2. Use Euclidean distance for measuring closeness. 3. Optimize for performance where possible.","solution":"import math from collections import Counter def classify_point(dataset: dict, new_point: tuple, k: int) -> int: Classifies the new_point based on the k nearest neighbors in the dataset. Args: dataset (dict): A dictionary where keys are tuples representing 2D points, and values are the labels (0 or 1) for those points. new_point (tuple): A tuple representing the 2D point to classify. k (int): The number of nearest neighbors to consider for classification. Returns: int: The label (0 or 1) assigned to the new_point. # Calculate the Euclidean distance between new_point and each point in the dataset distances = [] for point in dataset: distance = math.sqrt((point[0] - new_point[0])**2 + (point[1] - new_point[1])**2) distances.append((distance, dataset[point])) # Sort distances in ascending order distances.sort(key=lambda x: x[0]) # Get the labels of the k nearest neighbors nearest_labels = [label for _, label in distances[:k]] # Find the most common label among the nearest neighbors label_counter = Counter(nearest_labels) most_common_label = label_counter.most_common(1)[0][0] return most_common_label"},{"question":"Scenario: You are tasked to implement a function that determines the maximum depth of a binary tree. This problem is important in various applications ranging from data indexing to designing hierarchical structures. Given that the binary tree might be very large or unbalanced, it\'s essential to handle it efficiently both in terms of time and space complexity. Task: Write a function `calculate_max_depth(root)` that takes as input the root node of a binary tree and returns an integer representing the maximum depth of the tree. Requirements: 1. The function should be implemented using iterative level-order traversal (BFS). 2. Use an efficient queue data structure (consider using `collections.deque`). 3. Handle the edge case where the tree is empty (i.e., `root` is `None`). Function Signature: ```python def calculate_max_depth(root: \'TreeNode\') -> int: ``` Input: * `root` - a `TreeNode` object representing the root of the binary tree. Output: * An integer representing the maximum depth of the binary tree. Example: ```python # Binary Tree Example # 10 # / # 12 15 # / / # 25 30 36 # # 100 class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Sample usage: tree = TreeNode(10) tree.left = TreeNode(12) tree.right = TreeNode(15) tree.left.left = TreeNode(25) tree.left.left.right = TreeNode(100) tree.left.right = TreeNode(30) tree.right.left = TreeNode(36) print(calculate_max_depth(tree)) # Output should be 4 ``` Constraints: * The tree node values will be integers. * The depth of the tree will not exceed 1000. Notes: - Focus on making the queue operations efficient. - Make sure to test with various tree structures, including unbalanced and complete trees.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def calculate_max_depth(root: TreeNode) -> int: Determines the maximum depth of a binary tree using iterative level-order traversal. if not root: return 0 queue = deque([root]) depth = 0 while queue: depth += 1 level_size = len(queue) for _ in range(level_size): node = queue.popleft() if node.left: queue.append(node.left) if node.right: queue.append(node.right) return depth"},{"question":"# Problem: Two Sum with Sorted Array Given an array of integers sorted in ascending order, write a function `two_sum` that finds two distinct indices such that the elements at those indices add up to a specific target number. Your function should return these indices, and they must be 1-based (not zero-based). Input: * A list of integers `numbers` sorted in ascending order. * An integer `target` representing the required sum. Output: * A list containing two integers representing the 1-based indices of the two numbers that add up to the target. The first index must be less than the second index. Constraints: * You may assume that each input would have exactly one solution. * You may not use the same element twice. Examples: ```python # Example 1 numbers = [2, 7, 11, 15] target = 9 # The function should return: [1, 2] # Example 2 numbers = [1, 2, 3, 4, 4] target = 8 # The function should return: [4, 5] ``` Requirements: * Implement the solution using the two pointers approach with optimal time and space complexity. * Be mindful of edge cases, such as arrays with negative numbers or involving the same number twice if that\'s possible. Implementation: ```python def two_sum(numbers, target): left, right = 0, len(numbers) - 1 # Initialize the two pointers while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] # 1-based indices elif current_sum < target: left += 1 # Move the left pointer to the right else: right -= 1 # Move the right pointer to the left return None # In case there is no solution, though the problem guarantees one ```","solution":"def two_sum(numbers, target): Finds two distinct indices such that the elements at those indices in a sorted array add up to the target. Returns the indices as 1-based. left, right = 0, len(numbers) - 1 # Initialize the two pointers while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] # 1-based indices elif current_sum < target: left += 1 # Move the left pointer to the right else: right -= 1 # Move the right pointer to the left return None # In case there is no solution, though the problem guarantees one"},{"question":"# Move Zeros to the End Scenario Imagine you are developing a data preprocessing tool in Python. One of the tasks is to ensure that all zeros in a dataset array are moved to the end for better alignment and easier subsequent processing. The function should preserve the order of non-zero elements. # Problem Statement Write a function `move_zeros(array)` that takes a list and moves all zeros to the end, preserving the order of the other elements. The function should handle various data types but treat `0` values (not `False`) strictly as zeros. # Expected Function Signature ```python def move_zeros(array): # Your code here pass ``` # Input - An array `array` of elements, which may include integers, strings, floats, and boolean values. # Output - A new list with all zeros moved to the end, preserving the order of other elements. # Constraints - The array can have mixed types. - Do not use built-in functions that directly solve the problem. - Boolean `False` should be treated as non-zero. - The function should run efficiently on large datasets. # Examples ```python >>> move_zeros([False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"]) [False, 1, 1, 2, 1, 3, \'a\', 0, 0] >>> move_zeros([0, 0, 0]) [0, 0, 0] >>> move_zeros([1, 2, 3]) [1, 2, 3] >>> move_zeros([0, \\"a\\", 0, \\"b\\", 0, \\"c\\"]) [\'a\', \'b\', \'c\', 0, 0, 0] ``` # Additional Notes - Be mindful of the time complexity and strive to achieve linear time complexity, `O(n)`. - Consider edge cases such as empty arrays, arrays without zeros, and arrays entirely of zeros.","solution":"def move_zeros(array): Moves all zeros in the array to the end while preserving the order of non-zero elements. Parameters: array (list): The input list containing elements of various data types. Returns: list: A new list with zeros moved to the end. non_zeros = [x for x in array if x != 0 or type(x) is bool] zeros = [x for x in array if x == 0 and type(x) is not bool] return non_zeros + zeros"},{"question":"# Coding Problem You are given an array of sorted integers. Implement an efficient algorithm to find the index of a given searchKey in this array using the principles of Interpolation Search. Function Signature: ```python def find_index(arr: List[int], search_key: int) -> int: ``` Input: - `arr`: a list of integers sorted in increasing order. (1 <= len(arr) <= 10^5) - `search_key`: an integer to find in the array. Output: - An integer representing the index of `searchKey` in `arr`. If `search_key` is not found, return -1. Constraints: - The array elements are between -10^5 and 10^5. - The `search_key` is an integer within the same bound. Performance Requirement: - Your solution should aim for O(log2(log2 n)) average time complexity. Examples: ```python find_index([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) # Output: 2 find_index([5, 10, 12, 14, 17, 20, 21], 55) # Output: -1 find_index([5, 10, 12, 14, 17, 20, 21], -5) # Output: -1 ``` Context: You are designing an automated system that logs temperature readings every minute. For efficient data retrieval, you need an algorithm that quickly finds specific temperature values within these logs, assuming the logs are sorted by timestamp.","solution":"from typing import List def find_index(arr: List[int], search_key: int) -> int: Uses Interpolation Search to find the index of search_key in a sorted array. Returns the index of search_key, or -1 if search_key is not present in the array. low = 0 high = len(arr) - 1 while low <= high and search_key >= arr[low] and search_key <= arr[high]: if low == high: if arr[low] == search_key: return low return -1 # Estimating the position of search_key in the array pos = low + ((high - low) // (arr[high] - arr[low]) * (search_key - arr[low])) # Check if search_key is found if arr[pos] == search_key: return pos # If search_key is larger, search in the right side if arr[pos] < search_key: low = pos + 1 # If search_key is smaller, search in the left side else: high = pos - 1 return -1"},{"question":"# Question: Roman Numeral Validation and Conversion Context: You are working on a text-processing application tasked with interpreting ancient manuscripts. These manuscripts frequently contain Roman numerals, which must be converted to their integer equivalent for further computations. However, you have realized that some of the numerals might be invalid or malformed. Therefore, you need to enhance the existing conversion function to validate the Roman numeral format before performing the conversion. Task: Write a function `validate_and_convert_roman(s: str) -> int` that takes a string representing a Roman numeral and performs two tasks: 1. **Validation**: Ensure the input is a well-formed Roman numeral within the range 1 to 3999. 2. **Conversion**: Convert the valid Roman numeral to its integer representation. If the numeral is invalid, your function should raise a `ValueError` with an appropriate message. Input: - `s` (str): A string representing a Roman numeral. Output: - `int`: The integer representation of the Roman numeral if valid. Constraints: - The length of the input string will not exceed 15 characters. - The input string can include characters \'I\', \'V\', \'X\', \'L\', \'C\', \'D\', \'M\'. Example: ```python assert validate_and_convert_roman(\\"XCIV\\") == 94 assert validate_and_convert_roman(\\"MCMIV\\") == 1904 assert validate_and_convert_roman(\\"MMMM\\") raises ValueError(\\"Invalid Roman numeral\\") ``` Notes: - Ensure the function is robust against invalid inputs. - Consider implementing helper functions for validation and conversion processes to maintain clarity and modularity.","solution":"def validate_and_convert_roman(s: str) -> int: Validates and converts a Roman numeral to its integer representation. Parameters: s (str): Roman numeral string. Returns: int: Integer representation of the Roman numeral. Raises: ValueError: If the Roman numeral is invalid. if not s or not isinstance(s, str): raise ValueError(\\"Invalid Roman numeral\\") # Roman numeral value map roman_to_int = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } # Regex to match valid Roman numerals between 1 and 3999 import re pattern = re.compile(r\\"^(M{0,3})(CM|CD|D?C{0,3})\\" r\\"(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})\\") if not pattern.match(s): raise ValueError(\\"Invalid Roman numeral\\") total = 0 i = 0 while i < len(s): # If this is a subtractive combination if i+1 < len(s) and roman_to_int[s[i]] < roman_to_int[s[i+1]]: total += roman_to_int[s[i+1]] - roman_to_int[s[i]] i += 2 else: total += roman_to_int[s[i]] i += 1 return total"},{"question":"# Question: Unique Permutations Generator You are tasked with generating all possible unique permutations of a given list of numbers which might contain duplicates. Implement the function `generate_unique_permutations(nums: List[int]) -> List[List[int]]` that: - Takes a list of integers `nums` as input. - Returns a list of lists, where each list represents a unique permutation of the input list. The function should handle the following: - The input list can be empty. - The input list can contain duplicate elements. **Constraints**: - Your implementation should aim for optimal performance given that the number of permutations is inherently large (n!). **Input/Output Examples**: ``` Example 1: Input: [1,1,2] Output: [[1,1,2], [1,2,1], [2,1,1]] Example 2: Input: [1,2,3] Output: [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] Example 3: Input: [] Output: [[]] Example 4: Input: [2,2,2] Output: [[2,2,2]] ``` # Performance Requirements: - Time Complexity: Aim for O(n * n!) in the worst case due to the nature of permutations. - Space Complexity: Aim for O(n * n!) in the worst case for storing permutations. # Additional Notes for Students: Consider leveraging data structures such as sets or hash tables to manage and check duplications efficiently during permutations generation.","solution":"from typing import List from itertools import permutations def generate_unique_permutations(nums: List[int]) -> List[List[int]]: Generates all unique permutations of a list of numbers, taking into account possible duplicates. Args: nums (List[int]): A list of integers, possibly with duplicates. Returns: List[List[int]]: A list of lists, each representing a unique permutation of the input list. return list(map(list, set(permutations(nums))))"},{"question":"You are tasked to implement an `OrderedStack` class, which is a stack data structure that maintains its elements in an ordered manner (highest on top, lowest at bottom). You will be provided with the class skeleton, including basic methods – your task is to complete the parts responsible for maintaining order during item insertion. # Detailed Requirements 1. **Class Definition**: Complete the `OrderedStack` class provided as follows: * **push(item)**: Insert an item into the stack while maintaining the order. * **pop()**: Remove and return the top item from the stack. * **peek()**: Return the top item without removing it. * **size()**: Return the number of elements in the stack. * **is_empty()**: Check if the stack is empty. 2. **Function Definitions**: * `push(item: int) -> None`: Inserts the `item` into the stack maintaining the highest element on top. * `pop() -> int`: Removes and returns the top item if the stack is not empty, else raises an `IndexError`. * `peek() -> int`: Returns the top item if the stack is not empty, else raises an `IndexError`. * `size() -> int`: Returns the number of elements in the stack. * `is_empty() -> bool`: Returns `True` if the stack is empty, otherwise `False`. 3. **Edge Cases and Constraints**: * Make sure the stack handles edge cases like pushing to an empty stack. * Ensure functionality for all provided methods. * Avoid using built-in sorting functions. # Example Use Case ```python stack = OrderedStack() stack.push(3) stack.push(1) stack.push(4) stack.push(2) print(stack.peek()) # Output: 4 print(stack.pop()) # Output: 4 print(stack.peek()) # Output: 3 print(stack.size()) # Output: 3 ``` Implement the `OrderedStack` class and all methods as defined.","solution":"class OrderedStack: def __init__(self): self.stack = [] def push(self, item): Inserts item into the stack maintaining the highest element on top. temp_stack = [] # Empty the stack till we find the correct position for the item while self.stack and self.stack[-1] > item: temp_stack.append(self.stack.pop()) self.stack.append(item) # Restore the temporary stack back to main stack while temp_stack: self.stack.append(temp_stack.pop()) def pop(self): Removes and returns the top item if the stack is not empty, else raises IndexError. if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.stack.pop() def peek(self): Returns the top item if the stack is not empty, else raises IndexError. if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def size(self): Returns the number of elements in the stack. return len(self.stack) def is_empty(self): Returns True if the stack is empty, otherwise False. return len(self.stack) == 0"},{"question":"# Secure Chat Application Key Exchange You are tasked to create a secure chat application that enables two users, Alice and Bob, to share a secret encryption key over an insecure network using a Diffie-Hellman key exchange. The application should perform the following tasks: 1. Verify if a given number is a prime. 2. Compute Euler\'s Totient function. 3. Find all primitive roots of a given prime number. 4. Generate private and public keys for both users. 5. Perform the key exchange and verify that both users end up with the same shared secret key. Requirements 1. **Input**: - `p`: A large prime number. - `a`: A primitive root of `p`. 2. **Output**: - Print Alice\'s private and public keys. - Print Bob\'s private and public keys. - Print the shared secret key calculated by Alice. - Print the shared secret key calculated by Bob. - Return `True` if both shared keys are identical, `False` otherwise. 3. **Constraints**: - `p` must be a prime number greater than 1000. - `a` must be a primitive root of the given `p`. 4. **Performance**: - Efficient prime checking (optimize for large numbers). - Efficient calculation of Euler\'s Totient function and primitive roots. Example ```python p = 761 a = 6 # Expected output based on random private keys # Output: # Alice\'s private key: 437 # Alice\'s public key: 56 # Bob\'s private key: 289 # Bob\'s public key: 28 # Shared key calculated by Alice = 341 # Shared key calculated by Bob = 341 # True ``` Function Signatures You need to implement the following functions: - `prime_check(num: int) -> bool` - `euler_totient(n: int) -> int` - `find_primitive_root(n: int) -> List[int]` - `alice_private_key(p: int) -> int` - `alice_public_key(a_pr_k: int, a: int, p: int) -> int` - `bob_private_key(p: int) -> int` - `bob_public_key(b_pr_k: int, a: int, p: int) -> int` - `alice_shared_key(b_pu_k: int, a_pr_k: int, p: int) -> int` - `bob_shared_key(a_pu_k: int, b_pr_k: int, p: int) -> int` - `diffie_hellman_key_exchange(a: int, p: int, option: Optional[int] = None) -> bool` Ensure your implementation correctly implements these requirements with proper validation and error handling.","solution":"import random from typing import List, Optional def prime_check(num: int) -> bool: if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def euler_totient(n: int) -> int: result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result def find_primitive_root(p: int) -> List[int]: if not prime_check(p): raise ValueError(\\"p must be a prime number\\") phi = euler_totient(p) s = set() for i in range(2, p): for j in range(1, phi + 1): s.add(pow(i, j, p)) if len(s) == phi: return i s.clear() return -1 def alice_private_key(p: int) -> int: return random.randint(2, p-2) def alice_public_key(a_pr_k: int, a: int, p: int) -> int: return pow(a, a_pr_k, p) def bob_private_key(p: int) -> int: return random.randint(2, p-2) def bob_public_key(b_pr_k: int, a: int, p: int) -> int: return pow(a, b_pr_k, p) def alice_shared_key(b_pu_k: int, a_pr_k: int, p: int) -> int: return pow(b_pu_k, a_pr_k, p) def bob_shared_key(a_pu_k: int, b_pr_k: int, p: int) -> int: return pow(a_pu_k, b_pr_k, p) def diffie_hellman_key_exchange(a: int, p: int, option: Optional[int] = None) -> bool: if not prime_check(p): return \\"p must be a prime number\\" if a == -1: return \\"a is not a valid primitive root\\" alice_pr_k = alice_private_key(p) alice_pu_k = alice_public_key(alice_pr_k, a, p) bob_pr_k = bob_private_key(p) bob_pu_k = bob_public_key(bob_pr_k, a, p) alice_shared = alice_shared_key(bob_pu_k, alice_pr_k, p) bob_shared = bob_shared_key(alice_pu_k, bob_pr_k, p) print(f\\"Alice\'s private key: {alice_pr_k}\\") print(f\\"Alice\'s public key: {alice_pu_k}\\") print(f\\"Bob\'s private key: {bob_pr_k}\\") print(f\\"Bob\'s public key: {bob_pu_k}\\") print(f\\"Shared key calculated by Alice = {alice_shared}\\") print(f\\"Shared key calculated by Bob = {bob_shared}\\") return alice_shared == bob_shared # Example usage p = 761 a = find_primitive_root(p) result = diffie_hellman_key_exchange(a, p) print(result)"},{"question":"# Question: String Reversal Implementations In this task, you are required to implement four different functions to reverse the given string using different techniques. Each function should adhere to one of the specified methods: recursive, iterative, pythonic, and ultra-pythonic. Function Specifications: 1. **Function Name**: `reverse_recursive` * **Input**: A string `s` (0 ≤ len(s) ≤ 10000) * **Output**: The reversed string. 2. **Function Name**: `reverse_iterative` * **Input**: A string `s` (0 ≤ len(s) ≤ 10000) * **Output**: The reversed string. 3. **Function Name**: `reverse_pythonic` * **Input**: A string `s` (0 ≤ len(s) ≤ 10000) * **Output**: The reversed string. 4. **Function Name**: `reverse_ultra_pythonic` * **Input**: A string `s` (0 ≤ len(s) ≤ 10000) * **Output**: The reversed string. Constraints: * Ensure that your functions can handle the input size within a reasonable runtime. * Avoid using any libraries or functions that directly reverse the string except for the specified method. # Example: ```python # Input s = \\"hello\\" # Output reverse_recursive(s) -> \\"olleh\\" reverse_iterative(s) -> \\"olleh\\" reverse_pythonic(s) -> \\"olleh\\" reverse_ultra_pythonic(s) -> \\"olleh\\" ``` Implement these functions considering the methodology specified.","solution":"def reverse_recursive(s): Reverses the string recursively. if len(s) == 0: return s return s[-1] + reverse_recursive(s[:-1]) def reverse_iterative(s): Reverses the string iteratively. reversed_str = \\"\\" for char in s: reversed_str = char + reversed_str return reversed_str def reverse_pythonic(s): Reverses the string using string slicing. return s[::-1] def reverse_ultra_pythonic(s): Reverses the string using join and reversed functions. return \'\'.join(reversed(s))"},{"question":"# Coding Challenge: Find Numbers that Add Up to Target Given an array of integers sorted in ascending order, find two numbers that add up to a specific target number. Return the indices of the two numbers such that they add up to the target, where index1 must be less than index2. Assume that there is exactly one solution, and you may not use the same element twice. # Function Signature ```python def find_two_sum(numbers: List[int], target: int) -> List[int]: pass ``` # Input 1. **numbers**: A list of integers sorted in ascending order. (1 ≤ len(numbers) ≤ 10^5) 2. **target**: A single integer that represents the target sum. (-10^9 ≤ target ≤ 10^9) # Output Return a list containing two integers, index1 and index2, where 1 ≤ index1 < index2 ≤ len(numbers). # Constraints 1. Each input will have exactly one solution. 2. You may not use the same element twice. # Example ```python numbers = [2, 7, 11, 15] target = 9 find_two_sum(numbers, target) ``` Output: ```python [1, 2] ``` # Instructions 1. Implement the function using any of the three algorithms analyzed (binary search, hash table, two pointers). 2. Ensure the solution adheres to the specified time and space complexities. 3. Check edge cases, like minimal input size and scenarios where no valid pairs exist.","solution":"from typing import List def find_two_sum(numbers: List[int], target: int) -> List[int]: Returns the indices of the two numbers such that they add up to the target, where index1 must be less than index2. The indices are 1-based. left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1"},{"question":"**Scenario**: You are responsible for data transmission in a network where bandwidth is costly. To reduce data volume over the wire, your task is to implement a compression-decompression system using Run-Length Encoding (RLE). **Task**: Implement functions to encode a given string using Run-Length Encoding and decode a string already encoded by RLE. You are to ensure that your implementation handles potential edge cases and performs efficiently. # Function Signatures: ```python def encode_rle(input: str) -> str: pass def decode_rle(input: str) -> str: pass ``` # Requirements: 1. **encode_rle(input: str) -> str**: - **Input**: A string `input` of length `n`, where `0 <= n <= 10^5`. - **Output**: A string representing the run-length encoded version of the input. 2. **decode_rle(input: str) -> str**: - **Input**: A string `input` of run-length encoded format. - **Output**: A string representing the original uncompressed string. # Constraints: * You must handle edge cases such as empty strings, strings without any character repetition, and strings with all identical characters. * Your solution should be optimal, aiming for O(n) time complexity for both encoding and decoding. # Example: ```python # Example for encode_rle input = \\"aaabbbcccaaa\\" output = \\"3a3b3c3a\\" assert encode_rle(input) == output # Example for decode_rle input = \\"3a3b3c3a\\" output = \\"aaabbbcccaaa\\" assert decode_rle(input) == output ``` **Note**: The encoded output format should be a sequence of counts followed by the corresponding character.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" output = [] count = 1 previous_char = input[0] for char in input[1:]: if char == previous_char: count += 1 else: output.append(f\\"{count}{previous_char}\\") previous_char = char count = 1 output.append(f\\"{count}{previous_char}\\") return \\"\\".join(output) def decode_rle(input: str) -> str: if not input: return \\"\\" output = [] count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) else: output.append(char * count) count = 0 return \\"\\".join(output)"},{"question":"# Problem: Implement a Bidirectional Sorting Algorithm Background You are tasked with sorting a dataset by implementing the Cocktail Shaker Sort algorithm. This algorithm is an extension of Bubble Sort and works by sorting the list in both directions in each pass. Task Implement a function `cocktail_shaker_sort(arr)` that sorts a given list of integers in ascending order using the Cocktail Shaker Sort algorithm. Your implementation should utilize the bidirectional traversal feature, where it first sorts from left-to-right and then from right-to-left, and repeats the process until the list is sorted. Input - A list of integers `arr` with length `n` (0 ≤ n ≤ 10^4). Output - The function should return a sorted list of integers. Constraints - You are required to sort the array in place, thus make sure your space complexity is O(1). - Your implementation should handle edge cases, including empty lists and lists with a single element. Example ```python arr = [5, 1, 4, 2, 8] print(cocktail_shaker_sort(arr)) # Output: [1, 2, 4, 5, 8] ``` # Notes - Consider optimization techniques, such as early exit if no swaps are performed during a pass. - Ensure your implementation efficiently handles typical edge cases like arrays with repeated elements or already sorted arrays.","solution":"def cocktail_shaker_sort(arr): Sorts a list of integers in ascending order using the Cocktail Shaker Sort algorithm. n = len(arr) if n <= 1: return arr swapped = True start = 0 end = n - 1 while swapped: # Reset the swapped flag on entering the loop swapped = False # Loop from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # If nothing moved, then the array is sorted if not swapped: break # Reset the swapped flag so that it can be used in the next stage swapped = False # Move the end point back by one, because the item at the end is in its right place end -= 1 # Loop from right to left for i in range(end, start - 1, -1): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # Increase the starting point, because the last iteration would have moved the next smallest number to its correct place start += 1 return arr"},{"question":"# Directed Graph Connection Check **Problem Statement**: You are given a class `DirectedGraph` which constructs a directed graph using nodes and directed edges. Implement a function `check_path_exists(graph: DirectedGraph, start: str, end: str) -> bool` that checks if there exists a directed path from a starting node to a target node in the graph. # Function Description: ```python def check_path_exists(graph: DirectedGraph, start: str, end: str) -> bool: Check if there is a path from \'start\' to \'end\' node in the given directed graph. Parameters: graph (DirectedGraph): A populated directed graph. start (str): The starting node name. end (str): The target node name. Returns: bool: True if a path exists from start to end, False otherwise. ``` # Input: - `graph`: an instance of the `DirectedGraph` class. - `start`: a string denoting the name of the starting node. - `end`: a string denoting the name of the target node. # Output: - `True` if there exists a path from the start node to the end node. - `False` if no such path exists. # Constraints: - Assume all node names are unique strings. - Assume the graph is directed and can contain cycles. # Example: ```python # Graph definition as a dictionary for illustration graph_data = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'D\', \'E\'], \'D\': [\'F\'], \'E\': [], \'F\': [] } graph = DirectedGraph(graph_data) print(check_path_exists(graph, \'A\', \'F\')) # Output: True print(check_path_exists(graph, \'A\', \'E\')) # Output: True print(check_path_exists(graph, \'B\', \'C\')) # Output: False ``` # Notes: - Your function should account for cycles in the graph and avoid infinite loops. - Use graph traversal techniques such as DFS or BFS to implement the path checking logic.","solution":"class DirectedGraph: def __init__(self, graph): Initializes the DirectedGraph with the given adjacency list. :param graph: A dictionary representing the adjacency list of the graph. self.graph = graph def neighbors(self, node): Returns the list of neighbors for a given node. :param node: The node to retrieve neighbors for. :return: List of neighboring nodes. return self.graph.get(node, []) def check_path_exists(graph: DirectedGraph, start: str, end: str) -> bool: Check if there is a path from \'start\' to \'end\' node in the given directed graph. Parameters: graph (DirectedGraph): A populated directed graph. start (str): The starting node name. end (str): The target node name. Returns: bool: True if a path exists from start to end, False otherwise. def dfs(current): if current == end: return True visited.add(current) for neighbor in graph.neighbors(current): if neighbor not in visited: if dfs(neighbor): return True return False visited = set() return dfs(start)"},{"question":"# Bipartite Graph Verification Objective Determine if a given undirected graph is bipartite using a Breadth-First Search (BFS) approach. Scenario A social network consists of users who have various connections marked as friendships. The network wants to determine if it is possible to divide the users into two distinct groups such that no two users within the same group are friends. This can be determined by checking if the network graph is bipartite. Function Signature ```python def is_bipartite(adj_matrix: List[List[int]]) -> bool: Determine if the given graph is bipartite. Args: adj_matrix (List[List[int]]): The graph represented as an adjacency matrix. Returns: bool: True if the graph is bipartite, False otherwise. ``` # Input - `adj_matrix`: An `N x N` matrix where `adj_matrix[i][j] = 1` indicates a direct connection (edge) between vertex `i` and vertex `j`, and `adj_matrix[i][j] = 0` indicates no direct connection (no edge). # Output - Return `True` if the graph is bipartite; otherwise, return `False`. # Constraints - The matrix will be square (i.e., `adj_matrix` will have the same number of rows and columns). - There will be no negative edges. - The matrix will be symmetric because it represents an undirected graph. # Examples ```python adj_matrix1 = [ [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0] ] output1 = True adj_matrix2 = [ [0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0] ] output2 = False ``` These tests check the implementation against multiple scenarios, ensuring that it works for standard cases and catches non-bipartite graphs effectively. # Notes - Handle graphs with self-loops correctly by returning `False`, as self-loops prevent a graph from being bipartite. - Consider graphs that are potentially disconnected; each connected component must be bipartite for the entire graph to be bipartite. Implement the function `is_bipartite` as specified.","solution":"from collections import deque from typing import List def is_bipartite(adj_matrix: List[List[int]]) -> bool: Determine if the given graph is bipartite. Args: adj_matrix (List[List[int]]): The graph represented as an adjacency matrix. Returns: bool: True if the graph is bipartite, False otherwise. N = len(adj_matrix) colors = [-1] * N # To store colors of vertices: -1 means uncolored def bfs(start): queue = deque([start]) colors[start] = 0 # Color the starting vertex with 0 while queue: u = queue.popleft() for v in range(N): if adj_matrix[u][v] == 1: # There is an edge between u and v if colors[v] == -1: # If vertex v is not colored # Color vertex v with opposite color of vertex u colors[v] = 1 - colors[u] queue.append(v) elif colors[v] == colors[u]: # If vertex v has the same color as vertex u return False return True # Check all disconnected components for i in range(N): if colors[i] == -1: if not bfs(i): return False return True"},{"question":"You are given an integer array where each element represents a positive integer. Your task is to implement a function that sums up all these integers without using the \'+\' operator. Instead, you must use bitwise operations (as shown in the provided code snippet). # Input * An integer array `nums`, where `1 <= nums.length <= 1000` and each element `0 <= nums[i] <= 10^9`. # Output * Return a single integer representing the sum of all elements in the array. # Function Signature ```python def sum_without_plus_operator(nums: List[int]) -> int: pass ``` # Example ```python assert sum_without_plus_operator([2, 3, 5]) == 10 assert sum_without_plus_operator([10, 20, 30, 40]) == 100 assert sum_without_plus_operator([1, 1, 1, 1, 1]) == 5 ``` # Constraints 1. Do not use the \'+\' operator to calculate the sum. 2. Use bitwise operations to implement the addition. 3. You can use loops or other structures to iterate over the array. # Hints 1. Refer to the provided code snippet for adding two numbers using bitwise operations. 2. Start with an initial sum of zero and iteratively add each number in the list to this sum using the bitwise addition method provided. # Scenario Imagine you are designing an embedded system where arithmetic operations are costly, and you prefer bitwise logic for addition. Crafting this function will mimic such a scenario, ensuring you are able to efficiently sum numbers without relying on traditional arithmetic.","solution":"def add_bitwise(a, b): Add two integers using bitwise operations. while b != 0: carry = a & b a = a ^ b b = carry << 1 return a def sum_without_plus_operator(nums): Sums up all integers in the list `nums` using bitwise operations. total_sum = 0 for num in nums: total_sum = add_bitwise(total_sum, num) return total_sum"},{"question":"# Question Context Imagine you manage a proprietary tree data structure that organizes user data. You need to extract and process this data efficiently. Given an in-depth understanding of tree traversal, your task is to implement a function to perform the inorder traversal of this tree both iteratively and recursively. Task Write a function `enhanced_inorder` that satisfies the following constraints and requirements, demonstrating your comprehensive understanding of inorder tree traversal: 1. The function should take the root node of a binary tree as input and return a list of node values in inorder sequence. 2. Implement both an iterative method (`inorder_iter`) and a recursive method (`inorder_rec`), and combine their results to ensure they match. Constraints - Nodes will have integer values. - The function must work efficiently for large trees (up to 10,000 nodes). Input - The input is the root of a binary tree. Output - A list of integers representing the inorder traversal of the tree. Performance Requirements - The implementation should not exceed O(n) time complexity. - Aim to minimize additional space usage beyond necessary data structures (e.g., stacks for iteration). ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def enhanced_inorder(root: Node) -> list: def inorder_iter(root): # Implement the iterative inorder traversal pass def inorder_rec(root): # Implement the recursive inorder traversal pass # Combine results from both methods to ensure correctness result_iter = inorder_iter(root) result_rec = inorder_rec(root) assert result_iter == result_rec, \\"Inconsistent results between iterations and recursion\\" return result_iter # Example Usage: if __name__ == \'__main__\': n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert enhanced_inorder(n1) == [25, 50, 75, 100, 125, 150, 175] ``` Notes - Ensure that you handle all edge cases such as empty trees and unbalanced trees. - Verify your implementation with various test cases to confirm its robustness.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def enhanced_inorder(root: Node) -> list: def inorder_iter(root): result = [] stack = [] current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_rec(root): result = [] def dfs(node): if not node: return dfs(node.left) result.append(node.val) dfs(node.right) dfs(root) return result # Combine results from both methods to ensure correctness result_iter = inorder_iter(root) result_rec = inorder_rec(root) assert result_iter == result_rec, \\"Inconsistent results between iterations and recursion\\" return result_iter # Example Usage: if __name__ == \'__main__\': n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert enhanced_inorder(n1) == [25, 50, 75, 100, 125, 150, 175]"},{"question":"# Question: Bitonic Sort Implementation and Extensions **Background**: Bitonic Sort is a comparison-based sorting algorithm suitable for parallel implementation. In this task, you will implement and extend the bitonic sort algorithm provided to handle cases where the length of the array is not a power of 2. **Requirements**: 1. Implement the `bitonic_sort` function to handle arbitrary-length arrays by appropriately padding the array to the next power of 2 using a designated fill value (e.g., infinity for sorting in increasing order). 2. Ensure the function correctly supports both increasing and decreasing sorts. 3. Compare performance between the unpadded and padded implementation for non-power of 2 array sizes. # Function Signature ```python def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: pass ``` # Input * `arr`: A list of integers to be sorted. * `reverse`: A boolean indicating the sort order. Default is `False` (sort in increasing order). # Output * Returns a sorted list of integers. # Constraints * The input list may contain up to 10^5 elements. * The list can include negative numbers. * If `reverse` is `True`, the output list should be in decreasing order; otherwise, in increasing order. # Examples ```python assert bitonic_sort([3, 7, 4, 8, 6, 2, 1, 5]) == [1, 2, 3, 4, 5, 6, 7, 8] assert bitonic_sort([3, 7, 4, 8, 6, 2, 1, 5], reverse=True) == [8, 7, 6, 5, 4, 3, 2, 1] assert bitonic_sort([10, -2, 4, 7, 32, 9]) == [-2, 4, 7, 9, 10, 32] assert bitonic_sort([1]) == [1] assert bitonic_sort([]) == [] ``` # Extension * Write a brief analysis (2-3 paragraphs) explaining the performance difference between padded and unpadded versions for non-power of 2 sizes.","solution":"def bitonic_sort(arr, reverse=False): Perform Bitonic Sort on the input array. Args: arr: List of integers to be sorted. reverse: Boolean indicating the sort order. Default is False (sort in increasing order). Returns: Sorted list of integers. import math, itertools def bitonic_compare_swap(a, b, direction): if (a > b) == direction: return b, a return a, b def bitonic_merge(arr, direction): n = len(arr) if n <= 1: return arr m = n // 2 for i in range(m): arr[i], arr[i + m] = bitonic_compare_swap(arr[i], arr[i + m], direction) return bitonic_merge(arr[:m], direction) + bitonic_merge(arr[m:], direction) def bitonic_sort_recursive(arr, direction): n = len(arr) if n <= 1: return arr m = n // 2 first_half = bitonic_sort_recursive(arr[:m], True) second_half = bitonic_sort_recursive(arr[m:], False) return bitonic_merge(first_half + second_half, direction) # Padding the array to the next power of 2 next_power_of_2 = 1 << (len(arr) - 1).bit_length() padded_arr = arr + [float(\'inf\')] * (next_power_of_2 - len(arr)) result = bitonic_sort_recursive(padded_arr, not reverse) # Remove the padding values sorted_arr = [x for x in result if x != float(\'inf\')] return sorted_arr"},{"question":"# Question As a water resources engineer, you have been assigned to design an algorithm to simulate water flow on a continental land represented by an m x n matrix of non-negative integers. Each cell in the matrix represents the elevation at that point. This matrix is surrounded by two oceans: the Pacific Ocean on the left and top edges, and the Atlantic Ocean on the right and bottom edges. **Task:** Write a function `pacific_atlantic(matrix)` that returns a list of coordinates where water can flow to both the Pacific and Atlantic oceans. Water can only flow from a cell to another cell if the height of the destination cell is equal to or less than the current cell. Water can also flow to adjacent cells in four possible directions: up, down, left, or right. **Input:** * A matrix `matrix` of size m x n where 1 <= m, n <= 150, and each element is a non-negative integer representing the elevation of the land. **Output:** * A list of coordinates `[i, j]` where water can flow to both the Pacific and Atlantic oceans. The order of coordinates in the list does not matter. **Constraints:** * If the matrix is empty, the function should return an empty list. * It is guaranteed that both m and n are less than 150. **Examples:** ``` Given the following 5x5 matrix: Pacific ~ ~ ~ ~ ~ ~ 1 2 2 3 (5) * ~ 3 2 3 (4) (4) * ~ 2 4 (5) 3 1 * ~ (6) (7) 1 4 5 * ~ (5) 1 1 2 4 * * * * * * Atlantic The function should return [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]]. ``` **Function Signature:** ```python def pacific_atlantic(matrix: List[List[int]]) -> List[List[int]]: # Your implementation here pass ``` Provide a well-optimized and correct solution that handles the given constraints efficiently.","solution":"def pacific_atlantic(matrix): if not matrix: return [] m, n = len(matrix), len(matrix[0]) pacific_reachable = [[False]*n for _ in range(m)] atlantic_reachable = [[False]*n for _ in range(m)] def dfs(x, y, ocean_reachable): directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] ocean_reachable[x][y] = True for dx, dy in directions: newX, newY = x + dx, y + dy if 0 <= newX < m and 0 <= newY < n and not ocean_reachable[newX][newY] and matrix[newX][newY] >= matrix[x][y]: dfs(newX, newY, ocean_reachable) for i in range(m): dfs(i, 0, pacific_reachable) dfs(i, n-1, atlantic_reachable) for j in range(n): dfs(0, j, pacific_reachable) dfs(m-1, j, atlantic_reachable) result = [] for i in range(m): for j in range(n): if pacific_reachable[i][j] and atlantic_reachable[i][j]: result.append([i, j]) return result"},{"question":"**Objective**: Implement a specialized hash table that supports a fixed load factor for resizing and includes additional methods for analytical purposes. # Problem Statement You are required to extend the functionality of the provided `ResizableHashTable` class. Implement a hash table based on linear probing that dynamically resizes based on a provided load factor. Additionally, create methods to analyze current load factor and average collision length. **Specifications**: 1. **Class Name**: `AnalyticalHashTable` 2. **Base Class**: `ResizableHashTable` 3. **New Methods Required**: - `current_load_factor() -> float`: Returns the current load factor of the hash table. - `average_collision_length() -> float`: Returns the average length of collision chains. **Method Requirements**: 1. **Resizing Mechanism**: Resize the table when the load factor exceeds a certain threshold, which should be passed during initialization. 2. **Load Factor Calculation**: The load factor is defined as the number of elements divided by the size of the hash table. 3. **Collision Chain Calculation**: The collision chain length is defined as the number of slots inspected during insertion that were occupied. # Input/Output - **Initialization Input**: An integer specifying the initial size of the table, and a float specifying the load factor threshold. - **Method Output**: - `current_load_factor()`: Float value representing the load factor. - `average_collision_length()`: Float value representing the average collision chain length. # Constraints - The initial size of the hash table will be a positive integer. - The load factor threshold will be a float between 0.1 and 1.0. - The table should at least resize once to facilitate testing of both the load factor and collision length calculations. # Example ```python hash_table = AnalyticalHashTable(initial_size=8, load_factor_threshold=0.75) hash_table.put(1, \'a\') hash_table.put(9, \'b\') # should cause a resize print(hash_table.current_load_factor()) # Should print a value <= 0.75 print(hash_table.average_collision_length()) # Average collision length given the insertions ``` # Additional Instructions - Ensure your implementation inherits all methods and properties correctly. - Optimize for average time and space complexity. - Avoid manual rehashing and use inherited mechanisms where possible.","solution":"class ResizableHashTable: def __init__(self, initial_size=8): self.size = initial_size self.table = [None] * self.size self.count = 0 def hash_function(self, key): return key % self.size def put(self, key, value): pos = self.hash_function(key) initial_pos = pos collisions = 0 while self.table[pos] is not None: if self.table[pos][0] == key: self.table[pos] = (key, value) return collisions += 1 pos = (pos + 1) % self.size self.table[pos] = (key, value) self.count += 1 self.collisions += collisions if self.count / self.size > self.load_factor_threshold: self.resize() def get(self, key): pos = self.hash_function(key) while self.table[pos] is not None: if self.table[pos][0] == key: return self.table[pos][1] pos = (pos + 1) % self.size return None def resize(self): old_table = self.table self.size *= 2 self.table = [None] * self.size self.count = 0 for item in old_table: if item is not None: self.put(item[0], item[1]) class AnalyticalHashTable(ResizableHashTable): def __init__(self, initial_size=8, load_factor_threshold=0.75): super().__init__(initial_size) self.load_factor_threshold = load_factor_threshold self.collisions = 0 self.insert_operations = 0 def put(self, key, value): pos = self.hash_function(key) initial_pos = pos collisions = 0 self.insert_operations += 1 while self.table[pos] is not None: if self.table[pos][0] == key: self.table[pos] = (key, value) return collisions += 1 pos = (pos + 1) % self.size self.table[pos] = (key, value) self.count += 1 self.collisions += collisions if self.count / self.size > self.load_factor_threshold: self.resize() def current_load_factor(self): return self.count / self.size def average_collision_length(self): if self.insert_operations == 0: return 0 return self.collisions / self.insert_operations"},{"question":"# Linked List Operations You have been given a partially implemented `DoublyLinkedList` and `SinglyLinkedList` along with their respective `Node` classes. Your task is to implement essential operations for both singly and doubly linked lists such as insertion, deletion, and search. The operations should be efficient and handle edge cases appropriately. Definitions: 1. **Singly Linked List**: Provides operations to append an element, delete an element by value, and search for an element by value. 2. **Doubly Linked List**: Provides operations to append an element, delete an element by value, and search for an element by value. # SinglyLinkedList Implement the following methods: 1. `append(value)`: Adds a new node with the given value at the end of the list. 2. `delete(value)`: Deletes the first node with the given value from the list. If the value is not found, the list remains unchanged. 3. `search(value)`: Returns `True` if a node with the given value exists in the list, otherwise returns `False`. # DoublyLinkedList Implement the following methods: 1. `append(value)`: Adds a new node with the given value at the end of the list. 2. `delete(value)`: Deletes the first node with the given value from the list. If the value is not found, the list remains unchanged. 3. `search(value)`: Returns `True` if a node with the given value exists in the list, otherwise returns `False`. Example: ```python # Singly Linked List example sll = SinglyLinkedList() sll.append(3) sll.append(5) assert sll.search(5) == True sll.delete(3) assert sll.search(3) == False # Doubly Linked List example dll = DoublyLinkedList() dll.append(3) dll.append(5) assert dll.search(5) == True dll.delete(3) assert dll.search(3) == False ``` # Constraints - The `value` will be a positive integer. - Each method should be implemented with consideration for performance and edge cases. - You must not use any built-in Python collections (e.g., list, dict) for storage. You are expected to submit the full implementation of the `SinglyLinkedList` and `DoublyLinkedList` classes with the specified methods.","solution":"class Node: def __init__(self, value): self.value = value self.next = None self.prev = None class SinglyLinkedList: def __init__(self): self.head = None def append(self, value): new_node = Node(value) if not self.head: self.head = new_node return current = self.head while current.next: current = current.next current.next = new_node def delete(self, value): if not self.head: return if self.head.value == value: self.head = self.head.next return current = self.head while current.next and current.next.value != value: current = current.next if current.next: current.next = current.next.next def search(self, value): current = self.head while current: if current.value == value: return True current = current.next return False class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def append(self, value): new_node = Node(value) if not self.head: self.head = new_node self.tail = new_node return self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def delete(self, value): if not self.head: return if self.head.value == value: if self.head == self.tail: self.head = None self.tail = None else: self.head = self.head.next self.head.prev = None return current = self.head while current and current.value != value: current = current.next if current: if current == self.tail: self.tail = self.tail.prev self.tail.next = None else: current.prev.next = current.next current.next.prev = current.prev def search(self, value): current = self.head while current: if current.value == value: return True current = current.next return False"},{"question":"# Task: Enhanced Selection Sort with Custom Swapping # Objective You are required to implement an enhanced version of the selection sort algorithm. Instead of directly swapping elements within the array, you should implement a custom swap function. Furthermore, the algorithm should handle specific constraints efficiently. # Problem Statement Write a function `enhanced_selection_sort(arr: List[int], descending: bool = False) -> List[int]` that sorts an array of integers using an enhanced version of the selection sort algorithm. Add a custom swap function to manage the swapping of elements. Additionally, the function should have the capability to sort in either ascending or descending order based on an input boolean parameter `descending`. # Input Format - `arr`: A list of integers. Example: `[4, 2, 7, 1, 3]`. - `descending`: A boolean value. If `True`, sort the array in descending order. Default is `False` (ascending order). # Output Format - Return a list of integers sorted based on the specified order. # Constraints - You may not use any built-in sort functions (i.e., `list.sort()`, `sorted()`, etc.). - The size of the list, `n`, will be in the range [0, 1000]. - Each element of the list will be an integer that fits within standard integer limits. # Example Example 1: ```python enhanced_selection_sort([4, 2, 7, 1, 3]) ``` **Expected Output**: `[1, 2, 3, 4, 7]` Example 2: ```python enhanced_selection_sort([4, 2, 7, 1, 3], descending=True) ``` **Expected Output**: `[7, 4, 3, 2, 1]` # Key Considerations - Ensure that edge cases (e.g., empty lists, single-element lists, lists with all duplicate elements) are properly handled. - Implement a separate swap function that performs the element swapping to improve code maintainability and clarity. - Efficiently manage any constraints specified in the problem.","solution":"from typing import List def swap(arr: List[int], i: int, j: int): Swap the elements at index i and j in the list arr. arr[i], arr[j] = arr[j], arr[i] def enhanced_selection_sort(arr: List[int], descending: bool = False) -> List[int]: Sorts the array using an enhanced version of the selection sort algorithm. It can sort in ascending or descending order based on the \'descending\' parameter. n = len(arr) for i in range(n): # Assume the i-th position is the minimum (or maximum) in the remaining unsorted array swap_idx = i for j in range(i + 1, n): # Select the proper element based on the required order if (descending and arr[j] > arr[swap_idx]) or (not descending and arr[j] < arr[swap_idx]): swap_idx = j # Perform the swap swap(arr, i, swap_idx) return arr"},{"question":"# Problem: Efficient FFT Computation You have been supplied with an array representing a time-domain signal, composed of complex numbers. Your task is to write a Python function that transforms this array into its frequency-domain representation using the Cooley-Tukey FFT algorithm. **Function Signature**: ```python def fft(signal: List[complex]) -> List[complex]: ``` # Input: - `signal`: A list of complex numbers of length `N`, where `N` is a power of 2 (2, 4, 8, 16, ...). # Output: - A list of complex numbers representing the discrete Fourier transform of the input signal. # Constraints: - The input list length ( N ) will be a power of 2 (1 <= ( N ) <= 2048). - The elements of the array will be valid complex numbers. # Performance: - Your algorithm should run in ( O(N log N) ) time complexity. - Aim to optimize space utilization although recursion will inherently use extra space. # Example ```python # Given Example input_signal = [2.0+2j, 1.0+3j, 3.0+1j, 2.0+2j] output_signal = fft(input_signal) print(output_signal) # Expected: [8+8j, 2j, 2-2j, -2+0j] # Additional Tests can be added by the grader ``` # Notes: - Implement the function from scratch; do not use any library functions directly for FFT. - Consider edge cases such as single-element input lists. - Pay attention to handling indices correctly when combining the results of the recursive calls. Make sure your function passes all provided test cases to verify its correctness and efficiency.","solution":"from typing import List import cmath def fft(signal: List[complex]) -> List[complex]: Efficiently computes the Fast Fourier Transform (FFT) of a given signal using the Cooley-Tukey algorithm. N = len(signal) if N <= 1: return signal even = fft(signal[0::2]) odd = fft(signal[1::2]) T = [cmath.exp(-2j * cmath.pi * k / N) * odd[k] for k in range(N // 2)] return [even[k] + T[k] for k in range(N // 2)] + [even[k] - T[k] for k in range(N // 2)]"},{"question":"**Question Title**: Stack Pair Switching with Auxiliary Storage **Description**: You are given a stack that holds a sequence of integer values. Your task is to write a function that switches successive pairs of elements starting from the bottom of the stack using auxiliary storage. If the stack has an odd number of elements, the top most element should remain in its position. You are required to implement two versions of this function: 1. `first_switch_pairs`: Uses an auxiliary stack to achieve the switching. 2. `second_switch_pairs`: Uses an auxiliary queue to achieve the switching. **Function Signatures**: ```python def first_switch_pairs(stack: list) -> list: # Your solution here pass def second_switch_pairs(stack: list) -> list: # Your solution here pass ``` **Input**: - `stack`: A list of integers representing a stack where the last element of the list is the top of the stack. **Output**: - A list representing the stack after switching successive pairs of elements. **Constraints**: - The stack will not contain more than 10^5 elements. - Each element will be an integer within the range [-10^9, 10^9]. **Example**: ```python # Example 1: stack = [3, 8, 17, 9, 1, 10] print(first_switch_pairs(stack)) # Output: [8, 3, 9, 17, 10, 1] print(second_switch_pairs(stack)) # Output: [8, 3, 9, 17, 10, 1] # Example 2: stack = [3, 8, 17, 9, 1] print(first_switch_pairs(stack)) # Output: [8, 3, 9, 17, 1] print(second_switch_pairs(stack)) # Output: [8, 3, 9, 17, 1] ``` **Notes**: - You must handle the case when the stack is empty. - Ensure optimal solution in terms of time and space complexity.","solution":"def first_switch_pairs(stack): if not stack: return stack auxiliary_stack = [] while stack: auxiliary_stack.append(stack.pop()) while auxiliary_stack: element = auxiliary_stack.pop() if auxiliary_stack: next_element = auxiliary_stack.pop() stack.append(next_element) stack.append(element) return stack def second_switch_pairs(stack): if not stack: return stack from collections import deque queue = deque() while stack: queue.appendleft(stack.pop()) while queue: element = queue.popleft() if queue: next_element = queue.popleft() stack.append(next_element) stack.append(element) return stack"},{"question":"# Objective Write two functions to encode and decode a list of strings. The aim is to ensure that the encoded format allows precise reconstruction of the original list of strings. # Function Signatures - `encode(strs: List[str]) -> str` - `decode(s: str) -> List[str]` # Description 1. **Encode Function**: This function takes a list of strings `strs` and returns a single string that represents the encoded list with the following rules: - Each string in the list should be prefixed by its length followed by a special character \':\'. - There should be no additional delimiters or spaces between the encoded strings. 2. **Decode Function**: This function takes a single encoded string `s` and returns the original list of strings by reversing the encode process. # Input and Output Format - **Input for `encode`**: - `strs`: List of strings `List[str]` where each string can consist of any printable ASCII characters including spaces. - **Output for `encode`**: A single encoded string `str`, satisfying the above encoding rules. - **Input for `decode`**: - `s`: A string `str` representing the encoded list. - **Output for `decode`**: A list of strings `List[str]` which is the original list before encoding. # Constraints - Each string can be up to 10^5 characters in length. - The number of strings in the list can be up to 10^4. - The total length of all strings combined will not exceed 10^7 characters. # Examples Example 1 ```python encode([\\"hello\\", \\"world\\"]) -> \\"5:hello5:world\\" decode(\\"5:hello5:world\\") -> [\\"hello\\", \\"world\\"] ``` Example 2 ```python encode([\\"data\\", \\"structures\\", \\"and\\", \\"algorithms\\"]) -> \\"4:data10:structures3:and10:algorithms\\" decode(\\"4:data10:structures3:and10:algorithms\\") -> [\\"data\\", \\"structures\\", \\"and\\", \\"algorithms\\"] ``` Example 3 ```python encode([\\"\\"]) -> \\"0:\\" decode(\\"0:\\") -> [\\"\\"] ``` # Guidelines - Make sure to handle edge cases, such as empty strings or strings containing special characters. - Ensure efficient time and space complexity to handle the upper limits of input sizes.","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. Args: strs (List[str]): The list of strings to encode. Returns: str: A single encoded string. encoded_str = \'\'.join(f\\"{len(s)}:{s}\\" for s in strs) return encoded_str def decode(s: str) -> List[str]: Decodes a single string to a list of strings. Args: s (str): The encoded string. Returns: List[str]: The decoded list of strings. decoded_list = [] i = 0 while i < len(s): j = i while s[j] != \':\': j += 1 length = int(s[i:j]) decoded_list.append(s[j+1:j+1+length]) i = j + 1 + length return decoded_list"},{"question":"# Question: Implement an Optimized Merge Sort **Context**: You have been hired to optimize a data processing application that frequently needs to sort large datasets. The current version uses the classic Merge Sort algorithm, which, while stable and having good time complexity, suffers from high space complexity. Your goal is to implement a space-optimized version of Merge Sort that works efficiently for large datasets. **Task**: Write a Python function `merge_sort_inplace(arr)` that sorts a list of integers in non-decreasing order using an optimized version of Merge Sort that performs in-place sorting. Function Signature ```python def merge_sort_inplace(arr: List[int]) -> None: Modifies `arr` in-place to sort the elements in non-decreasing order. Parameters: arr (List[int]): The list of integers to be sorted. Returns: None ``` # Input & Output * **Input**: A list of integers `arr` (0 ≤ len(arr) ≤ 100,000, -10^9 ≤ arr[i] ≤ 10^9). * **Output**: The function should modify the input list `arr` in-place such that it is sorted in non-decreasing order. The function should not return anything. # Constraints * The algorithm should have a time complexity of O(n log n). * Aim to reduce the space complexity compared to the conventional Merge Sort algorithm. * Consider edge cases such as empty lists and lists with a single element. # Example ```python arr = [3, 6, 2, 7, 5] merge_sort_inplace(arr) print(arr) # Output should be [2, 3, 5, 6, 7] arr = [] merge_sort_inplace(arr) print(arr) # Output should be [] arr = [1] merge_sort_inplace(arr) print(arr) # Output should be [1] ``` # Notes * Refrain from using additional lists for merging; try to sort the elements within the original list. * You might need helper functions to perform specific tasks within the main `merge_sort_inplace` function. * Make sure your implementation is efficient and handles all edge cases.","solution":"def merge_sort_inplace(arr): Modifies `arr` in-place to sort the elements in non-decreasing order using an optimized version of Merge Sort that performs in-place sorting. Parameters: arr (List[int]): The list of integers to be sorted. Returns: None def merge_inplace(arr, start, mid, end): start2 = mid + 1 # If the direct merge is already sorted if arr[mid] <= arr[start2]: return while start <= mid and start2 <= end: if arr[start] <= arr[start2]: start += 1 else: value = arr[start2] index = start2 while index != start: arr[index] = arr[index - 1] index -= 1 arr[start] = value start += 1 mid += 1 start2 += 1 def merge_sort_inplace_util(arr, start, end): if start < end: mid = start + (end - start) // 2 merge_sort_inplace_util(arr, start, mid) merge_sort_inplace_util(arr, mid + 1, end) merge_inplace(arr, start, mid, end) merge_sort_inplace_util(arr, 0, len(arr) - 1)"},{"question":"Scenario You are tasked with developing low-level functions for a hardware controller that manipulates binary data. The controller frequently needs to insert bits into its binary registers represented by integers. Your job is to implement functions to insert one or multiple bits at specified positions in a given integer. Function Definitions 1. `insert_one_bit(num: int, bit: int, i: int) -> int` * **Input**: * `num` - An integer representing the binary register. * `bit` - A single bit (either 0 or 1) to insert. * `i` - Index position where the bit is to be inserted. * **Output**: An integer with the `bit` inserted at position `i`. 2. `insert_mult_bits(num: int, bits: int, length: int, i: int) -> int` * **Input**: * `num` - An integer representing the binary register. * `bits` - An integer representing multiple bits to be inserted. * `length` - The number of bits in the `bits`. * `i` - Index position where the bits are to be inserted. * **Output**: An integer with the `bits` inserted at position `i`. Requirements 1. Ensure that the insertion maintains the integrity of bits to the right of position `i`. 2. Both functions should handle edge cases, such as inserting at the beginning or end of the integer. 3. Provide the time and space complexity of your solution. Examples ```python # Example for insert_one_bit print(insert_one_bit(21, 1, 2)) # Should return 45 (binary: 101101) print(insert_one_bit(21, 0, 2)) # Should return 41 (binary: 101001) print(insert_one_bit(21, 1, 5)) # Should return 53 (binary: 110101) print(insert_one_bit(21, 1, 0)) # Should return 43 (binary: 101011) # Example for insert_mult_bits print(insert_mult_bits(5, 7, 3, 1)) # Should return 47 (binary: 101111) print(insert_mult_bits(5, 7, 3, 0)) # Should return 47 (binary: 101111) print(insert_mult_bits(5, 7, 3, 3)) # Should return 61 (binary: 111101) ``` You are required to implement these functions correctly and efficiently.","solution":"def insert_one_bit(num: int, bit: int, i: int) -> int: Inserts a single bit at position i into the integer num. # Mask for the bit to insert bit_mask = bit << i # Shift all bits after position i to make space for the new bit left_part = num >> i << (i + 1) # Preserve the bits before position i right_part = num & ((1 << i) - 1) # Combine the parts with the new bit return left_part | bit_mask | right_part def insert_mult_bits(num: int, bits: int, length: int, i: int) -> int: Inserts multiple bits at position i into the integer num. # Mask for the bits to insert bits_mask = bits << i # Shift all bits after position i to make space for the new bits left_part = num >> i << (i + length) # Preserve the bits before position i right_part = num & ((1 << i) - 1) # Combine the parts with the new bits return left_part | bits_mask | right_part"},{"question":"# Question: Insertion Sort with Binary Search To enhance your understanding of sorting algorithms and binary search, implement the insertion sort algorithm using the provided binary search helper function. This exercise will showcase your ability to systematically combine searching and sorting techniques for efficient in-place data ordering. **Function to Implement**: ```python def insertion_sort_with_binary_search(arr): Sorts an array using insertion sort algorithm enhanced with binary search for finding the right insert position. Parameters: arr (list): The list of integers to be sorted. Returns: list: A new sorted list. pass ``` # Input and Output: - The function will receive a single parameter `arr` which is a list of integers. - The function should return the sorted list. # Constraints: - You can assume the input list will have at least one element and no more than 10,000 elements. # Example: ```python print(insertion_sort_with_binary_search([8, 2, 4, 9, 3, 6])) # => [2, 3, 4, 6, 8, 9] print(insertion_sort_with_binary_search([-3, -1, -2, -4])) # => [-4, -3, -2, -1] ``` # Requirements: - Use the `search_insert` function provided as part of your solution. - Maintain efficiency in your implementation, demonstrating O(n log n) time complexity where possible for the search operations. # Task Context: You are developing a large-scale log processing system where logs must be inserted into a sorted list based on timestamps. Your current approach involves simple insertion sort which proves inefficient. Use binary search to optimize the process, ensuring each log is inserted in its correct position with minimal insertion time.","solution":"def search_insert(arr, val): Helper function to find the index where val should be inserted to keep arr sorted. Uses binary search. Parameters: arr (list): The sorted list of integers. val (int): The value to find the insertion index for. Returns: int: The index where val should be inserted. low, high = 0, len(arr) - 1 while low <= high: mid = (low + high) // 2 if arr[mid] < val: low = mid + 1 else: high = mid - 1 return low def insertion_sort_with_binary_search(arr): Sorts an array using insertion sort algorithm enhanced with binary search for finding the right insert position. Parameters: arr (list): The list of integers to be sorted. Returns: list: A new sorted list. if len(arr) <= 1: return arr sorted_arr = [arr[0]] for val in arr[1:]: pos = search_insert(sorted_arr, val) sorted_arr.insert(pos, val) return sorted_arr"},{"question":"**Question: Efficient Sub-Square Sum Calculation** Your task is to implement a more efficient algorithm to find the sum of all k x k sub-squares in a given n x n matrix. # Objectives 1. **Function Signature**: Implement a function `efficient_sum_sub_squares(matrix: List[List[int]], k: int) -> List[List[int]]`. 2. **Input**: - `matrix`: A 2D list of integers representing an n x n matrix. - `k`: An integer representing the size of sub-squares. 3. **Output**: - A 2D list of integers where each element represents the sum of a k x k sub-square of the input matrix. 4. **Constraints**: - The input matrix will have dimensions n x n, where 1 <= n <= 1000. - The value of k will be such that 1 <= k <= n. - Matrix elements will be between -10^4 to 10^4. # Scenario Imagine you are developing a feature for an image processing software where local areas\' sums are computed for various operations like image blurring, feature extraction, etc. Given the inefficiency of the initial approach, optimize the current solution for better performance. # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] k = 2 # Expected Output # [ # [12, 16], # [24, 28] # ] ``` In this example, the sums of all possible 2 x 2 sub-squares are: - First sub-square (top-left): 1 + 2 + 4 + 5 = 12 - Second sub-square (top-right): 2 + 3 + 5 + 6 = 16 - Third sub-square (bottom-left): 4 + 5 + 7 + 8 = 24 - Fourth sub-square (bottom-right): 5 + 6 + 8 + 9 = 28 # Requirements Improve the performance by minimizing redundant calculations. Use a helper approach, such as prefix sums, to speed up the computation.","solution":"from typing import List def efficient_sum_sub_squares(matrix: List[List[int]], k: int) -> List[List[int]]: n = len(matrix) # Step 1: Compute the prefix sum matrix prefix_sum = [[0]*(n+1) for _ in range(n+1)] for i in range(1, n+1): for j in range(1, n+1): prefix_sum[i][j] = (matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1]) result = [] for i in range(n - k + 1): row = [] for j in range(n - k + 1): total_sum = (prefix_sum[i+k][j+k] - prefix_sum[i][j+k] - prefix_sum[i+k][j] + prefix_sum[i][j]) row.append(total_sum) result.append(row) return result"},{"question":"# B-Tree Operations Implementation You are required to implement a specific operation on a B-tree which involves complex handling of keys and nodes. # Problem Statement Given a B-tree that supports insertion, search, and deletion, implement an operation to find the k-th smallest element in the B-tree. The B-tree is defined using the `Node` and `BTree` classes provided. Input Format - An instance of `BTree` with its nodes containing integer keys. - An integer `k` representing the position (1-based index) of the smallest element to be retrieved from the B-tree. Output Format - Return the k-th smallest element (an integer) in the B-tree. Constraints - 1 <= k <= number of elements in the B-tree - The tree is guaranteed to contain at least k elements. # Function Signature ```python def find_kth_smallest_element(tree: BTree, k: int) -> int: ``` # Example Given the B-tree with the following structure: ``` 25 / 10 30 / 5 15 35 20 ``` - `find_kth_smallest_element(tree, 3)` should return 15. - `find_kth_smallest_element(tree, 5)` should return 25. # Guidelines - You may need to traverse the tree in an in-order manner to find the k-th smallest element. - Consider edge cases like nodes with no children or nodes that are full. - Optimize for time complexity to remain within O(log n) operations where possible.","solution":"class Node: def __init__(self, keys=[], children=[], leaf=True): self.keys = keys # List of keys in this node self.children = children # List of child nodes self.leaf = leaf # Is this node a leaf node? class BTree: def __init__(self, t): self.root = Node() self.t = t # Minimum degree (defines the range for number of keys) def find_kth_smallest_element(tree, k): Traverses the B-tree in-order and finds the k-th smallest element. def inorder_traversal(node, result): if node is not None: for i in range(len(node.keys) + 1): if i < len(node.children): inorder_traversal(node.children[i], result) if i < len(node.keys): result.append(node.keys[i]) result = [] inorder_traversal(tree.root, result) return result[k-1]"},{"question":"Context You are tasked with implementing an algorithm that summarizes continuous ranges in a sorted list of integers. This functionality is crucial for summarizing large datasets where compact visual representation is essential, such as in data analytics and reporting systems. Problem Statement Write a Python function `summarize_ranges` that takes a sorted list of integers without duplicates and returns a list of strings summarizing the continuous ranges. Function Signature ```python def summarize_ranges(array: List[int]) -> List[str]: ``` Input - `array`: A list of integers `List[int]`, sorted in non-decreasing order and containing no duplicates. - Length of the list: 0 ≤ len(array) ≤ 10^4 - Each element `e` in the list: -10^6 ≤ e ≤ 10^6 Output - A list of strings `List[str]` where each string represents a continuous range in the format: - \\"start-end\\" for ranges with more than one element (inclusive). - \\"single\\" for a single element (where start equals end). Constraints - You can assume that the input list is already sorted and contains no duplicates. - Minimize the time and space complexity of your solution. Examples ```python summarize_ranges([0, 1, 2, 4, 5, 7]) # Returns [\\"0-2\\", \\"4-5\\", \\"7\\"] summarize_ranges([1, 3, 5, 7]) # Returns [\\"1\\", \\"3\\", \\"5\\", \\"7\\"] summarize_ranges([0]) # Returns [\\"0\\"] ``` Performance Requirements - The solution should run in O(n) time complexity where n is the length of the input list. - Use O(n) space complexity for the resultant list.","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: Summarize continuous ranges in a sorted list of integers. Parameters: array (List[int]): A sorted list of integers without duplicates. Returns: List[str]: A list of strings summarizing the continuous ranges. if not array: return [] ranges = [] start = end = array[0] for num in array[1:]: if num == end + 1: end = num else: if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") start = end = num if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") return ranges"},{"question":"# Objective: Your task is to implement the Dinic algorithm for computing the maximum flow in a directed graph. You need to write the functions for BFS and DFS which are used within the main Dinic algorithm function. # Function Signature: ```python def dinic(capacity: List[List[int]], source: int, sink: int) -> int: pass ``` # Requirements: 1. **Input**: * `capacity`: A 2D list of integers representing the capacity of the edges. If there is no edge from i to j, then capacity[i][j] is zero. * `source`: An integer representing the source vertex in the graph. * `sink`: An integer representing the sink vertex in the graph. 2. **Output**: An integer representing the maximum flow from the source to the sink. # Constraints: - The number of vertices in the graph must be <= 200. - Capacity values are non-negative integers. - Source and sink are valid vertices in the graph. # Specifications: 1. Implement `dinic_bfs` and `dinic_dfs` functions as helper functions used within the main `dinic` function. 2. Ensure that the maximum flow is computed accurately considering all possible augmenting paths. 3. Optimize for performance to handle larger graphs up to the constraint limits. # Example: ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 assert dinic(capacity, source, sink) == 23 ``` **Describe the scenario**: You are building a network that routes data packets from a central server (source) to several endpoints (sink). Your goal is to maximize the flow of data while respecting the capacity limits of each connection. Implementing the Dinic algorithm will help you achieve an efficient routing system that maximizes data throughput.","solution":"from typing import List from collections import deque def dinic_bfs(capacity: List[List[int]], source: int, sink: int, level: List[int]) -> bool: n = len(capacity) for i in range(n): level[i] = -1 queue = deque([source]) level[source] = 0 while queue: u = queue.popleft() for v in range(n): if level[v] < 0 and capacity[u][v] - flow[u][v] > 0: level[v] = level[u] + 1 queue.append(v) return level[sink] >= 0 def dinic_dfs(u: int, flow_in: int, sink: int, capacity: List[List[int]], level: List[int]) -> int: if u == sink: return flow_in for v in range(len(capacity)): if level[v] == level[u] + 1 and capacity[u][v] - flow[u][v] > 0: f_to_add = min(flow_in, capacity[u][v] - flow[u][v]) dfs_flow = dinic_dfs(v, f_to_add, sink, capacity, level) if dfs_flow > 0: flow[u][v] += dfs_flow flow[v][u] -= dfs_flow return dfs_flow return 0 def dinic(capacity: List[List[int]], source: int, sink: int) -> int: global flow # to use \'flow\' globally in bfs and dfs n = len(capacity) flow = [[0] * n for _ in range(n)] level = [-1] * n max_flow = 0 while dinic_bfs(capacity, source, sink, level): while True: flow_added = dinic_dfs(source, float(\'Inf\'), sink, capacity, level) if flow_added == 0: break max_flow += flow_added return max_flow"},{"question":"# Inorder Tree Traversal: Implement Both Iterative and Recursive Approaches You are provided with a binary tree data structure. Your task is to implement two functions that perform an inorder traversal on this tree: 1. `inorder_iterative(root)` - an iterative approach using a stack. 2. `inorder_recursive(root)` - a recursive approach. Both functions should return a list of node values in the inorder sequence. # Input * `root`: The root node of the binary tree. Each node has two children, `left` and `right`, which can be `None`. # Output * A list of integers representing the node values in the inorder sequence. # Constraints * The number of nodes in the tree will not exceed (10^4). * Node values are unique integers. * Your solutions should work within the time and space complexities of O(n) and O(h), respectively. # Example Given the binary tree: ``` 100 / 50 150 / / 25 75 125 175 ``` Your functions should return the list `[25, 50, 75, 100, 125, 150, 175]`. # Edge Cases * An empty tree should return an empty list. * A single-node tree should return a list with that one node. # Function Definitions ```python def inorder_iterative(root): # Implement the iterative approach using a stack pass def inorder_recursive(root): # Implement the recursive approach pass ``` Write both implementations effectively to handle the traversal properly ensuring the constraints are met. Test your functions with varied tree structures to validate efficiency and correctness.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_iterative(root): Iterative inorder traversal using a stack. stack, result = [], [] current = root while current or stack: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_recursive(root): Recursive inorder traversal. def helper(node, result): if not node: return helper(node.left, result) result.append(node.val) helper(node.right, result) result = [] helper(root, result) return result"},{"question":"You are required to implement an optimized version of Dijkstra’s algorithm to find the shortest path from a source node to all other nodes in a weighted graph. Unlike the standard implementation using an adjacency matrix, you will use an adjacency list and a priority queue to improve the efficiency. # Implement the following Function: ```python def optimized_dijkstra(graph, source): Calculate the shortest path from the source node to all other nodes in the graph using Dijkstra\'s algorithm with an adjacency list and priority queue. Parameters: graph (dict): A dictionary where keys are node labels and values are lists of tuples (neighbor, weight) representing the graph. source (int): The source vertex to start the shortest path algorithm. Returns: dict: A dictionary where keys are node labels and values are the shortest distance from the source to that node. pass ``` # Input Format: * `graph`: A dictionary representing the weighted graph where keys are node labels (integers) and values are lists of tuples. Each tuple contains two integers: the target node and the edge weight. * `source`: An integer representing the source node from which the shortest paths are to be calculated. # Output Format: * A dictionary where keys are node labels and values are the shortest distances from the source node to that node. # Constraints: * The graph will have at most 1000 nodes. * Edge weights will be non-negative integers. * There will be no negative weight cycles in the graph. # Example: ```python graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } source = 0 print(optimized_dijkstra(graph, source)) ``` Expected Output: ```python {0: 0, 1: 3, 2: 1, 3: 4} ``` # Requirements: * Implement the algorithm utilizing a priority queue for optimal performance. * Ensure your solution handles the described edge cases.","solution":"import heapq def optimized_dijkstra(graph, source): Calculate the shortest path from the source node to all other nodes in the graph using Dijkstra\'s algorithm with an adjacency list and priority queue. Parameters: graph (dict): A dictionary where keys are node labels and values are lists of tuples (neighbor, weight) representing the graph. source (int): The source vertex to start the shortest path algorithm. Returns: dict: A dictionary where keys are node labels and values are the shortest distance from the source to that node. distances = {node: float(\'inf\') for node in graph} distances[source] = 0 priority_queue = [(0, source)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If a popped node is encountered with a longer distance, skip processing if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"Scenario: You are working on a linked list library that allows users to manipulate lists dynamically. One common operation that users frequently request is the ability to remove a range of elements from a linked list. To optimize list operations, your task is to write a function that efficiently removes a specified range of elements from the list. Problem: You need to implement the function `def remove_range(head, start, end):` that removes elements from the linked list `head`, starting from position `start` to position `end` (both inclusive). Input: * `head`: The head node of the singly linked list. * `start`: An integer denoting the starting index of the range to be removed (0-based index). * `end`: An integer denoting the ending index of the range to be removed (0-based index). Output: Return the head node of the modified linked list. Constraints: * 0 <= start <= end < list_size. * list_size is the number of nodes in the linked list. Example: ```python # Helper function to create a linked list from a list and return the head node class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def array_to_list(arr): if not arr: return None head = ListNode(arr[0]) current = head for val in arr[1:]: current.next = ListNode(val) current = current.next return head # Helper function to convert linked list to a Python list def list_to_array(node): result = [] while node: result.append(node.val) node = node.next return result # Example usage initial_list = [8, 13, 17, 4, 9, 12, 98, 41, 7, 23, 0, 92] linked_list = array_to_list(initial_list) # Given operation result_head = remove_range(linked_list, 3, 8) # Convert result back to list for verification print(list_to_array(result_head)) # Output should be: [8, 13, 17, 23, 0, 92] ``` Notes: * Ensure edge cases are handled, such as removing elements that include the head of the list. * Assume list nodes are draggable to create new neighbors.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_range(head, start, end): Removes elements from the linked list starting from position `start` to `end` (both inclusive). :param head: ListNode, the head of the linked list. :param start: int, starting index of the range to be removed. :param end: int, ending index of the range to be removed. :return: ListNode, the head of the modified linked list. # Dummy node to handle edge cases easily dummy = ListNode(0) dummy.next = head prev = dummy current = head # Move `prev` to the node just before the start position for _ in range(start): prev = current current = current.next # Move `current` to the end position for _ in range(end - start + 1): current = current.next # Link the end of the previous section to the node after the range prev.next = current return dummy.next"},{"question":"# Question You are hired by a database management company to help optimize their record search operations. The company stores its records in sorted arrays and typically handles large amounts of data. Your task is to implement an efficient search algorithm suitable for this use case. **Problem Statement**: Write a function `interpolation_search_records` that uses the interpolation search algorithm to find a specific record (search key) in a sorted array of records. # Function Signature ```python def interpolation_search_records(records: List[int], search_key: int) -> int: ``` # Input * `records` (List[int]): A list of integers (sorted in increasing order) representing the database records. * `search_key` (int): The record you are searching for. # Output * (int): The index of `search_key` in `records` if found; otherwise, return -1. # Constraints * The length of `records` will be between 1 and 10^6. * Each element in `records` will be an integer between -10^9 and 10^9. * `search_key` will be an integer between -10^9 and 10^9. # Examples ```python assert interpolation_search_records([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) == 2 assert interpolation_search_records([5, 10, 12, 14, 17, 20, 21], 55) == -1 assert interpolation_search_records([5, 10, 12, 14, 17, 20, 21], -5) == -1 assert interpolation_search_records([], 10) == -1 # Edge case: empty array assert interpolation_search_records([1], 1) == 0 # Edge case: singleton array ``` # Hints * Consider the efficiency of the search when the data points are not uniformly distributed. * Make sure to handle potential edge cases, such as empty arrays and records where all elements are equal. * Comment your code to explain each step of the algorithm.","solution":"from typing import List def interpolation_search_records(records: List[int], search_key: int) -> int: Performs interpolation search on a sorted list of records to find the index of the search_key. :param records: A sorted list of integers representing the database records. :param search_key: The value to search for in the records. :return: The index of search_key in records, or -1 if search_key is not in the records. if not records: return -1 low = 0 high = len(records) - 1 while low <= high and search_key >= records[low] and search_key <= records[high]: if low == high: if records[low] == search_key: return low return -1 # Estimate the position of the search_key using the interpolation formula pos = low + ((search_key - records[low]) * (high - low) // (records[high] - records[low])) if records[pos] == search_key: return pos elif records[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"Gnome Sort Analysis and Implementation Scenario You\'ve been hired by a startup to help them sort datasets in an efficient manner. As a preliminary task, you are asked to evaluate the simplicity and effectiveness of an unconventional sorting algorithm, Gnome Sort. You\'ll develop a function to perform Gnome Sort on a given list and analyze edge cases to ensure reliability. Question **Task**: Implement a function `gnome_sort(arr: List[int]) -> List[int]` in Python that sorts an array of integers in non-decreasing order using the Gnome Sort algorithm. Ensure your implementation handles edge cases effectively. **Input**: - A list of integers `arr` with `0 <= len(arr) <= 10^5` and `-10^6 <= arr[i] <= 10^6`. **Output**: - A list of integers sorted in non-decreasing order. **Constraints**: - The algorithm must be implemented using the Gnome Sort technique. - The sorting should be done in place, i.e., without using any additional lists or arrays. - You should consider various edge cases such as: - An empty array (i.e., `arr = []`). - An array with all identical elements (i.e., `arr = [5, 5, 5, 5]`). - An already sorted array. - An array sorted in reverse order. **Performance Requirements**: - Your implementation should handle the given constraints efficiently within reasonable time limits for different array sizes and values. **Example**: ```python assert gnome_sort([34, 2, 10, -9]) == [-9, 2, 10, 34] assert gnome_sort([]) == [] assert gnome_sort([5, 5, 5, 5]) == [5, 5, 5, 5] assert gnome_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert gnome_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] ``` Good luck!","solution":"from typing import List def gnome_sort(arr: List[int]) -> List[int]: Sorts an array of integers using the Gnome Sort algorithm. Args: arr (List[int]): A list of integers to sort. Returns: List[int]: The sorted list of integers. index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Problem: Additive Expression Evaluation **Objective**: Implement a function that generates and returns all possible expressions that can be formed by inserting binary operators (+, -, *) between the digits of a given string, such that the resulting expression evaluates to a specified target value. Function Signature ```python def add_operators(num: str, target: int) -> list: :param num: A string containing only digits (0-9). :param target: An integer representing the target value. :return: A list of strings, each representing a valid expression that evaluates to the target value. ``` Input * `num`: A string that contains only digits (0-9), with length in the range [1, 10]. * `target`: An integer value (-2^31 <= target <= 2^31 - 1). Output * Return a list of strings, where each string represents a valid arithmetic expression using the binary operators (+, -, *) that evaluates to the target value. * If no valid expression can be formed, return an empty list. Examples 1. `add_operators(\\"123\\", 6)` -> `[\\"1+2+3\\", \\"1*2*3\\"]` 2. `add_operators(\\"232\\", 8)` -> `[\\"2*3+2\\", \\"2+3*2\\"]` 3. `add_operators(\\"105\\", 5)` -> `[\\"1*0+5\\", \\"10-5\\"]` 4. `add_operators(\\"00\\", 0)` -> `[\\"0+0\\", \\"0-0\\", \\"0*0\\"]` 5. `add_operators(\\"3456237490\\", 9191)` -> `[]` Constraints * Ensure that all digits from the input string are used exactly once in forming the expressions. * Handle cases where no valid expression matches the target within a reasonable execution time. # Task Using the guidelines provided, implement the `add_operators` function by leveraging the depth-first search approach with backtracking to explore all possibilities of placing operators and validate if each resulting expression matches the target. **Hint**: Pay special attention to handling edge cases like leading zeros in the input string.","solution":"def add_operators(num: str, target: int) -> list: def dfs(index, path, value, prev_operand): if index == len(num): if value == target: result.append(path) return for i in range(index, len(num)): if i != index and num[index] == \'0\': break curr_str = num[index:i+1] curr_operand = int(curr_str) if index == 0: dfs(i + 1, curr_str, curr_operand, curr_operand) else: dfs(i + 1, path + \'+\' + curr_str, value + curr_operand, curr_operand) dfs(i + 1, path + \'-\' + curr_str, value - curr_operand, -curr_operand) dfs(i + 1, path + \'*\' + curr_str, value - prev_operand + prev_operand * curr_operand, prev_operand * curr_operand) result = [] dfs(0, \\"\\", 0, 0) return result"},{"question":"Context In various computational problems, efficiently determining the greatest common divisor (GCD), the least common multiple (LCM), and trailing zero bits plays a critical role. Understanding and optimizing these algorithms are essential skills in both competitive programming and software development. Problem Statement Given the functions `gcd(a, b)`, `gcd_bit(a, b)`, and `trailing_zero(x)`, you are tasked with extending the utility of these mathematical operations by implementing a new function `gcd_lcm_trailing(a: int, b: int) -> dict`. The function should: 1. Compute the GCD of `a` and `b` using both the traditional method and the bitwise method. 2. Calculate the LCM of `a` and `b`. 3. Determine the number of trailing zeros in the binary representation of the GCD obtained by both methods. Expected Input and Output * **Input**: Two non-negative integers `a` and `b` such that `1 <= a, b <= 10^9`. * **Output**: A dictionary with the following structure: ```json { \\"gcd\\": gcd_value, # Greatest common divisor using Euclid\'s Algorithm \\"gcd_bit\\": gcd_bit_value, # Greatest common divisor using bitwise operations \\"lcm\\": lcm_value, # Least common multiple \\"trailing_zeros_gcd\\": tz_gcd, # Trailing zeros in binary representation of gcd_value \\"trailing_zeros_gcd_bit\\": tz_gcd_bit # Trailing zeros in binary representation of gcd_bit_value } ``` * **Constraints**: * Ensure all inputs are valid non-negative integers. * Do not use any built-in Python libraries for GCD, LCM, or bit manipulation. Function Signature ```python def gcd_lcm_trailing(a: int, b: int) -> dict: pass ``` # Example Input ```python a = 54 b = 24 ``` Output ```python { \\"gcd\\": 6, \\"gcd_bit\\": 6, \\"lcm\\": 216.0, \\"trailing_zeros_gcd\\": 1, \\"trailing_zeros_gcd_bit\\": 1 } ``` Notes * Focus on implementing efficient algorithms for large input values. * Be mindful of edge cases such as when either `a` or `b` is 1. * Ensure your solution handles the constraints and performs input validation as necessary.","solution":"def gcd(a, b): Compute the Greatest Common Divisor using Euclid\'s algorithm. while b: a, b = b, a % b return a def gcd_bit(a, b): Compute the Greatest Common Divisor using binary (bitwise) GCD algorithm. if a == 0: return b if b == 0: return a # Finding common factors of 2 shift = 0 while ((a | b) & 1) == 0: a >>= 1 b >>= 1 shift += 1 while (a & 1) == 0: a >>= 1 while b != 0: while (b & 1) == 0: b >>= 1 if a > b: a, b = b, a b -= a return a << shift def lcm(a, b): Compute the Least Common Multiple. return abs(a * b) // gcd(a, b) def trailing_zero(x): Compute the number of trailing zeros in the binary representation of x. if x == 0: return 0 count = 0 while (x & 1) == 0: x >>= 1 count += 1 return count def gcd_lcm_trailing(a: int, b: int) -> dict: gcd_val = gcd(a, b) gcd_bit_val = gcd_bit(a, b) lcm_val = lcm(a, b) tz_gcd = trailing_zero(gcd_val) tz_gcd_bit = trailing_zero(gcd_bit_val) return { \\"gcd\\": gcd_val, \\"gcd_bit\\": gcd_bit_val, \\"lcm\\": lcm_val, \\"trailing_zeros_gcd\\": tz_gcd, \\"trailing_zeros_gcd_bit\\": tz_gcd_bit }"},{"question":"<|Analysis Begin|> # Algorithm Analysis Core Identification * **Algorithm/Data Structure**: Modified Binary Search in a Sorted 2D Matrix * **Type**: Search Algorithm * **Main Purpose**: To find a key in a 2D matrix where each row and column is sorted in non-decreasing order. Complexity * **Time Complexity**: O(m + n), where m is the number of rows and n is the number of columns. This is because, in the worst case, you might have to traverse the entire first row and the last column. * **Space Complexity**: O(1), as the algorithm uses a constant amount of extra space. Principles * **Core Operational Steps**: 1. Start from the bottom-left corner of the matrix. 2. If the current element matches the key, return its position. 3. If the current element is greater than the key, move one row up. 4. If the current element is less than the key, move one column to the right. 5. Repeat steps 2-4 until you either find the key or exhaust the matrix limits. Characteristics & Applications * **Properties**: Efficient search due to sorted nature of matrix\'s rows and columns. * **Common Use Cases**: Useful in scenarios where you need to efficiently search through large datasets sorted in two dimensions, such as table lookup systems or grid-based data structures in games. * **Strengths**: * Handles duplicates gracefully. * Predictable performance with O(m + n). * **Limitations**: * The matrix must be sorted in non-decreasing order both row-wise and column-wise. * Might not be the best choice for highly sparse matrices as more targeted search methods might outperform. Implementation Challenges * **Edge Cases**: * Empty matrix. * Key smaller than the smallest element or larger than the largest element. * Presence of duplicate elements. * **Performance Bottlenecks**: None significant under the given time complexity. * **Error Scenarios**: Failure to handle indices correctly can lead to out-of-bounds errors. * **Optimization Points**: Further optimization isn\'t typically needed due to the O(m + n) efficiency. <|Analysis End|> <|Question Begin|> # Problem Statement You are given a matrix where each row and each column is sorted in non-decreasing order. Implement a function `search_in_a_sorted_matrix` that searches for a given key in the matrix and returns its position if found, or a message indicating that the key is not present. # Detailed Requirements 1. **Function Signature**: ```python def search_in_a_sorted_matrix(mat: List[List[int]], m: int, n: int, key: int) -> Tuple[int, int]: ``` 2. **Input**: - `mat`: 2D list of integers (m x n matrix) where each row and column is sorted in non-decreasing order. - `m`: Integer representing the number of rows. - `n`: Integer representing the number of columns. - `key`: Integer value to search for in the matrix. 3. **Output**: - Returns a tuple (i, j) representing the row and column indices (1-based) of the key in the matrix if found. - If the key is not found, return `(-1, -1)` to indicate absence. 4. **Constraints**: - The matrix will have at most `1000` rows and columns. - Each element in the matrix will be an integer between `-10^9` and `10^9`. - Key will also be an integer between `-10^9` and `10^9`. 5. **Performance Requirement**: - The solution should run in O(m + n) time complexity. # Example Given the following matrix: ```python mat = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 ``` Output: ```python (2, 3) ``` Another example: Given the following matrix: ```python mat = [ [2, 5, 7], [4, 8, 10], [9, 11, 15], [12, 17, 20] ] key = 14 ``` Output: ```python (-1, -1) ``` # Note: - The function should handle cases where the key might be out of the matrix bounds or where the matrix is empty.","solution":"from typing import List, Tuple def search_in_a_sorted_matrix(mat: List[List[int]], m: int, n: int, key: int) -> Tuple[int, int]: Searches for the given key in a m x n matrix where each row and column is sorted in non-decreasing order. Returns (i, j) as 1-based index if key found, otherwise returns (-1, -1) # Start from the bottom-left corner row = m - 1 col = 0 while row >= 0 and col < n: if mat[row][col] == key: # +1 for 1-based index return (row + 1, col + 1) elif mat[row][col] > key: row -= 1 else: col += 1 return (-1, -1)"},{"question":"# Cocktail Shaker Sort Assessment Problem Statement You have been provided with an unsorted list of integers. Your task is to implement the Cocktail Shaker Sort algorithm to sort this list in ascending order. The Cocktail Shaker Sort is a variation of Bubble Sort that sorts the list in both directions on each pass through it, from left to right and then from right to left. Requirements 1. Implement the function `cocktail_shaker_sort(arr: List[int]) -> List[int]` that accepts a list of integers and returns the sorted list. 2. Ensure the function is implemented with in-place sorting. 3. Assume the input will always be a list of integers, though it might be empty or contain only one element. Function Signature ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: ``` Sample Input and Output # Example 1 * **Input:** `[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]` * **Output:** `[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]` # Example 2 * **Input:** `[6, 4, 2, 1]` * **Output:** `[1, 2, 4, 6]` # Example 3 * **Input:** `[]` * **Output:** `[]` Constraints * The list can contain up to (10^3) elements. * The values in the list will be integers in the range (-10^6) to (10^6). Instructions 1. Write the code for the `cocktail_shaker_sort` function. 2. Ensure to handle edge cases such as an empty list, a list with a single element, and lists with duplicate values correctly. 3. Optimize the function for early exits where no swaps are detected. Evaluation Criteria * **Correctness:** The function should correctly sort the list in ascending order. * **Efficiency:** The algorithm should be efficient with respect to the given time and space complexity constraints. * **Edge Cases Handling:** The function should handle all specified edge cases appropriately.","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: Sorts the list using the Cocktail Shaker Sort algorithm. if len(arr) <= 1: return arr n = len(arr) start = 0 end = n - 1 swapped = True while swapped: swapped = False # Traverse from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break swapped = False end -= 1 # Traverse from right to left for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True start += 1 return arr"},{"question":"Given two integers `n` and `r`, write a function named `efficient_combination` that computes the number of ways to choose `r` items from `n` items without repetition and irrespective of the order. To ensure efficient computation, your algorithm should leverage dynamic programming principles. # Implement the function: ```python def efficient_combination(n: int, r: int) -> int: # Your code here ``` # Input Format - Two integers `n` and `r` where (0 leq r leq n). # Output Format - Return a single integer representing `nCr`. # Constraints - (0 leq r leq n leq 1000) # Example ```python assert efficient_combination(5, 2) == 10 assert efficient_combination(10, 0) == 1 assert efficient_combination(10, 10) == 1 assert efficient_combination(6, 2) == 15 ``` # Requirements 1. **Efficiency**: You must ensure your implementation has a time complexity no worse than O(n * r). 2. **Space**: Total space usage should not exceed O(n * r). # Additional Information - Handle edge cases such as when r is 0 or equals n directly. - Consider both iterative and recursive approaches but ensure they are optimized using dynamic programming techniques.","solution":"def efficient_combination(n: int, r: int) -> int: Computes the number of ways to choose r items from n items without repetition and irrespective of the order. Efficient computation using dynamic programming. if r > n: return 0 if r == 0 or r == n: return 1 if r == 1: return n # Create a table to store intermediate results dp = [[0] * (r + 1) for _ in range(n + 1)] for i in range(n + 1): for j in range(min(i, r) + 1): if j == 0 or j == i: dp[i][j] = 1 else: dp[i][j] = dp[i-1][j-1] + dp[i-1][j] return dp[n][r]"},{"question":"# Context You are developing a simulation for a bank where customers line up for service. Your task is to implement a queue system to manage the sequence of customers. # Task Implement two classes `ArrayQueue` and `LinkedListQueue` as per the following specifications: Class: `ArrayQueue` - **Methods**: - `__init__(self, capacity=10)`: Initializes a queue with a given capacity. - `enqueue(self, value)`: Adds an element to the rear of the queue. - `dequeue(self)`: Removes and returns the element from the front of the queue. Raises `IndexError` if the queue is empty. - `peek(self)`: Returns the front element without removing it. Raises `IndexError` if the queue is empty. - `is_empty(self)`: Returns `True` if the queue is empty, otherwise `False`. - `__iter__(self)`: Iterates over the queue elements. Class: `LinkedListQueue` - **Methods**: - `__init__(self)`: Initializes an empty queue. - `enqueue(self, value)`: Adds an element to the rear of the queue. - `dequeue(self)`: Removes and returns the element from the front of the queue. Raises `IndexError` if the queue is empty. - `peek(self)`: Returns the front element without removing it. Raises `IndexError` if the queue is empty. - `is_empty(self)`: Returns `True` if the queue is empty, otherwise `False`. - `__iter__(self)`: Iterates over the queue elements. # Constraints - Operations will be within the bounds of typical usage scenarios (e.g., number of elements < 10^6). - Ensure edge cases such as dequeueing from an empty queue are correctly handled. # Input and Output Formats You are provided with no input as this is an implementation task. Ensure your classes implement the specified methods correctly. # Example ```python # ArrayQueue Example aq = ArrayQueue(2) aq.enqueue(1) aq.enqueue(2) print(aq.dequeue()) # Output: 1 print(aq.peek()) # Output: 2 # LinkedListQueue Example llq = LinkedListQueue() llq.enqueue(1) llq.enqueue(2) print(llq.dequeue()) # Output: 1 print(llq.peek()) # Output: 2 ```","solution":"class ArrayQueue: def __init__(self, capacity=10): self.capacity = capacity self.queue = [None] * capacity self.size = 0 self.front = 0 self.rear = -1 def enqueue(self, value): if self.size == self.capacity: raise OverflowError(\\"Queue is full\\") self.rear = (self.rear + 1) % self.capacity self.queue[self.rear] = value self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def is_empty(self): return self.size == 0 def __iter__(self): for i in range(self.size): yield self.queue[(self.front + i) % self.capacity] class LinkedListQueue: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self): self.front = None self.rear = None self.size = 0 def enqueue(self, value): new_node = self.Node(value) if self.is_empty(): self.front = self.rear = new_node else: self.rear.next = new_node self.rear = new_node self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self.front.value self.front = self.front.next if self.front is None: self.rear = None self.size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.front.value def is_empty(self): return self.size == 0 def __iter__(self): current = self.front while current: yield current.value current = current.next"},{"question":"# Context Merge Sort is a commonly used sorting technique that leverages the divide-and-conquer approach to sort arrays efficiently. Your task is to extend a merge sort implementation with a specific feature for handling a wider range of edge cases. # Task Implement a function `merge_sort_with_duplicates(arr: List[int]) -> List[int]` that performs merge sort on the input array and ensures the stability of sorting even with duplicate elements. # Input * `arr`: A list of integers. - (1 leq len(arr) leq 10^5) - ( -10^6 leq arr[i] leq 10^6 ) for any element ( arr[i] ) # Output * A list of integers sorted in non-decreasing order, maintaining the stability among duplicates. # Requirements * The solution must make use of the merge sort algorithm. * The function must handle arrays of varying lengths and containing duplicates efficiently. * Time complexity should be (O(n log(n))) and space complexity (O(n)). # Constraints * Do not use in-built sorting functions. * Perform stability checks to ensure equal elements retain their original relative order. * Minimize the recursion depth by utilizing iterative solutions if possible. # Example ```python # Example 1 arr = [4, 2, 5, 1, 5, 2] result = merge_sort_with_duplicates(arr) # Expected output: [1, 2, 2, 4, 5, 5] # Example 2 arr = [3, 3, 3, 3] result = merge_sort_with_duplicates(arr) # Expected output: [3, 3, 3, 3] ``` # Considerations * Ensure that your implementation handles typical edge cases such as empty arrays or arrays containing all identical elements. * Verify that the function maintains stable sorting through different test cases.","solution":"from typing import List def merge_sort_with_duplicates(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: sorted_arr = [] i = j = 0 # Merging two halves while maintaining stability while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_arr.append(left[i]) i += 1 else: sorted_arr.append(right[j]) j += 1 # If there are remaining elements in left or right, add them sorted_arr.extend(left[i:]) sorted_arr.extend(right[j:]) return sorted_arr def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) # Merge sorted halves return merge(left, right) return merge_sort(arr)"},{"question":"# RSA Encryption/Decryption Enhancement Task You are tasked with improving the key generation part of the RSA encryption algorithm and implementing an optimized function to generate large prime numbers using the Miller-Rabin primality test. Your goal is to enhance the prime number generation to reduce the time complexity while maintaining the integrity of the key generation process. Additionally, you need to implement the RSA encrypt and decrypt functions that use these generated keys. # Objectives: 1. Implement a function `miller_rabin_prime(k, seed=None)` to generate a k-bit prime number using the Miller-Rabin primality test. 2. Implement an enhanced version of `generate_key` using the `miller_rabin_prime` instead of the existing `gen_prime`. 3. Ensure the encryption and decryption processes are efficient and secure. # Function Specifications: **miller_rabin_prime(k, seed=None)** * Input: - `k` (int): Number of bits in the desired prime number. - `seed` (optional, int): Seed for the random number generator for reproducibility. * Output: - Return a k-bit prime number. **generate_key(k, seed=None)** * Input: - `k` (int): Number of bits in the modulus n. - `seed` (optional, int): Seed for the random number generator for reproducibility. * Output: - Return a tuple (n, e, d) where: - `n` (int): The modulus. - `e` (int): The public exponent. - `d` (int): The private exponent. **encrypt(data, e, n)** * Input: - `data` (int): The plaintext data to encrypt. - `e` (int): The public exponent. - `n` (int): The modulus. * Output: - Return the encrypted data as an integer. **decrypt(data, d, n)** * Input: - `data` (int): The encrypted data. - `d` (int): The private exponent. - `n` (int): The modulus. * Output: - Return the decrypted data as an integer. # Constraints: * `k >= 16`, and `k` will be a multiple of 4. * The `data` to encrypt will be a non-negative integer less than `n`. # Example: ```python n, e, d = generate_key(16) data = 42 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data ``` Use the following template to write your solution: ```python import random def miller_rabin_prime(k, seed=None): # Implement the Miller-Rabin primality test pass def generate_key(k, seed=None): # Implement key generation using miller_rabin_prime for prime generation pass def encrypt(data, e, n): return pow(int(data), int(e), int(n)) def decrypt(data, d, n): return pow(int(data), int(d), int(n)) # Test cases to validate the implementation n, e, d = generate_key(16) data = 42 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data ``` # Notes: - Your implementation should be efficient and correctly handle edge cases. - Thoroughly test your functions with different bit sizes and data values. - Ensure the prime number generation processes are optimized.","solution":"import random def miller_rabin_test(n, d): a = random.randint(2, n - 2) x = pow(a, d, n) if x == 1 or x == n - 1: return True while d != n - 1: x = (x * x) % n d *= 2 if x == 1: return False if x == n - 1: return True return False def is_prime(n, k=5): if n <= 1 or n == 4: return False if n <= 3: return True d = n - 1 while d % 2 == 0: d //= 2 for _ in range(k): if not miller_rabin_test(n, d): return False return True def generate_prime_candidate(k): p = random.getrandbits(k) p |= (1 << k - 1) | 1 return p def miller_rabin_prime(k, seed=None): if seed is not None: random.seed(seed) p = 4 while not is_prime(p, 128): p = generate_prime_candidate(k) return p def gcd(a, b): while b != 0: a, b = b, a % b return a def modinv(a, m): m0, y, x = m, 0, 1 if m == 1: return 0 while a > 1: q = a // m t = m m = a % m a = t t = y y = x - q * y x = t if x < 0: x += m0 return x def generate_key(k, seed=None): p = miller_rabin_prime(k//2, seed) q = miller_rabin_prime(k//2, seed + 1 if seed is not None else None) n = p * q phi = (p - 1) * (q - 1) e = 65537 if gcd(e, phi) != 1: for i in range(3, phi, 2): if gcd(i, phi) == 1: e = i break d = modinv(e, phi) return (n, e, d) def encrypt(data, e, n): return pow(data, e, n) def decrypt(data, d, n): return pow(data, d, n)"},{"question":"# Question: Implement an Improved Sorting Algorithm You have learned about the Exchange Sort algorithm, which is simple but inefficient for large datasets due to its O(n^2) time complexity. To improve performance, you will implement the Merge Sort algorithm, which has a better time complexity of O(n log n). Implement the following function: ```python def merge_sort(arr): Sorts an array in non-decreasing order using the Merge Sort algorithm. Parameters: arr (list): A list of comparable elements to be sorted. Returns: list: A sorted list containing all elements from the input list. pass ``` # Function Description * **Input**: A list of comparable elements, `arr`, where elements can be integers, floats, or any other types that can be compared using the `<` and `>` operators. * **Output**: A sorted list containing all elements from `arr` in non-decreasing order. # Constraints * The length of the list will be in the range `0 <= len(arr) <= 10^5`. * Each element of the list will lie in the range `-10^9 <= element <= 10^9`. # Example Input ```python arr = [4, 2, 7, 1, 3] ``` Output ```python [1, 2, 3, 4, 7] ``` # Notes * Your algorithm should efficiently handle large arrays, with the expectation of O(n log n) time complexity. * Ensure your solution works for all edge cases including empty arrays, arrays with a single element, and arrays with duplicate elements.","solution":"def merge_sort(arr): Sorts an array in non-decreasing order using the Merge Sort algorithm. Parameters: arr (list): A list of comparable elements to be sorted. Returns: list: A sorted list containing all elements from the input list. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left, right): sorted_array = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_array.append(left[i]) i += 1 else: sorted_array.append(right[j]) j += 1 sorted_array.extend(left[i:]) sorted_array.extend(right[j:]) return sorted_array"},{"question":"# Binary Tree Postorder Traversal Implementation You are tasked with implementing postorder traversal for a binary tree. The objective of this traversal is to process nodes of the binary tree in the following order: left subtree, right subtree, and the root node. You are required to write both an iterative and a recursive function that performs postorder traversal on a given binary tree. Function Definitions and Input Formats 1. **Iterative Function**: ```python def postorder_iterative(root: Node) -> List[int]: ``` 2. **Recursive Function**: ```python def postorder_recursive(root: Node) -> List[int]: ``` # Input * `root`: The root node of the binary tree. Each node is an instance of the provided `Node` class. # Output * A list containing the values of the nodes in postorder traversal order. Constraints * You may assume that the tree does not contain duplicate values. Performance Requirements * Both iterative and recursive solutions must run within O(n) time complexity, where n is the number of nodes in the binary tree. * Space complexity should be managed appropriately: O(n) for maintaining the result and for stack utilization. Example Given the binary tree: ``` 1 / 2 3 / 4 5 ``` Both functions should return the postorder traversal: `[4, 5, 2, 3, 1]`. Notes * Consider edge cases such as an empty tree or a tree with just one node. * Ensure your code handles deeply nested trees without causing stack overflow for the recursive solution.","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def postorder_iterative(root: Node): if not root: return [] stack, output = [root], [] while stack: node = stack.pop() output.append(node.value) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return output[::-1] def postorder_recursive(root: Node): result = [] def traverse(node): if not node: return traverse(node.left) traverse(node.right) result.append(node.value) traverse(root) return result"},{"question":"# Question Given a range `[low, high]`, write a Python function `find_digit_power_sum_numbers(low, high)` that returns a list of all numbers within that range where each number satisfies the property that it is equal to the sum of its digits each raised to the power of their respective positions. **Function Signature**: ```python def find_digit_power_sum_numbers(low: int, high: int) -> List[int]: ``` **Parameters**: 1. `low` (int): Lower bound of the range (inclusive). 2. `high` (int): Upper bound of the range (inclusive). **Returns**: * List[int]: A list of numbers within the given range that satisfy the stated property. **Constraints**: * `1 <= low <= high <= 10^6` * The function should efficiently handle large ranges. **Examples**: ```python assert find_digit_power_sum_numbers(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert find_digit_power_sum_numbers(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert find_digit_power_sum_numbers(50, 150) == [89, 135] ``` **Scenario**: You are working on a digit property-based puzzle and need to write a function that can quickly determine all numbers in a given range that satisfy the digit power sum condition. Ensure your function is optimized to handle large ranges efficiently. Good luck, and write clean, efficient code!","solution":"from typing import List def find_digit_power_sum_numbers(low: int, high: int) -> List[int]: result = [] def sum_of_digit_powers(n: int) -> int: return sum(int(digit)**(idx+1) for idx, digit in enumerate(str(n))) for number in range(low, high + 1): if number == sum_of_digit_powers(number): result.append(number) return result"},{"question":"# Hamming Weight Calculation with Brian Kernighan\'s Algorithm # Problem Statement: You are required to write a function that calculates the number of \'1\' bits (also known as the Hamming weight) in the binary representation of an unsigned integer using Brian Kernighan\'s Algorithm. This algorithm efficiently counts the number of set bits by iteratively clearing the lowest set bit. # Requirements: - Function Name: `count_ones` - Input Format: A single parameter, an unsigned integer `n`. - Output Format: An integer representing the number of \'1\' bits in the binary representation of `n`. - Constraints: - The input integer `n` will be in the range: `0 <= n <= 2^32 - 1`. # Examples: ```python count_ones(11) -> 3 # Explanation: 11 in binary is 00000000000000000000000000001011, which has three \'1\' bits. count_ones(128) -> 1 # Explanation: 128 in binary is 00000000000000000000000010000000, which has one \'1\' bit. count_ones(255) -> 8 # Explanation: 255 in binary is 00000000000000000000000011111111, which has eight \'1\' bits. count_ones(0) -> 0 # Explanation: 0 in binary is 00000000000000000000000000000000, which has zero \'1\' bits. ``` # Function Signature: ```python def count_ones(n: int) -> int: pass ``` # Performance Requirements: - Your solution should have a time complexity of `O(k)` where `k` is the number of \'1\' bits in the binary representation of `n`. - The space complexity should be `O(1)`.","solution":"def count_ones(n: int) -> int: Calculate the number of \'1\' bits (Hamming weight) in the binary representation of an unsigned integer n using Brian Kernighan\'s Algorithm. count = 0 while n: n &= n - 1 # Drop the lowest set bit count += 1 return count"},{"question":"# Next Higher Permutation Finder You need to write a function called `next_higher_permutation(num: int) -> int` that finds the next higher number which has the exact same set of digits as the given input number. If no such higher permutation exists, return -1. Function Signature ```python def next_higher_permutation(num: int) -> int: ``` Input * `num` - an integer (0 <= num <= 10^9) Output * Return the next higher number with the same set of digits as the input number, or -1 if no such number exists. Constraints * You should handle leading zeroes correctly; however, the input will not contain negatives. * Performance should be efficient given the constraints. Example ```python assert next_higher_permutation(38276) == 38627 assert next_higher_permutation(99999) == -1 assert next_higher_permutation(12345) == 12354 assert next_higher_permutation(5) == -1 ``` Description 1. Start by converting the number into a list of its digits. 2. Traverse the list from the right to find the first instance where a digit is smaller than the digit to its right. 3. Identify the smallest digit to the right of this number which is larger than it, and swap these two numbers. 4. Reverse the sequence of digits to the right of the original point of change to get the smallest permutation higher than the input number. Edge Cases Consider edge cases such as: * Single-digit numbers. * Numbers already in descending order. * Numbers with repeated digits.","solution":"def next_higher_permutation(num: int) -> int: Function to find the next higher permutation of the given number. If no such permutation exists, return -1. # Convert the number to a list of digits digits = list(str(num)) n = len(digits) # Find the largest index i such that digits[i] < digits[i + 1] i = n - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 # If no such index exists, the digits are in descending order if i == -1: return -1 # Find the largest index j > i such that digits[i] < digits[j] j = n - 1 while digits[j] <= digits[i]: j -= 1 # Swap the value of digits[i] with that of digits[j] digits[i], digits[j] = digits[j], digits[i] # Reverse the sequence from i + 1 to end digits = digits[:i + 1] + digits[i + 1:][::-1] # Convert the list of digits back to an integer next_permutation = int(\'\'.join(digits)) return next_permutation"},{"question":"Scenario A software developer is designing an application to generate financial plans based on combinations of possible investments. Each investment can be chosen multiple times, and the objective is to reach a target investment amount using given investment options. Task You are required to implement a function that generates all possible unique combinations of a given list of investments (candidate numbers) that sum up to a target investment amount. Each number in the investment options can be chosen multiple times. Function Signature ```python def generate_investment_combinations(investments: List[int], target: int) -> List[List[int]]: pass ``` Input - `investments`: A list of positive integers representing different investment options. (1 ≤ len(investments) ≤ 30) - `target`: A positive integer representing the desired investment amount. (1 ≤ target ≤ 500) Output - A list of lists, where each list contains a combination of investments that sum up to the target amount. Each combination should be unique and not repeated. Constraints 1. Each investment option and the target investment amount are positive integers. 2. The function should not generate duplicate combinations. 3. Each investment option in the combination list should be in non-descending order. Example ```python # Example 1 investments = [2, 3, 6, 7] target = 7 # Expected output # [ # [2, 2, 3], # [7] # ] # Example 2 investments = [2, 3, 5] target = 8 # Expected output # [ # [2, 2, 2, 2], # [2, 3, 3], # [3, 5] # ] ``` Performance Requirements - Aim to keep the recursive depth manageable and avoid excessive memory usage. - Ensure that the solution efficiently handles edge cases and large targets. # Notes You should thoroughly test your implementation with different sets of inputs to verify correctness and efficiency.","solution":"from typing import List def generate_investment_combinations(investments: List[int], target: int) -> List[List[int]]: def backtrack(remain, comb, start): if remain == 0: result.append(list(comb)) return elif remain < 0: return for i in range(start, len(investments)): comb.append(investments[i]) backtrack(remain - investments[i], comb, i) comb.pop() result = [] investments.sort() backtrack(target, [], 0) return result"},{"question":"You are given a binary tree. Write a function `min_depth(root)` to compute the minimum depth of the binary tree and a function `print_tree(root)` to print the values of the nodes in the tree using pre-order traversal. # Specifications: 1. **Function Name**: `min_depth` * **Input**: - `root` (TreeNode) - The root of the binary tree. * **Output**: - `int` - The minimum depth of the tree. 2. **Function Name**: `print_tree` * **Input**: - `root` (TreeNode) - The root of the binary tree. * **Output**: - Prints the values of the nodes in pre-order traversal. # Constraints: - Nodes in the tree will have unique integer values. - The number of nodes in the tree will be in the range [0, 10^4]. # Examples: 1. **Example 1:** ``` Input: root = [1, 2, 3, None, None, 4, 5] Representation: 1 / 2 3 / 4 5 Output: min_depth: 2 print_tree: 1 2 3 4 5 ``` 2. **Example 2:** ``` Input: root = [2, None, 3, 4, None, None, 5] Representation: 2 3 / 4 5 Output: min_depth: 3 print_tree: 2 3 4 5 ``` # Remarks: - Consider handling edge cases such as an empty tree (should return depth of 0 and print nothing). - Aim for an efficient solution with well-considered time and space complexities. # Structs and Classes: Define a `TreeNode` class if not already defined: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` This will be used as the structure of each node in the binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_depth(root): Calculates the minimum depth of a binary tree. if not root: return 0 children = [root.left, root.right] # if we\'re at leaf node if not any(children): return 1 min_depth_val = float(\'inf\') for c in children: if c: min_depth_val = min(min_depth_val, min_depth(c)) return min_depth_val + 1 def print_tree(root): Prints the values of the nodes in the tree using pre-order traversal. if not root: return print(root.val, end=\' \') print_tree(root.left) print_tree(root.right)"},{"question":"# Graph Traversal Challenge Description: Graph traversal is a fundamental concept in computer science, involving the visiting of all nodes in a graph. In this exercise, you\'ll implement both Depth First Search (DFS) and Breadth First Search (BFS) algorithms to build upon your understanding of these strategies. Task: Implement two graph traversal functions: `dfs_paths` and `bfs_paths`. Both functions should identify all possible paths from a given start node to a target node in an undirected graph. * `dfs_paths(graph, start, goal)`: This function should find and return all paths from the `start` node to the `goal` node using DFS. * `bfs_paths(graph, start, goal)`: This function should find and return all paths from the `start` node to the `goal` node using BFS. # Function Signature: ```python def dfs_paths(graph: Dict[int, List[int]], start: int, goal: int) -> List[List[int]]: pass def bfs_paths(graph: Dict[int, List[int]], start: int, goal: int) -> List[List[int]]: pass ``` # Input: - `graph`: A dictionary where keys are node identifiers and values are lists of adjacent nodes. - `start`: The starting node for path search. - `goal`: The target node for path search. # Output: - A list of paths (each path is represented as a list of nodes from start to goal). # Constraints: - All nodes will be integers. - There can be multiple or no paths between the start and goal nodes. - Ensure paths are returned in the correct order respective to the DFS and BFS strategies. # Example: ```python graph = { 1: [2, 3], 2: [1, 4], 3: [1, 4], 4: [2, 3, 5], 5: [4] } start = 1 goal = 5 # Possible outputs - Note: Order of paths may vary with the algorithm print(dfs_paths(graph, start, goal)) # Example Output: [[1, 2, 4, 5], [1, 3, 4, 5]] print(bfs_paths(graph, start, goal)) # Example Output: [[1, 2, 4, 5], [1, 3, 4, 5]] ``` Implement these functions considering edge cases, performance factors, and accurate path tracking.","solution":"from typing import List, Dict def dfs_paths(graph: Dict[int, List[int]], start: int, goal: int) -> List[List[int]]: Perform a Depth First Search (DFS) to find all paths from start node to goal node. def dfs(node, goal, path, visited): if node == goal: paths.append(path.copy()) return for neighbor in graph.get(node, []): if neighbor not in visited: visited.add(neighbor) path.append(neighbor) dfs(neighbor, goal, path, visited) path.pop() visited.remove(neighbor) paths = [] dfs(start, goal, [start], {start}) return paths def bfs_paths(graph: Dict[int, List[int]], start: int, goal: int) -> List[List[int]]: Perform a Breadth First Search (BFS) to find all paths from start node to goal node. from collections import deque queue = deque([(start, [start])]) paths = [] while queue: node, path = queue.popleft() if node == goal: paths.append(path) for neighbor in graph.get(node, []): if neighbor not in path: queue.append((neighbor, path + [neighbor])) return paths"},{"question":"# Binary Search Tree and Range Query You need to augment the binary search tree (BST) class to support an additional method called `range_query`. This function should take two integer arguments, `low` and `high`, and return a list of all node values within the range [low, high] (inclusive), in ascending order. # Requirements: 1. Implement the `range_query` method in the provided `BST` class. 2. The function should perform efficiently utilizing the properties of the BST. 3. Ensure to handle edge cases such as: * Empty tree. * No values within the specified range. # Function Signature: ```python def range_query(self, low: int, high: int) -> List[int]: # Your code here ``` # Expected Input/Output Formats: * **Input 1**: Range Query on a given BST with `low = 5`, `high = 15` * **Output 1**: A list of node values within the range, e.g., `[6, 7, 9, 10, 12, 15]` * **Input 2**: Range Query on an empty tree with `low = 0`, `high = 10` * **Output 2**: An empty list, e.g., `[]` # Constraints: * Time Complexity should ideally be O(k + log N) where k is the number of elements in the range [low, high] and N is the number of nodes in the BST. * Space Complexity should be O(k). # Code Template: ```python class BST(object): # Existing methods as provided (insert, search, size, traversals) def range_query(self, low: int, high: int) -> List[int]: # Your code here ``` # Unit Tests: Create several unit tests to ensure the functionality of your code. Here are examples: ```python import unittest class TestRangeQuery(unittest.TestCase): def setUp(self): self.tree = BST() self.tree.insert(10) self.tree.insert(15) self.tree.insert(6) self.tree.insert(4) self.tree.insert(9) self.tree.insert(12) self.tree.insert(24) self.tree.insert(7) self.tree.insert(20) self.tree.insert(30) self.tree.insert(18) def test_range_query(self): self.assertEqual(self.tree.range_query(5, 15), [6, 7, 9, 10, 12, 15]) self.assertEqual(self.tree.range_query(18, 24), [18, 20, 24]) self.assertEqual(self.tree.range_query(0, 50), [4, 6, 7, 9, 10, 12, 15, 18, 20, 24, 30]) self.assertEqual(self.tree.range_query(16, 17), []) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.key: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def range_query(self, low: int, high: int): def _range_query(node, low, high, result): if node is None: return if low < node.key: _range_query(node.left, low, high, result) if low <= node.key <= high: result.append(node.key) if high > node.key: _range_query(node.right, low, high, result) result = [] _range_query(self.root, low, high, result) return result"},{"question":"# Scenario Imagine you are designing an e-commerce website where users can combine different discount coupons to reach a specific target discount value. You need to develop a function that will count all possible combinations of given coupon values that sum up to the target discount amount. Note that the different sequences of the same values count as different combinations. # Task Given an array of positive integers representing coupon values and a target integer, write a function `coupon_combinations(nums, target)` to find the number of possible combinations that add up to the target discount. # Input and Output * **Input**: * `nums`: a list of positive integers without duplicates, where `1 <= nums.length <= 200` and `1 <= nums[i] <= 1000` * `target`: an integer `0 <= target <= 1000` * **Output**: * An integer representing the number of different combinations that add up to the target discount. # Constraints * Use either top-down or bottom-up dynamic programming approach to solve the problem. * Your function should handle all edge cases effectively. # Example ```python # Example 1: nums = [1, 2, 3] target = 4 # Output: 7 # Example 2: nums = [2, 3, 6, 7] target = 7 # Output: 4 # Example 3: nums = [2, 5] target = 3 # Output: 0 ``` # Code Template ```python def coupon_combinations(nums, target): # Your implementation here pass # Example usage print(coupon_combinations([1, 2, 3], 4)) # Output should be 7 print(coupon_combinations([2, 3, 6, 7], 7)) # Output should be 4 print(coupon_combinations([2, 5], 3)) # Output should be 0 ``` # Follow-up * If negative numbers were allowed in the given array, discuss how it would change the problem and what limitations should be added to handle such scenarios.","solution":"def coupon_combinations(nums, target): This function returns the number of possible combinations of given coupon values that sum up to the target discount. dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for num in nums: if i - num >= 0: dp[i] += dp[i - num] return dp[target] # Example usage print(coupon_combinations([1, 2, 3], 4)) # Output should be 7 print(coupon_combinations([2, 3, 6, 7], 7)) # Output should be 4 print(coupon_combinations([2, 5], 3)) # Output should be 0"},{"question":"You are tasked with implementing a Min Heap data structure. This heap will allow you to insert elements and remove the minimum element efficiently while maintaining the heap property. Implement the following methods: 1. **`insert(val: int) -> None`**: - Inserts a value into the heap and maintains the min heap property. 2. **`remove_min() -> int`**: - Removes the minimum element from the heap and returns it, while maintaining the min heap property. # Example ```python heap = BinaryHeap() heap.insert(10) heap.insert(5) heap.insert(30) heap.insert(1) print(heap.remove_min()) # Output: 1 print(heap.remove_min()) # Output: 5 ``` # Constraints * You may assume all input values are integers. * You should handle inserting into an initially empty heap. * You should handle edge cases where operations like `remove_min()` are called on an empty heap by raising an appropriate exception, such as `IndexError`. Notes - Each of the core operations should have a time complexity of O(log N). - Your implementation should follow the described properties and principles of a min heap.","solution":"class BinaryHeap: def __init__(self): self.heap = [] def insert(self, val): Inserts a value into the heap and maintains the min heap property. self.heap.append(val) self._bubble_up(len(self.heap) - 1) def remove_min(self): Removes the minimum element from the heap and returns it, while maintaining the min heap property. if not self.heap: raise IndexError(\'remove_min() called on empty heap\') self._swap(0, len(self.heap) - 1) min_element = self.heap.pop() self._bubble_down(0) return min_element def _bubble_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self._swap(index, parent_index) self._bubble_up(parent_index) def _bubble_down(self, index): child_index_1 = 2 * index + 1 child_index_2 = 2 * index + 2 smallest = index if child_index_1 < len(self.heap) and self.heap[child_index_1] < self.heap[smallest]: smallest = child_index_1 if child_index_2 < len(self.heap) and self.heap[child_index_2] < self.heap[smallest]: smallest = child_index_2 if smallest != index: self._swap(index, smallest) self._bubble_down(smallest) def _swap(self, i, j): self.heap[i], self.heap[j] = self.heap[j], self.heap[i]"},{"question":"# Mode-Finding with Constraints Problem Statement You are given an array of integers. Your task is to write a function that finds the most frequently occurring value(s) in the array. If multiple values have the same highest frequency, return all of them in a list. Ensure your function handles edge cases gracefully and operates efficiently. Function Signature ```python def find_modes(array: List[int]) -> List[int]: pass ``` Input - `array` (List[int]): A list of integers which can contain both positive and negative numbers. Length of the array: `0 <= len(array) <= 10^6`. Output - Returns a list containing the most frequent element(s) in the array. The elements in the output list can be in any order. Constraints - Your solution should have a time complexity of O(n). - Handle edge cases such as empty arrays and arrays with all unique elements. Example ```python assert find_modes([1, 1, 2, 2, 3, 4]) == [1, 2] assert find_modes([4, 4, 4, 3, 3, 1]) == [4] assert find_modes([]) == [] assert find_modes([1]) == [1] assert find_modes([5, 5, 5, 5]) == [5] ``` Explanation - In the first example, both 1 and 2 appear twice, hence the result is [1, 2]. - In the second example, 4 appears three times which is more frequent than any other number. - In the third example, an empty array should return an empty list. - In the fourth example, an array with a single element should return that single element. - In the fifth example, all elements are the same and hence the result is that element. Begin with designing your function considering the various edge cases and trying to maintain optimal time and space complexities.","solution":"from typing import List from collections import Counter def find_modes(array: List[int]) -> List[int]: if not array: # Handle the edge case of an empty array return [] counter = Counter(array) max_frequency = max(counter.values()) return [num for num, freq in counter.items() if freq == max_frequency]"},{"question":"# Matrix Transformations Problem Context: You are working on an image processing application that needs to perform various transformations on images represented as 2D matrices. To achieve this, you need to implement functions that can rotate the matrix clockwise and counterclockwise, invert it from the top-left and bottom-left corners. Task: Write Python functions to perform the following transformations on a given 2D matrix: 1. `rotate_clockwise(matrix)` 2. `rotate_counterclockwise(matrix)` 3. `top_left_invert(matrix)` 4. `bottom_left_invert(matrix)` Each function should take a 2D list `matrix` as input and return a new 2D list that is transformed as per the required transformation. Input and Output Formats: - Input: A 2D list `matrix` with dimensions `m x n`. - Output: A new 2D list of dimensions `m x n` that has been transformed. # Constraints: - The matrix can be non-square (i.e., m and n can be different). - The matrix will not be empty. # Performance Requirements: - The functions should run within O(n^2) time complexity. - They should use O(n^2) space to store the transformed matrix. # Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] rotate_clockwise(matrix) # Output: [[7, 4, 1], [8, 5, 2], [9, 3, 0]] rotate_counterclockwise(matrix) # Output: [[3, 6, 9], [2, 5, 8], [1, 4, 7]] top_left_invert(matrix) # Output: [[1, 2, 3], [4, 5, 6], [7, 8, 9]] bottom_left_invert(matrix) # Output: [[9, 8, 7], [6, 5, 4], [3, 2, 1]] ``` # Requirements: 1. Implementations should avoid using any additional imported libraries. 2. Ensure that common edge cases such as single row/column or non-square matrices are handled gracefully.","solution":"def rotate_clockwise(matrix): Rotates the given matrix 90 degrees clockwise. return [list(row) for row in zip(*matrix[::-1])] def rotate_counterclockwise(matrix): Rotates the given matrix 90 degrees counterclockwise. return [list(row) for row in zip(*matrix)][::-1] def top_left_invert(matrix): Inverts the given matrix from the top-left corner. return [row[::-1] for row in matrix[::-1]] def bottom_left_invert(matrix): Inverts the given matrix from the bottom-left corner. return [row[::-1] for row in matrix]"},{"question":"# Insertion Sort Enhanced Problem Statement You are given a list of integers. Write a function `enhanced_insertion_sort` that sorts the list in non-decreasing order using the insertion sort algorithm. The function should also optimize for the following scenario: 1. **Early Exit Optimization**: If the list becomes sorted before the end of the algorithm, your function should detect this and return early to save unnecessary comparisons. Input: * `arr` (List[int]): A list of integers that needs to be sorted. Output: * The function should return the sorted list (List[int]). Constraints: * The length of the list `n` will be `0 <= n <= 10^4`. * The list elements are within the range `-10^6 <= element <= 10^6`. Requirements: * Your implementation must optimize for early termination if no swaps are made on a complete pass through the list. Example: ```python def enhanced_insertion_sort(arr): # Your implementation here pass # Example Usage: print(enhanced_insertion_sort([4, 3, 2, 1])) # Output: [1, 2, 3, 4] print(enhanced_insertion_sort([1, 2, 3, 4])) # Output: [1, 2, 3, 4] (Expected to return early) print(enhanced_insertion_sort([])) # Output: [] print(enhanced_insertion_sort([4, 3, 2, 4, 1])) # Output: [1, 2, 3, 4, 4] ``` Hint: Consider adding a flag to monitor if any swap has been made during each pass. If no swaps are made, the list is already sorted and you can exit early.","solution":"def enhanced_insertion_sort(arr): Sorts a list of integers in non-decreasing order using an optimized insertion sort algorithm that terminates early if the list becomes sorted. Parameters: arr (List[int]): A list of integers that needs to be sorted. Returns: List[int]: The sorted list of integers. for i in range(1, len(arr)): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater than key, to one position ahead of their current position while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key # Early exit check: If no changes were made during the entire iteration if arr == sorted(arr): break return arr"},{"question":"# Optimal Travel Planning In this problem, you are tasked with helping a group of students plan their visits to different cities during their study break. Each city offers a certain experience value and requires a specific number of travel days. The goal is to maximize the total experience value within the limited number of travel days available. You are provided with a list of cities, each characterized by its experience value and the number of days required to visit it. You must determine the maximum experience value that can be achieved without exceeding the available travel days. Write a function `maximum_experience_value` that takes a list of `City` objects and an integer `total_days` representing the total number of travel days available, and returns the maximum experience value achievable. # Function Signature ```python def maximum_experience_value(cities: List[City], total_days: int) -> int: ``` # Input - `cities` (List[City]): A list of `City` objects, where each `City` has two attributes: - `experience` (int): The experience value of the city. - `days` (int): The number of travel days required to visit the city. - `total_days` (int): An integer representing the total number of travel days available. # Output - Returns an integer representing the maximum experience value achievable within the given days. # Constraints - The `City` class is defined as follows: ```python class City: def __init__(self, experience: int, days: int): self.experience = experience self.days = days ``` - The number of cities `n` is such that 0 <= n <= 100. - Each `City` object has 1 <= experience <= 100 and 1 <= days <= 100. - `total_days` is an integer such that 0 <= total_days <= 1000. # Example ```python class City: def __init__(self, experience, days): self.experience = experience self.days = days cities = [City(50, 3), City(70, 4), City(40, 2), City(60, 5)] total_days = 5 print(maximum_experience_value(cities, total_days)) # Output: 90 ``` In this example, to get the maximum experience value of 90, the students would visit cities with experience values 50 and 40 within the available 5 travel days.","solution":"from typing import List class City: def __init__(self, experience: int, days: int): self.experience = experience self.days = days def maximum_experience_value(cities: List[City], total_days: int) -> int: n = len(cities) # Create a DP table with (n+1) rows and (total_days+1) columns dp = [[0] * (total_days + 1) for _ in range(n + 1)] # Populate the DP table for i in range(1, n + 1): for j in range(total_days + 1): if cities[i-1].days <= j: dp[i][j] = max(dp[i-1][j], dp[i-1][j - cities[i-1].days] + cities[i-1].experience) else: dp[i][j] = dp[i-1][j] return dp[n][total_days]"},{"question":"You are working on a file management application that requires standardizing various types of file paths entered by the users to their absolute forms. Implement a function in Python that takes a list of relative and user-home-prefixed file paths and returns a list of their absolute file paths. # Input: - A list of strings, where each string represents a file path. The file paths may be relative, absolute, or starting with a user\'s home directory indicated by `~`. # Output: - A list of strings, where each string is the absolute path corresponding to each input path. # Constraints: - The input list will contain at least one file path and at most 1000 file paths. - Each file path string will have a maximum length of 300 characters. - The function should handle invalid file paths gracefully, returning an empty string for any invalid path. # Example: ```python file_paths = [\\"~/documents/report.txt\\", \\"./data/input.csv\\", \\"/var/log/syslog\\"] print(resolve_file_paths(file_paths)) # Output might be: # [\\"/home/user/documents/report.txt\\", \\"/home/user/current_directory/data/input.csv\\", \\"/var/log/syslog\\"] ``` # Function Signature: ```python def resolve_file_paths(file_paths: list) -> list: pass ``` # Guidelines: - Use Python\'s `os` module to handle path conversions. - Ensure the function can run efficiently even for the maximum input size. - Include error handling for invalid paths, returning an empty string for such cases.","solution":"import os def resolve_file_paths(file_paths): Given a list of file paths, return the list of their absolute paths. If a path is invalid, return an empty string for that path. absolute_paths = [] for path in file_paths: try: absolute_path = os.path.abspath(os.path.expanduser(path)) absolute_paths.append(absolute_path) except Exception: absolute_paths.append(\\"\\") return absolute_paths"},{"question":"# **Graph Connectivity Analysis Using DFS** **Scenario**: You are working as a network analyst responsible for analyzing the connectivity of networks represented as undirected graphs. An undirected graph is passed to you in the form of an adjacency list, and you need to determine the number of connected components in the graph using Depth-First Search (DFS). **Task**: Implement the function `count_components(adjacency_list: List[List[int]], size: int) -> int` that counts the number of connected components in an undirected graph. **Function Signature**: ```python def count_components(adjacency_list: List[List[int]], size: int) -> int: ``` **Input**: * `adjacency_list`: A list of lists of integers where the outer list represents the graph nodes and each inner list contains the nodes connected to the node represented by the outer list index. * `size`: An integer representing the total number of nodes in the graph. **Output**: * An integer representing the number of connected components in the given graph. **Constraints**: * `1 <= size <= 1000` * The graph may contain at most `10^4` edges. * Graph nodes are indexed from 1 through `size`. **Example**: ```text Input: adjacency_list = [[], [2], [1, 4], [4, 5], [2, 3], [3]] size = 5 Output: 1 Input: adjacency_list = [[], [2], [1], [4, 5], [3], [3]] size = 5 Output: 2 ``` **Explanation**: - In the first example, all nodes are connected, forming a single connected component. - In the second example, there are two distinct sets of connected components: {1, 2} and {3, 4, 5}. **Requirements**: - Handle different forms of input and ensure accurate component counting. - Optimize for performance, considering the highest constraints. **Good Luck!**","solution":"from typing import List def count_components(adjacency_list: List[List[int]], size: int) -> int: visited = [False] * (size + 1) # To keep track of visited nodes def dfs(node: int): stack = [node] while stack: current = stack.pop() if not visited[current]: visited[current] = True for neighbor in adjacency_list[current]: if not visited[neighbor]: stack.append(neighbor) count = 0 for node in range(1, size + 1): if not visited[node]: dfs(node) count += 1 return count"},{"question":"Binary Tree Preorder Traversal # Problem Description Preorder traversal of a binary tree means visiting nodes in the following order: root, left, and right. You are given a binary tree implementation. Your task is to implement a function that conducts a preorder traversal of the binary tree. # Objectives 1. Implement both recursive and iterative approaches for binary tree preorder traversal. 2. Ensure your implementation handles edge cases effectively. # Function Signatures - **preorder(root: Node) -> List[int]**: This function should perform an iterative preorder traversal. - **preorder_rec(root: Node, res=None) -> List[int]**: This function should perform a recursive preorder traversal. # Input Format 1. **root**: A `Node` object that represents the root of the binary tree. - `Node` class contains `val`, `left`, and `right`. # Output Format - Return a list of integers representing the node values in preorder traversal order for both functions. # Constraints 1. The number of nodes in the tree is in the range [0, 10^4]. 2. The value of each node is a unique integer. # Example Given the tree below: ``` 1 / 2 3 / 4 5 ``` - Preorder traversal should return: [1, 2, 4, 5, 3] # Notes - If the tree is empty, return an empty list. - The iterative approach should utilize a stack for traversal. - Validate your function to handle edge scenarios, such as empty trees or trees with only one node, effectively.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def preorder(root): Perform the iterative preorder traversal of the binary tree. if root is None: return [] stack = [root] result = [] while stack: node = stack.pop() result.append(node.val) # Push right first so that left is processed first if node.right: stack.append(node.right) if node.left: stack.append(node.left) return result def preorder_rec(root, res=None): Perform the recursive preorder traversal of the binary tree. if res is None: res = [] if root is None: return res res.append(root.val) preorder_rec(root.left, res) preorder_rec(root.right, res) return res"},{"question":"# Rabin-Karp Algorithm Question Context: Rabin-Karp is an efficient and widely used algorithm for pattern searching in strings. Your task is to implement the Rabin-Karp algorithm to find the starting index of a given pattern within a larger text. Task: Write a function `find_pattern_in_text(pattern, text)` that implements the Rabin-Karp algorithm. The function should return the starting index of the first occurrence of the pattern in the text or `None` if the pattern is not found: Input: - `pattern`: A string representing the pattern to be searched. - `text`: A string representing the text in which the pattern is searched. Output: - Return an integer representing the starting index of the pattern in the text. - Return `None` if the pattern is not found. Constraints: - The pattern and text will only contain lowercase alphabetic characters. - The length of the pattern will be at most 100. - The length of the text will be at most 10,000. Requirements: The implementation should efficiently calculate the hash values and handle the rolling hash update for the text windows. Example: ```python def find_pattern_in_text(pattern, text): # Your implementation here pass # Example Test Cases print(find_pattern_in_text(\\"abc\\", \\"abcabcabc\\")) # Output: 0 print(find_pattern_in_text(\\"def\\", \\"abcabcabc\\")) # Output: None print(find_pattern_in_text(\\"aab\\", \\"aaab\\")) # Output: 1 ``` Implement the function considering various edge cases and performance optimizations as discussed.","solution":"def find_pattern_in_text(pattern, text): Implements the Rabin-Karp algorithm to find the starting index of the first occurrence of the pattern in the text. Returns None if the pattern is not found. if not pattern or not text or len(pattern) > len(text): return None d = 256 # number of characters in the input alphabet q = 101 # A prime number for modulus operation M = len(pattern) N = len(text) p = 0 # hash value for pattern t = 0 # hash value for text h = 1 # The value of h would be \\"pow(d, M-1) % q\\" for _ in range(M-1): h = (h * d) % q # Calculate the hash value of pattern and first window of text for i in range(M): p = (d * p + ord(pattern[i])) % q t = (d * t + ord(text[i])) % q # Slide the pattern over text one by one for i in range(N - M + 1): # Check the hash values of current window of text and pattern. # If the hash values match then only check for characters one by one if p == t: # Check for characters one by one for j in range(M): if text[i + j] != pattern[j]: break else: return i # if p == t and the characters match # Calculate hash value for the next window of text: # Remove leading digit, add trailing digit if i < N - M: t = (d * (t - ord(text[i]) * h) + ord(text[i + M])) % q # We might get negative value of t, converting it to positive if t < 0: t = t + q return None"},{"question":"**Problem Statement**: You are tasked with implementing a sorting function using an enhanced version of Bubble Sort. However, the requirement is to improve the original algorithm to identify and handle specific edge cases, and also optimize it to handle cases where the list is already sorted more efficiently. **Function Description**: Write a function `enhanced_bubble_sort(arr: List[int], simulation: bool = False) -> List[int]` that performs the sorting operation as follows: 1. The function takes two parameters: - `arr`: A list of integers to be sorted. - `simulation`: A Boolean flag to indicate whether to print the intermediate steps of the sorting process (default is `False`). 2. The function will: - Handle an empty list or a single element list and return it as is. - Improve the algorithm to achieve O(N) time complexity in the best case (already sorted list). - Print the list after each swap if `simulation` is set to `True`. 3. Return the sorted list. **Input Format**: - A list of integers, `arr`. - A boolean flag, `simulation`. **Output Format**: - Return the sorted list of integers. **Constraints**: - The length of the list should be between 0 and 10^3. - Each integer in the list will be between -10^5 and 10^5. **Performance Requirements**: - Your function should have a best-case time complexity of O(N). **Scenario**: Imagine that you are an instructor grading programming assignments. One of the assignments requires students to implement the enhanced bubble sort. Provide feedback on whether their implementation correctly handles the specified edge cases and meets the performance requirement.","solution":"from typing import List def enhanced_bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts the list using an enhanced bubble sort algorithm that is optimized for already sorted lists. Parameters: arr (List[int]): A list of integers to be sorted. simulation (bool): A flag to indicate whether to print the intermediate steps (default is False). Returns: List[int]: The sorted list of integers. n = len(arr) if n < 2: return arr for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if simulation: print(f\\"Swapped {arr[j]} and {arr[j+1]}: {arr}\\") if not swapped: break return arr"},{"question":"# Linear Search Enhancement: First and Last Position Search **Context**: You are enhancing the linear search algorithm to not only find the first occurrence of a search term but also to determine the last occurrence of the same term in a list. This is useful in situations where you need to pinpoint the range of indices at which an element appears. **Task**: Write a function `search_first_and_last_occurrence` that takes an array and a query element as input and returns a tuple containing the indices of the first and last occurrence of the query element. **Function Signature**: ```python def search_first_and_last_occurrence(array: list, query: any) -> tuple: pass ``` **Input**: * `array`: A list of elements (can contain any data type). * `query`: The element you are searching for within the array. **Output**: * A tuple of two integers. The first integer represents the index of the first occurrence of the query element, and the second integer represents the index of the last occurrence. If the element is not found, return `(-1, -1)`. **Constraints**: * The length of the array will be between 0 and 10^4. **Example**: ```python assert search_first_and_last_occurrence([1, 2, 2, 2, 3, 4, 2], 2) == (1, 6) assert search_first_and_last_occurrence([4, 5, 6, 7, 8, 4, 5], 5) == (1, 6) assert search_first_and_last_occurrence([1, 3, 5, 7], 2) == (-1, -1) assert search_first_and_last_occurrence([], 3) == (-1, -1) ``` **Performance Requirement**: * Your solution should run in O(n) time complexity. **Edge Cases to Consider**: * An empty array should return `(-1, -1)`. * An array with no occurrence of the query should return `(-1, -1)`. * If the query appears only once, the result should have the same index for both first and last occurrence.","solution":"def search_first_and_last_occurrence(array, query): Returns a tuple containing the indices of the first and last occurrence of the query element in the array. If the element is not found, returns (-1, -1). first_occurrence = -1 last_occurrence = -1 for i in range(len(array)): if array[i] == query: if first_occurrence == -1: first_occurrence = i last_occurrence = i return (first_occurrence, last_occurrence)"},{"question":"# Sorting Life Expectancy Data In a scientific study, you are given a dataset containing the life expectancies of various species of animals. You are required to sort this list to analyze patterns related to lifespan. Given the constraints of the study, you know that the life expectancies fall within a certain range, say 1 year to 100 years. You decide to use **Pigeonhole Sort** due to its efficiency with such data. Your task is to implement the `pigeonhole_sort` function to sort the given list of life expectancies. Function Signature ```python def pigeonhole_sort(arr: List[int]) -> List[int]: pass ``` # Input - A list of integers `arr` where each integer represents the life expectancy of an animal species. The length of the list is `n` where `1 <= n <= 10^6`. - The values in the list are between 1 and 100 inclusive. # Output - A list of integers sorted in non-decreasing order. Constraints - All life expectancies lie within the range [1, 100]. - The list may contain duplicate values. - The implementation should be efficient in terms of both time and space. # Example ```python assert pigeonhole_sort([5, 2, 8, 1, 4, 7, 9]) == [1, 2, 4, 5, 7, 8, 9] assert pigeonhole_sort([10, 10, 10, 10]) == [10, 10, 10, 10] assert pigeonhole_sort([100, 1, 1, 100]) == [1, 1, 100, 100] ``` # Edge Cases to Consider - The input list `arr` is empty. - The input list contains only one element. - All elements in the list are the same. Implement the `pigeonhole_sort` function that adheres to the above specifications and passes all provided test cases.","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: Sorts a list of integers where each integer represents the life expectancy of an animal species. The values in the list are between 1 and 100 inclusive. if not arr: return [] min_val = 1 max_val = 100 size = max_val - min_val + 1 holes = [0] * size for x in arr: assert min_val <= x <= max_val, f\\"Value {x} is out of the expected range [{min_val}, {max_val}]\\" holes[x - min_val] += 1 sorted_arr = [] for i in range(size): while holes[i] > 0: sorted_arr.append(i + min_val) holes[i] -= 1 return sorted_arr"},{"question":"# Primality Testing with Rabin-Miller Objective Implement a function `is_probably_prime` that leverages the Rabin-Miller primality test to assess if a number is probably prime. Function Signature ```python def is_probably_prime(n: int, k: int = 5) -> bool: ... ``` Input - An integer `n` (2 <= `n` <= 10^18): the number to test for primality. - An integer `k` (default = 5): the number of iterations for accuracy checks. Output - A boolean value: - `True` if `n` is probably prime. - `False` if `n` is definitely composite. Constraints - `n` should be a valid positive integer greater than or equal to 2. - The function should avoid using any external libraries for arbitrary precision arithmetic. Notes - You can assume that the input values will fit within standard Python integer limits. - Handle edge cases such as numbers less than 5 manually. Example ```python assert is_probably_prime(101) == True # 101 is a prime number assert is_probably_prime(102) == False # 102 is not a prime number assert is_probably_prime(2) == True # Smallest prime number assert is_probably_prime(97) == True # 97 is a prime number ``` Implement the function and ensure it runs efficiently for large input values, leveraging the principles of the Rabin-Miller primality test for probabilistic validation of primality.","solution":"import random def is_probably_prime(n: int, k: int = 5) -> bool: Performs the Rabin-Miller primality test to check if a number is probably prime. Arguments: n -- the number to test for primality k -- the number of iterations (default 5) for the Rabin-Miller algorithm Returns: True if n is probably prime, False if n is definitely composite if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False # Write n-1 as 2^r * d with d odd by factoring powers of 2 from n-1 r, d = 0, n - 1 while d % 2 == 0: r += 1 d //= 2 def is_composite(a): x = pow(a, d, n) if x == 1 or x == n - 1: return False for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return False return True for _ in range(k): a = random.randint(2, n - 2) if is_composite(a): return False return True"},{"question":"Number of Digits in an Integer You are tasked with implementing a function to calculate the number of digits in an integer. This function should be able to: 1. Handle positive, negative, and zero values. 2. Operate in constant time complexity, O(1). Function Signature ```python def num_digits(n: int) -> int: # Your implementation here ``` Input - `n` (int): An integer whose digits need to be counted. Output - (int): The number of digits in the integer `n`. Constraints - The integer `n` will be in the range of representable 32-bit integers (-2,147,483,648 to 2,147,483,647). Examples ```python assert num_digits(123) == 3 assert num_digits(-123) == 3 assert num_digits(0) == 1 assert num_digits(1000) == 4 ``` # Scenario You are developing a logging system that requires integer entries to be automatically adjusted in format based on their digit count. Implementing an efficient function to count the number of digits quickly helps format these logs dynamically. # Requirements - Ensure the function works efficiently in constant time. - Handle edge cases, including zero and negative numbers correctly. - `math.log10` may be used to achieve the solution.","solution":"import math def num_digits(n: int) -> int: Returns the number of digits in the integer n. Works for positive, negative, and zero values. if n == 0: return 1 else: return int(math.log10(abs(n))) + 1"},{"question":"# Find the Extra Character in Shuffled String **Scenario**: You are working as a software engineer at an e-commerce company. One day, a bug report comes in stating that some customer orders are getting mixed up randomly. After thorough investigation, you find that occasionally a new character representing a special note or identifier gets added to the shuffled order sequence, causing the discrepancies. To automate the detection, you need to write a function that identifies this extra character. **Objective**: Write a function `find_difference(s, t)` to find the extra character in string `t` which is generated by shuffling string `s` and adding exactly one new character. **Function Signature**: `def find_difference(s: str, t: str) -> str:` **Input**: - `s` (string): A string containing lowercase letters of the alphabet. - `t` (string): A string containing lowercase letters of the alphabet, which is a shuffled version of `s` plus one additional character. **Output**: - Return a single character which is the extra character added to string `t`. **Example**: ```python s = \\"abcd\\" t = \\"abecd\\" # find_difference(s, t) should return \'e\' print(find_difference(s, t)) # Output: \'e\' ``` **Constraints**: - Both strings only contain lowercase letters. - The length of string `t` is exactly one more than the length of string `s` (i.e., len(t) = len(s) + 1). **Explanation**: - The added character in string `t` that is not present in string `s` needs to be determined. **Performance Requirements**: - The function should run efficiently with linear time complexity O(n) and constant space complexity O(1).","solution":"def find_difference(s: str, t: str) -> str: Find the extra character in string t which is generated by shuffling string s and adding one new character. s_sum = sum(ord(char) for char in s) t_sum = sum(ord(char) for char in t) return chr(t_sum - s_sum)"},{"question":"# Shell Sort Coding Challenge Context: Shell Sort is a sorting algorithm that builds upon insertion sort with improved performance by sorting elements that are a certain distance apart. With this challenge, you will implement Shell Sort using a specific gap sequence and demonstrate your understanding of sorting algorithms. Instructions: Implement the Shell Sort algorithm using the following gap sequence: [N/2, N/4, ..., 1], where N is the length of the array. Function Signature: ```python def shell_sort_custom(arr: list) -> list: Sorts an input list using the Shell Sort algorithm with a specific gap sequence. Parameters: arr: list : The list of integers to be sorted Returns: list : A new list containing the sorted integers pass ``` Input: * A single list `arr` containing `n` integers, where `0 <= n <= 10^4` and `-10^6 <= arr[i] <= 10^6`. Output: * Return a new list which is the sorted version of `arr` using Shell Sort. Constraints: 1. You must use the provided gap sequence `[N//2, N//4, ..., 1]`. Example: ```python arr = [64, 34, 25, 12, 22, 11, 90] print(shell_sort_custom(arr)) # Output: [11, 12, 22, 25, 34, 64, 90] arr = [] print(shell_sort_custom(arr)) # Output: [] arr = [2, -19, 23, -4, 5, 0] print(shell_sort_custom(arr)) # Output: [-19, -4, 0, 2, 5, 23] ``` Performance and Edge Cases: 1. **Performance**: Your solution should handle arrays up to a length of `10^4` efficiently. 2. **Edge Cases**: * Consider empty arrays and arrays with one element. * Arrays with all elements the same. * Arrays already sorted in ascending or descending order. * Arrays with large positive and negative numbers.","solution":"def shell_sort_custom(arr: list) -> list: Sorts an input list using the Shell Sort algorithm with a specific gap sequence. Parameters: arr: list : The list of integers to be sorted Returns: list : A new list containing the sorted integers n = len(arr) gap = n // 2 # initial gap size while gap > 0: for i in range(gap, n): temp = arr[i] j = i # Shift elements of arr[0..i-gap] to one position ahead # if they are greater than temp while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 # reduce gap for next pass return arr"},{"question":"# Hierarchical Data Printer You work as a software developer responsible for maintaining tools that handle hierarchical data structures, such as organizational directories or nested JSON objects. One common task is to print these structures in a readable format for log files or debugging purposes. You are provided with a nested dictionary where each key can map to a string or another dictionary. Your task is to write a function that takes this nested dictionary and prints its structure in a hierarchical, indented format. # Function Signature ```python def print_hierarchy(data: dict) -> None: ``` # Input * `data`: A dictionary where keys are strings, and values can be strings or other dictionaries. # Output * The function should print the dictionary\'s structure, with each level of the hierarchy indented by two spaces. # Example ```python data = { \\"a\\": {\\"Adam\\": {\\"Book\\": 4}}, \\"b\\": {\\"Bill\\": {\\"Computer\\": 5, \\"TV\\": 6}, \\"Jill\\": {\\"Sports\\": 1}}, \\"c\\": {\\"Bill\\": {\\"Sports\\": 3}}, \\"d\\": {\\"Adam\\": {\\"Computer\\": 3}, \\"Quin\\": {\\"Computer\\": 3}}, \\"e\\": {\\"Quin\\": {\\"Book\\": 5, \\"TV\\": 2}}, \\"f\\": {\\"Adam\\": {\\"Computer\\": 7}} } print_hierarchy(data) ``` Expected output: ``` a -> Adam -> Book 4 b -> Bill -> Computer 5 -> TV 6 -> Jill -> Sports 1 c -> Bill -> Sports 3 d -> Adam -> Computer 3 -> Quin -> Computer 3 e -> Quin -> Book 5 -> TV 2 f -> Adam -> Computer 7 ``` # Constraints * You may assume that all keys and values in the dictionary and nested dictionaries are properly formatted strings and integers. * The depth of the nesting will not exceed Python\'s default recursion limit. # Notes * The function only prints the hierarchy and does not return any value. * Ensure proper handling of non-dictionary values within the hierarchy. * Consider how your function will handle deep recursion and optimize if needed.","solution":"def print_hierarchy(data: dict, indent: int = 0) -> None: Prints the structure of a nested dictionary in a readable, hierarchical format. Parameters: data (dict): The nested dictionary to print indent (int): The current level of indentation (for internal use) indent_str = \' \' * (indent * 2) for key, value in data.items(): if isinstance(value, dict): print(f\\"{indent_str}{key}\\") print_hierarchy(value, indent + 1) else: print(f\\"{indent_str}{key} {value}\\") # Example usage data = { \\"a\\": {\\"Adam\\": {\\"Book\\": 4}}, \\"b\\": {\\"Bill\\": {\\"Computer\\": 5, \\"TV\\": 6}, \\"Jill\\": {\\"Sports\\": 1}}, \\"c\\": {\\"Bill\\": {\\"Sports\\": 3}}, \\"d\\": {\\"Adam\\": {\\"Computer\\": 3}, \\"Quin\\": {\\"Computer\\": 3}}, \\"e\\": {\\"Quin\\": {\\"Book\\": 5, \\"TV\\": 2}}, \\"f\\": {\\"Adam\\": {\\"Computer\\": 7}} } print_hierarchy(data)"},{"question":"# Scenario You are working on a project that requires efficient storage and retrieval of key-value pairs, and you decide to use a hash table for this purpose. However, the standard hash table implementation you are using does not handle resizing operations efficiently, leading to performance degradation as the number of elements increases. Therefore, you need to implement a resizable hash table. # Task Implement a Python class `ResizableHashTable` that extends a basic hash table implementation to include dynamic resizing capabilities. The custom hash table should double in size when it is at least two-thirds full to maintain performance efficiency. # Function Specification Your implementation should support the following operations: 1. **put(key, value)**: Adds a new key-value pair to the hash table. If the key already exists, its value should be updated. If necessary, this should trigger the table resizing. 2. **get(key)**: Retrieves the value associated with the given key. Returns `None` if the key does not exist. 3. **del(key)** [or **del hash_table[key]**]: Deletes the key-value pair associated with the given key. 4. **len() [or using len]**: Returns the number of key-value pairs stored in the hash table. # Input and Output * **Input**: Commands and parameters provided as function calls. * **Output**: Results of `get` function calls and the state of the hash table after each operation. # Constraints * Keys are integers. * Initial size of the hash table is 8. * The hash function used is a simple modulus operation `key % table_size`. # Example ```python hash_table = ResizableHashTable() hash_table.put(1, \\"Value1\\") hash_table.put(9, \\"Value9\\") # Result in collision print(hash_table.get(1)) # Output: \\"Value1\\" print(len(hash_table)) # Output: 2 del hash_table[1] print(len(hash_table)) # Output: 1 print(hash_table.get(1)) # Output: None ``` # Note Provide a thorough implementation of the `ResizableHashTable` class focusing on handling collisions through linear probing and ensuring the table resizes efficiently while maintaining the correctness of the stored key-value pairs.","solution":"class ResizableHashTable: def __init__(self): Initialize the hash table with a fixed initial size. self.initial_capacity = 8 self.table = [None] * self.initial_capacity self.size = 0 def _hash(self, key): Compute the hash index for a given key. return key % len(self.table) def _resize(self): Double the size of the hash table and rehash all existing key-value pairs. new_capacity = len(self.table) * 2 new_table = [None] * new_capacity for item in self.table: if item: key, value = item index = key % new_capacity while new_table[index] is not None: index = (index + 1) % new_capacity new_table[index] = (key, value) self.table = new_table def put(self, key, value): Add a key-value pair to the hash table. if self.size >= 2 * len(self.table) // 3: self._resize() index = self._hash(key) while self.table[index] is not None and self.table[index][0] != key: index = (index + 1) % len(self.table) if self.table[index] is None: self.size += 1 self.table[index] = (key, value) def get(self, key): Retrieve the value associated with the key. index = self._hash(key) while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] index = (index + 1) % len(self.table) return None def __delitem__(self, key): Delete the key-value pair associated with the given key. index = self._hash(key) while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = None self.size -= 1 self._rehash_from(index) return index = (index + 1) % len(self.table) def _rehash_from(self, index): Rehash from a given index to handle removals. next_index = (index + 1) % len(self.table) while self.table[next_index] is not None: key, value = self.table[next_index] self.table[next_index] = None self.size -= 1 self.put(key, value) next_index = (next_index + 1) % len(self.table) def __len__(self): Return the number of key-value pairs stored in the hash table. return self.size"},{"question":"# Anagram Checker for Extended Character Sets Suppose you are building a text processing system that needs to check if two strings are anagrams of each other. However, your system will handle not just lowercase English letters but any printable ASCII characters, including digits, punctuation, and spaces. Task: Write a function `are_anagrams(s1, s2)` that: 1. Takes two strings `s1` and `s2` as input. 2. Returns `True` if the strings are anagrams, and `False` otherwise. Requirements: - Your function should work for any printable ASCII characters. - The function should handle both uppercase and lowercase letters as distinct characters. - Consider performance efficiency in terms of time and space complexity. Input: - Two strings `s1` and `s2`. Output: - Boolean value `True` or `False`. Constraints: - The length of each string will not exceed 10^6 characters. Examples: ```python print(are_anagrams(\\"A gentleman\\", \\"Elegant man\\")) # True print(are_anagrams(\\"Clint Eastwood\\", \\"Old west action\\")) # True print(are_anagrams(\\"Anagrams\\", \\"Not anagrams\\")) # False print(are_anagrams(\\"!\\", \\"!\\")) # True print(are_anagrams(\\"!?\\", \\"?!\\")) # True print(are_anagrams(\\"abc\\", \\"def\\")) # False ``` Note that you cannot use any built-in sorting functions or external libraries for sorting.","solution":"from collections import Counter def are_anagrams(s1, s2): Checks if two strings are anagrams considering printable ASCII characters. Parameters: s1 (str): First string to compare. s2 (str): Second string to compare. Returns: bool: True if the strings are anagrams, False otherwise. return Counter(s1) == Counter(s2)"},{"question":"You are provided with a class `SegmentTree` that facilitates efficient range queries and updates on an array using a commutative function (an operation that yields the same result regardless of the order of the operands). Implement the `SegmentTree` class, which should allow the following operations: 1. **Initialization**: The tree is initialized with an array and a function. 2. **Update**: Update an element at a specified index. 3. **Query**: Retrieve results for a specified range. # Class Definition Implement the `SegmentTree` class with the following attributes and methods: Attributes - **tree**: List representing the segment tree. - **size**: Integer representing the size of the original array. - **fn**: Commutative function used for operations on the tree. Methods 1. **`__init__(self, arr: List[Any], function: Callable[[Any, Any], Any])`**: Initializes the segment tree. 2. **`build_tree(self)`**: Builds the segment tree from the array using the specified function. 3. **`update(self, index: int, value: Any)`**: Updates the element at the given index with the new value. 4. **`query(self, left: int, right: int) -> Any`**: Returns the result of the commutative function over the specified range [left, right]. # Example ```python # Define a segment tree with a summation function mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) # Perform a range query from index 0 to 6 print(mytree.query(0, 6)) # Output: 64 # Update the element at index 2 to -10 mytree.update(2, -10) # Perform a range query from index 0 to 6 again print(mytree.query(0, 6)) # Output: 52 ``` Constraints - The input array length is between 1 and 10^5. - The provided function is guaranteed to be commutative. - Queries and updates should be efficient (O(log n)). # Additional Notes - Handle invalid indices gracefully. - Assume the array contains integers, floats, or tuples where the function can be applied.","solution":"from typing import List, Callable, Any class SegmentTree: def __init__(self, arr: List[Any], function: Callable[[Any, Any], Any]): self.size = len(arr) self.fn = function self.tree = [None] * (2 * self.size) self.build_tree(arr) def build_tree(self, arr: List[Any]): # initialize leaves for i in range(self.size): self.tree[self.size + i] = arr[i] # build the tree for i in range(self.size - 1, 0, -1): self.tree[i] = self.fn(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, index: int, value: Any): if index < 0 or index >= self.size: return # invalid index pos = index + self.size self.tree[pos] = value # update the tree while pos > 1: pos //= 2 left = pos * 2 right = pos * 2 + 1 self.tree[pos] = self.fn(self.tree[left], self.tree[right]) def query(self, left: int, right: int) -> Any: if left < 0 or right >= self.size or left > right: return None # invalid range left += self.size right += self.size result = None while left <= right: if left % 2 == 1: result = self.tree[left] if result is None else self.fn(result, self.tree[left]) left += 1 if right % 2 == 0: result = self.tree[right] if result is None else self.fn(result, self.tree[right]) right -= 1 left //= 2 right //= 2 return result"},{"question":"**Context**: You have been employed to develop a feature in a system where certain tasks must always be handled in order of their priority values. Higher priority tasks should always be dealt with first. To achieve this, you need a custom stack implementation which supports maintaining an ordered structure efficiently. **Task**: Implement the `OrderedStack` class to handle ordered elements in a stack with the following functionality: 1. **push(item)**: Adds a new item to the stack in such a way that the stack always remains ordered. The highest value should be at the top of the stack. 2. **pop()**: Removes and returns the top item of the stack. 3. **peek()**: Returns the top item of the stack without removing it. 4. **size()**: Returns the number of items in the stack. 5. **is_empty()**: Returns True if the stack is empty, False otherwise. Constraints * The stack should handle integer values. * Ensure your solution avoids unnecessary performance penalties. Input and Output Format - No input or output functions are required. You just need to implement the class `OrderedStack` with the methods specified. Examples 1. `push(3)`, `push(2)`, `push(5)`, the stack should now have `[2, 3, 5]`. 2. `peek()` should return `5`. 3. `pop()` should return `5` and the stack should now have `[2, 3]`. 4. `size()` should return `2`. ```python # Implement the class OrderedStack and its methods here class OrderedStack: def __init__(self): self.items = [] def is_empty(self): return self.items == [] def push_t(self, item): self.items.append(item) def push(self, item): temp_stack = OrderedStack() if self.is_empty() or item > self.peek(): self.push_t(item) else: while not self.is_empty() and item < self.peek(): temp_stack.push_t(self.pop()) self.push_t(item) while not temp_stack.is_empty(): self.push_t(temp_stack.pop()) def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items.pop() def peek(self): return self.items[-1] def size(self): return len(self.items) ```","solution":"class OrderedStack: def __init__(self): self.items = [] def is_empty(self): return len(self.items) == 0 def push(self, item): temp = [] while self.items and self.items[-1] > item: temp.append(self.pop()) self.items.append(item) while temp: self.items.append(temp.pop()) def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items.pop() def peek(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items[-1] def size(self): return len(self.items)"},{"question":"# Hash Table with Separate Chaining **Description**: A hash table is a data structure that maps keys to values efficiently. A common method to handle collisions in hash tables is **separate chaining**, where each bucket in the hash table uses a linked list to store all elements that hash to the same index. **Objective**: Implement a modified version of the given SeparateChainingHashTable class with the following additional features: 1. **Resizing**: Automatically resize the hash table when the load factor (number of elements / number of buckets) exceeds a threshold (e.g., 0.7). Upon resizing, rehash all existing elements to the new table size. 2. **Load Factor Calculation**: Implement a method to calculate the current load factor. 3. **Item Retrieval**: Tweak the get method to raise a KeyError if a requested key is not present, instead of returning `None`. # Requirements: 1. Implement a `resize` method to double the table size when the load factor exceeds 0.7. 2. Modify the `put` and `del_` methods to use the `resize` method. 3. Implement a `load_factor` method to return the current load factor. 4. Modify `get` method to raise `KeyError` if the key is not found. **Function Signatures**: * `def resize(self): -> None` * `def load_factor(self): -> float` # Input and Output Format: * No direct user input/output required. * Methods will be tested for correctness via unit tests. **Constraints**: * Initial bucket size should be a prime number. * You are required to handle strings as keys and assume keys are unique. # Example: ```python # Initialize a hash table with default size table = SeparateChainingHashTable() # Add key-value pairs table.put(\'hello\', \'world\') table.put(\'foo\', \'bar\') table.put(\'baz\', \'qux\') # Test get method assert table.get(\'hello\') == \'world\' # Calculate load factor assert table.load_factor() == 3/11 # Trigger resizing by adding more elements for i in range(10): table.put(f\'key{i}\', f\'value{i}\') # Verify resized table assert table.size > 11 # Test get method with non-existent key try: table.get(\'nonexistent\') except KeyError: print(\\"KeyError raised as expected\\") ``` **Notes**: - Pay attention to edge cases like duplicate keys, deleting non-existent keys, and resizing correctly. - Make sure your implementation is efficient and avoids unnecessary computations.","solution":"class SeparateChainingHashTable: def __init__(self, initial_size=11): self.table_size = initial_size self.buckets = [[] for _ in range(self.table_size)] self.num_elements = 0 def hash(self, key): return hash(key) % self.table_size def put(self, key, value): self.del_(key) # remove existing key if exists to avoid duplicates index = self.hash(key) self.buckets[index].append((key, value)) self.num_elements += 1 if self.load_factor() > 0.7: self.resize() def get(self, key): index = self.hash(key) for k, v in self.buckets[index]: if k == key: return v raise KeyError(f\\"Key \'{key}\' not found\\") def del_(self, key): index = self.hash(key) for i, (k, v) in enumerate(self.buckets[index]): if k == key: del self.buckets[index][i] self.num_elements -= 1 return def load_factor(self): return self.num_elements / self.table_size def resize(self): old_buckets = self.buckets self.table_size *= 2 self.buckets = [[] for _ in range(self.table_size)] self.num_elements = 0 for bucket in old_buckets: for k, v in bucket: self.put(k, v)"},{"question":"# Pattern Matching with Bijection Constraint You are given a pattern and a string. Your task is to determine if the string follows the same pattern, where \\"following\\" means that there should be a bijection between characters in the pattern and non-empty substrings in the string. In other words, every character in the pattern should map to a unique non-empty substring of the string, and no two characters should map to the same substring. Expected Input and Output: - **Input**: - `pattern`: A string consisting of lowercase letters (`1 <= len(pattern) <= 20`). - `string`: A string consisting of lowercase letters (`1 <= len(string) <= 50`). - **Output**: - Return `True` if the string follows the same pattern. - Return `False` otherwise. Constraints: - Both `pattern` and `string` contain only lowercase letters. Example: - pattern = \\"abab\\", string = \\"redblueredblue\\" should return `True`. - pattern = \\"aaaa\\", string = \\"asdasdasdasd\\" should return `True`. - pattern = \\"aabb\\", string = \\"xyzabcxzyabc\\" should return `False`. Performance Requirements: - Optimize the solution as much as possible. - Consider edge cases and provide a well-thought-out code solution. Challenge: Write your solution in the function `is_pattern_matching(pattern, string)`: ```python def is_pattern_matching(pattern, string): :type pattern: str :type string: str :rtype: bool # Your implementation here def backtrack(pattern, string, mapping): # Termination conditions if not pattern and not string: return True if not pattern or not string: return False char = pattern[0] for end in range(1, len(string) - len(pattern) + 2): substring = string[:end] if char not in mapping and substring not in mapping.values(): mapping[char] = substring if backtrack(pattern[1:], string[end:], mapping): return True del mapping[char] elif char in mapping and mapping[char] == substring: if backtrack(pattern[1:], string[end:], mapping): return True return False return backtrack(pattern, string, {}) # Test cases print(is_pattern_matching(\\"abab\\", \\"redblueredblue\\")) # Returns True print(is_pattern_matching(\\"aaaa\\", \\"asdasdasdasd\\")) # Returns True print(is_pattern_matching(\\"aabb\\", \\"xyzabcxzyabc\\")) # Returns False ```","solution":"def is_pattern_matching(pattern, string): Determines if the string follows the same pattern with a bijection constraint. :type pattern: str :type string: str :rtype: bool def backtrack(pattern, string, mapping, mapped_substrings): # Termination conditions if not pattern and not string: return True if not pattern or not string: return False char = pattern[0] for end in range(1, len(string) - len(pattern) + 2): substring = string[:end] if char not in mapping and substring not in mapped_substrings: mapping[char] = substring mapped_substrings.add(substring) if backtrack(pattern[1:], string[end:], mapping, mapped_substrings): return True del mapping[char] mapped_substrings.remove(substring) elif char in mapping and mapping[char] == substring: if backtrack(pattern[1:], string[end:], mapping, mapped_substrings): return True return False return backtrack(pattern, string, {}, set())"},{"question":"# Question: Implement Enhanced Comb Sort Comb Sort is a more optimized sorting algorithm compared to Bubble Sort. It operates by initially considering a large gap between elements to be compared and shrinking this gap until it is one, at which the final pass effectively becomes Bubble Sort. One issue with the basic Comb Sort is its worst-case performance which is O(N^2). Your task is to implement an enhanced version of Comb Sort that attempts to guarantee better performance by adjusting the shrink factor dynamically based on certain array properties. # Task Write a function `enhanced_comb_sort(arr: List[int]) -> List[int]` that implements an enhanced version of Comb Sort. The function should return the sorted array. # Input - `arr`: A list of integers which may contain duplicate values. - The list has at most 10,000 elements. # Output - The function should return a new list of integers sorted in ascending order. # Constraints - Elements in the array can range from -10^9 to 10^9. - The function must handle up to 10,000 elements efficiently. # Performance Requirements - The function should aim for average-case performance better than O(N^2) and approach O(N log N) under typical conditions. - The function should maintain an in-place sort (use O(1) additional space). # Example ```python input_array = [34, -5, 0, 12, 100, 1, 3, 12, 19] print(enhanced_comb_sort(input_array)) # Output: [-5, 0, 1, 3, 12, 12, 19, 34, 100] input_array = [4, 3, 2, 1] print(enhanced_comb_sort(input_array)) # Output: [1, 2, 3, 4] ``` **Note**: The actual performance gains will depend heavily on the specific implementation enhancements you apply.","solution":"def enhanced_comb_sort(arr): This function sorts a list of integers using an enhanced version of comb sort. import math def get_next_gap(gap): # Shrinking gap using the shrink factor 1.3 new_gap = int(math.floor(gap / 1.3)) return max(1, new_gap) n = len(arr) gap = n swapped = True while gap != 1 or swapped: # Calculate the next gap gap = get_next_gap(gap) swapped = False # Compare elements with the current gap and swap if needed for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] # Swaps elements swapped = True return arr"},{"question":"You are given a target value `value` and a list of coin denominations `coins`. You need to write a function that calculates the number of different ways to make up that `value` using the coin denominations provided. Each coin denomination can be used an infinite number of times. **Function Signature**: ```python def count(coins: List[int], value: int) -> int: ``` # Input * `coins` (List[int]): A list of integers representing the coin denominations (1 ≤ length of `coins` ≤ 100). * `value` (int): An integer representing the target value you need to make change for (0 ≤ `value` ≤ 10^4). # Output * Return an integer representing the number of ways to make change for the given value using the provided coin denominations. # Constraints * The order of coin denominations used in each way should not matter, i.e., [1, 2] is considered the same as [2, 1]. * Each denomination in `coins` list is assumed to be a positive integer greater than zero. * The function should have a time complexity of O(n * m) where n is the `value` and m is the number of `coins`, and a space complexity of O(n). # Example ```python assert count([1, 2, 3], 4) == 4 # Explanation: For value 4 and coins [1, 2, 3], there are four solutions: # [1, 1, 1, 1], [1, 1, 2], [2, 2], [1, 3] assert count([2, 5, 3, 6], 10) == 5 # Explanation: For value 10 and coins [2, 5, 3, 6], there are five solutions: # [2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 2, 6], [2, 3, 5], [5, 5] ``` # Additional Notes * Consider edge cases where `value` is 0 or where the `coins` list is empty. * Ensure the function is optimized to handle large values efficiently and avoid unnecessary computations.","solution":"from typing import List def count(coins: List[int], value: int) -> int: Returns the number of ways to make change for a given value using provided coin denominations. # Initialize a list of zeros with length (value + 1) dp = [0] * (value + 1) # There is one way to make 0 value: using no coins dp[0] = 1 # Process each coin for coin in coins: for i in range(coin, value + 1): dp[i] += dp[i - coin] return dp[value]"},{"question":"**Sliding Window Maximum** Given an array of integers `nums` and an integer `k`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position. Your task is to write a function `max_sliding_window(nums, k)` that returns an array of the maximum values in each window position. Function Signature ```python def max_sliding_window(nums, k): :param nums: List[int] - list of integers :param k: int - size of the sliding window :return: List[int] - list of integers representing the maximum values in each sliding window position ``` Expected Input and Output - Input: - `nums`: a list of integers, e.g., `[1,3,-1,-3,5,3,6,7]` - `k`: an integer, the size of the window, e.g., 3 - Output: a list of integers representing the maximum of the sliding window at each step, e.g., for the given example, return `[3,3,5,5,6,7]` Constraints: - The input list `nums` will have at least one element and at most 10^5 elements. - The integer `k` will be between 1 and the length of the list inclusive. Performance Requirement: - The solution should have a time complexity of O(N). Scenario: Consider an array that represents the temperature changes throughout several days. To analyze the weather patterns more effectively, you need to find the maximum temperature recorded in a sliding window of a few days. Example: ```python nums = [1,3,-1,-3,5,3,6,7] k = 3 print(max_sliding_window(nums, k)) # Output: [3, 3, 5, 5, 6, 7] ``` Notes: - You must handle edge cases such as an empty list or a window size of 1.","solution":"from collections import deque def max_sliding_window(nums, k): Returns the maximum values in each sliding window position of size k. :param nums: List[int] - list of integers :param k: int - size of the sliding window :return: List[int] - list of integers representing the maximum values in each sliding window position if not nums or k == 0: return [] if k == 1: return nums result = [] deq = deque() for i in range(len(nums)): # Remove elements not within the sliding window while deq and deq[0] < i - k + 1: deq.popleft() # Remove elements not useful (i.e., smaller than the current element) while deq and nums[deq[-1]] <= nums[i]: deq.pop() deq.append(i) # Append the maximum element for the current window if i >= k - 1: result.append(nums[deq[0]]) return result"},{"question":"# Context You are tasked with implementing a sorting algorithm that needs to be stable and more efficient than traditional O(n log n) algorithms for specific cases where the range of values in the array is limited. Given that the input may contain negative values, you need to ensure your solution can handle such cases. # Problem Statement Implement a stable sorting algorithm using Counting Sort that organizes an array of integers. Your implementation should handle arrays containing negative numbers by transforming the range appropriately. # Function Signature ```python def counting_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr`: List[int] - A list of integers (both positive and negative). # Output * List[int] - A sorted list of integers. # Constraints * The length of the array (n) is 1 ≤ n ≤ 10^6. * The elements of the array (arr[i]) are constrained by -10^6 ≤ arr[i] ≤ 10^6. # Example Example 1: ```python Input: arr = [4, 2, 2, 8, 3, 3, 1] Output: [1, 2, 2, 3, 3, 4, 8] ``` Example 2: ```python Input: arr = [-5, -10, 0, -3, 8, 5, -1, 10] Output: [-10, -5, -3, -1, 0, 5, 8, 10] ``` # Notes 1. Ensure that your algorithm is stable. 2. Handle the case where the array contains negative numbers appropriately. 3. Optimize for both time and space complexity within the constraints.","solution":"def counting_sort(arr): Sorts an array of integers using Counting Sort algorithm and handles negative numbers by transforming the range. :param arr: List[int] - A list of integers (both positive and negative). :return: List[int] - A sorted list of integers. if not arr: return [] # Find the minimum and maximum values in the array min_val = min(arr) max_val = max(arr) # Calculate the range of the elements range_val = max_val - min_val + 1 # Create count array with the size of range_val count = [0] * range_val # Fill the count array for num in arr: count[num - min_val] += 1 # Compute the starting index for each key for i in range(1, range_val): count[i] += count[i - 1] # Output array to store the sorted elements output = [0] * len(arr) # Build the output array using count array (Stable sort) for num in reversed(arr): output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return output"},{"question":"**Title:** Binary Search Tree Operations **Description:** You are required to implement a simple Binary Search Tree (BST) with insert, search, delete, and inorder traversal operations. **Task:** 1. Implement a `BinarySearchTree` class that supports the following methods: - `insert(val)`: Inserts a value into the BST. - `search(val)`: Returns `True` if the value exists in the BST, else `False`. - `delete(val)`: Deletes a value from the BST. - `inorder_traversal()`: Returns a list of values of the nodes in the BST in ascending order. **Input Format:** - For the `insert` and `delete` methods, `val` is an integer. - For the `search` method, `val` is an integer. - The `inorder_traversal` method takes no input. **Output Format:** - `search` returns a boolean. - `inorder_traversal` returns a list of integers. - `insert` and `delete` modify the BST but return nothing. **Constraints:** - None of the inputs will be `None`. - You can assume that no two insert values will be the same. **Example:** ```python bst = BinarySearchTree() bst.insert(5) bst.insert(3) bst.insert(7) print(bst.search(3)) # True print(bst.search(4)) # False bst.insert(4) print(bst.inorder_traversal()) # [3, 4, 5, 7] bst.delete(3) print(bst.inorder_traversal()) # [4, 5, 7] ``` **Note:** - Ensure proper management of node pointers during deletion to maintain BST properties. - Be mindful of edge cases such as deleting a node with zero, one, or two children, and ensure the tree remains valid after every operation.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val): if self.root is None: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._insert(node.left, val) else: if node.right is None: node.right = TreeNode(val) else: self._insert(node.right, val) def search(self, val): return self._search(self.root, val) def _search(self, node, val): if node is None: return False if node.val == val: return True elif val < node.val: return self._search(node.left, val) else: return self._search(node.right, val) def delete(self, val): self.root = self._delete(self.root, val) def _delete(self, node, val): if node is None: return node if val < node.val: node.left = self._delete(node.left, val) elif val > node.val: node.right = self._delete(node.right, val) else: if node.left is None: return node.right elif node.right is None: return node.left temp_val = self._min_value_node(node.right) node.val = temp_val node.right = self._delete(node.right, temp_val) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current.val def inorder_traversal(self): result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, node, result): if node is not None: self._inorder_traversal(node.left, result) result.append(node.val) self._inorder_traversal(node.right, result)"},{"question":"# Combination Calculation with Dynamic Programming In combinatorial mathematics, the combination formula ( C(n, r) ) determines how many ways you can choose ( r ) items from a set of ( n ) items without regard to the order of selection. This is crucial in various applications such as probability, statistics, and operations research. Task Implement a function that calculates the combinations ( nCr ) using dynamic programming to ensure efficient execution even with large inputs. Function Signature ```python def calculate_combinations(n: int, r: int) -> int: pass ``` Input * An integer ( n ) representing the total number of items. * An integer ( r ) representing the number of items to choose. Output * An integer representing the number of combinations. Constraints * ( 0 leq r leq n leq 1000 ) Algorithm Requirements 1. Implement the function using dynamic programming to ensure the solution remains performant for large values of ( n ) and ( r ). 2. Your solution should avoid recursive approaches prone to stack overflow issues. 3. Ensure that edge cases such as ( n = 0 ) or ( r = 0 ) are handled correctly. Example ```python print(calculate_combinations(5, 2)) # Output: 10 print(calculate_combinations(0, 0)) # Output: 1 print(calculate_combinations(6, 3)) # Output: 20 print(calculate_combinations(1000, 500)) # Output: (large number) ``` Notes - Make use of an iterative dynamic programming table to store the values of previously computed subproblems. - Ensure your solution is optimized for large values within the given constraint.","solution":"def calculate_combinations(n: int, r: int) -> int: Calculate combinations C(n, r) using dynamic programming. if r > n: return 0 if r == 0 or r == n: return 1 dp = [[0 for _ in range(r + 1)] for _ in range(n + 1)] for i in range(n + 1): for j in range(min(i, r) + 1): if j == 0 or j == i: dp[i][j] = 1 else: dp[i][j] = dp[i-1][j-1] + dp[i-1][j] return dp[n][r]"},{"question":"# Binary Tree Serialization and Deserialization Given the binary tree data structure and serialization/deserialization functions provided, implement a function that checks whether two binary trees are equal. Problem Description You are required to implement the function `is_equal` that takes the roots of two binary trees and determines if they are structurally identical and the nodes have the same values. Function Signature ```python def is_equal(root1: TreeNode, root2: TreeNode) -> bool: # Your code here ``` Input - `root1`: The root node of the first binary tree (`TreeNode` object). - `root2`: The root node of the second binary tree (`TreeNode` object). Output - Return `True` if both trees are structurally identical and all corresponding nodes have the same value. Otherwise, return `False`. Constraints - The number of nodes in each tree is `n` such that `0 <= n <= 10^4`. - Node values are integers. Examples ```python # Example 1: t1 = TreeNode(1) t1.left = TreeNode(2) t1.right = TreeNode(3) t2 = TreeNode(1) t2.left = TreeNode(2) t2.right = TreeNode(3) result = is_equal(t1, t2) # should return True # Example 2: t1 = TreeNode(1) t1.left = TreeNode(2) t2 = TreeNode(1) t2.right = TreeNode(2) result = is_equal(t1, t2) # should return False ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_equal(root1: TreeNode, root2: TreeNode) -> bool: Determine if two binary trees rooted at root1 and root2 are identical. # Base cases if root1 is None and root2 is None: return True if root1 is None or root2 is None: return False if root1.val != root2.val: return False # Recursive case return is_equal(root1.left, root2.left) and is_equal(root1.right, root2.right)"},{"question":"Optimized Selection Sort with Stability Context: Selection Sort is a fundamental sorting algorithm, known for its simplicity but also its inefficiency on large datasets due to its quadratic time complexity. However, in certain scenarios where sorting stability (preserving the relative order of equal elements) and efficiency are both important, an optimized variant can be useful. Task: You are required to implement a stable version of the Selection Sort algorithm. This means that equal elements should retain their relative positions from the original array. Additionally, the algorithm should be optimized to minimize unnecessary swaps. Function Signature: ```python def optimized_stable_selection_sort(arr, simulation=False): Optimized and stable version of Selection Sort that preserves the order of equivalent elements. :param arr: List of elements to be sorted :param simulation: Boolean to indicate if the simulation steps should be printed :return: Sorted list ``` Input: * `arr`: List of integers or float, the array to be sorted. The length of the array is between 1 and 1000. * `simulation`: Boolean indicating whether to print the array after each iteration (default is False). Output: * Return the sorted list. Constraints: * Handle edge cases such as arrays with all identical elements, empty arrays, and arrays with one element. * You should maintain the relative order of duplicated elements. Example: ```python print(optimized_stable_selection_sort([64, 34, 25, 12, 22, 11, 90])) # Output: [11, 12, 22, 25, 34, 64, 90] print(optimized_stable_selection_sort([4, 5, 3, 2, 4, 3], simulation=True)) # Output with simulation: # iteration 0 : [2, 5, 3, 4, 4, 3] # iteration 1 : [2, 3, 5, 4, 4, 3] # iteration 2 : [2, 3, 3, 5, 4, 4] # iteration 3 : [2, 3, 3, 4, 5, 4] # iteration 4 : [2, 3, 3, 4, 4, 5] # [2, 3, 3, 4, 4, 5] ``` Notes: * Ensure that your print statements match the example when `simulation` is `True`. * The goal is to maintain both the efficiency while ensuring stability in the selection sort implementation.","solution":"def optimized_stable_selection_sort(arr, simulation=False): Optimized and stable version of Selection Sort that preserves the order of equivalent elements. :param arr: List of elements to be sorted :param simulation: Boolean to indicate if the simulation steps should be printed :return: Sorted list n = len(arr) for i in range(n): min_index = i # Find the minimum element in remaining unsorted array for j in range(i + 1, n): if arr[min_index] > arr[j]: min_index = j # Move minimum element to the front by shifting elements to the right key = arr[min_index] while min_index > i: arr[min_index] = arr[min_index - 1] min_index -= 1 arr[i] = key if simulation: print(f\\"iteration {i} : {arr}\\") return arr"},{"question":"# Histogram Calculation with Added Constraints **Context**: Histograms are powerful tools in data analysis used to visualize the distribution of numerical or categorical data by representing frequencies. You are given a list of integers, and your task is to write a function to generate a histogram (frequency count) of the elements. Additionally, you need to ensure the implementation handles scenarios where the input list consists of large numbers efficiently. **Objective**: Implement a function `optimized_histogram` that calculates the frequency of each element in a list. The function should also handle lists with very large numbers effectively by using specialized data structures if necessary. # Function Signature ```python def optimized_histogram(input_list: list) -> dict: Calculate and return the histogram of values in the input list. :param input_list: List of integers. :return: Dictionary with elements as keys and their frequencies as values. ``` **Input and Output**: - **Input**: A list of integers (e.g., [1, 2, 2, 3, 3, 3, 4]) - **Output**: A dictionary with elements from the list as keys and their frequency count as values (e.g., {1: 1, 2: 2, 3: 3, 4: 1}). **Constraints**: - The input list can be very large, containing up to 10^6 elements. - Elements in the list can have a wide range of values, but all are integers. - The solution should aim for optimal performance with respect to both time and space. # Example - `optimized_histogram([1, 2, 2, 3, 3, 4, 4, 4, 4])` should return `{1: 1, 2: 2, 3: 2, 4: 4}` - `optimized_histogram([5, 5, 5, 10, 10])` should return `{5: 3, 10: 2}` - `optimized_histogram([100])` should return `{100: 1}` # Requirements - Efficient handling of large datasets and memory management. - Accurate counting of all elements. - Consider edge cases such as an empty list.","solution":"from collections import defaultdict def optimized_histogram(input_list: list) -> dict: Calculate and return the histogram of values in the input list. :param input_list: List of integers. :return: Dictionary with elements as keys and their frequencies as values. histogram = defaultdict(int) for item in input_list: histogram[item] += 1 return dict(histogram)"},{"question":"Context You are a software developer tasked with the implementation of a search utility for a client application. The application uses extensive datasets that are always sorted in increasing order. In this context, it is critical to efficiently locate the last occurrence of a specific element within these datasets. Objective Write a function that accurately finds the last occurrence of a given element in a sorted array using binary search. Function Signature ```python def find_last_occurrence(array: list, target: int) -> int: pass ``` Input/Output Formats * **Input**: * `array` (list): A list of integers sorted in increasing order. * `target` (int): The integer value to search for in the array. * **Output**: * Returns an integer representing the index of the last occurrence of `target` in the array. Return -1 if the target is not found. Constraints * The input array can be of substantial size (e.g., up to 10^6 elements). * Script execution should remain efficient and performant. Example ```python # Example 1 array = [1, 2, 2, 2, 3, 4, 5] target = 2 # Expected Output: 3 (last occurrence of 2 is at index 3) # Example 2 array = [1, 2, 3, 4, 5, 6, 7] target = 8 # Expected Output: -1 (8 is not present in the array) ``` Performance Requirements * The solution should be optimized for time complexity of O(log n). * The space complexity should not exceed O(1). Edge Cases * Handle arrays with a single element. * Handle target values that do not exist in the array. * Handle decreasing subsequences incorrectly interpreted as valid. Good luck, and ensure your implementation is thoroughly tested for edge cases and performance criteria.","solution":"def find_last_occurrence(array: list, target: int) -> int: Finds the last occurrence of the target in the sorted array. Returns the index of the last occurrence, or -1 if the target is not found. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == target: result = mid # Found the target, save the index left = mid + 1 # Continue to search in the right sub-array elif array[mid] < target: left = mid + 1 # Search in the right sub-array else: right = mid - 1 # Search in the left sub-array return result"},{"question":"# Question: Implement and Validate a Roman Numeral to Integer Converter **Context**: You are tasked with enhancing a legacy system that processes historical data in Roman numerals. Given the nature of this data, it is essential to handle both valid and invalid inputs gracefully. Your task involves not only converting valid Roman numerals to integers but also ensuring that invalid inputs are detected and handled appropriately. **Task**: Write a Python function `roman_to_int` that converts a Roman numeral string into an integer. Additionally, write another function `is_valid_roman` to validate the input string. If the input is valid, `roman_to_int` should return its integer equivalent; otherwise, it should raise a `ValueError` with a descriptive error message. **Input**: * `s`: A string representing a Roman numeral. It can be empty or contain invalid characters. **Output**: * An integer equivalent of the Roman numeral if the input is valid. * If invalid, raise a `ValueError` with the message \\"Invalid Roman numeral\\". **Constraints**: * Input is guaranteed to be within the range from 1 to 3999 for valid Roman numerals. * Roman numeral rules must be strictly followed. **Function Signature**: ```python def roman_to_int(s: str) -> int: pass def is_valid_roman(s: str) -> bool: pass ``` **Requirements**: * The `is_valid_roman` function: * Checks if the string contains only valid Roman numeral characters (\'M\', \'D\', \'C\', \'L\', \'X\', \'V\', \'I\'). * Ensures the Roman numeral follows proper subtractive combination rules (e.g., \'IX\' but not \'IIX\', \'CM\' but not \'CCM\'). * The `roman_to_int` function: * Calls `is_valid_roman` to validate the input. * Converts the valid Roman numeral to its integer equivalent using the algorithm described. **Example**: ```python print(roman_to_int(\\"DCXXI\\")) # Output: 621 print(roman_to_int(\\"MMXIV\\")) # Output: 2014 print(roman_to_int(\\"IIII\\")) # Raises ValueError: Invalid Roman numeral print(roman_to_int(\\"ABC\\")) # Raises ValueError: Invalid Roman numeral ``` ---","solution":"def is_valid_roman(s: str) -> bool: Validate if the given string is a valid Roman numeral. # Define valid Roman numeral patterns valid_roman_regex = r\\"^(M{0,3})(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})\\" # Use regex to match the string against valid patterns import re return bool(re.match(valid_roman_regex, s)) def roman_to_int(s: str) -> int: Convert a Roman numeral string into an integer. if not is_valid_roman(s): raise ValueError(\\"Invalid Roman numeral\\") roman_to_int_mapping = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_to_int_mapping[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"# Bipartite Graph Checker You are given an undirected graph represented by its adjacency list. Your task is to determine if the graph is bipartite. **Input**: - The graph is given in the form of an adjacency list, `adj_list`, where `adj_list[i]` is a list of vertices adjacent to the `i-th` vertex. - The graph is guaranteed to be undirected and may be disconnected. **Output**: - Return `True` if the graph is bipartite, otherwise return `False`. **Constraints**: - The graph will have at most 1000 vertices. - The number of edges in the graph will be at most 10^6. **Examples**: 1. **Input**: ```python adj_list = [ [1, 3], [0, 2], [1, 3], [0, 2] ] ``` **Output**: ```python True ``` **Explanation**: The graph can be colored using two colors in such a way that no two adjacent vertices have the same color. Thus, it is bipartite. 2. **Input**: ```python adj_list = [ [1, 2, 3], [0, 2], [0, 1, 3], [0, 2] ] ``` **Output**: ```python False ``` **Explanation**: There exists a loop between vertices 0-1-2 which makes it impossible to color graph with two colors. Thus, it is not bipartite. **Implementation Note**: Use a Breadth-First Search (BFS) approach to implement the bipartite graph checking. Ensure to manage the queue efficiently and handle disconnected components by initiating a BFS from unvisited nodes.","solution":"def is_bipartite(adj_list): Determines if the given undirected graph represented by its adjacency list is bipartite. :param adj_list: List[List[int]] An adjacency list representation of the graph. :return: bool True if the graph is bipartite, False otherwise. n = len(adj_list) color = [-1] * n # -1 means uncolored, 0 and 1 are the two colors def bfs(start): queue = [start] color[start] = 0 while queue: node = queue.pop(0) for neighbor in adj_list[node]: if color[neighbor] == -1: color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False return True for i in range(n): if color[i] == -1: if not bfs(i): return False return True"},{"question":"# Question: Implement a Min-Priority Queue using a Binary Heap **Context**: You are working on a complex system where task scheduling is critical, and tasks have different priorities. The current implementation using a linear list for the priority queue has performance issues. To optimize, you decide to implement a Min-Priority Queue using a Binary Heap. **Objective**: Write a class `MinPriorityQueue` that uses a binary heap to implement a min-priority queue. **Requirements**: - **Insertion** of elements should be in O(log n) time. - **Removal** of the element with the smallest priority should be in O(log n) time. - Supports methods `insert(item, priority)`, `extract_min()`, and `peek_min()`. **Classes and Methods**: ```python class MinPriorityQueue: def __init__(self): Initialize the priority queue using a binary heap. pass def insert(self, item: any, priority: int): Insert an item with the given priority into the priority queue. :param item: The item to be inserted into the queue. :param priority: The priority of the item. pass def extract_min(self) -> any: Remove and return the item with the smallest priority. :return: The item with the smallest priority. pass def peek_min(self) -> any: Return the item with the smallest priority without removing it. :return: The item with the smallest priority. pass def size(self) -> int: Return the number of elements in the priority queue. :return: The size of the priority queue. pass ``` **Constraints**: - Assume all priorities are unique. - The priority is an integer. - The insert, extract_min, and peek_min operations should be optimized for performance. **Note**: - You are required to use a binary heap for your implementation. - Your class should not use any Python built-in libraries for priority queues (i.e., no usage of `heapq`).","solution":"class MinPriorityQueue: def __init__(self): Initialize the priority queue using a binary heap. self.heap = [] self.entry_finder = {} self.counter = 0 def insert(self, item: any, priority: int): Insert an item with the given priority into the priority queue. :param item: The item to be inserted into the queue. :param priority: The priority of the item. self.counter += 1 entry = [priority, self.counter, item] self.entry_finder[item] = entry self._heapify_up(entry) def extract_min(self) -> any: Remove and return the item with the smallest priority. :return: The item with the smallest priority. min_item = self.heap[0][2] self._swap(0, len(self.heap) - 1) self.heap.pop() self._heapify_down(0) self.entry_finder.pop(min_item) return min_item def peek_min(self) -> any: Return the item with the smallest priority without removing it. :return: The item with the smallest priority. return self.heap[0][2] def size(self) -> int: Return the number of elements in the priority queue. :return: The size of the priority queue. return len(self.heap) def _heapify_up(self, entry): idx = len(self.heap) self.heap.append(entry) while idx > 0: parent_idx = (idx - 1) // 2 if self.heap[idx][0] < self.heap[parent_idx][0]: self._swap(idx, parent_idx) idx = parent_idx else: break def _heapify_down(self, idx): n = len(self.heap) while True: smallest = idx left = 2 * idx + 1 right = 2 * idx + 2 if left < n and self.heap[left][0] < self.heap[smallest][0]: smallest = left if right < n and self.heap[right][0] < self.heap[smallest][0]: smallest = right if smallest == idx: break self._swap(smallest, idx) idx = smallest def _swap(self, i, j): self.heap[i], self.heap[j] = self.heap[j], self.heap[i] self.entry_finder[self.heap[i][2]] = self.heap[i] self.entry_finder[self.heap[j][2]] = self.heap[j]"},{"question":"# Question: You are asked to implement a function that extends the Insertion Sort algorithm to support sorting in both ascending and descending orders. The function must handle the following scenarios effectively. # Function Signature: ```python def enhanced_insertion_sort(arr: List[int], order: str = \\"asc\\") -> List[int]: Parameters: arr (List[int]): List of integers to be sorted. order (str): Sorting order. It can be either \\"asc\\" for ascending or \\"desc\\" for descending (default is \\"asc\\"). Returns: List[int]: The sorted list in the specified order. ``` # Constraints: 1. The input list can contain zero or more integers. 2. The \'order\' parameter will only take \\"asc\\" or \\"desc\\" as values. Consider case sensitivity. 3. The function must handle edge cases such as an empty list, a single element list, and lists with duplicate elements correctly. 4. The solution should attempt to maintain the efficiency of the insertion sort as much as possible. # Example Usage: ```python # Example Usage: # Sorting in ascending order print(enhanced_insertion_sort([4, 2, 6, 1, 5, 3])) # Output: [1, 2, 3, 4, 5, 6] # Sorting in descending order print(enhanced_insertion_sort([4, 2, 6, 1, 5, 3], \\"desc\\")) # Output: [6, 5, 4, 3, 2, 1] # Handling edge cases print(enhanced_insertion_sort([])) # Output: [] print(enhanced_insertion_sort([1])) # Output: [1] print(enhanced_insertion_sort([5, 5, 5], \\"desc\\")) # Output: [5, 5, 5] ``` # Requirements: - Implement the \'enhanced_insertion_sort\' function as per the function signature provided. - Ensure the function handles all edge cases efficiently. - Avoid unnecessary computations to maintain the efficiency of the algorithm.","solution":"def enhanced_insertion_sort(arr, order=\\"asc\\"): Sorts a list of integers in ascending or descending order using the insertion sort algorithm. Parameters: arr (List[int]): List of integers to be sorted. order (str): Sorting order. It can be either \\"asc\\" for ascending or \\"desc\\" for descending (default is \\"asc\\"). Returns: List[int]: The sorted list in the specified order. if order not in [\\"asc\\", \\"desc\\"]: raise ValueError(\\"order must be \'asc\' or \'desc\'\\") for i in range(1, len(arr)): key = arr[i] j = i - 1 if order == \\"asc\\": while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 else: # order == \\"desc\\" while j >= 0 and key > arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"You are given an array of integers and your task is to implement the Selection Sort algorithm to sort the array in non-decreasing order. The function should simulate each iteration step to help visualize how the algorithm works. # Function Signature ```python def selection_sort(arr, simulation=False): Parameters: arr (list): A list of integers to sort. simulation (bool): If True, print the array at each iteration of sorting. Default is False. Returns: list: Sorted list of integers in non-decreasing order. ``` # Input * `arr`: List of integers. Constraints: 1 <= len(arr) <= 1000, -10000 <= arr[i] <= 10000 for all integers `arr[i]`. * `simulation`: A boolean flag that indicates whether to print the arrays after each iteration. # Output * The function should return a list of integers sorted in non-decreasing order. * If `simulation` is `True`, the function should print the array after each iteration in the format: `iteration <iteration_number> : <array elements>`, where `<iteration_number>` starts from 0 and `<array elements>` are space-separated. # Examples Example 1: Input: ``` arr = [64, 25, 12, 22, 11] simulation = False ``` Output: ``` [11, 12, 22, 25, 64] ``` Example 2: Input: ``` arr = [64, 25, 12, 22, 11] simulation = True ``` Output: ``` iteration 0 : 64 25 12 22 11 iteration 1 : 11 25 12 22 64 iteration 2 : 11 12 25 22 64 iteration 3 : 11 12 22 25 64 iteration 4 : 11 12 22 25 64 [11, 12, 22, 25, 64] ``` # Constraints * The array should be sorted using the Selection Sort algorithm only. * The function should print the simulation step if `simulation` is `True`. # Notes * This problem will test your understanding of simple sorting algorithms, ability to simulate algorithm steps, and your attention to detail with respect to edge cases.","solution":"def selection_sort(arr, simulation=False): Performs Selection Sort on the given array. Parameters: arr (list): List of integers to sort. simulation (bool): If True, prints the array at each iteration step. Returns: list: Sorted list of integers in non-decreasing order. n = len(arr) for i in range(n): # Assume the minimum is the first element min_idx = i for j in range(i + 1, n): # Update min_idx if the element at j is less than the current minimum if arr[j] < arr[min_idx]: min_idx = j # Swap the found minimum element with the first element arr[i], arr[min_idx] = arr[min_idx], arr[i] # Print the array at each iteration if simulation is True if simulation: print(f\\"iteration {i} : {\' \'.join(map(str, arr))}\\") return arr"},{"question":"# Queue Simulation with Dynamic Consumer **Context**: You have learned about implementing queues, both using arrays and linked lists. Now, let’s put this knowledge into practice by solving a real-world problem. # Problem Statement Design and implement a dynamic consumer simulator using both an `ArrayQueue` and a `LinkedListQueue`. This simulator should process customer service requests in the order they are received (FIFO). You will simulate a simple queue system where requests arrive at random intervals, and a consumer processes requests at set intervals. Write a function `simulate_queue(customers, processing_time, use_array_queue=True)` that simulates this system. Here\'s how it works: 1. Assume that `customers` is a list of tuples where each tuple `(t, r)` represents a customer request arriving at time `t` with request id `r`. 2. `processing_time` is an integer representing the time it takes for the consumer to process each request. 3. If `use_array_queue` is `True`, use the `ArrayQueue` implementation; otherwise, use the `LinkedListQueue` implementation. 4. The simulator should return a list of processed request ids in the order they were processed. # Input * `customers`: List of tuples `[(int, int)]` where each tuple represents `(arrival_time, request_id)` * `processing_time`: Integer representing the time to process each request * `use_array_queue`: Boolean value to select the type of queue implementation # Output * List of processed request ids # Performance Requirements * The solution should efficiently handle up to 1000 requests. # Example ```python customers = [(0, 1), (2, 2), (4, 3), (5, 4)] processing_time = 3 print(simulate_queue(customers, processing_time, use_array_queue=True)) # Output could be something like [1, 2, 3, 4] ``` # Constraints * The `arrival_time` of customers is a non-negative integer and is sorted. * `request_id` is a unique integer. * `processing_time` is a positive integer. # Notes * Ensure edge cases such as no customers, varying processing and arrival times, and empty queues are handled gracefully. * Consider the efficiency of the algorithm, especially handling frequent enqueue and dequeue operations.","solution":"from collections import deque class ArrayQueue: def __init__(self): self.queue = [] def enqueue(self, item): self.queue.append(item) def dequeue(self): return self.queue.pop(0) if self.queue else None def isEmpty(self): return len(self.queue) == 0 class Node: def __init__(self, value): self.value = value self.next = None class LinkedListQueue: def __init__(self): self.front = self.rear = None def enqueue(self, item): new_node = Node(item) if self.rear is None: self.front = self.rear = new_node return self.rear.next = new_node self.rear = new_node def dequeue(self): if self.front is None: return None temp = self.front self.front = temp.next if self.front is None: self.rear = None return temp.value def isEmpty(self): return self.front is None def simulate_queue(customers, processing_time, use_array_queue=True): queue = ArrayQueue() if use_array_queue else LinkedListQueue() current_time = 0 processed_requests = [] customer_index = 0 while customer_index < len(customers) or not queue.isEmpty(): while customer_index < len(customers) and customers[customer_index][0] <= current_time: queue.enqueue(customers[customer_index][1]) customer_index += 1 if not queue.isEmpty(): processed_requests.append(queue.dequeue()) current_time += processing_time else: if customer_index < len(customers): current_time = customers[customer_index][0] return processed_requests"},{"question":"# Longest Common Subsequence Challenge Background In computational biology, reversing the highest alignment score can reveal the longest common subsequence (LCS), instrumental in DNA sequence comparison. It\'ll help your new startup to refine text comparison algorithms for several practical applications like spell checkers, diff tools, and version control systems. Task You need to implement a function to determine the length of the longest common subsequence between two given strings. Your task is to write a function `longest_common_subsequence` that accepts two strings and returns the length of their Longest Common Subsequence (LCS). Function Signature ```python def longest_common_subsequence(s_1: str, s_2: str) -> int: pass ``` Input * Two strings `s_1` and `s_2`, each containing only lowercase English letters. * `1 <= len(s_1), len(s_2) <= 1000` Output * An integer representing the length of the longest common subsequence of the two strings. Example ```python # Example 1 input: \\"abcdgh\\", \\"aedfhr\\" output: 3 Explanation: The longest common subsequence is \\"adh\\" # Example 2 input: \\"abc\\", \\"abc\\" output: 3 Explanation: The longest common subsequence is \\"abc\\" ``` Constraints 1. The function should run efficiently with a time complexity of O(M*N) and space complexity of O(M*N). Note Ensure that your function correctly handles edge cases such as when one or both input strings are empty.","solution":"def longest_common_subsequence(s_1: str, s_2: str) -> int: Returns the length of the longest common subsequence between two strings s_1 and s_2. m = len(s_1) n = len(s_2) # Create a 2D array to store the length of LCS at different points dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array from bottom up for i in range(1, m + 1): for j in range(1, n + 1): if s_1[i - 1] == s_2[j - 1]: # match case dp[i][j] = dp[i - 1][j - 1] + 1 else: # mismatch case dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The value in dp[m][n] is the length of LCS for s_1[0..m-1] and s_2[0..n-1] return dp[m][n]"},{"question":"Scenario: You are developing a utility function for a digital signal processing library. This function will aid in assessing the integrity of data streams transmitted over a noisy channel by counting the number of error bits. Efficiently counting the number of \'1\' bits in the binary representation of each 32-bit data chunk can help in quickly determining error rates. Task: Implement a function `count_hamming_weight(n: int) -> int` that takes an unsigned 32-bit integer `n` and returns the Hamming weight, i.e., the number of \'1\' bits in its binary representation. # Requirements: 1. **Function Signature**: ```python def count_hamming_weight(n: int) -> int: :param n: An unsigned 32-bit integer. :return: Integer representing the number of \'1\' bits in the binary representation of n. ``` 2. **Input Constraints**: - `0 <= n < 2**32`: Ensure input is within the range of a 32-bit unsigned integer. 3. **Output**: - Return the count of \'1\' bits in `n`. 4. **Performance**: - The solution should be efficient with a time complexity of O(k), where k is the number of \'1\' bits. Example: ```python assert count_hamming_weight(11) == 3 # Binary: 00000000000000000000000000001011 assert count_hamming_weight(16) == 1 # Binary: 00000000000000000000000000010000 assert count_hamming_weight(0) == 0 # Binary: 00000000000000000000000000000000 ``` # Notes: - You may choose to implement either the iterative or recursive approach, but be mindful of the limitations discussed in the analysis.","solution":"def count_hamming_weight(n: int) -> int: Returns the number of \'1\' bits in the binary representation of n. :param n: An unsigned 32-bit integer. :return: Integer representing the number of \'1\' bits in the binary representation of n. count = 0 while n: count += n & 1 n >>= 1 return count"},{"question":"You are tasked with implementing a more flexible `ZigZagIterator` that can handle multiple (more than two) lists. Your iterator should iterate through the lists in a round-robin fashion. Specifically, you will be provided with a list of lists, and your iterator should alternate between all the lists, repeating this process until all elements are exhausted. # Requirements * Implement a class `ZigZagIterator2` with the following methods: - `__init__(self, vectors: List[List[int]])`: Initializes the iterator with a list of lists `vectors`. - `next(self) -> int`: Returns the next element in the zigzag iteration. - `has_next(self) -> bool`: Returns `True` if there are more elements to iterate over, otherwise returns `False`. # Input * The constructor receives a list of non-negative integer lists. * Example: ```python vectors = [[1, 2], [3, 4, 5, 6], [7, 8, 9]] ``` # Output * Calling `next()` successively should return: `1, 3, 7, 2, 4, 8, 5, 9, 6` * Calling `has_next()` appropriately should indicate whether more elements need to be iterated over. # Constraints * `0 <= vectors[i].length <= 1000` * `1 <= len(vectors) <= 10^5` # Example ```python vectors = [[1, 2], [3, 4, 5, 6], [7, 8, 9]] it = ZigZagIterator2(vectors) result = [] while it.has_next(): result.append(it.next()) # result should be [1, 3, 7, 2, 4, 8, 5, 9, 6] ``` # Notes * Ensure your solution handles lists of unequal lengths and accounts for empty lists. * Optimize for performance due to potentially large numbers of lists and elements.","solution":"from collections import deque class ZigZagIterator2: def __init__(self, vectors): self.queue = deque((vec_iter := iter(v), vec_iter) for v in vectors if v) def next(self): if self.has_next(): vec_iter, vec = self.queue.popleft() value = next(vec_iter) if (new_item := next(vec, None)) is not None: self.queue.append((iter([new_item]), vec)) return value def has_next(self): return len(self.queue) > 0"},{"question":"# Question: Verify Word Pattern Matching Description: You are given a pattern and a string. Your task is to determine if the string follows the same pattern. A string follows the pattern if, for each distinct character in the pattern, there is exactly one unique word in the string that consistently maps to the character. Input: - A string `pattern` composed of lowercase letters only. - A string `str` composed of lowercase letters separated by single spaces. Output: - Return `True` if the string follows the pattern. - Return `False` otherwise. Constraints: - The `pattern` string consists only of lowercase characters (a-z). - The `str` string consists of lowercase words separated by single spaces. Example: ``` Input: pattern = \\"abba\\", str = \\"dog cat cat dog\\" Output: True Input: pattern = \\"abba\\", str = \\"dog cat cat fish\\" Output: False Input: pattern = \\"aaaa\\", str = \\"dog cat cat dog\\" Output: False Input: pattern = \\"abba\\", str = \\"dog dog dog dog\\" Output: False ``` Requirements: - Implement the function `def word_pattern(pattern, str):` that solves the problem as specified. Extra Challenge (Optional): Identify and handle additional edge cases such as: - Patterns containing spaces. - Empty strings for either `pattern` or `str`. Function Signature: ```python def word_pattern(pattern: str, str: str) -> bool: # Your code here ```","solution":"def word_pattern(pattern: str, str: str) -> bool: words = str.split() # If the number of elements in pattern and list of words is different, return False if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: if word in word_to_char: return False char_to_word[char] = word word_to_char[word] = char return True"},{"question":"# Question: Transitive Closure with Improved Time Complexity Context You are given a directed graph represented as an adjacency list. Your task is to compute the transitive closure of the graph using a more efficient algorithm. Task Write a function `transitive_closure(vertices: int, edges: List[Tuple[int, int]]) -> List[List[int]]` that computes the transitive closure of a directed graph. Input * `vertices`: An integer, the number of vertices in the graph. * `edges`: A list of tuples, where each tuple (source, target) represents a directed edge from `source` to `target`. Output * Return a 2D list (matrix) of size `vertices x vertices` where the element at ith row and jth column is 1 if there is a path from vertex `i` to vertex `j`, otherwise 0. Constraints * `1 <= vertices <= 100` * `0 <= number of edges <= vertices * (vertices - 1)] Example * Input: ```python vertices = 4 edges = [(0, 1), (1, 2), (2, 3)] ``` * Output: ```python [ [1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1] ] ``` Notes * Make sure your solution efficiently handles graph traversal and avoids unnecessary recursive calls. * Consider using Floyd-Warshall algorithm for an efficient solution. * Assume vertex indices are 0-based.","solution":"from typing import List, Tuple def transitive_closure(vertices: int, edges: List[Tuple[int, int]]) -> List[List[int]]: Computes the transitive closure of a directed graph using the Floyd-Warshall algorithm. :param vertices: An integer, the number of vertices in the graph. :param edges: A list of tuples, where each tuple (source, target) represents a directed edge from source to target. :return: A 2D list (matrix) of size vertices x vertices where the element at ith row and jth column is 1 if there is a path from vertex i to vertex j, otherwise 0. # Initialize the transitive closure matrix with 0s closure = [[0] * vertices for _ in range(vertices)] # Set the edge relationships in the closure for (u, v) in edges: closure[u][v] = 1 # Each vertex should have a path to itself for i in range(vertices): closure[i][i] = 1 # Floyd-Warshall algorithm to compute transitive closure for k in range(vertices): for i in range(vertices): for j in range(vertices): closure[i][j] = closure[i][j] or (closure[i][k] and closure[k][j]) return closure"},{"question":"# Rabin-Miller Primality Test Enhancement **Context**: You are working on a cryptography project that requires frequent and reliable primality testing for large numbers. To ensure high levels of accuracy and performance, you need to optimize and extend the Rabin-Miller primality test. **Task**: Your task is to implement an enhanced version of the Rabin-Miller primality test that accepts a list of numbers and returns a dictionary where the keys are the numbers and the values are booleans indicating whether each number is probably prime. Additionally, introduce a mechanism to handle small primes directly to improve performance. # Function Signature ```python def enhanced_rabin_miller(numbers: List[int], k: int) -> Dict[int, bool]: pass ``` # Input - `numbers` (List[int]): A list of integers to be tested for primality. - `k` (int): The number of iterations for the Rabin-Miller test. Higher values of ( k ) increase the confidence in the primality test results. # Output - Returns a dictionary where keys are integers from the input list and values are booleans indicating whether each number is probably prime. # Constraints - ( 2 leq n leq 10^{18} ) - ( 1 leq k leq 100 ) # Requirements 1. Implement the Rabin-Miller test as described, optimizing for performance. 2. Handle small numbers directly within your function. 3. Ensure the implementation efficiently handles large lists of numbers. # Example ```python numbers = [101, 102, 103, 104, 105] k = 5 # Example output { 101: True, # 101 is prime 102: False, # 102 is composite 103: True, # 103 is prime 104: False, # 104 is composite 105: False, # 105 is composite } ``` Use the above example to test your implementation.","solution":"from typing import List, Dict import random def _miller_rabin_test(n: int, k: int) -> bool: Perform the Miller-Rabin primality test on number n with k iterations. if n <= 1: return False if n <= 3: return True if n > 1 else False if n % 2 == 0: return False # Find d such that d * 2^r = n-1 r, d = 0, n - 1 while d % 2 == 0: r += 1 d //= 2 # This function performs one Miller-Rabin test loop def is_composite(a: int) -> bool: x = pow(a, d, n) if x == 1 or x == n - 1: return False for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return False return True # Perform k witness loops for _ in range(k): a = random.randint(2, n - 2) if is_composite(a): return False return True def enhanced_rabin_miller(numbers: List[int], k: int) -> Dict[int, bool]: Test a list of numbers for primality using an enhanced Rabin-Miller test. # Small prime numbers small_primes = [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97 ] def is_small_prime(n: int) -> bool: if n in small_primes: return True if n < 2 or any(n % p == 0 for p in small_primes if p < n): return False return True results = {} for number in numbers: if number <= 97: results[number] = is_small_prime(number) else: results[number] = _miller_rabin_test(number, k) return results"},{"question":"Context You are working on a system that combines two streams of data into one. For validation purposes, it is essential to determine whether a given string can be constructed by interleaving two other strings while maintaining the order of characters from each string. Task Write a Python function `is_merge` that determines whether a given string `s` can be formed by interleaving two other strings `part1` and `part2`. The characters in `part1` and `part2` must appear in the same order as they appear in `s`. Function Signature ```python def is_merge(s: str, part1: str, part2: str) -> bool: pass ``` Input * `s` (str): The target string to form, with length `n`. * `part1` (str): The first part string, with length `m`. * `part2` (str): The second part string, with length `k`. Output * Returns a boolean indicating whether `s` can be formed by interleaving `part1` and `part2`. Constraints * 0 <= n, m, k <= 1000 * All strings consist of lowercase English letters only. Examples ```python print(is_merge(\\"codewars\\", \\"cdw\\", \\"oears\\")) # Should return True print(is_merge(\\"abc\\", \\"ab\\", \\"bc\\")) # Should return False print(is_merge(\\"abcd\\", \\"\\", \\"abcd\\")) # Should return True print(is_merge(\\"abcd\\", \\"abcd\\", \\"\\")) # Should return True print(is_merge(\\"\\", \\"\\", \\"\\")) # Should return True ``` Notes * Make sure to handle edge cases such as empty strings and mismatches. * Optimize your solution for efficiency, considering both time and space complexities.","solution":"def is_merge(s: str, part1: str, part2: str) -> bool: len_s, len_part1, len_part2 = len(s), len(part1), len(part2) if len_s != len_part1 + len_part2: return False # Create a DP table of size (len_part1 + 1) x (len_part2 + 1) dp = [[False] * (len_part2 + 1) for _ in range(len_part1 + 1)] dp[0][0] = True # Fill dp table where each entry dp[i][j] means # part1[:i] and part2[:j] can form s[:i+j] for i in range(len_part1 + 1): for j in range(len_part2 + 1): if i > 0 and s[i + j - 1] == part1[i - 1]: dp[i][j] |= dp[i-1][j] if j > 0 and s[i + j - 1] == part2[j - 1]: dp[i][j] |= dp[i][j-1] return dp[len_part1][len_part2]"},{"question":"You are provided with a string containing arbitrary characters. Your task is to write a function `delete_reoccurring_characters(string)` that removes all subsequent occurrences of each character after its first occurrence, while preserving the order of characters. # Input * A string `string` of length n (1 ≤ n ≤ 10^6). The string can contain letters, digits, spaces, and special characters. # Output * A new string with all reoccurring characters removed. The order of the first occurrence of each character should be preserved. # Constraints * The function should have a time complexity of O(n). * The function should efficiently handle the input size constraints. # Function Signature ```python def delete_reoccurring_characters(string: str) -> str: pass ``` # Example ```python assert delete_reoccurring_characters(\\"google\\") == \\"gole\\" assert delete_reoccurring_characters(\\"hello world\\") == \\"helo wrd\\" assert delete_reoccurring_characters(\\"abcdabcd\\") == \\"abcd\\" assert delete_reoccurring_characters(\\"\\") == \\"\\" assert delete_reoccurring_characters(\\"aaa\\") == \\"a\\" ``` # Notes * Pay attention to not use excessive memory. * Consider both uppercase and lowercase letters as distinct characters during processing.","solution":"def delete_reoccurring_characters(string: str) -> str: Removes all subsequent occurrences of each character after its first occurrence, while preserving the order of characters. Args: string (str): The input string containing arbitrary characters. Returns: str: A new string with all reoccurring characters removed. seen = set() result = [] for char in string: if char not in seen: result.append(char) seen.add(char) return \'\'.join(result)"},{"question":"# Find the Unique Number in a List of Duplicates Given an array of integers where every element appears exactly twice except for one element which appears exactly once, write a function `find_unique_number` that finds and returns that single unique element. Function Signature ```python def find_unique_number(nums: List[int]) -> int: ``` Inputs * `nums` : List[int] - A list of integers where every element except one appears exactly twice. - Length of the list will be odd, and there will be at least one element in the list. Outputs * Returns an integer that is the single number appearing exactly once in the list. # Example ```python assert find_unique_number([4,1,2,1,2]) == 4 assert find_unique_number([2,2,1]) == 1 assert find_unique_number([1]) == 1 ``` # Constraints * Your solution should have a linear runtime complexity, i.e., O(n). * Avoid using extra memory beyond a constant amount, i.e., O(1) space complexity. # Scenario Consider a data analysis scenario where data packets are received in pairs except for one odd packet that indicates a unique transaction ID. This function can be used to quickly find that unique transaction.","solution":"from typing import List def find_unique_number(nums: List[int]) -> int: Finds the element that appears only once in a list where every other element appears exactly twice. Parameters: nums: List[int] : List of integers Returns: int : The unique element unique_num = 0 for num in nums: unique_num ^= num return unique_num"},{"question":"**Bucket Sort Implementation Enhancement** *Goal:* Enhance the given bucket sort implementation to handle arrays with widely distributed non-integer numbers and improve sorting stages. **Task**: Write a function `enhanced_bucket_sort(arr: List[float], num_buckets: int) -> List[float]` that improves upon the provided bucket sort algorithm. # Requirements: 1. **Input/Output**: * **Input**: A list `arr` of floating-point numbers, and an integer `num_buckets` that determines the number of buckets. * **Output**: A sorted list using bucket sort. 2. **Enhancements**: * Ensure the algorithm performs efficiently for non-uniform distributed datasets. * Replace the insertion sort used in `next_sort` with Python\'s built-in `sorted()` function for better performance. 3. **Constraints**: * The array `arr` will contain floating-point numbers between 0 and 1000000. * `num_buckets` will be a positive integer smaller than or equal to the length of `arr`. # Example: ```python arr = [0.78, 0.17, 0.39, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68] num_buckets = 5 print(enhanced_bucket_sort(arr, num_buckets)) # Output: [0.12, 0.17, 0.21, 0.23, 0.39, 0.68, 0.72, 0.78, 0.94] ``` # Instruction: Your function should: 1. Initialize a list of empty buckets based on `num_buckets`. 2. Place each element from `arr` into the correct bucket based on its value and the maximum value in `arr`. 3. Sort each bucket using the `sorted()` function. 4. Combine the sorted buckets into a single sorted list and return it. # Implementation: ```python def enhanced_bucket_sort(arr, num_buckets): \'\'\'Enhanced Bucket Sort\'\'\' # Your code here pass # Example usage # arr = [0.78, 0.17, 0.39, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68] # num_buckets = 5 # print(enhanced_bucket_sort(arr, num_buckets)) # # Expected Output: [0.12, 0.17, 0.21, 0.23, 0.39, 0.68, 0.72, 0.78, 0.94] ```","solution":"from typing import List def enhanced_bucket_sort(arr: List[float], num_buckets: int) -> List[float]: Enhanced Bucket Sort to handle widely distributed non-integer numbers. Args: arr (List[float]): List of floating-point numbers to sort. num_buckets (int): Number of buckets to use for sorting. Returns: List[float]: Sorted list of floating-point numbers. if len(arr) == 0: return [] # Initialize buckets max_value = max(arr) buckets = [[] for _ in range(num_buckets)] # Distribute input array values into buckets for number in arr: index = int(number / max_value * (num_buckets - 1)) # Scale number to fit bucket index buckets[index].append(number) # Sort each bucket and concatenate results sorted_array = [] for bucket in buckets: sorted_bucket = sorted(bucket) sorted_array.extend(sorted_bucket) return sorted_array"},{"question":"# Question: Real-Time Moving Median Calculation Scenario As a software engineer at a financial technology company, you are developing a feature that calculates the real-time median of stock prices in a sliding window. The median is a more robust measure of central tendency compared to the average because it is less affected by extreme values. Instead of calculating the moving average, you will now need to implement an algorithm that calculates the moving median given a stream of integers. Task Implement a class called `MovingMedian` that: 1. Initializes with a fixed window size. 2. Provides a method `next` that takes an integer as input and returns the median of the current window. Requirements - The `next` method should be called serially and each call provides a new integer value from the data stream. - If the window is not full yet, the median should be calculated for the available window elements. - The solution should be efficient with respect to both time and space. Specifications 1. Function Signature: ```python class MovingMedian: def __init__(self, size: int): pass def next(self, val: int) -> float: pass ``` 2. Input: - `size`: An integer `n` (>0), the size of the sliding window. - `val`: An integer, the value to be added to the window. 3. Output: - A floating-point number, representing the median of the current window. 4. Constraints: - The number of calls to the `next` function will be at least 1 and up to 10^4. - The values inserted in the window will be in the range [-10^5, 10^5]. Example ```python if __name__ == \\"__main__\\": m = MovingMedian(3) assert m.next(1) == 1.0 # Window: [1] assert m.next(10) == 5.5 # Window: [1, 10] assert m.next(3) == 3.0 # Window: [1, 10, 3] assert m.next(5) == 5.0 # Window: [10, 3, 5] ``` You may assume that you are given sufficient time and processing capability to implement a performant solution.","solution":"from collections import deque import bisect class MovingMedian: def __init__(self, size: int): self.size = size self.window = deque() self.sorted_window = [] def next(self, val: int) -> float: if len(self.window) == self.size: oldest = self.window.popleft() self.sorted_window.remove(oldest) self.window.append(val) bisect.insort_left(self.sorted_window, val) n = len(self.sorted_window) if n % 2 == 1: return float(self.sorted_window[n // 2]) else: return (self.sorted_window[n // 2 - 1] + self.sorted_window[n // 2]) / 2.0"},{"question":"Addition with Bitwise Operations Given the provided code, which adds two positive integers using bitwise operations, your task is to extend this functionality. Implement a function that not only performs bitwise addition of two positive integers but also performs bitwise multiplication of two positive integers. Function Signature ```python def add_bitwise_operator(x: int, y: int) -> int: # Existing implementation for bitwise addition remains the same. while y: carry = x & y x = x ^ y y = carry << 1 return x def multiply_bitwise_operator(x: int, y: int) -> int: # Implement this function. ``` Detailed Requirements 1. **addition operations**: - The function `add_bitwise_operator` should keep its current functionality, adding two positive integers without using the \'+\' operator. 2. **multiplication operations**: - The function `multiply_bitwise_operator` should multiply two positive integers using only bitwise operations and without using the \'*\' operator. - Utilize the \\"shift and add\\" technique to perform multiplication: - Shift `y` to the left by one bit (i.e., y << 1) is equivalent to multiplying `y` by two. - Shift `x` to the right by one bit (i.e., x >> 1) is equivalent to dividing `x` by two. - Add (using bitwise addition) the intermediate results as needed. Input Format - Two positive integers for both functions. Output Format - An integer representing the added or multiplied result. Constraints - Both integers will be non-negative with values less than 2^31. Examples ```python add_bitwise_operator(2, 3) # Output: 5 multiply_bitwise_operator(2, 3) # Output: 6 add_bitwise_operator(0, 0) # Output: 0 multiply_bitwise_operator(0, 5) # Output: 0 ``` Note: Ensure your solution has good coverage of edge cases, and consider performance aspects in your implementation.","solution":"def add_bitwise_operator(x: int, y: int) -> int: Adds two numbers using bitwise operations. while y: carry = x & y x = x ^ y y = carry << 1 return x def multiply_bitwise_operator(x: int, y: int) -> int: Multiplies two numbers using bitwise operations. result = 0 while y: if y & 1: # If the last bit of y is 1 result = add_bitwise_operator(result, x) x <<= 1 # Shift x to the left y >>= 1 # Shift y to the right return result"},{"question":"You are hiking a series of cliffs, where the top of the cliffs is represented by reaching a specific count `steps`. Every time you take a chance to climb, you can ascend either 1 step or 2 steps at a time. You need to determine the number of distinct ways you can climb to the top given the total number of steps. # Task Write a function `distinct_ways_to_climb` that determines the number of distinct ways to climb to the top of the cliffs. **Function Signature**: ```python def distinct_ways_to_climb(steps: int) -> int: ``` **Input**: * `steps` (integer): The total number of steps to reach the top. (1 <= steps <= 10^6) **Output**: * The function should return an integer representing the number of distinct ways to climb to the top. # Constraints * You can assume the input `steps` will always be at least 1 and at most 1,000,000. # Example Example 1 Input: ```python distinct_ways_to_climb(2) ``` Output: ```python 2 ``` Explanation: There are two ways to climb to the top of a 2-step cliff: 1. (1 step + 1 step) 2. (2 steps) Example 2 Input: ```python distinct_ways_to_climb(3) ``` Output: ```python 3 ``` Explanation: There are three ways to climb to the top of a 3-step cliff: 1. (1 step + 1 step + 1 step) 2. (1 step + 2 steps) 3. (2 steps + 1 step) # Notes * You may assume that the result will fit within a standard integer data type. # Requirements * Implement an optimized solution considering efficient space usage. * Avoid excessive memory allocation even for large inputs.","solution":"def distinct_ways_to_climb(steps: int) -> int: Calculate the number of distinct ways to climb to the top of the cliffs given the total number of steps using dynamic programming. if steps == 0: return 0 elif steps == 1: return 1 elif steps == 2: return 2 # Use two variables to store the number of distinct ways to reach # the previous two steps (Fibonacci sequence) one_step_before = 2 two_steps_before = 1 for _ in range(3, steps + 1): current = one_step_before + two_steps_before two_steps_before = one_step_before one_step_before = current return one_step_before"},{"question":"# Question: Intersection of Two Singly Linked Lists You are given two singly linked lists. Each list may or may not intersect with each other. Your task is to write a function that determines the first node at which the two lists intersect. The intersection is defined based on the reference, not the value of the nodes. Function Signature ```python def find_intersection(headA: Node, headB: Node) -> Node: ``` Input - `headA` : the head node of the first linked list. - `headB` : the head node of the second linked list. Output - Returns the reference to the intersection node or `None` if there is no intersection. Constraints - A node in a linked list is defined as: ```python class Node: def __init__(self, val=0, next=None): self.val = val self.next = next ``` - The given nodes are part of the same unique input lists and their references uniquely identify each node. - The function must run in O(N + M) time complexity and use O(1) space. Example Given the linked lists: ``` List A: 1 -> 3 -> 5 -> 7 -> 9 -> 11 / List B: 2 -> 4 -> 6 ->/ ``` The function should return the node with the value `7`. Note: - Your solution should correctly handle different edge cases, such as empty lists, lists without an intersection, and lists with different lengths. Test Case ```python # Test intersection of two linked lists node1 = Node(1) node2 = Node(3) node3 = Node(5) node4 = Node(7) node5 = Node(9) node6 = Node(11) node7 = Node(2) node8 = Node(4) node9 = Node(6) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node5 node5.next = node6 node7.next = node8 node8.next = node9 node9.next = node4 print(find_intersection(node1, node7).val) # should output 7 ``` Implement your function such that it passes the above test case.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def find_intersection(headA: Node, headB: Node) -> Node: # calculate the length of both lists def get_length(head): length = 0 while head: length += 1 head = head.next return length lenA = get_length(headA) lenB = get_length(headB) # align the start of both lists while lenA > lenB: headA = headA.next lenA -= 1 while lenB > lenA: headB = headB.next lenB -= 1 # find the intersection node while headA and headB: if headA == headB: return headA headA = headA.next headB = headB.next return None"},{"question":"# Quick Sort Assessment: Efficient Sorting Algorithm Implementation You have been tasked with implementing an efficient sorting algorithm for a high-frequency trading system which requires rapid and reliable sorting of large datasets. Your implementation should leverage the quick sort algorithm due to its good average-case performance and in-place sorting attribute. **Your task**: Implement the `quick_sort` function which sorts an array of integers in ascending order. The provided `iteration` and `simulation` parameters are for demonstration purposes and can be used to visualize the sorting process, but for this task, you should focus on the sorting functionality. # Function Signature ```python def quick_sort(arr: List[int], simulation: bool=False) -> List[int]: pass ``` # Input - `arr`: A list of integers to be sorted, 0 <= len(arr) <= 10^6. - `simulation`: A boolean flag indicating whether to print the sorting iterations (default should be `False`). # Output - The function should return a new list containing the sorted integers from `arr`. # Constraints - Your implementation should have an average time complexity of O(n log n). - Limit the space complexity to O(log n) excluding the input list. # Example ```python assert quick_sort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10] assert quick_sort([]) == [] assert quick_sort([1]) == [1] assert quick_sort([1, -1, 0, -10, 5, 5, 1000, 0]) == [-10, -1, 0, 0, 1, 5, 5, 1000] ``` # Instructions - Ensure that your solution passes the provided test cases. - Handle edge cases appropriately (e.g., empty lists, lists with all identical elements). - Optimize to handle large datasets within reasonable time constraints. # Notes - The `simulation` parameter, when set to `True`, can help you visualize each iteration of the sorting process for debugging purposes. However, it should not affect the main functionality of sorting when set to `False`.","solution":"def quick_sort(arr, simulation=False): Function to perform quick sort on an array of integers. Args: - arr: List[int] - A list of integers to be sorted. - simulation: bool - A flag to indicate whether to print sorting iterations. Returns: - A new list of integers sorted in ascending order. def _quick_sort_helper(arr): if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] if simulation: print(f\\"Left: {left}, Pivot: {pivot}, Right: {right}\\") return _quick_sort_helper(left) + middle + _quick_sort_helper(right) return _quick_sort_helper(arr)"},{"question":"You are tasked with implementing a sorting algorithm known as **Comb Sort**. The algorithm is inspired by bubble sort but differs by initially creating a \'gap\' between compared elements that shrinks each pass through the list. # Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: ``` # Input * `arr`: A list of integers that needs to be sorted. * **Constraints**: * (1 leq text{len(arr)} leq 10^5) * Elements in `arr` can be between (-10^6) and (10^6). # Output * The function should return a list of integers, sorted in non-decreasing order. # Performance Requirements * The algorithm should aim for an average-case time complexity better than O(N^2). Be mindful of large input sizes and optimize for performance when possible. # Detailed Instructions 1. **Gap Initialization**: Start with an initial gap size equal to the length of the array. 2. **Gap Adjustment**: Reduce the gap by dividing it by the shrink factor (use 1.3). 3. **Element Comparison and Swap**: For the current gap size, compare elements and swap if out of order. 4. **Termination**: The process stops when the gap size reduces to 1 and no swaps occur during that pass (indicating the list is sorted). # Example ```python assert comb_sort([34, 7, 23, 32, 5, 62]) == [5, 7, 23, 32, 34, 62] assert comb_sort([3, 3, 2, 1]) == [1, 2, 3, 3] assert comb_sort([]) == [] assert comb_sort([1]) == [1] ``` The solution should handle large arrays efficiently while adhering to constraints and return the expected sorted output.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Sorts an array using the comb sort algorithm. Parameters: arr (List[int]): List of integers to sort. Returns: List[int]: Sorted list of integers. n = len(arr) gap = n shrink = 1.3 sorted = False while not sorted: gap = int(gap // shrink) if gap > 1: sorted = False else: gap = 1 sorted = True i = 0 while i + gap < n: if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False i += 1 return arr"},{"question":"# Reverse Vowels in a String **Scenario**: You are building a text editor feature that allows users to process and reverse the positions of vowels in any given text string. The goal is to ensure that all vowels within the string are reversed, while all non-vowel characters remain in their original position. **Task**: Implement a function `reverse_vowels(s: str) -> str` that takes a single string `s` and returns a new string with the positions of all vowels reversed. **Function Signature**: ```python def reverse_vowels(s: str) -> str: ``` **Input**: - `s` (1 ≤ len(s) ≤ 10^5): A string consisting of printable ASCII characters. **Output**: - A string with all vowels reversed, non-vowel characters remain in their original position. **Constraints**: - Vowels are defined as \\"AEIOUaeiou\\". **Example**: ```python assert reverse_vowels(\\"hello\\") == \\"holle\\" assert reverse_vowels(\\"leetcode\\") == \\"leotcede\\" assert reverse_vowels(\\"aA\\") == \\"Aa\\" assert reverse_vowels(\\"abcdef\\") == \\"ebcdaf\\" ``` **Explanation**: 1. For the input \\"hello\\", the vowels are \'e\' and \'o\'. Reversing them gives \\"holle\\". 2. For the input \\"leetcode\\", the vowels are \'e\', \'e\', \'o\', and \'e\'. Reversing them gives \\"leotcede\\". 3. For the input \\"aA\\", the vowels are \'a\' and \'A\'. Reversing them gives \\"Aa\\". 4. For the input \\"abcdef\\", the vowels are \'a\' and \'e\'. Reversing them gives \\"ebcdaf\\". **Considerations**: - Ensure the algorithm handles different cases, including uppercase and lowercase vowels correctly. - Performance needs to handle strings up to the length of 100,000 efficiently.","solution":"def reverse_vowels(s: str) -> str: Reverses the positions of all vowels in a given string. Parameters: s (str): The input string. Returns: str: The output string with reversed vowels. vowels = set(\\"AEIOUaeiou\\") s_list = list(s) left, right = 0, len(s) - 1 while left < right: if s_list[left] not in vowels: left += 1 elif s_list[right] not in vowels: right -= 1 else: s_list[left], s_list[right] = s_list[right], s_list[left] left += 1 right -= 1 return \'\'.join(s_list)"},{"question":"Context You are working on developing a performance-critical application that requires efficient dynamic set operations. Your task is to implement a Red-Black Tree that supports insertion, deletion, and search operations while ensuring that the tree balances itself. Task Implement a Red-Black Tree with the following functionality: 1. `insert(val)`: Inserts a value into the Red-Black Tree. 2. `search(val)`: Searches for a value in the Red-Black Tree. Returns `True` if found, otherwise `False`. 3. `delete(val)`: Deletes a value from the Red-Black Tree if it exists. 4. `inorder()`: Returns a list of dictionaries representing the inorder traversal of the tree. Each node should be represented as `{\'val\': <value>, \'color\': <color>}`. Function Definitions 1. `def insert(self, val: int) -> None` 2. `def search(self, val: int) -> bool` 3. `def delete(self, val: int) -> None` 4. `def inorder(self) -> List[Dict[str, int]]` Constraints 1. Values inserted into the tree are unique integers. 2. Values for insertion and deletion are within the range [1, 10^6]. Example Suppose the tree starts empty: ```python rb_tree = RBTree() rb_tree.insert(10) rb_tree.insert(15) rb_tree.insert(7) print(rb_tree.inorder()) # Output: [{\'val\': 7, \'color\': 1}, {\'val\': 10, \'color\': 0}, {\'val\': 15, \'color\': 1}] print(rb_tree.search(10)) # Output: True print(rb_tree.search(5)) # Output: False rb_tree.delete(15) print(rb_tree.inorder()) # Output: [{\'val\': 7, \'color\': 1}, {\'val\': 10, \'color\': 0}] ``` Implement the `RBTree` and `RBNode` classes with the required methods. Ensure that your tree remains balanced after each insertion and deletion, maintaining all properties of a Red-Black Tree as described.","solution":"class RBNode: def __init__(self, val, color, left=None, right=None, parent=None): self.val = val self.color = color # 0 for Black, 1 for Red self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.TNULL = RBNode(0, 0) # Sentinel node self.root = self.TNULL def insert(self, val): new_node = RBNode(val, 1, self.TNULL, self.TNULL, None) if self.root == self.TNULL: self.root = new_node self.root.color = 0 self.root.parent = None else: self._insert_recursive(self.root, new_node) self._fix_insert(new_node) def search(self, val): return self._search_tree(self.root, val) is not self.TNULL def delete(self, val): node = self._search_tree(self.root, val) if node == self.TNULL: return self._delete_node(node) def inorder(self): return self._inorder_recursive(self.root) def _insert_recursive(self, current, new_node): if new_node.val < current.val: if current.left != self.TNULL: self._insert_recursive(current.left, new_node) else: current.left = new_node new_node.parent = current else: if current.right != self.TNULL: self._insert_recursive(current.right, new_node) else: current.right = new_node new_node.parent = current def _fix_insert(self, node): while node != self.root and node.parent.color == 1: if node.parent == node.parent.parent.right: u = node.parent.parent.left if u.color == 1: u.color = 0 node.parent.color = 0 node.parent.parent.color = 1 node = node.parent.parent else: if node == node.parent.left: node = node.parent self._right_rotate(node) node.parent.color = 0 node.parent.parent.color = 1 self._left_rotate(node.parent.parent) else: u = node.parent.parent.right if u.color == 1: u.color = 0 node.parent.color = 0 node.parent.parent.color = 1 node = node.parent.parent else: if node == node.parent.right: node = node.parent self._left_rotate(node) node.parent.color = 0 node.parent.parent.color = 1 self._right_rotate(node.parent.parent) self.root.color = 0 def _search_tree(self, node, key): if node == self.TNULL or node.val == key: return node if key < node.val: return self._search_tree(node.left, key) return self._search_tree(node.right, key) def _inorder_recursive(self, node): if node == self.TNULL: return [] return self._inorder_recursive(node.left) + [{\'val\': node.val, \'color\': node.color}] + self._inorder_recursive(node.right) def _delete_node(self, node): y = node y_original_color = y.color if node.left == self.TNULL: x = node.right self._transplant(node, node.right) elif node.right == self.TNULL: x = node.left self._transplant(node, node.left) else: y = self._minimum(node.right) y_original_color = y.color x = y.right if y.parent == node: x.parent = y else: self._transplant(y, y.right) y.right = node.right y.right.parent = y self._transplant(node, y) y.left = node.left y.left.parent = y y.color = node.color if y_original_color == 0: self._fix_delete(x) def _transplant(self, u, v): if u.parent == None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def _minimum(self, node): while node.left != self.TNULL: node = node.left return node def _fix_delete(self, x): while x != self.root and x.color == 0: if x == x.parent.left: s = x.parent.right if s.color == 1: s.color = 0 x.parent.color = 1 self._left_rotate(x.parent) s = x.parent.right if s.left.color == 0 and s.right.color == 0: s.color = 1 x = x.parent else: if s.right.color == 0: s.left.color = 0 s.color = 1 self._right_rotate(s) s = x.parent.right s.color = x.parent.color x.parent.color = 0 s.right.color = 0 self._left_rotate(x.parent) x = self.root else: s = x.parent.left if s.color == 1: s.color = 0 x.parent.color = 1 self._right_rotate(x.parent) s = x.parent.left if s.left.color == 0 and s.left.color == 0: s.color = 1 x = x.parent else: if s.left.color == 0: s.right.color = 0 s.color = 1 self._left_rotate(s) s = x.parent.left s.color = x.parent.color x.parent.color = 0 s.left.color = 0 self._right_rotate(x.parent) x = self.root x.color = 0 def _left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def _right_rotate(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y"},{"question":"Radix Sort with Negative Numbers ---- **Problem Statement** Radix sort is a powerful sorting algorithm but it inherently does not handle negative numbers. Your task is to modify the given radix sort implementation to correctly sort an array of integers that includes both positive and negative numbers. **Function Signature** ```python def modified_radix_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` **Input/Output Formats** * **Input**: A list `arr` of integers, which may include both positive and negative numbers. * **Output**: A sorted list of integers in ascending order. **Constraints** * The list `arr` may contain up to (10^6) integers. * The integers in the list can range from (-10^9) to (10^9). **Scenario** You are developing a part of a larger system that processes large datasets of signed integer values. Efficiently sorting these data allows the system to perform tasks such as range queries and median calculations more effectively. **Guidelines** - Consider separating positive and negative numbers. - Sort positive and negative lists individually. - Combine the sorted negative and positive lists carefully, maintaining overall sorting order. - Use the provided radix sort implementation as a starting point. **Solution Evaluation** Your solution will be evaluated on: - Correctness: Accuracy of the implemented sorting logic. - Efficiency: Ability to handle large lists within reasonable time bounds. - Robustness: Handling of edge cases and invalid inputs.","solution":"from typing import List def modified_radix_sort(arr: List[int]) -> List[int]: def radix_sort(arr): max_num = max(arr) exp = 1 while max_num // exp > 0: counting_sort(arr, exp) exp *= 10 def counting_sort(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = arr[i] // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 i -= 1 for i in range(n): arr[i] = output[i] if not arr: return arr negative_part = [-x for x in arr if x < 0] positive_part = [x for x in arr if x >= 0] if negative_part: radix_sort(negative_part) negative_part = [-x for x in reversed(negative_part)] if positive_part: radix_sort(positive_part) return negative_part + positive_part # Test the function inline print(modified_radix_sort([170, -45, 75, -90, -802, 24, 2, 66])) # Output should be: [-802, -90, -45, 2, 24, 66, 75, 170]"},{"question":"# Matrix Inversion Challenge Given an n x n matrix, implement the function `invert_matrix(matrix)` which returns the inverse of the matrix if it is invertible. # Input and Output - **Input**: - An n x n matrix of integers or floats. - **Output**: - An n x n matrix representing the inverse if the matrix is invertible. - Return `[[ErrorCode]]` where ErrorCode is: - `-1` if the input is not a matrix. - `-2` if the matrix is not square. - `-3` if the matrix has fewer than two rows/columns. - `-4` if the determinant is zero (matrix is singular). # Constraints - The size of the matrix (n) is such that 2 ≤ n ≤ 10. - Matrix elements are real numbers. # Performance Requirements - Aim to minimize computations where possible, keeping time complexity in consideration. # Example ```python matrix = [ [4, 7], [2, 6] ] print(invert_matrix(matrix)) # Expected Output: # [[0.6, -0.7], # [-0.2, 0.4]] matrix = [ [1, 2, 3], [0, 1, 4], [5, 6, 0] ] print(invert_matrix(matrix)) # Expected Output: # [[-24, 18, 5], # [20, -15, -4], # [-5, 4, 1]] ``` # Explanation - The function should check for invalid inputs and handle errors gracefully. - For valid matrices, compute the inverse using the steps of calculating minors, cofactors, adjugate, and scaling by the reciprocal of the determinant. # Notes - Make use of helper functions to structure your code effectively. - Pay attention to numerical precision, especially for determinant calculations and scaling.","solution":"import numpy as np def invert_matrix(matrix): Returns the inverse of the matrix if it is invertible. Parameters: matrix (list of list of float): n x n matrix to be inverted Returns: list of list of float: Inverted matrix or error code as specified in the problem. # Check if input is a list of lists if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): return [[-1]] # Error code for input not being a matrix n = len(matrix) # Check if matrix is non-square if n < 2 or any(len(row) != n for row in matrix): return [[-2]] # Error code for matrix not being square or having fewer than two rows/columns try: # Convert to numpy array for easier manipulation np_matrix = np.array(matrix, dtype=float) # Calculate determinant det = np.linalg.det(np_matrix) if np.isclose(det, 0): return [[-4]] # Error code for determinant being zero (matrix is singular) # Calculate inverse inv_matrix = np.linalg.inv(np_matrix) except Exception as e: return [[-1]] # Catch-all for any unexpected errors with matrix manipulation # Convert numpy array back to a regular Python list return inv_matrix.tolist()"},{"question":"Find the Single Number You are given an array of integers `nums` where every element appears twice except for one. Write a function that finds and returns that single number. Your solution must execute in linear time complexity and you cannot use extra memory. Function Signature ```python def single_number(nums: List[int]) -> int: ``` Input * `nums` - A list of integers where every integer appears exactly twice except for one unique integer (1 <= len(nums) <= 10^6). Output * Returns the integer that appears only once in the list. Constraints * Your solution should run in O(n) time complexity. * You should not use any additional memory aside from a constant amount. # Example ```python assert single_number([4, 1, 2, 1, 2]) == 4 assert single_number([2, 2, 1]) == 1 assert single_number([1]) == 1 ``` # Notes * You can assume the input list is non-empty and contains elements where exactly one element appears a single time while all others appear exactly twice. Your task is to implement the `single_number` function that meets the given requirements. Make sure to consider possible edge cases and constraints in your implementation.","solution":"from typing import List def single_number(nums: List[int]) -> int: Finds the single number in the list where every element appears twice except one. unique_number = 0 for number in nums: unique_number ^= number return unique_number"},{"question":"You have been provided with an implementation of a regular expression matching function using dynamic programming. Your task is to extend this implementation to support an additional feature: `{n}`, which matches exactly `n` of the preceding element. Write a function `is_advanced_match(s, p)` that determines whether the input string `s` matches the pattern `p`. The pattern includes: - `.` which matches any single character. - `*` which matches zero or more of the preceding element. - `{n}` which matches exactly `n` of the preceding element, where `n` is a non-negative integer. Function Signature ```python def is_advanced_match(s: str, p: str) -> bool: # Your implementation here ``` Input - `s` (string): The input string. - `p` (string): The pattern string containing \'.\', \'*\', and `{n}`. Output - `bool`: `True` if the string matches the pattern, `False` otherwise. Examples ```python print(is_advanced_match(\\"aa\\", \\"a\\")) # False print(is_advanced_match(\\"aaa\\", \\"a{3}\\")) # True print(is_advanced_match(\\"aa\\", \\"a*\\")) # True print(is_advanced_match(\\"aab\\", \\"c*a*b\\")) # True print(is_advanced_match(\\"abc\\", \\"a.c\\")) # True print(is_advanced_match(\\"abbb\\", \\"ab{3}\\")) # True print(is_advanced_match(\\"abbb\\", \\"ab{2}\\")) # False print(is_advanced_match(\\"abcd\\", \\".*d\\")) # True print(is_advanced_match(\\"abcd\\", \\".{2}cd\\")) # True ``` Constraints - The input strings `s` and `p` will have a length of at most 1000 characters. - The `{n}` in the pattern will always be valid, i.e., `n` will be a non-negative integer and properly formatted. # Notes Make sure to handle edge cases such as: - Empty string and empty pattern. - Patterns with mixed wildcards (e.g., `a{2}*`). - Consecutive usage of special characters, like `*{2}` (which is invalid).","solution":"import re def is_advanced_match(s: str, p: str) -> bool: def preprocess_pattern(p: str) -> str: # Convert {n} into equivalent regex pattern {n} which is recognizable by re module new_pattern = \\"\\" i = 0 while i < len(p): if i < len(p) - 1 and p[i + 1] == \'{\': j = i + 2 while j < len(p) and p[j] != \'}\': j += 1 if j < len(p): new_pattern += f\\"{p[i]}{{{p[i+2:j]}}}\\" i = j + 1 else: new_pattern += p[i] i += 1 else: new_pattern += p[i] i += 1 return new_pattern # Preprocess the pattern to convert {n} into something re can understand preprocessed_pattern = preprocess_pattern(p) # Use the re.fullmatch to check if the entire string matches the pattern return re.fullmatch(preprocessed_pattern, s) is not None"},{"question":"Given an array with `n` objects colored red, white, or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white, and blue (represented by integers 0, 1, and 2 respectively). **Constraints**: * You should not use the library\'s sort function for this problem. * Aim for an algorithm with O(n) time complexity and O(1) space complexity. # Function Signature ```python def sort_colors(nums: List[int]) -> None: ``` # Input * `nums` - A list of integers where each element is either 0, 1, or 2, with `n` being the number of elements in `nums`. # Output * The function does not return anything. It modifies the input list `nums` in place to achieve the desired result: * All 0s appear before all 1s which appear before all 2s. # Scenario Consider a pile of colored balls where 0 represents red, 1 represents white, and 2 represents blue. You want to arrange these balls such that balls of the same color are together and in the order of red, white, and blue. # Example ```python nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Expected Output: [0, 0, 1, 1, 2, 2] ``` # Requirements * Implement a function to sort the list `nums` in-place. * Consider edge cases such as arrays with only one color or already sorted arrays. # Notes * The in-place sorting is crucial - avoid using any additional arrays or employing built-in sort functions. * Validate your solution with multiple test cases to ensure correctness across different input sizes and content.","solution":"from typing import List def sort_colors(nums: List[int]) -> None: Sorts the given list of colors represented by 0, 1, and 2 such that all 0s come first, followed by all 1s, then all 2s. The function modifies the input list in place. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: # nums[mid] == 2 nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"Implement a function to determine the number of ways a given positive integer can be decomposed into a sum of non-negative integers. The function should be optimized for performance and use dynamic programming concepts. Function Signature: ```python def num_decompositions(n: int) -> int: pass ``` Input: - `n` (1 <= n <= 1000): A positive integer that you need to decompose. Output: - Return an integer representing the number of ways to decompose `n`. # Example ```python assert num_decompositions(4) == 5 assert num_decompositions(7) == 15 ``` # Constraints: - The solution must have a time complexity of O(n^2) and a space complexity of O(n^2). - You should handle edge cases appropriately. - Consider writing additional test cases to ensure robustness.","solution":"def num_decompositions(n: int) -> int: Returns the number of ways n can be decomposed into a sum of non-negative integers. # DP table where dp[i][j] will store the number of ways to decompose # integer i using integers up to j dp = [[0 for _ in range(n+1)] for _ in range(n+1)] # Base case: There\'s one way to decompose 0: by using no numbers for i in range(n+1): dp[0][i] = 1 # Fill the DP table for i in range(1, n+1): for j in range(1, n+1): # Number of ways to decompose i without using j dp[i][j] = dp[i][j-1] if i >= j: # Number of ways to decompose i using j at least once dp[i][j] += dp[i-j][j] return dp[n][n]"},{"question":"# Question: RSA Encryption Algorithm Design an RSA encryption system by implementing the following functions `generate_key`, `encrypt`, and `decrypt`. **Function Signatures**: ```python def generate_key(k: int, seed: int = None) -> tuple: Generate RSA public and private keys. Args: k (int): Number of bits in the modulus n. seed (int, optional): Random seed for reproducibility. Returns: tuple: A tuple containing three integers: n, e, d. pass def encrypt(data: int, e: int, n: int) -> int: Encrypt data using the public key (e, n). Args: data (int): Data to be encrypted. e (int): Public exponent. n (int): Modulus. Returns: int: Encrypted data. pass def decrypt(data: int, d: int, n: int) -> int: Decrypt data using the private key (d, n). Args: data (int): Encrypted data. d (int): Private exponent. n (int): Modulus. Returns: int: Decrypted data. pass ``` **Description**: 1. **generate_key(k, seed=None)**: * Generate prime numbers (p) and (q) such that their bit lengths sum to `k`. * Compute the modulus (n = p cdot q). * Set the encryption exponent (e) as a prime number. * Compute the totient (varphi(n) = (p-1) cdot (q-1)). * Determine the decryption exponent (d) as the modular inverse of (e mod varphi(n)). 2. **encrypt(data, e, n)**: * Encrypt an integer `data` using the public key components (e) and (n) by computing ((data^e) mod n). 3. **decrypt(data, d, n)**: * Decrypt the encrypted data using the private key components (d) and (n) by computing ((data^d) mod n). **Inputs**: * `generate_key`: * `k`: an integer representing the number of bits for modulus (n). * `seed`: an optional integer for random number generation reproducibility. * `encrypt`: * `data`: an integer to be encrypted. * `e`: public exponent. * `n`: modulus. * `decrypt`: * `data`: an integer to be decrypted. * `d`: private exponent. * `n`: modulus. **Outputs**: * The function `generate_key` must return a tuple `(n, e, d)`: * `n`: modulus. * `e`: public exponent. * `d`: private exponent. * The functions `encrypt` and `decrypt` return an integer representing the encrypted or decrypted data, respectively. **Example**: ```python k = 16 n, e, d = generate_key(k, seed=42) data = 20 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data ``` **Constraints**: * Ensure efficient key generation and modular arithmetic operations. * Consider algorithmic optimizations and handle edge cases meticulously.","solution":"import random from sympy import isprime, mod_inverse def generate_prime_candidate(length): Generate an odd integer randomly. candidate = random.getrandbits(length) candidate |= (1 << length - 1) | 1 # Ensure it\'s odd and of the desired bit length return candidate def generate_prime_number(length): Generate a prime number of bit length \'length\'. candidate = generate_prime_candidate(length) while not isprime(candidate): candidate = generate_prime_candidate(length) return candidate def generate_key(k: int, seed: int = None) -> tuple: if seed is not None: random.seed(seed) # Generate two large prime numbers p and q p = generate_prime_number(k // 2) q = generate_prime_number(k // 2) n = p * q phi_n = (p - 1) * (q - 1) # Choose an integer e such that 1 < e < phi_n and gcd(e, phi_n) = 1 e = 65537 # It\'s common to choose 65537 for e d = mod_inverse(e, phi_n) return (n, e, d) def encrypt(data: int, e: int, n: int) -> int: return pow(data, e, n) def decrypt(data: int, d: int, n: int) -> int: return pow(data, d, n)"},{"question":"# Pancake Sorting with Constraints and Edge Case Handling Context You have been provided with an unsorted array of integers that needs to be sorted using an unconventional algorithm known as Pancake Sort. Your implementation should ensure that the array is sorted by \\"flipping\\" sub-arrays, mimicking the process of flipping pancakes in a pan. # Problem Statement Given an array of integers, write a function `pancake_sort(arr: List[int]) -> List[int]` that sorts the array in non-decreasing order using the Pancake Sort algorithm. Your function should adhere to the following requirements: # Input * `arr`: A list of integers where (1 leq len(arr) leq 10^3) # Output * Returns a new list of integers sorted in non-decreasing order using Pancake Sort. # Constraints * You must sort the array in-place without using additional data structures. * Your solution should handle edge cases such as already sorted arrays, arrays with a single element, and arrays with repeating elements efficiently. * Since the array may be large, ensure your solution is optimized for performance where possible. # Example ```python # Example 1 arr = [3, 2, 4, 1] print(pancake_sort(arr)) # Output: [1, 2, 3, 4] # Example 2 arr = [10, 5, 2, 7, 8] print(pancake_sort(arr)) # Output: [2, 5, 7, 8, 10] ``` # Special Notes * Write the main steps of your Pancake Sort process as comments in the function to help graders follow your thought process. * Be mindful of edge cases, including very small arrays and arrays with multiple identical elements. * Avoid using built-in sort functions or auxiliary data structures for sorting.","solution":"from typing import List def flip(arr: List[int], k: int) -> None: Reverses the order of the first k elements of the array. left = 0 right = k - 1 while left < right: arr[left], arr[right] = arr[right], arr[left] left += 1 right -= 1 def find_largest(arr: List[int], n: int) -> int: Finds the index of the largest element in the first n elements of arr. max_index = 0 for i in range(1, n): if arr[i] > arr[max_index]: max_index = i return max_index def pancake_sort(arr: List[int]) -> List[int]: Sorts the array in non-decreasing order using the Pancake Sort algorithm. n = len(arr) for size in range(n, 1, -1): # Find the index of the largest element in the current unsorted portion max_index = find_largest(arr, size) # Move the largest element to the end of the current unsorted portion if max_index != size - 1: # Flip the largest element to the front flip(arr, max_index + 1) # Flip the largest element to its final position flip(arr, size) return arr"},{"question":"Context In competitive programming and certain database applications, finding elements quickly in a sorted collection is a crucial task. Optimizing this search can significantly improve the efficiency of these applications. The binary search algorithm is a powerful tool for accomplishing this. Problem Statement Given a sorted array of integers and a target integer, implement a function that efficiently finds the index of the target integer in the array. If the target integer is not present in the array, the function should return -1. # Function Signature ```python def find_index(arr: List[int], target: int) -> int: pass ``` # Input - `arr`: A list of integers sorted in ascending order. - `target`: An integer representing the value to search for. # Output - An integer representing the index of the target in the list. Return -1 if the target is not in the list. # Constraints - The length of the array will be between 1 and 10^5. - The integers in the array will be between -10^9 and 10^9. - Implement an iterative solution with O(log n) time complexity. # Example ```python assert find_index([1, 2, 3, 4, 5, 6], 4) == 3 assert find_index([1, 2, 3, 4, 5, 6], 0) == -1 assert find_index([-10, -5, 0, 3, 7], -5) == 1 ``` Use the analysis provided to ensure your implementation of binary search handles edge cases effectively and meets the performance requirements.","solution":"from typing import List def find_index(arr: List[int], target: int) -> int: Returns the index of the target in arr using binary search. If target is not present, returns -1. left, right = 0, len(arr) - 1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"Context: You are tasked with verifying the integrity of a data transmission process. The transmitted data string `s` is believed to be a merge of two source strings, `part1` and `part2`. However, order integrity in `part1` and `part2` must be preserved, i.e., characters must appear in the same sequence as in the original parts. Problem: Write a function `is_valid_merge(s, part1, part2)` that checks if `s` is a valid merge of `part1` and `part2`. Function Signature: ```python def is_valid_merge(s: str, part1: str, part2: str) -> bool: pass ``` Inputs: - `s`: A string, the merged result. - `part1`: A string, one of the parts used to merge. - `part2`: A string, the other part used to merge. Outputs: - Return `True` if `s` is a valid merge of `part1` and `part2` considering the order of characters in `part1` and `part2`; otherwise, return `False`. Constraints: - The lengths of `s`, `part1`, and `part2` shall not exceed 10^4 characters. Examples: ```python # Example 1 s = \\"codewars\\" part1 = \\"cdw\\" part2 = \\"oears\\" assert is_valid_merge(s, part1, part2) == True # Example 2 s = \\"codewars\\" part1 = \\"cw\\" part2 = \\"oders\\" assert is_valid_merge(s, part1, part2) == False # Example 3 s = \\"\\" part1 = \\"\\" part2 = \\"\\" assert is_valid_merge(s, part1, part2) == True # Example 4 s = \\"a\\" part1 = \\"a\\" part2 = \\"\\" assert is_valid_merge(s, part1, part2) == True # Example 5 s = \\"ab\\" part1 = \\"a\\" part2 = \\"b\\" assert is_valid_merge(s, part1, part2) == True ``` Performance Considerations: The function should be efficient enough to handle the upper constraint limits, where the lengths of the strings can be up to 10^4 characters each.","solution":"def is_valid_merge(s: str, part1: str, part2: str) -> bool: m, n, o = len(part1), len(part2), len(s) if m + n != o: return False dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True for i in range(m + 1): for j in range(n + 1): if i > 0 and s[i + j - 1] == part1[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] if j > 0 and s[i + j - 1] == part2[j - 1]: dp[i][j] = dp[i][j] or dp[i][j - 1] return dp[m][n]"},{"question":"# Linked List Order Reversal You are provided with a singly linked list and asked to reverse it in-place. Your task is to implement a function that takes the head of the linked list and returns the new head of the reversed list. Function Signature: ```python class ListNode: def __init__(self, x): self.val = x self.next = None def reverse_linked_list(head: ListNode) -> ListNode: # Your code here ``` # Input: - The function `reverse_linked_list` receives the head of a singly linked list. # Output: - The function should return the new head of the reversed singly linked list. # Constraints: - The linked list can have up to 10^5 nodes. - Node values follow the constraint of typical integer values (`-10^3 <= node.val <= 10^3`). # Examples: 1. Example 1: - Input: `1 --> 2 --> 3 --> 4` - Output: `4 --> 3 --> 2 --> 1` 2. Example 2: - Input: `1` - Output: `1` 3. Example 3: - Input: `None` - Output: `None` # Context: Consider a scenario where you need to undo actions represented as a linked list. Reversing the list helps you to access the last action first. # Note: Make sure your implementation handles both the edge cases of an empty list and a single-element list correctly.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def reverse_linked_list(head: ListNode) -> ListNode: prev = None current = head while current is not None: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"# Coding Challenge: Next Higher Permutation of Digits Given a number, your task is to write a function that finds the next higher number that consists of the exact same set of digits as the original number. If no such number exists, return -1. Function Signature `def next_higher_permutation(num: int) -> int:` Input * A single integer `num` where `0 <= num <= 10^18`. Output * Return an integer which is the next higher number with the same set of digits, or -1 if no such number exists. Constraints * You may assume that the input number does not have leading zeros. * The function should handle numbers up to 18 digits long efficiently. Example 1. `next_higher_permutation(38276)` should return `38627` 2. `next_higher_permutation(99999)` should return `-1` 3. `next_higher_permutation(12345)` should return `12354` 4. `next_higher_permutation(1528452)` should return `1528524` Hints * Think about how permutations work and what properties of digits allow for finding the next permutation. * Make sure to handle edge cases where the number is already the highest possible permutation of its digits. Happy coding!","solution":"def next_higher_permutation(num: int) -> int: digits = list(str(num)) n = len(digits) # Step 1: Find the first digit that can be made bigger by a swap going from right to left i = n - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 if i == -1: # If no such digit is found, num is the highest permutation return -1 # Step 2: Find the smallest digit on right side of (i-th digit) which is greater than digits[i] j = n - 1 while digits[j] <= digits[i]: j -= 1 # Step 3: Swap digits[i] and digits[j] digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the digits after the i-th position digits = digits[:i+1] + sorted(digits[i+1:]) return int(\\"\\".join(digits))"},{"question":"# Power of Two Determination **Objective**: Write a function to determine if a given integer is a power of two. Your implementation should leverage bit manipulation to achieve a constant time complexity solution. **Function Signature**: ```python def is_power_of_two(n: int) -> bool: ``` **Input**: - `n`: An integer, can be positive, negative, or zero. **Output**: - Returns `True` if `n` is a power of two, otherwise returns `False`. **Constraints**: - Assume that the integer input lies within the range of standard 32-bit signed integers (`-2^31` to `2^31 - 1`). **Performance Requirements**: - The solution must execute in constant time, O(1). **Examples**: ```python assert is_power_of_two(1) == True # 2^0 assert is_power_of_two(16) == True # 2^4 assert is_power_of_two(3) == False assert is_power_of_two(0) == False assert is_power_of_two(-16) == False ``` **Scenario**: Imagine you are building a system that deals with allocation of memory, where you need to quickly validate that requested memory sizes are powers of two. Integrate this function to streamline the checks in your system\'s memory management module. **Edge Cases to Consider**: - Ensure the function returns `False` for zero and negative numbers. - Verify correct handling of very large positive numbers within the 32-bit signed integer range. **Hints**: - Consider the properties of binary representation where a number that is a power of two has exactly one bit set to `1`. - Utilize the bitwise AND operation to simplify your solution.","solution":"def is_power_of_two(n: int) -> bool: Determines if a given integer is a power of two. :param n: An integer, can be positive, negative, or zero. :return: True if n is a power of two, otherwise False. if n <= 0: return False # A number n is a power of two if n & (n-1) == 0 and n > 0 return (n & (n - 1)) == 0"},{"question":"# Coding Challenge # Scenario You are tasked with writing a function to generate all unique permutations of a list of integers that may contain duplicates. This is commonly required in problems involving combination generation where duplicates need special handling to avoid redundant results. # Problem Statement Write a function `permute_unique(nums)` that takes a list of integers `nums` and returns a list of lists, where each list is a unique permutation of `nums`. # Function Signature ```python def permute_unique(nums: List[int]) -> List[List[int]]: ``` # Input * `nums`: A list of integers that may contain duplicates. (`0 <= len(nums) <= 10`, `-10 <= nums[i] <= 10`) # Output * A list of lists, where each inner list is a unique permutation of `nums`. # Example ```python assert permute_unique([1,1,2]) == [[1,1,2], [1,2,1], [2,1,1]] assert permute_unique([1,2,3]) == [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] assert permute_unique([]) == [[]] ``` # Constraints * Determine the time and space complexity of your implementation. * Ensure that the function works efficiently for the worst-case input sizes. # Notes * You should ensure your function avoids generating duplicate permutations. * Consider edge cases like empty lists or lists with all identical elements. --- Implement your solution in Python, ensuring it adheres to the problem constraints and requirements.","solution":"from typing import List from itertools import permutations def permute_unique(nums: List[int]) -> List[List[int]]: Returns all unique permutations of the list \'nums\'. # Use a set to store unique permutations to avoid duplicates unique_permutations = set(permutations(nums)) # Convert each permutation from tuple back to list return [list(p) for p in unique_permutations]"},{"question":"# Atbash Cipher Coding Challenge **Scenario**: You are developing a software that includes a simple encryption mechanism for educational purposes. One of the ciphers you need to implement is the Atbash cipher. Given the high level of simplicity and quick operation, this cipher fits well into your application. **Task**: Implement a function `atbash` that takes a string and returns its Atbash cipher equivalent. The function should preserve the case of the letters and leave non-alphabet characters unchanged. Recall that the Atbash cipher maps \'a\' to \'z\', \'b\' to \'y\', and so on for both upper and lower case letters. **Function Signature**: ```python def atbash(s: str) -> str: ``` **Input**: - `s` (String): A string of printable ASCII characters. **Output**: - Returns the Atbash ciphered string. **Constraints**: - The input string `s` can be of length 0 to 10^5. - The function should run efficiently within time complexity O(n). **Examples**: 1. `atbash(\\"Attack at dawn\\")` should return `\\"Zggzxp zg wzdm\\"`. 2. `atbash(\\"Hello, World!\\")` should return `\\"Svool, Dliow!\\"`. 3. `atbash(\\"abcdefghijklmnopqrstuvwxyz\\")` should return `\\"zyxwvutsrqponmlkjihgfedcba\\"`. 4. `atbash(\\"\\")` should return `\\"\\"`. **Note**: - Make sure to handle both upper case and lower case letters correctly. - Non-alphabet characters should remain unchanged in their respective positions. **Edge Cases**: - An empty string should return an empty string. - Input with no alphabetic characters should return the same string. Good luck!","solution":"def atbash(s: str) -> str: def transform(char): if \'a\' <= char <= \'z\': return chr(219 - ord(char)) # \'a\' + (\'z\' - char) elif \'A\' <= char <= \'Z\': return chr(155 - ord(char)) # \'A\' + (\'Z\' - char) return char return \'\'.join(map(transform, s))"},{"question":"# Question: Binary Tree Minimum Depth Calculation **Context:** You are developing a functionality to determine the minimum depth of a given binary tree. The minimum depth of a binary tree is the number of nodes along the shortest path from the root node down to the nearest leaf node. Your task is to implement this feature both recursively and iteratively. **Task:** Implement two functions, `min_depth` and `min_height`, to calculate the minimum depth of a binary tree. **Function Signatures:** ```python def min_depth(root: TreeNode) -> int: Parameters: - root (TreeNode): The root node of the binary tree. Returns: - int: The minimum depth of the tree. def min_height(root: TreeNode) -> int: Parameters: - root (TreeNode): The root node of the binary tree. Returns: - int: The minimum depth of the tree. ``` **Constraints:** - The number of nodes in the tree is in the range [0, 10^4]. - -1000 <= Node.val <= 1000 **Performance Requirements:** - Time complexity should be O(n), where n is the number of nodes in the binary tree. - Space complexity should account for both call stacks in the recursive approach and queue usage in the iterative approach. **Additional Function for Testing:** Include a function to create a binary tree node and a sample tree for testing. ```python class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def create_sample_tree() -> TreeNode: root = TreeNode(10) root.left = TreeNode(12) root.right = TreeNode(15) root.left.left = TreeNode(25) root.left.left.right = TreeNode(100) root.left.right = TreeNode(30) root.right.left = TreeNode(36) return root ``` **Objective:** Implement both `min_depth` and `min_height` to compute the minimum depth accurately and efficiently. Ensure to handle edge cases such as empty trees and skewed trees.","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def min_depth(root: TreeNode) -> int: Recursively find the minimum depth of the binary tree. Parameters: - root (TreeNode): The root node of the binary tree. Returns: - int: The minimum depth of the tree. if not root: return 0 if not root.left and not root.right: return 1 if not root.left: return min_depth(root.right) + 1 if not root.right: return min_depth(root.left) + 1 return min(min_depth(root.left), min_depth(root.right)) + 1 def min_height(root: TreeNode) -> int: Iteratively find the minimum depth of the binary tree using BFS. Parameters: - root (TreeNode): The root node of the binary tree. Returns: - int: The minimum depth of the tree. if not root: return 0 queue = deque([(root, 1)]) # Store nodes along with their depth while queue: current, depth = queue.popleft() # Check if it\'s a leaf node if not current.left and not current.right: return depth if current.left: queue.append((current.left, depth + 1)) if current.right: queue.append((current.right, depth + 1)) def create_sample_tree() -> TreeNode: root = TreeNode(10) root.left = TreeNode(12) root.right = TreeNode(15) root.left.left = TreeNode(25) root.left.left.right = TreeNode(100) root.left.right = TreeNode(30) root.right.left = TreeNode(36) return root"},{"question":"# Zigzag Iterator for Multiple Lists Problem Statement Design a Zigzag Iterator that takes multiple lists (instead of just two) and returns elements in a round-robin fashion. The iterator should be initialized with a list of lists, and during each call to the `next()` method, it should return the next element from the lists in a cyclic order. Function Signatures ```python class ZigzagIterator: def __init__(self, vecs: List[List[int]]): Initialize your data structure here. :param vecs: List of lists of integers. pass def next(self) -> int: Return the next element in the sequence. :return: The next integer in the zigzag order pass def has_next(self) -> bool: :return: True if there are still elements in any list, False otherwise. pass ``` # Input / Output Specifications * **Input**: - A list of lists `vecs` where each sublist contains integer elements (e.g., `[[1, 2], [3, 4, 5, 6], [7, 8, 9]]`). * **Output**: - `next()`: Returns the next integer in the zigzag order. - `has_next()`: Returns `True` if there are elements remaining in any of the lists. # Constraints * You may assume that `vecs` will have a non-negative number of lists and the integers within these lists will be non-negative. * Your implementation should aim for `O(1)` time complexity for `next()` and `has_next()` methods concerning the number of lists. * Handle edge cases like empty lists or lists of unequal lengths gracefully. Example ```python vecs = [[1, 2], [3, 4, 5, 6], [7, 8, 9]] it = ZigzagIterator(vecs) result = [] while it.has_next(): result.append(it.next()) print(result) ``` Expected Output: `[1, 3, 7, 2, 4, 8, 5, 9, 6]` Explanation 1. Start from the first element in the first list: `1` 2. Move to the first element in the second list: `3` 3. Move to the first element in the third list: `7` 4. Go back to the second element in the first list: `2` 5. Continue this round-robin selection until all elements from all lists are exhausted. # Implementation Note Ensure your code handles lists of varying lengths and appropriately exits the iteration mechanism when all lists are completely traversed.","solution":"from collections import deque class ZigzagIterator: def __init__(self, vecs): Initialize your data structure here. :param vecs: List of lists of integers. self.queue = deque() for vec in vecs: if vec: self.queue.append(deque(vec)) def next(self): Return the next element in the sequence. :return: The next integer in the zigzag order if not self.has_next(): return None current_list = self.queue.popleft() next_elem = current_list.popleft() if current_list: self.queue.append(current_list) return next_elem def has_next(self): :return: True if there are still elements in any list, False otherwise. return bool(self.queue)"},{"question":"# Combination Sum Problem with Constraints **Context:** You are given an integer array with all positive numbers and no duplicates. You need to find the number of possible combinations that add up to a positive integer target. Your approach should demonstrate understanding of both top-down and bottom-up dynamic programming strategies. The problem should handle normal scenarios as well as edge cases efficiently. **Objective:** Write two functions, one for the top-down dynamic programming approach and one for the bottom-up dynamic programming approach, to find the number of possible combinations of elements in the array that sum to the target. **Input:** * `nums`: List of unique positive integers. * `target`: A positive integer. **Output:** * An integer indicating the number of possible combinations for the given target. **Constraints:** * All elements in `nums` are positive and unique. * The array size will not exceed 20. * The target value will not exceed 1000. **Function Signatures:** ```python def combination_sum_topdown(nums: List[int], target: int) -> int: pass def combination_sum_bottom_up(nums: List[int], target: int) -> int: pass ``` **Example:** ```python nums = [1, 2, 3] target = 4 combination_sum_topdown(nums, target) # Output: 7 combination_sum_bottom_up(nums, target) # Output: 7 ``` **Follow-up:** 1. How would your solution change if negative numbers were allowed in the given array? 2. What constraints are necessary to prevent infinite loops or incorrect results with negative numbers?","solution":"from typing import List def combination_sum_topdown(nums: List[int], target: int) -> int: Top-down dynamic programming approach to find the number of combinations that sum up to the target. memo = {} def helper(remaining: int) -> int: if remaining == 0: return 1 if remaining in memo: return memo[remaining] res = 0 for num in nums: if remaining >= num: res += helper(remaining - num) memo[remaining] = res return res return helper(target) def combination_sum_bottom_up(nums: List[int], target: int) -> int: Bottom-up dynamic programming approach to find the number of combinations that sum up to the target. dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for num in nums: if i >= num: dp[i] += dp[i - num] return dp[target]"},{"question":"# Subtree Detection in Binary Trees In this question, you are tasked with determining if a given binary tree `small` is a subtree of another binary tree `big`. Function Signature ```python def is_subtree(big: TreeNode, small: TreeNode) -> bool: ``` Input - `big`: A binary tree represented by its root node, `big` (type `TreeNode`). - `small`: A binary tree represented by its root node, `small` (type `TreeNode`). Both `TreeNode` objects have the following structure: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` Output - The function should return a boolean value `True` if `small` is a subtree of `big`, and `False` otherwise. Constraints and Limitations 1. The number of nodes in `big` and `small` can be up to 10,000. 2. Node values are between `-10000` and `10000`. 3. Both trees may contain duplicate values. 4. Optimize your solution for the case where `big` is significantly larger than `small`. Performance Requirements - Aim for an optimal balance between time complexity and space complexity within the constraint limits. Example ```python # Example 1 # Given big tree: # 3 # / # 4 5 # / # 1 2 # Given small tree: # 4 # / # 1 2 # Result: True, as the small tree is a subtree of the big tree. # Example 2 # Given big tree: # 3 # / # 4 5 # / # 1 2 # / # 0 # Given small tree: # 3 # / # 4 # / # 1 2 # Result: False, the subtree is structurally similar but not an exact match. # Test cases should consider various tree structures and ensure edge cases are covered. ``` You should implement the `is_subtree` function to pass all relevant test cases intelligently and efficiently. Ensure your code handles the edge cases and constraints provided.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_subtree(big: TreeNode, small: TreeNode) -> bool: if not small: # An empty tree is always a subtree return True if not big: # If big is empty but small is not, small cannot be a subtree return False def are_identical(root1: TreeNode, root2: TreeNode) -> bool: if not root1 and not root2: return True if root1 and root2 and root1.val == root2.val: return (are_identical(root1.left, root2.left) and are_identical(root1.right, root2.right)) return False # Traverse the big tree to check for subtree match def traverse(big: TreeNode, small: TreeNode) -> bool: if not big: return False if are_identical(big, small): return True return traverse(big.left, small) or traverse(big.right, small) return traverse(big, small)"},{"question":"You are given an array of non-negative integers. Implement an optimized version of the bucket sort algorithm that can handle large datasets more efficiently by using a more optimal sorting algorithm for sorting elements within each bucket. The input numbers can also have large values. Function Signature ```python def optimized_bucket_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr` (List[int]): The list of non-negative integers to be sorted. # Output * `List[int]`: A list of sorted integers. # Constraints * The number of integers `n` in the array satisfies 1 <= n <= 10^5. * The integers in the array can be as large as 10^9. # Examples ```python assert optimized_bucket_sort([3, 1, 2, 7, 5, 8, 4]) == [1, 2, 3, 4, 5, 7, 8] assert optimized_bucket_sort([9, 2, 6, 4, 3, 5, 8, 7, 1]) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert optimized_bucket_sort([]) == [] ``` # Explanation 1. **Bucket Creation**: The number of buckets should be based on the input size. 2. **Bucket Assignment**: Use appropriate logic to assign each array element to the correct bucket. 3. **Sorting Within Buckets**: Sort elements within each bucket using a more efficient sorting algorithm like merge sort if the bucket size is large. 4. **Merge Sorted Buckets**: Combine the sorted buckets to produce the final sorted list. # Notes - Ensure efficient sorting within buckets to make the algorithm handle large datasets effectively. - Additional boundary checking and error handling should be considered for edge cases and large values.","solution":"from typing import List import itertools def optimized_bucket_sort(arr: List[int]) -> List[int]: if not arr: return [] # Determine number of buckets num_buckets = len(arr) max_value = max(arr) bucket_size = max(1, max_value // num_buckets) # Create buckets buckets = [[] for _ in range((max_value // bucket_size) + 1)] # Distribute array elements into buckets for i in range(len(arr)): bucket_index = min(arr[i] // bucket_size, len(buckets) - 1) buckets[bucket_index].append(arr[i]) # Sort individual buckets for bucket in buckets: bucket.sort() # Using Python\'s Timsort # Merge sorted buckets sorted_arr = list(itertools.chain(*buckets)) return sorted_arr"},{"question":"# Dynamic Programming: Counting Unique Paths in a Grid You are given a grid of dimensions (m times n) representing a robot\'s workspace. The robot starts at the top-left corner of the grid (cell (0, 0)) and aims to reach the bottom-right corner of the grid (cell (m-1, n-1)). The robot can only move either right or down at any point in time. Write a function `unique_paths(m, n)` that calculates the number of unique paths the robot can take to reach its goal. # Input * An integer `m` (1 ≤ m ≤ 100). * An integer `n` (1 ≤ n ≤ 100). # Output * An integer representing the number of unique paths from the top-left corner to the bottom-right corner of the grid. # Constraints * Assume all cells in the grid are traversable. * (m) and (n) will always be positive integers. # Example ```py def unique_paths(m, n): # Solution here print(unique_paths(3, 7)) # Output: 28 print(unique_paths(3, 2)) # Output: 3 ``` # Explanation * For `m = 3` and `n = 7`, the robot can take 28 unique paths from the top-left to the bottom-right corner of the grid. * For `m = 3` and `n = 2`, the robot can take 3 unique paths. Your task is to implement the `unique_paths` function to solve the problem.","solution":"def unique_paths(m, n): Calculate the number of unique paths the robot can take to reach its goal. :param m: int: number of rows in the grid :param n: int: number of columns in the grid :return: int: number of unique paths # Create a 2D array with m rows and n columns initialized to 0 dp = [[0] * n for _ in range(m)] # Initialize the first row and first column to 1 for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Compute number of paths for each cell in the grid for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"# Scenario: You are a software engineer tasked with maintaining a networking application that uses linked lists to handle dynamically changing data efficiently. Your team has detected performance issues when deleting nodes from the list since it requires access to the head of the list followed by traversing to locate the node. To optimize, you decide to implement a function that deletes a node from a singly linked list given only access to that node. This approach helps reduce time complexity by eliminating the need to traverse the list for node deletion. # Task: Write a function `delete_node(node: Node) -> None` that deletes a node (except the tail) in a singly linked list, given only access to that node. The node will be an instance of the `Node` class where `Node.val` is an integer and `Node.next` is either another `Node` or `None`. # Input: * `node` (Node): The node to be deleted. It is guaranteed not to be the last node of the linked list. # Output: * The function should not return any value. It should modify the linked list in place. # Constraints: * The node provided will not be the last node of the linked list and will always be a valid node that exists in the list. * You should not access any part of the list directly except through the given node. # Example: Given a linked list `1 -> 2 -> 3 -> 4` and you are provided the third node (`val` = 3), calling your function should result in the linked list `1 -> 2 -> 4`. ```python class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node: Node) -> None: # Your code here # Example usage: # head = Node(1) # head.next = Node(2) # node_to_delete = head.next.next = Node(3) # head.next.next.next = Node(4) # delete_node(node_to_delete) # Expected linked list after deletion: 1 -> 2 -> 4 ``` Write the `delete_node` function based on the specification above.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node: Node) -> None: Deletes the given node (except the tail) from the singly linked list. The input node will not be the tail node. if node is None or node.next is None: raise Exception(\\"The node to be deleted should not be the tail node or None.\\") # Copy the data from the next node to the current node node.val = node.next.val # Point the current node to the next\'s next node node.next = node.next.next"},{"question":"# Level Order Traversal in Reverse Given a binary tree, return the level order traversal of its nodes\' values arranged from the bottom up (i.e., starting from the lowest level, from left to right, and moving upwards). **Example:** Given binary tree `[3, 9, 20, null, null, 15, 7]`, ``` 3 / 9 20 / 15 7 ``` return its reverse level order traversal as: ``` [ [15, 7], [9, 20], [3] ] ``` Function Signature ```python def reverse_level_order(root: TreeNode) -> List[List[int]]: ``` # Input * `root` - The root of the binary tree. A single node, potentially with children. # Output * A list of lists of integers, each representing the values of nodes at each level of the tree, starting from the bottom level to the root. # Constraints 1. The number of nodes in the binary tree is in the range `[0, 10^4]`. 2. The tree node values are integers. # Requirements * Handle empty tree scenario. * The solution must have a time complexity of O(n) and space complexity of O(n). # Example Usage ```python # Assuming TreeNode is a pre-defined class for the binary tree nodes # with attributes val (int), left (TreeNode), and right (TreeNode) # Example usage: # Given the tree structure as shown in the example # root = TreeNode(3) # ... (populate the tree) result = reverse_level_order(root) assert result == [[15, 7], [9, 20], [3]] ``` Take care of edge cases and ensure efficient memory usage.","solution":"from collections import deque from typing import List, Optional # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def reverse_level_order(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = deque() queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.appendleft(level_nodes) return list(result)"},{"question":"# Question: Histogram Dictionary Generation Background A histogram provides an accurate representation of data distribution. It\'s essential for statistical analysis and data visualization. In this task, you are required to implement a function that generates a histogram from an input list of numbers. The histogram should be represented as a dictionary where keys are the unique elements from the list, and values are their respective frequencies. Task Write a function `generate_histogram` that takes a list of integers as input and returns a dictionary representing the histogram of the list. Function Signature ```python def generate_histogram(input_list: List[int]) -> Dict[int, int]: pass ``` Input - `input_list`: A list of integers. (1 <= len(input_list) <= 10^7) Output - A dictionary where keys are the unique integers from the input list, and values are their frequencies in the list. Constraints - Each element in `input_list` is an integer (1 <= element <= 10^6). - The input list may contain up to 10 million elements. Performance Requirements - The solution should work efficiently for input lists containing up to 10 million elements. Example ```python # Example 1 input_list = [3, 3, 2, 1] # Expected Output: {1: 1, 2: 1, 3: 2} # Example 2 input_list = [2, 3, 5, 5, 5, 6, 4, 3, 7] # Expected Output: {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} ``` Note - Ensure your function handles edge cases, such as empty lists and lists with identical elements.","solution":"from typing import List, Dict def generate_histogram(input_list: List[int]) -> Dict[int, int]: Generates a histogram (frequency dictionary) from the input list of integers. Args: input_list (List[int]): A list of integers. Returns: Dict[int, int]: A dictionary where keys are the unique integers from the list, and values are their frequencies. histogram = {} for number in input_list: if number in histogram: histogram[number] += 1 else: histogram[number] = 1 return histogram"},{"question":"# Bitwise Manipulation Functions You are provided with four fundamental bit manipulation functions that perform operations on specific bits of an integer. Write a new function named `mask_bits` that takes the following parameters: * `num`: The integer whose bits are to be manipulated. * `mask`: Another integer representing which bits to manipulate. * `operation`: A string that specifies the type of operation to perform. It can be one of `\\"get\\"`, `\\"set\\"`, `\\"clear\\"`, or `\\"update\\"`. * `update_value`: An integer (either 0 or 1) needed only for the `\\"update\\"` operation to specify the value to which the bit should be set. This parameter can be ignored for other operations. The `mask_bits` function should apply the specified operation to each bit of `num` at positions where the corresponding bit in the `mask` is set to 1, and return the resulting integer. Input Format * `num`: an integer. * `mask`: an integer. * `operation`: a string, one of `\\"get\\"`, `\\"set\\"`, `\\"clear\\"`, or `\\"update\\"`. * `update_value`: an integer (0 or 1), required only for `\\"update\\"` operation. Output Format * The resulting integer after applying the specified operation on `num` using the bit positions defined by `mask`. Constraints 1. `0 <= num, mask < 2^31` 2. The length of `operation` string is small. 3. For the `update` operation, `update_value` is either 0 or 1. Examples Example 1: ```python input: num = 42, mask = 5, operation = \\"set\\" output: 47 ``` Example 2: ```python input: num = 42, mask = 8, operation = \\"clear\\" output: 34 ``` Example 3: ```python input: num = 15, mask = 2, operation = \\"update\\", update_value = 0 output: 13 ``` Function Signature ```python def mask_bits(num: int, mask: int, operation: str, update_value: int = None) -> int: pass ``` # Note: * For the \\"get\\" operation, return a binary representation of the bits in `num` that correspond to the set bits in `mask`. * Ensure that your function handles edge cases, such as invalid operations or indices out of range.","solution":"def mask_bits(num: int, mask: int, operation: str, update_value: int = None) -> int: if operation == \\"get\\": return num & mask elif operation == \\"set\\": return num | mask elif operation == \\"clear\\": return num & (~mask) elif operation == \\"update\\": if update_value not in (0, 1): raise ValueError(\\"update_value must be either 0 or 1\\") if update_value == 0: return num & (~mask) else: return num | mask else: raise ValueError(\\"Invalid operation\\") # Examples # mask_bits(42, 5, \\"set\\") -> 47 # mask_bits(42, 8, \\"clear\\") -> 34 # mask_bits(15, 2, \\"update\\", 0) -> 13"},{"question":"# Filter-based Array Slicing Objective You are tasked with implementing a function that filters elements from an array based on inclusive lower and upper bounds. Specifically, you will create subarrays that include only elements falling within given ranges. Function Signature ```python def filter_within_range(arr: List[int], lower_bound: Optional[int], upper_bound: Optional[int]) -> List[int]: ``` Input and Output Formats * **Input**: - arr: A list of integers, `arr` (0 ≤ len(arr) ≤ 10^5). - lower_bound: An optional integer, `lower_bound` (if None, consider the minimum value in `arr`). - upper_bound: An optional integer, `upper_bound` (if None, consider the maximum value in `arr`). * **Output**: - A list of integers containing only elements that satisfy the filtering condition (`lower_bound ≤ element ≤ upper_bound`). Constraints * All elements of `arr` are integers within the range of [-10^9, 10^9]. * If `arr` is empty, return an empty list. * If both bounds are `None`, return the array unmodified. * Ensure your solution runs efficiently with a time complexity of O(n). Example ```python assert filter_within_range([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert filter_within_range([10, 20, 30, 40], 15, 35) == [20, 30] assert filter_within_range([], 1, 2) == [] assert filter_within_range([5, 7, 9], 10, None) == [] ``` # Scenario/Context Imagine you are a data analyst working with large datasets containing numerical entries. Before conducting any analysis, you need to filter out entries that do not fall within a specified range. This preprocessing step is crucial for ensuring the accuracy and relevance of subsequent analyses. Your task is to write the `filter_within_range` function that performs this filtering efficiently.","solution":"from typing import List, Optional def filter_within_range(arr: List[int], lower_bound: Optional[int], upper_bound: Optional[int]) -> List[int]: Filters elements from arr based on inclusive lower and upper bounds. If lower_bound is None, consider the smallest element in arr as lower bound. If upper_bound is None, consider the largest element in arr as upper bound. Args: arr: List of integers to filter. lower_bound: Optional integer for the lower bound. upper_bound: Optional integer for the upper bound. Returns: List of integers within the specified bounds. if not arr: return [] if lower_bound is None: lower_bound = min(arr) if upper_bound is None: upper_bound = max(arr) return [x for x in arr if lower_bound <= x <= upper_bound]"},{"question":"**Context**: You are tasked with developing a sorting utility for a high-frequency trading system where the input dataset can be very large and involves timestamps represented as floating-point numbers between `[0.0, 1.0)`. **Task**: Implement the `optimized_bucket_sort` function, which sorts an array of floating-point numbers using the Bucket Sort algorithm with Optimized Bucketing. Instead of using the Insertion Sort for sorting individual buckets (like in standard implementation), you will improve it utilizing the Merge Sort algorithm. **Function Signature**: ```python def optimized_bucket_sort(arr: List[float]) -> List[float]: ``` # Requirements and Constraints - **Input**: A list of floating-point numbers `arr` with length `n` (1 ≤ n ≤ 10^6) where `0.0 ≤ arr[i] < 1.0`. - **Output**: A sorted list of floating-point numbers. - **Performance**: Your algorithm should aim for an average case time complexity of O(n log n). - You **must use Merge Sort** as the secondary sorting algorithm for sorting elements within each bucket. # Performance: - Target time complexity must handle the given sizes under typical distributions (aim for O(n log n) on average). - Space complexity should be efficiently managed with sub-linear auxiliary space constraints. # Implementation Details 1. **Bucketing strategy**: Ensure correct calculation and assignment of values into respective buckets. 2. **Sorting Each Bucket**: Use Merge Sort for sorting the elements within each bucket. 3. **Merging Results**: Combine sorted buckets to form the final sorted array.","solution":"from typing import List def merge_sort(arr: List[float]) -> List[float]: if len(arr) <= 1: return arr mid = len(arr) // 2 left = arr[:mid] right = arr[mid:] left = merge_sort(left) right = merge_sort(right) return merge(left, right) def merge(left: List[float], right: List[float]) -> List[float]: sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list def optimized_bucket_sort(arr: List[float]) -> List[float]: if len(arr) == 0: return arr # Number of buckets n = len(arr) buckets = [[] for _ in range(n)] # Distribute input array values into buckets for value in arr: bucket_index = int(n * value) buckets[bucket_index].append(value) # Sort each bucket and concatenate them sorted_array = [] for bucket in buckets: sorted_array.extend(merge_sort(bucket)) return sorted_array"},{"question":"**Binary Search Tree Count of Nodes in Left Subtree** You are provided with a binary search tree and a function that calculates the height of the tree. Your task is to implement a function `count_left_nodes(root)` that returns the number of nodes in the left subtree of the root node of the given binary search tree. * **Input**: The root node of a binary search tree (BST). The tree is represented by nodes with the structure: ```python class Node: def __init__(self, key): self.left = None self.right = None self.val = key ``` * **Output**: Return an integer representing the number of nodes in the left subtree of the root node. * **Constraints**: * The BST can have up to 10,000 nodes. * The node values are unique and follow the BST properties. * **Performance Requirements**: The function should aim for O(n) time complexity, where n is the number of nodes in the subtree. **Example**: Given the binary search tree: ```plaintext 9 / 6 12 / / 3 8 10 15 / 7 18 ``` The left subtree of the root node `9` is: ```plaintext 6 / 3 8 7 ``` So, the function should return `4`. **Solution Template**: ```python class Node: def __init__(self, key): self.left = None self.right = None self.val = key def count_left_nodes(root): if root is None or root.left is None: return 0 def count_nodes(node): if node is None: return 0 return 1 + count_nodes(node.left) + count_nodes(node.right) return count_nodes(root.left) ``` **Testing**: Implement a set of unit tests similar to the provided `TestSuite` class to ensure your function\'s accuracy. Consider edge cases like an empty tree, a single-node tree, and larger balanced/unbalanced trees.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def count_left_nodes(root): Returns the number of nodes in the left subtree of the root node. if root is None or root.left is None: return 0 def count_nodes(node): if node is None: return 0 return 1 + count_nodes(node.left) + count_nodes(node.right) return count_nodes(root.left)"},{"question":"You are tasked with enhancing the given substring search function to make it more efficient for large texts. The current function is provided below for reference: ```python def contain_string(haystack, needle): if len(needle) == 0: return 0 if len(needle) > len(haystack): return -1 for i in range(len(haystack)): if len(haystack) - i < len(needle): return -1 if haystack[i:i+len(needle)] == needle: return i return -1 ``` **Improvement Requirement**: Re-implement the function using the Knuth-Morris-Pratt (KMP) algorithm to enhance the search efficiency. # Function Signature ```python def improved_contain_string(haystack: str, needle: str) -> int: ``` # Input * `haystack` (str): The string in which to search for the substring. * `needle` (str): The substring to search for. # Output * Returns the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack`. # Constraints 1. Both `haystack` and `needle` consist only of lowercase English characters. 2. The length of `haystack` and `needle` will be between 0 and 10^4. # Performance Requirements * The solution must have a better time complexity than the existing brute-force solution. # Implementation Details 1. Implement the KMP algorithm for substring search. 2. Create the \\"partial match\\" table (also known as the \\"failure function\\") to ensure efficient backtracking. 3. Use this table to scan through `haystack`, ensuring that the overall complexity remains linear relative to the input size. # Example ```python # Example 1: input_haystack = \\"hello\\" input_needle = \\"ll\\" assert improved_contain_string(input_haystack, input_needle) == 2 # Example 2: input_haystack = \\"aaaaa\\" input_needle = \\"bba\\" assert improved_contain_string(input_haystack, input_needle) == -1 # Example 3: input_haystack = \\"abcabcabcd\\" input_needle = \\"abcd\\" assert improved_contain_string(input_haystack, input_needle) == 6 ``` Encourage students to handle all edge cases and optimize the solution as much as possible.","solution":"def improved_contain_string(haystack, needle): def build_lps(pattern): lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps if len(needle) == 0: return 0 lps = build_lps(needle) i = 0 j = 0 while i < len(haystack): if needle[j] == haystack[i]: i += 1 j += 1 if j == len(needle): return i - j elif i < len(haystack) and needle[j] != haystack[i]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"**Secure Messaging with Diffie-Hellman Key Exchange** **Context**: Alice and Bob want to share a secret key using the Diffie-Hellman Key Exchange mechanism to secure their communication. Your task is to implement the key exchange sequence and ensure that both parties end up with the same secret key without explicitly sharing it. **Problem Statement**: Implement a function `secure_diffie_hellman(a, p)` which verifies if Alice and Bob can successfully derive the same shared secret key using the given prime number `p` and its primitive root `a`. **Function Signature**: ```python def secure_diffie_hellman(a: int, p: int) -> bool: # Implement the function here ``` **Input**: - `a`: An integer representing a primitive root of `p`. - `p`: A large prime integer. **Output**: - Return `True` if Alice and Bob successfully derive the same shared secret key, otherwise return `False`. **Constraints**: - 2 ≤ `a` < `p` - `p` is guaranteed to be a prime number. - `a` is guaranteed to be a primitive root modulo `p`. **Example**: ```python print(secure_diffie_hellman(5, 23)) # Expected output: True ``` **Performance Requirements**: - The function should efficiently handle large prime numbers up to (10^9). **Hints**: - Use the provided utility functions if necessary. - Ensure proper handling of boundary conditions. - Focus on the correctness of key exchange and primality/primitive root checks.","solution":"import random def secure_diffie_hellman(a: int, p: int) -> bool: Function to verify if Alice and Bob can derive the same shared secret key using the Diffie-Hellman Key Exchange. Parameters: a (int): A primitive root of p. p (int): A large prime number. Returns: bool: True if Alice and Bob successfully derive the same shared secret key, otherwise False. # Alice and Bob each choose a private key randomly alice_private = random.randint(2, p - 2) bob_private = random.randint(2, p - 2) # Alice computes A = a^alice_private % p A = pow(a, alice_private, p) # Bob computes B = a^bob_private % p B = pow(a, bob_private, p) # Exchange of public keys A and B (simulated, not actually passed in function) # Alice computes the shared secret key as K_A = B^alice_private % p K_A = pow(B, alice_private, p) # Bob computes the shared secret key as K_B = A^bob_private % p K_B = pow(A, bob_private, p) # Both should have the same shared secret key return K_A == K_B"},{"question":"Intersection of Two Linked Lists **Context**: In programming and data structures, it is common to work with linked lists. A problem that often arises is determining where two linked lists intersect or merge. Given two singly linked lists, write a function `find_intersection` that determines the node at which the two lists intersect. The intersection is based on the address/reference of the nodes, not their values. **Function Signature**: ```python def find_intersection(head1: Node, head2: Node) -> Node: ``` # Input: * `head1` (Node): Head of the first linked list. * `head2` (Node): Head of the second linked list. **Output**: * Return the intersecting `Node` if the linked lists intersect, otherwise return `None`. # Constraints: * Both linked lists should retain their original structure after the function call. * The length of the linked lists is arbitrary but less than 10^6. * The function should complete in linear time O(N + M) where N and M are the lengths of the two linked lists respectively. * The function should use constant extra space O(1). # Example: ```python class Node: def __init__(self, val=None): self.val = val self.next = None # Example Lists: # 1 -> 3 -> 5 # # 7 -> 9 -> 11 # / # 2 -> 4 -> 6 a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f # Here, the lists intersect at node with value 7 assert find_intersection(a1, a2).val == 7 ``` **Note**: Ensure that your solution accounts for all edge cases, including empty lists and lists that do not intersect.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def find_intersection(head1: Node, head2: Node) -> Node: # Helper function to get the length of a linked list def get_length(head): length = 0 current = head while current: length += 1 current = current.next return length # Get lengths of both linked lists len1 = get_length(head1) len2 = get_length(head2) # Move the start pointer of the longer list to be the same distance from # the end as the shorter list\'s start pointer. current1, current2 = head1, head2 if len1 > len2: for _ in range(len1 - len2): current1 = current1.next else: for _ in range(len2 - len1): current2 = current2.next # Traverse both lists together to find the intersection while current1 and current2: if current1 is current2: return current1 current1 = current1.next current2 = current2.next # Return None if no intersection is found return None"},{"question":"# Coding Challenge **Context:** Quick Sort is a widely used sorting algorithm known for its efficiency in the average case due to its divide-and-conquer strategy. It can be implemented in different ways based on pivot selection and partitioning methods. Given its fundamental role in computer science, understanding and optimizing Quick Sort is crucial for students. **Objective:** Implement a Quick Sort function in Python with the ability to simulate its behavior step-by-step. This involves logging the array\'s state at each iteration where significant changes occur. **Task:** 1. Write a function `quick_sort(arr, simulation=False)` that sorts an array of integers using Quick Sort. 2. If the `simulation` parameter is set to `True`, the function should print the array after each partitioning step. 3. Ensure the function handles edge cases (e.g., empty array, sorted array) gracefully. **Function Signature:** ```python def quick_sort(arr, simulation=False): Quick sort an array of integers and optionally simulate by printing the array state at each significant step. Parameters: arr (List[int]): The array to sort. simulation (bool): If True, print the array at each significant step. Returns: List[int]: The sorted array. ``` **Input:** * `arr` - A list of integers, size ( n ) where ( 0 leq n leq 10^6 ). * `simulation` - A boolean flag that, if set to `True`, will print the intermediate state of the array. **Output:** * A list of integers, sorted in ascending order. **Constraints:** * Must efficiently handle large arrays (up to (10^6) elements). **Example Usage:** ```python arr = [3, 6, 8, 10, 1, 2, 1] sorted_arr = quick_sort(arr, simulation=True) print(sorted_arr) # Output should be [1, 1, 2, 3, 6, 8, 10] ``` **Clarifications:** * Print the array state only for significant steps (i.e., after partitioning). * Use the last element in the current subarray as the pivot for simplicity. * Ensure to include test cases covering edge scenarios.","solution":"def quick_sort(arr, simulation=False): Quick sort an array of integers and optionally simulate by printing the array state at each significant step. Parameters: arr (List[int]): The array to sort. simulation (bool): If True, print the array at each significant step. Returns: List[int]: The sorted array. def partition(low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_sort_recursive(low, high): if low < high: pi = partition(low, high) if simulation: print(arr) quick_sort_recursive(low, pi - 1) quick_sort_recursive(pi + 1, high) n = len(arr) quick_sort_recursive(0, n - 1) return arr"},{"question":"You are tasked with implementing an algorithm to sort an array of integers using the insertion sort technique. Given the following guidelines, write a function `custom_insertion_sort` that performs the sorting. # Function Signature ```python def custom_insertion_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr`: A list of integers which can be empty or contain one or more integers. The maximum length of the list is 10^3, and each integer can range from -10^3 to 10^3. # Output * Returns a sorted list of integers in non-decreasing order. # Constraints * Do not use the built-in `sort()` method or any other library sorting functions. * Aim for a time complexity of O(n^2) and space complexity of O(1). * Implement the function to be stable and in-place. # Example ```python assert custom_insertion_sort([4, 3, 2, 10, 12, 1, 5, 6]) == [1, 2, 3, 4, 5, 6, 10, 12] assert custom_insertion_sort([1]) == [1] assert custom_insertion_sort([]) == [] assert custom_insertion_sort([3, 3, 3]) == [3, 3, 3] assert custom_insertion_sort([-5, 0, -3, 8, 2]) == [-5, -3, 0, 2, 8] ``` # Scenario Imagine you\'re developing a sorting function to be used in a broader application where, for some operations on smaller sets of data, the overhead of advanced sorting algorithms like quicksort or mergesort is unnecessary. This function needs to be efficient in such contexts and should maintain stability to ensure that identical elements retain their original order. # Requirements 1. Implement the insertion sort algorithm. 2. Test your solution against a variety of cases, including edge cases like an empty array and arrays with one element. 3. Ensure the function is stable and performs sorting in-place.","solution":"from typing import List def custom_insertion_sort(arr: List[int]) -> List[int]: Sorts the given list of integers in non-decreasing order using the insertion sort technique and performs sorting in-place. for i in range(1, len(arr)): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater than key, to one position ahead of their current position while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"# Cycle Sort Implementation # Objective Implement the Cycle Sort algorithm to sort an array of integers in ascending order. The implementation should be in Python and must correctly handle duplicate elements. # Input - A list `arr` of `N` integers where `1 <= N <= 1000`. # Output - The function should return a new list of integers, sorted in ascending order. # Example ```python arr = [4, 3, 2, 1] cycle_sort(arr) # Output: [1, 2, 3, 4] arr = [1, 3, 2, 2, 5] cycle_sort(arr) # Output: [1, 2, 2, 3, 5] ``` # Constraints - The function should implement Cycle Sort as described. - Sorting must be done in ascending order. - The function should operate in-place with O(1) additional space. - Time complexity of your function should remain within O(N^2). # Function Signature ```python def cycle_sort(arr: List[int]) -> List[int]: pass ``` # Note To ensure your solution handles all potential edge cases: - Consider arrays of various lengths including very small (0 or 1 element) and edge cases like arrays with all identical elements. - Ensure that the function does not enter infinite loops and handles duplicates appropriately.","solution":"def cycle_sort(arr): Implements cycle sort to sort an array. n = len(arr) # Loop through the array to find cycles to rotate for cycle_start in range(0, n - 1): item = arr[cycle_start] # Find the position where we put the element pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Otherwise, put the item in the correct position (skipping duplicates) while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"# Question: You are given a sorted array of integers and a target integer. Write a function `insert_position` that returns the index at which the target should be inserted to maintain the sorted order. Function Signature: ```python def insert_position(array: List[int], target: int) -> int: pass ``` Input: - `array` (List[int]): A sorted list of integers. - `target` (int): The integer value which we want to insert into the list in a sorted manner. Output: - Returns an integer representing the index at which the target should be inserted. Constraints: - The array will have at most 10^6 elements. - Each element will be an integer in the range of [-10^9, 10^9]. - The target will be an integer in the range of [-10^9, 10^9]. - Array may be empty. Performance Requirements: - Must run in O(log n) time complexity. # Example: ```python >>> insert_position([1, 3, 5, 6], 5) 2 >>> insert_position([1, 3, 5, 6], 2) 1 >>> insert_position([1, 3, 5, 6], 7) 4 >>> insert_position([1, 3, 5, 6], 0) 0 >>> insert_position([], 1) 0 ``` Scenario: Imagine you are maintaining a leaderboard in a gaming application. Each new player\'s score needs to be inserted at the correct position to keep the leaderboard sorted. Your task is to determine the appropriate position for each new score efficiently.","solution":"from typing import List def insert_position(array: List[int], target: int) -> int: Returns the index at which the target should be inserted to maintain the sorted order. left, right = 0, len(array) while left < right: mid = (left + right) // 2 if array[mid] < target: left = mid + 1 else: right = mid return left"},{"question":"# Problem Description You are given an array of integers and a non-negative integer `k`. Write a function `rotate_array` to rotate the array elements to the right by `k` positions. Function Definition ```python def rotate_array(array: List[int], k: int) -> None: ``` Input - `array`: A list of integers, `array` (0 ≤ length of `array` ≤ 10^6). - `k`: A non-negative integer (0 ≤ `k` ≤ 10^6). Output - The function `rotate_array` should modify the `array` in place with its elements rotated to the right by `k` positions. Examples Example 1: ```python array = [1, 2, 3, 4, 5, 6, 7] rotate_array(array, 3) print(array) # Output: [5, 6, 7, 1, 2, 3, 4] ``` Example 2: ```python array = [-1, -100, 3, 99] rotate_array(array, 2) print(array) # Output: [3, 99, -1, -100] ``` Constraints - Implement the solution with O(n) time complexity and O(1) space complexity. - Use the `rotate_v2` method of reversing array segments for optimal performance. Notes - Consider edge cases such as empty arrays or `k` values greater than the length of the array. - Only modify the provided array in place; do not return a new array.","solution":"from typing import List def rotate_array(array: List[int], k: int) -> None: Rotate the elements of the array to the right by k positions. n = len(array) if n == 0: return k = k % n # In case k is greater than the length of the array # Reverse the whole array array.reverse() # Reverse the first k elements reverse_sub_array(array, 0, k - 1) # Reverse the remaining elements reverse_sub_array(array, k, n - 1) def reverse_sub_array(array: List[int], start: int, end: int) -> None: Helper function to reverse elements in array from index start to end. while start < end: array[start], array[end] = array[end], array[start] start += 1 end -= 1"},{"question":"# Question Context You are developing a string abbreviation generator for a text-based game where users can create shorter versions of their character names. To ensure unique character name recognition, you need a function that generates all possible abbreviations of a given character name. Task Implement a function `generate_abbreviations` that receives a string `word` and returns a list of all possible abbreviations for that word. Function Signature ```python def generate_abbreviations(word: str) -> List[str]: ``` Input * `word`: A string of lowercase English letters (1 <= len(word) <= 15). Output * A list of strings representing all possible abbreviations of the input word. Example ```python generate_abbreviations(\\"word\\") ``` Example Output ```python [\'word\', \'wor1\', \'wo1d\', \'wo2\', \'w1rd\', \'w1r1\', \'w2d\', \'w3\', \'1ord\', \'1or1\', \'1o1d\', \'1o2\', \'2rd\', \'2r1\', \'3d\', \'4\'] ``` Constraints * The length of the word will be between 1 and 15 inclusive. * Each character in the word will be a lowercase English letter. Notes * Ensure the output list contains all possible abbreviations in any order. * Focus on generating the correct set of abbreviations without adhering to the order seen in the example.","solution":"from typing import List def generate_abbreviations(word: str) -> List[str]: def backtrack(pos: int, cur: str, count: int): if pos == len(word): res.append(cur + (str(count) if count > 0 else \'\')) else: # Skip current character, increase the count backtrack(pos + 1, cur, count + 1) # Include current character and reset count backtrack(pos + 1, cur + (str(count) if count > 0 else \'\') + word[pos], 0) res = [] backtrack(0, \'\', 0) return res"},{"question":"# Missing Number Identification Given a list of unique integers within the range [0..n], write a function to find the missing number. The list represents a sequence that should ideally contain all numbers from 0 to `n` without repetition, except for one number that is missing. If the sequence is complete, return the next integer in the sequence. Function Signature ```python def find_missing(nums: List[int]) -> int: pass ``` Input * `nums`: A list of unique integers within the range [0..n]. Output * The missing number if one is missing, or the next integer in the sequence if the list is complete. Constraints * All elements in `nums` are unique. * `0 <= nums[i] <= len(nums)` * The length of `nums` will be in the range `[0, 10^6]` * The input list will represent a continuous sequence with at most one number missing. Example ```python print(find_missing([4, 1, 3, 0, 6, 5, 2])) # Output: 7 print(find_missing([0, 1, 2, 4, 5])) # Output: 3 print(find_missing([3, 0, 1, 4, 2])) # Output: 5 print(find_missing([0, 1, 2, 3, 4])) # Output: 5 print(find_missing([])) # Output: 0 ``` Notes * You can choose any approach (bitwise XOR, sum reduction, etc.) as long as it meets the time and space complexity requirements.","solution":"from typing import List def find_missing(nums: List[int]) -> int: Returns the missing number in the list. If no number is missing, returns the next integer in the sequence. n = len(nums) expected_sum = n * (n + 1) / 2 actual_sum = sum(nums) return int(expected_sum - actual_sum)"},{"question":"Problem: Optimizing Communication Network # Context You have been hired to design an optimal communication network using Kruskal\'s algorithm. Your task is to write a Python function to determine the minimum cost required to connect all nodes in a city grid, where each node represents a building and edges represent the cost to connect two buildings directly. # Function Signature ```python def find_minimum_cost(n: int, connections: List[Tuple[int, int, int]]) -> int: Calculate the minimum cost required to connect all nodes in the city grid. Args: n : int : the number of buildings connections : List[Tuple[int, int, int]] : list of available connections where each connection is represented as (u, v, cost) Returns: int : the minimum total cost to connect all buildings or -1 if it\'s not possible to connect all buildings pass ``` # Input - `n`: an integer (1 ≤ n ≤ 1000), representing the number of buildings. - `connections`: a list of tuples (u, v, cost). Each tuple (u, v, cost) denotes that: - `u` and `v` are connected with a cost to connect them. - The length of `connections` will be between 1 and 100,000. - All costs will be positive integers not exceeding 1,000,000. # Output - The function should return an integer representing the minimum cost to connect all buildings. - If it\'s impossible to connect all buildings, return -1. # Constraints - If there are multiple edges with the same weight, any valid MST can be chosen. # Performance Requirement - Your solution must have a worst-case time complexity of O(E log E), where E is the number of connections. # Example ```python assert find_minimum_cost(5, [(1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6)]) == 14 assert find_minimum_cost(3, [(1, 2, 20), (2, 3, 100), (1, 3, 50)]) == 70 assert find_minimum_cost(3, [(1, 2, 5)]) == -1 ``` # Solution Outline 1. **Input Validation**: Ensure the input constraints are respected. 2. **Edge Sorting**: Sort all connections by cost. 3. **Disjoint Set Initialization**: Initialize a disjoint-set structure to manage building sets. 4. **Kruskal\'s Algorithm**: Use Kruskal\'s method to iteratively add edges and form the MST. 5. **Check Connection**: Ensure all buildings are connected together, else return -1.","solution":"from typing import List, Tuple class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def find_minimum_cost(n: int, connections: List[Tuple[int, int, int]]) -> int: if n <= 1: return 0 # Sort connections by cost connections.sort(key=lambda x: x[2]) uf = UnionFind(n + 1) total_cost = 0 edges_used = 0 for u, v, cost in connections: if uf.find(u) != uf.find(v): uf.union(u, v) total_cost += cost edges_used += 1 # If we have used n-1 edges, we have constructed an MST if edges_used == n - 1: return total_cost # If we cannot connect all nodes return -1"},{"question":"# Coding Challenge: Sparse Matrix Multiplication Context You are working on a system that involves complex matrix multiplications. Given the sparse nature of the matrices, leveraging their sparsity can lead to significant optimizations in both time and space. Your task is to implement an efficient function for multiplying two sparse matrices. Task Write a function to multiply two sparse matrices A and B, and return the result. You may assume that A\'s column number is equal to B\'s row number. Function Description ```python def sparse_matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Multiply two sparse matrices A and B. :param A: List[List[int]] - 2D array representing sparse matrix A. :param B: List[List[int]] - 2D array representing sparse matrix B. :return: List[List[int]] - 2D array representing the result of AB. pass ``` Input - `A`: A 2D list of integers representing matrix A (m x n), where m is the number of rows and n is the number of columns. - `B`: A 2D list of integers representing matrix B (n x l), where n is the number of rows and l is the number of columns. Output - Return a 2D list of integers representing the resultant matrix (m x l). Constraints - The number of rows and columns in the input matrices will not exceed 1000. - Elements in matrices are integers between -100 and 100. Example ```python A = [ [ 1, 0, 0], [-1, 0, 3] ] B = [ [ 7, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 1 ] ] # Expected Output: # [ # [ 7, 0, 0 ], # [-7, 0, 3 ] # ] print(sparse_matrix_multiply(A, B)) ``` Notes - Pay attention to the sparsity of the matrices; avoid unnecessary computations involving zero elements. - Consider storing the matrices using dictionary-based structures to efficiently locate and operate on non-zero elements.","solution":"from typing import List def sparse_matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Multiply two sparse matrices A and B. :param A: List[List[int]] - 2D array representing sparse matrix A. :param B: List[List[int]] - 2D array representing sparse matrix B. :return: List[List[int]] - 2D array representing the result of AB. m = len(A) n = len(A[0]) l = len(B[0]) # Resultant matrix of size m x l result = [[0] * l for _ in range(m)] # Create a sparse representation of A sparseA = {} for i in range(m): for j in range(n): if A[i][j] != 0: if i not in sparseA: sparseA[i] = {} sparseA[i][j] = A[i][j] # Multiply A and B for i in sparseA: for k in sparseA[i]: if sparseA[i][k] != 0: for j in range(l): if B[k][j] != 0: result[i][j] += sparseA[i][k] * B[k][j] return result"},{"question":"You are tasked with implementing a variant of Comb Sort. This algorithm should initially utilize a large gap and progressively reduce it based on a specified shrink factor until the list is sorted. You must ensure the correctness and handle potential edge cases. # Function Signature ```python def optimized_comb_sort(arr: List[int], shrink: float = 1.3) -> List[int]: pass ``` # Input - `arr`: A list of integers that need to be sorted. - `shrink`: A float representing the shrink factor for the gap (default is 1.3). # Output - A new list of integers sorted in ascending order. # Constraints - The input list `arr` will have at most 10^5 elements. - The shrink value will be a float greater than 1. # Performance Requirements Your implementation should aim for O(N log N) average-case time complexity. # Example ```python # Example Input input_list = [34, 8, 64, 51, 32, 21] shrink_factor = 1.3 # Example Output result = optimized_comb_sort(input_list, shrink_factor) print(result) # Output: [8, 21, 32, 34, 51, 64] ``` # Detailed Description - Your function should start by initializing the `gap` equal to the length of the list and progressively reduce it by dividing it by the `shrink` factor each iteration. - If the gap becomes less than 1, it should be set to 1. - Continue comparing and swapping elements that are `gap` positions apart until the entire list is sorted. - The function should handle edge cases such as empty lists, single-element lists, and lists with all identical elements gracefully.","solution":"from typing import List def optimized_comb_sort(arr: List[int], shrink: float = 1.3) -> List[int]: Implements a variant of Comb Sort algorithm that progressively reduces the gap by a specified shrink factor until the list is sorted. Parameters: arr (List[int]): List of integers to be sorted. shrink (float): Shrink factor for reducing the gap (default is 1.3). Returns: List[int]: A new list of integers sorted in ascending order. n = len(arr) gap = n sorted = False while not sorted: gap = int(gap // shrink) if gap <= 1: gap = 1 sorted = True index = 0 while index + gap < n: if arr[index] > arr[index + gap]: arr[index], arr[index + gap] = arr[index + gap], arr[index] sorted = False index += 1 return arr"},{"question":"# Question: 2-SAT Solver Implementation Given a set of logical clauses in 2-CNF (2-Conjunctive Normal Form), write a Python function `solve_2_sat` that determines if there exists an assignment to the variables such that all clauses are satisfied. If a satisfying assignment exists, return any such assignment as a dictionary where keys are variable names and values are `True` or `False`. If no such assignment exists, return `None`. Input Format - `clauses`: A list of tuples, where each tuple represents a clause with two literals. Each literal is represented as a tuple `(variable, is_negated)`. Output Format - A dictionary mapping variables to truth values (`{variable: bool}`) that satisfy all clauses, or `None` if no satisfying assignment exists. Constraints - Variables are represented as strings. - The length of `clauses` can be up to 10^5. - Variables and their negations will be correctly identified in the clauses. Example ```python clauses = [((\'x\', False), (\'y\', False)), ((\'y\', True), (\'y\', True)), ((\'a\', False), (\'b\', False)), ((\'a\', True), (\'c\', True)), ((\'c\', False), (\'b\', True))] result = solve_2_sat(clauses) # Possible output: {\'x\': True, \'y\': True, \'a\': True, \'b\': True, \'c\': False} or any other valid assignment clauses = [((\'x\', False), (\'y\', False)), ((\'y\', True), (\'y\', True)), ((\'x\', False), (\'y\', True)), ((\'x\', True), (\'y\', False))] result = solve_2_sat(clauses) # Output: None ``` Function Signature ```python def solve_2_sat(clauses: list) -> dict: # Implement the solution based on the provided analysis and sample code pass ```","solution":"def solve_2_sat(clauses): from collections import defaultdict, deque def add_implication(graph, u, v): graph[u].append(v) def dfs(graph, node, visited, stack): visited[node] = True for neighbor in graph[node]: if not visited[neighbor]: dfs(graph, neighbor, visited, stack) stack.append(node) def reverse_graph(graph): rev_graph = defaultdict(list) for u in graph: for v in graph[u]: rev_graph[v].append(u) return rev_graph def kosaraju_scc(graph, nodes): stack = [] visited = {node: False for node in nodes} for node in nodes: if not visited[node]: dfs(graph, node, visited, stack) rev_graph = reverse_graph(graph) visited = {node: False for node in nodes} sccs = [] while stack: node = stack.pop() if not visited[node]: scc_stack = [] dfs(rev_graph, node, visited, scc_stack) sccs.append(scc_stack) return sccs def to_var_lit(var, is_neg): return var if not is_neg else f\'~{var}\' # Create implication graph graph = defaultdict(list) variables = set() for (v1, neg1), (v2, neg2) in clauses: var1 = to_var_lit(v1, neg1) var2 = to_var_lit(v2, neg2) var1_neg = to_var_lit(v1, not neg1) var2_neg = to_var_lit(v2, not neg2) add_implication(graph, var1_neg, var2) add_implication(graph, var2_neg, var1) variables.update([var1, var2, var1_neg, var2_neg]) sccs = kosaraju_scc(graph, variables) node_to_scc = {} for scc in sccs: for node in scc: node_to_scc[node] = scc assignment = {} for var in variables: if var.startswith(\'~\'): normal_var = var[1:] neg_var = var else: normal_var = var neg_var = f\'~{var}\' if node_to_scc[normal_var] == node_to_scc[neg_var]: return None if normal_var not in assignment: assignment[normal_var] = node_to_scc[normal_var] > node_to_scc[neg_var] return assignment"},{"question":"# Deletion of a Specific Node in a Singly Linked List **Problem Statement:** You are given a node in a singly linked list. Your task is to write a function `delete_specific_node(node)` that deletes this node from the list (except the tail node), given only access to that node. Suppose the linked list is `10 -> 20 -> 30 -> 40` and you are given the node with value `30`, the linked list should become `10 -> 20 -> 40` after calling your function. **Function Signature:** ```python def delete_specific_node(node): # Your code here pass ``` # Input and Output Formats * **Input:** A node `node` (a Python object of class `Node`) to be deleted. * **Output:** The function should modify the list in place, and thus, it does not need to return anything. # Constraints 1. You do not have access to the head of the list. 2. You cannot delete the tail node. # Performance Requirements - Time Complexity: O(1) - Space Complexity: O(1) # Example Given a linked list: ``` 10 -> 20 -> 30 -> 40 ``` And the node to delete has the value `30`. After calling `delete_specific_node(node_with_value_30)`, the list should become: ``` 10 -> 20 -> 40 ``` # Edge Cases 1. If the node is `None`, raise a `ValueError`. 2. If the node is the tail node, raise a `ValueError`. # Unit Tests Provided: ```python import unittest class Node: def __init__(self, x): self.val = x self.next = None def delete_specific_node(node): if node is None or node.next is None: raise ValueError node.val = node.next.val node.next = node.next.next class TestSuite(unittest.TestCase): def test_delete_node(self): # Create linked list 10 -> 20 -> 30 -> 40 head = Node(10) current = head for value in [20, 30, 40]: current.next = Node(value) current = current.next # Node to delete (30) node_to_delete = head.next.next # Perform deletion delete_specific_node(node_to_delete) # Verify the new linked list 10 -> 20 -> 40 current = head self.assertEqual(current.val, 10) current = current.next self.assertEqual(current.val, 20) current = current.next self.assertEqual(current.val, 40) self.assertIsNone(current.next) # Verify error scenarios tail = current self.assertRaises(ValueError, delete_specific_node, tail) self.assertRaises(ValueError, delete_specific_node, None) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, x): self.val = x self.next = None def delete_specific_node(node): if node is None or node.next is None: raise ValueError(\\"Cannot delete the node because it is either None or the tail node.\\") node.val = node.next.val node.next = node.next.next"},{"question":"# Coding Challenge: Reachability in Graphs Objective You are given a directed graph with `V` vertices and `E` edges. Implement the function `find_reachability_matrix(vertices, edges)` that returns the transitive closure matrix for the given graph. The matrix should indicate which vertices are reachable from each vertex. Function Signature ```python def find_reachability_matrix(vertices, edges): pass ``` Input - `int vertices`: The number of vertices in the graph (`1 <= vertices <= 100`). - `List[Tuple[int, int]] edges`: A list of tuples, where each tuple `(source, target)` represents a directed edge from `source` to `target`. Output - `List[List[int]]`: A 2D list representing the transitive closure matrix where `matrix[i][j]` is `1` if vertex `j` is reachable from vertex `i`; otherwise, `0`. Constraints - Vertices are indexed from `0` to `vertices-1`. - No self-loops or multiple edges. Example ```python vertices = 4 edges = [(0, 1), (1, 2), (2, 3), (3, 0)] print(find_reachability_matrix(vertices, edges)) # Expected Output: # [ # [1, 1, 1, 1], # [1, 1, 1, 1], # [1, 1, 1, 1], # [1, 1, 1, 1] # ] ``` Explanation - Vertex 0 can reach all other vertices through the following paths: `0 -> 1 -> 2 -> 3` and `3 -> 0`. - Similarly, each vertex can reach all other vertices because of the cycle. **Implement the function ensuring that it correctly handles edge cases and avoids common pitfalls like infinite recursion for cyclic graphs.**","solution":"def find_reachability_matrix(vertices, edges): Returns the transitive closure matrix for a directed graph with vertices and edges. # Initialize reachability matrix with 0s matrix = [[0]*vertices for _ in range(vertices)] # Every vertex is reachable from itself for v in range(vertices): matrix[v][v] = 1 # Set reachability from edges for (source, target) in edges: matrix[source][target] = 1 # Floyd-Warshall algorithm to compute transitive closure for k in range(vertices): for i in range(vertices): for j in range(vertices): if matrix[i][j] == 0: matrix[i][j] = matrix[i][k] and matrix[k][j] return matrix"},{"question":"You are given a Monomial class and a Polynomial class that handle basic mathematical operations for monomials and polynomials, respectively. Your task is to **implement a new operation called `differentiate` that computes the derivative of a Monomial or Polynomial with respect to a given variable**. # Function Signature ```python class Monomial: ... def differentiate(self, var_index: int) -> Monomial: pass class Polynomial: ... def differentiate(self, var_index: int) -> Polynomial: pass ``` # Input * For `Monomial.differentiate(self, var_index: int) -> Monomial`: * `var_index`: an integer representing the index of the variable with respect to which the differentiation should occur. * For `Polynomial.differentiate(self, var_index: int) -> Polynomial`: * `var_index`: an integer representing the index of the variable with respect to which the differentiation should occur. # Output * For `differentiate` method of `Monomial` class: * Returns a new `Monomial` instance representing the derivative of the original monomial with respect to the specified variable. * For `differentiate` method of `Polynomial` class: * Returns a new `Polynomial` instance representing the derivative of the original polynomial with respect to the specified variable. # Constraints * Coefficients and exponents are non-zero rational numbers unless the entire monomial or polynomial results in zero after differentiation. # Examples Monomial Example ```python m = Monomial({1: 3, 2: 2}, 4) d_m = m.differentiate(1) # d_m represents 12(a_1)^2(a_2)^2 as the derivative of 4(a_1)^3(a_2)^2 with respect to a_1 ``` Polynomial Example ```python p = Polynomial([ Monomial({1: 2}, 3), Monomial({2: 1}, -2), Monomial({1: 1, 2: 1}, 5) ]) d_p = p.differentiate(1) # d_p represents Polynomial([ # Monomial({1: 1}, 6), # Monomial({1: 0, 2: 1}, 5) # ]) as the derivative of 3(a_1)^2 - 2(a_2) + 5(a_1)(a_2) with respect to a_1 ``` # Explanation 1. **Monomial Derivative**: - If `variables[var_index]` is zero, the derivative is zero. - Multiply the coefficient by `variables[var_index]` and reduce `variables[var_index]` by 1. 2. **Polynomial Derivative**: - Derivative of a sum of monomials is the sum of derivatives of those monomials. # Detailed Requirements 1. **Monomial Derivative**: - For each variable represented as `a_i` with exponent `e_i`, compute the derivative: * ( d(ka_i^{e_i})/da_i = ke_i a_i^{e_i-1} ) * Remove the variable if `e_i-1` becomes zero. 2. **Polynomial Derivative**: - Apply the monomial differentiation to each term and sum the results.","solution":"class Monomial: def __init__(self, exponents, coefficient): self.exponents = exponents # exponents is a dictionary {var_index: exponent} self.coefficient = coefficient def __eq__(self, other): return self.exponents == other.exponents and self.coefficient == other.coefficient def differentiate(self, var_index: int): if var_index not in self.exponents or self.exponents[var_index] == 0: return Monomial({}, 0) new_exponents = self.exponents.copy() new_coefficient = self.coefficient * new_exponents[var_index] new_exponents[var_index] -= 1 if new_exponents[var_index] == 0: del new_exponents[var_index] return Monomial(new_exponents, new_coefficient) class Polynomial: def __init__(self, monomials): self.monomials = monomials # list of Monomial objects def differentiate(self, var_index: int): differentiated_monomials = [m.differentiate(var_index) for m in self.monomials] non_zero_monomials = [m for m in differentiated_monomials if m.coefficient != 0] return Polynomial(non_zero_monomials) def __eq__(self, other): return self.monomials == other.monomials"},{"question":"# Problem: Check Magic Number Identifier A number is considered a magic number if summing its digits and recursively repeating this process until a single digit is obtained results in `1`. Write a function `is_magic_number(digit_string)` where: ```python def is_magic_number(digit_string: str) -> bool: ``` # Input: - `digit_string`: A string representing a positive integer. # Output: - Return a boolean indicating whether the number is a magic number or not. # Constraints: 1. The input string can be of considerable length (up to 100 characters). 2. The string will always contain digits (i.e., \'0\'-\'9\') and is guaranteed to represent a valid positive number. # Example: ```python assert is_magic_number(\\"50113\\") == True assert is_magic_number(\\"199\\") == True assert is_magic_number(\\"111\\") == False ``` **Objective**: Implement this function by analyzing the notorious properties of magic numbers via iterative digit summation. This exercise will help in understanding complex digit manipulations and recursive processes.","solution":"def is_magic_number(digit_string: str) -> bool: Determine if the given string of digits represents a magic number. A number is a magic number if repeatedly summing its digits until a single digit is obtained results in 1. def sum_of_digits(number): total = 0 for char in number: total += int(char) return total # Sum the digits until a single digit is obtained current_sum = digit_string while len(current_sum) > 1: current_sum = str(sum_of_digits(current_sum)) # Check if the resulting single digit is 1 return current_sum == \'1\'"},{"question":"**Knapsack Problem with Dynamic Budget Allocation** You are tasked with designing a budget allocation system for a new project. You have a limited budget (`capacity`) and a list of potential project items. Each item has a specific cost and benefit value. Your goal is to maximize the total benefit by selecting a subset of these items that fit within the given budget. Write a function, `allocate_budget(items, capacity)`, that uses dynamic programming to determine the maximum benefit that can be achieved. **Function Signature**: ```python def allocate_budget(items: List[Tuple[int, int]], capacity: int) -> int: pass ``` **Input**: * `items`: A list of tuples where each tuple `(b, c)` includes: * `b` (int): The benefit value of the item. * `c` (int): The cost of the item. * `capacity` (int): The maximum budget available. **Output**: * Returns an integer representing the maximum benefit that can be achieved within the given capacity. **Constraints**: * The number of items, `n`, will be between `0` and `1000`. * The `capacity` will be between `0` and `1000`. * Each benefit `b` and cost `c` will be a non-negative integer. # Example ```python # Example 1 items = [(60, 5), (50, 3), (70, 4), (30, 2)] capacity = 5 assert allocate_budget(items, capacity) == 80 # Example 2 items = [(100, 20), (50, 10), (60, 12), (120, 30)] capacity = 50 assert allocate_budget(items, capacity) == 220 # Example 3 items = [] capacity = 5 assert allocate_budget(items, capacity) == 0 # Example 4 items = [(20, 5)] capacity = 0 assert allocate_budget(items, capacity) == 0 ``` # Performance Requirements Your solution must be efficient and able to handle the maximum constraints within a reasonable time frame.","solution":"def allocate_budget(items, capacity): Determine the maximum benefit that can be achieved within the given capacity using dynamic programming. :param items: List of tuples where each tuple (b, c) includes benefit value \'b\' and cost \'c\' of the item. :param capacity: Integer representing the maximum budget available. :return: Maximum benefit achievable within the given capacity. n = len(items) # Initialize the DP array with zeros. The array dimension is (n+1) x (capacity+1) dp = [[0] * (capacity + 1) for _ in range(n + 1)] for i in range(1, n + 1): benefit, cost = items[i-1] for w in range(capacity + 1): if cost > w: # If current item\'s cost is more than the remaining capacity, we can\'t take this item. dp[i][w] = dp[i-1][w] else: # Choose the maximum value between not taking or taking the current item. dp[i][w] = max(dp[i-1][w], dp[i-1][w-cost] + benefit) return dp[n][capacity]"},{"question":"You are given a binary tree with integer values. Your task is to write a function that returns all paths from the root node to the leaf nodes. The paths should be represented as a list of strings in the format \\"root->node2->node3\\". Function Signature ```python def binary_tree_paths(root: TreeNode) -> List[str]: ``` Input * `root` (TreeNode): The root of the binary tree. Output * `List[str]`: A list of strings, where each string represents a path from the root to a leaf node. Constraints * The number of nodes in the tree will be in the range [0, 100]. * `-100 <= Node.val <= 100` Example ```python # Example 1: Input: root = [1,2,3,null,5] Output: [\\"1->2->5\\", \\"1->3\\"] # Example 2: Input: root = [1] Output: [\\"1\\"] ``` Explanation For Example 1, the binary tree can be visualized as: ``` 1 / 2 3 5 ``` Paths from the root to leaves are \\"1->2->5\\" and \\"1->3\\". The problem involves understanding the DFS traversal on a binary tree, managing edge cases like empty trees and single-node trees, and ensuring proper string formatting for the output paths.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root: Optional[TreeNode]) -> List[str]: def dfs(node, path, paths): if not node: return path.append(str(node.val)) if not node.left and not node.right: paths.append(\\"->\\".join(path)) else: dfs(node.left, path, paths) dfs(node.right, path, paths) path.pop() if not root: return [] paths = [] dfs(root, [], paths) return paths"},{"question":"**Segment Trees Applied: Queries and Updates** Background Segment Trees are powerful data structures designed for efficient range queries and point updates. Given an array of elements, a Segment Tree allows you to perform operations like finding the sum, maximum, or any other commutative function over a range, and updating individual elements efficiently. Problem Statement You are given an array of integers and you need to implement a Segment Tree to support the following operations: 1. `update(index, value)`: Update the element at the specified index to the new value. 2. `query(left, right)`: Return the result of the commutative function applied over the elements between indices left and right (inclusive). **Function Signature**: ```python class SegmentTree: def __init__(self, arr, function): # initialize the segment tree def update(self, index, value): # update the element at specified index to the new value def query(self, left, right): # perform a range query from left to right and return the result ``` **Input and Output**: - `__init__(self, arr: List[int], function: Callable[[int, int], int])`: - `arr` is the input list of integers. - `function` is a commutative function to be applied for range queries. - `update(self, index: int, value: int) -> None`: Updates the element at `index` to `value`. - `query(self, left: int, right: int) -> int`: Returns the result of applying the commutative function over the elements from index `left` to `right` (inclusive). **Constraints**: - Array length `1 <= len(arr) <= 10^5` - Element values are within the integer range. - `0 <= index, left, right < len(arr)` **Scenario**: Imagine you are given a large dataset, which you need to process for various range-based queries and individual updates. Implementing a Segment Tree will help you handle these operations efficiently. Example ```python # Example Initialization and Operations arr = [2, 4, 5, 3, 4] tree = SegmentTree(arr, max) print(tree.query(2, 4)) # Output: 5 tree.update(3, 6) print(tree.query(0, 3)) # Output: 6 ``` # Note: - Ensure to handle edge cases such as single-element arrays and full-range queries. - Optimize for performance given the constraints.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.function = function self.tree = [0] * (2 * self.n) # Build the segment tree # Initialize the leaves of the tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Initialize the internal nodes of the tree for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, index, value): # Update the value in the segment tree pos = self.n + index self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.function(self.tree[pos * 2], self.tree[pos * 2 + 1]) def query(self, left, right): # Perform the range query l, r = self.n + left, self.n + right + 1 res = 0 # It should be the identity element of the function, e.g., 0 for sum or -∞ for max if self.function in (max, min): # for max, min, the identity element should be set correctly res = float(\'-inf\') if self.function == max else float(\'inf\') while l < r: if l % 2: res = self.function(res, self.tree[l]) l += 1 if r % 2: r -= 1 res = self.function(res, self.tree[r]) l //= 2 r //= 2 return res"},{"question":"# Matrix Exponentiation Challenge You are given a `d x d` square matrix (a list of lists in Python) and a non-negative integer `k`. Your task is to compute the `k`th power of the given matrix using the matrix exponentiation technique provided above. Functional Requirements 1. Implement a function `matrix_power(matrix: list, power: int) -> list` that: * Takes a square matrix `matrix` (represented as a list of lists) and a non-negative integer `power` as inputs. * Returns the result of raising the matrix to the given power. 2. You should use the `multiply` and `identity` helper functions provided below to perform matrix multiplication and to generate identity matrices when needed. Helper Function Definitions ```python def multiply(matA: list, matB: list) -> list: n = len(matA) matC = [[0 for i in range(n)] for j in range(n)] for i in range(n): for j in range(n): for k in range(n): matC[i][j] += matA[i][k] * matB[k][j] return matC def identity(n: int) -> list: I = [[0 for i in range(n)] for j in range(n)] for i in range(n): I[i][i] = 1 return I ``` Constraints * The input matrix will always be square (i.e., the number of rows = number of columns). * You must use the `matrix_exponentiation` technique described. # Example Input: ```python matrix = [ [1, 2], [3, 4] ] power = 2 ``` Output: ```python [ [7, 10], [15, 22] ] ``` **Function Signature** ```python def matrix_power(matrix: list, power: int) -> list: # Implementation Code Here pass ```","solution":"def multiply(matA: list, matB: list) -> list: n = len(matA) matC = [[0 for _ in range(n)] for _ in range(n)] for i in range(n): for j in range(n): for k in range(n): matC[i][j] += matA[i][k] * matB[k][j] return matC def identity(n: int) -> list: I = [[0 for _ in range(n)] for _ in range(n)] for i in range(n): I[i][i] = 1 return I def matrix_power(matrix: list, power: int) -> list: Computes the k-th power of the given square matrix using matrix exponentiation. n = len(matrix) if power == 0: return identity(n) result = identity(n) base = matrix while power > 0: if power % 2 == 1: result = multiply(result, base) base = multiply(base, base) power //= 2 return result"},{"question":"# Prompt: You are given a stack that contains integers. Write a Python function `stutter_stack` which takes a stack (represented as a list) as input and modifies it such that each element in the original stack appears twice. You have to implement two approaches for this: 1. Using another stack as auxiliary storage. 2. Using a queue as auxiliary storage. # Function Signature: ```python def stutter_stack(stack, method=\'stack\'): pass ``` * `stack` (list of integers): The original stack where the top element is the last item of the list. * `method` (str): The method used for processing (\'stack\' or \'queue\'). Default is \'stack\'. # Input: * `stack` is non-null and may have zero or more integers. # Output: * Modifies `stack` in-place by duplicating each of its elements without returning anything. # Constraints: * The function should handle stacks of varying size efficiently. * Maintain the order and integrity of the elements as specified. # Example: ```python s = [3, 7, 1, 14, 9] stutter_stack(s, method=\'stack\') print(s) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` # Note: 1. The \'stack\' method should use another stack as auxiliary storage, while the \'queue\' method should use a queue. 2. Consider edge cases such as empty stack, single element stack while implementing your solution.","solution":"def stutter_stack(stack, method=\'stack\'): if method == \'stack\': aux_stack = [] # Use the auxiliary stack to reverse elements while stack: aux_stack.append(stack.pop()) # Double the elements while moving back to the original stack while aux_stack: elem = aux_stack.pop() stack.append(elem) stack.append(elem) elif method == \'queue\': from collections import deque queue = deque() # Use the queue to reverse elements while stack: queue.appendleft(stack.pop()) # Double the elements while moving back to the original stack while queue: elem = queue.popleft() stack.append(elem) stack.append(elem) else: raise ValueError(\\"Invalid method specified. Use \'stack\' or \'queue\'.\\")"},{"question":"# Context A binary search tree (BST) is a data structure that allows fast lookup, addition, and deletion of items. To assess your understanding of this data structure, you will be required to write a series of functions for manipulating a BST. You need to implement an additional feature that finds the kth smallest element in the BST. # Task Implement the function `find_kth_smallest(self, k)` in the BST class that returns the k-th smallest element in the Binary Search Tree (BST). # Implementation Details * Method Signature: ```python class BST: def find_kth_smallest(self, k: int) -> int: ``` # Input * k: An integer representing the k-th position (1-based index) of the smallest element to find. # Output * Return the k-th smallest element as an integer. # Constraints * The given k will always be valid within the bounds of the BST size. * Assume the BST contains only distinct integers. # Examples ```python # Example 1: bst = BST() bst.insert(10) bst.insert(15) bst.insert(6) bst.insert(4) bst.insert(9) bst.insert(12) bst.insert(24) bst.insert(7) bst.insert(20) bst.insert(30) bst.insert(18) assert bst.find_kth_smallest(3) == 7 # The 3rd smallest element assert bst.find_kth_smallest(5) == 10 # The 5th smallest element # Example 2: new_bst = BST() new_bst.insert(1) new_bst.insert(3) new_bst.insert(2) assert new_bst.find_kth_smallest(2) == 2 # The 2nd smallest element ``` # Performance Requirements * Aim for O(H + k) where H is the height of the tree for time complexity.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.value = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.value: if root.left is None: root.left = TreeNode(key) else: self._insert(root.left, key) else: if root.right is None: root.right = TreeNode(key) else: self._insert(root.right, key) def find_kth_smallest(self, k: int) -> int: Returns the k-th smallest element in the BST. def inorder(node): return inorder(node.left) + [node.value] + inorder(node.right) if node else [] inorder_list = inorder(self.root) if 0 < k <= len(inorder_list): return inorder_list[k - 1] else: return None # k is out of bounds # Example usage: # bst = BST() # bst.insert(10) # bst.insert(15) # bst.insert(6) # bst.insert(4) # bst.insert(9) # bst.insert(12) # bst.insert(24) # bst.insert(7) # bst.insert(20) # bst.insert(30) # bst.insert(18) # print(bst.find_kth_smallest(3)) # Output: 7 (The 3rd smallest element) # print(bst.find_kth_smallest(5)) # Output: 10 (The 5th smallest element)"},{"question":"Coding Assessment Question # Problem Statement You are given a base path and a suffix path, which could either be parts of a URL or a file path. These paths need to be concatenated in a manner that ensures there will be exactly one slash (`/`) separating the base path and the suffix path, regardless of the presence of trailing slashes in the base or leading slashes in the suffix. # Requirements * Write a function `join_paths(base: str, suffix: str) -> str` that takes two strings: `base` and `suffix`, and returns a single string representing the correctly joined path. # Input Format * `base` (0 ≤ length of base ≤ 10^4): The base part of the path. * `suffix` (0 ≤ length of suffix ≤ 10^4): The suffix part of the path. # Output Format * A single string representing the correctly joined path. # Constraints 1. If `base` is an empty string, the result should be `/` followed by the `suffix`. 2. If `suffix` is an empty string, the result should be the `base`. 3. The `base` and `suffix` will not contain spaces. # Sample Input/Output **Example 1:** ```python base = \\"http://algorithms.com\\" suffix = \\"part\\" # Expected Output: \\"http://algorithms.com/part\\" ``` **Example 2:** ```python base = \\"http://algorithms.com/\\" suffix = \\"/part\\" # Expected Output: \\"http://algorithms.com/part\\" ``` **Example 3:** ```python base = \\"\\" suffix = \\"file\\" # Expected Output: \\"/file\\" ``` # Implementation ```python def join_paths(base: str, suffix: str) -> str: # Your implementation here pass ``` # Performance Requirements Your function should handle input strings up to a length of 10,000 efficiently. # Additional Notes - Special cases where both base and suffix are empty strings should be handled gracefully. - Avoid using the built-in libraries or functions that directly solve this problem.","solution":"def join_paths(base: str, suffix: str) -> str: Concatenates a base path and a suffix path with exactly one slash between them. # Handle edge case when base is an empty string if not base: return \'/\' + suffix # Handle edge case when suffix is an empty string if not suffix: return base # Remove trailing slash from base and leading slash from suffix base = base.rstrip(\'/\') suffix = suffix.lstrip(\'/\') # Concatenate with a single slash return base + \'/\' + suffix"},{"question":"# Matrix Transformation Challenge Objective Implement matrix rotation and inversion functions that demonstrate a comprehensive understanding of matrix manipulations. Problem Statement You are given a matrix represented as a list of lists in Python. You need to implement the following transformations on the matrix: 1. **Rotate 90 degrees clockwise** 2. **Rotate 90 degrees counterclockwise** 3. **Invert diagonally from top-left to bottom-right** 4. **Invert diagonally from bottom-left to top-right** Each function should take a matrix as input and return a new matrix transformed accordingly. Specifications 1. **rotate_clockwise(matrix)**: - **Input**: A matrix (list of lists) of size m x n. - **Output**: A new matrix rotated 90 degrees clockwise. 2. **rotate_counterclockwise(matrix)**: - **Input**: A matrix (list of lists) of size m x n. - **Output**: A new matrix rotated 90 degrees counterclockwise. 3. **top_left_invert(matrix)**: - **Input**: A matrix (list of lists) of size m x n. - **Output**: A new matrix inverted along the top-left to bottom-right diagonal. 4. **bottom_left_invert(matrix)**: - **Input**: A matrix (list of lists) of size m x n. - **Output**: A new matrix inverted along the bottom-left to top-right diagonal. You should also consider edge cases such as empty matrices, single-element matrices, and non-square matrices. Examples ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] print(rotate_clockwise(matrix)) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3], # ] print(rotate_counterclockwise(matrix)) # Output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7], # ] print(top_left_invert(matrix)) # Output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9], # ] print(bottom_left_invert(matrix)) # Output: # [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1], # ] ``` Constraints - The matrix will have dimensions m x n where 0 <= m, n <= 100.","solution":"def rotate_clockwise(matrix): Rotates the given matrix 90 degrees clockwise. if not matrix or not matrix[0]: return matrix m, n = len(matrix), len(matrix[0]) return [[matrix[m - 1 - j][i] for j in range(m)] for i in range(n)] def rotate_counterclockwise(matrix): Rotates the given matrix 90 degrees counterclockwise. if not matrix or not matrix[0]: return matrix m, n = len(matrix), len(matrix[0]) return [[matrix[j][n - 1 - i] for j in range(m)] for i in range(n)] def top_left_invert(matrix): Inverts the given matrix along the top-left to bottom-right diagonal. if not matrix or not matrix[0]: return matrix return [[matrix[j][i] for j in range(len(matrix[0]))] for i in range(len(matrix))] def bottom_left_invert(matrix): Inverts the given matrix along the bottom-left to top-right diagonal. if not matrix or not matrix[0]: return matrix m, n = len(matrix), len(matrix[0]) return [[matrix[m - 1 - j][n - 1 - i] for j in range(n)] for i in range(m)]"},{"question":"# Matrix Inversion Function Background Matrix inversion is a fundamental concept in linear algebra with applications in various domains like scientific computing, numerical analysis, and graphics. Given a square matrix, the task is to compute its inverse such that the product of the matrix and its inverse yields the identity matrix. Task Write a Python function `invert_matrix(matrix)` which takes as input a square matrix (represented as a list of lists) and returns its inverse. If the matrix is not invertible or invalid, return a specific error code as described below. Input - A 2D list `matrix` representing an n x n matrix. - Each element `matrix[i][j]` is a rational number (represented as a fraction). Output - A 2D list representing the inverse of the input matrix, or an error code list in the following scenarios: - `[-1]` if the input is not a matrix. - `[-2]` if the input matrix is not square. - `[-3]` if the matrix is too small (1x1 or trivial cases). - `[-4]` if the matrix is singular (determinant is zero and no inverse exists). Constraints - Ensure the function handles matrices up to the size of 10x10 efficiently. - Utilize fraction representation to avoid floating-point precision errors. - Do not use external libraries for matrix inversion. Example Input: ```python matrix = [ [4, 7], [2, 6] ] ``` Output: ```python [ [0.6, -0.7], [-0.2, 0.4] ] ``` Notes - Implement necessary helper functions (like determinant calculation and minors matrix creator) within the same Python file. - Ensure input validation and handle edge cases appropriately.","solution":"from fractions import Fraction def invert_matrix(matrix): def is_square(mat): return all(len(row) == len(mat) for row in mat) def determinant(mat): if len(mat) == 1: return mat[0][0] if len(mat) == 2: return mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0] det = Fraction(0) for c in range(len(mat)): submatrix = [[mat[i][j] for j in range(len(mat)) if j != c] for i in range(1, len(mat))] det += ((-1) ** c) * mat[0][c] * determinant(submatrix) return det def minor(mat, i, j): return [[mat[row][col] for col in range(len(mat)) if col != j] for row in range(len(mat)) if row != i] def cofactor_matrix(mat): cofactors = [] for r in range(len(mat)): cofactor_row = [] for c in range(len(mat)): minor_mat = minor(mat, r, c) cofactor_row.append(((-1) ** (r + c)) * determinant(minor_mat)) cofactors.append(cofactor_row) return cofactors def transpose(mat): return list(map(list, zip(*mat))) if not matrix or not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): return [-1] if not is_square(matrix): return [-2] if len(matrix) == 1: return [-3] n = len(matrix) for i in range(n): for j in range(n): if not isinstance(matrix[i][j], (int, float, Fraction)): return [-1] det = determinant(matrix) if det == 0: return [-4] cofactor_mat = cofactor_matrix(matrix) adjugate = transpose(cofactor_mat) inv_det = Fraction(1, det) inverse_matrix = [[adjugate[i][j] * inv_det for j in range(n)] for i in range(n)] return inverse_matrix"},{"question":"# AVL Tree: Advanced Operations and Debugging You are required to extend the functionality of the provided AVL Tree class. The task is split into two parts: 1. **Method Implementation**: Write a method that finds the predecessor and successor of an input key in the AVL Tree. - **Function Signature**: `def find_pre_suc(self, key: int) -> Tuple[Optional[int], Optional[int]]:` - **Input**: An integer key. If the key exists in the tree, find its in-order predecessor and successor. - **Output**: A tuple with the predecessor and successor of the key. Return `None` if it does not exist. - **Edge Cases**: Handle keys not present in the tree and keys which are edge cases (e.g., the smallest or largest elements). 2. **Testing Rebalance Efficiency**: Extend and test the rebalancing mechanism. - Write a utility to check if the tree remains balanced after removal. - **Function Signature**: `def remove(self, key: int) -> None` - **Input**: An integer key to be removed from the tree. - **Output**: Updates the tree by removing the specified key and maintaining balance via rotations. - **Edge Cases**: Removing a node that causes multiple rebalances, removing both leaf and internal nodes. # Constraints - Your solution should be efficient, leveraging the balanced nature of AVL trees. - You should ensure that the tree operations (insert, delete) maintain a balanced state efficiently. - Assume that the keys for operations are always integers. # Sample Scenario: Given an AVL Tree with the following elements [20, 4, 26, 3, 9, 15], your functions should be able to: 1. Determine that for key 9, the predecessor is 4 and the successor is 15. 2. When removing key 9, the tree should rebalance itself to maintain an AVL invariant. # Example ```python # Initializing the AVL Tree avl = AvlTree() avl.insert(20) avl.insert(4) avl.insert(26) avl.insert(3) avl.insert(9) avl.insert(15) # Finding predecessor and successor pre_suc = avl.find_pre_suc(9) print(pre_suc) # Output: (4, 15) # Removing a node and ensuring balance avl.remove(9) # The tree should rebalance in_order = avl.in_order_traverse() print(in_order) # Output should present a balanced AVL traversal. ```","solution":"class AVLTreeNode: def __init__(self, key: int): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def insert(self, key: int): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return AVLTreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) # Left Left if balance > 1 and key < node.left.key: return self._right_rotate(node) # Right Right if balance < -1 and key > node.right.key: return self._left_rotate(node) # Left Right if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) # Right Left if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) return x def _get_height(self, node): return node.height if node else 0 def _get_balance(self, node): return self._get_height(node.left) - self._get_height(node.right) if node else 0 def in_order_traverse(self): res = [] def _in_order(node): if node: _in_order(node.left) res.append(node.key) _in_order(node.right) _in_order(self.root) return res def find_pre_suc(self, key: int) -> tuple: predecessor, successor = None, None def _find_pre_suc(node, key): nonlocal predecessor, successor if not node: return if node.key == key: if node.left: temp = node.left while temp.right: temp = temp.right predecessor = temp.key if node.right: temp = node.right while temp.left: temp = temp.left successor = temp.key elif key < node.key: successor = node.key _find_pre_suc(node.left, key) else: predecessor = node.key _find_pre_suc(node.right, key) _find_pre_suc(self.root, key) return (predecessor, successor) def remove(self, key: int) -> None: self.root = self._remove(self.root, key) def _remove(self, node, key): if not node: return node if key < node.key: node.left = self._remove(node.left, key) elif key > node.key: node.right = self._remove(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._get_min_value_node(node.right) node.key = temp.key node.right = self._remove(node.right, temp.key) if not node: return node node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and self._get_balance(node.left) >= 0: return self._right_rotate(node) if balance < -1 and self._get_balance(node.right) <= 0: return self._left_rotate(node) if balance > 1 and self._get_balance(node.left) < 0: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and self._get_balance(node.right) > 0: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _get_min_value_node(self, node): if node is None or node.left is None: return node return self._get_min_value_node(node.left)"},{"question":"# Question: Prime Number Optimizer You have been hired by a cryptographic security firm to help in implementing efficient primality testing for large numbers up to 10^6. Your task is to implement a function that determines if a given number ( n ) is prime. Your function should: 1. Take an integer ( n ) as input. 2. Return `True` if ( n ) is a prime number, `False` otherwise. **Function Signature** ```python def is_prime(n: int) -> bool: pass ``` **Input Constraints** - ( 0 leq n leq 10^6 ) **Output** - A boolean value: `True` if ( n ) is a prime number, `False` otherwise. **Example** ```python assert is_prime(2) == True assert is_prime(4) == False assert is_prime(17) == True assert is_prime(18) == False ``` # Guidelines 1. Be mindful of the edge cases, especially for integers 0, 1, 2, and 3. 2. Ensure your algorithm is optimal for the upper range of the input limits. 3. Avoid unnecessary computations to maintain the efficiency of ( O(sqrt{n}) ) time complexity.","solution":"import math def is_prime(n: int) -> bool: Determines if the given integer n is a prime number. Parameters: n (int): The number to check for primality. Returns: bool: True if n is a prime number, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Scenario You are working on a system that processes textual data. One part of this system involves verifying if text modifications include any new characters. To simplify this task, you need to develop an algorithm to identify an additional character in a modified string. # Problem Description Given two strings, `s` and `t`, where: - `s` is a string consisting of lowercase letters. - `t` is generated by randomly shuffling `s` and adding one more letter at a random position. You need to find the letter that was added in `t`. # Function Specification Implement a function `find_difference(s: str, t: str) -> str` that finds the extra character in `t`. Input - **s**: a string of lowercase letters (`1 <= len(s) <= 10^5`). - **t**: a string of lowercase letters which is a permutation of `s` with one additional letter (`len(t) == len(s) + 1`). Output - Returns the added character as a single lowercase letter. Example ```python s = \\"abcd\\" t = \\"abcde\\" find_difference(s, t) # Output: \'e\' ``` # Constraints - Both `s` and `t` contain only lowercase English letters. - All characters in `s` are unique. - `t` contains exactly one additional character compared to `s`. # Performance Requirements The solution should be optimized to run in linear time, O(n), with respect to the length of the strings, and should use constant space, O(1). # Note You may not use any sorting, list manipulation, or built-in collection functions that inherently sort/compare elements (such as `sort()` or `collections.Counter`). The solution should solely rely on bitwise operations to determine the result.","solution":"def find_difference(s: str, t: str) -> str: Finds the extra character in string t that is not in string s. # Initialize a variable with 0 result = 0 # Combine both strings and XOR all characters together for char in s + t: result ^= ord(char) # The result will be the ASCII value of the extra character return chr(result)"},{"question":"Cycle Sort Implementation Challenge # Objective Implement the Cycle Sort algorithm to sort a given list of integers in ascending order. # Problem Statement You are tasked with sorting an array of integers using the Cycle Sort algorithm. This requires positioning each element in its correct position through cycles until the whole list is sorted. # Function Definition ```python def cycle_sort(arr): Sorts an array of integers in ascending order using Cycle Sort algorithm. Args: arr (List[int]): The list of integers to be sorted. Returns: List[int]: The sorted list of integers. pass ``` # Input and Output * **Input**: A list of integers, `arr` of length `N` (where (1 leq N leq 10^3)). * **Output**: A list of integers sorted in ascending order. # Constraints * Elements in the list can be negative or positive. * The implementation should sort the list in place with minimal extra space. * Ensure that your implementation handles edge cases effectively. # Example ```python # Example 1 arr = [4, 3, 2, 1] assert cycle_sort(arr) == [1, 2, 3, 4] # Example 2 arr = [8, 3, 5, 3, 5] assert cycle_sort(arr) == [3, 3, 5, 5, 8] # Example 3 arr = [1] assert cycle_sort(arr) == [1] # Example 4 arr = [-5, 3, 2, -1, 0] assert cycle_sort(arr) == [-5, -1, 0, 2, 3] ``` # Guidelines * Focus on a clear and efficient implementation of the cycle sort algorithm. * Consider edge cases such as duplicate values and arrays of length 1. * Your solution should be thoroughly tested with diverse inputs to ensure correctness. * Document your code and explain the key steps involved in the sorting process.","solution":"def cycle_sort(arr): Sorts an array of integers in ascending order using Cycle Sort algorithm. Args: arr (List[int]): The list of integers to be sorted. Returns: List[int]: The sorted list of integers. # Traverse array elements and put each element at its correct position for cycle_start in range(0, len(arr) - 1): item = arr[cycle_start] # Find position where we need to place the element pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Ignore all duplicate elements while item == arr[pos]: pos += 1 # Put the item at its correct position arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"# Bucket Sort Implementation Challenge You are provided with a partially implemented Bucket Sort function in Python. Your task is to complete and optimize this function while considering the edge cases and potential performance bottlenecks. **Task**: 1. Implement the `bucket_sort` function that sorts an array of integers using the Bucket Sort algorithm. 2. Ensure the function handles edge cases effectively. 3. Optimize the sorting of elements within the buckets by choosing a suitable sorting algorithm. **Function Signature**: ```python def bucket_sort(arr: List[int]) -> List[int]: pass ``` **Input**: - A list of integers, `arr` (0 <= len(arr) <= 10^5). **Output**: - A list of integers sorted in non-decreasing order. **Constraints**: - Each element in the list, `arr[i]`, is in the range 0 <= arr[i] <= 10^6. **Performance Requirements**: - The algorithm should ideally run in O(n) time complexity under optimal conditions. **Example**: ```python assert bucket_sort([29, 25, 3, 49, 9, 37, 21, 43]) == [3, 9, 21, 25, 29, 37, 43, 49] assert bucket_sort([5, 1, 3, 7, 2, 4, 6, 8]) == [1, 2, 3, 4, 5, 6, 7, 8] assert bucket_sort([10, 45, 23, 91, 54, 81, 100, 2]) == [2, 10, 23, 45, 54, 81, 91, 100] ``` **Note**: - If the input list is empty, return an empty list. - Consider using a more efficient sorting algorithm than Insertion Sort within individual buckets. **Scenario**: You are developing a fast sorting feature for a large-scale educational platform that processes and sorts millions of students\' scores daily. As students\' scores range widely, a highly efficient and resilient sorting algorithm is crucial.","solution":"from typing import List def bucket_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return [] # Step 1: Create buckets max_value = max(arr) num_buckets = len(arr) buckets = [[] for _ in range(num_buckets)] # Step 2: Distribute the elements into the buckets for num in arr: index = num_buckets * num // (max_value + 1) buckets[index].append(num) # Step 3: Sort elements within each bucket and concatenate sorted_arr = [] for bucket in buckets: sorted_arr.extend(sorted(bucket)) return sorted_arr"},{"question":"# Pancake Sorting Algorithm Implementation Context: You are working as a software engineer at a startup that processes large datasets. One of your tasks is to implement various sorting algorithms to help with data analysis. Today, you need to implement and test a less common, but interesting, sorting algorithm called Pancake Sort. Task: Implement the `pancake_sort` function to sort a list of integers in ascending order using the Pancake Sort method described above. Input: - A list of integers, `arr`, of length `N` (0 <= N <= 1000). Output: - The sorted list of integers in ascending order. Function Signature: ```python def pancake_sort(arr: List[int]) -> List[int]: pass ``` Constraints: - Do not use built-in sorting functions like `sorted()` or `sort()`. Requirements: - Your implementation should modify the input list in-place. - Ensure the algorithm has a time complexity of O(N^2) and space complexity of O(1). Example: ```python assert pancake_sort([3, 6, 1, 10, 9, 7]) == [1, 3, 6, 7, 9, 10] assert pancake_sort([10, 9, 8, 7, 6]) == [6, 7, 8, 9, 10] assert pancake_sort([3, 1, 4, 1, 5, 9, 2, 6, 5]) == [1, 1, 2, 3, 4, 5, 5, 6, 9] assert pancake_sort([]) == [] assert pancake_sort([1]) == [1] ```","solution":"from typing import List def pancake_sort(arr: List[int]) -> List[int]: def flip(sub_arr: List[int], k: int) -> None: Perform an in-place reversal of the first k elements of the list \'sub_arr\'. left = 0 right = k while left < right: sub_arr[left], sub_arr[right] = sub_arr[right], sub_arr[left] left += 1 right -= 1 n = len(arr) for size in range(n, 1, -1): # Find the index of the maximum element in arr[0:size] max_index = 0 for i in range(1, size): if arr[i] > arr[max_index]: max_index = i if max_index != size - 1: # Move the largest number to the front if it\'s not already there flip(arr, max_index) # Move it to its final position flip(arr, size - 1) return arr"},{"question":"# Decoding Nested Strings Problem Description You are given an encoded string containing nested formatting and your goal is to decode it. The encoding uses a structure where: - `k[encoded_string]` indicates the substring `encoded_string` is repeated `k` times. The input string will always be valid (no extra whitespace, well-formed brackets, etc.). Also, the original data does not contain any digits outside the encoded numbers for repetition. Function Signature ```python def decode_string(s: str) -> str: ``` Input - A single string `s` (1 <= len(s) <= 30,000), which is the encoded string. Output - A single string that is the decoded result. Examples ```python # Example 1 s = \\"3[a]2[bc]\\" # Output should be \\"aaabcbc\\" # Example 2 s = \\"3[a2[c]]\\" # Output should be \\"accaccacc\\" # Example 3 s = \\"2[abc]3[cd]ef\\" # Output should be \\"abcabccdcdcdef\\" ``` Constraints - The input string `s` always contains valid encoding, ensuring no mismatched brackets or invalid structure within the given encoding parameters. Requirements 1. Implement the function `decode_string` which returns the decoded version of the input string `s`. 2. The function should handle nested encoding and ensure correct repetition. 3. Optimize for both time and space complexity, especially given the constraint on the length of the string. Hints - Use a stack-based approach to keep track of the current string and repeat numbers. - Ensure that digits are processed to form the complete repeat number in cases where it exceeds single digits.","solution":"def decode_string(s: str) -> str: stack = [] current_num = 0 current_string = \'\' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string = \'\' current_num = 0 elif char == \']\': prev_string, num = stack.pop() current_string = prev_string + current_string * num else: current_string += char return current_string"},{"question":"**Context**: Imagine you are a developer for a shipping company that needs to sort parcels based on their weights before loading them onto trucks. You have an extremely simple sorting algorithm, Gnome Sort, implemented. Due to resource constraints, you need to use this algorithm to sort parcels. You are required to modify and enhance this existing Gnome Sort implementation to ensure it works correctly for the given task. Additionally, since parcels with the same weight should retain their relative order (stability), you need to ensure that the sorting algorithm preserves this property. **Task**: Implement a function `enhanced_gnome_sort(arr)` that performs Gnome Sort on an array of integers (representing parcel weights) and meets the following requirements: * **Input**: * An array of integers `arr`, where 0 ≤ len(arr) ≤ 10^4 and each integer is a non-negative weight. * **Output**: * A sorted array of integers in non-decreasing order. **Constraints**: 1. The array must be sorted in-place (i.e., it should not use extra space for another array). 2. The algorithm should be stable, i.e., maintain the relative order of equal elements. **Examples**: 1. Enhanced functionality of already sorted array: ```python enhanced_gnome_sort([1, 2, 3, 4]) # Output: [1, 2, 3, 4] ``` 2. Functionality with unsorted array: ```python enhanced_gnome_sort([4, 3, 2, 1]) # Output: [1, 2, 3, 4] ``` 3. Handling an array with duplicate weights: ```python enhanced_gnome_sort([4, 2, 2, 4, 3, 1]) # Output: [1, 2, 2, 3, 4, 4] ``` 4. Edge case handling with an empty array: ```python enhanced_gnome_sort([]) # Output: [] ``` **Implementation**: Enhance and implement the `enhanced_gnome_sort` based on the given context and requirements. ```python def enhanced_gnome_sort(arr): n = len(arr) index = 0 while index < n: if index == 0 or arr[index] >= arr[index-1]: index += 1 else: arr[index], arr[index-1] = arr[index-1], arr[index] index -= 1 return arr # Test cases to verify the solution print(enhanced_gnome_sort([1, 2, 3, 4])) # Output: [1, 2, 3, 4] print(enhanced_gnome_sort([4, 3, 2, 1])) # Output: [1, 2, 3, 4] print(enhanced_gnome_sort([4, 2, 2, 4, 3, 1])) # Output: [1, 2, 2, 3, 4, 4] print(enhanced_gnome_sort([])) # Output: [] ```","solution":"def enhanced_gnome_sort(arr): Performs Gnome Sort on an array of integers in-place and ensures stable sorting. Parameters: arr (list): A list of non-negative integers. Returns: list: A sorted list of non-negative integers in non-decreasing order. n = len(arr) index = 0 while index < n: if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Question: Tree-Based Data Structure Manipulation and Output Formatting Suppose you have hierarchical data represented as a nested dictionary, and you need to implement a function to print this data in a specified format. You are provided with a sample dataset and a partially implemented function. Sample Dataset ```python tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6, \'Jill\', \'Sports\', 1], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, \'Quin\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } ``` Your task is to implement the function `tree_print(tree)` to print the tree in the following format: Expected Output ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` # Constraints - The data contains nodes represented by a dictionary where each key (node identifier) maps to a list. - The list can contain strings and numbers. - Nodes are displayed in the order they appear in the provided dictionary. Implementation Details - Use a dictionary to represent the tree. - Use depth-first traversal to visit each node. - Properly format the printed output as shown in the example. Ensure your implementation correctly formats the spaces and newlines as specified. Handle cases where the tree is empty or nodes have varying data types. Avoid redundant operations to optimize performance. ```python def tree_print(tree): for key in tree: print(key, end=\' \') # end=\' \' prevents a newline character tree_element = tree[key] # multiple lookups is expensive, even amortized O(1)! for subElem in tree_element: print(\\" -> \\", subElem, end=\' \') if type(subElem) != str: print(\\"n \\") # newline and a space to match indenting print() # forces a newline # Test your function with the sample dataset tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6, \'Jill\', \'Sports\', 1], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, \'Quin\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } tree_print(tree) ``` Your function should produce the expected output for the given sample dataset.","solution":"def tree_print(tree): Prints the hierarchical data stored in the given tree dictionary in a specified format. for key in tree: print(key, end=\' -> \') tree_element = tree[key] print(\\" -> \\".join(map(str, tree_element))) # Test your function with the sample dataset tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6, \'Jill\', \'Sports\', 1], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, \'Quin\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } tree_print(tree)"},{"question":"You are tasked with writing a function `add_operators(num: str, target: int) -> List[str]`, which takes a string of digits and a target number and returns all possible combinations of operators +, -, * that can be added to the string to make it evaluate to the target number. Goal Write a function `add_operators(num: str, target: int) -> List[str]` to find all such combinations. Input * `num`: A non-empty string consisting of numeric digits [0-9]. * `target`: An integer value which is the desired result of the expression formed by inserting +, -, * in `num`. Output * A list of strings, where each string represents a valid expression that evaluates to the target value. Constraints * The algorithm should create valid mathematical expressions considering operator precedence. * You must handle expressions with leading zeros appropriately (e.g., `105` can become `1*0+5` but `10*5` should be valid). Performance Requirements The function should be efficient enough to handle up to 20 digits in the input string. Example ```python num = \\"123\\", target = 6 # Expected output: [\\"1+2+3\\", \\"1*2*3\\"] num = \\"232\\", target = 8 # Expected output: [\\"2*3+2\\", \\"2+3*2\\"] num = \\"105\\", target = 5 # Expected output: [\\"1*0+5\\",\\"10-5\\"] num = \\"00\\", target = 0 # Expected output: [\\"0+0\\", \\"0-0\\", \\"0*0\\"] num = \\"3456237490\\", target = 9191 # Expected output: [] ```","solution":"from typing import List def add_operators(num: str, target: int) -> List[str]: def helper(index, path, value, prev): if index == len(num): if value == target: results.append(path) return for i in range(index + 1, len(num) + 1): temp_str = num[index:i] temp_val = int(temp_str) if index == 0: helper(i, temp_str, temp_val, temp_val) else: helper(i, path + \'+\' + temp_str, value + temp_val, temp_val) helper(i, path + \'-\' + temp_str, value - temp_val, -temp_val) helper(i, path + \'*\' + temp_str, value - prev + prev * temp_val, prev * temp_val) if num[index] == \'0\': break results = [] helper(0, \'\', 0, 0) return results"},{"question":"# Question: Finding the Deepest Left Node in a Binary Tree Given a binary tree, write a function `find_deepest_left_node(root: TreeNode) -> int` that finds the deepest node which is the left child of its parent node and returns its value. If no such node exists, return `None`. **Function Signature**: ```python def find_deepest_left_node(root: TreeNode) -> int: pass ``` # Input: * `root`: A `TreeNode` object representing the root of a binary tree. Each `TreeNode` object has the following attributes: * `val`: an integer value of the node. * `left`: a `TreeNode` object representing the left child of the node. * `right`: a `TreeNode` object representing the right child of the node. # Output: * An integer representing the value of the deepest left node. Return `None` if no left child exists. # Constraints: * The number of nodes in the tree is in the range [1, 10^4]. * Node values are integers within a reasonable range for typical binary tree problems. # Example: ```plaintext # Example tree: 1 / 2 3 / 4 5 6 7 Input: root of the above tree Output: 4 ``` # Explanation: In the provided example, the node with value 4 is the deepest node that is a left child of its parent node. Thus, the output is 4. # Notes: Consider all edge cases: 1. A tree consisting of a single node. 2. A tree where there are no left children. 3. Balanced versus skewed trees to evaluate performance. # Solution Template: To facilitate students in focusing on the logic: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class DeepestLeft: def __init__(self): self.depth = 0 self.Node = None def find_deepest_left_node(root): def dfs(node, is_left, depth): if not node: return if is_left and depth > result.depth: result.depth = depth result.Node = node dfs(node.left, True, depth + 1) dfs(node.right, False, depth + 1) result = DeepestLeft() dfs(root, False, 0) return result.Node.val if result.Node else None ``` Implement your solution in the given function signature.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class DeepestLeft: def __init__(self): self.depth = -1 self.Node = None def find_deepest_left_node(root): def dfs(node, is_left, depth): if not node: return if is_left and depth > result.depth: result.depth = depth result.Node = node dfs(node.left, True, depth + 1) dfs(node.right, False, depth + 1) result = DeepestLeft() dfs(root, False, 0) return result.Node.val if result.Node else None"},{"question":"# Stack with Minimum Element Consider your task to be the implementation of a `StackWithMin` class that extends basic stack functionality. Besides the regular stack methods (`push`, `pop`, `peek`, `is_empty`), this stack should support `get_min`, returning the minimum element in constant time. The `get_min` method should return the smallest item from the stack without removing it. You are required to implement this using an `ArrayStack`, making use of an auxiliary stack to track the minimum values. # Function Signatures ```python class StackWithMin(ArrayStack): def __init__(self, size=10): pass def push(self, value): pass def pop(self): pass def get_min(self): pass ``` # Input and Output Requirements * **Input**: - `push(value)`: Pushes a value onto the stack. - `pop()`: Pops the top value from the stack and returns it. Raise an `IndexError` with the message `Stack is empty` if the stack is empty. - `get_min()`: Returns the minimum value in the stack. Raise an `IndexError` with the message `Stack is empty` if the stack is empty. * **Output**: - `get_min()`: Should return the minimum value of the current elements in the stack. - For `push` and `pop`, the return type is void and the value popped, respectively. # Constraints * You must ensure all operations (`push`, `pop`, `get_min`) run in O(1) time. * The stack should use an array of fixed initial size that dynamically grows as needed. * Memory usage should be optimized: auxiliary space proportional to the stack size is acceptable. # Example Scenarios ```python stack = StackWithMin() stack.push(3) stack.push(5) print(stack.get_min()) # Should print 3 stack.push(2) stack.push(1) print(stack.get_min()) # Should print 1 stack.pop() print(stack.get_min()) # Should print 2 stack.pop() print(stack.get_min()) # Should print 3 ```","solution":"class StackWithMin: def __init__(self): self.stack = [] self.min_stack = [] def push(self, value): self.stack.append(value) # If min_stack is empty or the new value is smaller or equal to the current min, push it to min_stack if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self): if not self.stack: raise IndexError(\\"Stack is empty\\") value = self.stack.pop() # If the popped value is the same as the top of the min_stack, pop it from min_stack as well if value == self.min_stack[-1]: self.min_stack.pop() return value def get_min(self): if not self.min_stack: raise IndexError(\\"Stack is empty\\") return self.min_stack[-1] def peek(self): if not self.stack: raise IndexError(\\"Stack is empty\\") return self.stack[-1] def is_empty(self): return len(self.stack) == 0"},{"question":"# Coding Challenge: Extract Domain Name from URL Overview Imagine you\'re working on a web scraping tool where one of your tasks is to extract and categorize different domain names from a large collection of URLs. To achieve this, you need to write a function that can accurately parse out the domain name from any given URL. Task Write a function `extract_domain_name(url: str) -> str` that receives a URL as input and returns the domain name without any protocol (`http`, `https`) or `www` prefix. Examples ``` extract_domain_name(\\"http://github.com/SaadBenn\\") == \\"github\\" extract_domain_name(\\"http://www.zombie-bites.com\\") == \\"zombie-bites\\" extract_domain_name(\\"https://www.cnet.com\\") == \\"cnet\\" extract_domain_name(\\"http://subdomain.example.com\\") == \\"subdomain\\" extract_domain_name(\\"example.org\\") == \\"example\\" ``` Constraints - The URL will always be a well-formed and valid URL. - You are not allowed to use any external libraries like `re` (regular expression) or `urlparse` except built-in string manipulation functions such as `split()`. - Focus on correctly handling URLs with or without \'http(s)\' and \'www\'. Input and Output - **Input**: A single string representing a URL. - **Output**: A string representing the domain name. **Edgcases to consider**: 1. URLs that do not start with `http://` or `https://`. 2. URLs with more than one subdomain. 3. Handle URLs that are in the form of IP addresses. Performance Requirements - Time Complexity: O(n) - Space Complexity: O(n) Consider various scenarios to test your function thoroughly to ensure robustness.","solution":"def extract_domain_name(url: str) -> str: Extract the domain name from a URL, removing any protocol (http, https) and any \\"www\\" prefix. # Remove the protocol (http, https) if \\"://\\" in url: url = url.split(\\"://\\")[1] # Remove the \\"www\\" prefix if present if url.startswith(\\"www.\\"): url = url[4:] # Split by \'.\' to isolate the domain name domain = url.split(\'.\')[0] return domain"},{"question":"# Red-Black Tree Validation and Augmentation **Context:** You are given an implementation of a Red-Black Tree which is a self-balancing binary search tree. It follows the red-black properties to ensure the tree remains approximately balanced. # Task: Your task is to write a function `validate_rb_tree` that will verify if a given Red-Black Tree adheres to all the Red-Black properties. Additionally, you need to extend the tree to support an efficient range query, returning all elements between two given nodes in the sorted order. # Function Signature: ```python def validate_rb_tree(root: RBNode) -> bool: pass def range_query(rb_tree: RBTree, low: int, high: int) -> list: pass ``` # Input Format: 1. The `validate_rb_tree` function receives a reference to the root of the tree. 2. The `range_query` function will take: - `rb_tree`: an instance of RBTree. - `low` and `high`: integers representing the lower and upper bounds of the range query. # Output Format: 1. `validate_rb_tree` will return a boolean value indicating whether the tree satisfies all red-black properties. 2. `range_query` will return a list of all node values in the range `[low, high]` sorted in ascending order. # Constraints: - The tree consists of nodes each with a unique integer value. - The values of `low` and `high` will always be such that `low <= high`. # Performance Requirements: - `validate_rb_tree`: The function should complete in O(n) time where n is the number of nodes in the tree. - `range_query`: The function should utilize the properties of the RBTree to perform the range query in O(k + log n) where k is the number of elements in the range. # Examples: ```python # Assume a previously created RBTree instance \'rb_tree\' and nodes. # validate_rb_tree example assert validate_rb_tree(rb_tree.root) == True # range_query example assert range_query(rb_tree, 4, 14) == [4, 5, 7, 8, 11, 14] ``` # Hints: - For `validate_rb_tree`, you need to check each node for properties of the Red-Black Tree. - For `range_query`, perform an in-order traversal while skipping nodes not within the range.","solution":"class RBNode: def __init__(self, data, color=\\"RED\\"): self.data = data self.color = color # \\"RED\\" or \\"BLACK\\" self.left = None self.right = None self.parent = None class RBTree: def __init__(self): self.NIL_LEAF = RBNode(data=None, color=\\"BLACK\\") self.root = self.NIL_LEAF def validate_rb_tree(root: RBNode) -> bool: # Helper function to check red-black properties def check_properties(node): # Property 1: Every node is either red or black (ensured by implementation) if node is None or node.data is None: # nil leaves are black return 1 left_height = check_properties(node.left) right_height = check_properties(node.right) # Property 2: Every leaf (NIL) is black -> implicit since NIL_LEAF is black if node.left is None and node.right is None: return 1 # Property 3: Red nodes have only black children if node.color == \\"RED\\": if (node.left and node.left.color == \\"RED\\") or (node.right and node.right.color == \\"RED\\"): raise ValueError(\\"Red violation\\") # Property 4: Every path from a given node to its descendant NIL nodes has the same number of black nodes # This is done by checking consistency in black heights if node.left is not None and node.right is not None and left_height != right_height: raise ValueError(\\"Black height violation\\") # If the node is black, increase the black count from children return left_height + (1 if node.color == \\"BLACK\\" else 0) try: check_properties(root) except ValueError: return False return True def range_query(rb_tree: RBTree, low: int, high: int) -> list: result = [] def in_order_traversal(node): if node is None or node.data is None: return if node.data > low: in_order_traversal(node.left) if low <= node.data <= high: result.append(node.data) if node.data < high: in_order_traversal(node.right) in_order_traversal(rb_tree.root) return result"},{"question":"# Edit Distance Optimization You are provided with an algorithm to calculate the edit distance between two words, which utilizes a 2D array `edit` of size (length_a + 1) x (length_b + 1) to store intermediate results. Given the high space complexity, the objective is to implement a space-optimized version of the edit distance algorithm that reduces the space complexity from O(length_a * length_b) to O(min(length_a, length_b)). # Function Signature: ```python def optimized_edit_distance(word_a: str, word_b: str) -> int: ``` # Input: * `word_a`: A string representing the first word. (1 ≤ len(word_a) ≤ 1000) * `word_b`: A string representing the second word. (1 ≤ len(word_b) ≤ 1000) # Output: * Returns an integer representing the minimum number of edit operations required to convert `word_a` into `word_b`. # Constraints: * Use only O(min(length_a, length_b)) additional space. # Example: ```python # Example 1: print(optimized_edit_distance(\\"kitten\\", \\"sitting\\")) # Expected Output: 3 # Example 2: print(optimized_edit_distance(\\"flaw\\", \\"lawn\\")) # Expected Output: 2 ``` # Performance Requirement: The space complexity of your solution should be O(min(length_a, length_b)). # Guidelines: 1. Use a rolling array approach or a similar space reduction technique to optimize the space requirement. 2. Ensure that your solution handles edge cases such as: - Either of the input strings is empty. - Strings of unequal lengths. - Strings with no common characters.","solution":"def optimized_edit_distance(word_a: str, word_b: str) -> int: len_a, len_b = len(word_a), len(word_b) if len_a < len_b: word_a, word_b = word_b, word_a len_a, len_b = len_b, len_a previous_row = list(range(len_b + 1)) current_row = [0] * (len_b + 1) for i in range(1, len_a + 1): current_row[0] = i for j in range(1, len_b + 1): if word_a[i - 1] == word_b[j - 1]: current_row[j] = previous_row[j - 1] else: current_row[j] = min(previous_row[j] + 1, current_row[j - 1] + 1, previous_row[j - 1] + 1) previous_row, current_row = current_row, previous_row return previous_row[-1]"},{"question":"# Anagram Detection with Extended Character Support Scenario You are a software developer tasked with building a function to determine if two given strings are anagrams. An anagram of a string is another string that contains the same characters, only the order of characters can be different. However, this time you need to support any character (case-insensitive) and extensive ASCII range rather than just lowercase letters. Function Signature ```python def are_anagrams(s1: str, s2: str) -> bool: pass ``` Requirements * Implement the function `are_anagrams(s1: str, s2: str) -> bool` that returns `True` if the two strings are anagrams, otherwise returns `False`. * The function must be case-insensitive. * Consider all ASCII characters (from 0 to 127) while comparing the strings. Input * Two strings `s1` and `s2` where 0 <= |s1|, |s2| <= 10^6. Output * A boolean value indicating whether the input strings are anagrams. Performance Constraints * The solution should run in O(n) time complexity. * Use fixed-size space for frequency arrays. Edge Cases * Both strings being empty should return `True`. * Strings of different lengths should return `False` immediately. * Case differences should be ignored in the comparison. Example ```python assert are_anagrams(\\"Listen\\", \\"Silent\\") == True assert are_anagrams(\\"Triangle\\", \\"Integral\\") == True assert are_anagrams(\\"Apple\\", \\"Pabble\\") == False assert are_anagrams(\\"\\", \\"\\") == True ```","solution":"def are_anagrams(s1: str, s2: str) -> bool: Returns True if s1 and s2 are anagrams, otherwise False. This function is case insensitive and considers all ASCII characters. # If lengths differ, they cannot be anagrams if len(s1) != len(s2): return False # Create frequency arrays for all ASCII characters frequency1 = [0] * 128 frequency2 = [0] * 128 # Build frequency array for s1 and s2 for char in s1: frequency1[ord(char.lower())] += 1 for char in s2: frequency2[ord(char.lower())] += 1 # Compare frequency arrays return frequency1 == frequency2"},{"question":"# Prim\'s Algorithm Enhanced: Handling Graphs with No Edges and Dynamic Input Structure You are asked to implement a function that utilizes Prim\'s Algorithm to find the weight of a minimum spanning tree (MST) but with additional constraints and enhancements. The graph may not always be connected, and you need to handle cases gracefully. Task Write a Python function `prims_minimum_spanning_edge_case(graph)` that calculates the weight of the minimum spanning tree. The function needs to be robust to handle scenarios such as: - **Disconnected graphs**: Return `None` if it\'s impossible to form an MST. - **Graphs with no edges or only one node**: Return Zero in such cases. Input - `graph`: A dictionary where keys are nodes and values are lists of tuples where each tuple represents an edge with the format `(weight, node)`. Output - Returns the total weight of the minimum spanning tree if it exists; otherwise, return `None`. Constraints - All nodes are represented as integers. - The graph can be empty (no nodes). - The graph can be disconnected. - Edges have positive weights. Examples 1. `prims_minimum_spanning_edge_case({1: [(2, 2)], 2: [(2, 1)]})` should return `2`. 2. `prims_minimum_spanning_edge_case({1: [], 2: []})` should return `None`. 3. `prims_minimum_spanning_edge_case({1: []})` should return `0`. 4. `prims_minimum_spanning_edge_case({1: [(1, 2)], 2: [(1, 1)], 3: [(2, 4)], 4: [(2, 3)]})` should return `None`. Implementation Guidelines - Utilize Python\'s `heapq` for priority queue operations. - Ensure to check whether the graph is disconnected or if MST cannot be formed. - Handle edge cases as per the provided examples and constraints. ```python import heapq # for priority queue def prims_minimum_spanning_edge_case(graph): # Your code here pass ``` You are encouraged to maintain efficiency in terms of time and space complexity and ensure that the function is thoroughly tested with edge cases.","solution":"import heapq def prims_minimum_spanning_edge_case(graph): if not graph: return 0 # Initialize the variables start_node = next(iter(graph)) visited = set() min_heap = [] # Add initial node\'s edges to the heap for weight, neighbor in graph[start_node]: heapq.heappush(min_heap, (weight, start_node, neighbor)) total_weight = 0 visited.add(start_node) while min_heap: weight, frm, to = heapq.heappop(min_heap) if to not in visited: visited.add(to) total_weight += weight for edge in graph[to]: if edge[1] not in visited: heapq.heappush(min_heap, (edge[0], to, edge[1])) # Check if all nodes are visited if len(visited) != len(graph): return None return total_weight"},{"question":"# Fenwick Tree Data Structure Challenge You are given a list of integers representing initial frequencies of events. Your task is to: 1. Construct a Fenwick Tree from the given list. 2. Implement functions to get the prefix sum up to a specified index. 3. Implement functions to update the frequency at a specified index. You should implement the following API: ```python class FenwickTree: def __init__(self, frequency: List[int]): Initializes the Fenwick Tree with the given frequency array. pass def get_sum(self, index: int) -> int: Returns the prefix sum from the start of the array up to the given index. :param index: Index up to which the sum is required (0-based). :return: Sum of elements from start to index. pass def update_value(self, index: int, value: int): Updates the value at the given index to the new value in the original array and the Fenwick Tree. :param index: Index at which to update the value (0-based). :param value: New value to set at the given index. pass def construct_tree(self) -> List[int]: Constructs the Fenwick Tree based on the initialized frequency array. :return: The constructed Fenwick Tree as a list. pass ``` # Input Format 1. A list of integers representing the initial frequencies when the tree is constructed. 2. Query operations which are either `(\'sum\', index)` or `(\'update\', index, value)`. # Output Format For each query, output the result of the operation as specified: * For `(\'sum\', index)`, output the prefix sum up to `index`. * For `(\'update\', index, value)`, return None (no output required). # Example ```python # Initialize with frequency array ft = FenwickTree([3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3]) ft.construct_tree() # Perform operations print(ft.get_sum(5)) # Output should be the sum of elements from start to index 5 ft.update_value(3, 10) # Updates the value at index 3 to 10 print(ft.get_sum(5)) # Output should reflect the updated sum ``` # Constraints * `0 <= index < len(frequency)` * The initial frequency list can have up to `10^5` elements. * Values in the frequency list and updates can range between `-10^6` to `10^6`. Ensure to handle edge cases where the operations might go out of bounds or involve negative numbers.","solution":"class FenwickTree: def __init__(self, frequency): Initializes the Fenwick Tree with the given frequency array. self.n = len(frequency) self.tree = [0] * (self.n + 1) self.frequency = frequency[:] self.construct_tree() def construct_tree(self): Constructs the Fenwick Tree based on the initialized frequency array. :return: The constructed Fenwick Tree as a list. for i in range(self.n): self._update_tree(i, self.frequency[i]) def _update_tree(self, index, value): Helper function to update the tree at position (index + 1). index += 1 while index <= self.n: self.tree[index] += value index += index & -index def get_sum(self, index): Returns the prefix sum from the start of the array up to the given index. :param index: Index up to which the sum is required (0-based). :return: Sum of elements from start to index. result = 0 index += 1 while index > 0: result += self.tree[index] index -= index & -index return result def update_value(self, index, value): Updates the value at the given index to the new value in the original array and the Fenwick Tree. :param index: Index at which to update the value (0-based). :param value: New value to set at the given index. # Calculate the difference diff = value - self.frequency[index] # Update the value in the original array self.frequency[index] = value # Update the tree self._update_tree(index, diff)"},{"question":"# Disjoint Set Union - Connected Components Problem Statement You are provided with an implementation of a Union-Find (Disjoint Set) data structure. Your task is to implement a function that identifies the number of connected components (islands) in a 2D grid after a sequence of `addLand` operations. Each `addLand` operation turns water into land and possibly connects existing adjacent lands. # Function Signature ```python def countIslands(n, m, positions): ``` # Inputs * `n`: Integer representing the number of rows in the 2D grid. * `m`: Integer representing the number of columns in the 2D grid. * `positions`: List of lists, where each inner list contains two integers `[row, col]` representing the position to add land. # Outputs * Returns a list of integers where the i-th integer represents the number of islands in the grid after the `i-th` addLand operation. # Constraints * 1 <= n, m <= 1000 * 0 <= positions.length <= n * m * Positions will be distinct. # Example Given a 3x3 grid and the positions `[[0, 0], [0, 1], [1, 2], [2, 1]]`: 1. Initially, the grid is: ``` 0 0 0 0 0 0 0 0 0 ``` 2. After `addLand(0, 0)`: ``` 1 0 0 0 0 0 0 0 0 ``` Number of islands = 1 3. After `addLand(0, 1)`: ``` 1 1 0 0 0 0 0 0 0 ``` Number of islands = 1 4. After `addLand(1, 2)`: ``` 1 1 0 0 0 1 0 0 0 ``` Number of islands = 2 5. After `addLand(2, 1)`: ``` 1 1 0 0 0 1 0 1 0 ``` Number of islands = 3 So, the output should be `[1, 1, 2, 3]`. # Your Task Implement the function `countIslands(n, m, positions)` to solve the problem. Use the Union-Find data structure and logic provided in the code snippet above.","solution":"class UnionFind: def __init__(self, size): self.parent = [-1] * size self.rank = [0] * size def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) # Path compression return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: # Union by rank if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 def countIslands(n, m, positions): def index(x, y): return x * m + y uf = UnionFind(n * m) grid = [[0] * m for _ in range(n)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] result = [] island_count = 0 for pos in positions: x, y = pos if grid[x][y] == 1: result.append(island_count) continue grid[x][y] = 1 island_count += 1 idx = index(x, y) uf.parent[idx] = idx for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 1: nIdx = index(nx, ny) if uf.find(idx) != uf.find(nIdx): uf.union(idx, nIdx) island_count -= 1 result.append(island_count) return result"},{"question":"# String Reformatting and Validation You are tasked to design a function that formats and validates a given alphanumeric serial number. The formatting involves adding a specific delimiter after every specified number of characters, counted from the end of the string. Your task is to implement the following function: ```python def format_key(key: str, k: int, delimiter: str = \'-\') -> str: Formats the given alphanumeric serial number by inserting the specified delimiter every k characters from the end. Parameters: key (str): The alphanumeric serial number containing alphanumeric characters and possibly delimiters. k (int): The number of characters between each delimiter. delimiter (str): The delimiter to be inserted. Defaults to \'-\'. Returns: str: The formatted serial number. pass ``` Input: * A string `key` representing the serial number. It may or may not contain the initial delimiters. * An integer `k` representing the interval for adding the delimiter. * An optional string `delimiter` which defaults to `-`. Constraints: * The string `key` can have a length of up to `10^5` characters. * `k` is a positive integer and no greater than the length of `key`. * The characters in `key` are alphanumeric. Output: * A formatted string where the specified delimiter is inserted every `k` characters from the end. Example: ```python assert format_key(\\"2-4A0r7-4k\\", 4) == \\"24A-0R74-K\\" assert format_key(\\"2-4A0r7-4k\\", 3) == \\"24-A0R-74K\\" assert format_key(\\"-2-4A0r--7-4k\\", 2) == \\"2-4A-0R-74-K\\" assert format_key(\\"\\", 2) == \\"\\" ``` Your function should also handle the following edge cases: * The input is an empty string. * The input is shorter than `k`. * Input does not contain any alphanumeric characters.","solution":"def format_key(key: str, k: int, delimiter: str = \'-\') -> str: Formats the given alphanumeric serial number by inserting the specified delimiter every k characters from the end. Parameters: key (str): The alphanumeric serial number containing alphanumeric characters and possibly delimiters. k (int): The number of characters between each delimiter. delimiter (str): The delimiter to be inserted. Defaults to \'-\'. Returns: str: The formatted serial number. # Remove any existing delimiters and convert to uppercase key = \'\'.join(e for e in key if e.isalnum()).upper() # If the key is empty after removal, return an empty string if not key: return \\"\\" # Initialize an empty list to build the result result = [] n = len(key) # Process the key from the end towards the beginning in chunks of size k for i in range(n): if i > 0 and i % k == 0: result.append(delimiter) result.append(key[n - 1 - i]) # Reverse the result list to get the final formatted string and join it return \'\'.join(result[::-1])"},{"question":"Segment Tree for Range Minimum Query Imagine you are working on a project that requires efficient management and querying of large datasets. In particular, you need to frequently perform two types of operations on an array of integers: 1. **Update a specific element** in the array to a new value. 2. **Query the minimum value** in a range of the array. To achieve this, you decide to implement a **Segment Tree**. Requirements: * Implement a `SegmentTree` class that supports: 1. Construction of the tree from an initial list of integers. 2. Updating an element in the array. 3. Querying the minimum value in a specified range. Function Signatures: ```python class SegmentTree: def __init__(self, arr: List[int]): # Initialize the segment tree pass def update(self, index: int, value: int): # Update the element at `index` to `value`. pass def query(self, left: int, right: int) -> int: # Query the minimum value in the range [left, right]. pass ``` Input Specifications: * The constructor receives an initial array `arr` of `n` integers where `1 <= n <= 10^5`. * The `update` method receives the `index` (0-based) to be updated and the new `value`. * The `query` method receives the range `[left, right]` (0-based, inclusive) and returns the minimum value in that range. Output Specifications: * The `query` method returns the minimum value in the specified range. Examples: ```python # Example usage arr = [2, 4, 5, 3, 4] segment_tree = SegmentTree(arr) print(segment_tree.query(1, 3)) # Output: 3 segment_tree.update(1, 1) print(segment_tree.query(1, 3)) # Output: 1 ``` Constraints: * Expect the solution to handle up to `10^4` update and query operations combined efficiently. * Assume updates and queries are always within the bounds of the array. Implementation Notes: * Use a non-recursive approach to minimize memory usage. * Ensure the solution is optimized for high efficiency in both space and time.","solution":"class SegmentTree: def __init__(self, arr): Initialize the segment tree. self.n = len(arr) self.seg_tree = [0] * (2 * self.n) # Build the segment tree # Copy initial array to the second half of the segment tree array for i in range(self.n): self.seg_tree[self.n + i] = arr[i] # Build the segment tree by calculating parents for i in range(self.n - 1, 0, -1): self.seg_tree[i] = min(self.seg_tree[2 * i], self.seg_tree[2 * i + 1]) def update(self, index, value): Update the element at `index` to `value`. # Update the value at the corresponding position in the segment tree index += self.n self.seg_tree[index] = value # Update the relevant segment tree nodes i = index while i > 1: i //= 2 self.seg_tree[i] = min(self.seg_tree[2 * i], self.seg_tree[2 * i + 1]) def query(self, left, right): Query the minimum value in the range [left, right]. # Convert array indices to segment tree leaf node indices left += self.n right += self.n min_val = float(\'inf\') while left <= right: if left % 2 == 1: min_val = min(min_val, self.seg_tree[left]) left += 1 if right % 2 == 0: min_val = min(min_val, self.seg_tree[right]) right -= 1 left //= 2 right //= 2 return min_val"},{"question":"You are tasked with implementing a function that swaps every pair of adjacent bits in a given integer. Bit-level manipulation can be highly efficient for specific tasks such as optimizing hardware-level operations, graphics processing, and low-level network packet handling. # Function Signature ```python def swap_pair(num: int) -> int: ``` # Input * `num` (int): A non-negative integer. # Output * (int): The integer after every pair of adjacent bits has been swapped. # Example ```python assert swap_pair(22) == 41 # 22 in binary is 010110, which becomes 101001 which is 41 in decimal. assert swap_pair(10) == 5 # 10 in binary is 1010, which becomes 0101 which is 5 in decimal. ``` # Constraints * The function should handle standard integer sizes typically supported by Python (32-bit or 64-bit). # Scenario In a computer graphics application, you might need to adjust pixel data at a low level where adjacent bits represent different colors. Efficient bit manipulation can lead to significant performance gains. Write the `swap_pair` function to facilitate such scenarios by optimally swapping bits. # Additional Notes * Ensure your function handles edge cases, including the minimum and maximum values of integers. * Remember that Python\'s integers are of arbitrary precision; however, assume typical 32-bit integers for simplicity.","solution":"def swap_pair(num: int) -> int: Swaps every pair of adjacent bits in the given integer. Args: num (int): A non-negative integer. Returns: int: The integer after every pair of adjacent bits has been swapped. # Mask to get all even bits and shift them right even_bits = (num & 0b10101010101010101010101010101010) >> 1 # Mask to get all odd bits and shift them left odd_bits = (num & 0b01010101010101010101010101010101) << 1 # Combine the shifted bits return even_bits | odd_bits"},{"question":"# Task: Encode and Decode String Lists You are required to implement two functions: `encode` and `decode`. These functions will allow converting a list of strings into a single encoded string and back again. This task assesses your understanding of string manipulation and encoding techniques. **Function Definitions**: 1. `def encode(strs: List[str]) -> str` - **Input**: A list of strings `strs`. - **Output**: A single encoded string. 2. `def decode(s: str) -> List[str]` - **Input**: A single encoded string `s`. - **Output**: The original list of strings. **Detailed Requirements**: 1. **Encode Function**: - For each string in the list, prepend its length followed by a colon (`:`), then concatenate the string itself. - Example: `[\\"apple\\", \\"banana\\"]` should be encoded to `\\"5:apple6:banana\\"`. 2. **Decode Function**: - Parse the encoded string back into the original list by reading the lengths and slicing the substrings accordingly. **Constraints**: - The length of each string in the list is guaranteed to be a non-negative integer. - The list of strings can contain empty strings. - You must handle any ASCII and non-ASCII characters appropriately. **Example**: ```python # Example Encode assert encode([\\"hello\\", \\"world\\"]) == \\"5:hello5:world\\" # Example Decode assert decode(\\"5:hello5:world\\") == [\\"hello\\", \\"world\\"] ``` This question examines your ability to design an encoding and decoding algorithm and requires strong attention to detail with string operations. Ensure your implementation accounts for various edge cases like empty strings and special characters.","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings into a single string. return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s: str) -> List[str]: Decodes a single string into a list of strings. i, n = 0, len(s) result = [] while i < n: j = i while s[j] != \':\': j += 1 length = int(s[i:j]) result.append(s[j+1:j+1+length]) i = j + 1 + length return result"},{"question":"# Context You are tasked to implement a stack data structure that supports large-scale data operations efficiently. The stack should be able to handle typical push, pop, and peek operations while managing memory and performance optimally. You have decided to use an array-based stack due to its simple implementation and its predictable memory usage characteristics on typical workloads. # Task Implement the `ArrayStack` class described below, following these specifications: 1. **Initialization**: - Initialize the stack with an optional capacity (default is 10). Internally, the stack should use a fixed-size array. 2. **Operations**: - `push(item)`: Add item to the top of the stack. Resize the array if the current capacity is exceeded. - `pop()`: Remove and return the top item from the stack. Raise an exception if the stack is empty. - `peek()`: Return the top item from the stack without removing it. Raise an exception if the stack is empty. - `is_empty()`: Return a boolean indicating whether the stack is empty. 3. **Resizing**: - When resizing, double the capacity of the internal array. 4. **Performance Requirements**: - The push, pop, and peek operations should be O(1) on average. - Resizing the array should be handled in O(n) time complexity. # Constraints - Do not use any built-in stack or list methods (other than for basic array operations like indexing). - Your implementation should be efficient in terms of both time and space. - You should handle edge cases such as popping or peeking from an empty stack gracefully with appropriate exceptions. # Example ```python stack = ArrayStack(5) assert stack.is_empty() == True stack.push(1) stack.push(2) assert stack.peek() == 2 assert stack.pop() == 2 assert stack.pop() == 1 assert stack.is_empty() == True try: stack.pop() except IndexError as e: assert str(e) == \\"Stack is empty\\" ``` # Implementation Skeleton Use the following skeleton to start your implementation: ```python class ArrayStack: def __init__(self, capacity=10): self._array = [None] * capacity self._top = -1 def push(self, item): self._top += 1 if self._top == len(self._array): self._expand() self._array[self._top] = item def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") value = self._array[self._top] self._top -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self._array[self._top] def is_empty(self): return self._top == -1 def _expand(self): self._array += [None] * len(self._array) # double the size of the array ``` Ensure your implementation passes the provided example and any additional tests you create to validate the correctness and efficiency of your methods.","solution":"class ArrayStack: def __init__(self, capacity=10): self._array = [None] * capacity self._top = -1 def push(self, item): if self._top + 1 == len(self._array): self._expand() self._top += 1 self._array[self._top] = item def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") value = self._array[self._top] self._top -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self._array[self._top] def is_empty(self): return self._top == -1 def _expand(self): new_capacity = len(self._array) * 2 new_array = [None] * new_capacity for i in range(self._top + 1): new_array[i] = self._array[i] self._array = new_array"},{"question":"Question You are tasked with designing a data structure that supports adding words and searching for words using wildcard characters. Implement a Trie-based solution to handle these operations efficiently. # Requirements 1. **addWord(word: str)**: Adds a word to the dictionary. 2. **search(word: str) -> bool**: Searches for a word in the dictionary, where \\".\\" can represent any letter. # Input Format - The `addWord` method will receive a single string `word` (1 <= length of word <= 500). - The `search` method will receive a single string `word` (1 <= length of word <= 500). # Output Format - The `search` method should return `True` if the word is found, else `False`. # Constraints - Words consist of lowercase English letters only. - The total number of words added and searched can be up to 2500. # Performance Requirements - Ensure the `addWord` and `search` methods are efficient even with the upper constraint limits. - Handle wildcard searches without exponential time complexity growth. # Scenario You are implementing an auto-complete system for a large dataset of words. Your task is: 1. Develop a class `WordDictionary` with methods `addWord` and `search`. 2. The `addWord` method should add a word to the data structure. 3. The `search` method should return `True` if the word (which may contain the wildcard \\".\\") exists, and `False` otherwise. # Example ```python wd = WordDictionary() wd.add_word(\\"bad\\") wd.add_word(\\"dad\\") wd.add_word(\\"mad\\") print(wd.search(\\"pad\\")) # Output: False print(wd.search(\\"bad\\")) # Output: True print(wd.search(\\".ad\\")) # Output: True print(wd.search(\\"b..\\")) # Output: True ```","solution":"class WordDictionary: def __init__(self): self.trie = {} def addWord(self, word: str): node = self.trie for char in word: if char not in node: node[char] = {} node = node[char] node[\'\'] = True def search(self, word: str) -> bool: def dfs(j, node): for i in range(j, len(word)): char = word[i] if char == \'.\': for x in node: if x != \'\' and dfs(i + 1, node[x]): return True return False else: if char not in node: return False node = node[char] return \'\' in node return dfs(0, self.trie)"},{"question":"# Bogo Sort Simulation and Analysis Problem Context Bogo Sort, also known as permutation sort, stupid sort, slowsort, or monkey sort, is an inefficient sorting algorithm based on generating random permutations of a list until one is sorted. Problem Specification You are required to implement an enhanced version of Bogo Sort that not only sorts the array but also provides detailed insights about the process of shuffling and sorting. # Task Write a Python function `enhanced_bogo_sort(arr: List[int]) -> Tuple[List[int], int, List[List[int]]]` where: * **Input**: * `arr` (List[int]): a list of integers to be sorted. * **Output**: * A tuple comprising: * Sorted array. * The number of shuffles performed to get the array sorted. * A list of lists, detailing the intermediate states of the array after each shuffle. # Constraints * The input list `arr` will have a maximum length of 6 due to the high time complexity of the algorithm. * Each element in the list `arr` will be a unique integer within the range ([-1000, 1000]). # Example ```python def enhanced_bogo_sort(arr): # Your implementation here # Example Usage sorted_array, shuffle_count, intermediate_states = enhanced_bogo_sort([3, 2, 1]) print(f\\"Sorted Array: {sorted_array}\\") print(f\\"Number of Shuffles: {shuffle_count}\\") print(\\"Intermediate States:\\") for state in intermediate_states: print(state) # Output could be: # Sorted Array: [1, 2, 3] # Number of Shuffles: 2 # Intermediate States: # [3, 2, 1] # [2, 1, 3] # [1, 2, 3] ``` # Explanation * The function first shuffles the array. * Generates the intermediate steps until the array gets sorted. * Returns the sorted array, count of shuffles and the list of permutations encountered during the shuffling process. Make sure to handle edge cases such as empty arrays and array with one element.","solution":"import random from typing import List, Tuple def enhanced_bogo_sort(arr: List[int]) -> Tuple[List[int], int, List[List[int]]]: def is_sorted(li: List[int]) -> bool: return all(li[i] <= li[i+1] for i in range(len(li) - 1)) shuffle_count = 0 intermediate_states = [] while not is_sorted(arr): intermediate_states.append(arr.copy()) random.shuffle(arr) shuffle_count += 1 intermediate_states.append(arr.copy()) # Include the final sorted state return arr, shuffle_count, intermediate_states"},{"question":"Scenario You\'ve been tasked with writing a software utility that can detect cyclic patterns in strings. This utility will be useful in various applications such as data compression, pattern recognition, and even in the analysis of genetic sequences. Task Write a function `can_form_cyclic_pattern` that determines if a given non-empty string can be constructed by repeating a substring multiple times. Function Signature ```python def can_form_cyclic_pattern(s: str) -> bool: ``` Input - `s`: a non-empty string consisting of lower-case English letters. Output - Returns `True` if the string can be constructed by repeating a substring multiple times, otherwise returns `False`. Constraints - The length of the string `s` will be at most 10^4. - The function should run in linear time and use linear additional space. Examples 1. Input: \\"abab\\" Output: `True` Explanation: The string \\"abab\\" can be constructed by repeating the substring \\"ab\\". 2. Input: \\"aba\\" Output: `False` Explanation: The string \\"aba\\" cannot be constructed by repeating any substring. 3. Input: \\"abcabcabcabc\\" Output: `True` Explanation: The string \\"abcabcabcabc\\" can be constructed by repeating the substring \\"abc\\". Additional Notes - Consider edge cases like single character strings, strings with no repetitions, and strings that are exact repetitions. - Avoid using excessive memory for extremely large input strings.","solution":"def can_form_cyclic_pattern(s: str) -> bool: Determines if the string can be constructed by repeating a substring multiple times. n = len(s) # Double the string (this creates two concatenated copies of the string) doubled_s = s + s # Find the string s within doubled_s, starting from index 1 and ending at index n-1 # (We ignore the first and last character to ensure we don\'t trivially match the original string) if s in doubled_s[1:-1]: return True return False"},{"question":"**Scenario**: You are working as a data scientist at a company that processes a large number of geographic coordinates. You need to frequently find a small number of points that are closest to a specific location, often the origin point. To efficiently query the k closest points from a large dataset, you decide to use a heap-based algorithm. **Problem**: Implement a function, `find_k_closest_points`, which takes a list of 2D points, a positive integer k, and an optional origin point, and returns the k points closest to the origin. **Function Signature**: ```python def find_k_closest_points(points: List[Tuple[int, int]], k: int, origin: Tuple[int, int] = (0, 0)) -> List[Tuple[int, int]]: ``` **Input**: - `points`: List of tuples (x, y) representing the coordinates of points in the 2D plane. - `k`: The number of closest points to find. - `origin`: An optional tuple (x, y) representing the origin point. Default is (0, 0). **Output**: - List of tuples (x, y) representing the k closest points to the origin, in arbitrary order. **Constraints**: - 0 < k <= len(points) - Points are distinct. - Allowed to use heapq library. **Performance Requirements**: - Time complexity should be O(k + (n - k)log k) - Space complexity should be O(k) **Edge Cases to Consider**: - k is equal to the length of the points list. - Multiple points have the same distance from the origin. - Points list contains negative coordinates. # Example: ```python points = [(1, 3), (3, 4), (2, -1)] k = 2 print(find_k_closest_points(points, k)) # Output: [(1, 3), (2, -1)] points = [(1, 2), (1, 1), (1, 3), (1, 4), (2, 2), (2, 3), (3, 3)] k = 3 print(find_k_closest_points(points, k)) # Output: [(1, 1), (1, 2), (2, 2)] ``` # Notes: 1. You may assume all inputs are valid and adhere to constraints. 2. The points list will always contain at least k elements. 3. The origin will always be a valid 2D coordinate.","solution":"from typing import List, Tuple import heapq def find_k_closest_points(points: List[Tuple[int, int]], k: int, origin: Tuple[int, int] = (0, 0)) -> List[Tuple[int, int]]: def squared_distance(point): Helper function to calculate squared distance from the point to the origin. return (point[0] - origin[0]) ** 2 + (point[1] - origin[1]) ** 2 # Create a max-heap with the first k points (using negative distance for max-heap simulation) max_heap = [(-squared_distance(points[i]), points[i]) for i in range(k)] heapq.heapify(max_heap) # Iterate over the rest of the points for i in range(k, len(points)): dist = squared_distance(points[i]) if -max_heap[0][0] > dist: heapq.heappop(max_heap) heapq.heappush(max_heap, (-dist, points[i])) # Extract the points from the heap return [point for _, point in max_heap]"},{"question":"Question Scenario: You are working as a software engineer, and you need to implement a sorting feature for a data analytics tool. Your task is to provide an efficient algorithm to sort arrays of numbers to help with data visualization and analytics. Problem Statement: Write a function `heap_sort` that sorts an array of integers in ascending order using the heap sort algorithm. You should use a max-heap to accomplish this sorting. The function should follow these requirements: * The function must not use any additional data structures or libraries for sorting. * You should implement the heapify process inside this sort function. Function Signature: ```python def heap_sort(arr: list[int]) -> list[int]: pass ``` Input: * A list of integers `arr` (0 ≤ len(arr) ≤ 10^4 and -10^6 ≤ arr[i] ≤ 10^6). Output: * A list of integers sorted in ascending order. Example: ```python assert heap_sort([4, 10, 3, 5, 1]) == [1, 3, 4, 5, 10] assert heap_sort([-1, -4, 0, 2, 5]) == [-4, -1, 0, 2, 5] assert heap_sort([]) == [] ``` # Constraints: 1. You must implement the heap sort algorithm using a max-heap. 2. The algorithm should handle edge cases gracefully, such as empty array and arrays with all identical elements. 3. The algorithm should operate efficiently with a time complexity of O(n log(n)). # Additional Notes: * Do not use Python\'s built-in sort functions. * You may define additional helper functions if necessary.","solution":"def heap_sort(arr: list[int]) -> list[int]: def heapify(arr, n, i): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] > arr[largest]: largest = left if right < n and arr[right] > arr[largest]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest) n = len(arr) # Build a maxheap for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) # Extract elements one by one for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap heapify(arr, i, 0) return arr"},{"question":"You are working for an aerospace company that needs to determine the critical breaking point (in terms of height) of a new type of glass used in aircraft windows. To achieve this, you must find the highest possible floor from which the glass can be dropped without breaking. You have a building with `N` floors and `K` pieces of glass, and you want to minimize the number of drops in the worst case scenario to determine this breaking point. Implement a function `minimum_drops(N: int, K: int) -> int` that takes in two integers, `N` (number of floors) and `K` (number of pieces of glass) and returns the minimum number of drops required in the worst case scenario to find out the highest floor from which the glass can be dropped without breaking. # Input Format * `N`: Number of floors (1 ≤ N ≤ 1000). * `K`: Number of pieces of glass (1 ≤ K ≤ 100). # Output Format * An integer representing the minimum number of drops required in the worst case scenario. # Constraints * You cannot reuse any glass piece once it breaks. * The glass will not break if dropped from floor 0. * The glass will always break if dropped from any floor higher than the critical floor. # Function Signature ```python def minimum_drops(N: int, K: int) -> int: pass ``` # Example ```python # Example 1 print(minimum_drops(2, 1)) # Output: 2 # Example 2 print(minimum_drops(10, 2)) # Output: 4 ``` # Explanation * In the first example, with 1 glass and 2 floors, the worst-case scenario requires 2 drops (from floors 1 and 2). * In the second example, with 2 glass pieces and 10 floors, the worst-case scenario requires 4 drops. This is because the algorithm balances both the number of glass pieces and the floors to determine the minimum trials needed.","solution":"def minimum_drops(N: int, K: int) -> int: Returns the minimum number of drops required in the worst case scenario to determine the highest floor from which the glass can be dropped without breaking. # dp[k][n] represents the minimum number of drops required with k glasses and n floors dp = [[0] * (N + 1) for _ in range(K + 1)] for k in range(1, K + 1): for n in range(1, N + 1): if k == 1: dp[k][n] = n else: dp[k][n] = float(\'inf\') for x in range(1, n + 1): break_case = dp[k - 1][x - 1] no_break_case = dp[k][n - x] worst_case_drops = 1 + max(break_case, no_break_case) dp[k][n] = min(dp[k][n], worst_case_drops) return dp[K][N]"},{"question":"# Question: Graph Path Finder Given an undirected graph represented as an adjacency list, implement a function to determine whether there is a path between two given nodes using both Depth First Search (DFS) and Breadth First Search (BFS) algorithms. Input * A dictionary `graph` where the keys are nodes and the values are lists of neighboring nodes. * A `start_node` representing the starting point. * An `end_node` representing the destination node. Output * A tuple `(dfs_path_exists, bfs_path_exists)`: * `dfs_path_exists`: A boolean indicating if there is a path from `start_node` to `end_node` using DFS. * `bfs_path_exists`: A boolean indicating if there is a path from `start_node` to `end_node` using BFS. Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } start_node = \'A\' end_node = \'F\' ``` For the above graph: * `dfs_path_exists` should return `True` because there is a path A -> C -> F * `bfs_path_exists` should return `True` because there is a path A -> B -> E -> F An example implementation should be: ```python def graph_path_finder(graph, start_node, end_node): def dfs(graph, start, end, visited): stack = [start] while stack: node = stack.pop() if node == end: return True if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: stack.append(neighbor) return False def bfs(graph, start, end): queue = [start] visited = set() while queue: node = queue.pop(0) if node == end: return True if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return False dfs_path_exists = dfs(graph, start_node, end_node, set()) bfs_path_exists = bfs(graph, start_node, end_node) return dfs_path_exists, bfs_path_exists # Verifying the example graph print(graph_path_finder(graph, start_node, end_node)) # Output: (True, True) ``` Constraints * The graph is undirected. * Ensure to handle disconnected graphs and isolated nodes.","solution":"def graph_path_finder(graph, start_node, end_node): def dfs(graph, start, end, visited): stack = [start] while stack: node = stack.pop() if node == end: return True if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: stack.append(neighbor) return False def bfs(graph, start, end): queue = [start] visited = set() while queue: node = queue.pop(0) if node == end: return True if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return False dfs_path_exists = dfs(graph, start_node, end_node, set()) bfs_path_exists = bfs(graph, start_node, end_node) return dfs_path_exists, bfs_path_exists"},{"question":"# Binomial Coefficient Calculation Context: The binomial coefficient is a widely used concept in combinatorics, which represents the number of ways to select (k) elements from a set of (n) elements. It is denoted as (C(n, k)) and defined mathematically as: [ C(n, k) = frac{n!}{k!(n-k)!} ] Task: Implement a function `iterative_binomial_coefficient(n, k)` to compute the binomial coefficient (C(n, k)) using an iterative approach. Your implementation should avoid recursion to handle larger values efficiently without risking stack overflow. # Input: - Two integers (n) and (k) where (n geq k geq 0). # Output: - An integer representing (C(n, k)). # Constraints: - (0 leq k leq n leq 10^9) # Performance Requirements: - The solution should be optimized to run in at most (O(k)) time complexity. - Avoid excessive memory use; strive for (O(1)) additional space beyond the input parameters. # Example: ```python >>> iterative_binomial_coefficient(5, 3) 10 >>> iterative_binomial_coefficient(8, 2) 28 >>> iterative_binomial_coefficient(10, 0) 1 >>> iterative_binomial_coefficient(10, 10) 1 >>> iterative_binomial_coefficient(500, 300) x # Some large integer output ``` # Note: - Handle the situation where (k > n) by raising a `ValueError` with the message: \'Invalid Inputs, ensure that n >= k\'. - Utilize properties such as symmetry (C(n, k) = C(n, n-k)) to potentially simplify the iteration process.","solution":"def iterative_binomial_coefficient(n, k): Computes the binomial coefficient C(n, k) iteratively. if k > n: raise ValueError(\'Invalid Inputs, ensure that n >= k\') # Utilize C(n, k) = C(n, n-k) k = min(k, n - k) if k == 0: return 1 c = 1 for i in range(k): c = c * (n - i) // (i + 1) return c"},{"question":"Scenario: You are a software developer tasked with optimizing search operations on a large, sorted dataset. The dataset represents a list of product prices in ascending order. Given the requirement for frequent and fast searches, you decide to utilize the Jump Search algorithm for efficient retrieval of specific prices. Problem: Implement the function `jump_search` that performs a Jump Search on the provided sorted list of prices `arr` to find the target price `target`. **Function Signature**: ```python def jump_search(arr: List[int], target: int) -> int: ``` **Input**: - `arr`: A list of integers representing sorted product prices (0 ≤ length of arr ≤ 10^6). - `target`: An integer representing the price to search for (0 ≤ target ≤ 10^9). **Output**: - An integer representing the index of the target price in the array. Return `-1` if the target price is not found. **Constraints**: - The array `arr` is guaranteed to be sorted in ascending order. - The function should be optimal in terms of performance to handle up to 10^6 elements efficiently. Example: ```python assert jump_search([1, 3, 5, 7, 9, 11, 13, 15], 9) == 4 assert jump_search([2, 4, 6, 8, 10, 12, 14, 16], 5) == -1 assert jump_search([1, 1, 1, 1, 1, 1, 1, 1], 1) == 0 ``` Explanation: 1. In the first example, the target price `9` is found at index `4`. 2. In the second example, the target price `5` is not present in the array, hence the function returns `-1`. 3. In the third example, the target price `1` is found at the first occurrence, which is index `0`.","solution":"import math from typing import List def jump_search(arr: List[int], target: int) -> int: Perform a jump search on the sorted list of prices to find the target price. Parameters: arr (List[int]): Sorted list of product prices. target (int): The price to search for. Returns: int: The index of the target price in the list, or -1 if not found. n = len(arr) if n == 0: return -1 # Finding the block size to jump step = int(math.sqrt(n)) prev = 0 # Finding the block where the element is present (if it is present) while arr[min(step, n) - 1] < target: prev = step step += int(math.sqrt(n)) if prev >= n: return -1 # Doing a linear search for target in the block beginning with prev for i in range(prev, min(step, n)): if arr[i] == target: return i return -1"},{"question":"# Question: Combination Sum with Dynamic Programming You are tasked with finding the number of possible combinations that add up to a given target number using a list of unique positive integers. The order of numbers in the combination matters. Function Signature ```python def count_combinations(nums: List[int], target: int) -> int: pass ``` Input - `nums`: A list of unique positive integers `[1 <= nums[i] <= 100]`. - `target`: A positive integer `target` (1 <= `target` <= 1000). Output - Returns an integer representing the number of possible combinations that add up to the `target`. Constraints - All elements in `nums` are unique. - Numbers and target are positive. - Different sequences of the same combination are counted as distinct. Example ```python nums = [1, 2, 3] target = 4 # The function should return 7. ``` Explanation: The possible combinations are: 1. (1, 1, 1, 1) 2. (1, 1, 2) 3. (1, 2, 1) 4. (1, 3) 5. (2, 1, 1) 6. (2, 2) 7. (3, 1) Follow-up Questions 1. If negative numbers are allowed in the `nums` list, how could it affect the current problem? 2. What additional constraints or changes to the algorithm are required to handle negative numbers to avoid infinite loops or invalid states? Implementation Implement the `count_combinations` function using both top-down and bottom-up dynamic programming approaches in separate cells/blocks.","solution":"from typing import List def count_combinations(nums: List[int], target: int) -> int: # Dynamic Programming - Bottom-Up approach dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for num in nums: if i - num >= 0: dp[i] += dp[i - num] return dp[target]"},{"question":"Given two compatible two-dimensional matrices, write a function `multiply_matrices` to return their product. The function should implement the matrix multiplication algorithm, ensuring compatibility of the input matrices beforehand. Input 1. `multiplicand` (list of list of integers): The first matrix A of size m x n. 2. `multiplier` (list of list of integers): The second matrix B of size n x p. Output - A list of list of integers representing the resultant matrix of size m x p after performing the multiplication. Constraints - Ensure that the number of columns in `multiplicand` is equal to the number of rows in `multiplier`. - The input matrices can contain negative, zero, and positive integers. - Matrices will not be larger than 50x50. Performance Requirements - Your implementation should handle the worst-case scenario efficiently considering the constraints provided. # Function Signature ```python def multiply_matrices(multiplicand: list, multiplier: list) -> list: pass ``` # Example ```python # Example 1: multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8], [9, 10], [11, 12] ] # Output: # [ # [58, 64], # [139, 154] # ] # Example 2: multiplicand = [ [2, 0, -1] ] multiplier = [ [3], [-2], [0] ] # Output: # [ # [6] # ] ``` # Notes - If the matrices are not compatible, the function should raise an appropriate exception with a message: \\"Multiplicand matrix not compatible with Multiplier matrix.\\" Implement the function `multiply_matrices` to solve the problem as described above.","solution":"def multiply_matrices(multiplicand, multiplier): if len(multiplicand[0]) != len(multiplier): raise ValueError(\\"Multiplicand matrix not compatible with Multiplier matrix.\\") m = len(multiplicand) n = len(multiplicand[0]) p = len(multiplier[0]) result = [[0 for _ in range(p)] for _ in range(m)] for i in range(m): for j in range(p): for k in range(n): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Question: Implement a Bitwise Subtraction Algorithm Objective: Create a function that subtracts one positive integer from another using bitwise operations only. The function should not use the \'-\' operator directly but should perform the subtraction by utilizing bitwise operations. Function Signature: ```python def subtract_bitwise_operator(a: int, b: int) -> int: pass ``` # Description: When implementing the subtraction of two non-negative integers `a` and `b` (where `a >= b`), follow these steps: 1. Use bitwise operations to borrow bits where needed, much like the addition process but in reverse. 2. The process of borrowing can be visualized as the bitwise complement operation to find the two\'s complement of the number to be subtracted. # Expected Input and Output Formats: * **Input**: * Two non-negative integers `a` and `b` (0 ≤ b ≤ a ≤ 10^9). * **Output**: * A single integer representing the result of `a - b`. # Constraints: * Both `a` and `b` will be non-negative. * `a` will always be greater than or equal to `b`. * You cannot use the \'-\' operator directly. # Example: ```python assert subtract_bitwise_operator(15, 5) == 10 assert subtract_bitwise_operator(20, 13) == 7 assert subtract_bitwise_operator(0, 0) == 0 ``` # Performance Requirements: * The function should run in linear time relative to the number of bits in the largest number, i.e., O(n) where n is the bit-length of the integers. # Edge Cases to Consider: * Subtracting 0 from any number (should return the number itself). * The function should handle large integer values efficiently. # Implementation Hints: * Utilize the properties of the two\'s complement representation. * Understand how bitwise NOT, AND, and XOR operations can facilitate the subtraction process. Good luck and happy coding!","solution":"def subtract_bitwise_operator(a: int, b: int) -> int: Subtract b from a using bitwise operations only. while b != 0: # Calculate borrow borrow = (~a) & b # Perform subtraction a = a ^ b # Update b with the borrow shifted left b = borrow << 1 return a"},{"question":"# Task Implement a `MaxStack` class that maintains elements in a stack such that the maximum element can be accessed in O(1) time. The `MaxStack` should support the following operations: 1. `push(val)`: Push a new element `val` onto the stack. 2. `pop()`: Remove and return the top element of the stack. 3. `top()`: Get the top element of the stack without removing it. 4. `get_max()`: Retrieve the maximum element in the stack. # Requirements * **Input and Output Formats**: * `push(val: int) -> None` * `pop() -> int` * `top() -> int` * `get_max() -> int` # Constraints * -10^7 <= val <= 10^7 * At most 10^5 operations will be performed. # Example ```python stack = MaxStack() stack.push(5) stack.push(1) stack.push(5) assert stack.top() == 5 assert stack.pop() == 5 assert stack.get_max() == 5 assert stack.pop() == 1 assert stack.get_max() == 5 assert stack.pop() == 5 ``` # Instructions Implement the `MaxStack` class according to the given specifications, ensuring the constraints and properties of a stack are maintained while optimizing for the `get_max` operation.","solution":"class MaxStack: def __init__(self): Initialize the MaxStack with a main stack and an auxiliary max stack. self.stack = [] self.max_stack = [] def push(self, val: int) -> None: Push a new element val onto the stack. self.stack.append(val) if not self.max_stack or val >= self.max_stack[-1]: self.max_stack.append(val) else: self.max_stack.append(self.max_stack[-1]) def pop(self) -> int: Remove and return the top element of the stack. if self.stack: self.max_stack.pop() return self.stack.pop() return None def top(self) -> int: Get the top element of the stack without removing it. if self.stack: return self.stack[-1] return None def get_max(self) -> int: Retrieve the maximum element in the stack. if self.max_stack: return self.max_stack[-1] return None"},{"question":"You are given the task of calculating the number of ways to choose `r` items from a set of `n` items, which is denoted as (C(n, r)) or nCr. You are expected to write a function to perform this calculation efficiently using dynamic programming. # Function Signature ```python def combination_dp(n: int, r: int) -> int: pass ``` # Input * `n` (an integer, (0 leq n leq 1000)): The total number of items. * `r` (an integer, (0 leq r leq n)): The number of items to choose. # Output * Return an integer which is the value of nCr. # Constraints * Use dynamic programming to ensure that the solution runs efficiently for large values of `n` and `r`. # Example ```python assert combination_dp(5, 2) == 10 assert combination_dp(10, 5) == 252 assert combination_dp(0, 0) == 1 assert combination_dp(1000, 0) == 1 ``` # Explanation For `combination_dp(5, 2)`, the number of ways to choose 2 items from a set of 5 items is 10.","solution":"def combination_dp(n: int, r: int) -> int: Returns the value of nCr using dynamic programming. if r > n: return 0 if r == 0 or r == n: return 1 # Initialize a table to store previously computed values of nCr dp = [[0 for _ in range(r+1)] for _ in range(n+1)] # Compute the values in a bottom-up manner for i in range(n+1): for j in range(min(i, r)+1): if j == 0 or j == i: dp[i][j] = 1 else: dp[i][j] = dp[i-1][j-1] + dp[i-1][j] return dp[n][r]"},{"question":"# Context You are given a 2D grid of \'1\'s (land) and \'0\'s (water), and you are required to count the number of distinct islands in the grid. An island is formed by connecting adjacent lands horizontally or vertically. This question aims to test your understanding of graph traversal algorithms, particularly Depth-First Search (DFS). # Task Write a function `count_islands(grid)` that takes a 2D list representing the grid and returns the number of islands. # Input - `grid` (List[List[int]]): A 2D list where `grid[i][j]` is \'1\' representing land or \'0\' representing water. You may assume all four edges of the grid are all surrounded by water. # Output - `int`: The number of islands. # Constraints - 1 <= len(grid) <= 300 - 1 <= len(grid[0]) <= 300 - The grid contains only \'1\' (land) and \'0\' (water). # Example ```python Example 1: Input: grid = [ [“1”, “1”, “1”, “1”, “0”], [“1”, “1”, “0”, “1”, “0”], [“1”, “1”, “0”, “0”, “0”], [“0”, “0”, “0”, “0”, “0”] ] Output: 1 Example 2: Input: grid = [ [“1”, “1”, “0”, “0”, “0”], [“1”, “1”, “0”, “0”, “0”], [“0”, “0”, “1”, “0”, “0”], [“0”, “0”, “0”, “1”, “1”] ] Output: 3 ``` # Requirements 1. Implement Depth-First Search (DFS) to traverse the grid. 2. Ensure to mark visited nodes to avoid counting the same island multiple times. 3. Consider edge cases like empty grid, grid full of water, and grid with a single land cell.","solution":"def count_islands(grid): Returns the number of distinct islands in the grid. if not grid: return 0 def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == \'0\': return grid[i][j] = \'0\' # mark as visited by turning land into water dfs(grid, i+1, j) # down dfs(grid, i-1, j) # up dfs(grid, i, j+1) # right dfs(grid, i, j-1) # left num_islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': num_islands += 1 dfs(grid, i, j) return num_islands"},{"question":"# Context You are designing a feature for a software application that involves calculating all possible combinations of sequences, such as arranging tasks or items in different orders. The ability to generate all permutations of a list of distinct items is crucial in solving this problem. # Task Implement a function `generate_permutations(elements)` that takes a list of unique elements and returns a list containing all the permutations of these elements. # Input * `elements`: A list of distinct integers. # Output * A list of lists, where each list is a permutation of the input list. # Constraints * The size of the input list will not exceed 10 elements. * Each element in the list is distinct. # Example ```python generate_permutations([1, 2, 3]) ``` Expected Output: ```python [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] ``` # Requirements * Optimize the function to handle up to 10 elements efficiently. * Consider edge cases such as an empty list or a list with a single element. * Avoid using libraries that provide direct permutation functions; the point is to assess the implementation of the permutation logic. # Performance Consider both time and space complexity in your solution. Discuss any improvements or optimizations you can think of.","solution":"def generate_permutations(elements): Generates all permutations of the given list of elements. Args: elements (list): A list of distinct elements. Returns: list: A list of lists, where each list is a permutation of the input list. if len(elements) == 0: return [[]] elif len(elements) == 1: return [elements] # Recursive approach to generate permutations result = [] for i in range(len(elements)): first_element = elements[i] remaining_elements = elements[:i] + elements[i+1:] for permutation in generate_permutations(remaining_elements): result.append([first_element] + permutation) return result"},{"question":"# Question: Range Summarization **Problem Statement** You are given a sorted integer array without duplicates. Write a function `summarize_ranges` that returns a summary of its continuous ranges. Each range should be represented as a string where a single number is listed as is, and ranges are expressed in the form \\"start-end\\". **Function Signature** ```python def summarize_ranges(array: List[int]) -> List[str]: ``` **Input** * `array` (List[int]): A sorted list of integers without duplicates (0 ≤ len(array) ≤ 10^5; -10^5 ≤ array[i] ≤ 10^5) **Output** * List[str]: The summary of continuous ranges in the format \\"start-end\\" or \\"number\\" for individual numbers. **Examples** ```python summarize_ranges([0, 1, 2, 4, 5, 7]) # -> [\\"0-2\\", \\"4-5\\", \\"7\\"] summarize_ranges([0, 2, 3, 4, 6, 8, 9]) # -> [\\"0\\", \\"2-4\\", \\"6\\", \\"8-9\\"] summarize_ranges([]) # -> [] summarize_ranges([-1]) # -> [\\"-1\\"] summarize_ranges([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) # -> [\\"0-9\\"] ``` **Constraints** * Your function must run in O(n) time. * Your function should use O(n) additional space. **Detailed Explanation** 1. Initialize an empty list `res` to store the result. 2. If the list is empty, return an empty list. 3. Use iterators to traverse the list while tracking the start and end of each range. 4. For each element, check if it continues the current range; if not, finalize the current range and start a new one. 5. After the loop, make sure to add the last range. Ensure your function handles edge cases such as single-element lists and lists with no continuous ranges.","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: Summarizes the continuous ranges in the given sorted list of integers. Parameters: array (List[int]): A sorted list of integers without duplicates. Returns: List[str]: A list of strings summarizing the continuous ranges. if not array: return [] ranges = [] start = array[0] end = array[0] for i in range(1, len(array)): if array[i] == end + 1: end = array[i] else: if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") start = array[i] end = array[i] if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") return ranges"},{"question":"# Matrix Transformation and Validation You are given a set of matrix transformation functions that can rotate and invert a square matrix. Your task is to write a new function that validates a matrix transformation against the expected output. 1. **Function Signature**: `def validate_transformation(matrix, transformation, expected_output):` 2. **Input Parameters**: * `matrix`: A list of lists representing a n x n matrix. * `transformation`: A string representing one of the transformations (\'rotate_clockwise\', \'rotate_counterclockwise\', \'top_left_invert\', \'bottom_left_invert\'). * `expected_output`: A list of lists representing the expected output matrix after applying the transformation. 3. **Output**: Return a boolean value `True` if the transformed matrix matches the expected output, `False` otherwise. 4. **Constraints**: * The matrix will be a square matrix with dimensions 1 <= n <= 100. * The transformation input will always be valid (one of the four specified). # Scenario and Example: Imagine you are building a system that checks different matrix transformations applied to an image, where each pixel in the image is represented by a matrix cell. Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] transformation = \\"rotate_clockwise\\" expected_output = [ [7, 4, 1], [8, 5, 2], [9, 6, 3], ] # Step-by-step: # Applying \'rotate_clockwise\' on matrix should produce: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3], # ] print(validate_transformation(matrix, transformation, expected_output)) # Should print: True ``` # Requirements: 1. Implement the `validate_transformation` function. 2. Ensure the function accurately applies the specified transformation using the appropriate pre-defined transformation functions. 3. Compare the result to `expected_output` and return `True` or `False`. ```python def rotate_clockwise(matrix): new = [] for row in reversed(matrix): for i, elem in enumerate(row): try: new[i].append(elem) except IndexError: new.insert(i, []) new[i].append(elem) return new def rotate_counterclockwise(matrix): new = [] for row in matrix: for i, elem in enumerate(reversed(row)): try: new[i].append(elem) except IndexError: new.insert(i, []) new[i].append(elem) return new def top_left_invert(matrix): new = [] for row in matrix: for i, elem in enumerate(row): try: new[i].append(elem) except IndexError: new.insert(i, []) new[i].append(elem) return new def bottom_left_invert(matrix): new = [] for row in reversed(matrix): for i, elem in enumerate(reversed(row)): try: new[i].append(elem) except IndexError: new.insert(i, []) new[i].append(elem) return new def validate_transformation(matrix, transformation, expected_output): if transformation == \'rotate_clockwise\': result = rotate_clockwise(matrix) elif transformation == \'rotate_counterclockwise\': result = rotate_counterclockwise(matrix) elif transformation == \'top_left_invert\': result = top_left_invert(matrix) elif transformation == \'bottom_left_invert\': result = bottom_left_invert(matrix) else: raise ValueError(\\"Invalid transformation type\\") return result == expected_output # Example Usage matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] transformation = \\"rotate_clockwise\\" expected_output = [ [7, 4, 1], [8, 5, 2], [9, 6, 3], ] print(validate_transformation(matrix, transformation, expected_output)) # Should print: True ```","solution":"def rotate_clockwise(matrix): return [list(reversed(col)) for col in zip(*matrix)] def rotate_counterclockwise(matrix): return [list(row) for row in zip(*matrix)][::-1] def top_left_invert(matrix): size = len(matrix) return [[matrix[i][j] for j in range(size)] for i in range(size)][::-1] def bottom_left_invert(matrix): size = len(matrix) return [[matrix[i][j] for j in range(size)][::-1] for i in range(size)] def validate_transformation(matrix, transformation, expected_output): if transformation == \'rotate_clockwise\': result = rotate_clockwise(matrix) elif transformation == \'rotate_counterclockwise\': result = rotate_counterclockwise(matrix) elif transformation == \'top_left_invert\': result = top_left_invert(matrix) elif transformation == \'bottom_left_invert\': result = bottom_left_invert(matrix) else: raise ValueError(\\"Invalid transformation type\\") return result == expected_output"},{"question":"# Question: Enhanced Linear Search with Multiple Targets You are tasked to implement an enhanced version of the linear search algorithm. This new version should take an array of integers and an array of query values. Instead of returning the index of a single query, it should return a dictionary where the keys are the query values and the values are lists of indices representing where each query value appears in the array. **Function Signature**: ```python def enhanced_linear_search(array: list, queries: list) -> dict: pass ``` **Input**: - `array`: A list of integers. The length of the list `n` is constrained as (0 leq n leq 10^4). - `queries`: A list of integers representing the values to search in the array. The length of the list `m` is constrained as (0 leq m leq 10^3). **Output**: - A dictionary where the keys are integers from the `queries` list and the values are lists of indices indicating where each query appears in the `array`. If a particular query does not exist in the array, its associated list should be empty. **Constraints**: - Your solution should handle an empty array or an empty queries list gracefully. - Efficient handling of multiple queries is preferred. **Examples**: ```python # Example 1 array = [4, 2, 3, 2, 5, 2, 1] queries = [2, 3] # Expected Output: {2: [1, 3, 5], 3: [2]} # Example 2 array = [1, 2, 3, 4, 5] queries = [6, 7] # Expected Output: {6: [], 7: []} # Example 3 array = [] queries = [1, 2, 3] # Expected Output: {1: [], 2: [], 3: []} ```","solution":"def enhanced_linear_search(array: list, queries: list) -> dict: Given an array and a list of queries, this function returns a dictionary where the keys are the query values and the values are lists of indices where each query value appears in the array. result = {query: [] for query in queries} for index, value in enumerate(array): if value in result: result[value].append(index) return result"},{"question":"**Question**: Optimized Pathfinding in Graphs In a given directed graph, you are to implement an optimized version of the pathfinding functions provided. Given the inherent inefficiencies and the risk of high computing cost in the provided algorithms, your challenge is to implement an efficient pathfinding algorithm that solves the given problems within practical time and space limits. # Task: You need to create two functions: 1. `find_shortest_path_bfs(graph, start, end)`: This function should find the shortest path between two nodes using an optimized approach, suitable for handling large graphs efficiently. 2. `find_path_with_max_nodes(graph, start, end)`: This function should find a path with the maximum number of nodes acyclically between the start and end nodes. # Requirements: 1. Function signatures: ```python def find_shortest_path_bfs(graph, start, end): # your code here def find_path_with_max_nodes(graph, start, end): # your code here ``` 2. **Input Formats**: * `graph`: a dictionary where keys are node identifiers and values are lists of adjacent nodes. * `start`: the starting node identifier. * `end`: the ending node identifier. 3. **Output Formats**: * `find_shortest_path_bfs`: should return a list of nodes representing the shortest path from `start` to `end`. * `find_path_with_max_nodes`: should return a list of nodes representing a path from `start` to `end` with the maximum number of nodes. # Constraints: * The graph is guaranteed to be acyclic. * Node identifiers are unique. * The `start` and `end` nodes are guaranteed to exist in the graph. * Paths always exist between `start` and `end`. # Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\', \'E\'], \'C\': [\'F\'], \'D\': [], \'E\': [\'F\'], \'F\': [] } print(find_shortest_path_bfs(graph, \'A\', \'F\')) # [\'A\', \'C\', \'F\'] print(find_path_with_max_nodes(graph, \'A\', \'F\')) # [\'A\', \'B\', \'E\', \'F\'] ``` # Notes: - Use the Breadth-First Search (BFS) strategy to find the shortest path to ensure efficiency. - Use depth-limited searches to ensure acyclic paths with the maximum number of nodes.","solution":"from collections import deque def find_shortest_path_bfs(graph, start, end): Find the shortest path in terms of number of edges between start and end nodes. Uses a BFS approach to find the shortest path. queue = deque([(start, [start])]) visited = set() while queue: current_node, path = queue.popleft() if current_node == end: return path visited.add(current_node) for neighbor in graph[current_node]: if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return [] def find_path_with_max_nodes(graph, start, end): Finds a path from start to end node with the maximum number of nodes visited. Uses a modified DFS approach to find the longest path in an acyclic graph. def dfs_path_max_nodes(current_node, end, path, visited, result): if current_node == end: if len(path) > len(result[0]): result[0] = path[:] return visited.add(current_node) for neighbor in graph[current_node]: if neighbor not in visited: dfs_path_max_nodes(neighbor, end, path + [neighbor], visited, result) visited.remove(current_node) result = [[]] visited = set() dfs_path_max_nodes(start, end, [start], visited, result) return result[0]"},{"question":"You are requested to implement a function to extend the nearest neighbor algorithm. Instead of selecting the single nearest neighbor, you need to find the **k nearest neighbors** to the given vector and return their associated labels. # Function Signature ```python def k_nearest_neighbors(x: tuple, tSet: dict, k: int) -> list: This function finds the k nearest neighbors for a given vector `x` from a training set `tSet`. Arguments: x -- A tuple representing the input vector. tSet -- A dictionary where keys are tuples (training vectors) and values are labels. k -- An integer representing the number of nearest neighbors to find. Returns: A list of length k containing the labels of the k nearest neighbors. ``` # Input * `x`: A tuple of numerical values representing the vector (1 <= len(x) <= 100). * `tSet`: A dictionary where keys are tuples and values are labels; each tuple represents a vector, and each label is an integer (1 <= |tSet| <= 1000). * `k`: An integer denoting the number of nearest neighbors to find (1 <= k <= len(tSet)). # Output * A list of length `k` containing the labels of the `k` nearest neighbors. # Constraints * Ensure you handle edge cases, such as when multiple vectors are equidistant to the given vector `x`. * The function should be able to handle up to 1000 training vectors efficiently. # Performance Requirements * The implementation should attempt to minimize the computational complexity where feasible. # Example ```python x = (2, 2) tSet = { (1, 1): 0, (2, 3): 1, (3, 4): 0, (6, 6): 1 } k = 2 # Example output: # The two nearest neighbors are (1, 1) and (2, 3) corresponding to labels 0 and 1. print(k_nearest_neighbors(x, tSet, k)) # Output: [0, 1] ``` # Notes * You may use the provided `distance` helper function if needed. * The order of labels in the output list depends on the closeness; if multiple points are equidistant, the order is arbitrary. * Take into consideration the time and space optimizations.","solution":"import math from heapq import nsmallest def euclidean_distance(point1, point2): Helper function to calculate the Euclidean distance between two points. return math.sqrt(sum((coord1 - coord2) ** 2 for coord1, coord2 in zip(point1, point2))) def k_nearest_neighbors(x: tuple, tSet: dict, k: int) -> list: This function finds the k nearest neighbors for a given vector `x` from a training set `tSet`. Arguments: x -- A tuple representing the input vector. tSet -- A dictionary where keys are tuples (training vectors) and values are labels. k -- An integer representing the number of nearest neighbors to find. Returns: A list of length k containing the labels of the k nearest neighbors. # Calculate distances from input vector x to all training vectors distances = [(euclidean_distance(x, vector), label) for vector, label in tSet.items()] # Find the k nearest neighbors k_nearest = nsmallest(k, distances, key=lambda y: y[0]) # Extract and return the labels of the k nearest neighbors return [label for _, label in k_nearest]"},{"question":"Context You are tasked with integrating binary search with an insertion sort algorithm. The insertion sort algorithm typically requires shifting elements to insert a new value in its correct place. The provided function `search_insert` is crucial for finding the correct position of the element efficiently. Task Implement a function named `insertion_sort` that utilizes the `search_insert` function to sort an array of integers in ascending order. Function Signature ```python def insertion_sort(array: List[int]) -> List[int] ``` Input * A list of integers `array` with 0 ≤ length ≤ 10^3. Output * A new list of integers sorted in ascending order. Constraints * You must use the provided `search_insert` function within your solution. * You cannot use any built-in sort functions. Performance Requirements * Your solution should maintain a time complexity of O(n^2), where `n` is the length of the array. Example ```python assert insertion_sort([4,3,2,1]) == [1,2,3,4] assert insertion_sort([1,2,3,4]) == [1,2,3,4] assert insertion_sort([3,1,4,1,5,9,2,6,5,3,5]) == [1,1,2,3,3,4,5,5,5,6,9] ``` Detailed Description 1. Iterate through each element of the array starting from the second element. 2. For each element, determine its correct position using the `search_insert` function. 3. Shift the elements of the array to insert the element in its correct position. 4. Return the sorted array.","solution":"from typing import List def search_insert(array: List[int], value: int) -> int: Binary search to find the position to insert the value. Returns the index where the value should be inserted to keep the array sorted. low = 0 high = len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] < value: low = mid + 1 else: high = mid - 1 return low def insertion_sort(array: List[int]) -> List[int]: Sorts the array using the insertion sort algorithm with binary search to find the correct insertion point. for i in range(1, len(array)): key = array[i] # Find location where the current element should be inserted pos = search_insert(array[:i], key) # Move all elements to the right to make the position for key for j in range(i, pos, -1): array[j] = array[j-1] # Insert the key at its proper location array[pos] = key return array"},{"question":"You are provided with a singly linked list. Your task is to write a function `swap_pairs` that swaps every two adjacent nodes and returns the head of the modified list. Function Signature ```python def swap_pairs(head: Node) -> Node: ``` Input - The `head` of a singly linked list, where each node is an instance of the following class: ```python class Node: def __init__(self, x: int): self.val = x self.next = None ``` Output - Return the `head` of the modified linked list with every pair of nodes swapped. Constraints - Your algorithm should use only constant space. - You may not modify the values in the list, only nodes themselves can be changed. Example ```python # Creating the linked list 1 -> 2 -> 3 -> 4 node1 = Node(1) node2 = Node(2) node1.next = node2 node3 = Node(3) node2.next = node3 node4 = Node(4) node3.next = node4 # After swapping pairs, the list should be 2 -> 1 -> 4 -> 3 new_head = swap_pairs(node1) # To assert the transformation, you would traverse the linked list and check the new order assert new_head.val == 2 assert new_head.next.val == 1 assert new_head.next.next.val == 4 assert new_head.next.next.next.val == 3 ``` Explanation - For the given linked list `1 -> 2 -> 3 -> 4`, after swapping every two adjacent nodes, the linked list should become `2 -> 1 -> 4 -> 3`. - Ensure the solution handles edge cases where the linked list is empty or contains only one node. **Note**: To reinforce the solution’s correctness, include appropriate unit tests covering typical cases and edge cases.","solution":"class Node: def __init__(self, x: int): self.val = x self.next = None def swap_pairs(head: Node) -> Node: if not head or not head.next: return head # Initialize the new head to the second node new_head = head.next prev = None current = head while current and current.next: next_pair = current.next.next second = current.next # Swapping the pair second.next = current current.next = next_pair if prev: prev.next = second # Updating previous node pointer prev = current current = next_pair return new_head"},{"question":"Strongly Connected Components in a Directed Graph Consider a directed graph represented by a set of vertices and edges. A graph is *strongly connected* if there is a path between any two vertices, both in the forward and reverse directions. You are to determine if a given graph is strongly connected. **Given**: - An integer `n` representing the number of vertices. - A list of tuples `edges` where each tuple `(u, v)` represents a directed edge from vertex `u` to vertex `v`. **Task**: Write a function `is_strongly_connected(n: int, edges: List[Tuple[int, int]]) -> bool` that returns `True` if the graph is strongly connected, otherwise `False`. **Input**: 1. `n (1 ≤ n ≤ 10^4)`: The number of vertices. 2. `edges (0 ≤ len(edges) ≤ 2 * 10^4)`: A list of directed edges. **Output**: - Return a boolean indicating if the graph is strongly connected. **Example**: ```python assert is_strongly_connected(5, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]) == True assert is_strongly_connected(5, [(0, 1), (1, 2), (2, 3), (3, 4)]) == False ``` **Constraints**: - The graph is given as a zero-indexed list of edges. - Ensure your solution is optimized for large values of `n` and `len(edges)`. **Performance Note**: - Aim for a time complexity of O(V + E).","solution":"from collections import defaultdict, deque def is_strongly_connected(n, edges): Determines if the directed graph is strongly connected. :param n: int - Number of vertices :param edges: List of tuples representing directed edges (u, v) :return: bool - True if the graph is strongly connected, otherwise False def bfs(start, graph, visited): queue = deque([start]) visited[start] = True visited_count = 1 while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True visited_count += 1 queue.append(neighbor) return visited_count if n == 1: return True # Create adjacency list for the original graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Check reachability from the first node visited_from_first = [False] * n if bfs(0, graph, visited_from_first) != n: return False # Create reversed adjacency list reversed_graph = defaultdict(list) for u, v in edges: reversed_graph[v].append(u) # Check reachability in the reversed graph visited_from_first_reversed = [False] * n if bfs(0, reversed_graph, visited_from_first_reversed) != n: return False return True"},{"question":"# Coding Assessment: K-th Smallest Element in a Binary Search Tree Scenario You are tasked with improving a dataset retrieval system that frequently requires fetching the k-th smallest element from a dynamically updating list of integers. This list is stored in a Binary Search Tree (BST), which maintains a sorted order of elements. Objective Write a function `kth_smallest` that takes the root of a Binary Search Tree and an integer k, and returns the k-th smallest element in the tree. # Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root: TreeNode, k: int) -> int: pass ``` Inputs: - `root` (TreeNode): The root node of the BST. It may be `None` if the tree is empty. - `k` (int): The position (1-indexed) of the smallest element to find in the BST. Outputs: - (int): The k-th smallest element\'s value in the BST. Constraints: 1. The number of nodes in the tree will be in the range [1, 10⁴]. 2. 1 ≤ k ≤ number of nodes in the tree. # Example ```python # Example 1: # Input: root = [3,1,4,null,2], k = 1 # Output: 1 # Example 2: # Input: root = [5,3,6,2,4,null,null,1], k = 3 # Output: 3 ``` # Notes: - Consider edge cases such as an empty tree or invalid k values. - Optimize for time and space efficiency. - The input is given as a TreeNode structure. Implementation Rules - Ensure the function runs in linear time O(N) with respect to the number of nodes. - The function should handle invalid inputs gracefully by raising appropriate exceptions. # Testing - Provide unit tests for various edge cases including very small and large trees. - Verify the function with both very small and very large values of k.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root: TreeNode, k: int) -> int: Returns the k-th smallest element from the Binary Search Tree (BST). :param root: The root node of the BST. :param k: The 1-indexed position of the smallest element to find. :return: The k-th smallest element\'s value in the BST. def inorder_traversal(node): if not node: return [] # Traverse the left subtree, then the current node, then the right subtree return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) # Inorder traversal of the BST gives a sorted list of elements sorted_elements = inorder_traversal(root) # Return the k-th smallest element (1-indexed) return sorted_elements[k - 1]"},{"question":"Scenario: You are developing a spell-checker that provides suggestions for possible correct spellings of a word. To efficiently manage the words in the dictionary and search for them, you decide to implement a data structure that can handle both exact matches and searches that allow for wildcard characters (`.`), where `.` can represent any letter. Task: Implement a class `SpellChecker` that supports the following operations: 1. `add_word(word: str) -> None`: Adds a word to the dictionary. 2. `search(word: str) -> bool`: Returns `True` if the word is in the dictionary, or if the word can match any word in the dictionary where `.` is used as a wildcard character. Expected Input and Output: * Input: - For `add_word`: A string `word` consisting of lowercase letters (1 <= len(word) <= 100) to be added to the dictionary. - For `search`: A string `word` consisting of lowercase letters and/or `.` characters (1 <= len(word) <= 100) to be searched in the dictionary. * Output: - For `search`: A boolean indicating if the `word` is found in the dictionary. Constraints: * The dictionary will contain up to 10^4 words. * Implement the solution efficiently considering both space and time complexities. Example: ```python # Initialize your data structure spell_checker = SpellChecker() # Add words to the dictionary spell_checker.add_word(\\"bad\\") spell_checker.add_word(\\"dad\\") spell_checker.add_word(\\"mad\\") # Search words or patterns print(spell_checker.search(\\"pad\\")) # Returns False print(spell_checker.search(\\"bad\\")) # Returns True print(spell_checker.search(\\".ad\\")) # Returns True print(spell_checker.search(\\"b..\\")) # Returns True print(spell_checker.search(\\"b.d\\")) # Returns True print(spell_checker.search(\\"...\\")) # Returns True print(spell_checker.search(\\"....\\")) # Returns False ``` Implement the `SpellChecker` class to accomplish the requirement efficiently. Evaluate both exact and wildcard searches within the constraints.","solution":"class SpellChecker: def __init__(self): self.dictionary = [] def add_word(self, word: str) -> None: Adds a word to the dictionary. self.dictionary.append(word) def search(self, word: str) -> bool: Returns true if the word is in the dictionary, or if the word can match any word in the dictionary where `.` is used as a wildcard character. for dict_word in self.dictionary: if self._matches(dict_word, word): return True return False def _matches(self, dict_word: str, pattern: str) -> bool: if len(dict_word) != len(pattern): return False for dw_char, pt_char in zip(dict_word, pattern): if pt_char != \'.\' and dw_char != pt_char: return False return True"},{"question":"# Permutation Generation Challenge Context You are tasked with writing a function to generate the next lexicographical permutation of a given integer. Given a number, your function should return the next higher number which has the exact same set of digits as the original number. If no such higher number exists, the function should return -1. Problem Statement Write a Python function `next_bigger(num: int) -> int` that takes a single integer as input and returns the next higher permutation of its digits. Input * An integer `num` which is a positive number. Output * Return the next higher permutation of the digits of `num` as an integer. * If such a permutation does not exist, return -1. Constraints * The input value `num` will be such that `1 <= num <= 10^18`. Examples ```python next_bigger(38276) # returns 38627 next_bigger(12345) # returns 12354 next_bigger(99999) # returns -1 next_bigger(5) # returns -1 ``` # Detailed Description Your implementation should: 1. Identify the largest index `i` such that `array[i − 1] < array[i]`. If no such index exists, return -1. 2. Find the largest index `j` such that `j ≥ i` and `array[j] > array[i − 1]`. 3. Swap the values at `array[j]` and `array[i − 1]`. 4. Reverse the subarray starting from `i`. Edge Cases * Consider single-digit numbers. * Handle numbers where no next permutation is possible (e.g., `54321`). * Efficiently manage numbers with repeated digits. Performance * Aim for a solution with time complexity of O(n) and space complexity of O(n), where `n` is the number of digits in the input number.","solution":"def next_bigger(num: int) -> int: Returns the next higher permutation of the digits of the given number. If no such permutation exists, returns -1. num_list = list(str(num)) n = len(num_list) # Step 1: Find the largest index i such that num_list[i - 1] < num_list[i] i = n - 1 while i > 0 and num_list[i - 1] >= num_list[i]: i -= 1 if i == 0: return -1 # Step 2: Find the largest index j such that j >= i and num_list[j] > num_list[i - 1] j = n - 1 while num_list[j] <= num_list[i - 1]: j -= 1 # Step 3: Swap the value of num_list[j] and num_list[i - 1] num_list[i - 1], num_list[j] = num_list[j], num_list[i - 1] # Step 4: Reverse the subarray starting from i num_list = num_list[:i] + num_list[i:][::-1] return int(\'\'.join(num_list))"},{"question":"# Question: Implement a Custom Multi-dimensional Selection Sort You are required to extend the basic selection sort algorithm to handle a 2D array (a matrix). Given a `n x m` matrix where `n` is the number of rows and `m` is the number of columns, implement a function that will sort the entire matrix in ascending order. Note that the matrix should be sorted row-wise but handle column elements as well, ensuring the entire matrix remains sorted. Input and Output Formats: - **Input:** A 2D list (matrix) of integers `matrix` with dimensions `n x m`. - **Output:** Return a new 2D list (matrix) where the matrix elements are sorted in ascending order. Constraints: - The number of elements in `n x m` will not exceed 10,000. - Each row of the matrix will have the same number of columns. Performance Requirements: - The solution should aim to maintain O(n^2) time complexity of the underlying selection sort while accommodating the 2D structure. Example: # Input: ``` matrix = [ [3, 1, 2], [6, 4, 5], [9, 8, 7] ] ``` # Output: ``` sorted_matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` Implementation: Create a function `matrix_selection_sort(matrix)` that performs the sorting as described. ```python def matrix_selection_sort(matrix): # Flatten the matrix into a single list flat_list = [item for sublist in matrix for item in sublist] # Implement selection sort on the flat list for i in range(len(flat_list)): min_index = i for j in range(i + 1, len(flat_list)): if flat_list[j] < flat_list[min_index]: min_index = j flat_list[i], flat_list[min_index] = flat_list[min_index], flat_list[i] # Reconstruct the sorted matrix from the sorted list sorted_matrix = [] k = 0 for row in range(len(matrix)): sorted_row = [] for col in range(len(matrix[0])): sorted_row.append(flat_list[k]) k += 1 sorted_matrix.append(sorted_row) return sorted_matrix # Example usage: matrix = [ [3, 1, 2], [6, 4, 5], [9, 8, 7] ] print(matrix_selection_sort(matrix)) ```","solution":"def matrix_selection_sort(matrix): Sorts a 2D list (matrix) in ascending order. # Flatten the matrix into a single list flat_list = [item for sublist in matrix for item in sublist] # Implement selection sort on the flat list for i in range(len(flat_list)): min_index = i for j in range(i + 1, len(flat_list)): if flat_list[j] < flat_list[min_index]: min_index = j flat_list[i], flat_list[min_index] = flat_list[min_index], flat_list[i] # Reconstruct the sorted matrix from the sorted list sorted_matrix = [] k = 0 for row in range(len(matrix)): sorted_row = [] for col in range(len(matrix[0])): sorted_row.append(flat_list[k]) k += 1 sorted_matrix.append(sorted_row) return sorted_matrix"},{"question":"# Question Scenario: You are working on a project that involves serializing and deserializing binary trees for network communication. One particular case involves full binary trees, where each node has either zero or two children. Given the preorder and postorder traversal arrays of such a tree, you need to reconstruct the binary tree and return its inorder traversal. Task: Write a function `reconstruct_inorder(preorder: List[int], postorder: List[int]) -> List[int]` that takes the preorder and postorder traversal arrays of a full binary tree and returns its inorder traversal as a list of integers. Input: - `preorder`: A list of integers representing the preorder traversal of the full binary tree. - `postorder`: A list of integers representing the postorder traversal of the full binary tree. Output: - A list of integers representing the inorder traversal of the constructed binary tree. Constraints: - The number of nodes in the tree is `n`, where `1 <= n <= 1000`. - It is guaranteed that the input forms a valid full binary tree with unique node values. Example: ```python preorder = [1, 2, 4, 5, 3, 6, 7] postorder = [4, 5, 2, 6, 7, 3, 1] result = reconstruct_inorder(preorder, postorder) print(result) # Output should be: [4, 2, 5, 1, 6, 3, 7] ``` Notes: - You may assume that the input lists will always be valid full binary tree traversals. - You can define additional helper functions as necessary. - Aim for a solution with a time complexity of O(n), where possible.","solution":"from typing import List class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(preorder: List[int], postorder: List[int]) -> TreeNode: if not preorder or not postorder: return None if len(preorder) == 1: return TreeNode(preorder[0]) root = TreeNode(preorder[0]) left_subtree_root = preorder[1] left_subtree_size = postorder.index(left_subtree_root) + 1 root.left = build_tree(preorder[1:1+left_subtree_size], postorder[:left_subtree_size]) root.right = build_tree(preorder[1+left_subtree_size:], postorder[left_subtree_size:-1]) return root def inorder_traversal(root: TreeNode) -> List[int]: if root is None: return [] return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) def reconstruct_inorder(preorder: List[int], postorder: List[int]) -> List[int]: root = build_tree(preorder, postorder) return inorder_traversal(root)"},{"question":"# Question: Implement an Enhanced Resizable HashTable Given the base `HashTable` and `ResizableHashTable` implementations, your task is to enhance the `ResizableHashTable` to support the following additional features: 1. **Load Factor Management**: - Allow the user to specify a maximum load factor at initialization. - The HashTable should dynamically resize to maintain the load factor below this threshold. 2. **Custom Probing Strategy**: - Implement a quadratic probing mechanism for collision resolution. 3. **Improved Efficiency**: - Track the number of operations and optimize for frequent insertions by implementing a batch update mechanism which allows a group of insertions to be handled together. # Function Specifications: * **Class `EnhancedResizableHashTable`**: - Should inherit from `ResizableHashTable`. - **Initialization**: - Accept an additional `max_load_factor` parameter (default 0.75). - **Method `put_batch(self, key_value_pairs)`**: - Accepts a list of `(key, value)` tuples and inserts them. - Ensure that resizing is efficiently managed during batch insertion. * **Method Signatures**: ```python class EnhancedResizableHashTable(ResizableHashTable): def __init__(self, max_load_factor=0.75): # initialize with specified max load factor pass def put_batch(self, key_value_pairs): # batch insert key-value pairs efficiently pass def _rehash(self, old_hash, attempt): # Implement quadratic rehashing pass ``` # Input & Output: - **Input**: A sequence of method calls to `put`, `get`, and `put_batch`. - **Output**: The correct state of the HashTable after all operations. # Constraints: - Keys are non-negative integers. - Initial HashTable size is set to 8. - The load factor for resizing does not exceed the specified `max_load_factor`. # Example: ```python hash_table = EnhancedResizableHashTable(max_load_factor=0.6) hash_table.put(1, \\"one\\") hash_table.put(2, \\"two\\") hash_table.put_batch([(3, \\"three\\"), (4, \\"four\\")]) print(hash_table.get(1)) # should return \\"one\\" print(hash_table.get(4)) # should return \\"four\\" ``` # Notes: - Ensure the handling of collisions is properly managed with the new quadratic probing. - Implement necessary helper functions to maintain readability and functionality.","solution":"class ResizableHashTable: def __init__(self, initial_size=8): self.table = [None] * initial_size self.count = 0 def hash_function(self, key): return key % len(self.table) def put(self, key, value): index = self.hash_function(key) attempt = 0 while self.table[index] is not None and self.table[index][0] != key: attempt += 1 index = (index + self._rehash(key, attempt)) % len(self.table) if self.table[index] is None: self.count += 1 self.table[index] = (key, value) if self.load_factor() > 0.75: self.rehash_table() def get(self, key): index = self.hash_function(key) attempt = 0 while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] attempt += 1 index = (index + self._rehash(key, attempt)) % len(self.table) return None def load_factor(self): return self.count / len(self.table) def rehash_table(self): old_table = self.table self.table = [None] * (2 * len(old_table)) self.count = 0 for item in old_table: if item is not None: self.put(item[0], item[1]) def _rehash(self, old_hash, attempt): return attempt class EnhancedResizableHashTable(ResizableHashTable): def __init__(self, max_load_factor=0.75): super().__init__() self.max_load_factor = max_load_factor def put_batch(self, key_value_pairs): for key, value in key_value_pairs: self.put(key, value) if self.load_factor() > self.max_load_factor: self.rehash_table() def _rehash(self, old_hash, attempt): # Implement quadratic rehashing return (attempt * attempt)"},{"question":"# Question: Advanced Path Finding in Graphs **Context**: You are responsible for implementing a navigation system for an autonomous robot navigating through a grid-based warehouse. The warehouse is represented as an unweighted graph, and the robot needs effective algorithms to traverse between nodes (positions in the warehouse). **Problem**: Implement a function named `find_optimal_path` that combines the following functionalities: - Finds a path from a start node to an end node. - Identifies all possible paths from a start node to an end node. - Discovers the shortest path between two nodes. Your function should handle cycles efficiently and operate within reasonable time limits for moderately sized graphs (up to 1000 nodes). **Requirements**: - Implement a class `Graph` with methods: - `add_edge(self, u, v)`: Adds an edge between nodes `u` and `v`. - `find_path(self, start, end)`: Returns a path from `start` to `end`. - `find_all_paths(self, start, end)`: Returns all paths from `start` to `end`. - `find_shortest_path(self, start, end)`: Returns the shortest path from `start` to `end`. ```python class Graph: def __init__(self): self.graph = {} def add_edge(self, u, v): Adds an edge between nodes u and v. # your code here def find_path(self, start, end): Returns a single path from start to end. # your code here def find_all_paths(self, start, end): Returns all paths from start to end. # your code here def find_shortest_path(self, start, end): Returns the shortest path from start to end. # your code here ``` **Input Format**: - `add_edge(self, u, v)`: - `u` and `v`: Nodes in the graph (integers or strings). - `find_path(self, start, end)`, `find_all_paths(self, start, end)`, `find_shortest_path(self, start, end)`: - `start` and `end`: Nodes in the graph. **Output Format**: - `find_path`: Returns a list representing a path, or None if no path exists. - `find_all_paths`: Returns a list of lists, where each inner list is a unique path. - `find_shortest_path`: Returns a list representing the shortest path, or None if no path exists. **Constraints**: - Graph can have up to 1000 nodes. - There are no parallel edges. - The graph is unweighted. **Performance Requirements**: - `find_path` and `find_shortest_path` should run efficiently on graphs with up to 1000 nodes. - `find_all_paths` might be slower but should handle the graph size within reasonable limits.","solution":"from collections import defaultdict, deque class Graph: def __init__(self): self.graph = defaultdict(list) def add_edge(self, u, v): Adds an edge between nodes u and v. self.graph[u].append(v) self.graph[v].append(u) # Assuming the graph is undirected def find_path(self, start, end): Returns a single path from start to end. visited = set() stack = [(start, [start])] while stack: (vertex, path) = stack.pop() if vertex in visited: continue if vertex == end: return path visited.add(vertex) for neighbor in self.graph[vertex]: if neighbor not in visited: stack.append((neighbor, path + [neighbor])) return None def find_all_paths(self, start, end): Returns all paths from start to end. def dfs(current, end, path, paths): path.append(current) if current == end: paths.append(path.copy()) else: for neighbor in self.graph[current]: if neighbor not in path: dfs(neighbor, end, path, paths) path.pop() paths = [] dfs(start, end, [], paths) return paths def find_shortest_path(self, start, end): Returns the shortest path from start to end. visited = set() queue = deque([(start, [start])]) while queue: (vertex, path) = queue.popleft() if vertex in visited: continue if vertex == end: return path visited.add(vertex) for neighbor in self.graph[vertex]: if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return None"},{"question":"# Advanced Quick Sort Implementation You are required to implement an optimized version of the Quick Sort algorithm. The goal is to enhance the basic Quick Sort provided in the snippets by introducing optimizations and addressing performance risks. Requirements: 1. **Pivot Selection**: - Implement a median-of-three method for pivot selection to improve average performance and avoid the worst-case scenario. 2. **Tail Call Optimization**: - Recognize and optimize tail recursive calls to reduce stack space usage. 3. **Input Constraints**: - Array size: `1 ≤ len(arr) ≤ 10^6` - Element values: `-10^9 ≤ arr[i] ≤ 10^9` Function Signature: ```python def quick_sort_optimized(arr): pass ``` Input: - `arr` (List of integers): List of integers that need to be sorted. Output: - (List of integers): A sorted list of integers in ascending order. Example: ```python assert quick_sort_optimized([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10] assert quick_sort_optimized([10, 7, 8, 9, 1, 5]) == [1, 5, 7, 8, 9, 10] assert quick_sort_optimized([4, 4, 4, 4, 4]) == [4, 4, 4, 4, 4] ``` Constraints: - Optimize for time and space complexity based on the constraints provided. - Ensure the function can handle large input sizes effectively. Additional Notes: - Include comments within your code to explain the pivot selection and tail call optimization. - Handle edge cases such as empty array and arrays with duplicate values gracefully.","solution":"def quick_sort_optimized(arr): Optimized Quick Sort using median-of-three pivot selection and iterative approach to minimize stack usage. def median_of_three(low, high): mid = (low + high) // 2 if arr[low] > arr[mid]: arr[low], arr[mid] = arr[mid], arr[low] if arr[low] > arr[high]: arr[low], arr[high] = arr[high], arr[low] if arr[mid] > arr[high]: arr[mid], arr[high] = arr[high], arr[mid] return mid def partition(low, high): pivot_index = median_of_three(low, high) pivot_value = arr[pivot_index] arr[pivot_index], arr[high] = arr[high], arr[pivot_index] store_index = low for i in range(low, high): if arr[i] < pivot_value: arr[i], arr[store_index] = arr[store_index], arr[i] store_index += 1 arr[store_index], arr[high] = arr[high], arr[store_index] return store_index def quicksort_iterative(low, high): size = high - low + 1 stack = [0] * (size) top = -1 top += 1 stack[top] = low top += 1 stack[top] = high while top >= 0: high = stack[top] top -= 1 low = stack[top] top -= 1 pivot_index = partition(low, high) if pivot_index - 1 > low: top += 1 stack[top] = low top += 1 stack[top] = pivot_index - 1 if pivot_index + 1 < high: top += 1 stack[top] = pivot_index + 1 top += 1 stack[top] = high if len(arr) <= 1: return arr quicksort_iterative(0, len(arr) - 1) return arr"},{"question":"# Scenario: You are given a large dataset of user activities on a website, stored as a Binary Search Tree (BST), where each node contains a unique user ID as its value. To perform analytics, one common task is to find the user who performed the activity immediately before a given user (in the sorted order of user IDs). # Problem: Implement a function `find_predecessor(root, node)` that returns the predecessor of a given node in a BST. The tree nodes are defined with a `TreeNode` class, where each node has a `val` (user ID), `left` (left subtree), and `right` (right subtree). # Input: - `root`: The root of the BST (a `TreeNode` object). - `node`: The node for which the predecessor needs to be found (a `TreeNode` object). # Output: - The predecessor node (a `TreeNode` object) if it exists; otherwise, `None`. # Constraints: - All nodes in the BST have unique integers as their `val`. - The number of nodes in the tree can be up to 10^4. - The BST does not contain any duplicates. # Example: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None root = TreeNode(20) root.left = TreeNode(10) root.right = TreeNode(30) root.left.left = TreeNode(5) root.left.right = TreeNode(15) node = root.left.right # Node with value 15 # Function to find predecessor def find_predecessor(root, node): # Your code here predecessor = find_predecessor(root, node) print(predecessor.val if predecessor else \\"None\\") # Output should be 10 ``` # Notes: - You should handle all edge cases such as when the node has no predecessor, or the node itself is not present in the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_predecessor(root, node): predecessor = None current = root while current: if node.val > current.val: predecessor = current current = current.right else: current = current.left if node.left: current = node.left while current.right: current = current.right predecessor = current return predecessor"},{"question":"# Question As part of your coding assessment, you are tasked with solving the following question: Given a binary tree, your task is to write a function that calculates its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. A leaf is a node with no children. Use both approaches (Recursive DFS and Iterative BFS) provided below: 1. **Recursive Approach (DFS)**: - Define a function `min_depth(root)` that implements the recursive approach to find the minimum depth. 2. **Iterative Approach (BFS)**: - Define a function `min_height(root)` that implements the iterative approach to find the minimum depth using a level-order traversal. # Inputs and Outputs - **Input**: A binary tree represented by its root node `root`. - **Output**: An integer representing the minimum depth of the binary tree. Input Constraints - The number of nodes in the tree is in the range `[0, 10^4]`. - `-1000 <= Node.val <= 1000` # Sample Output Given the following tree: ``` 10 / 12 15 / / 25 30 36 100 ``` - The minimum depth is `2` as the shortest path to a leaf node is from the root (10) to (15). # Functional Specifications Implement the following two functions in Python: ```python def min_depth(root): :type root: TreeNode :rtype: int # Your DFS code here def min_height(root): :type root: TreeNode :rtype: int # Your BFS code here ``` # Notes Your implementation should consider edge cases such as an empty tree (where the minimum depth should be `0`). Ensure your code is optimized for both time and space efficiency, handling very large and potentially unbalanced trees within acceptable performance limits.","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def min_depth(root): Recursive DFS approach to find the minimum depth of a binary tree. :type root: TreeNode :rtype: int if not root: return 0 if not root.left and not root.right: return 1 if not root.left: return min_depth(root.right) + 1 if not root.right: return min_depth(root.left) + 1 return min(min_depth(root.left), min_depth(root.right)) + 1 def min_height(root): Iterative BFS approach to find the minimum depth of a binary tree. :type root: TreeNode :rtype: int if not root: return 0 queue = deque([(root, 1)]) while queue: node, depth = queue.popleft() if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1))"},{"question":"# Context You are provided with a tree-like structure represented as a dictionary in Python. Each key corresponds to a person (name), and each value is a list that can contain a mix of strings and nested data. Your goal is to modify the provided `tree_print` function to: 1. Handle deeper nested structures correctly. 2. Maintain appropriate indentation for all levels of hierarchy in the printout. # Problem Statement Modify the function `tree_print` to recursively print all elements in the nested dictionary structure with correct indentation to represent the hierarchy level. # Requirements 1. **Input Format**: * A dictionary where each key (string) has a value as a list. The list contains elements that could be strings or other dictionaries. 2. **Output Format**: * Print the elements of the dictionary to represent the hierarchy. Each level should be indented with 4 spaces more than the previous level. 3. **Constraints**: * Assume all dictionary keys are strings. * Assume values within lists are either strings or nested dictionaries (unlimited depth). # Function Signature ```python def tree_print(tree: dict, indent: int = 0) -> None: # your code here ``` # Example Input ```python tree = { \\"Adam\\": [\\"Book\\", \\"Computer\\", \\"TV\\"], \\"Bill\\": [\\"Computer\\", {\\"Jill\\": [\\"Sports\\"]}], \\"Quin\\": [{\\"Adam\\": [\\"Sports\\", {\\"Quin\\": [\\"Book\\", \\"TV\\"]}]}, \\"Computer\\"] } ``` Output ``` Adam Book Computer TV Bill Computer Jill Sports Quin Adam Sports Quin Book TV Computer ``` # Additional Notes * Ensure you handle leaf nodes correctly and increment the indentation level for each nested structure. * Nested dictionaries should be properly recognized and processed.","solution":"def tree_print(tree: dict, indent: int = 0) -> None: for key, value in tree.items(): print(\' \' * indent + key) for item in value: if isinstance(item, str): print(\' \' * (indent + 4) + item) elif isinstance(item, dict): tree_print(item, indent + 4)"},{"question":"# Scenario You have been hired by a cybersecurity firm to preprocess user-submitted passwords. One of the requirements is to ensure that each password only contains the first occurrence of each character, removing any subsequent duplicates. # Task Implement a function `remove_reoccurring_characters(string)` that takes a single input string, deletes any reoccurring character after its first appearance, and returns the resulting string. Your implementation should aim for optimal performance. # Input and Output Formats * **Input**: A single string `string` consisting of lowercase and uppercase alphabetic characters and possibly digits. * **Output**: A single string with all reoccurring characters removed after their first occurrence. # Constraints * The input string can have a length up to 10^5 characters. * Characters in the string consist of printable ASCII characters. # Examples ```python assert remove_reoccurring_characters(\'banana\') == \'ban\' assert remove_reoccurring_characters(\'password123\') == \'pasword123\' assert remove_reoccurring_characters(\'\') == \'\' assert remove_reoccurring_characters(\'aabbcc\') == \'abc\' ``` # Performance Requirements * Your solution should have a time complexity of O(n), where n is the length of the input string.","solution":"def remove_reoccurring_characters(string): Removes reoccurring characters from the string after their first appearance. Parameters: string (str): Input string from which duplicates are to be removed. Returns: str: String after removing reoccurring characters. result = [] seen_characters = set() for char in string: if char not in seen_characters: result.append(char) seen_characters.add(char) return \'\'.join(result)"},{"question":"**Context**: You are working on a system that needs to simulate sequences of operations based on probabilistic rules defined by a Markov chain. Each state in the chain represents a different operation, and the probabilities define the likelihood of transitioning from one state to another. **Task**: Implement a function to simulate a series of operations based on a given Markov chain and an initial state. Write the function `simulate_markov_chain(chain, initial_state, steps)` where `chain` is a dictionary describing the Markov chain, `initial_state` is the starting state, and `steps` is the number of operations to simulate. **Function Definition**: ```python def simulate_markov_chain(chain, initial_state, steps): Parameters: chain (dict): A dictionary representing the Markov chain where each key is a state and its value is another dictionary representing the transition probabilities to other states. initial_state (str): The state from which the Markov chain simulation starts. steps (int): The number of steps (operations) to simulate. Returns: List[str]: A list of states of length `steps` representing the sequence of states produced by the Markov chain simulation. # Your implementation here ``` **Inputs**: * `chain`: Dict[str, Dict[str, float]] - Dictionary where keys are states and values are dictionaries mapping states to transition probabilities. * `initial_state`: str - The state to start the sequence from. * `steps`: int - The total number of steps to simulate. **Outputs**: * List[str] - A list of states representing the sequence of transitions, each state appearing in the order it was transitioned into. **Constraints**: * Transition probabilities for a given state must sum to 1. * The chain dictionary will contain at least one state with at least one outgoing transition. * The function will not need to handle invalid inputs (e.g., states not in the chain, or steps less than 1). **Example**: ```python chain = { \'A\': {\'A\': 0.6, \'B\': 0.4}, \'B\': {\'A\': 0.3, \'B\': 0.7} } initial_state = \'A\' steps = 5 print(simulate_markov_chain(chain, initial_state, steps)) # Output could be: [\'A\', \'B\', \'B\', \'A\', \'A\'] # Note: The exact output may vary due to random transitions. ```","solution":"import random def simulate_markov_chain(chain, initial_state, steps): Simulate a series of operations based on a given Markov chain and an initial state. Parameters: chain (dict): A dictionary representing the Markov chain where each key is a state and its value is another dictionary representing the transition probabilities to other states. initial_state (str): The state from which the Markov chain simulation starts. steps (int): The number of steps (operations) to simulate. Returns: List[str]: A list of states of length `steps` representing the sequence of states produced by the Markov chain simulation. current_state = initial_state sequence = [] for _ in range(steps): sequence.append(current_state) transitions = chain[current_state] next_state = random.choices( population=list(transitions.keys()), weights=list(transitions.values()) )[0] current_state = next_state return sequence"},{"question":"# Question **Title: Is Palindromic Sentence** **Description:** Given a string, write a function to determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Your function should handle different kinds of inputs, including empty strings and strings with spaces and punctuation. **Function Signature:** ```python def is_palindromic_sentence(s: str) -> bool: ``` **Input:** - A single string `s`, which consists of printable ASCII characters. **Output:** - Return a boolean indicating whether the string `s` is a palindrome considering only alphanumeric characters and ignoring case. **Constraints:** - The string can have a maximum length of up to 100,000 characters. - Must consider only alphanumeric characters and ignore cases. - Empty string should be considered a valid palindrome. **Example:** ```python assert is_palindromic_sentence(\\"A man, a plan, a canal: Panama\\") == True assert is_palindromic_sentence(\\"race a car\\") == False assert is_palindromic_sentence(\\"\\") == True assert is_palindromic_sentence(\\"!!!!!\\") == True ``` **Performance Requirements:** - The solution should be optimal with a time complexity of O(n) where n is the length of the string. - Use O(1) extra space not counting input or pre-processing operations (consider a solution with two-pointer approach). **Hints:** - Pre-process the string to remove all non-alphanumeric characters. - Use two pointers to compare characters from the start and the end of the cleaned string.","solution":"def is_palindromic_sentence(s: str) -> bool: Determines if the given string s is a palindrome, considering only alphanumeric characters and ignoring cases. def is_alphanumeric(c): return (\'a\' <= c <= \'z\') or (\'A\' <= c <= \'Z\') or (\'0\' <= c <= \'9\') # Filter out non-alphanumeric characters and convert to lowercase filtered_chars = [c.lower() for c in s if is_alphanumeric(c)] # Use two-pointer technique to check for palindrome left, right = 0, len(filtered_chars) - 1 while left < right: if filtered_chars[left] != filtered_chars[right]: return False left += 1 right -= 1 return True"},{"question":"You have been hired by a tech company to implement a mathematical function that will approximate the square root of a positive integer using an iterative method. The implementation must ensure that the result has a maximum error within a given precision factor. Function Signature: ```python def square_root(n: int, epsilon: float = 0.001) -> float: pass ``` # Inputs: * An integer ( n ) ( ( 1 leq n leq 10^6 ) ), representing the number you need to find the square root of. * A floating point number ( epsilon ) ( ( 0 < epsilon leq 1 ) ), representing the maximum allowable absolute error in the result. # Outputs: * Return a floating point number representing the square root of ( n ) with a maximum absolute error of ( epsilon ). # Constraints: * Your function must be able to handle the full range of integers from 1 to 1,000,000. * The function must complete in a reasonable time frame for any valid input. # Example Scenarios: 1. **Example 1**: * **Input**: `n = 5`, `epsilon = 0.001` * **Output**: A float between 2.235 and 2.237 (Actual square root: 2.23606797749979) 2. **Example 2**: * **Input**: `n = 16`, `epsilon = 0.0001` * **Output**: A float between 3.9999 and 4.0001 (Actual square root: 4.0) # Notes: 1. Your function should use the iterative method described. 2. You must ensure the function maintains the precision requirement within the specified bounds of ( epsilon ).","solution":"def square_root(n: int, epsilon: float = 0.001) -> float: Approximate the square root of a positive integer using an iterative method. The result will have a maximum error within the given precision factor. # Initial guess guess = n / 2.0 # Iterate until the absolute error is within epsilon while abs(guess**2 - n) > epsilon: guess = (guess + n / guess) / 2.0 return guess"},{"question":"# Question: Enhanced Selection Sort with Stability Context: You have been given the task of sorting an array using the Selection Sort algorithm. The standard Selection Sort is not stable, meaning it does not preserve the order of equal elements. Your goal is to implement a stable version of the Selection Sort known as \\"Stable Selection Sort\\". In a stable sorting algorithm, equal elements maintain their relative order in the sorted output just as they appeared in the input. Problem Statement: Write a Python function `stable_selection_sort(arr)` that performs a stable version of the Selection Sort algorithm to sort an array in ascending order. Input: * `arr`: A list of integers `arr` where `0 <= len(arr) <= 10^4` and `-10^6 <= arr[i] <= 10^6`. Output: * A list of integers sorted in ascending order with stability. Constraints: * Maintain the stability of the sorting algorithm. * Minimize the number of swaps. Expected Performance: * Time Complexity: O(n^2) * Space Complexity: O(1) (In-place sorting) Example: ```python # Example 1: arr = [4, 5, 3, 2, 4, 1] print(stable_selection_sort(arr)) # Output: [1, 2, 3, 4, 4, 5] # Example 2: arr = [7, -3, 2, 1, 2, 7, 9] print(stable_selection_sort(arr)) # Output: [-3, 1, 2, 2, 7, 7, 9] ``` Function Signature: ```python def stable_selection_sort(arr): # your code here ```","solution":"def stable_selection_sort(arr): Perform a stable selection sort on the list arr. n = len(arr) for i in range(n): min_index = i # Find the smallest element\'s index in the remaining unsorted part for j in range(i + 1, n): if arr[j] < arr[min_index]: min_index = j # Instead of swapping, we will shift elements to the right to maintain stability key = arr[min_index] while min_index > i: arr[min_index] = arr[min_index - 1] min_index -= 1 arr[i] = key return arr"},{"question":"**Scenario:** You are a data analyst working with a grid of data points representing a certain metric (e.g., temperature, elevation, etc.) across a region. Your task is to create a tool to analyze the data by summarizing the metric over smaller subregions of the grid. # Problem: Write a function `optimized_sum_sub_squares(matrix, k)` that takes a two-dimensional list `matrix` of size `n x n` and an integer `k`, and returns a two-dimensional list where each element represents the sum of all elements in the respective `k x k` sub-square of the matrix. **Input**: - `matrix`: A list of lists of integers representing an `n x n` grid. - `k`: An integer representing the size of the sub-square. **Output**: - A list of lists of integers where each element is the sum of the respective `k x k` sub-square of the input matrix. **Constraints**: - Assume all elements of `matrix` are integers. - 1 ≤ `k` ≤ `n` ≤ 1000 - If `k` > `n`, return an empty list. **Examples**: ```python matrix = [ [1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4] ] k = 2 # Output should be: # [ # [6, 6, 6], # [10, 10, 10], # [14, 14, 14] # ] matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] k = 3 # Output should be: # [ # [45] # ] ``` **Performance Requirements**: - Optimize the solution to handle large matrices efficiently.","solution":"def optimized_sum_sub_squares(matrix, k): Computes the sum of each k x k sub-square in an n x n grid. n = len(matrix) # Edge case: if k is larger than n, return an empty matrix if k > n: return [] # Initialize auxillary sum matrix of size (n+1) x (n+1) with zeroes sum_matrix = [[0] * (n + 1) for _ in range(n + 1)] # Compute cumulative sum matrix to aid in sub-square sum calculations for i in range(n): for j in range(n): sum_matrix[i + 1][j + 1] = (matrix[i][j] + sum_matrix[i][j + 1] + sum_matrix[i + 1][j] - sum_matrix[i][j]) # Calculate the sum for each k x k sub-square result = [] for i in range(n - k + 1): row_result = [] for j in range(n - k + 1): # Sub-square sum using the inclusion-exclusion principle total = (sum_matrix[i + k][j + k] - sum_matrix[i][j + k] - sum_matrix[i + k][j] + sum_matrix[i][j]) row_result.append(total) result.append(row_result) return result"},{"question":"Write a function `swap_pair` that swaps every pair of consecutive bits of a given 32-bit unsigned integer. You need to manipulate the bits directly without using loops or recursion. # Function Signature ```python def swap_pair(num: int) -> int: ``` # Input - An integer `num` within the range of a 32-bit unsigned integer (`0` to `4294967295`). # Output - The integer resulting from swapping every pair of consecutive bits of `num`. # Constraints 1. The integer given will always be within the 32-bit unsigned integer range. 2. The function should be efficient with a time complexity of O(1). # Example ```python assert swap_pair(22) == 41 assert swap_pair(10) == 5 assert swap_pair(4294967295) == 4294967295 # 0xFFFFFFFF remains same after swapping bits ``` # Explanation - For `swap_pair(22)`, binary `22` is `010110`. After swapping consecutive bits, it becomes `101001` which is `41`. - For `swap_pair(10)`, binary `10` is `1010`. After swapping consecutive bits, it becomes `0101` which is `5`. # Notes - Ensure you are using bitwise operators and constants efficiently as the operations should be performed in constant time. - Consider edge cases and verify the correctness with provided examples.","solution":"def swap_pair(num: int) -> int: Swaps every pair of consecutive bits of the given 32-bit unsigned integer. Args: num (int): A 32-bit unsigned integer. Returns: int: The integer resulting from swapping every pair of consecutive bits of num. # Masking even bits with 0xAAAAAAAA (binary: 10101010...1010) and shifting right by 1 even_bits = (num & 0xAAAAAAAA) >> 1 # Masking odd bits with 0x55555555 (binary: 01010101...0101) and shifting left by 1 odd_bits = (num & 0x55555555) << 1 # Combining the results return even_bits | odd_bits"},{"question":"Word Symbol Replacement Objective You are given a list of words and a list of symbols. Your task is to replace the longest matching symbol (if any) within each word with the same symbol surrounded by square brackets `[]`. Detailed Requirements: 1. **Input**: - A list of words, `words`, where each word is a string. - A list of symbols, `symbols`, where each symbol is a string. 2. **Output**: - A list of words with the symbols replaced as required. 3. **Rules**: - For each word, find the longest symbol that matches a substring of the word. - If a match is found, replace the symbol within the word with the same symbol surrounded by square brackets `[]`. - If a word contains multiple symbols, choose the first occurrence. - If no match is found for a word, it should remain unchanged. 4. **Example**: ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] Output: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` Constraints: - All words and symbols contain only alphabetic characters. - Assume the maximum length of any word is 100 and the maximum number of symbols is 100. Function Signature: ```python def replace_symbols(words: List[str], symbols: List[str]) -> List[str]: pass ``` Implementation Tips: - Efficiently match symbols using a Trie structure. - Ensure to handle edge cases where symbols are prefixes or suffixes of each other. - Consider the performance and optimize where necessary. Example Code: ```python from typing import List class TrieNode: def __init__(self): self.children = {} self.symbol = None def replace_symbols(words: List[str], symbols: List[str]) -> List[str]: # Building the Trie root = TrieNode() for symbol in symbols: node = root for char in symbol: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.symbol = symbol def find_longest_symbol(word: str) -> str: start, longest_match = 0, None while start < len(word): current, node = start, root while current < len(word) and word[current] in node.children: node = node.children[word[current]] if node.symbol: longest_match = (start, current + 1, node.symbol) current += 1 start += 1 return longest_match # Replacing symbols in words result = [] for word in words: match = find_longest_symbol(word) if match: start, end, symbol = match word = f\\"{word[:start]}[{symbol}]{word[end:]}\\" result.append(word) return result # Test cases words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] assert replace_symbols(words, symbols) == [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ```","solution":"from typing import List def replace_symbols(words: List[str], symbols: List[str]) -> List[str]: sorted_symbols = sorted(symbols, key=len, reverse=True) def replace_word_symbol(word: str) -> str: for symbol in sorted_symbols: index = word.find(symbol) if index != -1: return word[:index] + \'[\' + symbol + \']\' + word[index + len(symbol):] return word return [replace_word_symbol(word) for word in words]"},{"question":"# Question: Check if a Circular Linked List is Sorted Given the head of a circular singly linked list, implement a function `is_sorted_circular(head)` that determines if the list is sorted in non-decreasing order. A circular linked list is one where the last node points back to the first node instead of `None`. An empty list or a single-node list is considered sorted. Definition ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Function Signature ```python def is_sorted_circular(head: ListNode) -> bool: # Your code here ``` Input * `head`: The head node of a circular singly linked list. Output * Return `True` if the list is sorted in non-decreasing order, otherwise return `False`. Example ```python # Example: # Input: head -> 1 -> 2 -> 3 -> 1 (circular) # Output: False # Input: head -> 1 -> 2 -> 3 -> 4 -> 1 (circular) # Output: True ``` # Constraints * The number of nodes in the list is in the range `[0, 10^4]`. * -10^6 <= Node.val <= 10^6 Context Sometimes we need to determine if operating on a circular linked list efficiently is feasible based on its sorted status. Your implementation should explicitly handle circular comparisons, taking into account the wrap-around nature of the list by correctly looping back to the head node when necessary.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted_circular(head: ListNode) -> bool: if not head or not head.next: # An empty or single-node list is considered sorted return True # Finding the node where the circular linked list rewraps current = head while current.next != head: if current.val > current.next.val: break current = current.next # Current now points to the node where it should rewrap if sorted tempNode = current.next while tempNode != head: if tempNode.val > tempNode.next.val: return False tempNode = tempNode.next return True"},{"question":"Implement Ternary Search Given a sorted array of integers and a target integer value, write a function to implement the ternary search algorithm to find the target value. The function should return the index of the target value if it is present in the array and -1 if it is not present. # Function Signature ```python def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: pass ``` # Input - `left`: An integer representing the left index of the search range (usually starting from 0). - `right`: An integer representing the right index of the search range (usually starting from the length of the array - 1). - `key`: An integer representing the target value to search for. - `arr`: A list of integers sorted in ascending order. # Output - The function should return an integer: - The index of the target value if it is found in the array. - -1 if the target value is not found. # Constraints - `0 <= left <= right < len(arr)` - Sorted array `arr` with unique integers. - Array length does not exceed 10^5. - All elements in the array are between -10^9 and 10^9. # Example ```python def ternary_search(left, right, key, arr): while right >= left: mid1 = left + (right-left) // 3 mid2 = right - (right-left) // 3 if key == arr[mid1]: return mid1 if key == arr[mid2]: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1 # Test case arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] key = 5 print(ternary_search(0, len(arr)-1, key, arr)) # Output: 4 ```","solution":"from typing import List def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: Implements the ternary search algorithm. Returns the index of the key if found, otherwise returns -1. while right >= left: mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 if key == arr[mid1]: return mid1 if key == arr[mid2]: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"# Scenario You are developing a file management library that needs to manipulate file paths provided by users. One of the core functionalities required is the ability to split a given path into the directory path and the last component (which could be a file name or the final directory name). To achieve this, you need to implement a utility function that can accurately partition the paths. # Objective Write a function `split_path(path: str) -> List[str]` that takes a string representing the path and returns a list of two elements: - The first element is the directory path up to but not including the last slash. - The second element is the last component after the final slash. # Input Format - `path`: A string representing the path, which could be a file path or URL. - The path will at least contain one non-slash character. - Assume Unix-style paths which use \'/\' as the separator. # Output Format - A list of two strings where the first element is the directory path and the second element is the final component of the path. # Constraints - The length of the path string will not exceed 10^4 characters. - The path will always contain at least one character. # Examples ```python assert split_path(\\"https://algorithms/unix/test.py\\") == [\\"https://algorithms/unix\\", \\"test.py\\"] assert split_path(\\"algorithms/unix/test.py\\") == [\\"algorithms/unix\\", \\"test.py\\"] assert split_path(\\"/unix/\\") == [\\"/unix\\", \\"\\"] assert split_path(\\"unix\\") == [\\"\\", \\"unix\\"] ``` # Notes - Consider edge cases where there is no directory component or where the path ends with a slash. - Handle the input robustly to avoid common pitfalls.","solution":"def split_path(path: str) -> list: Split the given path into directory path and the last component. Parameters: path (str): The path to be split. Returns: list: A list containing the directory path and the final component. # Find the last slash in the path last_slash_index = path.rfind(\'/\') # If there is no slash, return an empty string for directory and the whole path as the last component if last_slash_index == -1: return [\\"\\", path] # Return the directory path and last component return [path[:last_slash_index], path[last_slash_index + 1:]]"},{"question":"Efficient Custom Sort **Context**: Suppose you are given an array of integers where the maximum possible value in each element is known and relatively small (e.g., less than 100). To ensure efficient sorting for such constraints, we\'d like to implement a battle-proven, efficient sorting algorithm and avoid inefficient ones like Bogo Sort. **Task**: Write a function `efficient_sort(arr: list) -> list` in Python that sorts the array of integers in ascending order. Given the constraints mentioned, choose an appropriate algorithm that guarantees performance efficiency. You are free to use sorting techniques such as Counting Sort which benefit from the small range of integer values. **Input**: - A list of integers `arr` where each integer is in the range ([0, 99]). **Output**: - A list of integers sorted in ascending order. **Constraints**: 1. ( 0 leq text{len}(arr) leq 10^6 ) 2. ( 0 leq text{arr[i]} leq 99 ) for all (i) **Performance Requirements**: - The solution should have a time complexity of (O(n + k)), where (n) is the number of elements in the array and (k) is the range of elements. **Edge Cases**: 1. An empty array should return an empty array. 2. An array with one element should return that element. # Implementation Details: Implement an efficient sorting algorithm and justify your choice based on the analysis above.","solution":"def efficient_sort(arr): Sorts an array of integers in the range [0, 99] using Counting Sort. :param arr: List of integers where each integer is between 0 and 99 :return: Sorted list of integers in ascending order if not arr: return [] # Initialize the count array with 100 zeros (since numbers are between 0 and 99 inclusive) count = [0] * 100 # Populate the count array for num in arr: count[num] += 1 # Create the sorted array sorted_arr = [] for i in range(100): if count[i] > 0: sorted_arr.extend([i] * count[i]) return sorted_arr"},{"question":"Context You are given a binary tree, and your goal is to perform an inorder traversal on this tree. Inorder traversal visits nodes in a non-decreasing order for a binary search tree by visiting the left subtree, the root, and then the right subtree. Objective Write a function `custom_inorder_traversal` that takes in the root of a binary tree and outputs a list of values in inorder traversal order. Function Signature ```python def custom_inorder_traversal(root: Node) -> List[int]: ``` Input - `root`: The root node of the binary tree or `None`. Output - A list of integers representing the inorder traversal of the given binary tree. Constraints - The number of nodes in the tree is in the range `[0, 10^4]`. - Each node\'s value is an integer within the range `[-10^5, 10^5]`. Requirements - The implementation should be efficient in terms of both time and space complexity. - Consider using an iterative approach to handle potential deep recursion issues in a large tree effectively. Examples 1. Given the below tree: ``` 100 / 50 150 / / 25 75 125 175 ``` ```python root = Node(100) root.left = Node(50, Node(25), Node(75)) root.right = Node(150, Node(125), Node(175)) assert custom_inorder_traversal(root) == [25, 50, 75, 100, 125, 150, 175] ``` 2. Given an empty tree: ```python root = None assert custom_inorder_traversal(root) == [] ``` Notes - Using the provided `Node` class: ```python class Node: def __init__(self, val: int, left=None, right=None): self.val = val self.left = left self.right = right ``` Starter Code ```python from typing import List, Optional class Node: def __init__(self, val: int, left: Optional[\'Node\']=None, right: Optional[\'Node\']=None): self.val = val self.left = left self.right = right def custom_inorder_traversal(root: Node) -> List[int]: # Implement the inorder traversal logic here. pass ```","solution":"from typing import List, Optional class Node: def __init__(self, val: int, left: Optional[\'Node\']=None, right: Optional[\'Node\']=None): self.val = val self.left = left self.right = right def custom_inorder_traversal(root: Optional[Node]) -> List[int]: result = [] stack = [] current = root while current is not None or stack: # Reach the left most Node of the current Node while current is not None: stack.append(current) current = current.left # Current must be None at this point current = stack.pop() result.append(current.val) # Add the node value to result # We have visited the node and its left subtree. Now, it\'s right subtree\'s turn current = current.right return result"},{"question":"**Question**: You are given an array of integers, which may include negative numbers. Your task is to implement a function `generalized_counting_sort` that sorts the given array using the counting sort method. **Function Signature**: ```python def generalized_counting_sort(arr: List[int]) -> List[int]: pass ``` **Input**: * A list of integers `arr` where the length of `arr` is n (0 ≤ n ≤ 10^6). * The values inside `arr` range between -10^6 and 10^6. **Output**: * A list of integers sorted in ascending order. **Constraints**: * Ensure the solution has an efficient complexity and handles edge cases appropriately. * Implement the function without importing any external libraries. **Example**: ```python assert generalized_counting_sort([4, 2, -3, -1, 5, 2]) == [-3, -1, 2, 2, 4, 5] assert generalized_counting_sort([1, 1, 1, 1]) == [1, 1, 1, 1] assert generalized_counting_sort([]) == [] assert generalized_counting_sort([0]) == [0] ``` **Explanation**: 1. For the input `[4, 2, -3, -1, 5, 2]`, the output should be `[-3, -1, 2, 2, 4, 5]`. 2. For an array where all elements are the same, like `[1, 1, 1, 1]`, the output should be `[1, 1, 1, 1]`. 3. An empty array should return an empty array. 4. A single-element array should return the same single element array. **Tasks**: 1. Analyze the range of the input elements and handle cases involving negative numbers. 2. Implement counting sort that accommodates negative numbers efficiently. 3. Ensure the function is optimized and handles edge cases properly.","solution":"def generalized_counting_sort(arr): if not arr: return [] min_value = min(arr) max_value = max(arr) range_of_elements = max_value - min_value + 1 count = [0] * range_of_elements output = [0] * len(arr) for number in arr: count[number - min_value] += 1 for i in range(1, range_of_elements): count[i] += count[i - 1] for number in reversed(arr): output[count[number - min_value] - 1] = number count[number - min_value] -= 1 return output"},{"question":"# Matrix Power Calculation Given a square matrix of dimension `d x d` and an integer `n`, write a function `efficient_matrix_power` that efficiently computes the matrix raised to the power `n` using the method of squaring. Function Signature ```python def efficient_matrix_power(mat: list, n: int) -> list: pass ``` Input * **mat (list[list[int]])** - A square matrix of integers (dimensions `d x d` where `1 <= d <= 100`). * **n (int)** - A non-negative integer representing the power the matrix is raised to (`0 <= n <= 10^9`). Output * Returns a list of lists representing the resultant matrix after exponentiation. Examples ```python assert efficient_matrix_power([[2, 1], [1, 0]], 2) == [[5, 2], [2, 1]] assert efficient_matrix_power([[1, 1], [1, 0]], 5) == [[8, 5], [5, 3]] assert efficient_matrix_power([[7]], 4) == [[2401]] assert efficient_matrix_power([[2, 3], [4, 5]], 0) == [[1, 0], [0, 1]] ``` Constraints and Assumptions 1. Input matrices will be non-empty and will always be square matrices (d x d). 2. Elements of the matrix and the resultant matrix are within the integer range. 3. Ensure your code handles large exponents efficiently both in terms of time and space.","solution":"def efficient_matrix_power(mat, n): Computes the matrix mat raised to the power n using matrix exponentiation by squaring. d = len(mat) # Assuming mat is a square matrix, so mat has d rows and d columns # Function to multiply two matrices def matrix_mult(A, B): result = [[0] * d for _ in range(d)] for i in range(d): for j in range(d): for k in range(d): result[i][j] += A[i][k] * B[k][j] return result # Function to compute matrix exponentiation by squaring def matrix_power(matrix, power): # Start with the identity matrix result = [[1 if i == j else 0 for j in range(d)] for i in range(d)] base = matrix while power > 0: if power % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) power //= 2 return result # Special case for power 0: return identity matrix if n == 0: return [[1 if i == j else 0 for j in range(d)] for i in range(d)] return matrix_power(mat, n)"},{"question":"# Question You are tasked with implementing a sorting function using the quick sort algorithm for a custom user-defined object. The object `Student` has the following structure: ```python class Student: def __init__(self, name: str, grade: float): self.name = name self.grade = grade ``` Your task is to sort a list of `Student` instances based on their grades in ascending order using quick sort. If multiple students have the same grade, their relative order should not be changed (stable sort). # Function Signature ```python def quick_sort_students(students: List[Student]) -> List[Student]: pass ``` # Input - `students`: List of `Student` instances, where each student has a `name` (string) and a `grade` (float). # Output - A list of `Student` instances sorted by their `grade` in ascending order. # Constraints - The length of the list `students` will not exceed 10^5. - The `grade` of any student will be between 0.0 and 100.0 inclusive. # Example ```python students = [ Student(\'Alice\', 91.5), Student(\'Bob\', 85.0), Student(\'Charlie\', 85.0), Student(\'David\', 95.0) ] sorted_students = quick_sort_students(students) for student in sorted_students: print(f\'{student.name}: {student.grade}\') ``` Output: ``` Bob: 85.0 Charlie: 85.0 Alice: 91.5 David: 95.0 ``` # Note: The order of students Bob and Charlie should remain as they appear in the input because their grades are identical (stable sorting). # Requirements: - Ensure the sorting is stable. - Optimize the quick sort algorithm to handle large lists efficiently.","solution":"from typing import List class Student: def __init__(self, name: str, grade: float): self.name = name self.grade = grade def quick_sort_students(students: List[Student]) -> List[Student]: if len(students) <= 1: return students else: pivot = students[len(students) // 2].grade less = [] equal = [] greater = [] for student in students: if student.grade < pivot: less.append(student) elif student.grade == pivot: equal.append(student) else: greater.append(student) return quick_sort_students(less) + equal + quick_sort_students(greater)"},{"question":"# Selection Sort with Optimization and Edge Cases Problem Statement You are given an unsorted list of integers and your goal is to sort it using the Selection Sort algorithm. However, you need to enhance the algorithm by incorporating optimizations and handling various edge cases efficiently. Function Signature ```python def optimized_selection_sort(arr): Sorts the given list of integers using an enhanced selection sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: list: The sorted list of integers. ``` Input * An unsorted list of integers, `arr` (0 ≤ len(arr) ≤ 10^4). Output * A sorted list of integers in ascending order. Constraints * You must maintain the in-place property of the selection sort. * Ensure to handle the following edge cases: - An empty list. - A list with a single element. - Lists with all identical elements. - Already sorted lists. Example ```python print(optimized_selection_sort([64, 25, 12, 22, 11])) # Output: [11, 12, 22, 25, 64] print(optimized_selection_sort([1, 2, 3, 4, 5])) # Output: [1, 2, 3, 4, 5] print(optimized_selection_sort([5, 4, 3, 2, 1])) # Output: [1, 2, 3, 4, 5] print(optimized_selection_sort([])) # Output: [] print(optimized_selection_sort([1])) # Output: [1] print(optimized_selection_sort([3, 3, 3, 3, 3])) # Output: [3, 3, 3, 3, 3] ``` Performance Requirements * Ensure that the function handles the worst-case scenario efficiently within the constraints. * Focus on reducing unnecessary operations while ensuring correctness. Notes * Avoid direct copy-pasting of existing selection sort code. Reflect on the basic principles and re-implement the algorithm with the enhancements and edge cases in mind. * Your implementation will be tested for both correctness and performance.","solution":"def optimized_selection_sort(arr): Sorts the given list of integers using an enhanced selection sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: list: The sorted list of integers. n = len(arr) for i in range(n): # Assume the minimum element is the first element of the unsorted part min_index = i # Check the rest of the array for a smaller element for j in range(i + 1, n): if arr[j] < arr[min_index]: min_index = j # Swap if we found a smaller element if min_index != i: arr[i], arr[min_index] = arr[min_index], arr[i] return arr"},{"question":"# Background You are building a system that generates URLs for different parts of your website. To do this, you need a function that joins the base URL with different subpaths or endpoints. Similarly, for file system operations, such a function can ensure the correctness of file paths by handling redundant slashes appropriately. # Task Write a function `join_paths` that takes two strings as input, a `base` and a `suffix`, and returns a well-formed path or URL by joining the base and suffix with a single slash (\\"/\\") between them. # Function Signature ```python def join_paths(base: str, suffix: str) -> str: ``` # Input - `base` (string): The base part of the path or URL. For example, `\'http://algorithms.com/\'` or `\'path/to/dir/\'`. - `suffix` (string): The suffix part to be appended to the base. For example, `\'page1\'` or `\'subdir/file\'`. # Output - Returns a single string representing the joined path or URL. # Constraints - The input strings may be empty. - The input strings may contain leading, trailing, or multiple slashes. - You can assume that the inputs will be well-formed URLs or file paths without special characters like \\"..\\" or \\".\\". # Example ```python assert join_paths(\'http://algorithms.com/\', \'/part\') == \'http://algorithms.com/part\' assert join_paths(\'/root/\', \'child\') == \'/root/child\' assert join_paths(\'folder\', \'/file\') == \'folder/file\' assert join_paths(\'\', \'suffix\') == \'/suffix\' assert join_paths(\'base\', \'\') == \'base\' ``` # Additional Notes Consider edge cases where the input strings may have extra slashes or are empty. Ensure your function handles these situations appropriately.","solution":"def join_paths(base: str, suffix: str) -> str: Joins base and suffix ensuring there\'s a single slash between them. if not base: return \'/\' + suffix.lstrip(\'/\') if not suffix: return base.rstrip(\'/\') return base.rstrip(\'/\') + \'/\' + suffix.lstrip(\'/\')"},{"question":"Suppose you are given a list of integers that is sorted in non-decreasing order. Your task is to implement a function that can efficiently find the position where a new integer should be inserted to maintain the list\'s sorted order. Write a function `find_insert_position(sorted_list, x)` that returns the index at which the integer `x` should be inserted. Function Signature ```python def find_insert_position(sorted_list: List[int], x: int) -> int: ``` Parameters - `sorted_list (List[int])`: A list of integers sorted in non-decreasing order. It can be empty. - `x (int)`: The integer to be inserted. Returns - `int`: The index at which `x` should be inserted to maintain the sorted order. Requirements - Your implementation should be efficient with a time complexity of O(log n). - You are not allowed to use any built-in search or insertion methods. # Constraints - All integers in `sorted_list` and `x` lie in the range `-10^5` to `10^5`. - The length of `sorted_list` will be between `0` and `10^5`. # Examples 1. `find_insert_position([1, 3, 5, 6], 5) -> 2` 2. `find_insert_position([1, 3, 5, 6], 2) -> 1` 3. `find_insert_position([1, 3, 5, 6], 7) -> 4` 4. `find_insert_position([1, 3, 5, 6], 0) -> 0` 5. `find_insert_position([], 3) -> 0` # Explanation In the first example, 5 is already in the list at index 2. In the second example, 2 should be inserted between 1 and 3, hence at index 1. Similarly, in the third and fourth examples, 7 should be inserted at the end and 0 at the beginning, respectively.","solution":"from typing import List def find_insert_position(sorted_list: List[int], x: int) -> int: Given a sorted list of integers and an integer x, find the index at which x should be inserted to maintain the sorted order. low, high = 0, len(sorted_list) while low < high: mid = (low + high) // 2 if sorted_list[mid] < x: low = mid + 1 else: high = mid return low"},{"question":"You are tasked with implementing a function to calculate cosine similarity between two vectors of equal length. This measure is often used in text analysis, recommender systems, and machine learning for comparing the orientation of vectors disregarding their magnitude. # Detailed Requirements: 1. **Input**: Two lists of integers or floats of equal length. 2. **Output**: A float representing the cosine similarity between the two input vectors. # Function Signature: ```python def cosine_similarity(vec1: List[Union[int, float]], vec2: List[Union[int, float]]) -> float: pass ``` # Constraints: - The input vectors will each have at least one element and no more than (10^6) elements. - The values within the vectors will be between (-10^9) and (10^9). # Performance Requirements: - The implementation should run in linear time, with respect to the length of the vectors. # Example: ```python assert abs(cosine_similarity([1, 1, 1], [1, 2, -1]) - 0.4714) < 1e-4 assert abs(cosine_similarity([1, 0], [0, 1]) - 0.0) < 1e-4 assert abs(cosine_similarity([1, 1], [1, 1]) - 1.0) < 1e-4 ``` # Context: Imagine you are working in a machine learning team building a document similarity module. This module helps in identifying similar documents by comparing term frequency vectors – vectors representing the counts of terms in each document. Implementing an efficient cosine similarity function is crucial for the real-time performance of this module. # Special Considerations: - Ensure to handle division by zero if either vector is completely zero after norm calculation. - Handle and raise appropriate errors if the input vectors are of different lengths. Implement the `cosine_similarity` function based on the given details and constraints.","solution":"import math from typing import List, Union def cosine_similarity(vec1: List[Union[int, float]], vec2: List[Union[int, float]]) -> float: if len(vec1) != len(vec2): raise ValueError(\\"Input vectors must have the same length\\") dot_product = sum(a * b for a, b in zip(vec1, vec2)) magnitude_vec1 = math.sqrt(sum(a * a for a in vec1)) magnitude_vec2 = math.sqrt(sum(b * b for b in vec2)) if magnitude_vec1 == 0 or magnitude_vec2 == 0: raise ValueError(\\"One of the input vectors is a zero vector\\") return dot_product / (magnitude_vec1 * magnitude_vec2)"},{"question":"# **Problem Statement:** You are tasked to implement a Binary Heap data structure and its essential operations. **Function Implementations:** 1. `__init__(self)`: - Initialize a new empty Binary Heap. 2. `perc_up(self, i)`: - Helper function to maintain heap properties while inserting. 3. `insert(self, val)`: - Insert a new value into the heap and maintain the heap property. - **Input**: an integer `val` to be inserted into the heap. - **Output**: None. The heap is modified in place. 4. `min_child(self, i)`: - Helper function to find the index of the minimum child. - **Input**: an integer `i` representing index in the array. - **Output**: an integer, index of the minimum child. 5. `perc_down(self, i)`: - Helper function to maintain heap properties while removing the minimum. 6. `remove_min(self)`: - Remove and return the minimum element from the heap while maintaining the heap property. - **Output**: the minimum element in the heap. **Requirements:** - You must implement all these methods in a class called `BinaryHeap` that follows the structure of the provided code snippet. - Maintain the heap property after each `insert` and `remove_min` operation. - Handle edge cases, such as removing from an empty heap or inserting into an empty heap. **Example:** ```python bh = BinaryHeap() bh.insert(4) bh.insert(50) bh.insert(7) bh.insert(55) bh.insert(90) bh.insert(87) print(bh.heap) # Expected output: [0, 4, 50, 7, 55, 90, 87] min_val = bh.remove_min() print(min_val) # Expected output: 4 print(bh.heap) # Expected output: [0, 7, 50, 87, 55, 90] ``` Your goal is to implement the `BinaryHeap` class with the above methods to manage a binary heap correctly.","solution":"class BinaryHeap: def __init__(self): self.heap = [0] self.current_size = 0 def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def insert(self, val): self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def min_child(self, i): if i * 2 + 1 > self.current_size: return i * 2 else: if self.heap[i * 2] < self.heap[i * 2 + 1]: return i * 2 else: return i * 2 + 1 def perc_down(self, i): while (i * 2) <= self.current_size: mc = self.min_child(i) if self.heap[i] > self.heap[mc]: self.heap[i], self.heap[mc] = self.heap[mc], self.heap[i] i = mc def remove_min(self): if self.current_size == 0: return None min_val = self.heap[1] self.heap[1] = self.heap[self.current_size] self.heap.pop() self.current_size -= 1 self.perc_down(1) return min_val"},{"question":"# Matrix Rotation by 90 Degrees Clockwise Given an `n x n` 2D matrix `mat` representing an image, rotate the image by 90 degrees in a clockwise direction in-place. Implement the function `rotate(mat)` to achieve this. Input * `mat`: A 2D list (square matrix) of integers. Output * The function should modify the `mat` in place such that it\'s rotated 90 degrees clockwise. The function does not return any value. Constraints * The function should handle an edge case where the matrix is empty. * It should perform the rotation in-place with O(1) extra space and in O(n^2) time complexity. Example ```python Input: mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] Output: The modified matrix mat after rotation will be: [[7, 4, 1], [8, 5, 2], [9, 6, 3]] def rotate(mat): if not mat: return mat mat.reverse() for i in range(len(mat)): for j in range(i): mat[i][j], mat[j][i] = mat[j][i], mat[i][j] return mat ``` Implement the function in Python and test it with the given example. Follow-up Could you improve your solution to handle larger matrices effectively without changing the time and space complexity constraints?","solution":"def rotate(mat): Rotates an n x n matrix by 90 degrees clockwise in-place. if not mat or not mat[0]: return n = len(mat) # First, reverse the rows of the matrix mat.reverse() # Then, transpose the matrix for i in range(n): for j in range(i + 1, n): mat[i][j], mat[j][i] = mat[j][i], mat[i][j]"},{"question":"# Context Permutations of integers can often solve real-world problems, like generating different combinations for testing, optimizing resource allocations, etc. Your task is to find the next permutation of an integer in its numerical form when arranged in lexicographical order. # Problem Statement Given a positive integer `num`, write a function `next_bigger(num)` that returns the next higher permutation of the digits within the number. If no such permutation exists, the function should return `-1`. Input - A single integer `num` where `1 <= num <= 10^9` Output - A single integer representing the next higher permutation, or `-1` if no such permutation exists. # Constraints - Utilize the given digits only; no digit repetitions outside the original set. - Performance must handle the largest constraints within reasonable time limits (`O(n)` time complexity). # Function Signature ```python def next_bigger(num: int) -> int: pass ``` # Examples ```python assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(1528452) == 1528524 assert next_bigger(138654) == 143568 assert next_bigger(54321) == -1 assert next_bigger(999) == -1 assert next_bigger(5) == -1 ``` # Explanation - `38276`: The next permutation is `38627` after swapping `3` with `8` and reversing `276` to get `627`. - `12345`: The next permutation is `12354` by swapping `5` and `4`. - `54321`, `999`, `5`: No higher permutation, return `-1`. Provide the function implementation and validate using the test cases provided.","solution":"def next_bigger(num: int) -> int: digits = list(str(num)) n = len(digits) # Step 1: Find the largest index \'i\' such that digits[i] < digits[i + 1] i = n - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 # If no such index exists, the permutation is the highest already if i == -1: return -1 # Step 2: Find the largest index \'j\' such that digits[i] < digits[j] j = n - 1 while digits[i] >= digits[j]: j -= 1 # Step 3: Swap the value of digits[i] with that of digits[j] digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the sequence from digits[i + 1] to the end of the list digits = digits[:i + 1] + digits[i + 1:][::-1] return int(\\"\\".join(digits))"},{"question":"Context: You are given a matrix that is sorted in non-decreasing order both row-wise and column-wise. Your task is to implement an efficient search algorithm to find a target integer in this matrix. If the target is found, return its position (row and column indices starting from 1). If the target is not found, return a message stating the key is not found. Problem: Implement a function `search_in_sorted_matrix` that accepts: - A 2D list of integers `matrix` representing the sorted matrix. - Two integers `m` (number of rows) and `n` (number of columns). - An integer `target` representing the element you need to find. The function should return a tuple `(row, column)` indicating the position of the target (both 1-indexed) or a string \\"Key not found\\" if the target is not in the matrix. Input/Output Formats: **Input:** ```python matrix: List[List[int]] m: int (number of rows) n: int (number of columns) target: int ``` **Output:** ```python If the target is found: (row: int, column: int) If the target is not found: \\"Key not found\\" ``` Constraints: * The matrix size: 0 ≤ m, n ≤ 10^3. * Element values: Elements in the matrix will be within the range of -10^9 and 10^9. * The matrix is guaranteed to be sorted in non-decreasing order both row-wise and column-wise. Example: **Example 1:** ```python matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] m = 4 n = 3 target = 13 # Output: # (2, 3) ``` **Example 2:** ```python matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] m = 4 n = 3 target = 6 # Output: # \\"Key not found\\" ``` Function Signature: ```python def search_in_sorted_matrix(matrix: List[List[int]], m: int, n: int, target: int) -> Union[Tuple[int, int], str]: # Your implementation here ```","solution":"from typing import List, Union, Tuple def search_in_sorted_matrix(matrix: List[List[int]], m: int, n: int, target: int) -> Union[Tuple[int, int], str]: Search for the target value in a sorted matrix. If found, return its position (1-indexed). If not found, return \\"Key not found\\". :param matrix: List of lists of integers representing the matrix :param m: Number of rows in the matrix :param n: Number of columns in the matrix :param target: Integer target value to search for :return: Tuple of (row, column) if the target is found, or \\"Key not found\\" if m == 0 or n == 0: return \\"Key not found\\" row = 0 col = n - 1 while row < m and col >= 0: if matrix[row][col] == target: return (row + 1, col + 1) elif matrix[row][col] > target: col -= 1 else: row += 1 return \\"Key not found\\""},{"question":"**Scenario**: You are developing a financial application to help users decide the best days to buy and sell stocks for maximum profit. Given an array `prices` where the `prices[i]` is the price of a given stock on day `i`, design and implement an efficient algorithm to determine the maximum profit obtainable from one transaction (a single buy followed by a single sell). If no profit is possible, return 0. **Requirements**: - Implement a function `max_profit(prices: List[int]) -> int` using the most efficient approach. - Your solution should handle large datasets efficiently within acceptable time limits. - Your function must fulfill the following contract: ```python def max_profit(prices: List[int]) -> int: \'\'\' Calculate the maximum profit possible from a single transaction within given stock prices. Parameters: prices (List[int]): A list of stock prices where prices[i] represents the stock price on the ith day. Returns: int: Maximum profit obtainable from one transaction. Return 0 if no profit possible. \'\'\' ``` **Constraints**: - Prices list can contain up to `10^5` elements. - Prices list elements will be in the range `[0, 10^4]`. **Examples**: - Example 1: ```python Input: [7, 1, 5, 3, 6, 4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5 ``` - Example 2: ```python Input: [7, 6, 4, 3, 1] Output: 0 Explanation: No transaction is done, and the maximum profit = 0 ``` Provide your implemented function in Python.","solution":"from typing import List def max_profit(prices: List[int]) -> int: if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"Problem Statement Given a singly linked list, implement a function to detect if a cycle exists in the list. If a cycle exists, return the node where the cycle begins. If no cycle exists, return `None`. # Input - `head`: The head node of the singly linked list. # Output - The node where the cycle begins, or `None` if there is no cycle. # Constraints - The values of the nodes are not necessary to solve the problem. - The function should strive to achieve an O(n) time complexity and O(1) space complexity. # Example ```python # Example 1: # Input: 1 -> 2 -> 3 -> 4 -> 5 -> 1 (Cycle starts at node with value 1) # Output: Node with value 1 # Example 2: # Input: A -> B -> C -> D -> E -> C (Cycle starts at node with value C) # Output: Node with value C # Example 3: # Input: X -> Y -> Z (No cycle) # Output: None ``` # Function Signature ```python class Node: def __init__(self, x): self.val = x self.next = None def first_cyclic_node(head: Node) -> Node: pass ``` Ensure your code passes the following test cases: ```python import unittest class TestSuite(unittest.TestCase): def test_no_cycle(self): head = Node(\'X\') head.next = Node(\'Y\') head.next.next = Node(\'Z\') self.assertIsNone(first_cyclic_node(head)) def test_cycle_at_start(self): head = Node(1) head.next = Node(2) cycle_start = head head.next.next = Node(3) head.next.next.next = Node(4) head.next.next.next.next = Node(5) head.next.next.next.next.next = cycle_start self.assertEqual(first_cyclic_node(head).val, 1) def test_cycle_in_middle(self): head = Node(\'A\') head.next = Node(\'B\') cycle_start = Node(\'C\') head.next.next = cycle_start cycle_start.next = Node(\'D\') cycle_start.next.next = Node(\'E\') cycle_start.next.next.next = cycle_start self.assertEqual(first_cyclic_node(head).val, \'C\') if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, x): self.val = x self.next = None def first_cyclic_node(head: Node) -> Node: Detects if a cycle exists in the linked list and returns the node where the cycle begins. If no cycle exists, returns None. if head is None: return None slow = head fast = head # Using Floyd\'s Tortoise and Hare algorithm to detect cycle while fast is not None and fast.next is not None: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected, now find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow return None"},{"question":"Task You are tasked with designing a function that computes the number of digits in a number, utilizing logarithmic properties to achieve this in constant time O(1). Objective Implement the function `num_digits(n)` that takes a single integer `n` and returns the number of digits in `n`. Function Signature ```python def num_digits(n: int) -> int: ``` Detailed Requirements * **Input**: - `n`: A signed integer, where -10^18 ≤ n ≤ 10^18. * **Output**: - An integer representing the number of digits in the absolute value of `n`. Constraints * The function should handle both positive and negative integers. * If `n` is 0, the function should return 1. Performance Requirements * The implementation should have a time and space complexity of O(1). Example ```python # Example 1 n = 12345 num_digits(n) # Expected output: 5 # Example 2 n = -678 num_digits(n) # Expected output: 3 # Example 3 n = 0 num_digits(n) # Expected output: 1 ``` # Scenario or Context Imagine you are developing a logging system where every computed number needs to be categorized based on its number of digits. To ensure performance, you need a utility function to quickly determine the digit count of any given number regardless of its magnitude.","solution":"import math def num_digits(n: int) -> int: Returns the number of digits in the absolute value of n. if n == 0: return 1 return int(math.log10(abs(n))) + 1"},{"question":"# Panagram Checker Description Write a function `panagram(string)` that determines whether the provided string is a pangram. A pangram is a sentence that uses every letter of the English alphabet at least once, ignoring case. Function Signature ```python def panagram(string: str) -> bool: ``` Parameters - `string` (str): A sentence in the form of a string which may contain spaces and punctuation. Returns - `bool`: Returns `True` if the input string is a pangram, `False` otherwise. Constraints - The string may contain spaces, punctuation, and numbers, but only the 26 letters of the English alphabet are considered in determining if it is a pangram. - The function should be case-insensitive. Example ```python print(panagram(\\"The quick brown fox jumps over the lazy dog\\")) # Expected output: True print(panagram(\\"Hello, world!\\")) # Expected output: False print(panagram(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\")) # Expected output: True print(panagram(\\"\\")) # Expected output: False print(panagram(\\"Pack my box with five dozen liquor jugs\\")) # Expected output: True ``` Edge Cases - Empty string should return `False`. - Strings with only digits or punctuation should return `False`. - Strings with mixed cases (upper and lower) should still be considered correctly. Performance Requirements Ensure your solution runs efficiently even for large input strings, within a reasonable time and space complexity. Additional Notes - Python\'s `string` module provides a convenient constant `string.ascii_lowercase` which may help in implementing the solution.","solution":"import string def panagram(s: str) -> bool: Determines if the input string is a pangram. Parameters: s (str): Input string which may contain letters, spaces, punctuation, and numbers. Returns: bool: True if the input string is a pangram, False otherwise. # Create a set of all letters in the alphabet alphabet_set = set(string.ascii_lowercase) # Convert input string to lowercase and create a set of characters in the string input_set = set(s.lower()) # Check if alphabet_set is a subset of input_set return alphabet_set.issubset(input_set)"},{"question":"Context Your company needs to implement an efficient array rotation algorithm as part of a data preprocessing system. The system will often rotate arrays of varying lengths and rotation counts, and it’s crucial that the process is performed optimally in terms of both time and space. Problem Statement You are given an array of integers and a non-negative integer (k). Your task is to rotate the array to the right by (k) steps. Implement the most efficient in-place algorithm you can, considering both time and space complexity. Function Signature ```python def rotate_array(array: List[int], k: int) -> None: Rotates the array to the right by k steps. :param array: List[int] - The array to be rotated. :param k: int - The number of steps to rotate the array. :rtype: None pass ``` Input * `array`: A list of integers of length (n) (0 ≤ (n) ≤ (10^5)). * `k`: A non-negative integer representing the number of steps to rotate (0 ≤ (k) ≤ (10^9)). Output * The function should modify the input array in place, with no return value. Example ```python # Example 1 array = [1, 2, 3, 4, 5, 6, 7] k = 3 rotate_array(array, k) # After function call, array should be [5, 6, 7, 1, 2, 3, 4] # Example 2 array = [-1, -100, 3, 99] k = 2 rotate_array(array, k) # After function call, array should be [3, 99, -1, -100] ``` Constraints * The solution must achieve a time complexity of (O(n)). * The solution must achieve a space complexity of (O(1)), modifying the array in place. Notes * Ensure that your solution works for edge cases like empty arrays and single-element arrays. * Optimize for large values of (k) using appropriate operations. Good luck!","solution":"from typing import List def rotate_array(array: List[int], k: int) -> None: Rotates the array to the right by k steps. :param array: List[int] - The array to be rotated. :param k: int - The number of steps to rotate the array. :rtype: None n = len(array) if n == 0: return # Reduce k to minimize unnecessary full rotations k %= n # Helper function to reverse a segment of the array def reverse(arr, start, end): while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 # Reverse the entire array reverse(array, 0, n - 1) # Reverse the first k elements reverse(array, 0, k - 1) # Reverse the remaining elements reverse(array, k, n - 1)"},{"question":"# Rabin-Karp Algorithm for String Matching Objective: Implement a function to find the first occurrence of a given word within a text string using the Rabin-Karp algorithm. Task: Write a function `rabin_karp` that returns the index of the first occurrence of the given word in the text string. If the word is not found, the function should return `-1`. Function Signature: ```python def rabin_karp(word: str, text: str) -> int: ``` Input: - `word`: A non-empty string which is the pattern to search for. - `text`: A potentially empty string (the text in which to search). Output: - An integer. The 0-based index of the first occurrence of the word in the text. Return `-1` if the word is not found. Constraints: - The length of the `word` will be (1 leq m leq 10^4). - The length of the `text` will be (0 leq n leq 10^6). Detailed Explanation: Implement the Rabin-Karp algorithm as follows: 1. Calculate the hash of the search word. 2. Initialize the rolling hash for the text substrings. 3. Slide the window over the text and compare hash values. 4. In case of a hash match, verify by comparing the actual substrings. 5. Return the starting index of the match, or `-1` if no match is found. Example: ```python # Example 1 text = \\"abracadabra\\" word = \\"cad\\" result = rabin_karp(word, text) print(result) # Expected output: 4 # Example 2 text = \\"hello\\" word = \\"ll\\" result = rabin_karp(word, text) print(result) # Expected output: 2 # Example 3 text = \\"aaaaa\\" word = \\"bba\\" result = rabin_karp(word, text) print(result) # Expected output: -1 # Example 4 text = \\"\\" word = \\"a\\" result = rabin_karp(word, text) print(result) # Expected output: -1 ``` Develop your function to be efficient and handle the constraints effectively. Pay special attention to handling edge cases such as empty strings and performance with large inputs.","solution":"def rabin_karp(word: str, text: str) -> int: if not word or not text or len(word) > len(text): return -1 base = 256 prime = 101 m = len(word) n = len(text) hash_word = 0 hash_text = 0 h = 1 for i in range(m - 1): h = (h * base) % prime for i in range(m): hash_word = (base * hash_word + ord(word[i])) % prime hash_text = (base * hash_text + ord(text[i])) % prime for i in range(n - m + 1): if hash_word == hash_text: if text[i:i + m] == word: return i if i < n - m: hash_text = (base * (hash_text - ord(text[i]) * h) + ord(text[i + m])) % prime if hash_text < 0: hash_text = hash_text + prime return -1"},{"question":"# Scenario You are helping develop a cryptographic application that requires efficient calculation of large exponentiations modulo a given number. Your task is to implement an efficient solution for computing `a^n % mod`. The function should work directly on potentially large integers without causing integer overflow and maintain the efficiency for very large values of `n`. # Task Implement a function `modular_exponentiation` that takes three arguments: `a`, `n`, and `mod`, which are the base, exponent, and modulus, respectively. The function should return `(a^n) % mod` in an efficient manner. # Input - `a` (1 <= a <= 10^9): the base. - `n` (0 <= n <= 10^9): the exponent. - `mod` (2 <= mod <= 10^9): the modulus. # Output - An integer representing `(a^n) % mod`. # Constraints - The output should be calculated using an efficient algorithm. - Consider edge cases where `a` or `n` are at their minimum or maximum values. # Performance Requirements - The algorithm should have a time complexity of O(log(n)). # Example ```python def modular_exponentiation(a: int, n: int, mod: int) -> int: # Implement your solution here pass # Example usage: print(modular_exponentiation(2, 10, 1000)) # Output: 24 print(modular_exponentiation(3, 200, 50)) # Output: 1 print(modular_exponentiation(5, 0, 100)) # Output: 1 ``` # Hints 1. Consider how the properties of exponents (a^b)^c = a^(b*c) can simplify the problem. 2. Make sure to take advantage of the modulo operation to keep numbers manageable.","solution":"def modular_exponentiation(a: int, n: int, mod: int) -> int: Computes (a^n) % mod using an efficient algorithm. result = 1 a = a % mod # Update a if it is more than or equal to mod while n > 0: # If n is odd, multiply a with result if n % 2 == 1: result = (result * a) % mod # n must be even now n = n >> 1 # n = n // 2 a = (a * a) % mod # Change a to a^2 return result"},{"question":"# RSA Key Generation and Encryption As a foundational exercise in cryptography, you are tasked with implementing a robust version of the RSA key generation, encryption, and decryption in Python. # Objective Write a function `generate_key(k)` to generate RSA keys, and two functions `encrypt(data, e, n)` and `decrypt(data, d, n)` to encrypt and decrypt data using the RSA algorithm. # Requirements 1. **Key Generation**: - `def generate_key(k: int) -> (int, int, int):` - Input: `k` (number of bits for the modulus `n`) - Output: A tuple `(n, e, d)` where `n` is the modulus, `e` is the encryption exponent, and `d` is the decryption exponent. 2. **Encryption**: - `def encrypt(data: int, e: int, n: int) -> int:` - Input: `data` (integer data to encrypt), `e` (encryption exponent), `n` (modulus) - Output: Encrypted integer. 3. **Decryption**: - `def decrypt(data: int, d: int, n: int) -> int:` - Input: `data` (encrypted integer), `d` (decryption exponent), `n` (modulus) - Output: Decrypted integer. # Constraints - The prime numbers generated for the key should have bit lengths that add up to `k`. - Ensure primality using deterministic checks for smaller bit lengths; probabilistic checks may be used for larger primes. - Ensure `e` and `d` accurately reflect the RSA properties: `(data ** e) ** d % n == data % n`. # Example ```python n, e, d = generate_key(16) data = 20 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data ```","solution":"import random from sympy import isprime, randprime def generate_large_prime(bits): while True: prime_candidate = random.getrandbits(bits) if isprime(prime_candidate): return prime_candidate def gcd_extended(a, b): if a == 0: return (b, 0, 1) gcd, x1, y1 = gcd_extended(b % a, a) x = y1 - (b // a) * x1 y = x1 return gcd, x, y def lcm(a, b): return abs(a * b) // math.gcd(a, b) def generate_key(k: int) -> (int, int, int): p = generate_large_prime(k // 2) q = generate_large_prime(k // 2) n = p * q phi = (p - 1) * (q - 1) e = 65537 gcd, d, _ = gcd_extended(e, phi) if d < 0: d += phi return n, e, d def encrypt(data: int, e: int, n: int) -> int: return pow(data, e, n) def decrypt(data: int, d: int, n: int) -> int: return pow(data, d, n)"},{"question":"Scenario You are working on a project that involves efficiently converting numbers between different numeral systems. Your system needs to handle conversions for bases ranging from binary (base 2) to base 36, including negative numbers in base 10. Additionally, you need to reconstruct numbers from their string representations in these numeral systems back to integers. You are tasked with implementing two functions: 1. **int_to_base**: Converts an integer to its string representation in a specified base. 2. **base_to_int**: Converts a number in string representation from a specified base back to an integer. Function Signatures ```python def int_to_base(num: int, base: int) -> str: Converts an integer to its representation in a specified base. :param num: An integer number to convert. :param base: The base for conversion (between 2 and 36 inclusive). :return: A string representation of the number in the specified base. def base_to_int(str_to_convert: str, base: int) -> int: Converts a string representation of a number in a specified base back to an integer. :param str_to_convert: The string representation to convert. :param base: The base of the number in the string (between 2 and 36 inclusive). :return: The integer value of the string representation. ``` Constraints * The `base` parameter will always be an integer between 2 and 36, inclusive. * The `num` parameter in `int_to_base` can be a positive or negative integer. * The `str_to_convert` parameter in `base_to_int` will always be a valid representation in the specified base. * You should handle edge cases such as zero and negative numbers in `int_to_base`. Examples ```python # Example 1: assert int_to_base(5, 2) == \'101\' assert int_to_base(-10, 16) == \'-A\' assert base_to_int(\'F\', 16) == 15 assert base_to_int(\'101\', 2) == 5 # Example 2: assert int_to_base(0, 2) == \'0\' assert int_to_base(0, 10) == \'0\' assert base_to_int(\'0\', 2) == 0 assert base_to_int(\'0\', 10) == 0 ``` Implement these functions ensuring they handle the constraints and edge cases efficiently.","solution":"def int_to_base(num: int, base: int) -> str: Converts an integer to its representation in a specified base. if not (2 <= base <= 36): raise ValueError(\\"Base must be between 2 and 36, inclusive.\\") if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" negative = num < 0 num = abs(num) result = [] while num: result.append(digits[num % base]) num //= base if negative: result.append(\'-\') return \'\'.join(reversed(result)) def base_to_int(str_to_convert: str, base: int) -> int: Converts a string representation of a number in a specified base back to an integer. if not (2 <= base <= 36): raise ValueError(\\"Base must be between 2 and 36, inclusive.\\") result = 0 negative = str_to_convert.startswith(\'-\') str_to_convert = str_to_convert.lstrip(\'-\') digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" digit_map = {char: index for index, char in enumerate(digits)} for char in str_to_convert: result = result * base + digit_map[char] if negative: result *= -1 return result"},{"question":"# Question: Binary Tree In-order Traversal Verification Given the code snippets above, you understand the process of performing in-order traversal on a binary tree both iteratively and recursively. Your task is to implement a function to determine if a given binary tree is a Binary Search Tree (BST) using an in-order traversal. A Binary Search Tree (BST) follows these properties: 1. The left subtree of a node contains only nodes with keys less than the node\'s key. 2. The right subtree of a node contains only nodes with keys greater than the node\'s key. 3. Both the left and right subtrees must also be binary search trees. # Input - The input consists of a single `Node` object, representing the root of the binary tree. # Output - Return `True` if the tree is a BST, otherwise return `False`. # Constraints - The number of nodes in the tree is not more than 10^4. - The tree values are unique integers. # Function Signature ```python def is_valid_bst(root: Node) -> bool: pass ``` # Performance Requirements - Your solution should have a time complexity of O(n) and a space complexity of O(h), where n is the number of nodes and h is the height of the tree. # Implementation Constraints - Do not alter the `Node` class or the structure of the tree. # Example ```python # Example 1: # Input: # 2 # / # 1 3 # Output: True # Example 2: # Input: # 5 # / # 1 4 # / # 3 6 # Output: False # Explanation: The root node has value 5 but no nodes in the right tree have values greater than 5. n1 = Node(2) n2 = Node(1) n3 = Node(3) n1.left, n1.right = n2, n3 assert is_valid_bst(n1) == True n1 = Node(5) n2 = Node(1) n3 = Node(4) n4 = Node(3) n5 = Node(6) n1.left, n1.right = n2, n3 n3.left, n3.right = n4, n5 assert is_valid_bst(n1) == False ```","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_valid_bst(root: Node) -> bool: def in_order_traversal(node): if node is None: return [] return in_order_traversal(node.left) + [node.value] + in_order_traversal(node.right) values = in_order_traversal(root) for i in range(1, len(values)): if values[i] <= values[i - 1]: return False return True"},{"question":"Coding Assessment Question # Scenario You are tasked with optimizing a low-level data processing system for a microcontroller unit (MCU). The system uses a 32-bit register to monitor the status of 32 sensors (each sensor corresponds to a single bit in the register). As part of the system\'s functionality, you need to design functions to manipulate the bits of these registers efficiently. # Problem Statement Implement a Python class `BitManipulator` that provides methods to perform fundamental bit manipulations on a given integer. Your class should provide the following methods: 1. `get_bit(num: int, i: int) -> bool`: Return the boolean value of the bit at index `i`. 2. `set_bit(num: int, i: int) -> int`: Set the bit at index `i` to 1 and return the modified integer. 3. `clear_bit(num: int, i: int) -> int`: Clear the bit at index `i` to 0 and return the modified integer. 4. `update_bit(num: int, i: int, bit: int) -> int`: Update the bit at index `i` to the value of `bit` (either 0 or 1) and return the modified integer. # Constraints 1. `num` will be a 32-bit unsigned integer. 2. `i` will be an integer such that `0 <= i < 32`. 3. `bit` will be either 0 or 1. # Input and Output Formats * I/O for `get_bit(num: int, i: int) -> bool`: - **Input**: An integer `num`, and an integer `i`. - **Output**: A boolean value representing the bit at index `i`. * I/O for `set_bit(num: int, i: int) -> int`: - **Input**: An integer `num`, and an integer `i`. - **Output**: An integer with the bit at index `i` set to 1. * I/O for `clear_bit(num: int, i: int) -> int`: - **Input**: An integer `num`, and an integer `i`. - **Output**: An integer with the bit at index `i` cleared to 0. * I/O for `update_bit(num: int, i: int, bit: int) -> int`: - **Input**: An integer `num`, an integer `i`, and a bit value `bit`. - **Output**: An integer with the bit at index `i` updated to `bit`. # Example ```python bit_manip = BitManipulator() # Example Usage num = 29 # Binary: 11101 i = 2 bit = 0 print(bit_manip.get_bit(num, i)) # Output: True print(bit_manip.set_bit(num, i)) # Output: 29 (Binary: 11101, bit at index 2 is already set) print(bit_manip.clear_bit(num, i)) # Output: 25 (Binary: 11001) print(bit_manip.update_bit(num, i, bit)) # Output: 25 (Binary: 11001, bit at index 2 is updated to 0) ``` # Notes - Be mindful of edge cases where `i` is on the boundary values (0 and 31). - Ensure your code handles different bit values correctly (1 and 0).","solution":"class BitManipulator: @staticmethod def get_bit(num: int, i: int) -> bool: Returns the boolean value of the bit at index `i`. return (num & (1 << i)) != 0 @staticmethod def set_bit(num: int, i: int) -> int: Sets the bit at index `i` to 1 and returns the modified integer. return num | (1 << i) @staticmethod def clear_bit(num: int, i: int) -> int: Clears the bit at index `i` to 0 and returns the modified integer. return num & ~(1 << i) @staticmethod def update_bit(num: int, i: int, bit: int) -> int: Updates the bit at index `i` to the value of `bit` and returns the modified integer. mask = ~(1 << i) return (num & mask) | (bit << i)"},{"question":"# Question You are given a list `nums` containing integers, where some elements may be duplicated. Your task is to implement a function `permute_unique(nums)` that returns all possible unique permutations of the list `nums`. # Function Signature ```python def permute_unique(nums: List[int]) -> List[List[int]]: pass ``` # Input * `nums` (List[int]): A list of integers `1 <= len(nums) <= 8` and `-10 <= nums[i] <= 10`. # Output * List[List[int]]: A list of lists where each inner list represents a unique permutation of the input list. # Constraints * The solution must handle potential duplicate elements effectively ensuring only unique permutations are returned. * The time complexity should not exceed O(n * n!) and the space complexity should manage storage efficiently. # Example ```python assert permute_unique([1,1,2]) == [ [1,1,2], [1,2,1], [2,1,1] ] assert permute_unique([1,2,3]) == [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] ``` # Scenario Imagine you are working on a software module for generating all possible unique combinations for a word game where some letters may repeat. Your solution should ensure that each unique combination (permutation) of letters is considered, and duplicate combinations are avoided. Implement the function carefully to handle possible duplicates and ensure optimal performance.","solution":"from typing import List def permute_unique(nums: List[int]) -> List[List[int]]: def backtrack(path, remaining, result): if not remaining: result.append(path) return for i in range(len(remaining)): # Skip duplicate numbers if i > 0 and remaining[i] == remaining[i-1]: continue backtrack(path + [remaining[i]], remaining[:i] + remaining[i+1:], result) nums.sort() # Sort the array to make it easier to skip duplicates result = [] backtrack([], nums, result) return result"},{"question":"# FizzBuzz Enhanced You are tasked with implementing a function that not only performs the original FizzBuzz logic but also allows for dynamic configuration of the divisibility conditions and their corresponding outputs. **Specifications**: 1. Implement a function `dynamic_fizzbuzz(n, conditions)` where: - `n`: the positive integer up to which to generate the sequence. - `conditions`: a list of tuples, each containing a divisor and its corresponding string output, e.g., [(3, \'Fizz\'), (5, \'Buzz\')]. 2. The function should return an array containing the numbers from 1 to `n` as follows: - Replace values divisible by any of the divisors provided in `conditions` with their corresponding string outputs. - If a number is divisible by multiple specified divisors, concatenate the corresponding strings in the order given. **Examples**: ```python dynamic_fizzbuzz(15, [(3, \'Fizz\'), (5, \'Buzz\')]) # Returns: [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] dynamic_fizzbuzz(10, [(2, \'Foo\'), (3, \'Bar\')]) # Returns: [1, \'Foo\', \'Bar\', \'Foo\', 5, \'FooBar\', 7, \'Foo\', \'Bar\', \'Foo\'] ``` **Constraints**: * The value of `n` will be at least 1 and at most 10^6. * The list of conditions will contain at least one and at most 20 tuples. * Divisors in the conditions are positive integers. **Function Signature**: ```python def dynamic_fizzbuzz(n: int, conditions: List[Tuple[int, str]]) -> List[Union[int, str]]: ``` **Notes**: * Ensure your function is efficient and handles the input limits effectively. * Consider edge cases such as minimum values and condition overlaps.","solution":"def dynamic_fizzbuzz(n, conditions): result = [] for i in range(1, n + 1): output = \'\' for divisor, text in conditions: if i % divisor == 0: output += text result.append(output if output else i) return result"},{"question":"You are responsible for designing a system that can manage and evaluate connectivity among multiple nodes dynamically. This requires handling two key operations: - Joining two nodes into the same cluster. - Checking if two nodes belong to the same cluster. You\'ll implement a `DynamicConnectivity` class utilizing the Union-Find data structure to accomplish this. Class Specifications 1. **`__init__(initial_nodes: List[int])`**: - Initializes the Union-Find structure with a list of initial nodes. 2. **`unite(node1: int, node2: int) -> None`**: - Merges the clusters containing `node1` and `node2`. 3. **`connected(node1: int, node2: int) -> bool`**: - Returns `True` if `node1` and `node2` are in the same cluster, `False` otherwise. 4. **`add_node(node: int) -> None`**: - Adds a new node to the Union-Find structure as a separate cluster. # Example Usage ```python # Initialize with nodes 1, 2, 3. dc = DynamicConnectivity([1, 2, 3]) # Unite 1 and 2 dc.unite(1, 2) # Check if 1 and 3 are connected print(dc.connected(1, 3)) # Output: False # Check if 1 and 2 are connected print(dc.connected(1, 2)) # Output: True # Adding a new node 4 dc.add_node(4) # Unite 3 and 4 dc.unite(3, 4) # Check if 1, 2, 3, and 4 form one cluster print(dc.connected(1, 4)) # Output: False ``` # Constraints - Node values are non-negative integers. - Number of nodes, n: 1 ≤ n ≤ 10^5 - Number of operations: 1 ≤ operations ≤ 10^5","solution":"class DynamicConnectivity: def __init__(self, initial_nodes): self.parent = {node: node for node in initial_nodes} self.rank = {node: 0 for node in initial_nodes} def find(self, node): if self.parent[node] != node: self.parent[node] = self.find(self.parent[node]) return self.parent[node] def unite(self, node1, node2): root1 = self.find(node1) root2 = self.find(node2) if root1 != root2: if self.rank[root1] > self.rank[root2]: self.parent[root2] = root1 elif self.rank[root1] < self.rank[root2]: self.parent[root1] = root2 else: self.parent[root2] = root1 self.rank[root1] += 1 def connected(self, node1, node2): return self.find(node1) == self.find(node2) def add_node(self, node): if node not in self.parent: self.parent[node] = node self.rank[node] = 0"},{"question":"Scenario You’ve been assigned a task in an e-commerce company to process orders stored in a Binary Search Tree (BST), where each node contains the order ID. To perform various analyses, you often need to find the k-th smallest order ID efficiently. Objective Design a function that takes the root of a BST and an integer k, and returns the k-th smallest element in the BST. Function Signature ```python def kth_smallest_order_id(root: Node, k: int) -> int: pass ``` Input * `root` - the root node of the BST. * Node structure is defined as: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` * `k` - an integer representing the position of the smallest element to find. (1 ≤ k ≤ number of nodes in the BST) Output * The function should return the k-th smallest element in the BST as an integer. Constraints * You may assume that root is a valid BST. * The BST can contain up to 10^5 nodes. * k is always valid. Example ```python # Test Case n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 print(kth_smallest_order_id(n1, 2)) # Output: 50 ``` Implement the `kth_smallest_order_id` function to correctly return the k-th smallest order ID from the BST.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest_order_id(root: Node, k: int) -> int: This function returns the k-th smallest element in the BST. def inorder_traversal(node): if node is None: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) elements = inorder_traversal(root) return elements[k-1]"},{"question":"Context: In cryptographic systems, ensuring secure communication channels is paramount. One common approach is the Diffie-Hellman Key Exchange, which allows two parties to establish a shared secret over a non-secure channel. Your task is to write an implementation that simulates the full Diffie-Hellman key exchange process and verifies the shared secret key. Task: 1. Implement a function `diffie_hellman_key_exchange(a, p)` that verifies if the selected base `a` and modulus `p` can be used for the Diffie-Hellman key exchange and performs the key exchange process between two simulated parties (Alice and Bob). 2. Implement helper functions to: - Check if `p` is a prime number. - Find primitive roots of `p`. - Determine private and public keys for Alice and Bob. - Calculate the shared secret keys. Requirements: 1. **Input**: - `a`: Integer, proposed base (primitive root). - `p`: Integer, a large prime number used as the modulus. 2. **Output**: - Boolean: Indicating if the key exchange was successful (i.e., both parties calculated the same shared secret key). 3. **Constraints**: - 1 < a < p - p should be a large prime number (typically in the range of large primes for cryptography). 4. **Performance**: Ensure the implementation can handle typical cryptographic prime sizes efficiently. Example: ```python # Sample input where 2 is a primitive root of 7 a = 2 p = 7 result = diffie_hellman_key_exchange(a, p) print(result) # Expected output: True ```","solution":"import random def is_prime(n): Check if a number n is a prime if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_primitive_root(p): Find a primitive root of the prime number p. if not is_prime(p): return None if p == 2: return 1 phi = p - 1 factors = set() n = 2 while n * n <= phi: if phi % n == 0: factors.add(n) while phi % n == 0: phi //= n n += 1 if phi > 1: factors.add(phi) for r in range(2, p): flag = False for factor in factors: if pow(r, (p - 1) // factor, p) == 1: flag = True break if not flag: return r return None def diffie_hellman_key_exchange(a, p): Perform Diffie-Hellman Key Exchange simulation between two parties if not is_prime(p): return False primitive_root = find_primitive_root(p) if primitive_root != a: return False # Alice\'s private key private_key_a = random.randint(2, p - 2) public_key_a = pow(a, private_key_a, p) # Bob\'s private key private_key_b = random.randint(2, p - 2) public_key_b = pow(a, private_key_b, p) # Shared secret keys shared_secret_a = pow(public_key_b, private_key_a, p) shared_secret_b = pow(public_key_a, private_key_b, p) return shared_secret_a == shared_secret_b"},{"question":"You are given a singly linked list, where each node contains a character value. Implement a function to remove all duplicate characters from the list, such that each character appears only once. You have to implement two versions of the solution: 1. Using additional memory (e.g., a hash set). 2. Without using any additional memory (no extra data structures). # Function Signatures ```python def remove_duplicates_with_set(head: \'Node\') -> \'Node\': pass def remove_duplicates_without_set(head: \'Node\') -> \'Node\': pass ``` # Input * `head`: The head node of a singly linked list where each node has a `val` attribute (a character) and a `next` node attribute pointing to the next node in the list or `None` if it is the last node. # Output * The head node of the modified linked list with all duplicates removed. # Constraints * The input linked list can have 0 to 10^6 nodes. * The character values can be any ASCII character. # Example ```python # Define the Node class and helper functions for testing class Node(): def __init__(self, val = None): self.val = val self.next = None def print_linked_list(head): string = \\"\\" while head and head.next: string += head.val + \\" -> \\" head = head.next if head: string += head.val print(string) # Construct the linked list: A -> A -> B -> C -> D -> C -> F -> G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # Example Function Calls head1 = remove_duplicates_with_set(a1) print_linked_list(head1) # Expected Output: A -> B -> C -> D -> F -> G # Reset the list for the second example a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g head2 = remove_duplicates_without_set(a1) print_linked_list(head2) # Expected Output: A -> B -> C -> D -> F -> G ``` # Notes * Ensure that your implementation handles edge cases such as an empty list and single-node lists. * For the version without additional memory, pay attention to the performance implications for larger linked lists.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates_with_set(head: \'Node\') -> \'Node\': if not head: return head seen = set() current = head seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head def remove_duplicates_without_set(head: \'Node\') -> \'Node\': if not head: return head current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next return head"},{"question":"# Hash Table Implementation with Custom Resizing Given the implementation of a basic hash table and an extended resizable hash table with linear probing for collision resolution, your task is to implement a custom resize method that optimizes the performance by reducing memory allocation frequency. # Task 1. Implement the `CustomResizableHashTable` class by extending `ResizableHashTable`. 2. The new resize method should adjust the size based on a custom load factor. 3. Ensure that the new hash table retains all existing functionality (insertion, lookup, deletion). 4. Design the resize method to strike a balance between memory overhead and performance, adjusting the size based on varying load factors (e.g., shrink if used space falls below 1/4th and expand if it exceeds 3/4th). # Requirements * Class Name: `CustomResizableHashTable` * Input: - `put(key, value)` - Add or update key-value pairs. - `(key)` - Retrieve value for key if present. - `len()` - Return the number of key-value pairs in the hash table. - `del_(key)` - Delete the key-value pair if exists. * Output: - Correct resizing of hash table based on custom load factors. - Ensure linear probing for collision handling during all operations. - Retain all existing methods and properties (initialization, hashing, rehashing). # Implementation * Implement the `CustomResizableHashTable` class. * Ensure the new class integrates with the provided `HashTable` and `ResizableHashTable` base classes. * Add the `__custom_resize` method to handle custom resizing. ```python class CustomResizableHashTable(ResizableHashTable): EXPAND_SIZE_RATIO = 0.75 SHRINK_SIZE_RATIO = 0.25 def __init__(self): super().__init__() def put(self, key, value): super().put(key, value) if len(self) >= (self.size * self.EXPAND_SIZE_RATIO): self.__custom_resize() def del_(self, key): super().del_(key) if len(self) <= (self.size * self.SHRINK_SIZE_RATIO) and self.size // 2 >= self.MIN_SIZE: self.__custom_resize(shrink=True) def __custom_resize(self, shrink=False): if shrink: self.size = max(self.size // 2, self.MIN_SIZE) else: self.size *= 2 keys, values = self._keys, self._values self._len = 0 self._keys = [self._empty] * self.size self._values = [self._empty] * self.size for key, value in zip(keys, values): if key is not self._empty and key is not self._deleted: self.put(key, value) # Example Usage if __name__ == \\"__main__\\": ht = CustomResizableHashTable() ht.put(1, \'value1\') ht.put(2, \'value2\') ht.put(3, \'value3\') print(\'Initial:\', len(ht)) ht.del_(1) print(\'After deletion:\', len(ht)) for i in range(10): ht.put(i, f\'value{i}\') print(\'After additions:\', len(ht)) print(\'Hash table size:\', ht.size) ``` # Constraints 1. The keys will be non-negative integers. 2. The values can be any valid Python object. 3. Initial size of the hash table is fixed at 8 elements. 4. Resizing logic should only consider the defined load factors.","solution":"class HashTable: _empty = object() _deleted = object() def __init__(self, size=8): self.size = size self._keys = [self._empty] * size self._values = [self._empty] * size self._len = 0 def _hash(self, key): return key % self.size def __len__(self): return self._len def put(self, key, value): idx = self._hash(key) while self._keys[idx] not in (self._empty, self._deleted, key): idx = (idx + 1) % self.size if self._keys[idx] in (self._empty, self._deleted): self._len += 1 self._keys[idx] = key self._values[idx] = value def get(self, key): idx = self._hash(key) start_idx = idx while self._keys[idx] is not self._empty: if self._keys[idx] == key: return self._values[idx] idx = (idx + 1) % self.size if idx == start_idx: break return None def del_(self, key): idx = self._hash(key) start_idx = idx while self._keys[idx] is not self._empty: if self._keys[idx] == key: self._keys[idx] = self._deleted self._values[idx] = self._deleted self._len -= 1 return idx = (idx + 1) % self.size if idx == start_idx: break class ResizableHashTable(HashTable): MIN_SIZE = 8 def __init__(self, size=MIN_SIZE): super().__init__(size) class CustomResizableHashTable(ResizableHashTable): EXPAND_SIZE_RATIO = 0.75 SHRINK_SIZE_RATIO = 0.25 def __init__(self): super().__init__() def put(self, key, value): super().put(key, value) if len(self) >= (self.size * self.EXPAND_SIZE_RATIO): self.__custom_resize() def del_(self, key): super().del_(key) if len(self) <= (self.size * self.SHRINK_SIZE_RATIO) and self.size // 2 >= self.MIN_SIZE: self.__custom_resize(shrink=True) def __custom_resize(self, shrink=False): new_size = max(self.size // 2, self.MIN_SIZE) if shrink else self.size * 2 old_keys = self._keys old_values = self._values self.size = new_size self._keys = [self._empty] * new_size self._values = [self._empty] * new_size self._len = 0 for key, value in zip(old_keys, old_values): if key not in (self._empty, self._deleted): self.put(key, value)"},{"question":"Context: You have been given an implementation of an iterator for a Binary Search Tree (BST), which allows the traversal of the BST in ascending order using an explicit stack to track the nodes. The iterator has already been defined with two functions: `has_next()`, which checks if there are any more nodes to traverse, and `next()`, which returns the value of the next node in ascending order. Task: Your task is to enhance the given implementation by adding a method `reset(root)` which resets the iterator to start from a new root of a BST. Additionally, ensure that the BSTIterator maintains its in-order traversal properties after the reset. Requirements: 1. Implement a `reset(root)` method to reset and initialize the iterator starting from a new root node. 2. Ensure the `has_next()` and `next()` methods still function correctly after being reset. 3. Ensure that the tree traversal remains in in-order. Function Signature: ```python class BSTIterator: def __init__(self, root): pass def has_next(self): pass def next(self): pass def reset(self, root): pass ``` Input: - The `BSTIterator` will be instantiated with the root of a binary search tree. - Calling `reset(root)` will reset the iterator to start from the new root. Output: - `next()` should return the next smallest number in the BST. - `has_next()` should return a boolean indicating whether there is a next node to traverse. Constraints: - The total number of nodes in the BST is between 0 and 30,000. - Assume that `next()` and `has_next()` will only be called if the BST is not empty. Example: ```python # Assuming the following BST: # 7 # / # 3 15 # / # 9 20 iterator = BSTIterator(root) print(iterator.next()) # return 3 print(iterator.next()) # return 7 print(iterator.has_next()) # return True iterator.reset(new_root) # Reset with a new tree print(iterator.next()) # return 9 (based on the new tree\'s structure) ```","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): Initialize the iterator with the root node of a BST. self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): Helper function to add all the leftmost nodes of the tree starting from root to stack. while root: self.stack.append(root) root = root.left def has_next(self) -> bool: Return True if there is a next node in the BST, else False. return len(self.stack) > 0 def next(self) -> int: Return the next smallest number in the BST. # Node at the top of the stack has the next smallest value topmost_node = self.stack.pop() # If the node has a right child, we add all the nodes of leftmost # children of the right child to the stack if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val def reset(self, root: TreeNode): Reset the iterator to start from a new root. self.stack = [] self._leftmost_inorder(root)"},{"question":"# Question: You are tasked with developing an in-place algorithm to rotate a given n x n 2D matrix by 90 degrees clockwise. Write a function `rotate(mat)` that modifies the matrix in place. Function Signature: ```python def rotate(mat: List[List[int]]) -> None: pass ``` Input: - `mat`: A list of lists representing an n x n 2D matrix of integers, where 1 <= n <= 20. Output: - The function should not return anything but should modify the input matrix `mat` in place. Constraints: - The matrix `mat` is guaranteed to be square (n x n). - Do this in-place without using any additional data structures that significantly contribute to memory usage. Description: 1. Reverse the matrix rows. 2. Perform a matrix transpose, swapping elements across the main diagonal. Example: ```python mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate(mat) # The modified matrix should now be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` Edge Cases to Handle: - The function should handle an empty matrix by simply returning it. - For a matrix with one element, the function should return the same matrix. **Note**: Be mindful of potential errors with indices during the transposition stage and ensure all operations modify the matrix in place.","solution":"from typing import List def rotate(mat: List[List[int]]) -> None: n = len(mat) # Step 1: Reverse the rows mat.reverse() # Step 2: Transpose the matrix for i in range(n): for j in range(i+1, n): mat[i][j], mat[j][i] = mat[j][i], mat[i][j]"},{"question":"# Height-Balanced BST from Sorted Array **Objective**: Implement a function to convert a sorted array into a height-balanced binary search tree (BST). **Function Signature**: ```python def sorted_array_to_bst(nums: List[int]) -> Optional[TreeNode]: # Your code here ``` **Input**: * `nums`: A list of integers sorted in ascending order. **Output**: * Return the root node of a height-balanced BST. **Constraints**: * The array consists of `-10^4 <= nums[i] <= 10^4`. * The length of the array will not exceed `10^4`. **Performance Requirements**: * The algorithm must run in O(n) time complexity and use O(log n) auxiliary space where n is the number of elements in the input array. **Instruction**: 1. You must use a class `TreeNode` to define each node of the BST. 2. The BST must be height-balanced, where the height difference between the left and right subtree of any node is at most 1. **Example**: ```python Input: nums = [-10, -3, 0, 5, 9] Output: Binary tree representing [0,-3,9,-10,null,5] Explanation: [0,-3,9,-10,null,5] 0 / -3 9 / / -10 5 ``` # Scenario: Consider an e-commerce platform that needs to efficiently manage product prices. Products are loaded in sorted order into a system that requires quick lookups. Implementing a height-balanced BST from the sorted array can optimize search queries for pricing information. Use the provided class structure to implement the function to meet the requirements. ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sorted_array_to_bst(nums: List[int]) -> Optional[TreeNode]: # Your code here ```","solution":"from typing import List, Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sorted_array_to_bst(nums: List[int]) -> Optional[TreeNode]: def helper(left: int, right: int) -> Optional[TreeNode]: if left > right: return None mid = (left + right) // 2 node = TreeNode(nums[mid]) node.left = helper(left, mid - 1) node.right = helper(mid + 1, right) return node return helper(0, len(nums) - 1)"},{"question":"You are given a stream of tuples, where each tuple contains a number and a sign (+/-). Implement a function `one_sparse_recovery(stream: List[Tuple[int, str]]) -> Optional[int]` that checks if the stream is 1-sparse. An input is considered 1-sparse if, after canceling out paired values (one positive and one negative of the same magnitude), there is exactly one unique number left. If the stream is 1-sparse, the function should return this unique number, otherwise, it should return `None`. # Input Format - A list of tuples, `stream`, where each tuple contains: * An integer number `val` * A sign character `sign`, which is either \'+\' or \'-\' # Output Format - An integer representing the unique number if the stream is 1-sparse. - `None` if the stream is not 1-sparse. # Constraints 1. The number of elements in the stream, N, is in the range [1, 10^5]. 2. The integers in the stream are all non-negative and within a 32-bit integer range. # Performance Requirements The implementation should have: * Time Complexity of O(N) * Space Complexity not exceeding O(log V) where V refers to the range of values represented. # Scenario Alana is monitoring network traffic data where it is crucial to identify a unique user action if it stands out from others canceling each other out. For efficiency, she implements a function to determine if her incoming data stream retains just one significant user action after processing. # Example 1. Input: [(4,\'+\'), (2,\'+\'),(2,\'-\'),(4,\'+\'),(3,\'+\'),(3,\'-\')] Output: 4 _Explanation_: Numbers 2 and 3 cancel out leaving 4 as the unique number. 2. Input: [(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\')] Output: 2 _Explanation_: Only the number 2 is present multiple times. 3. Input: [(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(1,\'+\')] Output: None _Explanation_: Numbers do not cancel out to a unique single number.","solution":"from typing import List, Tuple, Optional from collections import defaultdict def one_sparse_recovery(stream: List[Tuple[int, str]]) -> Optional[int]: count_dict = defaultdict(int) for val, sign in stream: if sign == \'+\': count_dict[val] += 1 elif sign == \'-\': count_dict[val] -= 1 # Check for the remaining non-zero counts non_zero_counts = [k for k, v in count_dict.items() if v != 0] if len(non_zero_counts) == 1: return non_zero_counts[0] else: return None"},{"question":"# Problem Description You are provided with an unsorted array of integers. Your task is to implement the Merge Sort algorithm to sort this array in non-decreasing order. # Input Format - An unsorted list of integers, `arr`. # Output Format - A list of integers sorted in non-decreasing order. # Constraints - 1 ≤ len(arr) ≤ 10^5 - -10^9 ≤ arr[i] ≤ 10^9 for all valid indices `i`. # Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: pass ``` # Example Example 1: **Input**: ```python arr = [3, 1, 2, 5, 4] ``` **Output**: ```python [1, 2, 3, 4, 5] ``` Example 2: **Input**: ```python arr = [5, 4, 3, 2, 1] ``` **Output**: ```python [1, 2, 3, 4, 5] ``` # Explanation 1. Recursively divide the array `arr` into two halves until each half contains a single element. 2. Merge the divided arrays back together in a sorted manner. # Note - You must implement a helper function `merge` that correctly merges two sorted sub-arrays into one. - Consider edge cases such as arrays with a single element, empty arrays, and arrays with all identical elements.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: def merge(left: List[int], right: List[int]) -> List[int]: result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right)"},{"question":"# Integer Decomposition using Dynamic Programming Context: In number theory, partitioning a number into sum components is a classical problem. The task is to find all possible ways a positive integer `n` can be decomposed into a sum of non-negative integers. Task: You are required to implement a function `number_of_decompositions` that takes a single integer `n` and returns the number of ways it can be decomposed into a sum of non-negative integers. Function Signature: ```python def number_of_decompositions(n: int) -> int: pass ``` Input: - A single integer `n` where `1 <= n <= 100`. Output: - An integer representing the number of decomposition ways for the given `n`. Example: 1. For the input `n = 4`, the function should return `5` because the possible decompositions are: - 4 - 3 + 1 - 2 + 2 - 2 + 1 + 1 - 1 + 1 + 1 + 1 2. For the input `n = 7`, the function should return `15` because the possible decompositions are: - 7 - 6 + 1 - 5 + 2 - 5 + 1 + 1 - 4 + 3 - 4 + 2 + 1 - 4 + 1 + 1 + 1 - 3 + 3 + 1 - 3 + 2 + 2 - 3 + 2 + 1 + 1 - 3 + 1 + 1 + 1 + 1 - 2 + 2 + 2 + 1 - 2 + 2 + 1 + 1 + 1 - 2 + 1 + 1 + 1 + 1 + 1 - 1 + 1 + 1 + 1 + 1 + 1 + 1 Requirements: - Your solution should work efficiently, given the constraints. - Ensure that you handle edge cases, such as `n = 1`. Constraints: - You may assume the input will always be a positive integer within the given range. - The output should be within the bounds of a typical integer. Good luck, and ensure your code is optimized and handles edge cases gracefully.","solution":"def number_of_decompositions(n: int) -> int: # Create a table to store results of subproblems dp = [0] * (n + 1) # Base case dp[0] = 1 # Iterate over all numbers up to n for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"# AVL Tree Implementation and Testing **Objective**: Implement additional functionality to an AVL Tree and verify its correctness. You are given a partial implementation of an AVL Tree in Python. Your task is to extend the `AvlTree` class with the following functionalities: 1. **Deletion**: - Implement the `delete` method that removes a node from the AVL tree. - Ensure the tree remains balanced after deletion. 2. **Search**: - Implement the `search` method that finds and returns a given key if it exists in the AVL tree. **Function Signatures**: ```python class AvlTree: # Existing methods... def delete(self, key: int): Deletes the key from the AVL tree. Args: - key (int): The key to be deleted. pass # Your implementation here def search(self, key: int) -> bool: Searches for the key in the AVL tree. Args: - key (int): The key to be searched. Returns: - bool: True if the key is found, False otherwise. pass # Your implementation here ``` **Expected Input and Output**: - The `insert` method takes an integer key and inserts it into the AVL tree. - The `delete` method takes an integer key and removes it from the AVL tree if it exists. - The `search` method takes an integer key and returns a boolean indicating whether the key exists in the tree. - Use the `in_order_traverse` method to verify that the nodes are in non-decreasing order after insertion and deletion. **Constraints**: - Keys are unique integers. - Perform the operations as efficiently as possible, adhering to the AVL tree properties. **Example**: ```python avl = AvlTree() avl.insert(10) avl.insert(20) avl.insert(30) avl.insert(40) avl.insert(50) avl.delete(30) assert avl.search(30) == False assert avl.search(50) == True assert avl.in_order_traverse() == [10, 20, 40, 50] ``` Ensure your implementation handles various edge cases like removing a leaf node, removing a node with one child, and removing a node with two children while maintaining the AVL tree balance.","solution":"class AvlTreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def delete(self, key): self.root = self._delete(self.root, key) def search(self, key): return self._search(self.root, key) def in_order_traverse(self): nodes = [] self._in_order_traverse(self.root, nodes) return nodes def _insert(self, node, key): if not node: return AvlTreeNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self.get_height(node.left), self.get_height(node.right)) balance = self.get_balance(node) if balance > 1 and key < node.left.key: return self.right_rotate(node) if balance < -1 and key > node.right.key: return self.left_rotate(node) if balance > 1 and key > node.left.key: node.left = self.left_rotate(node.left) return self.right_rotate(node) if balance < -1 and key < node.right.key: node.right = self.right_rotate(node.right) return self.left_rotate(node) return node def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self.get_min_value_node(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) if node is None: return node node.height = 1 + max(self.get_height(node.left), self.get_height(node.right)) balance = self.get_balance(node) if balance > 1 and self.get_balance(node.left) >= 0: return self.right_rotate(node) if balance > 1 and self.get_balance(node.left) < 0: node.left = self.left_rotate(node.left) return self.right_rotate(node) if balance < -1 and self.get_balance(node.right) <= 0: return self.left_rotate(node) if balance < -1 and self.get_balance(node.right) > 0: node.right = self.right_rotate(node.right) return self.left_rotate(node) return node def _search(self, node, key): if not node or node.key == key: return bool(node) elif key < node.key: return self._search(node.left, key) else: return self._search(node.right, key) def _in_order_traverse(self, node, nodes): if node: self._in_order_traverse(node.left, nodes) nodes.append(node.key) self._in_order_traverse(node.right, nodes) def get_height(self, node): if not node: return 0 return node.height def get_balance(self, node): if not node: return 0 return self.get_height(node.left) - self.get_height(node.right) def right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def get_min_value_node(self, node): current = node while current.left is not None: current = current.left return current"},{"question":"Scenario As a software engineer working on a graphical simulation project, you need to implement a function that efficiently inverts a matrix used in complex geometric transformations. The matrix inversion is crucial for numerous calculations, including coordinate mapping and linear transformations. Given the importance of this task, your function needs to handle various edge cases and ensure precise computation. Task Write a Python function `invert_matrix(matrix)` that takes as input an n x n matrix `matrix` and returns its inverse. If the matrix cannot be inverted (e.g., non-square or singular matrix), the function should return an appropriate error message using integer codes: * Return `-1` if the matrix is not square. * Return `-2` if the determinant of the matrix is zero (singular matrix). Function Signature ```python def invert_matrix(matrix: List[List[float]]) -> Union[List[List[float]], int]: # Your code here ``` Input * `matrix`: A list of lists of floats, where each list represents a row of an n x n matrix. Output * An n x n matrix (list of lists of floats) representing the inverse of the input matrix. * An integer error code (`-1` or `-2`) based on the constraints mentioned above. Constraints * `2 <= n <= 50` for the size of the matrix. Alternatively, you can refer to the given Python algorithm to understand the required steps and implement the solution accordingly. Example ```python matrix = [ [1, 2], [3, 4] ] print(invert_matrix(matrix)) # Output: [[-2.0, 1.0], [1.5, -0.5]] matrix = [ [0, 1], [1, 0] ] print(invert_matrix(matrix)) # Output: [[0.0, 1.0], [1.0, 0.0]] matrix = [ [1, 2], [2, 4] ] print(invert_matrix(matrix)) # Output: -2 (singular matrix) ``` Ensure your implementation is efficient and considers performance, especially handling matrix operations cleanly and effectively.","solution":"from typing import List, Union def invert_matrix(matrix: List[List[float]]) -> Union[List[List[float]], int]: Returns the inverse of the given matrix if possible. Returns -1 if the matrix is not square. Returns -2 if the matrix is singular. # Check if matrix is square n = len(matrix) if not all(len(row) == n for row in matrix): return -1 # Function to compute the determinant of a matrix def determinant(mat): if len(mat) == 1: return mat[0][0] if len(mat) == 2: return mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0] det = 0 for c in range(len(mat)): cofactor = (-1)**c * mat[0][c] * determinant([row[:c] + row[c+1:] for row in mat[1:]]) det += cofactor return det # Compute the determinant det = determinant(matrix) if det == 0: return -2 # Function to compute the matrix of minors def matrix_of_minors(mat): minors = [] for i in range(len(mat)): row_minors = [] for j in range(len(mat)): minor = determinant([row[:j] + row[j+1:] for row in (mat[:i] + mat[i+1:])]) row_minors.append(minor) minors.append(row_minors) return minors # Function to transpose a matrix def transpose(mat): return list(map(list, zip(*mat))) # Function to get cofactor matrix def cofactor_matrix(mat): minors = matrix_of_minors(mat) for i in range(len(minors)): for j in range(len(minors[i])): minors[i][j] *= (-1) ** (i + j) return minors # Get the cofactor matrix, and then its transpose to get the adjugate cofactor_mat = cofactor_matrix(matrix) adjugate = transpose(cofactor_mat) # Multiply the adjugate by 1/determinant to get the inverse inverse = [[adjugate[i][j] / det for j in range(n)] for i in range(n)] return inverse"},{"question":"# Question: Find Two Numbers that Add up to a Target Value You are given an array of integers that is already sorted in ascending order. Write a function `find_two_sum` that finds two numbers such that they add up to a specific target number. The function should return the 1-based indices of the two numbers such that they add up to the target number. You may assume that each input would have exactly one solution, and you may not use the same element twice. **Function Signature**: ```python def find_two_sum(numbers: List[int], target: int) -> List[int]: pass ``` # Input * `numbers` : List of integers sorted in ascending order. * `target` : A single integer representing the target sum. # Output * Returns a list that contains two integers representing the 1-based indices of the two numbers that add up to the target. # Constraints * The list `numbers` contains at least 2 elements. * The sum of any two elements in the list will fit within a signed 32-bit integer. # Requirements * Implement your function using **two-pointer** technique to ensure (O(n)) time complexity and constant (O(1)) space complexity. # Example Input ```python numbers = [2, 7, 11, 15] target = 9 ``` Output ```python [1, 2] ``` # Note The returned indices are 1-based, so the element at index 1 is the first element of the list.","solution":"from typing import List def find_two_sum(numbers: List[int], target: int) -> List[int]: Finds two numbers in the sorted list that add up to the target and returns their 1-based indices. left = 0 right = len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1 # As per the problem statement, this line should never be reached because # there is exactly one solution."},{"question":"# Question: Implement Tribonacci Sequence Generator Tribonacci sequence is a generalization of the Fibonacci sequence where each term is the sum of the three preceding terms. That is, the next term is always the sum of the previous three terms. The first three terms of the Tribonacci sequence are _0, 1, 1_. Write a function `tribonacci` that takes a non-negative integer `n` and returns the n-th Tribonacci number. Specifications: * The function `tribonacci` should have the signature: `def tribonacci(n: int) -> int:` * Expected input: A non-negative integer `n` where (0 leq n leq 37) (this constraint ensures calculations stay within the limits of a 32-bit integer). * Expected output: The n-th Tribonacci number. Example: ```python print(tribonacci(0)) # Output: 0 print(tribonacci(1)) # Output: 1 print(tribonacci(2)) # Output: 1 print(tribonacci(3)) # Output: 2 print(tribonacci(4)) # Output: 4 print(tribonacci(5)) # Output: 7 ``` Requirements: * **Efficiency**: Consider the performance of your solution and ensure it can compute the result within a reasonable time frame for the given constraints. * **Edge Cases**: Make sure to account for small and edge cases, such as the smallest value (0) and the boundaries of n.","solution":"def tribonacci(n: int) -> int: Returns the n-th Tribonacci number. if n == 0: return 0 if n == 1 or n == 2: return 1 t0, t1, t2 = 0, 1, 1 for i in range(3, n + 1): t3 = t0 + t1 + t2 t0, t1, t2 = t1, t2, t3 return t2"},{"question":"# Coding Challenge: Unique Character String Generation Objective Write a function `unique_char_string` that takes a string as an input and removes any reoccurring character, returning a new string that contains only the first occurrence of each character in the order they appeared in the input string. Function Signature ```python def unique_char_string(input_string: str) -> str: pass ``` Input - `input_string` (str): A string consisting of alphanumeric characters and/or symbols. Output - (str): A new string composed of unique characters from the input string, preserving their first occurrence order. Constraints - The input string can be empty. - All lowercase and uppercase letters are treated as distinct characters. - The input string length will not exceed 10^5 characters. Example ```python assert unique_char_string(\\"google\\") == \\"gole\\" assert unique_char_string(\\"elephant\\") == \\"elphant\\" assert unique_char_string(\\"aaaaa\\") == \\"a\\" assert unique_char_string(\\"\\") == \\"\\" ``` Use the given examples to verify correctness and ensure the function handles edge cases effectively. Performance Requirements - Time complexity should be O(n), where n is the length of the input string. - Space complexity should be O(n), considering the auxiliary space required for storage. Ensure your solution is efficient and can handle the upper constraint limits effectively.","solution":"def unique_char_string(input_string: str) -> str: Removes reoccurring characters, retaining only the first occurrence of each character in the input string. :param input_string: Original string input composed of alphanumeric characters / symbols. :return: New string with only unique characters from the input string in order. seen_chars = set() unique_chars = [] for char in input_string: if char not in seen_chars: seen_chars.add(char) unique_chars.append(char) return \\"\\".join(unique_chars)"},{"question":"# Scenario/context: You are tasked to develop solutions for handling queries related to tree structures in a large network system. One of the foundational tasks is to determine the relationship between nodes efficiently. For this purpose, you need to identify the lowest common ancestor (LCA) for any two given nodes in a binary tree. # Problem Statement: Write a function `find_lca` that determines the lowest common ancestor of two given nodes in a binary tree. Your function will be tested against various test cases including large trees. The solution should handle edge cases and optimize for deep recursion situations. Function Signature: ```python def find_lca(root: \'TreeNode\', p: \'TreeNode\', q: \'TreeNode\') -> \'TreeNode\': ``` Input: * `root`: The root node of the binary tree. * `p` and `q`: The two nodes for which the lowest common ancestor is to be found. Output: * Return the lowest common ancestor node of nodes `p` and `q`. # Constraints: * The number of nodes in the tree will be in the range `[1, 10^4]`. * The value of nodes will be unique within the range `[1, 10^4]`. * Both nodes p and q will exist in the binary tree (you don\'t need to check this condition). # Example: ```python _______3______ / ___5__ ___1__ / / 6 _2 0 8 / 7 4 For input [root = 3, p = 5, q = 1], the output should be 3. For input [root = 3, p = 5, q = 4], the output should be 5. ``` # Additional Notes: * Consider implementing optimizations or iterative approaches to manage very deep trees effectively. * Handle duplication checks within nodes and ensure unique constraints are maintained as per the input description.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_lca(root: \'TreeNode\', p: \'TreeNode\', q: \'TreeNode\') -> \'TreeNode\': Determines the lowest common ancestor (LCA) of two given nodes in a binary tree. if root is None or root == p or root == q: return root left = find_lca(root.left, p, q) right = find_lca(root.right, p, q) if left and right: return root return left if left else right"},{"question":"# Robot Movement Path Checker Imagine you are designing a control system for a simple robot that moves in a 2D plane. The robot starts at the origin (0, 0) and can move up (\'U\'), down (\'D\'), left (\'L\'), or right (\'R\'). You are required to write a function to determine if a sequence of moves will cause the robot to return to its starting position. # Task Implement the function `does_robot_return(moves: str) -> bool` which takes a single parameter: * `moves` (string): A sequence of characters representing the robot\'s moves. Each character is one of \'U\', \'D\', \'L\', or \'R\'. The function should return a boolean value: * `True` if the sequence of moves returns the robot to the original position (0, 0). * `False` otherwise. # Input Constraints: * Each character in the `moves` string will be one of \'U\', \'D\', \'L\', or \'R\'. * The length of the `moves` string will be between 0 and 10,000. # Example ```python # Example 1: # Input: \\"UD\\" # Output: True print(does_robot_return(\\"UD\\")) # Example 2: # Input: \\"LL\\" # Output: False print(does_robot_return(\\"LL\\")) # Example 3: # Input: \\"\\" # Output: True print(does_robot_return(\\"\\")) ``` # Note Consider possible edge cases where the input is empty, or where the number of moves in one direction does not exactly balance with the opposing direction.","solution":"def does_robot_return(moves: str) -> bool: Determines if a sequence of moves will return the robot to its starting position. Parameters: moves (str): A string representing the robot\'s moves, where each character is one of \'U\', \'D\', \'L\', or \'R\'. Returns: bool: True if the robot returns to the origin (0, 0), otherwise False. x, y = 0, 0 for move in moves: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return x == 0 and y == 0"},{"question":"# Integer Partition: Calculation Challenge Problem Statement: You are given a positive integer `n`. Your task is to determine the number of ways to partition this integer into sums of non-negative integers. Each partition should be counted only once, ignoring the order of the summands. Input: - An integer `n` where (1 leq n leq 1000). Output: - An integer representing the number of different partitions of the given number. Function Signature: ```python def number_of_partitions(n: int) -> int: pass ``` Example: ```python number_of_partitions(4) # Output: 5 ``` ```python number_of_partitions(7) # Output: 15 ``` Explanation: For `n = 4`, the partitions are: 1. 4 2. 3+1 3. 2+2 4. 2+1+1 5. 1+1+1+1 Constraints: 1. Your solution must run in O(n^2) time complexity. 2. You should consider the space complexity and try to optimize where possible. 3. Avoid redundant operations and ensure that your solution is efficient for larger values of `n`.","solution":"def number_of_partitions(n: int) -> int: Returns the number of ways to partition the integer n into sums of non-negative integers, each partition being counted only once ignoring the order of the summands. # Create an array to store the partition counts partitions = [0] * (n + 1) partitions[0] = 1 # Calculate the partitions using dynamic programming for num in range(1, n + 1): for j in range(num, n + 1): partitions[j] += partitions[j - num] return partitions[n]"},{"question":"# Verify Consecutive Elements in Stack Scenario John is working on a project where he needs to validate if given sequences of numbers in stacks are consecutive. He wants to maintain the integrity of the stacks while performing this check for sequences starting from the bottom of the stack. Task Implement a function `is_consecutive(stack)` that verifies if the stack contains a sequence of consecutive integers starting from the bottom. Ensure the integrity of the stack is maintained post-check. Function Signature ```python def is_consecutive(stack): pass ``` Input * `stack`: A list representing a stack where the first element is at the bottom and the last element is at the top. It contains integers. Output * A boolean value: - Returns `True` if the stack contains a sequence of consecutive integers starting from the bottom. - Returns `False` otherwise. Constraints * The length of the stack will be between 0 and 10^4. * Elements in the stack will be integers ranging from -10^5 to 10^5. * The stack should remain unchanged after the operation. Examples 1. **Example 1**: * Input: `stack = [3, 4, 5, 6, 7]` * Output: `True` 2. **Example 2**: * Input: `stack = [3, 4, 6, 7]` * Output: `False` 3. **Example 3**: * Input: `stack = [1]` * Output: `True` 4. **Example 4**: * Input: `stack = [3, 2, 1]` * Output: `False` Notes * Ensure you restore the original stack order after performing your checks. * Avoid using any built-in functions that may accidentally sort or alter the order of elements. * Efficiency and space utilization will be considered during evaluation.","solution":"def is_consecutive(stack): Verifies if the stack contains a sequence of consecutive integers starting from the bottom. if not stack: return True # Create a copy of the stack to preserve its integrity temp_stack = stack[:] # Loop through the copied stack and check for consecutive elements for i in range(len(temp_stack) - 1): if temp_stack[i] + 1 != temp_stack[i + 1]: return False return True"},{"question":"You are given a list of integers and two optional integer values `min_lim` and `max_lim`. Your task is to implement a function `limit_filter` that returns a new list containing only the elements from the original list that are between the `min_lim` and `max_lim` values (inclusive). If `min_lim` or `max_lim` is not provided, the function should use the minimum or maximum value of the list as the respective limits. Function Signature ```python def limit_filter(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: ``` Input - `arr`: A list of integers (`List[int]`) - `min_lim`: An optional integer representing the minimum limit (`Optional[int]`) - `max_lim`: An optional integer representing the maximum limit (`Optional[int]`) Output - Returns a new list (`List[int]`) containing only the elements between `min_lim` and `max_lim` (inclusive). Constraints - The function should handle input arrays up to a length of 10^6. - The function should operate with a time complexity of O(n). - Ensure to handle cases where `arr` is empty. Examples ```python assert limit_filter([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert limit_filter([10, 20, 30, 40, 50], 15, 35) == [20, 30] assert limit_filter([4, 8, 2, 7, 3, 1], 3, None) == [4, 8, 7, 3] assert limit_filter([], 5, 10) == [] assert limit_filter([100, 200, 300], None, None) == [100, 200, 300] ```","solution":"from typing import List, Optional def limit_filter(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: if not arr: return [] min_value = min(arr) if min_lim is None else min_lim max_value = max(arr) if max_lim is None else max_lim return [x for x in arr if min_value <= x <= max_value]"},{"question":"# FizzBuzz Plus In this question, you are required to implement a modified version of the traditional FizzBuzz that incorporates additional programmability and flexibility. You will define a function `fizzbuzz_plus(n, rules)` that generates a list of numbers from 1 to n, but replaces the numbers according to a set of rules provided as input. Each rule in the `rules` list is a tuple consisting of two elements: 1. A number `divisor` which should be checked as the divisor for the current iteration. 2. A string `substitute` which should be used in place of the current iteration number if the modulo operation with `divisor` equals 0. The final result list should be generated based on the following logic: 1. For each number in [1, n], check each `divisor` from the rules list. 2. Replace the number with the `substitute` strings of all rules that apply. If a number is replaced by multiple substitute strings, concatenate the substitutes in their respective order. # Function Signature: ```python def fizzbuzz_plus(n: int, rules: List[Tuple[int, str]]) -> List[Union[int, str]]: ``` # Parameters: - `n` (int): The end number of the sequence (inclusive), guaranteed to be at least 1. - `rules` (List[Tuple[int, str]]): A list of tuples where each tuple contains: - An integer `divisor` for divisibility check. - A string `substitute` that replaces numbers divisible by `divisor`. # Return: - A list containing numbers from 1 to n, with applicable substitutions. # Constraints: - Each `divisor` in the `rules` list will be greater than 0. # Example: ```python assert fizzbuzz_plus(15, [(3, \'Fizz\'), (5, \'Buzz\')]) == [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] ``` # Notes: - Make sure that the function handles empty `rules` list and returns the original sequence [1, 2, ..., n] without any replacement. - Validate input values and raise appropriate exceptions for invalid inputs.","solution":"from typing import List, Tuple, Union def fizzbuzz_plus(n: int, rules: List[Tuple[int, str]]) -> List[Union[int, str]]: result = [] for i in range(1, n + 1): substitute = \\"\\" for divisor, word in rules: if i % divisor == 0: substitute += word result.append(substitute if substitute else i) return result"},{"question":"You are tasked with writing a function to identify numbers in a given range where the sum of the digits, raised to the power of their respective positions, equals the number itself. # Function Signature ```python def sum_dig_pow(low: int, high: int) -> List[int]: pass ``` # Input * `low` (int): The lower bound of the range (inclusive). * `high` (int): The upper bound of the range (inclusive). Both `low` and `high` will be positive integers such that `1 <= low <= high <= 10^6`. # Output * A list of integers that satisfy the condition. # Example ```python assert sum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert sum_dig_pow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert sum_dig_pow(90, 150) == [135] ``` # Constraints * The function should handle large ranges efficiently for values up to 1,000,000. * Consider possible edge cases such as minimal ranges where `low` equals `high`. # Additional Notes * You may assume the input range is always valid (i.e., `low` will always be less than or equal to `high`).","solution":"from typing import List def sum_dig_pow(low: int, high: int) -> List[int]: def is_eureka_number(num: int) -> bool: digits = [int(d) for d in str(num)] return num == sum(d ** (i + 1) for i, d in enumerate(digits)) return [num for num in range(low, high + 1) if is_eureka_number(num)]"},{"question":"# Title: Calculate Minimum Depth of Binary Tree **Context**: You are working on a tree-based application that requires frequent calculations of tree depth. Efficiently determining the minimal depth of the tree is crucial for performance. **Problem Statement**: Write a function `min_depth` that calculates the minimum depth of a binary tree. Function Signature: ```python def min_depth(root): :type root: TreeNode :rtype: int ``` **Input**: - `root` (TreeNode): The root of the binary tree. **Output**: - Integer representing the minimum depth of the tree. **Constraints**: - TreeNode class structure is defined; each node has `val`, `left`, and `right`. - 1 ≤ Number of nodes ≤ 10^4 - Values within tree nodes can be any integer, including negative and zero. **Example**: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None # Example Tree: # 1 # / # 2 3 # / # 4 # / # 5 tree = TreeNode(1) tree.left = TreeNode(2) tree.right = TreeNode(3) tree.left.left = TreeNode(4) tree.left.left.left = TreeNode(5) print(min_depth(tree)) # Should print 2 (Path: 1 -> 3) tree2 = TreeNode(1) print(min_depth(tree2)) # Should print 1 (Only root node) ``` **Description**: The function should implement the following: 1. Use a BFS traversal to find the first leaf node (node without children) and return the depth at which this node is found. 2. Ensure the function handles edge cases such as null input trees, trees with only root, and large unbalanced trees. Consider performance efficiency, and make sure to handle all edge cases for a thorough and robust implementation.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def min_depth(root): :type root: TreeNode :rtype: int if not root: return 0 from collections import deque queue = deque([(root, 1)]) # (node, current_depth) while queue: current_node, depth = queue.popleft() if not current_node.left and not current_node.right: return depth if current_node.left: queue.append((current_node.left, depth + 1)) if current_node.right: queue.append((current_node.right, depth + 1))"},{"question":"Problem Description You are given an n x n 2D matrix representing an image or grid. Write a function `rotate(matrix: List[List[int]]) -> None` that rotates the matrix by 90 degrees (clockwise). Your solution should perform the rotation in place, meaning you should not use another matrix to accomplish the rotation. Input/Output * **Input**: An n x n matrix of integers, where 1 <= n <= 20. ```python matrix = [[int, int, ...], # n rows [int, int, ...], # and ... # n columns [int, int, ...]] ``` * **Output**: The matrix itself should be rotated in place. The function should return `None`. Constraints * You must perform the rotation in-place. * Only applicable to square matrices. Performance Requirements * **Time Complexity**: O(n^2) * **Space Complexity**: O(1) Example ```python # Sample input matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Function call rotate(matrix) # Expected output (in place) matrix = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` You can assume that the matrix will always be valid as per the given constraints.","solution":"def rotate(matrix): Rotates the given n x n matrix by 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"Optimized Jump Search Context You are working on a software system that processes large volumes of sorted data. To speed up search operations, you decide to implement a search algorithm that leverages Jump Search\'s principles but also optimizes the block size dynamically based on the characteristics of the dataset. Problem Statement Write a Python function `optimized_jump_search` that finds the index of a target value in a sorted array using an optimized version of Jump Search. The function should dynamically calculate the block size based on the array length and apply a binary search within the identified block for further optimization. Function Signature ```python def optimized_jump_search(arr: list, target: int) -> int: ``` Input * `arr`: A sorted list of integers. * `target`: An integer representing the value to search for. Output * An integer representing the index of the target value in the array if found, otherwise -1. Constraints * The array length `n` can be up to 10^6. * The elements of the array are sorted in non-decreasing order. * Values of the elements and target are within the range of `-10^6` to `10^6`. Example ```python assert optimized_jump_search([1, 3, 5, 7, 9, 11, 13, 15, 17, 19], 11) == 5 assert optimized_jump_search([1, 3, 5, 7, 9, 11, 13, 15, 17, 19], 10) == -1 ``` Additional Implementation Guidelines * **Edge Cases**: Ensure to handle cases where the target element is not present, or the array is empty. * **Optimization**: Implement a dynamic block size calculation. Once the block containing the target value is found, use Binary Search within that block for an optimal result. * **Error Handling**: Ensure to return -1 if the target is not found.","solution":"import math def binary_search(arr, target, left, right): while left <= right: mid = left + (right - left) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1 def optimized_jump_search(arr: list, target: int) -> int: n = len(arr) if n == 0: return -1 # Finding the optimal block size block_size = int(math.sqrt(n)) # Finding the block where the element is present prev = 0 while arr[min(block_size, n)-1] < target: prev = block_size block_size += int(math.sqrt(n)) if prev >= n: return -1 # Do a binary search in the found block return binary_search(arr, target, prev, min(block_size, n)-1)"},{"question":"# Problem Description Write a function that calculates the Hamming weight of an unsigned integer. The Hamming weight is the number of \'1\' bits present in the binary representation of the given unsigned integer. ```python def hamming_weight(n: int) -> int: Given a 32-bit integer n, return the number of \'1\' bits it has. Args: n: An unsigned 32-bit integer. Returns: int: The number of \'1\' bits in the integer\'s binary representation. # Your implementation goes here ``` # Input Format: * An unsigned 32-bit integer `n`. # Constraints: * `0 <= n <= 2^32 - 1` # Output Format: * Return an integer representing the number of \'1\' bits in the binary representation of `n`. # Example: 1. Input: `n = 11` Output: `3` Explanation: The binary representation of `11` is `00000000000000000000000000001011`, which has three \'1\' bits. 2. Input: `n = 128` Output: `1` Explanation: The binary representation of `128` is `00000000000000000000000010000000`, which has one \'1\' bit. 3. Input: `n = 4294967295` Output: `32` Explanation: The binary representation of `4294967295` is `11111111111111111111111111111111`, which has thirty-two \'1\' bits. # Notes: * The function should be optimized to run efficiently for any valid 32-bit unsigned integer within the specified constraints.","solution":"def hamming_weight(n: int) -> int: Given a 32-bit integer n, return the number of \'1\' bits it has. Args: n: An unsigned 32-bit integer. Returns: int: The number of \'1\' bits in the integer\'s binary representation. return bin(n).count(\'1\')"},{"question":"# Question: Flatten Nested Arrays In this task, you will write a function to flatten an array that may contain nested arrays into a single resultant flatten array. Your function should support both iterative and recursive approaches and be able to handle deeply nested arrays efficiently. The function should avoid exceeding Python\'s recursion depth limit and be memory efficient. # Function Signature ```python def flatten_nested_array(input_arr): Flatten a nested array into a single list. Parameters: input_arr (list): A list which can contain nested lists. Returns: list: A single flattened list containing all elements from the nested input_arr. pass ``` # Example ```python assert flatten_nested_array([1, [2, 3], [4, [5, 6]], 7]) == [1, 2, 3, 4, 5, 6, 7] assert flatten_nested_array([]) == [] assert flatten_nested_array([[[1]], [2, [3]], 4]) == [1, 2, 3, 4] assert flatten_nested_array([\'a\', [\'b\', \'c\'], [[[\'d\']]], \'e\']) == [\'a\', \'b\', \'c\', \'d\', \'e\'] ``` # Constraints - Input list will have a maximum depth of 1000. - The lengths of input lists are at most (10^5). # Notes - You may need to validate the input to ensure it does not exceed the maximum constraints, to avoid Deep Recursion issues. - Ensure that the function is robust and handles all edge cases efficiently.","solution":"def flatten_nested_array(input_arr): Flatten a nested array into a single list. Parameters: input_arr (list): A list which can contain nested lists. Returns: list: A single flattened list containing all elements from the nested input_arr. result = [] def flatten(arr): for element in arr: if isinstance(element, list): flatten(element) else: result.append(element) flatten(input_arr) return result"},{"question":"You are required to implement endian conversion utilities that convert integers to byte arrays and vice versa for both big-endian and little-endian formats. Function 1: int_to_bytes_big_endian * **Input**: A non-negative integer `num`. * **Output**: A `bytes` object representing the `num` in `big-endian` format. Function 2: int_to_bytes_little_endian * **Input**: A non-negative integer `num`. * **Output**: A `bytes` object representing the `num` in `little-endian` format. Function 3: bytes_big_endian_to_int * **Input**: A `bytes` object representing a big-endian encoded number. * **Output**: An integer that the byte sequence represents. Function 4: bytes_little_endian_to_int * **Input**: A `bytes` object representing a little-endian encoded number. * **Output**: An integer that the byte sequence represents. You should ensure your functions are optimized for edge cases, handle large inputs effectively, and do not exceed reasonable space/time complexity. Constraints * You may assume that inputs are non-negative integers and valid byte arrays. * Aim to minimize the number of operations where possible. * The input integer and byte arrays can be very large; consider memory efficiency. Examples ```python assert int_to_bytes_big_endian(1025) == bytes([0x04, 0x01]) assert int_to_bytes_little_endian(1025) == bytes([0x01, 0x04]) assert bytes_big_endian_to_int(bytes([0x04, 0x01])) == 1025 assert bytes_little_endian_to_int(bytes([0x01, 0x04])) == 1025 ``` Implement the following functions: * `int_to_bytes_big_endian(num)` * `int_to_bytes_little_endian(num)` * `bytes_big_endian_to_int(bytestr)` * `bytes_little_endian_to_int(bytestr)`","solution":"def int_to_bytes_big_endian(num): if num == 0: return b\'x00\' byte_array = [] while num > 0: byte_array.append(num & 0xFF) num >>= 8 return bytes(byte_array[::-1]) def int_to_bytes_little_endian(num): if num == 0: return b\'x00\' byte_array = [] while num > 0: byte_array.append(num & 0xFF) num >>= 8 return bytes(byte_array) def bytes_big_endian_to_int(bytestr): num = 0 for byte in bytestr: num = (num << 8) | byte return num def bytes_little_endian_to_int(bytestr): num = 0 for i, byte in enumerate(bytestr): num |= byte << (i * 8) return num"},{"question":"Problem Statement You are given two strings. Your task is to determine if the two strings are anagrams, considering they contain only lowercase alphabetic characters. Write a function `are_anagrams(s1, s2)` that returns `True` if they are anagrams and `False` otherwise. # Input and Output Format - **Input** - `s1`: (1 ≤ |s1| ≤ 10^5) A string comprised of lowercase alphabetic characters - `s2`: (1 ≤ |s2| ≤ 10^5) A string comprised of lowercase alphabetic characters - **Output** - `True` if `s1` and `s2` are anagrams, `False` otherwise. # Constraints - The function should run in O(n) time complexity and use a constant amount of space. - Avoid using built-in sorting functions. # Example ```python >>> are_anagrams(\\"apple\\", \\"pleap\\") True >>> are_anagrams(\\"apple\\", \\"cherry\\") False >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"hello\\", \\"bello\\") False >>> are_anagrams(\\"anagram\\", \\"nagaram\\") True ``` # Implementation Guidelines 1. Initialize two lists of size 26 to zero to store counts of each character for both strings. 2. Iterate over each character in the first string and count its occurrences. 3. Iterate over each character in the second string and count its occurrences. 4. Compare the two lists; if they are equal, the strings are anagrams. Write the code for `are_anagrams(s1, s2)` below: ```python def are_anagrams(s1, s2): if len(s1) != len(s2): return False count1 = [0] * 26 count2 = [0] * 26 for char in s1: pos = ord(char) - ord(\'a\') count1[pos] += 1 for char in s2: pos = ord(char) - ord(\'a\') count2[pos] += 1 return count1 == count2 ```","solution":"def are_anagrams(s1, s2): if len(s1) != len(s2): return False count = [0] * 26 for char in s1: pos = ord(char) - ord(\'a\') count[pos] += 1 for char in s2: pos = ord(char) - ord(\'a\') count[pos] -= 1 return all(x == 0 for x in count)"},{"question":"# Question: Implement a Custom Sorting Algorithm Context You are working as a software engineer in a company that handles a large dataset of products with unique product IDs. Although there are efficient built-in sorting algorithms, you are required to demonstrate your understanding of basic sorting principles by implementing a variant sorting algorithm. Your custom algorithm should be somewhat unique compared to the commonly used ones. Task Implement a custom sorting algorithm named `custom_exchange_sort` that improves upon the standard exchange sort mechanism. Your algorithm should follow the criteria below: 1. Sort an array of integers in non-decreasing order. 2. Instead of a simple swap, think of a way to reduce the number of swaps while maintaining the sorting order. Input and Output Formats * **Input**: A list of integers `arr`. * **Output**: A sorted list of integers in non-decreasing order. Constraints * The length of `arr` will be between `0` and `1000`. * The elements of `arr` will be between `-10^5` and `10^5`. Example ```python # Example 1: # Input: [5, 3, 8, 4, 2] # Output: [2, 3, 4, 5, 8] # Example 2: # Input: [10, -5, 2] # Output: [-5, 2, 10] ``` Performance Requirements Your implementation should aim to slightly optimize the number of array accesses and swaps compared to the basic exchange sort.","solution":"def custom_exchange_sort(arr): Custom exchange sorting algorithm that sorts an array of integers in non-decreasing order. n = len(arr) if n < 2: return arr for i in range(n - 1): min_idx = i for j in range(i + 1, n): if arr[j] < arr[min_idx]: min_idx = j if min_idx != i: arr[i], arr[min_idx] = arr[min_idx], arr[i] return arr"},{"question":"You are provided with an implementation of a Segment Tree data structure. A segment tree is useful for performing range-based queries efficiently. # Task Implement a function `range_operations` that utilizes the segment tree to perform a series of range operations on a given array. You\'ll be implementing this in the context of aggregation functions such as sum, minimum, and maximum. # Scenario Suppose you are given an array of integers. You want to perform efficient range operations on this array. Each operation can be one of three types: - Find the sum of elements in a given range. - Find the minimum element in a given range. - Find the maximum element in a given range. Your task is to process multiple such range operations efficiently using a segment tree. # Function Signature: ```python def range_operations(arr: List[int], operations: List[Tuple[str, int, int]]) -> List[int]: Perform a list of range operations on the given array using a segment tree. :param arr: List[int] - the input array of integers. :param operations: List[Tuple[str, int, int]] - a list of operations in the format (operation_type, start, end), where operation_type is one of \'sum\', \'min\', \'max\'. The (start, end) represents the inclusive range for the operation. :return: List[int] - the results of each operation. ``` # Input and Output * **Input**: * `arr`: A list of integers representing the array. * `operations`: A list of tuples where each tuple contains three elements: * `operation_type`: A string that can be either \\"sum\\", \\"min\\", or \\"max\\". * `start`: An integer representing the start index of the range (inclusive). * `end`: An integer representing the end index of the range (inclusive). * **Output**: * A list of integers where each integer is the result of the corresponding operation in the `operations` list. # Constraints * 1 <= len(arr) <= 10^5 * 0 <= start <= end < len(arr) * 1 <= operation count <= 10^5 * Elements of the array will be between -10^4 and 10^4. # Example ```python arr = [2, 4, 5, 3, 4] operations = [(\\"sum\\", 1, 3), (\\"min\\", 0, 4), (\\"max\\", 2, 4)] range_operations(arr, operations) # Output: [12, 2, 5] ``` # Additional Notes * Your solution should handle a large number of operations efficiently. * You should leverage the segment tree structure to ensure that each range operation is performed in O(log n) time. * Consider edge cases such as handling operations on the bounds of the array and operations on very small or large ranges.","solution":"from typing import List, Tuple import math class SegmentTree: def __init__(self, arr, operation): self.n = len(arr) self.tree = [0] * (2 * self.n) self.operation = operation self.build(arr) def build(self, arr): for i in range(len(arr)): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.operation(self.tree[i * 2], self.tree[i * 2 + 1]) def range_query(self, l, r): l += self.n r += self.n + 1 res = None while l < r: if l & 1: res = self.tree[l] if res is None else self.operation(res, self.tree[l]) l += 1 if r & 1: r -= 1 res = self.tree[r] if res is None else self.operation(res, self.tree[r]) l >>= 1 r >>= 1 return res def range_operations(arr: List[int], operations: List[Tuple[str, int, int]]) -> List[int]: sum_tree = SegmentTree(arr, lambda x, y: x + y) min_tree = SegmentTree(arr, min) max_tree = SegmentTree(arr, max) result = [] for op_type, start, end in operations: if op_type == \\"sum\\": result.append(sum_tree.range_query(start, end)) elif op_type == \\"min\\": result.append(min_tree.range_query(start, end)) elif op_type == \\"max\\": result.append(max_tree.range_query(start, end)) return result"},{"question":"# String Reversal Challenge Scenario You are tasked with developing a library function to reverse a string. Your goal is to implement a highly efficient string reversal method that balances time and space complexities. Given the multiple approaches to this task, you need to write a function that confirms your understanding of algorithm efficiency, especially focused on iterative and recursive patterns. Task Implement a function `optimized_reverse` that takes a single string `s` as input and returns the reversed string. The solution should be efficient both in terms of time and space complexities. Input * A single string `s` with length (1 leq |s| leq 10^6). Output * A single string which is the reversed version of `s`. Constraints * The solution should handle very large strings efficiently. * Avoid using Python\'s slicing or built-in `reversed` functions directly. Performance Requirements * Time Complexity: (O(n)) * Space Complexity: (O(1)) Example ```python # Example use case: s = \\"hello\\" print(optimized_reverse(s)) # Output: \\"olleh\\" ``` Implementation Your implementation should take into account potential edge cases and ensure that the function completes within time limits for all possible input sizes.","solution":"def optimized_reverse(s): Returns the reversed string of s. n = len(s) # Convert string to list to modify it in-place str_list = list(s) for i in range(n // 2): str_list[i], str_list[n - i - 1] = str_list[n - i - 1], str_list[i] # Convert list back to string return \'\'.join(str_list)"},{"question":"Question: Two Sum II - Input Array Is Sorted You are given an array of integers `numbers` that is sorted in non-decreasing order, and an integer `target`. Write a function to find two numbers such that they add up to a specific target. The function two_sum should return the indices of the two numbers (1-indexed) as an array of integers `[index1, index2]` where `1 <= index1 < index2 <= numbers.length`. The input array may contain one or more solutions, but you need to return only one such pair. Input/Output - **Input**: - `numbers`: A list of integers sorted in non-decreasing order. (e.g., `[2, 7, 11, 15]`) - `target`: An integer representing the target sum. (e.g., `9`) - **Output**: - A list of two integers representing the 1-indexed positions of the two integers within the list that add up to the target. (e.g., `[1, 2]`) Constraints: - The length of `numbers` will be at most `10^4`. - Each input would have exactly one solution, and you may not use the same element twice. - The array `numbers` is sorted in non-decreasing order. - The input array will contain distinct integers. Example: ```plaintext Input: numbers = [2, 7, 11, 15], target = 9 Output: [1, 2] Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2 Input: numbers = [2, 3, 4], target = 6 Output: [1, 3] Explanation: The sum of 2 and 4 is 6. Therefore, index1 = 1, index2 = 3 ``` Requirements: - Your solution must have a time complexity of O(n) and a space complexity of O(1). - You must handle edge cases such as arrays with negative numbers and zeroes effectively. Hint: - Consider using two pointers to solve this problem since the array is sorted. Implement your function in Python: ```python def two_sum(numbers, target): # Your code here pass ```","solution":"def two_sum(numbers, target): Given a sorted array of integers and a target sum, this function returns the 1-indexed positions of two numbers that add up to the target. :param numbers: List of integers sorted in non-decreasing order. :param target: Integer representing the target sum. :return: List with two 1-indexed integers. left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1 return [] # This line should not be reached since exactly one solution is guaranteed."},{"question":"Union-Find Algorithm Implementation and Island Counting **Scenario**: You are working as a software engineer tasked with processing a 2D grid representing a map. Each cell of the grid can be either water (0) or land (1). You need to keep track of the number of islands at each step after adding lands. An island is formed by horizontally or vertically connecting adjacent lands. Your task is to implement a function `num_islands` that takes a list of positions where land is added and returns the number of islands after each addLand operation. **Function Signature**: ```python def num_islands(positions: List[List[int]]) -> List[int]: pass ``` **Input**: - `positions`: a list of lists where each list has two integers [r, c] representing the row and column index respectively where a land is added. **Output**: - Return a list of integers, where each integer represents the number of islands after each addLand operation. **Constraints**: - Assume the grid is infinite, i.e., you only need to handle the positions provided. - Each position will be unique and will not repeat. **Performance Requirements**: - The implementation should efficiently handle union and find operations, ideally using path compression and union by rank/size. # Example ```python positions = [[0, 0], [0, 1], [1, 2], [2, 1]] print(num_islands(positions)) # Output: [1, 1, 2, 3] ``` **Note**: Initially, the grid is filled with water. Each position in the `positions` list corresponds to an addLand operation. After each operation, evaluate the number of islands in the grid. # Hints - You may want to implement a Union-Find (or Disjoint Set) data structure to efficiently manage the connectivity of the lands being added.","solution":"from typing import List class UnionFind: def __init__(self): self.parent = {} self.rank = {} self.count = 0 def add(self, x): if x not in self.parent: self.parent[x] = x self.rank[x] = 0 self.count += 1 def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 def num_islands(positions: List[List[int]]) -> List[int]: uf = UnionFind() island_counts = [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for pos in positions: r, c = pos current_pos = (r, c) uf.add(current_pos) for dr, dc in directions: nr, nc = r + dr, c + dc neighbor_pos = (nr, nc) if neighbor_pos in uf.parent: uf.union(current_pos, neighbor_pos) island_counts.append(uf.count) return island_counts"},{"question":"# Comb Sort Function Implementation **Objective:** Implement the Comb Sort algorithm to sort an array of integers. Demonstrate understanding of gap reduction and swapping mechanism intrinsic to Comb Sort. **Function Signature:** ```python def comb_sort(arr: List[int]) -> List[int]: pass ``` **Input:** - `arr` (List[int]): A list of integers that needs to be sorted. **Output:** - Returns a list of integers sorted in ascending order. **Constraints:** - The array size `n` can be up to 10^5. - The integers in the array can be positive, negative, or zero. **Performance Requirements:** - The implementation should aim for O(N log N) in the best case and should not exceed O(N^2) in the worst case. **Example:** ```python assert comb_sort([34, 7, 23, 32, 5, 62]) == [5, 7, 23, 32, 34, 62] assert comb_sort([10, -1, 0, 5, 8, 12]) == [-1, 0, 5, 8, 10, 12] assert comb_sort([1, 4, 3, 2]) == [1, 2, 3, 4] ``` # Additional Notes: - Consider edge cases such as already sorted arrays, arrays with a single element, or arrays containing repeated elements. - Use a shirking factor of 1.3 as standard. Experimenting with other factors may be permitted to study their impact on the performance.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Sort an array of integers using the Comb Sort algorithm. def get_next_gap(gap): # Shrink gap by shrink factor of 1.3 gap = int(gap / 1.3) if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Binary Search Insertion Index **Problem Statement**: Given a sorted array of integers `arr` and a target integer `target`, your task is to write a function `find_insertion_index` that finds and returns the index where the target should be inserted to maintain the array\'s sorted order. If the target is already present in the array, return the index of its first occurrence. **Function Signature**: ```python def find_insertion_index(arr: list[int], target: int) -> int: ``` **Input**: * `arr`: A list of integers, where the list is sorted in ascending order. The length of the list is between 0 and 10^5. * `target`: An integer, the value to be inserted. The value of target can be between -10^6 and 10^6. **Output**: * Return an integer representing the index at which the target should be inserted. **Constraints**: * The array must remain sorted after insertion. * Try to achieve the solution with O(log n) time complexity. **Example**: ```python assert find_insertion_index([1, 3, 5, 6], 5) == 2 assert find_insertion_index([1, 3, 5, 6], 2) == 1 assert find_insertion_index([], 2) == 0 assert find_insertion_index([1, 3, 5, 6], 7) == 4 assert find_insertion_index([1, 3, 5, 6], 0) == 0 ``` **Explanation**: 1. In the first example, `target` (5) is already present in the array at index 2. 2. In the second example, `target` (2) does not exist in the array; it should be inserted at index 1 to maintain the sorted order. 3. The third example handles an empty array, where `target` can only be inserted at index 0. 4. The fourth example shows `target` (7) is not in the array and should be placed at the end. 5. Finally, the fifth example places `target` (0) at the beginning. **Hint**: Use the binary search approach to find the potential insertion position efficiently.","solution":"def find_insertion_index(arr: list[int], target: int) -> int: This function uses binary search to find the index where the target should be inserted in order to maintain the array\'s sorted order. left, right = 0, len(arr) while left < right: mid = (left + right) // 2 if arr[mid] < target: left = mid + 1 else: right = mid return left"},{"question":"# Question: Implementation of Bogo Sort for Small Arrays You are tasked with implementing an extremely inefficient sorting algorithm known as Bogo Sort, using the principles of random shuffling and the brute-force nature of checking array order. This question is designed to test your understanding of algorithm inefficiencies and handling unconventional sorting approaches. Scenario A whimsical professor in an algorithms class decides to demonstrate one of the most inefficient sorting techniques, Bogo Sort, also known as \'stupid sort\'. As a student, you are required to implement this sort. Despite knowing its inefficiency, this will help in understanding the importance of algorithm efficiency in practical scenarios. Function Details You need to implement a function `bogo_sort(arr: List[int], simulation: bool=False) -> List[int]` that sorts a list of integers using the Bogo Sort algorithm. Input * `arr`: A list of integers to be sorted. (1 <= len(arr) <= 10) * `simulation`: A boolean that, if set to True, outputs the intermediate steps of the sorting process (default is False). Output * Return the sorted list of integers. Constraints * You can rely on Python\'s `random.shuffle` for shuffling the array. * Since this algorithm is impractical for large arrays, the input list length will not exceed 10. Performance Requirements There are no specific performance requirements due to the intentionally inefficient nature of Bogo Sort. Understanding and successfully demonstrating the use of the algorithm is the goal. Example ```python # Example usage: arr = [3, 1, 2] sorted_arr = bogo_sort(arr, simulation=True) print(sorted_arr) # Output: [1, 2, 3] ``` Ensure that your implementation correctly sorts the array and, if the `simulation` parameter is true, prints each shuffle step.","solution":"import random def bogo_sort(arr, simulation=False): Sorts the array using Bogo Sort algorithm. Parameters: arr (List[int]): List of integers to sort. simulation (bool): If True, prints intermediate steps. Returns: List[int]: Sorted list of integers. def is_sorted(arr): for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True attempts = 0 while not is_sorted(arr): if simulation: print(f\\"Attempt {attempts}: {arr}\\") random.shuffle(arr) attempts += 1 if simulation: print(f\\"Sorted after {attempts} attempts: {arr}\\") return arr"},{"question":"# Polynomial Equivalence Checking Objective Given the implemented `Polynomial` class, you are required to write a function to determine if two polynomial expressions are equivalent after performing given substitutions for their variables. Task Implement the function `are_polynomials_equivalent(poly1: Polynomial, poly2: Polynomial, substitutions: Dict[int, Union[int, float, Fraction]]) -> bool`. This function should evaluate the two polynomials with the given substitutions and return `True` if they are equivalent, otherwise, return `False`. Input and Output * **Input**: * `poly1` and `poly2`: Two instances of the `Polynomial` class. * `substitutions`: A dictionary where the keys are variable indices, and the values are the numbers to substitute for those variables. The substitutions can be integers, floats, or fractions. * **Output**: * A boolean value `True` if the evaluated polynomials are equivalent, `False` otherwise. Constraints 1. The variable indices in the `substitutions` dictionary match the variables used in the polynomials. 2. Substitute all necessary variables required by the polynomials in the `substitutions` dictionary. 3. Perform exact arithmetic using the `Fraction` class to avoid floating-point precision issues. Performance Requirements Your solution should efficiently handle polynomials with up to 100 terms and 10 variables. The substitution process should be optimized to minimize redundant computations. Example ```python from fractions import Fraction # Example Polynomials: # poly1 = 2a_1 + a_2^2 poly1 = Polynomial([Monomial({1: 1}, 2), Monomial({2: 2}, 1)]) # poly2 = 3a_1 + (a_2)^2 - a_1 poly2 = Polynomial([Monomial({1: 1}, 3), Monomial({2: 2}, 1), Monomial({1: 1}, -1)]) # Substitutions: a_1 = 1, a_2 = 2 substitutions = {1: Fraction(1, 1), 2: Fraction(2, 1)} # Function should return True because both polynomials evaluate to 6 when a_1 = 1 and a_2 = 2 assert are_polynomials_equivalent(poly1, poly2, substitutions) == True ```","solution":"from fractions import Fraction from typing import Dict, Union class Monomial: def __init__(self, variables, coefficient): Monomial represents a single term in a polynomial. :param variables: A dictionary where keys are variable indices and values are their exponents. :param coefficient: The coefficient of the monomial. self.variables = variables # e.g., {1: 2, 3: 1} for a_1^2 * a_3 self.coefficient = Fraction(coefficient) def evaluate(self, substitutions): Evaluate the monomial given variable substitutions. :param substitutions: A dictionary where keys are variable indices and values are the numbers to substitute. :return: The evaluated value of the monomial after substitution. result = self.coefficient for var, exp in self.variables.items(): result *= substitutions[var] ** exp return result class Polynomial: def __init__(self, terms): Polynomial represents a sum of multiple monomials. :param terms: A list of Monomial objects. self.terms = terms def evaluate(self, substitutions): Evaluate the polynomial given variable substitutions. :param substitutions: A dictionary where keys are variable indices and values are the numbers to substitute. :return: The evaluated value of the polynomial after substitution. return sum(term.evaluate(substitutions) for term in self.terms) def are_polynomials_equivalent(poly1, poly2, substitutions): Determines if two polynomial expressions are equivalent after performing given substitutions for their variables. :param poly1: Polynomial object representing the first polynomial. :param poly2: Polynomial object representing the second polynomial. :param substitutions: A dictionary where keys are variable indices, and values are the numbers to substitute. The values can be integers, floats, or fractions. :return: True if the evaluated polynomials are equivalent, otherwise, False. # Evaluate each polynomial with the given substitutions value1 = poly1.evaluate(substitutions) value2 = poly2.evaluate(substitutions) return value1 == value2"},{"question":"Given a sorted list of integers without duplicates, write a function `summarize_ranges` that returns a summary of its ranges. A range is defined as a sequence of numbers with consecutive differences of exactly 1. Each range should be represented as a string in the format \\"start-end\\" if it contains more than one number, otherwise simply \\"start\\". Input * A sorted list of integers without duplicates. * The list can have any length, including zero. Output * A list of strings, where each string represents a range in the input list as described. Constraints * The length of the input list does not exceed 10^5. * Each element in the list is an integer between -10^6 and 10^6. Example * Input: `[0, 1, 2, 4, 5, 7]` * Output: `[\\"0-2\\", \\"4-5\\", \\"7\\"]` * Input: `[1, 3, 5, 7]` * Output: `[\\"1\\", \\"3\\", \\"5\\", \\"7\\"]` * Input: `[-5, -4, -3, 0, 1, 2, 5, 10, 11, 12]` * Output: `[\\"-5--3\\", \\"0-2\\", \\"5\\", \\"10-12\\"]` Function Signature ```python from typing import List def summarize_ranges(array: List[int]) -> List[str]: pass ``` Write the function `summarize_ranges(array: List[int]) -> List[str]` to solve the problem. Additional Constraints * Ensure your solution is optimized for large input sizes. * Handle all possible edge cases, including but not limited to empty lists and lists with single elements.","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: if not array: return [] result = [] start = array[0] end = array[0] for i in range(1, len(array)): if array[i] == end + 1: end = array[i] else: if start == end: result.append(f\\"{start}\\") else: result.append(f\\"{start}-{end}\\") start = array[i] end = array[i] if start == end: result.append(f\\"{start}\\") else: result.append(f\\"{start}-{end}\\") return result"},{"question":"# Stooge Sort Implementation Challenge **Scenario**: You are required to implement the Stooge Sort algorithm, a recursive sorting method characterized by its peculiar recursive steps. Stooge Sort, typically used for academic demonstrations, rearranges elements such that every step guarantees ordering within specific segments of the array. You are given an unsorted array with up to (10^3) elements where every element is an integer between (-10^4 ldots 10^4). Your task is to write the Stooge Sort function that rearranges the array in-place, ensuring it is sorted in ascending order. **Function Signature**: ```python def stoogesort(arr: list[int], l: int, h: int) -> None: pass ``` **Input Format:** - `arr`: List of integers to be sorted. - `l`: The starting index of the list `arr`. - `h`: The ending index of the list `arr`. **Output Format:** - The function modifies the list in-place, hence it returns `None`. **Constraints:** - (1 ≤ text{len(arr)} ≤ 1000) - (-10^4 ≤ text{arr[i]} ≤ 10^4) **Example Input:** ```python arr = [2, 4, 5, 3, 1] stoogesort(arr, 0, len(arr)-1) ``` **Example Output:** ```python # Now arr = [1, 2, 3, 4, 5] ``` **Notes:** - The main function is provided for manual testing as follows: ```python if __name__ == \\"__main__\\": arr = [5, 3, 2, 4, 1] stoogesort(arr, 0, len(arr) - 1) print(arr) # Output should be [1, 2, 3, 4, 5] ``` Complete the implementation of the Stooge Sort function to ensure accurate and efficient sorting according to the given constraints.","solution":"def stoogesort(arr: list[int], l: int, h: int) -> None: if l >= h: return # If the element at the start is greater than the element at the end, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than 2 elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 # Recur for first 2/3 elements stoogesort(arr, l, h - t) # Recur for last 2/3 elements stoogesort(arr, l + t, h) # Recur for first 2/3 elements again to confirm order stoogesort(arr, l, h - t)"},{"question":"# Question Title: Implement Optimized Selection Sort with Early Exit You are tasked with implementing an optimized version of the Selection Sort algorithm that includes an early exit mechanism. While the original Selection Sort has a time complexity of O(n^2) regardless of the array\'s initial order, your version should minimize unnecessary iterations when the array is already sorted or becomes sorted during the execution. **Function Signature**: ```python def optimized_selection_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` **Input**: 1. **arr** (List[int]): The list of integers to be sorted. 2. **simulation** (bool, optional): If set to `True`, print the array at each iteration step for visualization purposes. Defaults to `False`. **Output**: 1. Return the sorted list of integers. **Constraints**: - Do not use extra space proportionate to the input size. - Ensure the function handles edge cases gracefully (e.g., empty array, single element array, already sorted array). - If the array is already sorted at any iteration, exit early from further unnecessary iterations. **Example**: ```python assert optimized_selection_sort([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64] assert optimized_selection_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] assert optimized_selection_sort([]) == [] assert optimized_selection_sort([42]) == [42] assert optimized_selection_sort([1, 2, 3, 4, 5], simulation=True) == [1, 2, 3, 4, 5] ``` In this problem, demonstrate comprehension by handling various edge cases, optimizing performance through early exit, and ensuring stability by carefully managing array element swaps.","solution":"from typing import List def optimized_selection_sort(arr: List[int], simulation: bool = False) -> List[int]: n = len(arr) if n < 2: return arr for i in range(n): min_idx = i already_sorted = True for j in range(i + 1, n): if arr[j] < arr[min_idx]: min_idx = j if arr[j] < arr[j - 1]: already_sorted = False arr[i], arr[min_idx] = arr[min_idx], arr[i] if simulation: print(f\\"Iteration {i+1}: {arr}\\") if already_sorted: break return arr"},{"question":"Problem Statement In a binary search tree, every node has the following properties: * The left subtree of a node contains only nodes with keys less than the node\'s key. * The right subtree of a node contains only nodes with keys greater than the node\'s key. * Both the left and right subtrees must also be binary search trees. You are given the root of a BST and a target node. Your task is to write a function `predecessor` that finds the in-order predecessor of the given node in the BST. # Function Signature ```python def predecessor(root: TreeNode, node: TreeNode) -> Optional[TreeNode]: ... ``` # Input * `root` : TreeNode - The root of the binary search tree. * `node` : TreeNode - The node whose in-order predecessor you need to find. # Output * Returns the in-order predecessor `TreeNode` of the given node. If no predecessor exists, return `None`. # Constraints * The tree will have at least one node. * All node values are unique. # Example Consider the BST: ``` 20 / 10 30 / 25 ``` * If `node` is 25, `predecessor` should return 20. * If `node` is 10, `predecessor` should return None. **Note**: For a balanced BST, the time complexity should average O(log n), but in the worst case (skewed tree), it can be O(n). # Scenario In a company\'s internal database structured as a BST, finding the in-order predecessor helps in quickly locating the previous record in an ordered manner for tasks like generating reports or ensuring data consistency before adding new entries. Write the implementation of the function considering all edge cases and performance bottlenecks for optimal performance.","solution":"class TreeNode: def __init__(self, key, left=None, right=None): self.key = key self.left = left self.right = right def predecessor(root, node): Find the in-order predecessor of a given node in a BST. Parameters: root (TreeNode): The root of the BST. node (TreeNode): The target node whose in-order predecessor is to be found. Returns: TreeNode: The in-order predecessor of the given node, or None if no predecessor exists. if node.left: # The predecessor is the rightmost node of the left subtree. current = node.left while current.right: current = current.right return current # If no left subtree, the predecessor might be an ancestor. predecessor = None current = root while current: if node.key > current.key: predecessor = current current = current.right elif node.key < current.key: current = current.left else: break return predecessor"},{"question":"# Coding Challenge: Circular Array Queue Implementation You are to implement a Queue ADT using a circular array to enhance the performance of the array-based queue by preventing the need to shift elements or expand the array frequently. # Detailed Requirements Implement the CircularArrayQueue class with the following methods: - `__init__(self, capacity=10)`: Initialize the queue with an optional capacity argument. By default, the capacity should be 10. - `enqueue(self, value)`: Add a value to the rear of the queue, wrap around if necessary. - `dequeue(self)`: Remove and return the front item from the queue. Raise an IndexError if the queue is empty. - `peek(self)`: Return the front item without removing it. Raise an IndexError if the queue is empty. - `is_empty(self)`: Return True if the queue is empty, else False. - `__len__(self)`: Return the number of items in the queue. - `__iter__(self)`: An iterator that allows iteration over the queue elements from front to rear. # Input and Output Formats * Inputs: - On creation, the queue can optionally take an integer `capacity`. - Each method operates based on the standard queue conditions and returns the respective values or raises errors. * Outputs: - `enqueue` adds an item to the queue with no return. - `dequeue` and `peek` return the respective element or raise errors. # Constraints * The initial capacity is fixed, and your queue should manage the index wrapping around. * Consider edge cases where the queue can become full or empty. * Optimize for both performance and memory usage efficiently. # Examples **Example 1**: ```python queue = CircularArrayQueue(3) queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) print(queue.dequeue()) # Output: 1 queue.enqueue(4) print(queue.peek()) # Output: 2 print(len(queue)) # Output: 3 for elem in queue: print(elem) ``` The above code should print: ```python 2 3 4 ``` # Implementation Template: ```python class CircularArrayQueue: def __init__(self, capacity=10): # Initiate required variables def enqueue(self, value): # Enqueue operation with handling wrap around def dequeue(self): # Dequeue operation with error handling def peek(self): # Peek operation with error handling def is_empty(self): # Return if the queue is empty def __len__(self): # Return the number of items in the queue def __iter__(self): # Implement iterator for queue elements ```","solution":"class CircularArrayQueue: def __init__(self, capacity=10): self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = 0 self.size = 0 def enqueue(self, value): if self.size == self.capacity: raise IndexError(\\"Queue is full\\") self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def is_empty(self): return self.size == 0 def __len__(self): return self.size def __iter__(self): idx = self.front for _ in range(self.size): yield self.queue[idx] idx = (idx + 1) % self.capacity"},{"question":"**Context**: You are given a task to validate and process large data sets containing various integer values. For certain operations, knowing the number of digits in these integers is crucial for formatting and validation purposes. **Problem Statement**: Write a Python function `digit_count` that computes the number of digits in a given integer. Your function should handle both positive and negative integers correctly. The number zero should be treated as having one digit. Input: - An integer `n` where `-10^9 ≤ n ≤ 10^9`. Output: - An integer representing the number of digits in `n`. Function Signature: ```python def digit_count(n: int) -> int: ``` Constraints: - You must use a computational approach that runs in constant time O(1). Example: ```python assert digit_count(0) == 1 assert digit_count(123) == 3 assert digit_count(-98765) == 5 ``` Additional Notes: - You should avoid using iterative methods to count digits manually by looping through each digit or converting the number to a string. - Your solution should handle edge cases such as zero and negative numbers effectively.","solution":"def digit_count(n: int) -> int: Returns the number of digits in the given integer. Handles positive, negative numbers, and zero correctly. if n == 0: return 1 # We use absolute value and math logarithm to calculate digit count n = abs(n) return len(str(n))"},{"question":"# Binary Tree Height Calculation You are given a binary tree and your task is to write a function that calculates the height of this tree. The height of a binary tree is defined as the number of levels it contains. An empty tree has a height of 0, whereas a tree with just one node has a height of 1. Function Signature ```python def height(root: \'Node\') -> int: ``` # Input - `root`: The root node of the binary tree. The class definition for the Node can be assumed to have `left` and `right` attributes. `left` and `right` are pointers to the respective children of the node. # Output - An integer representing the height of the tree. # Constraints - The tree can be empty. - Nodes will have integer values. - Number of nodes (n) can be up to 10^5. - Height of the tree (h) can be up to n for skewed trees. # Example Example 1: ```plaintext 1 / 2 3 / 4 5 tree - height = 3 ``` Given the above tree, your function should return 3. Example 2: ```plaintext 9 / 6 12 / / 3 8 10 15 / 7 18 tree - height = 4 ``` # Unit Tests You can use the below tree structure and implement unit tests to validate your solution. ```python import unittest class TestSuite(unittest.TestCase): def setUp(self): self.tree = bst() self.tree.insert(9) self.tree.insert(6) self.tree.insert(12) self.tree.insert(3) self.tree.insert(8) self.tree.insert(10) self.tree.insert(15) self.tree.insert(7) self.tree.insert(18) def test_height(self): self.assertEqual(4, height(self.tree.root)) if __name__ == \'__main__\': unittest.main() ``` # Implementation Note: Use recursion to determine the maximum depth of left and right sub-trees and then calculate the height of the input tree as `1 + max(height(left_subtree), height(right_subtree))`.","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None def height(root: \'Node\') -> int: Calculates the height of a binary tree. :param root: The root node of the binary tree. :return: The height of the tree. if root is None: return 0 else: left_height = height(root.left) right_height = height(root.right) return max(left_height, right_height) + 1"},{"question":"You are working on a mapping application where you need to find the k closest points of interest to a user\'s current location. To implement this feature, your task is to write a function that, given a list of points on a 2D plane, determines the k points closest to the user\'s location (origin). # Function Signature ```python def k_closest(points: List[Tuple[int, int]], k: int, origin: Tuple[int, int] = (0, 0)) -> List[Tuple[int, int]]: ``` # Input * `points` (List[Tuple[int, int]]): A list of tuples representing the points on a 2D plane. * `k` (int): The number of closest points to find. * `origin` (Tuple[int, int], optional): The reference point from which distances are calculated. Defaults to (0, 0). # Output * (List[Tuple[int, int]]): A list of tuples representing the k closest points to the origin. # Constraints * The number of points will be in the range [1, 10^4]. * K will be between 1 and the number of points. * The coordinates of each point will be in the range [-10^4, 10^4]. # Requirements * Your function must have a time complexity of O(n log k) and space complexity of O(k). # Example ```python points = [(1, 3), (-2, 2), (5, 8), (0, 1)] k = 2 origin = (0, 0) print(k_closest(points, k, origin)) # Output: [(-2, 2), (0, 1)] ``` # Explanation For input points `[(1, 3), (-2, 2), (5, 8), (0, 1)]` and `k = 2`: * The distances from origin (0, 0) are `[10, 8, 89, 1]` respectively. * The two closest points to the origin are `(-2, 2)` and `(0, 1)`. Write a function `k_closest` that implements the above logic.","solution":"import heapq from typing import List, Tuple def k_closest(points: List[Tuple[int, int]], k: int, origin: Tuple[int, int] = (0, 0)) -> List[Tuple[int, int]]: Returns the k points closest to the origin. Args: points (List[Tuple[int, int]]): A list of points on the 2D plane. k (int): The number of closest points to find. origin (Tuple[int, int], optional): The reference point for calculating distances. Defaults to (0, 0). Returns: List[Tuple[int, int]]: A list of the k closest points to the origin. # Custom comparator function for the max-heap based on negative distance to the origin def distance(p): return -(p[0] - origin[0])**2 - (p[1] - origin[1])**2 # Use a max-heap of size k max_heap = [] for point in points: dist = distance(point) if len(max_heap) < k: heapq.heappush(max_heap, (dist, point)) else: heapq.heappushpop(max_heap, (dist, point)) # Extract the points from the max-heap return [point for _, point in max_heap]"},{"question":"# Constraint-Based Frequency Control You are given a list of integers and a number ( N ). Your task is to implement a function that returns a new list that contains each number from the original list at most ( N ) times without reordering any elements. Function Signature ```python def limit_frequency(lst: List[int], N: int) -> List[int]: pass ``` Input - `lst`: A list of integers `lst[]` (( 1 leq |lst| leq 10^6 )). - `N`: An integer `N` ((1 leq N leq 10^3)`. Output - Return a list of integers where each integer appears at most ( N ) times. Constraints - The elements in the list should appear in the order they first appear in the input list. - The function should be optimized for large input sizes. Example ```python # Example 1: input_list = [1, 2, 3, 1, 2, 1, 2, 3] N = 2 limit_frequency(input_list, N) # Output: [1, 2, 3, 1, 2, 3] # Example 2: input_list = [20, 37, 20, 21] N = 1 limit_frequency(input_list, N) # Output: [20, 37, 21] ``` Additional Notes - Your implementation should consider edge cases such as an empty list or lists with large numbers. - Avoid using the list `count` method in your solution to ensure it operates within acceptable time complexity limits.","solution":"from typing import List def limit_frequency(lst: List[int], N: int) -> List[int]: frequency = {} result = [] for num in lst: if num not in frequency: frequency[num] = 0 if frequency[num] < N: result.append(num) frequency[num] += 1 return result"},{"question":"You are given a list of integers and an integer N. Your task is to implement a function `delete_nth_occurrence` that will return a new list in which no integer appears more than N times. The order of elements in the new list should be the same as their order in the input list. # Function Signature ```python def delete_nth_occurrence(lst: list, N: int) -> list: ``` # Input - `lst`: A list of integers. (0 <= len(lst) <= 10^6) - `N`: An integer (1 <= N <= 10^6). The maximum number of occurrences for any integer in the returned list. # Output - A new list of integers, where no integer appears more than N times, preserving order from the original list. # Constraints - Time complexity should be O(n) where n is the length of the input list. - Space complexity should be O(n) including the output list. # Example ```python # Example 1 lst = [1, 2, 3, 1, 2, 1, 2, 3] N = 2 # Output: [1, 2, 3, 1, 2, 3] # Example 2 lst = [20, 37, 20, 21] N = 1 # Output: [20, 37, 21] # Example 3 lst = [] N = 5 # Output: [] # Example 4 lst = [1, 1, 1, 1] N = 2 # Output: [1, 1] ``` # Notes - You should ensure that your solution is efficient and works within the given constraints. - Consider and handle edge cases appropriately. Provide your implementation below: ```python def delete_nth_occurrence(lst: list, N: int) -> list: # Your implementation here ```","solution":"def delete_nth_occurrence(lst: list, N: int) -> list: from collections import defaultdict count = defaultdict(int) result = [] for num in lst: if count[num] < N: result.append(num) count[num] += 1 return result"},{"question":"# Binary Search Tree with Additional Functionalities You are required to extend the Binary Search Tree (BST) implementation based on the provided code snippet. The BST class already supports insertion, search, size computation, and traversal methods (preorder, inorder, postorder). For this task, you will implement two additional functionalities: 1. **Find Minimum and Maximum Element** 2. **Compute the Depth of the Tree** Function Specifications 1. **find_min(self) -> int:** * Finds and returns the minimum element in the BST. * Returns `None` if the tree is empty. 2. **find_max(self) -> int:** * Finds and returns the maximum element in the BST. * Returns `None` if the tree is empty. 3. **depth(self) -> int:** * Calculates and returns the depth (height) of the BST. * Depth of an empty tree is 0. * Depth of a tree with a single node is 1. Input & Output * **find_min()**: * Input: No input. * Output: Integer representing the minimum value in the BST, or `None`. * **find_max()**: * Input: No input. * Output: Integer representing the maximum value in the BST, or `None`. * **depth()**: * Input: No input. * Output: Integer representing the depth of the BST. Constraints * All BST operations should adhere to their average time complexity of O(log N) where possible. * The BST should maintain its properties during these operations. * Avoid using additional data structures to store tree elements. Example Usage Consider the following tree: ``` 10 / 4 15 / / 2 6 12 20 14 30 ``` 1. `find_min()` -> returns `2` 2. `find_max()` -> returns `30` 3. `depth()` -> returns `4` (path: 10 -> 15 -> 20 -> 30) Testing Implement unit tests to verify the correctness of the extended BST functionalities: 1. Insert nodes into the BST. 2. Verify `find_min()` and `find_max()` return correct values. 3. Verify `depth()` calculates the correct depth of the BST.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.key: if node.left is None: node.left = TreeNode(key) else: self._insert(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert(node.right, key) def find_min(self): if self.root is None: return None return self._find_min(self.root).key def _find_min(self, node): current = node while current.left is not None: current = current.left return current def find_max(self): if self.root is None: return None return self._find_max(self.root).key def _find_max(self, node): current = node while current.right is not None: current = current.right return current def depth(self): return self._depth(self.root) def _depth(self, node): if node is None: return 0 left_depth = self._depth(node.left) right_depth = self._depth(node.right) return max(left_depth, right_depth) + 1"},{"question":"# Context Heap Sort is an efficient comparison-based algorithm that sorts an array by leveraging a heap data structure. In this task, you are required to implement a max heap sort algorithm and consider edge cases properly. # Task You are given the following Python function signatures: ```python def max_heap_sort(arr: List[int], simulation: bool=False) -> List[int]: pass def max_heapify(arr: List[int], end: int, simulation: bool, iteration: int) -> int: pass ``` # Requirements 1. Implement the `max_heap_sort` function which sorts an array in ascending order using a max heap. 2. Implement the `max_heapify` helper function which helps in maintaining the max heap property. # Input * `arr` (List[int]): A list of integers to sort. * `simulation` (bool): A flag to print the array state at each iteration of heapify if set to True. # Output * Returns `List[int]`: The sorted list. # Constraints * `0 <= len(arr) <= 10^5` * `-10^9 <= arr[i] <= 10^9` # Example ```python from typing import List def max_heap_sort(arr: List[int], simulation: bool=False) -> List[int]: # Your implementation here def max_heapify(arr: List[int], end: int, simulation: bool, iteration: int) -> int: # Your implementation here # Example use case arr = [3, 1, 5, 2, 4] sorted_arr = max_heap_sort(arr, simulation=True) print(sorted_arr) # Output should be [1, 2, 3, 4, 5] ``` # Notes 1. If the `simulation` flag is set to `True`, print the array at each iteration step of the heapify process. 2. Ensure the algorithm works efficiently even for large inputs within the given constraints. 3. Consider edge cases including empty arrays and arrays with duplicate elements.","solution":"from typing import List def max_heap_sort(arr: List[int], simulation: bool=False) -> List[int]: def heapify(end: int, i: int, iteration: int): left = 2 * i + 1 right = 2 * i + 2 max_index = i if left < end and arr[left] > arr[max_index]: max_index = left if right < end and arr[right] > arr[max_index]: max_index = right if max_index != i: arr[i], arr[max_index] = arr[max_index], arr[i] if simulation: print(f\\"Iteration {iteration}: {arr}\\") heapify(end, max_index, iteration + 1) n = len(arr) # Build max heap for i in range(n // 2 - 1, -1, -1): heapify(n, i, 1) # Extract elements from heap for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(i, 0, 1) return arr"},{"question":"# Objective Implement a function that converts a given file path (that can be a relative path or a path containing user directory symbols) to an absolute path. Your implementation should handle various edge cases and optimize for typical file path inputs. # Input Format - A single string `file_path` which represents the file path. This can be a relative path, a path with user directory symbols (e.g., `~`), or an already absolute path. # Output Format - A single string which is the absolute path corresponding to the input `file_path`. # Constraints - The input string can contain multiple components separated by the OS-specific path separator (`/` on Unix-based systems, `` on Windows). - The input string can be empty or contain only whitespace characters. - The length of the input string will not exceed 1024 characters. # Performance Requirements - The function should handle up to 1000 such conversions efficiently in a single execution. # Example ```python # Given the user\'s home directory is /home/user Input: \'~/documents/report.docx\' Output: \'/home/user/documents/report.docx\' Input: \'./project/notes.txt\' Output: \'/current/working/directory/project/notes.txt\' ``` # Function Signature ```python def convert_to_absolute_path(file_path: str) -> str: pass ``` # Hints 1. Use standard library functions to expand user directories and relative paths. 2. Consider edge cases such as empty strings and paths that are already absolute.","solution":"import os def convert_to_absolute_path(file_path: str) -> str: Converts the given file path to an absolute path. Args: - file_path (str): A string representing the file path, which can be relative, include user directory symbols, or be an already absolute path. Returns: - str: An absolute path corresponding to the input file path. # Trim any surrounding whitespace from the input file_path = file_path.strip() # Expand any user directory symbol (~) expanded_path = os.path.expanduser(file_path) # Convert to absolute path absolute_path = os.path.abspath(expanded_path) return absolute_path"},{"question":"As the chief software engineer at a leading tech company, you are tasked with developing a text search feature for your company\'s new text editor. Users should be able to quickly find the first occurrence of a word within a document using a highly efficient method. # Task: Implement the function `rabin_karp(word, text)` which searches for a word within a given text using the Rabin-Karp algorithm. Your implementation should handle the initial hashing, updating the hash in constant time, and comparing the hash values for potential matches. # Function Signature: ```python def rabin_karp(word: str, text: str) -> int: pass ``` # Input: - `word` (str): The word to search for. It is guaranteed to contain only lowercase alphabets and will have a length between 1 and 10^5. - `text` (str): The text within which to search. It is guaranteed to contain only lowercase alphabets and will have a length between 1 and 10^6. # Output: - Returns the starting index (0-based) of the first occurrence of `word` in `text`. If the word is not found, return `-1`. # Constraints: - The function should achieve an average-case time complexity of O(n + m). # Examples: ```python assert rabin_karp(\\"test\\", \\"thisisatesttext\\") == 7 assert rabin_karp(\\"pattern\\", \\"searchingforpatternwithinktext\\") == 13 assert rabin_karp(\\"notfound\\", \\"itisnotinhere\\") == -1 ``` # Considerations: - Think of how you will handle hash collisions. - Ensure that your implementation is efficient to handle the upper limits of input sizes. - Validate for edge cases, such as empty patterns or texts, appropriately.","solution":"def rabin_karp(word, text): Searches for the first occurrence of `word` in `text` using the Rabin-Karp algorithm. Returns the starting index of the first occurrence of `word` in `text`, or -1 if `word` is not found. if not word or not text or len(word) > len(text): return -1 base = 256 prime = 101 word_len = len(word) text_len = len(text) word_hash = 0 text_hash = 0 h = 1 for i in range(word_len - 1): h = (h * base) % prime for i in range(word_len): word_hash = (base * word_hash + ord(word[i])) % prime text_hash = (base * text_hash + ord(text[i])) % prime for i in range(text_len - word_len + 1): if word_hash == text_hash: if text[i:i + word_len] == word: return i if i < text_len - word_len: text_hash = (base * (text_hash - ord(text[i]) * h) + ord(text[i + word_len])) % prime if text_hash < 0: text_hash += prime return -1"},{"question":"# Question: Implement a Deterministic Finite Automaton Context You are designing a simple parser that validates whether given strings match predefined patterns. The parser uses a Deterministic Finite Automaton (DFA) for this purpose. Task Implement a function `DFA` that determines if a string is accepted by a DFA. Function Signature ```python def DFA(transitions: dict, start: int, final: list, string: str) -> bool: ``` Parameters - `transitions` (dict): A dictionary representing the state transitions. Keys are state integers, and values are dictionaries where keys are input characters and values are the next state. - `start` (int): The starting state of the DFA. - `final` (list): A list of acceptable final states. - `string` (str): The input string to be evaluated. Return Value - (bool): Returns `True` if the string is accepted by the DFA, otherwise `False`. Constraints - Each character in the input string `string` must have a defined transition in each state. - The input string can be empty. Examples 1. ```python transitions = {0: {\'a\': 1, \'b\': 0}, 1: {\'a\': 1, \'b\': 2}, 2: {\'a\': 1, \'b\': 0}} start = 0 final = [2] string = \\"abab\\" # DFA recognizes the pattern if it ends in state 2 print(DFA(transitions, start, final, string)) # Output: True ``` 2. ```python transitions = {0: {\'a\': 1}, 1: {\'b\': 2}, 2: {\'c\': 3}, 3: {\'d\': 3}} start = 0 final = [3] string = \\"abcd\\" # DFA recognizes the pattern if it ends in state 3 print(DFA(transitions, start, final, string)) # Output: True ``` 3. ```python transitions = {0: {\'a\': 1}, 1: {\'a\': 0}} start = 0 final = [1] string = \\"aaa\\" # DFA should recognize the pattern ending in state 1 print(DFA(transitions, start, final, string)) # Output: False ``` Notes - Ensure that you handle scenarios where the input string does not contain transitions for some characters or where the string length is zero. - Consider edge cases like no valid transitions for certain characters and different lengths of input strings.","solution":"def DFA(transitions, start, final, string): Determines if a given string is accepted by the DFA. Parameters: - transitions (dict): State transitions of the DFA. - start (int): Starting state. - final (list): List of acceptable final states. - string (str): Input string to be evaluated. Returns: - bool: Returns True if the string is accepted by the DFA, otherwise False. state = start for char in string: if char not in transitions[state]: return False state = transitions[state][char] return state in final"},{"question":"# Flatten Nested Lists You are given a list that may contain other nested lists. Your task is to write a function to flatten this list and all its nested lists into a single list containing all the elements. The order of elements must remain the same as they appear in the original nested structure. Function Signature ```python def flatten_nested_list(nested_list: list) -> list: pass ``` Input * `nested_list`: A list which can contain integers, other nested lists, or any mix of these. The overall length of the list, including all nested lists, will not exceed 10^5 elements. Output * Returns a single, flat list containing all the elements of the input nested list, maintaining the order of appearance. Constraints * The function should handle up to 10^5 elements efficiently. * Strings should be treated as single, non-iterable elements. * Integer elements should also be treated as single, non-iterable elements. Example ```python flatten_nested_list([1, [2, [3, 4], 5], [6, 7]]) # Output: [1, 2, 3, 4, 5, 6, 7] flatten_nested_list([[1, \'abc\'], [3, [\'a\', \'b\', \'c\']]]) # Output: [1, \'abc\', 3, \'a\', \'b\', \'c\'] flatten_nested_list([1, [], [3, []], 5]) # Output: [1, 3, 5] flatten_nested_list([]) # Output: [] ``` Performance * The implementation should efficiently handle nested lists with a large number of elements and deep nesting levels.","solution":"def flatten_nested_list(nested_list: list) -> list: Flattens a nested list into a single list containing all the elements in the input list. Args: nested_list (list): A list which can contain integers, other nested lists, or any mix of these. Returns: list: A single, flat list containing all the elements of the nested input list, maintaining the order of appearance. def flatten(lst): for item in lst: if isinstance(item, list): yield from flatten(item) else: yield item return list(flatten(nested_list))"},{"question":"**Context**: You are given an array of integers which needs to be sorted in non-decreasing order. You have learned about various sorting algorithms and are tasked with implementing the Merge Sort algorithm. **Objective**: Write a Python function `merge_sort(arr)` that takes in a list of integers `arr` and returns the sorted list using the Merge Sort algorithm. You must also implement the necessary helper function `merge(left, right, merged)` as shown in the provided code snippet to handle the merging process. **Function Signature**: ```python def merge_sort(arr): # your code here def merge(left, right, merged): # your code here ``` **Example**: ```python print(merge_sort([38, 27, 43, 3, 9, 82, 10])) # Output: [3, 9, 10, 27, 38, 43, 82] print(merge_sort([])) # Output: [] print(merge_sort([1])) # Output: [1] print(merge_sort([5, 2, 2, 3])) # Output: [2, 2, 3, 5] ``` **Constraints**: - The array can contain duplicate elements. - The input array length can be up to 10^4 elements. - Your implementation must utilize the given merge sort approach and should not use any built-in sort functions. **Hints**: 1. Remember to handle edge cases such as empty lists or lists with one element. 2. Consider how you are dividing the array into halves and merging the results. 3. Be careful with indexing to avoid off-by-one errors during the merge step. **Assessment Criteria**: - Correctness: The function should always produce a correctly sorted array. - Efficiency: The solution should respect the O(n log(n)) time complexity. - Code Quality: The code should be well-organized and readable, with appropriate comments explaining key steps.","solution":"def merge_sort(arr): Sorts an array of integers using the merge sort algorithm. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) sorted_array = [] merge(left_half, right_half, sorted_array) return sorted_array def merge(left, right, merged): Merges two sorted subarrays (left and right) into a single sorted array. i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 while i < len(left): merged.append(left[i]) i += 1 while j < len(right): merged.append(right[j]) j += 1"},{"question":"# Scenario You are developing an application that processes large datasets organized in binary trees. Efficient and correct traversal of these trees is crucial to ensure robustness and correctness of your application. # Task Write a function to perform a postorder traversal of a binary tree. The function should return a list of node values in postorder sequence. # Function Signature ```python def postorder_traversal(root: Node) -> List[int]: pass ``` # Input - `root` (Node): The root of the binary tree. The `Node` class is structured as follows: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output - `List[int]`: A list of integers representing the node values in postorder sequence. # Constraints - `1 <= Number of nodes <= 10^4` - Node values are unique integers. # Example ```python # Given a binary tree: # 1 # / # 2 3 # / # 4 5 root = Node(1, Node(2, Node(4), Node(5)), Node(3)) print(postorder_traversal(root)) # Expected output: [4, 5, 2, 3, 1] ``` # Notes - You are required to implement both an iterative and recursive version. - The recursive implementation must consider the limitations of recursion in deep trees.","solution":"from typing import List class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def postorder_traversal(root: Node) -> List[int]: Returns a list of node values in postorder sequence. if root is None: return [] result = [] def recurse(node): if not node: return recurse(node.left) recurse(node.right) result.append(node.val) recurse(root) return result def postorder_traversal_iterative(root: Node) -> List[int]: Returns a list of node values in postorder sequence using iterative approach. if root is None: return [] stack = [root] result = [] while stack: node = stack.pop() result.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return result[::-1]"},{"question":"# Scenario You\'ve been hired by an analytics company to help them summarize their data more efficiently. You are provided with sorted arrays of integers from various data sources. Your task is to write a function that returns a summary of contiguous ranges within these arrays as described below. # Function Specification Write a function `summarize_ranges(array: List[int]) -> List[str]` where: * **Input**: - `array`: A `List[int]` of sorted integers without duplicates. * **Output**: - A `List[str]` where each element is: - A single integer `i` represented as a string if `i` does not have consecutive neighbors. - A range `i-j` as a string if there exists a contiguous sequence from `i` to `j` in the list. # Example ```python # Example input [0, 1, 2, 4, 5, 7] # Example output [\\"0-2\\", \\"4-5\\", \\"7\\"] ``` # Constraints - The length of the array will be at most `10^4`. - Each element in the array will be within the range `-10^6` to `10^6`. # Important Notes 1. You should handle the edge case for an empty array by returning an empty list. 2. Make sure to address non-contiguous sequences and single elements correctly in your implementation. 3. Your function should have a linear time complexity with respect to the size of the input array.","solution":"def summarize_ranges(array): This function takes a sorted list of integers and returns a list summarizing the contiguous ranges. :param array: List[int] - sorted list of integers without duplicates. :return: List[str] - list of strings with either single integer or contiguous range described. if not array: return [] result = [] start = array[0] for i in range(1, len(array)): if array[i] != array[i - 1] + 1: if start == array[i - 1]: result.append(f\\"{start}\\") else: result.append(f\\"{start}-{array[i - 1]}\\") start = array[i] if start == array[-1]: result.append(f\\"{start}\\") else: result.append(f\\"{start}-{array[-1]}\\") return result"},{"question":"# Wildcard Word Search using Trie You are asked to implement a flexible dictionary that can store words and support searches with wildcard characters. A wildcard character represented by `\'.\'` can match any letter in the word. To achieve this, you will use a Trie data structure. Implement the following methods 1. **add_word(word: str) -> None**: Adds a word to the dictionary. 2. **search(word: str) -> bool**: Returns `True` if the word (including with wildcards) is in the dictionary, and `False` otherwise. Example: ```python wd = WordDictionary() wd.add_word(\\"bad\\") wd.add_word(\\"dad\\") wd.add_word(\\"mad\\") assert wd.search(\\"pad\\") == False # returns False assert wd.search(\\"bad\\") == True # returns True assert wd.search(\\".ad\\") == True # returns True assert wd.search(\\"b..\\") == True # returns True ``` Constraints: - The `add_word` method won\'t be called with the same word multiple times. - The total number of words added will not exceed `10^4`. - The search query word will not exceed length `50`. - You may assume all inputs are lowercase English letters. Performance Requirements: - Design your solution to handle wildcard searches efficiently while keeping memory usage reasonable. Implement the `WordDictionary` class based on the provided example and structural requirements.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: def dfs(node, i): if i == len(word): return node.is_end_of_word if word[i] == \'.\': for child in node.children.values(): if dfs(child, i + 1): return True return False else: if word[i] in node.children: return dfs(node.children[word[i]], i + 1) else: return False return dfs(self.root, 0)"},{"question":"# Level Order Traversal Challenge You are given a binary tree. Write a function `level_order_traversal` that performs a level order traversal (also known as breadth-first traversal) on the tree and returns a list of lists containing the values of each level, with each inner list representing one level. Function signature: ```python def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: ``` # Input - `root`: The root node of the binary tree. A TreeNode object where: - `root.val` is the value of the node. - `root.left` is the left child. - `root.right` is the right child. # Output - A list of lists. Each list contains the values of nodes at that level in the binary tree. # Constraints - The number of nodes in the binary tree is in the range `[0, 10^4]`. - The values of the nodes are unique within the binary tree. # Example ```python # Example Binary Tree # # 3 # / # 9 20 # / # 15 7 # # Input: root = [3,9,20,null,null,15,7] # # Output: [[3], [9,20], [15,7]] ``` # Implementation Hints 1. Use a queue to keep track of nodes at each level. 2. Initialize your queue with the root node and process nodes in breadth-first order. 3. For each node, add its children to the queue for future processing. 4. Collect values level by level into the resulting list.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"Context: You are tasked with validating HTML tags in a provided string. Similar to parenthesis validation, HTML tags must open and close properly and in the correct order. Problem Statement: Write a function `is_html_valid(html: str) -> bool` that determines if the input string containing HTML tags is valid. The tags are in the form `<tagname>` and `</tagname>`. A tag is considered valid if: 1. HTML tags must be correctly nested. 2. HTML tags must close in the correct order. 3. Single tags like `<img/>` are self-closed and do not need a separate closing tag. Input: - `html`: A string containing HTML tags. Output: - Returns `True` if the string is a valid sequence of HTML tags, otherwise returns `False`. Constraints: - The length of the string will not exceed 10,000 characters. - Tags will be alphanumeric and case-insensitive. Example Input and Output: ```python # Examples print(is_html_valid(\\"<html><body><h1>Hello</h1></body></html>\\")) # Output: True print(is_html_valid(\\"<div><div><p>Test</div></p>\\")) # Output: False print(is_html_valid(\\"<img/>\\")) # Output: True print(is_html_valid(\\"<html><b><i>Text</i></b></html>\\")) # Output: True print(is_html_valid(\\"<html><body></html>\\")) # Output: False ``` Note: 1. Consider edge cases such as empty strings or strings with only self-closing tags. 2. Ensure your function efficiently handles up to the maximum length constraint.","solution":"import re def is_html_valid(html: str) -> bool: Determines if the input string containing HTML tags is valid. # Regular expression to match HTML tags tag_pattern = re.compile(r\'<(/?)([a-zA-Z0-9]+)([^>]*)>\') tag_stack = [] pos = 0 while pos < len(html): match = tag_pattern.match(html, pos) if not match: pos += 1 continue is_closing, tag_name, attributes = match.groups() if tag_name and attributes.strip().endswith(\'/\'): # If it\'s a self-closing tag, no nesting needed pos = match.end() continue if is_closing: # If it\'s a closing tag, stack must not be empty and must match the top of the stack if not tag_stack or tag_stack[-1] != tag_name: return False tag_stack.pop() else: # It\'s an opening tag, push it to the stack tag_stack.append(tag_name) pos = match.end() return not tag_stack"},{"question":"# Question: Context: You are working on a project where you need to analyze if two versions of binary configurations only differ by minimal bit flips, which is crucial in optimizing configurations in digital systems. Task: Write a function `minimal_bit_flips(a, b)` that computes the minimal number of bit flips required to convert integer `a` to integer `b`. Input: - Two integers `a` and `b` (0 ≤ a, b ≤ 10^9). Output: - An integer representing the number of bits that need to be flipped to convert `a` to `b`. # Function Signature: ```python def minimal_bit_flips(a: int, b: int) -> int: # Your code here pass ``` # Example: Example 1: Input: ```python a = 29 b = 15 ``` Output: ```python 2 ``` Explanation: For `a = 29` (binary `11101`) and `b = 15` (binary `01111`), two bits need to be flipped (the first and fourth bits from the right). Example 2: Input: ```python a = 0 b = 15 ``` Output: ```python 4 ``` Explanation: For `a = 0` (binary `0000`) and `b = 15` (binary `1111`), all four bits need to be flipped. Constraints: - The function should run efficiently even for the largest inputs. - You are not allowed to use any standard library functions directly aimed at solving this problem (e.g., not using Python\'s in-built bit counting). # Additional Notes: - Consider edge cases such as when `a` and `b` are the same.","solution":"def minimal_bit_flips(a: int, b: int) -> int: Computes the minimal number of bit flips required to convert integer `a` to integer `b`. xor_value = a ^ b # XOR to find the differing bits count = 0 # Count the number of set bits (1s) in the XOR result while xor_value > 0: count += xor_value & 1 xor_value >>= 1 return count"},{"question":"# Scenario You\'re developing a version control system that models different users\' change histories as singly linked lists of commits. Due to branches and merges, two users\' histories may share some common commits. Your task is identifying the first common commit in both histories. # Problem Statement Write a function `find_intersection` that accepts two heads of singly linked lists and returns the first common node. If no common node exists, return `None`. # Function Signature ```python class Node: def __init__(self, val=None): self.val = val self.next = None def find_intersection(headA: Node, headB: Node) -> Node: ``` # Input - `headA` (`Node`): The head of the first singly linked list. - `headB` (`Node`): The head of the second singly linked list. # Output - A reference to the first shared node (`Node`), or `None` if no intersection is found. # Constraints 1. Nodes uniquely identified by their references. 2. Value of nodes are not unique and can\'t be used for comparison. 3. The lists are non-cyclic. 4. Both lists contain a maximum of 10,000 nodes. # Example ```python # Example setup # 1 -> 3 -> 5 # # 7 -> 9 -> 11 # / # 2 -> 4 -> 6 headA = Node(1) node3 = Node(3) node5 = Node(5) node7 = Node(7) node9 = Node(9) node11 = Node(11) headB = Node(2) node4 = Node(4) node6 = Node(6) headA.next = node3 node3.next = node5 node5.next = node7 node7.next = node9 node9.next = node11 headB.next = node4 node4.next = node6 node6.next = node7 assert find_intersection(headA, headB) == node7 ``` # Further Guidelines - Ensure your solution handles all edge cases, such as one or both input lists being empty, or there being no common nodes. - Aim to minimize both time and space complexities.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def find_intersection(headA: Node, headB: Node) -> Node: Identifies the first common node in two singly linked lists. if not headA or not headB: return None # Get the lengths of both linked lists def get_length(head): length = 0 current = head while current: length += 1 current = current.next return length lenA = get_length(headA) lenB = get_length(headB) # Align the start of both linked lists currentA, currentB = headA, headB if lenA > lenB: for _ in range(lenA - lenB): currentA = currentA.next else: for _ in range(lenB - lenA): currentB = currentB.next # Iterate through both linked lists and find the intersection while currentA and currentB: if currentA is currentB: return currentA currentA = currentA.next currentB = currentB.next return None"},{"question":"# Rabin-Miller Primality Test Enhancement Context: You have been provided with an implementation of the Rabin-Miller primality test. Your task is to enhance the algorithm by incorporating additional checks and optimizations to improve its reliability and performance. Requirements: 1. Preprocess to quickly determine small primes and handle trivial cases. 2. Optimize the power calculations to reduce computational overhead. 3. Improve the witness selection process to minimize false positives. Functional Specifications: Write a function `enhanced_is_prime(n: int, k: int = 5) -> bool` described as follows: - **Input**: * `n (int)`: The number to check for primality. * `k (int)`: The number of iterations to perform for accuracy, default is 5. - **Output**: * `bool`: Return `True` if the number is a probable prime, `False` otherwise. - **Constraints**: * ( n geq 1 ) * ( 1 leq k leq 20 ) Example: ```python assert enhanced_is_prime(3) == True assert enhanced_is_prime(4) == False assert enhanced_is_prime(17) == True assert enhanced_is_prime(21, 10) == False ``` Notes: - The function should handle small numbers quickly and avoid unnecessary computations. - Ensure the algorithm is resistant to edge cases that might cause false positives. - Performance should be optimal within the provided constraints.","solution":"import random def enhanced_is_prime(n: int, k: int = 5) -> bool: Enhanced Rabin-Miller primality test. :param n: The number to check for primality. :param k: The number of iterations to perform for accuracy, default is 5. :return: True if the number is a probable prime, False otherwise. if n <= 1: return False if n in (2, 3): return True if n % 2 == 0: return False # find r and s s = 0 r = n - 1 while r % 2 == 0: r //= 2 s += 1 def is_composite(a): x = pow(a, r, n) if x == 1 or x == n - 1: return False for _ in range(s - 1): x = pow(x, 2, n) if x == n - 1: return False return True # Do the test k times for _ in range(k): a = random.randint(2, n - 2) if is_composite(a): return False return True"},{"question":"# Question Maximum Sum of Contiguous Subsequence **Context**: You are given an array of integers. You are supposed to find the maximum sum of any contiguous subsequence of the given array. The subsequence must contain at least one element. This problem is meant to test your understanding of dynamic programming and greedy algorithms. **Specification**: **Function Signature**: ```python def max_contiguous_subsequence_sum(arr: List[int]) -> int: ``` **Input**: - `arr`: A list of integers, where `1 <= len(arr) <= 10^5` and `-10^4 <= arr[i] <= 10^4`. **Output**: - Return an integer representing the maximum sum of any contiguous subsequence of the input array. **Example**: ```python arr = [-2, 3, 8, -1, 4] result = max_contiguous_subsequence_sum(arr) # Expected output: 14 (as the subsequence [3, 8, -1, 4] gives the sum 14) arr = [-1, 1, 0] result = max_contiguous_subsequence_sum(arr) # Expected output: 1 (as the subsequence [1] gives the sum 1) arr = [-1, -3, -4] result = max_contiguous_subsequence_sum(arr) # Expected output: -1 (as the subsequence [-1] gives the sum -1) arr = [-2, 3, 8, -12, 8, 4] result = max_contiguous_subsequence_sum(arr) # Expected output: 12 (as the subsequence [8, 4] gives the sum 12) ``` **Constraints**: - The function should run in `O(n)` time complexity. - The function should use `O(1)` additional space.","solution":"from typing import List def max_contiguous_subsequence_sum(arr: List[int]) -> int: Returns the maximum sum of any contiguous subsequence of the given array. # Initialize the variables for the maximum sum found so far and the current sum max_sum = arr[0] current_sum = arr[0] # Iterate through the array starting from the second element for num in arr[1:]: # Update current_sum by including the current number or starting anew from the current number current_sum = max(num, current_sum + num) # Update max_sum if current_sum is greater max_sum = max(max_sum, current_sum) return max_sum"},{"question":"# **Euler\'s Totient Function implementation** Given a positive integer `n`, implement a Python function `euler_totient(n)` to calculate Euler\'s Totient Function (ϕ(n)), which is the number of integers from 1 to `n` that are coprime with `n`. # **Function Signature** ```python def euler_totient(n: int) -> int: ``` # **Input** - An integer `n` (1 <= n <= 10^6), the number for which the totient function is to be computed. # **Output** - The function should return an integer, the value of ϕ(n). # **Constraints** - Consider edge cases such as `n = 1` or `n = 2`. - Factor in the efficiency of the algorithm to handle the upper limits effectively. - Optimize for large `n` within the given constraints. # **Examples** ```python euler_totient(1) -> 1 euler_totient(2) -> 1 euler_totient(3) -> 2 euler_totient(10) -> 4 euler_totient(36) -> 12 ``` # **Scenario** Consider a cryptography class where students learn about basic number theory concepts that form the foundation of encryption algorithms like RSA. A common function they must understand and implement efficiently for encryption and decryption is Euler\'s Totient Function. The task is to ensure students can write efficient and correct code for computing ϕ(n) which is crucial for encrypting and decrypting messages securely. # **Explanation** Given `n`, the function calculates the number of integers from 1 to `n` that are coprime to `n`: - **Example**: For `n = 10`, the numbers 1, 3, 7, and 9 are coprime with 10, thus ϕ(10) = 4. Implement the function observing constraints and ensure efficiency to handle `n` up to 1,000,000.","solution":"def euler_totient(n: int) -> int: Calculate Euler\'s Totient Function (ϕ(n)) for a given positive integer n. if n == 1: return 1 result = n p = 2 # Check for factors of n while p * p <= n: if n % p == 0: # p is a prime factor of n while n % p == 0: n //= p result -= result // p p += 1 # If n is a prime number greater than 1 if n > 1: result -= result // n return result"},{"question":"# Context You are implementing a task scheduler that manages tasks in the order they arrive. To handle this, you need to implement your own Queue data structure that operates based on the first-in-first-out (FIFO) principle. You are to choose the ArrayQueue or LinkedListQueue implementation based on the provided abstract methods. # Task Implement a Queue data structure by extending the provided `AbstractQueue` class using an array-based approach (ArrayQueue). Ensure your implementation correctly adheres to the FIFO principle and handles edge cases and resizing efficiently. # Requirements 1. **enqueue(value)**: Adds a new item to the rear of the queue. - *Input*: Any value. - *Output*: None. 2. **dequeue()**: Removes the front item from the queue. - *Input*: None. - *Output*: The dequeued value. - *Edge Cases*: If the queue is empty, raise an IndexError with the message \\"Queue is empty\\". 3. **peek()**: Returns the front element of the queue without removing it. - *Input*: None. - *Output*: The front item. - *Edge Cases*: If the queue is empty, raise an IndexError with the message \\"Queue is empty\\". 4. **is_empty()**: Checks if the queue is empty. - *Input*: None. - *Output*: Boolean value indicating whether the queue is empty. 5. **__len__()**: Returns the number of items in the queue. - *Input*: None. - *Output*: Integer representing the number of items in the queue. 6. **__iter__()**: Returns an iterator for the queue items. # Constraints - The initial capacity of the underlying array should be 10. - The queue should dynamically expand by doubling the array size when it reaches capacity. # Function Signature ```python class ArrayQueue(AbstractQueue): def __init__(self, capacity=10): # initialize the queue def enqueue(self, value): # add item to the queue def dequeue(self): # remove and return the front value from the queue def peek(self): # return the front value without removing it def _expand(self): # expand the array size def __iter__(self): # implement the iterator for the queue ``` # Note Using Python lists directly as dynamic arrays is not allowed. Ensure you handle the array resizing manually.","solution":"class ArrayQueue: def __init__(self, capacity=10): Initialize the queue with an initial capacity. self._queue = [None] * capacity # Underlying array to hold the elements self._capacity = capacity # Initial capacity self._size = 0 # Number of elements in the queue self._front = 0 # Index of the front element self._rear = 0 # Index of the rear element def enqueue(self, value): Add item to the rear of the queue. if self._size == self._capacity: self._expand() self._queue[self._rear] = value self._rear = (self._rear + 1) % self._capacity self._size += 1 def dequeue(self): Remove and return the front value from the queue. if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self._queue[self._front] self._queue[self._front] = None # Clear the reference self._front = (self._front + 1) % self._capacity self._size -= 1 return value def peek(self): Return the front value without removing it. if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._queue[self._front] def is_empty(self): Check if the queue is empty. return self._size == 0 def __len__(self): Return the number of items in the queue. return self._size def _expand(self): Expand the array size by doubling its capacity. new_capacity = self._capacity * 2 new_queue = [None] * new_capacity for i in range(self._size): new_queue[i] = self._queue[(self._front + i) % self._capacity] self._queue = new_queue self._front = 0 self._rear = self._size self._capacity = new_capacity def __iter__(self): Implement the iterator for the queue. for i in range(self._size): yield self._queue[(self._front + i) % self._capacity]"},{"question":"**Scenario:** You have been asked to develop a component for a large-scale cryptographic application that involves frequent prime number validation to ensure the security and integrity of the system. The efficiency and correctness of your prime-checking algorithm are crucial as the system processes very large numbers. **Task:** Implement a function `is_prime(n: int) -> bool` that checks if a given number `n` is a prime number. Your algorithm should efficiently determine the primality of numbers to handle up to very large integers. # Function Signature ```python def is_prime(n: int) -> bool: pass ``` # Input * `n` (integer): The number to be checked for primality. ( 0 leq n leq 10^{18} ). # Output * Returns a boolean value: - `True` if `n` is a prime number. - `False` otherwise. # Constraints * Your solution should handle edge cases such as small values of `n` and very large values up to ( 10^{18} ). * Ensure that your algorithm adheres to ( O(sqrt{n}) ) time complexity for optimal performance. # Example ```python assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(17) == True assert is_prime(18) == False ``` # Notes * A prime number is only divisible by 1 and itself. * For larger values, consider potential performance issues and optimize accordingly without relying on external libraries.","solution":"def is_prime(n: int) -> bool: Checks if the given number n is a prime number. Parameters: n (int): The number to be checked for primality. Returns: bool: True if n is a prime number, False otherwise. # Handle edge cases if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False # Optimal trial division up to the square root of n i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"Given a large non-negative integer `n`, write a function `optimized_fib` to calculate the n-th Fibonacci number in an efficient manner. # Constraints and Requirements: - Input will be a non-negative integer `n` (0 ≤ n ≤ 10^18). - Your function should handle very large values of `n` efficiently, with both time and space considerations. - Return the Fibonacci number modulo (10^9 + 7) to keep the result manageable. # Input Format: ```python def optimized_fib(n: int) -> int: pass ``` # Outputs: - Returns the n-th Fibonacci number modulo (10^9 + 7). # Performance Requirements: - Your implementation should handle large values of `n` (up to (10^{18})) efficiently. # Example: ```python assert optimized_fib(10) == 55 assert optimized_fib(100) == 354224848179261915075 % (10**9 + 7) assert optimized_fib(1000000000000000000) != None # Asserts that it works for very large input ``` # Additional Context: Use matrix exponentiation or other efficient algorithms to achieve the desired performance. Simple iterative or recursive approaches will not suffice due to the vastness of the input\'s potential size. Provide necessary comments and explanations in your code.","solution":"def optimized_fib(n: int) -> int: MOD = 10**9 + 7 # Matrix exponentiation method to find nth Fibonacci number def matrix_multiply(A, B): return [ [(A[0][0] * B[0][0] + A[0][1] * B[1][0]) % MOD, (A[0][0] * B[0][1] + A[0][1] * B[1][1]) % MOD], [(A[1][0] * B[0][0] + A[1][1] * B[1][0]) % MOD, (A[1][0] * B[0][1] + A[1][1] * B[1][1]) % MOD], ] def matrix_pow(M, power): result = [[1, 0], [0, 1]] # Identity matrix while power: if power % 2 == 1: result = matrix_multiply(result, M) M = matrix_multiply(M, M) power //= 2 return result if n == 0: return 0 if n == 1: return 1 F = [[1, 1], [1, 0]] result_matrix = matrix_pow(F, n-1) return result_matrix[0][0]"},{"question":"# FizzBuzz Plus Plus **Problem Description**: You are tasked with enhancing the classic FizzBuzz problem by adding two new conditions and constructing the output in a more dynamic way. Implement a function called `fizzbuzz_plus_plus(n, additional_conditions)` that: - Returns an array containing the numbers from 1 to n. - Replaces certain values if any of the specified conditions are met. The conditions include the classic FizzBuzz rules and additional dynamic rules. - Each additional condition is provided as a tuple `(divisor, word)`. If a number is divisible by `divisor`, include `word` in its place (following the ordering in additional_conditions). **Rules**: 1. If a value is a multiple of 3, use \\"Fizz\\" instead. 2. If a value is a multiple of 5, use \\"Buzz\\" instead. 3. If a value meets any additional provided condition `(divisor, word)`, include `word`. 4. If a value satisfies multiple conditions, concatenate the respective words, preserving the order from the additional conditions list. **Function Signature**: ```python def fizzbuzz_plus_plus(n: int, additional_conditions: List[Tuple[int, str]]) -> List[Union[int, str]]: pass ``` **Parameters**: - `n` (int): The inclusive upper limit of the sequence (1 <= n). - `additional_conditions` (List[Tuple[int, str]]): A list of tuples representing additional replacement conditions. **Returns**: - List[Union[int, str]]: An array of numbers and strings based on the conditions met. **Examples**: 1. `fizzbuzz_plus_plus(15, [(7, \'Jazz\')])` should return `[1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', \'Jazz\', 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, \'Jazz\', \'FizzBuzz\']`. 2. `fizzbuzz_plus_plus(10, [(2, \'Even\')])` should return `[1, \'Even\', \'Fizz\', \'Even\', \'Buzz\', \'FizzEven\', 7, \'Even\', \'Fizz\', \'BuzzEven\']`. **Constraints**: - `1 <= n <= 10^3`.","solution":"from typing import List, Tuple, Union def fizzbuzz_plus_plus(n: int, additional_conditions: List[Tuple[int, str]]) -> List[Union[int, str]]: result = [] for i in range(1, n + 1): output = \\"\\" if i % 3 == 0: output += \\"Fizz\\" if i % 5 == 0: output += \\"Buzz\\" for divisor, word in additional_conditions: if i % divisor == 0: output += word result.append(output if output else i) return result"},{"question":"# Spiral Matrix Traversal **Objective**: Write a function to traverse a given matrix in spiral order and return the sequence of elements. **Function Signature**: ```python def spiral_traversal(matrix: List[List[int]]) -> List[int]: pass ``` **Input Format**: * `matrix`: A list of lists (2D array) representing the matrix, where each sub-list is a row containing integers. **Output Format**: * A list of integers representing the elements of the matrix traversed in spiral order. **Constraints**: * The dimensions of the matrix (m x n) where 0 <= m,n <= 100. **Scenario**: You are given a matrix representing a grid of pixels in a 2D image. Your task is to extract the pixel values in a spiral order starting from the top-left corner and proceeding outward in a clock-wise fashion. This order might be used for a specific type of image processing or data visualization task. **Examples**: 1. Given the following matrix: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` The function should return `[1, 2, 3, 6, 9, 8, 7, 4, 5]`. 2. Given the following matrix: ``` [ [1, 2], [3, 4] ] ``` The function should return `[1, 2, 4, 3]`. 3. Given the following matrix: ``` [ [1] ] ``` The function should return `[1]`. **Edge Cases**: * Matrices with a single row or a single column. * Unbalanced matrices such as 2x5 or 5x2. **Notes**: * Ensure your solution handles matrices of non-uniform shapes correctly. * Consider the computational limits for very large matrices within the given constraint.","solution":"from typing import List def spiral_traversal(matrix: List[List[int]]) -> List[int]: Returns the elements of the matrix in spiral order. result = [] if not matrix or not matrix[0]: return result rows, cols = len(matrix), len(matrix[0]) left, right, top, bottom = 0, cols - 1, 0, rows - 1 while left <= right and top <= bottom: for col in range(left, right + 1): result.append(matrix[top][col]) top += 1 for row in range(top, bottom + 1): result.append(matrix[row][right]) right -= 1 if top <= bottom: for col in range(right, left - 1, -1): result.append(matrix[bottom][col]) bottom -= 1 if left <= right: for row in range(bottom, top - 1, -1): result.append(matrix[row][left]) left += 1 return result"},{"question":"# Inorder Traversal Modification You are given a binary tree data structure, as implemented in the code snippet provided. Your goal is to modify the inorder traversal functions (`inorder` and `inorder_rec`) such that they not only return the in-order traversal of the tree but also transform the tree during the traversal. Specifically, each node’s value should be swapped with the sum of its original value and the values of all previously visited nodes in the inorder traversal. Make sure to implement both the iterative and the recursive versions of this modified inorder traversal. Function Signature ```python def modified_inorder(root: Node) -> list: pass def modified_inorder_rec(root: Node) -> list: pass ``` Input - `root`: The root of the binary tree (Node object). Output - A list of integers representing the inorder traversal of the modified tree. Constraints 1. Each node’s value resides within the integer range. 2. The tree may contain up to 10^4 nodes. Example Suppose we have a tree as follows: ``` 4 / 2 6 / / 1 3 5 7 ``` **Input**: ```python n1 = Node(4) n2 = Node(2) n3 = Node(6) n4 = Node(1) n5 = Node(3) n6 = Node(5) n7 = Node(7) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 ``` **Output**: For function `modified_inorder` or `modified_inorder_rec`, after running either function, the output list should be: ```python [1, 3, 6, 10, 15, 21, 28] ``` As a result, the tree would be modified as follows: ``` 10 / 6 21 / / 1 3 15 28 ```","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def modified_inorder(root: Node) -> list: if not root: return [] stack, result, current, sum_so_far = [], [], root, 0 while stack or current: while current: stack.append(current) current = current.left current = stack.pop() sum_so_far += current.val result.append(sum_so_far) current.val = sum_so_far current = current.right return result def modified_inorder_rec(root: Node) -> list: result = [] sum_so_far = [0] def helper(node): if not node: return helper(node.left) sum_so_far[0] += node.val result.append(sum_so_far[0]) node.val = sum_so_far[0] helper(node.right) helper(root) return result"},{"question":"# Radix Sort Simulation You are an engineer at a tech company, and your team is responsible for building efficient data processing pipelines. One task involves sorting large streams of log timestamps represented as integers. To achieve this, you decide to use the Radix Sort algorithm due to its efficiency with large datasets. # Task Implement the `radix_sort` function that showcases the sorting process using the LSD radix sort mechanism. Additionally, implement a `simulate` parameter to visually demonstrate each sorting iteration step-by-step for educational purposes. # Function Signature ```python def radix_sort(arr, simulate=False) -> list: ``` # Parameters * **arr**: A list of non-negative integers that need to be sorted. * **simulate**: A boolean flag. If `True`, your function should print the list at each main iteration of the sorting process. # Returns * The sorted list of integers. # Constraints 1. The array `arr` will contain at most `10^5` integers. 2. The values in `arr` will be non-negative and will fit into a standard 32-bit signed integer type. 3. The maximum number of digits (k) of integers in `arr` will not exceed 10. # Example Usage: ```python original_list = [170, 45, 75, 90, 802, 24, 2, 66] sorted_list = radix_sort(original_list) print(\\"Sorted List:\\", sorted_list) # Output should be [2, 24, 45, 66, 75, 90, 170, 802] # With simulation enabled: original_list = [170, 45, 75, 90, 802, 24, 2, 66] sorted_list = radix_sort(original_list, simulate=True) # Output should show intermediate steps of sorting: # iteration 0: 170 45 75 90 802 24 2 66 # iteration 1: 170 90 802 2 24 45 75 66 # iteration 2: 2 24 45 66 75 170 802 90 # iteration 3: 2 24 45 66 75 90 170 802 ``` # Considerations * Ensure that your implementation handles edge cases, such as arrays with uniform or zero elements. * Optimize for both time and space efficiency to handle large input sizes within practical time limits. * Validate the correctness of your algorithm by writing unit tests that cover both normal and edge cases.","solution":"def get_digit(number, digit_index): # Get digit at the specific place (0-based from right to left) return (number // (10 ** digit_index)) % 10 def counting_sort(arr, digit_index, simulate): n = len(arr) output = [0] * n # Output array to hold sorted elements count = [0] * 10 # Initialize count array for digits 0-9 # Count frequency of each digit in the given digit place for i in range(n): digit = get_digit(arr[i], digit_index) count[digit] += 1 # Compute cumulative count for i in range(1, 10): count[i] += count[i - 1] # Construct the output array for i in range(n - 1, -1, -1): digit = get_digit(arr[i], digit_index) output[count[digit] - 1] = arr[i] count[digit] -= 1 # Copy the sorted elements into original array for i in range(n): arr[i] = output[i] if simulate: print(\\"Iteration {}:\\".format(digit_index), \' \'.join(map(str, arr))) def radix_sort(arr, simulate=False): Perform LSD Radix Sort on the provided list of non-negative integers. if not arr: return [] max_num = max(arr) max_digits = len(str(max_num)) # Find the number of digits in the largest number # Perform here Counting Sort for each digit from LSD to MSD for digit_index in range(max_digits): counting_sort(arr, digit_index, simulate) return arr"},{"question":"# Scenario You are working on a task scheduling system where you need to prioritize tasks based on their urgency. Tasks can arrive at any time, and each task has a priority. Your task is to implement a priority queue that will help efficiently manage these tasks. # Problem Statement Implement a class based priority queue that maintains elements based on their priorities. This priority queue should allow: 1. Inserting elements with a given priority. 2. Removing and returning elements with the highest priority (if there are multiple elements with the same highest priority, return any one of them). 3. Checking if the priority queue is empty. # Functional Specifications Methods to Implement 1. `__init__(self)`: Initializes the priority queue. 2. `insert(self, item, priority)`: Inserts `item` with the given `priority` into the priority queue. 3. `remove_max_priority(self)`: Removes and returns the item with the highest priority. 4. `is_empty(self)`: Returns True if the priority queue is empty, otherwise False. Input and Output Formats 1. `__init__`: Does not take any arguments and initializes an empty priority queue. 2. `insert`: Takes `item` (a string) and `priority` (an integer). 3. `remove_max_priority`: Returns the item with the highest priority. 4. `is_empty`: Returns a boolean indicating whether the priority queue is empty. Constraints - Assume `item` is always a non-empty string. - Assume `priority` is always an integer. Examples ```python # Example usage pq = PriorityQueue() pq.insert(\\"task1\\", 5) pq.insert(\\"task2\\", 10) pq.insert(\\"task3\\", 3) assert pq.remove_max_priority() == \\"task2\\" assert pq.remove_max_priority() == \\"task1\\" assert pq.is_empty() == False assert pq.remove_max_priority() == \\"task3\\" assert pq.is_empty() == True ``` # Note You should ensure that the priority queue operations have the expected time complexities mentioned in the analysis.","solution":"import heapq class PriorityQueue: def __init__(self): self._queue = [] self._index = 0 def insert(self, item, priority): # Use a negative priority to simulate a max-heap using heapq (which is a min-heap) heapq.heappush(self._queue, (-priority, self._index, item)) self._index += 1 def remove_max_priority(self): if self.is_empty(): raise IndexError(\\"remove_max_priority from empty priority queue\\") return heapq.heappop(self._queue)[-1] def is_empty(self): return len(self._queue) == 0"},{"question":"# Bogo Sort with Optimization Constraints You have been given an unoptimized sorting algorithm, Bogo Sort, which relies on random shuffling to sort an array. The algorithm is both inefficient and impractical as it can potentially run indefinitely. To assess your understanding of sorting algorithms and optimization, you are tasked with the following: Task: You need to implement a function `optimized_sort()` which improves the original algorithm. However, instead of using standard sorting algorithms (like Quick Sort, Merge Sort, etc.), you have to introduce constraints to minimize the inefficiencies of the Bogo Sort. You will: 1. Implement an optimized approximation of the Bogo Sort by introducing a mechanism that reduces randomness while progressively moving toward a sorted array. 2. Track performance statistics including the number of shuffles, and iterations. Function Signature: ```python def optimized_sort(arr: list) -> tuple: Sort the array and return the sorted array along with performance statistics. Parameters: arr (list): List of integers to be sorted. Returns: tuple: (sorted array (list), iterations (int), shuffles (int)) pass ``` Constraints: 1. Your implementation should leverage the Bogo Sort concept but include logic to reduce unnecessary shuffles. 2. You must not entirely replace Bogo Sort with another standard sorting algorithm. Input: * A single list of integers, `arr`, which you need to sort. Output: * A tuple containing: - The sorted list. - The number of iterations taken. - The number of shuffles performed. Example: ```python arr = [3, 2, 1] print(optimized_sort(arr)) # Output: ([1, 2, 3], iterations_count, shuffles_count) ``` Notes: - Emphasis should be placed on optimizing within the paradigm of the Bogo Sort. - Keep track of the number of iterations and shuffles to understand how your optimizations affect performance. - Handle edge cases (e.g., empty arrays, already sorted arrays) effectively to ensure robust code.","solution":"import random def is_sorted(arr): Helper function to check if the array is sorted. return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) def optimized_sort(arr): Sort the array and return the sorted array along with performance statistics. This function uses an optimized version of Bogo Sort by applying a selection shuffle to progressively move towards a sorted array. Parameters: arr (list): List of integers to be sorted. Returns: tuple: (sorted array (list), iterations (int), shuffles (int)) iterations = 0 shuffles = 0 while not is_sorted(arr): iterations += 1 # Implementing a pseudo Bogo Sort with a shuffle optimization for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: # Shuffle only the out-of-order part shuffle_part = arr[i:] random.shuffle(shuffle_part) shuffles += 1 arr = arr[:i] + shuffle_part break return arr, iterations, shuffles"},{"question":"# Question: SAT Solver with Implication Graph You are provided with a code snippet that solves the 2-Satisfiability (2-SAT) problem using the concept of implication graphs and Strongly Connected Components (SCC). The provided formula is in Conjunctive Normal Form (CNF), with each clause containing exactly two literals. Your task is to extend the provided code that currently solves the 2-SAT problem to handle a modification. The modification involves adding an additional feature where the user can query the resulting assignment for a specific variable to determine if it is assigned `True` or `False`. # Input 1. A list of clauses where each clause is a pair of tuples. Each tuple represents a literal in the form `(name, is_neg)` where `name` is a string (the variable\'s name) and `is_neg` is a boolean indicating if the literal is negated. 2. A query string representing the variable name whose assignment is queried. # Output 1. A boolean indicating the assignment of the queried variable (`True` for True, `False` for False), or `None` if the formula is unsatisfiable. # Constraints * Each clause contains exactly two literals. * The formula is non-empty, and the variable names are unique strings. * The solution must determine if the CNF formula is satisfiable and then return the assignment for the queried variable. # Example ```python # Input: formula and queried variable formula = [((\'x\', False), (\'y\', False)), ((\'y\', True), (\'y\', True)), ((\'a\', False), (\'b\', False)), ((\'a\', True), (\'c\', True)), ((\'c\', False), (\'b\', True))] query = \'a\' # Expected Output True or False (depending on the CNF satisfiability) # Example Execution result = extended_solve_sat(formula, query) print(result) # Output should be boolean or None ``` # Implementation Complete the function `extended_solve_sat` to determine the satisfiability of the given 2-SAT formula and to return the assignment for the queried variable if the formula is satisfiable. ```python def extended_solve_sat(formula, query): Extends the 2-SAT solver to include querying the assignment for a specific variable. Parameters: formula (list of pairs): The CNF formula. query (str): The variable name to query for its assignment. Returns: bool or None: The assignment of the queried variable or None if formula is unsatisfiable. # Implementation from provided code def dfs_transposed(vertex, graph, order, visited): visited[vertex] = True for adjacent in graph[vertex]: if not visited[adjacent]: dfs_transposed(adjacent, graph, order, visited) order.append(vertex) def dfs(vertex, current_comp, vertex_scc, graph, visited): visited[vertex] = True vertex_scc[vertex] = current_comp for adjacent in graph[vertex]: if not visited[adjacent]: dfs(adjacent, current_comp, vertex_scc, graph, visited) def add_edge(graph, vertex_from, vertex_to): if vertex_from not in graph: graph[vertex_from] = [] graph[vertex_from].append(vertex_to) def scc(graph): order = [] visited = {vertex: False for vertex in graph} graph_transposed = {vertex: [] for vertex in graph} for (source, neighbours) in graph.items(): for target in neighbours: add_edge(graph_transposed, target, source) for vertex in graph: if not visited[vertex]: dfs_transposed(vertex, graph_transposed, order, visited) visited = {vertex: False for vertex in graph} vertex_scc = {} current_comp = 0 for vertex in reversed(order): if not visited[vertex]: dfs(vertex, current_comp, vertex_scc, graph, visited) current_comp += 1 return vertex_scc def build_graph(formula): graph = {} for clause in formula: for (lit, _) in clause: for neg in [False, True]: graph[(lit, neg)] = [] for ((a_lit, a_neg), (b_lit, b_neg)) in formula: add_edge(graph, (a_lit, a_neg), (b_lit, not b_neg)) add_edge(graph, (b_lit, b_neg), (a_lit, not a_neg)) return graph def solve_sat(formula): graph = build_graph(formula) vertex_scc = scc(graph) for (var, _) in graph: if vertex_scc[(var, False)] == vertex_scc[(var, True)]: return None # The formula is contradictory comp_repr = {} # An arbitrary representant from each component for vertex in graph: if not vertex_scc[vertex] in comp_repr: comp_repr[vertex_scc[vertex]] = vertex comp_value = {} # True/False value for each strongly connected component components = sorted(vertex_scc.values()) for comp in components: if comp not in comp_value: comp_value[comp] = False (lit, neg) = comp_repr[comp] comp_value[vertex_scc[(lit, not neg)]] = True value = {var: comp_value[vertex_scc[(var, False)]] for (var, _) in graph} return value assignments = solve_sat(formula) if assignments is None: return None else: return assignments[query] ```","solution":"def extended_solve_sat(formula, query): Extends the 2-SAT solver to include querying the assignment for a specific variable. Parameters: formula (list of pairs): The CNF formula. query (str): The variable name to query for its assignment. Returns: bool or None: The assignment of the queried variable or None if formula is unsatisfiable. def dfs_transposed(vertex, graph, order, visited): visited[vertex] = True for adjacent in graph[vertex]: if not visited[adjacent]: dfs_transposed(adjacent, graph, order, visited) order.append(vertex) def dfs(vertex, current_comp, vertex_scc, graph, visited): visited[vertex] = True vertex_scc[vertex] = current_comp for adjacent in graph[vertex]: if not visited[adjacent]: dfs(adjacent, current_comp, vertex_scc, graph, visited) def add_edge(graph, vertex_from, vertex_to): if vertex_from not in graph: graph[vertex_from] = [] graph[vertex_from].append(vertex_to) def scc(graph): order = [] visited = {vertex: False for vertex in graph} graph_transposed = {vertex: [] for vertex in graph} for (source, neighbours) in graph.items(): for target in neighbours: add_edge(graph_transposed, target, source) for vertex in graph: if not visited[vertex]: dfs_transposed(vertex, graph_transposed, order, visited) visited = {vertex: False for vertex in graph} vertex_scc = {} current_comp = 0 for vertex in reversed(order): if not visited[vertex]: dfs(vertex, current_comp, vertex_scc, graph, visited) current_comp += 1 return vertex_scc def build_graph(formula): graph = {} for clause in formula: for (lit, _) in clause: for neg in [False, True]: graph[(lit, neg)] = [] for ((a_lit, a_neg), (b_lit, b_neg)) in formula: add_edge(graph, (a_lit, a_neg), (b_lit, not b_neg)) add_edge(graph, (b_lit, b_neg), (a_lit, not a_neg)) return graph def solve_sat(formula): graph = build_graph(formula) vertex_scc = scc(graph) for (var, _) in graph: if vertex_scc[(var, False)] == vertex_scc[(var, True)]: return None # The formula is contradictory comp_repr = {} # An arbitrary representant from each component for vertex in graph: if not vertex_scc[vertex] in comp_repr: comp_repr[vertex_scc[vertex]] = vertex comp_value = {} # True/False value for each strongly connected component components = sorted(vertex_scc.values()) for comp in components: if comp not in comp_value: comp_value[comp] = False (lit, neg) = comp_repr[comp] comp_value[vertex_scc[(lit, not neg)]] = True value = {var: comp_value[vertex_scc[(var, False)]] for (var, _) in graph} return value assignments = solve_sat(formula) if assignments is None: return None else: return assignments[query]"},{"question":"You are given a Unix-style absolute path for a file or directory. Write a function `simplify_path` that simplifies the given path. Function Signature ```python def simplify_path(path: str) -> str: ``` Input - `path`: A string representing an absolute Unix-style path. (1 <= len(path) <= 3000) - The path can contain alphabetic characters, numeric characters, \'.\', \'/\', and \'_\'. Output - Returns a string that represents the simplified Unix-style path. Constraints - The input path will always begin with a \'/\' and represent an absolute path. - The output should also represent an absolute path starting with a \'/\'. - Consecutive slashes should be treated as a single slash. - Resolve \'..\' in the path that moves one level up in the directory. - \'.\' refers to the current directory and should be ignored. - Any extra slashes between directories should be managed correctly. Examples ```python assert simplify_path(\\"/home/\\") == \\"/home\\" assert simplify_path(\\"/../\\") == \\"/\\" assert simplify_path(\\"/home//foo/\\") == \\"/home/foo\\" assert simplify_path(\\"/a/./b/../../c/\\") == \\"/c\\" ``` Scenario Throughout the various tasks, a filesystem utility needs to handle path normalizations to ensure all paths refer to a valid and simplified directory reference. Implementing a robust simplification helper contributes to more secure and accurate file handling in applications.","solution":"def simplify_path(path: str) -> str: components = path.split(\'/\') stack = [] for part in components: if part == \'..\': if stack: stack.pop() elif part and part != \'.\': stack.append(part) return \'/\' + \'/\'.join(stack)"},{"question":"Scenario You are tasked to implement a system that supports adding words and performing complex searches on them using wildcards. Your solution should handle insertion and search efficiently given the constraints. You will implement two classes: one using a Trie and another using a dictionary of lists. Requirements 1. **Class Definitions**: Implement two classes `WordDictionary` and `WordDictionary2`. 2. **Function Requirements**: * `add_word(word: str) -> None`: Adds a word to the data structure. * `search(word: str) -> bool`: Searches for a word where \'.\' can represent any character. 3. **Performance**: * Target efficiency in both time and space for adding and searching words. 4. **Constraints**: * All words consist of lowercase letters (\'a\' to \'z\'). * The number of words to be added and searched can be up to 10^4. * Each word\'s length is up to 100. Implementation You need to implement the following methods for both classes `WordDictionary` and `WordDictionary2`: ```python class WordDictionary: def __init__(self): pass def add_word(self, word: str) -> None: pass def search(self, word: str) -> bool: pass class WordDictionary2: def __init__(self): pass def add_word(self, word: str) -> None: pass def search(self, word: str) -> bool: pass ``` Examples ```python wd1 = WordDictionary() wd1.add_word(\\"bad\\") wd1.add_word(\\"dad\\") wd1.add_word(\\"mad\\") assert wd1.search(\\"pad\\") == False assert wd1.search(\\"bad\\") == True assert wd1.search(\\".ad\\") == True assert wd1.search(\\"b..\\") == True wd2 = WordDictionary2() wd2.add_word(\\"bad\\") wd2.add_word(\\"dad\\") wd2.add_word(\\"mad\\") assert wd2.search(\\"pad\\") == False assert wd2.search(\\"bad\\") == True assert wd2.search(\\".ad\\") == True assert wd2.search(\\"b..\\") == True ``` **Note**: Your solution must be efficient to handle the upper constraint limits effectively. Exceptionally high time or space complexity may lead to insufficient performance.","solution":"class TrieNode: def __init__(self): self.children = {} self.endOfWord = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.endOfWord = True def search(self, word: str) -> bool: def dfs(j, node): for i in range(j, len(word)): char = word[i] if char == \'.\': for child in node.children.values(): if dfs(i + 1, child): return True return False else: if char not in node.children: return False node = node.children[char] return node.endOfWord return dfs(0, self.root) class WordDictionary2: def __init__(self): self.words = {} def add_word(self, word: str) -> None: length = len(word) if length not in self.words: self.words[length] = [] self.words[length].append(word) def search(self, word: str) -> bool: length = len(word) if length not in self.words: return False for candidate in self.words[length]: for i in range(length): if word[i] != \'.\' and word[i] != candidate[i]: break else: return True return False"},{"question":"# Question: Reverse a String Context: You are working on a text processing application that requires efficient string reversal. Based on the provided analysis, write a function to reverse a given string. You need to choose the most appropriate method for handling large strings efficiently. Function Signature: ```python def reverse_string(s: str) -> str: pass ``` Input: * `s`: A string consisting of ASCII characters (`1 <= len(s) <= 10^5`). Output: * A new string which is the reverse of input string `s`. Constraints: * The function should have an optimal time and space complexity. * Think about the edge cases such as empty strings and strings with special characters. Requirements: 1. Implement an iterative or ultra-Pythonic method you find best suited for this task. 2. Write clean and efficient code, considering performance implications for large inputs. Example: ```python print(reverse_string(\\"hello\\")) # Output: \\"olleh\\" print(reverse_string(\\"\\")) # Output: \\"\\" print(reverse_string(\\"a\\")) # Output: \\"a\\" print(reverse_string(\\"12345\\")) # Output: \\"54321\\" print(reverse_string(\\"Able was I ere I saw Elba\\")) # Output: \\"ablE was I ere I saw elbA\\" ```","solution":"def reverse_string(s: str) -> str: Returns the reversed string of input string s. return s[::-1]"},{"question":"# Topological Sorting with Cycle Detection Write a Python function that takes a directed graph as input and returns a topological ordering of its vertices. The graph is represented as a dictionary where keys are node identifiers and values are lists of adjacent nodes. Your function should detect cycles and raise an appropriate exception if one is found. You must ensure that your implementation handles large graphs efficiently in both time and space. Input * A dictionary `graph` representing the directed graph. Output * A list representing a topological ordering of the graph\'s vertices. Constraints * The graph is a Directed Acyclic Graph (DAG). * Each node identifier is unique. * There can be up to 10^5 nodes. * The graph might have multiple disconnected components. Example ```python graph = { 5: [2, 0], 4: [0, 1], 3: [1], 2: [3], 1: [], 0: [] } print(top_sort(graph)) # Example output: [5, 4, 2, 3, 1, 0] graph_with_cycle = { 1: [2], 2: [3], 3: [4], 4: [2] # Cycle here } print(top_sort(graph_with_cycle)) # Example output: Raises ValueError(\\"cycle\\") ``` Additional Requirements * Ensure the function runs efficiently for graphs with up to 10^5 nodes and 10^6 edges. * Handle and raise exceptions when a cycle is detected. Function Signature ```python def top_sort(graph: dict) -> list: pass ```","solution":"def top_sort(graph): Perform topological sorting on a directed acyclic graph and detect cycles. Parameters: - graph: Dictionary where keys are node identifiers and values are lists of adjacent nodes. Returns: - List of nodes in topologically sorted order. Raises: - ValueError: If a cycle is detected in the graph. from collections import deque # Kahn\'s algorithm for Topological Sorting in_degree = {node: 0 for node in graph} # Calculate in-degrees of all nodes for node in graph: for neighbor in graph[node]: in_degree[neighbor] += 1 queue = deque([node for node in graph if in_degree[node] == 0]) sorted_list = [] while queue: node = queue.popleft() sorted_list.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(sorted_list) == len(graph): return sorted_list else: raise ValueError(\\"cycle\\")"},{"question":"**Scenario**: You are working as an analyst and have been given a dataset containing daily temperatures. Your task is to find the longest period (in terms of number of days) where the sum of daily temperature changes is maximized. **Problem Statement**: You need to implement a function `max_subarray_length(array)` which returns the length of the longest contiguous subarray in a given list of integers where the sum is maximized. **Function Signature**: ```python def max_subarray_length(array: List[int]) -> int: ``` **Input**: - `array`: A list of integers representing temperature changes over days. You can assume the list always contains at least one element. **Output**: - An integer representing the length of the longest subarray with the maximum sum. **Constraints**: - The input list will contain at least one integer and no more than 10^5 elements. - Elements in the list will be between -10^3 and 10^3. **Example**: ```python # Example 1 array = [1, 2, -3, 4, 5, -7, 23] # The longest subarray with maximum sum is [4, 5, -7, 23] with length 4 print(max_subarray_length(array)) # Output: 4 # Example 2 array = [-1, -2, -3, -4] # The longest subarray with maximum sum is the single element [-1] with length 1 print(max_subarray_length(array)) # Output: 1 ``` **Notes**: Consider edge cases like arrays with all negative numbers, and ensure the solution is optimized for large input sizes.","solution":"def max_subarray_length(array): Returns the length of the longest contiguous subarray with the maximum sum. max_sum = float(\'-inf\') current_sum = 0 max_length = 0 current_length = 0 for value in array: if current_sum + value > value: current_sum += value current_length += 1 else: current_sum = value current_length = 1 if current_sum > max_sum: max_sum = current_sum max_length = current_length elif current_sum == max_sum: max_length = max(max_length, current_length) return max_length"},{"question":"# Selection Sort with Optimization and Edge Cases Selection sort, while simple and instructive, is inefficient for large arrays. It does, however, serve as a valuable exercise in understanding sorting mechanics and algorithm optimization. **Task**: Enhance the provided `selection_sort` function by considering various edge cases and implementing an early termination optimization. **Function Signature**: ```python def optimized_selection_sort(arr): pass ``` # Requirements: 1. **Input**: The function receives a list of integers, `arr`. 2. **Output**: The function returns the sorted list in ascending order. 3. **Constraints**: - The input list can have a size of up to (10^4). - The input integers can be both positive and negative, ranging from (-10^6) to (10^6). 4. **Performance**: The optimized function should ideally make use of early termination where possible. 5. **Edge Cases**: - Handle arrays with zero, one, and all identical elements properly. - Your function should work correctly on already sorted arrays as well as reverse-sorted arrays. # Example: ```python print(optimized_selection_sort([64, 25, 12, 22, 11])) # Output: [11, 12, 22, 25, 64] ``` # Instructions: 1. Implement the `optimized_selection_sort` function. 2. Early termination should occur if no swaps are needed during an iteration. 3. Test your function thoroughly with provided and additional test cases to ensure reliability. Consider the provided `selection_sort` as a base reference to build upon. The primary focus is to demonstrate multi-faceted understanding: edge cases, early exit optimization, while maintaining simplicity and correctness.","solution":"def optimized_selection_sort(arr): This function sorts an array using the optimized selection sort algorithm, by utilizing early termination when the array is already sorted. n = len(arr) for i in range(n): min_index = i # find the minimum element in remaining unsorted array for j in range(i+1, n): if arr[j] < arr[min_index]: min_index = j # Swap the found minimum element with the first element of unsorted part arr[i], arr[min_index] = arr[min_index], arr[i] # Early termination check if i < n - 1 and arr[i] <= arr[i+1]: sorted_check = True for k in range(i+2, n): if arr[k-1] > arr[k]: sorted_check = False break if sorted_check: break return arr"},{"question":"# Coding Challenge: Unique Element Finder with Bit Manipulation Scenario In data integrity systems, you often come across streams where a sensor signal might spike exactly three times due to noisy readings, but only one actual meaningful reading does not repeat. Your task is to design an algorithm that accurately identifies this unique reading. Problem Statement Given an array of integers `nums` where every element appears exactly three times except for one, which appears exactly once, write a function `find_unique` to identify and return the single unique element. # Function Signature ```python def find_unique(nums: List[int]) -> int: ``` # Input Format - `nums`: A list of integers where each integer except one appears exactly three times. - The list `nums` will contain at least one element. # Output Format - Return the unique integer that appears exactly once. # Constraints - You must achieve a linear runtime complexity, i.e., O(n). - Your solution should not use extra memory, aiming for O(1) space complexity. # Example ```python assert find_unique([2, 2, 3, 2]) == 3 assert find_unique([0, 1, 0, 1, 0, 1, 99]) == 99 assert find_unique([30000, 500, 100, 30000, 100, 30000, 100]) == 500 assert find_unique([-2, -2, 1, -2]) == 1 ``` # Explanation - In the first example, `3` appears only once while `2` appears three times. - In the second example, `99` is the unique number while `0` and `1` appear three times each. - Your solution should efficiently leverage bit manipulation to identify the unique value.","solution":"from typing import List def find_unique(nums: List[int]) -> int: Finds the unique element in a list where every other element appears exactly three times. Uses bit manipulation to achieve O(n) time complexity and O(1) space complexity. :param nums: List of integers where every element except one appears exactly three times. :return: The unique integer that appears exactly once. ones, twos = 0, 0 for num in nums: # `twos` records a bit if it appears second time twos |= ones & num # `ones` records a bit if it appears once ones ^= num # Common bits in `ones` and `twos` which should be reset common_bits = ones & twos # Remove common bits from `ones` ones &= ~common_bits # Remove common bits from `twos` twos &= ~common_bits return ones"},{"question":"You are given a node in a singly linked list. The task is to delete this node from the list. You are not given access to the head of the list but only to this node that needs to be deleted (except the tail node). Write a function `delete_node(node)` that accomplishes this. Input - `node`: The node in a singly linked list that needs to be deleted. It\'s guaranteed that this node is not a tail node and is a valid node. Output - Modify the linked list in-place so that the given node is effectively removed. Constraints - You cannot traverse the list from the head. - You cannot access any node before the given node. - The node is guaranteed not to be the tail node. Performance Requirements - Time Complexity: O(1) - Space Complexity: O(1) # Examples 1. Suppose the linked list is `1 -> 2 -> 3 -> 4 -> 5`, and you\'re given the node with value `3`. ``` delete_node(node3) ``` After calling `delete_node`, the linked list should become `1 -> 2 -> 4 -> 5`. # Explanation The function should: 1. Copy the value of the next node to the current node. 2. Update the next pointer of the current node to skip the next node. # Edge Cases 1. If the node is None, raise a `ValueError`. 2. If the node is the tail, raise a `ValueError`.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def delete_node(node): Deletes the given node (except the tail) by copying the value of the next node and then bypassing the next node. Args: node (ListNode): The node to be deleted (not the tail). Raises: ValueError: If the node is None or the tail node. if node is None or node.next is None: raise ValueError(\\"Cannot delete tail or None node.\\") next_node = node.next node.value = next_node.value node.next = next_node.next"},{"question":"# RSA Encryption Enhancement The RSA algorithm provided can generate keys, encrypt, and decrypt data effectively. However, the current implementation of the `modinv` function to calculate the modular inverse is inefficient. Your task is to enhance the RSA implementation by optimizing the `modinv` function using the Extended Euclidean Algorithm. This optimization will ensure that the modular inverse calculation is more efficient, especially for larger values of (a) and (m). Function Signature ```python def modinv(a: int, m: int) -> int: Calculate the inverse of a mod m using the Extended Euclidean Algorithm. ``` # Input - `a` (int): A non-negative integer representing the number to find the modular inverse of. - `m` (int): A positive integer representing the modulus. # Output - int: The modular inverse of `a` modulo `m`. # Constraints - (1 leq a < m leq 10^{12}) - a and m are coprime (i.e., gcd(a, m) == 1) # Scenario John, a data security expert, wants to use the RSA algorithm to secure communication channels in his company. He needs an efficient implementation for key generation. Specifically, he requires an optimized solution for calculating the modular inverse that will work efficiently for large keys (512 bits or more). # Example ```python # Example Key Generation n, e, d = generate_key(16) data = 42 encrypted = encrypt(data, e, n) # Encrypt the data decrypted = decrypt(encrypted, d, n) # Decrypt the data assert decrypted == data # The verification of the encryption-decryption process ``` # Implementation Details 1. Implement the `modinv` function using the Extended Euclidean Algorithm. 2. Integrate `modinv` in the `generate_key` function. 3. Ensure the key generation and encryption/decryption process works correctly and efficiently. You may use the given `encrypt` and `decrypt` functions for testing.","solution":"def egcd(a, b): Extended Euclidean Algorithm. Returns a tuple of gcd, x, y such that a*x + b*y = gcd. if a == 0: return b, 0, 1 gcd, x1, y1 = egcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return gcd, x, y def modinv(a, m): Calculate the modular inverse of a under modulus m using the Extended Euclidean Algorithm. gcd, x, _ = egcd(a, m) if gcd != 1: raise ValueError(\'Modular inverse does not exist\') return x % m # Example RSA key generation to showcase usage import random def generate_key(bits): from sympy import isprime, randprime p = randprime(2**(bits-1), 2**bits) q = randprime(2**(bits-1), 2**bits) n = p * q phi_n = (p-1) * (q-1) e = 65537 while True: try: d = modinv(e, phi_n) break except ValueError: e = randprime(2, phi_n) return n, e, d def encrypt(data, e, n): return pow(data, e, n) def decrypt(data, d, n): return pow(data, d, n)"},{"question":"Scenario You are working on a communication protocol for a system where you need to send lists of strings between servers efficiently. These strings can contain any character, and you need to make sure that the data remains intact and the order preserved through network transmission. Your task is to implement encoding and decoding functions that ensure this integrity. Problem Statement Design and implement two functions: `encode` and `decode`. - **encode**: Takes a list of strings and encodes it into a single string. - **Input**: List of strings, `strs`, e.g., `[\\"hello\\", \\"world\\"]`. - **Output**: A single string representing the encoded list, e.g., `\\"5:hello5:world\\"`. - **decode**: Takes an encoded string and decodes it back to the list of strings. - **Input**: A single encoded string, `s`, e.g., `\\"5:hello5:world\\"`. - **Output**: The original list of strings, e.g., `[\\"hello\\", \\"world\\"]`. Constraints 1. The input strings may include any character. 2. Avoid using any in-built parsing functions that deal directly with data serialization. 3. Handle edge cases like empty input lists, large strings, and strings containing delimiters appropriately. ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str res = \'\' for string in strs: res += str(len(string)) + \\":\\" + string return res def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] strs = [] i = 0 while i < len(s): j = s.find(\\":\\", i) length = int(s[i:j]) strs.append(s[j+1:j+1+length]) i = j+1+length return strs ``` Implement both functions ensuring they handle edge cases and are efficient for large inputs.","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str res = \'\' for string in strs: res += str(len(string)) + \\":\\" + string return res def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] strs = [] i = 0 while i < len(s): j = s.find(\\":\\", i) length = int(s[i:j]) strs.append(s[j+1:j+1+length]) i = j+1+length return strs"},{"question":"# Sorting Students based on Age **Context:** You are tasked with sorting a list of students based on their ages for an event where participants need to be lined up according to their age. You have decided to use Exchange Sort due to its simplicity. **Task:** Write a function `sort_students_by_age(students: List[Tuple[str, int]]) -> List[Tuple[str, int]]` that takes a list of tuples where each tuple contains a student\'s name and their age, and returns the list sorted by age in ascending order using the Exchange Sort algorithm. **Input:** * A list of tuples `students`, where each tuple consists of a name (string) and an age (integer). * Length of list, `n` (0 <= n <= 10^3). **Output:** * A list of tuples sorted by age in ascending order. **Constraints:** * The name is a non-empty string and the age is a non-negative integer. * The input list can be empty (in which case, return an empty list). **Example:** ```python students = [(\\"Alice\\", 22), (\\"Bob\\", 20), (\\"Charlie\\", 23)] sort_students_by_age(students) # Output: [(\\"Bob\\", 20), (\\"Alice\\", 22), (\\"Charlie\\", 23)] ``` Ensure your function handles edge cases correctly such as: * An empty list. * A list with one student. * All students with the same age.","solution":"def sort_students_by_age(students): Sorts a list of students based on their ages using the Exchange Sort algorithm. Parameters: students (List[Tuple[str, int]]): List of tuples where each tuple contains a student\'s name and their age. Returns: List[Tuple[str, int]]: List of tuples sorted by age in ascending order. n = len(students) for i in range(n): for j in range(i + 1, n): if students[i][1] > students[j][1]: students[i], students[j] = students[j], students[i] return students"},{"question":"# Question Context You are working on a game board system where different transformations of the game board are essential for gameplay mechanics. The board is represented as a square matrix. You need to implement the following matrix transformations: 1. Rotate the matrix 90 degrees clockwise. 2. Rotate the matrix 90 degrees counterclockwise. 3. Invert the matrix along the top-left to bottom-right diagonal. 4. Invert the matrix along the bottom-left to top-right diagonal. Task Implement the four matrix transformations described above. Each function should take a square matrix (a list of lists where each inner list is a row) as input and return a new matrix representing the transformed state. Function Signatures ```python def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: pass def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: pass def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: pass def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: pass ``` Input - `matrix`: A square matrix represented as a list of lists, where each nested list is of equal length and represents a row of the matrix. Output - A new matrix representing the transformed state. Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] # Rotate 90 degrees clockwise assert rotate_clockwise(matrix) == [ [7, 4, 1], [8, 5, 2], [9, 3, 0] ] # Rotate 90 degrees counterclockwise assert rotate_counterclockwise(matrix) == [ [3, 6, 9], [2, 5, 8], [1, 4, 7] ] # Invert along top-left to bottom-right diagonal assert top_left_invert(matrix) == [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] # Invert along bottom-left to top-right diagonal assert bottom_left_invert(matrix) == [ [9, 6, 3], [8, 5, 2], [7, 4, 1] ] ``` Constraints - The input matrix will always be a square matrix with dimensions ( n times n ) where ( 1 leq n leq 100 ). - Elements of the matrix are integers. Performance Requirements Your solution should efficiently handle matrices up to (100 times 100).","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the given square matrix 90 degrees clockwise. n = len(matrix) new_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): new_matrix[j][n - 1 - i] = matrix[i][j] return new_matrix def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the given square matrix 90 degrees counterclockwise. n = len(matrix) new_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): new_matrix[n - 1 - j][i] = matrix[i][j] return new_matrix def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: Inverts the matrix along the top-left to bottom-right diagonal. n = len(matrix) new_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): new_matrix[j][i] = matrix[i][j] return new_matrix def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: Inverts the matrix along the bottom-left to top-right diagonal. n = len(matrix) new_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): new_matrix[n - 1 - j][n - 1 - i] = matrix[i][j] return new_matrix"},{"question":"You are tasked with developing a function to compute the modular exponentiation of three integers - base, exponent, and mod. The function should efficiently compute ( (base^{exponent}) mod text{mod} ) even for very large values of the exponent. # Function Signature ```python def calculate_modular_exponentiation(base: int, exponent: int, mod: int) -> int: ``` # Input * An integer `base` (1 ≤ base ≤ (10^9)) * An integer `exponent` (0 ≤ exponent ≤ (10^9)) * An integer `mod` (2 ≤ mod ≤ (10^9)) # Output * An integer representing ( (base^{exponent}) mod text{mod} ) # Constraints * The exponent will always be non-negative. * The `mod` will always be a positive integer greater than 1. # Example ```python calculate_modular_exponentiation(2, 10, 1000) -> 24 calculate_modular_exponentiation(3, 0, 13) -> 1 calculate_modular_exponentiation(5, 7, 23) -> 17 ``` # Additional Notes 1. Your function should handle very large input values efficiently. 2. Ensure that you use an iterative approach to avoid stack overflow with large exponents. # Testing Considerations * Test with a variety of exponents, including boundary cases like 0 and large numbers. * Verify performance and correctness for a wide range of mod values. # Performance Requirements Given the potential size of the inputs, your function should have ( O(log text{exponent}) ) time complexity to ensure it runs efficiently within the input constraints.","solution":"def calculate_modular_exponentiation(base: int, exponent: int, mod: int) -> int: Efficiently computes (base^exponent) % mod using iterative method of modular exponentiation. result = 1 base = base % mod # Update the base if it is more than or equal to mod while exponent > 0: # If exponent is odd, multiply the result with base if (exponent % 2) == 1: result = (result * base) % mod # Exponent must be even now exponent = exponent >> 1 # Equivalent to exponent // 2 base = (base * base) % mod return result # Testing the function print(calculate_modular_exponentiation(2, 10, 1000)) # Output: 24 print(calculate_modular_exponentiation(3, 0, 13)) # Output: 1 print(calculate_modular_exponentiation(5, 7, 23)) # Output: 17"},{"question":"You are tasked with creating two functions that perform base conversion for integers. Specifically, you need to implement: 1. A function to convert an integer to a string representation in a specified base. 2. A function to convert a string representation of a number in a specified base back to an integer. # Function Signatures * `def int_to_base(num: int, base: int) -> str:` * `def base_to_int(str_to_convert: str, base: int) -> int:` # Specifications * Your base should support any integer from 2 to 36. * You should handle both positive and negative integers for the `int_to_base` function. * Assume valid input characters (i.e., digits and uppercase letters) and bases only (2 - 36) for simplicity. # Input * `int_to_base(num: int, base: int) -> str` - `num`: An integer to be converted. (Constraints: -2^31 <= num <= 2^31 - 1) - `base`: An integer representing the base to convert to. (Constraints: 2 <= base <= 36) * `base_to_int(str_to_convert: str, base: int) -> int` - `str_to_convert`: A non-empty string that represents the number in the given base. - `base`: An integer representing the base of the given string. (Constraints: 2 <= base <= 36) # Output * `int_to_base`: Return a string representation of `num` in the desired base. * `base_to_int`: Return the integer value of the string representation in the given base. # Examples 1. `int_to_base(5, 2)` should return `\'101\'`. 2. `int_to_base(-15, 16)` should return `\'-F\'`. 3. `base_to_int(\'101\', 2)` should return `5`. 4. `base_to_int(\'F\', 16)` should return `15`. # Constraints * Your implementation should be efficient in terms of time and space complexity, especially considering large values for `num` and long strings for `base_to_int`.","solution":"def int_to_base(num: int, base: int) -> str: Convert an integer to its string representation in a specified base. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36, inclusive\\") if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" negative = num < 0 num = abs(num) result = [] while num > 0: result.append(digits[num % base]) num //= base if negative: result.append(\'-\') return \'\'.join(reversed(result)) def base_to_int(str_to_convert: str, base: int) -> int: Convert a string representation of a number in a specified base back to an integer. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36, inclusive\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" digit_map = {char: index for index, char in enumerate(digits)} negative = str_to_convert[0] == \'-\' if negative: str_to_convert = str_to_convert[1:] num = 0 for char in str_to_convert: num = num * base + digit_map[char] return -num if negative else num"},{"question":"# Combination Calculation Context In combinatorial mathematics, the concept of combinations involves selecting items from a larger pool where the order of selection does not matter. The binomial coefficient, denoted as nCr, represents the number of ways to choose r items from n items and is a fundamental concept in probability and statistics as well as various fields in computer science. Task Given two integers `n` and `r`, write a function that calculates the nCr value. Implement both a naive and an optimized approach using memoization. Your solution should demonstrate an understanding of both recursion and dynamic programming. Function Signature ```python def combination(n: int, r: int) -> int: pass def combination_memo(n: int, r: int) -> int: pass ``` Input - Two integers `n` and `r` where `0 <= r <= n`. Output - An integer representing the number of ways to choose `r` items from `n` items. Constraints - 0 <= n, r <= 1000 Examples ```python # Example 1 combination(5, 2) => 10 # Example 2 combination(6, 6) => 1 # Example 3 combination_memo(5, 2) => 10 # Example 4 combination_memo(6, 3) => 20 ``` Requirements - Implement an efficient solution for larger values of `n` and `r` using dynamic programming/memoization. - Ensure that your function handles the base cases correctly. - Consider edge cases and provide the expected results for such scenarios.","solution":"def combination(n: int, r: int) -> int: Calculate the binomial coefficient nCr using a naive recursive approach. if r == 0 or r == n: return 1 return combination(n - 1, r - 1) + combination(n - 1, r) def combination_memo(n: int, r: int, memo=None) -> int: Calculate the binomial coefficient nCr using memoization. if memo is None: memo = {} if (n, r) in memo: return memo[(n, r)] if r == 0 or r == n: return 1 memo[(n, r)] = combination_memo(n - 1, r - 1, memo) + combination_memo(n - 1, r, memo) return memo[(n, r)]"},{"question":"**Question: Increment Each Digit in an Array** You are given a non-negative number represented as an array of its digits in big-endian format, where each element in the array contains a single digit. Your task is to write a function that increments the number by one and returns the resulting array. **Function Signature:** ```python def increment_array(digits: List[int]) -> List[int]: pass ``` **Input:** - `digits`: A list of integers where each integer is a digit (0-9) representing the number in big-endian format. **Output:** - A list of integers representing the number after adding one. **Constraints:** - The input list will have at least one digit. - The number represented by the array will not be negative. - The array can be very large, so consider efficient solutions. **Examples:** 1. `increment_array([1, 2, 3])` should return `[1, 2, 4]`. 2. `increment_array([9, 9, 9])` should return `[1, 0, 0, 0]`. 3. `increment_array([0])` should return `[1]`. **Edge Cases to Consider:** - When all digits are the maximum possible value (9). - Single digit arrays. - Handling leading zero additions when overflow happens beyond the most significant digit. Include a short description explaining your approach and consider optimizing for both time and space.","solution":"from typing import List def increment_array(digits: List[int]) -> List[int]: Increments the number represented by the list of digits by 1. n = len(digits) # Traverse the list from the end to the beginning for i in range(n - 1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits else: # If digit is 9, it becomes 0 digits[i] = 0 # If all the digits are 9, we\'ll fall through to here return [1] + [0] * n"},{"question":"# Coding Challenge: Implement a Mode Finder Function **Objective:** Your task is to write a function that identifies the mode(s) of an array of integers. The mode is defined as the element(s) that appear most frequently in the array. In case of a tie (multiple elements with the same maximum frequency), your function should return all such elements in the form of a list. **Function Signature:** ```python def find_modes(arr: List[int]) -> List[int]: pass ``` **Input:** * `arr` (List[int]): A list of integers. The list can contain both positive and negative numbers and may include duplicates. **Output:** * Returns a list of integer(s) that are the mode(s) of the input list. **Constraints:** * The function must run in O(n) time complexity where n is the length of the list. * The function must account for edge cases such as an empty list and multiple elements having the same maximum frequency. **Example Scenarios:** 1. **Example 1:** ```python find_modes([1, 1, 2, 2, 3, 4]) ``` * **Input:** [1, 1, 2, 2, 3, 4] * **Output:** [1, 2] * **Explanation:** Both 1 and 2 appear twice, which is the highest frequency. 2. **Example 2:** ```python find_modes([4, 4, 4, 6, 6, 1, 1, 1]) ``` * **Input:** [4, 4, 4, 6, 6, 1, 1, 1] * **Output:** [4, 1] * **Explanation:** Both 4 and 1 appear three times, which is the highest frequency. 3. **Example 3:** ```python find_modes([]) ``` * **Input:** [] * **Output:** [] * **Explanation:** An empty array has no mode. **Additional Note:** Your solution should preferably use Python’s built-in data structures and operations for efficiency. Ensure you handle edge cases gracefully to avoid runtime errors.","solution":"from typing import List def find_modes(arr: List[int]) -> List[int]: if not arr: return [] frequency_map = {} for num in arr: if num in frequency_map: frequency_map[num] += 1 else: frequency_map[num] = 1 max_frequency = max(frequency_map.values()) modes = [num for num, freq in frequency_map.items() if freq == max_frequency] return modes"},{"question":"# Task You are given a Binary Search Tree (BST) and a node within the tree. Write a function `findSuccessor(root: TreeNode, node: TreeNode) -> TreeNode:` that finds the in-order successor of the given node in the BST. # Input * `root`: The root node of the BST. * `node`: The node for which the in-order successor needs to be found. Both `root` and `node` are of type `TreeNode`, where `TreeNode` is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output * The function should return the in-order successor of the `node`. * If the `node` has no in-order successor, return `None`. # Constraints * All node values are unique. * The given node exists in the tree. * The BST does not contain duplicates. * The number of nodes in the tree is in the range [1, 10^4]. # Example Example 1 Input: ```python root = TreeNode(20) root.left = TreeNode(8) root.right = TreeNode(22) root.left.left = TreeNode(4) root.left.right = TreeNode(12) root.left.right.left = TreeNode(10) root.left.right.right = TreeNode(14) node = root.left.right ``` Calling `findSuccessor(root, node)` should return the node with value `14`. Example 2 Input: ```python root = TreeNode(20) root.left = TreeNode(8) root.right = TreeNode(22) root.left.left = TreeNode(4) node = root.left.left ``` Calling `findSuccessor(root, node)` should return the node with value `8`. Example 3 Input: ```python root = TreeNode(20) root.left = TreeNode(8) root.right = TreeNode(22) model = root.right ``` Calling `findSuccessor(root, node)` should return `None`. # Notes * Consider edge cases such as the given node being the smallest or the largest in the tree. * The solution requires efficient implementation due to constraints on the number of nodes.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findSuccessor(root: TreeNode, node: TreeNode) -> TreeNode: if not root or not node: return None successor = None # If node has a right subtree, the successor is the left-most node in its right subtree if node.right: successor = node.right while successor.left: successor = successor.left return successor # If no right subtree, the successor is the lowest ancestor whose left child is also # an ancestor of the node current = root while current: if node.val < current.val: successor = current current = current.left elif node.val > current.val: current = current.right else: break return successor"},{"question":"- Unique Paths in a Grid Given a grid with dimensions `m x n`, you are positioned at the top-left cell (0,0). You can only move right or down at any point in time. Your goal is to determine the number of unique paths to reach the bottom-right cell (m-1,n-1) from the top-left cell. **Function Signature:** ```python def unique_paths(m: int, n: int) -> int: Return the number of unique paths from the top-left to the bottom-right. ``` **Inputs:** * `m` (1 ≤ m ≤ 100): An integer representing the number of rows in the grid. * `n` (1 ≤ n ≤ 100): An integer representing the number of columns in the grid. **Outputs:** * An integer representing the number of unique paths from the top-left to the bottom-right cell. **Constraints:** * You are only allowed to move right or down to the adjacent cells in the grid. * You should handle the edge cases where the grid dimensions are minimal (1x1, 1xN, Mx1). **Example:** ```python assert unique_paths(3, 7) == 28 assert unique_paths(3, 2) == 3 assert unique_paths(1, 1) == 1 ``` **Scenarios and Context:** Consider this implementation in scenarios where you have to calculate possible paths in grid-based games or navigation systems. This problem is crucial in areas such as robotics and drone navigation optimization. Ensure your solution adheres to a time complexity of O(m*n) and a space complexity of O(m*n) or better. **Clarifications:** * Handle invalid inputs, where `m` or `n` are less than 1, by returning `-1`. * Optimize the space usage if possible, especially for larger grid sizes.","solution":"def unique_paths(m: int, n: int) -> int: Return the number of unique paths from the top-left to the bottom-right. if m < 1 or n < 1: return -1 # Create a 2D dp array initialized to 1 dp = [[1] * n for _ in range(m)] # Iterate over the array to fill in the number of unique paths for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # Return the number of unique paths to reach the bottom-right corner return dp[m-1][n-1]"},{"question":"Given two strings `s` and `t` which consist only of lowercase letters, where string `t` is generated by shuffling string `s` and adding one more letter at a random position. Your task is to write a function `find_added_letter(s: str, t: str) -> str` that finds and returns the letter that was added in `t`. # Function Signature ```python def find_added_letter(s: str, t: str) -> str: ``` # Input * `s`: A string of lowercase letters, not empty. * `t`: A string derived from `s` by shuffling it and adding one extra lowercase letter. # Output * A single character (string) representing the letter added to `t`. # Constraints * Both `s` and `t` will only contain lowercase letters. * The length of string `t` will be exactly one more than the length of string `s`. # Example ```python # Example 1 s = \\"abcd\\" t = \\"abecd\\" print(find_added_letter(s, t)) # Output: \'e\' # Example 2 s = \\"xyz\\" t = \\"xzya\\" print(find_added_letter(s, t)) # Output: \'a\' ``` # Performance Requirements * The solution should be efficient with O(n) time complexity and O(1) space complexity. # Background Your solution should leverage concepts similar to the provided XOR-based explanation to identify the added letter efficiently without using additional data structures like dictionaries or lists.","solution":"def find_added_letter(s: str, t: str) -> str: Finds the additional letter in string t that\'s not in string s. Args: s (str): Original string. t (str): String derived from s by shuffling and adding one extra letter. Returns: str: The extra letter added to t. xor_result = 0 # XOR all characters from both strings for char in s + t: xor_result ^= ord(char) return chr(xor_result)"},{"question":"# Question: Balanced Binary Tree Inorder Traversal Context You are given the task to perform an inorder traversal on a balanced binary tree. The traversal should be achieved using both iterative and recursive approaches. Implement both methods and ensure they yield the same result. Requirements 1. **Function 1: inorder(root)** * **Input**: The root node of a binary tree. * **Output**: A list of node values in inorder sequence. * **Implementation**: Iterative approach. 2. **Function 2: inorder_rec(root, res=None)** * **Input**: The root node of a binary tree. * **Output**: A list of node values in inorder sequence. * **Implementation**: Recursive approach. Example Case - Given the binary tree: ``` 100 / 50 150 / / 25 75 125 175 ``` - Both `inorder(root)` and `inorder_rec(root)` should return: `[25, 50, 75, 100, 125, 150, 175]`. Constraints * Assume the tree nodes only contain integer values. * The tree is height-balanced. * Tree may have a maximum of 1000 nodes. Performance Requirements - Both methods should have O(n) time complexity. Submission * Implement the two functions `inorder` and `inorder_rec`. * Ensure they handle edge cases, such as an empty tree or trees with single nodes.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder(root): Perform iterative inorder traversal on the binary tree. stack, result = [], [] current = root while current or stack: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_rec(root, res=None): Perform recursive inorder traversal on the binary tree. if res is None: res = [] if root: inorder_rec(root.left, res) res.append(root.val) inorder_rec(root.right, res) return res"},{"question":"Scenario Imagine you are working on a real-time analytics platform that needs to process large streams of financial data. Your task is to implement an efficient function that can quickly identify the maximum profit that can be made from a contiguous subarray of daily profits. The given array may have positive, negative, or zero values representing daily gains and losses. Task Write a function `max_contiguous_profit(profits)` that takes a list of integers `profits`, where each integer represents a daily profit/loss, and returns the maximum profit that can be achieved from a contiguous subarray. Input and Output Formats * **Input**: A list of integers `profits` (1 ≤ length of profits ≤ 10^5, -10^3 ≤ profits[i] ≤ 10^3). * **Output**: An integer representing the maximum profit from a contiguous subarray. Function Signature ```python def max_contiguous_profit(profits: List[int]) -> int: ``` Constraints * The array will contain at least one element. * The elements of the array will be whole numbers within the range specified above. Examples ```python # Example 1 profits = [1, 2, -3, 4, 5, -7, 23] print(max_contiguous_profit(profits)) # Output: 25 # Example 2 profits = [-5, -1, -8, -9] print(max_contiguous_profit(profits)) # Output: -1 # Example 3 profits = [3, -2, 5, -1] print(max_contiguous_profit(profits)) # Output: 6 # Example 4 profits = [9, -1, -3, 2, 6, -5] print(max_contiguous_profit(profits)) # Output: 12 ``` Additional Notes Ensure that your solution is efficient and can handle the upper limit of the input size within a reasonable time frame.","solution":"def max_contiguous_profit(profits): Returns the maximum profit that can be achieved from a contiguous subarray. max_current = max_global = profits[0] for profit in profits[1:]: max_current = max(profit, max_current + profit) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Path Splitting Function Implementation Context You are working on a file management system that needs to handle a variety of path formats. The primary function you need to implement is one that can split a given path into two parts: the directory path and the file name. Task Implement a function `split_path(path: str) -> Tuple[str, str]` that takes a string representing a path as input and returns a tuple containing two strings: the directory path and the file name. Input * A single string `path` representing the path. Output * A tuple `(directory_path, file_name)`: - `directory_path` (str): The directory component of the path. - `file_name` (str): The file name extracted from the path. Constraints * The input string `path` will contain only characters valid in paths (ASCII characters). * You cannot assume the presence of `/` in the path. * If the path does not contain any `/`, the directory path should be an empty string. Example 1. Input: `\\"https://algorithms/unix/test.py\\"` Output: `(\\"https://algorithms/unix\\", \\"test.py\\")` 2. Input: `\\"algorithms/unix/test.py\\"` Output: `(\\"algorithms/unix\\", \\"test.py\\")` 3. Input: `\\"test.py\\"` Output: `(\\"\\", \\"test.py\\")` Performance Considerations * Your implementation should efficiently handle the partition without unnecessary processing. * Ensure that the code correctly handles edge cases, such as the absence of a directory component.","solution":"def split_path(path: str) -> tuple: Splits the given path into directory path and file name. Args: path (str): The input path string. Returns: tuple: A tuple where the first element is the directory path and the second element is the file name. if \'/\' not in path: return (\\"\\", path) directory_path, file_name = path.rsplit(\'/\', 1) return (directory_path, file_name)"},{"question":"# Coding Challenge: Implement Advanced Interpolation Search Context You are working on a search engine algorithm for a retail website\'s backend. Consumers routinely search for product IDs in a large, sorted list of items. Interpolation search can greatly enhance performance, but the existing implementation needs modifications to handle edge cases and array distribution more efficiently. Task Write an advanced implementation of the interpolation search algorithm with the following features: 1. **Handling Zero Division**: Ensure that your implementation handles potential division by zero when the array\'s high and low values are equal. 2. **Assessment of Array Distribution**: Determine if the array is uniformly distributed or not and decide whether to proceed with interpolation search or fallback to binary search. 3. **Edge Case Handling**: Implement checks for edge cases like empty arrays or single-element arrays. 4. **Performance Optimization**: Enhance the performance by preprocessing the array if needed. Function Signature ```python def advanced_interpolation_search(array: List[int], search_key: int) -> int: :param array: A sorted array of integers. :param search_key: An integer key to search for in the array. :returns: Index of search_key in array if found, else -1. ``` Input and Output - **Input**: - A sorted list `array` of integers with `1 <= len(array) <= 10^6`. - An integer `search_key` to search for in the array. - **Output**: - Return the index of `search_key` if found, otherwise return -1. Constraints and Requirements - Ensure the time complexity is efficient, aiming for O(log(log(n))) in the best scenarios. - Handle arrays with severe non-uniform distributions gracefully. - Your solution should be robust against potential edge cases and pitfalls. Example Usage ```python # The function should return 2 because -1 is located at index 2 print(advanced_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1)) # The function should return -1 because 55 is not in the array print(advanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55)) # The function should return -1 because -5 is not in the array print(advanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], -5)) ``` Notes - Document your code thoroughly. - Add necessary test cases to fully validate the functionality and robustness. - Think about potential optimizations and justify your choices.","solution":"from typing import List def advanced_interpolation_search(array: List[int], search_key: int) -> int: def is_uniform_distribution(arr): Heuristically determines if the array is uniformly distributed. Returns True if it is likely uniformly distributed, else False. if len(arr) < 2: return True avg_diff = (arr[-1] - arr[0]) / (len(arr) - 1) threshold = avg_diff * 0.1 # Define a threshold for non-uniformity for i in range(1, len(arr)): if abs(arr[i] - arr[i-1] - avg_diff) > threshold: return False return True if not array: return -1 low, high = 0, len(array) - 1 if array[low] == array[high]: if array[low] == search_key: return low return -1 if not is_uniform_distribution(array): from bisect import bisect_left index = bisect_left(array, search_key) if index < len(array) and array[index] == search_key: return index return -1 while low <= high and search_key >= array[low] and search_key <= array[high]: if array[low] == array[high]: break pos = low + ((search_key - array[low]) * (high - low)) // (array[high] - array[low]) if pos < low or pos > high: break if array[pos] == search_key: return pos elif array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"Problem Statement You are tasked with writing a function to check whether given geographical coordinates are valid. A coordinating checking function must ensure that the coordinates meet the specific criteria outlined below, and return either `True` or `False`. # Input The input to your function will be a single string `coordinates`. The string represents a set of geographical coordinates and has the following characteristics: - Latitude and longitude are separated by a comma. - Coordinates should contain only digits, or one of the following symbols: `- , .`. - Latitude can be between -90 and 90, inclusive. - Longitude can be between -180 and 180, inclusive. - Coordinates can have floating point numbers but only one dot per number. # Output The function must return `True` if the coordinates are valid, otherwise return `False`. # Constraints 1. The input string does not contain any leading or trailing spaces. 2. There is only one space after the comma (if any space at all). # Examples Valid Coordinates: 1. `\\"23.32353342, -32.543534534\\"` -> `True` 2. `\\"-90, 180\\"` -> `True` 3. `\\"0, 0\\"` -> `True` 4. `\\"90, -180\\"` -> `True` 5. `\\"45.5, 100\\"` -> `True` Invalid Coordinates: 1. `\\"23.234, - 23.4234\\"` -> `False` 2. `\\"N23.43345, E32.6457\\"` -> `False` 3. `\\"6.325624, 43.34345.345\\"` -> `False` 4. `\\"0, 1,2\\"` -> `False` # Implementation Implement the function: ```python def is_valid_coordinates(coordinates: str) -> bool: # Your code here ``` You should consider edge cases such as extra spaces, multiple dots in a number, presence of unwanted characters, and values beyond the specified ranges.","solution":"def is_valid_coordinates(coordinates: str) -> bool: try: # Split latitude and longitude by comma parts = coordinates.split(\',\') if len(parts) != 2: return False latitude, longitude = parts # Strip spaces after the comma latitude = latitude.strip() longitude = longitude.strip() # Convert to float and check the ranges lat_float = float(latitude) lon_float = float(longitude) if not (-90 <= lat_float <= 90): return False if not (-180 <= lon_float <= 180): return False # Check for multiple dots or invalid characters if latitude.count(\'.\') > 1 or longitude.count(\'.\') > 1: return False # Ensure all characters are digits or allowed symbols, only one dot is allowed per part for char in latitude + longitude: if not (char.isdigit() or char in \'-.\'): return False return True except ValueError: return False"},{"question":"# Binary Sum Calculator You are working on a system that relies heavily on binary arithmetic, and you need to implement a function that adds two binary strings. Your task is to write a function `binary_sum` that takes two binary string inputs and returns their sum as a binary string. # Function Signature ```python def binary_sum(a: str, b: str) -> str: pass ``` # Input - `a` (str): A non-empty string containing only the characters \'0\' and \'1\', representing a binary number. - `b` (str): A non-empty string containing only the characters \'0\' and \'1\', representing a binary number. # Output - (str): A string representing the binary sum of inputs `a` and `b`. # Constraints - The lengths of `a` and `b` will be between 1 and 10000. - The input strings contain only \'0\' and \'1\'. # Performance Requirements - The solution should efficiently handle the worst-case scenario, where both input strings are of maximum length. # Examples *Example 1*: ```python a = \\"11\\" b = \\"1\\" binary_sum(a, b) # should return \\"100\\" ``` *Example 2*: ```python a = \\"1010\\" b = \\"1011\\" binary_sum(a, b) # should return \\"10101\\" ``` # Procedure 1. Traverse each string from the least significant bit to the most significant one (right to left). 2. Maintain a carry value initialized to 0. 3. Add corresponding bits from both strings along with the carry. 4. Append the result bit (`sum % 2`) to the result string. 5. Update the carry (`sum // 2`). 6. Ensure to handle the carry-over after traversing all bits. 7. Finally, return the resulting string in proper order. Implement the function `binary_sum` to meet the above requirements.","solution":"def binary_sum(a: str, b: str) -> str: Returns the binary sum of two binary strings. max_len = max(len(a), len(b)) # Padding the shorter string with zeros a = a.zfill(max_len) b = b.zfill(max_len) carry = 0 result = [] # Traverse from the least significant bit to the most significant bit for i in range(max_len-1, -1, -1): sum_val = int(a[i]) + int(b[i]) + carry carry = sum_val // 2 result.append(str(sum_val % 2)) # If there is a carry left, add it to the result if carry: result.append(\'1\') # The result is reversed because we added the digits from the back return \'\'.join(result[::-1])"},{"question":"# Subsets of a Set As a software engineer, you\'re tasked with developing a feature that calculates all possible subsets for a given set of distinct integers. This feature can be utilized in various applications, such as generating combinations in a game or enumerating configuration options for a setup. **Function Signature:** ```python def subsets(nums: List[int]) -> Set[tuple]: pass ``` # Input * `nums`: A list of distinct integers `List[int]`. # Output * A set of tuples, where each tuple is a subset of the input list `Set[tuple]`. # Constraints * The elements of the list `nums` are unique. * 0 <= len(nums) <= 10. # Example ```python nums = [1, 2, 3] print(subsets(nums)) # Expected output: # { # (1, 2), # (1, 3), # (1,), # (2,), # (3,), # (1, 2, 3), # (), # (2, 3) # } ``` # Performance Requirements * The implementation should efficiently handle the constraints, maintaining an acceptable time complexity of O(n * 2^n). # Edge Cases to Consider: * When the input list is empty, the output should be a set containing the empty tuple `{()}`. Your task is to implement the described function so that it produces the correct output for any valid input within the constraints.","solution":"from typing import List, Set, Tuple from itertools import chain, combinations def subsets(nums: List[int]) -> Set[Tuple[int]]: Returns all possible subsets of the given list of distinct integers. return set(chain.from_iterable(combinations(nums, r) for r in range(len(nums) + 1)))"},{"question":"# Question: Implement a Robust General Search Function You are tasked with creating a general search function that not only utilizes the linear search algorithm but also handles multiple value searches efficiently. You will implement a function `multi_linear_search` that takes an array and a list of queries and returns a list of results. Each result corresponds to the index of the occurrences of each query in the array. If a query is not found, it should return -1 for that query. Function Signature: ```python def multi_linear_search(array: list, queries: list) -> list: # your code here ``` Input: - `array`: A list of integers, which can be empty. Elements may be in any order. - `queries`: A list of integers to search for within the `array`. Output: - A list of integers, where each integer is the index of the found query in the `array` or -1 if the query is not found. Constraints: - The array can have up to (10^5) elements. - Each query in the queries list must be found individidually in the array. - Queries list can contain up to (10^4) queries. Example: ```python # Example 1: array = [5, 3, 7, 1, 4] queries = [7, 4, 10] output = [2, 4, -1] # Example 2: array = [] queries = [1, 2, 3] output = [-1, -1, -1] # Example 3: array = [1, 2, 3, 4, 5] queries = [5, 3, 2] output = [4, 2, 1] ``` Notes: - Ensure your function maintains a time complexity close to O(n * k), where n is the length of the array, and k is the length of the queries list. - Optimize for efficient searching by minimizing redundant operations if possible.","solution":"def multi_linear_search(array, queries): This function takes an `array` and a list of `queries`, and returns a list of indices where each query is found in the array. If a query is not found, it returns -1 for that query. result = [] for query in queries: try: index = array.index(query) except ValueError: index = -1 result.append(index) return result"},{"question":"You are given an array of integers. Your task is to implement two different searching algorithms, Linear Search and Binary Search, within a given class structure. This will allow you to identify elements\' indices in the array. The array may be unsorted, so you must include a mechanism to sort it when needed for Binary Search. # Function Signature ```python class SearchAlgorithms: def __init__(self, array: List[int]): pass def linear_search(self, query: int) -> int: pass def binary_search(self, query: int) -> int: pass ``` # Input * `array`: List of integers, which may be unsorted. * `query`: An integer to be searched within the array. # Output * The method `linear_search` should return the index of `query` in the list using linear search. If `query` is not found, return -1. * The method `binary_search` should return the index of `query` in the list using binary search. The array should be sorted as part of the method. If `query` is not found, return -1. # Constraints 1. The input list can contain up to `10^6` integers. 2. Each integer in the array is in the range [-10^9, 10^9]. # Performance Requirements * **Linear Search**: Should operate within the time complexity of O(n). * **Binary Search**: Should operate within the time complexity of O(log n) after sorting. # Example ```python array = [4, 2, 5, 8, 9, 1, 3] search = SearchAlgorithms(array) # Performing linear search print(search.linear_search(5)) # Output should be 2 (or any valid index where 5 is found) print(search.linear_search(6)) # Output should be -1 # Performing binary search print(search.binary_search(5)) # Output should be 4 (or any valid index where 5 is found after sorting [1, 2, 3, 4, 5, 8, 9]) print(search.binary_search(6)) # Output should be -1 ``` # Notes - Consider the sorting time for binary search as part of the total time complexity. - You may use the built-in sorting function of Python for sorting the array before performing Binary Search.","solution":"class SearchAlgorithms: def __init__(self, array): self.array = array def linear_search(self, query): Perform a linear search to find the index of `query` in `array`. Returns the index of `query` if found, else returns -1. for index, value in enumerate(self.array): if value == query: return index return -1 def binary_search(self, query): Perform a binary search to find the index of `query` in `array`. As the array needs to be sorted for binary search, this method sorts the array first. Returns the index of `query` if found, else returns -1. sorted_array = sorted(self.array) left, right = 0, len(sorted_array) - 1 while left <= right: mid = (left + right) // 2 if sorted_array[mid] == query: return mid elif sorted_array[mid] < query: left = mid + 1 else: right = mid - 1 return -1"},{"question":"Given an array of integers, you are required to implement a Fenwick Tree with the following functionalities: 1. **Update Value**: Update the value at a specific index in the array. 2. **Get Sum Upto Index**: Calculate the sum of all elements from index 0 to a given index. You need to implement these functionalities in a class `FenwickTree`, ensuring efficient performance. Class Design: ```python class FenwickTree: def __init__(self, arr): Initialize the Fenwick Tree with the given array. Arguments: arr -- list of integers def update(self, index, value): Update the element at the given index with the new value. Arguments: index -- integer, the index at which the update should occur (0-based). value -- integer, the new value to update. def get_sum(self, index): Get the sum of elements from index 0 to the given index. Arguments: index -- integer, the index up to which the sum should be computed (0-based). Returns: integer, the sum of elements up to the given index. ``` Example: ```python # Initialize the Fenwick Tree ft = FenwickTree([3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3]) # Update element at index 3 to 8 ft.update(3, 8) # Get the sum of elements from index 0 to 5 print(ft.get_sum(5)) # Output should match the sum up to the 5th element considering update above. ``` Constraints: 1. The length of the input array will not exceed 100,000 elements. 2. Input values will range between -10,000 and 10,000.","solution":"class FenwickTree: def __init__(self, arr): Initialize the Fenwick Tree with the given array. Arguments: arr -- list of integers self.n = len(arr) self.bit = [0] * (self.n + 1) self.arr = arr[:] for i in range(self.n): self._add_to_bit(i + 1, arr[i]) def _add_to_bit(self, index, value): Helper function to update BIT array. while index <= self.n: self.bit[index] += value index += index & -index def update(self, index, value): Update the element at the given index with the new value. Arguments: index -- integer, the index at which the update should occur (0-based). value -- integer, the new value to update. delta = value - self.arr[index] self.arr[index] = value self._add_to_bit(index + 1, delta) def get_sum(self, index): Get the sum of elements from index 0 to the given index. Arguments: index -- integer, the index up to which the sum should be computed (0-based). Returns: integer, the sum of elements up to the given index. index += 1 # Convert 0-based index to 1-based index for BIT sum_ = 0 while index > 0: sum_ += self.bit[index] index -= index & -index return sum_ # Example usage # Initialize the Fenwick Tree ft = FenwickTree([3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3]) # Update element at index 3 to 8 ft.update(3, 8) # Get the sum of elements from index 0 to 5 print(ft.get_sum(5)) # Output should match the sum up to the 5th element considering the update above."},{"question":"Skyline Problem Using Heap A city\'s skyline is determined by the outline formed by its buildings when viewed from a distance. Given the locations and heights of all buildings in the city, write a program to output the skyline formed by these buildings collectively. Each building is represented by a triplet of integers `[Li, Ri, Hi]`, where `Li` and `Ri` are the x coordinates of the left and right edges of the ith building, respectively, and `Hi` is its height. It is guaranteed that `0 ≤ Li`, `Ri ≤ INT_MAX`, `0 < Hi ≤ INT_MAX`, and `Ri - Li > 0`. # Input * List of buildings `buildings` where each building is represented by `[Li, Ri, Hi]`. * The buildings list is sorted in ascending order by the left x position `Li`. # Output * A list of \\"key points\\" which uniquely defines the skyline. A key point is the left endpoint of a horizontal line segment. * The output list should be sorted by the x position and have no consecutive horizontal lines of equal height. # Example Input: ```python buildings = [ [2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8] ] ``` Output: ```python [ [2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0] ] ``` # Constraints * The number of buildings in the input list is guaranteed to be in the range `[0, 10,000]`. * Ensure no consecutive horizontal lines of equal height in the output skyline. # Function Signature ```python def get_skyline(buildings: List[List[int]]) -> List[List[int]]: pass ``` # Implementation Notes: * You are expected to use a heap to track the current tallest building at each x coordinate. * Handle overlapping and nested buildings efficiently. * Avoid having consecutive horizontal lines of the same height by merging them in the final result where necessary.","solution":"import heapq def get_skyline(buildings): Returns the skyline formed by a list of buildings. Each building is represented as a triplet [Li, Ri, Hi]. Parameters: - buildings: List of buildings, where each building is defined by [Li, Ri, Hi] Returns: - A list of key points defining the skyline. # Events are either building start or end events = [] for L, R, H in buildings: events.append((L, -H, R)) # building start event events.append((R, 0, 0)) # building end event events.sort() # Result list and a max heap to track current heights result = [[0, 0]] height_heap = [(0, float(\\"inf\\"))] for x, negH, R in events: # Remove buildings from the heap where the right edge is left of the current x while height_heap[0][1] <= x: heapq.heappop(height_heap) if negH: # if it\'s a building start event, add to the heap heapq.heappush(height_heap, (negH, R)) # The current maximum height if different from the last added max_height = -height_heap[0][0] if result[-1][1] != max_height: result.append([x, max_height]) return result[1:]"},{"question":"Scenario You are hired by a software development company to assist in developing a text editor. One key feature required for the editor is an undo mechanism, which relies heavily on the stack data structure. Your task is to implement a stack-based undo system using either an array-backed stack or a linked-list-backed stack. Task You need to implement a class `TextEditor` that simulates basic text editing operations and supports an undo feature. Choose whether to implement the stack using an `ArrayStack` or a `LinkedListStack`, based on the provided abstract classes in the code snippets. # Implementation Details 1. **Class**: `TextEditor` 2. **Methods**: - `__init__(self)`: Initializes an empty text editor. - `type_character(self, char: str)`: Types a single character into the editor. - `get_text(self) -> str`: Returns the current text in the editor. - `undo(self)`: Undoes the last typing action, if any. # Constraints * `type_character` only accepts single alphabetic characters (`a-z`, `A-Z`). * The text editor starts empty. * The undo functionality only undoes typing actions, not other undos. # Performance Requirements * Ensure that the operations `type_character`, `get_text`, and `undo` can handle up to 10,000 operations efficiently. # Example Usage ```python editor = TextEditor() editor.type_character(\'a\') editor.type_character(\'b\') editor.type_character(\'c\') print(editor.get_text()) # Output: \\"abc\\" editor.undo() print(editor.get_text()) # Output: \\"ab\\" editor.undo() print(editor.get_text()) # Output: \\"a\\" editor.undo() print(editor.get_text()) # Output: \\"\\" editor.undo() # No effect, remains empty print(editor.get_text()) # Output: \\"\\" ``` Your Task Implement the `TextEditor` class with the specified methods.","solution":"class TextEditor: def __init__(self): Initializes an empty text editor. self.text = [] self.history = [] def type_character(self, char: str): Types a single character into the editor. if len(char) == 1 and char.isalpha(): self.text.append(char) self.history.append(char) def get_text(self) -> str: Returns the current text in the editor. return \'\'.join(self.text) def undo(self): Undoes the last typing action, if any. if self.history: self.history.pop() self.text.pop()"},{"question":"Implement a Priority Queue using a Linked List **Objective**: Implement a priority queue using a linked list data structure to manage elements. **Task**: 1. **Class Definition**: - Define a `PriorityQueueNode` for the linked list nodes. - Define a `PriorityQueue` class that supports the following operations: * `push(item, priority)`: Inserts `item` with the specified `priority`. * `pop()`: Removes and returns the item with the lowest priority. * `size()`: Returns the number of elements in the queue. * Implement error handling for popping from an empty queue. **Function Signature**: ```python class PriorityQueueNode: def __init__(self, data, priority): pass class PriorityQueue: def __init__(self): pass def push(self, item, priority): pass def pop(self): pass def size(self): pass ``` **Example**: ```python pq = PriorityQueue() pq.push(\\"task1\\", 1) pq.push(\\"task2\\", 5) pq.push(\\"task3\\", 3) print(pq.pop()) # Output: \\"task1\\" print(pq.size()) # Output: 2 pq.push(\\"task4\\", 0) print(pq.pop()) # Output: \\"task4\\" print(pq.pop()) # Output: \\"task3\\" print(pq.pop()) # Output: \\"task2\\" print(pq.size()) # Output: 0 # Edge case: Popping from an empty queue should raise an exception. ``` **Constraints**: - Use a singly linked list for implementing the priority queue. - Maintain the elements such that popping the lowest priority item is efficient. **Performance Requirements**: - Ensure that all operations are efficient enough to handle at least 10,000 elements. **Scenario**: You are required to implement a task scheduler for a small operating system emulator. Tasks can be added with a specific priority, and the operating system needs to process the task with the highest priority first to ensure essential tasks are handled promptly.","solution":"class PriorityQueueNode: def __init__(self, data, priority): self.data = data self.priority = priority self.next = None class PriorityQueue: def __init__(self): self.head = None self._size = 0 def push(self, item, priority): new_node = PriorityQueueNode(item, priority) if not self.head or self.head.priority > priority: new_node.next = self.head self.head = new_node else: current = self.head while current.next and current.next.priority <= priority: current = current.next new_node.next = current.next current.next = new_node self._size += 1 def pop(self): if not self.head: raise Exception(\\"Priority Queue is empty\\") node = self.head self.head = self.head.next self._size -= 1 return node.data def size(self): return self._size"},{"question":"# Simplify Unix-Style Path Context You are working on a file management utility that needs to process and simplify file paths. Given an absolute path for a file (Unix-style), you need to simplify it following these rules: 1. Any multiple slashes (\'/\') are treated as a single slash (\'/\'). 2. Any \'.\' segments (representing the current directory) should be ignored. 3. Any \'..\' segment (representing the parent directory) should pop the last valid directory entered into the path, unless the directory stack is empty. 4. The result should always start with a single \'/\' and never end with a \'/\' unless it is the root directory. Function Specification **Function Name**: `simplify_path` **Input**: A single string `path` representing the absolute file path. **Output**: A simplified Unix-style file path as a string. **Constraints**: - The path will contain only valid characters (no invalid characters such as illegal path symbols). - The path will always be an absolute path starting with \'/\' Example Cases **Example 1**: - Input: `path = \\"/home/\\"` - Output: `/home` **Example 2**: - Input: `path = \\"/a/./b/../../c/\\"` - Output: `/c` **Example 3**: - Input: `path = \\"/../\\"` - Output: `/` **Example 4**: - Input: `path = \\"/home//foo/\\"` - Output: `/home/foo` **Example 5**: - Input: `path = \\"/home//foo/../bar/\\"` - Output: `/home/bar` **Example 6**: - Input: `path = \\"/./././.\\"` - Output: `/` Prompt Implement the function `simplify_path(path)` to simplify the given Unix-style file path according to the above rules. Your function should pass all the provided example cases and handle additional edge cases efficiently.","solution":"def simplify_path(path): Simplifies the given Unix-style file path. Args: path (str): The absolute file path to be simplified. Returns: str: The simplified Unix-style file path. parts = path.split(\'/\') stack = [] for part in parts: if part == \'..\': if stack: stack.pop() elif part and part != \'.\': stack.append(part) return \'/\' + \'/\'.join(stack)"},{"question":"Context You are tasked with designing a system to determine the maximum amount of money a professional robber can rob from a row of houses without tripping the security system. Problem Each house has a certain amount of money. Adjacent houses have security systems connected, and robbing two adjacent houses will trigger an alarm. Your goal is to calculate the maximum amount of money that can be robbed without alerting the police. Function Signature ```python def rob_houses(houses: List[int]) -> int: pass ``` Input - `houses`: A list of non-negative integers, where each integer represents the amount of money in a house. Output - An integer representing the maximum amount of money that can be robbed without triggering the alarm. Constraints - The list can be empty (i.e., no houses). - The values in the list are non-negative integers. Examples 1. **Input**: `houses = [2, 7, 9, 3, 1]` **Output**: `12` **Explanation**: The optimal strategy is to rob houses 1, 3, and 5 (0-based index), totaling 2 + 9 + 1 = 12. 2. **Input**: `houses = [5, 3, 4, 11, 2]` **Output**: `16` **Explanation**: The optimal strategy is to rob houses 1, 4, and either 2 or 3, totaling 5 + 11 = 16. 3. **Input**: `houses = []` **Output**: `0` **Explanation**: No houses to rob, therefore the maximum amount is 0. Notes - Make sure the function handles edge cases such as an empty list. - Optimize for efficiency in terms of both time and space complexity.","solution":"from typing import List def rob_houses(houses: List[int]) -> int: Function to determine the maximum amount of money that can be robbed without robbing two adjacent houses. if not houses: return 0 n = len(houses) if n == 1: return houses[0] # Use dynamic programming to store the maximum money robbed up to each house dp = [0] * n dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, n): dp[i] = max(dp[i - 1], dp[i - 2] + houses[i]) return dp[-1]"},{"question":"Problem Description You are provided with a graph represented as a dictionary, where keys are node identifiers and values are lists of neighboring node identifiers. Your task is to write a function to find the shortest path, if it exists, between two given nodes in the graph. You must handle edge cases and ensure the function is efficient for large graphs. The function signature is as follows: ```python def efficient_shortest_path(graph: dict, start: str, end: str) -> list: ``` # Input: - `graph`: A dictionary where each key represents a node and its value is a list of neighboring nodes. - `start`: A string representing the starting node. - `end`: A string representing the destination node. # Output: - A list of nodes representing the shortest path from `start` to `end` inclusive. If no such path exists, return `None`. # Constraints: - The graph can contain up to 1000 nodes. - The graph can have cycles. - Assume all edges have the same weight. # Examples: ```python graph = { \'A\': [\'B\', \'C\', \'E\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\', \'G\'], \'D\': [\'B\'], \'E\': [\'A\', \'B\', \'D\'], \'F\': [\'C\'], \'G\': [\'C\'] } print(efficient_shortest_path(graph, \'A\', \'D\')) # Output: [\'A\', \'B\', \'D\'] print(efficient_shortest_path(graph, \'A\', \'G\')) # Output: [\'A\', \'C\', \'G\'] print(efficient_shortest_path(graph, \'A\', \'Z\')) # Output: None ``` # Notes: - Use an efficient method (Hint: Think about BFS for shortest path in an unweighted graph). - Your implementation must be able to handle edge cases properly (like disconnected nodes, absence of start/end, etc.).","solution":"from collections import deque def efficient_shortest_path(graph, start, end): Find the shortest path between start and end nodes in an unweighted graph. Args: graph (dict): A dictionary representing the graph where keys are nodes and values are lists of neighboring nodes. start (str): The starting node. end (str): The target node. Returns: list: A list representing the shortest path from start to end inclusive. If no path exists, return None. if start not in graph or end not in graph: return None queue = deque([(start, [start])]) visited = set() while queue: current_node, path = queue.popleft() if current_node == end: return path if current_node in visited: continue visited.add(current_node) for neighbor in graph[current_node]: if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return None"},{"question":"# Custom Serialization of String Lists In the context of transmitting data over networks, it\'s often necessary to serialize complex data structures to simple string representations. Your task is to implement two functions: `encode` and `decode` for a custom serialization scheme. The `encode` function will convert a list of strings into a single string, and the `decode` function will revert the encoded string back to the list of strings. Function Signatures ```python def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. pass def decode(s: str) -> List[str]: Decodes a single string to a list of strings. pass ``` # Guidelines 1. **Encoding Logic**: * Each string in the list will be prefixed by its length and a delimiter (colon `:`). * Example: `[\\"hello\\", \\"world\\"]` should be encoded as `5:hello5:world`. 2. **Decoding Logic**: * Read the length of each string from the prefix and extract the corresponding substring. * Example: `5:hello5:world` should be decoded back to `[\\"hello\\", \\"world\\"]`. # Input and Output Formats * **Input (encode)**: A list of strings `strs`. * **Output (encode)**: A single encoded string. * **Input (decode)**: A single encoded string `s`. * **Output (decode)**: The original list of strings. # Constraints * The length of the strings, and the list can be any non-negative integer. * The strings will not contain the delimiter character (colon `:`). # Examples ```python assert encode([\\"hello\\", \\"world\\"]) == \\"5:hello5:world\\" assert decode(\\"5:hello5:world\\") == [\\"hello\\", \\"world\\"] assert encode([\\"\\"]) == \\"0:\\" assert decode(\\"0:\\") == [\\"\\"] assert encode([]) == \\"\\" assert decode(\\"\\") == [] ``` # Performance Requirements * The implementation should be efficient in terms of both time and space complexity.","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. encoded_str = \'\'.join(f\'{len(s)}:{s}\' for s in strs) return encoded_str def decode(s: str) -> List[str]: Decodes a single string to a list of strings. decoded_list = [] i = 0 while i < len(s): j = s.find(\':\', i) length = int(s[i:j]) i = j + 1 decoded_list.append(s[i:i+length]) i += length return decoded_list"},{"question":"**Algorithm Design Question: Implement an Optimized Quick Sort** # Background: Quick Sort is a highly efficient sorting algorithm based on the divide-and-conquer principle. However, its performance can degrade to O(n^2) when poor pivots are selected. To optimize, you will implement a version of Quick Sort that uses the median-of-three method for pivot selection and switches to insertion sort when partitions are small. # Task: Implement an optimized Quick Sort algorithm. The function should be named `optimized_quick_sort`, and it should include two significant enhancements: 1. Use the median-of-three method to choose pivots. 2. Switch to insertion sort for partitions smaller than a threshold size to improve performance. # Function Signature: ```python def optimized_quick_sort(arr, threshold_size=10): # Implementation here pass ``` # Requirements: 1. **Median-of-three Pivot Selection**: Use the median of the first, middle, and last elements as the pivot. 2. **Switch to Insertion Sort**: For partitions smaller than `threshold_size` (default value: 10). # Constraints: - The function should be able to handle arrays with up to 10^5 elements. - Consider edge cases such as empty arrays and arrays with duplicate elements. # Input: - `arr`: A list of integers to be sorted. - `threshold_size`: An integer defining when to switch to insertion sort. # Output: - Return the sorted list. # Examples: ```python arr = [3, 6, 8, 10, 1, 2, 1] print(optimized_quick_sort(arr)) arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] print(optimized_quick_sort(arr, 2)) ``` # Performance Expectation: The function should perform well for large arrays and avoid the worst-case O(n^2) performance scenario. **Explanation** 1. Implement the core Quick Sort function using a recursive strategy. 2. The `partition` function should use the median-of-three method for pivot selection. 3. When the size of a partition is less than `threshold_size`, use insertion sort for that partition instead of further dividing it. # Additional Note: Students are expected to manage edge cases effectively and ensure the algorithm is both performant and correct.","solution":"def optimized_quick_sort(arr, threshold_size=10): if len(arr) <= 1: return arr def median_of_three(arr, low, high): mid = (low + high) // 2 if arr[low] > arr[mid]: arr[low], arr[mid] = arr[mid], arr[low] if arr[low] > arr[high]: arr[low], arr[high] = arr[high], arr[low] if arr[mid] > arr[high]: arr[mid], arr[high] = arr[high], arr[mid] return mid def partition(arr, low, high): median_index = median_of_three(arr, low, high) arr[median_index], arr[high] = arr[high], arr[median_index] pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def insertion_sort(arr, low, high): for i in range(low + 1, high + 1): key = arr[i] j = i - 1 while j >= low and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def quick_sort(arr, low, high): if high - low + 1 <= threshold_size: insertion_sort(arr, low, high) elif low < high: pivot_index = partition(arr, low, high) quick_sort(arr, low, pivot_index - 1) quick_sort(arr, pivot_index + 1, high) quick_sort(arr, 0, len(arr) - 1) return arr"},{"question":"# Longest Repeated Subsequence (LRS) Problem Objective Design a function to find the length of the longest repeated subsequence in a string. Remember, a subsequence is derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Background In this problem, we are dealing with finding patterns in strings that repeat themselves in a non-overlapping fashion but must follow the original order. If a character occurs at index `i` and then again at index `j` and the subsequence formed from these characters matches other parts of the string, it\'s part of a repeated subsequence. Example ``` Input: \'aabebcdd\' Output: 3 Explanation: The longest repeated subsequence is \\"abd\\". ``` Specifications * Function Name: `longest_repeated_subsequence` * Expected Input: A single string `s` containing lowercase English alphabets. * Expected Output: An integer representing the length of the longest repeated subsequence. Constraints * The length of the string `s` will be between 1 and 1000 inclusive. * The function must handle edge cases efficiently, such as handling strings of length 1 or strings with no repeated characters. * A time complexity of O(N^2) and space complexity of O(N^2) is expected, where N is the length of the input string. Implementation Notes The implementation should carefully iterate through the string while maintaining memoization to efficiently compute the lengths of repeated subsequences. Here are a few key points: * Use dynamic programming to build a matrix `dp` where `dp[i][j]` stores the length of the longest repeated subsequence for the string up to `i` and `j`. * At each step: - If characters match and they are not at the same index, increment the length from previous indices. - Otherwise, take the maximum value from the previous steps.","solution":"def longest_repeated_subsequence(s): Returns the length of the longest repeated subsequence in the given string. n = len(s) # Create and initialize the dp array dp = [[0] * (n + 1) for _ in range(n + 1)] # Fill dp array (similar to LCS with one extra condition) for i in range(1, n + 1): for j in range(1, n + 1): if s[i - 1] == s[j - 1] and i != j: dp[i][j] = 1 + dp[i - 1][j - 1] else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][n]"},{"question":"# Question Graph Shortest Path You are given an unweighted, undirected graph represented as an adjacency list. Write a function to find the shortest path between two given nodes using the BFS algorithm. If there is no path between the nodes, return `None`. Function Signature ```python def shortest_path(graph: Dict[int, List[int]], start: int, end: int) -> Optional[List[int]]: pass ``` # Input - `graph`: A dictionary where keys are nodes and values are lists of adjacent nodes. - `start`: The starting node (an integer). - `end`: The target node (an integer). # Output - A list representing the shortest path from `start` to `end`. If no such path exists, return `None`. # Constraints - The graph contains no negative cycles. - Nodes are represented by integers. - There can be up to `1000` nodes in the graph. - The graph is connected. # Example ```python graph = { 1: [2, 3], 2: [1, 4], 3: [1, 4, 5], 4: [2, 3, 5], 5: [3, 4] } assert shortest_path(graph, 1, 5) == [1, 3, 5] assert shortest_path(graph, 2, 5) == [2, 4, 5] assert shortest_path(graph, 1, 6) == None ``` **Explanation**: In the first example, the BFS traversal starts from node 1, visits nodes 2 and 3, and then node 5 with a shortest path of `[1, 3, 5]`. In the second example, starting from node 2, it quickly reaches node 4 and subsequently node 5. # Hints - Use a queue to implement BFS. - Keep track of the path separately to reconstruct the shortest path from `start` to `end`.","solution":"from collections import deque from typing import Dict, List, Optional def shortest_path(graph: Dict[int, List[int]], start: int, end: int) -> Optional[List[int]]: Finds the shortest path between two given nodes in an undirected, unweighted graph using Breadth-First Search (BFS). Parameters: - graph (dict): A dictionary representing the adjacency list of the graph. - start (int): The starting node. - end (int): The target node. Returns: - list: The shortest path from start to end as a list of nodes. - None: If no path exists between start and end. if start == end: return [start] # Initialize the queue with the starting node queue = deque([start]) # Dictionary to track the visited nodes and the path to reach them visited = {start: None} while queue: current = queue.popleft() # Check all adjacent nodes for neighbor in graph.get(current, []): if neighbor not in visited: visited[neighbor] = current queue.append(neighbor) # If we reach the end node, reconstruct the path if neighbor == end: path = [] while neighbor is not None: path.append(neighbor) neighbor = visited[neighbor] return path[::-1] return None"},{"question":"# Task: Implement a Nested Dictionary Printer **Context**: You are given a nested dictionary that represents a hierarchical structure, similar to a tree. You need to implement a function that prints this structure in a readable format, preserving the nested levels. The keys and sub-elements can be of mixed data types (strings, numbers). **Objective**: Write a function `nested_dict_printer(tree: dict) -> None` that processes the nested dictionary and prints each level in a formatted way, illustrating the hierarchy clearly. # Function Signature ```python def nested_dict_printer(tree: dict) -> None: pass ``` # Input * `tree`: A dictionary object where each key can map to either a list of sub-elements or another dictionary. # Output * The function should print the structure to the console in a readable, indented format. The exact indentation is up to you, but it should make the hierarchy clear. # Example Given the dictionary: ```python sample_tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', { \'sub_1\': \'Computer\', \'sub_2\': 5, \'sub_3\': \'TV\', \'sub_4\': 6, }, \'Jill\', \'Sports\', 1], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } ``` Your function should output something readable such as: ``` a -> Adam -> Book -> 4 b -> Bill -> sub_1 -> Computer sub_2 -> 5 sub_3 -> TV sub_4 -> 6 Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` # Constraints * The dictionary can have any level of nesting. * Keys and sub-elements are strings or numbers. # Considerations Ensure your implementation handles empty dictionaries, deeply nested structures, and various data types within the dictionary. Optimize for clarity and readability of the output.","solution":"def nested_dict_printer(tree: dict, indent: int = 0) -> None: Prints the nested dictionary in a readable format. Parameters: tree (dict): The nested dictionary to print indent (int): The current indentation level (used internally) for key, value in tree.items(): print(\' \' * indent + str(key) + \\" ->\\", end=\\" \\") if isinstance(value, dict): print() nested_dict_printer(value, indent + 1) else: if isinstance(value, list): print() nested_dict_printer({str(i): v for i, v in enumerate(value)}, indent + 1) else: print(value) # Example test if __name__ == \\"__main__\\": sample_tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', { \'sub_1\': \'Computer\', \'sub_2\': 5, \'sub_3\': \'TV\', \'sub_4\': 6, }, \'Jill\', \'Sports\', 1], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } nested_dict_printer(sample_tree)"},{"question":"Stooge Sort Implementation with Bounds Validation Scenario You are provided with an array of integers that needs to be sorted using the Stooge Sort algorithm. Your task is to write a function that takes an array and provides its sorted version, ensuring that the algorithm operates correctly, including validation of array bounds and non-decreasing arrangement of elements. Requirements 1. Implement the Stooge Sort algorithm. 2. Ensure that the array bounds are correctly validated and handled within the function. 3. Instead of sorting the array in-place, your function should return a new sorted array. Input Format * A list of integers, `arr`. Output Format * A list of integers representing the sorted array. Constraints * The input list `arr` will contain between 0 and 1000 integers. * Each integer in the list will be between -10^6 and 10^6. Example ```python Input: [5, 3, 2, 4, 1] Output: [1, 2, 3, 4, 5] Input: [10, -1, 2, 3, 0] Output: [-1, 0, 2, 3, 10] ``` Performance Considerations * The time complexity of Stooge Sort is O(n^2.709). Ensure that your implementation handles recursion efficiently by correctly validating and managing array bounds.","solution":"def stooge_sort(arr): Perform Stooge Sort on the given array. Args: arr (list of int): The array to be sorted. Returns: list of int: A new sorted array. def stooge_sort_recursive(arr, l, h): if l >= h: return # If the first element is larger than the last, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than 2 elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 stooge_sort_recursive(arr, l, h - t) # sort initial 2/3rd stooge_sort_recursive(arr, l + t, h) # sort final 2/3rd stooge_sort_recursive(arr, l, h - t) # sort initial 2/3rd again # Make a copy of the array arr_copy = arr.copy() stooge_sort_recursive(arr_copy, 0, len(arr_copy) - 1) return arr_copy"},{"question":"**Title**: Maximum Flow Computation in a Flow Network **Objective**: You are asked to implement a function that calculates the maximum flow in a flow network using one of the maximum flow algorithms discussed (Ford-Fulkerson, Edmonds-Karp, or Dinic). This will assess your understanding of augmenting path techniques and their implementations. # Problem Statement: You are given a flow network represented as a capacity matrix. Implement a function `maximum_flow` to compute the maximum flow from a source node to a sink node using either Ford-Fulkerson, Edmonds-Karp, or Dinic algorithm. * **Function Signature**: ```python def maximum_flow(capacity: List[List[int]], source: int, sink: int) -> int: ``` * **Input**: - `capacity`: A 2D list where capacity[i][j] represents the maximum capacity from vertex `i` to vertex `j`. If there is no edge from `i` to `j`, capacity[i][j] will be 0. - `source`: An integer representing the source vertex. - `sink`: An integer representing the sink vertex. * **Output**: - Returns an integer denoting the maximum flow from the source to the sink. * **Constraints**: - The capacity matrix will have dimensions n x n (1 <= n <= 100), where `n` is the number of vertices. - `capacity[i][j]` will be a non-negative integer less than or equal to 10^6. - `source` and `sink` will be valid vertices in the graph (0 <= source, sink < n; source != sink). * **Example**: ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 print(maximum_flow(capacity, source, sink)) # Output should be 23 ``` # Solution Requirements: - Implement the maximum flow computation using either of the provided algorithm techniques (DFS/BFS-based Ford-Fulkerson, Edmonds-Karp, or Dinic). - Ensure the solution handles all edge cases and works within the specified constraints. - Consider the efficiency of your implementation in terms of time and space complexity. # Notes: - Provide clear comments explaining your implementation approach. - Assume standard library functions and data structures are allowed.","solution":"from collections import deque from typing import List def bfs(C: List[List[int]], F: List[List[int]], source: int, sink: int, parent: List[int]) -> bool: Performs a BFS to find an augmenting path in the residual graph. visited = [False] * len(C) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v in range(len(C)): if not visited[v] and C[u][v] - F[u][v] > 0: # Residual Capacity > 0 queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def maximum_flow(capacity: List[List[int]], source: int, sink: int) -> int: Returns the maximum flow from the source to the sink in the given capacity graph using Edmonds-Karp algorithm. n = len(capacity) F = [[0] * n for _ in range(n)] # Flow matrix parent = [-1] * n # To store the path max_flow = 0 while bfs(capacity, F, source, sink, parent): path_flow = float(\'Inf\') s = sink # Find the maximum flow through the path found by BFS. while s != source: path_flow = min(path_flow, capacity[parent[s]][s] - F[parent[s]][s]) s = parent[s] # Update residual capacities of the edges and reverse edges along the path. v = sink while v != source: u = parent[v] F[u][v] += path_flow F[v][u] -= path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"Scenario You have been tasked to implement a scheduling system for a telecommunications company to connect various cities with fiber-optic cables. The objective is to connect all cities with minimal total cost by laying cables. The cities are represented by graph nodes, and the costs of laying cables between the cities are represented by edge weights. Task Implement a function `minimize_cable_cost(connections: List[List[int]]) -> int` that computes the minimal cost required to connect all cities with fiber-optic cables using Prim\'s Algorithm. Assume you have a connected, undirected graph described in a list of lists. # Input - `connections`: A list of lists, where each inner list represents a connection in the format `[cost, city1, city2]`, indicating a bi-directional connection with the associated cost. # Output - The function returns the minimal total cost of laying the cables to connect all cities. # Constraints - The number of cities `n` will be at most (10^4). - The cost of laying the cable will be a positive integer. # Example ```python def minimize_cable_cost(connections: List[List[int]]) -> int: # Your implementation here connections = [ [3, \'a\', \'b\'], [8, \'a\', \'c\'], [5, \'b\', \'d\'], [2, \'c\', \'d\'], [4, \'c\', \'e\'], [6, \'d\', \'e\'] ] print(minimize_cable_cost(connections)) # Output should be 14 ``` Requirements - Ensure your solution handles edge cases effectively. - Optimize for both time and space complexity. - Clearly comment your code to explain the functionality.","solution":"from typing import List import heapq def minimize_cable_cost(connections: List[List[int]]) -> int: # Prim\'s Algorithm to find Minimum Spanning Tree (MST) # Create an adjacency list adj_list = {} for cost, city1, city2 in connections: if city1 not in adj_list: adj_list[city1] = [] if city2 not in adj_list: adj_list[city2] = [] adj_list[city1].append((cost, city2)) adj_list[city2].append((cost, city1)) # Start from any node, we choose the first city here start_city = next(iter(adj_list)) # Min-heap to keep track of the minimum cost edges min_heap = [(0, start_city)] # (cost, city) # Set to keep track of visited nodes visited = set() total_cost = 0 while min_heap: cost, city = heapq.heappop(min_heap) if city in visited: continue visited.add(city) total_cost += cost # Add all edges from this node to the heap for edge_cost, neighbor in adj_list[city]: if neighbor not in visited: heapq.heappush(min_heap, (edge_cost, neighbor)) # Verify if all nodes were reached if len(visited) != len(adj_list): return -1 # A case where not all nodes are connected return total_cost"},{"question":"# Question: As a software developer, you are assigned the task of developing a function to sort a list of student grades using the Selection Sort algorithm. The company wants to visualize the process and expects you to add a feature that shows each step of the sorting process. Your function should handle various edge cases, including empty lists and lists with duplicate elements. **Function Signature**: ```python def selection_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts a list of integers using the Selection Sort algorithm. Prints each step if the simulation flag is set to True. Parameters: arr (List[int]): List of integers to be sorted. simulation (bool): If True, print each iteration step. Returns: List[int]: Sorted list of integers. ``` **Input**: * A list of integers `arr` which can include duplicates. * A boolean flag `simulation` which when set to `True` enables printing the state of the list after each iteration. **Output**: * A sorted list of integers in ascending order. **Constraints**: 1. The length of the list `arr` is at most (10^3). 2. Each integer in the list `arr` has an absolute value no greater than (10^3). **Examples**: 1. **Input**: `arr = [64, 25, 12, 22, 11], simulation = True` **Output**: ``` iteration 0 : 64 25 12 22 11 iteration 1 : 11 25 12 22 64 iteration 2 : 11 12 25 22 64 iteration 3 : 11 12 22 25 64 iteration 4 : 11 12 22 25 64 [11, 12, 22, 25, 64] ``` 2. **Input**: `arr = [1, 2, 3, 4], simulation = False` **Output**: `[1, 2, 3, 4]` 3. **Input**: `arr = [], simulation = True` **Output**: `[]` **Explanation**: * The function should print the state of the list at each step of the sorting process if `simulation` is set to `True`. If `simulation` is `False`, it should just return the sorted list. * Handle edge cases such as an empty list, one-element list, and lists with duplicate elements properly. Implement the `selection_sort` function based on the provided requirements and examples.","solution":"from typing import List def selection_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts a list of integers using the Selection Sort algorithm. Prints each step if the simulation flag is set to True. Parameters: arr (List[int]): List of integers to be sorted. simulation (bool): If True, print each iteration step. Returns: List[int]: Sorted list of integers. n = len(arr) for i in range(n): min_idx = i for j in range(i + 1, n): if arr[j] < arr[min_idx]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] if simulation: print(f\\"iteration {i} : {\' \'.join(map(str, arr))}\\") return arr"},{"question":"# Context You are working on a data analytics project and need to identify the mode(s) of different datasets collected. This is crucial for understanding the most frequent responses or items in your datasets. # Objectives Implement a function `find_modes` that follows the specification below to determine the most frequent values in an array. The function should handle typical edge cases and be efficient with its time and space complexity. # Specification **Function Name**: `find_modes` **Input**: - `data` (List[int]): A list of integers representing the dataset to analyze. **Output**: - List[int]: A list containing the most frequent element(s) in the input array. **Constraints**: - The input list can contain up to 10^6 elements. - The elements in the list range from -10^6 to 10^6. - If there are multiple modes, the function should return all of them in any order. - If the input list is empty, the function should return an empty list. **Example Cases**: 1. find_modes([1, 1, 2, 2, 3, 4]) -> [1, 2] 2. find_modes([5, 5, 5, 3, 3, 1]) -> [5] 3. find_modes([]) -> [] 4. find_modes([10, 20, 30, 10, 20, 30, 30, 20]) -> [20, 30] # Function Signature ```python from typing import List def find_modes(data: List[int]) -> List[int]: pass ```","solution":"from typing import List from collections import Counter def find_modes(data: List[int]) -> List[int]: if not data: return [] count = Counter(data) max_frequency = max(count.values()) modes = [key for key, freq in count.items() if freq == max_frequency] return modes"},{"question":"Objective: Implement a function that resolves a given file path to its absolute form, ensuring compatibility with both user-relative and relative paths. This function should also verify the accessibility of the target file or directory. Scenario: You are developing a configuration loader for a software application that reads configuration files from user-specified paths. To ensure robustness, the application must handle absolute, user-relative, and relative paths seamlessly. Additionally, the application needs to confirm that the specified path leads to an accessible file. Function Signature: ```python def resolve_and_validate_path(input_path: str) -> str: Resolves the provided file path to its absolute form and checks if the file is accessible. :param input_path: The user provided file path (can be absolute, user-relative, or relative) :return: The absolute path if the file is accessible :raises FileNotFoundError: If the file does not exist or is not accessible ``` Expected Input and Output Formats: - **Input**: A single string representing the file path. - **Output**: A single string, the resolved absolute path if the target is accessible. Constraints: 1. The path may include `~` for user home directory. 2. The file or directory must exist and be accessible. 3. If the input path is empty or invalid, raise a `FileNotFoundError`. Requirements: 1. **Accuracy**: Must correctly handle and resolve user-relative and relative paths. 2. **Validation**: Must check that the final resolved path exists and is accessible. 3. **Error Handling**: Raise appropriate exceptions for problems like non-existent paths. Example: ```python # Given that \'/home/user/config.txt\' exists and is accessible print(resolve_and_validate_path(\'~/config.txt\')) # Output: /home/user/config.txt # Given that \'/home/user/data/config.txt\' is accessible from \'/home/user/application/\' print(resolve_and_validate_path(\'../data/config.txt\')) # Output: /home/user/data/config.txt # Raising error for non-existent path try: resolve_and_validate_path(\'nonexistent/file\') except FileNotFoundError as e: print(e) # Output: FileNotFoundError ```","solution":"import os def resolve_and_validate_path(input_path: str) -> str: Resolves the provided file path to its absolute form and checks if the file is accessible. :param input_path: The user provided file path (can be absolute, user-relative, or relative) :return: The absolute path if the file is accessible :raises FileNotFoundError: If the file does not exist or is not accessible if not input_path: raise FileNotFoundError(\\"The path provided is empty.\\") # Expand user home directory symbol (~) expanded_path = os.path.expanduser(input_path) # Get the absolute path absolute_path = os.path.abspath(expanded_path) # Check if the file exists and is accessible if not os.path.exists(absolute_path): raise FileNotFoundError(f\\"The path \'{absolute_path}\' does not exist or is not accessible.\\") return absolute_path"},{"question":"**Question: Compute Binomial Coefficient Using Recursion** # Objective Implement an efficient function to compute the binomial coefficient C(n, k) utilizing recursion. Ensure your function handles various special cases and achieves the correct results for large values of n and k without exceeding stack limits. # Problem Statement The binomial coefficient C(n, k) is defined as the number of ways of picking k unordered outcomes from n possibilities, also known as \\"n choose k\\". It can be calculated using the formula: [ C(n, k) = frac{n!}{k!(n-k)!} ] Function Signature ```python def binomial_coefficient(n: int, k: int) -> int: pass ``` # Input - **n**: A non-negative integer (n >= 0). - **k**: A non-negative integer (0 <= k <= n). # Output - Return an integer representing the binomial coefficient C(n, k). # Examples ```python assert binomial_coefficient(5, 0) == 1 assert binomial_coefficient(8, 2) == 28 assert binomial_coefficient(500, 300) == 5054949849935535817667719165973249533761635252733275327088189563256013971725761702359997954491403585396607971745777019273390505201262259748208640 ``` # Constraints and Considerations - Make sure `n >= k` otherwise raise a ValueError. - Optimize your function to prevent excessive recursive depth. - Evaluate efficiency for large values of n and k. # Hint Consider symmetry properties C(n, k) = C(n, n-k) to reduce problem size, and the core recursion relationship used in the analysis above.","solution":"def binomial_coefficient(n, k): Calculate binomial coefficient C(n, k) using a recursive approach. if k < 0 or k > n: raise ValueError(\\"k must be in range 0 <= k <= n\\") if k == 0 or k == n: return 1 if k > n - k: # Taking advantage of symmetry, C(n, k) = C(n, n-k) k = n - k return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k)"},{"question":"**Objective**: Implement a function that computes the inverse Fast Fourier Transform (IFFT) using the Cooley-Tukey algorithm. **Context**: In signal processing, the inverse Fast Fourier Transform (IFFT) is used to reconstruct a signal from its frequency domain representation. This is essentially the reverse process of the FFT. **Function**: Implement the `ifft` function which computes the IFFT of a given complex input array. **Function Signature**: ```python def ifft(x): Computes the inverse Fast Fourier Transform of the input array. Parameters: x (list): A list of complex numbers representing the frequency domain representation. Returns: list: A list of complex numbers representing the time domain reconstruction. ``` **Input**: * A list of complex numbers `x`, where the length of `x` is an integer power of 2. **Output**: * A list of complex numbers representing the IFFT of the input list. **Constraints**: * The length of the input list will always be a power of 2. **Example**: Input: `[8+8j, 2j, 2-2j, -2+0j]` Output: `[2 + 2j, 1 + 3j, 3 + 1j, 2 + 2j]` **Guidelines**: * You may assume that suitable functions for complex arithmetic (like addition, multiplication, etc.) are available. * Ensure to handle normalization correctly within the IFFT computation. * You must not use any existing libraries that directly compute IFFT. Your implementation should use the principles of the Cooley-Tukey FFT algorithm. **Performance Requirement**: * The solution should have a time complexity of (O(N log N)).","solution":"import cmath def ifft(x): Computes the inverse Fast Fourier Transform of the input array. Parameters: x (list): A list of complex numbers representing the frequency domain representation. Returns: list: A list of complex numbers representing the time domain reconstruction. n = len(x) if n <= 1: return x even = ifft(x[0::2]) odd = ifft(x[1::2]) T = [cmath.exp(2j * cmath.pi * k / n) * odd[k] for k in range(n // 2)] return [(even[k] + T[k]) / 2 for k in range(n // 2)] + [(even[k] - T[k]) / 2 for k in range(n // 2)]"},{"question":"# Power of Two Checker and Its Extensions Context The provided implementation efficiently checks if a number is a power of two using binary operations. This has critical uses in computer science and engineering where powers of two play a role, such as memory management, data structuring, and algorithm design. Problem Statement Write a function `extended_power_of_two` that not only checks if a number is a power of two but also returns the next power of two greater than a given positive integer ( n ) and the previous power of two less than ( n ). Input - An integer ( n ) where ( 0 < n < 10^9 ). Output - A tuple of three values: 1. A boolean indicating if ( n ) is a power of two. 2. The next power of two greater than ( n ). 3. The previous power of two less than ( n ). Examples ```python assert extended_power_of_two(16) == (True, 32, 8) assert extended_power_of_two(18) == (False, 32, 16) assert extended_power_of_two(1) == (True, 2, 1) assert extended_power_of_two(1024) == (True, 2048, 512) ``` Constraints - Implement the function using efficient bit manipulation where possible. - Ensure the function runs in ( O(1) ) time complexity. Additional Notes - Utilize Python\'s native capabilities for handling large integers and binary operations to maintain constant time and space complexity. - Consider edge cases where ( n ) is just one more or one less than a power of two.","solution":"import math def extended_power_of_two(n): Checks if an integer is a power of two, and finds the next and previous powers of two. Parameters: n (int): The input integer. Returns: tuple: A tuple (is_power_of_two, next_power_of_two, previous_power_of_two). if n <= 0: raise ValueError(\\"Input must be a positive integer.\\") is_power_of_two = (n & (n - 1)) == 0 next_power_of_two = 1 << (n.bit_length()) previous_power_of_two = 1 << (n.bit_length() - 1) return is_power_of_two, next_power_of_two, previous_power_of_two"},{"question":"You need to implement a function that converts a Roman numeral to an integer. The input is guaranteed to be within the range from 1 to 3999. Your function should correctly identify and process the Roman numeral syntax, including subtraction cases. # Function Signature: ```python def roman_to_int(s: str) -> int: ``` # Input: - `s` (str): A Roman numeral string, guaranteed to be a valid Roman numeral within the range from 1 to 3999. # Output: - An integer corresponding to the Roman numeral value. # Constraints: - The input string will always represent a valid Roman numeral within the specified range. - Use the standard Roman numeral characters: {\'M\', \'D\', \'C\', \'L\', \'X\', \'V\', \'I\'}. # Example: ```python assert roman_to_int(\\"III\\") == 3 assert roman_to_int(\\"IX\\") == 9 assert roman_to_int(\\"LVIII\\") == 58 assert roman_to_int(\\"MCMXCIV\\") == 1994 ``` **Scenario**: As part of a history learning application, you need to convert Roman numerals to integers to allow users to input and manipulate historical dates more easily. The function you implement will be an integral part of the application\'s numeral processing module. # Requirements: 1. Implement the function to correctly handle conversion including the subtractive combinations. 2. Ensure the function runs efficiently with a time complexity of O(n). 3. No additional data structures should be used outside the provided dictionary for Roman numeral mappings.","solution":"def roman_to_int(s: str) -> int: Converts a Roman numeral to an integer. Args: s (str): A Roman numeral string. Returns: int: The corresponding integer value. roman_to_value = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 previous_value = 0 for char in s: current_value = roman_to_value[char] if current_value > previous_value: total += current_value - 2 * previous_value else: total += current_value previous_value = current_value return total"},{"question":"Stooge Sort Enhancement **Context:** Stooge Sort is a recursive sorting algorithm known for its impractical efficiency. It serves as an educational example to understand the mechanics of recursive sorting approaches. In this exercise, you will implement a more optimized sorting algorithm and compare its performance against Stooge Sort. **Task:** You need to write a function `optimized_sort(arr: List[int]) -> List[int]` that sorts an array of integers. You will choose any efficient sorting algorithm (such as Merge Sort, Quick Sort, or Heap Sort) and implement it from scratch. After implementation, you need to write a test function to compare the performance of your optimized sort against Stooge Sort for arrays of varying sizes. **Steps:** 1. Implement the `optimized_sort` function. 2. Measure the running time of `stoogesort` and `optimized_sort` on arrays of sizes 10, 100, 500 to demonstrate the performance difference. 3. Write the results as a comment in your code. **Requirements:** 1. Your optimized sorting algorithm should have a time complexity better than O(n^2). 2. Ensure your implementation handles edge cases such as empty arrays, arrays with a single element, and arrays with repeated elements. 3. Do not use any built-in sorting functions or libraries. **Example:** ```python # Given the array arr = [3, 1, 6, 5, 2, 4] # Using your optimized_sort function sorted_arr = optimized_sort(arr) print(sorted_arr) # Output should be: [1, 2, 3, 4, 5, 6] # Using stoogesort function stoogesort(arr, 0, len(arr) - 1) print(arr) # Output should be: [1, 2, 3, 4, 5, 6] ``` **Bonus:** Explain in a few sentences why your chosen sorting algorithm is more efficient than Stooge Sort.","solution":"import time from typing import List def optimized_sort(arr: List[int]) -> List[int]: Sorts an array of integers using Quick Sort algorithm. if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return optimized_sort(left) + middle + optimized_sort(right) def stoogesort(arr: List[int], l: int, h: int) -> None: if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(arr, l, h - t) stoogesort(arr, l + t, h) stoogesort(arr, l, h - t) # Performance comparison def compare_performance(): import random sizes = [10, 100, 500] results = [] for size in sizes: arr = [random.randint(0, 1000) for _ in range(size)] # Measure optimized_sort start_time = time.time() sorted_arr = optimized_sort(arr.copy()) optimized_sort_time = time.time() - start_time # Measure stoogesort arr_for_stooge = arr.copy() start_time = time.time() stoogesort(arr_for_stooge, 0, len(arr_for_stooge) - 1) stoogesort_time = time.time() - start_time results.append((size, optimized_sort_time, stoogesort_time)) return results # Uncomment to run the performance comparison # results = compare_performance() # for size, opt_time, stooge_time in results: # print(f\\"Array size: {size}, Optimized sort time: {opt_time:.5f}s, Stooge sort time: {stooge_time:.5f}s\\") # The performance results (example): # Array size: 10, Optimized sort time: 0.00008s, Stooge sort time: 0.00041s # Array size: 100, Optimized sort time: 0.00133s, Stooge sort time: 0.18482s # Array size: 500, Optimized sort time: 0.00708s, Stooge sort time: 20.63765s # The Quick Sort algorithm is more efficient than Stooge Sort because it has an average-case time complexity of O(n log n), whereas Stooge Sort has a time complexity of O(n^(log 3 / log 1.5)) which is approximately O(n^2.7095). The recursive nature and multiple comparisons make Stooge Sort highly inefficient for larger datasets."},{"question":"You are given a singly linked list where each node contains a string value. Your task is to remove duplicate values from the list. Implement two functions, `remove_duplicates_with_set` and `remove_duplicates_without_set`, to achieve this. * `remove_duplicates_with_set` should use a hash set to keep track of seen values and achieve O(N) time complexity. * `remove_duplicates_without_set` should use a nested loop to compare each node\'s value with subsequent nodes to achieve O(1) space complexity. # Function Signatures ```python class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates_with_set(head: Node) -> None: pass def remove_duplicates_without_set(head: Node) -> None: pass ``` # Expected Input and Output * Input: * `head` - A reference to the head node of the linked list. * Output: * The linked list should be modified in-place to remove duplicates. The functions do not return any value. # Constraints * The linked list can have up to `10^5` nodes. * Node values are strings. # Example ```python # The linked list \\"A -> A -> B -> C -> D -> C -> F -> G\\" should be transformed to \\"A -> B -> C -> D -> F -> G\\". # Create linked list a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g remove_duplicates_with_set(a1) # Expected output: \\"A -> B -> C -> D -> F -> G\\" remove_duplicates_without_set(a1) # If the duplicates were reintroduced somehow: # Expected output: \\"A -> B -> C -> D -> F -> G\\" ``` # Note Make sure to handle edge cases such as an empty list or lists with only one element.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates_with_set(head: Node) -> None: if not head: return seen = set() current = head seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_duplicates_without_set(head: Node) -> None: current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"You are working as a software engineer in a company specializing in cryptographic solutions. One of your tasks involves working with modular arithmetic, specifically finding the order of numbers modulo `n`. Your goal is to implement a function `find_order(a, n)` that returns the order of a given positive integer `a` modulo `n`. The order of `a` modulo `n` is defined as the smallest positive integer `k` such that `a^k ≡ 1 (mod n)`. If no such `k` exists, your function should return `-1`. Function Signature: ```python def find_order(a: int, n: int) -> int: ``` Input: - `a` (1 <= a <= 10^9): A positive integer. - `n` (1 <= n <= 10^9): A positive integer. Output: - Returns an integer representing the order of `a` modulo `n`. If no such order exists, return `-1`. Constraints: - Ensure that the function handles invalid inputs gracefully. - Efficiency should be considered; the function should avoid unnecessary computations. Example: ```python assert find_order(2, 3) == 2 assert find_order(3, 7) == 6 assert find_order(2, 5) == 4 assert find_order(10, 15) == -1 # 10 and 15 are not coprime ``` Notes: - The function should print a meaningful message if the values of `a` and `n` are not coprime and return `-1`. - Carefully handle edge cases and ensure the function has optimal performance given the constraints. Implement the `find_order` function based on the specifications above.","solution":"import math def gcd(a, b): Helper function to calculate the greatest common divisor of a and b. while b: a, b = b, a % b return a def find_order(a: int, n: int) -> int: Returns the order of a modulo n, or -1 if no such order exists. if a <= 0 or n <= 0: raise ValueError(\\"Both a and n must be positive integers.\\") if gcd(a, n) != 1: print(f\\"{a} and {n} are not coprime.\\") return -1 order = 1 current = a % n while current != 1: current = (current * a) % n order += 1 if order > n: # Prevent infinite loops in case of error return -1 return order"},{"question":"# Matrix Transformation Implementation Problem Statement Given a matrix, implement a function `transform_matrix` that performs a specified transformation on the matrix. You are required to support the following transformations: 1. `rotate_clockwise`: Rotate the matrix by 90 degrees clockwise. 2. `rotate_counterclockwise`: Rotate the matrix by 90 degrees counterclockwise. 3. `top_left_invert`: A transformation resulting in a pseudo-transpose from the top-left corner. 4. `bottom_left_invert`: A transformation resulting in a pseudo-transpose from the bottom-left corner. Your function should take two arguments: - `matrix` (a list of lists): The original matrix to be transformed. - `transformation` (a string): One of the strings `\'rotate_clockwise\'`, `\'rotate_counterclockwise\'`, `\'top_left_invert\'`, `\'bottom_left_invert\'` indicating the desired transformation. Input - `matrix` : A list of lists containing integers. Assume all inner lists are of the same length. - `transformation`: A string specifying the type of transformation. Output - A list of lists representing the transformed matrix. Constraints - The matrix will have at most dimensions 100 x 100. - Each element in the matrix will be an integer between 1 and 10^4. Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] print(transform_matrix(matrix, \'rotate_clockwise\')) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] print(transform_matrix(matrix, \'rotate_counterclockwise\')) # Output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] print(transform_matrix(matrix, \'top_left_invert\')) # Output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] print(transform_matrix(matrix, \'bottom_left_invert\')) # Output: # [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1] # ] ``` Implementation ```python def transform_matrix(matrix, transformation): if transformation == \'rotate_clockwise\': return rotate_clockwise(matrix) elif transformation == \'rotate_counterclockwise\': return rotate_counterclockwise(matrix) elif transformation == \'top_left_invert\': return top_left_invert(matrix) elif transformation == \'bottom_left_invert\': return bottom_left_invert(matrix) else: raise ValueError(\\"Invalid transformation type\\") # Implement the helper functions as defined in the task description # rotate_clockwise, rotate_counterclockwise, top_left_invert, bottom_left_invert ```","solution":"def transform_matrix(matrix, transformation): if transformation == \'rotate_clockwise\': return rotate_clockwise(matrix) elif transformation == \'rotate_counterclockwise\': return rotate_counterclockwise(matrix) elif transformation == \'top_left_invert\': return top_left_invert(matrix) elif transformation == \'bottom_left_invert\': return bottom_left_invert(matrix) else: raise ValueError(\\"Invalid transformation type\\") def rotate_clockwise(matrix): return [list(row) for row in zip(*matrix[::-1])] def rotate_counterclockwise(matrix): return [list(row) for row in zip(*matrix)][::-1] def top_left_invert(matrix): return [list(row) for row in zip(*matrix)] def bottom_left_invert(matrix): return [list(row) for row in zip(*matrix[::-1])][::-1]"},{"question":"# Graph Traversal Challenge Given a directed graph represented as an adjacency list, your task is to implement both Depth-First Search (DFS) and Breadth-First Search (BFS) traversal methods. Each method should return the list of nodes in the order they are visited starting from a given start node. Input Specifications: * A dictionary representing the graph. Each key is a node (integer) and each value is a list of integers representing the adjacent nodes. * An integer representing the start node. Output Specifications: * A list of integers representing the nodes in the order they are visited by the DFS method. * Another list of integers representing the nodes in the order they are visited by the BFS method. Constraints: * The graph contains at most 1000 nodes. * Nodes are labeled with unique integers. * Start node is guaranteed to be a node in the graph. Example: ``` graph = { 1: [2, 3], 2: [4, 5], 3: [6], 4: [], 5: [6], 6: [] } start = 1 ``` * Expected output for DFS (starting from node 1): `[1, 3, 6, 2, 5, 4]` * Expected output for BFS (starting from node 1): `[1, 2, 3, 4, 5, 6]` Implementation Constraints: * Ensure that nodes are visited in the order provided by the adjacency list. * Use a set to keep track of visited nodes to avoid re-visiting. * For BFS, consider utilizing collections.deque for optimized performance. Write two functions `dfs_traversal` and `bfs_traversal` to achieve the above requirements.","solution":"def dfs_traversal(graph, start): Perform Depth-First Search (DFS) on the given graph starting from the start node. Args: graph: A dictionary representing the adjacency list of the graph. start: An integer representing the start node. Returns: A list of integers representing the nodes in the order they are visited by DFS. visited = set() result = [] def dfs(node): if node not in visited: visited.add(node) result.append(node) for neighbor in graph.get(node, []): dfs(neighbor) dfs(start) return result def bfs_traversal(graph, start): Perform Breadth-First Search (BFS) on the given graph starting from the start node. Args: graph: A dictionary representing the adjacency list of the graph. start: An integer representing the start node. Returns: A list of integers representing the nodes in the order they are visited by BFS. from collections import deque visited = set() queue = deque([start]) result = [] while queue: node = queue.popleft() if node not in visited: visited.add(node) result.append(node) for neighbor in graph.get(node, []): if neighbor not in visited: queue.append(neighbor) return result"},{"question":"# Question: Implement a Custom Pigeonhole Sorting Function Problem Statement You are tasked with implementing a custom version of the Pigeonhole Sort algorithm. The function should sort an array of integers where the number of elements and the range of values in the array are similar. Your goal is to demonstrate deep understanding by handling various scenarios, optimizing where possible, and ensuring the function is both efficient and correct. Function Signature ```python def custom_pigeonhole_sort(arr: List[int]) -> List[int]: pass ``` Input * **arr**: A list of integers (`List[int]`), where 0 <= len(arr) <= 10^5 and -10^4 <= arr[i] <= 10^4 for each `arr[i]`. Output * **Returns** a sorted list of integers (`List[int]`). Constraints * The list can be empty, return an empty list in that case. * The elements can be negative integers. * Take care of the space complexity, optimize wherever possible. Requirements * The implementation should sort the array in-place, if possible, without using additional helper functions outside the main function body. Example ```python print(custom_pigeonhole_sort([8, 3, 2, 7, 4])) # Output: [2, 3, 4, 7, 8] print(custom_pigeonhole_sort([-3, -1, -2, -7, 4, 2, 0])) # Output: [-7, -3, -2, -1, 0, 2, 4] print(custom_pigeonhole_sort([])) # Output: [] print(custom_pigeonhole_sort([10, 1000, 10000])) # Output: [10, 1000, 10000] ``` Hints 1. Consider how you calculate minimum and maximum values, especially with negative numbers involved. 2. Focus on optimizing the method by minimizing space usage without harming readability and correctness.","solution":"from typing import List def custom_pigeonhole_sort(arr: List[int]) -> List[int]: if not arr: return [] min_value = min(arr) max_value = max(arr) size = max_value - min_value + 1 holes = [0] * size for number in arr: holes[number - min_value] += 1 sorted_arr = [] for index, count in enumerate(holes): sorted_arr.extend([index + min_value] * count) return sorted_arr"},{"question":"# Coding Challenge Objective You are asked to implement a modified version of Comb Sort. In addition to sorting the array, your function should also count and return the number of swaps performed during the sorting process. Task Write a function `comb_sort_with_swaps` that takes a list of integers and returns a tuple containing two elements: the sorted list and the number of swaps made. # Function Signature ```python def comb_sort_with_swaps(arr: List[int]) -> Tuple[List[int], int]: ``` Input * `arr`: A list of integers of length (N) (0 <= (N) <= (10^6)). Output * A tuple containing: * A list of integers sorted in ascending order. * An integer representing the number of swaps performed. Constraints * The input list may contain negative integers. * The function should maintain a linearithmic time complexity wherever possible. # Example ```python arr = [5, 3, 1, 7, 2] sorted_arr, swap_count = comb_sort_with_swaps(arr) # sorted_arr should be [1, 2, 3, 5, 7] # swap_count should be the number of swaps performed ``` Performance Requirements * Try to optimize the number of swaps. * Ensure the function performs efficiently on large datasets.","solution":"from typing import List, Tuple def comb_sort_with_swaps(arr: List[int]) -> Tuple[List[int], int]: Implements comb sort on the input list and counts the number of swaps made. Args: arr: List[int] - List of integers to be sorted. Returns: Tuple[List[int], int] - A tuple containing the sorted list and the number of swaps made. def get_next_gap(gap: int) -> int: # Shrink gap by shrink factor of 1.3 new_gap = int(gap / 1.3) if new_gap < 1: return 1 return new_gap n = len(arr) gap = n swaps = 0 sorted = False while gap != 1 or not sorted: gap = get_next_gap(gap) sorted = True for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swaps += 1 sorted = False return arr, swaps"},{"question":"# Fibonacci Sequence Calculation Problem Description You are given three different algorithms to compute the n-th Fibonacci number: recursive, dynamic programming using a list, and iterative. Each of these has different performance characteristics in terms of time and space complexity. Task Given an integer `n`, implement the function `optimized_fibonacci(n)` which should compute the n-th Fibonacci number using the most efficient algorithm among the provided approaches. Function Signature ```python def optimized_fibonacci(n: int) -> int: ``` Input - `n`: an integer (0 ≤ n ≤ 10^6) Output - Return the n-th Fibonacci number. Constraints - `0 ≤ n ≤ 10^6` - The function should be efficient enough to handle the upper limit within a reasonable time frame. # Context The Fibonacci sequence is widely used in various computational problems to illustrate brute force vs. optimized solutions. As you are aware, the provided approaches range from a simple but inefficient recursive version to more optimized dynamic programming and iterative versions. The challenge is to carefully choose and implement the most suitable algorithm to handle very large inputs efficiently. # Example ```python print(optimized_fibonacci(10)) # Should return 55 print(optimized_fibonacci(50)) # Should return 12586269025 print(optimized_fibonacci(100)) # Should return 354224848179261915075 ```","solution":"def optimized_fibonacci(n: int) -> int: Returns the n-th Fibonacci number using an optimized iterative approach. This approach ensures efficient computation for large values of n. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"You are given an integer array `arr` representing stock prices over a period of days. You need to implement a function `max_contiguous_subsequence_sum` that computes the maximum sum of a contiguous subsequence (which includes at least one element) in the array. # Function Signature ```python def max_contiguous_subsequence_sum(arr: List[int]) -> int: ``` # Input - `arr` (List[int]): A list of integers representing stock prices, where `1 <= len(arr) <= 10^6` and `-10^8 <= arr[i] <= 10^8` for all valid `i`. # Output - Returns an integer representing the maximum sum of the contiguous subsequence. # Constraints - The contiguous subsequence must include at least one element from the array. # Example ```python >>> max_contiguous_subsequence_sum([-2, 3, 8, -1, 4]) 14 >>> max_contiguous_subsequence_sum([-1, 1, 0]) 1 >>> max_contiguous_subsequence_sum([-1, -3, -4]) -1 >>> max_contiguous_subsequence_sum([-2, 3, 8, -12, 8, 4]) 12 ``` # Notes - Ensure your code handles large inputs efficiently. - Example explanations: - For the array `[-2, 3, 8, -1, 4]`, the max subsequence sum is `3 + 8 + (-1) + 4 = 14`. - For the array `[-1, -3, -4]`, the max subsequence sum is `-1`. Ensure to validate input correctly and consider edge cases such as arrays with only negative numbers or very large arrays.","solution":"from typing import List def max_contiguous_subsequence_sum(arr: List[int]) -> int: Function to compute the maximum sum of a contiguous subsequence in an array. :param arr: List[int] - List of integers representing stock prices :return: int - The maximum sum of the contiguous subsequence max_current = max_global = arr[0] for i in range(1, len(arr)): max_current = max(arr[i], max_current + arr[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"Search in a Row and Column Wise Sorted Matrix Scenario: You are working as a software engineer at a company that processes large datasets stored in matrix format. Each row and column in these matrices is sorted in a non-decreasing order. Your task is to implement an efficient search algorithm to find a specified key in such matrices. Given the sorted nature, a binary search-like optimization is expected. Objective: Write a Python function `search_in_sorted_matrix(matrix, key)` that takes a 2D list `matrix` and an integer `key`, and returns a tuple containing the zero-based row and column indices of the key if it is found in the matrix. If the key is not found, return `(-1, -1)`. Expected Input and Output: - **Input**: - A 2D list `matrix` of integers where each row and column is sorted in a non-decreasing order. - An integer `key` to be searched for in the matrix. - **Output**: - A tuple (row_index, column_index) if the key is found. - `(-1, -1)` if the key is not found. Constraints: - Assume the matrix will not be empty and will always be a valid nxm 2D list. - The key may or may not be within the provided range of elements in the matrix. Function Signature: ```python def search_in_sorted_matrix(matrix, key): # Your code here ``` Example: ```python # Example 1: matrix= [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] key = 5 Output: (1, 1) # Key found at row index 1, column index 1 # Example 2: matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] key = 20 Output: (-1, -1) # Key not found in the matrix ``` Implement the function `search_in_sorted_matrix(matrix, key)` such that it efficiently finds the key in the given sorted matrix.","solution":"def search_in_sorted_matrix(matrix, key): Searches for the key in a row and column-wise sorted matrix. Args: matrix (List[List[int]]): 2D list where each row and column is sorted in non-decreasing order key (int): The key to be searched for Returns: Tuple[int, int]: The (row_index, column_index) if key is found, otherwise (-1, -1) if not matrix: return -1, -1 rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == key: return row, col elif matrix[row][col] > key: col -= 1 else: row += 1 return -1, -1"},{"question":"You are tasked with implementing a `DoublyLinkedList` class that supports the following operations: 1. **Insertion**: Add a new element to the list at a specified position. 2. **Deletion**: Remove an element from the list at a specified position. 3. **Traversal**: Print the elements of the list from head to tail and tail to head. # Function Signatures Implement the following functions: 1. `def insert(self, value: int, position: int) -> None` * Inserts a new node with the specified `value` at the specified `position` in the list. 2. `def delete(self, position: int) -> None` * Deletes the node at the specified `position` in the list. 3. `def traverse(self) -> List[int]` * Returns a list of elements in the list from head to tail. 4. `def reverse_traverse(self) -> List[int]` * Returns a list of elements in the list from tail to head. # Constraints * Do not use any built-in linked list implementations or collections. * The position is 0-indexed and should be valid (i.e., within the bounds of the list length). * Assume `value` is always an integer. * The list is initially empty and the head and tail should be managed appropriately. # Example Usage ```python dll = DoublyLinkedList() dll.insert(10, 0) # List: 10 dll.insert(20, 1) # List: 10 -> 20 dll.insert(30, 1) # List: 10 -> 30 -> 20 dll.delete(1) # List: 10 -> 20 print(dll.traverse()) # Output: [10, 20] print(dll.reverse_traverse()) # Output: [20, 10] ```","solution":"class Node: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert(self, value: int, position: int) -> None: new_node = Node(value) if position == 0: if self.head is None: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node else: current = self.head for _ in range(position - 1): current = current.next new_node.next = current.next new_node.prev = current if current.next is not None: current.next.prev = new_node current.next = new_node if new_node.next is None: # update tail if new node is at the end self.tail = new_node def delete(self, position: int) -> None: if self.head is None: return if position == 0: if self.head.next is None: # only one node self.head = self.tail = None else: self.head = self.head.next self.head.prev = None else: current = self.head for _ in range(position): current = current.next if current.next is not None: current.next.prev = current.prev if current.prev is not None: current.prev.next = current.next if current == self.tail: # update tail if necessary self.tail = current.prev def traverse(self) -> list: result = [] current = self.head while current: result.append(current.value) current = current.next return result def reverse_traverse(self) -> list: result = [] current = self.tail while current: result.append(current.value) current = current.prev return result"},{"question":"**Context**: Given a stack of integers, you are tasked to implement an algorithm that replaces every value in the stack with two occurrences of that value. Function Specification Write a function `stutter_stack(stack: list) -> list:` in Python. Input Format - A list of integers `stack` representing the original stack where the end of the list is considered the top of the stack. Output Format - Return a list of integers representing the modified stack where every value in the original stack has been replaced with two occurrences of that value. The end of the list should match the top of the stack. Constraints - You can assume that the list will have at most (10^6) elements. - You are not allowed to use additional data structures such as Python\'s `deque`. Example ```python # Example 1 stack = [3, 7, 1, 14, 9] print(stutter_stack(stack)) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] # Example 2 stack = [5] print(stutter_stack(stack)) # Output: [5, 5] # Example 3 stack = [] print(stutter_stack(stack)) # Output: [] # Example 4 stack = [1, 2, 1, 2] print(stutter_stack(stack)) # Output: [1, 1, 2, 2, 1, 1, 2, 2] ``` Constraints - The solution should be optimized for both time and space complexities. - You should handle edge cases such as an empty stack or a stack with a single element gracefully. Performance Requirements - **Time Complexity**: O(n), where n is the number of elements in the stack. - **Space Complexity**: Should be minimized, ideally O(1) auxiliary space but not exceeding O(n). Additional Information - Do not use built-in Python methods that trivialize the challenge. - The purpose is to test your understanding of stack data structure, and your ability to manipulate it directly.","solution":"def stutter_stack(stack): Replaces every value in the stack with two occurrences of that value. Parameters: stack (list): A list of integers representing the stack. Returns: list: A list with each value replaced by two occurrences. # Iterate from the end of the list to the beginning i = len(stack) - 1 while i >= 0: # Insert duplicate elements at the same index stack.insert(i, stack[i]) i -= 1 return stack"},{"question":"# Prim\'s Minimum Spanning Tree You are a part of a team developing a new software system for network design. Your task is to implement an efficient algorithm to compute the minimum cost to connect all nodes in a network, using Prim\'s algorithm. Function Signature ```python def prims_minimum_spanning(graph_used: dict) -> int: pass ``` Input `graph_used`: A dictionary where the keys are nodes and the values are lists of lists. Each inner list contains two elements: the first element is the distance (an integer) to an adjacent node, and the second element is the adjacent node itself. Example: ```python graph = { \'a\': [ [3, \'b\'], [8,\'c\'] ], \'b\': [ [3, \'a\'], [5, \'d\'] ], \'c\': [ [8, \'a\'], [2, \'d\'], [4, \'e\'] ], \'d\': [ [5, \'b\'], [2, \'c\'], [6, \'e\'] ], \'e\': [ [4, \'c\'], [6, \'d\'] ] } ``` Output Return the integer representing the minimum cost to connect all nodes. Constraints * All nodes in the graph are unique, represented as either strings or integers. * The graph is guaranteed to be connected and has no self-loops or multiple edges between the same pairs of nodes. * The graph will have at least 2 nodes and at most 1000 nodes. Example ```python graph = { \'a\': [ [3, \'b\'], [8,\'c\'] ], \'b\': [ [3, \'a\'], [5, \'d\'] ], \'c\': [ [8, \'a\'], [2, \'d\'], [4, \'e\'] ], \'d\': [ [5, \'b\'], [2, \'c\'], [6, \'e\'] ], \'e\': [ [4, \'c\'], [6, \'d\'] ] } assert prims_minimum_spanning(graph) == 14 ``` Notes 1. Handle the priority queue to always extend the MST with the shortest edge to an unvisited node. 2. Ensure to handle nodes and their connections efficiently to meet performance requirements. Implement the function `prims_minimum_spanning` to determine the minimum cost to connect all nodes in the graph.","solution":"import heapq def prims_minimum_spanning(graph_used: dict) -> int: Compute the minimum cost to connect all nodes in the network using Prim\'s algorithm. :param graph_used: A dictionary representing the graph where keys are nodes and values are lists of lists with distances and adjacent nodes. :return: The minimum cost to connect all nodes. if not graph_used: return 0 # Start with an arbitrary starting node start_node = next(iter(graph_used)) # Initialize a priority queue with edges from the start node min_heap = [] for cost, adjacent in graph_used[start_node]: heapq.heappush(min_heap, (cost, start_node, adjacent)) total_cost = 0 visited = set(start_node) while min_heap: cost, from_node, to_node = heapq.heappop(min_heap) if to_node in visited: continue visited.add(to_node) total_cost += cost for edge_cost, adjacent in graph_used[to_node]: if adjacent not in visited: heapq.heappush(min_heap, (edge_cost, to_node, adjacent)) # Check if all nodes are visited if len(visited) != len(graph_used): raise ValueError(\\"The graph is not fully connected.\\") return total_cost"},{"question":"You are given a function `find_order(a, n)` which calculates the smallest positive integer `k` such that `a^k % n = 1` (i.e., the order of `a` modulo `n`). This order exists when the greatest common divisor (gcd) of `a` and `n` is 1. Write an optimized version of the `find_order()` function that reduces the computation time. The improved function should ensure handling of edge cases and performance bottlenecks effectively. # Function Signature ```python def optimized_find_order(a: int, n: int) -> int: Optimized version of find_order to calculate the order of a modulo n. Parameters: a (int): the base integer such that gcd(a, n) = 1. n (int): the modulus integer. Returns: int: the smallest positive integer k such that (a^k) % n = 1, or -1 if no such k exists. # Input * `a` and `n` are integers (1 <= a, n <= 10^6). # Output * The function must return an integer, which is the smallest positive integer `k` such that `a^k % n = 1`, or `-1` if no such `k` exists. # Constraints * Ensure `gcd(a, n) = 1`. If not, return -1. # Examples ```python assert optimized_find_order(2, 7) == 3 assert optimized_find_order(3, 11) == 5 assert optimized_find_order(10, 20) == -1 # Since gcd(10, 20) != 1 assert optimized_find_order(7, 17) == 16 ``` # Notes * Utilize efficient iteration to determine the order, potentially through optimizing power calculations or reducing the iteration range effectively. * Handle edge cases such as when `a = 1`.","solution":"def optimized_find_order(a, n): Optimized version of find_order to calculate the order of a modulo n. Parameters: a (int): the base integer such that gcd(a, n) = 1. n (int): the modulus integer. Returns: int: the smallest positive integer k such that (a^k) % n = 1, or -1 if no such k exists. from math import gcd if gcd(a, n) != 1: return -1 k = 1 current_power = a % n while current_power != 1: current_power = (current_power * a) % n k += 1 return k"},{"question":"You have been given the task to implement a simplified version of the RSA encryption algorithm, focusing on the key components of key generation, encryption, and decryption. Ensure the implementation is secure and correctly handles edge cases. # Function Specifications: 1. `generate_key(k, seed=None)` * **Input**: Integer `k` indicating the number of bits for the modulus ( n ). Optional `seed` for random number generation. * **Output**: Tuple of integers `(n, e, d)` representing the modulus, public exponent, and private exponent, respectively. 2. `encrypt(data, e, n)` * **Input**: Integer `data` to encrypt, and public key components `e` and `n`. * **Output**: Integer representing the encrypted data. 3. `decrypt(data, d, n)` * **Input**: Integer `data` (encrypted) to decrypt, and private key components `d` and `n`. * **Output**: Integer representing the decrypted data. # Key Constraints: 1. The generated primes ( p ) and ( q ) should be of sizes ( frac{k}{2} ) and ( k - frac{k}{2} ) bits, respectively. 2. Ensure ( e ) is coprime with ( phi(n) ). 3. Handle potential errors in modular inverses and large number operations gracefully. # Example: ```python # Example of usage k = 16 # Example size in bits n, e, d = generate_key(k) # Sample data to encrypt data = 42 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert data == decrypted # Should hold true ``` # Notes: - The prime generation within key creation must be efficient and reliable. - Ensure the modular arithmetic operations are efficient, leveraging built-in Python features. - Handle edge cases where the prime number is too small or share factors with ( e ).","solution":"import random from sympy import isprime, mod_inverse from sympy.ntheory.generate import randprime import math def generate_prime(bits, seed=None): if seed is not None: random.seed(seed) lower_bound = 2**(bits - 1) upper_bound = 2**bits - 1 while True: candidate = randprime(lower_bound, upper_bound) if isprime(candidate): return candidate def generate_key(k, seed=None): if k < 16: # Minimum bit length constraint raise ValueError(\\"Bit length too small\\") p_bits = k // 2 q_bits = k - p_bits p = generate_prime(p_bits, seed) q = generate_prime(q_bits, seed) n = p * q phi_n = (p - 1) * (q - 1) e = 65537 # Common choice for e if math.gcd(e, phi_n) != 1: raise ValueError(\\"e is not coprime with phi(n)\\") d = mod_inverse(e, phi_n) return (n, e, d) def encrypt(data, e, n): if data < 0 or data >= n: raise ValueError(\\"Data out of bounds\\") return pow(data, e, n) def decrypt(data, d, n): if data < 0 or data >= n: raise ValueError(\\"Data out of bounds\\") return pow(data, d, n)"},{"question":"The function `combination(n, r)` and `combination_memo(n, r)` are implemented to calculate the number of ways to choose `r` items from `n` items (denoted as nCr). The first implementation uses basic recursion, while the latter uses memoization to optimize the function. # Task Write a function `combination_iterative(n, r)` that calculates the number of combinations (nCr) using an iterative approach and dynamic programming principles. Your solution should be efficient and handle larger inputs compared to the basic recursive approach. # Input * `n` (integer): The total number of items. * `r` (integer): The number of items to choose. # Output * Return an integer representing the number of ways to choose `r` items from `n` items. # Constraints * (0 leq r leq n leq 1000) # Performance Requirement * The function should be able to handle the maximum constraints within a reasonable execution time (ideally (O(n cdot r))). # Example Example 1 Input: `combination_iterative(5, 2)` Output: `10` Explanation: There are 10 ways to choose 2 items from 5 items. Example 2 Input: `combination_iterative(6, 3)` Output: `20` Explanation: There are 20 ways to choose 3 items from 6 items.","solution":"def combination_iterative(n, r): Calculates the number of ways to choose r items from n items using an iterative approach. if r > n: return 0 if r == 0 or r == n: return 1 C = [[0 for _ in range(r + 1)] for _ in range(n + 1)] for i in range(n + 1): for j in range(min(i, r) + 1): if j == 0 or j == i: C[i][j] = 1 else: C[i][j] = C[i-1][j-1] + C[i-1][j] return C[n][r]"},{"question":"# Context You are working as a software developer for a tech company that deals with large-scale networks. Your task is to implement a function that efficiently calculates the shortest paths from a single source node to all other nodes in the network, represented as a weighted graph. # Problem Statement Implement a function `find_shortest_paths` that takes in an adjacency matrix representation of a weighted directed graph and a source node. It should return a list containing the shortest distance from the source node to every other node. # Input * An integer `V` representing the number of vertices in the graph. * A `VxV` matrix `graph` where `graph[i][j]` represents the weight of the edge from vertex `i` to vertex `j`. A value of `0` means no direct edge exists between those vertices. * An integer `src` representing the source vertex. # Output * An array of size `V` where the i-th element represents the shortest distance from the source vertex to vertex `i`. # Constraints 1. `1 <= V <= 50` 2. `0 <= graph[i][j] <= 1000` 3. There are no negative weights in the graph. 4. For any `i`, `graph[i][i] = 0` (no self-loops). # Performance Requirements The solution should run efficiently within the time complexity bounds for the given input size. # Example ```python def find_shortest_paths(V, graph, src): # Your code goes here # Example usage: V = 5 graph = [ [0, 10, 0, 30, 100], [10, 0, 50, 0, 0], [0, 50, 0, 20, 10], [30, 0, 20, 0, 60], [100, 0, 10, 60, 0] ] src = 0 print(find_shortest_paths(V, graph, src)) # Expected Output: [0, 10, 50, 30, 60] ``` # Notes * Ensure to handle edge cases such as disconnected nodes properly. * Use efficient data structures to optimize the algorithm within the provided constraints.","solution":"import heapq def find_shortest_paths(V, graph, src): Calculates the shortest paths from the source node to all other nodes using Dijkstra\'s algorithm. Parameters: V (int): Number of vertices. graph (list of list of int): Adjacency matrix of the graph. src (int): Source vertex. Returns: list: Shortest distances from the source vertex to each vertex. # Distance array to store the shortest distance to each node dist = [float(\'inf\')] * V dist[src] = 0 # Min-heap priority queue to select the vertex with the smallest distance pq = [(0, src)] # (distance, vertex) visited = [False] * V while pq: # Extract the vertex with the smallest distance value current_dist, u = heapq.heappop(pq) if visited[u]: continue visited[u] = True # Iterate over all adjacent vertices of the extracted vertex for v in range(V): if graph[u][v] > 0 and not visited[v]: distance = current_dist + graph[u][v] if distance < dist[v]: dist[v] = distance heapq.heappush(pq, (distance, v)) return dist"},{"question":"Enhanced Knuth-Morris-Pratt Algorithm You are given a function `knuth_morris_pratt` that implements the KMP string matching algorithm. The function finds the start indexes of all occurrences of a pattern in a given text. The existing implementation efficiently handles typical cases, but let\'s explore an enhancement that incorporates an additional feature. **Enhanced Requirement**: Modify the function to not only return the starting indices of the pattern matches but also to return the number of occurrences of each match length, i.e., the lengths of the matched substrings. This additional feature will provide insight into how many times patterns of different lengths occur. # Function Specification You need to modify the given function signature: ```python def enhanced_knuth_morris_pratt(text: Sequence[str], pattern: Sequence[str]) -> (List[int], dict): Args: text: Text to search within as a string pattern: Pattern to search for as a string Returns: A tuple (match_indices, match_lengths) where: - match_indices: List of starting indices where the pattern matches in the text. - match_lengths: A dictionary with keys as the matched lengths and values as the count of occurrences of these lengths. Example: >>> enhanced_knuth_morris_pratt(\'hello there hero!\', \'he\') ([0, 7, 12], {2: 3}) >>> enhanced_knuth_morris_pratt(\'aabbaabbaabb\', \'aa\') ([0, 4, 8], {2: 3}) ``` # Constraints: - The function should maintain O(N + M) time complexity for matching. - Ensure the function is robust enough to handle all edge cases like empty text or pattern, repetitive characters, and patterns longer than text. # Your Task: 1. Modify the given function `knuth_morris_pratt` according to the added requirements. 2. Validate your implementation with the provided examples as well as comprehensive test cases.","solution":"from typing import Sequence, List, Dict, Tuple def enhanced_knuth_morris_pratt(text: Sequence[str], pattern: Sequence[str]) -> Tuple[List[int], Dict[int, int]]: Enhanced Knuth-Morris-Pratt string matching algorithm. Args: text: Text to search within as a string pattern: Pattern to search for as a string Returns: A tuple (match_indices, match_lengths) where: - match_indices: List of starting indices where the pattern matches in the text. - match_lengths: A dictionary with keys as the matched lengths and values as the count of occurrences of these lengths. Example: >>> enhanced_knuth_morris_pratt(\'hello there hero!\', \'he\') ([0, 7, 12], {2: 3}) >>> enhanced_knuth_morris_pratt(\'aabbaabbaabb\', \'aa\') ([0, 4, 8], {2: 3}) if not text or not pattern: return [], {} def build_lps(pattern: Sequence[str]) -> List[int]: Build the longest prefix-suffix (LPS) array. lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = build_lps(pattern) match_indices = [] match_lengths = {} i = 0 # index for text j = 0 # index for pattern while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): match_indices.append(i - j) match_length = len(pattern) if match_length in match_lengths: match_lengths[match_length] += 1 else: match_lengths[match_length] = 1 j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return match_indices, match_lengths"},{"question":"You are given a list of numbers and a commutative function `fn` for aggregation. Your task is to implement a class `SegmentTree` that supports efficient range queries and updates. # Objectives 1. **Build a segment tree** from the given list of numbers. 2. **Support range queries** over the tree using the given commutative function. 3. **Support updates** to the segment tree. # Implementation Details The segment tree should be implemented in a class `SegmentTree` with the following methods: 1. **`__init__(self, arr, fn)`**: Constructor that initializes the segment tree with the array `arr` and the function `fn`. 2. **`update(self, p, v)`**: Update the element at index `p` in the array to `v` and update the segment tree accordingly. 3. **`query(self, l, r)`**: Return the result of applying the function `fn` to the range [l, r] in the array. # Input and Output - **Input**: - A list of integers or tuples (arr). - A commutative function `fn` that combines two elements. - Query or update indices and values. - **Output**: - Result of the range query [l, r]. # Constraints - The function `fn` must be commutative. - Query indices 0 <= l, r < n (where n is the length of the initial array). - Update index 0 <= p < n. # Example ```python # Initialize segment tree with a list and max function mytree = SegmentTree([2, 4, 5, 3, 4], max) print(mytree.query(2, 4)) # Output: 5 (Maximum element in the range 2 to 4) mytree.update(3, 6) print(mytree.query(0, 3)) # Output: 6 (Maximum element in the range 0 to 3) # Initialize segment tree with another list and sum function using a lambda function mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) print(mytree.query(0, 6)) # Output: 64 (Sum of elements in the range 0 to 6) mytree.update(2, -10) print(mytree.query(0, 6)) # Output: 52 (Sum of elements in the range 0 to 6) # Initialize segment tree with a list of tuples and custom sum function mytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1])) print(mytree.query(0, 2)) # Output: (9, 13) (Sum of tuples in the range 0 to 2) mytree.update(2, (-1, 2)) print(mytree.query(0, 2)) # Output: (4, 10) (Sum of tuples in the range 0 to 2) ``` # Notes - Make sure to account for edge cases like single element ranges, updates at the boundaries, and fully spanning range queries. - Ensure your solution is optimized for large input arrays (consider using non-recursive methods for tree updates and queries to avoid stack overflow issues).","solution":"class SegmentTree: def __init__(self, arr, fn): self.n = len(arr) self.fn = fn self.tree = [None] * (2 * self.n) # Build the tree self.build(arr) def build(self, arr): # Insert leaf nodes in tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the rest of the tree by applying the function `fn` for i in range(self.n - 1, 0, -1): self.tree[i] = self.fn(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, p, value): # Update leaf node p += self.n self.tree[p] = value # Update the rest of the tree while p > 1: p //= 2 self.tree[p] = self.fn(self.tree[2 * p], self.tree[2 * p + 1]) def query(self, l, r): res = None l += self.n r += self.n while l <= r: if l % 2 == 1: if res is None: res = self.tree[l] else: res = self.fn(res, self.tree[l]) l += 1 if r % 2 == 0: if res is None: res = self.tree[r] else: res = self.fn(res, self.tree[r]) r -= 1 l //= 2 r //= 2 return res"},{"question":"**Problem Statement**: You have been hired to improve the performance of a sorting system that sorts a list of integers. Currently, they use Quick Sort, which struggles with performance when the input contains many duplicates. You need to implement the `counting_sort` function, which will efficiently solve the sorting problem for their particular use case where the range of integer values is reasonably small. # Requirements: 1. Implement a function `counting_sort(arr: List[int]) -> List[int]`. 2. The function should sort the input list of integers in ascending order. 3. The list may contain negative numbers and zero, but they will fall within the range of -1000 to 1000. 4. Ensure your solution is stable (maintains the relative order of equal elements). # Input: * A list of integers `arr`. # Output: * A sorted list of integers. # Constraints: * -1000 ≤ `arr[i]` ≤ 1000 for 1 ≤ `len(arr)` ≤ 10^6 # Example: **Example 1:** ```python print(counting_sort([6, -3, 4, 2, 6, 3, 2, -4, -2, 0])) ``` * Output: `[-4, -3, -2, 0, 2, 2, 3, 4, 6, 6]` **Example 2:** ```python print(counting_sort([5, 1, 4, 2, 6, 3])) ``` * Output: `[1, 2, 3, 4, 5, 6]` # Edges Cases to Consider: * List has a single element. * List is empty. * All elements in the list are the same. Your implementation should pass all the above-mentioned edge cases and should be optimized for performance.","solution":"def counting_sort(arr): Sorts a list of integers using the Counting Sort algorithm. if not arr: return [] min_val = min(arr) max_val = max(arr) range_of_elements = max_val - min_val + 1 count = [0] * range_of_elements output = [0] * len(arr) for num in arr: count[num - min_val] += 1 for i in range(1, len(count)): count[i] += count[i - 1] for num in reversed(arr): output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return output"},{"question":"# Question: Enhanced RandomizedSet Implementation You are tasked with implementing an enhanced version of the `RandomizedSet` data structure that supports the following operations in average O(1) time complexity: 1. `insert(val)`: Inserts an item `val` to the set if not already present. 2. `remove(val)`: Removes an item `val` from the set if present. 3. `get_random()`: Returns a random element from the current set of elements, with each element having an equal probability of being returned. Additionally, extend the `RandomizedSet` to include an operation `get_random_except(val)` that returns a random element from the set excluding the given value `val`, if it exists in the set. # Requirements * Implement the `RandomizedSet` class with the specified operations. * Ensure all operations (including the new `get_random_except(val)`) are handled in average O(1) time complexity. * Carefully handle edge cases, especially for the scenarios: * When `get_random` or `get_random_except` is called on an empty set. * When attempting to exclude a value that does not exist in the set for `get_random_except`. # Signature ```python class RandomizedSet: def __init__(self): pass def insert(self, val: int) -> bool: pass def remove(self, val: int) -> bool: pass def get_random(self) -> int: pass def get_random_except(self, val: int) -> int: pass ``` # Example ```python rs = RandomizedSet() print(rs.insert(1)) # True print(rs.insert(2)) # True print(rs.insert(3)) # True print(rs.remove(2)) # True print(rs.get_random()) # Randomly returns 1 or 3 print(rs.get_random_except(3)) # Returns 1, since 3 is excluded print(rs.get_random_except(2)) # Throws an error or handles empty set appropriately ``` # Constraints * Operations should be performed in average O(1) time. * The elements inserted in the set will be integers and will not exceed the range of standard integer values.","solution":"import random class RandomizedSet: def __init__(self): self.data = [] self.index_map = {} def insert(self, val: int) -> bool: if val in self.index_map: return False self.index_map[val] = len(self.data) self.data.append(val) return True def remove(self, val: int) -> bool: if val not in self.index_map: return False idx = self.index_map[val] last_element = self.data[-1] self.data[idx] = last_element self.index_map[last_element] = idx self.data.pop() del self.index_map[val] return True def get_random(self) -> int: if not self.data: raise Exception(\\"Set is empty\\") return random.choice(self.data) def get_random_except(self, val: int) -> int: if not self.data: raise Exception(\\"Set is empty\\") if val not in self.index_map: return self.get_random() if len(self.data) == 1: raise Exception(\\"No other elements available\\") while True: candidate = self.get_random() if candidate != val: return candidate"},{"question":"# Question: Implement a Randomized Set You are to implement a data structure that efficiently supports the following operations: 1. **insert(val)**: Inserts an item `val` to the set if it is not already present. 2. **remove(val)**: Removes an item `val` from the set if it is present. 3. **random_element()**: Returns a random element from the current set of elements. Each element must have the same probability of being returned. Below are the required functions and their descriptions: Function: `insert(val: int) -> None` * **Parameters**: - `val` (int): the value to insert. * **Returns**: `None` * **Description**: Inserts the value into the set if it is not already present. Function: `remove(val: int) -> None` * **Parameters**: - `val` (int): the value to remove. * **Returns**: `None` * **Description**: Removes the value from the set if it is present. Function: `random_element() -> int` * **Parameters**: None * **Returns**: An integer that was randomly chosen from the set of current elements. * **Description**: Returns a random element from the set. Each element should have the same probability of being returned. Constraints * All elements are non-negative integers. * Operations will be called in any order. * On average, operations should be performed in O(1) time. * Handle potential edge cases like: - Attempt to remove an element not in the set. - Retrieve a random element from an empty set should be undefined; handle this gracefully. # Example ```python rset = RandomizedSet() rset.insert(1) # Inserts 1 into the set rset.insert(2) # Inserts 2 into the set rset.remove(1) # Removes 1 from the set rset.insert(3) # Inserts 3 into the set assert rset.random_element() in {2, 3} # Randomly returns 2 or 3 ``` Implement the `RandomizedSet` class that satisfies the above requirements.","solution":"import random class RandomizedSet: def __init__(self): Initialize the RandomizedSet object. self.val_to_index = {} self.values = [] def insert(self, val: int) -> None: Inserts an item val to the set if not already present. if val not in self.val_to_index: self.val_to_index[val] = len(self.values) self.values.append(val) def remove(self, val: int) -> None: Removes an item val from the set if present. if val in self.val_to_index: # Move the last element to the place of the element to be removed last_element = self.values[-1] idx_to_remove = self.val_to_index[val] self.values[idx_to_remove] = last_element self.val_to_index[last_element] = idx_to_remove # Remove the last element self.values.pop() del self.val_to_index[val] def random_element(self) -> int: Returns a random element from the set. Returns None if the set is empty. if not self.values: return None return random.choice(self.values)"},{"question":"# Coding Challenge: Implement the Transitive Closure of a Directed Graph You are required to implement a transitive closure algorithm for a directed graph using Depth-First Search (DFS). Given the structure and methods outlined, your task is to develop a class that can capture the graph, add directed edges, and compute the transitive closure matrix. Input Format: 1. An integer, `V` representing the number of vertices in the graph. 2. An integer, `E` representing the number of edges in the graph. 3. `E` pairs of integers representing the directed edges of the graph. Output Format: A 2D list representing the transitive closure matrix of the graph. Requirements: - **Class**: `Graph` - **Method 1**: `__init__(self, vertices)` initializes the graph with `vertices` vertices and sets up necessary structures. - **Method 2**: `add_edge(self, source, target)` adds a directed edge from `source` to `target`. - **Method 3**: `transitive_closure(self)` computes and returns the transitive closure matrix of the graph. Constraints: 1. 1 <= V <= 1000 2. 0 <= E <= 10000 3. 0 <= source, target < V # Example: ```text Input: 4 4 0 1 2 0 3 1 3 2 Output: [[1, 1, 0, 0], [0, 1, 0, 0], [1, 1, 1, 0], [1, 1, 1, 1]] ``` Note: 1. A path exists from vertex `i` to vertex `j` if there is a sequence of edges leading from `i` to `j`. 2. The resulting matrix should have `1` at position `[i][j]` if there is a path from `i` to `j`, otherwise, it should be `0`. 3. The diagonal elements of the matrix should always be `1`, since it\'s possible to reach a vertex from itself.","solution":"class Graph: def __init__(self, vertices): self.vertices = vertices self.graph = [[] for _ in range(vertices)] self.transitiveCl = [[0] * vertices for _ in range(vertices)] def add_edge(self, source, target): self.graph[source].append(target) def transitive_closure(self): def dfs(v, reach): for u in self.graph[v]: if not reach[u]: reach[u] = True dfs(u, reach) for i in range(self.vertices): reach = [False] * self.vertices dfs(i, reach) for j in range(self.vertices): if reach[j] or i == j: self.transitiveCl[i][j] = 1 return self.transitiveCl"},{"question":"# Scenario You are working on a software that requires efficient storage and retrieval of large amounts of data. Given the characteristics and purpose of B-trees, you decide to implement a B-tree to manage this data. # Task Write a function `insert_keys` that inserts multiple keys into a B-tree. You will use the `insert_key` method provided in the B-tree class to insert each key into the tree. # Requirements 1. **Input Format**: * `btree` - An instance of the BTree class. (BTree object) * `keys` - A list of integers, each representing a key to be inserted into the B-tree. (List[int]) 2. **Output Format**: * The function does not need to return any value. The BTree should be modified in place. 3. **Constraints**: * The `keys` list can have up to 10^6 elements. * The keys can be any integer value (positive or negative). # Function Signature ```python def insert_keys(btree: BTree, keys: List[int]) -> None: pass ``` # Example ```python # Initialize B-tree btree = BTree(t_val=3) # List of keys to insert keys = [10, 20, 5, 6, 12, 30, 7, 17] # Function to insert keys into the B-tree insert_keys(btree, keys) # Traverse the tree to show its structure btree.traverse_tree() # Expected Output: [5, 6, 7] 10 [12, 17, 20, 30] ``` # Notes Make sure to appropriately handle all edge cases, such as inserting into an empty tree or scenarios where multiple splits occur. Your implementation should ensure the B-tree remains balanced after each insertion.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf, otherwise False self.keys = [] # List of keys self.children = [] # List of children BTreeNode references class BTree: def __init__(self, t): self.root = BTreeNode(t, True) self.t = t def insert_key(self, k): root = self.root if len(root.keys) == (2 * self.t) - 1: temp = BTreeNode(self.t, False) temp.children.insert(0, root) self.split_child(temp, 0) self.insert_non_full(temp, k) self.root = temp else: self.insert_non_full(root, k) def split_child(self, parent, i): t = self.t child = parent.children[i] new_child = BTreeNode(t, child.leaf) parent.children.insert(i + 1, new_child) parent.keys.insert(i, child.keys[t - 1]) new_child.keys = child.keys[t:(2*t) - 1] child.keys = child.keys[0:t - 1] if not child.leaf: new_child.children = child.children[t:2*t] child.children = child.children[0:t] def insert_non_full(self, node, k): if node.leaf: i = len(node.keys) - 1 node.keys.append(None) # Adding a dummy key at one end while i >= 0 and k < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = k else: i = len(node.keys) - 1 while i >= 0 and k < node.keys[i]: i -= 1 if len(node.children[i + 1].keys) == (2 * self.t) - 1: self.split_child(node, i + 1) if k > node.keys[i + 1]: i += 1 self.insert_non_full(node.children[i + 1], k) def traverse_tree(self): return self._traverse_tree(self.root) def _traverse_tree(self, node): result = [] n = len(node.keys) for i in range(n): if not node.leaf: result.extend(self._traverse_tree(node.children[i])) result.append(node.keys[i]) if not node.leaf: result.extend(self._traverse_tree(node.children[n])) return result def insert_keys(btree, keys): for key in keys: btree.insert_key(key)"},{"question":"# Pancake Sorting & Variant You\'ve been given a list of `n` integers, and you need to sort them using an approach similar to Pancake Sort. However, instead of sorting the entire list, you are asked to sort only the first `k` elements of the list, where `k` is always less than or equal to `n`. Write a function `partial_pancake_sort(arr, k)` that sorts the first `k` elements of the input list `arr` using the Pancake Sorting method and leaves the rest of the list unchanged. Your implementation should maintain the same overall approach of Pancake Sort by repeatedly locating the maximum element in the unsorted portion of the list and using reversals to place it in its correct position. # Constraints - You may assume that `k` is always a positive integer and `k <= len(arr)`. # Input Format - A list `arr` of `n` integers (1 <= n <= 10^3). - An integer `k`, the number of elements to sort within `arr`. # Output Format - The function should return the modified list where the first `k` elements are sorted in ascending order, and the remaining elements remain unchanged. # Example ```python def partial_pancake_sort(arr, k): # Your code here # Example usage: arr = [3, 6, 1, 9, 4, 2] k = 4 print(partial_pancake_sort(arr, k)) # Output: [1, 3, 6, 9, 4, 2] ``` # Your Task Implement the `partial_pancake_sort(arr, k)` function. Ensure it works efficiently for the given constraints and correctly sorts only the first `k` elements.","solution":"def partial_pancake_sort(arr, k): Sorts the first k elements of the list arr using Pancake Sort method. Leaves the rest of the list unchanged. def flip(arr, end): start = 0 while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 for curr_size in range(k, 1, -1): # Find the maximum element in arr[0..curr_size-1] max_index = max(range(curr_size), key=arr.__getitem__) if max_index != curr_size - 1: # Flip the maximum number to the front if it\'s not already at the front flip(arr, max_index) # Flip it to its correct position flip(arr, curr_size - 1) return arr"},{"question":"# Task Implement a function that finds the single unique number in an array, where all other numbers appear exactly twice. Your solution should work in linear runtime and not use extra memory. # Function Signature ```python def find_unique_element(nums: List[int]) -> int: ``` # Input * `nums`: A list of integers where each integer, except one, appears exactly twice. The list will contain at least one integer and at most (10^9) integers. # Output * Returns the unique integer which appears once in the list. # Constraints * The input list will always contain at least one unique element. * The problem guarantees that there is exactly one unique integer. * You must achieve a runtime complexity of O(n). * You must not use extra space for data structures other than simple variables. # Example ```python assert find_unique_element([4, 1, 2, 1, 2]) == 4 assert find_unique_element([2, 2, 1]) == 1 assert find_unique_element([17]) == 17 ``` # Explanation 1. In the first example, `4, 1, 2, 1, 2` - Each number except `4` appears twice. 2. In the second example, `2, 2, 1` - Each number except `1` appears twice. 3. In the third example, `17` - The single element is `17`. # Additional Information * Make sure to handle edge cases like very small arrays and arrays with varying integer values, including negative numbers.","solution":"from typing import List def find_unique_element(nums: List[int]) -> int: Finds the unique element in the list where all other elements appear exactly twice. unique_element = 0 for num in nums: unique_element ^= num return unique_element"},{"question":"You are given a string containing alphabets. Your task is to implement a function that removes any reoccurring character, returning a new string that preserves the order of the first occurrence of each character. Function Signature: ```python def delete_reoccurring_characters(string: str) -> str: ``` Input: * A single string `string` (0 <= len(string) <= 10^5) containing lowercase and/or uppercase alphabets. Output: * Return a new string with only the first occurrence of each character from the input string. Constraints: * The input string may be empty. * The input string can contain both lowercase and uppercase letters. Examples: *Example 1*: ```python Input: \\"abracadabra\\" Output: \\"abrcd\\" ``` *Example 2*: ```python Input: \\"google\\" Output: \\"gole\\" ``` *Example 3*: ```python Input: \\"\\" Output: \\"\\" ``` *Example 4*: ```python Input: \\"AaAaAaAa\\" Output: \\"Aa\\" ``` Explanation: - In the first example, the characters \'a\', \'b\', \'r\', \'c\', and \'d\' appear only once in the order of their first appearance. - In the second example, the characters \'g\', \'o\', \'l\', \'e\' appear in the order of their first appearance. - In the third example, since the input string is empty, the output is also an empty string. - In the fourth example, the characters \'A\' and \'a\' are treated as different unique characters. Performance Requirements: - The function should run in O(n) time complexity, where n is the length of the input string. - The function should use O(n) space complexity, where n is the number of unique characters in the string. Implementation: * Implement the function according to the above specifications, ensuring you handle various edge cases and adhere to performance requirements.","solution":"def delete_reoccurring_characters(string: str) -> str: Returns a new string where all reoccurring characters are removed, preserving only the first occurrence of each character. seen = set() result = [] for char in string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Moving Zeros in an Array You are tasked with implementing a function that takes a list and moves all zeros to the end, while preserving the order of the other elements. Function Signature: ```python def move_zeros(array: list) -> list: ``` # Input: * `array`: A list which can include integers, booleans, and strings. # Output: * Returns a new list with all zeros moved to the end, maintaining the order of other elements. # Constraints: * The function should handle lists with mixed data types. * The function should run in O(n) time complexity. * Consider edge cases such as an empty list, lists with all zeros, or no zeros. # Example: ```python move_zeros([False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"]) # returns: [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0] move_zeros([0, 0, 1]) # returns: [1, 0, 0] move_zeros([0]) # returns: [0] move_zeros([]) # returns: [] move_zeros([False, True, 0, 0, \'Hello\', \'\']) # returns: [False, True, \'Hello\', \'\', 0, 0] ``` # Scenario: You are writing a data cleaning function for a data preprocessing pipeline. The function will help in preparing datasets where zero values need to be moved to the end while maintaining the sequence of other relevant data.","solution":"def move_zeros(array: list) -> list: Moves all zeros to the end of the list while preserving the order of other elements. non_zeros = [x for x in array if x != 0 or isinstance(x, bool)] zeros = [x for x in array if x == 0 and not isinstance(x, bool)] return non_zeros + zeros"},{"question":"You are given a sorted array `arr` of unique integers and an integer `key`. Implement a function `ternary_search` to find the index of `key` in `arr` using the ternary search algorithm. If `key` is not present in the array, the function should return `-1`. # Function Signature ```python def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: ... ``` # Input * An integer `left`, representing the starting index of the array segment to search in. * An integer `right`, representing the ending index of the array segment to search in. * An integer `key`, representing the value to search for. * A list of integers `arr`, representing the sorted array in which the search is to be performed. # Output * Return the index (0-based) of `key` in `arr` if `key` is found. * Return `-1` if `key` is not found. # Constraints * Array `arr` is sorted in ascending order. * All elements in `arr` are unique. * The array size will be in the range `[1, 10^6]`. * `key` and array elements will be integers in the range `[-10^9, 10^9]`. # Example ```python # Example 1 arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] key = 5 left = 0 right = len(arr) - 1 print(ternary_search(left, right, key, arr)) # Output: 4 # Example 2 arr = [1, 3, 5, 7, 9, 11, 13, 15] key = 8 left = 0 right = len(arr) - 1 print(ternary_search(left, right, key, arr)) # Output: -1 ``` # Notes 1. Your solution should be efficient in terms of time complexity, ideally O(log3(N)). 2. Consider edge cases such as very small arrays or when the key is not present in the array. 3. Writing clean and readable code will be considered in the evaluation.","solution":"from typing import List def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: while left <= right: mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"Modular Inverse Verification Context You are part of a cryptographic system development team that relies heavily on modular arithmetic and number theory. To ensure robust implementations, you need to verify that given numbers produce the correct modular inverse results as part of the system\'s integrity checks. Task Implement a function `verify_modular_inverse(a: int, m: int, x: int) -> bool` that verifies if the integer `x` is indeed the modular inverse of `a` modulo `m`. Function Signature ```python def verify_modular_inverse(a: int, m: int, x: int) -> bool: Verifies if x is the modular inverse of a modulo m. Args: a (int): An integer for which we want to find the modular inverse. m (int): The modulus. x (int): The proposed modular inverse to verify. Returns: bool: True if x is the modular inverse of a modulo m, False otherwise. pass ``` Expected Input and Output * **Input**: - Integers `a`, `m`, and `x` such that (1 leq a, m, x leq 10^9). - Ensure that `a` and `m` are coprime. * **Output**: - Boolean `True` if `x` is the modular inverse of `a` modulo `m`. - Boolean `False` otherwise. Constraints * Perform necessary checks for validity of inputs (e.g., `a` and `m` must be coprime). * Ensure the function runs efficiently for large values of `a`, `m`, and `x`. Performance Requirements Ensure the solution runs in (O(log min(a, m))) time complexity. Example ```python assert verify_modular_inverse(3, 11, 4) == True assert verify_modular_inverse(10, 17, 12) == True assert verify_modular_inverse(10, 17, 5) == False ``` Implement this function to verify the modular inverses correctly.","solution":"def verify_modular_inverse(a: int, m: int, x: int) -> bool: Verifies if x is the modular inverse of a modulo m. Args: a (int): An integer for which we want to find the modular inverse. m (int): The modulus. x (int): The proposed modular inverse to verify. Returns: bool: True if x is the modular inverse of a modulo m, False otherwise. if (a * x) % m == 1: return True return False"},{"question":"You are provided with a set of distinct integers. Your task is to write a function that generates all possible subsets (the power set) of the given set and returns them without any duplicates. Function Signature ```python def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: pass ``` # Input * `nums`: A list of distinct integers (`List[int]`). # Output * A set of tuples, where each tuple represents a subset of `nums`. Example ```python assert generate_subsets([1, 2, 3]) == { (), (1,), (2,), (3,), (1, 2,), (1, 3,), (2, 3,), (1, 2, 3,) } assert generate_subsets([4, 5]) == { (), (4,), (5,), (4, 5,) } assert generate_subsets([]) == { () } ``` # Constraints * Each element of `nums` is a distinct integer. * The number of elements in `nums` will not exceed 20. * You must consider the time and space complexity of your solution. # Guidelines 1. Utilize bitwise operations to generate indices representing the presence or absence of each element. 2. Iterate through all possible binary masks from `0` to `2^n - 1`, constructing subsets based on the binary representation. 3. Add each constructed subset to a set to ensure all subsets are unique. # Performance Requirements * Your solution should run efficiently for `n` up to 20. # Edge Cases * Empty input list should return a set containing just the empty tuple. * Single-element list should return the element itself and the empty set as subsets.","solution":"from typing import List, Set, Tuple def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: Generates all possible subsets (the power set) of the given list of distinct integers. power_set = set() n = len(nums) # Loop over all possible subsets represented by bitmasks for i in range(2**n): subset = [] for j in range(n): if i & (1 << j): subset.append(nums[j]) power_set.add(tuple(subset)) return power_set"},{"question":"# Diffie-Hellman Key Exchange Implementation with Enhanced Security **Objective**: Implement a function to securely perform Diffie-Hellman Key Exchange algorithm and return the shared secret key, while ensuring appropriate validation and error handling mechanisms. # Problem Statement: Design and implement the function `secure_diffie_hellman_key_exchange` which employs the Diffie-Hellman key exchange algorithm to securely share a secret key. You should ensure all input parameters are correctly validated to prevent misuse. # Function Signature: ```python def secure_diffie_hellman_key_exchange(a: int, p: int) -> int: pass ``` # Inputs: - **a** (integer): A primitive root mod `p`. - **p** (integer): A large prime number. # Constraints: 1. `1 < a < p` 2. `a` must be a primitive root of `p`. 3. `p` must be a prime number. # Outputs: - **Secret Key** (integer): The shared secret key computed using the Diffie-Hellman exchange method. # Implementation Details & Requirements: 1. Perform input validation to ensure `p` is a prime number and `a` is a primitive root of `p`. 2. If validation fails, raise a custom exception or return a meaningful error message. 3. Use the provided partial algorithms, prime checking, Euler’s Totient, order finding, and key computation to perform the exchange. 4. The function needs to validate intermediate results to ensure the correctness of the exchange process. 5. Implement detailed error handling and testing to cover edge cases. # Example: ```python # Assume a = 2, p = 11 (11 is prime, 2 is a primitive root of 11) secure_diffie_hellman_key_exchange(2, 11) # Expected output: Returns the shared secret key (will vary based on internal random keys used by Alice and Bob). ``` # Hints: - Ensure `p` is prime using the `prime_check` function. - Verify `a` is a primitive root of `p` by leveraging Euler’s Totient function and order finding. - Look into secure random number generation for keys. # Bonus: Enhance the function to log intermediate values and steps taken during the exchange process when an optional debugging parameter is provided.","solution":"import random def is_prime(n): Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def gcd(a, b): while b: a, b = b, a % b return a def find_primitive_root(p): Find a primitive root for prime p if not is_prime(p): raise ValueError(f\\"{p} is not prime\\") # Euler\'s totient function φ(p), for prime number p it\'s (p-1) phi = p - 1 factors = set() n = phi i = 2 while i * i <= n: if n % i == 0: factors.add(i) while n % i == 0: n //= i i += 1 if n > 1: factors.add(n) for g in range(2, p): if all(pow(g, phi // factor, p) != 1 for factor in factors): return g return -1 # No primitive root found, theoretically should never happen for prime p def secure_diffie_hellman_key_exchange(a: int, p: int) -> int: Securely performs the Diffie-Hellman key exchange and returns the shared secret key. if not (1 < a < p): raise ValueError(\\"a must be greater than 1 and less than p\\") if not is_prime(p): raise ValueError(\\"p must be a prime number\\") if find_primitive_root(p) != a: raise ValueError(f\\"a ({a}) must be a primitive root of p ({p})\\") # Step 1: Alice chooses a secret integer a alice_private_key = random.randint(1, p-1) alice_public_key = pow(a, alice_private_key, p) # Step 2: Bob chooses a secret integer b bob_private_key = random.randint(1, p-1) bob_public_key = pow(a, bob_private_key, p) # Step 3: Exchange public keys and calculate the shared secret key shared_secret_key_for_alice = pow(bob_public_key, alice_private_key, p) shared_secret_key_for_bob = pow(alice_public_key, bob_private_key, p) assert shared_secret_key_for_alice == shared_secret_key_for_bob, \\"Key exchange failed\\" return shared_secret_key_for_alice"},{"question":"# Question **Bogo Sort Bracket Organizer** You are the coordinator of a sports event. The order of the participants in a knockout stage bracket is crucial. Luckily, you have heard of a method called Bogo Sort for organizing participants, just for fun! Write a function, `bogo_sort_bracket`, that uses Bogo Sort to organize participants in a `participants_list` in ascending order. Given a list of integers representing the skill ratings of various participants, sort them using the Bogo Sort algorithm. **Function Signature**: ```python def bogo_sort_bracket(participants_list): # your code here pass ``` **Input**: * `participants_list` (List[int]): A list of integers representing the skill levels of the participants in the bracket. Each integer is unique, and the list can have a maximum of 10 elements. **Output**: * The function returns a list of integers sorted in ascending order. **Constraints**: * The list will have at most 10 elements. **Example**: ```python participants_list = [4, 1, 3, 2] assert bogo_sort_bracket(participants_list) == [1, 2, 3, 4] participants_list = [10] assert bogo_sort_bracket(participants_list) == [10] participants_list = [] assert bogo_sort_bracket(participants_list) == [] ``` **Performance Requirements**: * Ensure the function terminates for the input constraints. **Scenario**: Imagine a fun sports event where you want to demonstrate how inefficient Bogo Sort is, and despite its inefficiency, sometimes it might just work on very small lists. Use this function to acquaint yourself with the types of situations and challenges in sorting algorithms, however impractical Bogo Sort may be in real-world scenarios.","solution":"import random def is_sorted(arr): for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def bogo_sort_bracket(participants_list): Sorts the list using the Bogo Sort algorithm. :param participants_list: List of integers representing the skill ratings :return: Sorted list of integers while not is_sorted(participants_list): random.shuffle(participants_list) return participants_list"},{"question":"# Context: Stacks are a fundamental data structure used extensively in algorithms and system software like compilers, operating systems, and even everyday applications like text editors. Two common ways to implement a stack are through dynamic arrays and linked lists. Both have their own advantages and limitations in terms of memory usage and operation efficiency. # Problem Statement: You are required to implement a mixed stack that can switch between array-based and linked list-based implementations dynamically based on the number of elements currently in the stack. This is to combine the fast access of arrays for smaller sizes with the flexible memory usage of linked lists for larger sizes. # Task: Write a Python class `MixedStack` that utilizes both `ArrayStack` and `LinkedListStack` to achieve dynamic resizing and efficient memory usage. Your class should inherit from the `AbstractStack` class and maintain the same interface. Follow the conditions below: 1. Start with an `ArrayStack` with a default initial size of 10. 2. When the number of elements exceeds twice the current size, switch to `LinkedListStack`. 3. If the number of elements in the stack drops below the initial size, switch back to `ArrayStack`. # Implementation Requirements: - Define your `MixedStack` class. - Provide implementations for `push`, `pop`, and `peek` methods. - Implement additional methods to handle the transitions between `ArrayStack` and `LinkedListStack`. # Input & Output: - There are no specific inputs as the focus is to implement a class. - Ensure to handle dynamic transitions during operations. # Constraints: - The transitions between array and linked list should not lose any elements. - All operations should maintain their expected time complexities according to their respective underlying data structures. # Example: ```python # Example usage of MixedStack stack = MixedStack() for i in range(30): stack.push(i) print(stack.pop()) # Should print 29 (LIFO) stack.push(100) print(stack.peek()) # Should print 100 ``` # Function Signature: ```python class MixedStack(AbstractStack): def __init__(self): pass def push(self, value): pass def pop(self): pass def peek(self): pass ```","solution":"class AbstractStack: def push(self, value): raise NotImplementedError def pop(self): raise NotImplementedError def peek(self): raise NotImplementedError class ArrayStack(AbstractStack): def __init__(self, initial_size=10): self.stack = [None] * initial_size self.size = 0 def push(self, value): if self.size >= len(self.stack): self.stack.extend([None] * len(self.stack)) # Resize the array self.stack[self.size] = value self.size += 1 def pop(self): if self.size == 0: raise IndexError(\\"Pop from empty stack\\") self.size -= 1 return self.stack[self.size] def peek(self): if self.size == 0: raise IndexError(\\"Peek from empty stack\\") return self.stack[self.size - 1] def __len__(self): return self.size class Node: def __init__(self, value): self.value = value self.next = None class LinkedListStack(AbstractStack): def __init__(self): self.head = None self.size = 0 def push(self, value): new_node = Node(value) new_node.next = self.head self.head = new_node self.size += 1 def pop(self): if self.head is None: raise IndexError(\\"Pop from empty stack\\") value = self.head.value self.head = self.head.next self.size -= 1 return value def peek(self): if self.head is None: raise IndexError(\\"Peek from empty stack\\") return self.head.value def __len__(self): return self.size class MixedStack(AbstractStack): def __init__(self, initial_size=10): self.initial_size = initial_size self.stack = ArrayStack(initial_size) def switch_to_linked_list(self): new_stack = LinkedListStack() while len(self.stack) > 0: new_stack.push(self.stack.pop()) self.stack = new_stack def switch_to_array(self): new_stack = ArrayStack(self.initial_size) buffer = [] while len(self.stack) > 0: buffer.append(self.stack.pop()) for value in reversed(buffer): new_stack.push(value) self.stack = new_stack def push(self, value): self.stack.push(value) if isinstance(self.stack, ArrayStack) and len(self.stack) > 2 * self.initial_size: self.switch_to_linked_list() def pop(self): value = self.stack.pop() if isinstance(self.stack, LinkedListStack) and len(self.stack) < self.initial_size: self.switch_to_array() return value def peek(self): return self.stack.peek()"},{"question":"# Question **Scenario**: As a database optimization specialist, you are often required to locate records using search algorithms quickly. One of your clients provided you with a large, sorted dataset and asked you to optimize the searching routine. You decide to use the interpolation search algorithm due to its efficiency in such scenarios. Task: Write a function `improved_interpolation_search` that takes a sorted list of integers and a search key, then returns the index of the search key if found, else -1. Your function should include considerations for edge cases including but not limited to empty lists, out-of-bound search keys, uniformly distributed data, and addressing any potential performance bottlenecks. Function Signature: ```python from typing import List def improved_interpolation_search(array: List[int], search_key: int) -> int: pass ``` Inputs: 1. `array` (List[int]): A sorted list of integers. 2. `search_key` (int): The integer value to search within the array. Outputs: - Return the index of the `search_key` if found within the array. Otherwise, return -1. Constraints: - The list is sorted in increasing order. - The integers in the list can include both positive and negative values. - The list can be large, containing up to (10^5) elements. Example: ```python >>> improved_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) 2 >>> improved_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) -1 >>> improved_interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) -1 >>> improved_interpolation_search([], 10) -1 ``` Performance Requirement: - Aim for optimal average-case time complexity and ensure it handles edge cases efficiently. Notes: - Consider incorporating checks within your function to handle edge cases that typically cause potential errors or inefficiencies. - You are encouraged to think about potential optimizations that can make your search more robust against non-uniform distributed data.","solution":"from typing import List def improved_interpolation_search(array: List[int], search_key: int) -> int: if not array: return -1 low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 pos = low + ((search_key - array[low]) * (high - low) // (array[high] - array[low])) if pos < low or pos > high: return -1 if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Coding Task: Strobogrammatic Number Checker Objective: Implement a function to determine if a given number (as a string) is strobogrammatic. Function Signature: ```python def is_strobogrammatic_number(num: str) -> bool: Determines if a number is strobogrammatic. :param num: str : The input number represented as a string. :return: bool : True if the number is strobogrammatic, False otherwise. ``` Input: * The input parameter `num` will be a string of length n (0 ≤ n ≤ 10^4) consisting of digits only (\'0\'-\'9\'). Output: * Return a boolean value: `True` if the number is strobogrammatic, `False` otherwise. Constraints: * You must implement the function efficiently to handle large inputs up to 10^4 characters. Performance Requirements: * The function should run in O(n) time where n is the length of the input string. * The function should use O(1) additional space. Example: ```python print(is_strobogrammatic_number(\\"69\\")) # Output: True print(is_strobogrammatic_number(\\"88\\")) # Output: True print(is_strobogrammatic_number(\\"962\\")) # Output: False print(is_strobogrammatic_number(\\"\\")) # Output: True ``` Hints: 1. Use a two-pointer approach to validate characters from both ends of the string. 2. Keep track of valid strobogrammatic character pairs. Scenario: Imagine you\'re developing software for an LED display system that needs to ensure certain critical numbers look the same if the display is accidentally rotated 180 degrees. This function will be a crucial part of the validation mechanism to ensure numbers remain readable and recognizable.","solution":"def is_strobogrammatic_number(num: str) -> bool: Determines if a number is strobogrammatic. :param num: str : The input number represented as a string. :return: bool : True if the number is strobogrammatic, False otherwise. strobogrammatic_pairs = {\'0\': \'0\', \'1\': \'1\', \'6\': \'9\', \'8\': \'8\', \'9\': \'6\'} left, right = 0, len(num) - 1 while left <= right: if num[left] not in strobogrammatic_pairs or num[right] not in strobogrammatic_pairs: return False if strobogrammatic_pairs[num[left]] != num[right]: return False left += 1 right -= 1 return True"},{"question":"Given an unsorted list of integers, implement the Comb Sort algorithm to sort the list in ascending order. Your implementation should be efficient in terms of both time and space complexity. Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: ``` Input * `arr`: A list of integers, with 1 ≤ len(arr) ≤ 1000. Output * A list of integers sorted in ascending order. Constraints * The input list will have all integers in the range `-10^5` to `10^5`. Performance Requirements * Your solution should aim for O(N log N) average-case time complexity and O(1) space complexity. # Examples ```python # Example 1 input: [5, 3, 8, 4, 2] output: [2, 3, 4, 5, 8] # Example 2 input: [0, -1, -10, 10, 20, 5, -5] output: [-10, -5, -1, 0, 5, 10, 20] # Example 3 input: [1, 2, 3, 4, 5] output: [1, 2, 3, 4, 5] ``` Edge Cases to Consider * An already sorted list. * A list where all elements are the same. * Lists with extreme values like very large and very small integers. Implementation Challenge While implementing the algorithm, consider the following: 1. Optimal choice of the gap shrink factor. 2. Correct handling of indices to avoid out-of-bounds errors. 3. Efficient detection of whether the list is sorted before the gap becomes 1. Implement the function `comb_sort` using the provided signature and test it with the above example inputs to ensure its correctness.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Comb Sort algorithm. def get_next_gap(gap): # Shrink factor 1.3 is commonly used for comb sort gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Counting \'1\' Bits in a Binary Representation **Scenario**: You are working with a team that is optimizing a network security tool. This tool requires frequent analysis of binary representations of IP addresses to count the number of \'1\' bits. Your task is to write a function that efficiently counts the number of \'1\' bits in an unsigned integer using Brian Kernighan\'s algorithm. **Objective**: Write a function to count the number of \'1\' bits in the binary representation of a given unsigned integer. **Function Signature**: ```python def count_ones(n: int) -> int: ``` **Input**: - `n` (int): An unsigned integer (0 ≤ n < 2^32). **Output**: - (int): The number of \'1\' bits in the binary representation of `n`. **Constraints**: - You must use an iterative approach. - You must handle edge cases effectively. **Performance Requirement**: - The function should have a time complexity of O(k) where k is the number of \'1\' bits in the binary representation of `n`. - Space complexity should be O(1). **Example**: ```python # Example 1 n = 11 # Binary: 1011 assert count_ones(n) == 3 # Example 2 n = 128 # Binary: 10000000 assert count_ones(n) == 1 # Example 3 n = 4294967295 # Binary: 11111111111111111111111111111111 assert count_ones(n) == 32 ```","solution":"def count_ones(n: int) -> int: Counts the number of \'1\' bits in the binary representation of an unsigned integer n using Brian Kernighan\'s algorithm. Parameters: n (int): The unsigned integer whose \'1\' bits are to be counted. Returns: int: The number of \'1\' bits in the binary representation of n. count = 0 while n: n &= (n - 1) # Drops the lowest set bit count += 1 return count"},{"question":"# FFT Algorithm Application in Signal Processing Scenario You are developing a signal processing tool that needs to analyze various signals captured over a period. One key functionality is to transform these time-domain signals to the frequency domain using the Fast Fourier Transform (FFT). Problem Statement Implement a Python function `compute_fft` based on the Cooley-Tukey FFT algorithm, which takes a list of complex numbers (of size N, where N is a power of 2) and returns their DFT in the frequency domain. Requirements - **Function Signature**: `def compute_fft(data: List[complex]) -> List[complex]:` - **Input Format**: A list of complex numbers (length N, where N is a power of 2). - **Output Format**: A list of complex numbers representing the DFT of the input. - **Constraints**: * Ensure the implementation is efficient with a time complexity of O(N log N). * You must use a recursive approach (similar to the Cooley-Tukey algorithm). Example - **Input**: `[2.0+2j, 1.0+3j, 3.0+1j, 2.0+2j]` - **Output**: `[8+8j, 2j, 2-2j, -2+0j]` Performance Requirements Your solution should handle inputs up to size 2^20 efficiently. # Notes * You must handle the input size constraint (N is a power of 2) within your implementation. * Consider special cases like single-element arrays effectively. * You are encouraged to avoid redundant computations to ensure efficiency.","solution":"import cmath def compute_fft(data): Compute the Fast Fourier Transform of a list of complex numbers. :param data: List of complex numbers (length N, where N is a power of 2). :return: List of complex numbers representing the DFT of the input. # Ensure the length of the data is a power of 2 def is_power_of_2(n): return (n & (n - 1) == 0) and n != 0 N = len(data) if not is_power_of_2(N): raise ValueError(\\"The length of the data must be a power of 2.\\") # Base case if N <= 1: return data # Recursive case: divide even_part = compute_fft(data[0::2]) odd_part = compute_fft(data[1::2]) # Combine step T = [cmath.exp(-2j * cmath.pi * k / N) * odd_part[k] for k in range(N // 2)] return [even_part[k] + T[k] for k in range(N // 2)] + [even_part[k] - T[k] for k in range(N // 2)]"},{"question":"You are given a sorted array of unique integers. Your task is to take this array and summarize the contiguous ranges of numbers within it. Your solution should be efficient and handle various edge cases effectively. Function Signature: ```python def summarize_ranges(array: List[int]) -> List[str]: pass ``` Input: * A list of sorted, unique integers `array` (1 ≤ array.length ≤ 1000, -10^4 ≤ array[i] ≤ 10^4). Output: * A list of strings, where each string represents a range. * Individual numbers should be represented as \\"n\\". * Ranges should be represented as \\"a-b\\". # Examples: 1. `summarize_ranges([0, 1, 2, 4, 5, 7])` should return `[\\"0-2\\", \\"4-5\\", \\"7\\"]`. 2. `summarize_ranges([5, 6, 7, 9, 10, 11, 13])` should return `[\\"5-7\\", \\"9-11\\", \\"13\\"]`. 3. `summarize_ranges([-10, -9, -8, -6, -4, -3, -1, 0, 1, 2])` should return `[\\"-10--8\\", \\"-6\\", \\"-4--3\\", \\"-1-2\\"]`. Constraints: * Ensure the function handles edge cases properly (e.g., single element arrays). * Strive for a time complexity of O(n) and space complexity of O(n). Notes: - The solution should handle small and large arrays within the given constraints efficiently. - Pay special attention to the input types and ensure to validate the type and constraints before processing. Implement the function `summarize_ranges` that meets the requirements described.","solution":"def summarize_ranges(array): if not array: return [] ranges = [] start = end = array[0] for i in range(1, len(array)): if array[i] == end + 1: end = array[i] else: if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") start = end = array[i] if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") return ranges"},{"question":"# Unique Paths: Wayfinding in a Grid Scenario You are tasked with developing a robust navigation system for a grid-based environment. Specifically, you need to calculate the number of unique ways to traverse from the northwest corner of a grid to its southeast corner, moving only in right or downward directions. Objective Write a function `count_unique_paths(m, n)` that returns the number of distinct paths from the top-left to the bottom-right of an `m` x `n` grid. Function Signature ```python def count_unique_paths(m: int, n: int) -> int: ``` Inputs * `m` (int): The number of rows in the grid. (1 <= m <= 100) * `n` (int): The number of columns in the grid. (1 <= n <= 100) Outputs * Returns an integer representing the number of unique paths. Constraints * Ensure your solution is efficient with respect to both time and space. * Take care of edge cases like grids with only one row or column. Example ```python assert count_unique_paths(3, 2) == 3 assert count_unique_paths(7, 3) == 28 assert count_unique_paths(1, 1) == 1 ``` Explanation - For a 3x2 grid, there are 3 ways to traverse: * Right -> Right -> Down * Right -> Down -> Right * Down -> Right -> Right Note - Valid approaches should not exceed O(m * n) time complexity. - Aim for optimal space usage.","solution":"def count_unique_paths(m, n): Calculate the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid, moving only right and downward. if m == 1 or n == 1: return 1 dp = [[0] * n for _ in range(m)] for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"Context You have been hired by a technology firm that works with specialized write-once memory. Due to the physical constraints of these memory storage solutions, minimizing the number of write operations is paramount. Your task is to implement an in-place sorting algorithm that ensures the array is sorted while performing the minimum possible write operations. Task Implement the `cycle_sort` algorithm for a given list of integers. Your solution should ensure that each element is written into its correct position in the final sorted array with the minimum number of writes. Function Signature ```python def cycle_sort(arr: list[int]) -> list[int]: ``` Input - `arr` (List of integers): A list of `n` integers where `n` is the number of elements (0 ≤ n ≤ 10^6). Output - A list of integers sorted in non-decreasing order. Constraints - You must sort the list in-place. No additional lists (other than the input list) should be used for sorting. - Minimize the number of write operations to the input list. Example ```python # Example 1 input: [4, 3, 2, 1] output: [1, 2, 3, 4] # Example 2 input: [1, 4, 3, 2, 5] output: [1, 2, 3, 4, 5] # Example 3 input: [5, 1, 4, 4, 2] output: [1, 2, 4, 4, 5] ``` Notes - You are not allowed to use built-in sorting functions. - Your solution should be efficient in terms of both time and space complexity given the constraints. Evaluation Criteria - Correctness: Does the function return the expected sorted list for various test cases? - Efficiency: Does the function avoid unnecessary write operations and use minimal auxiliary space? - Edge Case Handling: Does the function correctly handle edge cases such as empty lists or lists with repeated elements? Create a solution that demonstrates an understanding of cycle sort, and ensure thorough testing with various edge cases and performance scenarios.","solution":"def cycle_sort(arr: list[int]) -> list[int]: Sorts an array in-place using the Cycle Sort algorithm, minimizing the number of write operations. writes = 0 # Go through the array to place each element in its correct position for cycle_start in range(len(arr) - 1): item = arr[cycle_start] # Find where to put the item pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 # If the item is already in the correct position, continue if pos == cycle_start: continue # Skip duplicates while item == arr[pos]: pos += 1 # Swap the item with the target position if pos != cycle_start: arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 if item != arr[pos]: arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"# Plus One for Large Numbers **Objective**: Implement a function that adds one to a non-negative number represented as an array of its digits. **Scenario**: Imagine you are building a simple software that performs basic arithmetic operations on very large integers. You can\'t use built-in integer types because of potential overflow issues. Instead, you represent numbers as arrays where each element is a digit, and you need to implement adding one to such a number. # Function Signature ```python def plus_one(digits: List[int]) -> List[int]: ``` # Input * `digits`: A list of non-negative single-digit integers representing a number. It is guaranteed that each element is between 0 and 9, and the list is non-empty. # Output * Returns a new list of integers representing the number obtained by adding one. # Constraints 1. The input list will not be empty. 2. Each element of the list will be a digit (i.e., 0 through 9). # Example ```python print(plus_one([1, 2, 3])) # Output: [1, 2, 4] print(plus_one([9, 9, 9])) # Output: [1, 0, 0, 0] print(plus_one([0])) # Output: [1] ``` # Requirements * **Time Complexity**: O(n) * **Space Complexity**: O(1) if possible, otherwise O(n) # Notes * Ensure your implementation can handle the largest possible number that fits within the provided constraints. * Consider edge cases where the carry-over creates a new leading digit.","solution":"from typing import List def plus_one(digits: List[int]) -> List[int]: Adds one to a number represented as a list of digits. # Start from the end of the list n = len(digits) for i in range(n - 1, -1, -1): if digits[i] == 9: digits[i] = 0 # set to 0 and carry over else: digits[i] += 1 return digits # no carry over needed # If we exit the loop, that means we had a carry from the most significant digit return [1] + digits"},{"question":"# Question: Efficient Sorted Array Insert **Background:** You are working on a software project that requires frequently inserting elements into a sorted list. To make this process efficient, you need to determine the correct position to insert an element without disturbing the order of the list. **Task:** Write a function `insert_position` that takes in two parameters: a sorted list of unique integers and a target integer. This function should return the index where the target integer would be inserted in the list to maintain the sorted order. **Function Signature:** ```python def insert_position(array: List[int], target: int) -> int: pass ``` **Input:** - `array` (List[int]): A sorted list of unique integers. - `target` (int): The integer value to be inserted. **Output:** - (int): The index position at which the target integer should be inserted. **Constraints:** - The given array can have a length of up to 10^5. - The elements in the array are unique integers. - The target integer can be any integer value. **Performance Requirement:** - The solution must operate in O(log n) time complexity. # Example: ```python array = [1, 3, 5, 6] target = 5 assert insert_position(array, target) == 2 array = [1, 3, 5, 6] target = 2 assert insert_position(array, target) == 1 array = [1, 3, 5, 6] target = 7 assert insert_position(array, target) == 4 array = [1, 3, 5, 6] target = 0 assert insert_position(array, target) == 0 ``` **Explanation:** - In the first example, 5 is found at index 2. - In the second example, 2 should be inserted at index 1 to maintain order. - In the third example, 7 should be inserted at the end, index 4, to maintain order. - In the fourth example, 0 should be inserted at the beginning, index 0, to maintain order. Ensure your solution correctly handles various edge cases, including inserting at the beginning or end of the array.","solution":"from typing import List def insert_position(array: List[int], target: int) -> int: Finds the correct position in the array where the target should be inserted to maintain sorted order. Uses binary search to achieve O(log n) time complexity. left, right = 0, len(array) while left < right: mid = (left + right) // 2 if array[mid] < target: left = mid + 1 else: right = mid return left"},{"question":"# Scenario In a digital library system, book IDs are stored as large integers in an array. The library management system requires these IDs to be sorted for efficient cataloging and searching. # Problem Statement Write a function `library_sort(ids: List[int]) -> List[int]` that takes a list of book IDs as input and returns a sorted list using the radix sort algorithm. You should assume that each ID is a non-negative integer. # Input - `ids`: A list of non-negative integers representing book IDs. (0 ≤ `len(ids)` ≤ 10^6, 0 ≤ `ids[i]` ≤ 10^9) # Output - A sorted list of integers. # Constraints - Ensure the algorithm runs in a reasonable time frame even for large inputs (up to 10^6 elements). - The implementation should handle edge cases such as an empty list or all elements being identical. # Example ```python assert library_sort([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802] assert library_sort([]) == [] assert library_sort([10]) == [10] assert library_sort([100, 100, 100]) == [100, 100, 100] ``` Implement the function `library_sort()`.","solution":"from typing import List def counting_sort(arr: List[int], exp: int) -> List[int]: n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 for i in range(n): arr[i] = output[i] return arr def library_sort(ids: List[int]) -> List[int]: if not ids: return [] max_id = max(ids) exp = 1 while max_id // exp > 0: ids = counting_sort(ids, exp) exp *= 10 return ids"},{"question":"You are required to implement the `comb_sort` algorithm, which is a modification of the Bubble Sort algorithm aimed at improving performance by initially comparing elements that are far apart. Your task is to write a function `comb_sort` that takes in a list of integers and returns the sorted list using the comb sort methodology. # Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: ``` # Input - `arr`: A list of integers with 0 <= len(arr) <= 10^5. # Output - A list of integers sorted in non-decreasing order. # Constraints - The input list can be empty. - Elements of the list can be positive, negative, or zero. # Example ```python print(comb_sort([8, 4, 1, 56, 3, -44, 23, -6, 28, 0])) # Output: [-44, -6, 0, 1, 3, 4, 8, 23, 28, 56] ``` # Additional Requirements - Your implementation should be efficient with respect to both time and space complexity, adhering to the principles of Comb Sort. - Handle edge cases such as empty arrays or arrays with all identical elements. - Optimize for early exit when the array is already sorted.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the comb sort algorithm. def get_next_gap(gap): # Shrink gap by the shrink factor gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Question: Implement Diffie-Hellman Key Exchange with Security Enhancements **Context**: The Diffie-Hellman key exchange is widely used to establish a shared secret between two parties over an insecure communication channel. Alice and Bob wish to use it to agree upon a common secret key. To strengthen the security, you are required to enhance it by validating key lengths and ensuring that the prime number and primitive root are shared securely. **Task**: Implement a function, `enhanced_diffie_hellman_key_exchange`, that performs the Diffie-Hellman Key Exchange with the following requirements: 1. **Key Validation**: Both Alice and Bob\'s private keys should be at least 256 bits long to ensure adequate security. 2. **Prime Number Security**: The given prime number (p) must be validated for primality. 3. **Primitive Root Verification**: Ensure that the given number (a) is a valid primitive root of p. **Function Signature**: ```python def enhanced_diffie_hellman_key_exchange(a: int, p: int) -> Union[bool, str]: pass ``` **Inputs**: - `a` (int): A purported primitive root of the prime number `p`. - `p` (int): A large prime number. **Outputs**: - Returns `True` if the shared secret keys computed by Alice and Bob match. - Returns an appropriate error message (str) if any validation fails (e.g., if `p` is not prime or `a` is not a valid primitive root). **Constraints**: - `p` should be a prime number greater than 2. - `a` should be a positive integer less than `p`. **Hint**: - Utilize provided functions like `prime_check`, `find_primitive_root`, etc., to assist with validation. **Example**: ```python # Example call to the function. result = enhanced_diffie_hellman_key_exchange(a=5, p=23) if result == True: print(\\"Shared secret key successfully established.\\") else: print(f\\"Error: {result}\\") ``` **Performance Requirements**: - Ensure the implementation efficiently handles large prime numbers typically used in cryptographic applications.","solution":"import random def is_prime(n): Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_primitive_root(p): Find a primitive root for prime p. if not is_prime(p): return None phi = p - 1 factors = set() i = 2 while i * i <= phi: if phi % i == 0: factors.add(i) while phi % i == 0: phi //= i i += 1 if phi > 1: factors.add(phi) for r in range(2, p): for factor in factors: if pow(r, (p - 1) // factor, p) == 1: break else: return r return None def enhanced_diffie_hellman_key_exchange(a, p): Enhanced Diffie-Hellman Key Exchange. if not is_prime(p): return \\"p is not a prime number.\\" primitive_root = find_primitive_root(p) if primitive_root is None or primitive_root != a: return \\"a is not a valid primitive root of p.\\" # Generate private keys (at least 256-bit long) private_key_bits = 256 alice_private = random.getrandbits(private_key_bits) bob_private = random.getrandbits(private_key_bits) # Compute public keys alice_public = pow(a, alice_private, p) bob_public = pow(a, bob_private, p) # Compute shared secrets alice_shared_secret = pow(bob_public, alice_private, p) bob_shared_secret = pow(alice_public, bob_private, p) # Compare shared secrets return alice_shared_secret == bob_shared_secret # Example usage # result = enhanced_diffie_hellman_key_exchange(a=5, p=23) # if result == True: # print(\\"Shared secret key successfully established.\\") # else: # print(f\\"Error: {result}\\")"},{"question":"# Question: Dynamic Connectivity & Number of Islands You are given a **3x3 grid** initially filled with water. You will be given a sequence of positions where lands are added over time. Your task is to determine the number of islands after each land addition. An island is defined as a group of adjacent lands (horizontally or vertically connected components). The grid coordinates start from (0, 0) (i.e., top-left corner). **Function Signature** ```python def num_islands(positions: List[List[int]]) -> List[int]: pass ``` **Input** - `positions`: A list of pairs, where each pair (i, j) indicates a land being added at position (i, j) in the 3x3 grid. **Output** - Return a list of integers where the i-th integer is the number of islands after the i-th addLand operation. **Constraints** - The grid is always 3x3. - Positions will always be valid coordinates within the grid. - A land addition is only effective if the position was previously water, not already land. **Example** ```python positions = [[0, 0], [0, 1], [1, 2], [2, 1]] print(num_islands(positions)) # Output: [1, 1, 2, 3] ``` **Explanation** 1. After adding (0, 0), the grid is: ``` 1 0 0 0 0 0 0 0 0 ``` Number of islands = 1 2. After adding (0, 1), the grid is: ``` 1 1 0 0 0 0 0 0 0 ``` Number of islands = 1 3. After adding (1, 2), the grid is: ``` 1 1 0 0 0 1 0 0 0 ``` Number of islands = 2 4. After adding (2, 1), the grid is: ``` 1 1 0 0 0 1 0 1 0 ``` Number of islands = 3 Implement the `num_islands` function using the concepts of Union-Find to efficiently track the connectivity and number of islands dynamically.","solution":"from typing import List def num_islands(positions: List[List[int]]) -> List[int]: def find(x): if parent[x] != x: parent[x] = find(parent[x]) # Path compression return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootX] = rootY # Union return True return False n = 3 parent = {} rank = {} directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] count = 0 result = [] for i, j in positions: if (i, j) in parent: result.append(count) # If land already exists, skip and append current island count continue parent[(i, j)] = (i, j) count += 1 for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < n and 0 <= nj < n and (ni, nj) in parent: if union((i, j), (ni, nj)): count -= 1 result.append(count) return result"},{"question":"Scenario You are a data analyst working with large datasets. Before performing any complex analysis, you want to filter the dataset to focus only on the relevant range of values. For this purpose, you need a function that filters an array based on minimum and/or maximum bounds, but given the large size of your datasets, you also want to avoid excessive memory usage. Task Write a function that filters an array by a given minimum and maximum value. You should replace the list-based filtering with a generator to improve memory efficiency. Function Signature ```python def generator_limit(arr: list, min_lim: int = None, max_lim: int = None) -> \'generator\': pass ``` Input * `arr`: List of integers. Example: `[1, 2, 3, 4, 5]` * `min_lim` (optional): Minimum limit (inclusive). If `None`, use the minimum value of the array. * `max_lim` (optional): Maximum limit (inclusive). If `None`, use the maximum value of the array. Output * A generator that yields integers which are within the given min and max limits. Constraints * The input list `arr` can be assumed to contain at most `10^6` elements. * It can be empty, but will contain only integers if non-empty. * `min_lim` and `max_lim` can be `None`. Example ```python result = generator_limit([1, 2, 3, 4, 5], None, 3) print(list(result)) # Output: [1, 2, 3] result = generator_limit([10, 15, 20, 25], 15, None) print(list(result)) # Output: [15, 20, 25] ``` Notes * Pay attention to edge cases, like the input list being empty. * If both `min_lim` and `max_lim` are `None`, the generator should yield all elements. * Ensure the function is efficient in terms of both time and memory.","solution":"def generator_limit(arr: list, min_lim: int = None, max_lim: int = None) -> \'generator\': Filters the array based on the given minimum and/or maximum limit. Args: arr : list of int List of integers to be filtered. min_lim : int, optional Minimum limit (inclusive). If None, use the minimum value in the list. max_lim : int, optional Maximum limit (inclusive). If None, use the maximum value in the list. Returns: generator A generator that yields integers within the given range. # If the array is empty, return an empty generator if not arr: return yield # This turns the function into a generator if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) for num in arr: if min_lim <= num <= max_lim: yield num"},{"question":"# Task Implement a function that returns the average value of each level in a given Binary Search Tree (BST). Your implementation should traverse the tree level by level (breadth-first traversal) and calculate the average for each level. # Function Signature ```python def average_of_levels(bst: BST) -> List[float]: pass ``` # Input * A Binary Search Tree (BST) which has nodes implemented with the following structure: ```python class Node(object): def __init__(self, data): self.data = data self.left = None self.right = None ``` * The BST object has: * A `get_root()` method that returns the root node of the tree. * The BST may have nodes with integer values. # Output * A list of float values where each value is the average of the corresponding level in the BST. # Example Input A BST formed with the nodes: ``` 10 / 6 15 / / 4 9 12 24 ``` Output ``` [10.0, 10.5, 12.25] # Averages for levels: [10], [6, 15], [4, 9, 12, 24] ``` # Constraints 1. The BST will contain at least one node. 2. Node values will be between -1000 and 1000. 3. The height of the tree will not exceed 1000. 4. The values should be accurate to one decimal place.","solution":"from typing import List, Optional from collections import deque class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BST: def __init__(self): self.root = None def get_root(self): return self.root def insert(self, data): if self.root is None: self.root = Node(data) else: self._insert_recursive(self.root, data) def _insert_recursive(self, node, data): if data < node.data: if node.left: self._insert_recursive(node.left, data) else: node.left = Node(data) else: if node.right: self._insert_recursive(node.right, data) else: node.right = Node(data) def average_of_levels(bst: BST) -> List[float]: root = bst.get_root() if not root: return [] averages = [] queue = deque([root]) while queue: level_length = len(queue) level_sum = 0 for _ in range(level_length): node = queue.popleft() level_sum += node.data if node.left: queue.append(node.left) if node.right: queue.append(node.right) averages.append(level_sum / level_length) return averages"},{"question":"# Scenario You\'ve been hired by a tech company as a software engineer, and one of your tasks is to optimize their backend systems. As a preliminary step, your task is to implement a classic problem called \\"FizzBuzz\\". This problem will help understand your ability to write clean and efficient code. # Problem Statement Write a function `fizzbuzz_efficient(n: int) -> List[Union[int, str]]` that returns a list with numbers from 1 to N, where N is the provided parameter. If the number is divisible by 3, it should be replaced by the word \\"Fizz\\". If it is divisible by 5, it should be replaced by the word \\"Buzz\\". If it is divisible by both 3 and 5, the number should be replaced by the word \\"FizzBuzz\\". # Input * A single integer `n` which is greater than or equal to 1. # Output * A list of integers and strings based on the rules described above. # Constraints * `1 <= n <= 10^5` # Performance Requirements * Ensure that the solution runs efficiently for values of `n` up to 100,000. # Example ```python assert fizzbuzz_efficient(15) == [1, 2, \\"Fizz\\", 4, \\"Buzz\\", \\"Fizz\\", 7, 8, \\"Fizz\\", \\"Buzz\\", 11, \\"Fizz\\", 13, 14, \\"FizzBuzz\\"] ``` # Notes * Implement input validation. If `n` is less than 1, raise a ValueError with the message \'n must be at least 1\'. * The solution should iterate through the numbers efficiently without excessive use of resources. # Extra Challenge: Implement the function with a helper function within the same function definition to keep the main logic clean and modular.","solution":"from typing import List, Union def fizzbuzz_efficient(n: int) -> List[Union[int, str]]: if n < 1: raise ValueError(\'n must be at least 1\') def fizzbuzz_value(i: int) -> Union[int, str]: if i % 15 == 0: return \\"FizzBuzz\\" elif i % 3 == 0: return \\"Fizz\\" elif i % 5 == 0: return \\"Buzz\\" else: return i return [fizzbuzz_value(i) for i in range(1, n + 1)]"},{"question":"**Context**: Imagine you are tasked with implementing a data structure system for a database that handles vast amounts of insertions and deletions in real-time. Henceforth, you are to achieve efficient data retrieval and upkeep a balanced state of the underlying data storage. **Task**: You are to complete an AVL Tree class implementation with the following function: - **delete(key)**: Implement a method that deletes a node with the given key, re-balancing the tree if needed after deletion. **Function Signature**: ```python class AvlTree: ... def delete(self, key: int) -> None: pass ``` **Input/Output Requirements:** - **Input**: An integer key to be deleted from the AVL tree. - **Output**: None. The function should perform the deletion and ensure the tree is balanced thereafter. **Constraints**: - The key may or may not exist in the tree. - The tree may contain integer keys only. - Assume no duplicate keys exist in the tree. **Performance Requirements**: - Ensure the delete operation maintains an average time complexity of O(log n). - The deletion should result in a valid AVL tree after method completion. **Additional Operations Provided**: - An `in_order_traverse` function is available to verify the integrity and balance of the tree post-deletion. - `insert` and `rotate` operations have already been implemented for reference. **Edge Cases and Considerations**: - Deleting a node in three cases: leaf node, node with one child, node with two children. - Ensure re-balancing operations maintain the AVL properties. - Consider potential null references and proper height/balance recalculations. *Example*: Given the AVL tree constructed by inserting keys [10, 20, 30, 40, 50, 25], if the key `30` is deleted: - Perform necessary deletions and rotations. - Use the `in_order_traverse()` method to verify sorted output without the deleted key, ensuring balance.","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _rotate_right(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) return x def _rotate_left(self, x): y = x.right T2 = y.left y.left = x x.right = T2 x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _rebalance(self, node): node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and self._get_balance(node.left) >= 0: return self._rotate_right(node) if balance > 1 and self._get_balance(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance < -1 and self._get_balance(node.right) <= 0: return self._rotate_left(node) if balance < -1 and self._get_balance(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def _delete_node(self, root, key): if not root: return root if key < root.key: root.left = self._delete_node(root.left, key) elif key > root.key: root.right = self._delete_node(root.right, key) else: if root.left is None: temp = root.right root = None return temp elif root.right is None: temp = root.left root = None return temp temp = self._min_value_node(root.right) root.key = temp.key root.right = self._delete_node(root.right, temp.key) if root is None: return root return self._rebalance(root) def __init__(self): self.root = None def delete(self, key): self.root = self._delete_node(self.root, key) def insert(self, key): self.root = self._insert_node(self.root, key) def _insert_node(self, root, key): if not root: return Node(key) elif key < root.key: root.left = self._insert_node(root.left, key) else: root.right = self._insert_node(root.right, key) return self._rebalance(root) def inorder_traverse(self): result = [] self._inorder_util(self.root, result) return result def _inorder_util(self, root, result): if not root: return self._inorder_util(root.left, result) result.append(root.key) self._inorder_util(root.right, result)"},{"question":"# String Reversal Challenge **Objective**: Write a function to reverse a string using an algorithm not mentioned above. # Function Signature ```python def custom_reverse(s: str) -> str: # Your code here ``` # Input * `s` (str): The input string to be reversed. Constraints: `0 <= len(s) <= 10^5`. The string can contain any printable ASCII characters. # Output * A string that is the reversed version of the input string `s`. # Constraints - The function should have a time complexity of (O(n)). - Avoid using slicing, recursion, or the `reversed()` function. - Ensure the solution works efficiently for large strings. # Example ```python assert custom_reverse(\\"hello\\") == \\"olleh\\" assert custom_reverse(\\"\\") == \\"\\" assert custom_reverse(\\"a\\") == \\"a\\" assert custom_reverse(\\"abcde\\") == \\"edcba\\" ``` # Scenario **Context**: Your task is to implement a string reversal function that is efficient and avoids common Python idioms like slicing or using built-in functions. This is to test your understanding of basic algorithms, your ability to implement solutions without relying on Python’s syntactic sugar, and your ability to handle large inputs efficiently. This question assesses your ability to handle basic string manipulation and the understanding of underlying algorithmic principles to ensure robustness and efficiency.","solution":"def custom_reverse(s: str) -> str: Reverses the input string without using slicing, recursion, or the built-in reversed() function. n = len(s) reversed_string = [\'\'] * n # Create a list of the same length as s for i in range(n): reversed_string[n - 1 - i] = s[i] return \'\'.join(reversed_string)"},{"question":"Shell Sort with Custom Gap Sequence You are required to implement the Shell Sort algorithm with a custom gap sequence. This task will assess your understanding of adaptive sorting algorithms and how variations in implementation can affect performance. # Question **Objective**: Write a function `custom_shell_sort(arr)` that sorts an array of integers using Shell Sort with the following specific gap sequence: [9, 5, 3, 1]. # Input - An array of integers, `arr`, with length `n` (1 ≤ n ≤ 1000). # Output - The function should return the sorted array in ascending order. # Constraints - You must use the specified gap sequence: [9, 5, 3, 1]. - The function should handle edge cases efficiently: - Empty arrays. - Single-element arrays. - Arrays with all equal elements. # Example ```python def custom_shell_sort(arr): \'\'\' Your implementation here \'\'\' pass # Example usage: arr = [12, 34, 54, 2, 3] print(custom_shell_sort(arr)) # Output: [2, 3, 12, 34, 54] arr = [4, 0, -5, 12, 7, 55, 1, 99] print(custom_shell_sort(arr)) # Output: [-5, 0, 1, 4, 7, 12, 55, 99] ``` **Note**: Ensure your implementation handles edge cases and is optimized for the given input constraints.","solution":"def custom_shell_sort(arr): Sorts an array of integers using Shell Sort with a custom gap sequence [9, 5, 3, 1]. n = len(arr) gaps = [9, 5, 3, 1] for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"You are tasked with finding the index of the first occurrence of a target value in a sorted array of integers. The array is sorted in increasing order and may contain duplicate values. Implement the function `first_occurrence` to achieve this. # Function Signature ```python def first_occurrence(array: List[int], query: int) -> int: ``` # Input * `array` : List[int] : A sorted list of integers in increasing order. The list may contain duplicates. * `query` : int : The target value to search for in the array. # Output * int : The index of the first occurrence of the target value `query` in the array. If `query` is not found in the array, return -1. # Constraints * `0 <= len(array) <= 10^5` * `-10^9 <= array[i], query <= 10^9` # Example Input: ```python array = [1, 2, 2, 2, 3, 4, 5, 6] query = 2 ``` Output: ```python 1 ``` Input: ```python array = [2, 3, 4, 5, 6, 7, 8, 9] query = 5 ``` Output: ```python 3 ``` Input: ```python array = [] query = 1 ``` Output: ```python -1 ``` # Edge Cases 1. The array is empty. 2. The query is not present in the array. 3. The query is present at the start or end of the array. 4. The array contains duplicate values of the query. # Implementation Ensure your implementation handles all edge cases appropriately and is optimized for performance to handle large inputs.","solution":"from typing import List def first_occurrence(array: List[int], query: int) -> int: Returns the index of the first occurrence of the target value in the sorted array. If the target is not found, returns -1. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid right = mid - 1 # continue to search in the left half elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"**Problem Statement**: You are tasked with implementing an efficient substring matching algorithm, given two strings, `haystack` and `needle`. Your objective is to find the starting index of the first occurrence of `needle` in `haystack` or report that `needle` is not part of `haystack`. **Function Signature**: ```python def strStr(haystack: str, needle: str) -> int: ``` **Input**: - `haystack` (string): The string in which to search. - `needle` (string): The string to find within `haystack`. **Output**: - Return the index (integer) of the first occurrence of `needle` in `haystack` or -1 if `needle` is not part of `haystack`. **Constraints**: 1. Both `haystack` and `needle` consist of only lowercase English characters. 2. The length of `haystack` and `needle` will be at most 10^4. **Performance Requirements**: - Aim to optimize the solution with better than O(n * m) time complexity if possible, leveraging algorithms such as Knuth-Morris-Pratt (KMP). **Example**: ```python # Example 1: haystack = \\"hello\\" needle = \\"ll\\" # Expected Output: 2 # Example 2: haystack = \\"aaaaa\\" needle = \\"bba\\" # Expected Output: -1 # Example 3: haystack = \\"\\" needle = \\"\\" # Expected Output: 0 ``` **Context**: Imagine you are developing a search feature for a text editing tool that needs to efficiently find the first occurrence of a keyword in a document string. Implementing a robust string matching algorithm is crucial to provide users with fast and accurate results. **Important Considerations**: - Handle edge cases such as empty `needle`. - Consider optimizing for larger strings using advanced algorithms if possible. - Ensure the solution is robust against various input lengths and characters.","solution":"def strStr(haystack: str, needle: str) -> int: Returns the starting index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. if needle == \\"\\": return 0 hay_len = len(haystack) nee_len = len(needle) if nee_len > hay_len: return -1 # KMP Algorithm steps # Create the partial match table lps = [0] * nee_len j = 0 # Length of the previous longest prefix suffix i = 1 while i < nee_len: if needle[i] == needle[j]: j += 1 lps[i] = j i += 1 else: if j != 0: j = lps[j - 1] else: lps[i] = 0 i += 1 i = 0 # Index for haystack j = 0 # Index for needle while i < hay_len: if needle[j] == haystack[i]: i += 1 j += 1 if j == nee_len: return i - j elif i < hay_len and needle[j] != haystack[i]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"Context: You are working on a historical data processing application that needs the capability to convert Roman numerals to integers accurately. Your task is to implement a function that performs this conversion in a robust manner considering potential edge cases. Description: Write a Python function `roman_to_int(s: str) -> int` that takes a string representing a Roman numeral and converts it to its integer equivalent. The input is guaranteed to be within the range from 1 to 3999. Requirements: 1. Your function should handle the standard Roman numeral representation rules: - I can be placed before V(5) and X(10) to make 4 and 9. - X can be placed before L(50) and C(100) to make 40 and 90. - C can be placed before D(500) and M(1000) to make 400 and 900. 2. Your function should assume the input is a valid Roman numeral string. Input: - A string `s` representing a Roman numeral (1 ≤ s.length ≤ 15). Output: - An integer representing the equivalent value of the Roman numeral. Example: ```python assert roman_to_int(\\"DCXXI\\") == 621 assert roman_to_int(\\"IX\\") == 9 assert roman_to_int(\\"MCMXCIV\\") == 1994 assert roman_to_int(\\"IV\\") == 4 assert roman_to_int(\\"MMXXIII\\") == 2023 ``` Constraints: - The input string `s` is guaranteed to be a valid Roman numeral from 1 to 3999.","solution":"def roman_to_int(s: str) -> int: Convert Roman numeral to integer. :param s: Roman numeral as string. :return: Equivalent integer value. roman_numerals = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(s): current_value = roman_numerals[char] if current_value >= prev_value: total += current_value else: total -= current_value prev_value = current_value return total"},{"question":"You are tasked with simplifying a Unix-style file path provided as a string. Your goal is to remove any redundant parent and current directory references (i.e., `..` and `.`) and simplify the path to its canonical form. # Function Definition Implement the function: ```python def simplify_path(path: str) -> str: pass ``` # Input and Output - **Input**: A string `path` representing the absolute path in Unix-style. - **Output**: A string representing the simplified canonical path. # Constraints and Considerations - The path will always begin with a slash `/`. - The path may contain alphabets, numbers, dots (`.`), and slashes (`/`). - Multiple consecutive slashes (`//`) should be treated as a single slash (`/`). - Every `..` means moving one directory up (to the parent directory). - Every `.` or current directory should be ignored. - The resulting path should always start with a slash `/` and not end with a slash unless it is the root `/`. # Examples ```python simplify_path(\\"/home/\\") # Output: \\"/home\\" simplify_path(\\"/a/./b/../../c/\\") # Output: \\"/c\\" simplify_path(\\"/../\\") # Output: \\"/\\" simplify_path(\\"/home//foo/\\") # Output: \\"/home/foo\\" simplify_path(\\"\\") # Output: \\"/\\" ``` # Detailed Requirements - Ensure to handle edge cases, such as paths leading to or above the root directory. - Handle paths with multiple slashes and no directories correctly. - Optimize for both time and space efficiency.","solution":"def simplify_path(path: str) -> str: Simplifies a Unix-style file path. # Split the path by \\"/\\" and filter out empty and \\".\\" strings parts = [part for part in path.split(\\"/\\") if part and part != \\".\\"] stack = [] for part in parts: if part == \\"..\\": if stack: stack.pop() # Move up one directory else: stack.append(part) # Go into the folder # Join the stack into the canonical path return \\"/\\" + \\"/\\".join(stack)"},{"question":"# Context You are given the task to explore a special set of numbers. These numbers have a fascinating property: when each digit of the number is raised to consecutive powers starting from 1 and their sum equals the original number, like 89 (8^1 + 9^2 = 89) or 135 (1^1 + 3^2 + 5^3 = 135). # Problem Statement Write a function `find_special_numbers(low, high)` that returns a list of numbers within a given range ([low, high]) inclusive that match the described property. # Input * `low`: Integer, the starting value of the range (inclusive) (1 ≤ low ≤ high). * `high`: Integer, the ending value of the range (inclusive). # Output * A list of integers that satisfy the property, sorted in ascending order. # Constraints * 1 ≤ low ≤ high ≤ 10^6 * The function should be optimized to handle a large range efficiently. # Examples ```python print(find_special_numbers(1, 10)) # [1, 2, 3, 4, 5, 6, 7, 8, 9] print(find_special_numbers(1, 100)) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] print(find_special_numbers(50, 150)) # [89, 135] print(find_special_numbers(1, 1)) # [1] ``` # Notes * All input and output formats must be followed as specified. * Consider edge cases such as the lower range boundary and higher range values for testing and optimization. * Performance is key for large ranges, so consider efficient solutions beyond just brute force.","solution":"def find_special_numbers(low, high): Returns a list of numbers within the range [low, high] that match the property that the sum of each digit raised to consecutive powers equals the number itself. special_numbers = [] for num in range(low, high + 1): digits = [int(d) for d in str(num)] if num == sum(d ** (i + 1) for i, d in enumerate(digits)): special_numbers.append(num) return special_numbers"},{"question":"# AVL Tree - Coding Challenge **Scenario**: You are tasked with building and maintaining an AVL Tree for a dynamic dataset. The primary operations you need to focus on are insertion of new values while ensuring the tree is balanced. Implement the following functionality for the AVL Tree: 1. **Insertion** - Insert new values while ensuring the tree maintains AVL properties. 2. **Balance Verification** - Function that verifies whether the tree is balanced post operations. 3. **In-order Traversal** - Extracts the elements of the tree in sorted order. 4. **Test Balancing** - A function to test and confirm if the balancing mechanism is working accurately. Here\'s the interface you need to implement: ```python class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None class AvlTree: def __init__(self): self.node = None self.height = -1 self.balance = 0 # Insert a key into the AVL tree def insert(self, key): pass # Utility function to check if the tree is balanced def is_balanced(self): pass # Perform in-order traversal to return elements in sorted order def in_order_traverse(self): pass # Helper functions to maintain AVL properties def re_balance(self): pass def update_heights(self, recursive=True): pass def update_balances(self, recursive=True): pass def rotate_right(self): pass def rotate_left(self): pass ``` **Constraints**: 1. The keys inserted are unique integer values. 2. Ensure the AVL properties are maintained post each insertion. **Example**: ```python tree = AvlTree() # Insert Node tree.insert(10) tree.insert(20) tree.insert(30) # After multiple insertions, extract the in-order traversal print(tree.in_order_traverse()) # Expected [10, 20, 30] # Verify if the tree is balanced print(tree.is_balanced()) # Expected True ``` **Notes**: - Pay attention to the balance factor. - Consider edge cases where rebalancing might be required multiple times.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def __init__(self): self.root = None # Insert a key into the AVL tree def insert(self, key): if not self.root: self.root = TreeNode(key) else: self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._height(node.left), self._height(node.right)) balance = self._get_balance(node) # Left Left Case if balance > 1 and key < node.left.key: return self._rotate_right(node) # Right Right Case if balance < -1 and key > node.right.key: return self._rotate_left(node) # Left Right Case if balance > 1 and key > node.left.key: node.left = self._rotate_left(node.left) return self._rotate_right(node) # Right Left Case if balance < -1 and key < node.right.key: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node # Utility function to check if the tree is balanced def is_balanced(self): return self._is_balanced(self.root) def _is_balanced(self, node): if not node: return True balance = self._get_balance(node) if abs(balance) > 1: return False return self._is_balanced(node.left) and self._is_balanced(node.right) # Perform in-order traversal to return elements in sorted order def in_order_traverse(self): result = [] self._in_order_traverse(self.root, result) return result def _in_order_traverse(self, node, result): if node: self._in_order_traverse(node.left, result) result.append(node.key) self._in_order_traverse(node.right, result) def _height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._height(node.left) - self._height(node.right) def _rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._height(z.left), self._height(z.right)) y.height = 1 + max(self._height(y.left), self._height(y.right)) return y def _rotate_right(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._height(z.left), self._height(z.right)) y.height = 1 + max(self._height(y.left), self._height(y.right)) return y"},{"question":"Given a binary tree, write a function `find_deepest_node` to find the deepest node in the binary tree. The deepest node is the node located farthest from the root in terms of the number of edges. Function Signature ```python def find_deepest_node(root: TreeNode) -> TreeNode: pass ``` Constraints * The binary tree can have up to 10^4 nodes. * Node values are unique and can be any integer. Input * A root node of the binary tree. Output * Return the deepest node in the binary tree. Example ```python # Example 1 # Input: a binary tree [1, 2, 3, None, 4, 5, 6, None, None, 7] # Structure: # 1 # / # 2 3 # / # 4 5 6 # / # 7 # Output: TreeNode with value 7 # Example 2 # Input: a binary tree [1] # Structure: # 1 # Output: TreeNode with value 1 ``` Explanation - In Example 1, the node with value 7 is the farthest from the root, making it the deepest node. - In Example 2, the single node 1 is both the root and the deepest node. # Additional Context * You should consider edge cases like an empty tree, a tree with only one node, or very skewed trees. * Performance: Aim for a solution with O(n) time complexity and O(n) space complexity due to the potential size of tree and depth.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_deepest_node(root: TreeNode) -> TreeNode: if not root: return None # Perform level-order traversal (BFS) queue = [root] current = None while queue: current = queue.pop(0) if current.left: queue.append(current.left) if current.right: queue.append(current.right) return current"},{"question":"You are tasked with implementing a function `is_pattern_match(pattern: str, s: str) -> bool` that determines whether a given string `s` follows the same pattern provided by the string `pattern`. The function should implement the logic using backtracking to ensure that there is a one-to-one correspondence (bijection) between characters in the pattern and non-empty substrings in the string. # Input and Output Format - **Input**: - `pattern` (a string): A pattern string consisting of only lowercase English letters. - `s` (a string): A target string consisting of only lowercase English letters. - **Output**: - Return `True` if `s` follows the same pattern as `pattern`. Otherwise, return `False`. # Constraints - Both `pattern` and `s` will contain only lowercase English letters. - The length of `pattern` will be in the range [1, 20]. - The length of `s` will be in the range [1, 200]. # Example Example 1: - **Input**: `pattern = \\"abab\\"`, `s = \\"redblueredblue\\"` - **Output**: `True` - **Explanation**: There is a bijective mapping \'a\' -> \\"red\\" and \'b\' -> \\"blue\\". Example 2: - **Input**: `pattern = \\"aaaa\\"`, `s = \\"asdasdasdasd\\"` - **Output**: `True` - **Explanation**: There is a bijective mapping \'a\' -> \\"asd\\". Example 3: - **Input**: `pattern = \\"aabb\\"`, `s = \\"xyzabcxzyabc\\"` - **Output**: `False` - **Explanation**: There is no mapping that fits the entire pattern. # Implementation Your function signature should be: ```python def is_pattern_match(pattern: str, s: str) -> bool: # Your implementation goes here. ``` # Performance Requirements - The implementation should aim to complete within a reasonable time frame for the specified constraints. Consider edge cases and ensure your function handles: 1. Patterns and strings of mismatched lengths. 2. Empty patterns or strings if permissible. 3. Recursion depth and backtracking efficiently.","solution":"def is_pattern_match(pattern: str, s: str) -> bool: def backtrack(p_idx, s_idx, pat_to_str, str_to_pat): if p_idx == len(pattern) and s_idx == len(s): return True if p_idx == len(pattern) or s_idx == len(s): return False pattern_char = pattern[p_idx] for end in range(s_idx + 1, len(s) + 1): sub_str = s[s_idx:end] if pattern_char in pat_to_str: if pat_to_str[pattern_char] == sub_str: if backtrack(p_idx + 1, end, pat_to_str, str_to_pat): return True elif sub_str not in str_to_pat: pat_to_str[pattern_char] = sub_str str_to_pat[sub_str] = pattern_char if backtrack(p_idx + 1, end, pat_to_str, str_to_pat): return True del pat_to_str[pattern_char] del str_to_pat[sub_str] return False return backtrack(0, 0, {}, {})"},{"question":"Question: Determine if All Meetings Can Be Attended # Context A busy professional receives multiple meeting requests daily. Each meeting request is represented as a time interval with a start and end time. The professional wants to know if they can attend all the meetings without any overlaps. # Task Write a function `can_attend_meetings(intervals)` that determines if a person can attend all given meetings. The function should return `True` if the meetings do not overlap, and `False` otherwise. # Function Signature ```python def can_attend_meetings(intervals: List[List[int]]) -> bool: pass ``` # Input - `intervals`: A list of `n` meeting intervals, where each interval is a list `[start, end]` representing the start and end times of a meeting. `start` and `end` are non-negative integers (`0 <= start < end`). # Output - Returns `True` if a person can attend all meetings without overlaps, otherwise returns `False`. # Constraints - The input list may have up to `10^4` intervals. - The start and end times must satisfy `0 <= start < end <= 10^6`. # Examples - Example 1: ```python intervals = [[0, 30], [5, 10], [15, 20]] assert can_attend_meetings(intervals) == False ``` - Example 2: ```python intervals = [[7, 10], [2, 4]] assert can_attend_meetings(intervals) == True ``` # Performance Requirements - The function should run efficiently with a complexity of O(n log n) where n is the number of intervals.","solution":"from typing import List def can_attend_meetings(intervals: List[List[int]]) -> bool: # First, sort the intervals by their start times intervals.sort(key=lambda x: x[0]) # Compare each interval\'s start time with the previous interval\'s end time for i in range(1, len(intervals)): if intervals[i][0] < intervals[i-1][1]: return False return True"},{"question":"Randomized Collection with Duplicates Support Objective: Extend the `RandomizedSet` data structure to support inserting and removing duplicates while maintaining average O(1) operations. You are required to design a new data structure `RandomizedCollection` that supports the following operations: 1. `insert(val)`: Inserts an item val to the collection. Returns true if the item was not present, otherwise false. 2. `remove(val)`: Removes one occurrence of an item val from the collection. Returns true if the item was present, otherwise false. 3. `get_random()`: Returns a random element from the current collection of elements. Each element must have the same probability of being returned. Constraints: - The elements could include duplicates. - `get_random` should consider duplicate frequencies for uniform sampling. - Functions should perform operations in average O(1) time. Input & Output Format: - Implement the class `RandomizedCollection` with the three methods described. - Use appropriate data structures within your implementation to ensure the performance requirements are met. Example: ```python collection = RandomizedCollection() print(collection.insert(1)) # Returns True print(collection.insert(1)) # Returns False print(collection.insert(2)) # Returns True print(collection.remove(1)) # Returns True print(collection.get_random()) # Returns either 1 or 2 ``` Notes: - Be mindful of handling edge cases such as empty collections on calls to `get_random`. - Carefully maintain the integrity of indices in the list and dictionary for efficient operations.","solution":"import random from collections import defaultdict class RandomizedCollection: def __init__(self): self.data = [] self.index_map = defaultdict(set) def insert(self, val): self.data.append(val) self.index_map[val].add(len(self.data) - 1) return len(self.index_map[val]) == 1 def remove(self, val): if not self.index_map[val]: return False remove_idx = self.index_map[val].pop() last_val = self.data[-1] self.data[remove_idx] = last_val self.index_map[last_val].add(remove_idx) self.index_map[last_val].discard(len(self.data) - 1) self.data.pop() return True def get_random(self): return random.choice(self.data)"},{"question":"# AVL Tree Extension: Adding Range Search and Kth Smallest Element You are given an implementation of an AVL tree which is a self-balancing binary search tree. The AVL tree ensures that the heights of the two child subtrees of any node differ by no more than one by automatically adjusting via left and right rotations. Your task is to extend this AVL Tree with the following functionalities: 1. **`range_search(start, end)`**: This method should return a list of all keys within the range `[start, end]` (inclusive) in sorted order. 2. **`kth_smallest_element(k)`**: This method should return the k-th smallest key in the AVL tree. If k is out of bounds (i.e., if k is less than 1 or greater than the number of nodes), it should return `None`. # Implementation Description - **Input/Output Formats**: 1. `range_search(start: int, end: int) -> List[int]` - Input: Two integers `start` and `end`. - Output: A list of integers representing the tree keys in the specified range. 2. `kth_smallest_element(k: int) -> int` - Input: An integer `k`. - Output: The k-th smallest integer in the AVL tree or `None` if out of bounds. - **Constraints**: - For `range_search`: Assume `start <= end`. - For `kth_smallest_element`: 1 <= k <= n (where n is the number of nodes). **Performance Requirements**: - `range_search` should run in O(h + m) time, where h is the height of the tree and m is the number of keys in the range. - `kth_smallest_element` should run in O(h) time. ```python Assume the TreeNode class and the rest of the AVLTree implementation are available. class AvlTreeExtended(AvlTree): def range_search(self, start: int, end: int) -> List[int]: Returns all keys within the range [start, end] in sorted order. pass def kth_smallest_element(self, k: int) -> int: Returns the k-th smallest key in the tree. Returns None if k is out of bounds. pass # You can use the following function to test your methods. def main(): avl = AvlTreeExtended() keys = [20, 4, 15, 70, 50, 100, 55] for key in keys: avl.insert(key) # Test range search print(avl.range_search(15, 55)) # Expected output: [15, 20, 50, 55] or similar # Test kth smallest element print(avl.kth_smallest_element(3)) # Expected output: 20 or similar if __name__ == \\"__main__\\": main() ``` # Notes - Extend the existing AVL tree\'s functionality without modifying the core `AvlTree` class. - Ensure to manage tree traversal effectively to meet the performance requirements for both functionalities.","solution":"from typing import List, Optional class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 self.size = 1 # Add size attribute to keep track of the size of the subtree class AvlTreeExtended: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) node.size = 1 + self._get_size(node.left) + self._get_size(node.right) # Perform rotations if needed balance = self._get_balance(node) if balance > 1 and key < node.left.key: return self._right_rotate(node) if balance < -1 and key > node.right.key: return self._left_rotate(node) if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) z.size = 1 + self._get_size(z.left) + self._get_size(z.right) y.size = 1 + self._get_size(y.left) + self._get_size(y.right) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) z.size = 1 + self._get_size(z.left) + self._get_size(z.right) y.size = 1 + self._get_size(y.left) + self._get_size(y.right) return y def _get_height(self, node): if not node: return 0 return node.height def _get_size(self, node): if not node: return 0 return node.size def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def range_search(self, start: int, end: int) -> List[int]: result = [] self._range_search_helper(self.root, start, end, result) return result def _range_search_helper(self, node, start, end, result): if not node: return if start < node.key: self._range_search_helper(node.left, start, end, result) if start <= node.key <= end: result.append(node.key) if end > node.key: self._range_search_helper(node.right, start, end, result) def kth_smallest_element(self, k: int) -> Optional[int]: if k <= 0 or k > self._get_size(self.root): return None return self._kth_smallest_element_helper(self.root, k) def _kth_smallest_element_helper(self, node, k): left_size = self._get_size(node.left) if k == left_size + 1: return node.key elif k <= left_size: return self._kth_smallest_element_helper(node.left, k) else: return self._kth_smallest_element_helper(node.right, k - left_size - 1)"},{"question":"Scenario You are tasked with managing an inventory system for a manufacturing plant where items are categorized based on colors. To optimize storage and retrieval, you need to ensure that items of the same color are grouped together. In this scenario, your job is to implement a function that takes an array of integers representing colors and sorts them such that all items of the same color are adjacent in the order of red, white, and blue. We use the values 0, 1, and 2 to represent these colors, respectively. Function Implementation **Function**: `sort_colors(nums: List[int]) -> None` **Input**: - `nums`: A list of integers where each integer is either 0, 1, or 2, representing the colors red, white, and blue respectively. The list length can vary from 0 to 10^6. **Output**: - The function should not return anything. Instead, it should modify the input list in-place to rearrange the colors in ascending order (0s followed by 1s, followed by 2s). **Constraints**: - You cannot use the built-in sort function for this problem. - The solution should run in O(n) time complexity. - The sorting should be done in-place with O(1) additional space. **Example**: ```python Input: [2, 0, 2, 1, 1, 0] Output: [0, 0, 1, 1, 2, 2] ``` Additional Notes - Carefully analyze potential edge cases such as arrays that are already sorted, arrays with no elements, and arrays with only one type of element. - Handle all pointer manipulations cautiously to avoid out-of-bound errors or not sorting correctly.","solution":"def sort_colors(nums): Sorts the array nums in-place so that all 0s come first, followed by all 1s, then 2s. # Three pointers for sorting low = 0 mid = 0 high = len(nums) - 1 # Iterate while mid pointer is less than or equal to high while mid <= high: if nums[mid] == 0: # Swap nums[low] and nums[mid] nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: # nums[mid] == 2 case # Swap nums[mid] and nums[high] nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"# Merging Intervals and Checking Overlapping Intervals Imagine you are working on a calendar application that needs to manage time intervals. Given a set of intervals, your tasks are to: 1. Merge any overlapping intervals. 2. Determine if a specific number falls within any of the merged intervals. # Task **Part 1: Merging Intervals** Implement a function `merge_intervals(intervals)` that takes a list of intervals and returns a new list where all overlapping intervals have been merged. *Intervals will be given as a list of tuples, where each tuple represents an interval with a start and an end point (inclusive).* **Part 2: Checking Overlapping Intervals** Implement a method `__contains__` in the `Interval` class that should take an integer and return `True` if the integer is within the interval (inclusive) and `False` otherwise. # Input and Output 1. `merge_intervals(intervals)`: - **Input**: A list of tuples [(start1, end1), (start2, end2), ...] - **Output**: A list of merged tuples [(new_start1, new_end1), (new_start2, new_end2), ...] 2. `Interval.__contains__(self, item)`: - **Input**: An integer. - **Output**: Boolean value - `True` if the integer is within the interval, `False` otherwise. # Constraints 1. Interval boundaries will be given by integers. 2. You can assume that the start point of each interval will always be less than or equal to the end point. 3. Both start and end points of the intervals are inclusive. # Example ```python # Part 1: Merging Intervals intervals = [(1, 3), (2, 6), (8, 10), (15, 18)] merged_intervals = merge_intervals(intervals) print(merged_intervals) # Output: [(1, 6), (8, 10), (15, 18)] # Part 2: Checking Containment interval = Interval(1, 5) print(3 in interval) # Output: True print(6 in interval) # Output: False ``` # Implementation Make use of the provided `Interval` class. Pay special attention to edge cases such as intervals that barely overlap or do not overlap at all.","solution":"from typing import List, Tuple class Interval: def __init__(self, start: int, end: int): self.start = start self.end = end def __contains__(self, item: int) -> bool: return self.start <= item <= self.end def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: if not intervals: return [] # First, we sort the intervals by the start time. intervals.sort(key=lambda x: x[0]) merged = [] current_start, current_end = intervals[0] for start, end in intervals[1:]: if start <= current_end: # There is overlap current_end = max(current_end, end) else: merged.append((current_start, current_end)) current_start, current_end = start, end # Don\'t forget to add the last interval merged.append((current_start, current_end)) return merged"},{"question":"You are given a few multi-agent systems where agents can join, leave, and communicate with a central hub. Each time an agent communicates with the hub, it has an opportunity to be selected for a certain task by picking one randomly from the people who have communicated. Implement a data structure called `AgentHub` that supports the following operations in average O(1) time: 1. Add an agent to the hub by calling `add_agent(agent_id: int) -> None`. 2. Remove an agent from the hub by calling `remove_agent(agent_id: int) -> None`. 3. Select a random agent who has joined the hub by calling `random_agent() -> int`. # Function Signatures ```python class AgentHub: def __init__(self): # Initialization code here def add_agent(self, agent_id: int) -> None: # Code to add an agent def remove_agent(self, agent_id: int) -> None: # Code to remove an agent def random_agent(self) -> int: # Code to select a random agent ``` # Constraints 1. All agent IDs are unique positive integers. 2. `add_agent` will only be called with IDs that are not currently in the hub. 3. `remove_agent` will only be called with IDs that are currently in the hub. 4. `random_agent` will only be called when there is at least one agent in the hub. # Example Usage ```python hub = AgentHub() hub.add_agent(1) hub.add_agent(2) hub.remove_agent(1) print(hub.random_agent()) # This should output 2 since it\'s the only remaining agent hub.add_agent(3) print(hub.random_agent()) # This could output either 2 or 3, each with a 50% probability ```","solution":"import random class AgentHub: def __init__(self): self.agents = {} self.agent_list = [] def add_agent(self, agent_id: int) -> None: if agent_id not in self.agents: self.agents[agent_id] = len(self.agent_list) self.agent_list.append(agent_id) def remove_agent(self, agent_id: int) -> None: if agent_id in self.agents: index = self.agents[agent_id] last_agent = self.agent_list[-1] self.agent_list[index] = last_agent self.agents[last_agent] = index self.agent_list.pop() del self.agents[agent_id] def random_agent(self) -> int: return random.choice(self.agent_list)"},{"question":"Objective Write a function that verifies if a list of numbers contains any primes and returns a list of the prime numbers found. Context Your team is working on a cryptographic application that requires verification of prime numbers for key generation. To ensure efficient verification, implement a function that checks each number in a given list and identifies all prime numbers. Requirements **Function signature**: ```python def find_primes_in_list(numbers: List[int]) -> List[int]: Given a list of integers, return a list containing all the prime numbers from the input list. :param numbers: A list of integers to check for prime numbers. :return: A list of prime numbers found in the input list. ``` **Input**: - The function accepts a list `numbers` with `1 <= len(numbers) <= 10^5`, where each integer `-10^9 <= numbers[i] <= 10^9`. **Output**: - The function returns a list of integers representing all prime numbers found in the `numbers` list, in the same order they appear in the input list. **Constraints**: - The function should be optimized to handle the given constraints efficiently. - Do not use any built-in functions for checking primality. **Example**: ```python >>> find_primes_in_list([2, 3, 4, 5, 10, 17, -3, 23]) [2, 3, 5, 17, 23] >>> find_primes_in_list([0, 1, -7, 25, 31]) [31] ``` **Performance Requirements**: - The function should run efficiently even for the upper limits of input sizes and ranges. Scenario Imagine you are working on the backend of a large-scale cryptographic system that requires frequent checks of whether numbers are prime for key generation. Ensuring speed and accuracy in identifying prime numbers from a list is crucial for system performance and security.","solution":"from typing import List def is_prime(n: int) -> bool: Helper function to check if a given number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False max_divisor = int(n ** 0.5) + 1 for d in range(3, max_divisor, 2): if n % d == 0: return False return True def find_primes_in_list(numbers: List[int]) -> List[int]: Given a list of integers, return a list containing all the prime numbers from the input list. return [num for num in numbers if is_prime(num)]"},{"question":"# Bipartite Graph Checker Using BFS Context You are a software developer for a company specializing in graph theory applications. Your current task is to implement a function to determine if a given undirected graph is bipartite. A bipartite graph is one whose vertices can be divided into two disjoint and independent sets such that every edge connects a vertex in one set to a vertex in the other set. Task Implement a Python function `check_bipartite(adj_list)` that determines if the graph represented by `adj_list` is bipartite. Function Signature ```python def check_bipartite(adj_list): Determine if the given graph is bipartite. Parameters: adj_list (List[List[int]]): The adjacency matrix representation of the graph. Returns: bool: True if the graph is bipartite, False otherwise. ``` Inputs and Outputs - **Input**: A 2D list `adj_list` where `adj_list[i][j]` is 1 if there is an edge between vertex `i` and vertex `j`, and 0 otherwise. - **Output**: A boolean value `True` if the graph is bipartite, `False` otherwise. Constraints - The graph is undirected and there are no multiple edges. - Self loops (edges from a vertex to itself) are allowed. - The number of vertices in the graph `V` is between 1 and 1000. Performance Requirements - The function should operate within a time complexity of O(V + E) and a space complexity of O(V). # Example ```python adj_list = [ [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0] ] print(check_bipartite(adj_list)) # Output: True adj_list = [ [0, 1, 0, 1, 1], [1, 0, 1, 0, 1], [0, 1, 0, 1, 0], [1, 0, 1, 0, 0], [1, 1, 0, 0, 0] ] print(check_bipartite(adj_list)) # Output: False ``` Hints - Use a queue to perform the Breadth-First Search (BFS). - Consider the case of a self-loop explicitly. - Track the color of each vertex using an array.","solution":"def check_bipartite(adj_list): Determine if the given graph is bipartite. Parameters: adj_list (List[List[int]]): The adjacency list representation of the graph. Returns: bool: True if the graph is bipartite, False otherwise. from collections import deque V = len(adj_list) colors = [-1] * V # -1: Uncolored, 0: Color1, 1: Color2 for start in range(V): if colors[start] == -1: # Not yet visited queue = deque([start]) colors[start] = 0 # Start coloring with 0 while queue: node = queue.popleft() for neighbor in range(V): if adj_list[node][neighbor] == 1: # There is an edge if colors[neighbor] == -1: # Unvisited neighbor colors[neighbor] = 1 - colors[node] # Assign opposite color queue.append(neighbor) elif colors[neighbor] == colors[node]: # Adjacent node has the same color return False return True"},{"question":"# Question: Delete Node in a Linked List (Except Tail) You are given a linked list and an access to a node which needs to be deleted, except for the tail node. The linked list is made up of `Node` objects, and you are given direct access to the node to be deleted. Write a function `delete_node(node: Node)` that deletes the given node from the list. The function should modify the linked list in place. Input * A reference to the node to be deleted, which is guaranteed to be neither the head nor the tail of the list. Output * The function should not return anything. It should modify the linked list in place. Constraints * The node provided will not be the tail node and will always be part of a valid, singly linked list. Performance Requirements * The function should execute in O(1) time complexity. * It should use O(1) extra space. Example Consider the linked list: `1 -> 2 -> 3 -> 4 -> 5` You are given access to the node with value 3. # Scenario: If you call `delete_node(node_with_value_3)`, the linked list will be modified to: `1 -> 2 -> 4 -> 5` **Note**: You should not traverse the linked list to perform the deletion. Instead, you directly manipulate the given node. ```python class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node: Node): pass # implement this function # Example usage: # head = Node(1) # head.next = Node(2) # node_to_delete = head.next.next = Node(3) # head.next.next.next = Node(4) # delete_node(node_to_delete) # Resulting list should be 1 -> 2 -> 4 ```","solution":"class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node: Node): Deletes the node from the linked list by copying the data from the next node into the current node and then skipping over the next node. Args: node (Node): The node to be deleted. Guaranteed not to be the tail node. # Copy the value from the next node into the current node node.val = node.next.val # Skip over the next node by pointing to the next\'s next node node.next = node.next.next"},{"question":"You are given two integers, A and B. Write a function named `count_flips_to_convert` that determines the minimal number of bits needed to flip in the binary representation of integer A to convert it into integer B. # Function Signature: ```python def count_flips_to_convert(a: int, b: int) -> int: ``` # Input: * Two integers, `a` and `b` where `0 <= a, b <= 10^9`. # Output: * An integer representing the number of bits that need to be flipped to convert `a` to `b`. # Constraints: * Your algorithm should run efficiently for the given input range. * Consider handling signed integers appropriately. # Example: ```python # Example 1 # Input: a = 29, b = 15 # Binary of 29: 11101 # Binary of 15: 01111 # You must flip the third and fourth bits of 29 to match 15. # Therefore, the output is 2. count_flips_to_convert(29, 15) # Expected Output: 2 # Example 2 # Input: a = 0, b = 0 # No bits need to be flipped: output is 0. count_flips_to_convert(0, 0) # Expected Output: 0 # Example 3 # Input: a = 255, b = 0 # Binary of 255: 11111111 # Binary of 0: 00000000 # You must flip all 8 bits of 255 to match 0. # Therefore, the output is 8. count_flips_to_convert(255, 0) # Expected Output: 8 ``` # Notes: * Your implementation should handle edge cases, such as when the two integers are the same or when one integer is the complete bitwise inverse of the other (e.g., `a = 0` and `b = 255`). Good luck and happy coding!","solution":"def count_flips_to_convert(a: int, b: int) -> int: Returns the number of bits that need to be flipped to convert integer a to integer b. # XOR between a and b will give us a number where each 1 bit represents a difference in that bit position xor_result = a ^ b # count the number of 1 bits in the result which tells us the number of differing bits count_flips = bin(xor_result).count(\'1\') return count_flips"},{"question":"# Huffman Coding Algorithm Implementation Objective Your task is to implement the core parts of the Huffman coding algorithm. You are required to write functions for encoding and decoding a given text file using Huffman coding. Your implementation must demonstrate the ability to build the Huffman tree, generate Huffman codes, and perform both encoding and decoding of data. Input & Output * **Input Format**: 1. `input.txt`: A text file containing the data to be compressed and encoded. 2. `encoded.bin`: A binary file to store the encoded data and Huffman tree. * **Output Format**: 1. `decoded.txt`: A text file containing the decoded data, which should be identical to the original input data. Requirements Implement the following functions to complete the task: 1. **generate_huffman_tree(signs_frequency)** * **Arguments**: - `signs_frequency`: A dictionary where keys are symbols and values are their frequencies. * **Returns**: The root node of the Huffman tree. 2. **generate_codes(tree)** * **Arguments**: - `tree`: The root node of the Huffman tree. * **Returns**: A dictionary where keys are symbols and values are their Huffman codes. 3. **encode_data(input_file, output_file, codes)** * **Arguments**: - `input_file`: Filename of the text file to be encoded. - `output_file`: Filename of the binary file to store the encoded data. - `codes`: The Huffman codes dictionary generated from the tree. * **Writes**: Encoded data and tree structure to `output_file`. 4. **decode_data(input_file, output_file)** * **Arguments**: - `input_file`: Filename of the binary file containing the encoded data. - `output_file`: Filename of the text file to store the decoded data. * **Writes**: Decoded data to `output_file`. Constraints * The input text file will contain printable ASCII characters only. * The encoded binary file must store the Huffman tree structure and encoded data. Example Assume `input.txt` contains the text \\"hello huffman\\". After encoding and decoding the data, the contents of `decoded.txt` should be the same as `input.txt`. ```python # Example usage: def main(): input_file = \\"input.txt\\" encoded_file = \\"encoded.bin\\" decoded_file = \\"decoded.txt\\" signs_frequency = calculate_frequencies(input_file) tree = generate_huffman_tree(signs_frequency) codes = generate_codes(tree) encode_data(input_file, encoded_file, codes) decode_data(encoded_file, decoded_file) if __name__ == \\"__main__\\": main() ``` **Note**: You are NOT allowed to use any pre-existing libraries for Huffman coding. Implement the algorithms and data structures from scratch.","solution":"import heapq import os from collections import defaultdict, Counter class TreeNode: def __init__(self, char=None, freq=0): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq def calculate_frequencies(input_file): with open(input_file, \\"r\\") as file: text = file.read() return Counter(text) def generate_huffman_tree(signs_frequency): priority_queue = [TreeNode(char, freq) for char, freq in signs_frequency.items()] heapq.heapify(priority_queue) while len(priority_queue) > 1: node1 = heapq.heappop(priority_queue) node2 = heapq.heappop(priority_queue) merged = TreeNode(freq=node1.freq + node2.freq) merged.left = node1 merged.right = node2 heapq.heappush(priority_queue, merged) return priority_queue[0] if priority_queue else None def generate_codes(tree, prefix=\\"\\", codebook=None): if codebook is None: codebook = {} if tree is not None: if tree.char is not None: codebook[tree.char] = prefix generate_codes(tree.left, prefix + \\"0\\", codebook) generate_codes(tree.right, prefix + \\"1\\", codebook) return codebook def encode_data(input_file, output_file, codes): with open(input_file, \\"r\\") as file: text = file.read() encoded_text = \'\'.join(codes[char] for char in text) # Store encoded text and tree with open(output_file, \\"wb\\") as file: # Write tree first file.write(repr(codes).encode(\'utf-8\')) file.write(b\'n\') # Write the encoded bit string padding_length = 8 - len(encoded_text) % 8 encoded_text += \\"0\\" * padding_length file.write(bytes([padding_length])) byte_array = bytearray() for i in range(0, len(encoded_text), 8): byte = encoded_text[i:i+8] byte_array.append(int(byte, 2)) file.write(byte_array) def decode_data(input_file, output_file): with open(input_file, \\"rb\\") as file: # Read Huffman codes dictionary codes_str = b\'\' while True: byte = file.read(1) if byte == b\'n\': break codes_str += byte codes = eval(codes_str.decode(\'utf-8\')) inv_codes = {v: k for k, v in codes.items()} # Read encoded data padding_length = ord(file.read(1)) encoded_text = \'\' byte = file.read(1) while byte: byte = f\'{ord(byte):08b}\' encoded_text += byte byte = file.read(1) encoded_text = encoded_text[:-padding_length] # Decode using the Huffman codes current_code = \'\' decoded_text = [] for bit in encoded_text: current_code += bit if current_code in inv_codes: decoded_text.append(inv_codes[current_code]) current_code = \'\' decoded_text = \'\'.join(decoded_text) with open(output_file, \\"w\\") as file: file.write(decoded_text)"},{"question":"You have been hired as a software developer for a startup that processes large datasets of numerical data. However, you have been tasked to work on a specific module that deals with small or nearly sorted datasets most of the time. Your manager wants you to implement a sorting algorithm that is simple and effective for such datasets. Your task is to implement a sorting function using the **Cocktail Shaker Sort** algorithm. This bi-directional sorting algorithm is an extension of Bubble Sort. It is particularly useful for datasets that are usually small or nearly sorted. # Function Signature ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: pass ``` # Input * A list of integers `arr` where `0 <= len(arr) <= 10^3` and all elements are within the range `-10^6` to `10^6`. # Output * A list of integers sorted in ascending order. # Constraints * Aim for an in-place sorting to maintain O(1) space complexity. * Optimize to handle cases where the array might already be sorted efficiently. # Example ```python assert cocktail_shaker_sort([3, 2, 1]) == [1, 2, 3] assert cocktail_shaker_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert cocktail_shaker_sort([5, 3, 4, 1, 2]) == [1, 2, 3, 4, 5] assert cocktail_shaker_sort([]) == [] assert cocktail_shaker_sort([5, 5, 5, 5, 5]) == [5, 5, 5, 5, 5] ``` # Explanation * The function `cocktail_shaker_sort` should handle typical edge cases such as empty arrays, single element arrays, and arrays with all identical elements. * Ensure your function passes the provided examples and additional test cases with large but small-sized datasets optimally. * Consider the adaptive nature of the Cocktail Shaker Sort to quickly identify if the list is already sorted to optimize performance.","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: Sorts the list using the Cocktail Shaker Sort algorithm. n = len(arr) if n < 2: return arr is_sorted = False start = 0 end = n - 1 while not is_sorted: is_sorted = True # Traverse from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] is_sorted = False # If no elements were swapped, the list is sorted if is_sorted: break # Prepare for the next phase is_sorted = True end -= 1 # Traverse from right to left for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] is_sorted = False start += 1 return arr"},{"question":"**Objective**: Implement an enhanced palindrome checker function that addresses various edge cases elegantly and efficiently. # Context: A local library has a project to digitalize and archive historical texts. One of their tasks is to verify if a text excerpt is a palindrome, ignoring non-alphanumeric characters and considering case insensitivity. Given diverse inputs, some of which are very lengthy or predominantly punctuated, they need your help to implement a robust palindrome checking function. # Task: Write a Python function `enhanced_is_palindrome(text)` that takes in a string `text` and returns `True` if it is a palindrome, otherwise returns `False`. # Requirements: - Only alphanumeric characters should be considered. - Ignore case differences. - Handle edge cases including empty strings and strings with only non-alphanumeric characters. - Performance should be optimized for large texts. # Input Format: ```python def enhanced_is_palindrome(text: str) -> bool: ``` - `text` (String): The text to be checked for palindrome properties. # Output Format: - Returns `True` if the input string is a palindrome, otherwise `False`. # Constraints: - `0 <= len(text) <= 10^6` # Examples: 1. `enhanced_is_palindrome(\\"A man, a plan, a canal: Panama\\")` should return `True`. 2. `enhanced_is_palindrome(\\"race a car\\")` should return `False`. 3. `enhanced_is_palindrome(\\"\\")` should return `True`. **Note**: - You should not use extra space beyond O(1) for this implementation.","solution":"def enhanced_is_palindrome(text: str) -> bool: This function checks if the given text is a palindrome, ignoring non-alphanumeric characters and case insensitivity. Args: text (str): The input string. Returns: bool: True if the text is a palindrome, False otherwise. # Define two pointers, one at the start and one at the end of the text left, right = 0, len(text) - 1 while left < right: # Move the left pointer while it\'s not pointing to an alphanumeric character while left < right and not text[left].isalnum(): left += 1 # Move the right pointer while it\'s not pointing to an alphanumeric character while left < right and not text[right].isalnum(): right -= 1 # Compare the characters at left and right pointers if text[left].lower() != text[right].lower(): return False # Move both pointers towards the center left += 1 right -= 1 return True"},{"question":"# Question You are given two strings `s` and `t` that consist exclusively of lowercase letters. String `t` is formed by shuffling string `s` and adding one additional character at a random position. Write a function `find_difference` that identifies the letter added to `t`. Function Signature ```python def find_difference(s: str, t: str) -> str: ``` Input * `s` (0 <= len(s) <= 1000): A string of lowercase letters. * `t` (len(s) + 1): A string created by shuffling `s` and adding one more letter. Output * Return the additional letter added to `t` as a single character string. Constraints * Only lowercase letters will be used. * It is guaranteed that `t` always has exactly one extra character compared to `s`. Example ```python s = \\"abcd\\" t = \\"abecd\\" # Output: \'e\' s = \\"xyz\\" t = \\"yzxa\\" # Output: \'a\' ``` Scenario Consider a scenario where two lists of students\' names were created. The second list contains all the names from the first list, but due to a mix-up, an additional name was added. You need to identify that extra name using the `find_difference` function.","solution":"def find_difference(s: str, t: str) -> str: Identifies the letter added to t which is not present in s. # Initialize a dictionary to keep track of character frequencies in s char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Iterate through t and find the extra character for char in t: if char not in char_count or char_count[char] == 0: return char else: char_count[char] -= 1"},{"question":"Implement Dijkstra\'s Algorithm with an Extended Functionality Problem Statement You are tasked with implementing an enhanced version of Dijkstra\'s single-source shortest-path algorithm. Your implementation should not only return the shortest distances but also provide the actual shortest path from the source node to a specific target node in a graph. Input * An integer `vertex_count` representing the number of vertices in the graph. * A 2D list `graph` where `graph[i][j]` represents the weight of the edge from node `i` to node `j`. If there is no edge, the weight will be `0`. * An integer `src` representing the source node. * An integer `target` representing the target node. Output * A tuple containing: * A list of integers where the value at each index `i` represents the shortest distance from the source node to node `i`. * A list of integers representing the shortest path from the source node to the `target` node. Constraints * The graph is represented as a fully connected directed graph with non-negative edge weights. * `0 <= vertex_count <= 1000` * `0 <= weight <= 10^5` * The source and target nodes are valid nodes in the graph (0-indexed). Requirements * Implement the function: `dijkstra_extended(vertex_count, graph, src, target)`. * The function should return a tuple `(distances, path)`. * Ensure your solution is efficient and handles edge cases appropriately. # Example ```python vertex_count = 5 graph = [ [0, 10, 0, 0, 5], [0, 0, 1, 0, 2], [0, 0, 0, 4, 0], [7, 0, 6, 0, 0], [0, 3, 9, 2, 0] ] src = 0 target = 3 output = dijkstra_extended(vertex_count, graph, src, target) print(output) # Expected: ([0, 8, 9, 7, 5], [0, 4, 3]) ``` *Explanation*: The shortest path from node `0` to node `3` goes through node `4`. The distances from the source node `0` to all other nodes are [0, 8, 9, 7, 5].","solution":"import heapq def dijkstra_extended(vertex_count, graph, src, target): Implementation of Dijkstra\'s algorithm to find the shortest paths and the specific shortest path from src to target. # Initialize distances with infinity and prev with None distances = [float(\'inf\')] * vertex_count prev = [None] * vertex_count distances[src] = 0 # Priority queue (min-heap) pq = [(0, src)] while pq: current_distance, u = heapq.heappop(pq) if current_distance > distances[u]: continue for v in range(vertex_count): if graph[u][v] != 0 and u != v: # Edge exists distance = current_distance + graph[u][v] if distance < distances[v]: distances[v] = distance prev[v] = u heapq.heappush(pq, (distance, v)) # Reconstruct shortest path to target path = [] if distances[target] != float(\'inf\'): node = target while node is not None: path.insert(0, node) node = prev[node] return distances, path"},{"question":"# Context You are tasked with building an autocomplete feature for a text-based application. You need a data structure to efficiently store a large collection of words and provide fast prefix-based search functionality. # Task Implement a Python class `AutocompleteSystem` that extends the provided `Trie` class. This class should incorporate an `autocomplete` method, which returns all words in the Trie that start with a given prefix. # Requirements - **Function Name**: `autocomplete` - **Input**: A string `prefix` - **Output**: A list of strings, containing all words in the Trie that start with the given prefix. - **Constraints**: - All inputs consist of lowercase letters a-z. - The number of words in the Trie is at most 10^6. - The average length of words is around 10, with a maximum length of 5000. # Example ```python autocomplete_system = AutocompleteSystem() autocomplete_system.insert(\\"apple\\") autocomplete_system.insert(\\"application\\") autocomplete_system.insert(\\"appliance\\") autocomplete_system.insert(\\"banana\\") autocomplete_system.insert(\\"bandana\\") print(autocomplete_system.autocomplete(\\"app\\")) # Output: [\\"apple\\", \\"application\\", \\"appliance\\"] ``` # Notes - The returned words should be in lexicographic order. - If no word starts with the given prefix, return an empty list.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class AutocompleteSystem: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def _dfs(self, node, prefix): words = [] if node.is_end_of_word: words.append(prefix) for char in sorted(node.children): # ensure lexicographic order words.extend(self._dfs(node.children[char], prefix + char)) return words def autocomplete(self, prefix): node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] return self._dfs(node, prefix)"},{"question":"# Scenario Suppose you are working on a software system that requires generating different combinations of features for testing purposes. Each feature can either be included or excluded in a test configuration, and you need to ensure that all possible combinations are considered without any duplicates. Given an input list of distinct features, write a function to return all possible configurations. # Problem Statement You are tasked with writing a function `feature_combinations(features: List[int]) -> Set[tuple]` that takes a list of distinct integers representing features and returns a set of tuples, where each tuple represents a unique combination of features. Ensure that no duplicate combinations are included. # Input * `features`: A list of distinct integers representing features (1 <= len(features) <= 16). # Output * A set of tuples, where each tuple represents a unique combination of features. # Constraints * The input list will contain distinct integers. * Each feature should be considered for inclusion or exclusion in each combination. * The total number of generated combinations should not exceed 2^n, where n is the number of features. # Function Signature ```python from typing import List, Set, Tuple def feature_combinations(features: List[int]) -> Set[Tuple[int]]: pass ``` # Example ```python # Example 1 features = [1, 2, 3] output = feature_combinations(features) expected_output = {(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)} assert output == expected_output # Example 2 features = [] output = feature_combinations(features) expected_output = {()} assert output == expected_output # Example 3 features = [4, 5] output = feature_combinations(features) expected_output = {(), (4,), (5,), (4, 5)} assert output == expected_output ``` Your function should pass the provided examples and handle additional test cases covering various edge scenarios effectively.","solution":"from typing import List, Set, Tuple def feature_combinations(features: List[int]) -> Set[Tuple[int]]: from itertools import combinations result = set() length = len(features) for r in range(length + 1): # +1 to include empty set for comb in combinations(features, r): result.add(comb) return result"},{"question":"# Preorder Traversal Verification **Context**: You are given a representation of a binary tree. You need to perform preorder traversal and verify if the output matches the given expected sequence. **Task**: Implement a function `verify_preorder_traversal(root: Node, expected: List[int]) -> bool` that checks if the preorder traversal of the binary tree rooted at `root` matches the given list `expected`. **Function Signature**: ```python def verify_preorder_traversal(root: Node, expected: List[int]) -> bool: ``` **Input**: * `root` – The root node of the binary tree (Node). * `expected` – A list of integers representing the expected preorder traversal sequence. **Output**: * A boolean value `True` if the actual preorder traversal matches `expected`, otherwise `False`. **Constraints**: * The number of nodes in the tree is in the range [0, 10^4]. * Node values are unique integers. **Example**: ```python # Building the tree # 1 # / # 2 3 # / # 4 5 n1 = Node(1) n2 = Node(2) n3 = Node(3) n4 = Node(4) n5 = Node(5) n1.left = n2 n1.right = n3 n2.left = n4 n2.right = n5 # Verify preorder traversal assert verify_preorder_traversal(n1, [1, 2, 4, 5, 3]) == True assert verify_preorder_traversal(n1, [1, 3, 2, 4, 5]) == False ``` **Explanation**: * In the first example, the tree\'s preorder traversal is `[1, 2, 4, 5, 3]`, which matches the `expected` list, so the function returns `True`. * In the second example, the expected sequence does not match the actual traversal, so the function returns `False`.","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def verify_preorder_traversal(root: Node, expected: list[int]) -> bool: def preorder(node): if node: result.append(node.value) preorder(node.left) preorder(node.right) result = [] preorder(root) return result == expected"},{"question":"# Path Simplification **Scenario**: You are developing a system that manages Unix-style file paths. Given a string representing an absolute path for a file, you need to simplify it. This involves resolving \'.\' (current directory), \'..\' (parent directory), and redundant slashes. **Task**: Write a function `simplify_path(path: str) -> str` that takes an absolute Unix-style file path as a string and returns the simplified canonical path. **Input Format**: - `path` (string): An absolute path. **Output Format**: - A string representing the simplified canonical path. **Constraints**: - 1 <= `path.length` <= 3000 - `path` is a valid absolute Unix path which always starts with ‘/’. **Performance Requirements**: - Aim for O(n) time complexity where n is the length of the input path. - Minimize additional space usage where possible. **Examples**: 1. **Input**: `\\"/home/\\"` - **Output**: `\\"/home\\"` 2. **Input**: `\\"/a/./b/../../c/\\"` - **Output**: `\\"/c\\"` 3. **Input**: `\\"/../\\"` - **Output**: `\\"/\\"` 4. **Input**: `\\"/home//foo/\\"` - **Output**: `\\"/home/foo\\"` Edge Cases: - Handling input paths containing multiple consecutive slashes. - Resolving parent directory references that move above the root directory. # Example Function Signature ```python def simplify_path(path: str) -> str: # Write your solution here pass ```","solution":"def simplify_path(path: str) -> str: Simplify the given absolute Unix-style file path. Parameters: path (str): An absolute path Returns: str: The simplified canonical path stack = [] parts = path.split(\'/\') for part in parts: if part == \'\' or part == \'.\': continue elif part == \'..\': if stack: stack.pop() else: stack.append(part) return \'/\' + \'/\'.join(stack)"},{"question":"# Complete the BST Iterator Implementation As an experienced software developer, you\'ve been given a partially implemented `BSTIterator` class and asked to implement the required functionality for iterating through a binary search tree (BST). Task: Complete the following methods: 1. `has_next()` - Returns `True` if there are further nodes to be visited in the in-order traversal. 2. `next()` - Returns the next smallest node in the BST according to in-order traversal. # Constraints: - The number of nodes in the tree is within the range `[0, 10^4]`. - `-10^5 <= Node.val <= 10^5` # Scenario/Context: Imagine you are implementing a library requiring sorted iteration through a BST. Your implementation should guarantee that each call to `next` retrieves the next in-order element while maintaining an overall average O(1) time complexity for each traversal operation. # Input: Your input will include a construction of the `BSTIterator` using a root node of a BST and multiple calls to the methods `has_next()` and `next()`. # Output: Your implementation should properly function with successive calls to `has_next()` and `next()`, yielding elements in ascending order. # Code Snippet for Implementation: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root): Initializes an iterator object that will traverse the BST in in-order. :param root: TreeNode, the root of the BST. self.stack = [] while root: self.stack.append(root) root = root.left def has_next(self): Return true if there are further nodes to be visited in the in-order traversal. :rtype: bool return bool(self.stack) def next(self): Return the next smallest number in the in-order traversal. :rtype: int node = self.stack.pop() tmp = node if tmp.right: tmp = tmp.right while tmp: self.stack.append(tmp) tmp = tmp.left return node.val ``` Example: ```python # Construct the BST: # 7 # / # 3 15 # / / # 2 9 20 root = TreeNode(7) root.left = TreeNode(3) root.left.left = TreeNode(2) root.right = TreeNode(15) root.right.left = TreeNode(9) root.right.right = TreeNode(20) # Initialize iterator iterator = BSTIterator(root) # Iterate through BST result = [] while iterator.has_next(): result.append(iterator.next()) # Output: [2, 3, 7, 9, 15, 20] print(result) ``` Ensure that your solution caters to performance constraints and handles the edge cases effectively.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root): Initializes an iterator object that will traverse the BST in in-order. :param root: TreeNode, the root of the BST. self.stack = [] # Initialize the iterator with the leftmost nodes self._push_leftmost_nodes(root) def _push_leftmost_nodes(self, node): Helper function to push all leftmost nodes to the stack. while node: self.stack.append(node) node = node.left def has_next(self): Return true if there are further nodes to be visited in the in-order traversal. :rtype: bool return bool(self.stack) def next(self): Return the next smallest number in the in-order traversal. :rtype: int # The next smallest element node = self.stack.pop() # If there is a right subtree, push all its leftmost nodes to the stack if node.right: self._push_leftmost_nodes(node.right) return node.val"},{"question":"# Rotating a Square Matrix Problem Statement You are given an `n x n` 2D matrix representing an image. Write a function that rotates the image by 90 degrees clockwise in-place. Function Signature ```python def rotate(matrix: List[List[int]]) -> None: Rotate the matrix by 90 degrees clockwise in place. Parameters: matrix (List[List[int]]): n x n 2D matrix to rotate. Returns: None: The matrix is modified in-place. ``` Input - `matrix`: List of lists of integers representing an `n x n` 2D matrix. - Constraints: - 1 <= n <= 20 (the matrix will be small to keep performance manageable). - The matrix will contain integers between -1000 and 1000. Output - The function should modify the input matrix in-place and return None. The matrix will be rotated such that after the transformation, the element at `matrix[i][j]` will be moved to `matrix[j][n-1-i]`. Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate(matrix) # After calling rotate(matrix), matrix should become: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` Constraints & Considerations - The solution must perform the rotation in-place. - Consider edge cases such as: - A single element matrix. - All elements being the same. - Negative and positive integers mixed in the matrix. Write the complete function `rotate(matrix: List[List[int]]) -> None` and ensure it performs the rotation in-place.","solution":"from typing import List def rotate(matrix: List[List[int]]) -> None: Rotate the matrix by 90 degrees clockwise in place. Parameters: matrix (List[List[int]]): n x n 2D matrix to rotate. Returns: None: The matrix is modified in-place. n = len(matrix) # First, transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then, reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Context In a network, nodes can represent computers or other devices, and edges can represent connections between these devices. Your task is to implement a function that can find all possible paths between two devices in a network, given potential constraints and optimization requirements. # Problem Statement Implement a function `find_optimized_all_paths(graph, start, end)` that finds all paths between two nodes in an unweighted graph while optimizing for large graphs without compromising on correctness. # Function Signature ```python def find_optimized_all_paths(graph: dict, start: str, end: str) -> list: ``` # Input * `graph` (dict): A dictionary representing an unweighted, directed graph. Keys are node identifiers (strings), and values are lists of adjacent nodes. * `start` (str): The starting node identifier. * `end` (str): The ending node identifier. # Output * A list of lists representing all unique paths from `start` to `end`. # Constraints 1. The graph will contain at most 10,000 nodes and 50,000 edges. 2. The function should minimize memory usage. 3. The start and end nodes are guaranteed to be different. 4. The function should handle cycles in the graph properly without going into infinite loops. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [\'E\'], \'E\': [] } start = \'A\' end = \'D\' print(find_optimized_all_paths(graph, start, end)) # Expected Output: [[\'A\', \'B\', \'D\'], [\'A\', \'B\', \'C\', \'D\'], [\'A\', \'C\', \'D\']] ``` # Notes * Ensure that your solution avoids unnecessary memory usage and handles large graphs efficiently. * Consider using iterative depth-first search (DFS) with a stack to avoid deep recursion issues and compare different approaches to find optimal performance within given constraints.","solution":"def find_optimized_all_paths(graph, start, end): Finds all paths from \'start\' to \'end\' in a directed graph. def dfs(node, path): # Add the current node to the path path.append(node) # If reached the end node, add the path to the result if node == end: results.append(path[:]) else: # Recur for all the neighbors for neighbor in graph.get(node, []): if neighbor not in path: # avoid cycles dfs(neighbor, path) # Backtrack: remove the current node from the path path.pop() results = [] dfs(start, []) return results"},{"question":"# Context You are working on a project that involves processing a sequence of operations on a stack data structure. The stack needs to support basic operations and you must ensure it handles edge cases properly. # Problem Statement Implement a function `process_stack_operations(operations, stack_type)` to simulate a sequence of stack operations. The function takes two parameters: 1. `operations` (list of tuples): Each tuple contains an operation (str) and an optional value (int). - Operations include: \\"push\\", \\"pop\\", \\"peek\\", \\"is_empty\\". 2. `stack_type` (str): Determines the type of stack to use; either \\"array\\" or \\"linked\\". The function should return a list of results corresponding to each operation: - For \\"push\\", return None. - For \\"pop\\" and \\"peek\\", return the value. - For \\"is_empty\\", return a boolean value. # Example ```python operations = [(\\"push\\", 10), (\\"push\\", 20), (\\"peek\\",), (\\"pop\\",), (\\"is_empty\\",), (\\"pop\\",), (\\"is_empty\\",)] stack_type = \\"array\\" ``` Expected output: ```python [None, None, 20, 20, False, 10, True] ``` Notes - Handle any errors (e.g., popping from an empty stack) by returning a relevant error message. # Constraints - Operations list length: 1 ≤ len(operations) ≤ 1000 - Values will be non-negative integers only. # Function Signature ```python def process_stack_operations(operations, stack_type): pass ``` # Requirements - Implement at least one stack using an array (ArrayStack) and one using linked nodes (LinkedListStack). You may use the given code snippets as references. - Ensure the solution handles edge cases, such as operations on an empty stack. - Ensure operations are efficient based on the chosen stack type. - Handle invalid stack types appropriately.","solution":"class ArrayStack: def __init__(self): self.stack = [] def push(self, value): self.stack.append(value) def pop(self): if self.is_empty(): return \\"Error: Pop from empty stack\\" return self.stack.pop() def peek(self): if self.is_empty(): return \\"Error: Peek from empty stack\\" return self.stack[-1] def is_empty(self): return len(self.stack) == 0 class LinkedListStack: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self): self.head = None def push(self, value): new_node = self.Node(value) new_node.next = self.head self.head = new_node def pop(self): if self.is_empty(): return \\"Error: Pop from empty stack\\" value = self.head.value self.head = self.head.next return value def peek(self): if self.is_empty(): return \\"Error: Peek from empty stack\\" return self.head.value def is_empty(self): return self.head is None def process_stack_operations(operations, stack_type): if stack_type == \\"array\\": stack = ArrayStack() elif stack_type == \\"linked\\": stack = LinkedListStack() else: return \\"Error: Invalid stack type\\" result = [] for operation in operations: if operation[0] == \\"push\\": stack.push(operation[1]) result.append(None) elif operation[0] == \\"pop\\": result.append(stack.pop()) elif operation[0] == \\"peek\\": result.append(stack.peek()) elif operation[0] == \\"is_empty\\": result.append(stack.is_empty()) else: result.append(\\"Error: Unknown operation\\") return result"},{"question":"You are given a binary tree. Your task is to write an efficient function to determine the maximum depth of this tree using an iterative method. # Function Signature ```python def iterative_max_depth(root: TreeNode) -> int: ``` # Input * `root` (TreeNode): The root node of the binary tree. The TreeNode class is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output * Return an integer representing the maximum depth of the binary tree. # Constraints * The number of nodes in the tree is in the range [0, 10^4]. * -1000 <= Node.val <= 1000 # Example ```python # Example Usage: # Given the binary tree: # 3 # / # 9 20 # / # 15 7 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) print(iterative_max_depth(root)) # Output: 3 ``` # Additional Context This problem tests your understanding of tree traversals using BFS. Your solution must efficiently handle both the time complexity and the space complexity considerations. Be mindful of edge cases such as empty trees (root is None) and ensure your solution is robust against these.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def iterative_max_depth(root: TreeNode) -> int: if not root: return 0 queue = deque([(root, 1)]) # queue stores tuples of (node, current_depth) max_depth = 0 while queue: node, depth = queue.popleft() max_depth = max(max_depth, depth) if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return max_depth"},{"question":"You are given a stack of integers. Your task is to write a Python function that takes this stack as an input and replaces every value in the stack with two occurrences of that value, maintaining the original order. You must implement this functionality using two methods: 1. Using a single additional stack. 2. Using a single additional queue. # Functions You need to implement the following functions: **Function 1:** ```python def stutter_using_stack(stack: List[int]) -> List[int]: Given a stack as a list of integers, this function uses another stack as auxiliary storage to replace every value in the stack with two occurrences of that value. Args: stack (List[int]): The original stack represented as a list, where the end of the list is the top of the stack. Returns: List[int]: The modified stack with each value replaced with two occurrences. ``` **Function 2:** ```python def stutter_using_queue(stack: List[int]) -> List[int]: Given a stack as a list of integers, this function uses a queue as auxiliary storage to replace every value in the stack with two occurrences of that value. Args: stack (List[int]): The original stack represented as a list, where the end of the list is the top of the stack. Returns: List[int]: The modified stack with each value replaced with two occurrences. ``` # Input/Output Formats * **Input**: A stack represented as a list of integers. * **Output**: A modified stack where every element occurs twice, maintaining the original order. # Example Example 1: * Input: `[3, 7, 1, 14, 9]` * Output: `[3, 3, 7, 7, 1, 1, 14, 14, 9, 9]` # Constraints * The number of elements in the stack should be within the range of [0, 10^4]. * Element values should be integers. # Notes: * Ensure that your solution handles edge cases, such as an empty stack or a stack with only one element, effectively. * You are not allowed to use any built-in libraries for duplication functionalities other than stacks and queues.","solution":"from typing import List def stutter_using_stack(stack: List[int]) -> List[int]: Given a stack as a list of integers, this function uses another stack as auxiliary storage to replace every value in the stack with two occurrences of that value. Args: stack (List[int]): The original stack represented as a list, where the end of the list is the top of the stack. Returns: List[int]: The modified stack with each value replaced with two occurrences. if not stack: return stack aux_stack = [] while stack: temp = stack.pop() aux_stack.append(temp) aux_stack.append(temp) while aux_stack: stack.append(aux_stack.pop()) return stack def stutter_using_queue(stack: List[int]) -> List[int]: Given a stack as a list of integers, this function uses a queue as auxiliary storage to replace every value in the stack with two occurrences of that value. Args: stack (List[int]): The original stack represented as a list, where the end of the list is the top of the stack. Returns: List[int]: The modified stack with each value replaced with two occurrences. if not stack: return stack from collections import deque queue = deque() while stack: temp = stack.pop() queue.appendleft(temp) queue.appendleft(temp) while queue: stack.append(queue.popleft()) return stack"},{"question":"You have been given the task to implement an advanced sorting algorithm on a small dataset from a financial report. The algorithm you need to implement is called **Stooge Sort**. Given an array of integers, your task is to sort the array in ascending order using Stooge Sort. # Function Signature ```python def stooge_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr`: A list of integers, containing up to `20` elements, where `1 <= arr[i] <= 10^6`. # Output * Returns a new list containing elements sorted in ascending order. # Constraints * The input list will contain at most `20` elements. * The elements in the array are positive integers. # Example ```python assert stooge_sort([2, 4, 5, 3, 1]) == [1, 2, 3, 4, 5] assert stooge_sort([10, 9, 8, 7]) == [7, 8, 9, 10] assert stooge_sort([1, 1, 1, 1]) == [1, 1, 1, 1] assert stooge_sort([]) == [] assert stooge_sort([1]) == [1] ``` # Explanation You should implement the function `stooge_sort` which sorts the list using the following steps: 1. If the first element is greater than the last element, swap them. 2. Recursively sort the first 2/3 of the list. 3. Recursively sort the last 2/3 of the list. 4. Recursively sort the first 2/3 of the list again to ensure it is sorted. **Note:** The provided array can have up to 20 elements, so ensure your solution is optimized and performs well within these constraints. **Hints**: 1. Use recursion for this problem. 2. Handle the base cases effectively to avoid infinite recursion.","solution":"def stooge_sort(arr): def stooge_sort_recursive(arr, l, h): if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stooge_sort_recursive(arr, l, h - t) stooge_sort_recursive(arr, l + t, h) stooge_sort_recursive(arr, l, h - t) if not arr: # If the array is empty, return it as it is. return arr n = len(arr) stooge_sort_recursive(arr, 0, n - 1) return arr"},{"question":"# Matrix Chain Multiplication Optimization Given an array representing the dimensions of matrices, determine the minimum number of multiplication operations needed to multiply the sequence of matrices. You are provided the dimensions in an array such that the i-th matrix has dimensions `(array[i-1] x array[i])`. # Function Signature ```python def matrix_chain_multiplication(arr: List[int]) -> int: ``` # Input * `arr` - A list of integers representing the dimensions of matrices. (2 <= len(arr) <= 100) # Output * Return an integer representing the minimum number of multiplications required to multiply the sequence of matrices. # Constraints * Ensure to optimize for time and space complexity. * Handle edge cases where the list contains fewer than 2 elements. # Example ```python assert matrix_chain_multiplication([30, 35, 15, 5, 10, 20, 25]) == 15125 assert matrix_chain_multiplication([10, 20, 30, 40, 30]) == 30000 assert matrix_chain_multiplication([10, 20, 30]) == 6000 ``` # Requirements * Your solution should run in O(n^3) time complexity. * The output should be correct for varied inputs, including edge cases.","solution":"from typing import List def matrix_chain_multiplication(arr: List[int]) -> int: n = len(arr) # DP table to store results of subproblems dp = [[0 for _ in range(n)] for _ in range(n)] # L is chain length. for L in range(2, n): for i in range(1, n - L + 1): j = i + L - 1 dp[i][j] = float(\'inf\') for k in range(i, j): q = dp[i][k] + dp[k+1][j] + arr[i-1] * arr[k] * arr[j] if q < dp[i][j]: dp[i][j] = q return dp[1][n-1]"},{"question":"# Scenario You are a software engineer at a security company, and one of your tasks is to implement fundamental number theory functions for cryptographic algorithms. Given your deep understanding of algorithms, you need to implement an efficient algorithm to find the Euler\'s Totient function for a given integer `n`. # Question Implement a function `efficient_totient(n)` that calculates the Euler\'s Totient function ϕ(n) for a given positive integer `n`. Input: - An integer `n` (1 ≤ n ≤ 10^6). Output: - Return an integer which is the count of numbers from 1 to `n` that are coprime with `n`. Constraints: - Your solution should be efficient with respect to both time and space. - Assume `n` will always be a positive integer greater than 0. # Performance Requirements: - The algorithm should have a time complexity of at most O(sqrt(n)). - The space consumption should remain constant (O(1)). # Example: ```python assert efficient_totient(1) == 1 assert efficient_totient(2) == 1 assert efficient_totient(9) == 6 # The numbers 1, 2, 4, 5, 7, 8 are coprime with 9. assert efficient_totient(10) == 4 # The numbers 1, 3, 7, 9 are coprime with 10. ``` Implement the function `efficient_totient(n)`. It should return the correct results as specified in the examples above.","solution":"def efficient_totient(n): Calculates the Euler\'s Totient function ϕ(n) for a given positive integer n. This function returns the number of integers up to n that are coprime with n. Args: n (int): A positive integer Returns: int: The count of numbers from 1 to n that are coprime with n. if n == 1: return 1 result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result"},{"question":"# Problem: Moving Average Using Sliding Window Scenario You are developing a financial software application that provides real-time analytics of stock prices. One of the features you need to implement is the calculation of the moving average of stock prices based on the most recent transactions. Your task is to write a class that efficiently computes the moving average of all integers within a sliding window. Description Implement a `MovingAverage` class: * **Constructor**: `__init__(self, size: int)`: Initializes a new moving average calculator with a window size `size`. * **Method**: `next(self, val: int) -> float`: Given an integer `val`, returns the current moving average of the last `size` elements. Input and Output * **Input**: * The constructor receives a single integer `size` representing the fixed number of elements used to calculate the moving average. * The `next` method receives an integer `val` which is the next number in the stream of integers. * **Output**: * The `next` method returns the current moving average as a float. Constraints * You may assume that all integer inputs for `val` are non-negative. * The `size` parameter is a positive integer greater than 0. Example ```python m = MovingAverage(3) print(m.next(1)) # Output: 1.0 print(m.next(10)) # Output: 5.5 print(m.next(3)) # Output: 4.67 (approx) print(m.next(5)) # Output: 6.0 ``` **Explanation**: 1. The moving average of [1] is 1.0. 2. The moving average of [1, 10] is (1 + 10) / 2 = 5.5. 3. The moving average of [1, 10, 3] is (1 + 10 + 3) / 3 ≈ 4.67. 4. The moving average of [10, 3, 5] is (10 + 3 + 5) / 3 = 6.0. Performance Requirements * The `next` method should run in O(1) time. * Overall space complexity should be O(size).","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): Initialize the MovingAverage with a specific window size. self.size = size self.queue = deque() self.sum = 0 def next(self, val: int) -> float: Calculate the moving average of the last \'size\' elements. self.queue.append(val) self.sum += val if len(self.queue) > self.size: self.sum -= self.queue.popleft() return self.sum / len(self.queue)"},{"question":"Context: You are developing a text editor feature to highlight all occurrences of a user-specified pattern within a document. For this task, you decide to implement a highly efficient string searching algorithm, the Knuth-Morris-Pratt (KMP) algorithm, which preprocesses the pattern to quickly locate its occurrences in the text. Task: Implement the KMP algorithm to find all start indexes of the pattern in the given text. Your function should return a list of starting indices where the pattern is found in the text. Function Signature: ```python def knuth_morris_pratt(text: Sequence[str], pattern: Sequence[str]) -> List[int]: ``` Input: - `text` (Sequence[str]): The text in which to search for the pattern. - `pattern` (Sequence[str]): The pattern to search in the text. Output: - A list of integers, representing the start indices where the pattern matches in the text. Constraints: 1. `0 <= len(text), len(pattern) <= 10^5` 2. The text and pattern consist of printable ASCII characters. Example: ```python assert knuth_morris_pratt(\'hello there hero!\', \'he\') == [0, 7, 12] assert knuth_morris_pratt(\'hello\', \'\') == [] assert knuth_morris_pratt(\'aaaaa\', \'aa\') == [0, 1, 2, 3] assert knuth_morris_pratt(\'abcde\', \'f\') == [] ``` Notes: - Your implementation should handle the case where the pattern is an empty string by returning an empty list. - Ensure your implementation adheres to the time complexity of O(N + M). Evaluation Criteria: - **Correctness**: The function should return the correct list of starting indices for any valid input. - **Efficiency**: The function should run within the time constraints given the input size. - **Edge cases**: Ensure your function handles edge cases such as empty text/pattern, repeated characters, and pattern longer than text.","solution":"from typing import List, Sequence def knuth_morris_pratt(text: Sequence[str], pattern: Sequence[str]) -> List[int]: if len(pattern) == 0: return [] def compute_lps_array(pattern): lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = compute_lps_array(pattern) i, j = 0, 0 result = [] while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"# Move Zeros Algorithm **Objective**: Implement a function `move_zeros_inplace` that moves all the zero elements to the end of the list in place, preserving the order of the non-zero elements. # Function Signature ```python def move_zeros_inplace(array: list) -> None: ``` # Input and Output Formats * **Input**: A list of arbitrary elements. * **Output**: The function returns `None`. The input list should be modified in-place with all zeros moved to the end. The order of non-zero elements must be maintained. # Constraints * The function should handle boolean, integer, float, and string types, correctly treating `0.0` as zero but not boolean `False`. * Do not create a new list in your function; modify the input list in place. # Examples ```python array = [False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"] move_zeros_inplace(array) print(array) # Output: [False, 1, 1, 2, 1, 3, \'a\', 0, 0] array = [0, 0, 0, 1] move_zeros_inplace(array) print(array) # Output: [1, 0, 0, 0] array = [0, False, 0.0, \'0\', 0, 10] move_zeros_inplace(array) print(array) # Output: [False, \'0\', 10, 0, 0, 0] ``` # Notes 1. **Edge Cases**: Consider lists with no zeros, all zeros, or various data types. 2. **Performance**: Aim for O(n) time complexity with O(1) additional space.","solution":"def move_zeros_inplace(array: list) -> None: Moves all zeros in the list to the end, maintaining the order of non-zero elements. This is done in-place without creating a new list. zero_count = 0 i = 0 while i < len(array): if type(array[i]) in [int, float] and array[i] == 0: zero_count += 1 array.pop(i) else: i += 1 array.extend([0] * zero_count)"},{"question":"# Implement Enhanced B-Tree Operations Context You are working with a B-tree, a balanced tree data structure maintaining sorted data and enabling efficient insertion, deletion, and search operations. The B-tree is optimized for systems that read and write large blocks of data, and it is widely used in database and file systems. Your task is to implement an enhanced version of the B-tree class, focusing on the following operations and ensuring efficiency and correctness, especially in balancing the tree during insertions and deletions. Requirements 1. **Write a function to perform a range search**: Given two keys, return all keys within this range (inclusive). 2. **Write a function to bulk insert**: Take a list of keys and insert them into the B-tree. 3. **Write a function to count keys**: Return the total number of keys present in the B-tree. Input and Output Formats 1. **Range Search**: - **Input**: `range_search(self, start_key: int, end_key: int) -> List[int]` - **Output**: List of keys in the inclusive range `[start_key, end_key]`. 2. **Bulk Insert**: - **Input**: `bulk_insert(self, keys: List[int]) -> None` - **Output**: None, but the B-tree must be updated with the list of keys. 3. **Count Keys**: - **Input**: `count_keys(self) -> int` - **Output**: An integer representing the number of keys in the B-tree. Constraints - The B-tree degree (`t_val`) will be a positive integer greater than 1. - The number of keys can be very large, ranging up to 100,000. - The operations should maintain the average and worst-case complexities mentioned above. Your Task Implement the specified functions (`range_search`, `bulk_insert`, and `count_keys`) as part of the `BTree` class. Ensure your implementation is efficient and correctly maintains the B-tree properties during all operations. ```python from typing import List class BTree: # Your current BTree class implementation here. # ... def range_search(self, start_key: int, end_key: int) -> List[int]: # Implement this method pass def bulk_insert(self, keys: List[int]) -> None: # Implement this method pass def count_keys(self) -> int: # Implement this method pass ```","solution":"from typing import List, Optional class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node, else False self.keys = [] # List of keys self.children = [] # List of child BTreeNode instances class BTree: def __init__(self, t: int): self.root = BTreeNode(t, True) self.t = t def _range_search_recursive(self, node: BTreeNode, start_key: int, end_key: int, result: List[int]): i = 0 while i < len(node.keys) and node.keys[i] < start_key: i += 1 while i < len(node.keys) and node.keys[i] <= end_key: if not node.leaf: self._range_search_recursive(node.children[i], start_key, end_key, result) result.append(node.keys[i]) i += 1 if not node.leaf: self._range_search_recursive(node.children[i], start_key, end_key, result) def range_search(self, start_key: int, end_key: int) -> List[int]: result = [] self._range_search_recursive(self.root, start_key, end_key, result) return result def _split_child(self, parent: BTreeNode, i: int, node: BTreeNode): t = self.t new_node = BTreeNode(t, node.leaf) parent.children.insert(i + 1, new_node) parent.keys.insert(i, node.keys[t - 1]) new_node.keys = node.keys[t:(2 * t - 1)] node.keys = node.keys[0:(t - 1)] if not node.leaf: new_node.children = node.children[t:(2 * t)] node.children = node.children[0:t] def _insert_non_full(self, node: BTreeNode, key: int): i = len(node.keys) - 1 if node.leaf: node.keys.append(0) while i >= 0 and key < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = key else: while i >= 0 and key < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == (2 * self.t - 1): self._split_child(node, i, node.children[i]) if key > node.keys[i]: i += 1 self._insert_non_full(node.children[i], key) def bulk_insert(self, keys: List[int]) -> None: for key in keys: self.insert(key) def insert(self, key: int): root = self.root if len(root.keys) == (2 * self.t - 1): new_root = BTreeNode(self.t, False) new_root.children.append(self.root) self._split_child(new_root, 0, root) self._insert_non_full(new_root, key) self.root = new_root else: self._insert_non_full(root, key) def _count_keys_recursive(self, node: BTreeNode) -> int: total = len(node.keys) if not node.leaf: for child in node.children: total += self._count_keys_recursive(child) return total def count_keys(self) -> int: return self._count_keys_recursive(self.root)"},{"question":"# Problem: Implement a Function to Detect Cycles in a Directed Graph Scenario/Context: You are developing a system to manage dependencies between tasks in a project. Each task can depend on one or more other tasks. To ensure that the project is manageable and acyclic, you need to detect if there are any cyclic dependencies present. # Function Specification Write a function `detect_cycle(graph: Dict[str, List[str]]) -> bool` that takes in a directed graph represented as an adjacency list and returns a boolean indicating whether the graph contains a cycle. Input * `graph`: A dictionary where keys are task identifiers (strings) and values are lists of task identifiers (strings) that each task depends on. Output * Returns `True` if there is at least one cycle in the graph, `False` otherwise. Constraints * All task identifiers are unique strings. * The graph can have up to 10^4 vertices and 10^5 edges. * The function should be efficient and run within reasonable time limits for the given constraints. Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } assert detect_cycle(graph) == True graph2 = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [] } assert detect_cycle(graph2) == False ``` # Explanation * In `graph`, there\'s a cycle involving the tasks B -> D -> E -> B. * In `graph2`, there are no cycles as the dependencies form a directed acyclic graph. # Notes * Carefully handle the states of task identifiers to ensure correct cycle detection. * Optimize the function to handle the upper limits of input constraints efficiently.","solution":"def detect_cycle(graph): Detect if a directed graph contains a cycle. Args: graph (Dict[str, List[str]]): A dictionary representing the adjacency list of a directed graph. Returns: bool: True if there is a cycle in the graph, False otherwise. # Enum to mark states via dictionary lookup from enum import Enum class State(Enum): UNVISITED = 0 VISITING = 1 VISITED = 2 # Dictionary to track the state of each node visited = {node: State.UNVISITED for node in graph} def has_cycle(v): if visited[v] == State.VISITING: return True if visited[v] == State.VISITED: return False visited[v] = State.VISITING for neighbor in graph[v]: if has_cycle(neighbor): return True visited[v] = State.VISITED return False for node in graph: if visited[node] == State.UNVISITED: if has_cycle(node): return True return False"},{"question":"# RSA Key Generation and Encryption Scenario: You are asked to develop a secure communication system using the RSA encryption algorithm. Your task is to implement the key generation component, which is critical for setting up secure encryption and decryption channels. Problem: Implement the RSA key generation algorithm, focusing on generating appropriate keys: a modulus ( n ), an encryption exponent ( e ), and a decryption exponent ( d ). Function Signature: ```python def generate_rsa_key(bit_length: int, seed: Optional[int] = None) -> Tuple[int, int, int]: Generate RSA keys. :param bit_length: Number of bits for the modulus n. Should be at least 16. :param seed: Optional seed for the random number generator to ensure reproducibility. :return: A tuple (n, e, d) where n is the modulus, e is the encryption exponent, and d is the decryption exponent. ``` Input: * **bit_length** (int): Number of bits for the modulus ( n ). Should be at least 16. * **seed** (Optional[int]): Seed for the random number generator, to ensure reproducibility of test cases. Output: * **Tuple[int, int, int]**: A tuple containing the modulus ( n ), encryption exponent ( e ), and decryption exponent ( d ). Constraints: * The generated keys should be valid and satisfy RSA constraints. * Assume ( bit_length ) is always provided correctly as at least 16 bits. Task Requirements: 1. Generate two prime numbers ( p ) and ( q ) such that their product ( n = p times q ) is a bit_length-bit number. 2. Ensure ( e ) is a prime number and relatively small. 3. Compute the totient function ( phi(n) = (p-1) times (q-1) ). 4. Determine the decryption exponent ( d ) which is the modular multiplicative inverse of ( e ) modulo ( phi(n) ). Additional Notes: * Use efficient methods to determine prime numbers and the modular inverse. * Handle edge cases where prime generation might fail. Example: ```python # Example usage bit_length = 16 seed = 42 n, e, d = generate_rsa_key(bit_length, seed) print(f\\"n: {n}, e: {e}, d: {d}\\") ```","solution":"import random from sympy import isprime, mod_inverse def generate_prime_candidate(bit_length): Generate a random odd integer of the given bit length. p = random.getrandbits(bit_length) # Ensure the candidate is odd and has the correct bit length p |= (1 << bit_length - 1) | 1 return p def generate_prime_number(bit_length): Generate a prime number of the specified bit length. p = 4 # Initialize non-prime while not isprime(p): p = generate_prime_candidate(bit_length) return p def generate_rsa_key(bit_length: int, seed: int = None) -> tuple: Generate RSA keys. :param bit_length: Number of bits for the modulus n. Should be at least 16. :param seed: Optional seed for the random number generator to ensure reproducibility. :return: A tuple (n, e, d) where n is the modulus, e is the encryption exponent, and d is the decryption exponent. # Seed the random number generator if seed is provided if seed is not None: random.seed(seed) # Step 1: Generate two distinct primes p and q of bit_length/2 bits each half_bit_length = bit_length // 2 p = generate_prime_number(half_bit_length) q = generate_prime_number(half_bit_length) # Ensure p and q are distinct while q == p: q = generate_prime_number(half_bit_length) # Step 2: Compute n = p * q and φ(n) = (p-1) * (q-1) n = p * q phi = (p - 1) * (q - 1) # Step 3: Choose e such that 1 < e < φ(n) and gcd(e, φ(n)) = 1 e = 65537 # Commonly used prime exponent while phi % e == 0: e = generate_prime_number(16) # Try another small prime if necessary # Step 4: Compute d, the modular multiplicative inverse of e mod φ(n) d = mod_inverse(e, phi) return (n, e, d)"},{"question":"# Graph Path-finding Challenge You are a software engineer assigned to improve the pathfinding capabilities of a navigation system. Your task is to implement a function that finds the longest path in an unweighted directed graph. You are provided with the `start` and `end` nodes. Function Signature ```python def find_longest_path(graph: dict, start: str, end: str) -> list: Find the longest path between two nodes in an unweighted directed graph. Args: graph (dict): Adjacency list representation of the graph. start (str): The starting node. end (str): The destination node. Returns: list: A list of nodes representing the longest path from start to end. If no path exists, return an empty list. pass ``` Input - `graph`: A dictionary where keys are nodes and values are lists of adjacent nodes. - `start`: A string representing the start node. - `end`: A string representing the end node. Output - A list of nodes representing the longest path from start to end node. If no path exists, return an empty list. Constraints - Assume there are no negative weight cycles. - All nodes are unique. - The graph may contain cycles. Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [] } print(find_longest_path(graph, \'A\', \'D\')) # Example output: [\'A\', \'B\', \'C\', \'D\'] ``` Performance Requirements - Your solution should be efficient even for larger graphs with up to 100 nodes. Consider how recursion, backtracking, and careful state management can help you solve this problem. Be mindful of potential pitfalls like cycles and state restoration.","solution":"def find_longest_path(graph, start, end): Find the longest path between two nodes in an unweighted directed graph. Args: graph (dict): Adjacency list representation of the graph. start (str): The starting node. end (str): The destination node. Returns: list: A list of nodes representing the longest path from start to end. If no path exists, return an empty list. longest_path = [] def dfs(current, path): nonlocal longest_path path.append(current) if current == end: if len(path) > len(longest_path): longest_path = path.copy() else: for neighbor in graph.get(current, []): if neighbor not in path: # Avoid cycles dfs(neighbor, path) path.pop() dfs(start, []) return longest_path"},{"question":"# Question: Implement an Optimized Quick Sort **Objective**: Implement an enhanced version of the Quick Sort algorithm that optimizes pivot selection to improve performance on already sorted or nearly sorted arrays, and switches to Insertion Sort for smaller sub-arrays. **Requirements**: * **Input**: A list of integers. * **Output**: A sorted list of integers in ascending order. **Constraints**: * The input list can contain negative numbers and duplicates. * The length of the list will be between 1 and 10^5. **Performance Requirements**: * The algorithm should aim for an average time complexity of O(n log(n)) and should handle the worst case more efficiently than the basic Quick Sort. **Function Signature**: ```python def optimized_quick_sort(arr): pass ``` # Task and Implementation Details: 1. Create an optimized pivot selection strategy (e.g., median-of-three or random pivot). 2. Implement the hybrid sorting approach: * Use Quick Sort for larger sub-arrays. * Switch to Insertion Sort for sub-arrays smaller than a specified threshold (e.g., 10 elements). 3. Ensure the implementation handles common edge cases efficiently: * Arrays with duplicated elements. * Arrays that are already sorted or nearly sorted. * Very large input arrays within the given constraints. # Example: ```python print(optimized_quick_sort([34, 7, 23, 32, 5, 62])) # Output: [5, 7, 23, 32, 34, 62] print(optimized_quick_sort([1, 2, 2, 3, 1, 4, 1, 3, 5])) # Output: [1, 1, 1, 2, 2, 3, 3, 4, 5] ``` **Hints**: * Consider a hybrid approach combining Quick Sort with another stable sort like Insertion Sort for smaller sections of the array. * Ensure to test with arrays of various sizes and characteristics to validate your implementation\'s efficiency.","solution":"import random def insertion_sort(arr, low, high): for i in range(low + 1, high + 1): key = arr[i] j = i - 1 while j >= low and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def optimized_quick_sort(arr, low=0, high=None, threshold=10): if high is None: high = len(arr) - 1 if low < high: if high - low + 1 < threshold: insertion_sort(arr, low, high) else: pivot_index = random.randint(low, high) # Random pivot to avoid worst-case scenario arr[pivot_index], arr[high] = arr[high], arr[pivot_index] pi = partition(arr, low, high) optimized_quick_sort(arr, low, pi - 1) optimized_quick_sort(arr, pi + 1, high) return arr"},{"question":"As an experienced developer, you are tasked with designing a stack-based feature for a browser. This feature is a tab manager which keeps track of the order of tabs opened in the browser and allows functionalities such as opening new tabs, closing the current tab, viewing the current tab, and checking if there are any open tabs. Implement this using a linked list based stack. # Objectives 1. Implement a class called `BrowserTabManager` with the following methods: * `open_tab(url: str) -> None`: Opens a new tab with the given URL. * `close_tab() -> str`: Closes the current tab and returns the URL of the closed tab. Raise an `IndexError` if there are no tabs open. * `current_tab() -> str`: Returns the URL of the current tab without closing it. Raise an `IndexError` if there are no tabs open. * `has_tabs() -> bool`: Returns `True` if there are any tabs open, `False` otherwise. # Constraints * Each URL is a non-empty string with a maximum length of 2048 characters. * The methods should have constant time complexities. # Input and Output Format * The methods `open_tab`, `close_tab`, `current_tab`, and `has_tabs` have their described behaviors in terms of inputs and outputs. # Performance Requirements * Constant time complexity O(1) for each method. # Example ```python btm = BrowserTabManager() btm.open_tab(\'https://example.com\') btm.open_tab(\'https://anotherexample.com\') assert btm.current_tab() == \'https://anotherexample.com\' assert btm.close_tab() == \'https://anotherexample.com\' assert btm.current_tab() == \'https://example.com\' assert btm.has_tabs() == True assert btm.close_tab() == \'https://example.com\' assert btm.has_tabs() == False ``` Develop your implementation to meet the constraints and example provided.","solution":"class Node: def __init__(self, url): self.url = url self.next = None class BrowserTabManager: def __init__(self): self.top = None def open_tab(self, url: str) -> None: new_node = Node(url) new_node.next = self.top self.top = new_node def close_tab(self) -> str: if self.top is None: raise IndexError(\\"No tabs open\\") url = self.top.url self.top = self.top.next return url def current_tab(self) -> str: if self.top is None: raise IndexError(\\"No tabs open\\") return self.top.url def has_tabs(self) -> bool: return self.top is not None"},{"question":"# Binary Heap Implementation and Usage **Context**: You are designing a system that requires efficient retrieval and management of the smallest elements in a dynamic set. To achieve this, you decide to implement a min-heap structure to facilitate efficient insert and remove-min operations. The min-heap should always ensure that the smallest element can be quickly retrieved and removed, and new elements can be efficiently added. **Task**: 1. Implement the `BinaryHeap` class with the following functionalities: * **Initialization**: Initialize the heap with a given list of elements. * **Insert**: Add a new element to the heap, preserving the heap property. * **Remove Min**: Remove and return the minimum element from the heap. * **Heapify**: Convert a given array into a heap. * **Min Element**: Return the current minimum element without removing it. # Implementation Requirements - **Heap Initialization**: The constructor of the `BinaryHeap` class should accept an optional list of elements to initialize the heap. - **Insert Function**: Implement the insert function to add a new element while maintaining the min-heap property. - **Remove Min Function**: Implement the function to remove and return the minimum element from the heap. - **Heapify Function**: Implement a function that can turn any new list into a valid heap. - **Min Element Function**: Implement the function that returns the current minimum element without removing it. # Input and Output Formats: * **Constructor Input**: List of integers (elements to initialize the heap). * **Insert Function Input**: Single integer value. * **Remove Min Function Output**: Integer value (the removed minimum element). * **Heapify Function Input**: List of integers. * **Min Element Function Output**: Integer value (the current minimum element). # Constraints: * The heap should support at least 100,000 insertions and removals efficiently. * Elements will be within the range [-1000000, 1000000]. **Scenario**: Your goal is to create a class `BinaryHeap` with methods to manage a heap such that the system can efficiently handle a large set of dynamic data, maintaining quick access to the smallest element. ```python class BinaryHeap: def __init__(self, items=None): Initialize the heap with an optional list of elements. pass def insert(self, val): Insert a new value into the heap. pass def remove_min(self): Remove and return the minimum value from the heap. pass def heapify(self, items): Convert a list of elements into a heap. pass def min(self): Return the current minimum value without removing it. pass ``` Ensure your implementation is efficient and can handle edge cases as discussed in the analysis.","solution":"import heapq class BinaryHeap: def __init__(self, items=None): Initialize the heap with an optional list of elements. self.heap = items or [] heapq.heapify(self.heap) def insert(self, val): Insert a new value into the heap. heapq.heappush(self.heap, val) def remove_min(self): Remove and return the minimum value from the heap. return heapq.heappop(self.heap) if self.heap else None def heapify(self, items): Convert a list of elements into a heap. self.heap = items heapq.heapify(self.heap) def min(self): Return the current minimum value without removing it. return self.heap[0] if self.heap else None"},{"question":"# Pathfinding using Depth First Search in a Directed Graph You are given the task to determine whether there is a path between two nodes in a directed graph. Implement a Python class `DirectedGraph` with methods to add edges and check path existence using Depth First Search (DFS). # Class Structure DirectedGraph - **Methods**: 1. `__init__(self, vertex_count: int)`: Initializes the graph with the given number of vertices. 2. `add_edge(self, source: int, target: int)`: Adds a directed edge from `source` to `target`. 3. `is_path(self, source: int, target: int) -> bool`: Returns `True` if there is a path from `source` to `target`, otherwise returns `False`. # Constraints - The graph is represented using adjacency lists. - The vertices are labeled from 0 to `vertex_count - 1`. - The `is_path` method should use DFS for pathfinding. - Assume that `vertex_count > 0` and edges are valid (source and target within bounds). # Example Usage ```python # Initializing the graph with 5 vertices (0 to 4) graph = DirectedGraph(5) # Adding edges graph.add_edge(0, 1) graph.add_edge(1, 2) graph.add_edge(2, 3) graph.add_edge(3, 4) # Determining if there is a path between nodes print(graph.is_path(0, 4)) # Output: True print(graph.is_path(4, 0)) # Output: False ```","solution":"class DirectedGraph: def __init__(self, vertex_count: int): Initializes the graph with the given number of vertices. self.vertex_count = vertex_count self.adjacency_list = {i: [] for i in range(vertex_count)} def add_edge(self, source: int, target: int): Adds a directed edge from source to target. self.adjacency_list[source].append(target) def is_path(self, source: int, target: int) -> bool: Returns True if there is a path from source to target, otherwise returns False. visited = [False] * self.vertex_count return self._dfs(source, target, visited) def _dfs(self, current: int, target: int, visited: list) -> bool: Helper method to perform DFS and check path existence. if current == target: return True visited[current] = True for neighbor in self.adjacency_list[current]: if not visited[neighbor]: if self._dfs(neighbor, target, visited): return True return False"}]'),C={name:"App",components:{PoemCard:A},data(){return{searchQuery:"",visibleCount:4,poemsData:N,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},O={class:"search-container"},z={class:"card-container"},F={key:0,class:"empty-state"},L=["disabled"],R={key:0},j={key:1};function Y(r,e,l,c,a,s){const f=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",O,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>a.searchQuery=o),placeholder:"Search..."},null,512),[[y,a.searchQuery]]),a.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>a.searchQuery="")}," ✕ ")):u("",!0)]),t("div",z,[(n(!0),i(b,null,v(s.displayedPoems,(o,m)=>(n(),w(f,{key:m,poem:o},null,8,["poem"]))),128)),s.displayedPoems.length===0?(n(),i("div",F,' No results found for "'+d(a.searchQuery)+'". ',1)):u("",!0)]),s.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:a.isLoading,onClick:e[2]||(e[2]=(...o)=>s.loadMore&&s.loadMore(...o))},[a.isLoading?(n(),i("span",j,"Loading...")):(n(),i("span",R,"See more"))],8,L)):u("",!0)])}const B=p(C,[["render",Y],["__scopeId","data-v-b57f85b9"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/52.md","filePath":"library/52.md"}'),P={name:"library/52.md"},U=Object.assign(P,{setup(r){return(e,l)=>(n(),i("div",null,[x(B)]))}});export{M as __pageData,U as default};
