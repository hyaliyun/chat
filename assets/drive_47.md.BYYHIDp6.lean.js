import{_ as c,o as n,c as i,a as t,m as h,t as u,C as g,M as _,U as y,f as d,F as b,p as w,e as v,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},E={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(u(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",E,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(u(l.poem.solution),1)])])])}const S=c(k,[["render",A],["__scopeId","data-v-d4143cd7"]]),O=JSON.parse('[{"question":"# Question: Pattern Matching Bijection You are given a pattern string and a text string containing multiple words separated by spaces. Your task is to implement a function `word_pattern(pattern: str, text: str) -> bool` that determines if the text string follows the same pattern as the pattern string. Here, \\"following the same pattern\\" means that each character in the pattern string should map to a unique word in the text string, forming a bijective relationship. Input - A string `pattern` containing only lowercase alphabetical characters. - A string `text` containing words separated by single spaces. Output - A boolean value indicating whether the text follows the pattern (True) or not (False). Constraints - The `pattern` string could have a length up to 100. - The `text` string could have a maximum of 100 words. - Each word in the `text` string has between 1 and 20 lowercase alphabetical characters. Performance Requirements - The algorithm should operate in linear time relative to the length of the input strings and use space linearly proportional to the number of unique pattern characters and words. Examples ```python assert word_pattern(\\"abba\\", \\"dog cat cat dog\\") == True assert word_pattern(\\"abba\\", \\"dog cat cat fish\\") == False assert word_pattern(\\"aaaa\\", \\"dog cat cat dog\\") == False assert word_pattern(\\"abba\\", \\"dog dog dog dog\\") == False ``` Explanation 1. In the first example, pattern \\"abba\\" maps to text \\"dog cat cat dog\\" since \'a\' -> \'dog\', \'b\' -> \'cat\'. 2. In the second example, pattern \\"abba\\" cannot map to text \\"dog cat cat fish\\" due to the mismatch at the last word. 3. In the third example, pattern \\"aaaa\\" cannot map to \\"dog cat cat dog\\" since \'a\' would need to map to different words. 4. In the fourth example, pattern \\"abba\\" cannot map to \\"dog dog dog dog\\" since multiple characters cannot map to the same word. Implement the `word_pattern` function considering the above requirements and constraints.","solution":"def word_pattern(pattern: str, text: str) -> bool: words = text.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char not in char_to_word: if word in word_to_char and word_to_char[word] != char: return False char_to_word[char] = word word_to_char[word] = char elif char_to_word[char] != word: return False return True"},{"question":"# Question: Subset Generation using Backtracking and Iterative Approach Given a set of distinct integers, `nums`, you need to implement two functions that return all possible subsets. 1. `subsets_backtrack(nums: List[int]) -> List[List[int]]`: Using a backtracking approach. 2. `subsets_iterative(nums: List[int]) -> List[List[int]]`: Using an iterative approach. **Input:** - `nums`: A list of distinct integers, up to 10 elements. **Output:** - Return a list of lists where each list represents a possible subset of the given integers. **Constraints:** - Distinct integers only, no duplicate subsets. - The result should contain the empty subset and all other combinations of elements. - Elements within subsets can be in any order, but the overall output should not have duplicate subsets. **Performance Requirements:** - Both implementations should produce results within the constraints and perform efficiently for the input size provided. # Examples: Example 1: ``` Input: nums = [1,2,3] Output: [ [], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3] ] ``` Example 2: ``` Input: nums = [0] Output: [ [], [0] ] ``` # Function Signatures: ```python from typing import List def subsets_backtrack(nums: List[int]) -> List[List[int]]: # Implement the backtracking approach here pass def subsets_iterative(nums: List[int]) -> List[List[int]]: # Implement the iterative approach here pass ``` Requirements 1. Ensure that your solution does not produce duplicate subsets. 2. Verify that both methods produce the correct output as shown in the examples. 3. Explain why you chose your specific implementation details for each method.","solution":"from typing import List def subsets_backtrack(nums: List[int]) -> List[List[int]]: def backtrack(start, path): res.append(path) for i in range(start, len(nums)): backtrack(i + 1, path + [nums[i]]) res = [] backtrack(0, []) return res def subsets_iterative(nums: List[int]) -> List[List[int]]: res = [[]] for num in nums: new_subsets = [curr + [num] for curr in res] res.extend(new_subsets) return res"},{"question":"# Problem Description You are tasked with implementing a function that simulates the addition of one to a non-negative integer represented by a list of digits. The digits are stored in big-endian order, meaning the most significant digit is at the head of the list. Your function should account for the necessary carry management. # Input * A list of non-negative integers where each integer represents a digit. Assume no leading zeros except if the number is zero itself. # Output * A list of non-negative integers representing the new number after adding one. # Constraints 1. The length of the digits list would be between 1 and 10,000. 2. Each element in the input list will be a single digit between 0 and 9. # Performance Requirements * The algorithm should run in O(n) time complexity, where n is the number of digits. # Function Signature ```python def increment_number(digits: List[int]) -> List[int]: ``` # Example ```python # Example 1 input_digits = [1, 2, 3] output_digits = [1, 2, 4] # Example 2 input_digits = [9, 9, 9] output_digits = [1, 0, 0, 0] # Example 3 input_digits = [0] output_digits = [1] ``` # Explanation 1. In the first example, `1, 2, 3` represents 123. Adding one results in 124. 2. In the second example, adding one to `999` results in `1000`, demonstrating the carry-over through all digits. 3. The third example handles a minimal input case where a single digit is incremented. Implement the above function: ```python from typing import List def increment_number(digits: List[int]) -> List[int]: n = len(digits) for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 return [1] + digits ```","solution":"from typing import List def increment_number(digits: List[int]) -> List[int]: Increment the integer represented by a list of digits by one. Args: digits (List[int]): List of non-negative integers representing the digits of the number. Returns: List[int]: List of non-negative integers representing the new number after adding one. n = len(digits) for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 return [1] + digits"},{"question":"You are provided with integers, and your task is to determine if each integer is a perfect square. If it is, compute and return the next perfect square. Otherwise, return -1. Function Signature ```python def find_next_square(sq: int) -> int: ``` Input * `sq` (int): A non-negative integer you need to evaluate. Output * (int): The next perfect square if `sq` is a perfect square, otherwise -1. Constraints * The provided integer `sq` will be in the range of a 32-bit signed integer. # Performance Requirements * The solution should run in constant time O(1) and use constant space O(1). # Examples ```python assert find_next_square(121) == 144 # 121 is a perfect square (11^2), next is 12^2 = 144 assert find_next_square(625) == 676 # 625 is a perfect square (25^2), next is 26^2 = 676 assert find_next_square(114) == -1 # 114 is not a perfect square assert find_next_square(-4) == -1 # Negative numbers cannot be perfect squares assert find_next_square(0) == 1 # 0 is a perfect square (0^2), next is 1^2 = 1 ``` Implement the function `find_next_square` adhering to the above requirements.","solution":"import math def find_next_square(sq: int) -> int: Determine if sq is a perfect square. If it is, return the next perfect square. Otherwise, return -1. # Check if sq is negative if sq < 0: return -1 # Calculate the square root root = math.isqrt(sq) # Check if sq is a perfect square if root * root == sq: # Return the next perfect square return (root + 1) ** 2 else: return -1"},{"question":"# Wiggle Sort Question Objective: Implement an in-place wiggle sort algorithm that reorders an unsorted array to satisfy the condition `nums[0] < nums[1] > nums[2] < nums[3]....` Description: You are given an unsorted array `nums`, implement a function `wiggle_sort(nums)` that reorders the elements in `nums` such that they form a wiggle sequence. Specifically, the algorithm must rearrange the array in such a manner that: - `nums[0] < nums[1] > nums[2] < nums[3]...` Input: * `nums`: A list of integers, where `1 <= len(nums) <= 10^5` and all elements are in the range `-10^9 <= nums[i] <= 10^9`. Output: * The function should modify the input list in place, and there is no returned value. Function Signature: ```python def wiggle_sort(nums: List[int]) -> None: ``` # Examples: Example 1: Input: ```python nums = [3, 5, 2, 1, 6, 4] wiggle_sort(nums) print(nums) ``` Output: ```python [3, 5, 1, 6, 2, 4] # One possible correct output ``` Example 2: Input: ```python nums = [1, 1, 1, 1] wiggle_sort(nums) print(nums) ``` Output: ```python [1, 1, 1, 1] # All elements are the same, maintaining the original order is acceptable ``` # Constraints: * For simplicity, assume that the input will always be a valid list of integers. * The function should handle all possible edge cases, such as: - Single element arrays. - Already wiggled arrays. - Edge values within the specified range. Write your solution to ensure the array `nums` is modified in place without using additional storage for another array.","solution":"def wiggle_sort(nums): Reorders the elements in nums in-place to satisfy the wiggle property: nums[0] < nums[1] > nums[2] < nums[3]... Args: nums (List[int]): The input list of integers to be reordered. for i in range(len(nums) - 1): if i % 2 == 0: if nums[i] > nums[i + 1]: nums[i], nums[i + 1] = nums[i + 1], nums[i] else: if nums[i] < nums[i + 1]: nums[i], nums[i + 1] = nums[i + 1], nums[i]"},{"question":"You are given a string consisting of words separated by spaces. Your task is to write a function `transform_string(s: str) -> str` that processes the string by performing the following transformation: 1. Reverse the order of words in the string. 2. Ensure that words are separated by a single space and there are no leading or trailing spaces in the output. The goal is to correctly handle various edge cases involving white spaces and punctuation. # Function Signature ```python def transform_string(s: str) -> str: pass ``` # Input * `s` (String): A string containing words separated by spaces. # Output * Returns a string with the words in reversed order. # Constraints * Do not use Python\'s built-in reverse methods directly on the entire string. * You may assume `s` contains only printable ASCII characters. # Requirements * Time complexity should be O(n), where n is the length of the input string. * Space complexity should be O(n), considering the space required for split and join operations. # Examples ```python # Example 1: s = \\" The quick brown fox \\" # The output should be \\"fox brown quick The\\" # Example 2: s = \\"Hello World\\" # The output should be \\"World Hello\\" # Example 3: s = \\"a good example\\" # The output should be \\"example good a\\" ``` # Implementation Notes Consider edge cases such as: - Input with leading/trailing spaces. - Multiple spaces between words. - Empty strings or strings with no spaces.","solution":"def transform_string(s: str) -> str: This function takes a string `s` and returns a string with the words in reversed order. Ensures that words are separated by a single space and there are no leading or trailing spaces. # Split the string on one or more whitespace characters words = s.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words with a single space return \' \'.join(reversed_words)"},{"question":"# AVL Tree Height Calculation and Balancing **Scenario**: You are given an AVL Tree implementation that offers standard insertion and balancing operations. Your task is to implement a function that verifies if an AVL tree is correctly balanced after a series of insertions and calculate the height of the tree. # Function to Implement: **Function Prototype**: ```python def is_avl_tree_balanced(tree: AvlTree) -> bool: Function to check if the AVL tree is balanced. :param tree: An instance of AvlTree. :return: True if the tree is balanced according to AVL properties, False otherwise. def calculate_tree_height(tree: AvlTree) -> int: Function to calculate the height of the AVL tree. :param tree: An instance of AvlTree. :return: The height of the tree. ``` # Input: - An instance of `AvlTree` which may have had multiple insertions. # Output: - For `is_avl_tree_balanced`: A boolean indicating whether the tree is balanced. - For `calculate_tree_height`: An integer indicating the height of the tree. # Constraints: - An AVL tree node is considered balanced if the balance factor is between -1 and 1. - You may assume the tree nodes contain integers as keys. # Example: ```python avl = AvlTree() avl.insert(10) avl.insert(20) avl.insert(5) avl.insert(4) avl.insert(15) print(is_avl_tree_balanced(avl)) # Output: True print(calculate_tree_height(avl)) # Example output: 2 ``` # Guidelines: - Ensure that your implementation correctly traverses the AVL tree and checks the balance factor and height of each node. - Optimize for both correctness and performance.","solution":"class AvlTreeNode: def __init__(self, key, height=1, left=None, right=None): self.key = key self.height = height self.left = left self.right = right class AvlTree: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if node is None: return AvlTreeNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) # Left Left Case if balance > 1 and key < node.left.key: return self._right_rotate(node) # Right Right Case if balance < -1 and key > node.right.key: return self._left_rotate(node) # Left Right Case if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) # Right Left Case if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def is_avl_tree_balanced(tree): def is_balanced(node): if node is None: return True, 0 left_balanced, left_height = is_balanced(node.left) right_balanced, right_height = is_balanced(node.right) node.height = 1 + max(left_height, right_height) balance = left_height - right_height return left_balanced and right_balanced and -1 <= balance <= 1, node.height balanced, _ = is_balanced(tree.root) return balanced def calculate_tree_height(tree): def get_height(node): if node is None: return 0 left_height = get_height(node.left) right_height = get_height(node.right) return 1 + max(left_height, right_height) return get_height(tree.root)"},{"question":"Problem Statement You are required to extend the current stack implementation by adding two additional functions: 1. `max_element()`: This function should return the maximum element in the stack without modifying the stack. 2. `size()`: This function should return the current size of the stack, i.e., the number of elements currently in the stack. Requirements 1. Modify both `ArrayStack` and `LinkedListStack` classes to add these new methods. 2. Ensure that the `max_element()` function operates in O(1) time for both stack types. 3. The `size()` function should also operate in O(1) time. Constraints * You can assume all elements pushed into the stack are integers. * The stack will not contain more than (10^5) elements. * No external libraries or built-in functions for finding max should be used. Input ```python # No direct input. Functions will be evaluated on the classes. ``` Output * For `max_element()`, an integer representing the maximum element in the stack. * For `size()`, an integer representing the number of elements in the stack. Example ```python # Example for ArrayStack array_stack = ArrayStack() array_stack.push(3) array_stack.push(5) array_stack.push(2) print(array_stack.max_element()) # Output: 5 print(array_stack.size()) # Output: 3 # Example for LinkedListStack linked_list_stack = LinkedListStack() linked_list_stack.push(3) linked_list_stack.push(5) linked_list_stack.push(2) print(linked_list_stack.max_element()) # Output: 5 print(linked_list_stack.size()) # Output: 3 ```","solution":"class ArrayStack: def __init__(self): self.stack = [] self.max_stack = [] def push(self, element): self.stack.append(element) if not self.max_stack or element >= self.max_stack[-1]: self.max_stack.append(element) def pop(self): if self.stack: element = self.stack.pop() if element == self.max_stack[-1]: self.max_stack.pop() return element return None def max_element(self): if self.max_stack: return self.max_stack[-1] return None def size(self): return len(self.stack) class LinkedListStack: class Node: def __init__(self, data, next=None, current_max=None): self.data = data self.next = next self.current_max = current_max def __init__(self): self.head = None self._size = 0 def push(self, element): if self.head is None: new_node = self.Node(element, None, element) else: new_max = max(element, self.head.current_max) new_node = self.Node(element, self.head, new_max) self.head = new_node self._size += 1 def pop(self): if self.head: popped_element = self.head.data self.head = self.head.next self._size -= 1 return popped_element return None def max_element(self): if self.head: return self.head.current_max return None def size(self): return self._size"},{"question":"# Validating HTML-like Tags Context In HTML/XML documents, tags are used to identify pieces of content. These tags are usually in pairs (e.g., `<div>` and `</div>`), and must be properly nested. Task You need to create a function that validates whether the provided string of tags is properly nested. Tags are considered properly nested if: 1. Every opening tag has a corresponding closing tag. 2. Tags are closed in the correct order. Requirements * Implement a function `is_valid_tags(s: str) -> bool`. * The input string `s` contains only valid tags (e.g. `<tag>`, `</tag>`) and text content. * Tag names only include lowercase letters. Input * `s` - a string containing HTML-like tags. * Each tag name consists of only lowercase English letters. Output * A boolean value indicating whether the input string\'s tags are properly nested. Constraints * Length of the string can be up to `10^4`. Examples ```python # Example 1 s = \\"<div><a></a></div>\\" assert is_valid_tags(s) == True # Example 2 s = \\"<div><a></div></a>\\" assert is_valid_tags(s) == False # Example 3 s = \\"<div><a></a><b></b></div>\\" assert is_valid_tags(s) == True # Example 4 s = \\"<a><b></a></b>\\" assert is_valid_tags(s) == False # Example 5 s = \\"text content\\" assert is_valid_tags(s) == True ``` Explanation * A valid string contains tags that are properly nested and closed. * An invalid string may have mismatched tags or tags that are not closed in a proper sequence. You should use a stack-based approach to solve this problem efficiently. Think about how you would handle regular parentheses and adapt that logic to HTML tags. Solution Template ```python def is_valid_tags(s: str) -> bool: # Your code here pass ```","solution":"def is_valid_tags(s: str) -> bool: stack = [] i = 0 while i < len(s): if s[i] == \'<\': j = s.find(\'>\', i) if j == -1: return False tag = s[i+1:j] if tag.startswith(\'/\'): if not stack or stack[-1] != tag[1:]: return False stack.pop() else: stack.append(tag) i = j i += 1 return not stack"},{"question":"# Find the Inorder Predecessor in a Binary Search Tree Context Consider a Binary Search Tree (BST) where you need to find the inorder predecessor of a given node. The inorder predecessor of a node in a BST is the node with the highest value that is smaller than the value of the given node. Problem Statement You are given the root of a binary search tree and a node, both represented as instances of a TreeNode class. Write a function `findPredecessor(root: TreeNode, node: TreeNode) -> Optional[TreeNode]` that returns the inorder predecessor of the given node. If the node does not have a predecessor or there are no nodes in the tree, return `None`. Constraints 1. The tree nodes have unique integer values. 2. The BST and all nodes follow the BST property: for any node N, all nodes in the left subtree are lesser, and all nodes in the right subtree are greater. 3. The TreeNode class is defined as: ```python class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right ``` Input/Output Format - **Input**: - `root: TreeNode` - The root of the BST. - `node: TreeNode` - The node for which the predecessor is to be found. - **Output**: - `Optional[TreeNode]` - The inorder predecessor of the given node if it exists, otherwise `None`. Example ```python root = TreeNode(20) root.left = TreeNode(10) root.right = TreeNode(30) root.left.left = TreeNode(5) root.left.right = TreeNode(15) node = root.left.right # TreeNode with value 15 assert findPredecessor(root, node).val == 10 ``` Explanation In the example provided, the inorder predecessor of the node with value 15 is the node with value 10.","solution":"class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def findPredecessor(root: TreeNode, node: TreeNode) -> TreeNode: predecessor = None if node.left: # If there\'s a left subtree, the predecessor is the rightmost node # in the left subtree. predecessor = node.left while predecessor.right: predecessor = predecessor.right return predecessor # Otherwise, start from the root and search for the node, keeping track # of the last node which is lesser than the given node. current = root while current: if node.val > current.val: predecessor = current current = current.right elif node.val < current.val: current = current.left else: break return predecessor"},{"question":"# Context Many real-world problems, such as combinations of items in a shopping cart or possible states in a game, can be represented as subsets of a given set. Efficiently generating these subsets is a fundamental problem in computer science and is crucial in fields such as combinatorics, data analysis, and artificial intelligence. # Problem Statement You are given a set of distinct integers, `nums`. Your task is to implement a function that returns all possible subsets of `nums`. This problem serves to test your understanding of bit manipulation and combinatorial algorithms. # Task Write a function `generate_subsets(nums)` that takes a list of distinct integers as input and returns a set containing all possible subsets. Each subset should be represented as a sorted tuple of integers. The solution should be efficient and not contain duplicate subsets. # Requirements **Function Signature**: ```python def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: ``` **Input**: * `nums` - A list of distinct integers, where `0 <= len(nums) <= 15`. **Output**: * Returns a set of tuples, where each tuple is a unique subset of the input list, and all elements within each tuple are sorted. **Example**: ```python # Example 1 input = [1, 2, 3] output = {(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)} # Example 2 input = [4, 5, 6] output = {(), (4,), (5,), (6,), (4, 5), (4, 6), (5, 6), (4, 5, 6)} ``` # Constraints * The input list `nums` contains distinct integers. * The length of `nums` will be at most 15. # Notes 1. You must use bitwise operations in your solution. 2. Make sure to handle edge cases such as an empty list.","solution":"from typing import List, Set, Tuple def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: Generate all possible subsets of a given distinct integer list using bitwise operations. Args: nums (List[int]): List of distinct integers. Returns: Set[Tuple[int]]: A set containing all unique subsets as sorted tuples of integers. subsets = set() n = len(nums) total_subsets = 1 << n # 2^n subsets for i in range(total_subsets): subset = [] for j in range(n): if i & (1 << j): subset.append(nums[j]) subsets.add(tuple(sorted(subset))) return subsets"},{"question":"Finding the nth Digit in a Sequence of Natural Numbers **Objective**: Write a function `find_nth_digit` that takes a single integer `n` and returns the nth digit in the sequence of concatenated natural numbers starting from 1 (e.g., 123456789101112...). **Function Signature**: ```python def find_nth_digit(n: int) -> int: # Function implementation here ``` **Input**: * `n` (1 ≤ n ≤ 2 * 10^9): An integer indicating the position in the sequence. **Output**: * An integer representing the nth digit in the sequence. **Constraints**: * The function should work efficiently within the given constraints. * Consider and handle edge cases appropriately. **Example**: * `find_nth_digit(3)` should return `3`. * `find_nth_digit(11)` should return `0`. * `find_nth_digit(189)` should return `9`. Scenario You are assigned a task to generate a digit from an infinite sequence of concatenated natural numbers. Due to resource constraints, creating the entire sequence is not feasible. Instead, you need an efficient algorithm to directly retrieve the desired digit without generating unnecessary data. **Requirements**: 1. Clearly identify the range (length) where the nth digit belongs. 2. Compute the exact number that contains the nth digit. 3. Extract and return the nth digit from the computed number. **Edge Cases**: * Handling small values of `n`, like n=1. * Handling transitions between different length ranges (9 to 10, 99 to 100). * Ensure no incorrect digit positions due to integer division peculiarities. **Performance**: Your implementation should aim for a time complexity of O(log(n)) and a space complexity of O(1).","solution":"def find_nth_digit(n): # How many digits are there with \'d\' digits in them length = 1 count = 9 start = 1 while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Now find the exact number start += (n - 1) // length # Find the exact digit in the number s = str(start) return int(s[(n - 1) % length])"},{"question":"# Coding Problem: Enhanced String Matching Context You have been hired by a digital library to help develop a robust search functionality. One of the core features of this search functionality is to efficiently find occurrences of a search string (pattern) within different books (texts). To achieve this, you will use and enhance the Rabin Karp algorithm provided to support finding all occurrences of the pattern in the text. Task Implement a function that returns all the starting positions of the occurrences of a given pattern in a given text. Function Signature ```python def find_all_occurrences(pattern: str, text: str) -> list: pass ``` Input/Output * **Input**: - `pattern`: A string `pattern` to be found in the `text`. 1 <= len(pattern) <= 10^3 - `text`: A string `text` where the pattern needs to be searched. 1 <= len(text) <= 10^5 * **Output**: - A list of integers representing starting indices of each occurrence of `pattern` in `text`. Constraints - The text and pattern will only contain lowercase alphabetical characters. - The pattern will always be non-empty and will not be longer than the text. Example ```python find_all_occurrences(\\"abab\\", \\"ababcabcabab\\") # should return [0, 8] find_all_occurrences(\\"test\\", \\"this is a test test\\") # should return [10, 15] find_all_occurrences(\\"abc\\", \\"abcabcabc\\") # should return [0, 3, 6] ``` Requirements 1. Your function should return all starting indices where the pattern matches the substring in the text. 2. Optimize for performance to handle large inputs up to the constraints specified. 3. Make sure to handle edge cases.","solution":"def find_all_occurrences(pattern: str, text: str) -> list: Returns all the starting positions of the occurrences of a given pattern in a given text. if not pattern or not text or len(pattern) > len(text): return [] pattern_length = len(pattern) text_length = len(text) result = [] # Base constants for the Rabin Karp algorithm prime = 101 # A prime number d = 256 # Total number of characters (considering ASCII) pattern_hash = 0 text_hash = 0 h = 1 # Calculate the h value (d^(pattern_length-1) % prime) for _ in range(pattern_length - 1): h = (h * d) % prime # Calculate initial hash values for the pattern and the text for i in range(pattern_length): pattern_hash = (d * pattern_hash + ord(pattern[i])) % prime text_hash = (d * text_hash + ord(text[i])) % prime # Slide the pattern over text for i in range(text_length - pattern_length + 1): if pattern_hash == text_hash: # Check for the exact match if text[i:i + pattern_length] == pattern: result.append(i) # Calculate the hash value for the next window of text if i < text_length - pattern_length: text_hash = (d * (text_hash - ord(text[i]) * h) + ord(text[i + pattern_length])) % prime # We might get negative value of text_hash, converting it to positive if text_hash < 0: text_hash += prime return result"},{"question":"# Question: Check if Number is Power of Two Context One common task in computer science is determining if a given number is a power of two. Powers of two play a fundamental role in areas like data structuring, algorithm optimization, and memory management. Task Implement the function `is_power_of_two(n)` in Python that checks if a given integer `n` is a power of two. Function Signature ```python def is_power_of_two(n: int) -> bool: Determine if \'n\' is a power of two. :param n: An integer to check :type n: int :return: True if n is a power of two, False otherwise :rtype: bool ``` Input * A single integer `n`. Output * A boolean value: `True` if `n` is a power of two, `False` otherwise. Examples ```python assert is_power_of_two(1) == True # 1 is 2**0 assert is_power_of_two(2) == True # 2 is 2**1 assert is_power_of_two(3) == False # 3 is not a power of two assert is_power_of_two(16) == True # 16 is 2**4 assert is_power_of_two(18) == False # 18 is not a power of two assert is_power_of_two(0) == False # 0 is not a power of two, valid for n > 0 only ``` Constraints 1. Assume all inputs are valid integers. 2. The integer can be negative (though those cannot be powers of two). 3. Function should execute in constant time, O(1). Hints * Remember that powers of two have exactly one `1` bit in their binary representation. * Explore how bitwise operations can simplify the problem.","solution":"def is_power_of_two(n: int) -> bool: Determine if \'n\' is a power of two. :param n: An integer to check :type n: int :return: True if n is a power of two, False otherwise :rtype: bool if n <= 0: return False return (n & (n - 1)) == 0"},{"question":"# 0/1 Knapsack Problem You are required to solve the classic 0/1 Knapsack problem using dynamic programming. You are given the capacity of the knapsack and a list of items, each represented by its value and weight. The goal is to determine the maximum value that can be carried in the knapsack without exceeding the given capacity. Write a function `optimal_knapsack_value` that takes in: 1. `capacity` (int) - the maximum weight that the knapsack can carry. 2. `items` (List[Tuple[int, int]]) - a list of tuples where each tuple represents the value and weight of an item. The function should return an integer representing the maximum value of items that can fit into the knapsack. Input Format: - `capacity` : an integer (1 <= capacity <= 10^4) - `items`: a list of tuples where each tuple is `(value, weight)` with: - `value` : an integer (1 <= value <= 10^3) - `weight` : an integer (1 <= weight <= 10^4) - You can assume the number of items will not exceed 100. Output Format: - Return a single integer - the maximum value that can be obtained. Example: ```python # Input capacity = 5 items = [(60, 5), (50, 3), (70, 4), (30, 2)] # Output result = optimal_knapsack_value(capacity, items) print(result) # should output 80 ``` Constraints: - There are no duplicate items. - Each item can only be taken once. - The solution should be optimal and efficient.","solution":"def optimal_knapsack_value(capacity, items): Solves the 0/1 Knapsack problem using dynamic programming. Parameters: capacity (int): The maximum weight that the knapsack can carry. items (List[Tuple[int, int]]): A list of tuples where each tuple represents the value and weight of an item. Returns: int: The maximum value of items that can fit into the knapsack. n = len(items) dp = [[0] * (capacity + 1) for _ in range(n + 1)] for i in range(1, n + 1): value, weight = items[i-1] for w in range(capacity + 1): if weight > w: dp[i][w] = dp[i-1][w] else: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight] + value) return dp[n][capacity]"},{"question":"You are provided a class `UndirectedGraphNode` to define an undirected graph node. Each node contains a label and a list of references to its neighbors. Implement a function `clone_graph(node)` that takes in an `UndirectedGraphNode` representing an undirected graph and returns a deep copy (clone) of the graph. You need to ensure that the clone is completely separate from the original graph, maintaining identical structure and connections. # Function Signature ```python def clone_graph(node: UndirectedGraphNode) -> UndirectedGraphNode: pass ``` # Input - **node**: An instance of `UndirectedGraphNode` representing the head of the undirected graph. # Output - Returns the head of the cloned graph as an instance of `UndirectedGraphNode`. # Constraints - The graph can have between 0 to 1000 nodes. # Example Example 1: **Input**: ``` Graph: 0 - 1 - 2 ``` ``` Node 0 has neighbors [1, 2] Node 1 has neighbors [2] Node 2 has no neighbors ``` **Output**: A deep copy of the input graph. Example 2: **Input**: Null **Output**: Null # Notes - Consider both BFS and DFS approaches for traversal. - Handle edge cases including null graphs, self-loops, and disconnected components. - Ensure that your function is efficient and scales well with up to 1000 nodes.","solution":"class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def clone_graph(node: UndirectedGraphNode) -> UndirectedGraphNode: if not node: return None # Dictionary to hold the mapping from original nodes to their clones node_map = {} # Helper function to clone nodes using DFS def dfs(original): if original in node_map: return node_map[original] # Clone the node clone = UndirectedGraphNode(original.label) node_map[original] = clone # Clone the neighbors for neighbor in original.neighbors: clone.neighbors.append(dfs(neighbor)) return clone # Start DFS from the input node return dfs(node)"},{"question":"You are given classes and functions to serialize and deserialize a binary tree. Serialization converts the tree to a string in a pre-order traversal way, and deserialization converts that string back into the tree structure. Your task is to write a function `find_in_serialized` that searches for a given integer value in the serialized string to determine whether the value exists in the binary tree without reconstructing the entire tree. # Function Signature ```python def find_in_serialized(serialized_tree: str, target: int) -> bool: pass ``` # Input * `serialized_tree`: A string containing the serialized representation of a binary tree where null nodes are represented as \\"#\\". * `target`: An integer that you need to search for in the tree\'s serialized string. # Output * Returns `True` if the target value exists in the serialized tree string; otherwise, returns `False`. # Constraints * The serialized input string will contain node values and null indicators (using \\"#\\") separated by spaces. * No node in the tree will have an integer value outside the range of typical signed 32-bit integers. * The target can be any 32-bit signed integer. # Example ```python # Example tree: # 3 # / # 9 20 # / # 15 7 serialized_tree = \\"3 9 # # 20 15 # # 7 # #\\" # find_in_serialized(serialized_tree, 15) # Returns: True # # find_in_serialized(serialized_tree, 10) # Returns: False ``` # Explanation 1. `serialized_tree` is passed to the function representing the serialized form of a binary tree. 2. You need to check if the `target` integer exists in the serialized string representation of the tree. 3. Return `True` if the value exists; otherwise, return `False`.","solution":"def find_in_serialized(serialized_tree: str, target: int) -> bool: Finds if target exists in the serialized representation of the binary tree. # Split the serialized tree string into parts parts = serialized_tree.split() # Check if the target integer exists in the serialized parts return str(target) in parts"},{"question":"# Repeated Substring Search Implementation You are given two strings `A` and `B`. Your task is to find the minimum number of times the string `A` must be repeated such that `B` becomes a substring of the resulted repeated string. If no such repetition is possible, return -1. Implement the function `repeat_string(A: str, B: str) -> int` that accomplishes this task following the instructions below. Input: * `A`: a string with length between 1 and 10000. * `B`: a string with length between 1 and 10000. Output: * An integer representing the minimum number of times `A` has to be repeated for `B` to become a substring of it. Constraints: * The length of strings A and B will be between 1 and 10000. * Use efficient string operations to ensure optimal performance. Example: ```python # Example 1: # A = \\"abcd\\" # B = \\"cdabcdab\\" # Expected Output: 3 print(repeat_string(\\"abcd\\", \\"cdabcdab\\")) # Example 2: # A = \\"abc\\" # B = \\"cabcabca\\" # Expected Output: 4 print(repeat_string(\\"abc\\", \\"cabcabca\\")) ``` Implement the function below: ```python def repeat_string(A, B): count = 1 tmp = A max_count = (len(B) // len(A)) + 2 while not(B in tmp): tmp += A count += 1 if count > max_count: return -1 return count ```","solution":"def repeat_string(A: str, B: str) -> int: Returns the minimum number of times the string A must be repeated such that B is a substring of the resultant string. Returns -1 if there is no such repetition possible. count = 1 repeated_string = A max_count = (len(B) // len(A)) + 2 while B not in repeated_string: repeated_string += A count += 1 if count > max_count: return -1 return count"},{"question":"You are tasked with implementing a simple data compression and decompression algorithm named Run-Length Encoding (RLE). This algorithm is designed to compress data by encoding consecutive repeated characters into their frequency counts followed by the character itself. You need to write two functions to handle encoding and decoding operations. # Function 1: Encode RLE Write a function `encode_rle` that takes a string as input and returns its run-length encoded string. **Function Signature**: ```python def encode_rle(input: str) -> str: ``` **Input**: - `input`: A string of data to be encoded using RLE. **Output**: - Returns the run-length encoded string. **Example**: ```python assert encode_rle(\'aaabbcccc\') == \'3a2b4c\' assert encode_rle(\'\') == \'\' assert encode_rle(\'a\') == \'1a\' assert encode_rle(\'abc\') == \'1a1b1c\' ``` # Function 2: Decode RLE Write a function `decode_rle` that takes a run-length encoded string as input and returns the original uncompressed string. **Function Signature**: ```python def decode_rle(input: str) -> str: ``` **Input**: - `input`: A run-length encoded string. **Output**: - Returns the decoded string. **Example**: ```python assert decode_rle(\'3a2b4c\') == \'aaabbcccc\' assert decode_rle(\'\') == \'\' assert decode_rle(\'1a\') == \'a\' assert decode_rle(\'1a1b1c\') == \'abc\' ``` # Constraints - The encoded string will follow the format: digit(s) followed by a character. - The input strings will only contain alphanumeric characters. - The encoded string will be a valid run-length encoded string. - Maximum length of input strings (for both functions) is 10^5 characters. # Performance - Ensure that the solution runs efficiently within the provided input size constraints. # Context Run-length encoding (RLE) can be used in lossless data compression where sequences of repeated characters are common. This technique is often used in simple image compression formats (such as bit-mapped raster images) and is suitable for scenarios where data has long runs of repeated characters. Implement these functions and thoroughly test them to verify their correctness.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded = [] count = 1 prev_char = input[0] for char in input[1:]: if char == prev_char: count += 1 else: encoded.append(f\\"{count}{prev_char}\\") count = 1 prev_char = char # Append the last run encoded.append(f\\"{count}{prev_char}\\") return \'\'.join(encoded) def decode_rle(input: str) -> str: if not input: return \\"\\" decoded = [] count = \'\' for char in input: if char.isdigit(): count += char else: decoded.append(char * int(count)) count = \'\' return \'\'.join(decoded)"},{"question":"# Coding Challenge Context You are working on a project that identifies special numbers, which are numbers that equal the sum of their digits raised to the consecutive power of their positions. Task Write a function to find all numbers that fit this criterion within a specified range. Function Signature ```python def sum_dig_pow(low: int, high: int) -> List[int]: pass ``` Input - `low` (int): The starting integer of the range (inclusive). - `high` (int): The ending integer of the range (inclusive). Output - `result` (List[int]): A list of all integers within the given range [low, high] that fit the criterion. Requirements - Performance efficiency: The function should handle ranges up to 100,000 efficiently. - Integrity: The function must correctly identify and include all valid numbers in the result list. Examples ```python # Example 1: # Range: 1 to 10 # Valid numbers: [1, 2, 3, 4, 5, 6, 7, 8, 9] print(sum_dig_pow(1, 10)) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] # Example 2: # Range: 1 to 100 # Valid numbers: [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] print(sum_dig_pow(1, 100)) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] # Example 3: # Range: 100 to 150 # Valid numbers: [135] print(sum_dig_pow(100, 150)) # Output: [135] ``` Constraints - 1 ≤ `low` ≤ `high` ≤ 100000 Ensure your function is optimized for both time and space complexity and is capable of handling edge cases such as a single number range.","solution":"from typing import List def sum_dig_pow(low: int, high: int) -> List[int]: def is_special_number(num: int) -> bool: digits = [int(d) for d in str(num)] return num == sum(d ** (i + 1) for i, d in enumerate(digits)) result = [num for num in range(low, high + 1) if is_special_number(num)] return result"},{"question":"# Cosine Similarity Calculation You are given two non-zero vectors represented as lists. Implement a function `cosine_similarity_adjusted` which calculates the cosine similarity between these two vectors. The function should also handle potential edge cases such as lists containing zero elements gracefully if either vector results in a zero L2 norm. # Input - Two non-zero lists of integers or floating-point numbers, `vec1` and `vec2`, where both lists have the same length (1 ≤ length ≤ 10^6). # Output - A single floating-point number representing the cosine similarity between the two vectors. # Constraints - Each list will contain at least one element that is not zero. - The two lists are guaranteed to be of the same length. # Performance Requirements - Your implementation should run in O(n) time complexity and O(1) space complexity. # Example ```python # Example 1: cosine_similarity_adjusted([1, 2, 3], [4, 5, 6]) # Output: 0.9746318461970762 # Example 2: cosine_similarity_adjusted([1, 1, 1], [1, 2, -1]) # Output: 0.47140452079103173 # Example 3: cosine_similarity_adjusted([0, 1, 0], [0, 0, 1]) # Output: 0.0 ``` # Special Scenarios Consider handling gracefully cases where: - The L2 norm of either vector is zero. # Notes 1. Do not use any libraries other than `math` for vector operations. 2. Ensure that your function raises an appropriate error when input lists are not of the same length, as handled in the starter code.","solution":"import math def cosine_similarity_adjusted(vec1, vec2): Calculate the cosine similarity between two vectors. Handles cases where either vector results in a zero L2 norm by returning 0. if len(vec1) != len(vec2): raise ValueError(\\"Vectors must be of the same length\\") # Calculate dot product dot_product = sum(v1 * v2 for v1, v2 in zip(vec1, vec2)) # Calculate L2 norms norm1 = math.sqrt(sum(v1 * v1 for v1 in vec1)) norm2 = math.sqrt(sum(v2 * v2 for v2 in vec2)) if norm1 == 0 or norm2 == 0: return 0.0 # Calculate cosine similarity return dot_product / (norm1 * norm2)"},{"question":"# Question: Detect Unique Value in Dynamic Stream of Tuples You are provided with a stream of tuples where each tuple consists of a number and a sign indicator (\'+\' or \'-\'). Your task is to determine whether the given stream is 1-sparse. A stream is 1-sparse if adding and removing numbers in the stream results in exactly one unique number. Write a function `one_sparse(array)` which accepts a list of tuples. Each tuple contains an integer `value` and a character `sign` This function should return the unique number if the stream is 1-sparse, otherwise, it should return `None`. Input - A list of tuples `array`, where each tuple is of the form `(int, str)`. Output - An integer representing the unique number in the stream if it is 1-sparse. - Return `None` if the stream is not 1-sparse. Constraints - The integers in the tuples are non-negative. - Character `sign` is either `\'+\'` or `\'-\'`. Examples Example 1: ```python Input: [(4, \'+\'), (2, \'+\'), (2, \'-\'), (4, \'+\'), (3, \'+\'), (3, \'-\')] Output: 4 Comment: Since 2 and 3 gets removed. ``` Example 2: ```python Input: [(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\')] Output: 2 Comment: No other numbers present. ``` Example 3: ```python Input: [(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (1, \'+\')] Output: None Comment: Not 1-sparse ``` Note that your solution needs to handle edge cases, and you should ensure that your function runs efficiently with emphasis on the conditions provided.","solution":"def one_sparse(array): Determine whether the given stream is 1-sparse and return the unique number if it is. Otherwise, return None. Params: array (list of tuples): A list where each item is a tuple consisting of a number and a sign (\'+\' or \'-\'). Returns: int or None: The unique number if the stream is 1-sparse, otherwise None. count_map = {} for number, sign in array: if sign == \'+\': if number in count_map: count_map[number] += 1 else: count_map[number] = 1 elif sign == \'-\': if number in count_map and count_map[number] > 0: count_map[number] -= 1 unique_number = None found_once = False for num, count in count_map.items(): if count > 0: if found_once: # More than one unique number found return None unique_number = num found_once = True return unique_number if found_once else None"},{"question":"# Problem Description You are tasked with enhancing the following algorithms to not only find the missing number from a sequence of unique integers but also gracefully handle invalid inputs, including: - Arrays with duplicate numbers. - Arrays containing elements outside the expected range [0..n]. - Non-integer values, although by problem definition, it is assumed we deal with valid integer inputs only. # Function Signature ```python def find_missing_number_enhanced(nums): Enhanced function to find the missing number from a sequence of unique integers in range [0..n]. Args: nums (List[int]): A list of unique integers where one integer is missing. Returns: int: The missing integer if the sequence is valid, otherwise an appropriate error indicator. ``` # Input Format - `nums`: A list of integers representing the sequence, with exactly one integer missing. # Output Format - Returns the missing integer if the input is a valid sequence. - Otherwise, prints an appropriate error message. # Constraints - The list `nums` consists of integers in the range [0..n], where n is the length of the array. - The elements in `nums` are unique and there is exactly one missing integer. # Example Cases Example 1 ```python nums = [4, 1, 3, 0, 6, 5, 2] # Output: 7 ``` Example 2 ```python nums = [0, 1, 3] # Output: 2 ``` Example 3 ```python nums = [1, 2, 0, 4, 6, 3] # Output: Error: Invalid input - expected unique integers in range [0..n]. ``` # Enhanced Algorithm Steps (Guideline) 1. Validate the input to ensure that it contains unique integers within the expected range. 2. Implement the XOR approach to find the missing number. 3. With invalid input, output an appropriate error message. Your task is to write the `find_missing_number_enhanced` function to meet the above specifications.","solution":"def find_missing_number_enhanced(nums): Enhanced function to find the missing number from a sequence of unique integers in range [0..n]. Args: nums (List[int]): A list of unique integers where one integer is missing. Returns: int: The missing integer if the sequence is valid, otherwise an appropriate error indicator. n = len(nums) expected_nums = set(range(n + 1)) # Expected numbers deduced from the length of nums actual_nums = set(nums) if len(actual_nums) != len(nums): return \\"Error: Invalid input - duplicates are not allowed\\" if actual_nums - expected_nums: return \\"Error: Invalid input - elements outside the expected range [0..n]\\" # Calculate the missing number using expected sum formula return list(expected_nums - actual_nums)[0]"},{"question":"# Question: List Frequency Limiter Problem Statement You are given a list of integers and a positive integer ( N ). Your task is to write a function `limit_frequencies(lst, N)` that returns a new list where each integer appears at most ( N ) times, while maintaining the original order. Function Signature ```python def limit_frequencies(lst: list[int], N: int) -> list[int]: pass ``` Input * `lst`: A list of integers. * `N`: A positive integer indicating the maximum occurrences allowed for any integer in the list. Output * The function should return a new list of integers. Constraints * ( 1 leq text{len(lst)} leq 10^5 ) * ( 1 leq N leq 100 ) * ( -10^6 leq text{element} leq 10^6 ) Example ```python >>> limit_frequencies([1,2,3,1,2,1,2,3], 2) [1, 2, 3, 1, 2, 3] >>> limit_frequencies([20, 37, 20, 21], 1) [20, 37, 21] ``` Explanation 1. For the first example: - Initially, we start building the new list: [1, 2, 3]. - The next \'1\' is allowed because it appears less than 2 times, so we get [1, 2, 3, 1]. - Similarly, the next \'2\' is allowed, giving us [1, 2, 3, 1, 2]. - The next \'1\' and \'2\' are skipped because they would exceed the allowed count. - Finally, \'3\' is added, resulting in [1, 2, 3, 1, 2, 3]. 2. For the second example: - We start with [20, 37, 20]. - The next \'21\' is allowed to give the final list [20, 37, 21]. Make sure that your function runs efficiently to handle large inputs within acceptable time limits.","solution":"def limit_frequencies(lst, N): Returns a new list with each integer appearing at most N times, while maintaining the original order. freq = {} result = [] for num in lst: if num not in freq: freq[num] = 0 if freq[num] < N: result.append(num) freq[num] += 1 return result"},{"question":"# Scenario: You are tasked with implementing a system that can iterate over a Binary Search Tree (BST) in ascending order without loading all elements into memory first. Your implementation should simulate in-order traversal using an iterative approach with a stack. # Objective: Given the skeleton of the `BSTIterator` class, complete the methods to enable in-order traversal. The class should be instantiated with the root of a BST, and it should support two methods: * `has_next()`: Return a boolean indicating whether there are more nodes to visit. * `next()`: Return the next smallest node value. # Constraints: * The BST will have at most `10^4` nodes. * `-10^5 <= Node.val <= 10^5` * `next()` should only be called if `has_next()` returns true. # Input Format: A class definition for `BSTIterator` with methods `__init__`, `has_next`, and `next`. # Output Format: No direct output is expected. The class methods will be tested to ensure they perform the in-order traversal correctly. # Example: ```python # Define the BST node class. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example usage: root = TreeNode(7, TreeNode(3), TreeNode(15, TreeNode(9), TreeNode(20))) iterator = BSTIterator(root) print(iterator.next()) # return 3 print(iterator.next()) # return 7 print(iterator.has_next()) # return True print(iterator.next()) # return 9 print(iterator.has_next()) # return True print(iterator.next()) # return 15 print(iterator.has_next()) # return True print(iterator.next()) # return 20 print(iterator.has_next()) # return False ``` # Task: Implement the `BSTIterator` with the provided methods ensuring efficient traversal by managing the stack operations appropriately.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root): Initializes an iterator over the BST with the root node. self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): Helper function to add all nodes along the leftmost branch of the tree to the stack. while root: self.stack.append(root) root = root.left def has_next(self): Return whether there is a next smallest number. return len(self.stack) > 0 def next(self): Return the next smallest number. # Node at the top of the stack is the next smallest element. topmost_node = self.stack.pop() # If the node has a right child, perform the same process for the right child. if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val"},{"question":"# Task: Find the Unique Number You are given an array of integers where all elements appear twice except for one element which appears once. Implement a function `find_unique_number` that finds and returns the single unique element in constant space and linear time complexity. # Function Signature ```python def find_unique_number(nums: List[int]) -> int: ``` # Input * `nums` (List[int]): A list of integers where each integer appears twice except for one integer which appears once. # Output * Returns the unique number that appears once in the list. # Constraints * The input list is non-empty. * There is exactly one unique number. * The length of the list is at most 10^4. # Performance Requirements * The algorithm must run in linear time, O(n). * The algorithm must use constant additional space, O(1). # Example ```python assert find_unique_number([2, 2, 1]) == 1 assert find_unique_number([4, 1, 2, 1, 2]) == 4 assert find_unique_number([1]) == 1 ``` # Scenario Consider downloading transaction logs where every transaction appears twice except one error transaction. Identifying this unique error is crucial to ensure the correctness of the logs. *Note*: You must achieve this without using extra memory. A powerful property of the XOR operation is that it can accomplish the task with constant space.","solution":"from typing import List def find_unique_number(nums: List[int]) -> int: Finds and returns the single unique element in the list. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Scenario You have been hired to optimize the memory usage of a software system that stores a large amount of binary data. One of the functions you need to optimize involves removing a specific bit from a binary number. This helps in various data processing tasks where bitwise manipulation provides a more efficient way to handle data. # Task Write a function `remove_bit(num, i)` that takes an integer `num` representing a binary number and an integer `i` representing the bit position to be removed. Your function should return the new integer value after the bit at position `i` has been removed from `num`. # Function Signature ```python def remove_bit(num: int, i: int) -> int: # Your implementation here ``` # Input * `num` (int): The integer value from which you need to remove a bit. (0 <= num <= 10^9) * `i` (int): The position of the bit to be removed. (0 <= i < number of bits in `num`) # Output * Returns (int): The integer value after the bit at position `i` has been removed. # Constraints * `num` will always be a non-negative integer. * `i` will always be within a valid range for the binary representation of `num`. # Examples 1. Input: `num = 21` (binary `10101`), `i = 2` Output: `9` (binary `1001`) 2. Input: `num = 21` (binary `10101`), `i = 4` Output: `5` (binary `101`) 3. Input: `num = 10` (binary `1010`), `i = 0` Output: `5` (binary `101`) Make sure to account for the necessary bit manipulations and edge cases mentioned in the detailed analysis.","solution":"def remove_bit(num: int, i: int) -> int: Removes the bit at position i from the binary representation of num and returns the new integer value. # Create a mask that has all bits set to 1 except the bit at position i mask = (1 << i) - 1 # Get the part of num before the bit to be removed before = num & mask # Get the part of num after the bit to be removed, and shift it right by 1 to fill the removed bit\'s position after = (num >> (i + 1)) << i # Combine before and after to get the final result return before | after"},{"question":"You are helping a set of developers to optimize their code that calculates the number of distinct ways to climb to the top of a flight of stairs, where each step taken can be 1 or 2 steps at a time. The existing code computes the result using linear space complexity, but you recognize a more space-efficient method. **Function to Implement:** Write a function `climb_stairs_optimized` that returns the number of distinct ways to reach the top of a staircase with `steps` steps using O(1) space. ```python def climb_stairs_optimized(steps): This function calculates the number of distinct ways to climb to the top of the staircase taking either 1 or 2 steps at a time. :param steps: int - total number of steps in the staircase. :return: int - number of distinct ways to reach the top. # Your code here ``` # Constraints: - The `steps` parameter is a positive integer, with (1 leq steps leq 1000). - Performance should be efficient in terms of space complexity, specifically O(1). # Example: ```python print(climb_stairs_optimized(2)) # Output: 2 print(climb_stairs_optimized(3)) # Output: 3 print(climb_stairs_optimized(5)) # Output: 8 ``` # Explanation: - For `steps = 2`, there are 2 ways to reach the top: (1, 1) and (2). - For `steps = 3`, there are 3 ways to reach the top: (1, 1, 1), (1, 2), and (2, 1). - For `steps = 5`, there are 8 ways, calculated using the Fibonacci sequence logic extended to climbing stairs problem. Validate your function against the examples and ensure it uses constant space for the computations.","solution":"def climb_stairs_optimized(steps): This function calculates the number of distinct ways to climb to the top of the staircase taking either 1 or 2 steps at a time using O(1) space complexity. :param steps: int - total number of steps in the staircase. :return: int - number of distinct ways to reach the top. if steps <= 1: return 1 first = 1 second = 1 for _ in range(2, steps + 1): current = first + second first = second second = current return second"},{"question":"You are tasked with implementing the Comb Sort algorithm for sorting an array of integers. To test your understanding of sorting algorithms and edge case handling, you must implement the function with particular focus on optimization and robustness for various input types. Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: ``` Input - `arr`: A list of integers (0 <= len(arr) <= 10^5). Output - A list of integers sorted in non-decreasing order. Constraints - You must use the Comb Sort algorithm. - Your implementation must handle edge cases like empty arrays and arrays with identical elements efficiently. - Aim for an optimized solution with reduced time complexity where possible. Example Input ```python arr = [32, 24, 15, 69, 8, 52] ``` Output ```python [8, 15, 24, 32, 52, 69] ``` Additional Information Comb Sort is known for its average case efficiency but can degrade in performance for worst-case scenarios. Your task includes implementing the core algorithm while ensuring it performs well on typical datasets, addressing edge cases and potential performance bottlenecks. Ensure your code is clean, well-commented, and handles all specified constraints effectively.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Comb Sort algorithm. if len(arr) <= 1: return arr def get_next_gap(gap): # Shrink the gap by the shrink factor of 1.3 gap = (gap * 10) // 13 return max(1, gap) n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"You are building a secure vault system where certain vaults cannot be accessed consecutively due to security protocols. For this, you need to write a function that determines the maximum amount of value that can be retrieved from the vaults without tripping any alarms. Function Signature ```python def max_retrievable_value(vaults: List[int]) -> int: pass ``` Input * `vaults`: A list of non-negative integers where each integer represents the value stored in each vault. The length of the list can be up to `10^4`. Output * Returns the maximum amount of value that can be retrieved from the vaults without accessing two consecutive vaults. Constraints * You cannot access two consecutive vaults. * The list may contain 0 or more vaults. Example ```python # Example 1 vaults = [2, 7, 9, 3, 1] # Explanation: Robbing vaults with values 2, 9, and 1 will give you the maximum value 2 + 9 + 1 = 12. assert max_retrievable_value(vaults) == 12 # Example 2 vaults = [2, 1, 1, 2] # Explanation: Robbing vaults with values 2 and 2 will give you the maximum 2 + 2 = 4. assert max_retrievable_value(vaults) == 4 ``` Your task is to implement the `max_retrievable_value` function in such a way that it efficiently computes the maximum value that can be retrieved without accessing any two consecutive vaults.","solution":"from typing import List def max_retrievable_value(vaults: List[int]) -> int: if not vaults: return 0 if len(vaults) == 1: return vaults[0] # Using dynamic programming to store the max value at each vault index dp = [0] * len(vaults) dp[0] = vaults[0] dp[1] = max(vaults[0], vaults[1]) for i in range(2, len(vaults)): dp[i] = max(dp[i-1], dp[i-2] + vaults[i]) return dp[-1]"},{"question":"# Binary Tree Paths Background You\'ve been provided with a binary tree, and your task is to find all the paths from the root to the leaves. Each path should be represented as a string of node values separated by arrows (`->`). # Problem Statement Given the root of a binary tree, implement a function `binary_tree_paths` that returns a list of all root-to-leaf paths. Each path is represented as a string of node values separated by arrows (`->`). Function Signature ```python def binary_tree_paths(root: TreeNode) -> List[str]: ``` Input - `root`: The root node of a binary tree. Each node is an instance of `TreeNode`. Output - `List[str]`: A list of all root-to-leaf paths in the tree, where each path is a string. Constraints - The number of nodes in the tree is in the range [0, 1000]. - -100 <= Node.val <= 100 # Example ```python # Example 1: # Input: [1, 2, 3, None, 5] # Output: [\\"1->2->5\\", \\"1->3\\"] # # Example 2: # Input: [1] # Output: [\\"1\\"] ``` # Notes 1. A leaf is defined as a node with no children. 2. If the input tree is empty (root is None), return an empty list. TreeNode Class Assume the following class definition for the TreeNode: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root: Optional[TreeNode]) -> List[str]: def construct_paths(node, path): if node: path += str(node.val) if not node.left and not node.right: # if leaf node paths.append(path) # add path to paths else: path += \'->\' construct_paths(node.left, path) construct_paths(node.right, path) paths = [] construct_paths(root, \'\') return paths"},{"question":"Binomial Coefficient Calculation # Objective Design a function to calculate the binomial coefficient C(n, k) using a dynamic programming approach. This function should handle large values of n and k efficiently and avoid recursion-related limitations. # Context Binomial coefficients are crucial in combinatorial mathematics and often used to solve problems involving combinations. Your function will be used in a simulation software where performance and accuracy for large inputs are critical. # Task Implement a function named `binomial_coefficient(n: int, k: int) -> int` that calculates the binomial coefficient C(n, k) using an iterative dynamic programming approach. # Input - `n`: A non-negative integer (0 <= n <= 10^5) - `k`: A non-negative integer (0 <= k <= n) # Output - Return the integer value representing C(n, k) # Constraints - The function should handle large values up to n = 100,000 efficiently. - Avoid recursion to prevent stack overflow. - Perform necessary validation to ensure n >= k and n, k are non-negative. # Example ```python assert binomial_coefficient(5, 0) == 1 assert binomial_coefficient(8, 2) == 28 assert binomial_coefficient(500, 300) == 294692427022540894366527900 ``` # Hint Consider using a 2D list for implementing dynamic programming or optimize space complexity using a 1D list since each calculation depends only on the previous row\'s values.","solution":"def binomial_coefficient(n: int, k: int) -> int: Calculate the binomial coefficient C(n, k) using a dynamic programming approach. :param n: A non-negative integer (0 <= n <= 10^5) :param k: A non-negative integer (0 <= k <= n) :return: The binomial coefficient C(n, k) if k > n or k < 0: return 0 if k == 0 or k == n: return 1 # Optimize by reducing the value of k to be at most n-k k = min(k, n - k) C = [0] * (k + 1) C[0] = 1 # Base case for i in range(1, n + 1): # Compute the value backwards to avoid overwriting the values for j in range(min(i, k), 0, -1): C[j] += C[j - 1] return C[k]"},{"question":"# Stooge Sort Enhancement Task You are tasked with enhancing the Stooge Sort algorithm. Given the highly inefficient nature of Stooge Sort, you need to modify the original algorithm to improve its performance where possible. # Objective Create a modified version of Stooge Sort that includes a threshold parameter `t`. If the number of elements between `l` and `h` is less than or equal to `t`, the algorithm should switch to using Insertion Sort for that segment instead of recursing further. This optimizes performance by reducing unnecessary recursive calls for smaller partitions of the array. # Implementation Details Write a function called `enhanced_stoogesort(arr, l, h, t)` that sorts an array `arr` from indices `l` to `h` using the Stooge Sort algorithm enhanced with the specified threshold `t`. # Input * `arr`: A list of integers to be sorted. * `l`: Starting index of the segment to be sorted. * `h`: Ending index of the segment to be sorted. * `t`: Threshold parameter for switching to Insertion Sort. # Output The function should return the sorted `arr` in-place. # Constraints 1. The array `arr` will have no more than 1000 elements. 2. The values in `arr` will range from -10^6 to 10^6. 3. `t` is a positive integer. # Example Usage ```python def enhanced_stoogesort(arr, l, h, t): # Write your function implementation here. # Sample Input arr = [5, 2, 9, 1, 5, 6] l = 0 h = len(arr) - 1 t = 3 enhanced_stoogesort(arr, l, h, t) # Expected Output # The sorted array should be: [1, 2, 5, 5, 6, 9] print(arr) ``` # Notes * Make sure your function handles edge cases, such as very small arrays and already sorted arrays. * You may create helper functions where necessary for better code organization.","solution":"def insertion_sort(arr, l, h): Helper function to perform Insertion Sort on the subarray from indices l to h for i in range(l + 1, h + 1): key = arr[i] j = i - 1 while j >= l and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def enhanced_stoogesort(arr, l, h, t): Enhanced Stooge Sort algorithm with a threshold parameter to switch to Insertion Sort for small segments. if l >= h: return # If the subarray is smaller than the threshold, use Insertion Sort if (h - l + 1) <= t: insertion_sort(arr, l, h) return # Perform the Stooge Sort logic if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if (h - l + 1) > 2: third = (h - l + 1) // 3 enhanced_stoogesort(arr, l, h - third, t) enhanced_stoogesort(arr, l + third, h, t) enhanced_stoogesort(arr, l, h - third, t)"},{"question":"You are building a simple scientific calculator and need a function to calculate the square root of a given positive integer `N` within a desired precision `P`. Specifically, you must implement the square root calculation using the Newton\'s Method. # Requirements 1. Your function should be named `calc_square_root` and have the following signature: ```python def calc_square_root(N: int, P: float = 0.001) -> float: ``` 2. The function should take: * A positive integer `N` (1 ≤ N ≤ 10^9) * A positive floating-point precision `P` (0 < P ≤ 0.1) 3. The function should return a floating-point number which is the approximate square root of the integer `N` such that the absolute error between the true square root and the result is less than `P`. 4. You may assume `P` is provided or defaults to `0.001` if not supplied. # Constraints * The algorithm should aim for a time complexity of O(log(N/P)). * The algorithm should have a space complexity of O(1). # Example ```python # Example 1: print(calc_square_root(5, 0.001)) # Expected Output: Close to 2.236 (Since √5 ≈ 2.236) # Example 2: print(calc_square_root(10, 0.0001)) # Expected Output: Close to 3.1623 (Since √10 ≈ 3.1623) ``` # Notes: * Your implementation should thoroughly handle edge cases, ensuring accurate results for very small and very large values of `N`. * Ensure you take floating point precision handling into consideration for edge cases involving precision `P`.","solution":"def calc_square_root(N: int, P: float = 0.001) -> float: if N < 1: raise ValueError(\\"N must be a positive integer.\\") if P <= 0 or P > 0.1: raise ValueError(\\"P must be a positive floating point number less than or equal to 0.1.\\") # Initial guess x = N while True: next_x = 0.5 * (x + N / x) if abs(next_x - x) < P: break x = next_x return next_x"},{"question":"# Ordered Stack with Set Insertion Given the `OrderedStack` class implementation, extend its functionality by adding a method `push_set` that pushes all elements from a given set (or list) into the stack such that the order is maintained. The `push_set` method should leverage the existing `push` method to ensure all elements are inserted in the correct order. Function Signature ```python class OrderedStack: ... def push_set(self, items: list) -> None: pass ``` Input * `items`: List or Set of elements to be pushed into the stack. Output * The method returns `None`. It modifies the stack in place. Constraints * All elements in `items` are comparable and are of the same type. * The `items` list or set can contain duplicate values. * You must ensure the stack remains ordered with the highest value at the top and the lowest at the bottom after all elements from `items` have been pushed. Example ```python os = OrderedStack() os.push_set([3, 5, 1, 4]) print(os.items) # Expected: [1, 3, 4, 5] os.push(2) print(os.items) # Expected: [1, 2, 3, 4, 5] ``` Make sure your implementation maintains an ordered stack after inserting all elements.","solution":"class OrderedStack: def __init__(self): self.items = [] def push(self, item): if not self.items or item >= self.items[-1]: self.items.append(item) else: temp = [] while self.items and self.items[-1] > item: temp.append(self.items.pop()) self.items.append(item) while temp: self.items.append(temp.pop()) def push_set(self, items): for item in sorted(items): self.push(item) # Example usage: # os = OrderedStack() # os.push_set([3, 5, 1, 4]) # print(os.items) # Output: [1, 3, 4, 5] # os.push(2) # print(os.items) # Output: [1, 2, 3, 4, 5]"},{"question":"# Prime Number Identification with Enhanced Conditions **Context**: You are working on a project that requires extensive use of prime numbers. Given a standard function to check whether a number is prime, you need to enhance it to handle special conditions more explicitly and improve its efficiency under certain constraints. Write a function `enhanced_prime_check(n: int) -> bool` that does the following: 1. Accepts an integer `n` as input. 2. Returns `True` if `n` is a prime number and `False` otherwise. **Enhanced Conditions**: 1. If `n` is less than or equal to 0, return `False`. 2. Prime check must be efficient and consider steps to minimize the number of iterations. 3. For extremely large numbers (greater than 10^6), implement an additional check that leverages computational efficiency principles. 4. Ensure that the solution does not use excessive memory, maintaining O(1) space complexity. **Input**: - An integer `n` where `n` can be any integer. **Output**: - `True` if `n` is prime. - `False` otherwise. **Examples**: ``` enhanced_prime_check(-1) -> False enhanced_prime_check(0) -> False enhanced_prime_check(2) -> True enhanced_prime_check(17) -> True enhanced_prime_check(18) -> False ``` **Constraints**: - Ensure the function handles edge cases effectively. - Optimize for better performance, especially for very large numbers. - Do not use standard library functions or modules that directly provide primality testing.","solution":"import math def enhanced_prime_check(n: int) -> bool: Determines if a number is a prime. if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0 or n % 3 == 0: return False if n > 10**6: # Advanced check for large numbers if n % 5 == 0 or n % 7 == 0: return False i = 5 while (i * i) <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Factorials and Modular Arithmetic As a researcher working with combinatorial mathematics, you frequently need to compute large factorials. To manage these computations more effectively, you sometimes use the concept of calculating factorials modulo a given number. Problem Write a function in Python that computes the factorial of a given non-negative integer `n`. Your function should also be able to compute the factorial modulo a `mod` value if provided. Function Signature ```python def compute_factorial(n: int, mod: int = None) -> int: pass ``` Input - `n` (int): a non-negative integer (0 ≤ n ≤ 10^6). - `mod` (int, optional): a positive integer (1 ≤ mod ≤ 10^9). Output - Return the factorial of `n`. If `mod` is provided, return the factorial modulo `mod`. Constraints - Do not use Python\'s in-built factorial functions. - Maintain efficient memory usage. Examples 1. `compute_factorial(5)` should return `120` because 5! = 1×2×3×4×5 = 120. 2. `compute_factorial(5, 3)` should return `0` because 120 % 3 = 0. 3. `compute_factorial(0)` should return `1` as 0! = 1. 4. `compute_factorial(10, 11)` should return `10` because 3628800 % 11 = 10. Notes - Ensure to handle edge cases properly. - Optimize for large values of `n`.","solution":"def compute_factorial(n: int, mod: int = None) -> int: Compute the factorial of a non-negative integer n. If mod is provided, compute the factorial modulo mod. if n < 0: raise ValueError(\\"n must be a non-negative integer.\\") if mod is not None and mod < 1: raise ValueError(\\"mod must be a positive integer.\\") result = 1 for i in range(2, n + 1): result *= i if mod is not None: result %= mod return result"},{"question":"# Question: Minimum Steps in a Forest Fire Escape You are aiding in the design of an emergency escape route for a forest with potential wildfire hazards. The forest is represented as a 2D grid where each cell may either be passable (1) or impassable (0). Your task is to figure out the shortest safe escape route from the top-left corner cell (0,0) to the bottom-right corner cell (m-1,n-1), moving only on passable cells. **Specifications**: * The grid is given as a 2D list of integers, where `1` represents a passable cell and `0` represents an impassable cell. * Only 4 possible movements are allowed: up, down, left, right. * Some cells may be impassable; thus, there might be no viable escape route. Your goal is to implement a function `forest_fire_escape(maze)` that returns the minimum number of steps required to reach the bottom-right corner from the top-left corner. If no such path exists, return `-1`. **Input**: * An `m x n` 2D list `maze` where `maze[i][j]` can be either `0` or `1`. **Output**: * An integer representing the minimum number of steps required or `-1` if no path exists. **Constraints**: - (1 leq m, n leq 100) - `maze[i][j]` is either `0` or `1` **Examples**: ```python # Example 1 maze = [ [1,0,1,1,1,1], [1,0,1,0,1,0], [1,0,1,0,1,1], [1,1,1,0,1,1] ] print(forest_fire_escape(maze)) # Output: 14 # Example 2 maze = [ [1,0,0], [0,1,1], [0,1,1] ] print(forest_fire_escape(maze)) # Output: -1 ``` **Note**: Ensure your solution handles edge cases like blocked entry or exit points and grids where no valid path exists.","solution":"from collections import deque def forest_fire_escape(maze): if not maze or not maze[0] or maze[0][0] == 0 or maze[-1][-1] == 0: return -1 m, n = len(maze), len(maze[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: row, col, steps = queue.popleft() if row == m - 1 and col == n - 1: return steps for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < m and 0 <= new_col < n and (new_row, new_col) not in visited and maze[new_row][new_col] == 1: visited.add((new_row, new_col)) queue.append((new_row, new_col, steps + 1)) return -1"},{"question":"**Scenario**: You are a software security expert who’s consulting for a security company. You need to analyze the patterns of a professional robber who plans to rob houses along a street. Each house has a certain amount of money stashed, but adjacent houses have interconnected security systems that trigger alarms if broken into on the same night. Your task is to write a program that determines the maximum amount of money the robber can steal without triggering these alarms. **Function Signature**: ```python def max_robbery(houses: List[int]) -> int: ``` # Input: * `houses` (List[int]): A non-empty list of non-negative integers where each integer represents the amount of money hidden in each house. # Output: * `int`: The maximum amount of money that can be robbed tonight without alerting the police. # Constraints: * The length of `houses` list is `1 <= len(houses) <= 1000`. * Each element in `houses` is a non-negative integer `0 <= houses[i] <= 10^4`. # Example: ```python # Example 1 houses = [2, 3, 2] print(max_robbery(houses)) # Output: 4 # Example 2 houses = [7, 10, 12, 7, 9, 14] print(max_robbery(houses)) # Output: 33 ``` # Notes: 1. Consider edge cases like an empty list or lists with just one or two houses. 2. Optimal solutions should demonstrate dynamic programming principles as discussed. 3. Solutions should be efficient, operating within both time and space complexity requirements.","solution":"from typing import List def max_robbery(houses: List[int]) -> int: if not houses: return 0 n = len(houses) if n == 1: return houses[0] if n == 2: return max(houses) # Dynamic programming table dp = [0] * n # Base cases dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) # Fill the dp table for i in range(2, n): dp[i] = max(dp[i - 1], dp[i - 2] + houses[i]) return dp[n - 1]"},{"question":"# Context An e-commerce platform allows its users to search for products using keywords. To enhance the search experience, matched keywords within product names need to be highlighted by surrounding them with square brackets. Given an array of product names and an array of keywords (symbols), implement the highlighting efficiently. # Objective Write a function `highlight_keywords(products, keywords)` that takes: - `products`: a list of product names (strings). - `keywords`: a list of keywords (strings). # Input - `products`: List of strings, with each string length up to 100 and the list containing a maximum of 1000 products. - `keywords`: List of strings, with each string length up to 50 and the list containing a maximum of 100 keywords. # Output - Return a list of strings where each product name has its longest matching keyword surrounded by square brackets. If a product name contains no keywords, it should remain unchanged. # Constraints - A product name may contain multiple keywords; choose the one with the longest length. - If multiple keywords of the same length match a product name, choose any one of them. - The function should be optimized for performance due to large input sizes. # Function Signature ```python def highlight_keywords(products: List[str], keywords: List[str]) -> List[str]: ``` # Example ```python products = [\'Amazon\', \'Microsoft\', \'Google\'] keywords = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] # Expected Output: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] result = highlight_keywords(products, keywords) print(result) ``` # Note - Ensure your solution is efficient and leverages appropriate data structures to handle the problem constraints. - Pay attention to edge cases such as overlapping or nested keywords within product names.","solution":"from typing import List def highlight_keywords(products: List[str], keywords: List[str]) -> List[str]: def find_longest_keyword(product, keywords): max_length = 0 longest_keyword = \\"\\" position = -1 for keyword in keywords: index = product.find(keyword) if index != -1: if len(keyword) > max_length: max_length = len(keyword) longest_keyword = keyword position = index return longest_keyword, position highlighted_products = [] for product in products: longest_keyword, position = find_longest_keyword(product, keywords) if position != -1: highlighted_product = (f\\"{product[:position]}[{longest_keyword}]{product[position+len(longest_keyword):]}\\") else: highlighted_product = product highlighted_products.append(highlighted_product) return highlighted_products"},{"question":"# Context You are tasked with implementing a specialized sorting algorithm, Cocktail Shaker Sort, which is a bi-directional variant of the classical Bubble Sort. This sort algorithm is best used on small or nearly sorted datasets due to its ability to move high and low values from the end and start of the list, respectively, more efficiently than Bubble Sort. # Task Create a function `cocktail_shaker_sort` that takes a list of integers and sorts it in ascending order using the Cocktail Shaker Sort algorithm. # Function Signature ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr` (List[int]): A list of integers that needs to be sorted. # Output * (List[int]): A sorted list in ascending order. # Constraints * The function should handle lists of up to 10,000 integers efficiently. * You should not use any built-in sorting functions; the solution must implement Cocktail Shaker Sort. # Example ```python # Example 1 input_arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] print(cocktail_shaker_sort(input_arr)) # Output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] # Example 2 input_arr = [10, 7, 8, 9, 1, 5] print(cocktail_shaker_sort(input_arr)) # Output: [1, 5, 7, 8, 9, 10] ``` # Notes * Ensure that the function is robust enough to handle edge cases including empty lists and lists with a single element. * Aim to maintain the stability of the sorting algorithm, preserving the relative order of equal elements. * Consider using helper functions for swapping elements to maintain clean and modular code.","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: Sorts a list of integers in ascending order using the Cocktail Shaker Sort algorithm. if not arr: return arr n = len(arr) start = 0 end = n - 1 while start <= end: swapped = False # Traverse the list from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # If nothing moved, the array is sorted if not swapped: break # Otherwise, reset the swapped flag so we can use it in the next stage swapped = False end -= 1 # Traverse the list from right to left for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True start += 1 return arr"},{"question":"You are tasked with designing an extended version of the staircase problem, where each time you can either climb 1, 2, or 3 steps instead of just 1 or 2. Given a positive integer `steps`, you are to find the number of distinct ways to reach the top. # Function Specification Implement the function `count_ways(steps)` to solve the problem. Input * **steps** (int): A positive integer representing the number of steps to reach the top. Output * **int**: The number of distinct ways to climb the staircase. # Constraints * ( 1 leq text{steps} leq 10^5 ) # Example ```python count_ways(3) > 4 # [1,1,1], [1,2], [2,1], [3] count_ways(5) > 13 # Various combinations of 1, 2, and 3 steps summing to 5 ``` # Requirements * Efficient time complexity: O(n) * Use constant space optimization similar to the optimized solution provided. # Implementation Details * Consider reusing the dynamic programming approach. * Think through how to extend the approach to allow up to 3 steps at a time without significantly increasing complexity.","solution":"def count_ways(steps): Returns the number of distinct ways to climb the staircase with \'steps\' steps, where one can climb either 1, 2 or 3 steps at a time. if steps == 1: return 1 elif steps == 2: return 2 elif steps == 3: return 4 # Initial values corresponding to 1, 2, and 3 steps. a, b, c = 1, 2, 4 for i in range(4, steps + 1): d = a + b + c a, b, c = b, c, d return c"},{"question":"# Coding Challenge: Implement a Priority Queue Objective: Implement a Priority Queue using a Min-Heap to understand the crucial operations like insertion and deletion in the context of priority handling. Operation and Constraints: 1. **Initialize Priority Queue**: Ability to initialize an empty priority queue. 2. **Insert with Priority**: Add elements with an associated priority. 3. **Get Minimum Priority Element**: Retrieve and remove the element with the minimum priority. 4. **Peek Minimum Priority Element**: Retrieve, without removing, the element with the minimum priority. 5. **Check if Empty**: Ability to check if the priority queue is empty. 6. **Get Size**: Return the number of elements in the priority queue. Example: ```python pq = PriorityQueue() pq.insert(3, \'Task 3\') pq.insert(1, \'Task 1\') pq.insert(2, \'Task 2\') print(pq.get_min()) # Output: \'Task 1\' print(pq.peek_min()) # Output: \'Task 2\' (Next minimum after Task 1 is removed) print(pq.is_empty()) # Output: False print(pq.size()) # Output: 2 ``` Function Signature: ```python class PriorityQueue: def __init__(self): # Initialize priority queue using min-heap def insert(self, priority: int, value): # Insert value with given priority into the priority queue def get_min(self): # Get and remove the element with the minimum priority # Throws an exception if the queue is empty def peek_min(self): # Get the element with the minimum priority without removing it # Throws an exception if the queue is empty def is_empty(self) -> bool: # Returns True if the priority queue is empty, else False def size(self) -> int: # Returns the size (number of elements) in the priority queue ``` Constraints: * Priority values can be assumed to be integers. * The priority queue should handle a very large number of elements efficiently. * Operations should be optimized to ensure minimum average time complexity.","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] def insert(self, priority, value): heapq.heappush(self.heap, (priority, value)) def get_min(self): if not self.heap: raise IndexError(\\"get_min() called on empty priority queue\\") return heapq.heappop(self.heap)[1] def peek_min(self): if not self.heap: raise IndexError(\\"peek_min() called on empty priority queue\\") return self.heap[0][1] def is_empty(self): return len(self.heap) == 0 def size(self): return len(self.heap)"},{"question":"# Bit Manipulation: Find the Single Unique Element You are given an array of integers where every element appears exactly twice, except for one unique element that appears only once. Your task is to find the element that appears only once. **Function Signature:** ```python def find_unique(arr: list[int]) -> int: Finds the element that appears only once in the array where every other element appears twice. :param arr: List of integers where every element appears exactly twice, except for one unique element. :return: The element that appears only once. ``` **Input:** - A list of integers, `arr`, where `1 <= len(arr) <= 10^5` and each integer in the array has a value between `-10^5` and `10^5`. **Output:** - Return the integer that appears only once in the array. **Constraints:** - The array must contain exactly one unique element. - The algorithm should be efficient with a time complexity of O(n) and constant space complexity O(1). **Performance Requirements:** - The solution should not use any extra memory other than a few variables (constant space). **Example:** ```python # Example 1: arr = [2, 2, 1] # Output: 1 # Example 2: arr = [4, 1, 2, 1, 2] # Output: 4 # Example 3: arr = [1] # Output: 1 ``` **Instructions:** - Implement the function `find_unique(arr)` to solve the problem. - The function should leverage bit manipulation, particularly the XOR operation (`^`), to achieve the desired outcome efficiently. **Hint:** - Use the property of XOR: `a ^ a = 0` and `a ^ 0 = a`. XOR-ing all the elements will cancel out elements that appear twice, leaving the unique element.","solution":"def find_unique(arr): Finds the element that appears only once in the array where every other element appears twice. :param arr: List of integers where every element appears exactly twice, except for one unique element. :return: The element that appears only once. unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"# Next Higher Permutation Generator You are required to generate the next higher number permutation for a given non-negative integer. The goal is to find the immediate next largest number that can be formed using the exact set of digits of the given number. If no such greater permutation is possible, return -1. Write a function `next_higher_permutation(num: int) -> int`: Input: * An integer `num` where `0 ≤ num ≤ 10^9`. Output: * The next higher permutation as an integer, or -1 if no such permutation exists. Constraints: 1. The input number will always be non-negative. 2. The function must handle numbers with up to 9 digits effectively. 3. Optimize for best possible time complexity; algorithm should ideally run in O(n) time, where `n` is the number of digits. Examples: 1. `next_higher_permutation(38276)` should return `38627`. 2. `next_higher_permutation(12345)` should return `12354`. 3. `next_higher_permutation(54321)` should return `-1`. Edge Cases to consider: * Input with all identical digits (e.g., 1111) * Single digit input (e.g., 5) * Input with descending ordered digits (e.g., 4321) * Globally maximal permutations (e.g., 999999999) # Scenario: For this task, imagine you are creating the underlying logic for a calculator tool that helps users determine the next possible permutation of their entered number. This could be particularly useful for users involved in tasks involving combinatorial logic, such as creating unique identifiers based on user inputs. Implement the function `next_higher_permutation(num: int) -> int` with the details outlined above.","solution":"def next_higher_permutation(num: int) -> int: Finds the next higher permutation of the given number. If no such permutation exists, returns -1. num_str = list(str(num)) i = len(num_str) - 2 # Find the rightmost char which is smaller than its next char. while i >= 0 and num_str[i] >= num_str[i + 1]: i -= 1 # If no such char is found, that means the digits are in descending order if i == -1: return -1 # Find the rightmost char on the right side of (i\'th) which is # greater than num_str[i] then swap them for j in range(len(num_str) - 1, i, -1): if num_str[j] > num_str[i]: num_str[i], num_str[j] = num_str[j], num_str[i] break # Reverse the digits after (i\'th) position num_str = num_str[:i + 1] + num_str[i + 1:][::-1] return int(\'\'.join(num_str))"},{"question":"**Context**: Design a data structure that supports adding new words and searching for existing words using minimal and efficient space and time. The search can include literal words or a pattern where \'.\' can match any letter. **Objective**: Implement a class `WordDictionary` with the following methods: 1. `def add_word(word: str) -> None` 2. `def search(word: str) -> bool` # Input and Output Formats: - `add_word(word: str) -> None`: Adds the word `word` to the data structure. - `search(word: str) -> bool`: Returns `True` if the word or pattern `word` exists in the data structure, otherwise returns `False`. # Constraints: - Assume all input words consist of lowercase English alphabets. - The length of input words will not exceed 5000 characters. - The total number of words added will be at most 1,000,000. # Examples: ```python dic = WordDictionary() dic.add_word(\\"bad\\") dic.add_word(\\"dad\\") dic.add_word(\\"mad\\") print(dic.search(\\"pad\\")) # Output: False print(dic.search(\\"bad\\")) # Output: True print(dic.search(\\".ad\\")) # Output: True print(dic.search(\\"b..\\")) # Output: True ``` # Requirements: 1. You may choose to implement the data structure using a Trie or a combination of a Hash Map and lists. 2. Consider efficiency in both time and space. 3. Handle edge cases such as empty strings effectively. # Performance: - Ensure your solution is efficient and can handle large inputs within reasonable time limits. - Aim for an optimal balance of performance, readability, and maintainability.","solution":"class WordDictionary: def __init__(self): Initialize your data structure here. self.trie = {} def add_word(self, word: str) -> None: Adds a word into the data structure. node = self.trie for char in word: if char not in node: node[char] = {} node = node[char] node[\'#\'] = True def search(self, word: str) -> bool: Returns if the word is in the data structure. A word could contain the dot character \'.\' to represent any one letter. return self._search_in_node(word, self.trie) def _search_in_node(self, word, node): for i, char in enumerate(word): if char not in node: if char == \'.\': for x in node: if x != \'#\' and self._search_in_node(word[i+1:], node[x]): return True return False else: node = node[char] return \'#\' in node # return True if end of word is reached"},{"question":"**Scenario**: A smart communication system uses a simple encoding scheme to transmit alphabetic messages as sequences of digits. Each letter is mapped to a numeric value (\'A\' -> \'1\', \'B\' -> \'2\', ..., \'Z\' -> \'26\'). When the encoded message is received, it needs to be decoded to determine how many different valid ways the original message can be reconstructed. **Problem Statement:** Write a function `count_ways_to_decode(message: str) -> int` that takes an encoded message as input and returns the number of ways to decode it according to the given mapping. # Input * `message`: A string containing only digits representing the encoded message. It is guaranteed to be non-empty. # Output * Returns an integer representing the number of possible ways to decode the message. # Constraints * The input string `message` will only contain digits \'0\'-\'9\'. * If the string contains any invalid sequences of digits for decoding (\'0\' not part of \'10\' or \'20\', or values greater than \'26\' that can\'t be part of a valid pair), return `0`. # Examples 1. **Input**: `message = \\"12\\"` **Output**: `2` **Explanation**: \\"12\\" can be decoded as \\"AB\\" (1 2) or \\"L\\" (12). 2. **Input**: `message = \\"226\\"` **Output**: `3` **Explanation**: \\"226\\" can be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6) or \\"BBF\\" (2 2 6). 3. **Input**: `message = \\"06\\"` **Output**: `0` **Explanation**: \\"06\\" is not a valid encoded message. 4. **Input**: `message = \\"101\\"` **Output**: `1` **Explanation**: \\"101\\" can be decoded as \\"JA\\" (10 1). # Task Implement the function `count_ways_to_decode(message)` based on the explanation and requirements above. ```python def count_ways_to_decode(message: str) -> int: if not message or message[0] == \'0\': return 0 n = len(message) dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 # Base cases for i in range(2, n + 1): one_digit = int(message[i-1:i]) two_digit = int(message[i-2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i-1] if 10 <= two_digit <= 26: dp[i] += dp[i-2] return dp[n] # You may test your implementation with some example inputs print(count_ways_to_decode(\\"12\\")) # Expected output: 2 print(count_ways_to_decode(\\"226\\")) # Expected output: 3 print(count_ways_to_decode(\\"06\\")) # Expected output: 0 ```","solution":"def count_ways_to_decode(message: str) -> int: if not message or message[0] == \'0\': return 0 n = len(message) dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 # Base cases for i in range(2, n + 1): one_digit = int(message[i-1:i]) two_digit = int(message[i-2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i-1] if 10 <= two_digit <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"# Cycle Detection in Linked List A tech company is creating a new database system that handles transactions represented as a linked list. For stability and to avoid infinite loops in transaction processing, the system must be able to detect cycles in the linked list efficiently. You need to implement a function that detects whether a given linked list has a cycle. This function must solve the problem using Floyd\'s Tortoise and Hare algorithm. Function Signature ```python def has_cycle(head: Node) -> bool: Determine if the linked list has a cycle. :param head: The head node of the linked list. :type head: Node :return: True if there is a cycle in the linked list, False otherwise. :rtype: bool # Your code here ``` Input * `head`: A Node object which is the head of the linked list. Output * A boolean value: * `True` if the linked list contains a cycle. * `False` if the linked list does not contain a cycle. Constraints * The linked list is composed of nodes with a `val` attribute and a `next` attribute. * The length of the linked list does not exceed 10^5 nodes. Example ```python # A linked list with a cycle: # 1 -> 2 -> 3 -> 4 -> 2 ... head = Node(1) head.next = Node(2) second = head.next second.next = Node(3) third = second.next third.next = Node(4) fourth = third.next fourth.next = second # Creates a cycle print(has_cycle(head)) # Output: True # A linked list without a cycle: # 1 -> 2 -> 3 -> 4 head = Node(1) head.next = Node(2) second = head.next second.next = Node(3) third = second.next third.next = Node(4) print(has_cycle(head)) # Output: False ``` # Note Ensure your function handles all edge cases and performs efficiently for large inputs. The solution should not use any extra space other than the required pointers.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def has_cycle(head: Node) -> bool: Determine if the linked list has a cycle. :param head: The head node of the linked list. :type head: Node :return: True if there is a cycle in the linked list, False otherwise. :rtype: bool if not head: return False slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"# Question: Encode and Decode a List of Strings You are given a list of strings that needs to be encoded into a single string, which can be transmitted or stored efficiently. Later, this encoded string needs to be decoded back into the original list of strings. **Tasks**: 1. Implement the `encode` function that converts a list of strings into a single encoded string. 2. Implement the `decode` function that converts the encoded string back into the original list of strings. # Function Signatures: ```python def encode(strs: List[str]) -> str: pass def decode(s: str) -> List[str]: pass ``` # Input and Output: - `encode`: * **Input**: `strs` (List of strings) * **Output**: A single encoded string - `decode`: * **Input**: `s` (A single encoded string) * **Output**: Original list of strings # Example: ```python # Example of how to use encode and decode original_strings = [\\"hello\\", \\"world\\"] encoded_string = encode(original_strings) print(encoded_string) # Could be \\"5:hello5:world\\" decoded_strings = decode(encoded_string) print(decoded_strings) # Should output [\\"hello\\", \\"world\\"] ``` # Constraints: 1. Each string in the list will only contain printable ASCII characters. 2. Total length of the encoded string will not exceed 1,000,000 characters. # Requirements: Ensure your solution is efficient enough to handle large inputs within the given constraints. Discuss edge cases and potential limitations of your implementation. **Tip**: Ensure your `encode` and `decode` functions are inverse operations, i.e., `decode(encode(strs))` should return `strs`.","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. encoded = \'\' for s in strs: encoded += \'{}:{}\'.format(len(s), s) return encoded def decode(s: str) -> List[str]: Decodes a single string to a list of strings. i = 0 decoded = [] while i < len(s): j = s.find(\':\', i) length = int(s[i:j]) decoded.append(s[j + 1: j + 1 + length]) i = j + 1 + length return decoded"},{"question":"# Pattern Matching with Backtracking Given a pattern and a string, your task is to determine if the string follows the same pattern using a one-to-one mapping between characters in the pattern and non-overlapping substrings of the string. Function Signature ```python def pattern_match(pattern: str, string: str) -> bool: pass ``` # Input - `pattern`: A string representing the pattern, consisting of lowercase letters (1 <= len(pattern) <= 20). - `string`: A string where we need to match the pattern, consisting of lowercase letters (1 <= len(string) <= 100). # Output - Returns `True` if the string follows the pattern, `False` otherwise. # Constraints - The pattern and string both only contain lowercase letters. - Each letter in the pattern must map to a non-empty substring in the string, and different letters in the pattern must map to different substrings. # Examples ```python print(pattern_match(\\"abab\\", \\"redblueredblue\\")) # should return True print(pattern_match(\\"aaaa\\", \\"asdasdasdasd\\")) # should return True print(pattern_match(\\"aabb\\", \\"xyzabcxzyabc\\")) # should return False ``` # Performance Requirements - Aim for an efficient implementation, but understand that a complete solution involves significant backtracking and exploration of possible mappings. # Edge Cases - Handle empty strings and patterns (valid and invalid cases). - Ensure the algorithm returns correct results for patterns longer than the input string. - Consider scenarios where the pattern consists of a single character and validate correct functionality.","solution":"def pattern_match(pattern: str, string: str) -> bool: def backtrack(pattern, string, p_index, s_index, mapping, used): if p_index == len(pattern) and s_index == len(string): return True if p_index == len(pattern) or s_index == len(string): return False pattern_char = pattern[p_index] if pattern_char in mapping: mapped_str = mapping[pattern_char] if not string.startswith(mapped_str, s_index): return False return backtrack(pattern, string, p_index + 1, s_index + len(mapped_str), mapping, used) for end_index in range(s_index + 1, len(string) + 1): candidate = string[s_index:end_index] if candidate in used: continue mapping[pattern_char] = candidate used.add(candidate) if backtrack(pattern, string, p_index + 1, s_index + end_index - s_index, mapping, used): return True del mapping[pattern_char] used.remove(candidate) return False return backtrack(pattern, string, 0, 0, {}, set())"},{"question":"# Coding Task **Context:** You are tasked with implementing a function that finds the next higher number which has the same set of digits as the given number. This problem is crucial in permutation generation problems and can be directly applied while needing the next permutation in series. **Problem Statement:** Implement a function `next_bigger(num: int) -> int` which takes an integer `num` as an input and returns the next higher integer composed of the same set of digits. If no such number exists, return `-1`. **Function Signature:** ```python def next_bigger(num: int) -> int: pass ``` **Input:** - An integer `num` where `0 <= num <= 10^18`. **Output:** - An integer which is the next higher number formed from the digits of `num`. **Constraints:** - You must handle very large numbers efficiently. - The function should run in O(n) time complexity where n is the number of digits. **Example:** ```python assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(54321) == -1 assert next_bigger(999) == -1 assert next_bigger(5) == -1 assert next_bigger(1234321) == 1241233 ``` **Notes:** - Ensure to handle edge cases where no higher permutation is possible. - The function should be optimized to handle integer limits efficiently. **Test Cases:** 1. Basic scenarios: - `next_bigger(38276)` should return `38627`. - `next_bigger(12345)` should return `12354`. 2. No available permutation: - `next_bigger(54321)` should return `-1`. - `next_bigger(999)` should return `-1`. 3. Single digit or non-incrementable sequence: - `next_bigger(5)` should return `-1`. - `next_bigger(222)` should return `-1`. 4. Large numbers: - `next_bigger(12343210)` should efficiently return `12401233`. **Hints:** 1. Convert the number to an array of digits. 2. Traverse from right to left to find the first decreasing element. 3. Perform the necessary swaps and reverse operations to find the next permutation. 4. Carefully handle edge cases to ensure proper results.","solution":"def next_bigger(num: int) -> int: digits = list(str(num)) n = len(digits) # Step 1: Find the rightmost digit which is smaller than its next digit i = n - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 # If there is no such digit, return -1 as it is the largest permutation if i == -1: return -1 # Step 2: Find the smallest digit on right side of (i\'th digit) which is greater than digits[i] j = n - 1 while digits[j] <= digits[i]: j -= 1 # Step 3: Swap the found smallest greater digit with digits[i] digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the digits after (i+1) digits = digits[:i + 1] + digits[i + 1:][::-1] return int(\'\'.join(digits))"},{"question":"# Bubble Sort Augmentation and Optimization Bubble sort is a fundamental sorting algorithm that can be suboptimal for performance-intensive tasks due to its O(N^2) time complexity. However, it serves as an excellent example for learning basic sorting concepts. In this task, you are asked to augment the existing bubble sort function and implement an early termination mechanism along with handling specific edge cases. Task Modify the existing `bubble_sort` function delivering the following enhancements: 1. **Early Termination**: Integrate an early termination feature that halts the sorting process if the list is already sorted before completing all iterations. 2. **Handle Edge Cases**: Ensure the function handles cases such as an empty array, a single-element array, and arrays where all elements are equal. 3. **Enhanced Simulation**: (Optional) Preserve the simulation feature to visualize the steps of sorting for educational purposes. # Function Signature ```python def bubble_sort(arr, simulation=False): # Your code here ``` # Input * `arr`: A list of integers to be sorted. * `simulation`: A boolean flag indicating whether to print the sorting process. # Output * Returns a sorted list of integers. # Example ```python # Example 1 assert bubble_sort([5, 2, 9, 1, 5, 6]) == [1, 2, 5, 5, 6, 9] # Example 2 with simulation assert bubble_sort([3, 0, 2, 5, -1, 4, 1], True) == [-1, 0, 1, 2, 3, 4, 5] ``` # Constraints * The input list `arr` can contain any integer values. * Minimize the number of swaps if the list is already or nearly sorted. * Ensure the function works efficiently for small to moderately-sized datasets. Notes * Consider adding any helper functions if needed to keep the main bubble_sort function clean and understandable. * Document any additional changes or enhancements to the sorting algorithm.","solution":"def bubble_sort(arr, simulation=False): Bubble Sort implementation with early termination and edge case handling. :param arr: List of integers to be sorted. :param simulation: Boolean flag to print the sorting process for educational purposes. :return: Sorted list of integers. if len(arr) < 2: return arr # Return early for empty or single-element arrays n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if simulation: print(f\\"Step {i}-{j}: {arr}\\") # Simulation of the sorting steps # If no elements were swapped, array is already sorted if not swapped: break return arr"},{"question":"# Minimum Repeated Substring Match Problem Statement Given two strings `A` and `B`, write a function `repeat_string(A: str, B: str) -> int` that determines the minimum number of times `A` must be repeated such that `B` becomes a substring of the resulting string. If no number of repeated `A` makes `B` a substring, return `-1`. Input and Output * **Input**: * `A` (1 <= length(A) <= 10000): A non-empty string of lowercase alphabetic characters. * `B` (1 <= length(B) <= 10000): A non-empty string of lowercase alphabetic characters. * **Output**: * An integer specifying the minimum number of times `A` must be repeated. If it is not possible for `B` to be a substring of any repeated version of `A`, return `-1`. Constraints * Maintain a time complexity within O(N * M) in the worst case where N is the length of `A` and M is the length of `B`. * Use only built-in string manipulation functions. Example ```python # Example 1 A = \\"abcd\\" B = \\"cdabcdab\\" # Minimum repetitions needed: 3 # Explanation: \\"abcd\\" repeated 3 times \\"abcdabcdabcd\\" which contains \\"cdabcdab\\" as a substring. # Output: 3 # Example 2 A = \\"a\\" B = \\"aa\\" # Minimum repetitions needed: 2 # Explanation: \\"a\\" repeated 2 times \\"aa\\" which contains \\"aa\\" as a substring. # Output: 2 # Example 3 A = \\"abc\\" B = \\"def\\" # Minimum repetitions needed: -1 # Explanation: No number of repetitions of \\"abc\\" can contain \\"def\\". # Output: -1 ``` Function Signature ```python def repeat_string(A: str, B: str) -> int: # implement the function pass ``` Implementation Notes 1. Concatenate `A` repeatedly and check at each step if `B` is a substring. 2. Use the threshold `(length of B / length of A) + 1` to determine the maximum repetitions to check before concluding it is impossible. 3. Return the count of repetitions or `-1` if `B` cannot be a substring of the repeated `A`.","solution":"def repeat_string(A: str, B: str) -> int: Determines the minimum number of times A must be repeated such that B becomes a substring of the resulting string. If no number of repeated A makes B a substring, return -1. repeat_count = 1 repeated_A = A while len(repeated_A) < len(B): repeated_A += A repeat_count += 1 if B in repeated_A: return repeat_count if B in (repeated_A + A): return repeat_count + 1 return -1"},{"question":"# Moving Average Calculation Using Sliding Window Scenario: You have been given a stream of integers and need to calculate the moving average over the last `n` numbers for every integer read from the stream. This is a typical problem in signal processing, financial markets, and performance analysis, where moving averages are used to smooth out short-term fluctuations and highlight longer-term trends. Objective: Create a class `MovingAverage` that efficiently calculates the latest moving average of the most recent `n` values. Requirements: 1. Implement a constructor that initializes your data structure with a given `size`. 2. Implement a method `next(val)` that: - Receives an integer `val`. - Returns the current moving average of the last `size` values (including the new `val`). Input and Output Format: - The constructor takes one input: * `size` (an integer, `1 <= size <= 1000`): the number of elements in the sliding window. - The `next` method takes one input: * `val` (an integer, `-10^4 <= val <= 10^4`): the new integer being added to the stream. - The `next` method returns: * A float representing the moving average of the last `size` elements. Constraints: - Ensure to handle edge cases such as adding the first element, where the queue may not be at capacity yet. - Aim to minimize the time complexity for both adding new values and computing the moving average. Example Usage: ```python mov_avg = MovingAverage(3) print(mov_avg.next(1)) # Output: 1.0 print(mov_avg.next(10)) # Output: 5.5 print(mov_avg.next(3)) # Output: 4.6667 (average of [1, 10, 3]) print(mov_avg.next(5)) # Output: 6.0 (average of [10, 3, 5]) ``` Note: Be sure to thoroughly test for edge cases and validate the constraints.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): Initialize the MovingAverage with a specified window size. :param size: The size of the sliding window. self.size = size self.queue = deque() self.sum = 0 def next(self, val: int) -> float: Add a new value to the stream and return the moving average of the last `size` values. :param val: The new integer value to add to the stream. :return: The current moving average of the last `size` elements. self.queue.append(val) self.sum += val if len(self.queue) > self.size: self.sum -= self.queue.popleft() return self.sum / len(self.queue)"},{"question":"**Context**: You have been hired to enhance the performance of a company\'s data handling processes. A key area identified is the sorting of records based on various criteria. One specific challenge is ensuring efficient sorting of large datasets while maintaining optimal performance across a variety of input scenarios, including nearly sorted data with duplicate entries. **Objective**: Implement an optimized version of the Quick Sort algorithm which mitigates the issues associated with poor pivot selection. Implement a \'median-of-three\' pivot selection strategy to improve performance on average while minimizing the chances of encountering the worst-case time complexity. **Function Signature**: ```python def optimized_quick_sort(arr): Sorts the array in ascending order using an optimized Quick Sort algorithm. Parameters: arr (List[int]): The list of integers to sort. Returns: List[int]: The sorted list in ascending order. pass ``` **Requirements**: 1. Implement the median-of-three pivot selection technique. 2. Ensure the function is efficient in average case performance close to (O(n log n)). 3. The function must handle large datasets efficiently and avoid common pitfalls of the worst-case scenarios. **Constraints**: - The input array can have up to (10^6) elements. - The elements of the array are integers within the range of (-10^9) to (10^9). **Example**: ```python input_array = [3, 6, 8, 10, 1, 2, 1] print(optimized_quick_sort(input_array)) # Output: [1, 1, 2, 3, 6, 8, 10] input_array = [10, 7, 8, 9, 1, 5] print(optimized_quick_sort(input_array)) # Output: [1, 5, 7, 8, 9, 10] ``` **Instructions**: 1. Implement the function following the given specification. 2. Validate your implementation with both the provided example arrays and additional edge cases to ensure robustness.","solution":"def _median_of_three(arr, low, high): mid = (low + high) // 2 a, b, c = arr[low], arr[mid], arr[high] if a > b: if a < c: return low elif b > c: return mid else: return high else: if a > c: return low elif b < c: return mid else: return high def _partition(arr, low, high): median_index = _median_of_three(arr, low, high) arr[median_index], arr[low] = arr[low], arr[median_index] pivot = arr[low] left = low + 1 right = high done = False while not done: while left <= right and arr[left] <= pivot: left = left + 1 while right >= left and arr[right] >= pivot: right = right - 1 if right < left: done = True else: arr[left], arr[right] = arr[right], arr[left] arr[low], arr[right] = arr[right], arr[low] return right def _quick_sort_helper(arr, low, high): if low < high: split_point = _partition(arr, low, high) _quick_sort_helper(arr, low, split_point - 1) _quick_sort_helper(arr, split_point + 1, high) def optimized_quick_sort(arr): if len(arr) <= 1: return arr _quick_sort_helper(arr, 0, len(arr) - 1) return arr"},{"question":"# Task Description You are required to implement a `MaxPriorityQueue` class using a different underlying data structure, specifically a binary heap, to improve insertion performance. # Specifications - Implement a binary max-heap to manage the elements along with their priorities. - The `MaxPriorityQueue` class should support the following operations: 1. `push(item: int, priority: int) -> None`: Insert an item with a given priority into the priority queue. 2. `pop() -> int`: Remove and return the item with the maximum priority. 3. `size() -> int`: Return the size of the priority queue. # Input/Output - The `push` method takes two integers: `item` and `priority`. - The `pop` method returns an integer. If the priority queue is empty, raise an `IndexError` with the message \\"pop from empty priority queue\\". - The `size` method returns an integer representing the number of elements in the priority queue. # Constraints - You may assume that all item and priority values are integers. - The priority queue can handle up to 10^5 elements. # Example Usage ```python pq = MaxPriorityQueue() pq.push(1, 5) pq.push(2, 9) pq.push(3, 3) print(pq.pop()) # Output: 2 print(pq.size()) # Output: 2 pq.push(4, 10) print(pq.pop()) # Output: 4 print(pq.size()) # Output: 1 ``` # Performance Requirements - Ensure that insertion and extraction operations are optimized for performance with average time complexity of O(log n). # Implementation Notes - Use a binary heap for the `MaxPriorityQueue`. - Consider edge cases such as attempting to `pop` from an empty priority queue. - Ensure efficient handling of up to 10^5 elements.","solution":"import heapq class MaxPriorityQueue: def __init__(self): self.heap = [] def push(self, item: int, priority: int) -> None: # Since heapq in python is a min-heap, we use negative priorities to simulate a max-heap. heapq.heappush(self.heap, (-priority, item)) def pop(self) -> int: if not self.heap: raise IndexError(\\"pop from empty priority queue\\") return heapq.heappop(self.heap)[1] def size(self) -> int: return len(self.heap)"},{"question":"**Title**: Implementation and Application of Interpolation Search **Problem Statement**: You are provided a list of unique integer numbers that is sorted in ascending order. Design and implement a function that performs interpolation search to find the position of a given search key in the array. Your implementation should demonstrate the correct application of the interpolation search algorithm and take into account edge cases and performance efficiency. **Function Signature**: ```python def interpolation_search(array: List[int], search_key: int) -> int: pass ``` **Input**: - `array` (List[int]): A list of unique integers sorted in ascending order (1 ≤ len(array) ≤ 10^6) - `search_key` (int): An integer value to be searched in the array. **Output**: - `int`: The index of `search_key` in the array if found; otherwise, -1. **Constraints**: - The array will be sorted in non-decreasing order. - All integers in the array are unique. **Performance Requirements**: - The algorithm should, on average, execute with a time complexity of O(log(log n)) for uniformly distributed data. **Examples**: ```python assert interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) == 2 assert interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) == -1 assert interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) == -1 ``` **Edge Cases to Consider**: 1. The array is empty. 2. The search key is not present in the array. 3. The search key is at the first or last position in the array. 4. All elements of the array are the same and equal to the search key. 5. The array has elements that do not lend themselves well to interpolation search (e.g., highly non-uniform distribution). **Instructions**: 1. Implement the `interpolation_search` function as per the provided question description. 2. Ensure to test your function with different edge cases. 3. Aim for a clean and efficient implementation that adheres to best coding practices.","solution":"from typing import List def interpolation_search(array: List[int], search_key: int) -> int: Perform interpolation search to find the position of search_key in a sorted array. Parameters: array (List[int]): A list of unique integers sorted in ascending order. search_key (int): The integer value to be searched. Returns: int: The index of search_key in the array if found; otherwise, -1. low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 # Estimate the position using the interpolation formula pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"You are given a list of integers that you need to sort in non-decreasing order using an optimization of the Bubble Sort algorithm. Your implementation should ensure that if the list is already sorted, the algorithm terminates early without making unnecessary passes over the list. # Requirements * Implement the function `optimized_bubble_sort(arr)`. * The function takes a list of integers `arr` as input and returns a new sorted list in non-decreasing order. # Function Signature ```python def optimized_bubble_sort(arr: List[int]) -> List[int]: ``` # Input * A list of integers `arr` with 0 <= len(arr) <= 1000. * You may assume that all integers fit within the typical 32-bit signed integer range. # Output * A new list containing the elements of `arr` sorted in non-decreasing order. # Constraints * You must use the Bubble Sort algorithm with early termination optimization. * The implementation must sort the list in place and should not use any additional data structures for sorting. # Example ```python assert optimized_bubble_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90] assert optimized_bubble_sort([5, 1, 4, 2, 8]) == [1, 2, 4, 5, 8] assert optimized_bubble_sort([3, 0, -1, 8, 7, 2]) == [-1, 0, 2, 3, 7, 8] assert optimized_bubble_sort([]) == [] assert optimized_bubble_sort([1]) == [1] assert optimized_bubble_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] ``` # Explanation * The given examples illustrate the expected behavior of your implementation. For instance, `optimized_bubble_sort([64, 34, 25, 12, 22, 11, 90])` sorts the list correctly into `[11, 12, 22, 25, 34, 64, 90]`. * Consider edge cases like an empty list or a list with one element to ensure robustness.","solution":"def optimized_bubble_sort(arr): Sorts a list of integers in non-decreasing order using an optimized Bubble Sort algorithm. n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] # Swap swapped = True # If no two elements were swapped by inner loop, then the list is already sorted if not swapped: break return arr"},{"question":"Optimized Search in a Sensor Data Array You are working on an application that processes data from a series of sensors arranged in a linear fashion. The sensor data, once processed, is stored in a sorted array. Given the nature of this setup, the data must be accessed rapidly for real-time analysis. You need to implement an optimized search function that quickly finds the index of a specified target value within this sorted array of sensor data. Function Signature ```python def find_sensor_data(sensor_data: List[int], target: int) -> int: ``` Input * `sensor_data` (List[int]): A list of integers representing sorted sensor data. * `target` (int): The integer value representing the sensor data you need to find. Output * Returns the index of the `target` in `sensor_data` if found; otherwise, returns -1. Example ```python sensor_data = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21] target = 7 assert find_sensor_data(sensor_data, target) == 3 sensor_data = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21] target = 4 assert find_sensor_data(sensor_data, target) == -1 ``` Constraints * The length of the array `n` will be at most 10^5. * Elements in `sensor_data` are unique and sorted in ascending order. * The target can be any integer. Performance Requirements * Your implementation should aim to achieve O(√n) time complexity. Notes 1. Handle edge cases where the array may be empty. 2. Ensure that the solution works efficiently even for the upper constraint limits.","solution":"from typing import List def find_sensor_data(sensor_data: List[int], target: int) -> int: Finds the index of the target in the sorted sensor data array using binary search. Args: sensor_data (List[int]): A list of integers representing sorted sensor data. target (int): The integer value representing the sensor data to find. Returns: int: The index of the target if found, otherwise -1. left, right = 0, len(sensor_data) - 1 while left <= right: mid = (left + right) // 2 if sensor_data[mid] == target: return mid elif sensor_data[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Deep Copy of a Linked List with Random Pointers You are given a linked list where each node contains an additional random pointer that could point to any node in the list or `null`. Your task is to create a deep copy of the linked list. Function Signature ```python class RandomListNode(object): def __init__(self, label): self.label = label self.next = None self.random = None def deep_copy_linked_list(head: RandomListNode) -> RandomListNode: pass ``` Input - `head`: The head of the linked list. Output - Returns the head of the deep-copied linked list. Constraints - The number of nodes in the linked list is in the range `[0, 1000]`. - The values of the node\'s label are within the range `[1, 10^6]`. Examples and Explanations Example 1: ``` Input: head -> [label: 1, next: 2, random: 2] -> [label: 2, next: None, random: None] Output: new_head -> [label: 1, next: 2, random: 2] -> [label: 2, next: None, random: None] ``` Example 2: ``` Input: head -> [label: 1, next: None, random: 1] Output: new_head -> [label: 1, next: None, random: 1] ``` Scenario Consider a case where you have a doubly linked list representing a series of commands in a command-line program. Each node has a `random` pointer referring to an earlier state in the execution history. You need to clone this history for a snapshot restoration functionality, ensuring no state is inadvertently altered when moving back and forth through the original list. Implement the `deep_copy_linked_list` function such that it takes the head of the original linked list and returns the head of its deep copy. Ensure to handle all edge cases properly.","solution":"class RandomListNode: def __init__(self, label): self.label = label self.next = None self.random = None def deep_copy_linked_list(head: RandomListNode) -> RandomListNode: if not head: return None # Step 1: Create a new node for each original node and insert it right after the original node current = head while current: new_node = RandomListNode(current.label) new_node.next = current.next current.next = new_node current = new_node.next # Step 2: Assign the random pointers for the newly created nodes current = head while current: if current.random: current.next.random = current.random.next current = current.next.next # Step 3: Separate the original list and the deep copied list current = head new_head = current.next while current: new_node = current.next current.next = new_node.next if new_node.next: new_node.next = new_node.next.next current = current.next return new_head"},{"question":"# Question You are developing a fitness application and need to determine the number of distinct ways users can reach their step goals. Each time, users can either climb 1 or 2 steps. Given a step goal, you need to provide the number of distinct ways to achieve that goal using dynamic programming. Function Signature ```python def distinct_step_ways(steps: int) -> int: :param steps: an integer representing the step goal (steps > 0) :return: an integer, the number of distinct ways to climb to the given step goal pass ``` # Input and Output Input - One integer, `steps` (1 ≤ steps ≤ 10^5), representing the target number of steps. Output - Return an integer representing the number of distinct ways to reach the given step goal. # Constraints - Your solution should have a time complexity of O(n). - Optimize for space complexity where possible. - It is guaranteed that the input will be a positive integer. # Example ```python print(distinct_step_ways(2)) # Output: 2 print(distinct_step_ways(3)) # Output: 3 print(distinct_step_ways(4)) # Output: 5 ``` # Context Imagine you are tasked with implementing a core function for your fitness app\'s step counter feature. This function helps users see how they can break down their target step goal into smaller, achievable segments. Your implementation needs to be both efficient and scalable to handle very high step targets typical in fitness routines.","solution":"def distinct_step_ways(steps: int) -> int: if steps == 1: return 1 if steps == 2: return 2 prev2, prev1 = 1, 2 for i in range(3, steps + 1): current = prev1 + prev2 prev2 = prev1 prev1 = current return prev1"},{"question":"Enhanced Counting Sort You are given an integer array, which can contain negative numbers, positive numbers, and zero. Implement an enhanced version of the Counting Sort algorithm that can efficiently sort the given array. # Instructions: 1. **Function Signature**: ```python def enhanced_counting_sort(arr: List[int]) -> List[int]: ``` 2. **Input**: - An integer list (arr) containing (n) elements ((-10^6 leq arr[i] leq 10^6)). 3. **Output**: - Return a list of integers sorted in non-decreasing order. 4. **Constraints**: - The array size (1 leq n leq 10^6). - The array must be handled even if it includes a mix of positive and negative integers. 5. **Performance Requirements**: - The algorithm should run in (O(n + k)) time, where (k) is the range of input values. 6. **Example**: ```python assert enhanced_counting_sort([4, 2, -1, 6, -3, 2, 0]) == [-3, -1, 0, 2, 2, 4, 6] assert enhanced_counting_sort([1, 2, 3, -1, -2, -3, 0]) == [-3, -2, -1, 0, 1, 2, 3] ``` # Requirements: 1. Address handling of negative numbers and ensure the integrity of the sorting operation. 2. Optimize for minimal extra space usage while preserving the array\'s stability. 3. Consider all typical edge cases including empty arrays, arrays with one element, and arrays with uniformly repeated elements.","solution":"def enhanced_counting_sort(arr): Sorts an input array containing positive, negative, and zero values using the Counting Sort algorithm. if not arr: return arr max_elem = max(arr) min_elem = min(arr) range_of_elements = max_elem - min_elem + 1 # Initialize the count array with zeros count_array = [0] * range_of_elements # Store the count of each element in the count array for num in arr: count_array[num - min_elem] += 1 # Build the output sorted array sorted_arr = [] for i in range(range_of_elements): count = count_array[i] sorted_arr.extend([i + min_elem] * count) return sorted_arr"},{"question":"# Problem: Custom List of Strings Encoder/Decoder You are tasked with designing an encoding and decoding mechanism for a list of strings. Specifically, you need to implement two functions: `encode` and `decode`. Your solution should allow for correctly encoding a list of strings into a single string and then decoding it back to the original list. # Function Signatures ```python def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. :type strs: List[str] :rtype: str def decode(s: str) -> List[str]: Decodes a single string to a list of strings. :type s: str :rtype: List[str] ``` # Input For the `encode` function: - `strs` is a list of strings, where each string consists of lower and uppercase English letters and special characters. - The length of each string is between 0 and 1000. - The total length of all strings combined will not exceed 10000. For the `decode` function: - `s` is a single string that represents the encoded version of the list of strings. # Output For the `encode` function: - Return a single string `res` that is the encoded form of the input list of strings. For the `decode` function: - Return a list of strings that were encoded in the input string `s`. # Constraints - Your solution should handle edge cases such as empty strings or an empty list (`[]`). - Consider any possible delimiters that might appear within the strings and encode them safely. # Examples ```python # Example usage: strs = [\\"hello\\", \\"world\\"] encoded_string = encode(strs) print(encoded_string) # Example output: \\"5:hello5:world\\" decoded_list = decode(encoded_string) print(decoded_list) # Example output: [\\"hello\\", \\"world\\"] # Edge case: empty_list = [] encoded_empty_list = encode(empty_list) print(encoded_empty_list) # Example output: \\"\\" decoded_empty_list = decode(encoded_empty_list) print(decoded_empty_list) # Example output: [] ``` # Notes 1. The encoding should be robust enough to handle special characters and numbers within the strings. 2. Consider performance aspects if the list of strings is large. 3. Ensure that decoding correctly mirrors the encoding process, restoring the original list of strings without any loss of information.","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. encoded_str = \\"\\" for s in strs: encoded_str += f\\"{len(s)}:{s}\\" return encoded_str def decode(s: str) -> List[str]: Decodes a single string to a list of strings. strs = [] i = 0 while i < len(s): j = i while s[j] != \':\': j += 1 length = int(s[i:j]) strs.append(s[j+1:j+1+length]) i = j+1+length return strs"},{"question":"# Regular Expression Matching with Support for \'.\' and \'*\' Question You need to implement a function `bool is_match(const char *s, const char *p)` that checks if a given input string `s` matches a given pattern `p`. The pattern could include the special characters: - `.` which matches any single character. - `*` which matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Expected Input and Output * **Input**: - `s`: a string (1 ≤ len(s) ≤ 100) - `p`: a pattern string (1 ≤ len(p) ≤ 100) * **Output**: - Returns a boolean `True` if the string matches the given pattern, otherwise returns `False`. Constraints * The pattern `p` will not contain empty characters. * The pattern `p` can only contain lowercase letters, \'.\', and \'*\'. Examples ```python assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"aa\\", \\"aa\\") == True assert is_match(\\"aaa\\", \\"aa\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"aa\\", \\".*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True ``` Instructions 1. Implement the function `is_match(s, p)`. 2. Use dynamic programming to build a solution. 3. You should consider the following scenarios when writing your algorithm: - Empty string against pattern. - Patterns that include \'.\' and \'*\'. - Consecutive \'*\' in the pattern. **Notes**: - Include comments to explain your logic and steps. - Handle edge cases efficiently. Good luck!","solution":"def is_match(s, p): Returns True if the string s matches the pattern p, otherwise False. The pattern can include \'.\' which matches any single character and \'*\' which matches zero or more of the preceding element. # DP table where dp[i][j] will be True if the first i characters in s # matches the first j characters in p dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] # An empty string matches an empty pattern dp[0][0] = True # Handle patterns like a*, a*b*, a*b*c* etc. for j in range(2, len(p) + 1): if p[j-1] == \'*\': dp[0][j] = dp[0][j-2] for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j-1] == s[i-1] or p[j-1] == \'.\': dp[i][j] = dp[i-1][j-1] elif p[j-1] == \'*\': dp[i][j] = dp[i][j-2] # Zero occurrence of the character before \'*\' if p[j-2] == s[i-1] or p[j-2] == \'.\': dp[i][j] |= dp[i-1][j] # One or more occurrences of the character before \'*\' return dp[-1][-1]"},{"question":"You are required to implement a function named `optimized_exchange_sort` that improves upon the traditional Exchange Sort algorithm by attempting to reduce unnecessary comparisons and swaps whenever possible. The improved sorting algorithm should still sort the array in place but aim to break early if it identifies that the list is already sorted during any pass through. # Function Signature ```python def optimized_exchange_sort(arr: List[int]) -> List[int]: ``` # Input - A list of integers `arr` with a maximum length of 1000. # Output - Return the sorted list `arr` in ascending order. # Constraints - The implementation must sort the array in place; no additional data structures should be used outside of fundamental variables. - The array elements are integers between -10^6 and 10^6. - The algorithm should aim to minimize the number of comparisons, especially for almost sorted arrays. # Example ```python assert optimized_exchange_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90] assert optimized_exchange_sort([3, 5, 7, 8, 9, 2, 1, 6, 4, 0]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] assert optimized_exchange_sort([1, 1, 1, 1, 1]) == [1, 1, 1, 1, 1] assert optimized_exchange_sort([]) == [] ``` # Requirements - Ensure that the optimized algorithm performs fewer comparisons on nearly sorted arrays. - Analyze and document the performance gain over the traditional Exchange Sort method, if any.","solution":"def optimized_exchange_sort(arr): Sorts the given list of integers using an optimized version of the exchange sort algorithm. The optimization includes breaking early if the list is already sorted during any pass. n = len(arr) for i in range(n): swapped = False for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True if not swapped: break return arr"},{"question":"# Segment Tree for Range Minimum Query You are tasked to implement a Segment Tree to handle a series of range minimum query (RMQ) operations and updates on an array. Problem Statement Given an array of integers, implement a Segment Tree that supports the following operations efficiently: 1. **Query the minimum value in a given range [l, r]**. 2. **Update the value at a specific index**. Function Specifications ***Constructor***: - `SegmentTree(arr: List[int])`: Construct the segment tree from the given list `arr`. ***Methods***: - `update(index: int, value: int)`: Update the element at index `index` to `value`. - `query(l: int, r: int) -> int`: Returns the minimum value in the range `[l, r]` (both inclusive). Input - The input consists of: - `arr`: A list of integers to initialize the segment tree (1 ≤ length of `arr` ≤ 10^5, -10^9 ≤ arr[i] ≤ 10^9). - `update(index: int, value: int)`: An index (0-based) and the new value to update at that index. - `query(l: int, r: int)`: Two integers `l` and `r` as the range for the query (0 ≤ l ≤ r < length of `arr`). Output - `query(l: int, r: int)`: Return an integer which is the minimum value in the range `[l, r]`. Example ```python # Create segment tree from array seg_tree = SegmentTree([2, 4, 5, 3, 4]) # Query minimum value from index 1 to 3 print(seg_tree.query(1, 3)) # Output: 3 # Update index 2 to have value 1 seg_tree.update(2, 1) # Query minimum value again from index 1 to 3 after the update print(seg_tree.query(1, 3)) # Output: 1 ``` Constraints - You need to ensure that both `query` and `update` operations are performed in O(log N) time complexity. **Note**: Do not use any built-in libraries for range queries or segment trees. Write the segment tree logic from scratch.","solution":"class SegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (2 * self.n) # Create segment tree by inserting leaf nodes in tree, then updating parent nodes. for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, index, value): # Set value at position p index += self.n self.tree[index] = value # Update the ancestors of the node i = index while i > 1: self.tree[i // 2] = min(self.tree[i], self.tree[i ^ 1]) i //= 2 def query(self, l, r): # Get the minimum value in the range [l, r) l += self.n r += self.n + 1 res = float(\'inf\') while l < r: if l % 2 == 1: res = min(res, self.tree[l]) l += 1 if r % 2 == 1: r -= 1 res = min(res, self.tree[r]) l //= 2 r //= 2 return res"},{"question":"Prim\'s MST Implementation Context You work as a network engineer, tasked with designing an optimal local area network (LAN) for an office. To minimize costs, you need to ensure that the network uses the least amount of cable while still ensuring all computers are connected. Given the points of connection and the cable lengths between them, your task is to find the minimum total length of cable required. Problem Statement Implement a function `prims_minimum_spanning(graph_used: dict) -> int` that computes the weight of the Minimum Spanning Tree (MST) of a given undirected, connected graph using Prim\'s algorithm. Input and Output Formats * **Input**: - A dictionary `graph_used` where keys are nodes represented as strings or integers, and values are lists of lists. Each inner list contains two elements: an integer representing the weight of the edge and the adjacent node. * **Output**: - A single integer representing the minimal total weight of all edges in the MST. Constraints * The graph is connected, and no node will be isolated. * Weights are non-negative integers. * There can be multiple edges between two nodes with different weights. * Node labels and edge weights fit standard integer ranges. Performance Requirements * Your algorithm should efficiently handle graphs with up to `10^4` nodes and `10^5` edges. Function Signature ```python def prims_minimum_spanning(graph_used: dict) -> int: # Your implementation here ``` Example ```python graph = { \'1\': [ [3, \'2\'], [8,\'3\'] ], \'2\': [ [3, \'1\'], [5, \'4\'] ], \'3\': [ [8, \'1\'], [2, \'4\'], [4, \'5\'] ], \'4\': [ [5, \'2\'], [2, \'3\'], [6, \'5\'] ], \'5\': [ [4, \'3\'], [6, \'4\'] ] } assert prims_minimum_spanning(graph) == 14 ```","solution":"import heapq def prims_minimum_spanning(graph_used: dict) -> int: Compute the weight of the Minimum Spanning Tree using Prim\'s algorithm. :param graph_used: dict, where keys are nodes and values are lists of [weight, adjacent_node] :return: int, the minimal total weight of all edges in the MST # Starting with any node, for simplicity let\'s start with the first key in the dictionary start_node = list(graph_used.keys())[0] # Initialize a priority queue and add first node to it with 0 cost pq = [(0, start_node)] total_weight = 0 visited = set() while pq: cost, node = heapq.heappop(pq) if node in visited: continue # Add node to visited visited.add(node) total_weight += cost # Add all edges from this node to the priority queue if the adjacent node is not visited for weight, adj_node in graph_used[node]: if adj_node not in visited: heapq.heappush(pq, (weight, adj_node)) return total_weight"},{"question":"# Coding Assignment: Implement Cycle Sort with Improvements and Custom Conditions Scenario You are working on firmware for a device that has non-volatile memory with a limited number of write cycles. You need to sort an array of integers to optimize certain operations but must minimize the number of writes to the memory due to its limitations. Hence, you decided to use Cycle Sort due to its minimal write characteristic. Objective Implement the Cycle Sort algorithm with additional handling for custom conditions and edge cases. Instructions * Implement a function `cycle_sort_custom` that sorts an array of integers in non-decreasing order. * Minimize the number of memory writes in the process. * Handle the following custom conditions: * If the array is empty, return an appropriately empty array. * If the array contains only identical elements, it should be returned as is. * Implement a flag parameter `allow_duplicates`: * If `allow_duplicates` is True, your function should handle arrays with duplicate elements. * If `allow_duplicates` is False, your function should raise an exception when encountering duplicate elements in the array. Function Signature ```python def cycle_sort_custom(arr: List[int], allow_duplicates: bool) -> List[int]: pass ``` Constraints * Input array elements are integers. * The input array can contain positive or negative integers. * Array length can be between 0 and 10^4. Example ```python arr = [3, 1, 4, 1, 5] sorted_arr = cycle_sort_custom(arr, allow_duplicates=True) print(sorted_arr) # Output: [1, 1, 3, 4, 5] arr = [3, 1, 4, 1, 5] try: sorted_arr = cycle_sort_custom(arr, allow_duplicates=False) except ValueError as e: print(e) # Output: \\"Duplicate elements are not allowed in the input array.\\" ```","solution":"def cycle_sort_custom(arr, allow_duplicates): Sorts the array using Cycle Sort with custom conditions: - If the array is empty, return it. - If the array contains only identical elements, return it. - Handle duplicates based on the allow_duplicates flag. if not arr: return arr def contains_duplicates(arr): seen = set() for num in arr: if num in seen: return True seen.add(num) return False if not allow_duplicates and contains_duplicates(arr): raise ValueError(\\"Duplicate elements are not allowed in the input array.\\") # Cycle sort implementation n = len(arr) writes = 0 for cycleStart in range(n - 1): item = arr[cycleStart] pos = cycleStart for i in range(cycleStart + 1, n): if arr[i] < item: pos += 1 if pos == cycleStart: continue while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 while pos != cycleStart: pos = cycleStart for i in range(cycleStart + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"Given the functions to convert integers to byte sequences (both big-endian and little-endian) and vice versa, write a new function that verifies if the conversions are performed correctly. The function `verify_conversion` should take an integer `num` and check that converting it to bytes and back to an integer yields the same value for both endian formats. # Function Signature ```python def verify_conversion(num: int) -> bool: ``` # Input - `num` (int): A non-negative integer. Assume `0 <= num < 2**64`. # Output - `bool`: `True` if the integer conversions and reversals are correct for both endian formats, `False` otherwise. # Constraints - The integer provided will be non-negative and within the 64-bit range. - You may not use any external library functions for integer-to-byte conversion. # Example ```python print(verify_conversion(1)) # Output: True print(verify_conversion(256)) # Output: True print(verify_conversion(1024)) # Output: True print(verify_conversion(0)) # Output: True print(verify_conversion(2**64-1)) # Output: True ``` # Additional Information - Consider any edge cases, such as the smallest (0) and largest possible (2<sup>64</sup>-1) integers. - Ensure the performance is optimal within the provided constraints.","solution":"def int_to_bytes_big_endian(num: int) -> bytes: return num.to_bytes((num.bit_length() + 7) // 8, byteorder=\'big\') def int_to_bytes_little_endian(num: int) -> bytes: return num.to_bytes((num.bit_length() + 7) // 8, byteorder=\'little\') def bytes_to_int_big_endian(b: bytes) -> int: return int.from_bytes(b, byteorder=\'big\') def bytes_to_int_little_endian(b: bytes) -> int: return int.from_bytes(b, byteorder=\'little\') def verify_conversion(num: int) -> bool: big_endian_bytes = int_to_bytes_big_endian(num) little_endian_bytes = int_to_bytes_little_endian(num) # Convert back to integer big_endian_result = bytes_to_int_big_endian(big_endian_bytes) little_endian_result = bytes_to_int_little_endian(little_endian_bytes) # Verify both conversions match the original integer return big_endian_result == num and little_endian_result == num"},{"question":"# Question You are given a connected, undirected graph represented as an adjacency list. Write a function to find all connected components in the graph using both Depth-First Search (DFS) and Breadth-First Search (BFS). Your solution should demonstrate understanding and implementation of both traversal methods. Your task is to implement two functions: 1. `connected_components_dfs(graph)` - which uses DFS to find the connected components. 2. `connected_components_bfs(graph)` - which uses BFS to find the connected components. # Input - `graph`: A dictionary where the keys are node labels and the values are lists of neighboring nodes. # Output - Each function should return a list of sets, where each set contains all the nodes in a connected component. # Assumptions and Constraints - All nodes in the graph will be represented as integers. - The graph is undirected and connected. - Node labels are non-negative integers. # Example ```python graph = { 0: [1, 2], 1: [0, 3], 2: [0], 3: [1], 4: [5], 5: [4] } print(connected_components_dfs(graph)) # Output: [{0, 1, 2, 3}, {4, 5}] print(connected_components_bfs(graph)) # Output: [{0, 1, 2, 3}, {4, 5}] ``` # Constraints - Your solution should handle graphs with up to (10^5) nodes and (10^6) edges in an efficient manner. - Each function should run in (O(V + E)) time complexity, where V is the number of vertices and E is the number of edges.","solution":"def connected_components_dfs(graph): Returns a list of sets, where each set contains all the nodes in a connected component using DFS. visited = set() components = [] def dfs(node, component): stack = [node] while stack: cur = stack.pop() if cur not in visited: visited.add(cur) component.add(cur) for neighbor in graph.get(cur, []): if neighbor not in visited: stack.append(neighbor) for node in graph: if node not in visited: component = set() dfs(node, component) components.append(component) return components def connected_components_bfs(graph): Returns a list of sets, where each set contains all the nodes in a connected component using BFS. visited = set() components = [] def bfs(start, component): queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.add(node) component.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: queue.append(neighbor) for node in graph: if node not in visited: component = set() bfs(node, component) components.append(component) return components"},{"question":"# Context: You are working as a developer for a text processing company that specializes in detecting common subsequences in large corpora of documents. Your task is to create an efficient function that finds the longest common substring between two texts, where the second text is guaranteed to contain only unique characters. # Objective: Write a function `max_common_sub_string` that takes two strings `s1` and `s2`. The function should return the longest common substring between `s1` and `s2`. You are guaranteed that `s2` contains all distinct characters. # Function Signature: ```python def max_common_sub_string(s1: str, s2: str) -> str: pass ``` # Input: - `s1` (string): The first text from which to find the substring. - `s2` (string): The second text containing all unique characters. # Output: - A string representing the longest common substring found in both `s1` and `s2`. # Constraints: - The length of `s1` and `s2` will not exceed 10^5. - `s2` contains all unique characters. # Example: ```python assert max_common_sub_string(\\"abcde\\", \\"ace\\") == \\"a\\" assert max_common_sub_string(\\"abcdef\\", \\"fycdez\\") == \\"cde\\" assert max_common_sub_string(\\"xyzabcd\\", \\"yzqwert\\") == \\"yz\\" ``` # Notes: - If there are multiple longest common substrings of the same length, return any one of them. - Optimize your solution to achieve a time complexity of O(n log n) and a space complexity of O(n).","solution":"def max_common_sub_string(s1: str, s2: str) -> str: Finds the longest common substring between s1 and s2, where s2 contains unique characters. n1, n2 = len(s1), len(s2) result = \\"\\" # Processing using a sliding window and hashing for optimization s2_chars = set(s2) max_len = 0 dp = [[0] * (n2 + 1) for _ in range(n1 + 1)] for i in range(1, n1 + 1): for j in range(1, n2 + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 if dp[i][j] > max_len: max_len = dp[i][j] result = s1[i - max_len: i] else: dp[i][j] = 0 return result"},{"question":"# Minimum Spanning Tree using Kruskal’s Algorithm You are given a connected, undirected graph represented by `n` vertices and `m` edges. Your task is to implement a function that computes the sum of weights of the edges in the Minimum Spanning Tree (MST) using Kruskal’s algorithm. Expected Input The input consists of multiple test cases. Each test case starts with two integers: - `n` (1 ≤ n ≤ 10^5): the number of vertices. - `m` (1 ≤ m ≤ 10^5): the number of edges. Each of the next `m` lines contains three integers: - `u` and `v` (1 ≤ u, v ≤ n): the vertices connected by the edge. - `w` (1 ≤ w ≤ 10^6): the weight of the edge. The vertices are 1-indexed. Expected Output For each test case, output a single integer representing the sum of edge weights in the MST. Constraints * The graph is connected, meaning there is at least one path between any two vertices. * The input has multiple test cases terminated by EOF. Performance Requirements * Your solution should efficiently handle the upper limits of the constraints. Example Input: ``` 5 6 1 2 3 1 3 8 2 4 5 3 4 2 3 5 4 4 5 6 3 3 2 1 20 3 1 20 2 3 100 ``` Output: ``` 14 40 ``` Implementation Use the following class structure to implement the solution: ```python class Edge: def __init__(self, source, target, weight): self.source = source self.target = target self.weight = weight class DisjointSet: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size def find(self, node): if self.parent[node] != node: self.parent[node] = self.find(self.parent[node]) return self.parent[node] def union(self, node1, node2): root1 = self.find(node1) root2 = self.find(node2) if root1 != root2: if self.rank[root1] > self.rank[root2]: self.parent[root2] = root1 elif self.rank[root1] < self.rank[root2]: self.parent[root1] = root2 else: self.parent[root2] = root1 self.rank[root1] += 1 def kruskal(n, edges): edges.sort(key=lambda edge: edge.weight) ds = DisjointSet(n) mst_weight_sum = 0 for edge in edges: if ds.find(edge.source) != ds.find(edge.target): ds.union(edge.source, edge.target) mst_weight_sum += edge.weight return mst_weight_sum def main(): import sys input = sys.stdin.read data = input().strip().split() index = 0 results = [] while index < len(data): n = int(data[index]) m = int(data[index+1]) index += 2 edges = [] for _ in range(m): u = int(data[index]) - 1 v = int(data[index+1]) - 1 w = int(data[index+2]) edges.append(Edge(u, v, w)) index += 3 result = kruskal(n, edges) results.append(result) for result in results: print(result) if __name__ == \\"__main__\\": main() ```","solution":"class Edge: def __init__(self, source, target, weight): self.source = source self.target = target self.weight = weight class DisjointSet: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size def find(self, node): if self.parent[node] != node: self.parent[node] = self.find(self.parent[node]) return self.parent[node] def union(self, node1, node2): root1 = self.find(node1) root2 = self.find(node2) if root1 != root2: if self.rank[root1] > self.rank[root2]: self.parent[root2] = root1 elif self.rank[root1] < self.rank[root2]: self.parent[root1] = root2 else: self.parent[root2] = root1 self.rank[root1] += 1 def kruskal(n, edges): edges.sort(key=lambda edge: edge.weight) ds = DisjointSet(n) mst_weight_sum = 0 for edge in edges: if ds.find(edge.source) != ds.find(edge.target): ds.union(edge.source, edge.target) mst_weight_sum += edge.weight return mst_weight_sum def process_input(input_str): data = input_str.strip().split() index = 0 results = [] while index < len(data): n = int(data[index]) m = int(data[index + 1]) index += 2 edges = [] for _ in range(m): u = int(data[index]) - 1 v = int(data[index + 1]) - 1 w = int(data[index + 2]) edges.append(Edge(u, v, w)) index += 3 result = kruskal(n, edges) results.append(result) return results"},{"question":"# Question: Implementing the Atbash Cipher Given a string `s`, implement the Atbash cipher algorithm that encrypts (`encodes`) the message by mapping each alphabetical character to its reverse counterpart in the alphabet. Non-alphabetical characters should be left unchanged. Write a function `atbash_cipher` that performs this encryption. **Function signature:** ```python def atbash_cipher(s: str) -> str: pass ``` # Input: * A single string `s` where `0 <= len(s) <= 10^6`. The string can contain upper and lower case alphabets, digits, and special characters. # Output: * A single string that is the Atbash cipher of the input string `s`. # Examples: 1. `Input`: \\"Attack at dawn\\" `Output`: \\"Zggzxp zg wzdm\\" 2. `Input`: \\"Hello, World!\\" `Output`: \\"Svool, Dliow!\\" 3. `Input`: \\"12345\\" `Output`: \\"12345\\" (unchanged since there are no alphabetic characters) # Constraints: * Your solution must handle up to 1 million characters efficiently. * Ensure the function remains case-sensitive and treats upper and lower case letters distinctly. * Maintain all non-alphabet characters unmodified in the resulting string. **Scenario**: Imagine you are sending coded messages to your friends and you decide to use the Atbash cipher as your method of keeping your conversations private. Implement the function `atbash_cipher` to automatically encode your messages.","solution":"def atbash_cipher(s: str) -> str: def atbash_char(c): if \'a\' <= c <= \'z\': return chr(219 - ord(c)) # 219 = \'a\' + \'z\' elif \'A\' <= c <= \'Z\': return chr(155 - ord(c)) # 155 = \'A\' + \'Z\' else: return c return \'\'.join(atbash_char(c) for c in s)"},{"question":"Context You are working on designing a minimalistic robot controller that moves based on strings of commands it receives. The robot has a deterministic finite set of states, and the commands dictate state transitions. Your task is to determine if a given string of commands is valid based on the robot\'s state transitions, initial state, and acceptable final states. Task Write a function `validateCommands(transitions, start, final, commands)` that determines whether a given string of commands is accepted by the robot. 1. **Function Signature**: ```python def validateCommands(transitions: dict, start: str, final: list, commands: str) -> bool: ``` 2. **Input**: * `transitions` (dict): A dictionary where keys are current states, and values are dictionaries mapping commands (characters) to next states. * `start` (str): The initial state of the DFA (the robot\'s starting position). * `final` (list): List of acceptable final states. * `commands` (str): The string of commands to process. 3. **Output**: * Return `True` if the string of commands is accepted, `False` otherwise. 4. **Constraints**: * All states are strings. * All commands are single characters. * The input string will only contain valid characters present in the transitions dictionary. Example ```python # Example transitions dictionary transitions = { \'A\': {\'0\': \'B\', \'1\': \'C\'}, \'B\': {\'0\': \'A\', \'1\': \'D\'}, \'C\': {\'0\': \'D\', \'1\': \'A\'}, \'D\': {\'0\': \'C\', \'1\': \'B\'} } # Example input start = \'A\' final = [\'D\'] # Commands string commands = \\"011\\" # Call the function print(validateCommands(transitions, start, final, commands)) # Output: True # Explanation: # \'A\' -> \'C\' (1) -> \'D\' (1) -> \'B\' (0) is \'B\', which is not a final state. # \'A\' -> \'B\' (0) -> \'D\' (1) -> \'B\' (1) is \'B\', which is not a final state. # \'A\' -> \'B\' (0) -> \'D\' (1) is \'D\', which is a final state. ``` Ensure your implementation handles various edge cases, including empty command strings, invalid transitions, and verifying correctness against provided conditions.","solution":"def validateCommands(transitions, start, final, commands): Determines whether a given string of commands is accepted by the robot. Parameters: transitions (dict): State transition mapping. start (str): Initial state. final (list): List of acceptable final states. commands (str): String of commands to process. Returns: bool: True if the string of commands is accepted, False otherwise. current_state = start for command in commands: if command in transitions[current_state]: current_state = transitions[current_state][command] else: return False return current_state in final"},{"question":"# Scenario You have been hired as a software developer for a company that manages a large database of customer details. Ensuring that operations on this database are consistently fast is a critical requirement. You have decided to use a Red-Black Tree to store the customer IDs, ensuring efficient insertion, deletion, and search operations. Your job is to implement a function that can efficiently manage the IDs using a Red-Black Tree by inserting, deleting, and retrieving an ordered list of IDs. # Problem Statement Implement an efficient Red-Black Tree that supports the following operations: 1. Insert a new ID. 2. Delete an existing ID. 3. Retrieve a list of IDs in ascending order. # Function Signature ```python class RBTree: def __init__(self): self.root = None def insert_id(self, customer_id: int) -> None: Insert a new customer ID into the Red-Black Tree. :param customer_id: int :return: None pass def delete_id(self, customer_id: int) -> None: Delete an existing customer ID from the Red-Black Tree. :param customer_id: int :return: None pass def get_sorted_ids(self) -> list: Retrieve a list of customer IDs in ascending order. :return: List[int] pass ``` # Constraints * The customer ID will be a positive integer. * The number of operations (`insert_id` and `delete_id`) will be at most 10^4. # Example ```python # Create an instance of RBTree rb_tree = RBTree() # Insert customer IDs rb_tree.insert_id(5) rb_tree.insert_id(3) rb_tree.insert_id(7) rb_tree.insert_id(1) # Retrieve sorted IDs sorted_ids = rb_tree.get_sorted_ids() print(sorted_ids) # Output: [1, 3, 5, 7] # Delete a customer ID rb_tree.delete_id(3) # Retrieve sorted IDs after deletion sorted_ids = rb_tree.get_sorted_ids() print(sorted_ids) # Output: [1, 5, 7] ``` # Requirements 1. Ensure that the Red-Black Tree remains balanced after each insertion and deletion. 2. Efficiently handle edge cases such as inserting duplicate values and deleting non-existent nodes.","solution":"class Node: def __init__(self, data, color=\\"red\\"): self.data = data self.color = color # Nodes are red or black. self.left = None self.right = None self.parent = None class RBTree: def __init__(self): self.NIL_LEAF = Node(data=None, color=\\"black\\") # Sentinel NIL_LEAF node (used as leaves) self.root = self.NIL_LEAF def insert_id(self, customer_id: int) -> None: Insert a new customer ID into the Red-Black Tree. :param customer_id: int :return: None new_node = Node(customer_id) new_node.left = self.NIL_LEAF new_node.right = self.NIL_LEAF self._insert_node(new_node) self._fix_insert(new_node) def _insert_node(self, node): if self.root == self.NIL_LEAF: self.root = node self.root.color = \\"black\\" self.root.parent = None return current = self.root while current != self.NIL_LEAF: parent = current if node.data < current.data: current = current.left else: current = current.right node.parent = parent if node.data < parent.data: parent.left = node else: parent.right = node def _fix_insert(self, node): while node != self.root and node.parent.color == \\"red\\": if node.parent == node.parent.parent.left: uncle = node.parent.parent.right if uncle.color == \\"red\\": node.parent.color = \\"black\\" uncle.color = \\"black\\" node.parent.parent.color = \\"red\\" node = node.parent.parent else: if node == node.parent.right: node = node.parent self._rotate_left(node) node.parent.color = \\"black\\" node.parent.parent.color = \\"red\\" self._rotate_right(node.parent.parent) else: uncle = node.parent.parent.left if uncle.color == \\"red\\": node.parent.color = \\"black\\" uncle.color = \\"black\\" node.parent.parent.color = \\"red\\" node = node.parent.parent else: if node == node.parent.left: node = node.parent self._rotate_right(node) node.parent.color = \\"black\\" node.parent.parent.color = \\"red\\" self._rotate_left(node.parent.parent) self.root.color = \\"black\\" def _rotate_left(self, node): r = node.right node.right = r.left if r.left != self.NIL_LEAF: r.left.parent = node r.parent = node.parent if node.parent is None: self.root = r elif node == node.parent.left: node.parent.left = r else: node.parent.right = r r.left = node node.parent = r def _rotate_right(self, node): l = node.left node.left = l.right if l.right != self.NIL_LEAF: l.right.parent = node l.parent = node.parent if node.parent is None: self.root = l elif node == node.parent.right: node.parent.right = l else: node.parent.left = l l.right = node node.parent = l def delete_id(self, customer_id: int) -> None: Delete an existing customer ID from the Red-Black Tree. :param customer_id: int :return: None self._delete_node(self.root, customer_id) def _delete_node(self, node, key): z = self.NIL_LEAF while node != self.NIL_LEAF: if node.data == key: z = node if node.data <= key: node = node.right else: node = node.left if z == self.NIL_LEAF: return y = z y_original_color = y.color if z.left == self.NIL_LEAF: x = z.right self._rb_transplant(z, z.right) elif z.right == self.NIL_LEAF: x = z.left self._rb_transplant(z, z.left) else: y = self._minimum(z.right) y_original_color = y.color x = y.right if y.parent == z: x.parent = y else: self._rb_transplant(y, y.right) y.right = z.right y.right.parent = y self._rb_transplant(z, y) y.left = z.left y.left.parent = y y.color = z.color if y_original_color == \\"black\\": self._fix_delete(x) def _rb_transplant(self, u, v): if u.parent is None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def _minimum(self, node): while node.left != self.NIL_LEAF: node = node.left return node def _fix_delete(self, x): while x != self.root and x.color == \\"black\\": if x == x.parent.left: sibling = x.parent.right if sibling.color == \\"red\\": sibling.color = \\"black\\" x.parent.color = \\"red\\" self._rotate_left(x.parent) sibling = x.parent.right if sibling.left.color == \\"black\\" and sibling.right.color == \\"black\\": sibling.color = \\"red\\" x = x.parent else: if sibling.right.color == \\"black\\": sibling.left.color = \\"black\\" sibling.color = \\"red\\" self._rotate_right(sibling) sibling = x.parent.right sibling.color = x.parent.color x.parent.color = \\"black\\" sibling.right.color = \\"black\\" self._rotate_left(x.parent) x = self.root else: sibling = x.parent.left if sibling.color == \\"red\\": sibling.color = \\"black\\" x.parent.color = \\"red\\" self._rotate_right(x.parent) sibling = x.parent.left if sibling.left.color == \\"black\\" and sibling.right.color == \\"black\\": sibling.color = \\"red\\" x = x.parent else: if sibling.left.color == \\"black\\": sibling.right.color = \\"black\\" sibling.color = \\"red\\" self._rotate_left(sibling) sibling = x.parent.left sibling.color = x.parent.color x.parent.color = \\"black\\" sibling.left.color = \\"black\\" self._rotate_right(x.parent) x = self.root x.color = \\"black\\" def get_sorted_ids(self) -> list: Retrieve a list of customer IDs in ascending order. :return: List[int] res = [] self._inorder_helper(self.root, res) return res def _inorder_helper(self, node, res): if node != self.NIL_LEAF: self._inorder_helper(node.left, res) res.append(node.data) self._inorder_helper(node.right, res)"},{"question":"**Context**: You are given a list of sorted lowercase letters and a target lowercase letter. Your task is to write a function that finds the smallest element in the list that is greater than the given target letter. If no such element exists because the list wraps around, return the first character of the list. # Function Signature ```python def find_next_letter(letters: List[str], target: str) -> str: ``` # Input * `letters` (List[str]): A list of sorted lowercase letters. * `target` (str): A single lowercase letter. # Output * `str`: The smallest letter in the list that is greater than the target letter. # Constraints * The list `letters` is guaranteed to be non-empty and sorted in non-decreasing order. * The list `letters` will have at most 10^4 characters. * Letters wrap around. For example, if the target is \'z\' and letters = [\'a\', \'b\'], the answer is \'a\'. # Example ```python # Example 1 letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"a\\" print(find_next_letter(letters, target)) # Output: \\"c\\" # Example 2 letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"c\\" print(find_next_letter(letters, target)) # Output: \\"f\\" # Example 3 letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"d\\" print(find_next_letter(letters, target)) # Output: \\"f\\" # Example 4 letters = [\\"e\\", \\"e\\", \\"e\\", \\"m\\", \\"q\\", \\"q\\"] target = \\"e\\" print(find_next_letter(letters, target)) # Output: \\"m\\" ``` # Explanation * In Example 1, the smallest character greater than \'a\' is \'c\'. * In Example 2, the smallest character greater than \'c\' is \'f\'. * In Example 3, the smallest character greater than \'d\' is \'f\'. * In Example 4, despite multiple occurrences of \'e\', the smallest character greater than \'e\' is \'m\'. Implement the function so that it efficiently handles large inputs, considering edge cases and performance constraints.","solution":"from typing import List def find_next_letter(letters: List[str], target: str) -> str: Finds the smallest element in the list that is greater than the given target letter. If no such element exists because the list wraps around, returns the first character of the list. left, right = 0, len(letters) - 1 # If wrap-around is needed if target < letters[0] or target >= letters[-1]: return letters[0] while left <= right: mid = (left + right) // 2 if letters[mid] > target: right = mid - 1 else: left = mid + 1 return letters[left]"},{"question":"Histogram Generator You have been provided with a list of elements, and your task is to generate a histogram from this list. A histogram is a representation of the distribution of elements, where each unique element is counted and shown along with its frequency. Function Signature ```python def create_histogram(elements: list) -> dict: ``` Input - `elements`: A list of unordered elements (not necessarily integers). Output - Returns a dictionary where each key is a unique element from the input list, and the corresponding value is the count of occurrences of that element. Constraints - The input list can contain any hashable data type (integers, strings, tuples, etc.). - The length of the input list ( n ) can be any non-negative integer (0 leq n leq 10^6). - If the input list is empty, the function should return an empty dictionary. Example ```python # Example 1 elements = [2, 3, 5, 5, 5, 6, 4, 3, 7] print(create_histogram(elements)) # Output: {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} # Example 2 elements = [\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"banana\\"] print(create_histogram(elements)) # Output: {\\"apple\\": 2, \\"banana\\": 3, \\"orange\\": 1} # Example 3 elements = [] print(create_histogram(elements)) # Output: {} ``` Additional Notes - Ensure that your solution is efficient, both in terms of time and space complexity. - Carefully handle input validation to avoid issues with non-hashable types or invalid inputs if any constraints are later modified. Write the `create_histogram` function to fulfill the given requirements.","solution":"def create_histogram(elements: list) -> dict: Generate a histogram from a list of elements. Parameters: elements (list): A list of unordered elements (not necessarily integers). Returns: dict: A dictionary where each key is a unique element from the input list, and the corresponding value is the count of occurrences of that element. histogram = {} for element in elements: if element in histogram: histogram[element] += 1 else: histogram[element] = 1 return histogram"},{"question":"# Problem Description You are given a non-negative number represented as an array of digits, where each element in the array contains a single digit. The array represents the number in a big-endian order, which means the most significant digit is at the head of the list. Write a function `increment_by_one(digits)` that takes this array and returns a new array that represents the number incremented by one. # Input Format - A list of integers `digits` where each integer is between 0 and 9 inclusive. - The array will not contain leading zeros except for the number `0` itself. # Output Format - A list of integers representing the incremented number. # Constraints - The length of the array will be between 1 and (10^4). # Example Example 1 **Input**: ```python digits = [1,2,3] ``` **Output**: ```python [1,2,4] ``` Example 2 **Input**: ```python digits = [9,9,9] ``` **Output**: ```python [1,0,0,0] ``` # Performance Requirement Your solution should run in (O(n)) time complexity and (O(1)) additional space complexity. # Edge Cases to Consider - All digits are 9. - Single-digit edge cases like [0], [5], [9]. - Incrementing leads to a change in the number of digits (e.g., [9, 9, 9] should become [1, 0, 0, 0]). Your implementation should handle these scenarios properly. # Function Signature ```python def increment_by_one(digits): # Your code here pass ```","solution":"def increment_by_one(digits): This function takes an array of digits representing a non-negative number and returns a new array representing the number incremented by one. n = len(digits) carry = 1 for i in range(n-1, -1, -1): new_digit = digits[i] + carry if new_digit == 10: digits[i] = 0 carry = 1 else: digits[i] = new_digit carry = 0 break if carry == 1: digits.insert(0, 1) return digits"},{"question":"# Permutation Generator Enhancement Given a collection of distinct numbers, your task is to enhance the permutations generation algorithm using an iterative approach to avoid deep recursion and excessive memory usage. Specifically, you need to: 1. Implement a function that returns all permutations of the given list of distinct numbers in an iterative manner. 2. Ensure that the implementation handles edge cases efficiently and performs well on moderately large datasets. Function Signature ```python def permute_iterative(elements: List[int]) -> List[List[int]]: pass ``` Input * `elements` (List[int]): A list of distinct integers. Output * Returns a list of lists, where each list is a unique permutation of the input list. Constraints * The length of `elements` will be between `1` and `10`. Performance Requirements * The solution should avoid deep recursion by using iterative techniques. # Example ```python assert permute_iterative([1, 2, 3]) == [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] ``` Scenario Consider that you are developing a software tool to generate different orderings of tasks for a project manager. The project manager wishes to explore all possible sequences for task completion to determine the most efficient order. The tasks are represented as distinct integers. Your implementation should effectively compute all possible permutations iteratively to ensure scalability and maintain performance.","solution":"from typing import List def permute_iterative(elements: List[int]) -> List[List[int]]: Generates all permutations of the input list of distinct integers using an iterative approach. :param elements: List[int] - a list of distinct integers :return: List[List[int]] - a list of all permutations of the input list results = [] stack = [(elements[:], [])] # (elements left to permute, current permutation) while stack: elements_left, curr_permutation = stack.pop() if not elements_left: # if no elements left to permute, add current perm to results results.append(curr_permutation) else: for i in range(len(elements_left)): next_elements = elements_left[:i] + elements_left[i+1:] next_permutation = curr_permutation + [elements_left[i]] stack.append((next_elements, next_permutation)) return results"},{"question":"# Sorting Colored Objects Objective You are provided with an array containing objects colored red, white, or blue, represented by integers 0, 1, and 2. Implement a function to sort the objects so that objects of the same color are adjacent, following the order red, white, and blue. Implementation Details * **Function Signature**: `def sort_colors(nums: List[int]) -> None` * **Input Format**: A list `nums` of n integers (`0 <= n <= 10^5`), where each integer can be 0, 1, or 2. * **Output Format**: The function should modify the list in-place so that all 0s come first, followed by all 1s, and then all 2s. * **Constraints**: * You must not use the library\'s sort function. * Aim for a time complexity of O(n) and space complexity of O(1). Scenario Consider a scenario where colored beads need to be sorted for a handicraft project, and the colors must follow a strict order to maintain the design pattern. Your task is to sort the beads represented by numbers according to their colors. Example ```python nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output: [0, 0, 1, 1, 2, 2] ``` Explanation In the example, the array `[2, 0, 2, 1, 1, 0]` is transformed to `[0, 0, 1, 1, 2, 2]` with the colors ordered as red, white, and blue. Provide a function that efficiently sorts the list following the above specification.","solution":"from typing import List def sort_colors(nums: List[int]) -> None: Sorts the list nums in-place where each element is 0, 1, or 2. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: # Swap nums[low] and nums[mid] and increment low and mid nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: # Just move to the next element mid += 1 else: # Swap nums[mid] and nums[high] and decrement high nums[mid], nums[high] = nums[high], nums[mid] high -= 1"},{"question":"# Question: *Bit Reversal for Variable Width Integers* You are required to implement a function that reverses the bits of a given unsigned integer and adjusts based on the specified width. # Function Signature: ```python def reverse_bits_vw(n: int, width: int) -> int: pass ``` # Input: * An unsigned integer `n` (0 ≤ n < 2^width). * An integer `width` (1 ≤ width ≤ 64), which denotes the bit width of `n`. # Output: * Return the integer resulting from reversing the bits of `n` according to the given width. # Constraints: * `n` fits within the bit width defined by `width`. * The function should handle all widths from 1 to 64 inclusively. # Example: ```python # For the example with width 5: # Input binary: 01101 (13 in decimal, width 5) # Output binary: 10110 (22 in decimal, width 5) print(reverse_bits_vw(13, 5)) # Output: 22 # For the example with width 7: # Input binary: 1001001 (73 in decimal, width 7) # Output binary: 1001001 (73 in decimal, width 7) print(reverse_bits_vw(73, 7)) # Output: 73 # Notice that the highest bit width is 64: print(reverse_bits_vw(0b1010, 64)) # Output: 2882303761517117440 (0b1000000000000000000000000000000000000000000000000000000000001010) ``` # Notes: * Be cautious about handling edge cases where `n` contains bits beyond `width`. * Ensure your solution is optimized and runs efficiently within the constraints given.","solution":"def reverse_bits_vw(n: int, width: int) -> int: Reverses the bits of a given unsigned integer `n` of bit-width `width`. # Start with an empty result reversed_n = 0 for i in range(width): # Shift the result to the left to make room for the next bit reversed_n <<= 1 # Add the least significant bit from n (rightmost bit) reversed_n |= n & 1 # Shift n to the right to process the next bit n >>= 1 return reversed_n"},{"question":"# Problem Description Given two words `word1` and `word2`, you are to determine the minimum number of steps required to make both words the same. A step consists of deleting exactly one character from either string. # Function Signature ```python def min_steps_to_equalize(word1: str, word2: str) -> int: :type word1: str :type word2: str :rtype: int ``` # Input - `word1` - A string consisting of lowercase English letters. (1 ≤ len(word1) ≤ 1000) - `word2` - A string consisting of lowercase English letters. (1 ≤ len(word2) ≤ 1000) # Output - The minimum number of deletions required to make both strings the same. # Constraints - The solution should be efficiently designed to handle the largest inputs within a reasonable time frame. # Scenario Imagine you are working on a text editing application where you need to sync two different versions of text files by making them exactly the same. You can only achieve this by deleting characters from either file. Your task is to find the optimal number of deletions to synchronize the two text files. # Examples Example 1: ```plaintext Input: word1 = \\"sea\\", word2 = \\"eat\\" Output: 2 Explanation: You need one step to make \\"sea\\" to \\"ea\\" and another step to make \\"eat\\" to \\"ea\\". ``` Example 2: ```plaintext Input: word1 = \\"leetcode\\", word2 = \\"etco\\" Output: 4 Explanation: You need two steps to make \\"leetcode\\" to \\"etcode\\" and another two steps to make \\"etco\\" to \\"etco\\". ``` # Requirements 1. Implement the function `min_steps_to_equalize` that computes the minimum deletion steps. 2. Use dynamic programming principles for an optimal solution. Avoid purely recursive approaches that may lead to excessive computations. 3. Handle edge cases appropriately (e.g., empty strings, identical strings). # Hints * Use the concept of Longest Common Subsequence (LCS) to determine the necessary deletions. * Consider optimizing space if your solution consumes excessive memory.","solution":"def min_steps_to_equalize(word1: str, word2: str) -> int: Determine the minimum number of steps required to make both words the same by deleting characters. :param word1: str :param word2: str :return: int m, n = len(word1), len(word2) # dp[i][j] will hold the length of the longest common subsequence of word1[:i] and word2[:j] dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) lcs_length = dp[m][n] # Minimum deletions required = total characters in both words - 2 * length of LCS return (m - lcs_length) + (n - lcs_length)"},{"question":"You are tasked with implementing a function that filters values in an array based on specified minimum and maximum limits. Your function should be able to handle edge cases effectively and ensure efficient memory usage. # Function Signature ```python def custom_limit(arr: list, min_lim: int = None, max_lim: int = None) -> list: pass ``` # Input - `arr` (list): A list of integers. - `min_lim` (int): An optional integer specifying the minimum value limit. Defaults to `None`. - `max_lim` (int): An optional integer specifying the maximum value limit. Defaults to `None`. # Output - Returns a list containing values from `arr` that are greater than or equal to `min_lim` and less than or equal to `max_lim`. # Constraints - If `min_lim` is `None`, it should be considered as the smallest value in the array. - If `max_lim` is `None`, it should be considered as the largest value in the array. - The array `arr` will contain at most `10^6` elements and each element will have a value between `-10^9` and `10^9`. # Performance Requirements - Your implementation should run in O(n) time complexity. # Example ```python assert custom_limit([5, 3, 8, 1, 9], min_lim=2, max_lim=6) == [5, 3] assert custom_limit([1, 2, 3, 4, 5], min_lim=None, max_lim=3) == [1, 2, 3] assert custom_limit([], min_lim=0, max_lim=10) == [] assert custom_limit([10, 20, 30, 40], min_lim=0, max_lim=None) == [10, 20, 30, 40] assert custom_limit([10, 20, 30, 40], min_lim=25, max_lim=None) == [30, 40] assert custom_limit([10, 20, 30, 40], min_lim=None, max_lim=25) == [10, 20] ``` # Special Notes - If `min_lim` is greater than `max_lim`, your function should return an empty list. - Consider how you might handle invalid input cases, such as non-integer elements within `arr`.","solution":"def custom_limit(arr: list, min_lim: int = None, max_lim: int = None) -> list: Filters values in an array based on specified minimum and maximum limits. Parameters: - arr: list of integers - min_lim: an optional integer specifying the minimum value limit. Defaults to None. - max_lim: an optional integer specifying the maximum value limit. Defaults to None. Returns: - A list containing values from arr that are greater than or equal to min_lim and less than or equal to max_lim. if min_lim is None: min_lim = min(arr, default=-float(\\"inf\\")) if max_lim is None: max_lim = max(arr, default=float(\\"inf\\")) if min_lim > max_lim: return [] return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"Problem Statement # Context You are working on a system that involves saving complex structures like binary trees. These structures need to be serialized into a string format for storage and deserialized back into tree structures for further computations. The provided functions `serialize` and `deserialize` handle these operations using pre-order traversal while accounting for null nodes. # Task Your task is to implement a function that, given a binary tree, will serialize it to a string and deserialize it back to a tree structure. Apart from verifying the correctness of these existing functions, you will: 1. Write additional test cases to check for edge cases. 2. Analyze performance for large and deeply nested trees. 3. Identify possible optimization points or suggest improvements to existing functions. # Requirements * **Function to Implement**: You need to verify and enhance the given `serialize` and `deserialize` functions. * **Input/Output Specifications**: * `serialize(root: TreeNode) -> str`: A function that takes the root of a binary tree and returns a string representing its serialization. * `deserialize(data: str) -> TreeNode`: A function that takes a serialized string and returns the corresponding binary tree. Constraints: - Do not assume balanced trees; test for highly unbalanced trees. - Trees can have up to `10^5` nodes. - Node values are integers and can be negative or positive. # Example: ```python # Example Tree: # 1 # / # 2 3 # / # 4 5 # Serialized Tree: \\"1 2 # # 3 4 # # 5 # #\\" root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) result = serialize(root) print(result) # Expected Output: \\"1 2 # # 3 4 # # 5 # #\\" original_tree = deserialize(result) assert serialize(original_tree) == result # Should pass ``` 1. Implement `serialize` and `deserialize` according to the specifications. 2. Write additional tests to cover edge cases. 3. Evaluate the performance with large inputs. 4. Suggest and optionally implement optimizations to `serialize` and `deserialize`.","solution":"from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root: Optional[TreeNode]) -> str: Encodes a tree to a single string. :param root: TreeNode :return: str def pre_order(node: Optional[TreeNode], acc: List[str]): if node is None: acc.append(\'#\') return acc.append(str(node.val)) pre_order(node.left, acc) pre_order(node.right, acc) acc = [] pre_order(root, acc) return \' \'.join(acc) def deserialize(data: str) -> Optional[TreeNode]: Decodes your encoded data to tree. :param data: str :return: TreeNode def build_tree(nodes: List[str]) -> Optional[TreeNode]: if not nodes: return None val = nodes.pop(0) if val == \'#\': return None node = TreeNode(int(val)) node.left = build_tree(nodes) node.right = build_tree(nodes) return node nodes = data.split() return build_tree(nodes)"},{"question":"# Scenario You are a software engineer designing a system to process data streams in real-time, where maintaining a low memory footprint is crucial. To handle specific monitoring tasks, you need to implement a function that checks if a stream of values is 1-sparse. A 1-sparse stream is defined such that exactly one unique value remains after all numeric values pair and cancel each other out based on their signs. # Function Specification Implement the function `check_one_sparse` that takes a list of tuples as input. Each tuple consists of an integer and a sign (\'+\' or \'-\'). Your function should return the unique value if the stream is 1-sparse. Otherwise, it should return `None`. ```python def check_one_sparse(array): Determine whether the stream is 1-sparse. Parameters: array (list of tuples): Stream represented as list of (value, sign) tuples. Returns: int/None: The unique number if the stream is 1-sparse; None otherwise. # Your implementation here ``` # Input * `array`: A list of tuples where each tuple consists of `(integer, char)` where `char` is either `\'+\'` or `\'-\'`. # Output * Return an integer if the stream is 1-sparse. * Return `None` if the stream is not 1-sparse. # Constraints * The input list contains at most 10^5 elements. * The integer values range between 0 and 10^6 (both inclusive). * The stream is non-negative as per the given algorithm. # Example ```python # Example 1 input_data = [(4,\'+\'), (2,\'+\'), (2,\'-\'), (4,\'+\'), (3,\'+\'), (3,\'-\')] print(check_one_sparse(input_data)) # Output: 4 # Example 2 input_data = [(2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\')] print(check_one_sparse(input_data)) # Output: 2 # Example 3 input_data = [(2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (1,\'+\')] print(check_one_sparse(input_data)) # Output: None ```","solution":"def check_one_sparse(array): Determine whether the stream is 1-sparse. Parameters: array (list of tuples): Stream represented as list of (value, sign) tuples. Returns: int/None: The unique number if the stream is 1-sparse; None otherwise. value_counts = {} for value, sign in array: if sign == \'+\': if value not in value_counts: value_counts[value] = 0 value_counts[value] += 1 elif sign == \'-\': if value not in value_counts: value_counts[value] = 0 value_counts[value] -= 1 unique_value = None non_zero_counts = 0 for value, count in value_counts.items(): if count != 0: non_zero_counts += 1 if non_zero_counts > 1: return None unique_value = value if non_zero_counts == 1: return unique_value return None"},{"question":"Frequency Counter You are tasked with implementing a function that calculates the frequency of elements in a list and returns this information as a dictionary. Function Signature: ```python def frequency_counter(input_list: list) -> dict: ``` Input: - `input_list`: A list of integers where the length of the list is denoted by ( n ) (0 ≤ ( n ) ≤ 10^6). Output: - A dictionary where the keys are the unique elements of the `input_list` and the values are their corresponding frequencies. Constraints: - Elements of `input_list` are integers and can be positive, negative, or zero. - Ensure the function efficiently handles large lists up to the given size constraint. Performance Requirements: - The function should operate within O(n) time complexity. - The function should handle the memory efficiently for the large possible size of `input_list`. Example: ```python # Example 1: # Input input_list = [3, 3, 2, 1] # Output # Expected output dictionary should be: # {1: 1, 2: 1, 3: 2} # Example 2: # Input input_list = [2, 3, 5, 5, 5, 6, 4, 3, 7] # Output # Expected output dictionary should be: # {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} ``` Requirements: - Implement the function within the given constraints and performance expectations. - Be prepared to handle edge cases such as empty lists and lists with repeated or negative numbers. # Assessment Criteria: - Correctness: The function should correctly identify and count frequencies of all elements. - Efficiency: The implementation should work within the specified time and space complexity limits. - Edge case handling: Consider and correctly handle all edge cases specified.","solution":"def frequency_counter(input_list): Returns a dictionary with the frequency count of each element in the input list. frequency_dict = {} for element in input_list: if element in frequency_dict: frequency_dict[element] += 1 else: frequency_dict[element] = 1 return frequency_dict"},{"question":"# Trie Data Structure and Word Search You are building a search engine feature that allows users to check if words or prefixes exist in a large dataset efficiently. Implement a Trie (Prefix Tree) with the following functionalities: 1. `insert(word)`: Inserts a word into the Trie. 2. `search(word)`: Returns `True` if the word exists in the Trie, otherwise returns `False`. 3. `starts_with(prefix)`: Returns `True` if there is any word in the Trie that starts with the given prefix, otherwise returns `False`. # Function Signature ```python class TrieNode: def __init__(self): self.children = collections.defaultdict(TrieNode) self.is_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: pass def search(self, word: str) -> bool: pass def starts_with(self, prefix: str) -> bool: pass ``` # Input/Output Formats 1. **insert(word)**: * **Input**: a string `word` consisting of lowercase letters `a-z`. * **Output**: No output (the function modifies the Trie in place). 2. **search(word)**: * **Input**: a string `word` consisting of lowercase letters `a-z`. * **Output**: `True` if the word exists in the Trie, otherwise `False`. 3. **starts_with(prefix)**: * **Input**: a string `prefix` consisting of lowercase letters `a-z`. * **Output**: `True` if there is any word in the Trie that starts with the given prefix, otherwise `False`. # Constraints 1. Assume all inputs are non-empty strings. 2. You may assume that all inputs are composed of lowercase letters from `a` to `z`. 3. The functions should be optimized for speed given a very large dataset of words. # Example ```python trie = Trie() trie.insert(\\"apple\\") print(trie.search(\\"apple\\")) # Returns True print(trie.search(\\"app\\")) # Returns False print(trie.starts_with(\\"app\\")) # Returns True trie.insert(\\"app\\") print(trie.search(\\"app\\")) # Returns True ``` Implement the above functions to demonstrate understanding and correct usage of the Trie data structure.","solution":"import collections class TrieNode: def __init__(self): self.children = collections.defaultdict(TrieNode) self.is_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: node = node.children[char] node.is_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"# Question Background You are given a directed graph represented by the `DirectedGraph`, `Node`, and `DirectedEdge` classes, as provided in the code snippet. The graph can have multiple nodes and directed edges between them. Your task is to implement a function that checks if there is a cycle in the graph. Problem Statement **Function Signature:** ```python def has_cycle(graph: DirectedGraph) -> bool: ... ``` **Input:** * The function will receive an instance of `DirectedGraph`. **Output:** * The function should return a boolean value: * `True` if the graph contains at least one cycle. * `False` if the graph is acyclic. **Constraints:** * Assume the graph can contain up to 10^5 nodes and edges, so your solution should handle large inputs efficiently. Explanation A cycle in a directed graph occurs if you can start from a node and follow directed edges back to the same node. Example Consider the following graph structure: ``` A -> B -> C | | | v D <- E ``` There are no cycles in this graph, so the function should return `False`. However, if a new edge is added from D to A, making the structure: ``` A -> B -> C | | | v D <- E ^ | |_ _| ``` It will form a cycle, so the function should return `True`. Note Consider all possible edge cases and ensure correctness and efficiency in handling large graphs.","solution":"class Node: def __init__(self, value): self.value = value class DirectedEdge: def __init__(self, from_node, to_node): self.from_node = from_node self.to_node = to_node class DirectedGraph: def __init__(self): self.nodes = set() self.edges = [] def add_node(self, node: Node): self.nodes.add(node) def add_edge(self, from_node: Node, to_node: Node): self.edges.append(DirectedEdge(from_node, to_node)) def has_cycle(graph: DirectedGraph) -> bool: def dfs(node, visited, rec_stack): if node not in visited: visited.add(node) rec_stack.add(node) for edge in graph.edges: if edge.from_node == node: if edge.to_node not in visited and dfs(edge.to_node, visited, rec_stack): return True elif edge.to_node in rec_stack: return True rec_stack.remove(node) return False visited = set() rec_stack = set() for node in graph.nodes: if node not in visited: if dfs(node, visited, rec_stack): return True return False"},{"question":"# Coding Challenge: Implement a Robust Diffie-Hellman Key Exchange in Python Objective Your task is to implement a secure Diffie-Hellman key exchange algorithm that ensures both participants (Alice and Bob) can securely generate and share a secret key over an insecure communication channel. Requirements 1. **Function Definitions**: - `is_prime(num)`: Checks if a number is prime. - `primitive_root(p)`: Finds a primitive root of a prime number `p`. - `diffie_hellman_key_exchange(a, p)`: Executes the Diffie-Hellman key exchange protocol. 2. **Function Specifications**: - **is_prime(num)**: - Input: An integer `num`. - Output: Boolean value indicating whether `num` is a prime number. - **primitive_root(p)**: - Input: A prime number `p`. - Output: A primitive root of `p`. - **diffie_hellman_key_exchange(a, p)**: - Input: Two integers `a` (primitive root of `p`) and `p` (prime number). - Output: The common shared secret key generated independently by Alice and Bob. 3. **Constraints**: - Use efficient algorithms for prime checking and finding primitive roots. - Handle cases where `a` is not a valid primitive root of `p`. - Ensure the selection of secure random numbers for private keys. - Both `a` and `p` must be provided as valid inputs (i.e., `p` is prime and `a` is its valid primitive root). Example ```python # Sample inputs p = 23 # A prime number a = 5 # A primitive root of 23 # Run the Diffie-Hellman key exchange shared_key = diffie_hellman_key_exchange(a, p) print(shared_key) # Both Alice\'s and Bob\'s calculations should match and print the same value. ``` Notes - Do not use built-in libraries for prime and primitive root calculations, implement your own methods. - Ensure thread safety and proper handling of random number generations for private keys. - Document and test your functions thoroughly for correctness and efficiency.","solution":"import random import math def is_prime(num): if num < 2: return False for i in range(2, int(math.sqrt(num)) + 1): if num % i == 0: return False return True def primitive_root(p): if not is_prime(p): raise ValueError(f\\"{p} is not a prime number.\\") def is_primitive_root(a): required_set = set(num for num in range(1, p)) actual_set = set(pow(a, powers, p) for powers in range(1, p)) return required_set == actual_set for possible_root in range(2, p): if is_primitive_root(possible_root): return possible_root raise ValueError(f\\"No primitive root found for {p}.\\") def diffie_hellman_key_exchange(a, p): if not is_prime(p): raise ValueError(f\\"{p} is not a prime number.\\") if not is_primitive_root(a, p): raise ValueError(f\\"{a} is not a valid primitive root of {p}.\\") private_key_a = random.randint(2, p-2) private_key_b = random.randint(2, p-2) public_key_a = pow(a, private_key_a, p) public_key_b = pow(a, private_key_b, p) shared_secret_key_a = pow(public_key_b, private_key_a, p) shared_secret_key_b = pow(public_key_a, private_key_b, p) assert shared_secret_key_a == shared_secret_key_b return shared_secret_key_a def is_primitive_root(root, p): required_set = set(num for num in range(1, p)) actual_set = set(pow(root, powers, p) for powers in range(1, p)) return required_set == actual_set"},{"question":"You are given an array of integers and a target integer. Your task is to implement a function `linear_search_enhanced(array, query)` that improves the linear search algorithm by handling additional requirements and edge cases. # Specifications - You need to add two enhancements: 1. Return -1 immediately if the array is empty. 2. If the query appears multiple times, return a list of all indices where the query appears. # Function Signature ```python def linear_search_enhanced(array: List[int], query: int) -> Union[int, List[int]]: ``` # Input Format - `array`: A list of integers, possibly empty. - `query`: An integer to search for in the array. # Output Format - If the `array` is empty, return -1. - If the `query` is found once, return its index. - If the `query` is found multiple times, return a list of all indices where the query appears. - If the `query` is not found, return -1. # Constraints - The length of `array` is between 0 and 10^5. - Elements of `array` and `query` are integers within the range of -10^9 and 10^9. # Example Input ```python array = [1, 2, 3, 4, 2, 5] query = 2 ``` Output ```python [1, 4] ``` # Notes - Return the list in sorted order of indices. - Use efficient techniques to ensure the solution scales well up to the largest input sizes specified.","solution":"from typing import List, Union def linear_search_enhanced(array: List[int], query: int) -> Union[int, List[int]]: Perform a linear search for `query` in `array`. - If the array is empty, return -1. - If the query is found once, return its index. - If the query is found multiple times, return a list of all indices where the query appears. - If the query is not found, return -1. if not array: return -1 indices = [] for i, value in enumerate(array): if value == query: indices.append(i) if not indices: return -1 if len(indices) == 1: return indices[0] return indices"},{"question":"# Question: Advanced String Reversal You are required to implement a function `advanced_reverse` that efficiently reverses a string. The function should utilize an iterative method that is both time and space efficient without using Python built-in slicing or `reversed` functions. **Function Signature**: ```python def advanced_reverse(s: str) -> str: pass ``` # Input: - `s` (string): The input string to be reversed. `1 <= len(s) <= 10^6` # Output: - Returns a string that is the reverse of the input string `s`. # Constraints: - Do not use Python slicing `s[::-1]` or the `reversed()` function. - Aim for a time complexity of O(n) and a space complexity of O(n). # Example: ```python assert advanced_reverse(\\"hello\\") == \\"olleh\\" assert advanced_reverse(\\"A man, a plan, a canal, Panama!\\") == \\"!amanaP ,lanac a ,nalp a ,nam A\\" assert advanced_reverse(\\"racecar\\") == \\"racecar\\" # Palindrome case assert advanced_reverse(\\"\\") == \\"\\" # Edge case: empty string ``` # Note: Consider optimal ways to handle very large strings efficiently without causing excessive memory use or stack overflows.","solution":"def advanced_reverse(s: str) -> str: Returns the reversed version of the input string `s`. result = [] for char in s: result.insert(0, char) return \'\'.join(result)"},{"question":"# Scenario: You are required to implement a recursive sorting algorithm called Stooge Sort, which demonstrates the basic principles of recursion and sorting. Stooge Sort works by sorting the array in three main steps: swapping elements, recursively sorting portions of the array, and ensuring the smallest elements move to the front of the array. # Task: Implement the Stooge Sort algorithm as described in the provided guidelines. # Input: 1. A list of integers, `arr`, which needs to be sorted. 2. Two integer indices `l` (left) and `h` (right) indicating the segment of the array to be sorted. # Output: The function should sort the segment of the array in place. The output does not require a return value since the original array will be modified directly. # Constraints: - The input array `arr` can have up to 1000 elements. - The indices `l` and `h` will always be valid and within the range of the array length. - The array may contain positive or negative integers. # Function Definition: ```python def stoogesort(arr, l, h): # Your implementation here ``` # Example: ```python arr = [5, 2, 4, 3, 1] stoogesort(arr, 0, len(arr) - 1) print(arr) # Output: [1, 2, 3, 4, 5] arr2 = [3, 2, 1] stoogesort(arr2, 0, len(arr2) - 1) print(arr2) # Output: [1, 2, 3] ``` **Note**: The sorting must be done in place. Ensure that your implementation adheres to the principles of Stooge Sort as outlined.","solution":"def stoogesort(arr, l, h): if l >= h: return # If the first element is greater than the last, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than two elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(arr, l, h - t) stoogesort(arr, l + t, h) stoogesort(arr, l, h - t)"},{"question":"You are working on a text messaging application that allows users to type messages using the T9 predictive text input method which maps digits to letters (like on older mobile phones). Your task is to write a function that generates all possible letter combinations from a given digit string input. Function Signature: ```python def letter_combinations(digits: str) -> List[str]: pass ``` # Input: - A string `digits` where each character is a digit from \'2\' to \'9\'. # Output: - A list of strings, where each string represents a possible letter combination. # Constraints: - The input string will only contain digits from \'2\' to \'9\'. - The output list should be sorted in lexicographical order. # Example: Input: ```plaintext \\"23\\" ``` Output: ```plaintext [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] ``` # Explanation: The digit \'2\' corresponds to the letters \'a\', \'b\', \'c\' and the digit \'3\' corresponds to the letters \'d\', \'e\', \'f\'. All combinations of these letters can be formed resulting in the provided output. **Note:** Avoid using built-in permutation or combination libraries to solve this problem as the focus is to implement the combination generation logic from scratch. # Performance Requirements: - The solution should handle input strings with up to 4-5 digits efficiently. Additional Notes: Make sure to handle edge cases like an empty input string, which should return an empty list.","solution":"from typing import List def letter_combinations(digits: str) -> List[str]: if not digits: return [] phone_mapping = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(index: int, path: str): if index == len(digits): combinations.append(path) return possible_letters = phone_mapping[digits[index]] for letter in possible_letters: backtrack(index + 1, path + letter) combinations = [] backtrack(0, \\"\\") return combinations"},{"question":"Context: You are tasked with decoding messages that have been encoded using a mapping from letters \'A\' to \'Z\' to numbers \'1\' to \'26\'. Given an encoded message, your goal is to determine the total number of ways to decode it. For instance: * The encoded message \\"12\\" can be decoded as \\"AB\\" (1 2) or \\"L\\" (12), giving a total of 2 ways. Problem Statement: Implement a function `num_ways_to_decode(encoded_message: str) -> int` that takes an encoded message as input and returns the total number of ways to decode it. Input: * `encoded_message`: A string consisting of digits, where `1 <= len(encoded_message) <= 100`. Output: * An integer representing the total number of distinct decodings of the input string. Constraints: * An encoded message starting with \'0\' is invalid and should return `0`. * Your algorithm should run in O(n) time complexity and use O(n) space complexity. Examples: ```python assert num_ways_to_decode(\\"12\\") == 2 # \\"12\\" -> \\"AB\\" or \\"L\\" assert num_ways_to_decode(\\"226\\") == 3 # \\"226\\" -> \\"BZ\\", \\"VF\\", \\"BBF\\" assert num_ways_to_decode(\\"0\\") == 0 # Invalid encoding assert num_ways_to_decode(\\"10\\") == 1 # \\"10\\" -> \\"J\\" assert num_ways_to_decode(\\"100\\") == 0 # Invalid encoding ``` Notes: * Ensure to include input validation. * Handle invalid inputs gracefully such as messages containing non-digit characters or empty strings. * Aim for clarity and optimal performance in your implementation.","solution":"def num_ways_to_decode(encoded_message: str) -> int: # Validate the input if not encoded_message or not encoded_message.isdigit(): return 0 if encoded_message[0] == \'0\': return 0 n = len(encoded_message) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): if encoded_message[i-1] != \'0\': dp[i] += dp[i-1] if 10 <= int(encoded_message[i-2:i]) <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"# Permutation Generation with Constraints You are required to implement a function that generates permutations of a list of distinct integers. However, this time you need to include a constraint based on a provided comparator function. The comparator function should define the sorting order in which permutations are to be generated. # Function Signature ```python def generate_permutations(nums: List[int], comparator: Callable[[int, int], bool]) -> List[List[int]]: Generate all permutations of the list nums and order them based on the comparator function. :param nums: List[int] - A list of distinct integers. :param comparator: Callable[[int, int], bool] - A comparator function that takes two integers and returns True if the first integer should come before the second, and False otherwise. :return: List[List[int]] - A list of permutations sorted based on the comparator function. ``` # Input * List of distinct integers `nums` (0 <= len(nums) <= 8). * A comparator function `comparator`, which will affect the order of the permutations. # Output * A list of all sorted permutations according to the comparator function. # Constraints * You may assume `nums` contains only distinct integers. * Any permutation sorting for the output needs to follow the comparator function\'s logic. # Example ```python nums = [1, 2, 3] comparator = lambda x, y: x < y # Standard ascending order generate_permutations(nums, comparator) # Expected Output: [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] ``` # Explanation In the above example, `nums` contains three distinct integers, and permutations are generated and returned in standard ascending order as per the comparator function. Implement the function so that you can handle any valid comparator function passed to it.","solution":"from typing import List, Callable import itertools def generate_permutations(nums: List[int], comparator: Callable[[int, int], bool]) -> List[List[int]]: Generate all permutations of the list nums and order them based on the comparator function. :param nums: List[int] - A list of distinct integers. :param comparator: Callable[[int, int], bool] - A comparator function that takes two integers and returns True if the first integer should come before the second, and False otherwise. :return: List[List[int]] - A list of permutations sorted based on the comparator function. # Generate all possible permutations of the given list permutations = list(itertools.permutations(nums)) # Convert permutations tuples to lists since the final output expects lists permutations = [list(perm) for perm in permutations] # Custom sort function based on the comparator def custom_sort_key(lst): # Generate a comparable tuple based on comparator results return tuple(cmp_to_key(comparator)(x) for x in lst) # Special function to turn a comparator into a key function def cmp_to_key(mycmp): \'Convert a cmp= function into a key= function\' class K: def __init__(self, obj, *args): self.obj = obj def __lt__(self, other): return mycmp(self.obj, other.obj) def __gt__(self, other): return mycmp(other.obj, self.obj) def __eq__(self, other): return not mycmp(self.obj, other.obj) and not mycmp(other.obj, self.obj) def __le__(self, other): return not mycmp(other.obj, self.obj) def __ge__(self, other): return not mycmp(self.obj, other.obj) def __ne__(self, other): return mycmp(self.obj, other.obj) or mycmp(other.obj, self.obj) return K # Sort permutations using a custom key derived from the comparator permutations.sort(key=lambda x: custom_sort_key(x)) return permutations"},{"question":"# Binary Search Tree Implementation Challenge In this question, you are required to implement a Binary Search Tree (BST) with the following functionalities: 1. **Insert**: Insert a new value into the BST. If the value already exists in the tree, do not insert it again. 2. **Search**: Check if a particular value is present in the BST. 3. **Size**: Calculate the total number of nodes in the BST. 4. **Traversals**: Provide Preorder, Inorder, and Postorder traversals of the BST. # Function Signatures ```python class Node: def __init__(self, data): pass class BST: def __init__(self): pass def insert(self, data): pass def search(self, data): pass def size(self): pass def preorder(self, root): pass def inorder(self, root): pass def postorder(self, root): pass ``` # Input/Output * **Insert**: * Input: Integer `data` * Output: Boolean (True if inserted, False if already present) * **Search**: * Input: Integer `data` * Output: Boolean (True if present, False if absent) * **Size**: * Input: None * Output: Integer (total number of nodes) * **Traversal**: * Input: `root` (root node of the BST) * Output: Prints nodes in Preorder/Inorder/Postorder # Constraints * All values inserted into the BST are integers. * There will be no duplicate values to deal with for insertion. * The tree should support at least 10,000 nodes without performance degradation. # Example Construct the following tree by inserting values: ``` 10 / 6 15 / / 4 9 12 24 / / 7 20 30 / 18 ``` Sample Usage: ```python tree = BST() tree.insert(10) tree.insert(15) tree.insert(6) tree.insert(4) tree.insert(9) tree.insert(12) tree.insert(24) tree.insert(7) tree.insert(20) tree.insert(30) tree.insert(18) print(tree.search(24)) # True print(tree.search(50)) # False print(tree.size()) # 11 tree.preorder(tree.get_root()) # 10 6 4 9 7 15 12 24 20 18 30 tree.inorder(tree.get_root()) # 4 6 7 9 10 12 15 18 20 24 30 tree.postorder(tree.get_root())# 4 7 9 6 12 18 20 30 24 15 10 ``` Your task is to complete the implementation of the `BST` class as per the provided function signatures with correct logic for insert, search, size, and traversal methods.","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BST: def __init__(self): self.root = None self._size = 0 def get_root(self): return self.root def insert(self, data): if self.root is None: self.root = Node(data) self._size += 1 return True else: return self._insert_recursive(self.root, data) def _insert_recursive(self, node, data): if data == node.data: return False elif data < node.data: if node.left is None: node.left = Node(data) self._size += 1 return True return self._insert_recursive(node.left, data) else: if node.right is None: node.right = Node(data) self._size += 1 return True return self._insert_recursive(node.right, data) def search(self, data): return self._search_recursive(self.root, data) def _search_recursive(self, node, data): if node is None: return False if data == node.data: return True elif data < node.data: return self._search_recursive(node.left, data) else: return self._search_recursive(node.right, data) def size(self): return self._size def preorder(self, root, traversal=[]): if root: traversal.append(root.data) self.preorder(root.left, traversal) self.preorder(root.right, traversal) return traversal def inorder(self, root, traversal=[]): if root: self.inorder(root.left, traversal) traversal.append(root.data) self.inorder(root.right, traversal) return traversal def postorder(self, root, traversal=[]): if root: self.postorder(root.left, traversal) self.postorder(root.right, traversal) traversal.append(root.data) return traversal"},{"question":"Objective Write a function that takes an unsigned integer and returns the number of \'1\' bits it has (also known as the Hamming weight). Context In a communication system, you are tasked to develop a module that verifies the integrity of transmitted data using the Hamming weight of an integer associated with error detection codes. Your function should efficiently count the number of \'1\' bits in the binary representation of an integer to aid in this process. Function Signature ```python def hamming_weight(n: int) -> int: Counts the number of \'1\' bits in the binary representation of a given unsigned integer. Parameters: n (int): The integer to count set bits for. Returns: int: The number of \'1\' bits in the binary representation of the given integer. pass ``` Requirements 1. You must implement the function using Brian Kernighan\'s Algorithm. 2. The implementation should handle a 32-bit unsigned integer as input. 3. Consider both iterative and recursive approaches and choose the one you find more appropriate. Constraints * The input integer `n` will be in the range `[0, 2^32 - 1]`. * You may not use any built-in functions that directly perform the task, like `bin()`. Example ```python >>> hamming_weight(11) 3 >>> hamming_weight(128) 1 >>> hamming_weight(0) 0 ``` Additional Instructions 1. Provide a brief explanation of your chosen approach. 2. Handle edge cases appropriately, such as ensuring correct output for `n = 0`. 3. Analyze the time and space complexity of your solution.","solution":"def hamming_weight(n: int) -> int: Counts the number of \'1\' bits in the binary representation of a given unsigned integer. Parameters: n (int): The integer to count set bits for. Returns: int: The number of \'1\' bits in the binary representation of the given integer. count = 0 while n: n = n & (n - 1) count += 1 return count"},{"question":"You are given a sorted array of integers and you need to find the index of a particular target element within this array using an efficient search algorithm. If the target element is not present in the array, the function should return -1. # Scenario Imagine you\'re working on a part of a search engine optimization task where searching within large but sorted data is frequent. Implementing an efficient search can significantly improve query performance. # Task Implement the function `jump_search` which takes two parameters: - `arr`: A sorted list of integers. - `target`: An integer representing the element to search for. The function should return the index of the `target` element if it is present in the array, and `-1` otherwise. # Function Signature ```python def jump_search(arr: List[int], target: int) -> int: ``` # Input - A sorted list of integers, `arr`, with length ( n ) ((1 leq n leq 10^5)). - An integer, `target`. # Output - An integer, the index of `target` in the list `arr` if present, otherwise `-1`. # Example ```python arr = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31] target = 19 print(jump_search(arr, target)) # Output: 7 arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] target = 0 print(jump_search(arr, target)) # Output: -1 ``` # Constraints - The list, `arr`, must be sorted in non-decreasing order. - The function should handle large lists efficiently within the time complexity of (O(sqrt{n})).","solution":"from typing import List import math def jump_search(arr: List[int], target: int) -> int: n = len(arr) step = int(math.sqrt(n)) prev = 0 # Finding the block where the element is present (if it is present) while arr[min(step, n) - 1] < target: prev = step step += int(math.sqrt(n)) if prev >= n: return -1 # Doing a linear search for target in block beginning with prev while arr[prev] < target: prev += 1 if prev == min(step, n): return -1 # If the element is found if arr[prev] == target: return prev return -1"},{"question":"# Hamming Weight Calculation Using Brian Kernighan\'s Algorithm Problem Statement Given an unsigned integer, write a function that returns the number of \'1\' bits it has, also known as the Hamming weight. You are expected to implement two versions of the function: one using a recursive approach and the other using an iterative approach, both based on Brian Kernighan\'s Algorithm. Function Signatures ```python def count_ones_recur(n: int) -> int: def count_ones_iter(n: int) -> int: ``` Input * A single integer `n` where `0 <= n <= 2^31 - 1`. Output * A single integer representing the number of \'1\' bits in the binary representation of `n`. Examples ```python # Example 1: n = 11 # 11 in binary is 1011 # Number of 1s = 3 assert count_ones_recur(n) == 3 assert count_ones_iter(n) == 3 # Example 2: n = 128 # 128 in binary is 10000000 # Number of 1s = 1 assert count_ones_recur(n) == 1 assert count_ones_iter(n) == 1 # Example 3: n = 4294967295 # 4294967295 in binary is 11111111111111111111111111111111 # Number of 1s = 32 assert count_ones_recur(n) == 32 assert count_ones_iter(n) == 32 ``` Constraints * You must use Brian Kernighan\'s Algorithm. * You must implement both the recursive and iterative versions. * Consider efficiency in terms of time and space complexity. Notes * Focus on handling edge cases, such as the minimum and maximum constraints for `n`. * Ensure your solution is optimized based on the given problem statement and constraints.","solution":"def count_ones_recur(n: int) -> int: Recursive implementation of Hamming weight calculation using Brian Kernighan\'s algorithm. if n == 0: return 0 return 1 + count_ones_recur(n & (n - 1)) def count_ones_iter(n: int) -> int: Iterative implementation of Hamming weight calculation using Brian Kernighan\'s algorithm. count = 0 while n != 0: n = n & (n - 1) count += 1 return count"},{"question":"// Scenario/Context In software to detect repeating patterns in data streams, it is essential to recognize cyclic patterns efficiently. You are tasked to create a function that checks if a string is composed of repeating substrings. The code will help detect cyclic patterns in string data passed to various modules. // Overall Requirements Implement a function that determines if a given non-empty string can be constructed by taking a substring and repeating it multiple times. // Implementation Guidelines **Function Signature**: ```python def is_repeated_substring(s: str) -> bool: pass ``` **Input**: - `s`: A non-empty string consisting of lowercase English letters (1 <= length of s <= 10^4). **Output**: - Returns `True` if the given string is a repeat of a substring, else returns `False`. **Constraints**: - The function should run in O(n) time complexity. - Should efficiently handle edge cases of very short and very long strings. **Detailed Requirements**: 1. Create a new string by concatenating `s` with itself and removing the first and last characters. 2. Check if the original string `s` exists within this new string. 3. If found, return `True`; otherwise, return `False`. 4. Ensure the solution handles edge cases robustly. **Example**: ```python assert is_repeated_substring(\\"abab\\") == True assert is_repeated_substring(\\"aba\\") == False assert is_repeated_substring(\\"abcabcabcabc\\") == True assert is_repeated_substring(\\"a\\") == False ```","solution":"def is_repeated_substring(s: str) -> bool: Determines if the given string can be constructed by repeating a substring. Args: s (str): The input string. Returns: bool: True if the string is composed of a repeating substring, else False. if not s: return False ss = (s + s)[1:-1] return s in ss"},{"question":"# Merge Two Sorted Arrays **Scenario**: You\'re given two sorted arrays `arr1` and `arr2`. Your task is to merge these two arrays into a single sorted array. This is a fundamental problem in computer science and is a key component of the Merge Sort algorithm, which you have recently studied. **Task**: Write a function `merge_sorted_arrays(arr1, arr2)` that merges two sorted arrays `arr1` and `arr2` into a single sorted array. # Function Signature ```python def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: pass ``` # Input * `arr1`: List of integers, sorted in ascending order (0 <= len(arr1) <= 10^5). * `arr2`: List of integers, sorted in ascending order (0 <= len(arr2) <= 10^5). # Output * Returns a single list of integers, containing all elements from `arr1` and `arr2`, sorted in ascending order. # Constraints * The combined length of `arr1` and `arr2` will not exceed 200,000 elements. # Example ```python merge_sorted_arrays([1, 3, 5], [2, 4, 6]) # Output: [1, 2, 3, 4, 5, 6] merge_sorted_arrays([1, 2, 3, 7], [4, 5, 6]) # Output: [1, 2, 3, 4, 5, 6, 7] merge_sorted_arrays([], [1, 2, 3]) # Output: [1, 2, 3] merge_sorted_arrays([1, 2, 3], []) # Output: [1, 2, 3] ``` # Performance Requirements * The function should run in O(n + m) time complexity, where n is the length of `arr1` and m is the length of `arr2`. * The function should use O(n + m) additional space. # Notes * You should handle edge cases, such as one or both arrays being empty. * Consider efficiency in terms of both time and space. * This is a fundamental building block for understanding more complex sorting algorithms like Merge Sort.","solution":"from typing import List def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: Merges two sorted arrays into one sorted array. merged_array = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"# Minimum Spanning Tree Using Prim\'s Algorithm You are required to implement a modified version of Prim\'s algorithm to find the weight of the minimum spanning tree (MST) for a connected graph. The input graph is represented as an adjacency list. Your task is to return the total weight of the MST. Input * **graph**: A dictionary representing the graph where keys are nodes, and values are lists of pairs `[weight, adjacent_node]`. Output * Return an integer representing the total weight of the MST. # Constraints 1. The graph is connected and undirected. 2. Graph nodes are represented as integers from 1 to (N). 3. The number of nodes (1 leq N leq 1000) and the number of edges (1 leq E leq N(N-1)/2). # Example ```python graph = { 1: [[3, 2], [8, 3]], 2: [[3, 1], [5, 4]], 3: [[8, 1], [2, 4], [4, 5]], 4: [[5, 2], [2, 3], [6, 5]], 5: [[4, 3], [6, 4]] } assert find_mst_weight(graph) == 14 ``` # Function Signature ```python def find_mst_weight(graph): pass ``` Example Explanation: In the example graph provided, the edges included in the MST are: * (1 - 2) with weight 3. * (2 - 4) with weight 5. * (4 - 3) with weight 2. * (3 - 5) with weight 4. The total weight of these edges is (3 + 5 + 2 + 4 = 14). Implement the function `find_mst_weight` below: ```python import heapq def find_mst_weight(graph): Prim\'s algorithm to find weight of the minimum spanning tree vis = set() heap = [[0, 1]] mincost = 0 while len(heap) > 0: cost, node = heapq.heappop(heap) if node in vis: continue mincost += cost vis.add(node) for distance, adjacent in graph[node]: if adjacent not in vis: heapq.heappush(heap, [distance, adjacent]) return mincost ```","solution":"import heapq def find_mst_weight(graph): Prim\'s algorithm to find weight of the minimum spanning tree. vis = set() min_heap = [[0, 1]] # Start with node 1, with 0 cost to include the starting node total_weight = 0 while min_heap and len(vis) < len(graph): weight, node = heapq.heappop(min_heap) if node in vis: continue vis.add(node) total_weight += weight for adj_weight, adj_node in graph[node]: if adj_node not in vis: heapq.heappush(min_heap, [adj_weight, adj_node]) return total_weight"},{"question":"# Keyboard Row Challenge Background Imagine you work for a software company developing a text processing tool. One of the features is to filter and display words that can be typed using letters from only a single row on a traditional American QWERTY keyboard. A standard QWERTY keyboard has three rows of letters as follows: 1. Top row: \\"QWERTYUIOP\\" 2. Middle row: \\"ASDFGHJKL\\" 3. Bottom row: \\"ZXCVBNM\\" Problem Statement Given a list of words, write a function `find_keyboard_row(words)` that filters and returns the list of words that can be typed using letters from only one keyboard row. Function Signature ```python def find_keyboard_row(words: List[str]) -> List[str]: pass ``` Input * `words`: A list of strings composed of alphabetic characters. Output * A list of strings, where each string in the original list can be typed using letters from only one row of the keyboard. Constraints * The input list can have up to 1000 words. * Each word can have a length up to 100 characters. Example ```python Input: [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] Output: [\\"Alaska\\", \\"Dad\\"] ``` Requirements 1. Your solution should efficiently handle the constraints. 2. Ensure to consider case-insensitivity i.e., \\"Hello\\" and \\"hello\\" should be treated alike. 3. Provide a clear, concise, and correct implementation. Hints * You may utilize sets to represent keyboard rows for efficient lookups. * Consider how set operations can help ensure that all characters of a word belong to a single row.","solution":"from typing import List def find_keyboard_row(words: List[str]) -> List[str]: top_row = set(\\"QWERTYUIOPqwertyuiop\\") middle_row = set(\\"ASDFGHJKLasdfghjkl\\") bottom_row = set(\\"ZXCVBNMzxcvbnm\\") def can_type_with_one_row(word): # Convert word to set of characters word_set = set(word) # Check if word_set is a subset of any of the row sets return word_set <= top_row or word_set <= middle_row or word_set <= bottom_row return [word for word in words if can_type_with_one_row(word)]"},{"question":"# Scenario You are working on a data analysis project where you need to preprocess a large dataset containing millions of numeric entries. The dataset needs to be filtered so that only entries within a specific range are included in further analysis. # Task Write a function `custom_limit(arr, min_lim=None, max_lim=None)` that mimics the functionality of the provided `limit()` function but includes additional features and optimizations: 1. **Handle Non-Inclusive Limits**: Take additional boolean parameters `inclusive` (default `True`), indicating whether the range checks should be inclusive. 2. **Optional Early Termination**: Add an argument `perform_early_termination` (default `False`) to allow early termination if the rest of the array elements are known to be outside the given range. 3. **Prevent Default Behavior**: The function should not automatically set `min_lim` and `max_lim` if they are not provided. Instead, it should explicitly require these values and raise a `ValueError` if both are `None`. # Expected Input and Output * **Input**: * `arr`: List of numeric elements (integers or floats). * `min_lim`: Minimum limit for the range. If `None`, it means there is no lower limit. * `max_lim`: Maximum limit for the range. If `None`, it means there is no upper limit. * `inclusive`: Boolean indicating whether the limits are inclusive. * `perform_early_termination`: Boolean indicating if early termination should be performed. * **Output**: * List of elements that fall within the specified range. # Constraints 1. `arr` contains at most 10^6 elements. 2. Values in `arr` are between -10^6 and 10^6. 3. If `inclusive` is `False`, use strict inequality checks (`<` and `>`); otherwise, use `<=` and `>=`. 4. If both `min_lim` and `max_lim` are `None`, raise a `ValueError`. # Function Signature ```python def custom_limit(arr, min_lim=None, max_lim=None, inclusive=True, perform_early_termination=False): pass ``` # Example ```python # Basic functionality test print(custom_limit([1, 2, 3, 4, 5], 2, 4)) # Output: [2, 3, 4] # Non-inclusive limits print(custom_limit([1, 2, 3, 4, 5], 2, 4, inclusive=False)) # Output: [3] # Early termination flag test (array is sorted) print(custom_limit([1, 2, 3, 4, 5, 6, 7, 8, 9], 2, 6, perform_early_termination=True)) # Output: [2, 3, 4, 5, 6] ``` Remember to handle edge cases like empty arrays or invalid inputs gracefully.","solution":"def custom_limit(arr, min_lim=None, max_lim=None, inclusive=True, perform_early_termination=False): Filters elements in `arr` between `min_lim` and `max_lim` based on the inclusive and early termination flags. Parameters: arr (list of int/float): The array to filter. min_lim (int/float): The minimum limit of the range. max_lim (int/float): The maximum limit of the range. inclusive (bool): If True, include the limits in the range check. If False, exclude them. perform_early_termination (bool): If True, terminate early if the rest of the elements are outside the range. Returns: list: Filtered list of elements within the specified range. if min_lim is None and max_lim is None: raise ValueError(\\"At least one of `min_lim` or `max_lim` must be provided\\") result = [] for num in arr: if min_lim is not None: if inclusive and num < min_lim: continue if not inclusive and num <= min_lim: continue if max_lim is not None: if inclusive and num > max_lim: if perform_early_termination: break continue if not inclusive and num >= max_lim: if perform_early_termination: break continue result.append(num) return result"},{"question":"# Question: Implement Rabin-Karp Algorithm for Substring Search **Context**: You are developing a search feature for a text editor that needs to efficiently locate and highlight instances of a given search term within the editor’s document. To achieve this, you decide to use the Rabin-Karp algorithm due to its efficiency with large texts. **Task**: Write a function `rabin_karp_search(pattern: str, text: str) -> int` that returns the first occurrence index of the pattern in the text using the Rabin-Karp algorithm. If the pattern is not found, the function should return `-1`. # Input * **pattern**: A non-empty string representing the search pattern. * **text**: A string representing the text to be searched. # Output * An integer representing the index of the first occurrence of the pattern in the text, or `-1` if the pattern is not found. # Constraints * Implement the function with consideration of the time complexity discussed. * Handle edge cases where the pattern or text might be empty, or the pattern is longer than the text. # Example ```python >>> print(rabin_karp_search(\\"abc\\", \\"abcdefab\\")) 0 >>> print(rabin_karp_search(\\"xyz\\", \\"abcdefab\\")) -1 >>> print(rabin_karp_search(\\"aaaa\\", \\"baaaacaaa\\")) 1 ```","solution":"def rabin_karp_search(pattern: str, text: str) -> int: if not pattern or not text or len(pattern) > len(text): return -1 base = 256 # Base value for the ASCII characters prime_modulus = 101 # A prime number for modulating hash values pattern_length = len(pattern) text_length = len(text) pattern_hash = 0 # Hash value for pattern current_hash = 0 # Hash value for the current window of text highest_power = 1 # The highest power of base used for the first window for i in range(pattern_length - 1): highest_power = (highest_power * base) % prime_modulus for i in range(pattern_length): pattern_hash = (base * pattern_hash + ord(pattern[i])) % prime_modulus current_hash = (base * current_hash + ord(text[i])) % prime_modulus for i in range(text_length - pattern_length + 1): if pattern_hash == current_hash: if text[i:i + pattern_length] == pattern: return i if i < text_length - pattern_length: current_hash = (base * (current_hash - ord(text[i]) * highest_power) + ord(text[i + pattern_length])) % prime_modulus if current_hash < 0: current_hash += prime_modulus return -1"},{"question":"# Objective Given the infinite sequence of all positive integers concatenated as \\"1234567891011121314...\\", your task is to write a function to find the nth digit within this sequence. # Input and Output Formats * **Input**: An integer `n` (1 ≤ n ≤ 2 * 10^9). * **Output**: Return the nth digit as an integer. # Constraints * Consider the limitations of floating-point operations. * Ensure the solution maintains optimal performance with O(log(n)) complexity. # Scenario You are developing a feature for a digital library that needs to access specific digits from a virtual enumeration of all integers. This feature aims to efficiently locate any digit position, even in exceedingly large data contexts. # Function Signature ```python def find_nth_digit(n: int) -> int: # implementation pass ``` # Examples 1. `find_nth_digit(3)` should return `3` 2. `find_nth_digit(11)` should return `0` 3. `find_nth_digit(15)` should return `2` 4. `find_nth_digit(19)` should return `4` **Hint**: Consider the shifting digit lengths contributing to the sequence as you loop through ranges.","solution":"def find_nth_digit(n: int) -> int: Returns the nth digit in the sequence \\"1234567891011121314...\\". length = 1 count = 9 start = 1 # Determine the range in which the nth digit falls while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Find the actual number that contains the nth digit start += (n - 1) // length s = str(start) # Find the digit within that number return int(s[(n - 1) % length])"},{"question":"# Scenario You are tasked with designing a system to merge event logs from multiple servers into a single sorted log. Each server provides a sorted linked list of log entries in real-time, and your goal is to combine all these lists into one continuous sorted log. # Task Write a function `merge_k_logs` that takes in a list of k sorted linked lists, each representing log entries from different servers, and merges them into one sorted linked list. # Input * A list `logs` of k linked lists, where each linked list node contains: * an integer `timestamp` representing the log entry time in seconds. * a reference to the next node in the list. # Output * A single sorted linked list containing all log entries from all k input lists. # Constraints * The total number of log entries (N) across all lists will not exceed 10^5. * Each linked list node will only contain a valid timestamp (integer). # Function Signature ```python class LogNode: def __init__(self, timestamp): self.timestamp = timestamp self.next = None def merge_k_logs(logs: List[LogNode]) -> LogNode: pass ``` # Example **Input** ```python logs = [ LogNode(1) -> LogNode(4) -> LogNode(5), LogNode(1) -> LogNode(3) -> LogNode(4), LogNode(2) -> LogNode(6) ] ``` **Output** ``` LogNode(1) -> LogNode(1) -> LogNode(2) -> LogNode(3) -> LogNode(4) -> LogNode(4) -> LogNode(5) -> LogNode(6) ``` # Notes * Ensure that your solution efficiently merges the lists using the optimal time complexity. * Consider edge cases where input lists might be empty or contain duplicate timestamps.","solution":"import heapq from typing import List class LogNode: def __init__(self, timestamp: int): self.timestamp = timestamp self.next = None def merge_k_logs(logs: List[LogNode]) -> LogNode: min_heap = [] # Helper function to manage heap def listnode_lt(self, other): return self.timestamp < other.timestamp # Assign the new lt function to LogNode LogNode.__lt__ = listnode_lt # Initialize the heap with the head of each list for log in logs: if log: heapq.heappush(min_heap, log) dummy = LogNode(0) current = dummy while min_heap: # Pop the smallest node from the heap smallest = heapq.heappop(min_heap) # Add the smallest node to the merged list current.next = smallest current = current.next # If there\'s a next node in the linked list, add it to the heap if smallest.next: heapq.heappush(min_heap, smallest.next) return dummy.next"},{"question":"Problem Statement You are given a list of distinct integers, `nums`. Write a function `generate_subsets(nums)` that returns all possible subsets of the given list. The solution set must not contain duplicate subsets, and you can return the subsets in any order. Input Format - A list of distinct integers `nums`. Output Format - A list of lists, where each list is a subset of the input list. Constraints - The elements in `nums` are distinct. - The length of `nums` will be in the range `[0, 10]`. Sample Input and Output # Example 1 Input: `[1, 2, 3]` Output: `[[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]`. # Example 2 Input: `[5]` Output: `[[], [5]]`. Performance Requirements Ensure the function runs efficiently within the given constraints, handling the exponential growth in the number of subsets when the list size increases. Implementation Implement the function `generate_subsets(nums)` using both a recursive approach and an iterative approach. Ensure both versions pass the provided test cases and are optimized for readability and performance.","solution":"from itertools import chain, combinations def generate_subsets(nums): Returns all possible subsets of the given list of distinct integers. # Generate all subsets using combinations from itertools def subsets(nums): return list(chain.from_iterable(combinations(nums, r) for r in range(len(nums)+1))) return [list(subset) for subset in subsets(nums)]"},{"question":"Given the graph data structure classes `DirectedGraph`, `DirectedEdge`, and `Node` provided, implement a function that determines if there is a cycle within a directed graph. A cycle in a directed graph is a path that starts and ends at the same node, and traverses at least one edge. # Function Signature: ```python def has_cycle(graph: DirectedGraph) -> bool: pass ``` # Input and Output: * **Input**: * `graph` : an instance of `DirectedGraph` that represents the directed graph. * **Output**: * Returns a boolean value `True` if there is a cycle in the graph, otherwise `False`. # Constraints: * The graph can have multiple disconnected components. * The graph can have zero or more nodes and/or edges. * Node names are unique and non-empty strings. # Example: ```python # Example 1: load_dict1 = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'] } graph1 = DirectedGraph(load_dict1) print(has_cycle(graph1)) # Should return True, cycle A -> B -> C -> A # Example 2: load_dict2 = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [] } graph2 = DirectedGraph(load_dict2) print(has_cycle(graph2)) # Should return False, no cycle in the graph # Example 3: load_dict3 = { \'A\': [\'B\'], \'B\': [\'C\'], \'A1\': [\'B1\'], \'B1\': [\'A1\'] } graph3 = DirectedGraph(load_dict3) print(has_cycle(graph3)) # Should return True, cycle A1 -> B1 -> A1 ``` # Approach: To solve the problem, you should implement a cycle detection algorithm for directed graphs. You may use Depth First Search (DFS) with an additional visited state tracking to detect back edges indicating cycles. Keep track of recursion stack to detect if a node points back to an ancestor. # Detailed Steps: 1. For each node, if it hasn\'t been visited yet, perform a DFS traversal. 2. During DFS, mark the node in recursion stack. 3. If a back edge is found (a node points back to an ancestor in recursion stack), a cycle exists. 4. Mark the node as exited from recursion stack once the DFS for that node completes. 5. Repeat for all nodes in the graph. # Note: Ensure to handle edge cases such as nodes without neighbors and disconnected components in the graph.","solution":"class DirectedGraph: def __init__(self, adjacency_list): self.adjacency_list = adjacency_list def has_cycle(graph: DirectedGraph) -> bool: def dfs(node, visited, rec_stack): visited.add(node) rec_stack.add(node) for neighbor in graph.adjacency_list.get(node, []): if neighbor not in visited: if dfs(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True rec_stack.remove(node) return False visited = set() rec_stack = set() for node in graph.adjacency_list.keys(): if node not in visited: if dfs(node, visited, rec_stack): return True return False"},{"question":"# Question Title: Efficient Sparse Matrix Multiplication Problem Statement: You are given two sparse matrices `A` and `B`, where `A` has dimensions `m x n` and `B` has dimensions `n x k`, and you need to return the product matrix `C = AB`. A sparse matrix is a matrix in which most of the elements are zero. Write a function `multiply_sparse_matrices(A: List[List[int]], B: List[List[int]]) -> List[List[int]]` that performs efficient multiplication of these sparse matrices and returns the resulting matrix `C`. Function Signature: ```python def multiply_sparse_matrices(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: pass ``` Input: * **A**: a list of `m` lists, each containing `n` integers `[a[i][j]]`. * **B**: a list of `n` lists, each containing `k` integers `[b[i][j]]`. Output: * **C**: a list of `m` lists, each containing `k` integers `[c[i][j]]`, representing the product matrix. Constraints: * The number of columns in `A` should be equal to the number of rows in `B`. * `0 <= m, n, k <= 100`. Example: ```python A = [ [1, 0, 0], [-1, 0, 3] ] B = [ [7, 0, 0], [0, 0, 0], [0, 0, 1] ] # Calling the function result = multiply_sparse_matrices(A, B) # Expected result # [ # [7, 0, 0], # [-7, 0, 3] # ] ``` Additional Notes: * Consider using dictionaries to store non-zero elements for both A and B to improve the efficiency of the multiplication. * Use efficient dictionary operations to minimize the number of unnecessary multiplications. * Ensure to handle edge cases including empty matrices and completely zero matrices appropriately.","solution":"from typing import List def multiply_sparse_matrices(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: if not A or not B or not A[0] or not B[0]: return [] m, n = len(A), len(A[0]) nB, k = len(B), len(B[0]) if n != nB: return [] # invalid input # Create a sparse representation of A and B sparse_A = {} sparse_B = {} for i in range(m): for j in range(n): if A[i][j] != 0: if i not in sparse_A: sparse_A[i] = {} sparse_A[i][j] = A[i][j] for i in range(n): for j in range(k): if B[i][j] != 0: if i not in sparse_B: sparse_B[i] = {} sparse_B[i][j] = B[i][j] C = [[0] * k for _ in range(m)] for i in sparse_A: for j in sparse_A[i]: if j in sparse_B: for l in sparse_B[j]: C[i][l] += sparse_A[i][j] * sparse_B[j][l] return C"},{"question":"# Unique Morse Code Representations (Advanced) You are provided with a simplified version of International Morse Code that maps each English letter to a series of dots and dashes. A dictionary for this mapping is provided for your convenience. Given a list of non-empty words, your task is to determine how many unique Morse code transformations you can generate from these words based on the provided Morse code dictionary. Function Signature ```python def unique_morse(words: List[str]) -> int: pass ``` Input - A list of `words` consisting of lowercase English letters, `words[i]` length can vary and will contain alphabets from \'a\' to \'z\' only. Output - Return the number of different Morse code transformations among all words. Constraints - The size of the list `words` is no more than 10^4. - Each word is at least 1 character long and at most 12 characters long. Performance Requirements - The solution should aim for efficient time complexity, ideally `O(N * M)` where `N` is the number of words, and `M` is the average length of a word. - Efficient use of memory should be a consideration. Examples ``` python morse_code_dict = { \'a\':\\".-\\",\'b\':\\"-...\\",\'c\':\\"-.-.\\",\'d\':\\"-..\\",\'e\':\\".\\",\'f\':\\"..-.\\",\'g\':\\"--.\\",\'h\':\\"....\\", \'i\':\\"..\\",\'j\':\\".---\\",\'k\':\\"-.-\\",\'l\':\\".-..\\",\'m\':\\"--\\",\'n\':\\"-.\\",\'o\':\\"---\\",\'p\':\\".--.\\", \'q\':\\"--.-\\",\'r\':\\".-.\\",\'s\':\\"...\\",\'t\':\\"-\\",\'u\':\\"..-\\",\'v\':\\"...-\\",\'w\':\\".--\\",\'x\':\\"-..-\\", \'y\':\\"-.--\\",\'z\':\\"--..\\" } def unique_morse(words: List[str]) -> int: morse_code_dict = { \'a\':\\".-\\",\'b\':\\"-...\\",\'c\':\\"-.-.\\",\'d\':\\"-..\\",\'e\':\\".\\",\'f\':\\"..-.\\",\'g\':\\"--.\\",\'h\':\\"....\\", \'i\':\\"..\\",\'j\':\\".---\\",\'k\':\\"-.-\\",\'l\':\\".-..\\",\'m\':\\"--\\",\'n\':\\"-.\\",\'o\':\\"---\\",\'p\':\\".--.\\", \'q\':\\"--.-\\",\'r\':\\".-.\\",\'s\':\\"...\\",\'t\':\\"-\\",\'u\':\\"..-\\",\'v\':\\"...-\\",\'w\':\\".--\\",\'x\':\\"-..-\\", \'y\':\\"-.--\\",\'z\':\\"--..\\" } unique_transformations = set() for word in words: morse_word = \'\'.join(morse_code_dict[char] for char in word) unique_transformations.add(morse_word) return len(unique_transformations) # Sample usage words = [\\"gin\\", \\"zen\\", \\"gig\\", \\"msg\\"] print(unique_morse(words)) # Output: 2 ``` Explanation - For the input list [\\"gin\\", \\"zen\\", \\"gig\\", \\"msg\\"], \\"gin\\" and \\"zen\\" yield the same transformation \\"--...-.\\", whereas \\"gig\\" and \\"msg\\" yield a different transformation \\"--...--.\\". - There are two unique Morse code transformations in total. Thus, the function returns 2.","solution":"from typing import List def unique_morse(words: List[str]) -> int: morse_code_dict = { \'a\':\\".-\\",\'b\':\\"-...\\",\'c\':\\"-.-.\\",\'d\':\\"-..\\",\'e\':\\".\\",\'f\':\\"..-.\\",\'g\':\\"--.\\",\'h\':\\"....\\", \'i\':\\"..\\",\'j\':\\".---\\",\'k\':\\"-.-\\",\'l\':\\".-..\\",\'m\':\\"--\\",\'n\':\\"-.\\",\'o\':\\"---\\",\'p\':\\".--.\\", \'q\':\\"--.-\\",\'r\':\\".-.\\",\'s\':\\"...\\",\'t\':\\"-\\",\'u\':\\"..-\\",\'v\':\\"...-\\",\'w\':\\".--\\",\'x\':\\"-..-\\", \'y\':\\"-.--\\",\'z\':\\"--..\\" } unique_transformations = set() for word in words: morse_word = \'\'.join(morse_code_dict[char] for char in word) unique_transformations.add(morse_word) return len(unique_transformations)"},{"question":"# Question: Implement an Enhanced Trie with Deletion and Autocomplete Scenario You are tasked to enhance the existing Trie implementation further by adding deletion support and providing a method for auto-completing a given prefix. The goal is to maintain the efficiency of insertion and search operations while adding these new features. Requirements 1. **Insert Method**: Retain as implemented. 2. **Search Method**: Retain as implemented. 3. **StartsWith Method**: Retain as implemented. 4. **Delete Method**: Implement a method to remove a word from the trie. 5. **Autocomplete Method**: Implement a method to return all words in the trie that start with a given prefix. Function Signatures ```python def insert(self, word: str) -> None: Insert a word into the trie. def search(self, word: str) -> bool: Returns if the word is in the trie. def starts_with(self, prefix: str) -> bool: Returns if there is any word in the trie that starts with the given prefix. def delete(self, word: str) -> bool: Deletes a word from the trie if it exists. def autocomplete(self, prefix: str) -> List[str]: Returns all words in the trie that start with the given prefix. ``` Constraints - All words consist of lowercase letters a-z. - Assume inputs to insert and delete are non-empty strings. - The Trie should maintain efficient performance for insert and search operations. Inputs and Outputs - **Insert**: `insert(self, word: str) -> None` - Inserts the word into the trie. - **Search**: `search(self, word: str) -> bool` - Returns `True` if the word is in the trie, `False` otherwise. - **StartsWith**: `starts_with(self, prefix: str) -> bool` - Returns `True` if there is any word in the trie that starts with the given prefix, `False` otherwise. - **Delete**: `delete(self, word: str) -> bool` - Deletes the word from the trie. Returns `True` if the word was deleted; `False` if the word was not found. - **Autocomplete**: `autocomplete(self, prefix: str) -> List[str]` - Returns a list of all words in the trie that start with the given prefix. Example ```python trie = Trie() trie.insert(\\"apple\\") trie.insert(\\"app\\") print(trie.search(\\"apple\\")) # True print(trie.search(\\"app\\")) # True print(trie.starts_with(\\"app\\")) # True print(trie.autocomplete(\\"app\\")) # [\\"apple\\", \\"app\\"] print(trie.delete(\\"apple\\")) # True print(trie.search(\\"apple\\")) # False print(trie.search(\\"app\\")) # True print(trie.autocomplete(\\"app\\")) # [\\"app\\"] ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self._search_node(word) return node is not None and node.is_end_of_word def starts_with(self, prefix: str) -> bool: return self._search_node(prefix) is not None def _search_node(self, word: str): node = self.root for char in word: if char in node.children: node = node.children[char] else: return None return node def delete(self, word: str) -> bool: if not self.search(word): return False self._delete(self.root, word, 0) return True def _delete(self, node, word, depth) -> bool: if depth == len(word): node.is_end_of_word = False return len(node.children) == 0 char = word[depth] if char in node.children: can_delete = self._delete(node.children[char], word, depth + 1) if can_delete: del node.children[char] return len(node.children) == 0 return False def autocomplete(self, prefix: str): results = [] node = self._search_node(prefix) if node: self._dfs(node, prefix, results) return results def _dfs(self, node, prefix, results): if node.is_end_of_word: results.append(prefix) for char, child_node in node.children.items(): self._dfs(child_node, prefix + char, results)"},{"question":"# Insertion Point in Sorted Array Problem Description Given a sorted array `arr` of distinct integers and an integer `target`, write a function `get_insert_position(arr, target)` that finds the index where `target` should be inserted in order to maintain the array sorted. If `target` is already present in the array, return its current index. Input - `arr`: A list of integers, where -10^4 ≤ arr[i] ≤ 10^4. It is guaranteed that the list is sorted in ascending order and contains no duplicates. - `target`: An integer, where -10^4 ≤ target ≤ 10^4. Output - An integer representing the index where `target` should be inserted to keep the array sorted. Constraints - The list `arr` is sorted. - The function should execute with a time complexity of O(log n). Examples 1. `get_insert_position([1, 3, 5, 6], 5)` should return `2` 2. `get_insert_position([1, 3, 5, 6], 2)` should return `1` 3. `get_insert_position([1, 3, 5, 6], 7)` should return `4` 4. `get_insert_position([1, 3, 5, 6], 0)` should return `0` 5. `get_insert_position([], 1)` should return `0` 6. `get_insert_position([1], 0)` should return `0` Function Signature ```python def get_insert_position(arr: List[int], target: int) -> int: pass ``` Ensure your implementation is efficient and handles all edge cases correctly.","solution":"def get_insert_position(arr, target): Returns the index where the target should be inserted in the sorted array to maintain the order. If the target is already in the array, its current index is returned. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"Context You are developing a program that processes lists of mixed data types. As part of this task, you must implement a function that takes an array and moves all zero values to the end without altering the order of non-zero elements. Keep in mind that boolean `False` and other non-zero falsy values such as empty list `[]` should not be considered zeroes. Requirements Write a function `move_zeros` that adheres to the following specifications: * **Input**: A list of mixed data types (integers, strings, booleans, etc.) ```python def move_zeros(array: list) -> list: ``` * **Output**: A list with the same elements as the input, but with all zeroes moved to the end and maintaining the order of other elements. * **Constraints**: * Do not use external libraries. * The input array can be empty. * Non-zero falsy values (like `False`) should remain in their original position. * Performance should be efficient, ideally with linear time complexity. * **Example**: ```python move_zeros([False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"]) # Should return [False, 1, 1, 2, 1, 3, \'a\', 0, 0] ``` * **Edge Cases**: * Test with an array that contains no zeroes. * Test with an array that contains only zeroes. * Test with an array that contains different types including integers, booleans, and strings. Additional Notes Provide a brief explanation of how your code handles edge cases and why your solution is efficient in terms of both time and space complexity.","solution":"def move_zeros(array): This function takes a list and moves all zero values to the end while maintaining the existing order of non-zero elements. non_zeros = [x for x in array if not(x == 0 and x is not False)] zeros = [x for x in array if x == 0 and x is not False] return non_zeros + zeros"},{"question":"Context Software applications often require navigation through a set of hierarchical decisions or states, each represented as nodes connected in a tree-like structure. Your task is to implement a function that collects and prints all possible paths from the root to the leaf nodes in a binary tree. Task Implement a function `collect_binary_tree_paths(root: TreeNode) -> List[str]` that, given the root of a binary tree, returns all root-to-leaf paths in the tree. Input * The root node of the binary tree. Output * A list of strings, where each string represents a distinct root-to-leaf path. Each path is formatted as a string with node values separated by arrows (\\"->\\"). Constraints * The number of nodes in the binary tree is between 1 and 1000. * Each node\'s value is a unique integer. Example ```python # Binary Tree Representation: # 1 # / # 2 3 # # 5 # Expected output: [\\"1->2->5\\", \\"1->3\\"] class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def collect_binary_tree_paths(root: TreeNode) -> List[str]: # Implement this function. pass # Example Usage: root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(5) print(collect_binary_tree_paths(root)) # Output: [\\"1->2->5\\", \\"1->3\\"] ``` Performance Considerations * Make sure the function efficiently handles up to the maximum constraint on the number of nodes. * Consider both time and space complexity when designing the solution.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def collect_binary_tree_paths(root: TreeNode) -> list: def dfs(node, path, paths): if node: path.append(str(node.val)) if not node.left and not node.right: # if it\'s a leaf paths.append(\\"->\\".join(path)) else: dfs(node.left, path, paths) dfs(node.right, path, paths) path.pop() paths = [] dfs(root, [], paths) return paths"},{"question":"You are asked to write a function that returns a list of numbers from 1 to N. However, there are specific rules to modify the output based on the following conditions: 1. Replace numbers divisible by 3 with the string \\"Fizz\\". 2. Replace numbers divisible by 5 with the string \\"Buzz\\". 3. Replace numbers divisible by both 3 and 5 with the string \\"FizzBuzz\\". # Implementation Details: * Implement the function `custom_fizzbuzz(n: int) -> List[Union[int, str]]` * **Input**: A single integer `n` (1 <= n <= 10^4) * **Output**: A list of integers and strings based on the rules above. * **Constraints**: - `n` will always be an integer. - `n` will have a positive value with an upper limit of 10,000. - The function should handle potential exceptions minimally and gracefully. # Example: ```python assert custom_fizzbuzz(5) == [1, 2, \\"Fizz\\", 4, \\"Buzz\\"] assert custom_fizzbuzz(15) == [1, 2, \\"Fizz\\", 4, \\"Buzz\\", \\"Fizz\\", 7, 8, \\"Fizz\\", \\"Buzz\\", 11, \\"Fizz\\", 13, 14, \\"FizzBuzz\\"] ``` # Guidelines: 1. Ensure the solution is efficient and handles edge cases, such as passing minimal valid input (n=1). 2. Consider modularization for readability and maintainability. 3. Avoid unnecessary computations or complex logic.","solution":"from typing import List, Union def custom_fizzbuzz(n: int) -> List[Union[int, str]]: Returns a list of numbers from 1 to n, with multiples of 3 replaced by \\"Fizz\\", multiples of 5 replaced by \\"Buzz\\", and multiples of both replaced by \\"FizzBuzz\\". result = [] for i in range(1, n + 1): if i % 15 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(i) return result"},{"question":"# Scenario You are a software engineer tasked with ensuring the integrity of a digital system that assigns unique IDs to user accounts. You need to implement a function to identify any missing user ID in a sequence or determine the next available ID if none are missing. # Task Write a function `find_missing_number` that takes a list of unique integer IDs ranging from `0` to `n`, but with one ID possibly missing, and returns the missing ID. If no IDs are missing, it should return the next expected ID (`n+1`). # Function Signature ```python def find_missing_number(nums: List[int]) -> int: pass ``` # Input * `nums` (List[int]): A list of unique integers in the range `[0..n]`. # Output * (int): The missing integer from the sequence, or `n+1` if the sequence is complete. # Constraints * The list will contain unique integers and should be treated as a sequence from `0` to `n` with at most one missing number. * `0 <= len(nums) <= 10^6` * The length of the list `nums` will determine the range `n`. # Example ```python # Example 1 nums = [4, 1, 3, 0, 6, 5, 2] print(find_missing_number(nums)) # Output: 7 # Example 2 nums = [0, 1, 2, 3] print(find_missing_number(nums)) # Output: 4 # Example 3 nums = [3, 0, 1] print(find_missing_number(nums)) # Output: 2 ``` # Note Ensure your function is optimized for time complexity O(n) and space complexity O(1).","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Find the missing number in the sequence from 0 to n, or return n+1 if no number is missing. n = len(nums) expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) missing_number = expected_sum - actual_sum return missing_number"},{"question":"# ArrayStack and LinkedListStack Implementations\' Comparison Given the `ArrayStack` and `LinkedListStack` classes, you are required to write a function that demonstrates the use of each stack type and evaluates their performance differences for a set of operations. The function must: 1. Create an instance of each stack type (`ArrayStack` and `LinkedListStack`). 2. Perform a series of push operations followed by pop operations. 3. Capture the time taken for all operations on each stack. 4. Compare the performance (time taken) of both implementations. # Function Signature ```python def compare_stack_performance(n: int) -> dict: Compare performance of ArrayStack and LinkedListStack. Parameters: n (int): Number of push/pop operations to test Returns: dict: Dictionary with performance time for both stack implementations ``` # Inputs and Outputs * **Input**: * `n`: An integer representing the number of push and pop operations to be performed on each stack. * **Output**: * A dictionary with keys `ArrayStack` and `LinkedListStack` and their corresponding total operation time as strings. # Constraints * `1 <= n <= 10^6` # Example ```python result = compare_stack_performance(1000) print(result) # Output: # { # \'ArrayStack\': \'0.00050s\', # \'LinkedListStack\': \'0.00040s\' # } ``` # Notes * The time for each operation should be calculated using Python\'s `time` library. * Use the classes `ArrayStack` and `LinkedListStack` as provided.","solution":"import time class ArrayStack: def __init__(self): self.items = [] def push(self, item): self.items.append(item) def pop(self): if not self.is_empty(): return self.items.pop() return None def is_empty(self): return len(self.items) == 0 class LinkedListStack: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self): self.head = None def push(self, item): new_node = self.Node(item) new_node.next = self.head self.head = new_node def pop(self): if not self.is_empty(): value = self.head.value self.head = self.head.next return value return None def is_empty(self): return self.head is None def compare_stack_performance(n: int) -> dict: array_stack = ArrayStack() linked_list_stack = LinkedListStack() # Timing ArrayStack start_time = time.time() for i in range(n): array_stack.push(i) for i in range(n): array_stack.pop() array_stack_time = time.time() - start_time # Timing LinkedListStack start_time = time.time() for i in range(n): linked_list_stack.push(i) for i in range(n): linked_list_stack.pop() linked_list_stack_time = time.time() - start_time return { \'ArrayStack\': f\'{array_stack_time:.5f}s\', \'LinkedListStack\': f\'{linked_list_stack_time:.5f}s\' } # Example usage: # result = compare_stack_performance(1000) # print(result) # Output: # { # \'ArrayStack\': \'0.00050s\', # \'LinkedListStack\': \'0.00040s\' # }"},{"question":"Roman Numeral Conversion You are to write a function that converts a given integer into its corresponding Roman numeral representation. **Function Signature**: ```python def int_to_roman(num: int) -> str: ``` **Constraints**: - The input integer will be in the range from 1 to 3999, inclusive. # Input - An integer `num` within the range of 1 to 3999. # Output - A string representing the Roman numeral corresponding to the integer `num`. # Example ```python assert int_to_roman(1) == \\"I\\" assert int_to_roman(4) == \\"IV\\" assert int_to_roman(3999) == \\"MMMCMXCIX\\" ``` # Guidelines - Use the predefined Roman numeral mappings for thousands, hundreds, tens, and units as demonstrated in the analysis. - Ensure your solution handles all edge cases within the valid range. - Avoid using loops or auxiliary data structures to maintain the constant time complexity of the solution. # Scenario You are building a historical data processing system that needs to convert event years and other numerics into their Roman numeral forms for aesthetic display purposes.","solution":"def int_to_roman(num: int) -> str: Converts an integer to its Roman numeral representation. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] symbols = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_numeral = \\"\\" i = 0 while num > 0: for _ in range(num // val[i]): roman_numeral += symbols[i] num -= val[i] i += 1 return roman_numeral"},{"question":"Implement a Cuckoo Hash Table In this assessment, you are required to implement a Cuckoo Hash Table, a variant of hash tables designed to handle high load situations and collisions more efficiently by using multiple hash functions. Requirements: 1. **Insert**: Insert a key-value pair into the hash table. If it collides with an existing key, use a second hash function to find an alternative location. 2. **Get**: Retrieve the value associated with a key. 3. **Delete**: Remove a key-value pair. Functions to Implement: ```python class CuckooHashTable: def __init__(self, size=11): pass def put(self, key, value): pass def get(self, key): pass def delete(self, key): pass ``` Constraints: * Keys and values will be non-negative integers. * The table should resize (double in size) when more than two-thirds full. * Handle and avoid infinite loops due to simultaneous collisions during insertion. # Example: ```python hash_table = CuckooHashTable(size=11) hash_table.put(1, \'value1\') hash_table.put(12, \'value12\') print(hash_table.get(1)) # Output: \'value1\' print(hash_table.get(12)) # Output: \'value12\' hash_table.delete(1) print(hash_table.get(1)) # Output: None ``` Notes: 1. Implement two different hash functions for determining storage indices. 2. Properly manage the table size and handle resizing (rehashing all items) when it becomes too full. 3. Ensure the Cuckoo Hash table does not enter an infinite loop by managing cycles properly during insertion.","solution":"class CuckooHashTable: def __init__(self, size=11): self.size = size self.table1 = [None] * size self.table2 = [None] * size self.count = 0 def hash1(self, key): return key % self.size def hash2(self, key): return (key // self.size) % self.size def rehash(self): old_table1 = self.table1 old_table2 = self.table2 self.size *= 2 self.table1 = [None] * self.size self.table2 = [None] * self.size self.count = 0 for pair in old_table1 + old_table2: if pair: self.put(pair[0], pair[1]) def put(self, key, value): if self.count / self.size >= 2 / 3: self.rehash() for _ in range(self.size): index1 = self.hash1(key) if self.table1[index1] is None: self.table1[index1] = (key, value) self.count += 1 return key, value, self.table1[index1] = self.table1[index1][0], self.table1[index1][1], (key, value) index2 = self.hash2(key) if self.table2[index2] is None: self.table2[index2] = (key, value) self.count += 1 return key, value, self.table2[index2] = self.table2[index2][0], self.table2[index2][1], (key, value) self.rehash() self.put(key, value) def get(self, key): index1 = self.hash1(key) if self.table1[index1] and self.table1[index1][0] == key: return self.table1[index1][1] index2 = self.hash2(key) if self.table2[index2] and self.table2[index2][0] == key: return self.table2[index2][1] return None def delete(self, key): index1 = self.hash1(key) if self.table1[index1] and self.table1[index1][0] == key: self.table1[index1] = None self.count -= 1 return index2 = self.hash2(key) if self.table2[index2] and self.table2[index2][0] == key: self.table2[index2] = None self.count -= 1"},{"question":"**Context**: You are working on a data analytics project where you need to analyze customer survey data. One of the tasks is to determine the most frequently mentioned feature that customers like or dislike the most. **Question**: Implement a function `find_modes(arr: List[Any]) -> List[Any]` that takes a list of elements and returns a list of the mode(s)—the most frequently occurring element(s). Input: * `arr` (List[Any]): A list of elements of any comparable type (integers, strings, etc.). The length of the list can be zero or more. Output: * List[Any]: A list of the mode(s). If multiple elements are tied for the highest frequency, all of them should be included. If the input list is empty, the output should be an empty list. Constraints: * Elements in `arr` can be of any type that is hashable. * The function should handle both small and large lists efficiently. * The implementation should be able to handle edge cases gracefully. Performance Requirement: The algorithm should run in linear time relative to the length of the input list, i.e., O(n). Examples: 1. `find_modes([1, 1, 2, 2, 3, 4])` should return `[1, 2]`. 2. `find_modes([\'apple\', \'banana\', \'apple\', \'orange\', \'banana\', \'apple\'])` should return `[\'apple\']`. 3. `find_modes([])` should return `[]`. 4. `find_modes([\'a\', \'b\', \'b\', \'b\', \'a\', \'a\', \'c\'])` should return `[\'a\', \'b\']`. ```python # Write your code here from typing import List, Any def find_modes(arr: List[Any]) -> List[Any]: pass ``` **Notes**: * Consider handling the edge cases such as an empty list and elements with the same frequency comprehensively. * Efficient memory usage and avoiding unnecessary computations will be considered in evaluation.","solution":"from typing import List, Any from collections import Counter def find_modes(arr: List[Any]) -> List[Any]: if not arr: return [] element_counts = Counter(arr) max_frequency = max(element_counts.values()) return [elem for elem, count in element_counts.items() if count == max_frequency]"},{"question":"# Merge Verification Algorithm **Context:** You are working on a text processing tool that needs to verify if a specific string can be created as a merge of two other strings. A merge of two strings is defined such that characters from the two strings are interleaved while maintaining their order. **Task:** Write a function `is_merge_combined` that determines if string `s` is a valid merge of string `part1` and string `part2`. **Function Signature:** ```python def is_merge_combined(s: str, part1: str, part2: str) -> bool: # Write your implementation here ``` **Parameters:** - `s` (str): The target string to be formed. - `part1` (str): The first part string. - `part2` (str): The second part string. **Returns:** - `bool`: Return `True` if `s` is a valid merge of `part1` and `part2`, otherwise return `False`. **Constraints:** - The length of the strings will not exceed 1000 characters. - All strings contain only lowercase English letters. **Examples:** 1. ```python print(is_merge_combined(\\"codewars\\", \\"cdw\\", \\"oears\\")) # Output: True ``` 2. ```python print(is_merge_combined(\\"codewars\\", \\"cdwr\\", \\"aeor\\")) # Output: False ``` **Notes:** - Characters in `part1` and `part2` must appear in the same order as in `s`. - Consider edge cases where one or both of `part1` and `part2` are empty. - Optimize your solution to handle larger inputs efficiently.","solution":"def is_merge_combined(s: str, part1: str, part2: str) -> bool: # If the combined length of part1 and part2 isn\'t equal to s, it\'s not a valid merge if len(s) != len(part1) + len(part2): return False # Create a table to store results of subproblems dp = [[False] * (len(part2) + 1) for _ in range(len(part1) + 1)] dp[0][0] = True # Initialize the table for the case where part1 is empty for i in range(1, len(part2) + 1): dp[0][i] = dp[0][i - 1] and part2[i - 1] == s[i - 1] # Initialize the table for the case where part2 is empty for i in range(1, len(part1) + 1): dp[i][0] = dp[i - 1][0] and part1[i - 1] == s[i - 1] # Fill the table for other cases for i in range(1, len(part1) + 1): for j in range(1, len(part2) + 1): dp[i][j] = (dp[i - 1][j] and part1[i - 1] == s[i + j - 1]) or (dp[i][j - 1] and part2[j - 1] == s[i + j - 1]) return dp[len(part1)][len(part2)]"},{"question":"# Polynomial Class Challenge You are given the `Monomial` and `Polynomial` classes, representing mathematical monomials and polynomials. The provided implementation supports a variety of algebraic operations. Your task is to implement a function `differentiate_polynomial(polynomial: Polynomial, variable: int) -> Polynomial` that differentiates a given polynomial with respect to a given variable. Input: - **polynomial**: an instance of `Polynomial`. - **variable**: an integer representing the variable with respect to which differentiation is to be performed. Output: - Returns a new `Polynomial` instance representing the differentiated polynomial. Example: ```python # Example polynomials p = Polynomial([ Monomial({1: 2}, 3), # 3(a_1)^2 Monomial({1: 1, 2: 2}, 4), # 4(a_1)(a_2)^2 Monomial({3: 3}, -5) # -5(a_3)^3 ]) # Differentiating with respect to variable 1 dp = differentiate_polynomial(p, 1) # Expected output: # dp should represent the polynomial: 6(a_1) + 4(a_2)^2 ``` Constraints: - It is guaranteed that the given polynomial is non-null and all monomials within it are valid. Notes: - Implement the differentiation rules for monomials and extend them to polynomials: - The derivative of `cx^n` with respect to `x` is `cnx^(n-1)`. - Differentiate each monomial within the polynomial and sum the results. Implement the function `differentiate_polynomial` which differentiates a polynomial by a given variable:","solution":"class Monomial: def __init__(self, exponents, coefficient): self.exponents = exponents # Dictionary: {variable: exponent} self.coefficient = coefficient def differentiate(self, variable): if variable in self.exponents: new_exponents = self.exponents.copy() if self.exponents[variable] == 1: del new_exponents[variable] else: new_exponents[variable] -= 1 new_coefficient = self.coefficient * self.exponents[variable] return Monomial(new_exponents, new_coefficient) else: return Monomial({}, 0) class Polynomial: def __init__(self, monomials): self.monomials = monomials # List of Monomial instances def differentiate(self, variable): differentiated_monomials = [monomial.differentiate(variable) for monomial in self.monomials] non_zero_monomials = [m for m in differentiated_monomials if m.coefficient != 0] return Polynomial(non_zero_monomials) def differentiate_polynomial(polynomial, variable): Differentiates the given polynomial with respect to the given variable. :param polynomial: Polynomial instance to be differentiated :param variable: integer representing the variable with respect to which differentiation is to be performed :return: differentiated Polynomial instance return polynomial.differentiate(variable)"},{"question":"<|Analysis Begin|> **Algorithm/Data Structure**: Depth First Search (DFS) and Breadth First Search (BFS) are graph traversal algorithms. # Core Identification * **Algorithm/Data Structure**: DFS and BFS - **Type**: Graph traversal algorithms - **Main Purpose**: Visit all nodes in a graph in a specific order, useful for searching, pathfinding, and discovering connectivity components. # Complexity * **DFS**: - **Time Complexity**: O(V + E) where V is the number of vertices and E is the number of edges. - **Space Complexity**: O(V) due to the stack/recursion call stack. * **BFS**: - **Time Complexity**: O(V + E) - **Space Complexity**: O(V) due to the queue. # Principles * **DFS**: - Uses a stack structure (either explicitly or via recursion) to explore as far as possible along each branch before backtracking. * **BFS**: - Uses a queue to explore all nodes at the present depth level before moving on to nodes at the next depth level. # Characteristics & Applications * **Properties**: - **DFS**: Can be used to classify edges of a graph, check for cycles, topological sorting. - **BFS**: Finds shortest path in an unweighted graph, level-order traversal. * **Common Use Cases**: - **DFS**: Pathfinding, cycle detection, topological sorting in directed graphs. - **BFS**: Finding shortest paths, evaluating connectivity in graphs, level-order traversal. * **Strengths/Limitations**: - **DFS**: - Strengths: Simple implementation, good for problems requiring exploring all paths. - Limitations: Can get stuck in deep paths, high recursive call stack in deep graphs. - **BFS**: - Strengths: Finds shortest path in unweighted graphs. - Limitations: Uses more memory compared to DFS due to maintaining the queue. # Implementation Challenges * **Edge Cases**: - Disconnected graphs. - Graphs with cycles. - Single node graphs. - Large graphs causing stack overflow in recursive DFS. * **Performance Bottlenecks**: - High memory usage in BFS for large graphs. - Deep recursion calls in DFS for deep graphs. * **Error Scenarios**: - Handling nodes with no outgoing edges correctly (leaf nodes). - Ensuring all nodes are visited even in disconnected graphs. * **Optimization Points**: - Use iterative DFS to prevent stack overflow in large graphs. - Optimize BFS queue operations for large graph traversal. <|Analysis End|> <|Question Begin|> # Question: You are given an undirected graph represented as an adjacency list. The graph may be disconnected, meaning not all vertices are reachable from a single starting point. Implement a function that performs both DFS and BFS traversal starting from a given node, but ensures that all nodes in the graph are visited even if they are in disconnected components. **Input**: - An adjacency list representation of the graph, e.g., `graph = {0: [1, 2], 1: [0], 2: [0], 3: []}`. - An integer `start` representing the starting node for traversal. **Output**: - Two sets: - A set of nodes visited using DFS traversal. - A set of nodes visited using BFS traversal. **Constraints**: - The graph is an undirected graph. - The number of nodes can be up to 10^3. - Nodes are labeled with non-negative integers and the graph is represented using adjacency lists. **Example**: ```python graph = { 0: [1, 2], 1: [0], 2: [0], 3: [] } start = 0 dfs_visited, bfs_visited = traverse_complete_graph(graph, start) print(\\"DFS Visited:\\", dfs_visited) # Output should include all nodes {0, 1, 2, 3} print(\\"BFS Visited:\\", bfs_visited) # Output should include all nodes {0, 1, 2, 3} ``` **Solution Template**: ```python def traverse_complete_graph(graph, start): def dfs_complete(graph, node, visited): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) for next_node in graph[current]: if next_node not in visited: stack.append(next_node) return visited def bfs_complete(graph, node, visited): queue = [node] while queue: current = queue.pop(0) if current not in visited: visited.add(current) for next_node in graph[current]: if next_node not in visited: queue.append(next_node) return visited visited_dfs = set() visited_bfs = set() for node in graph: if node not in visited_dfs: visited_dfs = dfs_complete(graph, node, visited_dfs) if node not in visited_bfs: visited_bfs = bfs_complete(graph, node, visited_bfs) return visited_dfs, visited_bfs ```","solution":"def traverse_complete_graph(graph, start): def dfs_complete(graph, node, visited): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) for next_node in graph[current]: if next_node not in visited: stack.append(next_node) return visited def bfs_complete(graph, node, visited): queue = [node] while queue: current = queue.pop(0) if current not in visited: visited.add(current) for next_node in graph[current]: if next_node not in visited: queue.append(next_node) return visited visited_dfs = set() visited_bfs = set() for node in graph: if node not in visited_dfs: visited_dfs = dfs_complete(graph, node, visited_dfs) if node not in visited_bfs: visited_bfs = bfs_complete(graph, node, visited_bfs) return visited_dfs, visited_bfs"},{"question":"Implement an RSA Key Generation Function Context: You are tasked with designing a simplified RSA public and private key generation script. RSA relies on the Extended Euclidean Algorithm for modular inverse calculations. Objective: Write a Python function `generate_rsa_keys(p: int, q: int) -> Tuple[Tuple[int, int], Tuple[int, int]]` to generate RSA keys. `p` and `q` are distinct prime numbers. The output should be two tuples representing public and private keys respectively. The public key tuple should be `(n, e)` and the private key `(n, d)`. # Requirements: - Implement the given `extended_gcd` and `modular_inverse` as helper functions. - Ensure the resultant public key `e` is such that `1 < e < φ(n)` and gcd(e, φ(n)) = 1, where `φ(n) = (p-1) * (q-1)`. - `d` should be computed using the modular inverse of `e` modulo φ(n). # Input and Output Format: Input: - Two integers `p` and `q`, both primes. Output: - A tuple with two tuples: the first tuple is the public key (n, e), and the second is the private key (n, d). # Constraints: - `1 < p, q < 10^6` - `p` and `q` are prime and distinct. # Example: For `p = 61` and `q = 53`: ```python public_key, private_key = generate_rsa_keys(61, 53) # Expected: public_key = (n, e), private_key = (n, d) with valid RSA properties. ```","solution":"import random from typing import Tuple def extended_gcd(a: int, b: int) -> Tuple[int, int, int]: if a == 0: return b, 0, 1 gcd, x1, y1 = extended_gcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return gcd, x, y def modular_inverse(e: int, phi: int) -> int: gcd, x, y = extended_gcd(e, phi) if gcd != 1: raise ValueError(\'Modular inverse does not exist\') return x % phi def generate_rsa_keys(p: int, q: int) -> Tuple[Tuple[int, int], Tuple[int, int]]: if p == q: raise ValueError(\'The prime numbers p and q must be distinct\') n = p * q phi = (p - 1) * (q - 1) e = random.randrange(2, phi) g = extended_gcd(e, phi)[0] while g != 1: e = random.randrange(2, phi) g = extended_gcd(e, phi)[0] d = modular_inverse(e, phi) return (n, e), (n, d)"},{"question":"# Bogo Sort Extension Context: Bogo Sort is a highly inefficient algorithm due to its randomized approach to sorting. While Bogo Sort is not practical for real-world sorting tasks, it can be modified to create a new hypothetical sorting algorithm for educational purposes. Your task is to implement a modified version of Bogo Sort, called **Modified Bogo Sort**. In this version, instead of randomly shuffling the entire array, you will randomly select two indices and swap their elements, repeating this process until the array is sorted. Requirements: 1. Implement the **Modified Bogo Sort** algorithm. 2. The function should take an array and perform sorting using the described modification. 3. Ensure the function thoroughly checks the array to determine if it is sorted each iteration. Function Signature: ```python def modified_bogo_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` Input: - `arr`: List of integers to be sorted. - `simulation`: A boolean flag that, if set to `True`, prints the array\'s state after each iteration for visualization. Output: - The sorted list of integers. Constraints: - Your solution should handle edge cases like empty arrays or arrays with one element efficiently. - There are no constraints on the maximum size of the array, but be mindful of performance due to the nature of Bogo Sort. Example: ```python arr = [3, 1, 4, 2] sorted_arr = modified_bogo_sort(arr, simulation=True) print(sorted_arr) # Output should be a sorted list: [1, 2, 3, 4] ```","solution":"import random from typing import List def is_sorted(arr: List[int]) -> bool: Helper function to check if the array is sorted. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def modified_bogo_sort(arr: List[int], simulation: bool = False) -> List[int]: Implements the Modified Bogo Sort algorithm. while not is_sorted(arr): i, j = random.sample(range(len(arr)), 2) # Swap elements at indices i and j arr[i], arr[j] = arr[j], arr[i] if simulation: print(arr) return arr"},{"question":"Given a string, you need to write a function `remove_reoccurring_characters` that deletes any reoccurring character, and returns the new string with only the first occurrence of each character. Function Signature ```python def remove_reoccurring_characters(s: str) -> str: ``` Input - A single string `s` with a maximum length of (10^6). Output - A new string with all duplicate characters removed, preserving the order of their first appearance. Constraints - The input string can contain any printable ASCII characters. - The function should handle an empty input string gracefully and simply return an empty string. Example ```python assert remove_reoccurring_characters(\\"google\\") == \\"gole\\" assert remove_reoccurring_characters(\\"programming\\") == \\"progamin\\" assert remove_reoccurring_characters(\\"\\") == \\"\\" assert remove_reoccurring_characters(\\"abcabcabc\\") == \\"abc\\" ``` Performance Requirements - Your solution should run in linear time, (O(n)), where (n) is the length of the input string. - The space complexity should also be linear relative to the size of the input. Context This problem is a common preprocessing step, often useful in data cleaning tasks where duplicate entries need to be removed while preserving the original order of elements. It is also a typical interview question to test understanding of hash sets and string manipulation.","solution":"def remove_reoccurring_characters(s: str) -> str: Removes reoccurring characters from the string s, returning a new string with only the first occurrence of each character. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"Overview Given two singly linked lists, determine the node at which they intersect, if any. An intersection is defined by reference and not value, meaning that the nodes are identical by reference (memory address) rather than having the same data. Function Signature Implement the following function: ```python def intersection(head1: Optional[Node], head2: Optional[Node]) -> Optional[Node]: # implementation ``` Input - `head1`: Head node of first linked list (Type: `Node` or `None`) - `head2`: Head node of second linked list (Type: `Node` or `None`) Output - The node at which the two linked lists intersect. If they do not intersect at any point, return `None`. (Type: `Optional[Node]`) Constraints - The function should have a time complexity of O(n + m), where n and m are the lengths of the two linked lists. - The function should use O(1) additional space. Example Suppose you have two linked lists represented as: ``` List1: 1 -> 2 -> 3 6 -> 7 -> 8 / List2: 4 -> 5 ``` In this case, the lists are intersecting at node with value `6`, so the function should return the node containing `6`. Approach 1. Traverse both lists to find their lengths. 2. Align the lists by advancing the pointer of the longer list by the difference in lengths. 3. Traverse both lists simultaneously to find the intersection point. Edge Cases - Test for non-intersecting lists. - Both lists are `None`. - Intersection occurs at the head of the lists. Implement your solution and ensure it handles these conditions correctly.","solution":"class Node: def __init__(self, data=0, next=None): self.data = data self.next = next def intersection(head1: Node, head2: Node) -> Node: Finds the intersection node of two singly linked lists. If they do not intersect, returns None. if not head1 or not head2: return None # Helper function to get the length of a list. def get_length(head): length = 0 current = head while current: length += 1 current = current.next return length # Get the lengths of both lists. len1 = get_length(head1) len2 = get_length(head2) # Align the start of both lists. diff = abs(len1 - len2) if len1 > len2: for _ in range(diff): head1 = head1.next else: for _ in range(diff): head2 = head2.next # Traverse both lists together until we find the intersection or reach the end. while head1 and head2: if head1 == head2: return head1 head1 = head1.next head2 = head2.next return None"},{"question":"# Ordered Stack Implementation and Operations You are tasked with implementing an ordered version of a stack, where the stack is always maintained in non-decreasing order. You will extend the provided `OrderedStack` class to include additional functionalities and ensure the stack remains ordered after each operation. **Objective** 1. Extend the `OrderedStack` class to implement the following additional functionalities: - `insert_at_bottom(item)`: Inserts an item at the bottom of the stack. - `delete_min()`: Removes and returns the smallest element from the stack. 2. Ensure that the stack remains ordered after each operation. **Input and Output Formats** - **Function**: `insert_at_bottom(item)` - **Input**: An integer item to be inserted at the bottom of the stack. - **Output**: None. - **Function**: `delete_min()` - **Input**: None. - **Output**: The smallest integer element from the stack. **Constraints** - The stack only stores integer values. - Duplicate values are allowed in the stack. - The stack must remain ordered after every operation. **Performance Requirements** - The `insert_at_bottom(item)` operation should take O(n) time complexity in the worst case. - The `delete_min()` operation should take O(1) time as the minimum element should always be at the bottom if the stack is maintained properly. **Scenario** Consider a scenario where you are managing a list of student grades in non-decreasing order. You can only access the stack through the top. However, you need to frequently insert grades at the bottom (oldest grades remain at the bottom) and remove the lowest grade. **Example** ```python stack = OrderedStack() stack.push(10) stack.push(30) stack.push(20) stack.insert_at_bottom(5) # Stack becomes [5, 10, 20, 30] min_element = stack.delete_min() # min_element = 5, Stack becomes [10, 20, 30] ``` Implement and test the `OrderedStack` class with the required functionalities.","solution":"class OrderedStack: def __init__(self): self.stack = [] def push(self, item): if not self.stack or item >= self.stack[-1]: self.stack.append(item) else: temp = [] while self.stack and self.stack[-1] > item: temp.append(self.stack.pop()) self.stack.append(item) while temp: self.stack.append(temp.pop()) def pop(self): if not self.stack: raise IndexError(\\"pop from empty stack\\") return self.stack.pop() def peek(self): if not self.stack: raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def is_empty(self): return len(self.stack) == 0 def insert_at_bottom(self, item): if self.is_empty(): self.push(item) else: top_item = self.pop() self.insert_at_bottom(item) self.push(top_item) def delete_min(self): if self.is_empty(): raise IndexError(\\"delete_min from empty stack\\") return self.stack.pop(0)"},{"question":"# Question: You are provided with the implementation of preorder traversal for a binary tree, both iteratively and recursively. Your task is to: 1. Implement a function to perform the preorder traversal of a binary tree in a non-recursive manner without using extra space, retaining the same order of operations (i.e., root first, then left subtree, followed by the right subtree). 2. Improve the given recursive implementation by having it return a generator which yields nodes in preorder, instead of a list of node values. This will help in saving space and can be more efficient in some use cases. **Input Format:** - A binary tree represented by its root node. **Output Format:** - For the iterative function: A list of node values in preorder. - For the recursive generator: Node values yielded in preorder sequence. **Constraints:** - The binary tree can have up to 10^5 nodes. - Node values are integers and may repeat. **Performance Requirements:** - Time Complexity: O(n). - Space Complexity: Should be no extra space for non-recursive implementation and O(h) recursion stack space for the generator, where h is the height of the tree. Function Signatures: ```python def preorder_no_extra_space(root: Node) -> List[int]: # Implement this function to perform preorder traversal # using a constant amount of space. pass def preorder_generator(root: Node): # Implement this function to create a generator for preorder traversal. pass ``` **Examples:** ```python # Example 1: # 1 # # 2 # / # 3 root = Node(1) root.right = Node(2) root.right.left = Node(3) print(preorder_no_extra_space(root)) # Output: [1, 2, 3] print(list(preorder_generator(root))) # Output: [1, 2, 3] # Example 2: # 4 # / # 2 5 # / #1 3 6 root = Node(4) root.left = Node(2) root.right = Node(5) root.left.left = Node(1) root.left.right = Node(3) root.right.right = Node(6) print(preorder_no_extra_space(root)) # Output: [4, 2, 1, 3, 5, 6] print(list(preorder_generator(root))) # Output: [4, 2, 1, 3, 5, 6] ```","solution":"class Node: def __init__(self, value: int): self.value = value self.left = None self.right = None def preorder_no_extra_space(root: Node) -> list: Perform a preorder traversal of the binary tree without using extra space. result = [] current = root while current is not None: if current.left is None: result.append(current.value) current = current.right else: # Find the inorder predecessor of current pre = current.left while pre.right is not None and pre.right is not current: pre = pre.right if pre.right is None: # Make current as the right child of its inorder predecessor pre.right = current result.append(current.value) current = current.left else: # Revert the changes made in the binary tree pre.right = None current = current.right return result def preorder_generator(root: Node): Generate nodes\' values in preorder traversal (root, left, right). if root: yield root.value yield from preorder_generator(root.left) yield from preorder_generator(root.right)"},{"question":"You are given two functions: `encode_rle` and `decode_rle` that implement the Run-Length Encoding (RLE) and decoding algorithms. While these functions serve the purpose, they need improvement in handling various edge cases and performance optimization. Your task is to: 1. Improve the `encode_rle` and `decode_rle` functions to handle the edge cases and optimize the performance. 2. Write a new function `encoded_length(input: str) -> int` that returns the length of the encoded RLE string without actually encoding it. This function should have optimal space and time complexity. # Input 1. **encode_rle(input: str) -> str**: Takes a string as input and returns the Run-Length Encoded string. 2. **decode_rle(input: str) -> str**: Takes an encoded RLE string as input and returns the decoded string. 3. **encoded_length(input: str) -> int**: Takes a string as input and returns the length of the encoded RLE string. # Output 1. For `encode_rle`: A string that represents the Run-Length Encoded form of the input. 2. For `decode_rle`: A string that represents the decoded form of the RLE input. 3. For `encoded_length`: An integer that represents the length of the encoded RLE string. # Constraints 1. The input string for encoding and decoding will contain only alphanumeric characters. 2. The length of the input string will not exceed 10^6 characters. # Examples Example 1: ```python >>> encode_rle(\\"aaabbbcc\\") \'3a3b2c\' >>> decode_rle(\\"3a3b2c\\") \'aaabbbcc\' >>> encoded_length(\\"aaabbbcc\\") 6 ``` Example 2: ```python >>> encode_rle(\\"a\\") \'1a\' >>> decode_rle(\\"1a\\") \'a\' >>> encoded_length(\\"a\\") 2 ``` Example 3: ```python >>> encode_rle(\\"\\") \'\' >>> decode_rle(\\"\\") \'\' >>> encoded_length(\\"\\") 0 ``` # Notes - Ensure the functions handle empty input strings appropriately. - Aim to optimize the `encoded_length` function to run in O(n) time complexity.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded = [] count = 1 for i in range(1, len(input)): if input[i] == input[i-1]: count += 1 else: encoded.append(f\\"{count}{input[i-1]}\\") count = 1 # Add the last run encoded.append(f\\"{count}{input[-1]}\\") return \\"\\".join(encoded) def decode_rle(input: str) -> str: if not input: return \\"\\" decoded = [] count = \\"\\" for char in input: if char.isdigit(): count += char else: decoded.append(char * int(count)) count = \\"\\" return \\"\\".join(decoded) def encoded_length(input: str) -> int: if not input: return 0 length = 0 count = 1 for i in range(1, len(input)): if input[i] == input[i-1]: count += 1 else: length += len(str(count)) + 1 count = 1 # Add the last run length length += len(str(count)) + 1 return length"},{"question":"# Question Implement a function `cocktail_shaker_sort` that sorts an integer array of length `n` using the cocktail shaker sort algorithm. You should not use any built-in sorting functions. # Function Signature ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: ``` # Inputs * `arr` (List[int]): A list of integers that needs to be sorted. The length of the list is `n` where (0 leq n leq 10^3). # Outputs * Returns: (List[int]): The sorted list of integers in non-decreasing order. # Constraints * The algorithm should handle arrays of any length from 0 to 1000 elements. * You should dig into edge cases like arrays with all identical elements or arrays that are already sorted. * Ensure the algorithm does not go into unnecessary iterations once the array is sorted. # Example ```python assert cocktail_shaker_sort([3, 0, 2, 5, -1, 4, 1]) == [-1, 0, 1, 2, 3, 4, 5] assert cocktail_shaker_sort([]) == [] assert cocktail_shaker_sort([1,5,3,2,4]) == [1, 2, 3, 4, 5] assert cocktail_shaker_sort([2,2,2,2]) == [2, 2, 2, 2] ``` # Scenario You are employed at a company that deals with data sorting for various small real-time systems. The efficiency of the cocktail shaker sort makes it a suitable choice for data sets that are already partially ordered or for those that commonly need small adjustments, like sensor data readings. Implement the algorithm ensuring that it performs efficiently on the given constraints.","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: This function sorts an array of integers using the cocktail shaker sort algorithm. if not arr: return [] n = len(arr) start = 0 end = n - 1 swapped = True while swapped: swapped = False # Traverse from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # If no elements were swapped during the left to right traversal, the list is sorted if not swapped: break swapped = False end -= 1 # Traverse from right to left for i in range(end - 1, start - 1, -1): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True start += 1 return arr"},{"question":"**Scenario**: As a software engineer at a logistics company, you need to efficiently handle and sort large datasets representing shipment weights that arrive in no particular order. Your task is to implement an efficient heap sort algorithm. **Task**: Write a Python function `heap_sort(arr)` that sorts a given list of integers `arr` in ascending order using a max heap sort approach. **Implementation Requirements**: * **Input**: A list of integers `arr` where 1 ≤ len(arr) ≤ 10^5 and each element in the range [-10^6, 10^6]. * **Output**: A new list of integers sorted in ascending order. Your implementation must follow these rules: 1. Construct a max heap from the input list. 2. Use the max heap to sort the list in-place. 3. Your solution should have a time complexity of O(n log(n)) and a space complexity of O(1) additional space. **Constraints**: * Avoid using built-in sorting functions like `sorted()`. * Your function should handle arrays with identical elements and large datasets efficiently. # Example: ```python # Example Input arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] # Example Output sorted_arr = heap_sort(arr) print(sorted_arr) # Output should be [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] ``` Write your code below: ```python def heap_sort(arr): def max_heapify(arr, n, i): largest = i # Initialize largest as root l = 2 * i + 1 # left = 2*i + 1 r = 2 * i + 2 # right = 2*i + 2 # See if left child of root exists and is greater than root if l < n and arr[i] < arr[l]: largest = l # See if right child of root exists and is greater than root if r < n and arr[largest] < arr[r]: largest = r # Change root, if needed if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # swap # Heapify the root. max_heapify(arr, n, largest) n = len(arr) # Build a maxheap. for i in range(n // 2 - 1, -1, -1): max_heapify(arr, n, i) # One by one extract elements for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap max_heapify(arr, i, 0) return arr # You can test your function with the example input arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] print(heap_sort(arr)) # Expected Output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] ```","solution":"def heap_sort(arr): def max_heapify(arr, n, i): largest = i # Initialize largest as root l = 2 * i + 1 # left = 2*i + 1 r = 2 * i + 2 # right = 2*i + 2 # See if left child of root exists and is greater than root if l < n and arr[i] < arr[l]: largest = l # See if right child of root exists and is greater than root if r < n and arr[largest] < arr[r]: largest = r # Change root, if needed if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # swap # Heapify the root. max_heapify(arr, n, largest) n = len(arr) # Build a maxheap. for i in range(n // 2 - 1, -1, -1): max_heapify(arr, n, i) # One by one extract elements for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap max_heapify(arr, i, 0) return arr"},{"question":"Problem: Improved Shell Sort Shell Sort is an efficient sorting algorithm that is a generalization of insertion sort, but it performs better by allowing the exchange of elements that are far apart. You\'ll be implementing an improved version of Shell Sort using a more efficient gap sequence. # Task Write a function `improved_shell_sort(arr: List[int]) -> List[int]` that sorts a list of integers using the Shell Sort algorithm with the Sedgewick gap sequence. # Sedgewick Gap Sequence: The Sedgewick sequence is defined as: 1, 5, 19, 41, 109, 209, 505, 929... # Input: - A list of integers `arr` where `1 <= len(arr) <= 1000` and `-1000 <= arr[i] <= 1000` for all `0 <= i < len(arr)`. # Output: - Return the sorted list of integers in non-decreasing order. # Performance: - Your solution should aim to minimize the time complexity and take advantage of the Sedgewick gap sequence to improve the sorting performance. # Example: ```python >>> improved_shell_sort([8, 4, 1, 56, 3, -44, 23, -6, 28, 0]) [-44, -6, 0, 1, 3, 4, 8, 23, 28, 56] ``` # Constraints: - The function must handle edge cases such as empty arrays, arrays with a single element, arrays with duplicates, and arrays that are already sorted.","solution":"from typing import List def improved_shell_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Shell Sort algorithm with the Sedgewick gap sequence. n = len(arr) gaps = [1, 5, 19, 41, 109, 209, 505, 929] # Select appropriate gaps from the Sedgewick sequence gaps = [gap for gap in gaps if gap < n] # Perform the Shell Sort using the gaps in descending order for gap in reversed(gaps): for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Task Implement a Python function to calculate the cosine similarity between two n-dimensional vectors. Ensure that you handle any potential edge cases gracefully and validate the inputs before processing. # Function Signature ```python def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: pass ``` # Input 1. `vec1 : List[float]`: First input vector of length (n). 2. `vec2 : List[float]`: Second input vector of length (n). # Output - **float**: Cosine similarity value between the two input vectors. # Constraints: - Both input vectors must have the same length. # Examples ```python cosine_similarity([1, 0, -1], [1, 1, 0]) # Output: 0.0 cosine_similarity([1, 1, 1], [1, 2, -1]) # Output: 0.47140452079103173 cosine_similarity([0, 0, 0], [1, 0, -1]) # Output: ValueError: Both vectors must have non-zero magnitudes. ``` # Notes: - If the vectors are not of the same length, your function should raise a `ValueError` with an appropriate message. - Ensure that the vectors are not all zeros to avoid division by zero error, and raise a `ValueError` if this condition is not met with message: \\"Both vectors must have non-zero magnitudes.\\" - Make use of helper functions where appropriate to improve code readability and maintenance.","solution":"from typing import List import math def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: if len(vec1) != len(vec2): raise ValueError(\\"Input vectors must be of the same length.\\") dot_product = sum(a * b for a, b in zip(vec1, vec2)) magnitude_vec1 = math.sqrt(sum(a**2 for a in vec1)) magnitude_vec2 = math.sqrt(sum(b**2 for b in vec2)) if magnitude_vec1 == 0 or magnitude_vec2 == 0: raise ValueError(\\"Both vectors must have non-zero magnitudes.\\") return dot_product / (magnitude_vec1 * magnitude_vec2)"},{"question":"# Zigzag Iterator Implementation and Extension You are given two lists `l1` and `l2`. Your task is to implement a class `ZigzagIterator` that allows iterating over these lists in a zigzag manner. Once finished, extend this iterator to support an arbitrary number of input lists. Part 1: Basic Iterator Implement the `ZigzagIterator` class with the following methods: - `__init__(self, v1, v2)`: Initializes the iterator with two lists. - `next(self)`: Returns the next element in the iteration. - `has_next(self)`: Returns `True` if there are elements still to be iterated over, otherwise returns `False`. Part 2: Extended Iterator Extend your implementation to support an arbitrary number of input lists. Modify the `__init__` method to accept a variable number of lists. Input and Output - `__init__(self, *vectors)`: Initializes the iterator with any number of lists (0 or more). - `next(self) -> int`: Returns the next integer. - `has_next(self) -> bool`: Returns `True` if there are more integers to return, otherwise `False`. Example ```python l1 = [1, 2] l2 = [3, 4, 5, 6] it = ZigzagIterator(l1, l2) result = [] while it.has_next(): result.append(it.next()) print(result) # Output: [1, 3, 2, 4, 5, 6] ``` Similarly: ```python l1 = [1, 2, 3] l2 = [4, 5, 6, 7] l3 = [8, 9] it = ZigzagIterator(l1, l2, l3) result = [] while it.has_next(): result.append(it.next()) print(result) # Output: [1, 4, 8, 2, 5, 9, 3, 6, 7] ``` Constraints - Each list contains at most 1000 elements. - You may assume all elements in any given list are integers. Note * Ensure your solution is efficient and handles any edge cases as described in the analysis. * Consider using optimized data structures if necessary to improve the performance of your solution.","solution":"class ZigzagIterator: def __init__(self, *vectors): self.data = [vec for vec in vectors if vec] self.index_list = [0] * len(self.data) self.turn = 0 # to track whose turn it is def next(self): if not self.has_next(): return None while self.index_list[self.turn] >= len(self.data[self.turn]): self.turn = (self.turn + 1) % len(self.data) result = self.data[self.turn][self.index_list[self.turn]] self.index_list[self.turn] += 1 self.turn = (self.turn + 1) % len(self.data) return result def has_next(self): return any(self.index_list[i] < len(self.data[i]) for i in range(len(self.data)))"},{"question":"# Objective Given the encoded data generated through Run-Length Encoding (RLE), write a function that compresses the given data while also providing exact lengths of original data strings before and after decompression. # Task Implement a function `compress_data_and_lengths` that: 1. Encodes the input string using Run-Length Encoding. 2. Returns a tuple containing: - The encoded string. - The length of the original string before encoding. - The length of the encoded string after encoding. # Function Signature ```python def compress_data_and_lengths(input: str) -> tuple: ``` # Input * `input` (string): A string to be encoded. The input will contain only alphanumeric characters and its length will range from 0 to 1000 characters. # Output * Returns a tuple with: - Encoded string (string): The encoded version of the input. - Length of the original string (int): The length of the input string before encoding. - Length of the encoded string (int): The length of the encoded string after encoding. # Constraints * The function must handle the empty string input correctly. * The encoding and any string manipulations must be performed efficiently. # Example ```python assert compress_data_and_lengths(\\"aaabbccccdaa\\") == (\\"3a2b4c1d2a\\", 12, 10) assert compress_data_and_lengths(\\"abcdef\\") == (\\"1a1b1c1d1e1f\\", 6, 12) assert compress_data_and_lengths(\\"\\") == (\\"\\", 0, 0) ``` # Additional Information * Do not import any extra libraries; the task should be solvable with standard Python libraries only. * Focus on the correctness and efficiency of your solution.","solution":"def compress_data_and_lengths(input: str) -> tuple: if not input: return (\\"\\", 0, 0) encoded = [] count = 1 for i in range(1, len(input)): if input[i] == input[i - 1]: count += 1 else: encoded.append(str(count)) encoded.append(input[i - 1]) count = 1 # append the last group encoded.append(str(count)) encoded.append(input[-1]) encoded_str = \'\'.join(encoded) original_length = len(input) encoded_length = len(encoded_str) return (encoded_str, original_length, encoded_length)"},{"question":"**Ternary Search Implementation** **Scenario**: You are given a sorted array of integers. Your task is to implement the ternary search algorithm to find a specific integer in the array. **Function Details**: Implement a function `ternary_search(arr, key)` which takes in two parameters: - `arr`: A list of sorted integers (ascending order). - `key`: The integer value to search for in the array. **Expected Output**: The function should return the index of the `key` in the array if found. If the `key` is not found, the function should return -1. **Constraints**: - All integers in the array and the key value are within the range of -10^9 to 10^9. - The length of the array will not exceed 10^6. - The function should achieve at least O(log3(N)) time complexity. **Function Signature**: ```python def ternary_search(arr: List[int], key: int) -> int: # Your code goes here ``` **Examples**: ```python # Test cases assert ternary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == 4 assert ternary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 11) == -1 assert ternary_search([-5, -2, 0, 1, 4, 10, 12], 0) == 2 assert ternary_search([], 3) == -1 assert ternary_search([7], 7) == 0 ``` ***Note***: Ensure your implementation accurately accounts for all edge cases and performs efficiently for large datasets.","solution":"from typing import List def ternary_search(arr: List[int], key: int) -> int: def search(l, r): if r >= l: mid1 = l + (r - l) // 3 mid2 = r - (r - l) // 3 if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: return search(l, mid1 - 1) elif key > arr[mid2]: return search(mid2 + 1, r) else: return search(mid1 + 1, mid2 - 1) return -1 return search(0, len(arr) - 1)"},{"question":"# Problem: Linked List Sorting Validation You are given a singly linked list where each node contains an integer value. Your task is to implement a function `is_sorted(head)` that checks whether the linked list is sorted in non-decreasing order. Function Signature: ```python def is_sorted(head): pass ``` Input: * `head`: The head node of the linked list. Each node is represented as an object of a class `ListNode`. ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Output: * Return `True` if the linked list is sorted in non-decreasing order, otherwise return `False`. Constraints: * The linked list can be empty (in which case it is considered sorted). * Node values are integers which can be positive, negative, or zero. * The function should run within (O(n)) time complexity and use (O(1)) space complexity. Example: ```python # Example 1: head = ListNode(1, ListNode(2, ListNode(3, ListNode(4)))) assert is_sorted(head) == True # Example 2: head = ListNode(1, ListNode(2, ListNode(-1, ListNode(3)))) assert is_sorted(head) == False # Example 3: head = None assert is_sorted(head) == True ``` This task will assess your ability to work with linked lists and your understanding of a fundamental algorithmic check for sorted data.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head): Checks if the linked list is sorted in non-decreasing order. if not head: return True current = head while current.next: if current.val > current.next.val: return False current = current.next return True"},{"question":"Scenario You are a software engineer at a company tasked with developing a feature that compares and transforms text documents. To ensure accuracy and efficiency, you need to implement an algorithm that computes the minimum number of delete operations required to make two given strings identical. Problem Statement Given two words, `word1` and `word2`, your task is to write a function to find the minimum number of steps required to make `word1` and `word2` the same. In each step, you can delete one character in either string. Function Signature ```python def min_distance(word1: str, word2: str) -> int: Calculate the minimum number of deletions required to make two strings identical. :param word1: First input string. :param word2: Second input string. :return: The minimum number of deletions. ``` Input * `word1` and `word2` are strings consisting of lowercase English letters. * Constraints: * `1 <= len(word1), len(word2) <= 1000` Output * Return an integer representing the minimum number of delete operations. Example * Example 1: * Input: `\\"sea\\"`, `\\"eat\\"` * Output: `2` * Explanation: Delete `\'s\'` from `\\"sea\\"` and `\'t\'` from `\\"eat\\"` to have `\\"ea\\"` identical. * Example 2: * Input: `\\"leetcode\\"`, `\\"etco\\"` * Output: `4` * Explanation: Delete `\'l\'`, `\'e\'`, `\'d\'` from `\\"leetcode\\"` and `\'o\'` from `\\"etco\\"` to have `\\"etco\\"`. Constraints Consider the following while implementing the function: * Optimize your solution for both time and space complexity. * Address edge cases like empty strings or no common subsequences. * Ensure the solution is scalable for the maximum input size constraints.","solution":"def min_distance(word1: str, word2: str) -> int: Calculate the minimum number of deletions required to make two strings identical. :param word1: First input string. :param word2: Second input string. :return: The minimum number of deletions. m, n = len(word1), len(word2) # Create a dp array with size (m+1) x (n+1) dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the dp table for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The length of the longest common subsequence lcs_length = dp[m][n] # Minimum number of deletions required return (m - lcs_length) + (n - lcs_length) print(min_distance(\\"sea\\", \\"eat\\")) # Expected output: 2 print(min_distance(\\"leetcode\\", \\"etco\\")) # Expected output: 4"},{"question":"The number 89 is a special integer because its digits when raised up to consecutive powers give the same number, i.e., 89 = 8^1 + 9^2 which equals 89. The next number with this property is 135 since 135 = 1^1 + 3^2 + 5^3 which equals 135. Write a function `special_numbers(low, high)` that returns a list of all numbers within the given range `[low, high]` (both inclusive) that have this special property. Function Signature ```python def special_numbers(low: int, high: int) -> list: # Your implementation here ``` Input - `low`: An integer representing the lower bound of the range (inclusive). - `high`: An integer representing the upper bound of the range (inclusive). Output - Returns a list of integers within the range `[low, high]` (inclusive) that satisfy the described property. Example ```python assert special_numbers(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert special_numbers(1, 150) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89, 135] ``` Constraints - `1 <= low <= high <= 10^6` - The function should handle large ranges efficiently within reasonable computational limits. Notes - Focus on clean and efficient implementation. - Consider edge cases such as boundaries and large numbers.","solution":"def special_numbers(low: int, high: int) -> list: def is_special_number(n: int) -> bool: digits = [int(d) for d in str(n)] calculated_sum = sum(d**(i+1) for i, d in enumerate(digits)) return calculated_sum == n result = [] for number in range(low, high + 1): if is_special_number(number): result.append(number) return result"},{"question":"# Scenario You are given a list of elements which may contain duplicates. The goal is to write a function that removes the duplicates while maintaining the order of their first occurrence. However, the current implementation provided has a performance bottleneck due to its time complexity. # Task Optimize the given duplicate removal algorithm to improve its performance. You need to implement a function that efficiently removes duplicates from the input array. # Function Signature Implement the function `remove_duplicates_optimized(array: list) -> list`. # Input * `array` - A list of elements which can be of any data type (integers, strings, booleans, etc.). * Constraints: The length of the list is in the range [0, 10^6]. # Output * Returns a list containing the unique elements in the order of their first occurrence. # Examples ```python remove_duplicates_optimized([1, 1, 1, 2, 2, 3, 4, 4, \\"hey\\", \\"hey\\", \\"hello\\", True, True]) # Output: [1, 2, 3, 4, \'hey\', \'hello\'] remove_duplicates_optimized([]) # Output: [] remove_duplicates_optimized([5, 5, 5, 5]) # Output: [5] ``` # Constraints * Your solution should run with a better time complexity than O(n^2). # Hints * Consider using a data structure that allows efficient membership checking.","solution":"def remove_duplicates_optimized(array: list) -> list: Removes duplicates from the list while maintaining the order of their first occurrence. seen = set() # To keep track of seen elements result = [] # To store the result without duplicates for item in array: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"# Question You are tasked with developing a function that performs binary string addition. The goal is to add two binary strings and return the resulting binary string. This function must handle binary strings of different lengths and correctly manage carries. Requirements: 1. The function should be named `add_binary`. 2. It should accept two strings `a` and `b`. 3. It should return a single string representing their sum in binary format. Input: - `a`: A binary string (1 ≤ |a| ≤ 10^4). - `b`: Another binary string (1 ≤ |b| ≤ 10^4). Output: - A binary string that represents the sum of `a` and `b`. Constraints: - Both `a` and `b` are non-empty. - The input strings contain only characters \'0\' and \'1\'. - Performance should be efficient enough to handle strings as long as 10^4 characters. Example: ```python >>> add_binary(\\"11\\", \\"1\\") \\"100\\" >>> add_binary(\\"1010\\", \\"1011\\") \\"10101\\" ``` # Scenario Imagine you are working on a software dealing with low-level operations such as network protocols, where binary data representation and manipulation are common. You need to write an efficient function to perform binary addition, which forms the basis for handling binary arithmetic in this software. # Hints: - Consider how you handle binary addition manually. - Think about the role of carry and how it can affect the result. - Remember to handle cases when strings have differing lengths. Good luck!","solution":"def add_binary(a, b): Adds two binary strings and returns their sum as a binary string. max_len = max(len(a), len(b)) # Pad the shorter string with zeroes a = a.zfill(max_len) b = b.zfill(max_len) carry = 0 result = [] # Perform the addition from the last to the first bit for i in range(max_len - 1, -1, -1): bit_a = int(a[i]) bit_b = int(b[i]) total = bit_a + bit_b + carry result_bit = total % 2 carry = total // 2 result.append(str(result_bit)) if carry: result.append(\'1\') result.reverse() return \'\'.join(result)"},{"question":"Check if a Linked List is Sorted **Problem Statement**: You are given a singly linked list where each node contains an integer value. Your task is to write a function `check_sorted` that determines if the linked list is sorted in non-decreasing order (i.e., each node’s value should be less than or equal to the next node’s value). **Function Signature**: ```python def check_sorted(head: Optional[ListNode]) -> bool: ... ``` **Input**: * `head`: The head node of the singly linked list. **Output**: * Return `True` if the list is sorted in non-decreasing order, `False` otherwise. **Constraints**: - The linked list can be empty. - The linked list contains integers in the range ([-10^9, 10^9]). - Maximum number of nodes in the linked list is ([1, 10^6]). **Examples**: 1. Given the linked list: `None`, should return `True`. 2. Given the linked list: `1 -> 2 -> 3 -> 4`, should return `True`. 3. Given the linked list: `1 -> 2 -> -1 -> 3`, should return `False`. **Scenario**: Consider you are working on a logging system where user scores are stored in a linked list. To ensure the scores are logged in an increasing manner, you need to validate whether the existing list of scores is already sorted before performing any further operations on it. Write your function `check_sorted` to fulfill this requirement.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def check_sorted(head): This function checks if a given linked list is sorted in non-decreasing order. if not head or not head.next: return True current = head while current.next: if current.val > current.next.val: return False current = current.next return True"},{"question":"Binary and Hexadecimal Manipulation Background You are working on a system that requires frequent conversion of numeric data between binary and hexadecimal formats. To meet the performance requirements, optimally handling such conversions is essential. Task Implement two functions: 1. `to_hexadecimal`: Converts a non-negative integer to its corresponding hexadecimal string. 2. `from_binary`: Converts a binary string to its corresponding non-negative integer representation. Function Signatures ```python def to_hexadecimal(num: int) -> str: :param num: A non-negative integer :return: A string representing the hexadecimal form of the input integer. # Your implementation here def from_binary(binary_str: str) -> int: :param binary_str: A string containing the binary representation (e.g., \'1011\') :return: An integer corresponding to the binary string # Your implementation here ``` Input/Output Format **to_hexadecimal** * **Input**: A non-negative integer `num` * **Output**: A string that is the hexadecimal representation of `num`. **from_binary** * **Input**: A string `binary_str` representing a binary number (only \'0\' and \'1\' characters) * **Output**: An integer that corresponds to the binary number. Constraints * `0 <= num <= 10^6` * `binary_str` will only contain \'0\' and \'1\' characters. Examples ```python assert to_hexadecimal(255) == \'FF\' assert to_hexadecimal(0) == \'0\' assert from_binary(\'101\') == 5 assert from_binary(\'0000\') == 0 ``` Notes Handle conversion efficiently, and account for any edge cases, such as leading zeros in binary strings or the integer zero for hexadecimal conversion.","solution":"def to_hexadecimal(num: int) -> str: Converts a non-negative integer to its corresponding hexadecimal string. :param num: A non-negative integer :return: A string representing the hexadecimal form of the input integer. if num == 0: return \'0\' hex_str = \\"\\" hex_chars = \\"0123456789ABCDEF\\" while num > 0: hex_str = hex_chars[num % 16] + hex_str num //= 16 return hex_str def from_binary(binary_str: str) -> int: Converts a binary string to its corresponding non-negative integer representation. :param binary_str: A string containing the binary representation (e.g., \'1011\') :return: An integer corresponding to the binary string return int(binary_str, 2)"},{"question":"# Segment Tree Implementation and Usage Segment Trees are advanced data structures that efficiently perform range updates and queries on an array. Your task is to extend the `SegmentTree` class to include a method for range updates. Specifically, you need to implement a method `range_update(self, l, r, value)` that updates all elements in the range `[l, r]` by applying the given value. You should also write a method `query(self, l, r)` to test your range updates and ensure the correctness of the segment. Function Signature ```python class SegmentTree: def __init__(self, arr, function): pass # implementation provided def build_tree(self): pass # implementation provided def update(self, p, v): pass # implementation provided def query(self, l, r): pass # implementation provided def range_update(self, l, r, value): pass # implement this method # Usage of the SegmentTree with the new range update method def test_segment_tree(): arr = [2, 4, 5, 3, 4] mytree = SegmentTree(arr, max) mytree.range_update(1, 3, 7) # update indices 1 to 3 with value 7 result = mytree.query(0, 4) # query range 0 to 4 return result # expected result depends on initial function and range updates ``` Input and Output Formats * **Input**: * An array of integers. * A commutative function for the Segment Tree. * Indices `l`, `r` for range updates and range queries. * **Output**: * Updated Segment Tree values after calling `range_update`. * Result of the `query` operation. Constraints * Ensure the function used is commutative. * Efficiently manage the segment tree updates and queries without rebuilding the tree from scratch. # Example ```python # Testcase arr = [2, 4, 5, 3, 4] mytree = SegmentTree(arr, max) mytree.range_update(1, 3, 7) assert mytree.query(0, 4) == 7, \\"Test failed!\\" ``` # Performance Requirements * Ensure the `range_update` method maintains a time complexity of O(log N) per update. * Queries should still perform within O(log N) after range updates. Your implementation should demonstrate an understanding of Segment Trees and efficient management of data updates and queries.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.tree = [0] * (2 * self.n) self.lazy = [0] * self.n self.function = function self.array = arr self.build_tree(arr) def build_tree(self, arr): for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, p, value): p += self.n self.tree[p] += value i = p while i > 1: i //= 2 self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def query(self, l, r): l += self.n r += self.n res = 0 while l < r: if l % 2 == 1: res = self.function(res, self.tree[l]) l += 1 if r % 2 == 1: r -= 1 res = self.function(res, self.tree[r]) l //= 2 r //= 2 return res def range_update(self, l, r, value): for p in range(l, r + 1): self.update(p, value)"},{"question":"You are tasked with implementing a ModifiedQueue class that extends the functionalities of the provided AbstractQueue. This new class should use a circular array to optimize space management and improve performance for dynamic resizing operations. Requirements: 1. All basic queue operations (enqueue, dequeue, peek) should follow the Queue ADT principles. 2. Use a circular buffer to handle queue overflow efficiently without frequent resizes. 3. Handle both the performance of typical operations and worst-case scenarios, ensuring optimal space utilization and time complexity. # Specifications: ```python class ModifiedQueue(AbstractQueue): def __init__(self, capacity=10): Initialize a circular queue with a given initial capacity. If not provided, default capacity should be 10. pass def enqueue(self, value): Add a value to the rear of the queue. If the queue is full, re-size it to hold additional elements without using extra space. pass def dequeue(self): Remove and return the front value from the queue. Raise IndexError if the queue is empty. pass def peek(self): Return the front value of the queue without removing it. Raise IndexError if the queue is empty. pass def __iter__(self): Define an iterator to iterate through the queue elements in FIFO order. pass ``` # Constraints: - The initial capacity of the queue should default to 10 if not specified. - The queue implementation should handle dynamic resizing efficiently using a circular buffer approach. - The solution should have an amortized time complexity of O(1) for `enqueue` and `dequeue` operations. - Ensure efficient memory usage during the resizing process, minimizing unused space. Example: ```python q = ModifiedQueue(5) q.enqueue(1) q.enqueue(2) q.enqueue(3) print(q.dequeue()) # Output: 1 q.enqueue(4) q.enqueue(5) q.enqueue(6) print(q.peek()) # Output: 2 print(len(q)) # Output: 4 ``` Write a complete implementation of the `ModifiedQueue` class as specified. Ensure to handle edge cases, optimize for performance and provide proper docstrings for your methods.","solution":"class ModifiedQueue: def __init__(self, capacity=10): Initialize a circular queue with a given initial capacity. If not provided, the default capacity should be 10. self.capacity = capacity self.queue = [None] * self.capacity self.front = 0 self.rear = 0 self.size = 0 def enqueue(self, value): Add a value to the rear of the queue. If the queue is full, re-size it to hold additional elements without using extra space. if self.size == self.capacity: self._resize(2 * self.capacity) self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.size += 1 def dequeue(self): Remove and return the front value from the queue. Raise IndexError if the queue is empty. if self.size == 0: raise IndexError(\\"Dequeue from empty queue\\") result = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.size -= 1 if 0 < self.size <= self.capacity // 4: self._resize(self.capacity // 2) return result def peek(self): Return the front value of the queue without removing it. Raise IndexError if the queue is empty. if self.size == 0: raise IndexError(\\"Peek from empty queue\\") return self.queue[self.front] def __len__(self): Return the number of items currently in the queue. return self.size def __iter__(self): Define an iterator to iterate through the queue elements in FIFO order. idx = self.front num_elements_yielded = 0 while num_elements_yielded < self.size: yield self.queue[idx] idx = (idx + 1) % self.capacity num_elements_yielded += 1 def _resize(self, new_capacity): Resize the queue to the new capacity. old_queue = self.queue self.queue = [None] * new_capacity walk = self.front for i in range(self.size): self.queue[i] = old_queue[walk] walk = (walk + 1) % self.capacity self.front = 0 self.rear = self.size self.capacity = new_capacity"},{"question":"# Reverse a Singly Linked List Scenario You are tasked with developing a function to reverse a singly linked list. This is a common problem encountered in data manipulation and preparation tasks, such as restoring the original order of items processed in reverse order or preparing data for algorithms expecting reversed input. Task Write a function to reverse a singly linked list using both iterative and recursive methods. The function should return the head of the reversed list. Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head: ListNode) -> ListNode: # Implement the iterative method here pass def reverse_list_recursive(head: ListNode) -> ListNode: # Implement the recursive method here pass ``` Constraints * The number of nodes in the list is in the range [0, 5000]. * -5000 <= Node.val <= 5000 Example ```python # Example 1 # Input: 1 -> 2 -> 3 -> 4 -> 5 # Output: 5 -> 4 -> 3 -> 2 -> 1 # Example 2 # Input: 1 # Output: 1 # Example 3 # Input: [] # Output: [] ``` Notes 1. Ensure your implementation adheres to the time and space complexity expectations (O(n) time, O(1) space for iterative; O(n) time, O(n) space for recursive). 2. Write test cases to cover typical scenarios and edge cases.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head: ListNode) -> ListNode: prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev def reverse_list_recursive(head: ListNode) -> ListNode: if head is None or head.next is None: return head new_head = reverse_list_recursive(head.next) head.next.next = head head.next = None return new_head"},{"question":"# Base Conversion - Advanced Challenge Context In various computer science applications, you\'re often required to switch between different numerical representations. This problem aims to test your ability to implement efficient conversion functions between integer values and their string representations in various bases. Problem Statement Implement two functions: 1. `int_to_base(num, base)`: Converts an integer `num` to its string representation in the specified `base`. * **Inputs**: - `num` (int): The integer to be converted. (Constraints: -1,000,000 ≤ num ≤ 1,000,000) - `base` (int): The numerical base for the conversion (Constraints: 2 ≤ base ≤ 36) * **Output**: - A string representing the integer `num` in the specified `base`. 2. `base_to_int(str_num, base)`: Converts a string `str_num` representing a number in the specified `base` back to an integer. * **Inputs**: - `str_num` (str): The string representation of the number. (Constraints: The string length will be ≤ 100, and it will only contain valid characters for the given base) - `base` (int): The numerical base of the string representation. (Constraints: 2 ≤ base ≤ 36) * **Output**: - An integer representation of the string `str_num` in the specified `base`. Example ```python # Example 1 int_to_base(5, 2) # Output: \'101\' base_to_int(\'101\', 2) # Output: 5 # Example 2 int_to_base(-255, 16) # Output: \'-FF\' base_to_int(\'-FF\', 16) # Output: -255 # Example 3 int_to_base(0, 8) # Output: \'0\' base_to_int(\'0\', 8) # Output: 0 ``` Constraints * For `int_to_base`, the input `num` is an integer between -1,000,000 and 1,000,000. * For `base_to_int`, the input `str_num` is a string of length up to 100. * The base for both functions is between 2 and 36. Additional Requirements * Handle both positive and negative numbers in the conversion functions. * Make sure the functions are efficient and handle edge cases gracefully, including zero and invalid characters.","solution":"def int_to_base(num, base): Converts an integer num to its string representation in the specified base. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") if num == 0: return \'0\' digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" negative = num < 0 num = abs(num) result = [] while num: result.append(digits[num % base]) num //= base if negative: result.append(\'-\') return \'\'.join(reversed(result)) def base_to_int(str_num, base): Converts a string str_num representing a number in the specified base back to an integer. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") num = 0 negative = str_num[0] == \'-\' if negative: str_num = str_num[1:] digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" digit_map = {char: index for index, char in enumerate(digits)} for char in str_num: if char not in digit_map or digit_map[char] >= base: raise ValueError(f\\"Invalid character \'{char}\' for base {base}\\") num = num * base + digit_map[char] return -num if negative else num"},{"question":"Problem Statement You are given a sorted array of integers `arr` and an integer `key` to search in the array. Your task is to implement the ternary search algorithm, which divides the array into three parts and searches for the `key`. # Function Signature ```python def ternary_search(arr: List[int], key: int) -> int: ``` # Input * `arr` (List[int]): A list of integers sorted in ascending order. * `key` (int): The integer value to be searched in the array. # Output * Returns the index of `key` in `arr` if present, otherwise returns `-1`. # Constraints * 0 <= len(arr) <= 10^6 * -10^9 <= arr[i], key <= 10^9 # Example ```python # Example 1 arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] key = 5 Output: 4 # Example 2 arr = [-10, -3, 0, 5, 9, 12, 17, 23] key = 0 Output: 2 # Example 3 arr = [4, 8, 15, 16, 23, 42] key = 100 Output: -1 ``` # Guidelines 1. Implement the `ternary_search` function according to the ternary search principles outlined above. 2. Ensure proper handling of edge cases, including empty arrays and elements not present in the array. 3. Pay attention to time and space complexity constraints and optimize your function accordingly. 4. You should not use any built-in search functions (like `index()` or `binary_search()`) to solve the problem.","solution":"from typing import List def ternary_search(arr: List[int], key: int) -> int: Perform a ternary search to find the index of key in the sorted list arr. Returns the index of key if found, otherwise returns -1. def search(left, right): if left > right: return -1 third = (right - left) // 3 mid1 = left + third mid2 = right - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: return search(left, mid1 - 1) elif key > arr[mid2]: return search(mid2 + 1, right) else: return search(mid1 + 1, mid2 - 1) return search(0, len(arr) - 1)"},{"question":"**Scenario**: You are developing system software that frequently checks logs of user activity which are stored in sorted order by timestamps. Implementing an efficient search to quickly find specific events will greatly improve your system’s responsiveness. **Problem Statement**: Write a function `first_occurrence(array, query)` that takes in a sorted list of numbers `array` and a target number `query`. This function should return the index of the first occurrence of the given query in the array using the Binary Search algorithm. If the target is not found in the array, return `-1`. # Function Signature: ```python def first_occurrence(array: List[int], query: int) -> int: ``` # Input: * `array`: A list of integers sorted in increasing order. * `query`: An integer to find the first occurrence of in the array. # Output: * Return the index of the first occurrence of the target query in the array. * If the query is not present, return `-1`. # Constraints: * The array contains integers in non-decreasing order. * The array length `n` is at most `10^5`. * Each integer in the array falls within the range `[-10^6, 10^6]`. # Example: ```python assert first_occurrence([1, 2, 2, 2, 3, 4, 5], 2) == 1 assert first_occurrence([1, 2, 2, 2, 3, 4, 5], 5) == 6 assert first_occurrence([1, 2, 2, 2, 3, 4, 5], 6) == -1 assert first_occurrence([], 2) == -1 ``` # Requirements: 1. The function must run in O(log n) time complexity. 2. It should be capable of handling edge cases, including but not limited to: * Empty arrays. * Arrays where the query isn\'t found. * Arrays with all identical elements.","solution":"from typing import List def first_occurrence(array: List[int], query: int) -> int: left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid right = mid - 1 # Move left to find the first occurrence elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Shared Secret Agreement Using Diffie-Hellman Key Exchange Alice and Bob want to securely share a secret key using the Diffie-Hellman key exchange method. The Diffie-Hellman algorithm involves the following steps: 1. Choose a large prime number `p` and a primitive root `a` of `p`. 2. Alice picks a private key `a_pr_k` randomly from the range `[1, p-1]` and computes her public key `a_pu_k = (a^a_pr_k) % p`. 3. Bob picks a private key `b_pr_k` randomly from the range `[1, p-1]` and computes his public key `b_pu_k = (a^b_pr_k) % p`. 4. Alice and Bob exchange their public keys. 5. Alice uses Bob\'s public key and her private key to compute the shared secret key. 6. Bob uses Alice\'s public key and his private key to compute the shared secret key. Your task is to implement the Diffie-Hellman key exchange for Alice and Bob to securely agree on a shared secret key. Functions to Implement: 1. `alice_private_key(p)`: Returns a random private key for Alice. 2. `alice_public_key(a_pr_k, a, p)`: Computes and returns Alice\'s public key. 3. `bob_private_key(p)`: Returns a random private key for Bob. 4. `bob_public_key(b_pr_k, a, p)`: Computes and returns Bob\'s public key. 5. `alice_shared_key(b_pu_k, a_pr_k, p)`: Computes and returns the shared key calculated by Alice using Bob\'s public key and her private key. 6. `bob_shared_key(a_pu_k, b_pr_k, p)`: Computes and returns the shared key calculated by Bob using Alice\'s public key and his private key. The implementation should also handle basic validation to ensure that the given prime number `p` is indeed a prime and `a` is a primitive root of `p`. Input: - Prime number `p` - Primitive root `a` Output: - Shared secret key agreed upon by both Alice and Bob Example: ```python p = 23 # A small prime for simplicity a = 5 # A primitive root of 23 shared_secret = diffie_hellman_key_exchange(a, p) print(shared_secret) # Should print True if the keys matched, indicating the shared secret was agreed correctly ``` **Constraints:** - `p` must be a prime number - `a` must be a primitive root of `p`","solution":"import random def alice_private_key(p): Returns a random private key for Alice. return random.randint(1, p-1) def alice_public_key(a_pr_k, a, p): Computes and returns Alice\'s public key. return pow(a, a_pr_k, p) def bob_private_key(p): Returns a random private key for Bob. return random.randint(1, p-1) def bob_public_key(b_pr_k, a, p): Computes and returns Bob\'s public key. return pow(a, b_pr_k, p) def alice_shared_key(b_pu_k, a_pr_k, p): Computes and returns the shared key calculated by Alice using Bob\'s public key and her private key. return pow(b_pu_k, a_pr_k, p) def bob_shared_key(a_pu_k, b_pr_k, p): Computes and returns the shared key calculated by Bob using Alice\'s public key and his private key. return pow(a_pu_k, b_pr_k, p) def diffie_hellman_key_exchange(a, p): Simulates the entire Diffie-Hellman key exchange and verifies if both Alice and Bob end up with the same shared secret. a_pr_k = alice_private_key(p) a_pu_k = alice_public_key(a_pr_k, a, p) b_pr_k = bob_private_key(p) b_pu_k = bob_public_key(b_pr_k, a, p) alice_secret = alice_shared_key(b_pu_k, a_pr_k, p) bob_secret = bob_shared_key(a_pu_k, b_pr_k, p) return alice_secret == bob_secret"},{"question":"# Scenario You are designing a dictionary application which uses a Binary Search Tree (BST) to store words in a lexicographically sorted order. For enhancing navigation between words, you want to implement a feature that finds the predecessor of any given word in the BST. # Problem Statement Implement a function `predecessor(root, node)` that finds the in-order predecessor of a given node in a BST. If the given node has no predecessor, return `None`. # Functional Requirements * **Input**: * `root`: The root node of the BST (TreeNode). * `node`: The target node (TreeNode) whose predecessor is to be found. * **Output**: * Return the predecessor node (TreeNode) if it exists. Return `None` otherwise. # Constraints * The BST nodes contain integers as values. * Nodes are instances of the following class: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` * You may assume the tree does not contain duplicate values. * The given node exists in the tree. # Example Consider the following BST: ``` 20 / 10 30 / / 5 15 25 35 ``` If the target node is `15`, its in-order predecessor is `10`. **Function Call**: ```python predecessor(root, TreeNode(15)) ``` **Expected Output**: TreeNode with value `10` # Implementation Implement the function with consideration of edge cases and optimize for performance where possible.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def predecessor(root, node): Finds the in-order predecessor of the given node in a BST. :param root: The root TreeNode of the BST. :param node: The target TreeNode whose predecessor is to be found. :return: The predecessor TreeNode if it exists, None otherwise. predecessor = None current = root while current: if node.val > current.val: predecessor = current current = current.right else: current = current.left return predecessor"},{"question":"# Question: Advanced GCD and LCM Implementations You are to implement a function that computes the greatest common divisor (GCD) and the least common multiple (LCM) of two integers with the following improvements over given reference methods: 1. Implement Euclid\'s algorithm for GCD using both modulus and bitwise operations. 2. Implement LCM calculation, ensuring correctness and efficiency. 3. A composite function derivation that yields both GCD and LCM values at once. Specifications: 1. Implement the GCD using Euclid\'s modulus algorithm as `gcd_mod(a, b)`. 2. Implement the GCD using bitwise operations as `gcd_bitwise(a, b)`. 3. Implement LCM as `lcm(a, b)` which internally uses `gcd_mod(a, b)`. 4. Implement a composite function `gcd_lcm(a, b)` to return both GCD and LCM in a tuple using only one GCD computation. # Function Signatures: ```python def gcd_mod(a: int, b: int) -> int: pass def gcd_bitwise(a: int, b: int) -> int: pass def lcm(a: int, b: int) -> int: pass def gcd_lcm(a: int, b: int) -> (int, int): pass ``` # Input: * Two non-negative integers `a`, `b` (0 <= a, b <= 10^6) # Output: * Modulus GCD (for `gcd_mod`) * Bitwise GCD (for `gcd_bitwise`) * Least Common Multiple (for `lcm`) * Tuple of GCD and LCM (for `gcd_lcm`) # Constraints: * Avoid direct calls or third-party libraries for GCD/LCM calculations besides numpy. * Minimize total computational steps in `gcd_lcm`. # Example: ```python # Example usage of gcd_mod, gcd_bitwise, lcm, gcd_lcm assert gcd_mod(24, 36) == 12 assert gcd_bitwise(24, 36) == 12 assert lcm(24, 36) == 72 assert gcd_lcm(24, 36) == (12, 72) ```","solution":"def gcd_mod(a, b): Compute the GCD of a and b using Euclid\'s algorithm with modulus operation. while b != 0: a, b = b, a % b return a def gcd_bitwise(a, b): Compute the GCD of a and b using the binary GCD algorithm. if a == 0: return b if b == 0: return a # Reduce both numbers by removing any common factors of 2 shift = 0 while ((a | b) & 1) == 0: a >>= 1 b >>= 1 shift += 1 while (a & 1) == 0: a >>= 1 while b != 0: while (b & 1) == 0: b >>= 1 if a > b: a, b = b, a b = b - a return a << shift def lcm(a, b): Compute the LCM of a and b using the GCD from modulus method. return (a * b) // gcd_mod(a, b) if a and b else 0 def gcd_lcm(a, b): Return a tuple of (GCD, LCM) of a and b. gcd = gcd_mod(a, b) lcm_value = (a * b) // gcd if a and b else 0 return gcd, lcm_value"},{"question":"# Recursive Binomial Coefficient Calculation Given the mathematical concept of binomial coefficients, which are defined as: [ C(n, k) = frac{n!}{k!(n-k)!} ] Write a function `recursive_binomial_coefficient(n, k)` that computes the binomial coefficient ( C(n, k) ) using recursion. Your function should handle the following cases: 1. **Input constraints**: * `n` and `k` are non-negative integers. * `n >= k` 2. **Output**: * An integer representing the value of ( C(n, k) ). # Function Signature ```python def recursive_binomial_coefficient(n: int, k: int) -> int: pass ``` # Example ```python recursive_binomial_coefficient(5, 0) # Output: 1 recursive_binomial_coefficient(8, 2) # Output: 28 recursive_binomial_coefficient(500, 300) # Output: A very large number ``` # Constraints * Ensure that your function handles large values of `n` efficiently. * Implement error handling to manage invalid inputs where `k > n`. # Edge Cases * `recursive_binomial_coefficient(0, 0)` should return 1. * `recursive_binomial_coefficient(10, 10)` should return 1. * `recursive_binomial_coefficient(10, 0)` should return 1. * Handle scenarios where `k > n` gracefully by raising an appropriate error.","solution":"def recursive_binomial_coefficient(n: int, k: int) -> int: if k > n: raise ValueError(\\"k cannot be greater than n\\") if k == 0 or k == n: return 1 return recursive_binomial_coefficient(n - 1, k - 1) + recursive_binomial_coefficient(n - 1, k)"},{"question":"# Integer Partition Problem Problem Statement You are given a positive integer `n`, and your task is to write a function that computes the number of distinct partitions of `n` into positive integers. A partition of `n` is a way of writing `n` as a sum of positive integers, disregarding the order of the addends. Input - A single integer `n` where (1 leq n leq 100). Output - Return the number of distinct partitions of `n`. Constraints - The integer `n` will be at least 1 and at most 100. - The function should complete in acceptable time for largest input values. Example ```python assert count_partitions(4) == 5 assert count_partitions(7) == 15 ``` Explanation For `n = 4`: - The partitions are: [4], [3, 1], [2, 2], [2, 1, 1], and [1, 1, 1, 1]. For `n = 7`: - The partitions are: [7], [6 + 1], [5 + 2], [5 + 1 + 1], [4 + 3], [4 + 2 + 1], [4 + 1 + 1 + 1], [3 + 3 + 1], [3 + 2 + 2], [3 + 2 + 1 + 1], [3 + 1 + 1 + 1 + 1], [2 + 2 + 2 + 1], [2 + 2 + 1 + 1 + 1], [2 + 1 + 1 + 1 + 1 + 1], [1 + 1 + 1 + 1 + 1 + 1 + 1]. Boilerplate Code ```python def count_partitions(n): Compute the number of distinct partitions of `n`. n -- positive integer Returns: int -- number of distinct partitions # Write your solution here # Test cases assert count_partitions(4) == 5 assert count_partitions(7) == 15 ``` Your function should compute the number of distinct partitions of the given integer `n` efficiently and within the given constraints.","solution":"def count_partitions(n): Compute the number of distinct partitions of `n`. n -- positive integer Returns: int -- number of distinct partitions # Create a list to store partition counts with initial value 1 partitions = [1] + [0] * n # Loop over each number from 1 to n for i in range(1, n + 1): for j in range(i, n + 1): partitions[j] += partitions[j - i] return partitions[n]"},{"question":"# Context In the world of cryptography, there are many methods to encode and decode messages. One of the ancient methods is the Atbash cipher, which is a symmetric substitution cipher mapping each letter of an alphabet to its reverse. # Problem Statement Implement the Atbash cipher algorithm. Your task is to write a function that takes an input string and returns its Atbash cipher equivalent. # Function Signature ```python def atbash(s: str) -> str: pass ``` # Input - A string `s` where `1 <= len(s) <= 10^6`. The string can contain letters (both uppercase and lowercase) and symbols (spaces, punctuation). # Output - A string representing the Atbash ciphered text. # Constraints - Preserve the case of letters. - Non-alphabetic characters should remain unchanged. # Examples ```python assert atbash(\\"Attack at dawn\\") == \\"Zggzxp zg wzdm\\" assert atbash(\\"Hello World!\\") == \\"Svool Dliow!\\" assert atbash(\\"123 ABC xyz\\") == \\"123 ZYX cba\\" ``` # Notes - Aim for an efficient solution, considering the size of the input. - Optimize string operations for performance considerations.","solution":"def atbash(s: str) -> str: Returns the Atbash cipher equivalent of the given string. result = [] for char in s: if \'a\' <= char <= \'z\': result.append(chr(ord(\'z\') - ord(char) + ord(\'a\'))) elif \'A\' <= char <= \'Z\': result.append(chr(ord(\'Z\') - ord(char) + ord(\'A\'))) else: result.append(char) return \'\'.join(result)"},{"question":"# Scenario: You are tasked with designing a function to locate the `k`-th element from the end in a singly linked list. Given the head of a linked list, you need to implement an efficient solution to return the value of this `k`-th to last node. # Function Signature: ```python def find_kth_to_last(head: Node, k: int) -> str: ... ``` # Input: - The `head` of a singly linked list where each node\'s value is a string. - An integer `k` representing the position from the end of the list (0-based). # Output: - A string representing the value of the `k`-th to last node. - Raise an `IndexError` if `k` is invalid (e.g., larger than the list length or negative), or the list is empty. # Constraints: - The linked list contains at least one node and no more than (10^4) nodes. - Node values are non-empty strings. - Avoid using additional data structures that require space proportional to list size. # Examples: ```python # Example 1: # Input: head = Node(\\"A\\") -> Node(\\"B\\") -> Node(\\"C\\"), k = 1 # Output: \\"B\\" # Example 2: # Input: head = Node(\\"A\\") -> Node(\\"B\\"), k = 0 # Output: \\"B\\" # Example 3: # Input: head = Node(\\"X\\"), k = 0 # Output: \\"X\\" # Example 4: # Input: head = Node(\\"A\\") -> Node(\\"B\\"), k = 2 # Output: IndexError ``` # Requirements: - Ensure the solution is efficient, running in O(n) time with O(1) additional space. - Properly handle edge cases and invalid inputs.","solution":"class Node: def __init__(self, value): self.value = value self.next = None def find_kth_to_last(head: Node, k: int) -> str: if head is None or k < 0: raise IndexError(\\"Invalid k or empty list.\\") # Initialize two pointers slow = fast = head # Move fast pointer k steps ahead for i in range(k): if fast.next is None: raise IndexError(\\"k is larger than the number of nodes in the list.\\") fast = fast.next # Move both pointers until fast reaches the end while fast.next: slow = slow.next fast = fast.next return slow.value"},{"question":"You are given an array of words and an array of symbols. Your task is to write a function that returns the words with their matched symbol surrounded by square brackets. If a word matches more than one symbol, the longest matched symbol should be selected. # Function Signature ```python def match_and_bracket(words: List[str], symbols: List[str]) -> List[str]: ``` # Input - `words` (List[str]): A list of words (1 ≤ len(words) ≤ 10^4, 1 ≤ len(word) ≤ 100). - `symbols` (List[str]): A list of symbols (0 ≤ len(symbols) ≤ 100, 1 ≤ len(symbol) ≤ 100). # Output - Returns a list of words with matched symbols surrounded by square brackets. # Constraints - The function should aim for an efficient time complexity. - If no matches are found in a word, the word remains the same. - Each word can contain alphabets both in uppercase and lowercase. # Example ```python Input: words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] Output: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` # Note 1. In the example above, \'Am\' is the longest symbol found in \'Amazon\', \'cro\' is the longest match in \'Microsoft\', and \'le\' is the match found in \'Google\'. 2. The function should prioritize the longest symbol match. # Hints 1. Building a Trie from given symbols can help ensure efficient search and match operations. 2. Consider edge cases like empty words or symbols list, words with multiple potential matches of the same length, etc. Good luck!","solution":"from typing import List def match_and_bracket(words: List[str], symbols: List[str]) -> List[str]: # Sort symbols by length in descending order, so longest symbols come first sorted_symbols = sorted(symbols, key=len, reverse=True) # Resulting words after matching and bracketing symbols result = [] for word in words: matched = False for symbol in sorted_symbols: if symbol in word: word = word.replace(symbol, f\'[{symbol}]\') matched = True break result.append(word) return result"},{"question":"# Question: Identifying Added Character via XOR Objective Given two strings, `s` and `t`, where `t` is generated by shuffling `s` and adding one more character at a random position, write a function to find the character that was added. Input - `s`: a string consisting of lowercase English letters with length `n`. - `t`: a string consisting of lowercase English letters with length `n+1`, which is derived by shuffling `s` and adding an additional character. Output - A single character that is present in `t` but not in `s`. Constraints - The input strings will only contain lowercase letters. - The length of `t` will always be one more than the length of `s`. Implementation ```python def find_difference(s, t): This function uses the XOR operation to find the additional character in string t. :param s: Original string before the extra character was added. :param t: The string after an extra character is added to the original string s. :return: The single character that was added to create string t. ret = 0 for ch in s + t: ret = ret ^ ord(ch) return chr(ret) ``` Examples ```python # Example 1 s = \\"abcd\\" t = \\"abecd\\" # Expected output: \'e\' print(find_difference(s, t)) # Example 2 s = \\"xyz\\" t = \\"xyzq\\" # Expected output: \'q\' print(find_difference(s, t)) # Example 3 s = \\"mno\\" t = \\"nmoa\\" # Expected output: \'a\' print(find_difference(s, t)) ``` Performance Requirements The function must run within O(n) time complexity and use O(1) additional space complexity.","solution":"def find_difference(s, t): This function uses the XOR operation to find the additional character in string t. :param s: Original string before the extra character was added. :param t: The string after an extra character is added to the original string s. :return: The single character that was added to create string t. ret = 0 for ch in s + t: ret ^= ord(ch) return chr(ret)"},{"question":"# Question: Rotating Binary Search Tree Nodes You are given a class that implements a Binary Search Tree (BST) with basic functionalities such as inserting, searching, calculating size, and performing various types of tree traversals. Your task is to implement two additional functions in the `BST` class: 1. **Rotate Right**: This function should perform a right rotation on a specified node. 2. **Rotate Left**: This function should perform a left rotation on a specified node. Function Signatures ```python def rotate_right(self, root, node): \'\'\' Perform a right rotation on the subtree rooted at `node` and return the new root of the subtree. Args: - root (Node): The root of the BST. - node (Node): The node to perform rotation on. Returns: - Node: The new root of the subtree after rotation. \'\'\' pass def rotate_left(self, root, node): \'\'\' Perform a left rotation on the subtree rooted at `node` and return the new root of the subtree. Args: - root (Node): The root of the BST. - node (Node): The node to perform rotation on. Returns: - Node: The new root of the subtree after rotation. \'\'\' pass ``` Constraints * Rotations should maintain the properties of the BST. * Both methods (`rotate_right` and `rotate_left`) should preserve the inorder traversal of the BST. * The rotation should be performed only if the relevant node exists and can be rotated (i.e., nodes to be swapped are not `None`). Example ```python Before rotation: 10 / 5 20 / / 2 6 15 30 After rotate_right on node 10: 5 / 2 10 / 6 20 / 15 30 bst = BST() root = Node(10) root.left = Node(5) root.right = Node(20) root.left.left = Node(2) root.left.right = Node(6) root.right.left = Node(15) root.right.right = Node(30) # Rotate right on node 10 new_root = bst.rotate_right(root, root) assert new_root.data == 5 assert new_root.right.data == 10 Before rotation: 5 / 2 10 / 6 20 / 15 30 After rotate_left on node 10: 5 / 2 20 / 10 30 / 6 15 # Rotate left on node 10 new_root = bst.rotate_left(root, new_root.right) assert new_root.data == 5 assert new_root.right.data == 20 ``` Testing Create a comprehensive unittest suite to validate your implementation for various scenarios, including edge cases.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, root, key): if root is None: return Node(key) else: if root.val < key: root.right = self.insert(root.right, key) else: root.left = self.insert(root.left, key) return root def inorder_traversal(self, root): res = [] if root: res = self.inorder_traversal(root.left) res.append(root.val) res = res + self.inorder_traversal(root.right) return res def rotate_right(self, root, node): Perform a right rotation on the subtree rooted at `node` and return the new root of the subtree. if node is None or node.left is None: return node new_root = node.left node.left = new_root.right new_root.right = node return new_root def rotate_left(self, root, node): Perform a left rotation on the subtree rooted at `node` and return the new root of the subtree. if node is None or node.right is None: return node new_root = node.right node.right = new_root.left new_root.left = node return new_root"},{"question":"# Problem: Flatten Nested Arrays You are given an array which may contain nested arrays, mixed with other data types such as strings, integers, or other objects. Your task is to write a function `flatten_nested_arrays` which takes such an array and returns a single, flattened array containing all elements in the original order. Specifications - The function should handle multiple levels of nested arrays. - Strings should be treated as atomic elements and not split into characters. - Non-iterable elements should be directly appended to the result. Function Signature ```python def flatten_nested_arrays(arr: List[Any]) -> List[Any]: pass ``` Input - A list `arr` containing nested lists along with other data types. - `arr` can contain integers, strings, floats, nested lists, and other objects. - Length of `arr` is between 1 and 10^4. - Nesting depth will be at most 100. Output - A single list that is a flattened version of the input list. Constraints - You may not use any library utilities specifically meant for flatting arrays (like `itertools.chain` or `numpy.flatten`). - Aim for a time complexity close to O(n), where n is the total number of elements including nested ones. Example ```python Input: [1, [2, 3, [4]], \'text\', [5, [6, 7]]] Output: [1, 2, 3, 4, \'text\', 5, 6, 7] Input: [[1, 2, [3]], 4, [5, 6]] Output: [1, 2, 3, 4, 5, 6] Input: [[], [[]], [1, [2, [3]]]] Output: [1, 2, 3] ``` # Additional Notes - Consider the implications of deeply nested arrays and the recursion limits of your runtime environment. - Write test cases for edge cases like empty arrays, mixed data types, and deeply nested structures.","solution":"from typing import List, Any def flatten_nested_arrays(arr: List[Any]) -> List[Any]: def flatten(arr): for item in arr: if isinstance(item, list): yield from flatten(item) else: yield item return list(flatten(arr))"},{"question":"# Preorder Traversal of a Binary Tree You are given the root of a binary tree. Your task is to implement the preorder traversal algorithm both iteratively and recursively. The function should return a list of integers representing the node values in preorder traversal order. **Function Signature**: ```python def preorder(root: Node) -> List[int]: pass def preorder_rec(root: Node, res: List[int] = None) -> List[int]: pass ``` # Input - `root`: The root node of your binary tree (of type `Node`). # Output - A list of integers, returning the values of nodes visited in preorder. # Constraints - The binary tree node values are integers with no duplicate values. - The number of nodes in the binary tree will be between 1 and 10^4. # Performance Requirements - Your implementation should have a time complexity of O(n). - Aim for the space complexity to be O(h), where h is the height of the tree for both approaches. # Examples ```python # Consider the tree # 5 # / # 3 8 # / / # 1 4 7 9 # Example usage: root = Node(5, Node(3, Node(1), Node(4)), Node(8, Node(7), Node(9))) print(preorder(root)) # Output: [5, 3, 1, 4, 8, 7, 9] print(preorder_rec(root)) # Output: [5, 3, 1, 4, 8, 7, 9] ``` # Edge Cases to Consider - An empty tree (root is None) should return an empty list. - A tree with a single node. - Trees that are skewed to the left (all children are left nodes) and skewed to the right (all children are right nodes). Your task is to implement the iterative and recursive preorder traversal of a binary tree.","solution":"from typing import List, Optional class Node: def __init__(self, val: int, left: \'Optional[Node]\' = None, right: \'Optional[Node]\' = None): self.val = val self.left = left self.right = right def preorder(root: Optional[Node]) -> List[int]: Perform an iterative preorder traversal of a binary tree. if not root: return [] stack = [root] result = [] while stack: node = stack.pop() result.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return result def preorder_rec(root: Optional[Node], res: List[int] = None) -> List[int]: Perform a recursive preorder traversal of a binary tree. if res is None: res = [] if root: res.append(root.val) preorder_rec(root.left, res) preorder_rec(root.right, res) return res"},{"question":"# Scenario You are a professional burglar planning a series of heists on houses along a street. Each house has a specific stash of money, and you seek to maximize your earnings without tripping the automatic alarms. The security system triggers an alarm if you rob two adjacent houses on the same night. Given a list of non-negative integers, where each integer represents the money in a specific house, determine the maximum amount of money you can rob without triggering the alarms. # Requirements - **Function Name**: `max_robbery( houses: List[int]) -> int` - **Input**: A list of non-negative integers representing the money stashed in each house along a street. `houses` can be an empty list as well. - **Output**: An integer representing the maximum amount of money that can be robbed. # Constraints - The length of `houses` list will not exceed 10,000. - The money in each house will be in the range [0, 1000]. # Example ```python assert max_robbery([2, 7, 9, 3, 1]) == 12 # Rob houses with amounts 2, 9, and 1. assert max_robbery([5, 3, 4, 11, 2]) == 16 # Rob houses with amounts 5 and 11. assert max_robbery([]) == 0 # No houses to rob, so no money. ``` # Implementation Details - Consider edge cases where the list is empty. - Make sure your solution is optimal and does not exceed the time complexity of O(n) and space complexity of O(1). - Using dynamic programming, keep track of two variables to store results from previous computations to avoid excessive space usage.","solution":"from typing import List def max_robbery(houses: List[int]) -> int: Returns the maximum amount of money that can be robbed without triggering the alarms. if not houses: return 0 prev_max = 0 # previous maximum without robbing this house curr_max = 0 # current maximum with robbing this house for money in houses: new_max = max(curr_max, prev_max + money) prev_max = curr_max curr_max = new_max return curr_max"},{"question":"# Question: Generate All Possible Subsets You are given a set of distinct integers. Your task is to write a function `generate_subsets(nums)` that returns all possible subsets of the given set. The solution set must not contain duplicate subsets, and order inside subsets does not matter. However, subsequent calls should return subsets in a consistent sorted order. Function Signature ```python def generate_subsets(nums: List[int]) -> List[List[int]]: pass ``` Input - **nums**: A list of distinct integers `[a1, a2, ..., an]` where 0 <= n <= 10. Output - A list of lists, where each list is a possible subset of the input list. Constraints - The solution must handle edge cases gracefully. - Duplicate subsets are not allowed. Example ```python assert generate_subsets([1, 2, 3]) == [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] assert generate_subsets([]) == [[]] assert generate_subsets([1]) == [[], [1]] ``` # Scenario Imagine you are tasked with generating possible configurations for a set of switches (each switch can be on or off). Each configuration is a subset of switches that are on. For a given list of distinct integers representing switch indices, generate all possible configurations.","solution":"from typing import List def generate_subsets(nums: List[int]) -> List[List[int]]: Generates all possible subsets of the given list of distinct integers. Args: nums (List[int]): A list of distinct integers Returns: List[List[int]]: A list of lists, where each list is a possible subset of the input list nums.sort() # Ensure the input is sorted for consistent output order res = [] def backtrack(start, path): res.append(path) for i in range(start, len(nums)): backtrack(i + 1, path + [nums[i]]) backtrack(0, []) return res"},{"question":"# Transitive Closure Calculation Scenario A telecommunication company is analyzing its network to improve connectivity. It wants to identify all potential communication paths among different towers. Given a directed graph representing the network of towers where an edge from tower (A) to tower (B) indicates that direct communication is possible from (A) to (B), your task is to compute the transitive closure of this network graph to determine all reachable towers from each tower. Task Implement a function `find_transitive_closure` that takes an integer `n` and a list of tuples as `edges` representing a directed graph, and returns the transitive closure matrix of the graph. ```python def find_transitive_closure(n, edges): # n is the number of vertices # edges is a list of tuples (source, target) pass ``` Input Format * An integer `n` (1 ≤ n ≤ 300) - number of vertices. * A list of tuples, `edges`, where each tuple (a, b) represents a directed edge from node `a` to node `b`. Output Format * A 2D list (matrix) of size `n x n` where `matrix[i][j]` is 1 if there is a path from vertex (i) to vertex (j), otherwise 0. Example ```python n = 4 edges = [(0, 1), (1, 2), (2, 3), (3, 0)] find_transitive_closure(n, edges) ``` Expected Output: ``` [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ] ``` Constraints and Limitations * The function should handle up to (n = 300) efficiently. * Assume the nodes are indexed from `0` to `n-1`. * Ensure the function is optimized to avoid deep recursion issues. * Focus on creating an efficient and readable solution.","solution":"def find_transitive_closure(n, edges): Computes the transitive closure of a directed graph. :param n: Number of vertices. :param edges: List of tuples (a, b) representing a directed edge from node a to node b. :return: n x n matrix where matrix[i][j] is 1 if there is a path from vertex i to vertex j, otherwise 0. # Initialize the transitive closure matrix with 0s closure = [[0] * n for _ in range(n)] # Add the given edges to the closure matrix for (a, b) in edges: closure[a][b] = 1 # Each vertex can reach itself for i in range(n): closure[i][i] = 1 # Floyd-Warshall algorithm to compute transitive closure for k in range(n): for i in range(n): for j in range(n): closure[i][j] = closure[i][j] or (closure[i][k] and closure[k][j]) return closure"},{"question":"# Question You are given an array of integers and a target value. Design a function `find_two_sum` that returns the indices of the two numbers in the array such that they add up to the target value. **Function Signature:** ```python def find_two_sum(array: List[int], target: int) -> Tuple[int, int]: pass ``` **Input:** - `array` (List[int]): A list of integers. - `target` (int): The target sum value. **Output:** - Returns a tuple (int, int), which are the indices of the two numbers that add up to the target. **Constraints:** - Each input will have exactly one solution. - You cannot use the same element twice. - You should try to achieve a solution with O(n) time complexity. **Example:** ```python find_two_sum([2, 7, 11, 15], 9) ``` Expected output: ``` (0, 1) ``` Explanation: - Because nums[0] + nums[1] = 2 + 7 = 9, return the indices (0, 1). **Scenario**: You are working with a financial software system that tracks individual transactions. The records are kept in an array format. Your task is to identify two transactions that together sum to a specific amount, for reconciliation purposes. Thus, your function will help in quickly identifying these transactions.","solution":"from typing import List, Tuple def find_two_sum(array: List[int], target: int) -> Tuple[int, int]: Returns the indices of the two numbers in the array such that they add up to the target value. hash_map = {} for i, num in enumerate(array): complement = target - num if complement in hash_map: return (hash_map[complement], i) hash_map[num] = i # Example print(find_two_sum([2, 7, 11, 15], 9)) # should return (0, 1)"},{"question":"You are working on a system that needs to reliably encode a list of strings into a single string and decode it back. Your solution should handle special edge cases such as strings containing the delimiter or empty strings. # Task: Write two functions `encode` and `decode`: * `encode(strs: List[str]) -> str`: Encodes a list of strings to a single string. * `decode(str: str) -> List[str]`: Decodes a single string back to a list of strings. # Input Format: * `encode` accepts a list of strings `strs` with length in the range [0, 1000]. Each string in `strs` will be composed of ASCII characters and may be empty. * `decode` accepts a string `s` which represents an encoded version of a list of strings. # Output Format: * `encode` returns a single string that is the encoded version of the list. * `decode` returns a list of strings that were encoded in the input string. # Constraints: * The functions should efficiently handle lists of strings where individual strings can be empty and may include the delimiter `\':\'`. * Ensure that both functions (`encode` and `decode`) maintain linear time complexity relative to the total number of characters processed. * Avoid using pre-built serialization functions such as `json.dumps` or `pickle`. # Example: ```python # Example for encode input_list = [\\"hello\\", \\"world\\", \\"\\", \\"python:3\\"] encoded_string = encode(input_list) print(encoded_string) # Expected Output: \\"5:hello5:world0:6:python:3\\" # Example for decode encoded_string = \\"5:hello5:world0:6:python:3\\" output_list = decode(encoded_string) print(output_list) # Expected Output: [\\"hello\\", \\"world\\", \\"\\", \\"python:3\\"] ```","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. encoded = \'\'.join(f\'{len(s)}:{s}\' for s in strs) return encoded def decode(s: str) -> List[str]: Decodes a single string back to a list of strings. i = 0 strs = [] while i < len(s): j = s.find(\':\', i) length = int(s[i:j]) i = j + 1 strs.append(s[i:i+length]) i += length return strs"},{"question":"You are tasked with designing a text-based predictive system similar to the one used in old mobile phones. The system should generate all possible letter combinations that a given digit string could represent, based on a predefined digit-to-letter mapping. Function Signature ```python def letter_combinations(digits: str) -> List[str]: pass ``` # Input - A string `digits` consisting of digits from \'2\' to \'9\'. (1 ≤ `|digits|` ≤ 10) # Output - A list of strings representing all possible letter combinations that the number string could represent. # Constraints - The input string will only contain digits from \'2\' to \'9\', inclusive. - The solution should handle up to 10 characters in the input string efficiently. # Example Example 1 **Input**: `digits = \\"23\\"` **Output**: `[\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"]` Example 2 **Input**: `digits = \\"5\\"` **Output**: `[\\"j\\", \\"k\\", \\"l\\"]` # Instructions 1. Implement the function `letter_combinations(digits: str) -> List[str]`. 2. Ensure the function adheres to the input and output format described. 3. You are encouraged to think about both time and space complexity of your solution. 4. Handle edge cases such as empty input strings.","solution":"from typing import List def letter_combinations(digits: str) -> List[str]: if not digits: return [] digit_to_chars = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_chars = digit_to_chars[digits[index]] for char in possible_chars: path.append(char) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"# Regular Expression Matching Challenge Objective Implement a function to perform regular expression matching with support for \'.\' and \'*\'. Context You are developing a text processing tool and need to implement a core function to match text strings against patterns that include wildcards and repetition markers. This function must ensure that the entire input string is matched against the given pattern. Function Signature ```python def is_match(s: str, p: str) -> bool: Determines if the given string `s` matches the pattern `p`. Parameters: - s: Input string containing only lowercase letters. - p: Pattern string containing only lowercase letters, \'.\' (matches any single character), and \'*\' (matches zero or more of the preceding character). Returns: - bool: True if the entire string `s` matches the pattern `p`, otherwise False. ``` Input - `s`: A non-empty string (1 <= len(s) <= 1000), containing only lowercase letters. - `p`: A potentially empty pattern (0 <= len(p) <= 1000), containing only lowercase letters, \'.\' and \'*\'. Output - Return `True` if the string `s` matches the pattern `p` entirely, otherwise return `False`. Constraints - The pattern should match the entire input string, not just a substring. Examples ```python assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"aa\\", \\"aa\\") == True assert is_match(\\"aaa\\", \\"aa\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"aa\\", \\".*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True ``` Requirements 1. Implement support for \'.\' which matches any single character. 2. Implement support for \'*\' which matches zero or more of the preceding element. **Note**: Ensure optimal performance with respect to both time and space complexity. Aim for a solution with a time complexity of O(n * m) and a space complexity of O(n * m), where n is the length of the input string `s` and m is the length of the pattern `p`.","solution":"def is_match(s: str, p: str) -> bool: Determines if the given string `s` matches the pattern `p`. Parameters: - s: Input string containing only lowercase letters. - p: Pattern string containing only lowercase letters, \'.\' (matches any single character), and \'*\' (matches zero or more of the preceding character). Returns: - bool: True if the entire string `s` matches the pattern `p`, otherwise False. memo = {} def dp(i, j): if (i, j) in memo: return memo[(i, j)] if j == len(p): ans = i == len(s) else: first_match = i < len(s) and p[j] in {s[i], \'.\'} if j + 1 < len(p) and p[j+1] == \'*\': ans = dp(i, j+2) or (first_match and dp(i+1, j)) else: ans = first_match and dp(i+1, j+1) memo[(i, j)] = ans return ans return dp(0, 0)"},{"question":"# Balanced Binary Tree Checker Context You are working with binary trees in your current project and need to ensure that the trees used are balanced for optimal performance in various operations. You decide to write a function that checks whether a given binary tree is balanced. Task Write a Python function `is_balanced(root)` that returns `True` if the given binary tree is balanced and `False` otherwise. Input * The input is a binary tree represented by its root node. The tree node class is defined as follows: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` Output * The output should be a boolean value: `True` if the tree is balanced, and `False` otherwise. Example # Example 1: Input: ```plaintext 1 / 2 3 / 4 5 ``` Output: ```plaintext True ``` # Example 2: Input: ```plaintext 1 / 2 / 3 ``` Output: ```plaintext False ``` Constraints * The number of nodes in the tree is in the range `[0, 10^4]`. * The value of each node is unique. Notes * Use the depth-first search (DFS) approach to determine the balance of the tree. * Ensure the solution is efficient in both time and space.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_balanced(root): def check_balance(node): if not node: return 0, True left_height, is_left_balanced = check_balance(node.left) right_height, is_right_balanced = check_balance(node.right) current_height = 1 + max(left_height, right_height) current_balance = is_left_balanced and is_right_balanced and abs(left_height - right_height) <= 1 return current_height, current_balance _, balance = check_balance(root) return balance"},{"question":"# Question: You are tasked with implementing a feature in a software system that helps analyze network connectivity. The network is modeled as an undirected graph where nodes represent servers and edges represent direct connections between servers. Your job is to determine the number of connected components (clusters of interconnected servers) in the network. Function Signature ```python def count_components(adjacency_list: List[List[int]], size: int) -> int: pass ``` # Input * `adjacency_list` (List[List[int]]): A list of lists where each list `adjacency_list[i]` contains the nodes connected to the node `i`. * `size` (int): The number of nodes in the graph (nodes are labeled from 1 to `size`). # Output * Return an integer representing the number of connected components in the graph. # Constraints * 1 <= `size` <= 10^5 * 0 <= `|adjacency_list[i]|` <= `size` - 1 for all valid `i` * The graph can be disconnected. # Example ```python def main(): node_count,edge_count = 6, 5 adjacency = [[], [2], [1, 4], [], [2, 6], [6], [4, 5]] print(\\"Total number of Connected Components are :\\", count_components(adjacency, node_count)) # Output: 2 ``` # Scenario Imagine you are developing a monitoring tool for a large-scale data center. This tool must periodically check and report the number of isolated clusters of servers. By detecting the number of connected components, you can identify isolated servers or groups within your data center, allowing you to take appropriate action to maintain network reliability. The challenge is to implement the `count_components` function that efficiently determines the number of these isolated clusters given the size of the network and the adjacency list representing the connections.","solution":"from typing import List def count_components(adjacency_list: List[List[int]], size: int) -> int: Counts the number of connected components in an undirected graph. Args: adjacency_list: List of lists where each list adjacency_list[i] contains the nodes connected to the node i. size: Number of nodes in the graph (nodes are labeled from 1 to size). Returns: int: The number of connected components in the graph. visited = [False] * (size + 1) def dfs(node): # Depth-First Search (DFS) to visit all nodes in this component stack = [node] while stack: current = stack.pop() for neighbor in adjacency_list[current]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) connected_components = 0 for node in range(1, size + 1): if not visited[node]: visited[node] = True connected_components += 1 dfs(node) return connected_components"},{"question":"# Cosine Similarity Implementation **Scenario**: In the field of natural language processing, one common task is comparing the similarity between different text documents. Another application could be in collaborative filtering where user preferences are compared to recommend items. Given this context, your task is to implement a function that computes the cosine similarity between two vectors. **Function Signature**: ```python def compute_cosine_similarity(vec1: List[float], vec2: List[float]) -> float: Calculate cosine similarity between given two vectors. :param vec1: First vector as a list of floats. :param vec2: Second vector as a list of floats. :return: Cosine similarity as a float. :raises ValueError: If the two vectors have different lengths. ``` **Input**: * `vec1`: List of floats representing the first vector. * `vec2`: List of floats representing the second vector. **Output**: * A float value representing the cosine similarity between `vec1` and `vec2`. **Constraints**: 1. Both `vec1` and `vec2` should be of the same length. 2. The vectors should contain at least one non-zero element to avoid division by zero. **Example**: ```python compute_cosine_similarity([1, 1, 1], [1, 2, -1]) # Output: 0.47140452079103173 ``` **Explanation**: In the example, the function first computes the norm of each vector, then calculates the dot product, and finally divides the dot product by the product of the norms to get the cosine similarity.","solution":"from typing import List import math def compute_cosine_similarity(vec1: List[float], vec2: List[float]) -> float: if len(vec1) != len(vec2): raise ValueError(\\"Vectors must be of the same length\\") dot_product = sum(a * b for a, b in zip(vec1, vec2)) norm_vec1 = math.sqrt(sum(a * a for a in vec1)) norm_vec2 = math.sqrt(sum(b * b for b in vec2)) if norm_vec1 == 0 or norm_vec2 == 0: raise ValueError(\\"Vectors must have at least one non-zero element to avoid division by zero\\") cosine_similarity = dot_product / (norm_vec1 * norm_vec2) return cosine_similarity"},{"question":"# Anagram Checker # Problem Description You are given two strings. Your task is to write a function that determines if the two strings are anagrams of each other. Two strings are considered anagrams if they contain the same characters in the same frequency. # Input * Two strings `s1` and `s2` consisting of lowercase alphabetic characters only. # Output * Return `True` if the strings are anagrams of each other, otherwise return `False`. # Constraints 1. `1 <= len(s1), len(s2) <= 10^5` 2. Both `s1` and `s2` consist of lowercase English letters only. # Examples ```python anagram(\\"apple\\", \\"pleap\\") -> True anagram(\\"apple\\", \\"cherry\\") -> False anagram(\\"\\", \\"\\") -> True anagram(\\"a\\", \\"b\\") -> False anagram(\\"aabbcc\\", \\"abcabc\\") -> True ``` # Implementation Implement the function `anagram(s1: str, s2: str) -> bool`: ```python def anagram(s1, s2): if len(s1) != len(s2): return False c1 = [0] * 26 c2 = [0] * 26 for c in s1: pos = ord(c) - ord(\'a\') c1[pos] += 1 for c in s2: pos = ord(c) - ord(\'a\') c2[pos] += 1 return c1 == c2 ``` Consider edge cases such as: * Strings of different lengths. * Empty strings. * Strings containing repeated characters in different orders. Elaborate and justify the algorithm\'s efficiency in terms of time and space complexity.","solution":"def anagram(s1, s2): Determines if the two strings are anagrams of each other. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if s1 and s2 are anagrams, False otherwise. if len(s1) != len(s2): return False c1 = [0] * 26 c2 = [0] * 26 for c in s1: pos = ord(c) - ord(\'a\') c1[pos] += 1 for c in s2: pos = ord(c) - ord(\'a\') c2[pos] += 1 return c1 == c2"},{"question":"# Binary Tree to Doubly Linked List Conversion **Problem Statement**: You are asked to convert a given Binary Search Tree (BST) into a sorted doubly linked list. Each node in the doubly linked list should be linked in sorted order, and you must modify the tree\'s structure in place. Specifically, the left pointers in the BST should become previous pointers in the doubly linked list, and the right pointers should become next pointers. **Function Signature**: ```python def bst_to_doubly_linked_list(root: TreeNode) -> TreeNode: pass ``` **Input**: - `root`: A `TreeNode`, representing the root of a binary search tree (BST). The `TreeNode` class is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` **Output**: - A `TreeNode`, representing the head of the resulting sorted doubly linked list. **Constraints**: - The number of nodes in the tree is in the range `[0, 1000]`. - `-10^5 <= Node.val <= 10^5` **Performance Requirements**: - Your solution should have O(n) time complexity, where n is the number of nodes in the BST. - The space complexity should be O(h), where h is the height of the tree, primarily due to the recursive stack usage. # Example Given the BST: ``` 4 / 2 5 / 1 3 ``` The function should return the head of the linked list: `1 <-> 2 <-> 3 <-> 4 <-> 5` **Explanation**: - The algorithm must traverse the tree in-order. - For each node, adjust pointers such that the left pointer becomes the previous pointer, and the right pointer becomes the next pointer in the doubly linked list. # Note: - You should not create new nodes, instead, adjust the pointers of existing nodes. - Ensure to handle edge cases such as an empty tree (`root` is `None`) or a single node in the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bst_to_doubly_linked_list(root: TreeNode) -> TreeNode: if not root: return None def inorder(node): nonlocal last, head if not node: return inorder(node.left) if last: last.right = node node.left = last else: head = node last = node inorder(node.right) last, head = None, None inorder(root) return head"},{"question":"Scenario You are developing a software tool that helps format license keys. License keys often come in an unformatted string with dashes possibly placed at random intervals. The goal is to reorganize these keys so that they become more readable and standardized. Task Write a function `format_license_key` that takes two inputs: a string `key` representing the unformatted license key, and an integer `k` representing the group size for the formatting. The function should: * Remove all non-alphanumeric characters (specifically dashes). * Reformat the remaining alphanumeric characters into groups of size `k`, separated by dashes (`-`) from right to left. Input * `key`: A string containing the license key, which may include alphanumeric characters and dashes (`-`). * `k`: An integer representing the size of each group. Output * Return a string representing the reformatted license key. Constraints * The input string `key` will have a length between 0 and 10,000. * The integer `k` will be a positive number no larger than 10,000. Performance Requirements * The function should be efficient in both time and space, ideally O(n) for both, where n is the length of the input string. Example 1. For `key = \\"2-5g-3-J\\"` and `k = 2`, the function should return `\\"2-5G-3J\\"`. 2. For `key = \\"2-4-A0r7-4k\\"` and `k = 3`, the function should return `\\"24-A0R-74K\\"`. Additional Notes * The output should be in uppercase characters. * Make sure to handle edge cases, such as empty input or input strings with no alphanumeric characters. ```python def format_license_key(key, k): # Your implementation here pass ```","solution":"def format_license_key(key, k): Reformat the license key such that: 1. Remove all non-alphanumeric characters. 2. Split the characters into groups of size k, from right to left. 3. Ensure all characters are uppercase. # Remove dashes and convert to uppercase. alphanumeric_key = key.replace(\'-\', \'\').upper() # Determine the length of the first group. first_group_length = len(alphanumeric_key) % k # Initialize the list to hold parts of the formatted key. groups = [] # Handle the first group if it is non-zero in length. if first_group_length > 0: groups.append(alphanumeric_key[:first_group_length]) # Process the remaining characters in chunks of size k. for i in range(first_group_length, len(alphanumeric_key), k): groups.append(alphanumeric_key[i:i + k]) # Join the groups with dashes. formatted_key = \'-\'.join(groups) return formatted_key"},{"question":"Problem Statement: You are given a `Polynomial` class and a `Monomial` class representing single-variable monomials and multivariable polynomials, respectively. These classes allow various operations like addition, subtraction, multiplication, and division of monomials and polynomials. You need to extend the functionality of the `Polynomial` class to implement polynomial differentiation. For a given polynomial, you need to return its derivative. Requirements: - Implement a method `derivative` in the `Polynomial` class. - The method should return a new `Polynomial` that is the derivative of the original polynomial. Expected Input and Output Formats: - The `Polynomial` class is initialized with a list of Monomials. - Method: `def derivative(self) -> Polynomial` - No specific constraints on coefficients and variables. Example: ```python # Example Instantiation m1 = Monomial({1: 2}, 3) # Represents 3*a1^2 m2 = Monomial({2: 1}, -4) # Represents -4*a2 p = Polynomial([m1, m2]) # Derivative dp = p.derivative() # Should return a `Polynomial` representing: # 6*a1 - 4 (assuming a1 and a2 are treated independently) print(dp) # Output should be \\"6(a1) + (-4)\\" ``` Instructions: 1. Carefully consider edge cases, such as differentiation of constants or variables with zero coefficients. 2. Ensure the derivative method simplifies the resulting Polynomial correctly. 3. Write clean and efficient code. Additional Tips: - Remember how differentiation works: the derivative of `a*x^n` is `a*n*x^(n-1)`. - Make sure the derivative of constants is zero.","solution":"class Monomial: def __init__(self, exponents, coefficient): self.exponents = exponents self.coefficient = coefficient def derivative(self): derivatives = [] for var, exp in self.exponents.items(): if exp > 0: new_exponents = self.exponents.copy() new_exponents[var] = exp - 1 if new_exponents[var] == 0: del new_exponents[var] new_coefficient = self.coefficient * exp derivatives.append(Monomial(new_exponents, new_coefficient)) return derivatives class Polynomial: def __init__(self, monomials): self.monomials = monomials def derivative(self): derived_monomials = [] for monomial in self.monomials: derived_monomials.extend(monomial.derivative()) return Polynomial(derived_monomials) def __str__(self): if not self.monomials: return \\"0\\" parts = [] for monomial in self.monomials: coeff = monomial.coefficient if not monomial.exponents: parts.append(f\\"{coeff}\\") else: terms = [] for var, exp in monomial.exponents.items(): if exp == 1: terms.append(f\\"a{var}\\") else: terms.append(f\\"a{var}^{exp}\\") parts.append(f\\"{coeff}*{\'*\'.join(terms)}\\") return \\" + \\".join(parts)"},{"question":"Implement Gnome Sort with Enhancements Objective Demonstrate your understanding of sorting algorithms by implementing the Gnome Sort with a preprocessing step that counts and skips already sorted segments. Problem Statement You are given an array of integers. Your task is to implement an enhanced version of the Gnome Sort algorithm that includes an additional preprocessing step. This step should quickly pass through the list to count and skip already sorted segments, reducing unnecessary comparisons. - **Function Signature**: `def enhanced_gnome_sort(arr: List[int]) -> List[int]:` Input * A list of integers, `arr` (1 ≤ len(arr) ≤ 10^3). Output * Returns the sorted list in non-decreasing order. Constraints * The list may contain duplicate elements. * Your solution should handle edge cases like empty lists and single-element lists gracefully. * Aim to minimize the number of swaps compared to the original gnome sort. Examples ```python assert enhanced_gnome_sort([34, 2, 10, -9]) == [-9, 2, 10, 34] assert enhanced_gnome_sort([3, 0, 2, 5, -1]) == [-1, 0, 2, 3, 5] assert enhanced_gnome_sort([1]) == [1] assert enhanced_gnome_sort([]) == [] ``` Performance Requirements * Your solution should aim to improve the performance of the worst-case scenario compared to the basic gnome sort, even if marginally. Scenario Consider a scenario where you are managing a simple data processing tool that frequently receives small datasets, often with segments already sorted. The enhanced gnome sort algorithm can make the sorting step more efficient in such cases, especially when partial order is present.","solution":"from typing import List def enhanced_gnome_sort(arr: List[int]) -> List[int]: Sorts an array using an enhanced version of the Gnome Sort algorithm with preprocessing. n = len(arr) # Early exit for empty or single-element lists if n <= 1: return arr # Preprocessing step: count and skip already sorted segments index = 0 while index < n - 1: if arr[index] <= arr[index + 1]: index += 1 else: break # Gnome sort with pointer starting from the end of the sorted segment while index < n: if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"You are tasked with enhancing a number validation system that identifies prime numbers. Your goal is to implement an optimized version of a function to check prime numbers. You must ensure that the implemented function is efficient and handles large inputs reasonably well, given the constraints. # Task Implement a function `is_prime(n: int) -> bool` that takes an integer `n` as input and returns a boolean indicating whether `n` is a prime number. # Input * An integer `n` where `1 <= n <= 10^9`. # Output * The function should return `True` if `n` is a prime number, and `False` otherwise. # Constraints 1. `1 <= n <= 10^9` 2. The function should run with a time complexity of O(√n). # Example ```python assert is_prime(1) == False assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(17) == True assert is_prime(25) == False assert is_prime(7919) == True ``` # Requirements * Your solution should efficiently handle numbers up to one billion (`10^9`). * Consider edge cases, such as very small and very large numbers within the given range. * Optimize the function to avoid unnecessary calculations. # Additional Information 1. **Primes**: A prime number is defined as a natural number greater than 1 that has no positive divisors other than 1 and itself. 2. **Non-primes**: These include numbers that can be divided evenly by numbers other than 1 and themselves. 3. **Efficiency**: Use mathematical properties (such as the 6k ± 1 optimization) to minimize the number of checks and improve performance.","solution":"import math def is_prime(n: int) -> bool: Checks whether the integer n is a prime number. Parameters: n (int): The number to check for primality. Returns: bool: True if n is a prime number, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Context Imagine you are developing a text processing feature for a word processing application. The feature needs to highlight certain substrings (symbols) within words by surrounding the symbols with square brackets. If a word contains multiple symbols, the longest symbol should be selected. # Task Write a function `bracket_words(words, symbols)` that takes in a list of words and a list of symbols, and returns a new list where each word has its longest matching symbol surrounded by square brackets. If a word has no matching symbols, it should remain unchanged. # Function Signature ```python def bracket_words(words: List[str], symbols: List[str]) -> List[str]: ``` # Input * `words`: A list of strings where each string represents a word. * `symbols`: A list of strings where each string represents a symbol to be matched and highlighted in the words. # Output * A list of strings where each word has its longest matching symbol surrounded by square brackets. If no symbol matches, the word remains unchanged. # Examples ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] bracket_words(words, symbols) # Output: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` # Constraints * Each symbol can match zero or one part of the word. * If a word matches more than one symbol, choose the symbol with the longest length. * The input words and symbols will consist of only uppercase and lowercase English letters. * Length of words and symbols arrays will not exceed 10^3, and the length of each word and symbol will not exceed 10^2. # Notes * Consider using efficient search techniques and data structures to optimize your solution. * Handle edge cases such as words with no symbols and overlapping symbols accurately.","solution":"from typing import List def bracket_words(words: List[str], symbols: List[str]) -> List[str]: def find_longest_symbol(word, symbols): longest_symbol = \\"\\" for symbol in symbols: if symbol in word and len(symbol) > len(longest_symbol): longest_symbol = symbol return longest_symbol result = [] for word in words: longest_symbol = find_longest_symbol(word, symbols) if longest_symbol: word = word.replace(longest_symbol, f\\"[{longest_symbol}]\\") result.append(word) return result"},{"question":"# Red-Black Tree Modification: Implement Kth Smallest Element Finder Description You are given an implementation of a Red-Black Tree. Your task is to extend this implementation to include a function that finds the k-th smallest element in the tree. The k-th smallest element is the element that would appear at position k if the tree elements were sorted. Function Signature ```python def kth_smallest(self, k: int) -> int: pass ``` Input - `k`: An integer representing the k-th position (1-based) to find the smallest element. Output - An integer representing the k-th smallest element in the tree. Constraints - `1 ≤ k ≤ n` where `n` is the number of nodes in the Red-Black Tree. - The function should efficiently find the k-th smallest element using properties of the Red-Black Tree. Example Consider the following tree which is represented in an inorder manner: `[1, 2, 4, 5, 7, 8, 11, 14, 15]`. - `k = 1`: The k-th smallest element is `1`. - `k = 5`: The k-th smallest element is `7`. Task 1. Implement the `kth_smallest(self, k: int) -> int` function inside the `RBTree` class. 2. Ensure that the function efficiently finds the k-th smallest element without converting the entire tree to a list. Notes * Utilize the properties of the Red-Black Tree for optimization. * Consider augmenting the tree nodes to store additional information if necessary, such as the size of the subtree rooted at each node.","solution":"class Node: def __init__(self, data, color=\'red\', parent=None, left=None, right=None): self.data = data self.color = color self.parent = parent self.left = left self.right = right self.size = 1 # to store the size of the subtree rooted at this node class RBTree: def __init__(self): self.NIL_LEAF = Node(data=None, color=\'black\') self.root = self.NIL_LEAF def insert(self, data): new_node = Node(data) new_node.left = self.NIL_LEAF new_node.right = self.NIL_LEAF if self.root == self.NIL_LEAF: self.root = new_node self.root.color = \'black\' self.root.parent = None else: self.__insert_helper(self.root, new_node) self.__fix_insert(new_node) self.__update_sizes(new_node) def __insert_helper(self, current, new_node): if new_node.data < current.data: if current.left == self.NIL_LEAF: current.left = new_node new_node.parent = current else: self.__insert_helper(current.left, new_node) else: if current.right == self.NIL_LEAF: current.right = new_node new_node.parent = current else: self.__insert_helper(current.right, new_node) # Update the size of each node during backtracking current.size += 1 def __fix_insert(self, node): # Implementation of fixing the tree after insertion to restore Red-Black properties pass def __update_sizes(self, node): while node != None: node.size = (0 if node.left == self.NIL_LEAF else node.left.size) + (0 if node.right == self.NIL_LEAF else node.right.size) + 1 node = node.parent def kth_smallest(self, k): return self.__kth_smallest_helper(self.root, k) def __kth_smallest_helper(self, node, k): if node == self.NIL_LEAF: return None left_size = 0 if node.left == self.NIL_LEAF else node.left.size if left_size + 1 == k: return node.data elif left_size >= k: return self.__kth_smallest_helper(node.left, k) else: return self.__kth_smallest_helper(node.right, k - left_size - 1)"},{"question":"Scenario: You are working on a social networking platform. You need to analyze the connectivity of users within the platform. Specifically, you want to determine how many isolated groups (connected components) exist among users. Problem Statement: Write a Python function to count the number of connected components in an undirected graph. The graph will be represented by an adjacency list. Use Depth-First Search (DFS) to achieve this. Input: - The function will receive the following parameters: 1. `adjacency_list` (List[List[int]]): An adjacency list of the graph where `adjacency_list[i]` contains the nodes connected to node `i`. 2. `size` (int): The number of nodes in the graph. Output: - The function should return an integer representing the number of connected components in the graph. Constraints: - The number of nodes, `size`, will be a positive integer. - Nodes are numbered from 1 to `size`. - The graph will not contain any self-loops. - The graph can be disconnected or connected. Function Signature: ```python def count_connected_components(adjacency_list: List[List[int]], size: int) -> int: pass ``` Example: ```python # Example input adjacency_list = [ [], # Node 0 (dummy node, no connections) [2], # Node 1 connects to node 2 [1, 4, 5], # Node 2 connects to nodes 1, 4, and 5 [7], # Node 3 connects to node 7 [2, 6], # Node 4 connects to nodes 2 and 6 [2, 6], # Node 5 connects to nodes 2 and 6 [4, 5], # Node 6 connects to nodes 4 and 5 [3] # Node 7 connects to node 3 ] size = 7 # Expected output print(count_connected_components(adjacency_list, size)) # Output: 2 ``` Notes: - The function should be able to handle large graphs efficiently. - Edge cases such as no edges, fully connected graphs, and graphs with a single node should be considered.","solution":"from typing import List def count_connected_components(adjacency_list: List[List[int]], size: int) -> int: def dfs(node, visited): stack = [node] while stack: current = stack.pop() for neighbor in adjacency_list[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) visited = set() count = 0 for node in range(1, size + 1): if node not in visited: dfs(node, visited) count += 1 return count"},{"question":"# Question: Hybrid GCD and LCM Calculator Context: Your task is to develop a robust function that computes both the greatest common divisor (GCD) and least common multiple (LCM) of two given integers using a hybrid approach that leverages the Euclidean method for GCD and bitwise manipulations for LCM. Problem Statement: Write a function `hybrid_gcd_lcm(a, b)` that takes two non-zero integers `a` and `b` and returns a tuple containing two elements: first is the GCD and second is the LCM of the input integers. Ensure that your function handles edge cases robustly and is optimized for performance. # Function Signature: ```python def hybrid_gcd_lcm(a: int, b: int) -> (int, int): ``` # Input: - Two non-zero integers `a` and `b` where -10^9 ≤ a, b ≤ 10^9. # Output: - A tuple with two elements: - The first element is the GCD of `a` and `b`. - The second element is the LCM of `a` and `b`. # Constraints: - Your implementations should consider edge cases such as negative numbers while maintaining robustness. - Zero as an input should result in a ValueError exception. - Utilize both Euclidean and bitwise operations where effective. # Example Cases: Example 1: ```python a = 48 b = 18 Output: (6, 144) ``` Example 2: ```python a = -25 b = 100 Output: (25, 100) ``` Example 3: ```python a = -7 b = -3 Output: (1, 21) ``` # Notes: - Make sure to validate input values. - Address potential performance bottlenecks. - Think about how you can combine Euclidean and bitwise methods effectively.","solution":"def hybrid_gcd_lcm(a: int, b: int) -> (int, int): Calculate the GCD and LCM of two integers using Euclidean method for GCD and leveraging their properties for LCM. if a == 0 or b == 0: raise ValueError(\\"Input integers must be non-zero\\") def gcd(x, y): while y: x, y = y, x % y return abs(x) gcd_value = gcd(a, b) lcm_value = abs(a * b) // gcd_value return (gcd_value, lcm_value)"},{"question":"Implementing an Enhanced BST Iterator Context: You are given a Binary Search Tree (BST) and need to create an enhanced iterator class `EnhancedBSTIterator` that not only iterates through the BST in an in-order sequence but also provides a method to check if there are nodes before the current node in the in-order sequence (`has_prev`), and a method to move the iterator to the previous node (`prev`). This extends the typical in-order traversal iterator by allowing bidirectional traversal. Function Specification: Implement the following methods for `EnhancedBSTIterator`: 1. `__init__(self, root)`: Initialize the iterator with the root of the BST. 2. `has_next(self)`: Return `True` if there is a next node in the in-order traversal that hasn\'t been visited, otherwise return `False`. 3. `next(self)`: Return the value of the next node in the in-order traversal. 4. `has_prev(self)`: Return `True` if there is a previous node in the in-order traversal that can be visited again, otherwise return `False`. 5. `prev(self)`: Return the value of the previous node in the in-order traversal. Input: * The `EnhancedBSTIterator` class will be initialized with the root of the BST. * All methods will be called sequentially on an instance of `EnhancedBSTIterator`. Output: * `has_next` should return a boolean indicating if there is a next element. * `next` should return the value of the next node in the in-order sequence. * `has_prev` should return a boolean indicating if there is a previous element. * `prev` should return the value of the previous node in the in-order sequence. Example: ```python # Assume TreeNode is a class for tree nodes in a BST with properties: val (int), left (TreeNode), right (TreeNode) # Consider the following BST # 7 # / # 3 15 # / # 9 20 root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15) root.right.left = TreeNode(9) root.right.right = TreeNode(20) iterator = EnhancedBSTIterator(root) print(iterator.has_next()) # True print(iterator.next()) # 3 print(iterator.next()) # 7 print(iterator.has_prev()) # True print(iterator.prev()) # 3 print(iterator.has_next()) # True print(iterator.next()) # 7 print(iterator.next()) # 9 print(iterator.next()) # 15 print(iterator.next()) # 20 print(iterator.has_next()) # False ``` **Note**: You are required to write the entire `EnhancedBSTIterator` class, ensuring all methods are correctly implemented for bidirectional traversal in a BST.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class EnhancedBSTIterator: def __init__(self, root): self.stack = [] self.s = [] self.pointer = -1 self._leftmost_inorder(root) def _leftmost_inorder(self, root): while root: self.stack.append(root) root = root.left def has_next(self): return len(self.stack) > 0 or self.pointer + 1 < len(self.s) def next(self): self.pointer += 1 if self.pointer == len(self.s): top_node = self.stack.pop() self.s.append(top_node.val) self._leftmost_inorder(top_node.right) return self.s[self.pointer] def has_prev(self): return self.pointer > 0 def prev(self): self.pointer -= 1 return self.s[self.pointer]"},{"question":"# Scenario You are creating a tool to aggregate web data from various sources. To ensure uniform processing, you need to extract the domain names from a list of URLs. # Task Implement the function `extract_domain_name(url: str) -> str` that parses a given URL string and returns the domain name as a string. The function should adhere to the following requirements: # Requirements 1. Do not use any external libraries such as `re` (regular expressions) or `urlparse` except for the `.split()` built-in function. 2. Handle URLs with or without \'www\'. 3. Preserve all possible domain name structures, including hyphens. # Input * The function receives a single URL as a string. The URL format will be valid and within a reasonable length suitable for standard URLs. # Output * A single string representing the domain name extracted from the input URL. # Constraints * The input URL will conform to the standard URL structure. * The solution should take into account the proper extraction rules as demonstrated in the examples below. # Examples ```python extract_domain_name(\\"http://github.com/SaadBenn\\") == \\"github\\" extract_domain_name(\\"http://www.zombie-bites.com\\") == \\"zombie-bites\\" extract_domain_name(\\"https://www.cnet.com\\") == \\"cnet\\" extract_domain_name(\\"http://sub.domain.example.com/path\\") == \\"domain\\" extract_domain_name(\\"http://192.168.1.1/index.html\\") == \\"192\\" ``` # Edge Cases to Consider * URLs with subdomains * URLs that directly use IP addresses * Mixed protocols (http, https) # Additional Context For the purpose of this exercise, it is assumed that the URLs are correctly formatted and validated beforehand. Focus should be on accurately parsing and extracting domain names using the given constraints.","solution":"def extract_domain_name(url: str) -> str: Extracts the domain name from a given URL. Args: url (str): A URL string. Returns: str: The extracted domain name. # Remove protocol (http, https) if present if \\"://\\" in url: url = url.split(\\"://\\")[1] # Remove the path part after the domain name if \\"/\\" in url: url = url.split(\\"/\\")[0] # Handle URLs with \'www.\' and IP addresses if url.startswith(\\"www.\\"): url = url[4:] # Split by dots to handle domains and subdomains parts = url.split(\\".\\") # Determine the domain name if parts[0].isnumeric(): # handle IP address case domain_name = parts[0] else: if len(parts) > 2 and parts[1] not in [\'com\', \'org\', \'net\', \'edu\', \'gov\', \'mil\']: domain_name = parts[1] else: domain_name = parts[0] return domain_name"},{"question":"# Simplify Absolute Path **Context**: You are working with a simplified virtual file system and need to implement a function that can resolve complex and arbitrary Unix-style absolute file paths into their most simplified canonical forms. This is a common task in file system navigation and web routing. Given an absolute Unix file path, provide a simplified path by handling up-navigation (`\\"..\\"`), current directory (`\\".\\"`), and redundant slashes appropriately. Function Signature: ```python def simplify_path(path: str) -> str: pass ``` **Input**: - A string `path` representing an absolute Unix file path. **Output**: - A simplified canonical path string. **Constraints**: - The input path is a non-empty string prefixed with a `/`. - Path components are separated by `/`. **Examples**: - Input: `\\"/home/\\"`, Output: `\\"/home\\"` - Input: `\\"/a/./b/../../c/\\"`, Output: `\\"/c\\"` - Input: `\\"/../\\"`, Output: `\\"/\\"` - Input: `\\"/home//foo/\\"`, Output: `\\"/home/foo\\"` Detailed Instructions: 1. Parse the given absolute path and split by slashes `/`. 2. Initialize an empty stack to simulate the directory traversal. 3. Process each component of the path: - Ignore empty and current directory components `\\".\\"`. - If component is `\\"..\\"`, pop from the stack unless it is empty. - Otherwise, push the component to the stack. 4. Join the stack with slashes to form and return the simplified path. Ensure the returned path starts with `/`. Implement the `simplify_path` function to handle these cases and verify correctness with the examples provided.","solution":"def simplify_path(path: str) -> str: Simplify a Unix-style absolute file path. components = path.split(\'/\') stack = [] for component in components: if component == \'\' or component == \'.\': continue elif component == \'..\': if stack: stack.pop() else: stack.append(component) return \'/\' + \'/\'.join(stack)"},{"question":"Find the Single Number in an Array **Context**: Given an array of integers, you are required to identify the single number that appears only once when every other number appears exactly twice. This task uses the properties of the XOR bitwise operation to find the odd one out efficiently in linear time. **Task**: Implement a function `single_number` that returns the single number in the array. If all numbers appear twice, return 0. Function Signature ```python def single_number(nums: List[int]) -> int: ``` Input Format * `nums` (List[int]): A list of integers where every element appears exactly twice, except for one element. Output Format * Return the single integer that appears only once. Constraints * The function should run in O(n) time and use O(1) extra space. * The array will always have one unique element that does not appear twice. Examples Example 1: ```python single_number([2, 2, 1]) -> 1 ``` Example 2: ```python single_number([4, 1, 2, 1, 2]) -> 4 ``` Example 3: ```python single_number([1]) -> 1 ``` Notes: * Elements with multiple occurrences appear exactly twice. * The list could contain both positive and negative integers. * If all numbers in the array appear twice (which violates the problem\'s constraints), for this implementation, return 0. Guidelines Consider edge cases such as: * An array of length 1. * An array where the odd-numbered element is negative.","solution":"from typing import List def single_number(nums: List[int]) -> int: Finds the single number in the list that appears only once while every other number appears exactly twice. Utilizes the XOR operation to solve this in linear time. Args: nums (List[int]): List of integers where every element appears exactly twice except for one element. Returns: int: The single integer that appears only once. result = 0 for num in nums: result ^= num return result"},{"question":"# Objective: Implement functions to search and insert elements in a Binary Search Tree (BST). # Context: You are given the base structure of a TreeNode class for creating nodes in a binary search tree. ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None ``` # Task: 1. Implement the function `search_bst(root, val)` that searches for a given value in a BST and returns the node containing that value. 2. Implement the function `insert_bst(root, val)` that inserts a new node with a given value into the BST. # Input: - `search_bst(root, val)`: - `root`: Root node of the BST (of type TreeNode or None if tree is empty). - `val`: Value to search for (integer). - `insert_bst(root, val)`: - `root`: Root node of the BST (of type TreeNode or None if tree is empty). - `val`: Value to insert (integer). # Output: - `search_bst(root, val)`: - Returns the TreeNode containing the value if found, else None. - `insert_bst(root, val)`: - Returns the root node of the BST after the insertion. # Constraints: - Do not insert duplicate values. - All node values are unique integers. - Tree can contain between 0 and 10,000 nodes. # Example: ```python # Assume TreeNode class is already defined as given. # Example usages: # Creating a BST root = TreeNode(10) insert_bst(root, 5) insert_bst(root, 15) insert_bst(root, 3) insert_bst(root, 7) # Searching in a BST found_node = search_bst(root, 7) print(found_node.val if found_node else \\"Not Found\\") # Should print 7 not_found_node = search_bst(root, 8) print(not_found_node.val if not_found_node else \\"Not Found\\") # Should print \\"Not Found\\" ``` # Note: Return the modified root after an insertion operation and handle edge cases as described in the analysis.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def search_bst(root, val): Searches for a given value in a BST and returns the node containing that value. If the value is not found, returns None. if root is None or root.val == val: return root if val < root.val: return search_bst(root.left, val) else: return search_bst(root.right, val) def insert_bst(root, val): Inserts a new node with a given value into the BST. Returns the root node of the BST after the insertion. if root is None: return TreeNode(val) if val < root.val: root.left = insert_bst(root.left, val) elif val > root.val: root.right = insert_bst(root.right, val) return root"},{"question":"Detecting an Anagram Given two strings, write a function to determine if they are anagrams of each other. An anagram consists of characters that can be rearranged to form the other string of the same length. Please ensure the function handles uppercase and lowercase characters and disregards non-alphabetic characters. Function Signature ```python def is_anagram(s1: str, s2: str) -> bool: pass ``` Input Format * s1: A string containing alphabetic and possibly non-alphabetic characters. * s2: A string containing alphabetic and possibly non-alphabetic characters. Output Format * Returns `True` if `s1` and `s2` are anagrams, `False` otherwise. Constraints * 0 <= len(s1), len(s2) <= 10^5 * All inputs are valid strings. Example ```python print(is_anagram(\\"apple\\", \\"pleAp\\")) # Output: True print(is_anagram(\\"apple\\", \\"ch3rry\\")) # Output: False ``` Requirements * Time Complexity must be O(n). * Space Complexity must be O(1). Notes * Treat uppercase and lowercase letters as equal (e.g., \\"A\\" and \\"a\\" are the same). * Ignore non-alphabetic characters.","solution":"def is_anagram(s1: str, s2: str) -> bool: Determine if two strings are anagrams of each other, considering only alphabetic characters and ignoring case. from collections import Counter # Normalize the strings: convert to lowercase and filter only alphabetic characters s1_filtered = \'\'.join(filter(str.isalpha, s1.lower())) s2_filtered = \'\'.join(filter(str.isalpha, s2.lower())) # If the lengths of the filtered strings are different, they cannot be anagrams if len(s1_filtered) != len(s2_filtered): return False # Use Counter to count the characters in both filtered strings and compare return Counter(s1_filtered) == Counter(s2_filtered)"},{"question":"# Sorting Problem Using Counting Sort You have been given the task of sorting an array of integers using the Counting Sort algorithm. Counting Sort is particularly effective when the range of the array elements is small compared to the number of elements. The array may contain negative numbers as well, and you must handle them correctly. Write a function `counting_sort(arr)` that takes as input a list of integers and returns a new list with the integers sorted in non-decreasing order. Your implementation should follow the principles of the Counting Sort algorithm. Function Signature ```python def counting_sort(arr: List[int]) -> List[int]: ``` Input - `arr`: A list of integers, where `1 <= len(arr) <= 10^5` and `-10^4 <= arr[i] <= 10^4`. Output - A list of integers sorted in non-decreasing order. Constraints - The input list may contain negative numbers. - The algorithm should be implemented with an overall time complexity of O(n + k), where n is the number of elements in the input list and k is the range of elements. Example ```python # Example 1 arr = [4, 2, -1, 3, 2, -2, 1] print(counting_sort(arr)) # Output: [-2, -1, 1, 2, 2, 3, 4] # Example 2 arr = [7, 3, 2, 2, 5, 9, -5] print(counting_sort(arr)) # Output: [-5, 2, 2, 3, 5, 7, 9] ``` Notes 1. You should handle both positive and negative numbers. 2. Make sure to optimize for both time and space complexity. Additional Instructions 1. Avoid using built-in sorting methods. 2. Ensure that your implementation remains stable and handles edge cases effectively. 3. Consider using comments to explain the main steps of your code. 4. Test your solution with a variety of test cases to confirm its correctness and performance.","solution":"from typing import List def counting_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Counting Sort algorithm. if not arr: return [] # Find the minimum and maximum elements in the array min_elem = min(arr) max_elem = max(arr) # Range of the elements range_of_elements = max_elem - min_elem + 1 # Initialize the count array count = [0] * range_of_elements # Populate the count array for num in arr: count[num - min_elem] += 1 # Build the sorted array sorted_arr = [] for i in range(range_of_elements): sorted_arr.extend([i + min_elem] * count[i]) return sorted_arr"},{"question":"You are given a singly linked list. A singly linked list is a linear data structure where each element (called a node) contains a value and a reference (or link) to the next node in the sequence. You need to implement a function `is_sorted_descending(head)` that determines if the linked list is sorted in strictly decreasing order. Your function should return True if the list is sorted in strictly decreasing order and False otherwise. Consider an empty list or a single node list as sorted. Function Signature ```python def is_sorted_descending(head: \'ListNode\') -> bool: ``` Input - `head`: The head of the singly linked list. The definition of the `ListNode` class is provided below. Output - Return `True` if the list is sorted in strictly decreasing order, otherwise return `False`. Constraints - The number of nodes in the list is between 0 and 10^4. - Each node\'s value is an integer, where -10^5 leq text{node.val} leq 10^5. Definition of `ListNode` ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Example ```python # Example 1: # Input: 5 -> 3 -> 2 -> 1 # Output: True # Example 2: # Input: # Output: True # Example 3: # Input: 3 -> 3 -> 2 # Output: False # Example 4: # Input: 1 -> 2 -> 3 -> 4 # Output: False ``` Notes 1. Be careful about handling the edge cases such as an empty list or a list with a single node. 2. Remember to handle cases where elements might have the same value while ensuring the strictly decreasing order.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted_descending(head: ListNode) -> bool: Determines if the linked list is sorted in strictly decreasing order. if not head or not head.next: # An empty list or a single node list is considered sorted. return True current = head while current and current.next: if current.val <= current.next.val: return False current = current.next return True"},{"question":"# Question You are provided with two functions for converting integers between different bases: 1. `int_to_base(num, base)`: Converts an integer `num` to a string representation of that number in the provided `base`. 2. `base_to_int(str_to_convert, base)`: Converts a string representation of a number in the given `base` back to an integer. Your task is to implement a function that first converts a negative integer to a given base and then converts it back to the original base, preserving its sign correctly. # Function Signature ```python def convert_and_revert(num, base): :type num: int :type base: int :rtype: int pass ``` # Input - `num` (int): The integer to convert and revert, which can be negative. - `base` (int): The base to which the integer will be converted, ranging between 2 and 36. # Output - The original integer after performing the conversion to `base` and back. # Constraints - The provided base will always be between 2 and 36 inclusive. - The input integer `num` will be within the range of a typical 32-bit signed integer. # Example ```python assert convert_and_revert(-8, 2) == -8 assert convert_and_revert(15, 16) == 15 assert convert_and_revert(-100, 10) == -100 ``` # Evaluation Criteria - **Correctness**: The function must correctly convert an integer to a specified base and then convert it back to the same integer. - **Edge Cases**: Handle cases involving zero and negative numbers correctly. - **Efficiency**: Ensure that the solution performs efficiently within the given constraints.","solution":"def int_to_base(num, base): Convert an integer to a string representation in a given base if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" sign = \\"\\" if num < 0: sign = \\"-\\" num = -num result = \\"\\" while num > 0: remainder = num % base result = digits[remainder] + result num = num // base return sign + result def base_to_int(str_to_convert, base): Convert a string representation of a number in a given base back to an integer if str_to_convert[0] == \'-\': sign = -1 str_to_convert = str_to_convert[1:] else: sign = 1 digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" result = 0 for char in str_to_convert: result = result * base + digits.index(char) return sign * result def convert_and_revert(num, base): Convert an integer to a given base and then convert it back to the original integer. base_representation = int_to_base(num, base) reverted_num = base_to_int(base_representation, base) return reverted_num"},{"question":"# Question: You are given a binary array (an array consisting of only 0s and 1s). Your task is to write a function `find_zero_index_to_flip` that identifies the index of a 0 that can be replaced with a 1 to create the longest continuous sequence of 1s in the array. If there are no zeros in the array, the function should return -1. Function Signature: ```python def find_zero_index_to_flip(arr: List[int]) -> int: ``` Input: - A list `arr` of integers where each integer is either 0 or 1. Length of the list (n) is in the range of 1 to 10^5. Output: - An integer representing the index of the 0 to be replaced with 1 to achieve the longest continuous sequence of 1s. If no zeros are present, return -1. Constraints: - The input list `arr` will only contain 0s and 1s. Example: ```python find_zero_index_to_flip([1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1]) # Returns: 3 find_zero_index_to_flip([0, 1, 0, 1, 1, 1, 1, 0, 1, 1]) # Returns: 7 find_zero_index_to_flip([1, 1, 1, 1]) # Returns: -1 find_zero_index_to_flip([0, 0, 0, 0]) # Returns: 0 ``` Explanation: - In the first example, flipping the 0 at index 3 results in the longest sequence of 1s: 8 1s in a row. - In the second example, flipping the 0 at index 7 results in the longest sequence of 1s: 7 1s in a row. - In the third example, there are no 0s to flip, so the function returns -1. - In the fourth example, any 0 flipped results in the same length of sequence (just 1), so the function returns the first index, 0. Note: Be sure to handle edge cases effectively and ensure your solution is optimal for large inputs.","solution":"from typing import List def find_zero_index_to_flip(arr: List[int]) -> int: max_ones_length = 0 max_index_to_flip = -1 start = 0 last_zero_index = -1 for idx in range(len(arr)): if arr[idx] == 0: if last_zero_index == -1: last_zero_index = idx else: start = last_zero_index + 1 last_zero_index = idx current_length = idx - start + 1 if current_length > max_ones_length: max_ones_length = current_length max_index_to_flip = last_zero_index if last_zero_index == -1: return -1 return max_index_to_flip"},{"question":"# Dutch National Flag Problem Context You are given an array `nums` consisting of `n` integers where each integer is either `0`, `1`, or `2`. The goal is to sort the array such that all `0`s come first, followed by all `1`s, then followed by all `2`s. This problem is known as the \\"Dutch National Flag Problem\\" due to its characteristic separation of elements based on flags\' colors. Task Implement the function `sort_colors(nums: List[int]) -> None` which sorts the given list `nums` in-place, ensuring that the sorted array has all 0s before all 1s, which in turn come before all 2s. Input and Output - **Input**: A list of integers `nums` where each integer is either `0`, `1`, or `2`. - **Output**: The function doesn’t return anything. It modifies the input list `nums` in-place. Constraints - The function should operate with O(n) time complexity. - It should use constant space O(1) apart from the input list. - Do not use any built-in sorting functions. Example ```python nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output should be [0, 0, 1, 1, 2, 2] ``` Function Signature ```python from typing import List def sort_colors(nums: List[int]) -> None: # your code here ```","solution":"from typing import List def sort_colors(nums: List[int]) -> None: Sorts the given list nums in-place so that all 0s come first, followed by all 1s, then all 2s. Uses the Dutch National Flag algorithm. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: # nums[mid] == 2 nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"# Substring Search Challenge **Scenario**: You are developing a basic string search feature for a text editor, where users frequently need to find specific words or phrases within large documents. Currently, the feature uses a simple substring search algorithm, but you\'ve noticed it performs slowly on larger texts. Your task is to implement a function `contain_string(haystack, needle)` that returns the index of the first occurrence of the `needle` in the `haystack`, or -1 if the `needle` is not part of the `haystack`. To ensure efficiency and accuracy: - Ensure that your solution handles all potential edge cases. - Aim for a clear and maintainable code structure. - Your solution should correctly handle very long `haystack` strings and very short or empty `needle` strings. Input and Output * **Input**: - `haystack`: a string which is the main text to search within. - `needle`: a string which is the pattern to search for within the haystack. * **Output**: - An integer representing the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not found. Constraints - `haystack` and `needle` are composed of lowercase English characters. - The total length of `haystack` and `needle` can be up to 10,000 characters. Example ```python # Input: haystack = \\"hello\\", needle = \\"ll\\" # Output: 2 # Input: haystack = \\"aaaaa\\", needle = \\"bba\\" # Output: -1 ``` **Your implementation should handle the following edge cases effectively**: - Needle is an empty string (should return 0). - Needle is longer than the haystack (should return -1). - Haystack and needle are of significantly different lengths. **Optimize the performance where possible, and ensure robustness in handling special cases**. ```python def contain_string(haystack, needle): if len(needle) == 0: return 0 if len(needle) > len(haystack): return -1 for i in range(len(haystack)): if len(haystack) - i < len(needle): return -1 if haystack[i:i+len(needle)] == needle: return i return -1 ```","solution":"def contain_string(haystack, needle): Returns the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. if len(needle) == 0: return 0 return haystack.find(needle)"},{"question":"You are given an unsorted array `nums` of unique integers. Your task is to rearrange the elements in-place such that they follow the wiggle sort pattern: ``` nums[0] < nums[1] > nums[2] < nums[3].... ``` Write a function `wiggle_sort(nums: List[int]) -> None` which modifies the input list to fulfill the wiggle sort condition. # Input A list of integers with the following constraints: - `1 <= len(nums) <= 10^5` - `-10^6 <= nums[i] <= 10^6` - All elements are unique. # Output The function does not return any value. It should modify `nums` in place to satisfy the wiggle sort pattern. # Constraints - You must solve the problem in O(n) time complexity. - You must solve the problem with O(1) additional space complexity. # Examples Example 1: - Input: `[3, 5, 2, 1, 6, 4]` - Output: One possible solution is `[3, 5, 1, 6, 2, 4]` Example 2: - Input: `[1, 2, 3, 4, 5, 6, 7]` - Output: One possible solution is `[1, 3, 2, 5, 4, 7, 6]` # Additional Notes - It is guaranteed that any valid rearrangement that satisfies the wiggle sort pattern will be accepted. - Focus on writing clear and efficient code.","solution":"def wiggle_sort(nums): Modifies the array nums in-place to follow wiggle sort pattern nums[0] < nums[1] > nums[2] < nums[3].... for i in range(len(nums) - 1): if i % 2 == 0: if nums[i] > nums[i + 1]: nums[i], nums[i + 1] = nums[i + 1], nums[i] else: if nums[i] < nums[i + 1]: nums[i], nums[i + 1] = nums[i + 1], nums[i]"},{"question":"# Bubble Sort Optimization and Application Question **Scenario**: You are working as a software engineer for a company that deals with e-commerce data. One of your tasks includes sorting the total sales data for different products to display them in the monthly report. However, the dataset can vary significantly in size, thus requiring an efficient solution. **Coding Task**: Write a function `optimized_bubble_sort` that sorts an array using an optimized version of the Bubble Sort algorithm. In this optimized version, both the original Bubble Sort mechanism and the suggested optimization techniques (like early stopping when the list is already sorted) should be considered. # Function Signature: ```python def optimized_bubble_sort(arr: List[int]) -> List[int]: pass ``` # Input: - A list of integers `arr` (0 ≤ len(arr) ≤ 10^5, -10^6 ≤ arr[i] ≤ 10^6), where each element represents the total sales for a product. # Output: - A sorted list of integers in non-decreasing order. # Requirements: 1. Implement the optimized version of Bubble Sort. 2. Ensure the implementation is efficient enough to handle the upper constraints. 3. Consider all edge cases such as an empty list and a list with duplicate elements. **Example**: ```python # Example input arr = [5, 1, 4, 2, 8] # Example output print(optimized_bubble_sort(arr)) # Output: [1, 2, 4, 5, 8] ``` **Explanation**: The function `optimized_bubble_sort` should return the sorted form of the input list `arr`. The example shows an unordered list of integers representing sales, and the function returns them in sorted order.","solution":"def optimized_bubble_sort(arr): Sorts an array using an optimized version of the Bubble Sort algorithm, which includes early stopping if the array becomes sorted before completing full passes. Parameters: arr (list of int): The list of integers to sort. Returns: list of int: The sorted list. n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True # If no elements were swapped, the array is already sorted if not swapped: break return arr"},{"question":"# Combinatorial Calculation with Memoization You are working on a statistical analysis program, and an essential part requires you to frequently compute the binomial coefficient, which is the number of ways to choose `r` items from `n` items without regard to the order. Your task is to implement this functionality efficiently, utilizing memoization to avoid redundant calculations. **Function Signature**: ```python def combination_memo(n: int, r: int) -> int: pass ``` # Input: * `n` (integer): The total number of items. ( 0 leq n leq 1000 ). * `r` (integer): The number of items to choose. ( 0 leq r leq n ). # Output: * An integer representing the number of ways to choose `r` items from `n` items. # Constraints: * You must use memoization to optimize your solution. * You need to handle cases where the inputs are edge cases properly. # Examples: * `combination_memo(5, 2)` should return `10`. * `combination_memo(6, 3)` should return `20`. * `combination_memo(6, 0)` should return `1` (by definition, there is exactly one way to choose 0 items). # Notes: * Do not use any libraries or helper functions for combinations; implement the solution using raw Python. * Consider edge cases where `r = 0` or `r = n`. Implement the `combination_memo` function to pass all the given test cases efficiently.","solution":"def combination_memo(n: int, r: int, memo=None) -> int: Returns the number of ways to choose r items from n items, also known as the binomial coefficient C(n, r). Uses memoization to optimize repeated calculations. if memo is None: memo = {} # Base cases if r == 0 or r == n: return 1 if (n, r) in memo: return memo[(n, r)] # Recurrence relation C(n, r) = C(n-1, r-1) + C(n-1, r) memo[(n, r)] = combination_memo(n - 1, r - 1, memo) + combination_memo(n - 1, r, memo) return memo[(n, r)]"},{"question":"# Assessment Question: Ordered Stack Implementation Scenario: You are working on a feature that requires you to maintain a collection of elements with both the properties of a stack and an ordered list. Specifically, you must design an `OrderedStack` class that ensures the largest element is always on top and the smallest is at the bottom while allowing typical stack operations like push, pop, peek, and is_empty. Task: Implement the `OrderedStack` class with methods to maintain order upon element insertion. The class should support the following methods: 1. `__init__()`: Initializes an empty stack. 2. `is_empty() -> bool`: Returns True if the stack is empty, False otherwise. 3. `push(item: int)`: Adds an integer item to the stack and maintains the ordering. 4. `pop() -> int`: Removes and returns the top item from the stack. Raises an `IndexError` if the stack is empty. 5. `peek() -> int`: Returns the top item of the stack without removing it. Raise an `IndexError` if the stack is empty. 6. `size() -> int`: Returns the number of items in the stack. Input: - An integer item to be pushed onto the stack in the `push` method. - No input parameters required for other methods except `size`. Output: - Appropriate values returned as per the method descriptions. Constraints: - Values pushed into the stack are within the integer range. - The `pop` and `peek` methods should raise an `IndexError` when attempted on an empty stack. Example Usage: ```python stack = OrderedStack() stack.push(3) stack.push(1) stack.push(2) # The stack now should be ordered as [1, 2, 3] with 3 at top assert stack.pop() == 3 assert stack.peek() == 2 assert stack.size() == 2 assert not stack.is_empty() ``` Prepare your implementation considering corner cases and performance requirements to handle up to 1000 operations efficiently.","solution":"class OrderedStack: def __init__(self): self.stack = [] def is_empty(self) -> bool: return len(self.stack) == 0 def push(self, item: int): # Insert element maintaining order if self.is_empty(): self.stack.append(item) else: # Find the position where the item should be inserted inserted = False for i in range(len(self.stack)): if self.stack[i] > item: self.stack.insert(i, item) inserted = True break if not inserted: self.stack.append(item) def pop(self) -> int: if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.stack.pop() def peek(self) -> int: if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def size(self) -> int: return len(self.stack)"},{"question":"<|Analysis Begin|> **Algorithm/Data Structure**: Simplifying Unix-style file paths * **Type**: Path simplification algorithm, involving string manipulation and stack data structure. * **Main Purpose**: To convert a given absolute Unix-style file path to its canonical form by resolving `.` (current directory), `..` (parent directory), and `//` (redundant slashes). **Complexity**: * **Time Complexity**: O(n), where n is the length of the path string. This is because we process each character of the path once. * **Space Complexity**: O(n), where n is the length of the path string. This is due to the space required to store elements in the stack. **Core Operational Steps**: 1. Split the input path by slashes (`/`). 2. Iterate through each component of the path: - If the component is `..`, pop from the stack if the stack is not empty (to move up one directory). - If the component is `.`, an empty string, or redundant slashes, skip it. - Otherwise, push the component onto the stack. 3. Join the stack with slashes to produce the simplified path. **Properties**: * Resolves `.` to the current directory (no change). * Resolves `..` to the parent directory (stack pop). * Ignores consecutive slashes. **Common Use Cases**: * Simplifying file paths before navigating a file system. * Normalizing user input paths for consistent storage or comparison. * Preparing paths for security-related operations to prevent directory traversal attacks. **Strengths/Limitations**: * **Strengths**: Efficient time complexity, straightforward implementation, handles a variety of input formats robustly. * **Limitations**: Mainly designed for Unix-style paths, needs modification to work with different path formats (e.g., Windows). **Edge Cases**: * Empty path or root path `/`. * Paths containing multiple slashes. * Paths attempting to navigate beyond the root using `..`. **Performance Bottlenecks**: * None significant for typical input sizes. **Error Scenarios**: * Incorrect handling of `..` at the root level. * Misinterpretation of multiple consecutive slashes. **Optimization Points**: * The algorithm is relatively optimized for its purpose; further improvements would be context-specific, such as handling very large input paths or integrating with other file system operations. <|Analysis End|> <|Question Begin|> # Simplifying Unix-style File Paths Problem Description: Given an absolute path for a file (Unix-style), design a function that simplifies it and returns the canonical form of the path. The canonical path should: 1. Start with a single `/`. 2. Avoid redundant slashes (`//`). 3. Process all occurrences of `.` (the current directory) and `..` (the parent directory). Input Format: * A single string `path` representing the absolute file path. Output Format: * A string representing the simplified canonical path. Constraints: * The input path will only contain ASCII characters and be at most 3000 characters long. * The input path will always begin with `/`. Example Scenarios: * **Scenario 1:** * Input: `\\"/home/\\"` * Expected Output: `\\"/home\\"` * **Scenario 2:** * Input: `\\"/a/./b/../../c/\\"` * Expected Output: `\\"/c\\"` * **Scenario 3:** * Input: `\\"/../\\"` * Expected Output: `\\"/\\"` * **Scenario 4:** * Input: `\\"/home//foo/\\"` * Expected Output: `\\"/home/foo\\"` Function Signature: ```python def simplify_path(path: str) -> str: pass ``` Implement the `simplify_path` function to meet the above description and requirements.","solution":"def simplify_path(path: str) -> str: components = path.split(\'/\') stack = [] for component in components: if component == \'\' or component == \'.\': continue elif component == \'..\': if stack: stack.pop() else: stack.append(component) return \'/\' + \'/\'.join(stack)"},{"question":"# Question: Given the AbstractStack implementation and its two concrete implementations, ArrayStack and LinkedListStack, you are asked to enhance the LinkedListStack to include a method that reverses the stack. This method should not use any additional data structures, and the stack\'s LIFO property must be maintained after reversal. # Requirements: 1. Implement a method `reverse` for the `LinkedListStack`. 2. Ensure the stack is reversed in place. 3. Use the existing infrastructure only. You are not allowed to use Python\'s in-built list functionalities or any additional library. # Function Signature: ```python def reverse(self): # Your code here ``` # Input Format: None (since this is an instance method). # Output Format: None (the stack is modified in place). # Constraints: * The provided stack can contain any data type. * Maximum number of elements in the stack: (10^5) # Example Scenario: ```python stack = LinkedListStack() stack.push(1) stack.push(2) stack.push(3) stack.reverse() print(list(stack)) # Output should be [1, 2, 3] instead of [3, 2, 1] ```","solution":"class Node: def __init__(self, value=None, next=None): self.value = value self.next = next class LinkedListStack: def __init__(self): self.head = None self.size = 0 def is_empty(self): return self.head is None def push(self, value): new_node = Node(value, self.head) self.head = new_node self.size += 1 def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") value = self.head.value self.head = self.head.next self.size -= 1 return value def peek(self): if self.is_empty(): return None return self.head.value def reverse(self): prev = None current = self.head while current is not None: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def __iter__(self): current = self.head while current: yield current.value current = current.next def __len__(self): return self.size"},{"question":"**Roman to Integer Conversion Challenge** **Problem Statement**: You are tasked with converting Roman numerals into their respective integer values. A Roman numeral is represented by several characters: \'I\', \'V\', \'X\', \'L\', \'C\', \'D\', \'M\', with their paired values being 1, 5, 10, 50, 100, 500, and 1000 respectively. Roman numeral strings require certain rules, especially regarding subtractive combinations (e.g., IV for 4 and IX for 9). **Function Definition**: Write a function `roman_to_integer(roman: str) -> int` where: - **Input**: A string `roman` representing a Roman numeral (1 ≤ n ≤ 3999). - **Output**: An integer representing the numerical value of the Roman numeral. **Constraints**: - The input string is guaranteed to be a valid Roman numeral within the range from 1 to 3999. - The input will contain only the characters \'I\', \'V\', \'X\', \'L\', \'C\', \'D\', \'M\'. **Examples**: 1. `roman_to_integer(\'III\')` should return `3`. 2. `roman_to_integer(\'IX\')` should return `9`. 3. `roman_to_integer(\'LVIII\')` should return `58`. 4. `roman_to_integer(\'MCMXCIV\')` should return `1994`. **Requirements**: - The function should operate with a time complexity of O(n) and a space complexity of O(1). - Handle the standard subtractive combinations. **Additional Notes**: - You are not required to validate the input string further beyond what is assumed by the constraints.","solution":"def roman_to_integer(roman): Converts a Roman numeral to an integer. Args: roman (str): The Roman numeral as a string. Returns: int: The equivalent integer value of the Roman numeral. roman_values = {\'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000} total = 0 prev_value = 0 for char in reversed(roman): current_value = roman_values[char] if current_value >= prev_value: total += current_value else: total -= current_value prev_value = current_value return total"},{"question":"# Question: Remove a Specific Bit from an Integer You need to implement a function that removes a specific bit from an integer. Given an integer `num` and a bit position `i`, the function removes the bit at position `i` and returns the new integer formed. The bit positions are zero-indexed, starting from the least significant bit (rightmost). Function Signature: ```python def remove_bit(num: int, i: int) -> int: pass ``` Input: - `num` (int): The integer from which a specific bit needs to be removed. It can be either positive or negative. - `i` (int): The zero-indexed position of the bit to be removed from `num`. Output: - Returns the integer resulting from removing the bit at position `i`. Constraints: - The position `i` should be a valid bit position in the binary representation of the integer. - `num` can be in the range of [-2^31, 2^31 - 1]. - The function must handle the correct manipulation of the sign bit for negative numbers. Example: ```python assert remove_bit(21, 2) == 9 # 10101 -> 1001 (21 -> 9) assert remove_bit(21, 4) == 5 # 10101 -> 101 (21 -> 5) assert remove_bit(10, 0) == 5 # 1010 -> 101 (10 -> 5) assert remove_bit(-10, 1) == -6 # -1010 -> -110 (-10 -> -6) ``` Explanation: The function should work by removing the bit at the given position and shifting the remaining bits accordingly. For instance, if you remove the bit at position 2 in the number 21 (binary: 10101), the resulting number should be 9 (binary: 1001).","solution":"def remove_bit(num: int, i: int) -> int: Removes the bit at position `i` from `num` and returns the new integer. Parameters: - num: The integer to remove the specific bit from. - i: The zero-indexed position of the bit to be removed. Returns: - The new integer formed after removing the specified bit. # Separate the parts of the number around the bit to remove left_part = num >> (i + 1) # bits left of the bit to be removed right_part = num & ((1 << i) - 1) # bits right of the bit to be removed # Combine the left part and right part, effectively removing the specified bit result = (left_part << i) | right_part return result"},{"question":"# Hierarchical Data Structure Printer Problem Description You are provided with a hierarchical data structure in the form of a dictionary, where each key maps to a list of strings and integers. The dictionary represents nested categories and their items/subcategories. Write a function `tree_print(tree)` that prints the content in a formatted manner as shown in the given code snippet. Function Signature ```python def tree_print(tree: dict) -> None: ``` Input * `tree (dict)`: A dictionary where keys are strings and values are lists containing strings and integers. Output * The function should print the hierarchical data structure, following these rules: * Each key should be on a new line. * For each key, its associated list elements should be printed on the same line, separated by \\" -> \\". * If the element is not a string, print a newline and indent the next key-value pair. Constraints * The dictionary may contain up to (10^5) key-value pairs. * Each key\'s list contains up to (10^5) elements. * Keys and string elements are alphanumeric characters. * Elements are either strings or integers. Example Given the input dictionary: ```python tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6, \'Jill\', \'Sports\', 1], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, \'Quin\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } ``` The output should be: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` Assumptions * Assume proper formatting input will be provided (dictionary of lists). * You do not need to handle invalid or malformed inputs. # Performance Consideration * Ensure the function is efficient and handles large datasets within acceptable runtime limits.","solution":"def tree_print(tree: dict) -> None: Prints the hierarchical data structure in a formatted manner. for key, values in tree.items(): line = f\\"{key}\\" for value in values: if isinstance(value, int): print(line + f\\" -> {value}\\") line = \\" \\" else: line += f\\" -> {value}\\" if line.strip(): # To handle the case where last entry is not an int print(line)"},{"question":"# Red-Black Tree Deletion Red-Black Trees are a type of balanced binary search tree that maintain balance through the use of an additional property - the color (red or black) of each node. Insertion and deletion in a Red-Black Tree involves rotations and recoloring to ensure the tree remains balanced, guaranteeing O(log n) time complexity for search, insert, and delete operations. **Problem Statement:** Given a Red-Black Tree, your task is to implement the `delete_node` function that removes a node with a given value from the Red-Black Tree while maintaining all Red-Black properties. **Function Signature:** ```python class RBTree: ... def delete_node(self, value: int) -> None: ... ``` **Input:** - `value` (int): The value to be deleted from the tree. It is guaranteed that the value exists in the tree. **Output:** - None **Constraints:** - Values in the tree are unique. - The tree is a valid Red-Black Tree before the deletion. - After deletion, the tree must remain a valid Red-Black Tree. **Example:** ```python rbt = RBTree() values_to_insert = [11, 2, 14, 1, 7, 15, 5, 8, 4] for value in values_to_insert: rbt.insert(RBNode(value, 1)) # Tree before deletion # ([1, \\"black\\"], [2, \\"black\\"], [4, \\"black\\"], [5, \\"red\\"], [7, \\"black\\"], [8, \\"red\\"], [11, \\"black\\"], [14, \\"black\\"], [15, \\"red\\"]) rbt.delete_node(7) # Tree should remain balanced and maintain Red-Black properties # ([1, \\"black\\"], [2, \\"black\\"], [4, \\"black\\"], [5, \\"red\\"], [8, \\"black\\"], [11, \\"black\\"], [14, \\"black\\"], [15, \\"red\\"]) ``` **Instructions:** 1. Implement the `delete_node` function within the `RBTree` class. 2. Ensure all Red-Black properties are maintained after the deletion. 3. You may refer to the tree structure and helper functions (`left_rotate`, `right_rotate`, `transplant`, `fix_insert`, `delete_fixup`) given above, but do not modify their signatures or logic. **Note:** Your solution will be evaluated for correctness as well as for maintaining the balanced nature of the Red-Black Tree. Consider edge cases like deleting a node with two children or deleting the root node.","solution":"class RBNode: def __init__(self, value, color, left=None, right=None, parent=None): self.value = value self.color = color # 1 for Red, 0 for Black self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.NIL = RBNode(0, 0) # Sentinel node for leaf self.root = self.NIL def insert(self, node): # Implementation for insertion (Not provided in the question) pass def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.NIL: y.left.parent = x y.parent = x.parent if x.parent == self.NIL: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.NIL: y.right.parent = x y.parent = x.parent if x.parent == self.NIL: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y def transplant(self, u, v): if u.parent == self.NIL: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def tree_minimum(self, node): while node.left != self.NIL: node = node.left return node def delete_node(self, value: int) -> None: z = self.root while z != self.NIL: if z.value == value: break elif z.value < value: z = z.right else: z = z.left if z == self.NIL: return # Node not found, exit y = z y_original_color = y.color if z.left == self.NIL: x = z.right self.transplant(z, z.right) elif z.right == self.NIL: x = z.left self.transplant(z, z.left) else: y = self.tree_minimum(z.right) y_original_color = y.color x = y.right if y.parent == z: x.parent = y else: self.transplant(y, y.right) y.right = z.right y.right.parent = y self.transplant(z, y) y.left = z.left y.left.parent = y y.color = z.color if y_original_color == 0: self.delete_fixup(x) def delete_fixup(self, x): while x != self.root and x.color == 0: if x == x.parent.left: w = x.parent.right if w.color == 1: w.color = 0 x.parent.color = 1 self.left_rotate(x.parent) w = x.parent.right if w.left.color == 0 and w.right.color == 0: w.color = 1 x = x.parent else: if w.right.color == 0: w.left.color = 0 w.color = 1 self.right_rotate(w) w = x.parent.right w.color = x.parent.color x.parent.color = 0 w.right.color = 0 self.left_rotate(x.parent) x = self.root else: w = x.parent.left if w.color == 1: w.color = 0 x.parent.color = 1 self.right_rotate(x.parent) w = x.parent.left if w.left.color == 0 and w.right.color == 0: w.color = 1 x = x.parent else: if w.left.color == 0: w.right.color = 0 w.color = 1 self.left_rotate(w) w = x.parent.left w.color = x.parent.color x.parent.color = 0 w.left.color = 0 self.right_rotate(x.parent) x = self.root x.color = 0"},{"question":"# Context You have been tasked with implementing the Bitonic Sort algorithm, which will be used in a high-performance computing environment. The Bitonic Sort must be capable of sorting arrays both in ascending and descending order, and the input size must be a power of two. # Task Implement the `bitonic_sort` function to perform the Bitonic Sort. Ensure your implementation handles the following requirements: 1. The function should sort arrays with sizes that are powers of two. 2. The function should be able to sort in both ascending and descending orders based on the flag `reverse`. 3. If the input size is not a power of two, your function should raise a `ValueError` with the message \\"the size of input should be power of two\\". Additionally, write a function `batch_bitonic_sort` that accepts a list of lists (each representing an array), sorts each array using the `bitonic_sort` function, and returns the sorted arrays in a single list of lists. # Input - `arr`: List[int] - an array to be sorted (size must be a power of two). - `reverse`: bool - (optional) default is False. If True, sorts in descending order. # Output - List[int]: Sorted array. # Constraints - You must implement the `bitonic_sort` function and `batch_bitonic_sort` function. - Each element in the input arrays will be an integer within the range `[-10^6, 10^6]`. - Input list size `n` (for individual arrays) can be as large as `2^16`. # Performance Requirements - Your solution should be efficient, ideally close to the theoretical time complexity of O(n log^2(n)). # Functions ```python def bitonic_sort(arr, reverse=False): Sorts an array using bitonic sort algorithm. Parameters: arr (List[int]): The array to sort. reverse (bool): Whether to sort in descending order. Default is False. Returns: List[int]: Sorted array. def batch_bitonic_sort(arrays): Sorts a list of arrays using bitonic sort algorithm. Parameters: arrays (List[List[int]]): List of arrays to be sorted. Returns: List[List[int]]: Sorted list of arrays. ```","solution":"def bitonic_sort(arr, reverse=False): Sorts an array using the bitonic sort algorithm. Parameters: arr (List[int]): The array to sort. reverse (bool): Whether to sort in descending order. Default is False. Returns: List[int]: Sorted array. Raises: ValueError: if the size of the input array is not a power of two def bitonic_compare_and_swap(arr, i, j, direction): if (direction == (arr[i] > arr[j])): arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 for i in range(low, low + k): bitonic_compare_and_swap(arr, i, i + k, direction) bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort_recursive(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 bitonic_sort_recursive(arr, low, k, True) bitonic_sort_recursive(arr, low + k, k, False) bitonic_merge(arr, low, cnt, direction) def is_power_of_two(n): return (n > 0) and (n & (n - 1)) == 0 n = len(arr) if not is_power_of_two(n): raise ValueError(\\"the size of input should be power of two\\") bitonic_sort_recursive(arr, 0, n, not reverse) return arr def batch_bitonic_sort(arrays): Sorts a list of arrays using bitonic sort algorithm. Parameters: arrays (List[List[int]]): List of arrays to be sorted. Returns: List[List[int]]: Sorted list of arrays. return [bitonic_sort(arr) for arr in arrays]"},{"question":"# Palindrome Permutation Checker Context Given a string, determine if any permutation of the string\'s characters forms a palindrome. A permutation is a rearrangement of characters. A string is considered a palindrome if it reads the same forward and backwards (ignoring spaces, punctuation, and cases). Task Write a function `is_palindrome_permutation(s: str) -> bool` to determine if any permutation of the input string can be rearranged to form a palindrome, considering only alphanumeric characters and ignoring cases. Constraints - Input string can contain spaces, punctuation, and mixed cases. - The function should return `True` if any permutation forms a palindrome, `False` otherwise. - Consider an empty string as a valid palindrome permutation. Input/Output Formats - **Input**: `s` (string of length up to 10^6) - **Output**: `bool` (True/False) Example - **Input**: `\\"Tact Coa\\"` **Output**: `True` **Explanation**: Permutations of \\"Tact Coa\\" include \\"taco cat\\", \\"atco cta\\", etc. which are palindromes. - **Input**: `\\"hello\\"` **Output**: `False` **Explanation**: No permutation of \\"hello\\" can form a palindrome. Implementation Your solution needs to effectively preprocess the input string, handle large inputs efficiently, and determine the palindromic permutation property accurately.","solution":"from collections import Counter def is_palindrome_permutation(s: str) -> bool: Determine if any permutation of the input string can be rearranged to form a palindrome, considering only alphanumeric characters and ignoring cases. # Normalize the input string: ignore non-alphanumeric characters and convert to lowercase s = \'\'.join(filter(str.isalnum, s)).lower() # Count the frequency of each character char_count = Counter(s) # For a string to be able to form a palindrome: # It can have at most one character with an odd count (for odd-length palindromes) # For even-length palindromes, all characters must have even counts odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"Single Unique Element in a Cancellation Stream You are provided with a stream of integer-value and sign tuples. The goal is to determine if the stream is 1-sparse, meaning it effectively cancels out to a unique non-zero integer after considering the signs. If such a unique integer exists, return it; otherwise, return `None`. # Function Signature: ```python def one_sparse(array: List[Tuple[int, str]]) -> Optional[int]: ``` # Input: * `array` - A list of tuples. Each tuple contains two elements: - An integer `val` (0 <= `val` <= 10^9). - A string `sign` which can be either \'+\' or \'-\'. # Output: * An integer `unique` if the stream is 1-sparse. * `None` if the stream is not 1-sparse. # Constraints: * Process the stream in a single pass. * You may assume the stream length (n) is reasonably large. # Example: Example 1: ```python array = [(4,\'+\'), (2,\'+\'), (2,\'-\'), (4,\'+\'), (3,\'+\'), (3,\'-\')] print(one_sparse(array)) ``` Output: ```python 4 ``` Example 2: ```python array = [(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'), (2,\'+\')] print(one_sparse(array)) ``` Output: ```python 2 ``` Example 3: ```python array = [(2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (1,\'+\')] print(one_sparse(array)) ``` Output: ```python None ``` # Note: * Ensure your solution handles typical edge cases correctly. * Focus on maintaining efficient time and space complexity.","solution":"from typing import List, Tuple, Optional def one_sparse(array: List[Tuple[int, str]]) -> Optional[int]: counter = {} for val, sign in array: if sign == \'+\': counter[val] = counter.get(val, 0) + 1 elif sign == \'-\': counter[val] = counter.get(val, 0) - 1 unique = None for val, count in counter.items(): if count != 0: if unique is not None: # We already found another non-zero count, hence not 1-sparse. return None unique = val return unique"},{"question":"You are required to implement a more efficient version of the Separate Chaining Hash Table data structure that supports dynamic resizing to ensure optimal performance. Your task is to extend the given implementation by adding resizing functionality and improving overall efficiency. # Requirements: 1. **Resizing**: Implement a resizing mechanism that dynamically doubles the hash table size when the load factor exceeds 0.75 and halves the size when the load factor falls below 0.25. 2. **Hash Function**: Improve the hash function to minimize collisions. 3. **Unit Tests**: Write unit tests to cover typical and edge cases. # Function Signatures: ```python class SeparateChainingHashTable(object): def __init__(self, size=11): # Existing implementation pass def put(self, key, value): # Existing implementation pass def get(self, key): # Existing implementation pass def del_(self, key): # Existing implementation pass def __len__(self): # Existing implementation pass def resize(self, new_size): # New method to handle resizing pass def hash(self, key): # Improved hash function pass ``` # Implementation Constraints: 1. Methods should efficiently handle both average and worst cases. 2. Avoid global variables; encapsulate state within the class. 3. Ensure that unit tests cover: * Basic operations (put, get, del_) * Resizing triggers * Handling of edge cases # Example Scenarios: ```python import unittest class TestSeparateChainingHashTable(unittest.TestCase): def test_insert_and_retrieve(self): table = SeparateChainingHashTable() table.put(\'key1\', \'value1\') self.assertEqual(table.get(\'key1\'), \'value1\') def test_resize_up(self): table = SeparateChainingHashTable(size=2) # Add enough elements to trigger resize for i in range(10): table.put(f\'key{i}\', f\'value{i}\') self.assertTrue(table._len > 2) def test_resize_down(self): table = SeparateChainingHashTable(size=16) # Add and remove elements to trigger resize down for i in range(10): table.put(f\'key{i}\', f\'value{i}\') for i in range(10): table.del_(f\'key{i}\') self.assertTrue(table.size < 16) # Add more tests as needed ``` # Submission: Provide a Python file with: 1. The `SeparateChainingHashTable` class implementing the required functionality. 2. A set of unit tests to verify the correctness of your implementation.","solution":"class SeparateChainingHashTable(object): def __init__(self, size=11): self.size = size self.table = [[] for _ in range(self.size)] self.count = 0 def put(self, key, value): if self.count / self.size > 0.75: self.resize(self.size * 2) index = self.hash(key) for entry in self.table[index]: if entry[0] == key: entry[1] = value return self.table[index].append([key, value]) self.count += 1 def get(self, key): index = self.hash(key) for entry in self.table[index]: if entry[0] == key: return entry[1] return None def del_(self, key): index = self.hash(key) for entry in self.table[index]: if entry[0] == key: self.table[index].remove(entry) self.count -= 1 if self.count / self.size < 0.25 and self.size > 11: self.resize(self.size // 2) return def __len__(self): return self.count def resize(self, new_size): old_table = self.table self.size = new_size self.table = [[] for _ in range(self.size)] self.count = 0 for bucket in old_table: for key, value in bucket: self.put(key, value) def hash(self, key): return hash(key) % self.size"},{"question":"Stooge Sort with Enhanced Input Handling You are tasked with enhancing the Stooge Sort algorithm to handle arrays of various data types and edge cases more efficiently. Problem Statement Write a Python function `stooge_sort(arr: List[Union[int, float]], l: int, h: int) -> None` that implements the Stooge Sort algorithm for an array of integers or floats. Improve it by handling edge cases and ensuring the function handles larger data sets effectively with safeguards for recursion limits. Input: 1. `arr` - A list of integers or floats representing the array to be sorted. 2. `l` - The starting index of the segment to be sorted. 3. `h` - The ending index of the segment to be sorted. Output: The function should modify the input list in-place to sort the elements in non-decreasing order. Constraints: - The array can contain any integer or float values. - The length of the array will be at most 10^5. - Handle recursion depth to avoid stack overflow for large arrays. Example: ```python array = [4.5, 2.2, 1.1, 3.0] stooge_sort(array, 0, len(array) - 1) print(array) ``` Output: ``` [1.1, 2.2, 3.0, 4.5] ``` # Additional Information: - Ensure proper handling of recursive depth. - Aim for clarity and robustness in your implementation.","solution":"import sys from typing import List, Union def stooge_sort(arr: List[Union[int, float]], l: int, h: int) -> None: if l >= h: return # If the element at the start is greater than at the end, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are at least three elements, sort the first 2/3 and the last 2/3 and then the first 2/3 again if h - l + 1 > 2: t = (h - l + 1) // 3 stooge_sort(arr, l, h - t) stooge_sort(arr, l + t, h) stooge_sort(arr, l, h - t) # To handle the recursion depth issue in Python, set the recursion limit higher sys.setrecursionlimit(2000)"},{"question":"# Pigeonhole Sort Implementation Scenario: You are tasked with organizing a list of scores from a school\'s grading system. The list contains the scores of students from multiple classes. You aim to sort these scores using an efficient algorithm. Problem Statement: Implement the **pigeonhole_sort** function that sorts a list of integers using the Pigeonhole Sorting Algorithm. This function will receive a list of integers, which can include negative values. The function should return the sorted list. Function Signature: ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` Input: - A list `arr` of integers. Example: `[-5, 3, 2, 0, -1, 4, -2]` - Length of the list will be in the range [0, 10**6], and the element values will be within a reasonable range for List[DataType]. Output: - A list of integers sorted in ascending order. Constraints: - The algorithm should handle lists with negative and positive integers appropriately. - The function should operate within acceptable time and space limits, especially for large inputs provided the range is not excessively large compared to the list size. Example: ```python assert pigeonhole_sort([8, 3, -1, 5, -3, 0]) == [-3, -1, 0, 3, 5, 8] assert pigeonhole_sort([100, -20, 50, 0, 25]) == [-20, 0, 25, 50, 100] assert pigeonhole_sort([-1, -1, -1, -1]) == [-1, -1, -1, -1] ```","solution":"def pigeonhole_sort(arr): if not arr: return arr min_value = min(arr) max_value = max(arr) size = max_value - min_value + 1 # Initialize holes holes = [0] * size # Fill the holes for number in arr: holes[number - min_value] += 1 # Collect sorted elements sorted_arr = [] for index in range(size): while holes[index] > 0: sorted_arr.append(index + min_value) holes[index] -= 1 return sorted_arr"},{"question":"# Merge Sort Implementation with In-Place Merge Scenario: You are tasked with optimizing a merge sort algorithm for an embedded system with limited memory. To achieve this, you need to implement an in-place merge sort, minimizing additional memory usage while maintaining the core characteristics and performance of the merge sort. Requirements: 1. Implement an in-place merge function that merges two sorted subarrays within the same array. 2. Use the in-place merge function as part of a complete in-place merge sort algorithm. Function Signatures: You need to implement the following functions: ```python def in_place_merge_sort(arr): Perform in-place merge sort on the input list. Parameters: arr (List[int]): The list of integers to sort. Returns: List[int]: Sorted list using in-place merge sort. pass def in_place_merge(arr, start, mid, end): In-place merge two sorted subarrays within \'arr\'. Parameters: arr (List[int]): The list containing the subarrays. start (int): The starting index of the first subarray. mid (int): The end index of the first subarray and start of the second. end (int): The end index of the second subarray. Returns: None: Merges the two subarrays within \'arr\' in place. pass ``` Input: * A list of integers, `arr`, where len(arr) <= 10^5. Constraints: * The function should not use additional lists or data structures that scale with input size. * The array may include negative and positive integers as well as duplicates. Output: * A sorted list of integers using in-place merge sort. Example: ```python input_array = [3, 5, 2, 9, 10, 1, 4, 7] sorted_array = in_place_merge_sort(input_array) print(sorted_array) # Output: [1, 2, 3, 4, 5, 7, 9, 10] ``` **Requirements**: - Ensure the algorithm runs within O(n log(n)) time. - Minimize additional memory usage as much as possible. **Important Notes**: - Make sure to handle base cases such as empty arrays and single-element arrays. - Consider the stability of the algorithm if necessary.","solution":"def in_place_merge_sort(arr): Perform in-place merge sort on the input list. Parameters: arr (List[int]): The list of integers to sort. Returns: List[int]: Sorted list using in-place merge sort. if arr is None or len(arr) <= 1: return arr def sort(arr, left, right): if left < right: mid = (left + right) // 2 sort(arr, left, mid) sort(arr, mid + 1, right) in_place_merge(arr, left, mid, right) sort(arr, 0, len(arr) - 1) return arr def in_place_merge(arr, start, mid, end): In-place merge two sorted subarrays within \'arr\'. Parameters: arr (List[int]): The list containing the subarrays. start (int): The starting index of the first subarray. mid (int): The end index of the first subarray and start of the second. end (int): The end index of the second subarray. Returns: None: Merges the two subarrays within \'arr\' in place. start2 = mid + 1 if arr[mid] <= arr[start2]: return while start <= mid and start2 <= end: if arr[start] <= arr[start2]: start += 1 else: value = arr[start2] index = start2 while index != start: arr[index] = arr[index - 1] index -= 1 arr[start] = value start += 1 mid += 1 start2 += 1"},{"question":"# Question: Implement an Optimized Bubble Sort Scenario In a coding competition, you are tasked with implementing a sorting algorithm to sort a given list of scores in a game. Because of the potential large number of players, it is important to use an efficient sorting method. One of the requirements is to use an optimized version of the Bubble Sort algorithm. Task Implement an optimized version of the Bubble Sort algorithm that includes the following features: 1. Stops early if the list is detected to be already sorted. 2. Handles edge cases efficiently. 3. Provides an optional simulation mode to display each step of the sorting process. Requirements * **Function Signature**: `def optimized_bubble_sort(arr: list, simulation: bool=False) -> list` * **Input**: * `arr`: A list of integers representing the scores. * `simulation`: An optional boolean flag to print each sorting step (defaults to `False`). * **Output**: * A list of integers sorted in ascending order. * **Constraints**: * The length of the list should not exceed 1,000 elements. * The integers in the list are within the range of -10,000 to 10,000. Example ```python scores = [64, 34, 25, 12, 22, 11, 90] print(optimized_bubble_sort(scores)) # Output: [11, 12, 22, 25, 34, 64, 90] print(optimized_bubble_sort(scores, simulation=True)) # Should output each step of the sorting process in addition to the final sorted list. ``` Guidelines * Ensure your implementation is efficient and handles all edge cases. * If `simulation` is `True`, print the list at each step of the sorting process (like the provided snippet). * Consider the provided bubble_sort function as a reference for understanding the steps.","solution":"def optimized_bubble_sort(arr: list, simulation: bool=False) -> list: n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if simulation: print(arr) if not swapped: break return arr"},{"question":"Objective Design a function to generate a histogram from a given list of numbers. The function should efficiently count the occurrences of each unique element in the list and return these counts as a dictionary. # Problem Statement You are given a list of integers, which may contain both positive and negative numbers, and zero. Your task is to write a function that creates a histogram of this list. The histogram should be represented as a dictionary where the keys are the unique elements from the list, and the values are the counts of these elements. # Expected Input and Output * **Input**: A list of integers, which can be empty, contain single-element, duplicates, negative numbers, or zeros. * **Output**: A dictionary where keys are the unique integers from the input list and values are the count of such integers in the list. # Function Signature ```python def generate_histogram(input_list: list) -> dict: pass ``` # Constraints * The input list elements can be in the range of `[-10^6, 10^6]`. * The length of the input list can be up to `10^6` elements. * Implement the solution with a time complexity of O(n) and space complexity of O(n). # Sample Test Cases 1. **Input**: `[3, 3, 2, 1]` * **Output**: `{1: 1, 2: 1, 3: 2}` 2. **Input**: `[2, 3, 5, 5, 5, 6, 4, 3, 7]` * **Output**: `{2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1}` 3. **Input**: `[-1, -1, -2, 0, 0, 1]` * **Output**: `{-2: 1, -1: 2, 0: 2, 1: 1}` 4. **Input**: `[]` * **Output**: `{}` 5. **Input**: `[0, 0, 0, 0, 0]` * **Output**: `{0: 5}` # Performance Considerations Ensure your implementation efficiently handles the upper limits of input constraints without significant performance degradation.","solution":"def generate_histogram(input_list: list) -> dict: Generates a histogram from a given list of numbers. :param input_list: List of integers. :return: Dictionary with integer elements as keys and their counts as values. histogram = {} for number in input_list: if number in histogram: histogram[number] += 1 else: histogram[number] = 1 return histogram"},{"question":"# Context Given the following problem context: You are working on a system that performs arithmetic operations at a hardware level. The system does not support standard arithmetic operators and relies heavily on bitwise operations. You are tasked with implementing an addition operation using bitwise techniques. # Problem Statement Write a function `add_bitwise_operator(x, y)` that takes two positive integers ( x ) and ( y ) as input and returns their sum. This function must not use direct addition (\'+\') operator but should use bitwise operations to calculate the result. # Input - Two positive integers ( x ) and ( y ) (1 ≤ ( x, y ) ≤ ( 10^9 )). # Output - A single integer which is the sum of ( x ) and ( y ). # Constraints - Use bitwise operations (`&`, `|`, `^`, `<<`, `>>`). - Do not use any addition operations like `x + y` or any arithmetic operators (`+\' or \'-\'). - Assume both `x` and `y` are positive and fit within a 32-bit signed integer range. # Example **Input**: ``` 2 3 ``` **Output**: ``` 5 ``` # Additional Notes - Consider edge cases where one number is significantly larger than the other. - Ensure the function is efficient enough to handle the upper limit of input constraints.","solution":"def add_bitwise_operator(x, y): Returns the sum of x and y using bitwise operations. while y != 0: carry = x & y # Calculate carry x = x ^ y # Sum bits where at least one of the bits is not set y = carry << 1 # Carry over the bits return x"},{"question":"# Question: Optimal Facility Placement on a Grid You are tasked with building a new distribution center in a city represented by an `m x n` grid. The city\'s map is provided as a 2D grid where: - `1` represents a building. - `0` represents an empty land that can be chosen for the new distribution center. - `2` represents an obstacle that cannot be passed through or chosen. The objective is to find the optimal location (empty land) to place the distribution center such that the sum of the shortest distances from all buildings to this location is minimized. Write a function `find_optimal_location(grid: List[List[int]]) -> int` that takes the grid as input and returns the minimum sum of distances from the chosen location to all buildings. If it is not possible to build such a distribution center that is reachable from all buildings, return `-1`. **Input:** - `grid` is a list of lists of integers representing the grid. The number of rows `m` and the number of columns `n` satisfies 1 <= m, n <= 50. - The grid contains at least one building. **Output:** - Returns an integer representing the minimum sum of distances from the chosen location to all buildings, or `-1` if no such location exists. **Example:** ```python from typing import List def find_optimal_location(grid: List[List[int]]) -> int: # TODO: Implement this function using the BFS-based approach provided in the coding snippet. pass # Example usage: grid = [ [1, 0, 2, 0, 1], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0] ] print(find_optimal_location(grid)) # Output: 7 ``` **Explanation:** In the given grid, there are three buildings. The optimal location for the distribution center should be placed at `(1, 2)` where the total distance to all buildings is minimized to 7. **Constraints:** - The number of rows and columns in the grid does not exceed 50. **Note:** Implement the BFS algorithm provided and ensure the function handles edge cases such as isolated buildings and grids with obstacles.","solution":"from typing import List, Tuple from collections import deque def bfs(grid: List[List[int]], m: int, n: int, start_x: int, start_y: int) -> List[List[int]]: distances = [[-1] * n for _ in range(m)] queue = deque([(start_x, start_y, 0)]) while queue: x, y, dist = queue.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and distances[nx][ny] == -1: distances[nx][ny] = dist + 1 queue.append((nx, ny, dist + 1)) return distances def find_optimal_location(grid: List[List[int]]) -> int: m, n = len(grid), len(grid[0]) building_positions = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1] if not building_positions: return -1 total_distance = [[0] * n for _ in range(m)] reachable_count = [[0] * n for _ in range(m)] for bx, by in building_positions: distances = bfs(grid, m, n, bx, by) for i in range(m): for j in range(n): if distances[i][j] != -1: total_distance[i][j] += distances[i][j] reachable_count[i][j] += 1 min_distance = float(\'inf\') for i in range(m): for j in range(n): if grid[i][j] == 0 and reachable_count[i][j] == len(building_positions): min_distance = min(min_distance, total_distance[i][j]) return min_distance if min_distance != float(\'inf\') else -1"},{"question":"# Hailstone Sequence Challenge Given a positive integer ( n ), implement a function `hailstone(n)` that generates the hailstone sequence starting from ( n ) down to 1. The sequence follows these rules: 1. If ( n ) is 1, the sequence is complete. 2. If ( n ) is even, the next number is ( n/2 ). 3. If ( n ) is odd, the next number is ( 3n + 1 ). # Function Signature ```python def hailstone(n: int) -> List[int]: pass ``` # Input * A single integer ( n ), where ( 1 leq n leq 10^6 ). # Output * A list of integers representing the hailstone sequence starting from ( n ) down to 1. # Constraints * The function should handle large values of ( n ) efficiently. * Avoid memory limitations by managing sequence generation carefully for large sequences. * Return the sequence in the format of a list of integers. # Example ```python assert hailstone(5) == [5, 16, 8, 4, 2, 1] assert hailstone(1) == [1] ``` Provide a function `hailstone(n)` that adheres to the specifications and constraints described above. Ensure the logic handles all edge cases and performs efficiently within the defined input constraints.","solution":"from typing import List def hailstone(n: int) -> List[int]: Generates the hailstone sequence starting from n down to 1. sequence = [n] while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 sequence.append(n) return sequence"},{"question":"# Exercise: Zigzag Traversal of a Matrix Scenario You are given a matrix of `m` x `n` elements. You need to write a function that returns all the elements of the matrix in a zigzag order. Zigzag order traversal follows these rules: 1. Start with the top-left element of the matrix. 2. The direction alternates between left-to-right and right-to-left for every subsequent row. For example, given the following matrix: ``` [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] ``` The expected output should be `[1, 2, 3, 6, 5, 4, 7, 8, 9]`. Function Signature ```python def zigzag_traversal(matrix): pass ``` Input - `matrix`: A list of lists, where each inner list represents a row of the matrix (1 ≤ len(matrix), len(matrix[0]) ≤ 100). Output - A list of integers representing the elements of the matrix in zigzag order. Constraints - The elements in the matrix can be any integer. - The function should handle both square and rectangular matrices. - Efficiently handle all possible edge cases, as discussed. Example If the input matrix is: ``` [ [ 10, 20, 30, 40 ], [ 50, 60, 70, 80 ], [ 90, 100, 110, 120 ] ] ``` The expected output is `[10, 20, 30, 40, 80, 70, 60, 50, 90, 100, 110, 120]`. Implement the `zigzag_traversal` function to achieve the above requirements and handle various edge cases.","solution":"def zigzag_traversal(matrix): Returns the elements of the matrix in zigzag order. if not matrix or not matrix[0]: return [] result = [] rows, cols = len(matrix), len(matrix[0]) for r in range(rows): if r % 2 == 0: result.extend(matrix[r]) else: result.extend(matrix[r][::-1]) return result"},{"question":"You are given two functions, `max_heap_sort` and `min_heap_sort`, which sort an array in ascending order using heap sort with max-heap and min-heap respectively. However, it is observed that `min_heap_sort` does not sort the array correctly. Investigate the `min_heap_sort` function to identify and correct the issue. **Task**: 1. Debug and fix the `min_heap_sort` function so that it sorts the array correctly in ascending order. 2. Write a function `is_sorted(arr)` that checks if the array is sorted in ascending order. # Input * `arr`: A list of integers where `1 <= len(arr) <= 10^5`. # Output * Return the sorted list and ensure it is sorted in ascending order. * The function `is_sorted` should return a boolean indicating whether the array is sorted in ascending order. # Constraints * The heapify function should be part of your code to maintain the heap property. * Optimize for both time and space complexity. # Example ```python def is_sorted(arr): for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True # Example 1 arr = [3, 2, 1, 4, 5] sorted_arr = min_heap_sort(arr) print(is_sorted(sorted_arr)) # True # Example 2 arr = [1, 5, 6, 2, 3, 4] sorted_arr = min_heap_sort(arr) print(is_sorted(sorted_arr)) # True ``` # Notes * Ensure all edge cases are handled properly. * Provide a clear explanation of any changes needed in the `min_heap_sort` function.","solution":"def min_heapify(arr, n, i): Helper function to maintain the min-heap property smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] < arr[smallest]: smallest = left if right < n and arr[right] < arr[smallest]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] min_heapify(arr, n, smallest) def min_heap_sort(arr): Sorts an array in ascending order using min-heap n = len(arr) # Build a min-heap for i in range(n // 2 - 1, -1, -1): min_heapify(arr, n, i) # One by one extract elements from the heap for i in range(n - 1, 0, -1): arr[0], arr[i] = arr[i], arr[0] # Swap current root to end min_heapify(arr, i, 0) # Reverse the array to get it in ascending order arr.reverse() return arr def is_sorted(arr): Checks if the array is sorted in ascending order for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True"},{"question":"Given the task to implement a data structure that allows for constant time complexity in insertions, deletions, and retrieval of random elements, you are required to complete the following function implementations in the `RandomizedSet` class: 1. `insert(val)`: Inserts a new element if it does not already exist in the set. - **Input**: A single integer `val` to be inserted. - **Output**: Return `True` if the element was successfully inserted, `False` otherwise. - **Constraints**: `-10^6 <= val <= 10^6` 2. `remove(val)`: Removes an existing element from the set. - **Input**: A single integer `val` to be removed. - **Output**: Return `True` if the element was successfully removed, `False` otherwise. - **Constraints**: `-10^6 <= val <= 10^6` 3. `get_random()`: Returns a random element from the current set. - **Output**: An integer randomly selected from the present elements. - **Constraints**: The set will have at least one element when this function is called. You are tasked to ensure that these operations function correctly with the average time complexity of O(1). # Example Usage ```python rs = RandomizedSet() print(\\"insert 1: \\", rs.insert(1)) # Output: True print(\\"insert 2: \\", rs.insert(2)) # Output: True print(\\"insert 3: \\", rs.insert(3)) # Output: True print(\\"insert 4: \\", rs.insert(4)) # Output: True print(\\"remove 3: \\", rs.remove(3)) # Output: True print(\\"remove 1: \\", rs.remove(1)) # Output: True print(\\"random: \\", rs.get_random()) # Output: One of [2, 4] randomly print(\\"random: \\", rs.get_random()) # Output: One of [2, 4] randomly ``` # Constraints - The calls to `insert`, `remove`, and `get_random` will be made in any order and are valid operations as described.","solution":"import random class RandomizedSet: def __init__(self): Initialize your data structure here. self.data = [] self.data_map = {} def insert(self, val): Inserts a value to the set. Returns True if the set did not already contain the specified element. if val in self.data_map: return False self.data_map[val] = len(self.data) self.data.append(val) return True def remove(self, val): Removes a value from the set. Returns True if the set contained the specified element. if val not in self.data_map: return False # Move the last element to the spot of the element to delete last_element, idx_to_delete = self.data[-1], self.data_map[val] self.data[idx_to_delete], self.data_map[last_element] = last_element, idx_to_delete # Remove the last element self.data.pop() del self.data_map[val] return True def get_random(self): Get a random element from the set. return random.choice(self.data)"},{"question":"# B-Tree Deletion with Variable Degrees **Context**: You\'re tasked with implementing an enhanced B-tree, a self-balancing tree data structure. Your task is to extend this B-tree with a specific emphasis on handling deletions efficiently and robustly under various conditions. This involves ensuring balance and property maintenance post-deletion. **Task**: Implement a method to remove a key from the B-tree, ensuring all B-tree properties are retained. Your implementation must handle various edge cases, and optimize performance for large datasets. # Requirements 1. **Class Definition**: * Continue using the `Node` and `BTree` classes as defined in the provided B-tree implementation. 2. **Method to Implement**: ```python def remove_key(self, key): This method should remove a specified key from the B-tree. It should ensure the B-tree remains balanced and valid after the removal. ``` 3. **Constraints**: * Assume a minimum degree t (≥ 2) that will be provided during B-tree initialization. * Key values are unique integers. * Avoid using any additional libraries for tree operations. 4. **Inputs/Outputs**: * Input: A single integer key. * Output: None (in-place modification of the tree). # Sample Scenario * Initialize the B-tree with a degree of 3. * Insert the numbers 10, 20, 5, 6, 12, 30, 7, 17. * Remove the keys 6, 13, 7, 4. * The final tree structure should still maintain B-tree properties. **Example**: ```python # Initialize BTree with degree 3 btree = BTree(3) # Insert elements for key in [10, 20, 5, 6, 12, 30, 7, 17]: btree.insert_key(key) # Perform deletions for key in [6, 13, 7, 4]: btree.remove_key(key) # Traverse the tree to check the final structure btree.traverse_tree() ``` **Expected Result**: When traversed in order, the final B-tree should reflect a balanced structure maintaining B-tree properties.","solution":"class Node: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node, else False self.keys = [] # List of keys in the node self.children = [] # List of child nodes (can be empty if leaf is True) class BTree: def __init__(self, t): self.t = t # Minimum degree self.root = Node(t, leaf=True) def traverse_tree(self): Function to traverse the tree return self._traverse_tree(self.root) def _traverse_tree(self, node): A recursive helper function to traverse the tree elements = [] for i in range(len(node.keys)): if not node.leaf: elements.extend(self._traverse_tree(node.children[i])) elements.append(node.keys[i]) if not node.leaf: elements.extend(self._traverse_tree(node.children[len(node.keys)])) return elements def insert_key(self, key): Function to insert a new key in the B-tree root = self.root if len(root.keys) == (2 * self.t) - 1: # If root is full new_node = Node(self.t, leaf=False) new_node.children.append(self.root) self._split_child(new_node, 0, self.root) self.root = new_node self._insert_non_full(self.root, key) def _split_child(self, parent, i, full_child): A helper function to split a full child node new_node = Node(self.t, leaf=full_child.leaf) parent.children.insert(i + 1, new_node) parent.keys.insert(i, full_child.keys[self.t - 1]) new_node.keys = full_child.keys[self.t:(2 * self.t) - 1] full_child.keys = full_child.keys[0:self.t - 1] if not full_child.leaf: new_node.children = full_child.children[self.t:(2 * self.t)] full_child.children = full_child.children[0:self.t] def _insert_non_full(self, node, key): A helper function to insert a new key to a non-full node i = len(node.keys) - 1 if node.leaf: node.keys.append(None) while i >= 0 and key < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = key else: while i >= 0 and key < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == (2 * self.t) - 1: self._split_child(node, i, node.children[i]) if key > node.keys[i]: i += 1 self._insert_non_full(node.children[i], key) def remove_key(self, key): Function to remove a key from the B-tree and ensure it remains balanced. self._remove_key(self.root, key) if len(self.root.keys) == 0: if not self.root.leaf: self.root = self.root.children[0] else: self.root = Node(self.t, leaf=True) def _remove_key(self, node, key): t = self.t pos = self._find_key(node, key) if pos < len(node.keys) and node.keys[pos] == key: # Key is in this node if node.leaf: self._remove_from_leaf(node, pos) else: self._remove_from_non_leaf(node, pos) elif node.leaf: # The key is not present in this tree return else: if len(node.children[pos].keys) < t: self._fill(node, pos) if pos > len(node.keys): self._remove_key(node.children[pos - 1], key) else: self._remove_key(node.children[pos], key) def _find_key(self, node, key): idx = 0 while idx < len(node.keys) and node.keys[idx] < key: idx += 1 return idx def _remove_from_leaf(self, node, pos): node.keys.pop(pos) def _remove_from_non_leaf(self, node, pos): key = node.keys[pos] if len(node.children[pos].keys) >= self.t: # Predecessor pred = self._get_predecessor(node, pos) node.keys[pos] = pred self._remove_key(node.children[pos], pred) elif len(node.children[pos + 1].keys) >= self.t: # Successor succ = self._get_successor(node, pos) node.keys[pos] = succ self._remove_key(node.children[pos + 1], succ) else: self._merge(node, pos) self._remove_key(node.children[pos], key) def _get_predecessor(self, node, pos): curr = node.children[pos] while not curr.leaf: curr = curr.children[len(curr.children) - 1] return curr.keys[len(curr.keys) - 1] def _get_successor(self, node, pos): curr = node.children[pos + 1] while not curr.leaf: curr = curr.children[0] return curr.keys[0] def _fill(self, node, pos): if pos != 0 and len(node.children[pos - 1].keys) >= self.t: self._borrow_from_prev(node, pos) elif pos != len(node.keys) and len(node.children[pos + 1].keys) >= self.t: self._borrow_from_next(node, pos) else: if pos != len(node.keys): self._merge(node, pos) else: self._merge(node, pos - 1) def _borrow_from_prev(self, node, pos): child = node.children[pos] sibling = node.children[pos - 1] child.keys.insert(0, node.keys[pos - 1]) if not child.leaf: child.children.insert(0, sibling.children.pop()) node.keys[pos - 1] = sibling.keys.pop() def _borrow_from_next(self, node, pos): child = node.children[pos] sibling = node.children[pos + 1] child.keys.append(node.keys[pos]) if not child.leaf: child.children.append(sibling.children.pop(0)) node.keys[pos] = sibling.keys.pop(0) def _merge(self, node, pos): child = node.children[pos] sibling = node.children[pos + 1] child.keys.append(node.keys.pop(pos)) child.keys.extend(sibling.keys) if not child.leaf: child.children.extend(sibling.children) node.children.pop(pos + 1)"},{"question":"# Deduplication of Linked List (Coding Question) You have been provided with a singly linked list where each node has an integer value. Your task is to write a function to remove all duplicate values from this list. You must clearly implement both versions: one using an additional data structure and one without using any extra space. Implement the following two functions: 1. `remove_dups(head: Node) -> None`: Removes duplicates from the linked list using a hash set. 2. `remove_dups_without_set(head: Node) -> None`: Removes duplicates without using any extra space. The linked list Node class is defined as follows: ```python class Node: def __init__(self, val=None): self.val = val self.next = None ``` # Input and Output - **Input**: The function takes as input the head node of the linked list. - **Output**: The function modifies the linked list in place, and does not return any value. # Constraints - The values of the nodes are integers. - The linked list can have up to 10^4 nodes. - The value of each node is in the range -10^4 to 10^4. # Performance Requirements - `remove_dups` should have an O(N) time complexity and O(N) space complexity. - `remove_dups_without_set` should have an O(N^2) time complexity and O(1) space complexity. # Example Consider the following linked list: ``` 3 -> 4 -> 3 -> 5 -> 4 -> 3 ``` After calling `remove_dups`, the linked list should be: ``` 3 -> 4 -> 5 ``` Similarly, after calling `remove_dups_without_set`, the linked list should be: ``` 3 -> 4 -> 5 ``` Write both implementations efficiently, handling edge cases and ensuring correctness.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups(head: Node) -> None: Remove duplicates from the linked list using a hash set. if not head: return current = head seen = set() seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_dups_without_set(head: Node) -> None: Remove duplicates from the linked list without using any extra space. if not head: return current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"**Context**: You have been hired to work on a search engine where efficient lookups in large datasets are crucial. One component of the search engine is a sorted list of keywords, and you need to implement a feature to quickly determine the position of a given keyword in this list. **Task**: Implement the function `binary_search` that takes a sorted array of integers and a target integer, and returns the index of the target in the array. If the target is not found in the array, return -1. Optimize for both time and space complexity. # Input Format: - `array`: A list of integers, sorted in ascending order. Size of the list: `1 <= len(array) <= 10^5` - `target`: An integer to be searched in `array`. # Output Format: - Return the index of `target` in `array`. If `target` is not found, return -1. # Constraints: - Try to achieve the best possible complexity in terms of both time and space. - Do not use any library functions for binary search; implement the algorithm from scratch. ```python def binary_search(array, target): Perform a binary search on a sorted array. Parameters: array (list): A sorted list of integers. target (int): The integer to search for in the array. Returns: int: The index of the target in the array, or -1 if the target is not found. # Write your code here. ``` # Examples: ```python # Example 1 array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] target = 5 assert binary_search(array, target) == 4 # Example 2 array = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20] target = 7 assert binary_search(array, target) == -1 # Example 3 array = [-10, -5, 0, 3, 8, 12, 18, 21] target = 0 assert binary_search(array, target) == 2 ``` Provide your implementation below.","solution":"def binary_search(array, target): Perform a binary search on a sorted array. Parameters: array (list): A sorted list of integers. target (int): The integer to search for in the array. Returns: int: The index of the target in the array, or -1 if the target is not found. left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] == target: return mid elif array[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Regular Expression Matching Given the complexity of validating string patterns, create a function `is_match` that can check whether a given string matches a specified pattern. The pattern includes the characters `\'.\'` (which matches any single character) and `\'*\'` (which matches zero or more occurrences of the preceding element). Function Signature ```python def is_match(s: str, p: str) -> bool: ``` Input * `s` (str): The input string which you need to check. * `p` (str): The pattern to match the string against. Output * Returns `bool`: A boolean value `True` if the string matches the pattern, otherwise `False`. Constraints * The input string `s` and pattern `p` will have a length between 1 and 1000. * The pattern `p` will contain only lowercase letters, `\'.\'`, and `\'*\'`. Examples 1. `is_match(\\"aa\\", \\"a\\")` should return `False` because \\"a\\" does not match the entire string \\"aa\\". 2. `is_match(\\"aa\\", \\"aa\\")` should return `True` because \\"aa\\" matches \\"aa\\". 3. `is_match(\\"aa\\", \\"a*\\")` should return `True` because \'*\' means zero or more of the preceding element \\"a\\". 4. `is_match(\\"ab\\", \\".*\\")` should return `True` because \'.*\' means \\"matches any string\\". 5. `is_match(\\"aab\\", \\"c*a*b\\")` should return `True` because \\"c*\\" can be ignored and \\"a*b\\" means \\"zero or more a\\", followed by \\"b\\". Instructions 1. Implement the required algorithm using a dynamic programming approach, storing intermediate states to avoid recomputation. 2. Make sure to handle edge cases such as empty patterns and non-trivial combinations of the pattern characters.","solution":"def is_match(s: str, p: str) -> bool: Given an input string (s) and a pattern (p), implement regular expression matching with support for \'.\' and \'*\'. # Initialize a table where dp[i][j] will be True if the first i characters in s # match the first j characters in p dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] # Base case: empty string matches with empty pattern dp[0][0] = True # Handle patterns with \'*\' that can match zero preceding elements for j in range(2, len(p) + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: # Current characters match, carry forward the result from previous state dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': # \'*\' can cancel the preceding element occurrence in three ways: # 1. Match zero occurrence of the preceding element. dp[i][j] = dp[i][j - 2] # 2. Match one more occurrence of the preceding element. if p[j - 2] == s[i - 1] or p[j - 2] == \'.\': dp[i][j] |= dp[i - 1][j] # Use |= to handle the OR operation return dp[len(s)][len(p)]"},{"question":"# Merging Two Sorted Linked Lists You are given two sorted linked lists. Your task is to implement a function that merges these two lists into one sorted linked list. The function should return the head of the merged linked list. Function Signature ```python def merge_sorted_lists(l1: Node, l2: Node) -> Node: ``` Input - `l1`: A reference to the head of the first sorted linked list. - `l2`: A reference to the head of the second sorted linked list. Output - Returns a reference to the head of the merged sorted linked list. Constraints - Both `l1` and `l2` can be `None` (indicating empty lists). - The values in the nodes are non-decreasing integers. Example: ```python # Suppose you have two linked lists represented as: # l1: 1 -> 2 -> 4 # l2: 1 -> 3 -> 4 # After merging, the linked list should be: # 1 -> 1 -> 2 -> 3 -> 4 -> 4 ``` Scenario/Context: Consider a scenario where you have two sorted lists of customer order timestamps and you are required to integrate them into a single, sequential dataset to process them in the order they arrived. This function helps in handling such merge operations on ordered data efficiently. Requirements: - You must implement an iterative solution. - The function should run in O(n + m) time complexity where n and m are the lengths of the two linked lists. - Aim to use O(1) auxiliary space for the iterative solution, avoiding additional data structures. You will be provided with the Node class for linked list nodes: ```python class Node: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Write your implementation in the `merge_sorted_lists` function. Ensure to handle edge cases such as empty input lists and differing list lengths.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sorted_lists(l1: Node, l2: Node) -> Node: dummy = Node(0) # Placeholder for the merged list current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # Append the remaining elements of l1 or l2 current.next = l1 if l1 else l2 return dummy.next"},{"question":"# Binary Heap Min-Heap Implementation **Context**: You are implementing a priority queue using a binary heap, a commonly used data structure for maintaining order dynamically while ensuring efficient element access. **Task**: Implement a min-heap class with both insertion and removal functionality. **Requirements**: 1. Define a class `MinHeap` with the following methods: - `insert(val)`: Inserts an integer value `val` into the heap. - `remove_min()`: Removes and returns the smallest element from the heap. 2. Adhere to the min-heap property where the parent node is always less than or equal to its children. **Input/Output**: - The `insert` method has one input: `val` (an integer). - The `remove_min` method does not take any input and returns an integer value, the smallest element in the heap. **Constraints**: - The heap supports up to 10^4 operations. - You may assume that `remove_min` is only called on a non-empty heap. **Example**: ```python # Initialize a MinHeap min_heap = MinHeap() # Insert elements into the heap min_heap.insert(4) min_heap.insert(50) min_heap.insert(7) min_heap.insert(55) min_heap.insert(90) min_heap.insert(87) # Remove the minimum element (4) min1 = min_heap.remove_min() # Insert another element min_heap.insert(2) # Remove the minimum element (2) min2 = min_heap.remove_min() ``` # Implementation Implement the `MinHeap` class according to the described requirements.","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, val): self.heap.append(val) self._heapify_up(len(self.heap) - 1) def remove_min(self): if len(self.heap) == 1: return self.heap.pop() min_elem = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return min_elem def _heapify_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index): left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 smallest_index = index if left_child_index < len(self.heap) and self.heap[left_child_index] < self.heap[smallest_index]: smallest_index = left_child_index if right_child_index < len(self.heap) and self.heap[right_child_index] < self.heap[smallest_index]: smallest_index = right_child_index if smallest_index != index: self.heap[index], self.heap[smallest_index] = self.heap[smallest_index], self.heap[index] self._heapify_down(smallest_index)"},{"question":"# Question: Nearest Neighbor Classifier with Euclidean Distance You need to implement the nearest neighbor algorithm to classify data points. You are provided with a function called `distance` that calculates the Euclidean distance between two vectors, and a partially implemented function `nearest_neighbor` that you need to complete. Function Signature: ```python def nearest_neighbor(x: Tuple[float, ...], tSet: Dict[Tuple[float, ...], str]) -> str: ``` Parameters: - `x`: A tuple of floats representing the feature vector of the point to be classified. - `tSet`: A dictionary where keys are tuples of floats (representing feature vectors) and values are labels or classes (strings). Returns: - A string which is the label of the nearest neighbor to vector `x`. Constraints: 1. All feature vectors will have the same length, including `x` and the keys in `tSet`. 2. The input `tSet` will never be empty and will contain at least one feature vector and its corresponding label. 3. The function `distance` is already implemented and available for use. Example: ```python tSet = { (1.0, 2.0): \'A\', (2.0, 3.0): \'B\', (3.0, 4.0): \'C\' } x = (2.5, 3.5) print(nearest_neighbor(x, tSet)) # Output: \'B\' ``` # Performance Expectations: - Efficiently handles a dataset with up to (10^4) feature vectors. Tasks: 1. Complete the implementation of the `nearest_neighbor` function using the provided skeleton. 2. Ensure that your function considers the edge cases mentioned in the analysis section. 3. Provide test cases to validate your implementation. Edge Cases to Consider: - `x` matches exactly one of the keys in `tSet`. - `tSet` contains vectors with very close distances to `x`. Additional Notes: - Any use of libraries for nearest neighbor search other than what is provided in `distance` is prohibited.","solution":"from math import sqrt from typing import Tuple, Dict def distance(vec1: Tuple[float, ...], vec2: Tuple[float, ...]) -> float: Calculate the Euclidean distance between two vectors. return sqrt(sum((v1 - v2) ** 2 for v1, v2 in zip(vec1, vec2))) def nearest_neighbor(x: Tuple[float, ...], tSet: Dict[Tuple[float, ...], str]) -> str: Find the label of the nearest neighbor to the vector `x` from the training set `tSet`. nearest_label = None min_distance = float(\'inf\') for feature_vector, label in tSet.items(): current_distance = distance(x, feature_vector) if current_distance < min_distance: min_distance = current_distance nearest_label = label return nearest_label"},{"question":"You are provided with two implementations of the stack data structure: one using arrays (`ArrayStack`) and the other using linked lists (`LinkedListStack`). Your task is to implement a new method in each class that checks if the stack is a palindrome. A palindrome is a sequence that reads the same backward as forward. # Method Signature ```python def is_palindrome(self) -> bool: Returns True if the stack is a palindrome, False otherwise. ``` # Requirements & Constraints 1. **Performance**: Try to implement the method such that it operates in O(n) time and O(1) additional space if possible. 2. **Edge Cases**: - An empty stack should be considered a palindrome. - A stack with a single element should be considered a palindrome. # Example Assume you have a stack with the elements [r, a, c, e, c, a, r] (top of the stack is on the left). - For an `ArrayStack`: ```python stack = ArrayStack() for char in \\"racecar\\": stack.push(char) assert stack.is_palindrome() == True ``` - For a `LinkedListStack`: ```python stack = LinkedListStack() for char in \\"racecar\\": stack.push(char) assert stack.is_palindrome() == True ``` # Additional Notes - Optimize for both time and space wherever possible. - Ensure proper handling of edge cases, such as an empty stack or single-element stack. - Your implementation should work seamlessly within the provided class definitions without altering other methods.","solution":"class ArrayStack: def __init__(self): self.stack = [] def push(self, value): self.stack.append(value) def pop(self): return self.stack.pop() if not self.is_empty() else None def is_empty(self): return len(self.stack) == 0 def is_palindrome(self) -> bool: n = len(self.stack) for i in range(n // 2): if self.stack[i] != self.stack[n - i - 1]: return False return True class LinkedListStack: class Node: def __init__(self, data): self.data = data self.next = None def __init__(self): self.head = None def push(self, value): new_node = self.Node(value) new_node.next = self.head self.head = new_node def pop(self): if not self.is_empty(): popped_value = self.head.data self.head = self.head.next return popped_value return None def is_empty(self): return self.head is None def is_palindrome(self) -> bool: slow = self.head fast = self.head stack = [] while fast and fast.next: stack.append(slow.data) slow = slow.next fast = fast.next.next if fast: slow = slow.next while slow: if stack.pop() != slow.data: return False slow = slow.next return True"},{"question":"# Regular Expression Matching Challenge **Objective**: Implement a function to determine if a given input string matches a pattern with support for \'.\' and \'*\'. **Input**: 1. `s` (string) - The input string. 2. `p` (string) - The pattern string containing \'.\' and/or \'*\'. **Output**: - Return `True` if the input string fully matches the pattern, otherwise, return `False`. **Definitions**: - `.` - Matches any single character. - `*` - Matches zero or more of the preceding element. **Example**: ```python is_match(\\"aa\\", \\"a\\") -> False is_match(\\"aa\\", \\"aa\\") -> True is_match(\\"aaa\\", \\"aa\\") -> False is_match(\\"aa\\", \\"a*\\") -> True is_match(\\"aa\\", \\".*\\") -> True is_match(\\"ab\\", \\".*\\") -> True is_match(\\"aab\\", \\"c*a*b\\") -> True ``` **Constraints**: - Both `s` and `p` consist of only lowercase English letters and characters `.` and `*`. - `1 <= len(s) <= 30` - `1 <= len(p) <= 30` # Detailed Function Signature Implement the function according to the provided definition: ```python def is_match(s: str, p: str) -> bool: # implementation here ``` **Note**: - Consider all edge cases such as empty strings and patterns. - Aim for an efficient solution with minimal time and space complexity.","solution":"def is_match(s: str, p: str) -> bool: Returns True if the input string s matches the pattern p, otherwise False. The pattern p supports \'.\' which matches any single character and \'*\' which matches zero or more of the preceding element. dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] dp[0][0] = True # Both strings are empty # Fill for patterns like a*, a*b*, a*b*c* etc. for j in range(2, len(p) + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] if (p[j - 2] == s[i - 1] or p[j - 2] == \'.\') else False) return dp[len(s)][len(p)]"},{"question":"# Question: Implement Enhanced Rabin-Karp Algorithm Context You are tasked with implementing an enhanced version of the Rabin-Karp algorithm. The Rabin-Karp algorithm is especially used for multiple pattern searches efficiently. Your version should account for common pitfalls such as handling upper and lower case characters, non-alphabet characters, and optimizing hash calculation to prevent performance degradation. Task Implement the function `enhanced_rabin_karp(pattern: str, text: str) -> list` that receives a pattern and a text (target string), and returns a list of starting indices where the pattern is found within the text. If the pattern is not found, return an empty list. Function Signature ```python def enhanced_rabin_karp(pattern: str, text: str) -> list: # Your implementation here ``` Input * `pattern`: A string representing the pattern to search for. * `text`: A string where the search is to be conducted. Output A list of integers, where each integer represents the starting index of the pattern found in the text. If no match is found, return an empty list. Constraints * 1 <= len(pattern) <= 10^3 * 1 <= len(text) <= 10^5 * The pattern and text can contain any printable ASCII characters. * The comparison is case-sensitive. Examples ```python assert enhanced_rabin_karp(\\"test\\", \\"this is a test text\\") == [10] assert enhanced_rabin_karp(\\"tEsT\\", \\"tEsT is a TEST text\\") == [0] assert enhanced_rabin_karp(\\"a\\", \\"abracadabra\\") == [0, 3, 5, 7, 10] assert enhanced_rabin_karp(\\"notfound\\", \\"there is nothing here\\") == [] ``` Notes * Optimize the rolling hash to handle ASCII characters efficiently. * Consider using a large prime number for modulus operation to minimize hash collisions. * Use sliding window technique for efficient hash calculations. * Handle edge cases such as empty strings and patterns larger than the text.","solution":"def enhanced_rabin_karp(pattern: str, text: str) -> list: Implement the enhanced Rabin-Karp algorithm to find the pattern in the given text. if not pattern or not text or len(pattern) > len(text): return [] # Parameters for Rabin-Karp algorithm base = 256 # number of characters in the input alphabet (ASCII) prime = 101 # a prime number for modulo operations to reduce hash collisions m = len(pattern) n = len(text) # Compute the hash value of the pattern and the first window of the text pattern_hash = 0 current_hash = 0 highest_power = 1 for i in range(m - 1): highest_power = (highest_power * base) % prime for i in range(m): pattern_hash = (base * pattern_hash + ord(pattern[i])) % prime current_hash = (base * current_hash + ord(text[i])) % prime # List of starting indices of pattern matches in text result = [] for i in range(n - m + 1): # Check the hashes first and then compare character by character for confirmation if pattern_hash == current_hash: if text[i:i + m] == pattern: result.append(i) if i < n - m: # Calculate the hash value for the next window of text current_hash = (base * (current_hash - ord(text[i]) * highest_power) + ord(text[i + m])) % prime # We might get a negative value of current_hash, convert it to positive if current_hash < 0: current_hash += prime return result"},{"question":"# Prime Race Context Imagine you are asked to optimize a piece of software that requires frequent checks of whether numbers are prime. To improve its efficiency, you need to implement a prime check algorithm and handle multiple queries in a performant way. Task Write a Python function named `prime_check_batch(number_list)`, which takes a list of integers and returns a list of booleans indicating whether each integer is a prime number. Function Signature ```python def prime_check_batch(number_list: List[int]) -> List[bool]: pass ``` Input: - `number_list`: A list of integers where 1 <= len(number_list) <= 10^6 and -10^12 <= number_list[i] <= 10^12. Output: - A list of booleans where each boolean corresponds to whether the integer at that position in the input list is a prime number. Constraints: - You need to handle up to 1 million numbers, optimizing for both time and space complexity. - Edge cases like negative numbers, 0, and very large numbers must be effectively managed. - The function should be able to run within reasonable time limits for the upper range of `number_list`. # Example ```python number_list = [2, 3, 4, 17, 19, 20, -5, 0, 1, 997] print(prime_check_batch(number_list)) # Output: [True, True, False, True, True, False, False, False, False, True] ``` Notes - Ensure correctness and efficiency. - Avoid unnecessary computations by leveraging the properties of prime numbers discussed earlier.","solution":"from typing import List def is_prime(n: int) -> bool: Check if a number is a prime number. if n <= 1: return False if n <= 3: return n > 1 if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def prime_check_batch(number_list: List[int]) -> List[bool]: Returns a list of booleans indicating whether each integer in the list is a prime number. return [is_prime(n) for n in number_list]"},{"question":"# RSA Encryption Algorithm Implementation and Analysis Context The RSA algorithm is crucial for secure communication in modern applications, from web browsing to secure email and digital signatures. As a cryptographer in training, you need to solidify your understanding of RSA by implementing an extended version of the provided key generation function, tackling challenges like efficient prime generation and modular inverse computation. Task You need to implement the following functions in Python to extend the RSA functionality: 1. **Efficient Prime Generation**: Create a function `efficient_gen_prime(k, seed=None)` that generates a prime number with `k` bits using a probabilistic approach (e.g., Miller-Rabin primality test). 2. **Extended Key Generation**: Modify the `generate_key` function to incorporate the more efficient prime generation mechanism. Ensure that the generated keys are valid and testable. 3. **Key Validation**: Implement a function `validate_keys(n, e, d)` to verify if the generated `(n, e, d)` triplet satisfies RSA\'s core properties. Ensure that `((x ** e) ** d) % n == x % n` holds true for several test values of `x`. Function Signatures ```python def efficient_gen_prime(k, seed=None): pass def generate_key(k, seed=None): pass def validate_keys(n, e, d): pass ``` Input and Output Formats 1. **efficient_gen_prime(k, seed=None)** - **Input**: - `k`: An integer specifying the number of bits. - `seed`: An optional integer for deterministic randomness (default is None). - **Output**: - A prime number with `k` bits. 2. **generate_key(k, seed=None)** - **Input**: - `k`: An integer specifying the total number of bits for `n`. - `seed`: An optional integer for deterministic randomness (default is None). - **Output**: - A tuple `(n, e, d)` which are the modulus, encryption exponent, and decryption exponent respectively. 3. **validate_keys(n, e, d)** - **Input**: - `n, e, d`: Integers representing the RSA keys. - **Output**: - A boolean indicating whether the provided keys are valid RSA keys. Constraints 1. Ensure that the functions are efficient and handle large integers gracefully. 2. Test cases will include edge scenarios to ensure robustness. Example ```python k = 16 prime = efficient_gen_prime(k) print(prime) # Expected output: A prime number with 16 bits n, e, d = generate_key(16) print(validate_keys(n, e, d)) # Expected output: True if keys are valid ```","solution":"import random from sympy import gcd, mod_inverse, isprime def efficient_gen_prime(k, seed=None): Generates a prime number with k bits using a probabilistic approach. Args: k (int): Number of bits. seed (int): Optional seed for deterministic randomness. Returns: int: A prime number with k bits. if seed is not None: random.seed(seed) while True: # Generate random k-bit number candidate = random.getrandbits(k) # Set the MSB and LSB to 1 to ensure it\'s k bits and odd candidate |= (1 << (k - 1)) | 1 if isprime(candidate): return candidate def generate_key(k, seed=None): Generates RSA keys (n, e, d). Args: k (int): The number of bits for n. seed (int): Optional seed for deterministic randomness. Returns: tuple: (n, e, d) where n is the modulus, e is the encryption exponent, and d is the decryption exponent. if seed is not None: random.seed(seed) e = 65537 # Commonly used prime exponent # Ensure the primes are half the size of the modulus prime_bits = k // 2 while True: p = efficient_gen_prime(prime_bits, seed) q = efficient_gen_prime(prime_bits, seed + 1 if seed is not None else None) if p != q: break n = p * q phi = (p - 1) * (q - 1) d = mod_inverse(e, phi) return (n, e, d) def validate_keys(n, e, d): Validates RSA keys. Args: n (int): Modulus. e (int): Encryption exponent. d (int): Decryption exponent. Returns: bool: True if the provided keys are valid RSA keys, False otherwise. test_values = [1, 2, 3, 17, 65537] # Test with some values for x in test_values: if x >= n: continue if pow(pow(x, e, n), d, n) != x: return False return True"},{"question":"# Scenario: You are implementing a task scheduler that needs a custom queue structure to manage and process tasks in the order they arrive. The task scheduler needs to support two types of queues: array-based and linked-list-based. # Task: Implement the following class `TaskScheduler` which uses both `ArrayQueue` and `LinkedListQueue` as available in the given code snippet. 1. The scheduler should have methods to add tasks, process tasks, and query the current state. 2. Implement the following methods: - `add_task(task)`: Adds a task to both the array-based and linked-list-based queues. - `process_next_task()`: Processes the next task from both queues. It should raise an error if no tasks are available. - `upcoming_task()`: Returns the next task that will be processed without removing it from both queues. - `is_empty()`: Checks if both queues are empty. - `queue_size()`: Returns the current size of the queues. Tasks are represented as strings for simplicity. # Constraints: * `add_task()` operations should complete in constant O(1) time. * `process_next_task()` operations should complete in O(1) time. * `upcoming_task()` operations should complete in O(1) time. * You may assume that the system running this scheduler has sufficient memory for these operations. # Performance requirements: * Ensure that all methods handle edge scenarios, like operating on an empty queue, gracefully. * Optimize memory usage where possible, especially for the `ArrayQueue`. # Implementation: Write the class `TaskScheduler` as described above. ```python class TaskScheduler: def __init__(self): self.array_queue = ArrayQueue() self.linked_list_queue = LinkedListQueue() def add_task(self, task: str): # your code here def process_next_task(self) -> str: # your code here def upcoming_task(self) -> str: # your code here def is_empty(self) -> bool: # your code here def queue_size(self) -> int: # your code here ``` Ensure your methods enforce the constraints and handle any error scenarios appropriately.","solution":"class TaskScheduler: def __init__(self): self.array_queue = ArrayQueue() self.linked_list_queue = LinkedListQueue() def add_task(self, task: str): Adds a task to both the array-based and linked-list-based queues. self.array_queue.enqueue(task) self.linked_list_queue.enqueue(task) def process_next_task(self) -> str: Processes the next task from both queues. Raises an error if no tasks are available. if self.is_empty(): raise IndexError(\\"No tasks to process\\") array_task = self.array_queue.dequeue() linked_list_task = self.linked_list_queue.dequeue() if array_task != linked_list_task: raise ValueError(\\"Inconsistent state between queues\\") return array_task def upcoming_task(self) -> str: Returns the next task that will be processed without removing it from both queues. if self.is_empty(): raise IndexError(\\"No upcoming tasks\\") array_task = self.array_queue.peek() linked_list_task = self.linked_list_queue.peek() if array_task != linked_list_task: raise ValueError(\\"Inconsistent state between queues\\") return array_task def is_empty(self) -> bool: Checks if both queues are empty. return self.array_queue.is_empty() and self.linked_list_queue.is_empty() def queue_size(self) -> int: Returns the current size of the queues. array_size = self.array_queue.size() linked_list_size = self.linked_list_queue.size() if array_size != linked_list_size: raise ValueError(\\"Inconsistent state between queues\\") return array_size class ArrayQueue: def __init__(self): self.queue = [] def enqueue(self, item): self.queue.append(item) def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue.pop(0) def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[0] def is_empty(self): return len(self.queue) == 0 def size(self): return len(self.queue) class LinkedListQueue: class Node: def __init__(self, data=None): self.data = data self.next = None def __init__(self): self.head = None self.tail = None self._size = 0 def enqueue(self, item): new_node = self.Node(item) if self.is_empty(): self.head = self.tail = new_node else: self.tail.next = new_node self.tail = new_node self._size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") data = self.head.data self.head = self.head.next if self.head is None: self.tail = None self._size -= 1 return data def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.head.data def is_empty(self): return self.head is None def size(self): return self._size"},{"question":"Implement Modified Jump Search Scenario You are working as a software developer for a search engine company, and your task is to implement an efficient search algorithm to index sorted search results quickly. Your manager has suggested using Jump Search for its simplicity and efficiency with sorted data. However, the datasets are subjected to frequent updates, which means the algorithm must remain simple for frequent testing but flexible for large datasets. Task Implement a function `jump_search_modified(arr: list[int], target: int) -> int` that performs a Jump Search on a sorted array but additionally checks two conditions: 1. If the target value is found in the array, return the index of the first occurrence of the target. 2. If the target value is not present in the array, return -1. Requirements - **Input Format**: - `arr`: A list of sorted integers (e.g., `[1, 2, 3, 4, 5, 6, 7, 8, 9]`). - `target`: An integer value to search for in the list. - **Output Format**: - Return the index of the first occurrence of the target value if found, or -1 otherwise. - **Constraints**: - The input list can have up to 10^6 integers. - The target integer can be any valid integer. Performance Requirements - The algorithm should aim to have a time complexity of O(√n) to handle very large datasets efficiently. - Space complexity should remain O(1). ```python def jump_search_modified(arr: list[int], target: int) -> int: import math length = len(arr) if length == 0: return -1 block_size = int(math.sqrt(length)) block_prev = 0 block = block_size if arr[length - 1] < target: return -1 while block <= length and arr[block - 1] < target: block_prev = block block += block_size while block_prev < min(block, length) and arr[block_prev] < target: block_prev += 1 if block_prev == min(block, length): return -1 if block_prev < length and arr[block_prev] == target: return block_prev return -1 # Feel free to add any additional helper functions if necessary. ```","solution":"def jump_search_modified(arr: list[int], target: int) -> int: import math length = len(arr) if length == 0: return -1 block_size = int(math.sqrt(length)) block_prev = 0 block = block_size while block_prev < length and arr[min(block, length) - 1] < target: block_prev = block block += block_size if block_prev >= length: return -1 while block_prev < min(block, length) and arr[block_prev] < target: block_prev += 1 if block_prev < length and arr[block_prev] == target: return block_prev return -1"},{"question":"You are building a new text editor application that helps users correct typos by providing suggestions for misspelled words. To do this, you need to implement a function that calculates the edit distance between two given words. The edit distance is the minimum number of insertions, deletions, and substitutions required to transform one word into another. Function Signature ```python def edit_distance(word_a: str, word_b: str) -> int: ... ``` Parameters * `word_a` (str): The first word. * `word_b` (str): The second word. Returns * (int): The minimum number of operations required to transform `word_a` into `word_b`. Constraints * The inputs will be valid strings containing only lowercase English letters. * The lengths of the words `word_a` and `word_b` will not exceed 1,000. Example ```python assert edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert edit_distance(\\"intention\\", \\"execution\\") == 5 assert edit_distance(\\"food\\", \\"money\\") == 4 assert edit_distance(\\"\\", \\"abc\\") == 3 ``` Performance Requirements * The solution should be optimized to handle the constraint limits efficiently. * It should aim for a time complexity of (O(n times m)), where `n` and `m` are the lengths of `word_a` and `word_b` respectively. * Space complexity should be reduced where possible, ideally to (O(min(n, m))). Scenario or Context In your text editor application, as a user types their content, the editor should be able to suggest corrections by determining the edit distance to known dictionary words instantly. Therefore, implementing an efficient version of the algorithm is critical to avoid any lag in user interaction.","solution":"def edit_distance(word_a: str, word_b: str) -> int: Returns the minimum number of operations required to transform `word_a` into `word_b`. Operations can be insertions, deletions, or substitutions. len_a, len_b = len(word_a), len(word_b) # If one of the strings is empty if len_a == 0: return len_b if len_b == 0: return len_a # Create a (len_a + 1) x (len_b + 1) distance matrix dp = [[0] * (len_b + 1) for _ in range(len_a + 1)] # Initialize the distance matrix for i in range(len_a + 1): dp[i][0] = i for j in range(len_b + 1): dp[0][j] = j # Compute the distances for i in range(1, len_a + 1): for j in range(1, len_b + 1): if word_a[i - 1] == word_b[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1) # Substitution return dp[len_a][len_b]"},{"question":"As a software engineer at a security company, you need to implement an authentication feature that relies on prime numbers for encryption keys. Your task is to write a function to generate the first `k` prime numbers greater than or equal to a given integer n. **Task**: Write a function `generate_primes` that accepts two integers, `n` and `k`, and returns a list of the first `k` prime numbers greater than or equal to `n`. # Function Signature ```python def generate_primes(n: int, k: int) -> List[int]: pass ``` # Input - `n` (1 ≤ n ≤ 10^9): an integer where prime generation starts. - `k` (1 ≤ k ≤ 10^4): the number of primes to be generated. # Output - `List[int]`: a list of the first `k` prime numbers ≥ `n`. # Constraints - The primes must be generated in order. - Ensure the function runs efficiently within the limits given. # Example ```python assert generate_primes(10, 5) == [11, 13, 17, 19, 23] assert generate_primes(50, 3) == [53, 59, 61] ``` # Notes - Consider edge cases such as when `n` is already prime or when `n` is very small compared to `k`. - Implement efficient checks to ensure performance meets the constraints especially when `n` is large.","solution":"from typing import List import math def is_prime(num: int) -> bool: if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def generate_primes(n: int, k: int) -> List[int]: primes = [] candidate = n while len(primes) < k: if is_prime(candidate): primes.append(candidate) candidate += 1 return primes"},{"question":"# Pigeonhole Sort Implementation **Scenario**: Imagine you are a data scientist given the task of analyzing exam scores of a large class of students. The scores are distributed within a specific range (e.g., 0 to 100). You are asked to sort these scores efficiently. **Task**: Write a function `pigeonhole_sort` in Python to sort an array of integers using the Pigeonhole Sort algorithm. **Function Signature**: ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` **Input**: * `arr` - A list of integers, unsorted, where the number of elements and the range of values are reasonably close (0 <= len(arr) <= 10^6). **Output**: * Returns a list of integers, sorted in non-decreasing order. **Constraints**: * Assumes that integer values will fit within the range defined by Python\'s `int`. * Elements in the list are non-negative and fit within a small range relative to the number of elements (e.g., less than 10^4 in difference between the maximum and minimum). **Example**: ```python print(pigeonhole_sort([8, 3, 2, 7, 4])) # Output: [2, 3, 4, 7, 8] print(pigeonhole_sort([9, 0, 0, 9, 3, 0, 3, 9, 9])) # Output: [0, 0, 0, 3, 3, 9, 9, 9, 9] ``` **Notes**: Ensure your function handles edge cases properly such as arrays with a single element and empty arrays.","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: Sorts the given array of integers using the pigeonhole sort algorithm. if not arr: return arr min_val = min(arr) max_val = max(arr) size = max_val - min_val + 1 holes = [0] * size for num in arr: holes[num - min_val] += 1 sorted_arr = [] for i in range(size): while holes[i] > 0: sorted_arr.append(i + min_val) holes[i] -= 1 return sorted_arr"},{"question":"# Coding Challenge: Removing Duplicates from a Singly Linked List Context: You are given a singly linked list that may contain duplicate values. Your task is to implement two functions to remove these duplicates. One function will use an additional data structure, a hashset, to maintain O(N) time complexity, while another will not use any extra space, hence running at O(N^2) time complexity. Function Signature: ```python class Node: def __init__(self, val: str): self.val = val self.next = None def remove_dups(head: Node) -> None: Removes duplicates from the linked list using a hash set. Parameters: head (Node): The head node of the linked list. Returns: None: The linked list is modified in place. def remove_dups_without_set(head: Node) -> None: Removes duplicates from the linked list without using any extra space. Parameters: head (Node): The head node of the linked list. Returns: None: The linked list is modified in place. ``` Requirements: 1. Implement the `remove_dups` function that removes duplicates using a hash set. 2. Implement the `remove_dups_without_set` function that removes duplicates without using any additional data structures. Input: - A singly linked list where each node contains a string value `val`. Output: - The linked list without duplicates. Constraints: - The linked list contains at most 10^6 nodes. - The value of each node is a string of length between 1 and 10 characters. Example: Given the linked list: ``` A -> A -> B -> C -> D -> C -> F -> G ``` After removing duplicates using `remove_dups`: ``` A -> B -> C -> D -> F -> G ``` After removing duplicates using `remove_dups_without_set`: ``` A -> B -> C -> D -> F -> G ``` Edge Cases: 1. Empty List: handle gracefully without errors.","solution":"class Node: def __init__(self, val: str): self.val = val self.next = None def remove_dups(head: Node) -> None: Removes duplicates from the linked list using a hash set. Parameters: head (Node): The head node of the linked list. Returns: None: The linked list is modified in place. if not head: return seen = set() current = head seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_dups_without_set(head: Node) -> None: Removes duplicates from the linked list without using any extra space. Parameters: head (Node): The head node of the linked list. Returns: None: The linked list is modified in place. current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"# Question You are given a list that may contain nested lists as elements. Your task is to flatten this list into a single-dimensional list. You need to implement two functions: 1. **flatten(input_list)** - A function that returns a flattened list by using recursion. 2. **flatten_iter(input_list)** - A function that returns an iterator which will produce flattened elements one by one using a generator. **Function Signatures**: ```python def flatten(input_list: list) -> list: pass def flatten_iter(input_list: list) -> Iterable: pass ``` **Input**: - `input_list` (list): A potentially nested list of arbitrary depth, which may include integers, other lists, and other non-iterable elements. **Output**: - For `flatten`: A list containing all the elements of the nested lists, traversed in a depth-first manner. - For `flatten_iter`: An iterator that yields elements from the nested input list in a depth-first manner. **Constraints**: - You may assume that `input_list` does not contain any infinite iterable structures. - Elements inside `input_list` will be either lists or non-iterable elements like integers or strings. # Example ```python # Example for `flatten` input_list = [1, [2, [3, 4], 5], 6, [[7]], 8] print(flatten(input_list)) # Output: [1, 2, 3, 4, 5, 6, 7, 8] # Example for `flatten_iter` input_list = [1, [2, [3, 4], 5], 6, [[7]], 8] print(list(flatten_iter(input_list))) # Output: [1, 2, 3, 4, 5, 6, 7, 8] ``` # Notes: - Ensure your solution is efficient and handles deeply nested lists gracefully. - Pay special attention to the complexity and performance considerations discussed in the analysis.","solution":"from typing import Iterable def flatten(input_list: list) -> list: Recursively flattens a nested list into a single-dimensional list. result = [] for element in input_list: if isinstance(element, list): result.extend(flatten(element)) else: result.append(element) return result def flatten_iter(input_list: list) -> Iterable: Flattens a nested list into a single-dimensional sequence one element at a time using a generator. for element in input_list: if isinstance(element, list): yield from flatten_iter(element) else: yield element"},{"question":"# Question You are given three matrices: `matA`, `matB`, and `matC`, each of size `n x n`. You are required to implement a function `matrix_operations` that takes these matrices along with an integer `p` as inputs and returns the product of the following operations: 1. Matrix multiplication of `matA` and `matB`. 2. Matrix exponentiation of `matC` raised to the power `p`. Your function should adhere to the following specifications: ```python def matrix_operations(matA: list, matB: list, matC: list, p: int) -> list: Computes the matrix ((matA * matB) * (matC^p)) Parameters: matA (list of list of int): First matrix to multiply. matB (list of list of int): Second matrix to multiply. matC (list of list of int): Matrix to raise to power p. p (int): Exponent to raise matC. Returns: list of list of int: Resultant matrix after performing the operations. ``` # Constraints 1. All matrices `matA`, `matB`, and `matC` are square matrices of size `n x n` where `1 <= n <= 100`. 2. The exponent `p` is a non-negative integer where `0 <= p <= 1000`. # Performance Requirements - Your implementation should optimize matrix operations as much as possible. - Aim for appropriate time complexity in your algorithm to handle edge cases efficiently. # Example: ```python matA = [ [1, 2], [3, 4] ] matB = [ [5, 6], [7, 8] ] matC = [ [2, 0], [0, 2] ] p = 2 # Compute matC^2 # matC^2 = [[4, 0], [0, 4]] # Compute matA * matB # Result = [[19, 22], [43, 50]] # Compute final ((matA * matB) * (matC^2)) # Result = [[76, 88], [172, 200]] matrix_operations(matA, matB, matC, p) # Output should be: [[76, 88], [172, 200]] ``` Remember to handle all edge cases and ensure that your solution is efficient for large matrices and high values of `p`.","solution":"def matrix_multiply(mat1, mat2): Multiplies two matrices mat1 and mat2. n = len(mat1) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): for k in range(n): result[i][j] += mat1[i][k] * mat2[k][j] return result def matrix_exponentiate(mat, power): Raises matrix mat to the power of `power`. Uses exponentiation by squaring for efficiency. n = len(mat) # Initialize result as the identity matrix result = [[1 if i == j else 0 for j in range(n)] for i in range(n)] base = mat while power: if power % 2: result = matrix_multiply(result, base) base = matrix_multiply(base, base) power //= 2 return result def matrix_operations(matA, matB, matC, p): Computes the matrix ((matA * matB) * (matC^p)). # Step 1: Matrix multiplication of matA and matB product_matAB = matrix_multiply(matA, matB) # Step 2: Matrix exponentiation of matC raised to the power p matC_power_p = matrix_exponentiate(matC, p) # Step 3: Multiply the result of step 1 with the result of step 2 result = matrix_multiply(product_matAB, matC_power_p) return result"},{"question":"# Question The warehouse has implemented a simple navigation system for robots. Each robot starts at position (0, 0) in a 2D plane and moves according to a given sequence of commands. Each command in the sequence instructs the robot to move one unit in one of four possible directions: * \'U\' means move one unit up. * \'D\' means move one unit down. * \'R\' means move one unit to the right. * \'L\' means move one unit to the left. Your task is to determine if the robot returns to the starting position after executing the entire sequence of commands. Implementation Write a function: ```python def judge_circle(moves: str) -> bool: ``` **Input**: * `moves`: A string of characters where each character can be \'R\', \'L\', \'U\', or \'D\'. It represents the sequence of commands issued to the robot. The length of the string will be at most 10,000. **Output**: * Return `True` if the robot returns to the starting position (0, 0) after executing all the commands, otherwise `False`. **Constraints**: * All characters in the input string are guaranteed to be one of \'R\', \'L\', \'U\', or \'D\'. Example Example 1: ```python moves = \\"UD\\" print(judge_circle(moves)) # Expected output: True ``` Example 2: ```python moves = \\"LL\\" print(judge_circle(moves)) # Expected output: False ``` Example 3: ```python moves = \\"RRDD\\" print(judge_circle(moves)) # Expected output: False ``` Example 4: ```python moves = \\"RLUD\\" print(judge_circle(moves)) # Expected output: True ``` Tip: You may use a dictionary to count the moves or any other data structures that you find optimal to solve the problem efficiently.","solution":"def judge_circle(moves: str) -> bool: Determine if the sequence of moves brings the robot back to the starting point (0, 0). Args: moves (str): A string containing the sequence of moves where each character is \'R\', \'L\', \'U\', or \'D\'. Returns: bool: True if the robot returns to the starting point, otherwise False. x, y = 0, 0 for move in moves: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'R\': x += 1 elif move == \'L\': x -= 1 return x == 0 and y == 0"},{"question":"You are tasked with building a function that reformats a given alphanumeric string by removing all non-alphanumeric characters (dashes) and then inserting dashes in a specific pattern. The function should insert dashes after every `k` characters from the end. Function Signature `def reformat_license_key(key: str, k: int) -> str:` Parameters * **key** (str): The input string which contains alphanumeric characters and possibly dashes (`\\"-\\"`). * **k** (int): The interval at which dashes should be inserted. Returns * **str**: The reformatted string according to the described rules. Constraints * `1 <= len(key) <= 10000` * `1 <= k <= len(key)` Examples ``` 1. reformat_license_key(\\"2-4A0r7-4k\\", 4) Output: \\"24A0-R74K\\" 2. reformat_license_key(\\"2-4A0r7-4k\\", 3) Output: \\"24-A0R-74K\\" 3. reformat_license_key(\\"abc-def-ghij\\", 2) Output: \\"AB-CD-EF-GH-IJ\\" 4. reformat_license_key(\\"5F3Z-2e-9-w\\", 4) Output: \\"5F3Z-2E9W\\" ``` Scenario You are working on a software product that requires license keys to be formatted in a readable manner after they are generated. Each license key is given with a specific delimiter and you need to ensure that after removing these delimiters, the remaining characters are grouped in blocks of a given size, starting from the end of the string. Your function will ensure that users can read and enter these license keys easily. Your implementation should be efficient and handle the upper limits of input sizes within reasonable time and space constraints.","solution":"def reformat_license_key(key: str, k: int) -> str: Reformats a given alphanumeric string by removing all non-alphanumeric characters and then inserting dashes after every k characters from the end. Parameters: key (str): The input string which contains alphanumeric characters and possibly dashes. k (int): The interval at which dashes should be inserted. Returns: str: The reformatted string according to the described rules. # Remove all dashes and convert to uppercase alphanumeric_str = key.replace(\'-\', \'\').upper() # Initialize a list to hold the reformatted components reformat_list = [] # Break the string into chunks of size k from the end while len(alphanumeric_str) > 0: reformat_list.insert(0, alphanumeric_str[-k:]) alphanumeric_str = alphanumeric_str[:-k] # Join the chunks with dashes reformatted_key = \'-\'.join(reformat_list) return reformatted_key"},{"question":"Implement a Priority Queue using Min Heap Background A Min Heap is a type of complete binary tree where the value of each node is no greater than the values of its children. It is commonly used in the implementation of priority queues. In a min heap, the minimum element is always at the root. Objective Implement a min priority queue using the given Min Heap class. Ensure to handle all common edge cases and optimize for performance. Task You are required to complete the `BinaryHeap` class as described below: 1. `perc_up(self, i)`: Adjust the position of a newly inserted element to maintain the heap property. 2. `insert(self, val)`: Insert an element into the heap and maintain the heap property. 3. `min_child(self, i)`: Get the index of the smaller child. 4. `perc_down(self, i)`: Adjust the position of the root element after removal to maintain the heap property. 5. `remove_min(self)`: Remove the minimum element and maintain the heap property. Input and Output Formats - `insert(val)`: - **Input**: A single integer `val` to be inserted into the heap. - **Output**: None. - `remove_min()`: - **Input**: None. - **Output**: Returns the minimum value in the heap. If the heap is empty, return `None`. - Additional utility methods should be implemented to manage and debug the heap contents. Constraints - Implement the above methods ensuring an average-case time complexity of O(log N) for both insertion and removal. Example ```python heap = BinaryHeap() heap.insert(4) heap.insert(50) heap.insert(7) heap.insert(55) heap.insert(90) heap.insert(87) heap.insert(2) print(heap.remove_min()) # Output should be 2 print(heap.remove_min()) # Output should be 4 ``` Complete the methods inside the `BinaryHeap` class so that the priority queue operates as described.","solution":"class BinaryHeap: def __init__(self): self.heap = [0] self.current_size = 0 def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def insert(self, val): self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def min_child(self, i): if i * 2 + 1 > self.current_size: return i * 2 else: if self.heap[i * 2] < self.heap[i * 2 + 1]: return i * 2 else: return i * 2 + 1 def perc_down(self, i): while (i * 2) <= self.current_size: mc = self.min_child(i) if self.heap[i] > self.heap[mc]: self.heap[i], self.heap[mc] = self.heap[mc], self.heap[i] i = mc def remove_min(self): if self.current_size == 0: return None min_val = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() self.perc_down(1) return min_val"},{"question":"# Question: Implement the Improved Cosine Similarity with Error Handling You are provided with the task to implement an enhanced version of the cosine similarity function, which is used to measure the similarity between two numerical vectors. To ensure robustness, you need to include proper error handling for possible edge cases. Requirements: - Write a function `improved_cosine_similarity(vec1, vec2)` that computes the cosine similarity between two vectors. - Ensure the two vectors have the same length. If not, raise a `ValueError`. - Handle the case where a vector is entirely zero, preventing division by zero errors. - Normalize the vectors, such that their L2 norms are within a valid range before computing the similarity. Input and Output Formats: - **Input**: Two lists of equal length containing numerical values. - Example: `vec1 = [1, 1, 1], vec2 = [1, 2, -1]` - **Output**: A float representing the cosine similarity. - Example: `0.47140452079103173` Constraints: - The lengths of the vectors, ( n ), will satisfy ( 1 leq n leq 10^6 ). - The values in the vectors are real numbers. Performance Requirements: - The function should run in linear time, ( O(n) ), relative to the length of the vectors. Scenario: Consider you are working with a large dataset of user ratings for movies stored as high-dimensional vectors. To recommend movies to a user based on their similarity to movies they\'ve liked, it\'s crucial to measure how close the vectors are in terms of direction rather than magnitude, and cosine similarity is a fitting measure for this purpose. Your task is to ensure this similarity measure is both accurate and efficient, even for very sparse vectors. Function Signature: ```python def improved_cosine_similarity(vec1: list, vec2: list) -> float: # Your implementation here pass ```","solution":"import math def improved_cosine_similarity(vec1, vec2): Computes the cosine similarity between two vectors vec1 and vec2. Args: - vec1 (list): First input vector. - vec2 (list): Second input vector. Returns: - float: Cosine similarity between the two vectors. Raises: - ValueError: If the vectors are not of the same length. - ValueError: If either vector is entirely zero. # Check if vectors have the same length if len(vec1) != len(vec2): raise ValueError(\\"Vectors must be of the same length\\") # Compute dot product, norm of vec1, and norm of vec2 dot_product = 0 norm_vec1 = 0 norm_vec2 = 0 for v1, v2 in zip(vec1, vec2): dot_product += v1 * v2 norm_vec1 += v1 ** 2 norm_vec2 += v2 ** 2 norm_vec1 = math.sqrt(norm_vec1) norm_vec2 = math.sqrt(norm_vec2) # Raise an error if either vector is entirely zero if norm_vec1 == 0 or norm_vec2 == 0: raise ValueError(\\"Vectors must not be entirely zero\\") # Compute cosine similarity cosine_similarity = dot_product / (norm_vec1 * norm_vec2) return cosine_similarity"},{"question":"# Dijkstra\'s Algorithm Assessment In this task, you are required to implement an enhanced version of Dijkstra\'s algorithm that returns not only the shortest distances but also the actual shortest paths from the source node to all other nodes in a graph. This will test your understanding of the core principles and implementation details of this algorithm. **Context**: You are working on a network routing system where you need to determine not just the shortest path distances but the actual paths along which packets travel from a source router to all other routers in the network. **Function to Implement**: ```python def dijkstra_shortest_path(graph, src): Given a weighted graph represented as an adjacency matrix and a source node, returns a tuple containing: - a list of shortest distances from the source node to each node, - a list of lists containing the paths from the source node to each node. Args: graph: List of List of int - 2D list representing the adjacency matrix of the graph. src: int - The source node for which the shortest paths are to be found. Returns: Tuple: (dist, paths) dist: List of int - Shortest distances from the source node to each node. paths: List of List of int - The paths from the source node to each node. pass ``` **Input Format**: - The graph should be a square 2D list of integers, where each element represents the weight of the edge between vertices. - If there is no edge between two nodes, the weight will be represented as infinity (`float(\'inf\')`), except the diagonal which will be zero. - The source node is an integer representing the starting vertex (0-indexed). **Output Format**: - A tuple containing two elements: 1. A list of integers representing the shortest distances from the source node to each other node. 2. A list of paths, where each path is represented as a list of nodes, showing the exact route from the source node to each respective node. **Constraints**: - The graph will have between 2 and 1000 vertices. - The weights will be non-negative integers, and the edge weights will not exceed (10^6). **Performance Requirements**: - Aim for a time complexity of (O((V + E) log V)) by using a priority queue. **Example**: ```python graph = [ [0, 1, 4, float(\'inf\')], [1, 0, 4, 2], [4, 4, 0, 3], [float(\'inf\'), 2, 3, 0] ] src = 0 # Expected output: # ([0, 1, 4, 3], [[0], [0, 1], [0, 2], [0, 1, 3]]), where the array represents distances. print(dijkstra_shortest_path(graph, src)) ``` **Notes**: - Be sure to handle graphs with disconnected components appropriately and return the correct shortest distance and path as `float(\'inf\')` and empty list respectively, if no path exists between the source and target nodes.","solution":"import heapq def dijkstra_shortest_path(graph, src): Given a weighted graph represented as an adjacency matrix and a source node, returns a tuple containing: - a list of shortest distances from the source node to each node, - a list of lists containing the paths from the source node to each node. Args: graph: List of List of int - 2D list representing the adjacency matrix of the graph. src: int - The source node for which the shortest paths are to be found. Returns: Tuple: (dist, paths) dist: List of int - Shortest distances from the source node to each node. paths: List of List of int - The paths from the source node to each node. V = len(graph) dist = [float(\'inf\')] * V dist[src] = 0 prev = [-1] * V visited = [False] * V # Priority queue for choosing the next node with the smallest distance priority_queue = [(0, src)] heapq.heapify(priority_queue) while priority_queue: (current_dist, u) = heapq.heappop(priority_queue) if visited[u]: continue visited[u] = True for v in range(V): if graph[u][v] != float(\'inf\') and not visited[v]: new_dist = current_dist + graph[u][v] if new_dist < dist[v]: dist[v] = new_dist prev[v] = u heapq.heappush(priority_queue, (new_dist, v)) paths = [] for target in range(V): if dist[target] == float(\'inf\'): paths.append([]) else: path = [] v = target while v != -1: path.insert(0, v) v = prev[v] paths.append(path) return dist, paths"},{"question":"**FizzBuzz Redesigned** You need to write a function `custom_fizzbuzz` that implements a modified version of FizzBuzz. This version accepts three additional parameters, `mult_1`, `mult_2`, and `mult_3`, besides `n`. These parameters will be used in place of 3 and 5 for determining the replacements \\"Fizz\\" and \\"Buzz\\". If a number is divisible by both `mult_1` and `mult_2`, it should return to \\"FizzBuzz\\", and a third substitution word \\"Jazz\\" should be used when a number is divisible by `mult_3`. Thus, the function signature will be: ```python def custom_fizzbuzz(n, mult_1, mult_2, mult_3): pass ``` # Specifications * **Input**: - `n` (int): an integer greater than or equal to 1 representing the upper bound of iteration (1≤n≤1000). - `mult_1` (int): an integer greater than zero representing the first multiple for substitution. - `mult_2` (int): an integer greater than zero representing the second multiple for substitution. - `mult_3` (int): an integer greater than zero representing the third multiple for substitution. * **Output**: - A list of length `n` containing integers or the substitution words \\"Fizz\\", \\"Buzz\\", \\"FizzBuzz\\", or \\"Jazz\\". # Examples 1. For `custom_fizzbuzz(15, 3, 5, 7)`, the output should be: ```python [1, 2, \\"Fizz\\", 4, \\"Buzz\\", \\"Fizz\\", \\"Jazz\\", 8, \\"Fizz\\", \\"Buzz\\", 11, \\"Fizz\\", 13, \\"Jazz\\", \\"FizzBuzz\\"] ``` 2. For `custom_fizzbuzz(10, 2, 4, 6)`, the output should be: ```python [1, \\"Fizz\\", 3, \\"FizzBuzz\\", 5, \\"Jazz\\", 7, \\"FizzBuzz\\", 9, \\"Fizz\\"] ``` # Constraints * You should handle invalid inputs by raising appropriate exceptions: - Raise `ValueError` if `n` is less than 1. - Raise `TypeError` if any of the inputs are not of integer type. * Ensure the function returns the expected results within acceptable performance limits (O(n) time complexity). Good luck!","solution":"def custom_fizzbuzz(n, mult_1, mult_2, mult_3): if not all(isinstance(x, int) for x in (n, mult_1, mult_2, mult_3)): raise TypeError(\\"All inputs must be integers.\\") if n < 1: raise ValueError(\\"n must be greater than or equal to 1.\\") if any(x <= 0 for x in (mult_1, mult_2, mult_3)): raise ValueError(\\"Multiples must be greater than 0.\\") result = [] for i in range(1, n + 1): if i % mult_1 == 0 and i % mult_2 == 0: result.append(\\"FizzBuzz\\") elif i % mult_3 == 0: result.append(\\"Jazz\\") elif i % mult_1 == 0: result.append(\\"Fizz\\") elif i % mult_2 == 0: result.append(\\"Buzz\\") else: result.append(i) return result"},{"question":"Scenario You are developing a feature for a search engine that needs to find the position of a specific element in a rotated sorted array. The array was originally sorted in ascending order and then rotated at some unknown pivot. Your task is to write a function to find the index of the target value in this array. If the element is not found, return -1. Your implementation must be efficient and handle large arrays effectively. Function Signature ```python def search_rotated_sorted_array(array: List[int], target: int) -> int: pass ``` Input - `array`: List of `n` integers representing the rotated sorted array where `1 <= n <= 10^4`. - `target`: An integer representing the value to search for in the array. Output - Return the index of the target if it exists in the array. Otherwise, return -1. Constraints - Your solution must have a time complexity of O(log n). - You cannot modify the input array. - The array does not contain duplicates for simplicity. Examples 1. **Example 1**: - Input: `array = [4, 5, 6, 7, 0, 1, 2]`, `target = 0` - Output: `4` 2. **Example 2**: - Input: `array = [4, 5, 6, 7, 0, 1, 2]`, `target = 3` - Output: `-1` 3. **Example 3**: - Input: `array = [1], target = 0` - Output: `-1` Instructions 1. Implement the `search_rotated_sorted_array` function to use a binary search adaptation that handles the rotated array. 2. Ensure that the solution respects the O(log n) complexity requirement. 3. Include appropriate checks for edge cases and handle them within your implementation. 4. You may use either an iterative approach or a recursive approach, but consider the implications of stack overflow with very large arrays if using recursion.","solution":"def search_rotated_sorted_array(array, target): This function returns the index of the target in the rotated sorted array if found, otherwise -1. start, end = 0, len(array) - 1 while start <= end: mid = (start + end) // 2 if array[mid] == target: return mid if array[start] <= array[mid]: # left half is sorted if array[start] <= target < array[mid]: end = mid - 1 else: start = mid + 1 else: # right half is sorted if array[mid] < target <= array[end]: start = mid + 1 else: end = mid - 1 return -1"},{"question":"# Graph Coloring using BFS and DFS In graph theory, it is often required to assign colors to vertices of a graph such that no two adjacent vertices share the same color. This problem is known as graph coloring. For this problem, you need to confirm whether a given graph is bipartite, which means you can color the graph using two colors in such a way that no two adjacent vertices share the same color. Your task is to implement two functions, `is_bipartite_dfs(graph)` and `is_bipartite_bfs(graph)`, using Depth First Search (DFS) and Breadth First Search (BFS) respectively. Each function should take a graph represented as an adjacency list and return a boolean indicating whether the graph is bipartite. # Input * A graph represented as a dictionary where keys are node identifiers and values are lists of adjacent nodes. # Output * A boolean value: * `True` if the graph is bipartite. * `False` otherwise. # Constraints * The graph does not contain self-loops. * The graph can be disconnected. * Nodes are represented by integers. # Example ```python graph_1 = { 0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2] } graph_2 = { 0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [1, 2] } print(is_bipartite_dfs(graph_1)) # Output: True print(is_bipartite_bfs(graph_1)) # Output: True print(is_bipartite_dfs(graph_2)) # Output: False print(is_bipartite_bfs(graph_2)) # Output: False ``` # Requirements * Both `is_bipartite_dfs` and `is_bipartite_bfs` should return correct results for all input graphs. * Your implementation should take into consideration disconnected graphs and handle each component appropriately. You must use DFS and BFS traversal algorithms for the respective functions provided.","solution":"def is_bipartite_dfs(graph): Returns True if the graph is bipartite using DFS, otherwise False. def dfs(node, color): stack = [(node, color)] while stack: n, c = stack.pop() if n in colors: if colors[n] != c: return False else: colors[n] = c for neighbor in graph[n]: stack.append((neighbor, 1 - c)) return True colors = {} for node in graph: if node not in colors: if not dfs(node, 0): return False return True from collections import deque def is_bipartite_bfs(graph): Returns True if the graph is bipartite using BFS, otherwise False. def bfs(start): queue = deque([(start, 0)]) while queue: node, color = queue.popleft() if node in colors: if colors[node] != color: return False else: colors[node] = color for neighbor in graph[node]: queue.append((neighbor, 1 - color)) return True colors = {} for node in graph: if node not in colors: if not bfs(node): return False return True"},{"question":"# Scenario You are developing a monitoring system for tracking resource usage in a cloud computing environment. One of its responsibilities is to keep an average of CPU usage over a fixed time window to trigger alerts if usage spikes. Implement a function to achieve this moving average calculation with a fixed window size for a given stream of usage data. # Task Write a Python class that maintains a moving average for a series of integers received incrementally. # Class Specification * **Class**: `MovingAverage` * **Methods**: - `__init__(self, size: int)`: Initializes the moving average object with a fixed window size. - `next(self, val: int) -> float`: Adds a new integer to the stream and returns the moving average of the last \'size\' integers. # Constraints * The window size `size` is a positive integer. * The stream of integers (values for `next`) are also positive integers. # Input and Output * **Input**: - `__init__(self, size: int)`: A single integer `size` for the window. - `next(self, val: int)`: A single integer `val` to be added to the window. * **Output**: - `next(self, val: int)`: Returns a float representing the moving average of the last `size` integers. # Examples ```python # Example usage: m = MovingAverage(3) print(m.next(1)) # Output: 1.0 print(m.next(10)) # Output: 5.5 print(m.next(3)) # Output: 4.67 print(m.next(5)) # Output: 6.0 ``` # Notes - Earlier elements drop off from the average calculation as the window slides forward. - Ensure precision up to two decimal places in the outputs.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): Initializes the moving average object with a fixed window size. self.size = size self.queue = deque(maxlen=size) self.sum = 0 def next(self, val: int) -> float: Adds a new integer to the stream and returns the moving average of the last \'size\' integers. if len(self.queue) == self.size: self.sum -= self.queue[0] self.queue.append(val) self.sum += val return round(self.sum / len(self.queue), 2)"},{"question":"# Subsets Generation and Validation # Context You have been given a set of distinct integers. Your task is to generate all the possible subsets of this set. Each subset should be returned as a tuple, and the collection of all subsets should be returned as a set to avoid duplicates. # Problem Statement Implement the `generate_subsets` function which takes a list of distinct integers `nums`, and returns a set of tuples where each tuple is a subset of the input list. # Input - `nums`: A list of distinct integers (1 <= len(nums) <= 16). # Output - A set of tuples, where each tuple is a subset of `nums`. # Function Signature ```python def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: ``` # Constraints * All elements in `nums` are distinct. * The number of subsets for the list of length `n` is `2^n`. * Your solution should handle edge cases, like an empty list or a list with a single element. # Example ```python assert generate_subsets([1, 2, 3]) == { (), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3) } assert generate_subsets([]) == { () } assert generate_subsets([4]) == { (), (4,) } ``` # Notes * You are expected to leverage the bit masking approach demonstrated in the provided code snippets. * Ensure your implementation is both time and space efficient considering the outlined complexity.","solution":"from typing import List, Set, Tuple def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: Generate all possible subsets of the given set of distinct integers. Args: nums : List[int] - List of distinct integers Returns: Set[Tuple[int]] - A set where each element is a tuple representing a subset of nums result = set() n = len(nums) for i in range(1 << n): subset = tuple(nums[j] for j in range(n) if i & (1 << j)) result.add(subset) return result"},{"question":"# Binary Search Tree: Advanced Operations Objective Your task is to extend the provided Binary Search Tree (BST) class by implementing the following methods: 1. Delete a node with a given value. 2. Check if the tree is balanced. 3. Convert the BST to a list in sorted order (do not use the inherent properties of the inorder traversal). Function Signatures ```python def delete(self, data) -> bool: Deletes a node with the given value from the BST. Returns True if the node was deleted, False otherwise. pass def is_balanced(self) -> bool: Checks if the BST is balanced. Returns True if balanced, False otherwise. pass def bst_to_sorted_list(self) -> list: Converts the BST to a list in sorted order. Returns the sorted list. pass ``` Constraints * Assume no duplicate values in the BST. * For the `delete` method, consider all three scenarios: * Node to be deleted has no children. * Node to be deleted has one child. * Node to be deleted has two children (find the in-order successor to replace). * An empty tree should return `False` for deletion, `True` for being balanced, and an empty list for bst_to_sorted_list. * A balanced tree must have minimal height differences between left and right subtrees for any node. Input/Output Format * **delete(self, data)** * **Input**: Integer `data`. * **Output**: Boolean indicating success of deletion. * **is_balanced(self)** * **Output**: Boolean indicating if the BST is balanced. * **bst_to_sorted_list(self)** * **Output**: List with elements in sorted order. Example ```python # Setup the initial tree tree = BST() tree.insert(10) tree.insert(15) tree.insert(6) tree.insert(4) tree.insert(9) tree.insert(12) tree.insert(24) tree.insert(7) tree.insert(20) tree.insert(30) tree.insert(18) # Test deletion assert tree.delete(24) == True # Node 24 exists and should be deleted assert tree.delete(50) == False # Node 50 doesn\'t exist # Check if tree is balanced assert tree.is_balanced() == True # Should return True for a balanced tree # Convert BST to sorted list assert tree.bst_to_sorted_list() == [4, 6, 7, 9, 10, 12, 15, 18, 20, 30] ``` Modify the above BST class accordingly to meet the requirements of these extended functions.","solution":"class Node: def __init__(self, key): self.right = None self.left = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def delete(self, data) -> bool: self.root, deleted = self._delete(self.root, data) return deleted def _delete(self, root, data): if root is None: return root, False if data < root.val: root.left, deleted = self._delete(root.left, data) elif data > root.val: root.right, deleted = self._delete(root.right, data) else: deleted = True if root.left is None: return root.right, deleted elif root.right is None: return root.left, deleted min_larger_node = self._get_min(root.right) root.val = min_larger_node.val root.right, _ = self._delete(root.right, min_larger_node.val) return root, deleted def _get_min(self, root): while root.left is not None: root = root.left return root def is_balanced(self) -> bool: def check_height(root): if root is None: return 0 left_height = check_height(root.left) right_height = check_height(root.right) if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1: return -1 # not balanced return max(left_height, right_height) + 1 return check_height(self.root) != -1 def bst_to_sorted_list(self) -> list: def inorder_traverse(root, result): if root is not None: inorder_traverse(root.left, result) result.append(root.val) inorder_traverse(root.right, result) result = [] inorder_traverse(self.root, result) return result"},{"question":"# File Path Resolver You are developing a script that processes various file paths provided by users. Frequently, users may input paths using shortcuts (like `~` for the home directory) or provide relative paths. To ensure the consistency and accuracy of the file path handling, you need to implement a function that converts any given path to its corresponding absolute path. Task Implement the function `resolve_path(path: str) -> str` that takes a file path as a string input and returns its absolute path, resolving any user-specific shortcuts such as `~` (home directory) and converting relative paths to absolute paths. Specifications - **Input**: A string `path` representing the file path. The path can be: * An absolute path. * A relative path. * A path containing user shortcuts (like `~`). - **Output**: A string representing the absolute path. Examples ```python assert resolve_path(\\"~/documents/project\\") == \\"/home/yourusername/documents/project\\" # Example output, depends on OS-specific home dir assert resolve_path(\\"report.txt\\") == \\"/current/directory/report.txt\\" # Resolves relative path assuming the current directory is \\"/current/directory\\" assert resolve_path(\\"/usr/local/bin\\") == \\"/usr/local/bin\\" # Already absolute path, remains unchanged ``` Constraints - The input path string will always be a valid file path string. - Assume that the system will execute in an environment where both `os.path.abspath` and `os.path.expanduser` are behaving as expected. Context Imagine a file management system where you need to process user-uploaded files located at various paths. To manage these files correctly, you must ensure that the paths provided are consistently transformed into absolute paths for further processing.","solution":"import os def resolve_path(path: str) -> str: Converts the given path to its absolute path, resolving any user-specific shortcuts like `~` for the home directory and converting relative paths to absolute paths. return os.path.abspath(os.path.expanduser(path))"},{"question":"**Min Heap Implementation Challenge** # Context You are working on developing a scheduling system where various tasks need to be prioritized based on their respective priority values. To maintain this system efficiently, making sure that the lowest priority tasks are handled first, you need to implement a Min Heap data structure. A Min Heap allows you to efficiently insert tasks and retrieve the task with the minimum priority. # Task Implement the `BinaryHeap` class that supports the following operations: 1. `insert(val)`: Insert a new integer value into the heap. 2. `remove_min()`: Remove and return the smallest integer from the heap. 3. `perc_up(i)`: Ensure that the heap property is maintained after insertion. 4. `perc_down(i)`: Ensure that the heap property is maintained after removal. 5. `min_child(i)`: Return the index of the smaller of the two children of the node at index `i`. # Implementation Details - Should be implemented using an array (or list in Python). - Heap should ensure the complete binary tree structure is maintained after each operation. # Constraints - The heap should support integers only. - The values inserted are non-negative integers. - Maximum number of elements to be inserted won\'t exceed 10000. # Example Usage ```python heap = BinaryHeap() heap.insert(5) heap.insert(2) heap.insert(8) print(heap.remove_min()) # Output: 2 print(heap.remove_min()) # Output: 5 print(heap.remove_min()) # Output: 8 ``` # Input 1. A list of operations to be performed on the heap. Operations can be one of the following: - \\"insert X\\" - to insert value X into the heap. - \\"remove_min\\" - to remove and print the minimum value from the heap. # Output Print the result of each \\"remove_min\\" operation on a new line. # Example ```python inputs = [ \\"insert 3\\", \\"insert 1\\", \\"insert 6\\", \\"remove_min\\", \\"insert 2\\", \\"remove_min\\" ] # Expected Output: # 1 # 2 ``` # Notes - Handle edge cases such as attempting to remove from an empty heap. - Ensure efficient operations to maintain performance constraints.","solution":"class BinaryHeap: def __init__(self): self.heap_list = [0] # Using index 0 as a placeholder to simplify integer division self.current_size = 0 def perc_up(self, i): while i // 2 > 0: if self.heap_list[i] < self.heap_list[i // 2]: self.heap_list[i], self.heap_list[i // 2] = self.heap_list[i // 2], self.heap_list[i] i = i // 2 def insert(self, val): self.heap_list.append(val) self.current_size += 1 self.perc_up(self.current_size) def perc_down(self, i): while (i * 2) <= self.current_size: mc = self.min_child(i) if self.heap_list[i] > self.heap_list[mc]: self.heap_list[i], self.heap_list[mc] = self.heap_list[mc], self.heap_list[i] i = mc def min_child(self, i): if (i * 2) + 1 > self.current_size: return i * 2 else: if self.heap_list[i * 2] < self.heap_list[(i * 2) + 1]: return i * 2 else: return (i * 2) + 1 def remove_min(self): if self.current_size == 0: raise IndexError(\\"remove_min invoked on an empty heap\\") root_val = self.heap_list[1] self.heap_list[1] = self.heap_list[self.current_size] self.current_size -= 1 self.heap_list.pop() self.perc_down(1) return root_val"},{"question":"Count Target Occurrences in Sorted Array Given a **sorted array** of integers and a target value, write a function to count the number of occurrences of the target value using an optimized approach. Utilize the principles of binary search to achieve an efficient solution with a time complexity of O(log(n)). Function Signature ```python def count_occurrences(array: List[int], target: int) -> int: pass ``` Input - `array`: A sorted list of integers (`-10^6 ≤ array[i] ≤ 10^6`) with length `n` (0 ≤ n ≤ 10^6). - `target`: An integer value (`-10^6 ≤ target ≤ 10^6`) to count in the array. Output - An integer representing the number of times the target appears in the array. Constraints - You are not allowed to use built-in functions that directly perform the counting. - Ensure the function operates within O(log(n)) time complexity. Examples 1. count_occurrences([1, 2, 2, 2, 3, 4, 5], 2) → 3 2. count_occurrences([1, 2, 3, 4, 5], 6) → 0 3. count_occurrences([], 3) → 0 4. count_occurrences([1, 2, 2, 3, 3, 3, 4], 3) → 3 Scenario Consider that you work on a back-end system for a phonebook application where fast number lookups are crucial to user experience. Users often search for contacts using partial or full matches. By pre-sorting the phonebook entries, you can efficiently count how many times a given name or number appears. Task Implement the `count_occurrences` function by using binary search to find the leftmost and rightmost occurrences of the target in the sorted array. The count will be determined by the positions of these occurrences.","solution":"from typing import List def count_occurrences(array: List[int], target: int) -> int: Counts the occurrences of the target value in the sorted array using binary search. def find_leftmost(array, target): left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] < target: left = mid + 1 else: right = mid - 1 return left def find_rightmost(array, target): left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] <= target: left = mid + 1 else: right = mid - 1 return right leftmost = find_leftmost(array, target) rightmost = find_rightmost(array, target) # Check if the target is actually present in the array. if leftmost < len(array) and array[leftmost] == target: return rightmost - leftmost + 1 else: return 0"},{"question":"You are given a non-negative integer. Your task is to find the next higher integer that can be formed using the same digits as the original number. If no such number exists, return -1. Implement a function `next_bigger(num)` to accomplish this. The implementation should be efficient in both time and space complexity. # Function Signature ```python def next_bigger(num: int) -> int: ``` # Input * `num` (integer): A non-negative integer. # Output * An integer representing the next higher permutation of the given digits, or `-1` if no such permutation exists. # Constraints 1. The input integer will fit within the range of a 32-bit signed integer. 2. Do not use any libraries or functions that directly perform permutations or combinations. # Scenarios and Examples * `next_bigger(38276)` should return `38627`. * `next_bigger(12345)` should return `12354`. * `next_bigger(54321)` should return `-1`. * `next_bigger(999)` should return `-1`. # Testing You should write several test cases to verify the correctness of your solution, ensuring to include edge cases. # Additional Notes * Consider numerical constraints and performance requirements to ensure your solution can handle large inputs efficiently. # Example ```python assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(54321) == -1 assert next_bigger(999) == -1 ``` # Hint Think about how you can convert the number to another form (e.g., a list of digits), manipulate that form to find the next permutation, and convert it back to the original form (an integer).","solution":"def next_bigger(num: int) -> int: num_list = list(str(num)) length = len(num_list) # Starting from the end, find the first digit that is smaller than the digit next to it. for i in range(length - 2, -1, -1): if num_list[i] < num_list[i + 1]: break else: # If no such digit is found, this is the largest permutation. return -1 # Find the smallest digit on the right side of the found digit that is larger than the found digit. for j in range(length - 1, i, -1): if num_list[j] > num_list[i]: # Swap the found digit with this digit num_list[i], num_list[j] = num_list[j], num_list[i] break # Reverse the digits after the position i+1 to get the smallest lexicographic order num_list = num_list[:i + 1] + sorted(num_list[i + 1:]) return int(\\"\\".join(num_list))"},{"question":"A postal service needs to track the number of digits in postal codes of various formats efficiently. They want to implement a function that determines the number of digits in each postal code to allocate the correct amount of space on forms and in databases. Your task is to write a Python function `num_digits` that takes an integer `n` (which can be positive or negative) as input and returns the number of digits in the absolute value of the number. Function Signature ```python def num_digits(n: int) -> int: ``` Input * An integer `n` where `-10^18 <= n <= 10^18`. Output * An integer representing the number of digits in the absolute value of `n`. Constraints * You must solve the problem in constant time O(1). * You may not use string conversion functions to determine the number of digits directly; logarithmic or other mathematical approaches are required. Examples ```python # Example 1: n = 12345 assert num_digits(n) == 5 # Example 2: n = -98765 assert num_digits(n) == 5 # Example 3: n = 0 assert num_digits(n) == 1 # Example 4: n = 1000000 assert num_digits(n) == 7 ``` Edge Cases 1. `n` being a very large positive or negative number within the given constraint. 2. `n` being zero.","solution":"import math def num_digits(n: int) -> int: Returns the number of digits in the absolute value of the integer n. if n == 0: return 1 return math.floor(math.log10(abs(n))) + 1"},{"question":"Problem Statement You are provided with two utility functions: `int_to_base` and `base_to_int` to convert numbers between integer form and base-represented strings. Your task is to implement a new function called `convert_base` that leverages these utilities to convert a number represented as a string in one base to another base. Function Signature ```python def convert_base(number_str, from_base, to_base): :param number_str: str, the number represented as a string in the from_base numeral system :param from_base: int, the base of the input number :param to_base: int, the base to convert the number to :return: str, the number represented in the to_base numeral system ``` Input * `number_str`: A string representing a number in base `from_base` (1 <= len(number_str) <= 50). * `from_base`: An integer representing the base of `number_str` (2 <= from_base <= 36). * `to_base`: An integer representing the base of the output string (2 <= to_base <= 36). Output * A string representing the number in base `to_base`. Constraints * Do not use built-in functions like `int()`, `hex()`, or `oct()` for base conversions directly. * Assume that the input `number_str` will always be valid for the given `from_base`. Example ```python convert_base(\'101\', 2, 10) -> \'5\' convert_base(\'FF\', 16, 10) -> \'255\' convert_base(\'255\', 10, 2) -> \'11111111\' ``` Notes * You may use the provided `int_to_base` and `base_to_int` functions as helper functions within your implementation. Good luck!","solution":"def int_to_base(number, base): Converts an integer to its string representation in a specified base. if number == 0: return \\"0\\" digits = [] while number: digits.append(int(number % base)) number //= base return \'\'.join(chr(digit + ord(\'0\')) if digit < 10 else chr(digit - 10 + ord(\'A\')) for digit in digits[::-1]) def base_to_int(number_str, base): Converts a string representation of a number in a specified base to an integer. number = 0 for char in number_str: digit = ord(char) - ord(\'0\') if \'0\' <= char <= \'9\' else ord(char) - ord(\'A\') + 10 number = number * base + digit return number def convert_base(number_str, from_base, to_base): Converts a number represented as a string in one base to another base. # Convert the number from the original base to an integer number_int = base_to_int(number_str, from_base) # Convert the integer to the new base return int_to_base(number_int, to_base)"},{"question":"# Linked List Deduplication Challenge You are given a singly linked list where each node contains a character. Your task is to implement a function that removes duplicate values from the linked list. Implement two versions of this function: 1. **With additional space**: Utilize a data structure like a hash set to achieve linear time complexity. 2. **Without additional space**: Utilize no extra space, achieving the deduplication with O(1) space but possibly higher time complexity. You need to write the following functions: ```python class Node(): def __init__(self, val=None): self.val = val self.next = None def remove_dups(head): Parameters: head (Node): Head of the singly linked list Returns: Node: Head of the modified linked list with duplicates removed def remove_dups_without_set(head): Parameters: head (Node): Head of the singly linked list Returns: Node: Head of the modified linked list with duplicates removed def print_linked_list(head): Prints linked list elements separated by \' -> \' string = \\"\\" while head.next: string += head.val + \\" -> \\" head = head.next string += head.val print(string) ``` Constraints * The linked list will only contain lowercase alphabetic characters. * The maximum number of nodes in the linked list will not exceed 10^3. Example Input Linked List (as chain of nodes): `A -> A -> B -> C -> D -> C -> F -> G` After removing duplicates with `remove_dups`: Output: `A -> B -> C -> D -> F -> G` After removing duplicates with `remove_dups_without_set`: Output: `A -> B -> C -> D -> F -> G` Notes 1. Pay attention to edge cases such as an empty list or a list with all unique elements. 2. Ensure your implementation properly handles updating of node pointers.","solution":"class Node(): def __init__(self, val=None): self.val = val self.next = None def remove_dups(head): Removes duplicates from the linked list with additional space (using a set). Parameters: head (Node): Head of the singly linked list Returns: Node: Head of the modified linked list with duplicates removed if not head: return head seen = set() current = head prev = None while current: if current.val in seen: prev.next = current.next else: seen.add(current.val) prev = current current = current.next return head def remove_dups_without_set(head): Removes duplicates from the linked list without additional space. Parameters: head (Node): Head of the singly linked list Returns: Node: Head of the modified linked list with duplicates removed if not head: return head current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next return head def print_linked_list(head): Prints linked list elements separated by \' -> \' string = \\"\\" while head and head.next: string += head.val + \\" -> \\" head = head.next string += head.val if head else \\"\\" print(string)"},{"question":"# Context You are tasked with maintaining an inventory system where items need to be stored and retrieved in a specific order based on their priority. # Task Implement an `OrderedStack` class that maintains an internal stack where items are ordered from the highest value at the top to the lowest at the bottom. You must ensure that items remain ordered with efficient operations for adding and removing elements. # Requirements Implement the following methods: 1. `__init__(self)`: Initializes an empty stack. 2. `is_empty(self)`: Returns `True` if the stack is empty, `False` otherwise. 3. `push(self, item)`: Inserts an item into the stack while maintaining order from highest to lowest. 4. `pop(self)`: Removes and returns the item at the top of the stack. Raises an `IndexError` if the stack is empty. 5. `peek(self)`: Returns the item at the top of the stack without removing it. Raises an `IndexError` if the stack is empty. 6. `size(self)`: Returns the current number of items in the stack. # Constraints - Items are integers. - `push`, `pop`, and `peek` operations should average O(1) time complexity in the best case, with worst-case time complexity for `push` being O(n). # Example Usage ```python stack = OrderedStack() stack.push(4) stack.push(2) stack.push(5) print(stack.pop()) # Outputs: 5 print(stack.peek()) # Outputs: 4 print(stack.size()) # Outputs: 2 print(stack.is_empty()) # Outputs: False stack.push(3) print(stack.pop()) # Outputs: 4 ``` # Performance Requirements - Efficient and optimized for large data sets, with special attention to maintaining order during `push`. # Note Ensure that your implementation handles edge cases such as pushing duplicate elements, and operating on an empty stack.","solution":"class OrderedStack: def __init__(self): self.stack = [] def is_empty(self): return len(self.stack) == 0 def push(self, item): index = len(self.stack) for i in range(len(self.stack)): if self.stack[i] < item: index = i break self.stack.insert(index, item) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.stack.pop(0) def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[0] def size(self): return len(self.stack)"},{"question":"# Question: Find the nth Digit in a Sequence of Concatenated Positive Integers Write a function `find_nth_digit(n)` that finds the nth digit in a sequence created by concatenating all positive integers sequentially (i.e., \\"123456789101112...\\"). The function should efficiently determine the nth digit without generating the sequence explicitly. Function Signature: ```python def find_nth_digit(n: int) -> int: pass ``` Input Format: - An integer `n` representing the position in the sequence of concatenated numbers. Output Format: - An integer representing the nth digit in the concatenated sequence. Constraints: - (1 leq n leq 2^{31} - 1): The function must handle very large values efficiently. Example: ```python find_nth_digit(3) # Returns 3 find_nth_digit(11) # Returns 0 find_nth_digit(15) # Returns 2 ``` Notes: - Consider edge cases where `n` is within single or small digit ranges efficiently. - Ensure calculations handle large `n` values without significant performance degradation. - Take care in arithmetic operations and string indexing to avoid off-by-one errors.","solution":"def find_nth_digit(n: int) -> int: length = 1 count = 9 start = 1 # Finding the length of the number where the nth digit is located while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Finding the actual number start += (n - 1) // length s = str(start) return int(s[(n - 1) % length])"},{"question":"# Scenario You are a consultant upgrading the security system of a future colony on Mars. The Martian houses are arranged in a single line, and each house contains some valuables. Your task is to design a robbing strategy so that you can maximize the amount of valuables you rob without triggering security alerts. The security system ensures that if two adjacent houses are robbed, an alarm will go off. # Coding Question Write a function `mars_house_robber(houses: List[int]) -> int` that determines the maximum amount of valuables you can rob from the houses without triggering any alarms. # Function Signature ```python def mars_house_robber(houses: List[int]) -> int: pass ``` # Input - `houses` (List[int]): A list of non-negative integers representing the amount of valuables in each house. # Output - Returns an integer, the maximum amount of valuables that can be robbed without alerting the police. # Constraints - The length of `houses` will be in the range [0, 1000]. - Each value in `houses` will be in the range [0, 10^4]. # Example Example 1 ```python houses = [2, 3, 2] assert mars_house_robber(houses) == 4 ``` Example 2 ```python houses = [1, 2, 3, 1] assert mars_house_robber(houses) == 4 ``` Example 3 ```python houses = [0] assert mars_house_robber(houses) == 0 ``` Example 4 ```python houses = [2, 7, 9, 3, 1] assert mars_house_robber(houses) == 12 ``` # Performance Requirements Your solution should efficiently handle the input size within the given constraints.","solution":"def mars_house_robber(houses): if not houses: return 0 elif len(houses) == 1: return houses[0] n = len(houses) dp = [0] * n dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, n): dp[i] = max(dp[i - 1], dp[i - 2] + houses[i]) return dp[-1]"},{"question":"You are required to implement a stack capable of storing integers and providing the typical stack operations. Your task is to implement a `LimitedStack` class, which combines both array and linked list stack properties, and is designed to automatically switch from array-based to linked-list-based storage when the array reaches its capacity. # Function Signatures ```python class LimitedStack: def __init__(self, size): Initializes the LimitedStack with a fixed size for the underlying array storage. pass def push(self, value): Pushes an integer value onto the stack. :param value: int pass def pop(self): Pops the top value from the stack and returns it. :return: int pass def peek(self): Returns the top value without removing it from the stack. :return: int pass def is_empty(self): Checks if the stack is empty. :return: bool pass def is_array_based(self): Checks if the stack is currently using array-based storage. :return: bool pass ``` # Requirements 1. **Initialization**: Create an instance with a fixed size for the array-based stack. 2. **Push Operation**: Adds a new integer to the stack. When the array reaches its capacity, switch to a linked-list-based storage seamlessly. 3. **Pop Operation**: Removes and returns the top integer from the stack. 4. **Peek Operation**: Returns the top integer without removing it from the stack. 5. **is_empty**: Checks whether the stack is empty. 6. **is_array_based**: Indicates if the stack is currently using array-based storage. # Example Usage ```python stack = LimitedStack(3) stack.push(1) stack.push(2) stack.push(3) print(stack.is_array_based()) # True, still using array stack.push(4) print(stack.is_array_based()) # False, switched to linked-list print(stack.peek()) # 4 print(stack.pop()) # 4 print(stack.pop()) # 3 print(stack.is_array_based()) # False, still using linked-list after overflow ``` # Constraints * Use of global variables or additional libraries outside the standard library is not allowed. * The array should automatically resize only once before switching to a linked-list-based stack.","solution":"class Node: A node in the linked-list stack implementation. def __init__(self, value): self.value = value self.next = None class LimitedStack: def __init__(self, size): Initializes the LimitedStack with a fixed size for the underlying array storage. self.array = [None] * size self.capacity = size self.top_index = -1 self.linked_list = None self.is_using_array = True def push(self, value): Pushes an integer value onto the stack. :param value: int if self.is_using_array: if self.top_index + 1 < self.capacity: self.top_index += 1 self.array[self.top_index] = value else: # overflow, switch to linked-list storage self.is_using_array = False for i in range(self.capacity): self._push_to_linked_list(self.array[i]) self._push_to_linked_list(value) self.array = None else: self._push_to_linked_list(value) def _push_to_linked_list(self, value): new_node = Node(value) new_node.next = self.linked_list self.linked_list = new_node def pop(self): Pops the top value from the stack and returns it. :return: int if self.is_using_array: if self.top_index == -1: raise IndexError(\\"pop from empty stack\\") value = self.array[self.top_index] self.top_index -= 1 return value else: if self.linked_list is None: raise IndexError(\\"pop from empty stack\\") value = self.linked_list.value self.linked_list = self.linked_list.next return value def peek(self): Returns the top value without removing it from the stack. :return: int if self.is_using_array: if self.top_index == -1: raise IndexError(\\"peek from empty stack\\") return self.array[self.top_index] else: if self.linked_list is None: raise IndexError(\\"peek from empty stack\\") return self.linked_list.value def is_empty(self): Checks if the stack is empty. :return: bool if self.is_using_array: return self.top_index == -1 else: return self.linked_list is None def is_array_based(self): Checks if the stack is currently using array-based storage. :return: bool return self.is_using_array"},{"question":"Objective Implement a data structure named `RandomizedCollection` that supports insertion, deletion, and retrieval of a random element, even when duplicates are allowed. All operations should have an average O(1) time complexity. Requirements * **insert(val)**: Inserts item `val` into the collection. Returns `True` if the item was not already present, `False` otherwise. * **remove(val)**: Removes one occurrence of item `val` from the collection. Returns `True` if an item was removed, `False` if the item was not present. * **get_random()**: Returns a random element from the collection. Each element should have an equal probability of being returned. Function Signature ```python class RandomizedCollection: def __init__(self): Initialize the data structure here. def insert(self, val: int) -> bool: Inserts an item `val` into the collection. Returns `True` if the item was not already present, `False` otherwise. def remove(self, val: int) -> bool: Removes one occurrence of item `val` from the collection. Returns `True` if an item was removed, `False` if the item was not present. def get_random(self) -> int: Returns a random element from the collection. Each element must have the same probability of being returned. ``` Example Usage ```python if __name__ == \\"__main__\\": rc = RandomizedCollection() print(rc.insert(1)) # True print(rc.insert(1)) # False print(rc.insert(2)) # True print(rc.remove(1)) # True print(rc.get_random()) # 1 or 2 print(rc.get_random()) # 1 or 2 print(rc.remove(1)) # True print(rc.remove(1)) # False print(rc.get_random()) # 2 ``` Constraints 1. Operations on the data structure are efficient and work in average constant time. 2. You can assume that all `get_random` calls will be valid (i.e., never called on an empty collection).","solution":"import random from collections import defaultdict class RandomizedCollection: def __init__(self): Initialize the data structure here. self.data = [] self.idx_map = defaultdict(set) def insert(self, val: int) -> bool: Inserts an item `val` into the collection. Returns `True` if the item was not already present, `False` otherwise. self.data.append(val) self.idx_map[val].add(len(self.data) - 1) return len(self.idx_map[val]) == 1 def remove(self, val: int) -> bool: Removes one occurrence of item `val` from the collection. Returns `True` if an item was removed, `False` if the item was not present. if not self.idx_map[val]: return False remove_idx = self.idx_map[val].pop() # Get an index of the value to remove last_val = self.data[-1] self.data[remove_idx] = last_val # Overwrite the index with the last value if self.idx_map[last_val]: # Adjust the index set for the last value self.idx_map[last_val].add(remove_idx) self.idx_map[last_val].discard(len(self.data) - 1) self.data.pop() # Remove the last value from the array # Clean up the idx map if empty if not self.idx_map[val]: del self.idx_map[val] return True def get_random(self) -> int: Returns a random element from the collection. Each element must have the same probability of being returned. return random.choice(self.data)"},{"question":"**Question**: You are a software engineer at a tech company, and your team is handling large datasets. Your current task involves finding the position of a specific target value in various arrays. However, some of your arrays are very large, and you understand that using a basic linear search might not be optimal for all cases. **Task Description**: Write a function `optimized_linear_search` which takes two arguments: 1. `array` (a list of integers) 2. `query` (an integer to search for) Your function should return the index of the `query` if it exists in the `array`. If the `query` is not found, return -1. Additionally, to optimize the search in large datasets, if the array is sorted, make use of binary search to reduce the time complexity to O(log n). Your function should first check whether the `array` is sorted and choose the appropriate algorithm (linear search for unsorted and binary search for sorted arrays). **Function Signature**: ```python def optimized_linear_search(array: List[int], query: int) -> int: pass ``` **Input/Output Formats**: * **Input**: * `array` is a list of integers `[a1, a2, ..., an]` * `query` is an integer * **Output**: * Return an integer representing the index of `query` in `array`. Return -1 if not found. **Constraints**: * `1 <= len(array) <= 10^6` * `-10^9 <= array[i], query <= 10^9` **Performance Requirements**: Your solution must be efficient and run within acceptable time limits for the constraints provided. **Example**: ```python print(optimized_linear_search([1, 2, 3, 4, 5], 3)) # Should return 2 print(optimized_linear_search([5, 3, 2, 1, 4], 1)) # Should return 3 print(optimized_linear_search([], 1)) # Should return -1 ```","solution":"from typing import List def optimized_linear_search(array: List[int], query: int) -> int: def is_sorted(arr): Check if the array is sorted in ascending order. return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) def binary_search(arr, q): Binary search implementation. low, high = 0, len(arr) - 1 while low <= high: mid = (low + high) // 2 if arr[mid] == q: return mid elif arr[mid] < q: low = mid + 1 else: high = mid - 1 return -1 if is_sorted(array): return binary_search(array, query) else: for index, value in enumerate(array): if value == query: return index return -1"},{"question":"Context You are part of a team working on a data verification module for a software system. The module needs to ensure that different parts of the data are stored in a sorted manner to optimize searching and reporting operations. As part of this module, you are tasked to implement a function that checks if a given singly linked list is sorted in non-decreasing order. Task Write a function `is_sorted`, which checks if a singly linked list is sorted. Additionally, implement a function to create a linked list from an array for testing purposes. Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head: ListNode) -> bool: # Your code here def create_linked_list(arr: List[int]) -> ListNode: # Helper function to create linked list from array # Your code here ``` Input * `head`: The head node of the singly linked list. The linked list node is defined as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` * `arr`: An array of integers to create the linked list (used in `create_linked_list` function). Output * The function `is_sorted` should return a boolean: * `True` if the linked list is sorted in non-decreasing order. * `False` otherwise. Constraints * The length of the linked list will be in the range [0, 10^4]. * Each value in the linked list will be an integer in the range [-10^5, 10^5]. Requirements * The main focus is on the implementation of `is_sorted` function. * Ensure that empty lists and single-node lists are correctly handled and considered sorted. Examples *Example 1:* Input: ```python arr = [1, 2, 3, 4] head = create_linked_list(arr) print(is_sorted(head)) # Output: True ``` *Example 2:* Input: ```python arr = [1, 2, -1, 3] head = create_linked_list(arr) print(is_sorted(head)) # Output: False ``` *Example 3:* Input: ```python arr = [] head = create_linked_list(arr) print(is_sorted(head)) # Output: True ``` *Example 4:* Input: ```python arr = [5] head = create_linked_list(arr) print(is_sorted(head)) # Output: True ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head: ListNode) -> bool: if head is None or head.next is None: return True current = head while current.next is not None: if current.val > current.next.val: return False current = current.next return True def create_linked_list(arr): if not arr: return None head = ListNode(arr[0]) current = head for value in arr[1:]: current.next = ListNode(value) current = current.next return head"},{"question":"# Binary Search Challenge You are a software developer working on a project that needs to quickly find elements in a large sorted array. Given an array of integers sorted in ascending order, and a target integer, your task is to implement two functions that perform binary search: 1. An **iterative** version of binary search. 2. A **recursive** version of binary search. # Function Specifications 1. **Iterative Version**: ```python def binary_search_iterative(array: List[int], target: int) -> int: pass ``` * **Input**: * `array`: a list of integers sorted in ascending order. * `target`: an integer value to search for. * **Output**: * Return the index of `target` if found, else return `-1`. 2. **Recursive Version**: ```python def binary_search_recursive(array: List[int], low: int, high: int, target: int) -> int: pass ``` * **Input**: * `array`: a list of integers sorted in ascending order. * `low`: the starting index of the subarray to search. * `high`: the ending index of the subarray to search. * `target`: an integer value to search for. * **Output**: * Return the index of `target` if found, else return `-1`. # Constraints * The array length will not exceed `10^7`. * The elements in the array and the target will fit in a 32-bit signed integer. * You must not use any built-in search functions or methods. # Example ```python arr = [1, 2, 4, 6, 9, 12, 15] target = 6 print(binary_search_iterative(arr, target)) # Output: 3 print(binary_search_recursive(arr, 0, len(arr) - 1, target)) # Output: 3 target = 5 print(binary_search_iterative(arr, target)) # Output: -1 print(binary_search_recursive(arr, 0, len(arr) - 1, target)) # Output: -1 ``` # Guidelines * Make sure to handle all edge cases such as empty arrays and target values not present in the array. * Consider the efficiency of your solution in terms of time and space complexity. * Pay attention to scenarios that might cause incorrect results, like integer overflow when computing the mid-point.","solution":"from typing import List def binary_search_iterative(array: List[int], target: int) -> int: Performs iterative binary search to find the target in the sorted array. Args: - array: List[int] - Sorted list of integers. - target: int - Integer value to search for. Returns: - int - Index of the target if found, else -1. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: low = mid + 1 else: high = mid - 1 return -1 def binary_search_recursive(array: List[int], low: int, high: int, target: int) -> int: Performs recursive binary search to find the target in the sorted array. Args: - array: List[int] - Sorted list of integers. - low: int - Starting index of the subarray to search. - high: int - Ending index of the subarray to search. - target: int - Integer value to search for. Returns: - int - Index of the target if found, else -1. if low > high: return -1 mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: return binary_search_recursive(array, mid + 1, high, target) else: return binary_search_recursive(array, low, mid - 1, target)"},{"question":"# Factorial Calculation with Optimized Memory Use Scenario You have been hired by a company that handles large-scale combinatorial computations. Given the potential for large integer results, they need an efficient way to compute factorials with an optional modulus, while minimizing memory usage. Task Write a function `optimized_factorial` that computes the factorial of a given non-negative integer `n` iteratively. The function should handle an optional modulus `mod` parameter to prevent overflow in large computations. Optimize the function to use minimal auxiliary space. # Implementation Details - **Function Signature**: `def optimized_factorial(n: int, mod: int = None) -> int` - **Input**: - `n`: A non-negative integer (0 ≤ n ≤ 10^6). - `mod`: An optional positive integer modulus (1 ≤ mod ≤ 10^9) or `None`. - **Output**: - An integer representing n! % mod (if mod is provided), or n! if mod is not provided. - **Constraints**: - The function should raise a `ValueError` if `n` is not a non-negative integer or if `mod` is provided but not a positive integer. # Example ```python # Input n = 5 mod = 3 # Output 2 ``` Explanation: 5! = 120, and 120 % 3 = 0. # Notes - Ensure your implementation handles large values of `n` efficiently. - Avoid recursion to optimize memory usage. - Validate inputs and raise appropriate exceptions for invalid cases.","solution":"def optimized_factorial(n: int, mod: int = None) -> int: Computes the factorial of a given non-negative integer n iteratively, with an optional modulus to prevent overflow in large computations. if not isinstance(n, int) or n < 0: raise ValueError(\\"n must be a non-negative integer\\") if mod is not None: if not isinstance(mod, int) or mod <= 0: raise ValueError(\\"mod must be a positive integer\\") result = 1 for i in range(2, n + 1): result *= i if mod: result %= mod return result"},{"question":"# Question: Cumulative Sum Range Query and Update You are given an array of integers. Your task is to implement a data structure that supports the following operations: 1. Querying the sum of elements within a range. 2. Updating the value of a specific element. **Requirements**: 1. Implement the Fenwick Tree (Binary Indexed Tree) data structure. 2. Provide the following methods: * `query_sum(left: int, right: int) -> int`: Returns the sum of elements from index `left` to `right` (inclusive). * `update(index: int, value: int): void`: Updates the element at index `index` to `value`. **Input Format**: * Initialization will be provided with an array of integers. * For `query_sum` method: * `left` and `right` will be non-negative integers representing the range within which the sum is to be calculated. * For `update` method: * `index` will be a non-negative integer representing the position to be updated. * `value` will be the new integer value to be placed at `index`. **Constraints**: * `1 <= size of array <= 10^5` * `0 <= array elements, left, right, index <= 10^9` **Example**: ```python # Example Array array = [1, 7, 3, 0, 7, 8, 3, 2, 6, 2] # Fenwick Tree Initialization fenwick_tree = FenwickTree(array) # Query Sum print(fenwick_tree.query_sum(1, 5)) # Output: 25 (7+3+0+7+8) print(fenwick_tree.query_sum(0, 9)) # Output: 39 (sum of the whole array) # Update Value fenwick_tree.update(3, 10) print(fenwick_tree.query_sum(1, 5)) # Output: 35 (7+3+10+7+8) ```","solution":"class FenwickTree: def __init__(self, array): self.n = len(array) self.tree = [0] * (self.n + 1) self.array = array[:] for idx, value in enumerate(array): self._update_internal(idx + 1, value) def _update_internal(self, idx, delta): while idx <= self.n: self.tree[idx] += delta idx += idx & -idx def update(self, index, value): delta = value - self.array[index] self.array[index] = value self._update_internal(index + 1, delta) def _prefix_sum(self, idx): result = 0 while idx > 0: result += self.tree[idx] idx -= idx & -idx return result def query_sum(self, left, right): return self._prefix_sum(right + 1) - self._prefix_sum(left)"},{"question":"# Problem: Finding Unique Paths in a Matrix Given a matrix of size `m x n`, write a function `count_unique_paths(m, n)` that returns the number of unique paths from the top-left corner of the matrix to the bottom-right corner. You are allowed to move either right or down from a cell in the matrix. Function Signature ```python def count_unique_paths(m: int, n: int) -> int: pass ``` # Input * Two positive integers `m` and `n` (1 <= m, n <= 1000) representing the number of rows and columns in the grid, respectively. # Output * An integer representing the number of unique paths from the top-left corner to the bottom-right corner. # Constraints * The input integers m and n will always be positive and within the range `[1, 1000]`. # Requirements * **Time Complexity**: O(m * n) * **Space Complexity**: O(m * n) or O(n) (if optimized) # Example Example 1 Input: ```plaintext m = 3, n = 3 ``` Output: ```plaintext 6 ``` Explanation: There are 6 unique paths from the top-left to the bottom-right corner in a 3x3 grid. Example 2 Input: ```plaintext m = 1, n = 5 ``` Output: ```plaintext 1 ``` Explanation: There is only one unique path from the top-left to the bottom-right corner in a 1x5 grid. # Notes * Make sure to handle edge cases where `m` or `n` is 1. * Optimize space usage if possible. * Validate input for negative or zero dimensions and handle such cases appropriately by returning `-1` for invalid inputs. # Hints * Use a dynamic programming approach to build a solution iteratively. * Consider optimizing the space complexity by reducing the dimensions of the auxiliary storage if needed.","solution":"def count_unique_paths(m: int, n: int) -> int: Returns the number of unique paths from the top-left to the bottom-right corner of a m x n grid. if m <= 0 or n <= 0: return -1 # Initialize a 2D list with 1s for the first row and first column dp = [[1] * n for _ in range(m)] # Fill the rest of the 2D list for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right cell holds the number of unique paths return dp[m-1][n-1]"},{"question":"# Task Create a function that converts a given Binary Search Tree (BST) into a doubly linked list in place. The nodes should appear in the doubly linked list in the same order as an in-order traversal of the BST. # Function Signature ```python def bst_to_doubly_list(root: TreeNode) -> TreeNode: ``` # Input Format * A variable `root` which is the root of a Binary Search Tree where each node contains an integer value `val`, a left child, and a right child. # Output Format * Return the head of the doubly linked list. # Constraints * The tree can have up to 10^5 nodes. * The tree may contain duplicate values. * The values in the tree are between -10^5 and 10^5. # Performance Requirements * The algorithm should run in O(n) time complexity, with n being the number of nodes in the tree. * Use O(h) space complexity with h being the height of the tree. # Example ```python # Example usage: # Definition for a binary tree node class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None self.prev = None # For doubly linked list self.next = None # For doubly linked list # Using sample input root = TreeNode(10) root.left = TreeNode(6) root.right = TreeNode(14) root.left.left = TreeNode(4) root.left.right = TreeNode(8) root.right.left = TreeNode(12) root.right.right = TreeNode(16) # Calling the function doubly_list_head = bst_to_doubly_list(root) # Verifying the resultant doubly linked list current = doubly_list_head while current: print(current.val, end=\' \') current = current.next # Output: 4 6 8 10 12 14 16 ``` **Notes**: * Ensure that you carefully manage the left and right pointers to transform the tree into a doubly linked list correctly. * Consider edge cases such as an empty tree and a tree with only one node.","solution":"# Definition for a binary tree node class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None self.prev = None # For doubly linked list self.next = None # For doubly linked list def bst_to_doubly_list(root: TreeNode) -> TreeNode: if not root: return None def inorder_traverse(node): nonlocal head, prev if not node: return # Traverse left subtree inorder_traverse(node.left) # Convert node if prev: # Link the previous node to the current node prev.next = node node.prev = prev else: # This node is the smallest and thus head of the doubly linked list head = node # Move prev to the current node prev = node # Traverse right subtree inorder_traverse(node.right) head, prev = None, None inorder_traverse(root) return head"},{"question":"You are required to implement an optimized version of a Fibonacci sequence calculator. Your implementation must handle inputs efficiently and must not exceed memory constraints for large values of `n`. # Function Definition ```python def fibonacci_optimized(n: int) -> int: Compute the n-th Fibonacci number in an optimized manner. Parameters: n (int): The index (0-based) of the Fibonacci number to compute. Must be non-negative. Returns: int: The n-th Fibonacci number. ``` # Input - A single integer `n` (0 ≤ n ≤ 10^7). # Output - A single integer representing the n-th Fibonacci number. # Constraints 1. The function should handle large values of `n` within a reasonable time frame. 2. Consider memory optimizations for large values of the sequence. 3. Ensure the implementation avoids performance bottlenecks. # Example ```python assert fibonacci_optimized(10) == 55 assert fibonacci_optimized(0) == 0 assert fibonacci_optimized(1) == 1 assert fibonacci_optimized(50) == 12586269025 ``` # Requirements - The function must return the computed Fibonacci number efficiently. - Submissions must not use any library or built-in functions for Fibonacci calculations. - Adhere strictly to the time and space complexity guidelines discussed.","solution":"def fibonacci_optimized(n: int) -> int: Compute the n-th Fibonacci number in an optimized manner. Parameters: n (int): The index (0-based) of the Fibonacci number to compute. Must be non-negative. Returns: int: The n-th Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Coding Task: Implement a Segment Tree with Lazy Propagation for Range Sum Queries Objective: In this task, you need to implement a Segment Tree with a capability to handle range sum queries and range updates efficiently. Problem Description: You are given an array of integers. Your task is to implement a segment tree to: 1. Construct the tree from given array. 2. Perform range sum queries. 3. Perform range updates (adding a value to all elements in a specified range). Constraints: * Array length (N): 1 <= N <= 100,000 * Elements of the array: -10^6 <= arr[i] <= 10^6 * Number of queries (Q): 1 <= Q <= 100,000 * Types of queries: - \\"sum L R\\": Query the sum of the segment from index L to R. - \\"update L R V\\": Update the segment from index L to R by adding value V. Input: * First line contains an integer N. * Second line contains N integers representing the array. * Third line contains an integer Q, followed by Q lines each containing a query. Output: For each \\"sum\\" query, output the sum of the values within the specified range. Function Signature: ```python class SegmentTree: def __init__(self, arr): pass def update_range(self, start, end, value): pass def query_sum(self, start, end): pass ``` Example: Input: ``` 5 1 3 5 7 9 3 sum 1 3 update 1 3 3 sum 1 3 ``` Output: ``` 15 24 ``` Detailed Explanation: 1. **Initialization**: ```python # The __init__ method should build the segment tree with the given array. tree = SegmentTree([1, 3, 5, 7, 9]) ``` 2. **Query**: ```python # Using \'sum\' method to get the sum of elements from index 1 to 3. result = tree.query_sum(1, 3) assert result == 15 # [3 + 5 + 7] ``` 3. **Update**: ```python # Using \'update_range\' method to add 3 to all elements from index 1 to 3. tree.update_range(1, 3, 3) result = tree.query_sum(1, 3) assert result == 24 # [(3+3) + (5+3) + (7+3)] ``` Note: - Consider using lazy propagation technique to handle range updates efficiently by deferring updates to child nodes.","solution":"class SegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (4 * self.n) self.lazy = [0] * (4 * self.n) self.build(arr, 0, 0, self.n - 1) def build(self, arr, node, start, end): if start == end: self.tree[node] = arr[start] else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 self.build(arr, left_child, start, mid) self.build(arr, right_child, mid + 1, end) self.tree[node] = self.tree[left_child] + self.tree[right_child] def update_range(self, l, r, val): self._update_range(0, 0, self.n - 1, l, r, val) def _update_range(self, node, start, end, l, r, val): if self.lazy[node] != 0: self.tree[node] += (end - start + 1) * self.lazy[node] if start != end: self.lazy[2 * node + 1] += self.lazy[node] self.lazy[2 * node + 2] += self.lazy[node] self.lazy[node] = 0 if start > end or start > r or end < l: return if start >= l and end <= r: self.tree[node] += (end - start + 1) * val if start != end: self.lazy[2 * node + 1] += val self.lazy[2 * node + 2] += val return mid = (start + end) // 2 self._update_range(2 * node + 1, start, mid, l, r, val) self._update_range(2 * node + 2, mid + 1, end, l, r, val) self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2] def query_sum(self, l, r): return self._query_sum(0, 0, self.n - 1, l, r) def _query_sum(self, node, start, end, l, r): if start > end or start > r or end < l: return 0 if self.lazy[node] != 0: self.tree[node] += (end - start + 1) * self.lazy[node] if start != end: self.lazy[2 * node + 1] += self.lazy[node] self.lazy[2 * node + 2] += self.lazy[node] self.lazy[node] = 0 if start >= l and end <= r: return self.tree[node] mid = (start + end) // 2 left_sum = self._query_sum(2 * node + 1, start, mid, l, r) right_sum = self._query_sum(2 * node + 2, mid + 1, end, l, r) return left_sum + right_sum"},{"question":"**Scenario**: You are tasked with designing a tool that helps an organization optimize their resource utilization. The organization has a set of resources, each with a certain value and weight. They have a container that has a capacity limit, and they want to maximize the total value of the resources they can put into the container without exceeding the capacity. # Problem Statement: **Implement a function `maximize_knapsack_value(items, capacity)` that returns the maximum summarized value of items that can fit in the knapsack.** **Input**: * `items`: A list of tuples where each tuple (value, weight) represents the value and weight of an item. * `capacity`: An integer representing the capacity of the knapsack. **Output**: * An integer representing the maximum value that can be obtained within the given capacity. **Constraints**: * Each item\'s value and weight are positive integers. * The capacity is a non-negative integer. * The list of items is non-empty. # Example: ```python capacity = 5 items = [(60, 5), (50, 3), (70, 4), (30, 2)] print(maximize_knapsack_value(items, capacity)) # Output: 80 (items valued 50 and 30 can both be fit in the knapsack) ``` # Requirements: * The solution should be efficient, ideally with time complexity O(n * m) and space complexity O(m) where `n` is the number of items and `m` is the capacity of the knapsack. * Consider edge cases such as when capacity is zero or when item weights are larger than the knapsack\'s capacity. **Focusing on the correct implementation and comprehension of dynamic programming principles is crucial for solving this problem effectively.**","solution":"def maximize_knapsack_value(items, capacity): Returns the maximum summarized value of items that can fit in the knapsack without exceeding the given capacity. Args: items (list of tuple): A list of tuples where each tuple (value, weight) represents the value and weight of an item. capacity (int): An integer representing the capacity of the knapsack. Returns: int: The maximum value that can be obtained within the given capacity. n = len(items) dp = [0] * (capacity + 1) for value, weight in items: for w in range(capacity, weight - 1, -1): dp[w] = max(dp[w], dp[w - weight] + value) return dp[capacity]"},{"question":"# Decoding Nested Patterns You are provided with an encoded string where patterns follow the format `k[encoded_string]`, denoting that the `encoded_string` inside the square brackets should be repeated exactly `k` times. Your task is to decode this string into a normal string. # Problem Statement Write a function `decode_string` that decodes an encoded string as described above. Input: * A single string `s` containing the encoded string format without any white spaces, and properly formed brackets. Output: * A single string representing the decoded version of the input string. # Constraints: * The string `s` will contain only lower case English letters, digits, and square brackets `[ ]`. * The repetition number `k` is guaranteed to be a positive integer. * You may assume that the input string is always valid, i.e., no extra white spaces, square brackets are well-formed, etc. * Digits are only for those repeat numbers, and there won\'t be any digits in the `encoded_string`. # Example: ```python assert decode_string(\\"3[a]2[bc]\\") == \\"aaabcbc\\" assert decode_string(\\"3[a2[c]]\\") == \\"accaccacc\\" assert decode_string(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\" assert decode_string(\\"2[a3[b2[c]]]\\") == \\"abccbccbccabccbccbcc\\" ``` # Steps: 1. Define the function `decode_string(s: str) -> str`. 2. Use a stack to manage regular characters and repetition counts. 3. Traverse the string `s`, and use conditions to handle digits, `[`, `]`, and regular characters appropriately to construct the decoded string. 4. Return the final decoded string after the complete traversal. # Performance Requirements: Ensure that the implementation provides efficient handling for typical use cases including nested structures, while managing memory usage effectively.","solution":"def decode_string(s): Decodes an encoded string where patterns follow the format `k[encoded_string]`, denoting that the `encoded_string` inside the square brackets should be repeated exactly `k` times. Parameters: s (str): The encoded string to decode. Returns: str: The decoded version of the input string. stack = [] current_num = 0 current_str = \\"\\" for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_str, current_num)) current_str = \\"\\" current_num = 0 elif char == \']\': prev_str, num = stack.pop() current_str = prev_str + num * current_str else: current_str += char return current_str"},{"question":"You are tasked with writing a function that implements the Shell Sort algorithm with a specific type of gap sequence for sorting a list of integers. Shell Sort is known to be a generalization of insertion sort, and in this problem, you will use the gap sequence suggested by Donald Shell in his original paper, which is `[n/2, n/4, ..., 1]` where `n` is the number of elements in the list. Function Signature ```python def custom_shell_sort(arr: List[int]) -> List[int]: pass ``` Input * A list of integers `arr` with `1 <= len(arr) <= 10^4`. Output * A list of integers representing the sorted order of input list `arr`. Constraints * You should use the [n/2, n/4, ..., 1] gap sequence as suggested by Donald Shell. * Try to minimize the overall time complexity and ensure your implementation is efficient. Example ```python custom_shell_sort([12, 34, 54, 2, 3]) # Output: [2, 3, 12, 34, 54] ``` Notes * You are required to implement the Shell Sort algorithm without using any built-in sorting functions. * Ensure your code handles edge cases such as empty lists or lists with a single element gracefully. * Focus on writing clean, efficient, and well-documented code.","solution":"from typing import List def custom_shell_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Shell sort algorithm with the gap sequence [n/2, n/4, ..., 1] as suggested by Donald Shell. Parameters: arr (List[int]): The list of integers to sort. Returns: List[int]: The sorted list of integers. n = len(arr) gap = n // 2 # Start with gap and reduce the gap while gap > 0: print(f\\"Gap: {gap}\\") for i in range(gap, n): # Perform gapped insertion sort temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp print(f\\"Array after gap {gap}: {arr}\\") gap //= 2 # Reduce the gap return arr"},{"question":"# Problem Description **Context**: You are working on a project that involves navigating the structure of a directory stored as a binary tree. Each node in the binary tree represents a folder, where each folder may contain sub-folders (represented as left and right children). You need to generate and print all possible directory paths from the root folder to every leaf folder. **Task**: Write a function `binary_tree_paths(root)` that takes the root node of a binary tree and returns a list of all root-to-leaf paths in the tree. Each path should be represented as a string of node values separated by \'->\'. # Function Signature ```python def binary_tree_paths(root): # Your code here pass ``` # Inputs * `root`: The root node of the binary tree. Each node has the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Outputs * A list of strings, where each string represents a root-to-leaf path with node values separated by \'->\'. # Constraints * The number of nodes in the tree is in the range [0, 1000]. * `-1000 <= Node.val <= 1000` # Example 1. **Input**: ```python root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(5) result = binary_tree_paths(root) print(result) ``` **Output**: ```python [\\"1->2->5\\", \\"1->3\\"] ``` # Requirements * Use DFS to traverse the tree. * Ensure the function handles edge cases, including an empty tree and trees with only one node. * Develop an efficient solution to avoid performance bottlenecks in large trees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): Given a root of a binary tree, return all root-to-leaf paths as a list of strings. Each path is represented as a string of node values separated by \'->\'. def dfs(node, path, paths): if node: # Append current node to the path path += str(node.val) # If it\'s a leaf, append the path to paths if not node.left and not node.right: paths.append(path) else: # Continue DFS on left and right subtrees path += \\"->\\" dfs(node.left, path, paths) dfs(node.right, path, paths) paths = [] dfs(root, \\"\\", paths) return paths"},{"question":"You\'re tasked with implementing the Crout Matrix Decomposition algorithm for a given square matrix (A). Your implementation should decompose (A) into two matrices (L) (lower triangular) and (U) (upper triangular) such that (A = LU). This exercise tests your understanding of LU decomposition and ability to handle edge cases. # Function Signature ```python def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: ``` # Input * **A**: A 2D list (square matrix) (n times n) where each element is a float. # Output * Return two 2D lists (L) and (U): * (L) should be a lower triangular matrix with non-zero elements only on and below the diagonal. * (U) should have 1s on the diagonal and non-zero elements above the diagonal. # Constraints 1. **Size of A**: (1 leq n leq 100) 2. **Matrix (A)**: Must be a symmetric positive-definite matrix. # Example ```python input_matrix = [ [1.0, 2.0, 3.0], [3.0, 4.0, 5.0], [6.0, 7.0, 8.0] ] L, U = crout_matrix_decomposition(input_matrix) # Expected Output L = [[1.0, 0.0, 0.0], [3.0, -2.0, 0.0], [6.0, -5.0, 0.0]] U = [[1.0, 2.0, 3.0], [0.0, 1.0, 2.0], [0.0, 0.0, 1.0]] ``` # Notes: * Ensure to handle potential edge cases such as zero or very small values on the diagonal. * Your code should aim for efficiency given the constraints.","solution":"from typing import List, Tuple def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: n = len(A) L = [[0.0] * n for _ in range(n)] U = [[0.0] * n for _ in range(n)] for i in range(n): U[i][i] = 1.0 # Setting the diagonal of U to 1 for j in range(n): for i in range(j, n): sum1 = sum(L[i][k] * U[k][j] for k in range(j)) L[i][j] = A[i][j] - sum1 for i in range(j+1, n): sum2 = sum(L[j][k] * U[k][i] for k in range(j)) U[j][i] = (A[j][i] - sum2) / L[j][j] return L, U"},{"question":"Design a class `EnhancedWordDictionary` that supports both addition of words and search functionality which may include wildcard characters (\'.\'). This class should combine the advantages of both the Trie-based and Dictionary-based approaches provided in the snippets above. # Function Definitions ```python class EnhancedWordDictionary: def __init__(self): # Initialize your data structure here. pass def add_word(self, word: str) -> None: # Adds a word into the data structure. pass def search(self, word: str) -> bool: # Returns if the word is in the data structure. A word could contain the \'. # character to represent any one letter. pass ``` # Requirements 1. `__init__`: Initialize the dictionary data structure. 2. `add_word(word: str)`: Add a word into the data structure. 3. `search(word: str)`: Implement the functionality to search for a word, potentially containing the \'.\' character that can represent any letter. # Constraints - Each input word consists of lowercase alphabets. - All inputs are valid according to the described requirements. # Performance Considerations - Aim for O(n) time for `add_word` where n is the length of the word. - Optimize `search` to handle wildcards efficiently. # Example ```python dic = EnhancedWordDictionary() dic.add_word(\\"bad\\") dic.add_word(\\"dad\\") dic.add_word(\\"mad\\") assert dic.search(\\"pad\\") is False assert dic.search(\\"bad\\") is True assert dic.search(\\".ad\\") is True assert dic.search(\\"b..\\") is True ``` Implement the methods to meet these performance and functional requirements.","solution":"class EnhancedWordDictionary: def __init__(self): self.trie = {} def add_word(self, word: str) -> None: node = self.trie for char in word: if char not in node: node[char] = {} node = node[char] node[\'#\'] = True # end of word marker def search(self, word: str) -> bool: def search_in_node(word, node): for i, char in enumerate(word): if char == \'.\': for x in node: if x != \'#\' and search_in_node(word[i+1:], node[x]): return True return False else: if char not in node: return False node = node[char] return \'#\' in node return search_in_node(word, self.trie)"},{"question":"Scenario: You are working on a software module that works with stack data structures. One of the requirements is to validate whether the elements in a stack are sorted in ascending order from bottom to top. You need to implement a function that checks if a given stack satisfies this sorted property. Function Specification: Implement the function `is_sorted(stack)` that takes a single parameter: * `stack` (list[int]): A stack represented as a list with elements in the stack. The end of the list is the top of the stack. The function should return: * A boolean value `True` if the stack elements are sorted in ascending order from bottom to top, otherwise `False`. The original stack should remain unchanged after this function is called. Constraints: * The stack can have zero or more elements. * Stack elements are integers which can be positive, negative, or zero. Example: * **Input**: * `stack`: [1, 2, 3, 4, 5, 6] * **Output**: * `True` * **Input**: * `stack`: [6, 3, 5, 1, 2, 4] * **Output**: * `False` Performance Requirements: * The function should have a time complexity of O(n) and space complexity of O(n), where n is the number of elements in the stack. Notes: * Ensure that the input stack remains unchanged after function execution. * Think about edge cases including empty stacks, stacks with one element, and already sorted or reverse-ordered stacks. Implement the function `is_sorted(stack)` as described.","solution":"def is_sorted(stack): Checks if the elements in the stack are sorted in ascending order from bottom to top. Args: stack (list[int]): A stack represented as a list with elements in the stack. Returns: bool: True if the stack elements are sorted in ascending order from bottom to top, otherwise False. return stack == sorted(stack)"},{"question":"Write a function called `optimized_bubble_sort` that takes an unsorted list of integers and returns the list sorted in ascending order. Additionally, your function should: 1. Handle input edge cases such as empty lists or lists with a single element. 2. Optimize the bubble sort by reducing the number of comparisons after each pass. 3. Provide an option to simulate the sorting process step-by-step. # Function Signature ```python def optimized_bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` # Input - `arr` (List[int]): A list of integers that needs to be sorted. - `simulation` (bool): A boolean flag, which if set to True, prints the array at each step of the sorting process. # Output - Returns a list of integers in ascending order. # Constraints 1. The length of the list `arr` will be between 0 and 10^3. 2. The elements of `arr` will be integers in the range -10^6 to 10^6. # Example Example 1 ```python arr = [64, 34, 25, 12, 22, 11, 90] print(optimized_bubble_sort(arr, True)) ``` **Output (in simulation mode)**: ``` iteration 0 : 64 34 25 12 22 11 90 iteration 1 : 34 64 25 12 22 11 90 iteration 2 : 34 25 64 12 22 11 90 iteration 3 : 34 25 12 64 22 11 90 iteration 4 : 34 25 12 22 64 11 90 iteration 5 : 34 25 12 22 11 64 90 iteration 6 : 34 25 12 22 11 64 90 iteration 7 : 25 34 12 22 11 64 90 ... iteration X : 11 12 22 25 34 64 90 [11, 12, 22, 25, 34, 64, 90] ``` Example 2 ```python arr = [1, 20, 30, 21, 50] print(optimized_bubble_sort(arr)) ``` **Output**: ```python [1, 20, 21, 30, 50] ```","solution":"from typing import List def optimized_bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: n = len(arr) for i in range(n): swapped = False if simulation: print(f\\"Start of iteration {i}: {\' \'.join(map(str, arr))}\\") for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] # Swap swapped = True if simulation: print(f\\"End of iteration {i}: {\' \'.join(map(str, arr))}\\") # If no elements were swapped during the traversal, the array is already sorted if not swapped: break return arr"},{"question":"Range Minimum Query Using Segment Tree You are required to implement a segment tree to support efficient range minimum queries on an array of integers. Your implementation should allow querying the minimum value in a given subarray range [L, R]. # Function Signature ```python class SegmentTree: def __init__(self, arr: List[int]): pass def query(self, L: int, R: int) -> int: pass ``` # Input * `arr`: A list of integers (1 ≤ len(arr) ≤ 10^5, -10^9 ≤ arr[i] ≤ 10^9) * `L`: An integer representing the starting index of the range (0 ≤ L < len(arr)) * `R`: An integer representing the ending index of the range (L ≤ R < len(arr)) # Output * Return the minimum value in the subarray `arr[L:R+1]`. # Constraints * Your solution must handle up to 10^5 range queries efficiently. * Your solution should run in O(N) time complexity for building the segment tree and O(log N) for each query. # Example ```python # Example usage: # Construct the Segment Tree tree = SegmentTree([2, 4, 5, 3, 7, 1, 9]) # Perform range minimum queries print(tree.query(1, 3)) # Output: 3 (minimum in [4, 5, 3]) print(tree.query(0, 5)) # Output: 1 (minimum in [2, 4, 5, 3, 7, 1]) print(tree.query(2, 6)) # Output: 1 (minimum in [5, 3, 7, 1, 9]) ``` # Notes * You need to handle edge cases like querying an empty range or the entire array. * Ensure that the solution properly supports the given constraints related to the size of the input array and query operations.","solution":"class SegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (2 * self.n) # Build the segment tree self.build(arr) def build(self, arr): # Initialize leaves in the segment tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[i * 2], self.tree[i * 2 + 1]) def query(self, L, R): # Make L and R zero-based L += self.n R += self.n res = float(\'inf\') while L <= R: if L % 2 == 1: res = min(res, self.tree[L]) L += 1 if R % 2 == 0: res = min(res, self.tree[R]) R -= 1 L //= 2 R //= 2 return res"},{"question":"# Matrix Transformation Function Implementation Context In image processing, graphics, and various simulations, matrix transformations (such as rotations) are frequently used. Understanding how to efficiently implement these transformations is fundamental. Task Implement the function `rotate_matrix(matrix, direction)` that takes a 2D square matrix (a list of lists) and rotates it 90 degrees in the specified direction. The direction can either be \\"clockwise\\" or \\"counterclockwise\\". Function Signature ```python def rotate_matrix(matrix: list[list[int]], direction: str) -> list[list[int]]: pass ``` Input Format - `matrix`: A list of lists representing a 2D matrix consisting of integers. - `direction`: A string that specifies the direction of rotation (\\"clockwise\\" or \\"counterclockwise\\"). Output Format - A new list of lists representing the rotated matrix. Constraints - The matrix will always be `n x n` (square matrix) with n >= 1. - Direction will always be either \\"clockwise\\" or \\"counterclockwise\\". Performance Requirements - O(n^2) time complexity. - O(n^2) space complexity. Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix, \\"clockwise\\") # Output # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] rotate_matrix(matrix, \\"counterclockwise\\") # Output # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] ``` Additional Notes - Handle any errors gracefully, assuming that inputs will follow the constraints. - Avoid using external libraries; focus on raw Python implementation.","solution":"def rotate_matrix(matrix: list[list[int]], direction: str) -> list[list[int]]: Rotates the given n x n matrix 90 degrees in the specified direction. Parameters: matrix (list[list[int]]): The input square matrix. direction (str): The direction of rotation (\\"clockwise\\" or \\"counterclockwise\\"). Returns: list[list[int]]: The rotated matrix. n = len(matrix) rotated = [[0] * n for _ in range(n)] if direction == \\"clockwise\\": for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] elif direction == \\"counterclockwise\\": for i in range(n): for j in range(n): rotated[n - 1 - j][i] = matrix[i][j] else: raise ValueError(\\"Invalid direction. It should be either \'clockwise\' or \'counterclockwise\'\\") return rotated"},{"question":"XOR-based Character Finder You are given two strings `s` and `t` which consist of only lowercase letters. The string `t` is generated by random shuffling the string `s` and then adding one more letter at a random position. Your task is to find the letter that was added in `t`. Implementation Details: Implement a function: ```python def find_difference(s: str, t: str) -> str: pass ``` Input: * `s`: A string of lowercase letters with a length of `n`. * `t`: A string of lowercase letters with a length of `n+1`. Output: * Return the single character that was added to `t`. Constraints: * Strings `s` and `t` will only contain lowercase letters (a-z). * The length of `s` will be in the range [1, 10^5]. Example: ```python s = \\"abcd\\" t = \\"abcde\\" Output: \'e\' ``` In the given example, \\"e\\" was the letter added to create `t`. Notes: * Ensure that your solution runs efficiently for large inputs. * Handle edge cases where the strings may be very short or contain repeated characters. # Auxiliary Information: To achieve the required solution, you can utilize the properties of the XOR operation, specifically that `XOR`ing identical items will zero them out (`x xor x = 0`) and that the `XOR` operation is commutative and associative, thereby making the order of operations irrelevant. Write your function implementation below: ```python def find_difference(s: str, t: str) -> str: ret = 0 for ch in s + t: ret ^= ord(ch) return chr(ret) ```","solution":"def find_difference(s: str, t: str) -> str: Finds the character that was added to t which is missing in s. ret = 0 for ch in s + t: ret ^= ord(ch) return chr(ret)"},{"question":"**Problem Statement**: Given a non-negative integer, write a function `is_power_of_two_optimized` to determine if it is a power of two. # Input: - An integer `n` (0 <= n <= 2^31 - 1). # Output: - Returns `True` if `n` is a power of two, `False` otherwise. # Constraints: - Your solution should have a time complexity of O(1) and space complexity of O(1). # Performance Requirements: - Your implementation should be efficient and handle large integers up to the maximum possible value of an unsigned 32-bit integer. # Function Signature: ```python def is_power_of_two_optimized(n: int) -> bool: ``` # Example: ```python assert is_power_of_two_optimized(1) == True # 2^0 assert is_power_of_two_optimized(16) == True # 2^4 assert is_power_of_two_optimized(3) == False assert is_power_of_two_optimized(0) == False assert is_power_of_two_optimized(1024) == True # 2^10 assert is_power_of_two_optimized(1025) == False ``` # Explanation: - The function should determine whether the given integer is a power of two by examining its binary representation and utilizing appropriate bitwise operations.","solution":"def is_power_of_two_optimized(n: int) -> bool: Determines if the given integer n is a power of two. :param n: non-negative integer :return: True if n is a power of two, False otherwise if n <= 0: return False return (n & (n - 1)) == 0"},{"question":"# Sorting Experiment with Bubble Sort Given the description and workings of the Bubble Sort algorithm, write a Python function `enhanced_bubble_sort` that enhances the provided bubble sort function with additional features: 1. **Sort in Both Ascending and Descending Order**: Your function should take an additional parameter `order` which can be either \'asc\' for ascending or \'desc\' for descending order sorting. 2. **Improved Efficiency**: Integrate an early termination check to stop the algorithm if the array becomes sorted before completing all iterations. # Function Signature: ```python def enhanced_bubble_sort(arr: List[int], order: str = \'asc\') -> List[int]: ``` # Input: * `arr`: A list of integers to be sorted. (0 leq text{len(arr)} leq 10^4) * `order`: A string, either \'asc\' for ascending order or \'desc\' for descending order. Default is \'asc\'. # Output: * A sorted list of integers according to the specified order. # Constraints: * The elements of `arr` are integers within the range ([-10^6, 10^6]). # Example: ```python assert enhanced_bubble_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90] # Default ascending order assert enhanced_bubble_sort([64, 34, 25, 12, 22, 11, 90], \'desc\') == [90, 64, 34, 25, 22, 12, 11] # Descending order assert enhanced_bubble_sort([]) == [] # Empty array case assert enhanced_bubble_sort([1]) == [1] # Single element case ``` # Detailed Requirements: * Implement both ascending and descending sort functionality using a single swap mechanism. * Optimize the function to detect if the list is already sorted to minimize unnecessary iterations. * Ensure robustness by handling edge cases such as empty arrays and single-element arrays.","solution":"from typing import List def enhanced_bubble_sort(arr: List[int], order: str = \'asc\') -> List[int]: n = len(arr) if n < 2: return arr for i in range(n): swapped = False for j in range(0, n - i - 1): if (order == \'asc\' and arr[j] > arr[j + 1]) or (order == \'desc\' and arr[j] < arr[j + 1]): arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True if not swapped: break return arr"},{"question":"# Question: Implement a Combined Heap Sorter Context: You are tasked with creating a versatile heap sorter that can sort an array using both max-heap and min-heap strategies. This function should be capable of choosing the appropriate heap sort method based on an input parameter. Requirements: Implement a function `combined_heap_sort(arr, heap_type=\'max\', simulation=False)` that takes the following parameters: * **arr**: A list of integers to be sorted. * **heap_type**: A string which can either be `\'max\'` or `\'min\'`. This indicates whether to use max-heap sort or min-heap sort. Default should be `\'max\'`. * **simulation**: A boolean flag that, when set to `True`, prints each step of the sorting process to help visualize the sorting. Input: * A list, `arr`, of integers. * A string, `heap_type`, specifying the type of heap sort to use (`\'max\'` or `\'min\'`). * A boolean, `simulation`. Output: * The sorted list in ascending order. Constraints: * Use in-place sorting. * The function should handle arrays with up to (10^6) elements efficiently. * Ensure that the function is correctly handling edge cases such as empty arrays and arrays with one element. Example Usage: ```python # Example 1 result = combined_heap_sort([4, 10, 3, 5, 1], \'max\') print(result) # Output: [1, 3, 4, 5, 10] # Example 2 result = combined_heap_sort([4, 10, 3, 5, 1], \'min\') print(result) # Output: [1, 3, 4, 5, 10] # Example 3 result = combined_heap_sort([], \'max\') print(result) # Output: [] # Example 4 result = combined_heap_sort([4], \'min\') print(result) # Output: [4] ``` Your task is to implement the `combined_heap_sort` function based on the guidelines provided.","solution":"def combined_heap_sort(arr, heap_type=\'max\', simulation=False): Sorts an array using either min-heap or max-heap strategy. Parameters: arr (list): List of integers to be sorted. heap_type (str): \'max\' for max-heap or \'min\' for min-heap sorting. Default is \'max\'. simulation (bool): If set to True, prints each step of the sorting process. Default is False. Returns: list: Sorted list in ascending order. def heapify(arr, n, i, heap_type): if heap_type == \'max\': largest = i l = 2 * i + 1 r = 2 * i + 2 if l < n and arr[i] < arr[l]: largest = l if r < n and arr[largest] < arr[r]: largest = r if largest != i: arr[i], arr[largest] = arr[largest], arr[i] if simulation: print(arr) heapify(arr, n, largest, heap_type) elif heap_type == \'min\': smallest = i l = 2 * i + 1 r = 2 * i + 2 if l < n and arr[i] > arr[l]: smallest = l if r < n and arr[smallest] > arr[r]: smallest = r if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] if simulation: print(arr) heapify(arr, n, smallest, heap_type) n = len(arr) # Build heap for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i, heap_type) # Extract elements one by one for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] if simulation: print(arr) heapify(arr, i, 0, heap_type) if heap_type == \'min\': arr.reverse() return arr"},{"question":"Optimized Very Large Array Sort **Scenario**: You have been appointed as a software engineer at a logistics company. Your task is to write a function that sorts arrays of shipment weights. Some arrays might be very large or almost sorted. To accommodate this, you will enhance an existing sorting algorithm. **Task**: Write a function `optimized_insertion_sort` that enhances the traditional Insertion Sort algorithm for efficiency on larger datasets and nearly sorted arrays. You must incorporate a binary search mechanism to find insertion points efficiently. **Function Signature**: ```python def optimized_insertion_sort(arr: list) -> list: pass ``` **Input**: * `arr` (List[int]): A list of integers representing shipment weights. **Output**: * List[int]: A sorted list of integers in non-decreasing order. **Constraints**: * Elements in the array are integers. * The implementation should retain the stability characteristic of Insertion Sort. * Must run efficiently for large datasets (hint: leverage binary search). **Performance Requirements**: * Must handle arrays of up to 10^5 elements efficiently. * Should optimize performance better than O(n^2) where possible. **Example**: ```python # Example 1 input_arr = [8, 3, 5, 4, 2, 7] assert optimized_insertion_sort(input_arr) == [2, 3, 4, 5, 7, 8] # Example 2 input_arr = [1, 2, 3, 4, 5] assert optimized_insertion_sort(input_arr) == [1, 2, 3, 4, 5] ``` **Instructions**: Alongside the function, simulate the sorting process by printing each major iteration and its resulting list. This will aid in understanding the sorting progression step-by-step. **Note**: Do not use Python\'s built-in sorting functions. Stick to enhancing the insertion sort as required.","solution":"def binary_search(arr, val, start, end): Perform binary search to find the index at which val should be inserted in the subarray arr[start:end]. Return the appropriate index. while start < end: mid = (start + end) // 2 if arr[mid] < val: start = mid + 1 else: end = mid return start def optimized_insertion_sort(arr): An optimized version of insertion sort that uses binary search to find the correct position to insert the current element. for i in range(1, len(arr)): val = arr[i] insertion_index = binary_search(arr, val, 0, i) # Move elements to the right to make space for the insertion arr = arr[:insertion_index] + [val] + arr[insertion_index:i] + arr[i+1:] print(f\\"Iteration {i}: {arr}\\") return arr # Example Usages: # optimized_insertion_sort([8, 3, 5, 4, 2, 7]) # optimized_insertion_sort([1, 2, 3, 4, 5])"},{"question":"Context You are tasked with developing a feature for a text editor that finds and highlights the longest substring within a given text where no characters are repeated. This will help users identify the largest section of text without any character duplication for better readability. Task Write a function `longest_unique_substring` that takes a string `text` as input and returns a tuple containing the length of the longest substring without repeating characters and the substring itself. Input - `text` (str): A non-empty string which may include any printable characters. Output - (int, str): A tuple where the first element is the length of the longest substring without repeating characters, and the second element is the substring itself. Constraints - The length of the input string will not exceed 10^5 characters. Requirements * Your solution should have a time complexity of O(n) and space complexity of O(min(n, m)), where n is the length of the input string, and m is the size of the character set. * Consider edge cases such as strings with all identical characters or an exceptionally long repeating sequence. Examples 1. `longest_unique_substring(\\"abcabcbb\\")` should return `(3, \\"abc\\")`. 2. `longest_unique_substring(\\"bbbbb\\")` should return `(1, \\"b\\")`. 3. `longest_unique_substring(\\"pwwkew\\")` should return `(3, \\"wke\\")`. You may assume all characters in the string are ASCII. # Function Signature ```python def longest_unique_substring(text: str) -> (int, str): pass ```","solution":"def longest_unique_substring(text: str) -> (int, str): Returns the length of the longest substring without repeating characters and the substring itself. Args: text (str): The input string. Returns: tuple: A tuple where the first element is the length of the longest substring without repeating characters, and the second element is the substring itself. n = len(text) if n == 0: return (0, \\"\\") char_index_map = {} start = 0 max_len = 0 max_substr = \\"\\" for end in range(n): if text[end] in char_index_map: start = max(start, char_index_map[text[end]] + 1) char_index_map[text[end]] = end current_len = end - start + 1 if current_len > max_len: max_len = current_len max_substr = text[start:end + 1] return (max_len, max_substr)"},{"question":"# Pattern Matching Challenge Write a function called `follows_pattern` that checks if a given string follows a specified pattern. Function Signature ```python def follows_pattern(pattern: str, string: str) -> bool: pass ``` Input * `pattern`: A string made up of lowercase letters. * `string`: A string of lowercase words separated by a single space. Output * The function should return `true` if the string follows the same pattern as provided in the input pattern string (meaning there is a one-to-one correspondence between characters in the pattern and words in the string). * It should return `false` otherwise. Constraints * 1 <= len(pattern) <= 100 * 1 <= len(string) <= 1000 * Only lowercase letters in pattern and lowercase words separated by a single space in string. Example: ```python assert follows_pattern(\\"abba\\", \\"dog cat cat dog\\") == True assert follows_pattern(\\"abba\\", \\"dog cat cat fish\\") == False assert follows_pattern(\\"aaaa\\", \\"dog cat cat dog\\") == False assert follows_pattern(\\"abba\\", \\"dog dog dog dog\\") == False ``` Notes You may assume the pattern contains only lowercase letters, and the string contains lowercase words separated by a single space. The bijection between letters in the pattern and words in the string implies that no two characters map to the same word.","solution":"def follows_pattern(pattern: str, string: str) -> bool: Checks if the given string of words follows the specified pattern. words = string.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char not in char_to_word: char_to_word[char] = word if word not in word_to_char: word_to_char[word] = char if char_to_word[char] != word or word_to_char[word] != char: return False return True"},{"question":"You are required to implement a priority queue using a min heap. The priority queue should support the following operations efficiently: 1. **insert(val)**: Inserts an integer value into the heap. 2. **peek_min()**: Returns the minimum element without removing it. If the heap is empty, return None. 3. **extract_min()**: Removes and returns the minimum element. If the heap is empty, return None. # Implementation Details * Design the class `PriorityQueue` with the methods described above. * Do not use Python\'s built-in heapq library, implement the heap from scratch. * Ensure that the heap property (min heap) is maintained after each insertion and deletion. # Expected Input and Output * **insert(val)** - Input: An integer value `val` to be inserted. - Output: None. * **peek_min()** - Input: None. - Output: The minimum value in the heap, or None if the heap is empty. * **extract_min()** - Input: None. - Output: The minimum value in the heap, or None if the heap is empty after removal. # Constraints 1. The heap should be dynamically resizable. 2. The operations `peek_min` and `extract_min` should have a time complexity of O(1) and O(log N) respectively. 3. The operation `insert` should be O(log N). # Example ```python pq = PriorityQueue() assert pq.peek_min() == None pq.insert(10) assert pq.peek_min() == 10 pq.insert(5) assert pq.peek_min() == 5 assert pq.extract_min() == 5 assert pq.peek_min() == 10 assert pq.extract_min() == 10 assert pq.extract_min() == None ``` # Note * Your implementation should be robust against edge cases such as handling an empty heap. # Solution Template ```python class PriorityQueue: def __init__(self): # Your code to initialize the heap def insert(self, val): # Your code to insert an element into the heap def peek_min(self): # Your code to return the minimum element without removing it def extract_min(self): # Your code to remove and return the minimum element ```","solution":"class PriorityQueue: def __init__(self): self.heap = [] def _swap(self, i, j): self.heap[i], self.heap[j] = self.heap[j], self.heap[i] def _heapify_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self._swap(index, parent_index) self._heapify_up(parent_index) def _heapify_down(self, index): smallest = index left = 2 * index + 1 right = 2 * index + 2 if left < len(self.heap) and self.heap[left] < self.heap[smallest]: smallest = left if right < len(self.heap) and self.heap[right] < self.heap[smallest]: smallest = right if smallest != index: self._swap(index, smallest) self._heapify_down(smallest) def insert(self, val): self.heap.append(val) self._heapify_up(len(self.heap) - 1) def peek_min(self): if len(self.heap) == 0: return None return self.heap[0] def extract_min(self): if len(self.heap) == 0: return None if len(self.heap) == 1: return self.heap.pop() root = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return root"},{"question":"Problem Statement You are given a non-negative integer presented as an array of digits. Each element in the array represents a single digit in a big-endian order (most significant digit first). Write a function that takes this array of digits and returns a new array that represents the integer incremented by one. The goal is to simulate incrementing this arbitrary-length number efficiently. # Function Signature ```python def increment_array(digits: List[int]) -> List[int]: pass ``` # Input * `digits` (List[int]): A list of non-negative integers such that each integer is a digit (0-9). The list is big-endian (i.e., the most significant digit is at the first position). # Output * (List[int]): A list of integers representing the incremented number in the same big-endian order. # Constraints * The input list `digits` will have a length between 1 and 1000, inclusive. * The digits in the input list will be in the range 0 to 9. # Example ```python assert increment_array([1, 2, 3]) == [1, 2, 4] assert increment_array([4, 3, 2, 1]) == [4, 3, 2, 2] assert increment_array([0]) == [1] assert increment_array([9, 9, 9]) == [1, 0, 0, 0] ``` # Edge Cases * Input array contains only zeros except the last digit. * Carry propagation results in an increase in the number of digits in the array (e.g., [9, 9, 9] -> [1, 0, 0, 0]). * The input is a single digit (e.g., [0] or [9]). # Performance Requirements Your implementation should handle the worst-case scenario within a linear time complexity (O(n)) and should ideally operate in constant space (O(1)).","solution":"from typing import List def increment_array(digits: List[int]) -> List[int]: Increments a number represented by a list of digits by one. Args: digits (List[int]): A list of integers representing the digits of a number in big-endian order. Returns: List[int]: A list of integers representing the incremented number in big-endian order. n = len(digits) carry = 1 # we start with the increment of 1 # Traverse the digits list from the end to the start for i in range(n - 1, -1, -1): new_digit = digits[i] + carry if new_digit == 10: digits[i] = 0 carry = 1 else: digits[i] = new_digit carry = 0 break if carry == 1: # If carry is still 1 after processing all digits, it means we had only 9s digits.insert(0, 1) return digits"},{"question":"You are given an array of integers. Implement a Fenwick Tree data structure to support the following operations efficiently: 1. **update(index, value)**: Update the element at the given index with the new value. 2. **prefix_sum(index)**: Return the sum of elements from the beginning of the array up to the given index. Your implementation should efficiently handle both operations in O(log n) time. # Function Signature ```python class FenwickTree: def __init__(self, input_list: List[int]): Initialize the Fenwick Tree with the given input_list. pass def update(self, index: int, value: int): Update the array element at the given index to the value. pass def prefix_sum(self, index: int) -> int: Return the sum of elements from the beginning up to the given index. pass ``` # Input Format * The initialization method receives an input_list of integers. * The update method receives an integer index and an integer value. * The prefix_sum method receives an integer index. # Output Format * The update method does not return anything. * The prefix_sum method returns the computed prefix sum as an integer. # Constraints * 1 <= len(input_list) <= 10^5 * -10^6 <= value <= 10^6 * 0 <= index < len(input_list) # Example ```python # Example Init: input_list = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3] fenwick_tree = FenwickTree(input_list) # Example Update: fenwick_tree.update(3, 13) # Update index 3 to value 13 # Example Prefix Sum: print(fenwick_tree.prefix_sum(5)) # Output should be sum of elements from index 0 to 5 # [3, 2, -1, 13, 5, 4, -3, 3, 7, 2, 3] # prefix_sum(5) = 3 + 2 - 1 + 13 + 5 + 4 = 26 ``` Implement the `FenwickTree` class according to the outlined specifications and confirm its correct functionality with the provided and additional test cases.","solution":"class FenwickTree: def __init__(self, input_list): self.n = len(input_list) self.tree = [0] * (self.n + 1) self.input_list = [0] * (self.n) # store the original array for easy updates for i in range(self.n): self.update(i, input_list[i]) def update(self, index, value): # find the difference between new value and old value delta = value - self.input_list[index] # update the original array self.input_list[index] = value index += 1 while index <= self.n: self.tree[index] += delta index += index & -index def prefix_sum(self, index): sum = 0 index += 1 while index > 0: sum += self.tree[index] index -= index & -index return sum"},{"question":"**Problem Statement**: You are provided with a list of integers that need to be sorted in ascending order using the Comb Sort algorithm. Implement the function `adaptive_comb_sort(arr: List[int]) -> List[int]` that sorts the list using an optimized version of the Comb Sort algorithm. # Requirements: 1. Utilize a comb sort mechanism with a standard gap shrink factor of 1.3. 2. Additionally, when the gap size becomes small (e.g., less than 10), switch to a more efficient sorting algorithm to handle the remainder. This will optimize the final part of the sorting process. 3. Ensure that your code handles common edge cases gracefully. 4. Your solution should be implemented in place without using extra space. # Function Signature: ```python from typing import List def adaptive_comb_sort(arr: List[int]) -> List[int]: pass ``` # Input: - A list of integers, `arr`. # Output: - A list of integers sorted in ascending order. # Constraints: - The length of the list can be up to 10^5. - The integers can range from -10^9 to 10^9. # Example: ```python assert adaptive_comb_sort([6, 3, 9, 7, 2, 1, 5]) == [1, 2, 3, 5, 6, 7, 9] assert adaptive_comb_sort([5, 1, 1, 2, 0, 0]) == [0, 0, 1, 1, 2, 5] assert adaptive_comb_sort([]) == [] assert adaptive_comb_sort([2]) == [2] ``` # Notes: - Consider the efficiency of both Comb Sort combined with your chosen secondary sorting algorithm. - Make sure to test your solution with various edge cases and performance scenarios.","solution":"from typing import List def adaptive_comb_sort(arr: List[int]) -> List[int]: def comb_sort(arr): gap = len(arr) shrink = 1.3 sorted = False while not sorted: gap = int(gap / shrink) if gap <= 1: gap = 1 sorted = True i = 0 while i + gap < len(arr): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False i += 1 def insertion_sort(arr): for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key comb_sort(arr) # Switch to insertion sort when comb_sort has gotten down to small gap sizes if len(arr) <= 10: insertion_sort(arr) return arr"},{"question":"# Question: Custom Heap Sort Implementation You are tasked with implementing a custom heap sort algorithm that sorts an array of integers in descending order. This custom heap sort should use a min-heap for its operations. Specifically, you need to write a function `custom_heap_sort(arr: List[int], simulation: bool = False) -> List[int]` that performs the following steps: 1. Builds a min-heap from the given unordered array. 2. Continuously extracts the minimum element from the heap and rebuilds the heap until all elements are sorted in descending order. Input: * `arr` : List of integers to be sorted. * `simulation` : Boolean flag. If `True`, print the array at each step to show the sorting process. Output: * Sorted array in descending order. Constraints: * The array can have up to 10^5 elements. * Each element in the array can be an integer between -10^9 and 10^9. Example: ```python >>> custom_heap_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], simulation=True) iteration 0 : 3 1 4 1 5 9 2 6 5 3 5 ... iteration n : 9 6 5 5 5 4 3 3 2 1 1 >>> custom_heap_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) [9, 6, 5, 5, 5, 4, 3, 3, 2, 1, 1] ``` # Hints: 1. Start by understanding how a min-heap works and how to modify it for custom sorting. 2. Make use of the given `min_heapify` function as a starting point. 3. Make sure to handle edge cases, such as empty arrays and arrays with duplicate values.","solution":"import heapq from typing import List def custom_heap_sort(arr: List[int], simulation: bool = False) -> List[int]: if not arr: return [] # Step 1: Build a min-heap from the unordered array heapq.heapify(arr) if simulation: print(\\"Initial min-heap:\\", arr) # Step 2: Extract elements from the heap and build the result in descending order sorted_arr = [] while arr: min_element = heapq.heappop(arr) sorted_arr.append(min_element) if simulation: print(\\"Min element extracted:\\", min_element) print(\\"Remaining heap:\\", arr) print(\\"Current sorted array:\\", sorted_arr) # Reverse the sorted_arr to get descending order sorted_arr.reverse() return sorted_arr"},{"question":"Scenario You are working for a software company that processes large datasets of sorted records. One of the tasks is to efficiently find the first occurrence of a specific element within a sorted dataset. Your task is to implement a function to perform this search using a Binary Search algorithm. Task Write a function `first_occurrence(array, query)` that takes a sorted array of integers and an integer query, and returns the index of the first occurrence of the query in the array. If the query is not present in the array, return -1. Function Signature ```python def first_occurrence(array: List[int], query: int) -> int: pass ``` Input and Output - **Input**: - `array`: A list of integers, sorted in increasing order. - `query`: An integer value to find in the array. - **Output**: - An integer, the index of the first occurrence of `query` in `array`, or -1 if the query is not found. Constraints - The array will have at most (10^6) elements. - The elements of the array and the query will be integers within the range (-10^9) to (10^9). Examples ```python test1 = ([1, 2, 2, 2, 3, 4, 5], 2) assert first_occurrence(*test1) == 1 test2 = ([1, 1, 1, 1, 1], 1) assert first_occurrence(*test2) == 0 test3 = ([1, 2, 3, 4, 5], 5) assert first_occurrence(*test3) == 4 test4 = ([1, 2, 3, 4, 5], 6) assert first_occurrence(*test4) == -1 ```","solution":"from typing import List def first_occurrence(array: List[int], query: int) -> int: Returns the index of the first occurrence of query in the sorted array. If the query is not present in the array, returns -1. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid right = mid - 1 # Look on the left side for the first occurrence elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Question You are given a partially implemented class `BinaryHeap` which represents a min heap data structure, allowing you to perform efficient insertions and deletions of the smallest element. Your task is to implement an additional method that will convert an arbitrary list of integers into a valid min heap in an optimal way. **Objective**: Implement the method `build_heap(self, elements)` within the `BinaryHeap` class. The method should transform the given list of integers into a min heap. # Input and Output Specifications - **Input**: - `build_heap(elements)` should take a single input, `elements`, which is a list of integers, e.g., `elements = [5, 3, 8, 4, 1, 2, 9]`. - **Output**: - The heap should be modified in place and the internal array `self.heap` should represent the min heap, starting from index 1. # Constraints - The given list `elements` will contain at least one integer. - You should ensure the time complexity of the `build_heap` method is O(N). # Example ```python heap = BinaryHeap() heap.build_heap([5, 3, 8, 4, 1, 2, 9]) print(heap.heap) # Output: [0, 1, 3, 2, 4, 5, 8, 9] ``` In the example above, the internal heap array is represented with a dummy `0` at index `0` for ease of calculations, thus the actual heap starts from index `1`. # Implementation Requirements 1. Implement the `build_heap(self, elements)` method. 2. Ensure the method modifies the internal array `self.heap` in-place. 3. Utilize `perc_down` or a similar mechanism to achieve optimal O(N) complexity.","solution":"class BinaryHeap: def __init__(self): self.heap = [0] self.current_size = 0 def perc_down(self, i): while (i * 2) <= self.current_size: mc = self.min_child(i) if self.heap[i] > self.heap[mc]: self.heap[i], self.heap[mc] = self.heap[mc], self.heap[i] i = mc def min_child(self, i): if i * 2 + 1 > self.current_size: return i * 2 else: if self.heap[i * 2] < self.heap[i * 2 + 1]: return i * 2 else: return i * 2 + 1 def build_heap(self, elements): # Build the heap from elements self.current_size = len(elements) self.heap = [0] + elements[:] i = len(elements) // 2 while i > 0: self.perc_down(i) i = i - 1"},{"question":"# Task Context You are given a class `DirectedGraph` which supports the creation of a directed graph using an adjacency list representation. The graph maintains a collection of `Node` objects and `DirectedEdge` objects and supports basic operations to add nodes and edges, as well as to initialize the graph via a dictionary input. Objective Your task is to implement an algorithm to find the number of strongly connected components (SCCs) in the given directed graph. A strongly connected component is a maximal subgraph where each node is reachable from every other node in that subgraph. # Instructions 1. Implement the function `num_strongly_connected_components(graph)` which accepts an instance of `DirectedGraph`. 2. The function should return the number of strongly connected components in the graph. # Input * An instance of `DirectedGraph`, where graph nodes and edges are already populated via either the constructor or the provided `add_node` and `add_edge` methods. # Output * An integer representing the number of strongly connected components in the graph. # Constraints * Node names are unique strings. * The graph can contain self-loops and multiple disconnected components. * Performance requirements: Your solution should efficiently handle graphs with up to 1000 nodes and 5000 edges. # Example ```python # Example graph with two SCCs: {A, B, C} & {D, E} graph_dict = { \'A\': [\'B\'], \'B\': [\'C\', \'D\'], \'C\': [\'A\'], \'D\': [\'E\'], \'E\': [\'D\'] } graph = DirectedGraph(graph_dict) print(num_strongly_connected_components(graph)) # Should output 2 ``` # Notes * Make use of graph traversal algorithms such as DFS to help identify SCCs effectively. * Consider implementing Kosaraju’s or Tarjan’s algorithm for finding SCCs.","solution":"class Node: def __init__(self, name): self.name = name self.edges = [] class DirectedEdge: def __init__(self, start, end): self.start = start self.end = end class DirectedGraph: def __init__(self, graph_dict=None): self.nodes = {} if graph_dict: for node, neighbors in graph_dict.items(): if node not in self.nodes: self.nodes[node] = Node(node) for neighbor in neighbors: if neighbor not in self.nodes: self.nodes[neighbor] = Node(neighbor) self.add_edge(node, neighbor) def add_node(self, node_name): if node_name not in self.nodes: self.nodes[node_name] = Node(node_name) def add_edge(self, start, end): self.nodes[start].edges.append(DirectedEdge(start, end)) # Kosaraju\'s algorithm to find strongly connected components (SCCs) def num_strongly_connected_components(graph): def dfs(node, visited, stack): visited.add(node) for edge in graph.nodes[node].edges: if edge.end not in visited: dfs(edge.end, visited, stack) stack.append(node) def reverse_graph(): reversed_graph = {node: [] for node in graph.nodes} for node in graph.nodes: for edge in graph.nodes[node].edges: reversed_graph[edge.end].append(node) return reversed_graph def dfs_reverse(node, visited, reversed_graph): visited.add(node) for neighbor in reversed_graph[node]: if neighbor not in visited: dfs_reverse(neighbor, visited, reversed_graph) stack = [] visited = set() for node in graph.nodes: if node not in visited: dfs(node, visited, stack) reversed_graph = reverse_graph() visited = set() scc_count = 0 while stack: node = stack.pop() if node not in visited: dfs_reverse(node, visited, reversed_graph) scc_count += 1 return scc_count"},{"question":"# Question Context In the study of binary trees, computing the height of a tree is a fundamental operation that has numerous applications, such as evaluating the complexity of other tree-related algorithms. Task Write a function `balanced_height` that returns whether a binary tree is height-balanced. A binary tree is height-balanced if for every node in the tree, the difference in height between the left and right subtree is no more than one. Input and Output * **Input**: A reference to the root of the binary tree. * **Output**: A boolean value indicating whether the tree is height-balanced or not. Constraints * The tree node has the following structure: ```python class Node: def __init__(self, key): self.left = None self.right = None self.val = key ``` Performance Requirements * The implementation should have a time complexity of O(N) and space complexity of O(H), where N is the number of nodes and H is the height of the tree. Function Signature ```python def balanced_height(root: Node) -> bool: pass ``` Example Scenarios 1. **Example 1**: * **Input**: ```python root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.left.left.left = Node(6) ``` * **Output**: `False` 2. **Example 2**: * **Input**: ```python root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) ``` * **Output**: `True` Additional Notes * Avoid recomputing the height of subtrees multiple times for better efficiency. * Consider edge cases such as an empty tree or a tree with only one node.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def balanced_height(root: Node) -> bool: Returns whether the binary tree is height-balanced. def check_height(node): if node is None: return 0, True left_height, is_left_balanced = check_height(node.left) right_height, is_right_balanced = check_height(node.right) current_height = 1 + max(left_height, right_height) is_balanced = is_left_balanced and is_right_balanced and abs(left_height - right_height) <= 1 return current_height, is_balanced _, is_tree_balanced = check_height(root) return is_tree_balanced"},{"question":"# Description You are given a string comprising numerical digits representing an encoded message. Each numerical character or pair of characters correlates to an alphabet letter (\'A\'-\'Z\'). The conversion follows: - \'1\' -> \'A\', \'2\' -> \'B\', ..., \'26\' -> \'Z\' Write a function to determine the total number of possible ways to decode this message. Note that an encoded message starting with \'0\' is invalid. # Input Format - A single string `enc_mes` consisting of digits (\'0\'-\'9\'). # Output Format - An integer indicating the number of distinct ways to decode the given message. # Sample Input ```plaintext \\"226\\" ``` # Sample Output ```plaintext 3 ``` # Explanation For the input \\"226\\", the possible decodings are: - \\"BZ\\" (\\"2\\", \\"26\\") - \\"VF\\" (\\"22\\", \\"6\\") - \\"BBF\\" (\\"2\\", \\"2\\", \\"6\\") # Constraints - The length of `enc_mes` will be between 1 and 100 inclusive. - The string will only contain digits. # Function Signature ```python def num_decodings(enc_mes: str) -> int: # Your implementation here pass ``` # Additional Notes: - Consider edge cases such as inputs starting with \'0\' or containing invalid subsequences. - Strive for an efficient solution to handle edge constraints optimally.","solution":"def num_decodings(enc_mes: str) -> int: if not enc_mes or enc_mes[0] == \'0\': return 0 n = len(enc_mes) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): one_digit = int(enc_mes[i-1]) two_digits = int(enc_mes[i-2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i-1] if 10 <= two_digits <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"An IT company wants to maintain an efficient, height-balanced binary search tree (BST) for their employee records to ensure optimal time complexity for search, insert, and delete operations. Given a binary tree, you are tasked with determining if the tree is height-balanced. A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than one. **Your task is to implement the following function:** ```python def is_balanced_tree(root): Determines if the binary tree rooted at \'root\' is balanced. Args: root (TreeNode): The root node of the binary tree. Returns: bool: True if the binary tree is balanced, False otherwise. pass ``` # Input * The function will be passed the root of a binary tree. * `root` is an object of a class `TreeNode`. **TreeNode class definition** (for your reference): ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` # Output * The function returns a boolean value: * `True` if the given binary tree is balanced. * `False` if the given binary tree is not balanced. # Constraints * The number of nodes in the tree is in the range [0, 10^4]. * The depth of the binary tree will not exceed 10^4. * Node values are in the range of [-10^9, 10^9]. # Performance Requirements * The algorithm should run in `O(N)` time complexity. * Space complexity should be linear with respect to the height of the tree, i.e., `O(H)`. # Example ```plaintext Example 1: Input: root = [3,9,20,null,null,15,7] Output: True Explanation: The binary tree [3,9,20,null,null,15,7] is balanced since the depths of all subtrees differ by no more than 1. Example 2: Input: root = [1,2,2,3,3,null,null,4,4] Output: False Explanation: The binary tree [1,2,2,3,3,null,null,4,4] is not balanced since the depth between the left and right subtrees of node 2 differ by 2. ```","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced_tree(root): Determines if the binary tree rooted at \'root\' is balanced. Args: root (TreeNode): The root node of the binary tree. Returns: bool: True if the binary tree is balanced, False otherwise. def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) current_height = max(left_height, right_height) + 1 is_balanced = ( left_balanced and right_balanced and abs(left_height - right_height) <= 1 ) return current_height, is_balanced _, result = check_balance(root) return result"},{"question":"# Problem You are tasked to implement an efficient way to encode a list of strings into a single string and then decode it back to the original list of strings. This will help in scenarios where you need to transmit or store lists of variable-length strings without losing any information. # Requirements 1. **Encode Function**: - Input: A list of strings (`List[str]`). - Output: A single encoded string (`str`). - Method: Concatenate lengths and strings using a delimiter. 2. **Decode Function**: - Input: A single encoded string (`str`). - Output: The original list of strings (`List[str]`). # Constraints - Strings in the list may contain any printable ASCII characters including digits and punctuation. - Assume no string will contain a colon `:` as it will be used as a delimiter. - The list may contain an arbitrary number of strings (including zero). - Each string in the list will have a length between 0 and 10^4. # Performance - The encoding and decoding processes should run in linear time relative to the total size of the input. # Example ```python # Encoding Input: [\\"hello\\", \\"world\\"] Output: \\"5:hello5:world\\" # Decoding Input: \\"5:hello5:world\\" Output: [\\"hello\\", \\"world\\"] ``` # Solution Template Please provide your implementation of the `encode` and `decode` functions within the following template: ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str res = \'\' for string in strs: res += str(len(string)) + \\":\\" + string return res def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] strs = [] i = 0 while i < len(s): index = s.find(\\":\\", i) size = int(s[i:index]) strs.append(s[index+1: index+1+size]) i = index+1+size return strs ``` # Testing Test your functions with the following test cases: 1. **Basic test case**: ``` assert decode(encode([\\"hello\\", \\"world\\"])) == [\\"hello\\", \\"world\\"] ``` 2. **Edge case with empty string**: ``` assert decode(encode([\\"\\", \\"test\\"])) == [\\"\\", \\"test\\"] ``` 3. **Multiple identical strings**: ``` assert decode(encode([\\"a\\", \\"a\\", \\"a\\"])) == [\\"a\\", \\"a\\", \\"a\\"] ``` Make sure to account for edge cases and validate your encoding and decoding processes thoroughly.","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str res = \'\' for string in strs: res += f\'{len(string)}:{string}\' return res def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] strs = [] i = 0 while i < len(s): j = s.find(\':\', i) length = int(s[i:j]) i = j + 1 + length strs.append(s[j+1:i]) return strs"},{"question":"# Question: Implement a Generalized Power Function with Modulo Operation Context You are hired to join a team of mathematicians working on large computational problems. Given the importance of efficient computation, you need to implement a power function to calculate large powers with an optional modulo operation. Problem Statement Write a function `power(x, y, mod=None)` that calculates ( x^y ) (x raised to the power y). If `mod` is not `None`, it should return ( (x^y) % text{mod} ). Function Signature ```python def power(x: int, y: int, mod: int = None) -> int: pass ``` Input * `x`: A non-negative integer representing the base. * `y`: A non-negative integer representing the exponent. * `mod`: An optional positive integer for modulo operation. Output * Returns the value of ( x^y ). If `mod` is provided, returns ( (x^y) % text{mod} ). Constraints * ( 0 leq x leq 10^9 ) * ( 0 leq y leq 10^9 ) * ( 1 leq text{mod} leq 10^9 ) (when provided) Performance Requirements * The solution should be efficient, preferably with a logarithmic time complexity ( mathcal{O}(log y) ). Example ```python print(power(2, 10)) # Outputs: 1024 print(power(2, 10, 1000)) # Outputs: 24 (as 1024 % 1000 is 24) ``` Edge Cases * `x = 0, y = 0`: According to mathematical convention, 0^0 is defined as 1. * `x = 0, y > 0`: Should return 0. * Test with large values for `x` and `y`. Implement the function considering these constraints and requirements.","solution":"def power(x: int, y: int, mod: int = None) -> int: Calculate x raised to the power y. If mod is provided, return (x^y) % mod. if x == 0 and y == 0: return 1 # Convention: 0^0 is defined as 1 result = 1 base = x while y > 0: if y % 2 == 1: # If y is odd, multiply base with the result result = (result * base) % mod if mod else result * base base = (base * base) % mod if mod else base * base y //= 2 return result % mod if mod else result"},{"question":"# Scenario You are working on a text processing application that needs to determine if a particular string can become a substring of another by repeating the original string a certain number of times. This can be useful in cyclic pattern detections such as finding repeating patterns in DNA sequences or wrapping texts in a visual editor. # Problem You are given two strings, A and B. Your task is to write a function: ```python def min_repeats_to_substring(A: str, B: str) -> int: ``` This function should return the minimum number of times string A needs to be repeated such that B is a substring of it. If no such number exists, the function should return `-1`. Input - Two non-empty strings A and B, with lengths between 1 and 10,000. Output - An integer representing the minimum number of repetitions of A required such that B is a substring of it or `-1` if no such substring inclusion is possible. # Constraints - The length of A and B are between 1 and 10,000. - String comparisons should be case-sensitive. # Example ```python A = \\"abcd\\" B = \\"cdabcdab\\" # Returns 3 because \\"abcd\\" needs to be repeated 3 times min_repeats_to_substring(A, B) # Output: 3 ``` # Notes - Consider edge cases where B is already a substring of A. - Optimize for the case where B cannot be a substring of repeated A early.","solution":"def min_repeats_to_substring(A: str, B: str) -> int: Returns the minimum number of times A needs to be repeated such that B is a substring of it. If no such number exists, returns -1. # Initial checks if B in A: return 1 # Calculate the max length to cover repeat_needed = (len(B) // len(A)) + 2 # +2 to account for possible boundary scenarios repeated_A = A for i in range(1, repeat_needed + 1): if B in repeated_A: return i repeated_A += A return -1"},{"question":"You are to implement two functions as described in the following tasks: 1. **Implement the Extended GCD Algorithm**: Write a function `extended_gcd(a: int, b: int) -> (int, int, int)` that returns a tuple `(s, t, g)` such that `a * s + b * t = g` where `g` is the greatest common divisor (GCD) of `a` and `b`. 2. **Implement the Modular Inverse**: Using the `extended_gcd` function, write a function `modular_inverse(a: int, m: int) -> int` that returns an integer `x` such that `(a * x) % m == 1`. If `a` and `m` are not coprime (i.e., their GCD is not 1), the function should raise a `ValueError`. # Specifications extended_gcd(a: int, b: int) -> (int, int, int) - **Input**: - `a`: An integer (1 <= |a| <= 10^9). - `b`: An integer (1 <= |b| <= 10^9). - **Output**: - A tuple `(s, t, g)` where integers `s` and `t` satisfy the equation `a * s + b * t = g` and `g` is the greatest common divisor of `a` and `b`. modular_inverse(a: int, m: int) -> int - **Input**: - `a`: An integer (1 <= |a| < m). - `m`: An integer (1 <= m <= 10^9), `a` and `m` should be coprime. - **Output**: - An integer `x` such that `(a * x) % m == 1`. - **Constraints**: - If `a` and `m` are not coprime, the function should raise a `ValueError` with the message `\\"a and m must be coprime\\"`. # Examples ```python assert extended_gcd(30, 20) == (1, -1, 10) assert modular_inverse(3, 11) == 4 assert modular_inverse(10, 17) == 12 try: modular_inverse(12, 8) except ValueError as e: assert str(e) == \\"a and m must be coprime\\" ``` # Explanation - For the example `extended_gcd(30, 20)`, 30 * 1 + 20 * (-1) = 10, hence the output is `(1, -1, 10)`. - For `modular_inverse(3, 11)`, the function returns `4` because `3 * 4 % 11 == 1`.","solution":"def extended_gcd(a, b): Returns a tuple (s, t, g) such that a * s + b * t = g where g is the greatest common divisor of a and b. if b == 0: return 1, 0, a else: s, t, g = extended_gcd(b, a % b) return t, s - (a // b) * t, g def modular_inverse(a, m): Returns an integer x such that (a * x) % m == 1. Raises ValueError if a and m are not coprime. s, t, g = extended_gcd(a, m) if g != 1: raise ValueError(\\"a and m must be coprime\\") return s % m"},{"question":"# Coding Problem: Enhanced Insertion Sort **Context**: You are tasked with implementing an enhanced version of insertion sort that leverages a binary search approach to find the appropriate insertion index. This will ensure that the sorting process performs better, particularly for larger datasets. **Challenge**: Write a function `enhanced_insertion_sort(arr)` that sorts an array of integers using the insertion sort algorithm. However, use the `search_insert` function (provided) for finding the correct insertion index. **Function Signature**: ```python def enhanced_insertion_sort(arr: List[int]) -> List[int]: ``` **Input**: * `arr`: A list of integers (0 <= len(arr) <= 10^5, -10^6 <= arr[i] <= 10^6). **Output**: * A list of integers sorted in non-decreasing order. **Constraints**: * Your implementation should make use of the `search_insert` function provided in the snippet. * Aim for clean code and efficient use of resources. **Performance Requirements**: * The solution should handle large input sizes efficiently by leveraging the logarithmic search provided in `search_insert`. **Example**: ```python arr = [12, 11, 13, 5, 6] enhanced_insertion_sort(arr) # Output: [5, 6, 11, 12, 13] arr = [-1, 2, 0, -3, 5, 7] enhanced_insertion_sort(arr) # Output: [-3, -1, 0, 2, 5, 7] ``` **Notes**: 1. Make sure to handle edge cases like empty arrays or arrays with one element, which are trivially sorted. 2. Use the `search_insert` function for finding the correct index to place each element during sorting. **Additional Considerations**: Reflect on the start and end points of the array while performing the sort. Ensure that elements are correctly shifted to their new positions during insertion.","solution":"from typing import List def search_insert(arr: List[int], value: int) -> int: Helper function that uses binary search to find the index where the value should be inserted. low, high = 0, len(arr) while low < high: mid = (low + high) // 2 if arr[mid] < value: low = mid + 1 else: high = mid return low def enhanced_insertion_sort(arr: List[int]) -> List[int]: Sorts an array using an enhanced insertion sort algorithm with binary search. for i in range(1, len(arr)): key = arr[i] # Find the correct position for the key using binary search j = search_insert(arr[:i], key) # Shift elements to make room for the key arr = arr[:j] + [key] + arr[j:i] + arr[i+1:] return arr"},{"question":"# Question: Implement an Advanced Binary Search You are given two sorted arrays, `arr1` and `arr2`, of different lengths. Your task is to find an element that is present in both arrays using the binary search algorithm. Implement a function `find_common_element(arr1, arr2)` that returns an element common to both `arr1` and `arr2`. If no such element exists, return `None`. Function Signature ```python def find_common_element(arr1: List[int], arr2: List[int]) -> Optional[int]: ``` Input * `arr1`: A sorted list of integers with length `n` (1 <= n <= 10^5). * `arr2`: A sorted list of integers with length `m` (1 <= m <= 10^5). Output * An integer representing a common element in both arrays, or `None` if there is no such element. Constraints * All elements in `arr1` and `arr2` are unique. * The values of elements are in the range of `-10^9` to `10^9`. Example ```python arr1 = [1, 2, 3, 4, 5] arr2 = [0, 2, 6, 10, 12] find_common_element(arr1, arr2) # Output: 2 arr1 = [-10, -5, 1, 4, 7] arr2 = [2, 3, 5, 8, 12] find_common_element(arr1, arr2) # Output: None ``` Explanation * In the first example, 2 is the only common element in both arrays. * In the second example, no element is common between the arrays. Solutions should demonstrate understanding and application of the binary search algorithm. Ensure your solution handles edge cases (e.g., arrays with one or zero elements) efficiently.","solution":"from typing import List, Optional def find_common_element(arr1: List[int], arr2: List[int]) -> Optional[int]: Returns an element that is present in both arr1 and arr2 using binary search. If no such element exists, returns None. def binary_search(arr: List[int], target: int) -> bool: left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return True elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return False # Iterate over the smaller array and use binary search on the larger array for efficiency if len(arr1) > len(arr2): arr1, arr2 = arr2, arr1 for element in arr1: if binary_search(arr2, element): return element return None"},{"question":"You are required to implement the Cycle Sort algorithm. Cycle Sort is known for its simplicity and its in-place sorting nature, which does not require extra space besides the input array itself. This algorithm is particularly famed for minimizing the number of write operations and is often used when write operations are expensive. # Problem Statement Given an array of integers, implement the cycle sort algorithm to sort the array in non-decreasing order. # Function Signature ```python def cycle_sort(arr: List[int]) -> List[int]: ``` # Input - `arr`: A list of integers with length `n`. # Output - Return a list of integers representing the sorted version of the input array. # Constraints - 1 <= n <= 10^4 - -10^6 <= arr[i] <= 10^6 # Example ```python assert cycle_sort([9, 5, 6, 0, 3]) == [0, 3, 5, 6, 9] assert cycle_sort([1, 3, 2, 3, 3]) == [1, 2, 3, 3, 3] assert cycle_sort([]) == [] assert cycle_sort([1]) == [1] ``` # Notes - Your implementation should be efficient with respect to both time and space. - Be aware of edge cases such as empty arrays and arrays with duplicate values. - The function should work even if the array contains negative numbers or a mix of negative and positive numbers.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: writes = 0 n = len(arr) # Traverse array elements and put them to the right position for cycle_start in range(0, n - 1): item = arr[cycle_start] # Find where to put the item pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Skip duplicates while item == arr[pos]: pos += 1 # Put the item to the right position if pos != cycle_start: arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 if item != arr[pos]: arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"# Question You are tasked with implementing a sorting function using the Bogo Sort algorithm. This algorithm repeatedly shuffles the array until it is sorted, checking after every shuffle to see if the array is in the correct order. Write a function `bogo_sort` which takes a list of integers as input and returns the sorted list. Additionally, implement a helper function `is_sorted` that checks whether a list is sorted in ascending order or not. # Input - A list of integers `arr` where `1 <= len(arr) <= 10`. # Output - Return a sorted list of integers in ascending order. # Constraints - Since Bogo Sort is highly inefficient, assume the input list length will not exceed 10 elements. - The function should handle cases where the list contains duplicate values. # Example ```python # Input arr = [3, 1, 2] # Output [1, 2, 3] ``` # Note You should also use a recursive version of `is_sorted` to determine if the array is sorted. The main `bogo_sort` function should use this helper to decide when to stop shuffling the array.","solution":"import random def is_sorted(arr): Recursively checks if the array is sorted in ascending order. if len(arr) <= 1: return True return arr[0] <= arr[1] and is_sorted(arr[1:]) def bogo_sort(arr): Sorts the array using the highly inefficient Bogo Sort algorithm. Repeatedly shuffles the array until it is sorted. while not is_sorted(arr): random.shuffle(arr) return arr"},{"question":"Objective: Write a function to determine the minimum cost to reach the last station in a linear sequence of transit stations where some transitions between stations are not possible. Problem Statement: You are given a cost matrix where `cost[i][j]` represents the cost of traveling directly from station `i` to station `j`. If `i > j`, the value is undefined and represented by -1 or infinity (`INF`). Your task is to write a function `min_cost` which calculates the minimum cost to travel from station `0` to station `N-1`. Input: * `cost` -- a square matrix of size `N x N` representing costs as described. Output: * An integer representing the minimum cost to reach station `N-1`. If it’s not possible to reach the last station, the function should return infinity (`INF`). Constraints: * `N` will be between 2 and 100. * `cost[i][j]` will be a non-negative integer or `INF` for valid transitions and `-1` for invalid transitions. * The path between any two stations is only allowed in one direction, `i < j`. Example: ```python costs = [ [0, 15, 80, 90], [-1, 0, 40, 50], [-1, -1, 0, 70], [-1, -1, -1, 0] ] print(min_cost(costs)) # Output: 65 costs = [ [0, 10, 75, 94], [-1, 0, 35, 50], [-1, -1, 0, 80], [-1, -1, -1, 0] ] print(min_cost(costs)) # Output: 60 ``` Function Signature: ```python def min_cost(cost: List[List[int]]) -> int: pass ``` Use dynamic programming to solve the problem efficiently with time complexity O(n^2) and space complexity O(n).","solution":"from typing import List def min_cost(cost: List[List[int]]) -> int: INF = float(\'inf\') N = len(cost) # Initialize the min_cost dp array min_cost_dp = [INF] * N min_cost_dp[0] = 0 # It costs nothing to stay at the first station for i in range(1, N): for j in range(i): if cost[j][i] != -1: min_cost_dp[i] = min(min_cost_dp[i], min_cost_dp[j] + cost[j][i]) # The result is the minimum cost to reach the last station return min_cost_dp[N-1]"},{"question":"# Scenario In certain communication systems, it is crucial to assess the difference between given states represented as integers, often requiring the counting of bit differences. This helps in error detection and correction mechanisms. # Task Write a function to determine the minimal number of bits that need to be flipped to convert one integer `A` to another integer `B`. # Requirements 1. **Function Name**: `count_flips_to_convert` 2. **Input**: - Two non-negative integers, `a` and `b`. 3. **Output**: - An integer representing the number of bits that need to be flipped. # Constraints - The integers `a` and `b` can be in the range 0 to 2^31 - 1. - The solution should not use any libraries that provide direct functionality answers. # Examples ```python assert count_flips_to_convert(29, 15) == 2 assert count_flips_to_convert(0, 0) == 0 assert count_flips_to_convert(1, 2) == 2 ``` # Notes - You may assume that the input values are non-negative and fit within the standard 32-bit integer range. - Optimal performance in terms of time and space complexity is preferred.","solution":"def count_flips_to_convert(a, b): Returns the number of bits that need to be flipped to convert integer a to integer b. :param a: int - non-negative integer :param b: int - non-negative integer :return: int - number of bits that need to be flipped xor = a ^ b count = 0 while xor: count += xor & 1 xor >>= 1 return count"},{"question":"Given a sorted array of integers and a search key, implement a function `adaptive_interpolation_search` that improves the classic interpolation search algorithm by handling non-uniform distributions effectively. The function should find and return the index of the search key if it exists in the array; otherwise, it should return -1. # Input * An integer array `arr` of length `n` (1 <= n <= 10^5), containing sorted integers (can include negative values). * An integer `search_key` which you need to search for in the array. # Output * Return the 0-based index of `search_key` in the array if found. * Return -1 if `search_key` is not in the array. # Constraints * The array contains at least one element. * The array is sorted in increasing order. * The search key can either be an element present in the array or one that does not exist in the array. # Performance Requirements The function should optimize the search process for both uniformly and non-uniformly distributed arrays, aiming to achieve better performance than the traditional interpolation search in diverse scenarios. # Example ```python def adaptive_interpolation_search(arr: List[int], search_key: int) -> int: # Your implementation here # Example Usage: assert adaptive_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) == 2 assert adaptive_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) == -1 assert adaptive_interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) == -1 assert adaptive_interpolation_search([1, 10, 15, 20, 35, 40, 55, 70], 35) == 4 ``` # Notes * Assume the function `adaptive_interpolation_search` does not use any global variables. * Consider edge cases such as empty arrays, arrays with duplicate values and arrays with all identical values.","solution":"from typing import List def adaptive_interpolation_search(arr: List[int], search_key: int) -> int: An adaptive interpolation search function to find the index of search_key in a sorted array. low = 0 high = len(arr) - 1 while low <= high and arr[low] <= search_key <= arr[high]: # Avoid division by zero and ensure search_key is within range if arr[low] == arr[high]: if arr[low] == search_key: return low else: return -1 # Calculate the interpolation position pos = low + int(((search_key - arr[low]) * (high - low)) / (arr[high] - arr[low])) # Check if pos is in the allowed range if pos < low or pos > high: return -1 if arr[pos] == search_key: return pos if arr[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Question: Exchange Sort Enhancement You are tasked with implementing an improved version of the Exchange Sort, incorporating a mechanism to detect whether the array is already sorted to minimize unnecessary comparisons. Write a function `enhanced_exchange_sort` that efficiently sorts an array of integers. Function Signature ```python def enhanced_exchange_sort(arr: List[int]) -> List[int]: ``` Input - A single list of integers `arr` (1 <= len(arr) <= 10^3). The list elements consist of integer values ranging from -10^5 to 10^5. Output - The function should return the sorted list of integers. Constraints - Implement the check to detect if the array is already sorted. - Ensure the function maintains an O(n^2) time complexity in the worst case but optimizes for the best-case scenario where the array might be already sorted. Example ```python # Example 1 input_list = [4, 3, 2, 1] # since the list is in reverse order, it will require maximum swaps. result = enhanced_exchange_sort(input_list) # Output: [1, 2, 3, 4] # Example 2 input_list = [1, 2, 3, 4, 5] # list is already sorted, should return immediately result = enhanced_exchange_sort(input_list) # Output: [1, 2, 3, 4, 5] # Example 3 input_list = [3, 3, 2, -1, 0] # Sorting the list with duplicates and negative values. result = enhanced_exchange_sort(input_list) # Output: [-1, 0, 2, 3, 3] ``` **Note**: Any direct reference to existing sorting algorithms is prohibited. You must write your implementation based on the description provided.","solution":"from typing import List def enhanced_exchange_sort(arr: List[int]) -> List[int]: This function sorts an array of integers using an improved version of the Exchange Sort algorithm. It includes a mechanism to detect whether the array is already sorted to minimize unnecessary comparisons. n = len(arr) for i in range(n - 1): already_sorted = True for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] already_sorted = False if already_sorted: break return arr"},{"question":"# Question: Selection Sort with Steps You are tasked with implementing a function that performs the Selection Sort algorithm on a given list of integers and returns the sorted list. Additionally, the function should have an option to simulate and print the state of the list at each iteration of the sorting process. Function Signature ```python def selection_sort(arr: list, simulation: bool = False) -> list: Sorts an array using the Selection Sort algorithm. Parameters: arr (list): A list of integers to be sorted. simulation (bool): A flag indicating whether to print the state of the list at each iteration. Returns: list: The sorted list. ``` Input * `arr`: A list of integers `[-10^5 <= arr[i] <= 10^5]` and length `n (1 <= n <= 10^3)`. * `simulation`: A boolean flag. If `True`, the function should print the list after each iteration of the outer loop. By default, it is set to `False`. Output * A list of sorted integers. Example ```python # Example 1 arr = [64, 25, 12, 22, 11], simulation = True # Output (Printed) # iteration 0 : 64 25 12 22 11 # iteration 1 : 11 25 12 22 64 # iteration 2 : 11 12 25 22 64 # iteration 3 : 11 12 22 25 64 # iteration 4 : 11 12 22 25 64 # Returned # [11, 12, 22, 25, 64] # Example 2 arr = [5, 3, 1, 7, 2], simulation = False # Returned # [1, 2, 3, 5, 7] ``` Requirements 1. Implement the `selection_sort` function as described. 2. Ensure that the function handles and prints the list state correctly when `simulation` is `True`. Constraints 1. The function should work within the limits of time and space complexity discussed. 2. Handle edge cases like an empty array or a single-element array correctly. Hint Consider leveraging the provided code snippet to get started and focus on correctly implementing and printing the sorting stages.","solution":"def selection_sort(arr: list, simulation: bool = False) -> list: Sorts an array using the Selection Sort algorithm. Parameters: arr (list): A list of integers to be sorted. simulation (bool): A flag indicating whether to print the state of the list at each iteration. Returns: list: The sorted list. n = len(arr) for i in range(n): if simulation: print(f\\"iteration {i} :\\", \\" \\".join(map(str, arr))) min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] return arr"},{"question":"# Find Two Unique Elements in an Array Given an array `nums` where exactly two elements appear only once and all the other elements appear exactly twice, write a function `find_unique_elements(nums)` to return the two elements that appear only once. Function Signature ```python def find_unique_elements(nums: List[int]) -> List[int]: ``` Input - `nums`: A list of integers `[n1, n2, ..., nk]` where `len(nums) >= 2` and there are exactly two unique elements in the array while all other elements appear exactly twice. Output - A list of two integers `[a, b]` which are the unique elements in the input array `nums`. Constraints - Time Complexity: (O(N)) - Space Complexity: (O(1)) - The order of the result does not matter. Example ```python assert find_unique_elements([1, 2, 1, 3, 2, 5]) in ([3, 5], [5, 3]) assert find_unique_elements([4, 1, 2, 1, 2, 7]) in ([4, 7], [7, 4]) assert find_unique_elements([10, 20]) in ([10, 20], [20, 10]) ``` # Context and Requirements You are given the task to detect the two unique numbers in an array where each other number appears exactly twice. This problem leverages bitwise XOR operation to achieve the solution efficiently. Good luck!","solution":"from typing import List def find_unique_elements(nums: List[int]) -> List[int]: # XOR of all elements gives us XOR of the two unique numbers xor = 0 for num in nums: xor ^= num # Find the rightmost set bit in the xor result rightmost_set_bit = xor & -xor unique1 = 0 unique2 = 0 # Divide elements into two groups based on the rightmost set bit for num in nums: if (num & rightmost_set_bit) == 0: unique1 ^= num else: unique2 ^= num return [unique1, unique2]"},{"question":"# Chinese Remainder Theorem Solver Problem Statement You are tasked with writing a function that uses the Chinese Remainder Theorem to find the smallest non-negative integer `x` that satisfies a set of linear modular congruences. The function should handle edge cases and perform validation on input lists. Function Signature ```python def find_smallest_x(nums: List[int], rems: List[int]) -> int: pass ``` Expected Input and Output **Input**: * `nums` - a list of integers representing the moduli (all values greater than 1 and pairwise coprime). * `rems` - a list of integers representing the remainders (should be non-negative integers). **Output**: * `x` - the smallest non-negative integer that satisfies all the given congruences. Constraints * `len(nums) == len(rems)`, non-empty lists. * Each value in `nums` and `rems` must be valid as per the problem statement. Example ```python # Example 1 nums = [3, 5, 7] rems = [2, 3, 2] # The smallest x that satisfies: # x % 3 = 2 # x % 5 = 3 # x % 7 = 2 # is 23 print(find_smallest_x(nums, rems)) # Output: 23 # Example 2 nums = [6, 7, 8] rems = [5, 4, 7] # Pre-condition is violated since 6 and 8 are not coprime print(find_smallest_x(nums, rems)) # Output: Exception ``` Additional Considerations 1. You should verify that `nums` and `rems` have the same length. 2. Ensure all numbers in `nums` are pairwise coprime; otherwise, raise an exception. 3. Validate that all numbers in `nums` are greater than 1. 4. If any of these conditions are not met, the function should raise appropriate exceptions. 5. Optimize your function for efficiency where possible.","solution":"from typing import List from math import gcd from functools import reduce def find_smallest_x(nums: List[int], rems: List[int]) -> int: Find the smallest non-negative integer x that satisfies the given set of linear modular congruences using the Chinese Remainder Theorem. # Check that nums and rems lists are of the same length if len(nums) != len(rems): raise ValueError(\\"The length of nums and rems should be the same\\") # Check that all nums are greater than 1 and pairwise coprime if any(n <= 1 for n in nums): raise ValueError(\\"All values in nums must be greater than 1\\") for i in range(len(nums)): for j in range(i + 1, len(nums)): if gcd(nums[i], nums[j]) != 1: raise ValueError(\\"All values in nums must be pairwise coprime\\") # Function to find modular inverse def mod_inverse(a, m): m0, x0, x1 = m, 0, 1 if m == 1: return 0 while a > 1: q = a // m m, a = a % m, m x0, x1 = x1 - q * x0, x0 if x1 < 0: x1 += m0 return x1 # Modular setting k = len(nums) prod = reduce(lambda a, b: a * b, nums) result = 0 for n_i, r_i in zip(nums, rems): p = prod // n_i result += r_i * mod_inverse(p, n_i) * p return result % prod"},{"question":"# Question: Shell Sort Implementation and Optimization You are tasked with writing a function that implements Shell Sort with an optimized gap sequence. The goal is to sort an array of integers effectively and handle edge cases properly. **Prompt**: Implement the function `optimized_shell_sort` which takes a list of integers `arr` as input and sorts the list in ascending order using Shell Sort with the Sedgewick gap sequence. # Function Signature ```python def optimized_shell_sort(arr: List[int]) -> List[int]: pass ``` # Input: - `arr` (List[int]): A list of integers to be sorted. It may contain negative or positive integers, repeated elements, or be empty. # Output: - The function should return a new list of integers sorted in ascending order. # Constraints: - Do not use built-in sorting functions. - Ensure the solution works for large arrays up to 10^5 elements efficiently. # Performance: - Aim for an optimized time complexity close to O(n^1.5). - Space complexity should be O(1) (in-place sorting). # Example: ```python print(optimized_shell_sort([12, 34, 54, 2, 3])) # Output: [2, 3, 12, 34, 54] print(optimized_shell_sort([6, 2, 5, 9, 0, 2])) # Output: [0, 2, 2, 5, 6, 9] ``` # Important Notes: 1. Carefully select and implement the Sedgewick gap sequence. 2. Handle edge cases such as empty list or list with a single element. 3. Ensure all elements are compared and swapped if necessary even with larger initial gaps. Implement `optimized_shell_sort` to effectively sort the array.","solution":"from typing import List def optimized_shell_sort(arr: List[int]) -> List[int]: n = len(arr) gaps = _sedgewick_sequence(n) for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr def _sedgewick_sequence(n: int) -> List[int]: seq = [] k = 0 while True: gap1 = 9 * (4**k) - 9 * (2**k) + 1 gap2 = (2**(k+2)) * (2**(k+2) - 3) + 1 if gap1 < n: seq.append(gap1) if gap2 < n: seq.append(gap2) if gap1 >= n and gap2 >= n: break k += 1 seq.sort(reverse=True) return seq"},{"question":"# Question **Scenario**: Imagine you are a software developer tasked with creating a module for detecting anagrams. An anagram is defined as a rearrangement of the characters in one string to form another string. Your module will be used in a text analysis tool that checks if different words in literature are anagrams of each other. **Task**: Write a function `is_anagram(s1: str, s2: str) -> bool` that determines if two strings `s1` and `s2` are anagrams of each other. The function should handle edge cases and be optimized for performance with regard to both time and space complexity. **Input and Output**: * **Input**: * `s1` (str): A string containing only lowercase English letters. * `s2` (str): A string containing only lowercase English letters. * **Output**: * `bool`: Return `True` if `s1` and `s2` are anagrams of each other, otherwise return `False`. **Constraints**: * The length of `s1` and `s2` will be at most `10^5`. * The strings are not guaranteed to be of the same length but will contain between 0 and `10^5` characters. **Performance Requirements**: * The implemented solution should have a linear time complexity of O(n) and a constant space complexity of O(1), where n is the maximum length of the input strings. **Examples**: ```python assert is_anagram(\\"listen\\", \\"silent\\") == True assert is_anagram(\\"triangle\\", \\"integral\\") == True assert is_anagram(\\"apple\\", \\"pleap\\") == True assert is_anagram(\\"rat\\", \\"car\\") == False assert is_anagram(\\"hello\\", \\"bello\\") == False ``` **Additional Requirements**: * Ensure the function gracefully handles empty strings. * Consider optimizing for clarity and efficiency.","solution":"def is_anagram(s1: str, s2: str) -> bool: Determines if two strings s1 and s2 are anagrams of each other. Args: s1: The first string containing only lowercase English letters. s2: The second string containing only lowercase English letters. Returns: True if s1 and s2 are anagrams of each other, False otherwise. if len(s1) != len(s2): return False count = [0] * 26 # To store the count of each character for ch in s1: count[ord(ch) - ord(\'a\')] += 1 for ch in s2: count[ord(ch) - ord(\'a\')] -= 1 if count[ord(ch) - ord(\'a\')] < 0: return False return True"},{"question":"Write a function `is_anagram_optimized(s: str, t: str) -> bool` that determines whether the two input strings `s` and `t` are anagrams of each other. Instead of creating separate dictionaries for both strings, utilize a single dictionary to optimize space usage and simplify the implementation. Input - `s`: a string containing only lowercase English letters. - `t`: a string containing only lowercase English letters. Output - Return `True` if `t` is an anagram of `s`, and `False` otherwise. Constraints - The input strings will only contain lowercase alphabets (a-z). - You may assume the maximum length of both strings is 100,000. Example ```python assert is_anagram_optimized(\\"anagram\\", \\"nagaram\\") == True assert is_anagram_optimized(\\"rat\\", \\"car\\") == False assert is_anagram_optimized(\\"\\", \\"\\") == True assert is_anagram_optimized(\\"a\\", \\"ab\\") == False ``` Notes - Your solution should have a time complexity of O(n), where n is the length of the strings. - Use a single dictionary to store character frequencies from one string and decrement frequencies while iterating through the other string. Implementation Guidelines - If the strings have different lengths, return `False` immediately. - Construct a frequency count dictionary from the first string. - Iterate through the second string and adjust frequencies. - Make sure all frequencies in the dictionary are zero after processing both strings to confirm that it\'s an anagram.","solution":"def is_anagram_optimized(s: str, t: str) -> bool: Determines whether the two input strings `s` and `t` are anagrams of each other. if len(s) != len(t): return False # Using a single dictionary for character counting char_count = {} for char in s: char_count[char] = char_count.get(char, 0) + 1 for char in t: if char not in char_count: return False char_count[char] -= 1 if char_count[char] == 0: del char_count[char] # If all values in the dictionary are zero, it means `t` is an anagram of `s` return len(char_count) == 0"},{"question":"# Linked List Right Rotation **Scenario**: You are working on a scheduler for a round-robin task assignment system. Tasks are stored in a singly-linked list, and after every fixed interval `k`, the first `k` tasks should be moved to the end of the list to allow an even distribution of tasks over time. **Objective**: Implement the function `rotate_right(head, k)` that rotates the tasks in the linked list to the right by `k` places. Function Signature ```python def rotate_right(head, k): :type head: ListNode :type k: int :rtype: ListNode ``` Input * `head` - A ListNode object representing the head of the singly-linked list. * `k` - An integer representing the number of places to rotate the list. Output * The function should return the new head of the rotated list. Constraints * The number of nodes in the list is in the range [0, 500]. * `0 <= k <= 10^9`. Examples 1. Given a linked list 1->2->3->4->5->NULL and k = 2, the function should return 4->5->1->2->3->NULL. 2. Given a linked list 0->1->2->NULL and k = 4, the function should return 2->0->1->NULL. Notes * The linked list is defined using the `ListNode` class: ```python class ListNode(object): def __init__(self, x): self.val = x self.next = None ```","solution":"class ListNode(object): def __init__(self, x): self.val = x self.next = None def rotate_right(head, k): if not head or k == 0: return head # Determine the length of the list length = 1 current = head while current.next: current = current.next length += 1 # Make the list circular current.next = head # Find the effective rotations needed (k can be larger than length) k = k % length steps_to_new_head = length - k new_tail = head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None return new_head"},{"question":"# Scenario You are tasked with writing a function that duplicates every value in a given stack but must optimize the function to avoid using additional space for storage (i.e., in-place duplication). # Problem Statement Implement the function `stutter_in_place(stack)` that takes a stack (implemented as a list) as input and modifies it in place such that each original element appears twice consecutively. # Input and Output Format * **Input**: A stack represented as a list of integers. The stack follows the last-in, first-out (LIFO) principle. - Example: `[3, 7, 1, 14, 9]` * **Output**: The stack modified in place such that each element is duplicated consecutively. - Example: `[3, 3, 7, 7, 1, 1, 14, 14, 9, 9]` # Constraints * The stack contains at most 10^3 elements. * Each element is an integer between -10^6 and 10^6. * The function should run in O(n) time complexity where n is the number of elements in the stack. * The function should use O(1) additional space apart from the input stack itself. # Example ```python # Example 1 stack = [3, 7, 1, 14, 9] stutter_in_place(stack) print(stack) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] # Example 2 stack = [1, 2, 3] stutter_in_place(stack) print(stack) # Output: [1, 1, 2, 2, 3, 3] # Example 3 stack = [] stutter_in_place(stack) print(stack) # Output: [] ``` # Note Make sure not to use additional data structures or extra storage. Your code should work directly on the input stack in place.","solution":"def stutter_in_place(stack): Modifies the stack in place such that each element is duplicated consecutively. :param stack: List[int] representing the stack n = len(stack) # We iterate from the end of the list to the beginning for i in range(n-1, -1, -1): # Insert the copy of the current element right after it stack.insert(i, stack[i]) # After insertion, move to the next original element (2 steps back) # because we just doubled the list size in bottom half"},{"question":"You are given the task of implementing two functions, `encode` and `decode`, for encoding a list of strings into a single string and then decoding it back to the list of strings. The encoded string is designed to be sent over the network and decoded back to the original list on the receiving end. Problem Specification: 1. **Function `encode`**: - **Input**: A list of strings, `strs`. - **Output**: A single string that represents the encoded list. - **Format**: Each string in the list is concatenated as `<length>:<string>`. For example, the list [\\"hello\\", \\"world\\"] will be encoded as \\"5:hello5:world\\". 2. **Function `decode`**: - **Input**: A single string that represents the encoded form of a list of strings. - **Output**: The original list of strings. 3. **Constraints**: - The input list for `encode` will contain only ASCII characters and no colons in the strings. - Both functions should handle edge cases properly, such as empty lists or strings. Example: ```python # Example of usage: encoded = encode([\\"hello\\", \\"world\\"]) print(encoded) # Output should be \\"5:hello5:world\\" decoded = decode(encoded) print(decoded) # Output should be [\\"hello\\", \\"world\\"] # Handle edge cases encoded_empty = encode([]) print(encoded_empty) # Output should be an empty string decoded_empty = decode(encoded_empty) print(decoded_empty) # Output should be [] ``` # Task: Implement the following functions: ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str pass def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] pass ``` **Note**: Ensure to handle edge cases and validate your implementation with a few different scenarios.","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str encoded_string = \'\' for s in strs: encoded_string += f\'{len(s)}:{s}\' return encoded_string def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] decoded_list = [] i = 0 while i < len(s): # Locate the colon separator colon_index = s.find(\':\', i) length = int(s[i:colon_index]) i = colon_index + 1 decoded_list.append(s[i:i+length]) i += length return decoded_list"},{"question":"Find Missing Number You are given a sequence of unique integers in the range [0..n], where n is the length of the given list. The difference between consecutive integers in the input list cannot be more than 1. Your task is to write a function that returns the missing number from the sequence in O(n) time and space. If the sequence is already complete, the next integer in the sequence should be returned. # Input * A list of unique integers, nums, where `1 <= len(nums) <= 10000`. # Output * A single integer representing the missing number or the next integer if the sequence is already complete. # Constraints - All integers in the input list are unique. - The integers are in the range [0..n] where n is the length of the list. - Length of the list will be at least 1 and at most 10000. # Example ```python def find_missing_number(nums): # Your code here # Example 1 nums = [4, 1, 3, 0, 6, 5, 2] print(find_missing_number(nums)) # Output: 7 # Example 2 nums = [1, 0, 3] print(find_missing_number(nums)) # Output: 2 ``` Implement the function `find_missing_number(nums)` to solve the problem.","solution":"def find_missing_number(nums): Returns the missing number from the sequence or the next integer if the sequence is already complete. n = len(nums) expected_sum = (n * (n + 1)) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"Problem Statement: You are working with a `SegmentTree` data structure, which allows efficient range queries and updates on an array. The `SegmentTree` class has been implemented to support associative and commutative functions. Your task is to extend the functionality of this `SegmentTree` class by implementing a method `range_update(l, r, v)` that performs a range update on the elements between indices `l` and `r` (inclusive) by applying the operation defined by the function to each element. # Function Signature: ```python def range_update(self, l: int, r: int, v): pass ``` # Expected Behavior: * Update all elements from index `l` to `r` with the value `v` using the segment tree\'s function. * Existing query and update methods should still function correctly after the range update. # Input/Output: * **Inputs**: * `l`: The starting index of the range (inclusive). * `r`: The ending index of the range (inclusive). * `v`: The value to be used in the update operation. # Example: ```python # Example usage of the modified SegmentTree def max_fn(a, b): return max(a, b) arr = [2, 4, 5, 3, 4] tree = SegmentTree(arr, max_fn) # Before any range update print(tree.query(2, 4)) # Output: 5 # Performing range update tree.range_update(1, 3, 6) # After range update print(tree.query(2, 4)) # Output: 6 print(tree.query(0, 2)) # Output: 6 print(tree.query(3, 4)) # Output: 6 ``` # Constraints: * Ensure that the range update efficiently updates the tree structure. Avoid updating leaf nodes directly without considering existing segment functions. * Handle edge cases where the indices might be at the boundaries of the array. * Assume the input `arr` size is within the range of 1 to ( 10^5 ).","solution":"class SegmentTree: def __init__(self, data, func): self.n = len(data) self.func = func self.tree = [None] * (2 * self.n) # 建立segment tree for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, index, value): index += self.n self.tree[index] = value while index > 1: index //= 2 self.tree[index] = self.func(self.tree[2 * index], self.tree[2 * index + 1]) def query(self, l, r): result = None l += self.n r += self.n + 1 while l < r: if l % 2 == 1: result = self.tree[l] if result is None else self.func(result, self.tree[l]) l += 1 if r % 2 == 1: r -= 1 result = self.tree[r] if result is None else self.func(result, self.tree[r]) l //= 2 r //= 2 return result def range_update(self, l, r, v): for i in range(l, r + 1): self.update(i, v)"},{"question":"Strongly Connected Components in a Graph Consider a directed graph with `V` vertices and `E` edges. You have to determine whether the graph is strongly connected. A directed graph is strongly connected if there is a path between any pair of vertices in both directions (i.e., from u to v and from v to u for any u, v in the graph). Your task is to write a function `is_graph_strongly_connected(graph)` that determines whether the provided directed graph is strongly connected. Function Signature ```python def is_graph_strongly_connected(graph: Graph) -> bool: pass ``` Input * `graph` (Graph): An instance of the Graph class described below. Output * Boolean value (True/False): Return `True` if the graph is strongly connected, otherwise `False`. Example ```python graph = Graph(5) graph.add_edge(0, 1) graph.add_edge(1, 2) graph.add_edge(2, 3) graph.add_edge(3, 4) graph.add_edge(4, 0) print(is_graph_strongly_connected(graph)) # Output: True ``` In this example, each node can reach all other nodes in both directions, making the graph strongly connected. Constraints * Assume that the vertex count (V) is at most 10^5. * The total number of edges (E) is at most 10^6. * Nodes will be identified by integers from `0` to `V-1`. Graph Class The Graph class has been provided as part of the initial code snippet: ```python class Graph: def __init__(self, vertex_count): self.vertex_count = vertex_count self.graph = defaultdict(list) def add_edge(self, source, target): self.graph[source].append(target) def dfs(self): visited = [False] * self.vertex_count self.dfs_util(0, visited) return all(visited) def dfs_util(self, source, visited): visited[source] = True for adj in self.graph[source]: if not visited[adj]: self.dfs_util(adj, visited) def reverse_graph(self): reversed_graph = Graph(self.vertex_count) for source, targets in self.graph.items(): for target in targets: reversed_graph.add_edge(target, source) return reversed_graph def is_strongly_connected(self): if self.dfs(): reversed_graph = self.reverse_graph() return reversed_graph.dfs() return False ```","solution":"from collections import defaultdict class Graph: def __init__(self, vertex_count): self.vertex_count = vertex_count self.graph = defaultdict(list) def add_edge(self, source, target): self.graph[source].append(target) def dfs(self): visited = [False] * self.vertex_count self.dfs_util(0, visited) return all(visited) def dfs_util(self, source, visited): visited[source] = True for adj in self.graph[source]: if not visited[adj]: self.dfs_util(adj, visited) def reverse_graph(self): reversed_graph = Graph(self.vertex_count) for source, targets in self.graph.items(): for target in targets: reversed_graph.add_edge(target, source) return reversed_graph def is_strongly_connected(self): if self.dfs(): reversed_graph = self.reverse_graph() return reversed_graph.dfs() return False def is_graph_strongly_connected(graph: Graph) -> bool: return graph.is_strongly_connected()"},{"question":"# Scenario You are developing a system that processes data stored in grid-like formats. One operation you need to implement retrieves data from these grids in a spiral order, starting from the top left corner and moving inwards. This sequence is required for visualization purposes. # Task Write a function, `spiralOrder`, to perform a spiral traversal on a given matrix and return the elements in the resulting spiral sequence. # Function Signature ```python def spiralOrder(matrix: List[List[int]]) -> List[int]: ``` # Input Format - A 2D list `matrix` where `matrix[i][j]` denotes the element at the i-th row and j-th column. - Constraints: - (1 leq text{number of rows}, text{number of columns} leq 100) - (-100 leq text{matrix[i][j]} leq 100) # Output Format - A list of integers representing the elements of the matrix in spiral order. # Example Given the following matrix: ```python [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] ``` The output should be `[1, 2, 3, 6, 9, 8, 7, 4, 5]`. # Notes - Ensure your solution handles matrices of various shapes including edge cases such as single row or single column matrices. - Optimize for readability and efficiency.","solution":"from typing import List def spiralOrder(matrix: List[List[int]]) -> List[int]: Perform a spiral traversal on the given matrix and return the elements in spiral order. result = [] if not matrix or not matrix[0]: return result top, bottom = 0, len(matrix) - 1 left, right = 0, len(matrix[0]) - 1 while top <= bottom and left <= right: # Traverse from left to right along the top row for i in range(left, right + 1): result.append(matrix[top][i]) top += 1 # Traverse from top to bottom along the right column for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 if top <= bottom: # Traverse from right to left along the bottom row for i in range(right, left - 1, -1): result.append(matrix[bottom][i]) bottom -= 1 if left <= right: # Traverse from bottom to top along the left column for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 return result"},{"question":"You are given a list `lst` of integers and an integer `N`. Your task is to write a function `limit_frequency` that returns a new list that contains each number of `lst` at most `N` times without changing the order of elements. To efficiently count the occurrences, you should aim to implement a solution with a time complexity of O(n). # Function Specification ```python def limit_frequency(lst, n): # Your code here ``` # Input - `lst`: a list of integers where `1 <= |lst| <= 10^5` and each integer `1 <= lst[i] <= 10^9`. - `n`: a non-negative integer where `0 <= n <= 10^5`. # Output - A list of integers with elements appearing no more than `n` times, preserving the original order. # Constraints - You should ensure the solution operates efficiently with a time complexity of O(n). # Example ```python # Example 1 lst = [1, 2, 3, 1, 2, 1, 2, 3] n = 2 print(limit_frequency(lst, n)) # Output: [1, 2, 3, 1, 2, 3] # Example 2 lst = [1, 1, 1, 1] n = 0 print(limit_frequency(lst, n)) # Output: [] # Example 3 lst = [20, 37, 20, 21] n = 1 print(limit_frequency(lst, n)) # Output: [20, 37, 21] ``` # Hint Consider using a dictionary to keep track of how many times an element has appeared in the output list.","solution":"def limit_frequency(lst, n): Limits the frequency of each element to at most n times in the resulting list, preserving the original order. if n == 0: return [] result = [] frequency = {} for number in lst: if frequency.get(number, 0) < n: result.append(number) frequency[number] = frequency.get(number, 0) + 1 return result"},{"question":"Scenario You are working on a software solution that needs to process data represented as matrices. One particular requirement is to sort the diagonal elements within a matrix while preserving the overall structure of the matrix. Objective Write a function `sort_diagonally(mat: List[List[int]]) -> List[List[int]]` that sorts each diagonal of a given matrix in ascending order and returns the sorted matrix. Function Signature ```python def sort_diagonally(mat: List[List[int]]) -> List[List[int]]: ``` Input - A 2D matrix `mat` of integers with dimensions `m x n` where `1 <= m, n <= 100`. Output - The matrix with each of its diagonals sorted in ascending order. Constraints 1. The matrix will contain only integer values. 2. Handle maximum matrix size efficiently within given constraints. Example Input: ```python mat = [ [3, 3, 1, 1], [2, 2, 1, 2], [1, 1, 1, 2] ] ``` Output: ```python [ [1, 1, 1, 1], [1, 2, 2, 2], [1, 2, 3, 3] ] ``` Performance Notes 1. Your solution must efficiently handle matrices where `m` and `n` approach the upper limits. Additional Requirements 1. Validate edge cases such as single row matrices and single column matrices. 2. Maintain coherent variable naming and clear, readable code.","solution":"def sort_diagonally(mat): Sorts each diagonal of the given matrix in ascending order and returns the sorted matrix. Parameters: mat (list of list of int): The input matrix. Returns: list of list of int: The matrix with each of its diagonals sorted in ascending order. from collections import defaultdict # Create a dictionary to hold the diagonals diagonals = defaultdict(list) # Populate the diagonals dictionary for i in range(len(mat)): for j in range(len(mat[0])): diagonals[i - j].append(mat[i][j]) # Sort each diagonal for key in diagonals: diagonals[key].sort() # Write the sorted diagonals back into the matrix for i in range(len(mat)): for j in range(len(mat[0])): mat[i][j] = diagonals[i - j].pop(0) return mat"},{"question":"# **Scenario:** In the ancient Roman era, Julius Caesar used a book cipher to encrypt his important messages. We\'re trying to decode/encode similar messages using the Caesar Cipher. The task is to implement both the encryption and decryption functions for the Caesar Cipher. The encryption function `caesar_cipher_encrypt` and the decryption function `caesar_cipher_decrypt` should correctly handle both uppercase and lowercase letters while leaving non-letter characters unchanged. # **Task:** Write two functions, `caesar_cipher_encrypt(s: str, k: int) -> str` and `caesar_cipher_decrypt(s: str, k: int) -> str`, where: - `s` is the string to be processed. - `k` is the integer key for the rotation (0 <= k <= 25). # **Input Format:** - The input string `s` contains only alphabetical characters and may include uppercase (A-Z) and lowercase (a-z) letters. - The rotation key `k` is a non-negative integer that specifies how many positions each letter in the text should be shifted. # **Output Format:** - The functions should return the encrypted and decrypted string based on the rotation key provided. # **Constraints:** - 1 <= |s| <= 100 (length of the input string). - 0 <= k <= 25. # **Example:** ```python # Example of the encryption assert caesar_cipher_encrypt(\'AttackAtDawn\', 3) == \'DwwdfnDwGdzq\' assert caesar_cipher_encrypt(\'Hello, World!\', 4) == \'Lipps, Asvph!\' # Example of the decryption assert caesar_cipher_decrypt(\'DwwdfnDwGdzq\', 3) == \'AttackAtDawn\' assert caesar_cipher_decrypt(\'Lipps, Asvph!\', 4) == \'Hello, World!\' ``` Use modular arithmetic to handle the wrap-around behavior of the letters and ensure that non-alphabetic characters remain unchanged.","solution":"def caesar_cipher_encrypt(s: str, k: int) -> str: Encrypts the given string s using Caesar Cipher with rotation k. encrypted_text = [] for char in s: if char.isalpha(): shift = k base = ord(\'A\') if char.isupper() else ord(\'a\') encrypted_text.append(chr((ord(char) - base + shift) % 26 + base)) else: encrypted_text.append(char) return \'\'.join(encrypted_text) def caesar_cipher_decrypt(s: str, k: int) -> str: Decrypts the given string s using Caesar Cipher with rotation k. decrypted_text = [] for char in s: if char.isalpha(): shift = k base = ord(\'A\') if char.isupper() else ord(\'a\') decrypted_text.append(chr((ord(char) - base - shift) % 26 + base)) else: decrypted_text.append(char) return \'\'.join(decrypted_text)"},{"question":"# Longest Palindromic Subsequence - Coding Challenge **Problem Statement**: You are tasked with writing a function that determines the length of the longest palindromic subsequence within a given string using dynamic programming. A subsequence is any sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. **Function Signature**: ```python def longest_palindromic_subsequence(s: str) -> int: pass ``` **Input**: - `s` (string): A single string of length `0 <= len(s) <= 1000` consisting of upper and lowercase English letters. **Output**: - Returns an integer representing the length of the longest palindromic subsequence. **Constraints**: - Handle strings that contain letters in mixed case. - You should aim for a solution with a time complexity of O(n^2) and a space complexity of O(n). **Performance Requirements**: - Ensure the implementation can handle any string within the provided length limit efficiently. **Scenario**: Imagine you are developing part of a text analysis tool that has to identify patterns in user input strings. One interesting pattern is symmetric substrings. This function will help identify the most extensive symmetric subsequence, aiding further text analysis and pattern recognition in the tool. **Example**: ```python # Given input s = \\"bbbab\\" # Expected output result = 4 # Explanation: The longest palindromic subsequence is \\"bbbb\\", which has a length of 4. s = \\"cbbd\\" # Expected output result = 2 # Explanation: The longest palindromic subsequence is \\"bb\\", which has a length of 2. ``` **Implementation Tips**: - Consider initializing a DP array to store intermediate results. - Think about how to manage the DP state considering the two boundary characters. - Ensure to handle both cases of different and identical characters separately. Happy coding!","solution":"def longest_palindromic_subsequence(s: str) -> int: n = len(s) if n == 0: return 0 # Create a 2D dp array to store the lengths of palindromic subsequences dp = [[0]*n for _ in range(n)] # Every single letter is a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Build the dp array for cl in range(2, n+1): # cl is the length of the substring for i in range(n-cl+1): j = i+cl-1 if s[i] == s[j]: if cl == 2: dp[i][j] = 2 else: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i][j-1], dp[i+1][j]) # The length of LPS is now in dp[0][n-1] return dp[0][n-1]"},{"question":"# Bitonic Sort Implementation You are asked to implement the `bitonic_sort` algorithm, which is designed to sort arrays particularly efficiently in parallel computing environments. However, we\'ll focus on a non-parallel implementation for this exercise. Problem Statement Given an array of integers, sort the array using the Bitonic Sort algorithm. You should write a function `bitonic_sort` that sorts the array. The size of the input array will always be a power of two. Your task: - Implement the `bitonic_sort` function in Python, following the provided bitonic sort principles. - Ensure the array is sorted in increasing order by default if no reverse argument is provided. - Handle the case where the array size is not a power of two gracefully by raising a `ValueError`. Function Signature ```python def bitonic_sort(arr, reverse=False): # Your implementation here ``` Input - `arr`: A list of integers where len(arr) is a power of two. - `reverse` (Optional): A boolean value indicating whether to sort the array in decreasing order. Default is `False`. Output - A sorted list of integers. Constraints - The array size will always be a power of two and will not exceed 2^10 (1024). - The elements in the array will be integers within the range of -10^5 to 10^5. Example ```python # Example 1 print(bitonic_sort([10, 30, 11, 20, 4, 15, 2, 5])) # Output: [2, 4, 5, 10, 11, 15, 20, 30] # Example 2 print(bitonic_sort([10, 30, 11, 20, 4, 15, 2, 5], reverse=True)) # Output: [30, 20, 15, 11, 10, 5, 4, 2] ``` # Additional Instructions - Ensure edge cases such as single-element arrays or empty arrays are handled properly. - Write efficient and clean code with appropriate variable names and comments.","solution":"def bitonic_sort(arr, reverse=False): Perform bitonic sort on the provided array. Arguments: arr -- list of integers (size must be a power of two) reverse -- whether to sort in descending order (default is False) Returns: Sorted list of integers. def bitonic_merge(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 for i in range(low, low + k): if (direction == 1 and arr[i] > arr[i + k]) or (direction == 0 and arr[i] < arr[i + k]): arr[i], arr[i + k] = arr[i + k], arr[i] bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort_recursive(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 bitonic_sort_recursive(arr, low, k, 1) # Sort in ascending order bitonic_sort_recursive(arr, low + k, k, 0) # Sort in descending order bitonic_merge(arr, low, cnt, direction) n = len(arr) if n == 0: return arr if (n & (n - 1)) != 0: # Check if n is not a power of 2 raise ValueError(\\"Size of array must be a power of two.\\") bitonic_sort_recursive(arr, 0, n, 1 if not reverse else 0) return arr"},{"question":"# Question You are given an array of integers that needs to be sorted in non-decreasing order. Your task is to implement the selection sort algorithm to accomplish this task. To test your comprehension, extend the given implementation to handle additional constraints. # Requirements 1. **Function Definition**: ```python def enhanced_selection_sort(arr: list) -> list: # your implementation here ``` 2. **Input**: A list of integers (arr). - Example: [29, 10, 14, 37, 13] 3. **Output**: A list of integers sorted in non-decreasing order. - Example: [10, 13, 14, 29, 37] # Constraints 1. The algorithm must handle edge cases such as empty arrays, arrays with one element, arrays with all identical elements, and already sorted arrays. 2. If a list is already sorted, the function should avoid unnecessary operations and complete in O(n) time. 3. You should return the original array if it already is sorted to optimize the existing solution. # Detailed Scenario Imagine you are designing a system that needs to sort individual transaction entries based on timestamps. The system could potentially receive small batches of transaction entries, and the timestamps need to be ordered to process the transactions sequentially. Your task is to ensure the array of timestamps is correctly ordered using the selection sort algorithm while enhancing it to be efficient with already sorted data. # Performance Expectation 1. Implement the sorting such that it performs optimally for small datasets. 2. Ensure that if the input array is already sorted, the function can complete the sort operation in linear time, O(n). Use the following example to validate your implementation: ```python # example usage input_data = [29, 10, 14, 37, 13] print(enhanced_selection_sort(input_data)) # should output [10, 13, 14, 29, 37] input_data_sorted = [10, 13, 14, 29, 37] print(enhanced_selection_sort(input_data_sorted)) # should output [10, 13, 14, 29, 37] and must run in O(n) time ```","solution":"def enhanced_selection_sort(arr: list) -> list: Sort the list using an enhanced selection sort algorithm. If the list is already sorted, the function will detect it and avoid unnecessary operations. n = len(arr) if n <= 1: return arr sorted_flag = True # Flag to check if the list is already sorted for i in range(n-1): min_index = i for j in range(i+1, n): if arr[j] < arr[min_index]: min_index = j sorted_flag = False if sorted_flag: break # Swap if a smaller element was found arr[i], arr[min_index] = arr[min_index], arr[i] return arr"},{"question":"# Climbing Stairs Puzzle **Scenario Context:** Imagine you are a legendary firefighter in a city with extremely tall skyscrapers. You often need to cover multiple staircases to rescue people, and each time you can either take one or two steps. To plan your strategy efficiently, you need to figure out the number of distinct ways you can climb to the top of a staircase of various heights. **Task:** Write a function `distinct_ways_to_climb` that calculates the number of distinct ways to climb a staircase with the given number of `steps`. Each time you can either climb 1 or 2 steps. **Function Signature:** ```python def distinct_ways_to_climb(steps: int) -> int: pass ``` **Expected Input and Output:** - **Input:** A positive integer `steps`, which indicates the number of steps to reach the top. - **Output:** An integer representing the number of distinct ways to reach the top of the staircase. **Constraints:** - `1 <= steps <= 1000` **Performance Requirements:** - The algorithm should maintain a time complexity of O(n) and a space complexity of O(1). **Examples:** ```python distinct_ways_to_climb(1) -> 1 distinct_ways_to_climb(2) -> 2 distinct_ways_to_climb(3) -> 3 distinct_ways_to_climb(4) -> 5 distinct_ways_to_climb(5) -> 8 ``` **Additional Notes:** - Clearly, the ways to climb the stairs follow the structure of the Fibonacci sequence where F(n) = F(n-1) + F(n-2). - Ensure your solution is optimal with respect to space and time complexity.","solution":"def distinct_ways_to_climb(steps: int) -> int: Calculate the number of distinct ways to climb a staircase with the given number of steps. Each time you can either climb 1 or 2 steps. if steps == 1: return 1 elif steps == 2: return 2 prev1, prev2 = 1, 2 for _ in range(3, steps + 1): current = prev1 + prev2 prev1, prev2 = prev2, current return prev2"},{"question":"Scenario You are tasked with determining whether a path exists between two nodes in a directed graph representing a network of cities. This graph allows one-way travel between cities, and your goal is to verify if you can travel from one specified city to another. Task Implement a function `is_reachable` that checks if there is a path from a given source node to a target node using Depth First Search (DFS). Function Signature ```python def is_reachable(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: pass ``` Input and Output * **Input**: - `vertex_count`: An integer representing the number of cities (vertices) in the network. - `edges`: A list of tuples where each tuple (u, v) represents a directed edge from city `u` to city `v`. - `source`: An integer representing the starting city for the path check. - `target`: An integer representing the destination city for the path check. * **Output**: - A boolean value: `True` if there is a path from `source` to `target`, `False` otherwise. Constraints * The number of vertices (cities) will be between 1 and 1000. * The number of edges will be between 0 and 10000. * The source and target will be valid vertex indices within the range [0, vertex_count-1]. Example ```python # Example 1 vertex_count = 5 edges = [(0, 1), (1, 2), (2, 3), (3, 4)] source = 0 target = 4 assert is_reachable(vertex_count, edges, source, target) == True # Example 2 vertex_count = 5 edges = [(0, 1), (1, 2), (2, 3)] source = 0 target = 4 assert is_reachable(vertex_count, edges, source, target) == False ``` Edge Cases to Consider * A graph with no edges. * Source is the same as the target. * Disconnected components in the graph.","solution":"def is_reachable(vertex_count, edges, source, target): from collections import defaultdict # Build graph using adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Depth First Search (DFS) to check reachability visited = [False] * vertex_count def dfs(node): if node == target: return True visited[node] = True for neighbor in graph[node]: if not visited[neighbor]: if dfs(neighbor): return True return False return dfs(source)"},{"question":"# Minimum Cost Set Cover Problem Background You are a project manager dealing with a selection of vendors, each offering services for a distinct set of tasks. Every vendor has a particular service set and associated service cost. Your goal is to ensure that all required tasks are covered at the minimum total service cost. This problem can be translated into a **Set Cover Problem**, which is a well-known combinatorial optimization problem in computer science. Problem Statement Given a `universe` of tasks and a collection of `subsets`, each with a corresponding `cost`, write a function `minimum_cost_set_cover` to determine the subcollection of subsets that covers all elements in the universe at the lowest possible total cost. Core Functions 1. **Function Name**: `minimum_cost_set_cover` 2. **Inputs**: * `universe`: A Python set of elements that needs to be covered. * `subsets`: A dictionary where the keys represent subset names and the values are sets of elements that each subset covers. * `costs`: A dictionary where the keys represent subset names and the values are the costs associated with each subset. 3. **Output**: * A list of subset names that form the minimum cost cover of the universe. * The total cost of the selected subsets. 4. **Constraint**: * The function should find the optimal solution for small input sizes but fall back on a near-optimal solution for larger sizes to avoid excessive computation. Requirements 1. Your algorithm must handle edge cases such as subsets not covering the entire universe. 2. Output `None` if it\'s impossible to cover the entire universe with the given subsets. 3. Aim to make your implementation efficient enough to handle larger inputs where possible. Example ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} result, total_cost = minimum_cost_set_cover(universe, subsets, costs) print(result) # Output can be: [\'S3\', \'S2\'] print(total_cost) # Output: 13 ``` Note * Ensure your implementation adequately handles potential inefficiencies for large inputs. * Justify and explain any assumptions or design choices that impact the efficiency and accuracy of your solution.","solution":"def minimum_cost_set_cover(universe, subsets, costs): Determine the subcollection of subsets that covers all elements in the universe at the lowest possible total cost. Args: universe (set): The set of elements that need to be covered. subsets (dict): A dictionary where keys are subset names and values are sets of elements each subset covers. costs (dict): A dictionary where keys are subset names and values are the costs associated with each subset. Returns: (list, int): A tuple with a list of subset names that form the minimum cost cover and the total cost of these subsets. selected_subsets = [] covered = set() total_cost = 0 while covered != universe: best_subset = None best_cost_effectiveness = float(\'inf\') for subset_name, subset in subsets.items(): newly_covered = subset - covered if newly_covered: cost_per_newly_covered = costs[subset_name] / len(newly_covered) if cost_per_newly_covered < best_cost_effectiveness: best_cost_effectiveness = cost_per_newly_covered best_subset = subset_name if best_subset is None: # No more subsets can cover additional elements return None, 0 selected_subsets.append(best_subset) covered |= subsets[best_subset] total_cost += costs[best_subset] return selected_subsets, total_cost"},{"question":"# Question Context You are given a binary tree, and you need to find all the paths from the root to the leaves. This information is critical in scenarios such as representing paths in a filesystem or finding network paths in a hierarchical network structure. Task Implement the function `binary_tree_paths(root)`, which takes the root of a binary tree and returns all root-to-leaf paths as a list of strings. Requirements - Implement the Depth-First Search (DFS) algorithm to traverse the tree. - Construct each path as a string with nodes separated by \\"->\\". Function Signature ```python def binary_tree_paths(root: TreeNode) -> List[str]: ... ``` # Input - A single parameter `root`, which is the root of the binary tree. - The tree may have between 0 and 10,000 nodes. # Output - A list of strings, where each string represents a root-to-leaf path. # Constraints - `TreeNode` is defined such that each node has attributes `val` (integer), `left` (left child node or `None`), and `right` (right child node or `None`). # Example ```python # Assume TreeNode is defined as follows: # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right # Example Tree: # 1 # / # 2 3 # # 5 # Expected Output: # [\\"1->2->5\\", \\"1->3\\"] root = TreeNode(1, TreeNode(2, None, TreeNode(5)), TreeNode(3)) print(binary_tree_paths(root)) # Output: [\\"1->2->5\\", \\"1->3\\"] ``` # Notes - Your solution will be tested against edge cases such as: - An empty tree (root is `None`). - A tree where every node has one child. - A balanced tree.","solution":"from typing import List, Optional # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root: Optional[TreeNode]) -> List[str]: def dfs(node, path, paths): if node: new_path = path + str(node.val) if not node.left and not node.right: # if leaf node paths.append(new_path) # add the current path to paths list else: new_path += \\"->\\" # prepare the path for the next nodes dfs(node.left, new_path, paths) dfs(node.right, new_path, paths) if not root: return [] paths = [] dfs(root, \'\', paths) return paths"},{"question":"# Question Context You are working on a pattern recognition system that needs to detect the longest symmetrical patterns within text segments. One of the core functionalities you need to implement involves identifying the longest palindromic substring within given text strings efficiently. # Problem Statement Implement a function `find_longest_palindromic_substring(s: str) -> str` that takes a single string input `s` and returns the longest palindromic substring present in `s`. # Input * `s` (String): The input string with a maximum length of 1000 characters. # Output * Returns a string representing the longest palindromic substring within the input `s`. # Constraints * The input string will consist of lower-case alphabetical characters only. * If there are multiple longest palindromic substrings of the same maximum length, return the first one encountered in the left-to-right scanning of the string. # Performance Requirements * Your solution should run in linear time, O(n), where n is the length of the input string. * Memory usage should be linear to the input size. # Example ```python assert find_longest_palindromic_substring(\\"babad\\") == \\"bab\\" # Note that \\"aba\\" is also a valid answer assert find_longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" assert find_longest_palindromic_substring(\\"a\\") == \\"a\\" assert find_longest_palindromic_substring(\\"ac\\") == \\"a\\" # \\"c\\" is also a valid answer ``` # Implementation Notes You are encouraged to use Manacher\'s algorithm, a powerful technique to achieve the desired time complexity. Ensure your function handles edge cases effectively and performs necessary transformations accurately.","solution":"def find_longest_palindromic_substring(s: str) -> str: Function to find the longest palindromic substring in a given string using Manacher\'s Algorithm. # Transform the original string \'s\' into a new one with \'#\' inserted between each character and at the ends t = \'#\' + \'#\'.join(s) + \'#\' n = len(t) p = [0] * n c = 0 r = 0 for i in range(n): mirr = 2*c - i if i < r: p[i] = min(r - i, p[mirr]) # Extending the palindrome centered at `i` a = i + p[i] + 1 b = i - p[i] - 1 while a < n and b >= 0 and t[a] == t[b]: p[i] += 1 a += 1 b -= 1 # Update the center and the right boundary if i + p[i] > r: c = i r = i + p[i] # Find the maximum length of palindrome and its center max_len = 0 center_index = 0 for i in range(n): if p[i] > max_len: max_len = p[i] center_index = i # Extract the actual palindrome from the transformed string start = (center_index - max_len) // 2 return s[start:start + max_len]"},{"question":"# Array Filtering Function **Context**: In data preprocessing, it\'s often necessary to restrict the values in a dataset to a specified range. Implement a function that filters out elements of an array that don\'t fall within the specified minimum and maximum range. **Task**: Write a function `limit` that takes an array of numbers and two optional boundary values `min_lim` and `max_lim`. The function should return a new array containing only those elements of the original array that fall within the specified range. If `min_lim` or `max_lim` is not provided, the function should automatically adjust to the lowest or highest value in the array, respectively. **Function Signature**: ```python def limit(arr, min_lim=None, max_lim=None): pass ``` **Inputs**: - `arr` (list of integers/floats): The input array to be filtered. - `min_lim` (int/float or None): The lower boundary for the elements (default is None). - `max_lim` (int/float or None): The upper boundary for the elements (default is None). **Outputs**: - Returns a list containing elements from `arr` that lie within the range `[min_lim, max_lim]`. **Constraints**: - Elements in `arr` can include integers and floats. - It is guaranteed that all elements in `arr` can be compared with each other using standard comparison operators. **Examples**: ```python # Example 1 arr = [1, 2, 3, 4, 5] min_lim = None max_lim = 3 print(limit(arr, min_lim, max_lim)) # Output: [1, 2, 3] # Example 2 arr = [-10, 0, 10, 20, 30, 40] min_lim = 5 max_lim = 35 print(limit(arr, min_lim, max_lim)) # Output: [10, 20, 30] # Example 3 arr = [5, 10, 15, 20] min_lim = 12 max_lim = None print(limit(arr, min_lim, max_lim)) # Output: [15, 20] ``` **Note**: - Handle edge cases including empty input arrays. - Optimize for large arrays if possible.","solution":"def limit(arr, min_lim=None, max_lim=None): Filters the array elements to be within the given range specified by min_lim and max_lim. :param arr: List of integers or floats. :param min_lim: The lower boundary (inclusive) for the elements (default is None). :param max_lim: The upper boundary (inclusive) for the elements (default is None). :returns: A new list containing elements within [min_lim, max_lim]. if not arr: return [] if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"# Pattern Matching Problem Objective Implement a function to determine if a string follows the same pattern provided, where there is a bijection between the pattern characters and non-empty substrings of the string. Function Signature ```python def pattern_match(pattern: str, string: str) -> bool: ``` Input - `pattern` (str): A string pattern consisting of lowercase letters (1 ≤ len(pattern) ≤ 20). - `string` (str): The input string consisting of lowercase letters (1 ≤ len(string) ≤ 1000). Output - Return `True` if the string follows the pattern, otherwise return `False`. Constraints - Each character in the pattern must map to a unique substring in the string. - If the resulting mappings do not adhere to a bijection, the function should return `False`. Example ```python pattern = \\"abab\\" string = \\"redblueredblue\\" # output: True pattern = \\"aaaa\\" string = \\"asdasdasdasd\\" # output: True pattern = \\"aabb\\" string = \\"xyzabcxzyabc\\" # output: False ``` Performance Requirement - Ensure your solution efficiently handles the provided constraint sizes. Context You are working on a parsing system that requires matching structured templates with provided textual inputs. This function will be used to ensure a uniform structure in the input data according to predefined template patterns.","solution":"def pattern_match(pattern: str, string: str) -> bool: def is_match(pattern, s, pat_to_str, str_to_pat): if not pattern: return not s p = pattern[0] if p in pat_to_str: mapped_str = pat_to_str[p] if s.startswith(mapped_str): return is_match(pattern[1:], s[len(mapped_str):], pat_to_str, str_to_pat) else: return False else: for i in range(1, len(s) - len(pattern) + 2): substring = s[:i] if substring in str_to_pat: continue pat_to_str[p] = substring str_to_pat[substring] = p if is_match(pattern[1:], s[i:], pat_to_str, str_to_pat): return True del pat_to_str[p] del str_to_pat[substring] return False return is_match(pattern, string, {}, {})"},{"question":"You need to implement a modified version of the `MovingAverage` class provided in the code snippets. The new version, `VariableMovingAverage`, should support variable window sizes, allowing the window size to be updated dynamically while still efficiently calculating the moving average. # Task 1. Define `VariableMovingAverage` class with the following methods: * `__init__(self)`: Initializes the data structure. * `next(self, val)`: Adds a new integer value `val` to the stream and returns the current moving average. * `update_window(self, size)`: Updates the window size to a new value `size`. If the current number of elements is greater than the new window size, remove the oldest elements first. # Input and Output - The method `next` should return the moving average of the last `size` number of elements passed through it. - The method `update_window` should alter the window size and adjust the current window elements accordingly. # Constraints - The integer `val` will be in the range [0, 10^4]. - Size for `update_window` will be in the range [1, 10^4]. # Example Below is an example of how your class should function: ```python # Initialize the moving average with a variable window vma = VariableMovingAverage() # Add elements print(vma.next(1)) # Output: 1.0 print(vma.next(10)) # Output: 5.5 print(vma.next(3)) # Output: 4.67 (or close enough with floating point precision) print(vma.next(5)) # Output: 4.75 # Update the window size vma.update_window(2) print(vma.next(8)) # Output: 6.5 (average of [5, 8]) print(vma.next(7)) # Output: 7.5 (average of [8, 7]) ``` Your solution should be optimized and handle edge cases well.","solution":"from collections import deque class VariableMovingAverage: def __init__(self): self.queue = deque() self.window_size = 1 self.window_sum = 0 def next(self, val: int) -> float: if len(self.queue) == self.window_size: self.window_sum -= self.queue.popleft() self.queue.append(val) self.window_sum += val return self.window_sum / len(self.queue) def update_window(self, size: int) -> None: self.window_size = size while len(self.queue) > size: self.window_sum -= self.queue.popleft()"},{"question":"You are tasked with writing a function to find the missing number in a list of unique integers from 0 to n. Your function should work in linear time and use constant space. Input: * A list of unique integers `nums` ranging from 0 to n. The integers are not sorted. * Example: `[4, 1, 3, 0, 6, 5, 2]`. Output: * The missing integer in the sequence. * If the list contains all integers from 0 to n, return `n+1`. * Example: `7`. Constraints: * The length of the list is `n`. * All integers in the list are unique and within the range [0..n]. * Performance requirements: * Time complexity: O(n) * Space complexity: O(1) Function Signature: ```python def find_missing_number(nums: List[int]) -> int: pass ``` # Example Test Cases: **Test Case 1**: * Input: `[4, 1, 3, 0, 6, 5, 2]` * Output: `7` **Test Case 2**: * Input: `[3, 0, 1]` * Output: `2` **Test Case 3**: * Input: `[0, 1, 2, 3, 4, 5, 6, 7]` * Output: `8` Edge Cases to Consider: * Empty array: `[]` * Array with one element: `[0]` * Sequence with last number missing: `[0, 1, 2, 3, 4, 5, 6, 8]` Ensure your implementation correctly handles these edge cases and provides the expected results.","solution":"def find_missing_number(nums): Finds the missing number in a list of unique integers from 0 to n. n = len(nums) total_sum = n * (n + 1) / 2 actual_sum = sum(nums) return int(total_sum - actual_sum)"},{"question":"# Question Context Bogo Sort is an intentionally inefficient sorting algorithm based on the generate-and-test paradigm. Given an array of integers, Bogo Sort repeatedly checks if the array is sorted and randomly shuffles it if it is not. Although highly impractical, this algorithm serves as a fascinating study in algorithm efficiency and randomness. Task Write a function `custom_bogo_sort(arr: List[int]) -> List[int]` that implements the Bogo Sort algorithm. The function should take a list of integers as input and return the list sorted in ascending order. Additionally, consider edge cases and performance constraints in your implementation. Requirements 1. Check if the list is sorted. 2. Randomly shuffle the list if it is not sorted. 3. Repeat until the list is sorted. 4. Return the sorted list. 5. Handle edge cases such as an empty list or an array with all identical elements. Function Signature ```python def custom_bogo_sort(arr: List[int]) -> List[int]: # your implementation here pass ``` Constraints 1. Input list size can be up to 100 elements. 2. Element values will be between -1000 and 1000. 3. Handling large lists efficiently is not the goal, but ensure the function doesn\'t run into infinite loops. Example ```python custom_bogo_sort([3, 1, 2]) # Output: [1, 2, 3] custom_bogo_sort([]) # Output: [] custom_bogo_sort([1, 1, 1]) # Output: [1, 1, 1] ```","solution":"import random from typing import List def is_sorted(arr: List[int]) -> bool: Helper function to check if the list is sorted in ascending order. return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) def custom_bogo_sort(arr: List[int]) -> List[int]: Sort the list using Bogo Sort algorithm while not is_sorted(arr): random.shuffle(arr) return arr"},{"question":"# KMP String Matching Implementation and Enhancement Given the KMP algorithm for string matching, your task is to enhance its functionality by implementing a function that, in addition to finding all positions where the pattern occurs in the text, also returns the total number of occurrences of the pattern, and the size of the largest prefix of the pattern which is also a suffix up to each character in the pattern. # Function Signature ```python def enhanced_knuth_morris_pratt(text: str, pattern: str) -> (List[int], int, List[int]): pass ``` # Input * `text`: a non-empty string (1 ≤ len(text) ≤ 10^5). * `pattern`: a non-empty string (1 ≤ len(pattern) ≤ 10^4). # Output * A tuple containing: 1. A list of starting indices where the pattern is found in the text. 2. An integer representing the total number of occurrences of the pattern in the text. 3. A list representing the pi table (longest prefix which is also a suffix for each prefix of the pattern). # Constraints * Input strings consist of ASCII characters. * You should ensure the function runs in O(N + M) time complexity. # Example ```python text = \'hello there hero!\' pattern = \'he\' enhanced_knuth_morris_pratt(text, pattern) # Expected output: ([0, 7, 12], 3, [0, 0]) ``` # Hints * Proper construction of the pi table is essential. * Ensure to handle cases where the pattern is not found in the text. # Guidance Focus on optimal construction and usage of the pi table to maintain the linear time complexity of the KMP algorithm.","solution":"from typing import List, Tuple def compute_pi_table(pattern: str) -> List[int]: # pi[i] is the length of the longest proper prefix which is also a suffix for substring pattern[0:i+1] pi = [0] * len(pattern) k = 0 for i in range(1, len(pattern)): while k > 0 and pattern[k] != pattern[i]: k = pi[k - 1] if pattern[k] == pattern[i]: k += 1 pi[i] = k return pi def enhanced_knuth_morris_pratt(text: str, pattern: str) -> Tuple[List[int], int, List[int]]: if not pattern or not text: return ([], 0, []) pi = compute_pi_table(pattern) match_positions = [] j = 0 # number of characters matched in pattern for i in range(len(text)): while j > 0 and text[i] != pattern[j]: j = pi[j - 1] if text[i] == pattern[j]: j += 1 if j == len(pattern): match_positions.append(i - j + 1) j = pi[j - 1] total_occurrences = len(match_positions) return (match_positions, total_occurrences, pi)"},{"question":"# String Search using Rabin-Karp Algorithm **Problem Statement:** You are provided with an implementation of the Rabin-Karp algorithm that searches for a given pattern (word) within a provided text. Your task is to extend this implementation to return **all** the starting indices of occurrences of the word in the text. # Function Signature ```python def search_all_occurrences(word: str, text: str) -> List[int]: pass ``` - **Input**: - `word (str)`: The pattern string which needs to be searched in the given text. - `text (str)`: The text in which you\'re searching for the pattern. - **Output**: - `List[int]`: List of starting indices of every occurrence of the word in the text. # Constraints: 1. The input strings `word` and `text` only consist of lowercase English letters (\'a\' to \'z\'). 2. The maximum length of `word` is 10^4. 3. The maximum length of `text` is 10^5. # Example: ```python # Example 1 search_all_occurrences(\\"abc\\", \\"ababcabc\\") # Output: [2, 5] # Example 2 search_all_occurrences(\\"a\\", \\"aaaaaa\\") # Output: [0, 1, 2, 3, 4, 5] # Example 3 search_all_occurrences(\\"abcd\\", \\"ababcabc\\") # Output: [] ``` # Instructions: 1. You need to utilize the provided rolling hash mechanism to update the substring hash efficiently. 2. Ensure the function handles edge cases such as when `word` or `text` are empty. 3. Optimize your implementation to handle large texts and patterns efficiently. 4. Implement your function in the provided function signature (`search_all_occurrences`).","solution":"def search_all_occurrences(word: str, text: str): Uses the Rabin-Karp algorithm to find all starting indices of the pattern string `word` in the provided `text`. if not word or not text: return [] word_len = len(word) text_len = len(text) if word_len > text_len: return [] base = 256 prime = 101 word_hash = 0 text_hash = 0 highest_pow = 1 result = [] for i in range(word_len - 1): highest_pow = (highest_pow * base) % prime for i in range(word_len): word_hash = (base * word_hash + ord(word[i])) % prime text_hash = (base * text_hash + ord(text[i])) % prime for i in range(text_len - word_len + 1): if word_hash == text_hash: match = True for j in range(word_len): if text[i + j] != word[j]: match = False break if match: result.append(i) if i < text_len - word_len: text_hash = (base * (text_hash - ord(text[i]) * highest_pow) + ord(text[i + word_len])) % prime if text_hash < 0: text_hash += prime return result"},{"question":"# Question Context: You are tasked with analyzing the connectivity of a social network, represented as a graph where nodes are users and edges are friendships between users. You need to determine which users are reachable from a particular user, and also check if it\'s possible to visit all users starting from that user. Problem Description: For this task, you need to implement two functions to traverse the graph using Depth First Search (DFS) and Breadth First Search (BFS). Additionally, you need to implement a function that checks if all nodes in the graph are reachable from a starting node. Function 1: `dfs_traverse(graph, start)` * **Input**: A dictionary `graph` representing the adjacency list of the graph, and the `start` node. * **Output**: A set of nodes that are reachable from the `start` node using DFS. Function 2: `bfs_traverse(graph, start)` * **Input**: A dictionary `graph` representing the adjacency list of the graph, and the `start` node. * **Output**: A set of nodes that are reachable from the `start` node using BFS. Function 3: `is_connected(graph, start)` * **Input**: A dictionary `graph` representing the adjacency list of the graph, and the `start` node. * **Output**: A boolean indicating whether all nodes are reachable from the `start` node (True) or not (False). Performance Constraints: - The graph can have up to (1000) nodes and (10000) edges. - The constraints on time complexity should be (O(V + E)). Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } # Using DFS print(dfs_traverse(graph, \'A\')) # Output: {\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'} # Using BFS print(bfs_traverse(graph, \'A\')) # Output: {\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'} # Check connectivity print(is_connected(graph, \'A\')) # Output: True ``` Implement these functions to verify their correctness against the provided example and any other edge cases you can think of.","solution":"def dfs_traverse(graph, start): Returns a set of nodes reachable from the start node using DFS. visited = set() def dfs(node): if node not in visited: visited.add(node) for neighbor in graph.get(node, []): dfs(neighbor) dfs(start) return visited def bfs_traverse(graph, start): Returns a set of nodes reachable from the start node using BFS. visited = set() queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.add(node) queue.extend([neighbor for neighbor in graph.get(node, []) if neighbor not in visited]) return visited def is_connected(graph, start): Returns a boolean indicating whether all nodes in the graph are reachable from the start node. reachable = bfs_traverse(graph, start) return len(reachable) == len(graph)"},{"question":"# Scenario Spellcheckers often need to suggest corrections for potentially misspelled words. One commonly used algorithm to measure how close two words are is the Edit Distance (or Levenshtein Distance) algorithm. Given two words, the edit distance between them is the minimum number of edit operations (insertions, deletions, substitutions) required to transform one word into the other. # Task Write a function `edit_distance(word_a, word_b)` that computes the edit distance between the two input words `word_a` and `word_b`. # Function Signature ```python def edit_distance(word_a: str, word_b: str) -> int: Compute the edit distance between word_a and word_b :param word_a: The first word (string) :param word_b: The second word (string) :return: An integer representing the minimum number of operations required ``` # Input - `word_a`: A string of length `n` (1 <= n <= 1000). - `word_b`: A string of length `m` (1 <= m <= 1000). # Output - An integer representing the minimum number of operations required to transform `word_a` into `word_b`. # Example ```python print(edit_distance(\\"FOOD\\", \\"MONEY\\")) # Output: 4 print(edit_distance(\\"INTENTION\\", \\"EXECUTION\\")) # Output: 5 ``` Note: - You can assume that both input strings are composed of uppercase English letters only (A-Z). - Your solution should efficiently compute the edit distance with the constraints provided. # Constraints - The function should handle edge cases such as one of the strings being empty. - Aim for O(length_a * length_b) time complexity.","solution":"def edit_distance(word_a: str, word_b: str) -> int: Compute the edit distance between word_a and word_b. :param word_a: The first word (string) :param word_b: The second word (string) :return: An integer representing the minimum number of operations required n, m = len(word_a), len(word_b) # DP table initialization dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill the first row and column with index values for i in range(n + 1): dp[i][0] = i for j in range(m + 1): dp[0][j] = j # Fill the table with the minimum edit distance for i in range(1, n + 1): for j in range(1, m + 1): if word_a[i - 1] == word_b[j - 1]: dp[i][j] = dp[i - 1][j - 1] # No operation required else: dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1) # Substitution return dp[n][m]"},{"question":"**Context**: You have been hired by a social networking company to analyze clusters of users who are all friends with each other. This analysis will help in determining closely-knit groups within the network, which can be useful for suggestions, targeted ads, and group activities. **Task**: Implement a function `find_all_cliques(edges)` that takes an undirected graph represented as an adjacency list and returns all maximal cliques in it. **Function Signature**: ```python def find_all_cliques(edges: dict) -> list: pass ``` **Input Format**: * `edges` (dict): Keys are vertex identifiers (strings or integers), and values are sets of adjacent vertices. **Output Format**: * List of lists, where each list represents a maximal clique in the graph. **Constraints**: * The number of vertices (n) will be (1 leq n leq 20). * Each key in `edges` will be a string representing the vertex. * The values corresponding to each key will be a set of strings, each representing adjacent vertices. **Performance Requirements**: * The solution should efficiently handle graphs up to the size constraint (n leq 20). **Example**: ```python edges = { \'1\': {\'2\', \'5\'}, \'2\': {\'1\', \'3\'}, \'3\': {\'2\', \'4\'}, \'4\': {\'3\', \'5\'}, \'5\': {\'1\', \'4\'} } Result: [[\'1\', \'2\'], [\'2\', \'3\'], [\'3\', \'4\'], [\'4\', \'5\'], [\'5\', \'1\']] ``` Additional Example: ```python edges = { \'A\': {\'B\', \'C\'}, \'B\': {\'A\', \'C\'}, \'C\': {\'A\', \'B\', \'D\'}, \'D\': {\'C\'}, \'E\': {} } Result: [[\'A\', \'B\', \'C\'], [\'C\', \'D\']] ```","solution":"from itertools import combinations def is_clique(edges, vertices): for v1, v2 in combinations(vertices, 2): if v2 not in edges[v1]: return False return True def find_all_cliques(edges: dict) -> list: vertices = list(edges.keys()) n = len(vertices) max_cliques = [] # Check all subsets of vertices to find all cliques for k in range(1, n + 1): for subset in combinations(vertices, k): if is_clique(edges, subset): max_cliques.append(list(subset)) return max_cliques"},{"question":"Scenario: You are working on optimizations for a cloud-based service that handles large data processing tasks. Given the importance of performance in handling huge datasets, you need to ensure that the service\'s sorting functionality is as efficient and reliable as possible. Task: Implement a function `merge_sort(arr)` that takes a list of integers and sorts them using the merge sort algorithm. Your implementation should precisely follow the principles of merge sort, ensuring that it works efficiently for very large datasets. **Function Signature**: ```python def merge_sort(arr: List[int]) -> List[int]: ``` **Input**: * A list of integers `arr` (0 ≤ len(arr) ≤ 10^5), where each integer is in the range of -10^6 to 10^6. **Output**: * A sorted list of integers. Constraints: * Ensure your function has a time complexity of O(n log n). * Your function should not use any in-built sort functions. * You can assume enough memory is available for the sorting operations. Examples: 1. **Example 1**: - Input: `[3, 6, 2, 8, 4, 10, 1]` - Output: `[1, 2, 3, 4, 6, 8, 10]` 2. **Example 2**: - Input: `[5, 3, 8, 4, 2]` - Output: `[2, 3, 4, 5, 8]` 3. **Example 3**: - Input: `[12, 11, 13, 5, 6, 7]` - Output: `[5, 6, 7, 11, 12, 13]` **Implementation Detail**: * You are required to implement both the `merge_sort` function and the `merge` helper function if needed. * Ensure to handle edge cases such as an empty list or lists with a single element. * Optimize for both time and space where applicable.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the merge sort algorithm. if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: sorted_array = [] i = j = 0 # Merge the two halves together while i < len(left) and j < len(right): if left[i] < right[j]: sorted_array.append(left[i]) i += 1 else: sorted_array.append(right[j]) j += 1 # If there are remaining elements in left or right, append them sorted_array.extend(left[i:]) sorted_array.extend(right[j:]) return sorted_array mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"# Stutter Stack Duplicator Objective Write a Python function to duplicate each element of a stack such that every element is replaced by two occurrences of itself. Function Signature: ```python def stutter(stack: list) -> list: ``` Input * A list `stack` representing the stack elements, with the top of the stack being the last element in the list. Output * Return a list representing the new stack where each element of the original stack is duplicated. Example ```python stack = [3, 7, 1, 14, 9] print(stutter(stack)) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` Constraints - Do not use any additional list or deque data structures. You may use primitive variables and counters. - Maintain the order of elements as mentioned in the problem statement. - Handle edge cases like an empty stack appropriately. Hint Make use of the intrinsic properties of the stack (LIFO) to manage element duplication without violating the constraints.","solution":"def stutter(stack: list) -> list: Duplicates each element of the stack provided such that every element is replaced by two occurrences of itself. # Work backwards through the list index = len(stack) - 1 while index >= 0: element = stack[index] # Duplicate the element by inserting it stack.insert(index + 1, element) # Move to the next element in the original stack index -= 1 return stack"},{"question":"Imagine you are designing a text processing system to annotate certain words with predefined symbols for a language processing task. You have been provided with an array of words and an array of symbols. Your task is to annotate each word by surrounding the longest matching symbol found within the word in square brackets. If no symbol matches, the word remains unchanged. # Requirements: 1. If a word matches more than one symbol, the longest matching symbol should be chosen. 2. The symbols and words are case-sensitive. 3. If no symbol matches any part of the word, the word should remain unchanged. 4. The replacement should be performed only once per word. # Input/Output Specification: * **Input**: - An array of strings `words` containing the words to be annotated. - An array of strings `symbols` containing the symbols to be searched and matched within the words. * **Output**: - Return an array of strings where each word in the `words` array is replaced based on the matching algorithm described. # Example: ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] # Expected output: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` # Constraints: 1. 1 <= len(words), len(symbols) <= 10^3 2. 1 <= len(word), len(symbol) <= 100 # Function Signature: ```python def annotate_words(words: list, symbols: list) -> list: pass ``` # Performance Requirements: - The solution should efficiently handle the above constraints without significant waiting delays. - The space complexity should be manageable within the given constraints. # Implementation Tips: - Construct a Trie from the symbols array to efficiently match substrings. - Traverse each word to find and replace the longest possible match using the Trie. - Only one replacement per word should be done.","solution":"def annotate_words(words: list[str], symbols: list[str]) -> list[str]: Annotate each word by surrounding the longest matching symbol found within the word in square brackets. def build_trie(words): root = {} for word in words: node = root for char in word: if char not in node: node[char] = {} node = node[char] node[\'\'] = word return root def search_in_trie(word, trie): longest_match = \\"\\" for i in range(len(word)): node = trie current_match = \\"\\" for j in range(i, len(word)): if word[j] in node: node = node[word[j]] current_match += word[j] if \'\' in node: if len(current_match) > len(longest_match): longest_match = current_match else: break return longest_match trie = build_trie(symbols) result = [] for word in words: longest_symbol = search_in_trie(word, trie) if longest_symbol: word = word.replace(longest_symbol, f\'[{longest_symbol}]\', 1) result.append(word) return result"},{"question":"# Question: Alternative Heapsort Implementation Context: You have been given coding snippets for heap sort which utilize max heap and min heap structures. Your task is to implement an alternative version of heap sort which provides an additional feature: Sorting an array either in ascending or descending order based on a flag parameter. Task: Write a function `heap_sort(arr: List[int], ascending: bool = True) -> List[int]` that sorts the array using heap sort. The function should: * Use a max heap if `ascending` is `True` (default behavior). * Use a min heap if `ascending` is `False`. * Sort the array in-place and return the sorted array. Input: * `arr` (List[int]): The array to be sorted, with `1 <= len(arr) <= 10^5`. * `ascending` (bool): Flag indicating sorting order. `True` for ascending, `False` for descending. Output: * Return the sorted array (List[int]). Constraints: * You must implement the heap sort in-place with O(n log n) time complexity. * Utilize an appropriate heap structure based on the `ascending` flag. Example: ```python >>> heap_sort([4, 10, 3, 5, 1]) [1, 3, 4, 5, 10] >>> heap_sort([4, 10, 3, 5, 1], ascending=False) [10, 5, 4, 3, 1] ``` Performance Requirements: * Your function should handle the constraints efficiently and avoid redundant operations.","solution":"from typing import List def heap_sort(arr: List[int], ascending: bool = True) -> List[int]: def heapify(arr, n, i, ascending): if ascending: largest = i l = 2 * i + 1 r = 2 * i + 2 if l < n and arr[i] < arr[l]: largest = l if r < n and arr[largest] < arr[r]: largest = r if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest, ascending) else: smallest = i l = 2 * i + 1 r = 2 * i + 2 if l < n and arr[i] > arr[l]: smallest = l if r < n and arr[smallest] > arr[r]: smallest = r if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] heapify(arr, n, smallest, ascending) n = len(arr) # Build max or min heap based on ascending flag for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i, ascending) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0, ascending) return arr"},{"question":"# Isomorphic Strings Check Problem Statement: You are given two strings, `s` and `t`, and you need to determine if they are isomorphic. Two strings are said to be isomorphic if each character in `s` can be replaced to form string `t`. Each occurrence of a character in `s` must be replaced with a corresponding character in `t` while preserving the order, and ensuring no two characters from `s` map to the same character in `t`. Function Signature: ```python def is_isomorphic(s: str, t: str) -> bool: pass ``` Input: - `s` : A string of length `n` where `1 <= n <= 10^4` - `t` : A string of length `m` where `1 <= m <= 10^4` Output: - Return `True` if the two strings `s` and `t` are isomorphic. - Return `False` otherwise. Constraints: - The strings `s` and `t` will consist solely of lowercase English letters. Examples: 1. Input: `s = \\"egg\\"`, `t = \\"add\\"` Output: `True` 2. Input: `s = \\"foo\\"`, `t = \\"bar\\"` Output: `False` 3. Input: `s = \\"paper\\"`, `t = \\"title\\"` Output: `True` 4. Input: `s = \\"ab\\"`, `t = \\"aa\\"` Output: `False` Scenario: Consider you are developing a text processing system that needs to ensure certain patterns are preserved despite transformations. You need to verify if two schemas, represented as strings, can map directly to each other without any conflicts, maintaining pattern consistency. Implement the function `is_isomorphic` that verifies if the given strings abide by these transformation rules and returns the appropriate boolean result. Note: - Ensure to handle edge cases such as strings of different lengths immediately. - When mapping characters, ensure that each character in `s` maps uniquely to one in `t` and vice versa by using auxiliary structures like dictionaries and sets if needed.","solution":"def is_isomorphic(s: str, t: str) -> bool: # If lengths of the strings are not the same, they cannot be isomorphic. if len(s) != len(t): return False # Create two dictionaries to keep track of the mappings. s_to_t = {} t_to_s = {} # Check each character pair in the strings. for char_s, char_t in zip(s, t): if char_s not in s_to_t: s_to_t[char_s] = char_t if char_t not in t_to_s: t_to_s[char_t] = char_s # If at any point the mapping doesn\'t match, return False. if s_to_t[char_s] != char_t or t_to_s[char_t] != char_s: return False return True"},{"question":"# Knapsack Problem with Variation Problem Statement You are given a knapsack with a maximum weight capacity, and a set of items, each with a specified weight and value. Your task is to maximize the total value of items that can be included in the knapsack without exceeding its capacity. Furthermore, you are required to track and return the list of items that contribute to this maximum value. **Function Signature:** ```python def knapsack_with_items(items: List[Tuple[int, int]], capacity: int) -> Tuple[int, List[Tuple[int, int]]]: Determines the maximum value achievable with the given knapsack capacity and the list of items and also returns the list of items included to achieve that maximum value. :param items: List of Tuples where each tuple is (value, weight). :param capacity: Integer representing the maximum capacity of the knapsack. :return: Tuple consisting of an integer (maximum value) and a list of Tuples (items included). ``` Input: * `items`: A list of tuples where each tuple contains two integers: - The first integer is the value of the item. - The second integer is the weight of the item. * `capacity`: An integer representing the maximum weight capacity of the knapsack, represented as M. Output: * A tuple containing: - An integer representing the maximum value attainable without exceeding the given capacity. - A list of tuples representing the items included in the knapsack to achieve this maximum value. Constraints: * ( 1 leq text{len(items)} leq 1000 ) * ( 1 leq text{value of items}, text{weight of items} leq 1000 ) * ( 1 leq text{capacity} leq 10000 ) Example: ```python items = [(60, 5), (50, 3), (70, 4), (30, 2)] capacity = 5 knapsack_with_items(items, capacity) # Output: (80, [(50, 3), (30, 2)]) # Note that order doesn\'t matter ``` # Additional Notes: 1. Consider both space and time complexity as you implement your function. 2. Handle edge cases as specified in the analysis. 3. Ensure optimal solutions using dynamic programming techniques elaborated in the analysis.","solution":"from typing import List, Tuple def knapsack_with_items(items: List[Tuple[int, int]], capacity: int) -> Tuple[int, List[Tuple[int, int]]]: n = len(items) dp = [[0] * (capacity + 1) for _ in range(n + 1)] # Fill the DP table for i in range(1, n + 1): for w in range(capacity + 1): value, weight = items[i - 1] if weight <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weight] + value) else: dp[i][w] = dp[i - 1][w] # Backtrack to find the items that contributed to this maximum value max_value = dp[n][capacity] w = capacity selected_items = [] for i in range(n, 0, -1): if dp[i][w] != dp[i - 1][w]: value, weight = items[i - 1] selected_items.append(items[i - 1]) w -= weight return max_value, selected_items"},{"question":"# 0/1 Knapsack Problem **Scenario**: Your friend Tim runs an online store and has received a customized knapsack bag for his business to carry items for delivery. However, the knapsack has a weight limit for what it can carry. Tim wants to make sure he uses the knapsack efficiently to carry items with the maximum total value without exceeding the weight limit. He needs your help to determine the best combination of items he can carry using his knapsack. **Task**: Write a function `max_knapsack_value` that takes a list of items and the maximum weight capacity of the knapsack and returns the maximum value of items that can be carried. **Function Signature**: ```python def max_knapsack_value(items: List[Tuple[int, int]], capacity: int) -> int: pass ``` **Input and Output**: * **Input**: * A list of tuples where each tuple contains two integers representing `value` and `weight` of an item (`items: List[Tuple[int, int]]`). * An integer representing the knapsack\'s weight capacity (`capacity: int`). * **Output**: * An integer which is the maximum summed value of items that can fit into the knapsack without exceeding the weight limit. **Constraints**: * The number of items won\'t exceed 1000. * The weight capacity of the knapsack won\'t exceed 10^4. * The value and weight of each item are positive integers. **Example**: ```python items = [(60, 5), (50, 3), (70, 4), (30, 2)] capacity = 5 assert max_knapsack_value(items, capacity) == 80 ``` **Notes**: * You must not use the built-in class `Item`. Stick to handling tuples as given in the input format. Good luck! This problem tests your understanding of dynamic programming and the classic knapsack problem scenario.","solution":"from typing import List, Tuple def max_knapsack_value(items: List[Tuple[int, int]], capacity: int) -> int: # Initialize a DP array where dp[w] represents the maximum value of items with weight capacity w dp = [0] * (capacity + 1) # Iterate over each item for value, weight in items: # Iterate over the DP array backwards from capacity to weight # This ensures we don\'t overwrite results from the same iteration for w in range(capacity, weight - 1, -1): dp[w] = max(dp[w], dp[w - weight] + value) # The last entry in the DP array will have the maximum value we can achieve with the given capacity return dp[capacity]"},{"question":"# Minimum Cost to Connect All Nodes You are given a weighted, connected, undirected graph with `n` nodes and `m` edges. Each edge connects two nodes with a specific weight. Your goal is to find the minimum cost required to connect all the nodes using an MST (Minimum Spanning Tree). # Task Implement the `minimum_cost_to_connect_all_nodes` function that computes and returns the minimum cost required to connect all the nodes. Function Signature ```python def minimum_cost_to_connect_all_nodes(vertex_count: int, edge_list: List[Tuple[int, int, int]]) -> int: ``` * `vertex_count` (int): Number of vertices in the graph. * `edge_list` (List[Tuple[int, int, int]]): List of edges, where each edge is represented as a tuple of three integers `(u, v, w)` - the two nodes `u` and `v` it connects and its weight `w`. Output * Returns the minimum cost (int) to connect all nodes. # Constraints * 1 <= vertex_count <= 1000 * 0 <= len(edge_list) <= 100000 * 1 <= w <= 10000 # Example ```python edges = [(1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6)] vertex_count = 5 print(minimum_cost_to_connect_all_nodes(vertex_count, edges)) # Output: 14 edges = [(2, 1, 20), (3, 1, 20), (2, 3, 100)] vertex_count = 3 print(minimum_cost_to_connect_all_nodes(vertex_count, edges)) # Output: 40 ``` # Note - Ensure to handle 0-based indexing when initializing `DisjointSet` and processing edges. - Remember to sort the edges by their weight first before applying the Kruskal\'s algorithm. - Use path compression and union by rank for efficient disjoint set operations.","solution":"from typing import List, Tuple class DisjointSet: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def minimum_cost_to_connect_all_nodes(vertex_count: int, edge_list: List[Tuple[int, int, int]]) -> int: # Sort edges based on their weight edge_list.sort(key=lambda x: x[2]) # Create a disjoint set dsu = DisjointSet(vertex_count) # Kruskal\'s algorithm to find MST minimum_cost = 0 for u, v, weight in edge_list: root_u = dsu.find(u - 1) root_v = dsu.find(v - 1) if root_u != root_v: dsu.union(u - 1, v - 1) minimum_cost += weight return minimum_cost"},{"question":"# Bipartite Graph Checker You are working on a graph-based application and need to determine if a given undirected graph is bipartite. A bipartite graph is a graph whose vertices can be divided into two disjoint and independent sets U and V such that every edge connects a vertex in U to one in V. # Task Write a function `is_bipartite_graph` to check if a given graph is bipartite. Function Specifications - **Function Name**: `is_bipartite_graph` - **Input**: - `adj_list`: A list of lists where `adj_list[i][j]` is `1` if there is an edge between vertex `i` and vertex `j`, otherwise `0`. - **Output**: - `True` if the graph is bipartite. - `False` otherwise. # Constraints - The graph contains no more than 1000 vertices. - The adjacency list does not contain negative weights and is symmetric (undirected graph). # Example Input ```python adj_list = [ [0, 1, 0, 0, 1], [1, 0, 1, 1, 1], [0, 1, 0, 1, 0], [0, 1, 1, 0, 0], [1, 1, 0, 0, 0] ] ``` Output ```python False ``` Explanation: The given graph has odd-length cycles, hence it is not bipartite. # Notes - Ensure the function runs efficiently within O(|V| + |E|) time complexity. - Consider edge cases such as graphs with no edges, graphs with self-loops, and disconnected graphs.","solution":"def is_bipartite_graph(adj_list): Checks if the given undirected graph is bipartite. Parameters: adj_list (list of list of int): Adjacency matrix representing the graph Returns: bool: True if the graph is bipartite, False otherwise n = len(adj_list) colors = [-1] * n # -1 indicates uncolored, 0 and 1 represent two colors def bfs(start): queue = [start] colors[start] = 0 # Start coloring with 0 while queue: node = queue.pop(0) for neighbor in range(n): if adj_list[node][neighbor] == 1: if colors[neighbor] == -1: # Not colored colors[neighbor] = 1 - colors[node] queue.append(neighbor) elif colors[neighbor] == colors[node]: return False return True for i in range(n): if colors[i] == -1 and not bfs(i): # Uncolored node, perform BFS return False return True"},{"question":"Context: You are working on a recommendation system where you need to measure the similarity between different user preferences represented as vectors. Given two vectors, you need to calculate their cosine similarity to determine their similarity. Task: Write a function `calculate_cosine_similarity(vec1, vec2)` that calculates the cosine similarity between two input vectors `vec1` and `vec2`. Function Signature: ```python def calculate_cosine_similarity(vec1: List[float], vec2: List[float]) -> float: pass ``` Input and Output: - **Input**: - `vec1` (list of floats): First input vector. - `vec2` (list of floats): Second input vector. - **Output**: - A float representing the cosine similarity between `vec1` and `vec2`. Constraints: - The input vectors `vec1` and `vec2` will have the same length and will not be empty. - Each element in the vectors will be a floating-point number or integer. Requirements: 1. Use the L2 norm to calculate the magnitude of the vectors. 2. Calculate the dot product of the two vectors. 3. Implement appropriate error handling for invalid inputs (e.g., different lengths). 4. Your implementation should have a time complexity of O(n). Example: ```python from typing import List def calculate_cosine_similarity(vec1: List[float], vec2: List[float]) -> float: import math if len(vec1) != len(vec2): raise ValueError(\\"The two vectors must be of the same length.\\") norm_a = math.sqrt(sum(x ** 2 for x in vec1)) norm_b = math.sqrt(sum(x ** 2 for x in vec2)) dot_product = sum(a * b for a, b in zip(vec1, vec2)) return dot_product / (norm_a * norm_b) # Example usage: cosine_similarity = calculate_cosine_similarity([1, 1, 1], [1, 2, -1]) print(cosine_similarity) # Should output: 0.47140452079103173 ``` Notes: Ensure that your function handles edge cases such as zero vectors, and provides meaningful error messages if the inputs are invalid.","solution":"from typing import List import math def calculate_cosine_similarity(vec1: List[float], vec2: List[float]) -> float: Calculate the cosine similarity between two vectors. Args: vec1 (List[float]): The first vector. vec2 (List[float]): The second vector. Returns: float: The cosine similarity between the two vectors. Raises: ValueError: If the vectors are not of the same length. if len(vec1) != len(vec2): raise ValueError(\\"The two vectors must be of the same length.\\") norm_a = math.sqrt(sum(x ** 2 for x in vec1)) norm_b = math.sqrt(sum(x ** 2 for x in vec2)) if norm_a == 0 or norm_b == 0: return 0.0 dot_product = sum(a * b for a, b in zip(vec1, vec2)) return dot_product / (norm_a * norm_b)"},{"question":"# Problem Description You are required to implement a function that adds one to an integer represented as an array of digits. The digits are stored in big-endian format, such that the most significant digit is at the head of the list. Implement this function in a performant way, considering both time and space complexities. Make sure to account for and handle edge cases appropriately. # Function Signature ```python def add_one_to_digits(digits: List[int]) -> List[int]: Adds one to the integer represented by the list of digits. :param digits: A list of integers where each integer is a digit of a larger non-negative number. :return: A new list representing the given number incremented by one. ``` # Input * A single list `digits` where (1 leq text{len(digits)} leq 10^4) * Each element in the list `digits` is an integer in the range 0-9 inclusive. # Output * A new list representing the given number incremented by one. # Constraints * The function should efficiently handle cases where the number of digits is large (up to 10,000 digits). * The solution should minimize usage of additional memory. * Edge cases such as an array containing only the digit 9 should be correctly managed. # Examples 1. Input: `[1, 2, 3]` Output: `[1, 2, 4]` 2. Input: `[9, 9, 9]` Output: `[1, 0, 0, 0]` 3. Input: `[0]` Output: `[1]` # Additional Notes * Consider the implications of overflow in the context of digit carrying. * Think about potential optimizations to reduce memory footprint and time complexity.","solution":"def add_one_to_digits(digits): Adds one to the integer represented by the list of digits. :param digits: A list of integers where each integer is a digit of a larger non-negative number. :return: A new list representing the given number incremented by one. n = len(digits) for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 # If we are here it means all the digits were 9 return [1] + digits"},{"question":"# Question: Implement an Enhanced Caesar Cipher **Context**: Julius Caesar\'s cipher is a basic encryption technique, but it can be limited due to its simplicity and security issues. We want to enhance this classical cipher to handle both positive and negative shift values and maintain non-alphabetic characters as is. **Objective**: Write a function `enhanced_caesar_cipher(s: str, k: int) -> str` that takes a string `s` and an integer `k` representing the shift value. The function should return a new string where each alphabetic character in `s` is shifted by `k` positions while keeping non-alphabetic characters unchanged. Both lower and upper case letters should be handled correctly. **Input/Output Format**: - **Input**: - `s`: A string containing the original message (1 ≤ len(s) ≤ 10^4). - `k`: An integer representing the shift value (-10^5 ≤ k ≤ 10^5). - **Output**: - A string containing the encrypted message. **Constraints**: - The string can contain any printable ASCII characters, but only English alphabetic characters (both lowercase and uppercase) should be shifted. - If the shift value `k` is positive, shift to the right; if `k` is negative, shift to the left. **Example**: ```python # Example 1 s1 = \\"Hello, World!\\" k1 = 3 print(enhanced_caesar_cipher(s1, k1)) # Output: \\"Khoor, Zruog!\\" # Example 2 s2 = \\"Python-123!\\" k2 = -3 print(enhanced_caesar_cipher(s2, k2)) # Output: \\"Msolkf-123!\\" # Example 3 s3 = \\"abcXYZ\\" k3 = 26 print(enhanced_caesar_cipher(s3, k3)) # Output: \\"abcXYZ\\" ``` **Performance Requirements**: - Your solution should efficiently handle the upper limit of the input constraints. **Guidelines**: - Focus on proper handling of both positive and negative shifts. - Ensure non-alphabetic characters remain unchanged in the output. - Make sure to handle large shifts efficiently by reducing them within the range of 0-25.","solution":"def enhanced_caesar_cipher(s: str, k: int) -> str: Encrypts the input string `s` using an enhanced Caesar cipher with shift value `k`. Parameters: s (str): The original message. k (int): The shift value. Returns: str: The encrypted message. def shift_char(c, k): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + k) % 26 + ord(\'a\')) if \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + k) % 26 + ord(\'A\')) return c k = k % 26 # Reduce k within the range of 0-25 for efficient handling return \'\'.join(shift_char(char, k) for char in s)"},{"question":"You are tasked with implementing a function to verify two conditions for a given pair of integers: 1. Whether these two integers are co-prime (i.e., their greatest common divisor is 1). 2. If they are co-prime, find their modular inverse. # Function Specification Implement the function `modular_inverse(a: int, m: int) -> [bool, int]` that takes two integers `a` and `m` and returns: - A boolean indicating whether `a` and `m` are coprime. - If they are coprime, the modular inverse of `a` under modulo `m`. If they are not coprime, return -1 as the modular inverse value. # Input * `a`: An integer. * `m`: An integer. # Output * `[bool, int]`: A list where the first element is a boolean indicating if `a` and `m` are coprime, and the second element is the modular inverse of `a` under modulo `m`, or -1 if they are not coprime. # Constraints * The inputs `a` and `m` will be integers such that (1 leq a, m leq 10^9). # Example ```python assert modular_inverse(3, 11) == [True, 4] assert modular_inverse(10, 20) == [False, -1] ``` # Explanation 1. `modular_inverse(3, 11)` returns `[True, 4]` because 3 and 11 are coprime and the modular inverse of 3 under modulo 11 is 4 (3 * 4 % 11 = 1). 2. `modular_inverse(10, 20)` returns `[False, -1]` because 10 and 20 are not coprime (gcd(10, 20) ≠ 1).","solution":"def gcd(a, b): while b: a, b = b, a % b return a def modular_inverse(a, m): Returns whether a and m are coprime and the modular inverse of a under modulo m. If they are not coprime, returns -1 as the modular inverse. if gcd(a, m) != 1: return [False, -1] # Using the Extended Euclidean Algorithm def extended_gcd(aa, mm): if mm == 0: return (aa, 1, 0) g, x1, y1 = extended_gcd(mm, aa % mm) x = y1 y = x1 - (aa // mm) * y1 return (g, x, y) g, x, y = extended_gcd(a, m) mod_inverse = x % m return [True, mod_inverse]"},{"question":"Objective Implement a function to encode a list of positive integers using Elias Gamma and Elias Delta codes and verify their correctness by decoding the encoded results back to integers. Description Write the functions `elias_gamma_encode`, `elias_delta_encode`, `elias_gamma_decode`, and `elias_delta_decode` to encode a list of integers with Elias Gamma and Elias Delta methods and decode the results back into the original integers. # Functions 1. **Encoding Functions**: - `def elias_gamma_encode(numbers: List[int]) -> List[str]:` - **Input**: List of positive integers. - **Output**: List of Elias Gamma coded strings for each input integer. - `def elias_delta_encode(numbers: List[int]) -> List[str]:` - **Input**: List of positive integers. - **Output**: List of Elias Delta coded strings for each input integer. 2. **Decoding Functions**: - `def elias_gamma_decode(codes: List[str]) -> List[int]:` - **Input**: List of Elias Gamma coded strings. - **Output**: List of decoded integers. - `def elias_delta_decode(codes: List[str]) -> List[int]:` - **Input**: List of Elias Delta coded strings. - **Output**: List of decoded integers. Requirements * **Encoding Input/output Formats**: - A list of positive integers, each integer `i` should be encoded into an Elias Gamma or Delta encoded string. - A list of encoded strings with Elias Gamma or Delta codes. * **Decoding Input/output Formats**: - A list of Elias Gamma or Delta encoded strings. - Output list of positive integers that correspond to the encoded strings. * **Constraints**: - 1 ≤ len(numbers) ≤ 1000 - 1 ≤ number ≤ 10^6 * **Performance requirements**: - Must handle up to 1000 integers efficiently. # Example ```python # Example for Elias Gamma Encoding and Decoding numbers = [10, 20, 30] encoded = elias_gamma_encode(numbers) # encoded -> [\'001010\', \'00110100\', \'00111110\'] decoded = elias_gamma_decode(encoded) # decoded -> [10, 20, 30] # Example for Elias Delta Encoding and Decoding numbers = [10, 20, 30] encoded = elias_delta_encode(numbers) # encoded -> [\'0001010\', \'000110100\', \'0001111110\'] decoded = elias_delta_decode(encoded) # decoded -> [10, 20, 30] ``` Ensure thorough testing with edge cases and large values to confirm correctness and performance.","solution":"def to_binary(n): return bin(n)[2:] def elias_gamma_encode(numbers): encoded = [] for number in numbers: binary_repr = to_binary(number) length = len(binary_repr) unary_repr = \'0\' * (length - 1) + \'1\' encoded.append(unary_repr + binary_repr[1:]) return encoded def elias_gamma_decode(codes): decoded = [] for code in codes: length = 0 while code[length] == \'0\': length += 1 length += 1 binary_repr = \'1\' + code[length:(2 * length - 1)] decoded.append(int(binary_repr, 2)) return decoded def elias_delta_encode(numbers): encoded = [] for number in numbers: binary_repr = to_binary(number) length_of_binary_repr = len(binary_repr) len_in_binary = to_binary(length_of_binary_repr) length_of_len_in_binary = len(len_in_binary) unary_repr = \'0\' * (length_of_len_in_binary - 1) + \'1\' encoded.append(unary_repr + len_in_binary[1:] + binary_repr[1:]) return encoded def elias_delta_decode(codes): decoded = [] for code in codes: length = 0 while code[length] == \'0\': length += 1 length += 1 len_in_binary = \'1\' + code[length:(2 * length - 1)] len_of_binary_repr = int(len_in_binary, 2) binary_repr = \'1\' + code[(2 * length - 1):(2 * length - 1 + len_of_binary_repr - 1)] decoded.append(int(binary_repr, 2)) return decoded"},{"question":"# Question Statement You are given a sorting algorithm called Bogo Sort which sorts an array by repeatedly shuffling it until it is sorted. The algorithm is highly inefficient but serves as a theoretical model for understanding randomness in sorting. Task Write a function `find_maximum_bogo_sort_iterations(arr)` that calculates the maximum number of iterations Bogo Sort takes to sort the input array `arr` in a given number of trials. Here, one iteration is defined as one complete shuffle of the array plus a check if the array is sorted. Use the following prototype: ```python def find_maximum_bogo_sort_iterations(arr: list, trials: int) -> int: ``` # Input * `arr` - A list of integers to be sorted. (1 ≤ len(arr) ≤ 10) * `trials` - An integer representing the number of simulation trials to run. (1 ≤ trials ≤ 1000) # Output * An integer representing the maximum number of iterations Bogo Sort took among all trials to sort the array. # Examples ```python print(find_maximum_bogo_sort_iterations([3, 1, 2], 100)) # Output might be a large number based on the trials print(find_maximum_bogo_sort_iterations([1, 2, 3], 100)) # Output should typically be 1 ``` # Note - Ensure to carefully randomize the array during each Bogo Sort iteration. - Your function should handle edge cases like already sorted array and reverse sorted array within the given input constraints.","solution":"import random def is_sorted(arr): Checks if a given array is sorted in non-decreasing order. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def bogo_sort(arr): Performs Bogo Sort on the array and returns the number of iterations. Bogo Sort shuffles the array until it finds it in sorted order. iterations = 0 while not is_sorted(arr): random.shuffle(arr) iterations += 1 return iterations def find_maximum_bogo_sort_iterations(arr, trials): Finds the maximum number of iterations Bogo Sort took among all trials to sort the array. max_iterations = 0 for _ in range(trials): copied_arr = arr[:] iterations = bogo_sort(copied_arr) if iterations > max_iterations: max_iterations = iterations return max_iterations"},{"question":"Context You are given two singly linked lists that potentially intersect at some node. The intersection means that the lists share a common node, and from that point onwards, they continue as a single combined list. Write a function to find and return the intersecting node. If the linked lists do not intersect, return `None`. The node is identified by its reference, not just by its value. Function Signature ```python def get_intersection_node(headA: \'Node\', headB: \'Node\') -> \'Node\': ``` Input - `headA`: The head node of the first linked list. - `headB`: The head node of the second linked list. Output - Return the intersecting node if the two linked lists intersect, otherwise return `None`. Constraints - The linked lists must retain their original structure after the function call. - Each list node contains an integer value and a `next` pointer to the next node. - Nodes are uniquely identified by their memory reference. Example Consider the following linked lists: ```plaintext 1 -> 3 -> 5 7 -> 9 -> 11 / 2 -> 4 -> 6 ``` If you call `get_intersection_node(headA, headB)`, where `headA` represents the head node of the list starting with node `1`, and `headB` represents the head node starting with node `2`, the function should return the node `7` (i.e., the intersection point). Note You may create helper functions as needed to complete the task. Write a complete solution including class and test cases.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def get_intersection_node(headA: Node, headB: Node) -> Node: if not headA or not headB: return None # Create two pointers, one for each list a_ptr, b_ptr = headA, headB # Ensure both pointers traverse the same total length when combined while a_ptr is not b_ptr: # Move each pointer to the next node, or to the head of the other list if reaching the end a_ptr = a_ptr.next if a_ptr else headB b_ptr = b_ptr.next if b_ptr else headA # Either both are None (no intersection) or both point to the intersection node return a_ptr"},{"question":"Scenario: You are part of a software development team working on a text manipulation library. One of the features is to rotate the characters in a string to the right by a given number of positions. Each rotation moves the first character to the end of the string. Task: Implement a function `rotate_string(s: str, k: int) -> str` that takes a string `s` and an integer `k`, and returns the string rotated to the right by `k` positions. Input: - `s`: a string consisting of lower-case alphabets (1 <= len(s) <= 10^5). - `k`: a non-negative integer (0 <= k <= 10^9). Output: - Returns a string rotated to the right by `k` positions. Constraints: 1. The function must run within O(n) time complexity where n is the length of the string. 2. The function should be able to handle very large values of `k` efficiently. Example: 1. `rotate_string(\\"hello\\", 2)` returns `\\"lohel\\"` 2. `rotate_string(\\"hello\\", 5)` returns `\\"hello\\"` 3. `rotate_string(\\"hello\\", 6)` returns `\\"ohell\\"` 4. `rotate_string(\\"hello\\", 7)` returns `\\"lohel\\"` 5. `rotate_string(\\"hello\\", 102)` returns `\\"lohel\\"` Notes: - Consider edge cases such as when `k` is zero, when `k` is a multiple of the length of the string, or when the string is of minimal length. Function Signature: ```python def rotate_string(s: str, k: int) -> str: # your implementation here ```","solution":"def rotate_string(s: str, k: int) -> str: Rotates the characters in the string s to the right by k positions. n = len(s) if n == 0 or k == 0: return s k = k % n # Handle large values of k return s[-k:] + s[:-k]"},{"question":"# Question: Zigzag Level Order Traversal of a Binary Tree You are given a binary tree structure represented by its root node. Your task is to implement a function that performs zigzag level order traversal on the binary tree. In zigzag traversal, nodes at the same level are visited from left to right, then right to left for the next level, and this pattern continues to alternate for each subsequent level. Write a function `zigzag_level(root)` that takes the root of a binary tree and returns a list of lists, where each inner list contains the node values at that level in zigzag order. Input: * The input will be the `root` object representing the root node of the binary tree. Each node contains: * `val`: The integer value of the node. * `left`: The left child node (or `None` if there is no left child). * `right`: The right child node (or `None` if there is no right child). Output: * Return a list of lists. Each inner list should contain the values of the nodes at the corresponding level, in zigzag order. Constraints: * The number of nodes in the tree is in the range `[0, 10^4]`. * `-100 <= Node.val <= 100` # Example: Given binary tree [3,9,20,null,null,15,7]: ``` 3 / 9 20 / 15 7 ``` The expected output is: ``` [ [3], [20,9], [15,7] ] ``` # Implementation Details: 1. Initialize an empty list `res` to store the result. 2. Handle the case where `root` is `None` by returning an empty list. 3. Use a list `level` to keep track of nodes at the current level, starting with the root node. 4. Use a flag variable to control the order of traversal (left-to-right or right-to-left). 5. Iterate through the levels, capturing node values and updating the traversal direction after each level. # Function Signature: ```python def zigzag_level(root): pass ```","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzag_level(root): if not root: return [] res = [] node_queue = deque([root]) left_to_right = True while node_queue: level_size = len(node_queue) level_nodes = deque() for _ in range(level_size): node = node_queue.popleft() if left_to_right: level_nodes.append(node.val) else: level_nodes.appendleft(node.val) if node.left: node_queue.append(node.left) if node.right: node_queue.append(node.right) res.append(list(level_nodes)) left_to_right = not left_to_right return res"},{"question":"Nested String Decoder Context You are working on a compression system that uses a specific encoding format for strings. This format encodes repeated substrings as `k[encoded_string]`, where `k` is a positive integer and `encoded_string` can potentially contain further nested encoded substrings. Your task is to write a function to decode such encoded strings back into their original form. # Task Specification **Function Signature** ```python def decode_string(s: str) -> str: pass ``` **Input** * `s`: A well-formed encoded string containing only lowercase English letters, digits, and square brackets. (1 ≤ len(s) ≤ 30,000) **Output** * A string representing the fully decoded version of the input string. **Constraints** * The input string is guaranteed to have well-formed square brackets and positive integer repetitions. * The input string will not contain any digits outside the repetition encodings. **Examples** 1. `s = \\"3[a]2[bc]\\"` -> `\\"aaabcbc\\"` 2. `s = \\"3[a2[c]]\\"` -> `\\"accaccacc\\"` 3. `s = \\"2[abc]3[cd]ef\\"` -> `\\"abcabccdcdcdef\\"` # Detailed Requirements 1. Implement the function `decode_string(s: str) -> str` to decode the input string as specified. 2. Ensure that your implementation correctly handles nested encodings. 3. Optimize for efficiency since the input size can reach up to 30,000 characters. # Edge Cases to Consider * Ensure your function can handle empty substrings within the encoding, e.g., `\\"2[]\\"` should effectively return an empty string for such segments. * Very large values for `k` should not result in substantial delays or excessive memory usage. * Deep nested encoded structures should be correctly handled without stack overflow or excessive recursive depth.","solution":"def decode_string(s: str) -> str: stack = [] current_string = \'\' current_num = 0 for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string = \'\' current_num = 0 elif char == \']\': last_string, num = stack.pop() current_string = last_string + current_string * num else: current_string += char return current_string"},{"question":"**Problem**: Maximum Clique Identification with Filtering You are given an undirected graph represented as an adjacency list. Your task is to identify all maximal cliques in the graph using the Bron-Kerbosch algorithm and further filter these cliques to only return those cliques whose size is above a given threshold. **Function Signature**: ```python def filter_cliques(edges: Dict[str, Set[str]], threshold: int) -> List[List[str]]: Given an undirected graph represented by \'edges\' and an integer \'threshold\', find all maximal cliques using the Bron-Kerbosch algorithm and return only those cliques whose size is greater than \'threshold\'. :param edges: Dictionary where keys are vertex labels and values are sets of adjacent vertices. :param threshold: Minimum size of cliques to be returned. :return: A list of lists, each representing a maximal clique with size greater than \'threshold\'. ``` **Input**: - `edges`: A dictionary representing an adjacency list where each key is a vertex (string) and each value is a set of vertices (also strings) that are directly connected to the key vertex. - `threshold`: A non-negative integer indicating the minimum size of cliques to return. **Output**: - A list of lists, each sublist is a maximal clique and its size is strictly greater than `threshold`. **Example**: ```python edges = { \\"1\\": {\\"2\\", \\"3\\"}, \\"2\\": {\\"1\\", \\"3\\", \\"4\\"}, \\"3\\": {\\"1\\", \\"2\\", \\"4\\"}, \\"4\\": {\\"2\\", \\"3\\"} } threshold = 2 result = filter_cliques(edges, threshold) # Expected Output: [[\'1\', \'2\', \'3\'], [\'2\', \'3\', \'4\']] ``` **Note**: - Vertices are labelled as strings. - Ensure efficient clique identification followed by filtering based on the clique size.","solution":"def bron_kerbosch(R, P, X, edges, cliques): Bron-Kerbosch recursive algorithm to find all maximal cliques. if not P and not X: cliques.append(R) return for v in list(P): bron_kerbosch(R | {v}, P & edges[v], X & edges[v], edges, cliques) P.remove(v) X.add(v) def filter_cliques(edges, threshold): Given an undirected graph represented by \'edges\' and an integer \'threshold\', find all maximal cliques using the Bron-Kerbosch algorithm and return only those cliques whose size is greater than \'threshold\'. cliques = [] bron_kerbosch(set(), set(edges.keys()), set(), edges, cliques) # Filter cliques based on the threshold filtered_cliques = [list(clique) for clique in cliques if len(clique) > threshold] return filtered_cliques"},{"question":"**Question Title**: Efficient Comb Sort Implementation **Scenario**: You\'ve been tasked with optimizing the sort function for a small-to-medium-sized dataset for an embedded systems application where memory usage must be kept to a minimum. The current implementation uses Bubble Sort, which is slow on larger inputs. **Objective**: Implement Comb Sort to achieve a more efficient sorting process while keeping the memory footprint minimal. **Function Signature**: ```python def comb_sort(arr: List[int]) -> List[int]: pass ``` # Requirements: 1. **Input**: - A list of integers `arr` where `1 <= len(arr) <= 10^4`. 2. **Output**: - A sorted list of integers. 3. **Constraints**: - The function should not use any additional data structures that significantly increase space complexity. - The function should handle edge cases like empty arrays, arrays with one element, and arrays that are already sorted. 4. **Performance**: - Aim for an improved average time complexity but be aware of the worst-case scenario of O(n^2). # Example: **Input**: ```python arr = [64, 25, 12, 22, 11] ``` **Output**: ```python sorted_arr = [11, 12, 22, 25, 64] ``` **Edge Cases to Consider**: - Already sorted array. - Array with all identical elements. - Empty array. Make sure your implementation takes these edge cases into account and performs efficiently within the given constraints.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Comb Sort algorithm. def get_next_gap(gap): # Shrink factor of comb sort is generally taken as 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"You are given a string containing only digits (0-9) and a target integer. Your task is to write a function `add_operators` that returns all possible interpretations of adding binary operators (+, -, *) between the digits so that the resulting expression evaluates to the target integer. # Function Signature: ```python def add_operators(num: str, target: int) -> List[str]: pass ``` # Input: * `num` (str): A non-empty string that contains only digits. * `target` (int): The target integer value. # Output: * List[str]: A list of strings representing different expressions formed by adding binary operators between the digits that evaluate to the target value. # Constraints: * The input string will not be empty and will only contain decimal digits (0-9). * The length of the input string will be ≤ 10. * The output list can be in any order. * No unary operators are allowed, and all digits should be used as is. # Performance Requirements: * Your solution should account for the exponential nature of the problem and aim to be as efficient as possible within given constraints. # Examples: ```python add_operators(\\"123\\", 6) # Returns: [\\"1+2+3\\", \\"1*2*3\\"] add_operators(\\"232\\", 8) # Returns: [\\"2*3+2\\", \\"2+3*2\\"] add_operators(\\"105\\", 5) # Returns: [\\"1*0+5\\", \\"10-5\\"] add_operators(\\"00\\", 0) # Returns: [\\"0+0\\", \\"0-0\\", \\"0*0\\"] add_operators(\\"3456237490\\", 9191) # Returns: [] ``` # Instructions: 1. Make sure to handle leading zeros correctly as per the example (`\\"105\\"` should include `\\"1*0+5\\"` but not `\\"10*5\\"` due to the leading zero constraint). 2. Handle potential edge cases where the input string doesn\'t form any valid expressions matching the target. 3. Avoid using built-in evaluation functions (`eval`) directly for evaluating expressions. 4. Optimize for performance to handle up to the maximum constraint effectively. # Implementation Hint: Use a recursive backtracking approach to explore all possible ways to insert the operators, and ensure to carry forward the intermediate evaluation results appropriately.","solution":"from typing import List def add_operators(num: str, target: int) -> List[str]: def backtrack(index, prev_op, current_value, value_string): if index == len(num): if current_value == target: result.append(value_string) return for i in range(index + 1, len(num) + 1): part = num[index:i] if i != index + 1 and num[index] == \'0\': break # Leading zero case part_int = int(part) if index == 0: backtrack(i, part_int, part_int, part) else: backtrack(i, part_int, current_value + part_int, value_string + \\"+\\" + part) backtrack(i, -part_int, current_value - part_int, value_string + \\"-\\" + part) backtrack(i, prev_op * part_int, current_value - prev_op + (prev_op * part_int), value_string + \\"*\\" + part) result = [] backtrack(0, 0, 0, \\"\\") return result"},{"question":"# Scenario You are tasked with enhancing the efficiency of a system that frequently searches for transaction IDs in a sorted list of logs. As part of this optimization, you need to ensure that your search algorithm can reliably find the first occurrence of any given transaction ID. # Task Write a function `first_occurrence(array, query)` that takes a sorted list of integers `array` and an integer `query` as inputs. This function should return the index of the first occurrence of `query` in `array`. The array is guaranteed to be initially sorted in increasing order. # Specifications * **Input**: * `array`: A list of sorted integers of length `n` where (1 leq n leq 10^6). * `query`: An integer where (-10^9 leq text{query} leq 10^9). * **Output**: * Index of the first occurrence of `query` in `array`. * If `query` is not found, return -1. * **Constraints**: * The function should run in (O(log n)) time complexity. * Utilize space efficiently, with constant extra space. * **Performance Requirements**: * Ensure that the implementation can handle the upper limits of the input sizes efficiently. # Example ```python >>> first_occurrence([1, 2, 2, 4, 5, 5, 5, 7], 5) 4 >>> first_occurrence([1, 2, 2, 4, 5, 5, 5, 7], 9) -1 >>> first_occurrence([1, 1, 1, 1, 1], 1) 0 ``` # Notes * If the array contains duplicates, return the index of the first occurrence. * If the element is not found, return -1.","solution":"def first_occurrence(array, query): Returns the index of the first occurrence of query in the sorted array. If the query is not present in the array, returns -1. low, high = 0, len(array) - 1 result = -1 while low <= high: mid = (low + high) // 2 if array[mid] == query: result = mid # mark the position high = mid - 1 # continue searching in the left half elif array[mid] < query: low = mid + 1 else: high = mid - 1 return result"},{"question":"Radix Sort Enhancement and Implementation Context Radix sort is an efficient sorting technique for sorting integers by processing individual digits. However, its basic implementation faces challenges when dealing with negative numbers and variable digit lengths. Task Enhance the radix sort function to handle an array containing both positive and negative integers, while maintaining its stability and efficiency. Function Signature ```python def enhanced_radix_sort(arr: List[int]) -> List[int]: ``` Expected Input and Output: * **Input**: A list of integers that may include both positive and negative integers. - `[-13, -123, 0, 5, 345, 45, 2]` * **Output**: A sorted list of integers. - `[-123, -13, 0, 2, 5, 45, 345]` # Constraints: * The list can contain both negative and positive integers. * Length of the input list, `n`, is up to 1000000. * Each integer can have up to `15` digits in the worst case. # Additional Notes: 1. Implement a stable sorting mechanism to handle digit-wise ordering. 2. Consider appropriate handling for negative integers to preserve the properties of radix sort. 3. Optimize for time and space efficiency.","solution":"from typing import List def enhanced_radix_sort(arr: List[int]) -> List[int]: def counting_sort(arr, exp, base=10): n = len(arr) output = [0] * n count = [0] * base # Counting occurrences for i in range(n): index = (arr[i] // exp) % base count[index] += 1 # Change count so that it contains the actual # position of this digit in output[] for i in range(1, base): count[i] += count[i - 1] # Build the output array for i in range(n - 1, -1, -1): index = (arr[i] // exp) % base output[count[index] - 1] = arr[i] count[index] -= 1 # Copy the output array to arr[], so that arr now # contains sorted numbers according to current digit for i in range(n): arr[i] = output[i] if len(arr) == 0: return [] # Find the minimum and maximum values to separate the array min_val = min(arr) max_val = max(arr) if min_val == max_val: return arr # Separate negative and non-negative values negatives = [-num for num in arr if num < 0] non_negatives = [num for num in arr if num >= 0] # Perform radix sort on the absolute values of negative numbers negative_max = max(negatives) if negatives else 0 exp = 1 while negative_max // exp > 0: counting_sort(negatives, exp) exp *= 10 # Convert negatives back to negative numbers and reverse the list negatives = [-num for num in reversed(negatives)] # Perform radix sort on non-negative numbers non_negative_max = max(non_negatives) if non_negatives else 0 exp = 1 while non_negative_max // exp > 0: counting_sort(non_negatives, exp) exp *= 10 # Combine the sorted negatives and non-negatives return negatives + non_negatives"},{"question":"# Scenario You work at a company that builds software for e-commerce businesses. A common feature involves searching through a catalog of items, sorted by price but sometimes rotated due to seasonal themes. To enhance search efficiency in such rotated catalogs, your task is to implement a search algorithm that can find items quickly. # Problem Statement You are given an array of integers \'nums\' that is sorted in ascending order and then possibly rotated at an unknown pivot where the rotation can be zero or more positions. Given an integer \'target\', write a function to search for \'target\' in \'nums\'. If \'target\' exists, return its index; otherwise, return -1. # Requirements - Your algorithm must run in O(log n) time complexity. - Implement both iterative and recursive versions of the search method. - Given constraints: - 1 <= nums.length <= 5000 - -10^4 <= nums[i] <= 10^4 - All values of nums are unique. - nums is rotated at some pivot. # Function Signature ```python def search(nums: List[int], target: int) -> int: pass def search_recursive(nums: List[int], target: int) -> int: pass ``` # Input - `nums`: List[int] - An integer list representing the rotated sorted array. - `target`: int - The integer to search for. # Output - Return the index of `target` if found, otherwise return -1. # Example Iterative Version ```python array = [4,5,6,7,0,1,2] target = 0 result = search(array, target) # Output: 4 ``` Recursive Version ```python array = [4,5,6,7,0,1,2] target = 3 result = search_recursive(array, target) # Output: -1 ``` # Constraints - Write concise and efficient code without using any excessive space. - Handle all possible edge cases, including but not limited to: - Empty array - Single-element scenarios - Target values at the start, end, and pivot indices.","solution":"from typing import List def search(nums: List[int], target: int) -> int: Iterative approach to find the target in a rotated sorted array. start, end = 0, len(nums) - 1 while start <= end: mid = (start + end) // 2 if nums[mid] == target: return mid if nums[start] <= nums[mid]: # left side is sorted if nums[start] <= target < nums[mid]: end = mid - 1 else: start = mid + 1 else: # right side is sorted if nums[mid] < target <= nums[end]: start = mid + 1 else: end = mid - 1 return -1 def search_recursive(nums: List[int], target: int) -> int: Recursive approach to find the target in a rotated sorted array. def recursive_helper(start, end): if start > end: return -1 mid = (start + end) // 2 if nums[mid] == target: return mid if nums[start] <= nums[mid]: # left side is sorted if nums[start] <= target < nums[mid]: return recursive_helper(start, mid - 1) else: return recursive_helper(mid + 1, end) else: # right side is sorted if nums[mid] < target <= nums[end]: return recursive_helper(mid + 1, end) else: return recursive_helper(start, mid - 1) return recursive_helper(0, len(nums) - 1)"},{"question":"Implementing RSA Key Generation Context: You are tasked with building a secure communication system and decide to use the RSA algorithm for encrypting messages. The core part of this implementation involves generating the RSA keys correctly. Your job is to refine and complete the RSA key generation function. Task: Implement the `generate_key` function to correctly and efficiently generate RSA keys: * The function should receive the bit length (k) for the modulus (n) and an optional random seed. * Your function should output a tuple containing three integers: (n) (modulus), (e) (encryption exponent), and (d) (decryption exponent). Requirements: 1. **Optimize Prime Generation**: * Use an efficient prime testing algorithm. * Ensure both primes (p) and (q) are large and not too close to each other. 2. **Ensure (e) is Suitable**: * (e) must be chosen such that it is commonly used and safe (e.g., 65537). 3. **Ensure Correct Modulus and Inverses**: * Verify and compute the multiplicative inverse for (d). Function Signature: ```python def generate_key(k: int, seed: int = None) -> (int, int, int): Generate RSA public and private keys. Parameters: ----------- k: int The number of bits in the modulus n. seed: int Optional random seed for reproducibility. Returns: -------- n: int The modulus for both keys. e: int The encryption exponent (public key). d: int The decryption exponent (private key). pass ``` Example Usage: ```python n, e, d = generate_key(16, seed=42) print(n, e, d) # Example Output: (some_large_number, 65537, some_other_large_number) ``` Constraints: * (k) will be at least 16. * Ensure prime generation and key computations are optimized for performance. __Note__: You don\'t need to implement encryption and decryption functions, but our test cases will verify the result by attempting to encrypt and decrypt data using returned keys.","solution":"import random from sympy import isprime from sympy import mod_inverse def generate_prime_candidate(bits): Generate an odd integer randomly p = random.getrandbits(bits) # apply a mask to set MSB and LSB to 1 p |= (1 << bits - 1) | 1 return p def generate_prime_number(bits): Generate a prime number of bit length `bits` p = 4 # keep generating while the generated number is not prime while not isprime(p): p = generate_prime_candidate(bits) return p def generate_key(k: int, seed: int = None) -> (int, int, int): Generate RSA key pair if seed is not None: random.seed(seed) # Generate two distinct large primes p and q bit_length = k // 2 p = generate_prime_number(bit_length) q = generate_prime_number(bit_length) while q == p: q = generate_prime_number(bit_length) n = p * q phi_n = (p - 1) * (q - 1) # Common choice for e e = 65537 # Compute d, the modular inverse of e d = mod_inverse(e, phi_n) return (n, e, d)"},{"question":"You are tasked with optimizing the Sieve of Eratosthenes algorithm provided to generate a list of all prime numbers less than a given integer n. This algorithm has already been partially optimized to skip even numbers, thereby reducing the array size and computational complexity. Your task is to write an enhanced version of the function that ensures further improvements. Specifically, implement a Python function `get_primes_enhanced(n)` which will bear the following characteristics: # Function Signature ```python def get_primes_enhanced(n: int) -> List[int]: pass ``` # Input - An integer `n` (1 ≤ n ≤ 10^7) specifying the upper limit (exclusive) to which prime numbers need to be generated. # Output - A list of integers containing all prime numbers less than `n`. # Constraints 1. Return an empty list if `n` is less than or equal to 2. 2. Optimize the function to handle the upper constraint efficiently in terms of both time and space complexity. 3. Ensure no prime number below `n` is omitted. 4. Performance should be close to the time complexity of O(n log log n) and space complexity should not exceed O(n/2). # Example Example 1: ```python get_primes_enhanced(10) # Expected Output: [2, 3, 5, 7] ``` Example 2: ```python get_primes_enhanced(2) # Expected Output: [] ``` # Challenge In addition to implementing this function, provide a brief explanation of any additional optimizations you introduced and why they are effective.","solution":"from typing import List def get_primes_enhanced(n: int) -> List[int]: if n <= 2: return [] sieve = [True] * (n // 2) sieve[0] = False for i in range(1, int(n**0.5/2) + 1): if sieve[i]: step = 2 * i + 1 start = step * step // 2 sieve[start::step] = [False] * len(sieve[start::step]) primes = [2] + [2 * i + 1 for i in range(1, n // 2) if sieve[i]] return primes"},{"question":"You are tasked with converting a given Binary Tree into a doubly linked list. The doubly linked list should be sorted if the tree is a Binary Search Tree. Each node in the doubly linked list should have two pointers (`left` for the previous node and `right` for the next node), and it should be created in an in-order fashion from the given Binary Tree. You are provided with a class `TreeNode` that has the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Write two functions `bin_tree_to_list` and `bin_tree_to_list_util` to achieve this conversion. The main function `bin_tree_to_list` should initialize the process, and the helper function `bin_tree_to_list_util` should handle the recursive node conversion. Function Signature ```python def bin_tree_to_list(root: TreeNode) -> TreeNode: pass def bin_tree_to_list_util(root: TreeNode) -> TreeNode: pass ``` Input - `root`: A `TreeNode` object representing the root of the binary tree. Output - The function `bin_tree_to_list` should return the head of the doubly linked list. Constraints: - The binary tree contains at most 1000 nodes. - Node values are integers and can be positive, negative, or zero. Example Given the following binary tree: ``` 4 / 2 5 / 1 3 ``` The output should be a doubly linked list with the following order: 1 <-> 2 <-> 3 <-> 4 <-> 5. Note: The function should print the doubly linked list head to verify the correct order. Helper Function You may implement a function to print the values of the doubly linked list starting from the head to verify the correctness: ```python def print_list(head: TreeNode) -> None: while head: print(head.val, end=\\" <-> \\" if head.right else \\"n\\") head = head.right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bin_tree_to_list(root: TreeNode) -> TreeNode: if not root: return None # Initialize the previous node as None bin_tree_to_list_util.prev = None # A wrapper node for the head of the doubly linked list dummy = TreeNode(0) bin_tree_to_list_util.head = dummy # Convert the binary tree to a doubly linked list bin_tree_to_list_util(root) # The head of the doubly linked list will be the right child of the dummy node head = dummy.right # Disconnect the dummy node from the linked list if head: head.left = None return head def bin_tree_to_list_util(root: TreeNode): if not root: return # Convert the left subtree bin_tree_to_list_util(root.left) # Link the previous node (if exists) to the current root if bin_tree_to_list_util.prev: bin_tree_to_list_util.prev.right = root root.left = bin_tree_to_list_util.prev else: # If prev is None, we are at the leftmost node which is the head of the list bin_tree_to_list_util.head.right = root root.left = None # Update the previous node to the current root bin_tree_to_list_util.prev = root # Convert the right subtree bin_tree_to_list_util(root.right) def print_list(head: TreeNode) -> None: while head: print(head.val, end=\\" <-> \\" if head.right else \\"n\\") head = head.right"},{"question":"# **Coding Challenge: Optimize and Enhance Insertion Sort** Context: The standard Insertion Sort algorithm is simple and effective for small or nearly sorted arrays but becomes inefficient for larger datasets. Your task is to implement a more efficient version of the Insertion Sort using binary search to find the insertion point, thereby reducing the number of comparisons required. Task: Write a Python function `binary_insertion_sort(arr, simulation=False)` that sorts an array of numbers using an optimized Insertion Sort algorithm with binary search for finding the proper insertion point, providing an option to display the simulation of the sorting process at each iteration. Function Signature: ```python def binary_insertion_sort(arr, simulation=False): pass ``` Input: * `arr`: a list of integers to be sorted. * `simulation` (optional): a boolean flag, defaulting to `False`. If set to `True`, it prints the state of the array after each iteration. Output: * A sorted list of integers in ascending order. Constraints: * **Input Size**: You can assume the input list contains between 0 and 10,000 integers. * **Input Range**: Elements of the input list are within the range `[-10^6, 10^6]`. Performance Requirements: - Time Complexity: O(n^2) in worst and average case but should make fewer comparisons using binary search for insertion. - Space Complexity: O(1) Example: ```python sorted_array = binary_insertion_sort([5, 2, 4, 6, 1, 3], simulation=True) # Expected Output: [1, 2, 3, 4, 5, 6] ```","solution":"def binary_insertion_sort(arr, simulation=False): Sorts an array in ascending order using an optimized Insertion Sort algorithm with binary search. Parameters: - arr: List of integers to be sorted. - simulation: Boolean flag. If True, prints the state of the array after each iteration. Returns: - A sorted list of integers in ascending order. def binary_search(sub_arr, val, start, end): while start < end: mid = (start + end) // 2 if sub_arr[mid] < val: start = mid + 1 else: end = mid return start for i in range(1, len(arr)): val = arr[i] # Find the correct position for the new element j = binary_search(arr, val, 0, i) # The elements arr[j] to arr[i-1] are shifted, and then val is placed at arr[j] arr = arr[:j] + [val] + arr[j:i] + arr[i+1:] if simulation: print(f\\"Iteration {i}: {arr}\\") return arr"},{"question":"Radix Sort Implementation with Simulation Mode **Context**: You are given a list of non-negative integers and required to sort them using Radix Sort. Radix Sort processes each digit of the numbers, starting from the least significant digit to the most significant digit. In this exercise, you will implement the Radix Sort algorithm and also provide a visual simulation mode to show the intermediate states of the list after processing each digit. **Task**: Write a Python function `radix_sort(arr: List[int], simulation: bool = False) -> List[int]` that sorts a list of non-negative integers using Radix Sort. The function should also take a `simulation` boolean flag that, when set to `True`, prints the state of the list after sorting by each digit. **Function Signature**: ```python def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` **Input**: * `arr` - A list of non-negative integers to sort. Example: `[170, 45, 75, 90, 802, 24, 2, 66]` * `simulation` - A boolean flag indicating whether to print the intermediate states of the list. Default is `False`. **Output**: * Returns the sorted list. Example: `[2, 24, 45, 66, 75, 90, 170, 802]` **Constraints**: * The list can be empty. * Elements of the list are non-negative integers. * The largest integer in the list will fit within the standard integer range. **Example**: ```python arr = [170, 45, 75, 90, 802, 24, 2, 66] print(radix_sort(arr, simulation=True)) ``` **Expected Simulation Output**: ``` iteration 0 : 170 45 75 90 802 24 2 66 iteration 1 : 170 90 802 2 24 45 75 66 iteration 2 : 2 24 45 66 75 90 802 170 ``` **Notes**: * Consider and handle edge cases as described in the analysis. * Make sure the function is efficient and adheres to the principles of Radix Sort.","solution":"from typing import List def counting_sort_for_radix(arr: List[int], exp: int) -> List[int]: n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 for i in range(1, 10): count[i] += count[i - 1] for i in range(n - 1, -1, -1): index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 for i in range(n): arr[i] = output[i] return arr def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: if len(arr) == 0: return arr max_num = max(arr) exp = 1 iteration = 0 while max_num // exp > 0: arr = counting_sort_for_radix(arr, exp) if simulation: print(f\\"iteration {iteration} : {\' \'.join(map(str, arr))}\\") exp *= 10 iteration += 1 return arr"},{"question":"# Context You are working on a search engine that needs to quickly look up keywords from a large, sorted list of entries. One of the algorithms considered for this task is Jump Search due to its efficiency with sorted data. # Task Implement the Jump Search algorithm in Python to find the position of a target element in a sorted list of integers. # Function Signature ```python def jump_search(arr: List[int], target: int) -> int: ``` # Input * `arr`: A list of integers sorted in ascending order. (1 ≤ len(arr) ≤ 10^6) * `target`: An integer value to search for within `arr`. # Output * Return the index of the target element if found. * Return -1 if the target is not found. # Constraints * The elements of `arr` are unique. * The list contains at least one element. # Examples ```python assert jump_search([1, 3, 5, 7, 9, 11], 7) == 3 assert jump_search([10, 20, 30, 40, 50, 60], 25) == -1 assert jump_search([2, 4, 8, 16, 32, 64], 2) == 0 assert jump_search([2, 4, 8, 16, 32, 64], 64) == 5 assert jump_search([1], 1) == 0 ``` # Performance Requirements * The solution should be optimized to run within O(√n) time complexity where n is the number of elements in the array. # Additional Information * Ensure that your function handles edge cases appropriately. * You are not allowed to use any pre-built search functions like `in` or `index`.","solution":"from typing import List import math def jump_search(arr: List[int], target: int) -> int: Perform jump search on the sorted list \'arr\' to find the \'target\'. Return the index of \'target\' if found, else return -1. n = len(arr) step = int(math.sqrt(n)) # block size to jump prev = 0 # Finding the block where element is present while prev < n and arr[min(step, n) - 1] < target: prev = step step += int(math.sqrt(n)) if prev >= n: return -1 # Linear search for target in block beginning with prev for i in range(prev, min(step, n)): if arr[i] == target: return i return -1"},{"question":"# AVL Insert and Delete Implementation You are required to implement an AVL tree in Python. The AVL tree should support insertion and deletion of nodes while maintaining its balance properties. Specifically, you need to implement: 1. The `insert` method to insert a new key into the tree. 2. The `delete` method to remove a key from the tree, ensuring that the tree remains balanced afterwards. Your implementation should also provide an in-order traversal method that returns the keys in sorted order. Function Signature ```python class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree(object): def __init__(self): self.root = None def insert(self, key): pass def delete(self, key): pass def in_order_traverse(self): pass # Example Usage: avl_tree = AvlTree() avl_tree.insert(10) avl_tree.insert(20) avl_tree.delete(10) print(avl_tree.in_order_traverse()) # Should output [20] ``` Constraints and Goals * The tree should automatically rebalance after every insertion and deletion. * Implement the appropriate rotation methods to maintain tree balance. * Ensure that the in-order traversal method returns keys in ascending order. Input - For the `insert` method: a single integer `key` to be inserted into the AVL tree. - For the `delete` method: a single integer `key` to be deleted from the AVL tree. Output - For the `in_order_traverse` method: a list of integers representing the keys in ascending order. Example ```python avl_tree = AvlTree() avl_tree.insert(10) avl_tree.insert(20) avl_tree.insert(15) print(avl_tree.in_order_traverse()) # Output: [10, 15, 20] avl_tree.delete(15) print(avl_tree.in_order_traverse()) # Output: [10, 20] ``` Note: Your solution should be efficient in terms of time and space complexity.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree(object): def __init__(self): self.root = None def _height(self, node): return node.height if node else 0 def _balance_factor(self, node): return self._height(node.left) - self._height(node.right) if node else 0 def _rotate_right(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self._height(y.left), self._height(y.right)) x.height = 1 + max(self._height(x.left), self._height(x.right)) return x def _rotate_left(self, x): y = x.right T2 = y.left y.left = x x.right = T2 x.height = 1 + max(self._height(x.left), self._height(x.right)) y.height = 1 + max(self._height(y.left), self._height(y.right)) return y def _rebalance(self, node): node.height = 1 + max(self._height(node.left), self._height(node.right)) balance_factor = self._balance_factor(node) if balance_factor > 1: if self._balance_factor(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance_factor < -1: if self._balance_factor(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _insert(self, node, key): if not node: return TreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) return self._rebalance(node) def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self.root = self._insert(self.root, key) def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._min_value_node(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) if node is None: return node return self._rebalance(node) def delete(self, key): if self.root is not None: self.root = self._delete(self.root, key) def _in_order_traverse(self, node, result): if not node: return result result = self._in_order_traverse(node.left, result) result.append(node.key) result = self._in_order_traverse(node.right, result) return result def in_order_traverse(self): return self._in_order_traverse(self.root, [])"},{"question":"Problem Statement You are given a partially filled 9x9 Sudoku board that needs to be solved. The Sudoku board is represented as a 2D list where empty cells are represented by the character \'.\'. Write a function `solve_sudoku(board: List[List[str]]) -> None` that modifies the board in-place to fill the empty cells such that the final board is a valid Sudoku solution. # Input * A 2D list `board` containing 9 lists of 9 strings. Each string is either a digit from \'1\' to \'9\' or the character \'.\'. # Output * The function should modify the `board` in-place to solve the Sudoku puzzle. # Constraints * The given board will have at least one valid solution. * The board is valid according to Sudoku rules initially. # Example ```python board = [ [\\"5\\", \\"3\\", \\".\\", \\".\\", \\"7\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\"6\\", \\".\\", \\".\\", \\"1\\", \\"9\\", \\"5\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\"9\\", \\"8\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\"], [\\"8\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\"3\\"], [\\"4\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\"3\\", \\".\\", \\".\\", \\"1\\"], [\\"7\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\".\\", \\".\\", \\".\\", \\"6\\"], [\\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\"8\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\"4\\", \\"1\\", \\"9\\", \\".\\", \\".\\", \\"5\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\".\\", \\"7\\", \\"9\\"] ] solve_sudoku(board) print(board) ``` # Expected Output The board should be modified to: ``` [ [\\"5\\", \\"3\\", \\"4\\", \\"6\\", \\"7\\", \\"8\\", \\"9\\", \\"1\\", \\"2\\"], [\\"6\\", \\"7\\", \\"2\\", \\"1\\", \\"9\\", \\"5\\", \\"3\\", \\"4\\", \\"8\\"], [\\"1\\", \\"9\\", \\"8\\", \\"3\\", \\"4\\", \\"2\\", \\"5\\", \\"6\\", \\"7\\"], [\\"8\\", \\"5\\", \\"9\\", \\"7\\", \\"6\\", \\"1\\", \\"4\\", \\"2\\", \\"3\\"], [\\"4\\", \\"2\\", \\"6\\", \\"8\\", \\"5\\", \\"3\\", \\"7\\", \\"9\\", \\"1\\"], [\\"7\\", \\"1\\", \\"3\\", \\"9\\", \\"2\\", \\"4\\", \\"8\\", \\"5\\", \\"6\\"], [\\"9\\", \\"6\\", \\"1\\", \\"5\\", \\"3\\", \\"7\\", \\"2\\", \\"8\\", \\"4\\"], [\\"2\\", \\"8\\", \\"7\\", \\"4\\", \\"1\\", \\"9\\", \\"6\\", \\"3\\", \\"5\\"], [\\"3\\", \\"4\\", \\"5\\", \\"2\\", \\"8\\", \\"6\\", \\"1\\", \\"7\\", \\"9\\"] ] ``` # Notes * Students should ensure to use efficient backtracking algorithms and consider the constraints when designing their solutions. * Solutions should account for the Sudoku rules and check for valid placements at each step.","solution":"from typing import List def solve_sudoku(board: List[List[str]]) -> None: Solves the Sudoku in-place. def is_valid(board, row, col, num): Checks if it\'s valid to place num in board[row][col]. for i in range(9): if board[row][i] == num or board[i][col] == num or board[row // 3 * 3 + i // 3][col // 3 * 3 + i % 3] == num: return False return True def solve(board): for row in range(9): for col in range(9): if board[row][col] == \'.\': for num in map(str, range(1, 10)): if is_valid(board, row, col, num): board[row][col] = num if solve(board): return True board[row][col] = \'.\' return False return True solve(board)"},{"question":"# Robot Path Validation Scenario A robot starts from the origin (0, 0) on a 2D grid and moves according to a sequence of instructions. The instructions are represented by a string where each character indicates a specific move: - `R` for moving right (+1 unit towards the x-axis) - `L` for moving left (-1 unit towards the x-axis) - `U` for moving up (+1 unit towards the y-axis) - `D` for moving down (-1 unit towards the y-axis) You are required to determine whether after executing the complete sequence of moves, the robot returns to its original starting position. Task Implement a function `robot_returns_to_origin(moves)` which returns `True` if the robot returns to the start position (0, 0) after executing the moves, otherwise returns `False`. Input - `moves`: A string consisting of the characters `R`, `L`, `U`, `D` indicating the move sequence the robot will execute. - Constraints: 1 <= len(moves) <= 10^4 Output - Returns a boolean value (`True` or `False`). Examples - Example 1: - Input: `\\"UD\\"` - Output: `True` - Example 2: - Input: `\\"LL\\"` - Output: `False` - Example 3: - Input: `\\"RRDD\\"` - Output: `False` - Example 4: - Input: `\\"RLUD\\"` - Output: `True` Notes - Ensure your solution handles edge cases like empty input string, single move, and larger sequences efficiently. - Avoid unnecessary checks and optimize for large inputs within the provided constraint.","solution":"def robot_returns_to_origin(moves): Determines if the robot returns to the origin after executing the moves. Parameters: moves (str): A string consisting of the characters \'R\', \'L\', \'U\', \'D\'. Returns: bool: True if the robot returns to the origin (0, 0) after executing the moves, False otherwise. x, y = 0, 0 for move in moves: if move == \'R\': x += 1 elif move == \'L\': x -= 1 elif move == \'U\': y += 1 elif move == \'D\': y -= 1 return x == 0 and y == 0"},{"question":"Given the two implementations of the Stack ADT (ArrayStack and LinkedListStack), implement a function `reverse_string_using_stack` that takes a string as input and returns a new string which is the reverse of the input string. You should use the ArrayStack implementation to achieve this. # Function Signature ```python def reverse_string_using_stack(input_string: str) -> str: pass ``` # Input * `input_string` (str): A string consisting of printable ASCII characters. # Output * (str): The reversed string. # Constraints * All characters in `input_string` will be printable ASCII characters. * Length of `input_string` will be between 1 to 10^6. # Example ```python # Example 1 input_string = \\"hello\\" assert reverse_string_using_stack(input_string) == \\"olleh\\" # Example 2 input_string = \\"world\\" assert reverse_string_using_stack(input_string) == \\"dlrow\\" ``` # Instructions 1. Use the ArrayStack class from the code snippet provided to implement the reverse function. 2. Validate the input and handle edge cases appropriately. 3. Ensure the solution runs efficiently for large input sizes within the given constraints.","solution":"class ArrayStack: def __init__(self): self.stack = [] def is_empty(self): return len(self.stack) == 0 def push(self, item): self.stack.append(item) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.stack.pop() def size(self): return len(self.stack) def reverse_string_using_stack(input_string: str) -> str: stack = ArrayStack() # Push all characters of input_string into the stack for char in input_string: stack.push(char) # Pop from stack and collect characters to form the reversed string reversed_string = [] while not stack.is_empty(): reversed_string.append(stack.pop()) return \'\'.join(reversed_string)"},{"question":"**Scenario**: You are working on a web development project and need to ensure that the URLs generated by your application are clean and optimized. Specifically, you need to remove duplicate query string parameters and optionally filter out some specified parameters. This will be useful for improving SEO and ensuring non-redundant, clean URLs. **Task**: Write a function `strip_url_params(url: str, params_to_strip: list = None) -> str` that performs the following: 1. Removes any duplicate query string parameters from the given URL, keeping only the first occurrence of each. 2. Optionally removes any query string parameters specified within the second argument (an optional list). # Input and Output - **Input**: - `url` (string): The URL containing query parameters. - `params_to_strip` (list): A list of query parameter keys to be removed from the URL (default is None). - **Output**: - A cleaned URL string with duplicates and specified parameters removed. # Constraints - The length of the URL will not exceed 2048 characters. - Query parameters will be formatted correctly (i.e., as key-value pairs separated by &). **Examples**: 1. `strip_url_params(\'www.example.com?a=1&b=2&a=2\')` should return `\'www.example.com?a=1&b=2\'` 2. `strip_url_params(\'www.example.com?a=1&b=2&a=2&c=3&a=3\', [\'a\', \'b\'])` should return `\'www.example.com?c=3\'` 3. `strip_url_params(\'www.example.com\')` should return `\'www.example.com\'` # Performance Requirements - The solution should handle URLs efficiently even with a significant number of query parameters (e.g., 1000+ parameters). # Edge Cases: - URLs with no query parameters. - All query parameters being duplicates or all being stripped. **Hints**: - Utilizing Python\'s built-in libraries can make parsing and reconstructing URLs more efficient and less error-prone. - Consider using a dictionary to manage query parameters. - Managing multiple occurrences of the same query parameter requires careful logic to ensure only the first occurrence is kept.","solution":"from urllib.parse import urlparse, parse_qsl, urlencode, urlunparse def strip_url_params(url: str, params_to_strip: list = None) -> str: # Parse the URL components parsed_url = urlparse(url) # Parse the query parameters into a list of tuples query_params = parse_qsl(parsed_url.query, keep_blank_values=True) # Create an ordered dictionary to preserve the first occurrence of each query parameter filtered_params = {} for key, value in query_params: if key not in filtered_params and (params_to_strip is None or key not in params_to_strip): filtered_params[key] = value # Reconstruct the query string without duplicates and stripped parameters new_query_string = urlencode(filtered_params) # Rebuild the URL with the cleaned query string cleaned_url = urlunparse((parsed_url.scheme, parsed_url.netloc, parsed_url.path, parsed_url.params, new_query_string, parsed_url.fragment)) return cleaned_url"},{"question":"# Scenario You are working on a project that requires you to search for specific values within a dataset represented as a two-dimensional matrix. This matrix has the property that each row and each column is sorted in non-decreasing order. # Task Implement a Python function `search_matrix(matrix, key)` that takes a matrix and a key as inputs and returns a tuple `row, col` representing the position of the key within the matrix (0-based index). If the key is not found, return `(-1, -1)`. # Input * `matrix` (List[List[int]]): A 2D list representing the sorted matrix. * `key` (int): The value to search for within the matrix. # Output * A tuple `(row, col)`: Representing the position of the key in the matrix (0-based index), or `(-1, -1)` if the key is not found. # Constraints * The number of rows and columns in the matrix are both at least 1. * The elements of the matrix are integers. * Your solution should handle matrices up to a size of `1000 x 1000` reasonably efficiently. # Example ```python def main(): matrix = [ [ 1, 4, 7, 11, 15], [ 2, 5, 8, 12, 19], [ 3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] key = 5 print(search_matrix(matrix, key)) # Output: (1, 1) key = 20 print(search_matrix(matrix, key)) # Output: (-1, -1) if __name__ == \\"__main__\\": main() ``` # Performance Requirement Your implementation should run in O(m + n) time complexity.","solution":"def search_matrix(matrix, key): Searches for the key in a 2D matrix where each row and column is sorted in non-decreasing order. Returns the position (row, col) of the key if found, otherwise returns (-1, -1). if not matrix: return (-1, -1) rows = len(matrix) cols = len(matrix[0]) # Start searching from the top-right corner row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == key: return (row, col) elif matrix[row][col] > key: col -= 1 else: row += 1 return (-1, -1)"},{"question":"Scenario You are tasked to implement a stutter operation on a stack. The stutter operation duplicates each element of the stack. You need to demonstrate your understanding by implementing two approaches using different auxiliary structures—a stack and a queue. Task Write two functions, `stutter_with_stack` and `stutter_with_queue`, replicating the functionality described below. 1. **stutter_with_stack(stack)**: This function should use an auxiliary stack to duplicate each element in the stack. 2. **stutter_with_queue(stack)**: This function should use an auxiliary queue to duplicate each element in the stack. Each function should take one parameter: - `stack`: a list representing a stack with the top of the stack being the last element of the list. And return the modified stack with each element duplicated. Input - A list `stack` which represents the stack. - Constraints: 1 <= len(stack) <= 10^5, 1 <= stack[i] <= 10^9 Output - The same list reference passed to function, where each element in the original list is replaced with two occurrences of that element. # Example ```python # Example stack stack = [3, 7, 1, 14, 9] # After stutter_with_stack stutter_with_stack(stack) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] # After stutter_with_queue stutter_with_queue(stack) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` # Notes 1. Avoid defining unnecessary global variables. 2. Focus on efficient implementation to handle large inputs within constraints. 3. Ensure that both functions must return the modified stack for validation against the expected outcome.","solution":"def stutter_with_stack(stack): Duplicates each element in the stack using an auxiliary stack. :param stack: List of integers representing the stack :return: The modified stack with each element duplicated. auxiliary_stack = [] while stack: element = stack.pop() auxiliary_stack.append(element) auxiliary_stack.append(element) # auxiliary_stack now has elements in reverse order but duplicated while auxiliary_stack: stack.append(auxiliary_stack.pop()) return stack def stutter_with_queue(stack): Duplicates each element in the stack using an auxiliary queue. :param stack: List of integers representing the stack :return: The modified stack with each element duplicated. from collections import deque queue = deque() while stack: element = stack.pop() queue.appendleft(element) queue.appendleft(element) # queue now has elements in correct order but duplicated while queue: stack.append(queue.popleft()) return stack"},{"question":"# Scenario You are a systems analyst at a cybersecurity firm that is tasked with developing a new algorithm to maximize the stealing potential for inventory that is monitored by motion sensors. Your team needs to devise a solution to maximize stolen items without triggering adjacent sensors simultaneously. # Problem Statement Given a list of non-negative integers representing the value of items in a sequence, determine the maximum value you can collect without triggering any two adjacent sensors. Implement the function `max_loot` which takes a list of integers and returns the maximum value that can be collected. # Input - **houses**: A list of non-negative integers where each integer represents the value of items in that house. # Output - An integer representing the maximum value that can be collected without triggering adjacent sensors. # Constraints - The number of elements in the list is between 0 and (10^4). - Each element in the list is a non-negative integer and does not exceed (10^4). # Examples **Example 1:** ```python houses = [2, 3, 2] print(max_loot(houses)) # Output: 4 ``` **Example 2:** ```python houses = [1, 2, 3, 1] print(max_loot(houses)) # Output: 4 ``` **Example 3:** ```python houses = [0] print(max_loot(houses)) # Output: 0 ``` # Function Signature ```python def max_loot(houses: List[int]) -> int: pass ``` # Notes - Pay attention to edge cases such as an empty list or lists with only one element. - Ensure your solution is optimized for time and space complexity as described.","solution":"from typing import List def max_loot(houses: List[int]) -> int: if not houses: return 0 if len(houses) == 1: return houses[0] dp = [0] * len(houses) dp[0] = houses[0] if len(houses) > 1: dp[1] = max(houses[0], houses[1]) for i in range(2, len(houses)): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[-1]"},{"question":"**Problem Statement**: You are given a stack implemented as a list. Your task is to implement the function `is_sorted`, which takes this stack as input and returns `True` if the elements in the stack are in ascending order from bottom to top, and `False` otherwise. The function must restore the original order of the stack before returning the result. **Function Signature**: ```python def is_sorted(stack: List[int]) -> bool: ``` **Input**: * `stack`: A list of integers representing a stack. The bottom of the stack is the start of the list, and the top of the stack is the end of the list. For example, in the list `[1, 2, 3]`, `1` is at the bottom, and `3` is at the top. **Output**: * Return `True` if the elements are in ascending order from bottom to top. * Return `False` otherwise. **Constraints**: * Do not use any other data structure(s) except primitive data types (no deque, queue, etc.). Stack operations like `pop` and `append` are permissible. * The function must restore the input stack to its original state before returning the result. **Example**: ```python stack = [1, 2, 3, 4, 5, 6] print(is_sorted(stack)) # Output: True stack = [6, 5, 4, 3, 2, 1] print(is_sorted(stack)) # Output: False stack = [1, 3, 2, 4, 5, 6] print(is_sorted(stack)) # Output: False ``` # Additional Context: Imagine you are a software developer tasked with ensuring data integrity in an order processing system. Your stack represents a set of orders that must be executed in a specific sequence. Implementing the `is_sorted` function correctly is crucial for the smooth operation of this system.","solution":"def is_sorted(stack): Returns True if the elements in the stack are in ascending order from bottom to top, and False otherwise. if len(stack) <= 1: return True original_stack = stack.copy() temp_stack = [] while stack: temp_stack.append(stack.pop()) is_ascending = True while len(temp_stack) > 1: if temp_stack[-1] > temp_stack[-2]: is_ascending = False stack.append(temp_stack.pop()) stack.append(temp_stack.pop()) return is_ascending"},{"question":"# Problem: Subset Generation and Analysis Given a set of distinct integers `nums`, write a function `subsets(nums)` to return all possible subsets. The solution set must not contain duplicate subsets. Implement the function using both backtracking and iterative approaches, and ensure your implementation handles edge cases effectively. __Function Signature__: ```python def subsets(nums): # Your code here ``` __Parameters__: - `nums`: List of distinct integers, where 1 <= len(nums) <= 16. Each integer is distinct and within the range [-10, 10]. __Output__: - Returns a list of lists, where each inner list is a subset of `nums`. __Example__: ``` Input: nums = [1, 2, 3] Output: [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] ``` __Constraints__: - The order of subsets in the output list does not matter. - The input list `nums` will not contain duplicate elements. # Additional Requirements: 1. Implement the subset generation using a backtracking approach. 2. Implement the subset generation using an iterative approach. 3. Discuss the time and space complexity of both implementations. 4. Identify potential edge cases and handle them appropriately.","solution":"def subsets_backtracking(nums): Generate all possible subsets using backtracking approach. def backtrack(start, path): res.append(path) for i in range(start, len(nums)): backtrack(i + 1, path + [nums[i]]) res = [] backtrack(0, []) return res def subsets_iterative(nums): Generate all possible subsets using iterative approach. res = [[]] for num in nums: res += [curr + [num] for curr in res] return res"},{"question":"# Problem Context In real-time data streams, it\'s often necessary to maintain a rolling or moving average of the most recent \'n\' data points. This is particularly useful in fields such as finance, sensor data processing, and various other analytical applications. # Task Your task is to implement a class `EfficientMovingAverage` that better handles the memory and time complexity issues by using a running sum instead of repeatedly summing the contents of the window for each new data point. # Requirements 1. Implement the `__init__` method to initialize the data structure with the given window size. 2. Implement the `next` method that accepts a new integer value and returns the current moving average of the last \'n\' values. # Function Signature ```python class EfficientMovingAverage: def __init__(self, size: int): pass def next(self, val: int) -> float: pass ``` # Input * The class is instantiated with a single integer parameter `size`, representing the window size. * The `next` method will be called with integers, representing new data points in the stream. # Constraints * 1 <= size <= 10^4 * -10^4 <= val <= 10^4 * The methods `__init__` and `next` should run in O(1) time complexity. # Output * Each call to the `next` method should return a float representing the moving average of the last `size` data points. # Example ```python # Example Usage: m = EfficientMovingAverage(3) print(m.next(1)) # Output: 1.0 print(m.next(10)) # Output: 5.5 print(m.next(3)) # Output: 4.66667 print(m.next(5)) # Output: 6.0 ``` # Notes * Ensure precision up to 5 decimal places.","solution":"from collections import deque class EfficientMovingAverage: def __init__(self, size: int): Initialize the data structure with the given window size. self.size = size self.queue = deque(maxlen=size) self.sum = 0 def next(self, val: int) -> float: Accepts a new integer value and returns the current moving average of the last \'n\' values. if len(self.queue) == self.size: self.sum -= self.queue.popleft() self.queue.append(val) self.sum += val return self.sum / len(self.queue)"},{"question":"**Question:** You are tasked with implementing a Python function to remove duplicates from a list while maintaining the order of their first appearance. However, you need to optimize the solution to improve its efficiency from O(n^2) to O(n). # Requirements: 1. **Function Name**: `remove_duplicates_optimized` 2. **Input**: A list `array` which may contain elements of any hashable types (integers, strings, booleans, etc.). - Example: ```python array = [1, 1, 1, 2, 2, 3, 4, 4, \\"hey\\", \\"hey\\", \\"hello\\", True, True] ``` 3. **Output**: A new list containing unique elements preserving the order of their first appearance. - Example Output: ```python [1, 2, 3, 4, \'hey\', \'hello\'] ``` 4. **Constraints**: - The input list size can be up to 10^6 elements. - Each element in the input list can be of any hashable type. # Performance Requirements: The function should have a time complexity of O(n) where n is the number of elements in the input list. ```python def remove_duplicates_optimized(array): # Your optimized code here pass # Example usage array = [1, 1 ,1 ,2 ,2 ,3 ,4 ,4 ,\\"hey\\", \\"hey\\", \\"hello\\", True, True] print(remove_duplicates_optimized(array)) # Should return [1, 2, 3, 4, \'hey\', \'hello\'] ``` # Notes: * Focus on making your solution as efficient as possible. * Consider using data structures that support O(1) lookups.","solution":"def remove_duplicates_optimized(array): Removes duplicates from the list while maintaining the order of their first appearance. Args: array (list): The input list which may contain elements of any hashable type. Returns: list: A new list with duplicates removed while maintaining the order of their first appearance. seen = set() result = [] for item in array: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"# Matrix Exponentiation and Multiplication You have been provided functions for matrix multiplication, identity matrix creation, and matrix exponentiation. You are tasked to implement a function `pow_matrix_sum(mat: list, exponents: list) -> list` that calculates the sum of a matrix raised to multiple powers. Description Your function should take a square matrix `mat` of size `n x n` and a list of integers `exponents`. It should compute the sum of the given matrix raised to each power specified in the `exponents` list. Input 1. `mat`: List of lists representing an `n x n` square matrix. 2. `exponents`: List of integers representing the power to which the matrix should be raised. Output - A list of lists representing the resulting matrix obtained from the sum. Constraints - Matrix `mat` is of size (n times n), where (1 leq n leq 100). - Length of `exponents` is up to 10. - Each power in `exponents` is a non-negative integer and does not exceed 100,000. - Use the provided `multiply`, `identity`, and `matrix_exponentiation` functions for your implementation. Example ```python mat = [ [1, 2], [3, 4] ] exponents = [1, 2, 3] Resulting matrix should be: [ [1, 2], [3, 4] ] + [ [7, 10], [15, 22] ] + [ [37, 54], [81, 118] ] = [ [45, 66], [99, 144] ] Hence, pow_matrix_sum(mat, exponents) should return: [ [45, 66], [99, 144] ] ``` Implementation Ensure your implementation is efficient given the constraints. ```python def pow_matrix_sum(mat: list, exponents: list) -> list: Returns the sum of the matrix `mat` raised to each power in `exponents`. n = len(mat) result = [[0] * n for _ in range(n)] for power in exponents: exp_mat = matrix_exponentiation(mat, power) for i in range(n): for j in range(n): result[i][j] += exp_mat[i][j] return result ``` Implement the `pow_matrix_sum` function to validate the example and constraints.","solution":"def multiply(mat1, mat2): Multiplies two matrices mat1 and mat2. n = len(mat1) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): for k in range(n): result[i][j] += mat1[i][k] * mat2[k][j] return result def identity(size): Returns an identity matrix of given size. result = [[0] * size for _ in range(size)] for i in range(size): result[i][i] = 1 return result def matrix_exponentiation(mat, power): Exponentiates matrix \'mat\' to the specified \'power\'. n = len(mat) result = identity(n) base = mat while power > 0: if power % 2 == 1: result = multiply(result, base) base = multiply(base, base) power //= 2 return result def pow_matrix_sum(mat, exponents): Returns the sum of the matrix `mat` raised to each power in `exponents`. n = len(mat) result = [[0] * n for _ in range(n)] for power in exponents: exp_mat = matrix_exponentiation(mat, power) for i in range(n): for j in range(n): result[i][j] += exp_mat[i][j] return result"},{"question":"# Problem: Enhanced Pigeonhole Sort Implementation **Context**: You are tasked with sorting a collection of integer numbers efficiently using a variation of Pigeonhole Sort. Your goal is to extend its functionality to handle potential edge cases more robustly and to work efficiently within given constraints. **Requirements**: 1. Implement the function `enhanced_pigeonhole_sort(arr)`. 2. Ensure that the function handles both small and large ranges effectively. # Function Signature ```python def enhanced_pigeonhole_sort(arr: List[int]) -> List[int]: pass ``` # Input * A list of integers: `arr` (0 ≤ len(arr) ≤ 10^6; -10^6 ≤ arr[i] ≤ 10^6 for all i). * The list can contain duplicate values and may be empty. # Output * A sorted list of integers. # Constraints 1. The algorithm should maintain linear time complexity where applicable. 2. Memory usage should be optimized for large ranges. # Examples ```python # Example 1: # Input arr = [8, 3, 2, 7, 4] # Output # [2, 3, 4, 7, 8] # Example 2: # Input arr = [5, -3, 5, 2, -1, 4, 0] # Output # [-3, -1, 0, 2, 4, 5, 5] # Example 3: # Input arr = [] # Output # [] ``` # Hints 1. Use an auxiliary array (`holes`) for counting occurrences of elements. 2. Ensure your implementation handles large ranges efficiently to prevent excessive memory usage.","solution":"def enhanced_pigeonhole_sort(arr): if len(arr) == 0: return [] min_val = min(arr) max_val = max(arr) size = max_val - min_val + 1 holes = [0] * size for num in arr: holes[num - min_val] += 1 sorted_arr = [] for i in range(size): while holes[i] > 0: sorted_arr.append(i + min_val) holes[i] -= 1 return sorted_arr"},{"question":"Flatten Nested Arrays Context You are given a complex data processing task where input data comes in the form of nested arrays. To facilitate this processing, you need to flatten these arrays into a single-level array. Task Implement a function `flatten_array` that takes a nested list as input and returns a single flattened list. Function Signature ```python def flatten_array(nested_list: list) -> list: pass ``` Input - A list, `nested_list`, which can contain integer and/or nested lists. Output - A single list containing all the elements of `nested_list` in the same order they appear, but without any nesting. Constraints - The elements of `nested_list` can be integers or lists. - The function should handle deeply nested lists. - Strings within the list should not be treated as iterables to be expanded. Examples ```python assert flatten_array([1, [2, 3, [4]], 5]) == [1, 2, 3, 4, 5] assert flatten_array([[1, 2, [3, 4]], [5, 6], 7]) == [1, 2, 3, 4, 5, 6, 7] assert flatten_array([1, \'a\', [2, [\'b\', 3]], 4]) == [1, \'a\', 2, \'b\', 3, 4] assert flatten_array([]) == [] ``` Performance Requirements - The solution should be optimized for both time and space complexity, leveraging either recursion safely or using iterative approaches where applicable.","solution":"def flatten_array(nested_list): Flattens a nested list into a single-level list. :param nested_list: List of nested lists and integers :return: Flattened list of integers result = [] def _flatten(lst): for item in lst: if isinstance(item, list): _flatten(item) else: result.append(item) _flatten(nested_list) return result"},{"question":"# Scenario You are given a project to implement a feature in a custom library that manipulates linked lists. One of the core functions required is the ability to reverse the elements of a singly linked list. This task is fundamental but crucial for other linked list manipulations that the library will perform. You are expected to provide a reliable and efficient implementation. # Task Implement a function `reverse_linked_list` that reverses a singly linked list. The function should handle both empty lists and lists with multiple elements properly. # Requirements 1. **Input Definition** * The function will receive the head node of the singly linked list. Each node is defined using a `ListNode` class as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` 2. **Output Definition** * The function should return the new head node of the reversed linked list. # Constraints * **Performance**: The solution should be efficient, aiming for O(n) time complexity and minimal space overhead. * **Linked List Size**: Assume the list can contain (n) nodes where (0 leq n leq 10^6). # Example ```python # Example: # Input: 1 -> 2 -> 3 -> 4 -> None # Output: 4 -> 3 -> 2 -> 1 -> None def reverse_linked_list(head: ListNode) -> ListNode: # Your implementation here # Test the function using the provided input and output example def print_list(head): while head: print(head.val, \\"->\\", end=\\" \\") head = head.next print(\\"None\\") head = ListNode(1, ListNode(2, ListNode(3, ListNode(4)))) new_head = reverse_linked_list(head) print_list(new_head) # Expected Output: 4 -> 3 -> 2 -> 1 -> None ``` **Deliverable**: Implement the `reverse_linked_list` function following the given requirements and constraints.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: Reverses a singly linked list. Parameters: head (ListNode): Head node of the singly linked list. Returns: ListNode: New head node of the reversed linked list. prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"**Objective**: Implement both iterative and recursive versions of a binary search algorithm in Python. The function should return the index where the specified element is found or -1 if the element is not present in the array. # Input 1. A sorted list of integers `arr` (1 ≤ len(arr) ≤ 10^5) 2. An integer `target` to search for in the array. # Output - An integer index where `target` is found in `arr`, or -1 if not found. # Function Signatures ```python def binary_search(array: List[int], target: int) -> int: def binary_search_recur(array: List[int], low: int, high: int, target: int) -> int: ``` # Constraints & Limitations - The array `arr` is sorted in ascending order. - Optimize for both time and space complexity. - Handle edge cases such as empty arrays or non-existent targets correctly. # Example Input ```python arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] target = 5 ``` Output ```python 4 ``` Explanation The element `5` is found at index `4` in the array. # Notes 1. Make sure both iterative and recursive versions return the correct result. 2. Focus on validating edge cases and optimizing the implementation.","solution":"from typing import List def binary_search(array: List[int], target: int) -> int: Iterative version of binary search to find the index of target in a sorted array. Returns -1 if the target is not found. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: low = mid + 1 else: high = mid - 1 return -1 def binary_search_recur(array: List[int], low: int, high: int, target: int) -> int: Recursive version of binary search to find the index of target in a sorted array. Returns -1 if the target is not found. if low > high: return -1 mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: return binary_search_recur(array, mid + 1, high, target) else: return binary_search_recur(array, low, mid - 1, target)"},{"question":"You are provided with an n x n square matrix representing an image. Your task is to write a function that rotates this matrix by 90 degrees clockwise in-place. # Function Details: **Function Signature:** ```python def rotate_image_90_clockwise(matrix: List[List[int]]) -> None: ... ``` **Input:** - `matrix`: List of lists, where each inner list represents a row in an n x n grid. (1 <= n <= 1000) **Output:** - The function should modify the `matrix` in-place to achieve the 90-degree clockwise rotation. # Constraints: - You must solve the problem in-place. - You cannot use any additional data structures to store the matrix. - Any modifications should be directly made to the input matrix. # Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_image_90_clockwise(matrix) print(matrix) ``` **Expected Output:** ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` # Explanation: Following the 90 degrees clockwise rotation: - The first row `[1, 2, 3]` becomes the last column `[7, 4, 1]`. - The second row `[4, 5, 6]` becomes the second column `[8, 5, 2]`. - The third row `[7, 8, 9]` becomes the first column `[9, 6, 3]`. # Requirements: - Aim for an in-place solution without using additional space. - Ensure the solution handles all edge cases effectively, including the minimum and maximum constraint values.","solution":"from typing import List def rotate_image_90_clockwise(matrix: List[List[int]]) -> None: Rotates the input n x n matrix by 90 degrees clockwise in-place. Args: matrix (List[List[int]]): The n x n matrix to be rotated. Returns: None: The function modifies the matrix in-place. n = len(matrix) # Transpose the matrix (swap rows with columns) for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Question: One-Row Keyboard Words You are tasked with writing a function that filters and returns words that can be typed using letters from only one row of an American keyboard. The American keyboard is laid out as follows: - Top row: QWERTYUIOP - Middle row: ASDFGHJKL - Bottom row: ZXCVBNM # Function Signature: ```python def find_keyboard_row(words: List[str]) -> List[str]: pass ``` # Input: * `words` (List[str]): A list of words (non-empty strings, and it could be empty). # Output: * List[str]: A list of words from the input that can be typed using letters from only one of the three rows of the keyboard. # Constraints: * The input words contain only English letters. * The comparison should be case-insensitive (i.e., \\"Hello\\" should be treated the same as \\"hello\\"). * The function should return the words in the same order as they appear in the input list. # Examples: ```python assert find_keyboard_row([\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"]) == [\\"Alaska\\", \\"Dad\\"] assert find_keyboard_row([\\"omg\\", \\"row\\", \\"Wow\\"]) == [\\"omg\\"] assert find_keyboard_row([]) == [] assert find_keyboard_row([\\"\\"]) == [] ``` # Scenario: Imagine you are using an emulator that only allows you to type words from one row of the keyboard at a time. To check if your phrase can be correctly typed, you need a program to verify every word in the phrase and retain only the words that can be entirely typed using characters from one specific row of the American keyboard.","solution":"from typing import List def find_keyboard_row(words: List[str]) -> List[str]: top_row = set(\\"qwertyuiop\\") middle_row = set(\\"asdfghjkl\\") bottom_row = set(\\"zxcvbnm\\") def is_single_row(word): word_set = set(word.lower()) return (word_set <= top_row) or (word_set <= middle_row) or (word_set <= bottom_row) return [word for word in words if is_single_row(word)]"},{"question":"# Problem Description You need to write a function that finds the number of possible combinations that add up to a positive integer target given an array of positive integers without duplicates. The array elements can be used multiple times, and different sequences of the same combination should be counted as distinct. # Function Signature ```python def num_combinations(nums: List[int], target: int) -> int: ``` # Input - `nums` : a list of integers (1 ≤ length of nums ≤ 100, 1 ≤ nums[i] ≤ 100) - `target`: a positive integer (1 ≤ target ≤ 1000) # Output - Return an integer representing the number of possible combinations that add up to `target`. # Constraints - All integers in `nums` are positive and without duplicates. - The target is a positive integer. # Example ```python nums = [1, 2, 3] target = 4 num_combinations(nums, target) # Output: 7 ``` # Explanation The possible combination ways are: (1, 1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 3), (2, 1, 1), (2, 2), (3, 1) # Follow-Up - If negative numbers are allowed, how would that change the problem? - What limitation would you need to add to allow negative numbers without causing infinite loops? # Advanced Challenge Implement both the top-down (memoized recursive) and bottom-up (iterative) dynamic programming approaches in your solution.","solution":"from typing import List def num_combinations(nums: List[int], target: int) -> int: Returns the number of possible combinations that add up to the target given an array of positive integers without duplicates. The elements can be used multiple times and different sequences of the same combination are counted as distinct. # Initialize a list to store the number of ways to form each sum up to target dp = [0] * (target + 1) # Base case: there is one way to form the sum 0, which is not to use any elements dp[0] = 1 # Iterate over each target sum from 1 to the actual target for t in range(1, target + 1): for num in nums: if t - num >= 0: dp[t] += dp[t - num] return dp[target]"},{"question":"# Scenario You are working on a simple text compression tool to help reduce the size of text data stored in your database. The primary method you plan to use is Run-length Encoding (RLE), which will handle the repetitive character sequences efficiently. Your task is to implement two functions: one that compresses the text using RLE (encoding) and another that reverses the compression (decoding). # Function Requirements Function: `encode_rle(input: str) -> str` * **Input**: A string `input` containing the text to be compressed. * **Output**: A string representing the RLE compressed text. * **Constraints**: * The input string may contain any printable characters. * Handle empty strings gracefully. Function: `decode_rle(input: str) -> str` * **Input**: A string `input` containing the RLE compressed text. * **Output**: The original uncompressed text. * **Constraints**: * The RLE format in the input string will be valid. * Handle empty strings gracefully. # Example ```python assert encode_rle(\\"aaabbcc\\") == \\"3a2b2c\\" assert encode_rle(\\"\\") == \\"\\" assert decode_rle(\\"3a2b2c\\") == \\"aaabbcc\\" assert decode_rle(\\"\\") == \\"\\" ``` # Notes - Ensure that your solution can handle edge cases like an input string of length 1, strings with special characters, and very large strings effectively. - The decoding function should properly interpret numerical counts followed by characters to reconstruct the original string precisely. Implement both functions in a concise and efficient manner.","solution":"def encode_rle(input: str) -> str: Compresses the text using Run-length Encoding (RLE). if not input: return \\"\\" encoded = [] count = 1 for i in range(1, len(input)): if input[i] == input[i - 1]: count += 1 else: encoded.append(f\\"{count}{input[i - 1]}\\") count = 1 encoded.append(f\\"{count}{input[-1]}\\") return \'\'.join(encoded) def decode_rle(input: str) -> str: Decompresses the text using Run-length Encoding (RLE) format. if not input: return \\"\\" decoded = [] count = [] for char in input: if char.isdigit(): count.append(char) else: decoded.append(char * int(\'\'.join(count))) count = [] return \'\'.join(decoded)"},{"question":"# Problem: Implementing an Efficient Contact Manager You are building an efficient contact manager for a mobile application. The contact manager should support the following operations: - **Inserting a new contact name**: Adding a new contact to the user\'s contact list. - **Searching for an existing contact name**: Checking if a contact name exists in the user\'s contact list. - **Searching for contacts by prefix**: Retrieving all contact names that start with a given prefix. You are required to implement a class `ContactManager` using the Trie data structure provided in the code snippets. Implement the following methods: - `insert(self, name: str) -> None` - `search(self, name: str) -> bool` - `starts_with(self, prefix: str) -> List[str]` # Requirements 1. **Functionality**: - `insert(name: str)`: Adds the contact name to the Trie. - `search(name: str)`: Returns `True` if the contact name is in the Trie, otherwise `False`. - `starts_with(prefix: str)`: Returns a list of all contact names starting with the given prefix. If no contacts match the prefix, return an empty list. 2. **Constraints**: - You may assume all inputs are lowercase letters (a-z). - Contact names and prefixes will each have a maximum length of 100. - No two contact names will be the same. 3. **Performance**: Optimize the solution to handle up to 10^4 contacts efficiently. # Example: ```python cm = ContactManager() cm.insert(\\"alice\\") cm.insert(\\"bob\\") cm.insert(\\"alina\\") assert cm.search(\\"alice\\") == True assert cm.search(\\"al\\") == False assert cm.starts_with(\\"al\\") == [\\"alice\\", \\"alina\\"] assert cm.starts_with(\\"bo\\") == [\\"bob\\"] assert cm.starts_with(\\"z\\") == [] ``` Implement the methods in the `ContactManager` class to fulfill the above requirements.","solution":"class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class ContactManager: def __init__(self): self.root = TrieNode() def insert(self, name: str) -> None: node = self.root for char in name: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.end_of_word = True def search(self, name: str) -> bool: node = self.root for char in name: if char not in node.children: return False node = node.children[char] return node.end_of_word def starts_with(self, prefix: str) -> list: result = [] node = self.root for char in prefix: if char not in node.children: return result node = node.children[char] self._dfs(node, prefix, result) return result def _dfs(self, node, prefix, result): if node.end_of_word: result.append(prefix) for char, next_node in node.children.items(): self._dfs(next_node, prefix + char, result)"},{"question":"# Question: Determine Typable Words Using One Keyboard Row Description: Given a list of words, write a function `find_keyboard_row` that returns the words that can be typed using letters of the alphabet on only one row of an American keyboard. The rows on the keyboard are defined as follows: 1. The first row consists of the letters: \\"QWERTYUIOP\\" 2. The second row consists of the letters: \\"ASDFGHJKL\\" 3. The third row consists of the letters: \\"ZXCVBNM\\" The function should be case-insensitive, meaning that the input \\"Hello\\" should be treated the same as \\"hello\\". Input: - A list of words (list of strings), e.g., `[\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"]`. Output: - A list of words (list of strings) that can be typed using one keyboard row, e.g., `[\\"Alaska\\", \\"Dad\\"]`. Constraints: - The list of words can be of any length between 0 and 10^4. - Each word consists of only alphabetic characters and has a length between 1 and 100. Example: ```python Input: [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] Output: [\\"Alaska\\", \\"Dad\\"] ``` Requirements: - The solution should be efficient with a clear and concise implementation. - Consider edge cases such as mixed-case words and empty input lists. - The solution should also handle words with non-alphabet characters gracefully (e.g., filtering such words out). Implement the function `find_keyboard_row(words)` that fulfills the above requirements.","solution":"def find_keyboard_row(words): Returns a list of words that can be typed using letters of the alphabet on only one row of an American keyboard. Args: words : list of str : List of words to check Returns: list of str : List of words that can be typed using one keyboard row row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") def can_type_with_one_row(word): word_set = set(word.lower()) return word_set <= row1 or word_set <= row2 or word_set <= row3 return [word for word in words if can_type_with_one_row(word)]"},{"question":"Context You are working on a file management system where users can provide file paths for various operations such as reading and writing files. For consistency and to avoid errors, you need to ensure that all paths are absolute paths with any user references properly resolved. Task Write a function `compute_absolute_path` that takes a single string input representing a file path, and returns its absolute path after expanding any user references. The input path could be a relative path, a path containing a user\'s home directory reference, or an already absolute path. Function Signature ```python def compute_absolute_path(file_path: str) -> str: pass ``` Input - `file_path` (string): A file path which may be relative, contain user home references, or be absolute. Output - (string): The corresponding absolute file path after resolving any user home references. Constraints - The input file path string will have a length of up to 1000 characters. - The function should handle different edge cases, such as paths with `~` and empty paths. - Exceptions or invalid input should return a message `\\"Invalid file path\\"`. Example ```python # Example 1 input: \\"some/relative/path\\" output: \\"/home/user/some/relative/path\\" # Assuming the home directory is /home/user # Example 2 input: \\"~/projects\\" output: \\"/home/user/projects\\" # Assuming the home directory is /home/user ``` Requirements - Ensure the function works efficiently within the given constraints. - Handle edge cases and invalid inputs gracefully.","solution":"import os def compute_absolute_path(file_path: str) -> str: Convert the provided file path to its absolute path, resolving \'~\' and other user home references. Return \'Invalid file path\' for invalid inputs. if not isinstance(file_path, str) or file_path == \\"\\": return \\"Invalid file path\\" try: absolute_path = os.path.expanduser(file_path) # Resolve \'~\' to home directory absolute_path = os.path.abspath(absolute_path) # Convert to absolute path return absolute_path except Exception: return \\"Invalid file path\\""},{"question":"# Palindromic Substrings Count Given a string, your task is to implement a function that returns the number of palindromic substrings in it. A string is considered a palindrome if it reads the same backward as forward, and for this problem, each substring must contain only alphanumeric characters and ignore cases. Function signature: ```python def count_palindromic_substrings(s: str) -> int: pass ``` # Input: * `s`: A string of length n (0 ≤ n ≤ 1000). # Output: * An integer representing the number of palindromic substrings. # Constraints: * Each substring must contain only alphanumeric characters and ignore cases. * Use an efficient algorithm to ensure that your solution runs within a reasonable time frame for large inputs. # Examples: 1. For `s = \\"Aba\\"`, the possible palindromic substrings are: \\"A\\", \\"b\\", \\"a\\", \\"Aba\\", making the count 4. 2. For `s = \\"racecar\\"`, the possible palindromic substrings are: \\"r\\", \\"a\\", \\"c\\", \\"e\\", \\"c\\", \\"a\\", \\"r\\", \\"cec\\", \\"aceca\\", \\"racecar\\", making the count 10. 3. For `s = \\"a\\"`, the possible palindromic substrings are: \\"a\\", making the count 1. 4. For `s = \\"\\"`, the output should be 0. # Approach: You may use any algorithm that effectively finds and counts all palindromic substrings in a given input string, such as: - Expanding from Centers - Dynamic Programming - Any other efficient approach Be sure to handle edge cases appropriately and optimize for time and space where possible.","solution":"def count_palindromic_substrings(s: str) -> int: def is_palindrome(sub): return sub == sub[::-1] s = \'\'.join(filter(str.isalnum, s)).lower() # Normalize the string n = len(s) count = 0 for start in range(n): for end in range(start, n): if is_palindrome(s[start:end+1]): count += 1 return count"},{"question":"# Substring Search Optimization Given two strings `haystack` and `needle`, write a function `strStr` to find the first occurrence of the substring `needle` in `haystack`. If `needle` is not found in `haystack`, return `-1`. Your task is to optimize the provided brute force implementation using a more efficient algorithm. The aim is to reduce the time complexity of the search to `O(n + m)` where `n` is the length of the `haystack` and `m` is the length of the `needle`. Input: - `haystack`: A non-null string, can be empty. - `needle`: A non-null string, can be empty. Output: - An integer representing the index of the first occurrence of `needle` in `haystack` or `-1` if `needle` is not found. Constraints: - The length of `haystack` and `needle` will not exceed `10^5`. Examples: ```python assert strStr(\\"hello\\", \\"ll\\") == 2 assert strStr(\\"aaaaa\\", \\"bba\\") == -1 assert strStr(\\"\\", \\"\\") == 0 assert strStr(\\"abc\\", \\"\\") == 0 ``` Performance Requirements: - The solution should have a linear time complexity relative to the lengths of `haystack` and `needle`. Scenario: Imagine you are developing a text editor, and you need to implement a \\"find\\" feature that can efficiently locate a word or phrase within large documents. Your task is to provide an optimized search implementation that ensures quick responses even for large texts.","solution":"def strStr(haystack, needle): Finds the first occurrence of the substring needle in haystack. Returns the index of the first occurrence, or -1 if needle is not found. This implementation uses the Knuth-Morris-Pratt (KMP) algorithm. def build_lps(pattern): Builds the longest proper prefix which is also suffix (lps) array used in KMP algorithm. lps = [0] * len(pattern) length = 0 # length of the previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps if not needle: return 0 if not haystack: return -1 lps = build_lps(needle) i = j = 0 # i -> index for haystack, j -> index for needle while i < len(haystack): if haystack[i] == needle[j]: i += 1 j += 1 if j == len(needle): # found the needle return i - j elif i < len(haystack) and haystack[i] != needle[j]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"# Question: Implement an Improved Randomized Set You are tasked with implementing an improved version of the `RandomizedSet` data structure that supports the following operations efficiently: 1. **insert(val)**: Inserts a value into the set if it is not already present. 2. **remove(val)**: Removes a value from the set if it is present. 3. **random_element()**: Returns a random element from the set with equal probability. Each of these operations should be optimized to run in average O(1) time. Input and Output Formats * `insert(val: int) -> bool`: Inserts the integer `val` into the set. Returns `True` if the element was inserted (i.e., it was not already present), or `False` otherwise. * `remove(val: int) -> bool`: Removes the integer `val` from the set. Returns `True` if the element was removed (i.e., it was present in the set), or `False` otherwise. * `random_element() -> int`: Returns a random integer from the current set of elements. Each element should have equal probability of being returned. If the set is empty, a suitable exception (e.g., `IndexError`) should be raised. Constraints - The operations must run in average O(1) time complexity. - The set should handle a substantial number of elements efficiently (up to (10^6)). Scenario Consider a scenario where you are managing a high-performance randomized testing framework. Your tool needs to dynamically handle a set of test cases, supporting quick additions and removals, and it also needs to quickly fetch a random test case for execution. Implementation You are required to implement the following methods in class `ImprovedRandomizedSet`: ```python import random class ImprovedRandomizedSet: def __init__(self): Initialize the data structure here. self.elements = [] self.index_map = {} def insert(self, val: int) -> bool: Inserts a value into the set. Returns True if the element was inserted, or False if it was already present. pass def remove(self, val: int) -> bool: Removes a value from the set. Returns True if the element was removed, or False if it was not present. pass def random_element(self) -> int: Returns a random element from the current set of elements. Raises IndexError if the set is empty. pass ``` Ensure that your implementation correctly handles edge cases and maintains the average O(1) time complexity for all operations.","solution":"import random class ImprovedRandomizedSet: def __init__(self): Initialize the data structure here. self.elements = [] self.index_map = {} def insert(self, val: int) -> bool: Inserts a value into the set. Returns True if the element was inserted, or False if it was already present. if val in self.index_map: return False self.index_map[val] = len(self.elements) self.elements.append(val) return True def remove(self, val: int) -> bool: Removes a value from the set. Returns True if the element was removed, or False if it was not present. if val not in self.index_map: return False last_element = self.elements[-1] idx_to_remove = self.index_map[val] self.elements[idx_to_remove] = last_element self.index_map[last_element] = idx_to_remove self.elements.pop() del self.index_map[val] return True def random_element(self) -> int: Returns a random element from the current set of elements. Raises IndexError if the set is empty. if not self.elements: raise IndexError(\\"The set is empty.\\") return random.choice(self.elements)"},{"question":"<|Analysis Begin|> # Algorithm Analysis Core Identification * **Algorithm/Data Structure**: Sudoku Solver using Depth-First Search (DFS) with Constraint Propagation. * **Complexity**: * **Time Complexity**: Typically, the worst-case time complexity for solving Sudoku using DFS with constraint propagation is O(9^(n^2)), where n is the board size (n=9 for standard Sudoku). However, constraint propagation significantly reduces the number of computations. * **Space Complexity**: O(n^2) for the storage of the board and possible values. * **Principles**: - Initialize a hash table to keep track of possible values for each cell. - Use DFS to attempt to solve the board, starting from the cell with the fewest possibilities. - Propagate constraints by updating possible values for other cells upon taking a value. Characteristics & Applications * **Properties**: - Uses backtracking to navigate through possible values and undo invalid choices. - Employs constraint propagation to reduce the search space effectively. * **Common Use Cases**: - Solving Sudoku puzzles. - Constraint satisfaction problems where pruning out invalid possibilities is necessary. * **Strengths/Limitations**: - **Strengths**: Efficiently narrows down possibilities using constraints, fast due to minimized search space. - **Limitations**: DFS may still be computationally expensive for highly constrained or unsolvable puzzles, requires managing the updates of potential values accurately. Implementation Challenges * **Edge Cases**: - Initial board is unsolvable. - Multiple solutions or no solution. - Invalid input (non-Sudoku configurations). * **Performance Bottlenecks**: - Too broad initial possibilities leading to intensive backtracking. - de/or removing elements from large possibilities list. * **Error Scenarios**: - Incorrect handling of updates leading to invalid board states. - Infinite loops due to faulty constraint propagation. * **Optimization Points**: - Further simplification of PossibleVals function. - Parallel computations for constraint propagation in each region/row/column. <|Analysis End|> <|Question Begin|> # Sudoku Solver Coding Challenge Objective You need to implement a Sudoku solver that uses Depth-First Search (DFS) and constraint propagation techniques to efficiently solve the given Sudoku puzzle. Problem Statement Given a 9x9 Sudoku board, implement a function that solves the puzzle and outputs a valid solved board. The board will contain digits (1-9) and empty cells represented by \\".\\". # Function Signature ```python def solve_sudoku(board: List[List[str]]) -> None: Solves the Sudoku puzzle by filling the empty cells in-place. Args: board (List[List[str]]): 2D list representing the Sudoku board with \'1\'-\'9\' and \'.\' for empty cells. Returns: None: The function modifies the input \'board\' in-place to reflect the solved Sudoku. ``` # Input - `board` is a list of lists with dimensions 9x9. - Each element of the list is a string character (\'1\'-\'9\') or \'.\'. # Output - The function should update the input board in-place with the solved Sudoku. # Constraints - The input board will have exactly 9 rows and 9 columns. - There will be at least one solution to the Sudoku. # Example Input: ```python board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] ``` Output: ```python [ [\\"5\\",\\"3\\",\\"4\\",\\"6\\",\\"7\\",\\"8\\",\\"9\\",\\"1\\",\\"2\\"], [\\"6\\",\\"7\\",\\"2\\",\\"1\\",\\"9\\",\\"5\\",\\"3\\",\\"4\\",\\"8\\"], [\\"1\\",\\"9\\",\\"8\\",\\"3\\",\\"4\\",\\"2\\",\\"5\\",\\"6\\",\\"7\\"], [\\"8\\",\\"5\\",\\"9\\",\\"7\\",\\"6\\",\\"1\\",\\"4\\",\\"2\\",\\"3\\"], [\\"4\\",\\"2\\",\\"6\\",\\"8\\",\\"5\\",\\"3\\",\\"7\\",\\"9\\",\\"1\\"], [\\"7\\",\\"1\\",\\"3\\",\\"9\\",\\"2\\",\\"4\\",\\"8\\",\\"5\\",\\"6\\"], [\\"9\\",\\"6\\",\\"1\\",\\"5\\",\\"3\\",\\"7\\",\\"2\\",\\"8\\",\\"4\\"], [\\"2\\",\\"8\\",\\"7\\",\\"4\\",\\"1\\",\\"9\\",\\"6\\",\\"3\\",\\"5\\"], [\\"3\\",\\"4\\",\\"5\\",\\"2\\",\\"8\\",\\"6\\",\\"1\\",\\"7\\",\\"9\\"] ] ``` # Notes - Do not return the result; modify the `board` in-place. - Utilize DFS and constraint propagation strategy to avoid excessive computation. - Test your solution against various edge cases (initial board nearly solved, a board with minimal clues, etc.)","solution":"from typing import List def solve_sudoku(board: List[List[str]]) -> None: Solves the Sudoku puzzle by filling the empty cells in-place. Args: board (List[List[str]]): 2D list representing the Sudoku board with \'1\'-\'9\' and \'.\' for empty cells. Returns: None: The function modifies the input \'board\' in-place to reflect the solved Sudoku. def is_valid(board, row, col, num): # Check if num is not in the current row for x in range(9): if board[row][x] == num: return False # Check if num is not in the current column for x in range(9): if board[x][col] == num: return False # Check if num is not in the current 3x3 sub-grid start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(3): for j in range(3): if board[i + start_row][j + start_col] == num: return False return True def solve(): for i in range(9): for j in range(9): if board[i][j] == \'.\': for num in \'123456789\': if is_valid(board, i, j, num): board[i][j] = num if solve(): return True board[i][j] = \'.\' return False return True solve()"},{"question":"You are given the task of implementing a function to compute the binomial coefficient ( C(n, k) ) using dynamic programming instead of recursion. The binomial coefficient ( C(n, k) ) represents the number of ways to choose ( k ) elements from a set of ( n ) elements. # Function Signature ```python def dp_binomial_coefficient(n: int, k: int) -> int: pass ``` # Input * An integer `n` (0 ≤ n ≤ 1000) representing the total number of items. * An integer `k` (0 ≤ k ≤ n) representing the number of items to choose. # Output * Return the binomial coefficient ( C(n, k) ) as an integer. # Constraints * ( 0 leq n leq 1000 ) * ( 0 leq k leq n ) # Example ```python assert dp_binomial_coefficient(5, 0) == 1 assert dp_binomial_coefficient(8, 2) == 28 assert dp_binomial_coefficient(10, 5) == 252 ``` # Explanation Implement the function using dynamic programming to optimize performance and avoid deep recursion. You may use a 2D table to store intermediate results to compute the binomial coefficient efficiently. **Scenario** In a data analysis project, you might need to compute combinations efficiently to evaluate various combination-based metrics. This problem aims to assess your ability to translate a recursive algebraic formulation into an iterative dynamic programming solution.","solution":"def dp_binomial_coefficient(n: int, k: int) -> int: Compute the binomial coefficient C(n, k) using dynamic programming. :param n: Total number of items. :param k: Number of items to choose. :return: Binomial coefficient C(n, k). if k > n: return 0 if k == 0 or k == n: return 1 # Create a 2D table to store results of subproblems dp = [[0 for _ in range(k + 1)] for _ in range(n + 1)] # Calculate value of Binomial Coefficient in bottom up manner for i in range(n + 1): for j in range(min(i, k) + 1): # Base cases if j == 0 or j == i: dp[i][j] = 1 else: dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] return dp[n][k]"},{"question":"# Cycle Sort Challenge Cycle Sort is an in-place sorting algorithm known for its minimal write operations which can be particularly useful in scenarios where write operations are costly. Your task is to implement an optimized version of the cycle sort algorithm and ensure it handles common edge cases correctly. # Problem Statement Given a list of integers, implement the Cycle Sort algorithm to sort the list in ascending order. # Function Signature ```python def cycle_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr`: A list of integers, where (1 leq text{len}(arr) leq 10^4). # Output * A list of integers sorted in ascending order. # Constraints * You are required to perform the sort in-place. * The algorithm should efficiently handle arrays with duplicate values. # Performance Requirements * Write-efficient in-place sorting. * Aim for linear space complexity and handle up to (10^4) elements efficiently. # Example ```python >>> cycle_sort([3, 1, 5, 2, 4]) [1, 2, 3, 4, 5] >>> cycle_sort([4, 4, 4, 4]) [4, 4, 4, 4] >>> cycle_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] ``` # Edge Cases to Consider 1. An array with all identical elements. 2. An array that is already sorted. 3. An array in reverse order. 4. Arrays containing negative integers and zeros. Ensure that your implementation efficiently handles these and does not run into infinite loops or other logical errors.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: Performs an in-place Cycle Sort on the given list. n = len(arr) for cycle_start in range(0, n - 1): item = arr[cycle_start] # Find the position where we put the item pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Otherwise, put the item to the right position while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"You are tasked to design and implement two functions to encode and decode a list of strings: 1. **encode**: This function takes a list of strings and converts it into a single encoded string. 2. **decode**: This function takes the encoded string and converts it back into the original list of strings. # Function Definition ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str # your code here def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] # your code here ``` # Input and Output - **encode**: * **Input**: A list of strings `strs` (0 <= len(strs) <= 10000, 0 <= len(str) <= 1000 for each string). * **Output**: A single encoded string. - **decode**: * **Input**: A single encoded string `s`. * **Output**: The original list of strings `strs`. # Constraints - You may assume all strings contain only printable ASCII characters. - Ensure that the algorithms handle edge cases such as empty lists and strings. # Example ```python strs = [\\"hello\\", \\"world\\"] encoded_string = encode(strs) print(encoded_string) # \\"5:hello5:world\\" decoded_list = decode(encoded_string) print(decoded_list) # [\\"hello\\", \\"world\\"] ``` # Notes - Carefully consider edge cases like empty strings or lists. - Ensure the solution is efficient and handles large inputs within reasonable time and space limits. - Document your code for clarity.","solution":"def encode(strs): Encodes a list of strings to a single string by using length prefix and colon. :type strs: List[str] :rtype: str return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] res = [] i = 0 while i < len(s): # Find the length of the next string j = s.find(\':\', i) length = int(s[i:j]) i = j + 1 + length res.append(s[j+1:i]) return res"},{"question":"# Objective Implement a function that finds the first occurrence of a given element in a sorted array using the binary search algorithm. # Problem Statement You are given a sorted array of integers in non-decreasing order. Your task is to write a function that finds and returns the index of the first occurrence of a given integer element. If the element is not found, return -1. # Function Signature ```python def find_first_occurrence(arr: List[int], target: int) -> int: ``` # Input - `arr` (List[int]): A list of integers sorted in increasing order. - `target` (int): The integer to find. # Output - The zero-based index of the first occurrence of `target` in `arr`. If `target` is not present in `arr`, return -1. # Constraints 1. The array `arr` contains between 1 and 10^6 elements. 2. The elements in `arr` and the `target` are integers in the range of `-10^9` to `10^9`. # Example ```python # Example 1: arr = [1, 2, 2, 3, 4, 5, 5, 5, 6] target = 5 # Expected output: 5 # Example 2: arr = [1, 2, 2, 3, 4, 5, 5, 5, 6] target = 7 # Expected output: -1 # Example 3: arr = [5, 5, 5, 5, 5, 5, 5, 5, 5] target = 5 # Expected output: 0 # Example 4: arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] target = 1 # Expected output: 0 ``` # Notes 1. Be mindful of the edge cases where the target may appear more than once or not at all. 2. Ensure your solution runs in O(log n) time complexity.","solution":"from typing import List def find_first_occurrence(arr: List[int], target: int) -> int: Finds the first occurrence of the target in the sorted list arr. Returns the index of the first occurrence if found, otherwise returns -1. left, right = 0, len(arr) - 1 result = -1 while left <= right: mid = (left + right) // 2 if arr[mid] < target: left = mid + 1 elif arr[mid] > target: right = mid - 1 else: result = mid # potentially the first occurrence, keep searching in left half right = mid - 1 return result"},{"question":"# Intersection of Two Linked Lists Problem Statement You are given two singly linked lists. Write a function to find the node at which the two lists intersect. This node should be determined by reference, not by value. You need to return the node itself, not just its value. If the two linked lists have no intersection, return `None`. Function Signature ```python def find_intersection(head1: Node, head2: Node) -> Node: pass ``` Input - `head1` and `head2`: The head nodes of the two singly linked lists, represented by `Node` objects. Output - Return the node where the two linked lists intersect, or `None` if there is no intersection. Constraints - The number of nodes in both lists will be within the range `[0, 10^4]`. Example ``` List1: 1 -> 3 -> 5 7 -> 9 -> 11 / List2: 2 -> 4 -> 6 Input: head1, head2 Output: Node with value 7 ``` Additional Information - Ensure that your solution has a **time complexity** of ( O(n + m) ) and a **space complexity** of ( O(1) ). - Consider edge cases such as when one or both of the lists are empty, and when there is no intersection at all. - You can assume that there are no cycles in the input linked lists. # Hint You may use two-pointer technique to optimize your solution.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def find_intersection(head1: Node, head2: Node) -> Node: if not head1 or not head2: return None p1, p2 = head1, head2 while p1 != p2: p1 = p1.next if p1 else head2 p2 = p2.next if p2 else head1 return p1"},{"question":"You are tasked with implementing a function to remove duplicates from a singly linked list. You must write an efficient solution that balances both time and space complexity. Function Signature ```python def remove_duplicates(head: Node) -> Node: pass ``` Input * **head**: An instance of the `Node` class, representing the head of a singly linked list. * `Node` class has two fields: `val` (the value stored in the node) and `next` (a pointer to the next node). Output * The function should return the head of the linked list after all duplicates have been removed. Constraints * The linked list can have up to 10^6 nodes. * Node values can be any valid string or integer. Performance Requirements * Your solution should aim for O(N) time complexity and O(1) additional space complexity, if possible. Examples ```python class Node: def __init__(self, val = None): self.val = val self.next = None def print_linked_list(head: Node) -> None: elements = [] while head: elements.append(head.val) head = head.next print(\\" -> \\".join(map(str, elements))) # Example 1: head = Node(\\"A\\") head.next = Node(\\"A\\") head.next.next = Node(\\"B\\") head.next.next.next = Node(\\"C\\") head.next.next.next.next = Node(\\"D\\") head.next.next.next.next.next = Node(\\"C\\") head.next.next.next.next.next.next = Node(\\"F\\") head.next.next.next.next.next.next.next = Node(\\"G\\") new_head = remove_duplicates(head) print_linked_list(new_head) # Output: \\"A -> B -> C -> D -> F -> G\\" # Example 2: head = Node(1) head.next = Node(1) head.next.next = Node(1) new_head = remove_duplicates(head) print_linked_list(new_head) # Output: \\"1\\" ```","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates(head: Node) -> Node: if not head: return head current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next return head"},{"question":"# Graph Cloning Challenge You are given an undirected graph represented using an `UndirectedGraphNode` class, where each node contains a label and a list of its neighbors. Implement a function that clones the provided graph using a breadth-first search (BFS) approach. Class Definition ```python class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def shallow_copy(self): return UndirectedGraphNode(self.label) def add_neighbor(self, node): self.neighbors.append(node) ``` Function Signature ```python def clone_graph_bfs(node): Clones the provided graph using a breadth-first search (BFS) approach. Args: node (UndirectedGraphNode): The root node of the graph to be cloned. Returns: UndirectedGraphNode: The root node of the cloned graph. ``` # Constraints * The number of nodes in the graph is in the range [0, 1000]. * The graph is connected. * Each node has a unique label. # Input & Output Formats * **Input**: The input will be provided as an instance of `UndirectedGraphNode` which is the root node of the graph. * **Output**: The function should return a new instance of `UndirectedGraphNode` which is the root of the newly cloned graph, with all labels and connections preserved. # Example ```python # Constructing the original graph: # 1 # / # / # 0 --- 2 # / # _/ n0 = UndirectedGraphNode(0) n1 = UndirectedGraphNode(1) n2 = UndirectedGraphNode(2) n0.add_neighbor(n1) n0.add_neighbor(n2) n1.add_neighbor(n2) n2.add_neighbor(n2) # Cloning the graph clone = clone_graph_bfs(n0) # clone should be a deep copy of the original graph ``` # Notes Ensure that the cloning process correctly handles graphs with cycles and self-loops. Use a queue to implement the BFS traversal and a hashmap to keep track of the visited nodes and their copies.","solution":"from collections import deque class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def shallow_copy(self): return UndirectedGraphNode(self.label) def add_neighbor(self, node): self.neighbors.append(node) def clone_graph_bfs(node): Clones the provided graph using a breadth-first search (BFS) approach. Args: node (UndirectedGraphNode): The root node of the graph to be cloned. Returns: UndirectedGraphNode: The root node of the cloned graph. if not node: return None # A dictionary to keep track of all the nodes which have already been created lookup = {} # Initialize the queue for BFS queue = deque([node]) # Create a copy of the root node lookup[node.label] = UndirectedGraphNode(node.label) while queue: current = queue.popleft() for neighbor in current.neighbors: if neighbor.label not in lookup: # Clone and store the neighbor lookup[neighbor.label] = UndirectedGraphNode(neighbor.label) # Append this neighbor to the queue for further traversal queue.append(neighbor) # Add this cloned neighbor to the current node\'s neighbors lookup[current.label].neighbors.append(lookup[neighbor.label]) return lookup[node.label]"},{"question":"Context: You have been given an array of integers which you need to sort using the Cycle Sort algorithm. Despite its inefficiency for larger datasets, understanding this sorting technique will help enhance your knowledge about permutations and minimal memory usage sorting algorithms. Task: Implement the function `cycle_sort(arr)` that sorts the input array `arr` using the Cycle Sort algorithm. Function Signature: ```python def cycle_sort(arr): pass ``` Input: * A list of integers `arr` where `1 <= len(arr) <= 10^4` and `-10^4 <= arr[i] <= 10^4`. Output: * The function should return a list of integers sorted in non-decreasing order. Constraints: * The algorithm must be implemented using the loop and index manipulation strategy as demonstrated in the cycle sort principle. * Avoid using Python\'s built-in sort functions or other external libraries for sorting. Example: ```python # Given Example arr = [3, 1, 2, 5, 4] print(cycle_sort(arr)) # Output: [1, 2, 3, 4, 5] # Custom Test Case arr = [1, 2, 3, 4, 5] print(cycle_sort(arr)) # Output: [1, 2, 3, 4, 5] arr = [10, -1, 2, 5, 0] print(cycle_sort(arr)) # Output: [-1, 0, 2, 5, 10] ``` **Note:** You are required to implement the cycle sort logic without importing any additional libraries for sorting purposes.","solution":"def cycle_sort(arr): n = len(arr) for cycle_start in range(0, n - 1): item = arr[cycle_start] # Find where to put the item pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Otherwise, put the item in the correct position while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"# Question: Optimizing Selection Calculation You are tasked with developing a more efficient method to compute the number of ways to choose `r` items from a set of `n` distinct items (combinations). Given the shortcomings of direct recursive computation due to its inefficiency and potential for stack overflow, you should leverage dynamic programming and memoization to optimize the calculation. **Function Prototype**: ```python def efficient_combination(n: int, r: int) -> int: pass ``` **Input**: * An integer `n` (0 ≤ n ≤ 1000) representing the total number of items in the set. * An integer `r` (0 ≤ r ≤ n) representing the number of items to choose from the set. **Output**: * An integer representing the number of ways to choose `r` items from `n`. **Constraints**: * Ensure efficient use of space and time. * Handle the edge cases as described in the analysis. **Examples**: ```python efficient_combination(5, 2) # Output: 10 efficient_combination(10, 0) # Output: 1 efficient_combination(10, 10) # Output: 1 efficient_combination(6, 3) # Output: 20 ``` # Implement the `efficient_combination` function to compute combinations efficiently using dynamic programming principles to optimize both time and space complexity.","solution":"def efficient_combination(n: int, r: int) -> int: Efficiently computes the number of ways to choose r items from n items using dynamic programming. :param n: Total number of items. :param r: Number of items to choose. :return: Number of combinations. # Handle edge cases if r > n or n < 0 or r < 0: return 0 if r == 0 or r == n: return 1 # Create a table to store results of subproblems dp = [[0 for _ in range(r + 1)] for _ in range(n + 1)] # Calculate the value of combinations via dynamic programming for i in range(n + 1): for j in range(min(i, r) + 1): # Base cases if j == 0 or j == i: dp[i][j] = 1 # Calculate value using previously stored values else: dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] return dp[n][r]"},{"question":"# Advanced String Matching As a software developer, you are tasked with creating a function that leverages an advanced string matching algorithm to search for a pattern in a large body of text. The requirement is to implement the Knuth-Morris-Pratt (KMP) string matching algorithm. Task Write a function `detect_pattern_occurrences(text: str, pattern: str) -> List[int]` that takes two inputs: 1. `text` - A string in which you are searching for the pattern. 2. `pattern` - The pattern string you need to find within the text. The function should return a list of starting indexes where the pattern is found in the text. Constraints - Both `text` and `pattern` can include alphanumeric characters and spaces. - The maximum length of `text` and `pattern` is 100,000. Performance Requirements - The function should have a time complexity of O(N + M) and a space complexity of O(M), where N is the length of `text` and M is the length of `pattern`. Example ```python assert detect_pattern_occurrences(\'hello there hero!\', \'he\') == [0, 7, 12] assert detect_pattern_occurrences(\'\', \'he\') == [] assert detect_pattern_occurrences(\'hello there hero!\', \'\') == [] assert detect_pattern_occurrences(\'ABC ABCDAB ABCDABCDABDE\', \'ABCDABD\') == [15] ``` Scenario Imagine you are working with textual data where efficient pattern searching is required. Consider a situation like a search feature in a text editor where users frequently search for terms. Implementing an efficient algorithm is crucial for performance, especially with large texts. Hints 1. Consider preprocessing the pattern to build the pi array. 2. Handle edge cases like empty strings upfront to avoid unnecessary computation. Implement the function `detect_pattern_occurrences` by following the above guidelines.","solution":"from typing import List def compute_prefix_function(pattern: str) -> List[int]: Computes the prefix function for the Knuth-Morris-Pratt algorithm. m = len(pattern) pi = [0] * m k = 0 for q in range(1, m): while k > 0 and pattern[k] != pattern[q]: k = pi[k - 1] if pattern[k] == pattern[q]: k += 1 pi[q] = k return pi def detect_pattern_occurrences(text: str, pattern: str) -> List[int]: Uses the KMP algorithm to find and return the starting indices of all occurrences of the pattern in the given text. n = len(text) m = len(pattern) if m == 0 or n == 0: return [] pi = compute_prefix_function(pattern) q = 0 result = [] for i in range(n): while q > 0 and pattern[q] != text[i]: q = pi[q - 1] if pattern[q] == text[i]: q += 1 if q == m: result.append(i - m + 1) q = pi[q - 1] return result"},{"question":"# Scenario You have been hired by a logistics company to manage their daily delivery data. They store the number of deliveries made each day in an array, and they need a system to quickly retrieve information for various date ranges, such as the total number of deliveries in a specific date range or the maximum number of deliveries in a certain period. # Task Implement the `SegmentTree` class to support the following operations: 1. **Constructor `__init__(self, arr, function)`**: - Constructs the segment tree from the array `arr` using the provided binary `function`. - The `function` can be any associative function like `sum`, `min`, `max`, etc. 2. **Method `query(self, L, R)`**: - Returns the result of the function applied to the range `[L, R]` in the array. # Input and Output Formats - `arr`: A list of integers representing the number of deliveries each day. - `function`: A binary function that takes two integers and returns an integer. Examples: `sum`, `min`, `max`. - `L`, `R`: Integers representing the inclusive range indices within which to perform the query. # Example ```python arr = [2, 4, 5, 3, 4] function = max segment_tree = SegmentTree(arr, function) # Query for the maximum value in the range [2,4] print(segment_tree.query(2, 4)) # Output: 5 arr2 = [4, 5, 2, 3, 4, 43, 3] segment_tree2 = SegmentTree(arr2, sum) # Query for the sum of the values in the range [1,5] print(segment_tree2.query(1, 5)) # Output: 57 ``` # Constraints - The length of `arr` will be at most 10^5. - 0 ≤ `L` ≤ `R` < length of `arr`. - You can assume that function operations (like addition in case of `sum`) will not result in integer overflow. # Objective - Write and optimize your code to handle large arrays and multiple queries efficiently. - Handle edge cases and ensure the queries correctly reflect the operations on the specified ranges.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.tree = [0] * (2 * self.n) self.function = function # Build the segment tree self.build(arr) def build(self, arr): # Copy the given array into the leaves of the segment tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the rest of the tree by applying the function for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def query(self, L, R): # Adjust indices to start from the leaves L += self.n R += self.n + 1 result = None while L < R: if L % 2 == 1: if result is None: result = self.tree[L] else: result = self.function(result, self.tree[L]) L += 1 if R % 2 == 1: R -= 1 if result is None: result = self.tree[R] else: result = self.function(result, self.tree[R]) L //= 2 R //= 2 return result"},{"question":"Implement a Data Structure to Track Components in a Network Problem Context: You are tasked with designing a data structure that will help to maintain and track components in a dynamically changing network. Each node in the network can connect to other nodes forming a component. Your solution will be used to add nodes, connect nodes, and determine the number of connected components at any given time. Requirements: 1. **add_node(node)**: Add a new node to the network. 2. **connect(node1, node2)**: Connect two nodes, potentially merging two components. 3. **count_components()**: Return the number of connected components in the network. 4. **are_connected(node1, node2)**: Determine if two nodes are in the same component. # Input/Output Format: - The `add_node(node)` function should accept a node identifier (e.g., integers or strings) and add it to the network. - The `connect(node1, node2)` function should accept two node identifiers and merge the components containing these nodes. - The `count_components()` function should return an integer representing the number of connected components. - The `are_connected(node1, node2)` function should return a boolean indicating whether the two nodes belong to the same component. # Constraints: - The total number of nodes will be at most (10^5). - The nodes will be uniquely identified. - The operations should be optimized for performance, targeting near-constant time complexity for union and find operations. # Example: ```python network = NetworkComponents() network.add_node(1) network.add_node(2) network.add_node(3) network.add_node(4) network.connect(1, 2) print(network.are_connected(1, 2)) # Output: True print(network.are_connected(1, 3)) # Output: False network.connect(3, 4) print(network.count_components()) # Output: 2 network.connect(2, 3) print(network.count_components()) # Output: 1 print(network.are_connected(1, 4)) # Output: True ``` # Task: Implement the class `NetworkComponents` with the required methods leveraging the Union-Find data structure described earlier.","solution":"class NetworkComponents: def __init__(self): self.parent = {} self.rank = {} self.components_count = 0 def add_node(self, node): if node not in self.parent: self.parent[node] = node self.rank[node] = 0 self.components_count += 1 def find(self, node): if self.parent[node] != node: self.parent[node] = self.find(self.parent[node]) return self.parent[node] def union(self, node1, node2): root1 = self.find(node1) root2 = self.find(node2) if root1 != root2: if self.rank[root1] > self.rank[root2]: self.parent[root2] = root1 elif self.rank[root1] < self.rank[root2]: self.parent[root1] = root2 else: self.parent[root2] = root1 self.rank[root1] += 1 self.components_count -= 1 def connect(self, node1, node2): if node1 in self.parent and node2 in self.parent: self.union(node1, node2) def count_components(self): return self.components_count def are_connected(self, node1, node2): if node1 in self.parent and node2 in self.parent: return self.find(node1) == self.find(node2) return False"},{"question":"You are given a string, and your task is to write a function that reverses the string using recursion and iteratively. Implement these two methods, ensuring you handle potential edge cases and performance considerations. # Requirements: * Implement two functions: `reverse_recursive(s)` and `reverse_iterative(s)`. * Both functions should take a single string `s` as input and return the reversed string. * Consider handling edge cases like empty strings and single-character strings. * You should not use Python\'s built-in `reversed()` function or slicing. # Function Signatures: ```python def reverse_recursive(s: str) -> str: # Your code here def reverse_iterative(s: str) -> str: # Your code here ``` # Constraints: * 1 <= len(s) <= 10^5 # Example: ```python # Example 1 s = \\"hello\\" print(reverse_recursive(s)) # Output: \\"olleh\\" print(reverse_iterative(s)) # Output: \\"olleh\\" # Example 2 s = \\"\\" print(reverse_recursive(s)) # Output: \\"\\" print(reverse_iterative(s)) # Output: \\"\\" # Example 3 s = \\"abcdef\\" print(reverse_recursive(s)) # Output: \\"fedcba\\" print(reverse_iterative(s)) # Output: \\"fedcba\\" ``` # Explanation: For the given string, both methods should handle reversing the string correctly. Recursive method involves splitting the string and concatenating the reversed halves, whereas the iterative method involves a two-pointer technique swapping characters from both ends. Ensure your solution is efficient and handles large inputs within acceptable time limits.","solution":"def reverse_recursive(s: str) -> str: def helper(s, start, end): if start >= end: return s s[start], s[end] = s[end], s[start] return helper(s, start + 1, end - 1) if not s: return \\"\\" s = list(s) reversed_s = helper(s, 0, len(s) - 1) return \'\'.join(reversed_s) def reverse_iterative(s: str) -> str: s = list(s) start, end = 0, len(s) - 1 while start < end: s[start], s[end] = s[end], s[start] start += 1 end -= 1 return \'\'.join(s)"},{"question":"# Word Segmentation Problem Problem Statement Given a non-empty string `word` and a dictionary `wordDict` containing a list of non-empty words, determine if `word` can be segmented into a space-separated sequence of one or more dictionary words. Assume the dictionary does not contain duplicate words. Requirements 1. Implement the function `word_break(word, word_dict)` that returns a boolean value. - **Input**: `word` (string) - the word to be segmented. - **Input**: `word_dict` (set of strings) - the dictionary of words. - **Output**: `bool` - `True` if `word` can be segmented, `False` otherwise. 2. Your implementation should run efficiently on inputs with length up to `10^3`. Input and Output Formats - **Input**: - `word`: string, a non-empty string to be segmented (1 ≤ |word| ≤ 10^3) - `word_dict`: set of strings with non-empty words (1 ≤ |word_dict| ≤ 10^3, 1 ≤ |word_dict[i]| ≤ 20) - **Output**: - `bool`: `True` if `word` can be segmented, otherwise `False`. Examples ```python # Example 1: word = \\"leetcode\\" word_dict = {\\"leet\\", \\"code\\"} # Should return True since \\"leetcode\\" can be segmented as \\"leet code\\". # Example 2: word = \\"applepenapple\\" word_dict = {\\"apple\\", \\"pen\\"} # Should return True since \\"applepenapple\\" can be segmented as \\"apple pen apple\\". # Example 3: word = \\"catsandog\\" word_dict = {\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"} # Should return False since \\"catsandog\\" cannot be completely segmented. ``` Constraints and Limitations - Ensure efficient utilization of both time and space for large inputs. - Handle edge cases where word cannot possibly be segmented or the dictionary is limited in relevant words. You are required to provide a robust solution following the given guidelines.","solution":"def word_break(word, word_dict): Determine if the word can be segmented into a sequence of one or more dictionary words. :param word: str, the word to be segmented :param word_dict: set, the dictionary containing list of words :return: bool, True if the word can be segmented, False otherwise n = len(word) dp = [False] * (n + 1) dp[0] = True for i in range(1, n + 1): for j in range(i): if dp[j] and word[j:i] in word_dict: dp[i] = True break return dp[n]"},{"question":"You are tasked with implementing a modified counting sort algorithm that can handle not just integers, but also floating-point numbers. The precision of the floating-point numbers is limited to one decimal place (e.g., 1.1, 2.5, -3.6). The range of numbers is specified and can include both positive and negative values. # Function Signature ```python def counting_sort_floats(arr: List[float], min_val: float, max_val: float) -> List[float]: Sorts an array of floating-point numbers using a modified counting sort. Arguments: arr : List[float] - A list of floating-point numbers with one decimal precision. min_val : float - The minimum possible value in the array. max_val : float - The maximum possible value in the array. Returns: List[float] - A sorted list of floating-point numbers. ``` # Input - **arr**: A list of floating-point numbers with one decimal place precision, length n (1 ≤ n ≤ 10^5). - **min_val**: The minimum possible value in the array. - **max_val**: The maximum possible value in the array. # Output - A sorted list of floating-point numbers. # Constraints - The floating-point numbers have one decimal precision. - The values of min_val and max_val are inclusive bounds for the elements in the array. - The range (max_val - min_val) is guaranteed to be manageable within the constraints of memory usage. # Example ```python arr = [1.2, 3.1, 2.3, -1.0, -3.3, 0.0, 2.6] min_val = -5.0 max_val = 5.0 print(counting_sort_floats(arr, min_val, max_val)) # Output: [-3.3, -1.0, 0.0, 1.2, 2.3, 2.6, 3.1] ``` # Implementation Notes - Consider the precision when setting up the temp array. Scale the values appropriately to handle their integer-equivalent. - Account for both positive and negative ranges within the input. - Ensure to restore the floating-point precision before returning the sorted list.","solution":"from typing import List def counting_sort_floats(arr: List[float], min_val: float, max_val: float) -> List[float]: Sorts an array of floating-point numbers using a modified counting sort. Arguments: arr : List[float] - A list of floating-point numbers with one decimal precision. min_val : float - The minimum possible value in the array. max_val : float - The maximum possible value in the array. Returns: List[float] - A sorted list of floating-point numbers. # Scaling factor to convert 1 decimal place float to int scale = 10 # Calculate the range of the values based on scaling min_val_scaled = int(min_val * scale) max_val_scaled = int(max_val * scale) # Create the count array with range from min_val to max_val count_range = max_val_scaled - min_val_scaled + 1 count = [0] * count_range # Count occurrences of each value in the input array for num in arr: scaled_number = int(num * scale) count[scaled_number - min_val_scaled] += 1 # Use the count array to construct the sorted array sorted_arr = [] for i in range(count_range): count_value = count[i] original_number = (i + min_val_scaled) / scale sorted_arr.extend([original_number] * count_value) return sorted_arr"},{"question":"You are tasked with expanding the `DirectedGraph` class by implementing a Depth-First Search (DFS) traversal that can detect cycles in the graph. Your solution should identify whether any cycle exists in the graph. # Input A dictionary `graph_dict` where the keys are node names (strings) and the values are lists of node names representing directed edges from the key node to the nodes in the list. # Output Return `True` if the graph contains at least one cycle; otherwise, return `False`. # Example ```python graph_dict = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'] } >>> g = DirectedGraph(graph_dict) >>> g.has_cycle() # True, because A -> B -> C -> A graph_dict = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [], \'D\': [] } >>> g = DirectedGraph(graph_dict) >>> g.has_cycle() # False, no cycles present ``` # Constraints - Assume that the graph does not contain any duplicate edges. - The graph can have at most 1000 nodes. - Nodes and edges names are alphanumeric strings. # Implementation Guide 1. **Update the `DirectedGraph` class** to include a method `has_cycle`. 2. **Use DFS traversal with recursion** to explore nodes while keeping track of visited nodes and the recursion stack. 3. **Detect cycles using recursion stack:** If a node is revisited and is in the recursion stack, a cycle exists. ```python class DirectedGraph: # class code defined previously def has_cycle(self): # Implement your solution here pass ```","solution":"class DirectedGraph: def __init__(self, graph_dict): self.graph = graph_dict def has_cycle(self): visited = set() rec_stack = set() def dfs(node): if node in rec_stack: return True # Cycle detected if node in visited: return False # Already processed node visited.add(node) rec_stack.add(node) for neighbor in self.graph.get(node, []): if dfs(neighbor): return True rec_stack.remove(node) return False for node in self.graph: if dfs(node): return True return False"},{"question":"# Stooge Sort Recursion Implementation **Context**: Stooge Sort is a highly inefficient sorting algorithm that sorts an array using a recursive approach. You have to implement this algorithm considering various edge cases and constraints. **Task**: Write a Python function `stooge_sort(arr)` that sorts an array of integers using the Stooge Sort algorithm. The function should sort the list in place. Function Signature ```python def stooge_sort(arr: List[int]) -> None: pass ``` Input - **arr (List[int])**: A list of integers to be sorted. The length of the list (n) is (0 leq n leq 10^3). Output - The function should modify the input list `arr` in place to be sorted in non-decreasing order. Constraints - The function must correctly handle edge cases such as: * An empty list `[]`. * A list with a single element `[x]`. * A list that is already sorted in ascending order. * A list containing duplicate elements like `[1, 1, 1, 1]`. Example ```python arr = [2, 4, 5, 3, 1] stooge_sort(arr) print(arr) # Output: [1, 2, 3, 4, 5] ``` Additional Requirements - Your solution should not use any built-in sort functions. - Aim to adhere to the original Stooge Sort algorithm as closely as possible while considering ways to optimize it or handle edge cases effectively.","solution":"def stooge_sort(arr, l=0, h=None): if h is None: h = len(arr) - 1 if l >= h: return # If the element at index l is greater than element at index h, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are at least three elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 # Sort first 2/3 of the array stooge_sort(arr, l, h - t) # Sort last 2/3 of the array stooge_sort(arr, l + t, h) # Sort first 2/3 of the array again stooge_sort(arr, l, h - t)"},{"question":"# Scenario Your task is to design an algorithm to encode a list of strings into a single string such that the encoded string can be sent over the network and then decoded back to the original list of strings on the other end. You need to implement both the encode and decode functions. # Problem Statement Implement two methods: 1. **encode(strs: List[str]) -> str**: - Converts a list of strings into a single encoded string. 2. **decode(s: str) -> List[str]**: - Converts the encoded string back to the original list of strings. # Input * A list of strings (`strs`) for the `encode` function. Each string can contain any printable characters. * A single encoded string (`s`) for the `decode` function. # Output * A single string for `encode`. * A list of strings for `decode`. # Constraints * The length of each string in the list can range from 0 to 10^3 characters. * The total number of strings in the list can be up to 10^3. * You should handle edge cases, such as empty strings and lists. # Performance Requirements * Ensure that your implementation is efficient with a linear time complexity in both encoding and decoding processes, proportionate to the input size. # Example Encoding Example: ```python strs = [\\"hello\\", \\"world\\", \\"\\", \\"python\\"] encoded_str = encode(strs) # Output: \'5:hello5:world0:6:python\' ``` Decoding Example: ```python encoded_str = \'5:hello5:world0:6:python\' decoded_list = decode(encoded_str) # Output: [\'hello\', \'world\', \'\', \'python\'] ``` Remember to handle special cases where strings may be empty or contain colons.","solution":"def encode(strs): Encodes a list of strings to a single string. Args: strs (List[str]): List of strings to be encoded Returns: str: The encoded string encoded_str = \'\' for s in strs: encoded_str += f\'{len(s)}:{s}\' return encoded_str def decode(s): Decodes a single string to a list of strings. Args: s (str): The encoded string Returns: List[str]: The decoded list of strings decoded_list, i = [], 0 while i < len(s): j = s.index(\':\', i) length = int(s[i:j]) decoded_list.append(s[j + 1:j + 1 + length]) i = j + 1 + length return decoded_list"},{"question":"**Problem Statement**: You are required to extend the Binary Search Tree (BST) implementation to include methods for finding the minimum and maximum values, deleting a node, and checking if the tree is balanced. **Function Specifications**: 1. **find_min(self)**: Find the minimum value in the BST. - Input: None - Output: Integer (the smallest value in the tree) 2. **find_max(self)**: Find the maximum value in the BST. - Input: None - Output: Integer (the largest value in the tree) 3. **delete(self, data)**: Delete a node containing the specified data from the BST. - Input: Integer (data to delete) - Output: Boolean (True if deletion was successful, False otherwise) 4. **is_balanced(self)**: Check if the BST is balanced (difference in height between left and right subtree for every node is at most 1). - Input: None - Output: Boolean (True if the tree is balanced, False otherwise) **Constraints**: - Duplicate values are not allowed in the BST. **Performance Requirements**: - Ensure the operations, where possible, maintain logarithmic time complexity. **Scenario**: Consider the following operations performed on a BST initialized from a sequence of numbers: [10, 6, 15, 4, 9, 12, 24, 7, 20, 30, 18]. You need to efficiently perform search, insert, minimum, maximum, delete, and balance check operations on this BST. **Example**: ```python tree = BST() tree.insert(10) tree.insert(6) tree.insert(15) # further insertions for 12, 24, 4, 9, 7, 20, 30, 18 as in the provided script assert tree.search(15) == True assert tree.find_min() == 4 assert tree.find_max() == 30 assert tree.is_balanced() == False (after the given insertions) assert tree.delete(24) == True assert tree.is_balanced() == True (after appropriate rebalancing, if implemented) ``` Implement and unittests correctly extending and testing the additional functionalities stated above.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def search(self, key): return self._search(self.root, key) def _search(self, root, key): if root is None or root.val == key: return root is not None if key < root.val: return self._search(root.left, key) return self._search(root.right, key) def find_min(self): current = self.root while current.left is not None: current = current.left return current.val def find_max(self): current = self.root while current.right is not None: current = current.right return current.val def delete(self, key): success, self.root = self._delete(self.root, key) return success def _delete(self, root, key): if root is None: return False, root if key < root.val: success, root.left = self._delete(root.left, key) elif key > root.val: success, root.right = self._delete(root.right, key) else: if root.left is None: return True, root.right elif root.right is None: return True, root.left min_larger_node = self._get_min(root.right) root.val = min_larger_node.val success, root.right = self._delete(root.right, root.val) return True, root return success, root def _get_min(self, root): while root.left is not None: root = root.left return root def is_balanced(self): return self._is_balanced(self.root)[0] def _is_balanced(self, root): if root is None: return True, 0 left_balanced, left_height = self._is_balanced(root.left) right_balanced, right_height = self._is_balanced(root.right) current_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 current_height = max(left_height, right_height) + 1 return current_balanced, current_height"},{"question":"# Coding Scenario **Scenario**: You have been tasked with developing an efficient algorithm to detect unique elements in datasets where each element appears a known number of times except for one single element. This scenario is common in data corruption where one piece of data is unique due to an error, and the rest follow an expected repeated pattern. **Problem**: Given an array of integers where every element appears three times except for one, which appears exactly once, write a function to find that single element. **Function Signature**: ```python def single_number(nums: List[int]) -> int: ``` **Input**: * A list `nums` of integers where every element appears exactly three times except for one element which appears only once. * 1 <= len(nums) <= 3 * 10^4 * -2^31 <= nums[i] <= 2^31 - 1 **Output**: * Return the integer that appears only once. **Constraints**: * Your algorithm should have a linear runtime complexity. * Implement the solution without using extra memory (occupying constant space). # Example: ```python # Example 1: nums = [2, 2, 3, 2] assert single_number(nums) == 3 # Example 2: nums = [0, 1, 0, 1, 0, 1, 99] assert single_number(nums) == 99 ``` # Requirements: 1. Implement the `single_number` function with the provided specifications. 2. Handle edge cases where the array is extremely large. 3. Ensure the solution does not use extra space beyond constant space.","solution":"from typing import List def single_number(nums: List[int]) -> int: Find the element that appears only once in an array where every other element appears exactly three times. # Initialize the variables to record the bits that appear exactly once and twice ones, twos = 0, 0 for num in nums: # Update `ones` and `twos` based on the current number ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"You are given a list of unique integers nums that represents a sequence of numbers in the range [0, n]. There is one number missing from the sequence. Write a function that identifies and returns the missing number from the sequence in O(n) time complexity. If the sequence contains all numbers from 0 to n (inclusive), then your function should return n+1. # Function Signature: ```python def find_missing_number(nums: List[int]) -> int: pass ``` # Input: - `nums`: List of unique integers in the range [0, n]. # Output: - Return the single missing number from the list. # Constraints: - The length of `nums` is `n`. - All integers in `nums` are unique and in the range `[0, n]`. # Example: ```python # Example 1: # Input: nums = [4, 1, 3, 0, 6, 5, 2] # Output: 7 # Example 2: # Input: nums = [3, 0, 1] # Output: 2 # Example 3: # Input: nums = [0, 1] # Output: 2 # Example 4: # Input: nums = [9,6,4,2,3,5,7,0,1] # Output: 8 ``` # Notes: 1. You may use either of the two approaches (XOR or Sum) described in the provided code snippets. 2. Ensure your solution addresses potential edge cases, such as the smallest and largest possible values. # Explanation: For Example 1, the numbers 0 to 6 are present, and the next number in the sequence should be 7, which is missing. For Example 2, the numbers 0, 1, and 3 are present. Hence, 2 is missing in the sequence.","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Identify and return the missing number from the list of unique integers ranging from 0 to n. If all numbers from 0 to n are present, return n + 1. Args: nums (List[int]): List of unique integers in the range [0, n]. Returns: int: The missing number from the list. n = len(nums) expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"Reverse and Transform Sentence You are given a task to modify a sentence transformation class to include additional functionalities. The underlying class has methods to reverse the words in a sentence as per the given code snippets. Class Design and Implementation Design a class `SentenceTransformer` with the following specifications: 1. Implement a method `reverse_words(self, string: str) -> str` that takes an input string and returns the sentence with words reversed. 2. Implement a method `to_uppercase(self, string: str) -> str` that takes an input string and converts all the characters in each word to uppercase. 3. Implement an additional method `transform(self, string: str) -> str` that utilizes the previous two methods to: * First reverse the words in the input sentence. * Then, convert each character of these reversed words to uppercase. ```python class SentenceTransformer: def reverse_words(self, string: str) -> str: # Implementation goes here def to_uppercase(self, string: str) -> str: # Implementation goes here def transform(self, string: str) -> str: # Implementation goes here ``` Input * A single string `string`. Output * The transformed string after applying word reversal and converting to uppercase. Constraints * The input string may contain leading or trailing spaces. * Each word in the input string is separated by a single space. * The input string does not contain any special characters or numbers. Example ```python transformer = SentenceTransformer() string = \\"I am keon kim and I like pizza\\" # should print: \\"PIZZA LIKE I AND KIM KEON AM I\\" print(transformer.transform(string)) ``` Thoroughly test your implementation to handle various edge cases and ensure the solution is optimal in terms of time and space complexity.","solution":"class SentenceTransformer: def reverse_words(self, string: str) -> str: words = string.split() reversed_words = words[::-1] return \' \'.join(reversed_words) def to_uppercase(self, string: str) -> str: return string.upper() def transform(self, string: str) -> str: reversed_string = self.reverse_words(string) uppercased_string = self.to_uppercase(reversed_string) return uppercased_string"},{"question":"# B-Tree Node Search and Height Calculation Problem Description A B-tree is an essential data structure commonly used in databases and file systems where balancing and ordered traversal are paramount. In this assignment, you are tasked with two primary functions for a B-tree: finding all leaf nodes with a given key and calculating the height of the B-tree. **You need to implement the following two functions:** 1. **`find_leaf_nodes_with_key(self, key: int) -> List[Node]`**: * This function should traverse the B-tree and return a list of all leaf nodes that contain the specified key. 2. **`calculate_height(self) -> int`**: * This function should return the height of the B-tree. The height of a B-tree is the number of edges on the longest path from the root to a leaf. Implementation Requirements * **Input/Output Formats**: * `find_leaf_nodes_with_key(key: int) -> List[Node]` * **Input**: An integer key to search in the B-tree. * **Output**: A list of nodes that are leaves and contain the specified key. The nodes should be part of the `BTree` class. * `calculate_height() -> int` * **Input**: None. * **Output**: An integer representing the height of the B-tree. * **Constraints**: * Assume the B-tree is balanced as per its properties. * Maximum number of keys in the tree node should be manageable within the available memory. * **Performance Requirements**: * The find operation should traverse the tree efficiently, maintaining (O(N)^{1/2}) complexity. * The height calculation should be performed in (O(log n)) time. Example Consider the following B-tree built with different integer keys: ``` Create a B-tree `bt` with a minimum degree of 3: bt.insert_key(10) bt.insert_key(20) bt.insert_key(30) bt.insert_key(40) bt.insert_key(50) Call `bt.find_leaf_nodes_with_key(30)` * Output: The leaf nodes list containing the key 30. Call `bt.calculate_height()` * Output: Height of the B-tree. ``` Implement these two functions within the `BTree` class to demonstrate your understanding of the B-tree functionalities.","solution":"class Node: def __init__(self, leaf=False): self.keys = [] self.child = [] self.leaf = leaf class BTree: def __init__(self, t): self.root = Node(True) self.t = t def find_leaf_nodes_with_key(self, key): def _find_leaf_nodes_with_key(node, key, result): if node.leaf: if key in node.keys: result.append(node) else: for i in range(len(node.keys)): _find_leaf_nodes_with_key(node.child[i], key, result) _find_leaf_nodes_with_key(node.child[len(node.keys)], key, result) result = [] _find_leaf_nodes_with_key(self.root, key, result) return result def calculate_height(self): def _calculate_height(node): if node.leaf: return 0 return 1 + _calculate_height(node.child[0]) return _calculate_height(self.root) # Additional helper functions would go here like insertion etc."},{"question":"# Prime Numbers and their Neighbors You are tasked to implement a function `find_prime_neighbors(n)`, which finds the closest prime numbers that are smaller and larger than a given positive integer `n`. Detailed Description & Requirements: 1. **Input**: An integer `n` (1 ≤ n ≤ 10^7). 2. **Output**: A tuple of two integers `(lower_prime, upper_prime)` where: * `lower_prime` is the largest prime number less than `n`. * `upper_prime` is the smallest prime number greater than `n`. 3. **Edge Cases**: * If there is no prime smaller than `n`, return `lower_prime` as -1. * If there is no prime larger than `n` within the search limit, return `upper_prime` as -1. Constraints: * You need to use the `prime_check` function to verify the primality of numbers. * Ensure your function is optimized for performance, considering the time complexity of the `prime_check` function. * Handle edge cases where no prime numbers might be found within certain search bounds. ```python def prime_check(n): Return True if n is a prime number Else return False. if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0 or n % 3 == 0: return False j = 5 while j * j <= n: if n % j == 0 or n % (j + 2) == 0: return False j += 6 return True def find_prime_neighbors(n): # Implement this function pass ``` # Example Usages: * For `n = 10`, the function should return `(7, 11)` as 7 is the closest prime less than 10, and 11 is the closest prime greater than 10. * For `n = 6`, the function should return `(5, 7)`. * For `n = 2`, the function should return `(-1, 3)` since there is no prime number smaller than 2. Ensure to run and test your function with edge cases and large values within the constraints.","solution":"def prime_check(n): Return True if n is a prime number Else return False. if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0 or n % 3 == 0: return False j = 5 while j * j <= n: if n % j == 0 or n % (j + 2) == 0: return False j += 6 return True def find_prime_neighbors(n): Finds the closest prime numbers smaller and larger than a given positive integer n. # Find the lower prime lower_prime = -1 for i in range(n - 1, 1, -1): if prime_check(i): lower_prime = i break # Find the upper prime upper_prime = -1 i = n + 1 while True: if prime_check(i): upper_prime = i break i += 1 if i > 10**7: # Limit search within bounds break return lower_prime, upper_prime"},{"question":"Scenario You are tasked with developing a navigation system for a robot in a warehouse. The warehouse is represented as a grid where some cells are blocked due to obstacles, and others are open for traversal. Your goal is to program the robot to find the shortest path from the top-left corner to the bottom-right corner of the grid. Problem Statement Write a function `robot_navigation(warehouse)` that takes as input a 2D list `warehouse` representing the grid of the warehouse. The function should return the minimum number of steps required for the robot to travel from the top-left cell `(0,0)` to the bottom-right cell `(height-1,width-1)`. If there is no valid path, the function should return `-1`. Input * A 2D list `warehouse` of dimensions `m x n` where: - `warehouse[i][j] = 1` indicates that the cell `(i,j)` is open. - `warehouse[i][j] = 0` indicates that the cell `(i,j)` is blocked. Output * An integer representing the minimum number of steps to reach the bottom-right cell from the top-left cell, or `-1` if no such path exists. Constraints * `1 <= m, n <= 1000` * The top-left and bottom-right corners will have `warehouse[0][0] == 1` and `warehouse[m-1][n-1] == 1`. Example 1. Given the input `warehouse = [[1,0,1,1,1,1], [1,0,1,0,1,0], [1,0,1,0,1,1], [1,1,1,0,1,1]]`, the function should return `14`. 2. Given the input `warehouse = [[1,0,0], [0,1,1], [0,1,1]]`, the function should return `-1`. Notes - The robot can only move up, down, left, or right. - You can assume that both the top-left and bottom-right cells are always open (contain a 1). Implement your solution in Python. ```python def robot_navigation(warehouse): # Your implementation here ```","solution":"from collections import deque def robot_navigation(warehouse): def is_valid(x, y): return 0 <= x < len(warehouse) and 0 <= y < len(warehouse[0]) and warehouse[x][y] == 1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, distance) warehouse[0][0] = 0 # mark as visited by setting it to 0 while queue: x, y, dist = queue.popleft() if x == len(warehouse) - 1 and y == len(warehouse[0]) - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): warehouse[nx][ny] = 0 queue.append((nx, ny, dist + 1)) return -1"},{"question":"# Cycle Sort Implementation Challenge Context: Cycle Sort is a sorting algorithm particularly efficient in terms of the number of memory writes it performs. The main advantage is that it minimizes memory writes, making it an ideal choice for memory constrained or write-limited environments like EEPROM or flash memory. However, it has a time complexity of O(N^2) in both average and worst-case scenarios, which may not be suitable for large datasets. Task: Implement the Cycle Sort algorithm in Python. The function should reorder the given list of integers in non-decreasing order. Function Signature: ```python def cycle_sort(arr: List[int]) -> List[int]: # Your code here ``` Input Format: - A list of integers `arr`. Output Format: - The sorted list of integers. Constraints: - The length of the list, `1 <= len(arr) <= 10^5`. - The integers in the list are in the range `-10^9` to `10^9`. Example: ```python assert cycle_sort([3, 1, 4, 1, 5, 9, 2]) == [1, 1, 2, 3, 4, 5, 9] assert cycle_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert cycle_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] assert cycle_sort([4, 5, 5, 4, -1, 0, 100, -100]) == [-100, -1, 0, 4, 4, 5, 5, 100] ``` Notes: - Ensure that you handle edge cases such as arrays that are already sorted, arrays with duplicate values, and arrays where all elements are in reverse order. - Minimize the number of writes to the provided list.","solution":"def cycle_sort(arr): Reorders the integers in the list \'arr\' using Cycle Sort algorithm. writes = 0 # Loop through the array to find cycles to rotate. for cycle_start in range(0, len(arr) - 1): item = arr[cycle_start] # Find the position where we put the element. pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 # If the item is already in the correct position. if pos == cycle_start: continue # otherwise, put the item there or right after any duplicates. while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle. while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"# Question: Trimmed Mean Calculation You are tasked with implementing a function to calculate the trimmed mean of a dataset. The trimmed mean is a method of averaging that removes a small designated percentage of the largest and smallest values before calculating the mean. Function Signature ```python def trimmed_mean(arr: List[int], percentage: float) -> float: ``` Input * `arr`: A list of integers representing the dataset. Length of the list: (1 leq text{len(arr)} leq 10^5). * `percentage`: A float representing the percentage of values to exclude from the top and bottom of the dataset. (0 leq text{percentage} < 100). Output * A float representing the trimmed mean of the dataset. Constraints * The percentage value will always be less than 100, ensuring that there will be elements in the list after trimming. * The values in the array can be positive or negative integers. Example Scenario Consider a dataset representing athletes\' scores, and you are required to find the trimmed mean excluding the top and bottom 10% of the scores to negate the effect of outliers. Example ```python arr = [2, 8, 1, 4, 6, 9, 10, 3, 7, 5] percentage = 20.0 print(trimmed_mean(arr, percentage)) # Expected output: 5.5 ``` In this example, 20% of the 10 values is 2 values, so we remove the smallest 2 values ([1, 2]) and the largest 2 values ([9, 10]), leaving us with the middle 6 values ([3, 4, 5, 6, 7, 8]). The mean of these 6 values is (3 + 4 + 5 + 6 + 7 + 8) / 6 = 5.5. Constraints * Your implementation should handle edge cases, such as when the percentage leads to a small number of values being retained. * Ensure the function runs efficiently, considering the constraints on the input size.","solution":"from typing import List def trimmed_mean(arr: List[int], percentage: float) -> float: Calculate the trimmed mean of a dataset. :param arr: List[int] - a list of integers representing the dataset. :param percentage: float - the percentage of values to exclude from the top and bottom of the dataset. :return: float - the trimmed mean of the dataset. n = len(arr) k = int(percentage / 100 * n) # Sort the array sorted_arr = sorted(arr) # Trim k elements from each end trimmed_arr = sorted_arr[k:n-k] # Calculate the mean of the trimmed array trimmed_mean_value = sum(trimmed_arr) / len(trimmed_arr) return trimmed_mean_value"},{"question":"# Coding Challenge **Context**: In many applications, such as search engines, recommendation systems, and data clustering, measuring the similarity between vectors is crucial. Cosine similarity is an effective method to ascertain the degree of similarity between two vectors. **Problem Statement**: Write a Python function, `generalized_cosine_similarity(vectors)`, that calculates the pairwise cosine similarity for multiple vectors. The input is a list of n vectors, each consisting of m elements (n >= 2, m >= 1). **Requirements**: 1. Each vector must have the same length; otherwise, raise a `ValueError` with the message: \\"Vectors must have the same length.\\" 2. The function should return a 2D list (matrix), where the element at the [i][j] position represents the cosine similarity between the i-th and j-th vectors. **Function Signature**: ```python def generalized_cosine_similarity(vectors: list[list[float]]) -> list[list[float]]: ``` **Input**: * `vectors` - a list of n vectors, where each vector is a list of floats **Output**: * A 2D list containing the pairwise cosine similarity values. **Constraints**: * 2 ≤ n ≤ 1000 (number of vectors) * 1 ≤ m ≤ 1000 (length of each vector) * Each vector contains floats in the range [-1000, 1000] **Example**: ```python vectors = [ [1, 1, 1], [1, 2, -1] ] # Output: # [ # [1.0, 0.47140452079103173], # [0.47140452079103173, 1.0] # ] ``` **Notes**: * Ensure the diagonal elements of the output matrix are equal to 1, representing the similarity of vectors with themselves. * Be efficient with the calculation to avoid redundant calculations.","solution":"import math def dot_product(v1, v2): return sum(x * y for x, y in zip(v1, v2)) def magnitude(v): return math.sqrt(sum(x ** 2 for x in v)) def cosine_similarity(v1, v2): return dot_product(v1, v2) / (magnitude(v1) * magnitude(v2)) def generalized_cosine_similarity(vectors): if not vectors or not vectors[0]: raise ValueError(\\"Vectors must not be empty.\\") vector_length = len(vectors[0]) for v in vectors: if len(v) != vector_length: raise ValueError(\\"Vectors must have the same length.\\") num_vectors = len(vectors) similarity_matrix = [[0.0] * num_vectors for _ in range(num_vectors)] for i in range(num_vectors): for j in range(i, num_vectors): if i == j: similarity_matrix[i][j] = 1.0 else: similarity = cosine_similarity(vectors[i], vectors[j]) similarity_matrix[i][j] = similarity similarity_matrix[j][i] = similarity return similarity_matrix"},{"question":"# AVL Tree Implementation As a software developer, you are tasked with implementing an AVL Tree to support efficient storage and retrieval operations for a dynamic dataset. An AVL Tree is a self-balancing binary search tree where the difference between heights of left and right subtrees cannot be more than one for all nodes. Your goal is to implement the AVL Tree with the following operations: 1. **Insert** a node with a specific key. 2. **Check Balances**: For each insert operation, ensure the tree remains balanced by updating heights and performing rotations. 3. **In-order Traversal**: Provide a function to perform an in-order traversal of the tree and return the keys in a sorted list. # Your Task: Implement the following methods in the `AvlTree` class: 1. `insert(key)`: Insert a new node with the provided key into the AVL tree. 2. `rotate_left()`: Perform a left rotation on the subtree. 3. `rotate_right()`: Perform a right rotation on the subtree. 4. `in_order_traverse()`: Return a list of keys representing the tree nodes in in-order traversal. **Input Format**: - Method `insert(key)` will be called multiple times with an integer `key` to populate the AVL tree. **Output Format**: - Method `in_order_traverse()` should return a list of integers representing the in-order traversal of the tree. **Constraints**: - All keys inserted will be unique integers. - Perform rotations to maintain the balance factor for each node between -1 and +1. # Example: ```python avl = AvlTree() avl.insert(10) avl.insert(20) avl.insert(30) avl.insert(40) avl.insert(50) print(avl.in_order_traverse()) # Output: [10, 20, 30, 40, 50] avl = AvlTree() avl.insert(20) avl.insert(10) avl.insert(30) avl.insert(40) avl.insert(50) print(avl.in_order_traverse()) # Output: [10, 20, 30, 40, 50] ``` Note: - Ensure the AVL tree remains balanced after each insertion. - It is not required to handle deletions in this assessment.","solution":"class TreeNode: def __init__(self, key): self.key = key self.height = 1 self.left = None self.right = None class AvlTree: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and key < node.left.key: return self._rotate_right(node) if balance < -1 and key > node.right.key: return self._rotate_left(node) if balance > 1 and key > node.left.key: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance < -1 and key < node.right.key: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _rotate_right(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def in_order_traverse(self): result = [] self._in_order_traverse(self.root, result) return result def _in_order_traverse(self, node, result): if node: self._in_order_traverse(node.left, result) result.append(node.key) self._in_order_traverse(node.right, result)"},{"question":"Implementing a B-Tree Search and Insert Function Objective: To test your understanding and implementation skills of B-Trees, including their key operations, we ask you to implement specific functionalities in a B-Tree class. Scenario: You are tasked with enhancing a B-Tree implementation. Your main job is to implement two crucial methods: `find()` and `insert_key()`. These methods are fundamental for searching and inserting keys in a B-Tree. We\'ll provide the basic structure of the BTree class, and you will complete the missing parts. Task: 1. **Implement the `find()` function** that searches for a key in the B-Tree. 2. **Implement the `insert_key()` function** to insert a new key into the B-Tree. Function Signatures: ```python def find(self, key: int) -> bool: Returns True if the key exists in the B-Tree, otherwise False. # Implement this function def insert_key(self, key: int): Inserts a key into the B-Tree. # Implement this function ``` Expected Input and Output Formats: * **find(key)** * **Input**: An integer key to search within the B-Tree. * **Output**: A boolean value, `True` if the key exists, `False` otherwise. * **insert_key(key)** * **Input**: An integer key to insert into the B-Tree. * **Output**: No output. The B-Tree should update its structure to include the new key. # Constraints: 1. You can assume that all keys are unique. 2. The degree of the B-Tree (t) is 2. # Implementation: Below is your starting template. Complete the `find` and `insert_key` methods. ```python class Node: Class of Node def __init__(self): self.keys = [] self.children = [] @property def is_leaf(self): Return if it is a leaf return len(self.children) == 0 class BTree: Class of BTree def __init__(self, t_val=2): self.min_numbers_of_keys = t_val - 1 self.max_number_of_keys = 2 * t_val - 1 self.root = Node() def _split_child(self, parent: Node, child_index: int): # Split logic here pass def find(self, key: int) -> bool: Returns True if the key exists in the B-Tree, otherwise False. # Implement this function def insert_key(self, key: int): Inserts a key into the B-Tree. # Implement this function # Additional Helper method as defined in snippets if needed ``` Example Case: ```python btree = BTree(t_val=2) btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) assert btree.find(10) == True assert btree.find(15) == False ``` Once you have implemented the above methods, your code should accurately search and insert keys while maintaining the B-Tree properties.","solution":"class Node: Class of Node def __init__(self): self.keys = [] self.children = [] @property def is_leaf(self): Return if it is a leaf return len(self.children) == 0 class BTree: Class of BTree def __init__(self, t_val=2): self.min_numbers_of_keys = t_val - 1 self.max_number_of_keys = 2 * t_val - 1 self.t = t_val self.root = Node() def _split_child(self, parent: Node, child_index: int): t = self.t child = parent.children[child_index] new_child = Node() parent.keys.insert(child_index, child.keys[t - 1]) parent.children.insert(child_index + 1, new_child) new_child.keys = child.keys[t:(2*t - 1)] child.keys = child.keys[0:(t - 1)] if not child.is_leaf: new_child.children = child.children[t:(2*t)] child.children = child.children[0:t] def _insert_non_full(self, node: Node, key: int): i = len(node.keys) - 1 if node.is_leaf: node.keys.append(0) while i >= 0 and key < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = key else: while i >= 0 and key < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == self.max_number_of_keys: self._split_child(node, i) if key > node.keys[i]: i += 1 self._insert_non_full(node.children[i], key) def find(self, key: int) -> bool: Returns True if the key exists in the B-Tree, otherwise False. def _find_in_node(node, key): i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if i < len(node.keys) and key == node.keys[i]: return True if node.is_leaf: return False return _find_in_node(node.children[i], key) return _find_in_node(self.root, key) def insert_key(self, key: int): Inserts a key into the B-Tree. root = self.root if len(root.keys) == self.max_number_of_keys: new_root = Node() self.root = new_root new_root.children.append(root) self._split_child(new_root, 0) self._insert_non_full(new_root, key) else: self._insert_non_full(root, key)"},{"question":"# Maximum Clique Finder in a Network You are a developer helping to analyze a social network. In this network, every person is a node, and every friendship is an edge connecting two nodes. Your goal is to identify all the maximal cliques in this network. A clique is a subset of nodes such that there is a direct edge between any two nodes in this subset. In simpler terms, every person in this clique is friends with every other person within the clique. # Problem Statement Write a function `find_all_cliques(edges)` that takes a dictionary `edges` as input. The keys in this dictionary represent nodes (persons), and the values are sets representing nodes connected to them (friends). The function should return a list of lists, where each sublist represents a maximal clique found in the network. # Input Format The input is a dictionary: ```python { \\"node1\\": {\\"node2\\", \\"node3\\"}, \\"node2\\": {\\"node1\\"}, \\"node3\\": {\\"node1\\"}, ... } ``` # Output Format The output should be a list of lists: ```python [ [\\"node1\\", \\"node2\\"], [\\"node1\\", \\"node3\\"], ... ] ``` # Constraints * The graph contains no self-loops (a node does not connect to itself). * The graph is undirected. * The number of nodes (n) will be such that 1 ≤ n ≤ 100. * The number of edges (e) will be such that 0 ≤ e ≤ 10,000. # Performance Requirements * The algorithm should work efficiently for graphs with up to 100 nodes. * Optimize the algorithm where possible to handle up to 10,000 edges without significant delays. # Example ```python edges = { \\"A\\": {\\"B\\", \\"C\\"}, \\"B\\": {\\"A\\", \\"C\\", \\"D\\"}, \\"C\\": {\\"A\\", \\"B\\"}, \\"D\\": {\\"B\\"} } result = find_all_cliques(edges) # Possible output: [[\'A\', \'B\', \'C\'], [\'B\', \'D\']] ``` # Notes 1. Ensure to handle graphs where nodes might not have any edges. 2. If multiple cliques of the same size exist, include them all in the result. Good luck!","solution":"from itertools import combinations def find_all_cliques(edges): def is_clique(nodes): for u, v in combinations(nodes, 2): if v not in edges[u]: return False return True max_cliques = [] nodes = list(edges.keys()) n = len(nodes) for r in range(1, n+1): for candidate in combinations(nodes, r): if is_clique(candidate): max_cliques.append(list(candidate)) maximal_cliques = [] for clique in max_cliques: if not any(set(clique) < set(other) for other in max_cliques): maximal_cliques.append(clique) return maximal_cliques"},{"question":"Pancake Sorting with Enhanced Efficiency The Pancake Sort algorithm sorts elements by repeatedly flipping subarrays to move the largest unsorted element to its proper position. Your task is to enhance the Pancake Sort algorithm to reduce the number of flips while maintaining its correctness. Implement the function `enhanced_pancake_sort` that sorts a given list of integers in ascending order by reducing unnecessary flips: **Function Signature**: ```python def enhanced_pancake_sort(arr: list) -> list: Sorts an array using an optimized Pancake Sort approach to minimize the number of flips. Parameters: arr (list): A list of integers to be sorted. Returns: list: The sorted list of integers. ``` **Inputs**: - An unsorted list `arr` of integers with length N (where 0 <= N <= 1000). **Outputs**: - Returns the input list sorted in ascending order. **Constraints**: - You should try to minimize the number of flips performed. - The function should handle edge cases effectively, such as empty arrays and arrays with duplicate elements. **Example**: ```python # Example 1 arr = [3, 6, 1, 10, 5] print(enhanced_pancake_sort(arr)) # Output: [1, 3, 5, 6, 10] # Example 2 arr = [1, 2, 3, 4, 5] print(enhanced_pancake_sort(arr)) # Output: [1, 2, 3, 4, 5] # Example 3 arr = [] print(enhanced_pancake_sort(arr)) # Output: [] # Example 4 arr = [10, 20, 20, 5, 7] print(enhanced_pancake_sort(arr)) # Output: [5, 7, 10, 20, 20] ``` **Requirements**: - Ensure the solution is efficient and minimizes the number of flips. - The algorithm should work correctly for all specified edge cases.","solution":"def enhanced_pancake_sort(arr): def flip(subarr, k): return subarr[:k+1][::-1] + subarr[k+1:] def find_max_index(subarr, n): return subarr.index(max(subarr[:n])) n = len(arr) for size in range(n, 1, -1): max_index = find_max_index(arr, size) if max_index != size - 1: # max already in correct position if max_index != 0: arr = flip(arr, max_index) arr = flip(arr, size - 1) return arr"},{"question":"**Word Pattern Check** **Problem Description:** You are provided with a `pattern` consisting of lowercase letters and a string `s` containing lowercase words separated by a single space. Your task is to implement a function `word_pattern(pattern: str, s: str) -> bool` that checks if `s` follows the same pattern as `pattern`. A full match is required, where each letter in `pattern` maps to a distinct word in `s`, and vice versa. This mapping must be consistent throughout. **Example:** 1. Input: `pattern = \\"abba\\"`, `s = \\"dog cat cat dog\\"` Output: `True` 2. Input: `pattern = \\"abba\\"`, `s = \\"dog cat cat fish\\"` Output: `False` 3. Input: `pattern = \\"aaaa\\"`, `s = \\"dog cat cat dog\\"` Output: `False` 4. Input: `pattern = \\"abba\\"`, `s = \\"dog dog dog dog\\"` Output: `False` **Function Signature:** ```python def word_pattern(pattern: str, s: str) -> bool: ``` **Constraints:** - The pattern will only contain lowercase English letters. - The string `s` will only contain lowercase words separated by a single space. - Patterns and words will be non-empty. - Solve with an O(n) time complexity where n is the max length of pattern or the number of words in s.","solution":"def word_pattern(pattern: str, s: str) -> bool: words = s.split() if len(pattern) != len(words): return False # Maps to check the bijective relationship char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: char_to_word[char] = word if word in word_to_char: if word_to_char[word] != char: return False else: word_to_char[word] = char return True"},{"question":"You are tasked with implementing a function that takes a list of words and a list of symbols, then modifies each word by surrounding the most suitable matching symbol with square brackets. Specifically, the longest matching symbol within the word should be bracketed. If there are no matching symbols, the word should remain unchanged. Function Signature ```python def bracket_words(words: List[str], symbols: List[str]) -> List[str]: ``` Input: - `words` is a list of strings, where each string represents a word. (1 ≤ len(words) ≤ 10^3) - `symbols` is a list of strings, where each string represents a symbol. (1 ≤ len(symbols) ≤ 10^2) Output: - Returns a list of strings, where each string is a word from the input list transformed according to the specified rules. Constraints: - If a word matches multiple symbols, choose the match with the longest symbol. - Only one match per word and once a symbol is bracketed for a word, don\'t reconsider the same symbol for multiple matches within that word. - All words and symbols consist only of lowercase and uppercase English letters. Example: ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] print(bracket_words(words, symbols)) # Expected Output: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` Guidance: - Consider constructing a trie structure for the given symbols to optimize the symbol matching. - Ensure your solution has a time complexity better than O(n * m * w).","solution":"from typing import List def bracket_words(words: List[str], symbols: List[str]) -> List[str]: # Sort symbols by length in descending order to prefer longer matches symbols.sort(key=len, reverse=True) output = [] for word in words: modified = word for symbol in symbols: if symbol in word: # Replace the first occurrence of the symbol modified = modified.replace(symbol, f\'[{symbol}]\', 1) break output.append(modified) return output"},{"question":"# Graph Traversal and Path Finding Given a directed graph represented as an adjacency list, implement a function to find the shortest path between two nodes using Breadth-First Search (BFS). The function should return the path as a list of nodes or **None** if no path exists. Function Signature ```python def find_shortest_path(graph, start, goal): Args: graph (dict): A dictionary where keys are node identifiers and values are lists of adjacent nodes. start: The starting node of the path. goal: The target node of the path. Returns: list: A list of nodes representing the shortest path from start to goal, inclusive. None if no path exists. ``` Input & Output Formats * **Input**: * `graph`: Dictionary with nodes and their corresponding adjacent nodes. * `start`: The node from which to start the traversal. * `goal`: The destination node of the traversal. * **Output**: * A list of nodes representing the path from start to goal. None if the path does not exist. Constraints * All node values are unique. * The graph can contain cycles. * There might be multiple paths between two nodes, return the shortest one. Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\', \'E\'], \'C\': [\'F\'], \'D\': [\'G\'], \'E\': [\'G\'], \'F\': [\'G\'], \'G\': [] } start = \'A\' goal = \'G\' assert find_shortest_path(graph, start, goal) == [\'A\', \'B\', \'D\', \'G\'] ``` # Notes: * The implementation should efficiently handle the traversal and ensure minimal usage of memory while maintaining correct path tracking. * Use BFS for guaranteed shortest path finding.","solution":"def find_shortest_path(graph, start, goal): Returns the shortest path in a directed graph from start node to goal node using BFS. Parameters: graph (dict): A dictionary where keys are node identifiers and values are lists of adjacent nodes. start: The starting node of the path. goal: The target node of the path. Returns: list: A list of nodes representing the shortest path from start to goal, inclusive. None if no path exists. from collections import deque if start == goal: return [start] queue = deque([(start, [start])]) visited = set() while queue: current, path = queue.popleft() if current in visited: continue visited.add(current) for neighbor in graph.get(current, []): if neighbor == goal: return path + [neighbor] else: queue.append((neighbor, path + [neighbor])) return None"},{"question":"Scenario You are working on a text processing system that needs to frequently check if patterns repeat within a string. Your task is to implement a function that determines if a given non-empty string can be constructed by repeating a substring of it multiple times. Task Description Implement a function: ```python def is_repeated_substring_pattern(s: str) -> bool: Determines if a given string can be formed by repeating a substring of it multiple times. :param s: A non-empty input string, consisting of lowercase alphabetic characters. :return: True if the string can be formed by repeating a substring of it multiple times, otherwise False. ``` Input and Output Formats * **Input**: - `s` (str): A non-empty string, consisting of lowercase alphabetic characters only. * **Output**: - Returns a boolean value: - `True` if the string can be formed by repeating a substring of it multiple times. - `False` otherwise. Constraints: - The string `s` will have at least 1 and at most 10000 characters. - The string will only contain lowercase English letters. Examples ```python assert is_repeated_substring_pattern(\\"abab\\") == True assert is_repeated_substring_pattern(\\"aba\\") == False assert is_repeated_substring_pattern(\\"abcabcabcabc\\") == True assert is_repeated_substring_pattern(\\"a\\") == True ``` Performance Requirements - An optimal solution should run in linear time O(n) with respect to the length of the string. - The space complexity should be O(n).","solution":"def is_repeated_substring_pattern(s: str) -> bool: Determines if a given string can be formed by repeating a substring of it multiple times. :param s: A non-empty input string, consisting of lowercase alphabetic characters. :return: True if the string can be formed by repeating a substring of it multiple times, otherwise False. if not s: return False doubled_s = s + s stripped_s = doubled_s[1:-1] return s in stripped_s"},{"question":"# Binary Tree to Doubly Linked List Conversion Context: You are given a binary tree where each node contains an integer value, and pointers to the left and right children. Your task is to convert this binary tree into a sorted doubly linked list in-place. The doubly linked list should be in the same order as an in-order traversal of the binary tree. Function Signature: ```python from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_to_doubly_linked_list(root: Optional[TreeNode]) -> Optional[TreeNode]: # Your code here ``` Input: * `root` - The root node of a binary tree, where each node has an integer value, and pointers to the left and right children. Output: * The head of the doubly linked list, where the left pointer of the head node is `None` and the right pointer points to the next node in the list. Constraints: 1. The number of nodes in the tree is in the range `[0, 10^4]`. 2. `-10^5 <= Node.val <= 10^5` Example: ```python # Example tree # 4 # / # 2 5 # / # 1 3 root = TreeNode(4) root.left = TreeNode(2, TreeNode(1), TreeNode(3)) root.right = TreeNode(5) head = binary_tree_to_doubly_linked_list(root) # The resulting doubly linked list should be: 1 <-> 2 <-> 3 <-> 4 <-> 5 ``` Notes: * Remember to handle edge cases such as an empty tree or a tree with only one node. * Make sure your function handles both balanced and unbalanced trees efficiently. * Think carefully about in-place modification. Challenge: Implement the function without using any extra space except for the recursion stack.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_to_doubly_linked_list(root: Optional[TreeNode]) -> Optional[TreeNode]: if not root: return None # Helper function to perform inorder traversal and link nodes def inorder_traversal(node): nonlocal last, head if not node: return # Recur on the left child inorder_traversal(node.left) # Link the previous node (last) with the current one (node) if last: last.right = node node.left = last else: # If this is the smallest node (leftmost), it will be the head of the doubly linked list head = node # Mark this node as the last processed node last = node # Recur on the right child inorder_traversal(node.right) # Initialize pointers to keep track of the head and the last processed node last, head = None, None # Perform the in-place conversion inorder_traversal(root) return head"},{"question":"# Fibonacci Sequence Algorithm Implementation Objective You are provided with code snippets that compute the nth Fibonacci number using different algorithmic approaches: Recursive, Dynamic Programming, and Iterative. Your task is to write a Python function that computes the nth Fibonacci number using the **Matrix Exponentiation** method, which can compute Fibonacci numbers in O(log n) time complexity. Function Signature ```python def fib_matrix_exp(n: int) -> int: pass ``` Input - An integer `n` (0 <= n <= 10^9) representing the position in the Fibonacci sequence. Output - An integer representing the nth Fibonacci number. Constraints - Your implementation must run in O(log n) time complexity. - Handle edge cases such as `n=0` and `n=1`. Detailed Description 1. **Matrix Representation**: The Fibonacci sequence can be expressed using the following matrix representation: ``` [F(n+1)] = [1 1]^n [F(1)] [F(n) ] [1 0] [F(0)] ``` 2. **Matrix Exponentiation**: Use the binary exponentiation (also known as exponentiation by squaring) to efficiently compute the power of the transformation matrix. 3. **Edge Cases**: - If n is 0, return 0. - If n is 1, return 1. Example ```python print(fib_matrix_exp(0)) # Output: 0 print(fib_matrix_exp(1)) # Output: 1 print(fib_matrix_exp(10)) # Output: 55 print(fib_matrix_exp(100)) # Output: 354224848179261915075 ``` Hints - Define a helper function to multiply two 2x2 matrices. - Define a helper function for matrix exponentiation using binary exponentiation. - Use these helper functions in your main function to calculate the nth Fibonacci number.","solution":"def matrix_mult(A, B): # Multiplies two 2x2 matrices A and B return [[A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]]] def matrix_pow(matrix, n): # Exponentiates matrix using binary exponentiation result = [[1, 0], [0, 1]] # Identity matrix base = matrix while n > 0: if n % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) n //= 2 return result def fib_matrix_exp(n: int) -> int: if n == 0: return 0 if n == 1: return 1 # Transformation matrix for Fibonacci sequence F = [[1, 1], [1, 0]] # Raise the matrix to the (n-1)th power result = matrix_pow(F, n-1) # The resulting matrix [ [Fn+1, Fn], [Fn, Fn-1] ] # Fn is therefore result[0][0] return result[0][0]"},{"question":"You are tasked with implementing a function to sort an array of integers using the Shell Sort algorithm. This function should demonstrate your understanding of advanced sorting techniques and in-place algorithms. # Requirements: Write a function named `shell_sort` that: - Accepts a list of integers as input. - Returns the list sorted in ascending order using the Shell Sort algorithm. # Input: - A list of integers `arr` of size `n` (0 <= n <= 10^5). - It is guaranteed that all integers in the list fit into standard 32-bit signed integers. # Output: - The function should return a list of integers sorted in ascending order. # Constraints: - The average time complexity of your implementation should be aimed around O(n^(3/2)) by choosing an appropriate gap sequence. - You should avoid using extra space beyond the input array. # Example: ```python # Input arr = [12, 34, 54, 2, 3] # Output [2, 3, 12, 34, 54] ``` # Solution Structure: ```python def shell_sort(arr): # Write your function code here pass # Test the function print(shell_sort([12, 34, 54, 2, 3])) # Output should be [2, 3, 12, 34, 54] ``` # Explanation: Your task is to implement the Shell Sort algorithm based on the principles explained. Make sure to choose an efficient gap sequence and address the edge cases and constraints outlined.","solution":"def shell_sort(arr): Sorts a list of integers using the Shell Sort algorithm. Returns the sorted list in ascending order. n = len(arr) gap = n // 2 while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 return arr"},{"question":"# Building a Polynomial Calculator Design a `Polynomial` class to handle polynomial expressions using the given `Monomial` class. You will be required to implement methods to add, subtract, multiply, and divide polynomials, as well as evaluate them for given variable values. # Requirements: 1. **Class Definition**: Define a class `Polynomial` to encapsulate polynomial expressions. 2. **Operations**: Implement the following methods: - `__add__(self, other: Union[int, float, Fraction, Monomial, Polynomial]) -> Polynomial`: Add polynomials. - `__sub__(self, other: Union[int, float, Fraction, Monomial, Polynomial]) -> Polynomial`: Subtract polynomials. - `__mul__(self, other: Union[int, float, Fraction, Monomial, Polynomial]) -> Polynomial`: Multiply polynomials. - `__truediv__(self, other: Union[int, float, Fraction, Monomial, Polynomial]) -> Polynomial`: Divide polynomials. - `subs(self, substitutions: Union[int, float, Fraction, Dict[int, Union[int, float, Fraction]]]) -> Union[int, float, Fraction]`: Apply variable substitutions for evaluation. 3. **Edge Cases**: Handle all possible edge cases such as division by zero and operations involving zero polynomials. 4. **String Representation**: Implement `__str__(self) -> str` to print the polynomial in a readable format. # Expected Input and Output: - **Input**: Polynomial expressions as objects of the `Polynomial` class or `Monomial` class. Coefficients can be integers, floats, or fractions. Substitution dictionary for evaluating the polynomial. - **Output**: Resulting polynomials after operations or evaluated results after substitution. # Constraints: - Coefficients will be integers, floats, or fractions. - Variable exponents are integers. - Ensure that your implementations handle edge cases such as empty polynomials, zero coefficients, and zero exponents. # Performance Requirements: - Aim to achieve O(n) time complexity for addition and subtraction where n is the number of monomials of the largest polynomial. - Multiplication should ideally be kept within O(n*m) where n and m are the numbers of monomials in the respective polynomials. - Avoid unnecessary memory usage by cleaning up monomials with zero coefficients. # Example: ```python # Example usage of Polynomial class p1 = Polynomial([Monomial({1: 1}, 2), Monomial({2: 2}, 3)]) p2 = Polynomial([Monomial({1: 1}, 1), Monomial({2: 2}, -1)]) p_sum = p1 + p2 print(p_sum) # Expected output: 3(a_1)+(2)(a_2)^2 substitution = {1: 2, 2: 3} evaluated_result = p_sum.subs(substitution) print(evaluated_result) # Expected output will be the evaluation of the polynomial after substitution ```","solution":"from typing import Union, List, Dict from fractions import Fraction class Monomial: def __init__(self, exponents: Dict[int, int], coefficient: Union[int, float, Fraction]): self.exponents = exponents # dictionary where keys are variable indices, values are their exponents self.coefficient = coefficient def __add__(self, other): if self.exponents == other.exponents: return Monomial(self.exponents, self.coefficient + other.coefficient) else: raise ValueError(\\"Monomials have different exponents.\\") def __mul__(self, other): new_exponents = self.exponents.copy() for key, value in other.exponents.items(): if key in new_exponents: new_exponents[key] += value else: new_exponents[key] = value return Monomial(new_exponents, self.coefficient * other.coefficient) def __str__(self): terms = [f\\"{self.coefficient}\\"] for var, exp in self.exponents.items(): terms.append(f\\"(a_{var}^{exp})\\") return \\" * \\".join(terms) class Polynomial: def __init__(self, terms: List[Monomial]): self.terms = terms self.combine_like_terms() def combine_like_terms(self): # Combine monomials with the same exponents combined = {} for term in self.terms: exponents = tuple(sorted(term.exponents.items())) if exponents in combined: combined[exponents].coefficient += term.coefficient else: combined[exponents] = Monomial(term.exponents, term.coefficient) self.terms = [term for term in combined.values() if term.coefficient != 0] def __add__(self, other): return Polynomial(self.terms + other.terms) def __sub__(self, other): negated_terms = [Monomial(term.exponents, -term.coefficient) for term in other.terms] return Polynomial(self.terms + negated_terms) def __mul__(self, other): new_terms = [] for term1 in self.terms: for term2 in other.terms: new_terms.append(term1 * term2) return Polynomial(new_terms) def __truediv__(self, other): raise NotImplementedError(\\"Polynomial division is not implemented.\\") def subs(self, substitutions: Union[int, float, Fraction, Dict[int, Union[int, float, Fraction]]]) -> Union[int, float, Fraction]: result = 0 for term in self.terms: term_value = term.coefficient for var, exp in term.exponents.items(): term_value *= substitutions[var] ** exp result += term_value return result def __str__(self): if not self.terms: return \\"0\\" return \\" + \\".join(str(term) for term in self.terms)"},{"question":"**Scenario**: You have been hired by a company to maintain a record of customer orders. Unfortunately, the orders are stored in an unsorted array, making it hard to efficiently locate a specific order. You need to implement an efficient (yet simple, due to low resources for now) solution to find the index of a specific order based on the order\'s unique ID. **Task**: Write a function `find_order_index` that takes in two arguments: 1. `orders`: A list of integers representing unique order IDs. 2. `target_order_id`: An integer representing the ID of the order you\'re searching for. The function should return the index of `target_order_id` in the `orders` list. If `target_order_id` is not found, return -1. **Function Signature**: ```python def find_order_index(orders: list, target_order_id: int) -> int: pass ``` **Input Format**: - `orders`: A list of integers `[order_id_1, order_id_2, ..., order_id_n]` where `1 ≤ length of orders ≤ 10^5` and `0 ≤ order_id_i ≤ 10^9`. - `target_order_id`: An integer `0 ≤ target_order_id ≤ 10^9`. **Output Format**: - An integer representing the index of `target_order_id` in the `orders` list. If the ID is not found, return -1. **Constraints**: - Time complexity of the solution should be O(n). - Space complexity should be O(1). **Example**: 1. Input: `orders = [5, 3, 1, 2, 4]`, `target_order_id = 3` Output: `1` (since 3 is at index 1) 2. Input: `orders = [5, 3, 1, 2, 4]`, `target_order_id = 6` Output: `-1` (since 6 is not present in the list) **Explanation**: - For the first example, the target order ID 3 is found at index 1 of the orders list. - For the second example, the target order ID 6 is not found in the orders list, so the function returns -1.","solution":"def find_order_index(orders: list, target_order_id: int) -> int: Returns the index of target_order_id in orders list. If target_order_id is not found, returns -1. for idx, order_id in enumerate(orders): if order_id == target_order_id: return idx return -1"},{"question":"# Cycle Detection in Directed Graph **Problem Description:** You are provided with an implementation for detecting cycles in a directed graph using Depth-First Search (DFS). Your task is to extend this implementation to handle additional features. Specifically, add functionality to: 1. Identify all the nodes involved in a cycle (if any) and return them as a list. 2. Handle cases where the graph may be disconnected, i.e., multiple subgraphs. **Input Format:** The function `detect_cycles(graph)` should take one parameter: - `graph` (dict): A dictionary representing a directed graph, where keys are vertices and values are lists of neighbors. **Output Format:** The function should return a tuple: - A boolean value indicating if a cycle exists. - A list of lists, where each sublist contains the nodes involved in one of the detected cycles. If no cycles are found, the list should be empty. **Function Signature:** ```python def detect_cycles(graph: dict) -> (bool, list): pass ``` **Constraints:** - The graph can have at most 1000 vertices and 10000 edges. **Example:** ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } # Expected output # (True, [[\'B\', \'D\', \'E\']]) print(detect_cycles(graph)) ``` # Notes: 1. Ensure that the implementation efficiently processes large graphs. 2. Consider edge cases such as empty graphs, graphs with no edges, and graphs with only isolated nodes. 3. You may utilize or modify the existing code snippets to build your solution.","solution":"def detect_cycles(graph): Detect cycles in a directed graph. This function returns a tuple where the first element is a boolean indicating if a cycle exists in the directed graph, and the second element is a list of lists where each sublist contains nodes involved in one of the detected cycles. Parameters: graph (dict) : A dictionary representing the directed graph. Keys are vertices and values are lists of neighbors. Returns: tuple : (bool, list[list]) (True if cycle exists else False, List of lists of nodes involved in cycles) def dfs(vertex): if vertex in stack: cycle_start_index = stack.index(vertex) cycle_nodes.append(stack[cycle_start_index:]) return True if vertex in visited: return False visited.add(vertex) stack.append(vertex) for neighbor in graph.get(vertex, []): if dfs(neighbor): return True stack.pop() return False visited = set() stack = [] cycle_nodes = [] has_cycle = False for node in graph.keys(): if node not in visited: if dfs(node): has_cycle = True return has_cycle, cycle_nodes"},{"question":"You are given an unsorted array of integers. Your task is to implement the bitonic sort algorithm to sort this array in ascending order. The size of the array will always be a power of two. Implement the function `bitonic_sort(arr)` which sorts the array in an ascending order using the bitonic sort algorithm outlined. # Function Signature ```python def bitonic_sort(arr: List[int]) -> List[int]: # Your code goes here ``` # Input * `arr`: A list of integers `arr` where `len(arr) = 2^k` for some integer `k >= 1`. # Output * Returns a sorted list of integers in ascending order. # Constraints * The size of the input list will always be a power of two. * The function should be capable of sorting arrays containing negative numbers and duplicate values. # Example ```python # Example 1 arr = [3, 7, 2, 8, 1, 6, 5, 4] assert bitonic_sort(arr) == [1, 2, 3, 4, 5, 6, 7, 8] # Example 2 arr = [1, -1, 3, -3, 5, -5, 7, -7] assert bitonic_sort(arr) == [-7, -5, -3, -1, 1, 3, 5, 7] ``` # Notes This problem tests your understanding of: * Recursive algorithm implementation. * Handling arrays with constraints. * Ensuring correct order through comparisons and merges. * Understanding and implementing a specialized sorting technique. Good luck and happy coding!","solution":"from typing import List def bitonic_sort(arr: List[int]) -> List[int]: def bitonic_merge(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 for i in range(low, low + k): if (direction == 1 and arr[i] > arr[i + k]) or (direction == 0 and arr[i] < arr[i + k]): arr[i], arr[i + k] = arr[i + k], arr[i] bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort_rec(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 bitonic_sort_rec(arr, low, k, 1) # sort in ascending order bitonic_sort_rec(arr, low + k, k, 0) # sort in descending order bitonic_merge(arr, low, cnt, direction) n = len(arr) bitonic_sort_rec(arr, 0, n, 1) return arr"},{"question":"# Diffie-Hellman Key Exchange Implementation Objective Implement the `diffie_hellman_key_exchange` function using Diffie-Hellman algorithm principles. Your task also includes creating a prime-checking function and finding a primitive root related to the given prime. Detailed Requirements 1. **Functions to Implement**: - `diffie_hellman_key_exchange(a, p, option=None)`: - `a` is the supposed primitive root. - `p` is the large prime number. - `option` is optional, used for debugging purposes. If set, extra output is printed. - Helper functions: - `prime_check(num)`: Checks if `num` is prime. - `find_primitive_root(n)`: Returns a list of primitive roots of `n`. 2. **Input/Output**: - **Input**: Two integers `a` (candidate primitive root) and `p` (large prime). - **Output**: Boolean indicating success or failure of key exchange. 3. **Constraints**: - `2 <= a <= p-1` - `p` should be a prime number. 4. **Expected Behavior**: - Determines if `a` is a valid primitive root of `p`. - Uses `a` and `p` to generate keys using Diffie-Hellman algorithm principles. - Outputs public/private keys (if `option` is specified) and confirms if shared keys match. Performance Requirements Ensure your solution handles large primes efficiently, employing appropriate mathematical optimizations. Example ```python # Sample Run result = diffie_hellman_key_exchange(5, 23, option=1) # Expected output: # Alice\'s private key: <some_private_key> # Alice\'s public key: <some_public_key> # Bob\'s private key: <some_private_key> # Bob\'s public key: <some_public_key> # Shared key calculated by Alice = <shared_key> # Shared key calculated by Bob = <shared_key> # True (indicating successful key exchange) assert result == True # Both shared keys should match ``` Notes - Use existing helper functions provided in the snippet for `alice_private_key`, `alice_public_key`, `bob_private_key`, `bob_public_key`, `alice_shared_key`, and `bob_shared_key`. - Include error handling to verify if `p` is prime and `a` is a primitive root of `p`.","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i ** 2 <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def find_primitive_root(p): if not is_prime(p): return [] def prime_factors(n): factors = set() d = 2 while d * d <= n: if n % d == 0: factors.add(d) while n % d == 0: n //= d d += 1 if n > 1: factors.add(n) return factors phi = p - 1 factors = prime_factors(phi) for r in range(2, p): for factor in factors: if pow(r, phi // factor, p) == 1: break else: return [r] return [] def diffie_hellman_key_exchange(a, p, option=None): if not is_prime(p): raise ValueError(f\\"The number {p} is not a prime.\\") primitive_roots = find_primitive_root(p) if a not in primitive_roots: raise ValueError(f\\"The number {a} is not a primitive root of {p}.\\") if option: import random alice_private_key = random.randint(2, p-2) bob_private_key = random.randint(2, p-2) alice_public_key = pow(a, alice_private_key, p) bob_public_key = pow(a, bob_private_key, p) alice_shared_key = pow(bob_public_key, alice_private_key, p) bob_shared_key = pow(alice_public_key, bob_private_key, p) print(f\\"Alice\'s private key: {alice_private_key}\\") print(f\\"Alice\'s public key: {alice_public_key}\\") print(f\\"Bob\'s private key: {bob_private_key}\\") print(f\\"Bob\'s public key: {bob_public_key}\\") print(f\\"Shared key calculated by Alice: {alice_shared_key}\\") print(f\\"Shared key calculated by Bob: {bob_shared_key}\\") return alice_shared_key == bob_shared_key else: return True"},{"question":"**Question**: You have been hired to work on a large-scale data-processing platform that frequently needs to verify whether certain integers are powers of two. You are to write a function that determines if a given integer is a power of two utilizing bitwise operation. # Function Signature ```python def is_power_of_two(n: int) -> bool: :param n: integer to be checked :return: True if n is a power of two, else False ``` # Input and Output Specifications: - **Input**: * An integer `n` where -2^31 <= n <= 2^31 - 1. - **Output**: * A boolean value: `True` if the given `n` is a power of two, `False` otherwise. # Constraints and Performance Requirements: - The solution should execute in constant time, O(1). - The solution should not use loops or recursion. - Consider all possible integers that fall within the specified range. # Example Scenarios 1. `is_power_of_two(1)` should return `True`, since 2^0 = 1. 2. `is_power_of_two(16)` should return `True`, since 2^4 = 16. 3. `is_power_of_two(18)` should return `False`, since 18 is not a power of two. 4. `is_power_of_two(0)` should return `False`, since 0 is not a power of two. 5. `is_power_of_two(-32)` should return `False`, since negative numbers cannot be powers of two. Your function will be tested against a variety of cases within the constraints listed above. Ensure it adheres to the stated performance requirements.","solution":"def is_power_of_two(n: int) -> bool: Determines if a given integer n is a power of two. :param n: integer to be checked :return: True if n is a power of two, else False # Check if n is greater than 0 and is a power of 2 using the bitwise AND operation # A number is a power of 2 if it has exactly one bit set in its binary representation, # i.e., it is of the form 2^k where k is a non-negative integer. # n & (n - 1) will be 0 only if n is a power of 2 and n > 0. return n > 0 and (n & (n - 1)) == 0"},{"question":"# Flatten Nested Arrays You are given a nested array that might contain other arrays to any depth. Your task is to implement a function that takes such a nested array and returns a flat array containing all the original elements but with none of the nested structures. Function Signature: ```python def flatten(input_arr: list) -> list: pass ``` Input: * `input_arr` (List) - A nested array which may contain integers, floats, strings, and other arrays. Output: * List - A flat array containing all elements in the given nested array in the same order. Constraints: * Do not use built-in functions like itertools.chain or recursive library functions. * You need to handle arbitrarily deep nesting. * Consider edge cases, such as empty nested arrays or arrays that contain empty lists. Performance Requirements: * Your solution should handle cases with high nesting levels efficiently to avoid recursion limits. Example: ```python assert flatten([1, [2, [3, 4], 5], 6]) == [1, 2, 3, 4, 5, 6] assert flatten([1, [\'a\', [2.5, []], \'b\'], []]) == [1, \'a\', 2.5, \'b\'] ``` # Scenario: Imagine you’re working on a data processing application where users can upload complex nested structures (like JSON). To simplify processing, you need to convert any given nested structure into a single flat list of values. This function will be a core utility in this transformation process.","solution":"def flatten(input_arr: list) -> list: Flattens a nested array into a single list with no nested structures. flat_list = [] # Helper function to handle the recursion def flatten_helper(arr): for element in arr: if isinstance(element, list): flatten_helper(element) else: flat_list.append(element) flatten_helper(input_arr) return flat_list"},{"question":"# ZigZag Iterator for K Lists You\'re tasked with implementing a more general ZigZag Iterator that can iterate over an arbitrary number of input lists in a zigzag (alternating) fashion. # Function Signature ```python class ZigZagIteratorK: def __init__(self, lists: List[List[int]]): Initialize your data structure here. :type lists: List[List[int]] pass def next(self) -> int: :rtype: int pass def has_next(self) -> bool: :rtype: bool pass ``` # Input * `lists`: A list of k input lists. Each list contains integers. The lists may be of different lengths and can be empty. # Output * `next()`: Returns the next element in the zigzag order. * `has_next()`: Returns a boolean indicating whether any elements are left to iterate over. # Constraints * Ensure constant time complexity for `next()` and `has_next()` operations. * Handle lists of varying lengths gracefully. # Example ```python lists = [[1, 2], [3, 4, 5, 6], [7, 8, 9]] it = ZigZagIteratorK(lists) output = [] while it.has_next(): output.append(it.next()) print(output) ``` * Expected Output: `[1, 3, 7, 2, 4, 8, 5, 9, 6]` # Requirements 1. Iterate across the lists in alternating order until all elements have been processed. 2. Handle edge cases such as empty input lists or lists of unequal length.","solution":"from typing import List class ZigZagIteratorK: def __init__(self, lists: List[List[int]]): Initialize your data structure here. :type lists: List[List[int]] self.lists = [lst for lst in lists if lst] self.queue = [] for idx, lst in enumerate(self.lists): if lst: self.queue.append((idx, 0)) # (index of list, index within list) def next(self) -> int: Return the next element in the zigzag order. :rtype: int if not self.has_next(): raise Exception(\\"No more elements in ZigZag Iterator\\") list_idx, elem_idx = self.queue.pop(0) next_elem = self.lists[list_idx][elem_idx] # If there are more elements in the current list, append next element index to the queue if elem_idx + 1 < len(self.lists[list_idx]): self.queue.append((list_idx, elem_idx + 1)) return next_elem def has_next(self) -> bool: Return whether any elements are left to iterate over. :rtype: bool return len(self.queue) > 0"},{"question":"# Question: Fibonacci Number Finder **Scenario**: You\'re participating in a technical coding challenge where you\'re required to help an athlete find the position of a Fibonacci number efficiently. The Fibonacci sequence is defined as follows: - F(0) = 0 - F(1) = 1 - For n ≥ 2, F(n) = F(n-1) + F(n-2) Given a positive integer `n`, your task is to write a function that returns the `n`-th Fibonacci number. **Function Signature**: ```python def find_fibonacci(n: int) -> int: ``` **Input**: - An integer `n` (1 ≤ n ≤ 35) **Output**: - The `n`-th Fibonacci number. **Examples**: 1. `find_fibonacci(1)` should return `1`. 2. `find_fibonacci(2)` should return `1`. 3. `find_fibonacci(3)` should return `2`. 4. `find_fibonacci(10)` should return `55`. **Constraints**: - You must achieve a solution with O(n) time complexity. - Aim for an O(1) space complexity. **Clarifications**: - Focus on an iterative solution rather than a recursive one to maintain efficiency in both time and space. - The dynamic programming approach will be helpful to ensure the optimal solution. Good luck! Your efficiency in solving this problem will be tested against large inputs within the provided constraints.","solution":"def find_fibonacci(n: int) -> int: Returns the n-th Fibonacci number. if n == 1 or n == 2: return 1 prev, curr = 1, 1 for _ in range(3, n + 1): prev, curr = curr, prev + curr return curr"},{"question":"# Implementation Question: One Edit Distance **Context**: You are creating a spelling suggestion feature for your text editor. Words that are just one edit (insertion, deletion, or modification) away from the user-typed word should be highlighted as suggestions. To achieve this, you first need to check if two words are indeed one edit distance apart. **Problem Statement**: Write a function `is_one_edit_distance(s: str, t: str) -> bool` that determines if two input strings `s` and `t` are at exactly one edit distance apart. **Function Signature**: ```python def is_one_edit_distance(s: str, t: str) -> bool: pass ``` **Input**: - `s` (1 <= len(s) <= 10^4): A non-empty string. - `t` (1 <= len(t) <= 10^4): A non-empty string. **Output**: - Return True if the strings `s` and `t` are exactly one edit distance apart, otherwise return False. **Examples**: ``` is_one_edit_distance(\\"abc\\", \\"ab\\") # returns True (deletion) is_one_edit_distance(\\"ab\\", \\"abc\\") # returns True (insertion) is_one_edit_distance(\\"abc\\", \\"adc\\") # returns True (modification) is_one_edit_distance(\\"abc\\", \\"abc\\") # returns False (no changes) is_one_edit_distance(\\"abc\\", \\"abcdc\\") # returns False (more than one edit) ``` **Constraints**: - Ensure your solution runs in O(n) time complexity where n is the length of the shorter string. - Aim for O(1) additional space complexity. **Details**: - Handle edge cases like identical strings, strings of different lengths, and single-character strings. - Avoid unnecessary slicing and rebuilds of strings during comparison if possible. - Consider performance impacts of differing string lengths and reduce logic redundancies.","solution":"def is_one_edit_distance(s: str, t: str) -> bool: len_s = len(s) len_t = len(t) # Ensure that s is the shorter string if len_s > len_t: return is_one_edit_distance(t, s) # If the length difference is more than 1, return False if len_t - len_s > 1: return False for i in range(len_s): if s[i] != t[i]: # Case of Replacement if len_s == len_t: return s[i+1:] == t[i+1:] # Case of Insertion else: return s[i:] == t[i+1:] # Case of the extra character at the end of t return len_s + 1 == len_t"},{"question":"You are tasked with implementing a function `find_accepted_strings` using a Deterministic Finite Automaton (DFA) to verify multiple strings for acceptance. A DFA is defined by a set of transition rules, a start state, and a set of final states. Function Signature ```python def find_accepted_strings(transitions: dict, start: str, final: list, strings: list) -> list: ``` Input * `transitions`: A dictionary where keys are state identifiers and values are dictionaries mapping input characters to resulting states. * `start`: A string representing the initial state of the DFA. * `final`: A list of strings representing the accepting states. * `strings`: A list of strings to be evaluated by the DFA. Output * Returns a list of booleans where each boolean indicates whether the corresponding string in the input `strings` list is accepted by the DFA. Constraints * The DFA is well-formed, meaning there are no undefined transitions. * The state and character identifiers are unique strings. * 1 ≤ number of states ≤ 100 * 1 ≤ length of each string ≤ 10^6 * Characters in strings are valid input according to the transitions. Example ```python transitions = { \'q0\': {\'a\': \'q1\', \'b\': \'q2\'}, \'q1\': {\'a\': \'q0\', \'b\': \'q3\'}, \'q2\': {\'a\': \'q3\', \'b\': \'q0\'}, \'q3\': {\'a\': \'q2\', \'b\': \'q1\'} } start = \'q0\' final = [\'q1\'] strings = [\'a\', \'b\', \'ab\', \'ba\', \'bab\', \'aa\'] # find_accepted_strings(transitions, start, final, strings) # Output: [False, False, True, True, False, False] ``` Explanation * \'a\' leads to \'q1\' which is final, hence True. * \'b\' leads to \'q2\' which is not final, hence False. * \'ab\' transitions from \'q0\' -> \'q1\' -> \'q3\', not final, hence False. * \'ba\' transitions from \'q0\' -> \'q2\' -> \'q3\', not final, hence False. * \'bab\' transitions from \'q0\' -> \'q2\' -> \'q3\' -> \'q1\', which is final, hence True. * \'aa\' transitions from \'q0\' -> \'q1\' -> \'q0\', not final, hence False. **Task**: Implement the function `find_accepted_strings` that checks each string in the `strings` list and returns a list of booleans indicating whether each string is accepted by the DFA.","solution":"def find_accepted_strings(transitions, start, final, strings): Determine if each string in \'strings\' list is accepted by a DFA described by \'transitions\', \'start\' and \'final\' states. Parameters: transitions (dict): DFA transitions in the form {state: {input_char: next_state}}. start (str): Initial state of the DFA. final (list): List of accepting states. strings (list): List of strings to be checked. Returns: list: List of booleans indicating acceptance for each string. results = [] for string in strings: current_state = start for char in string: current_state = transitions[current_state][char] results.append(current_state in final) return results"},{"question":"Context: You are tasked to develop a new variant of a Queue that combines strengths from both Array and Linked List implementations. The `HybridQueue` should utilize an array for fast access and a linked list to avoid resizing overhead. Task: Implement the `HybridQueue` class, inheriting from the `AbstractQueue`. The idea is to have a fixed-capacity array for primary operations but fall back on a linked list to handle overflow situations instead of resizing the array. Requirements: 1. Implement the `enqueue`, `dequeue`, and `peek` methods. 2. Ensure `enqueue` adds to the array until it\'s full, then shifts to a linked list. 3. Ensure `dequeue` works seamlessly, removing from the array first, and then from the linked list if the array is empty. 4. The `peek` method should fetch the front element from the array and linked list appropriately. 5. Implement the `__iter__` method to iterate through the queue elements in FIFO order. 6. Handle edge cases such as operations on an empty queue. Input and Output: * **Input**: Operations to perform on the queue (`enqueue`, `dequeue`, `peek`). * **Output**: Results of `dequeue` and `peek` operations, including potential error messages. Constraints: * Array capacity will be a fixed positive integer. * Queue size will not exceed the maximum capacity of both array and linked list combined. Expected Method Signatures: ```python class HybridQueue(AbstractQueue): def __init__(self, capacity): # Initializes hybrid queue with fixed array capacity def enqueue(self, value): # Adds the value to the hybrid queue based on the specified behavior def dequeue(self): # Removes and returns the front value of the hybrid queue def peek(self): # Returns the front value without removing it from the hybrid queue def __iter__(self): # Iterates over elements in FIFO order in the hybrid queue ``` Performance Requirements: * The primary operations (`enqueue`, `dequeue`, `peek`, `is_empty`, `size`) should maintain efficiency akin to either an array or linked list queue. Good luck!","solution":"class Node: def __init__(self, value): self.value = value self.next = None class HybridQueue: def __init__(self, capacity): self.capacity = capacity self.array = [] self.list_head = None self.list_tail = None def enqueue(self, value): if len(self.array) < self.capacity: self.array.append(value) else: new_node = Node(value) if not self.list_tail: self.list_head = self.list_tail = new_node else: self.list_tail.next = new_node self.list_tail = new_node def dequeue(self): if self.array: return self.array.pop(0) elif self.list_head: dequeued_value = self.list_head.value self.list_head = self.list_head.next if self.list_head is None: self.list_tail = None return dequeued_value else: raise IndexError(\\"Dequeue from empty queue\\") def peek(self): if self.array: return self.array[0] elif self.list_head: return self.list_head.value else: raise IndexError(\\"Peek from empty queue\\") def __iter__(self): for item in self.array: yield item current_node = self.list_head while current_node: yield current_node.value current_node = current_node.next"},{"question":"# Skyline Problem You are given a list of buildings represented by their geometric coordinates. Each building is defined by a triplet of integers ([Li, Ri, Hi]), where: - (Li) is the x-coordinate of the building\'s left edge. - (Ri) is the x-coordinate of the building\'s right edge. - (Hi) is the building\'s height. You are required to implement a function that computes the skyline formed by these buildings. The skyline is defined by a series of \\"key points\\" which are the moments where there is a change in the building height. **Input Format:** - A list of lists (text{buildings}) containing the building triplets ([Li, Ri, Hi]). - Example: (text{buildings} = [[2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]]) **Output Format:** - A list of lists (text{result}) containing the key points formatted as ([x, y]). - Example: (text{result} = [[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]]) **Constraints:** - (0 leq L_i, R_i leq text{INT_MAX}) - (0 < H_i leq text{INT_MAX}) - (R_i - L_i > 0) - The number of buildings is in the range ([0, 10,000]) # Performance Requirements: - Ensure the solution has a time complexity of (O(N log N)), where (N) is the number of buildings. - Handle large input sizes efficiently. # Task: Implement the function `get_skyline(buildings: List[List[int]]) -> List[List[int]]`. Include necessary imports and helper functions if required. ```python import heapq def get_skyline(buildings): Calculates the skyline formed by the given buildings. :param buildings: List[List[int]], list of buildings represented by [Li, Ri, Hi] :return: List[List[int]], list of key points representing the skyline skyline, live = [], [] i, n = 0, len(buildings) while i < n or live: if not live or (i < n and buildings[i][0] <= -live[0][1]): x = buildings[i][0] while i < n and buildings[i][0] == x: heapq.heappush(live, (-buildings[i][2], -buildings[i][1])) i += 1 else: x = -live[0][1] while live and -live[0][1] <= x: heapq.heappop(live) height = len(live) and -live[0][0] if not skyline or height != skyline[-1][1]: skyline += [x, height], return skyline ```","solution":"import heapq def get_skyline(buildings): Calculates the skyline formed by the given buildings. :param buildings: List[List[int]], list of buildings represented by [Li, Ri, Hi] :return: List[List[int]], list of key points representing the skyline events = [] for L, R, H in buildings: events.append((L, -H, R)) events.append((R, 0, 0)) events.sort() result = [[0, 0]] live_heap = [(0, float(\\"inf\\"))] for x, negH, R in events: while live_heap[0][1] <= x: heapq.heappop(live_heap) if negH: heapq.heappush(live_heap, (negH, R)) if result[-1][1] != -live_heap[0][0]: result.append([x, -live_heap[0][0]]) return result[1:]"},{"question":"# Question: Advanced Binary Search Application You are given a sorted array of integers and a target value. You need to write a function that returns the index of the target value if it is present in the array. If the target value is not in the array, the function should return the index where the target value would be if it were inserted in order. **Function Signature**: ```python def search_insert_position(array: list[int], target: int) -> int: This function returns the index of the target value if present. If not present, it returns the index where it should be inserted. Parameters: array (list of int): Sorted list of integers. target (int): The target value to find or insert. Returns: int: The index of the target value or the insertion position. ``` **Input**: - A sorted list of integers `array`. - An integer `target`. **Output**: - An integer representing the index of the target value or the insertion position. **Example**: ```python print(search_insert_position([1, 3, 5, 6], 5)) # Output: 2 print(search_insert_position([1, 3, 5, 6], 2)) # Output: 1 print(search_insert_position([1, 3, 5, 6], 7)) # Output: 4 print(search_insert_position([1, 3, 5, 6], 0)) # Output: 0 ``` **Constraints**: - The algorithm should run in O(log(n)) time complexity. - The list can contain 0 or more elements with no upper limit on its size. **Performance Requirements**: - Your solution must be both time and space efficient. - Consider edge cases like empty lists, single-element lists, and insertion positions at the start or end of the list.","solution":"def search_insert_position(array: list[int], target: int) -> int: Returns the index of the target value if present. If not present, returns the index where it should be inserted. Parameters: array (list of int): Sorted list of integers. target (int): The target value to find or insert. Returns: int: The index of the target value or the insertion position. left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] == target: return mid elif array[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"# Simplify Unix-Style File Path Given an absolute path for a file (Unix-style), write a function `canonicalize_path` to simplify it. Context: You are developing a file system feature that requires processing and normalizing file paths. Your system receives various file paths with redundant or navigational elements. Your task is to simplify these paths to their canonical form for consistent internal handling and storage. Functional Requirements: 1. The input path is a Unix-like file absolute path that starts with a \'/\' (root directory). 2. The simplified path should not end with a trailing slash unless it\'s the root \\"/\\". 3. Single or multiple consecutive slashes (\'/\') should be treated as a single slash. 4. The special directory names `.` (current directory) and `..` (parent directory) should be handled explicitly: * `.` means stay in the current directory. * `..` means move up to the parent directory, unless already at the root. Input: * A single `string path` representing the absolute path. Output: * A simplified canonical `string` representing the absolute path. Examples: ```python # Example 1 path = \\"/home/\\" print(canonicalize_path(path)) # Output: \\"/home\\" # Example 2 path = \\"/a/./b/../../c/\\" print(canonicalize_path(path)) # Output: \\"/c\\" # Example 3 path = \\"/../\\" print(canonicalize_path(path)) # Output: \\"/\\" # Example 4 path = \\"/home//foo/\\" print(canonicalize_path(path)) # Output: \\"/home/foo\\" ``` Constraints: * The length of `path` will be in the range [1, 3000]. * The path will always begin with a \'/\'. Implement the function `canonicalize_path(path)` that performs the described operation. ```python def canonicalize_path(path): Simplifies the given Unix-style file path to its canonical form. :param path: str, the absolute file path to simplify :return: str, the simplified canonical path pass # Replace with your implementation ```","solution":"def canonicalize_path(path): Simplifies the given Unix-style file path to its canonical form. :param path: str, the absolute file path to simplify :return: str, the simplified canonical path parts = path.split(\'/\') stack = [] for part in parts: if part == \'\' or part == \'.\': continue elif part == \'..\': if stack: stack.pop() else: stack.append(part) return \'/\' + \'/\'.join(stack)"},{"question":"Context You have been provided with a basic implementation of a hash table using separate chaining to handle collisions. A hash table is a data structure that offers fast average-case time complexity for insertion, deletion, and lookup operations. However, this implementation does not handle resizing of the hash table when it grows too large, which can lead to performance degradation. Problem Statement Your task is to implement a `resize` method for the `SeparateChainingHashTable` class that dynamically resizes the underlying array when a threshold is reached. This operation should maintain the overall average time complexity for insertions and retrievals. Specifications 1. **`resize` Method**: - Should be triggered when the load factor (number of elements divided by the number of buckets) exceeds a given threshold (e.g., 0.75). - Should create a new underlying array with a larger size (typically double the current size) and rehash all existing elements into the new array. 2. **Input and Output**: - No explicit input arguments other than `self` (as it\'s a method of the class). - The method should not return any value but should update the state of the hash table. 3. **Constraints**: - The hash function can remain the same. - The `get`, `put`, and `del_` methods should continue to work correctly after resizing. 4. **Performance Requirements**: - The resizing operation should be efficient and should not take more than O(n) time, where n is the number of elements in the hash table before resizing. Implementation Extend the `SeparateChainingHashTable` class to include the `resize` method and modify the `put` method to call `resize` when necessary. ```python class SeparateChainingHashTable(object): ... def resize(self): # Your implementation goes here def put(self, key, value): # Existing implementation # Add resizing logic here if self._len / self.size > 0.75: self.resize() ``` Example ```python table = SeparateChainingHashTable(size=11) for i in range(20): table.put(f\'key{i}\', f\'value{i}\') print(len(table)) # Should print 20 after resizing print(any(table.get(f\'key{i}\') == f\'value{i}\' for i in range(20))) # All should retrieve correct values post-resize ``` Unit Test Provide unit tests to ensure the correctness of your implementation. ```python class TestSeparateChainingHashTable(unittest.TestCase): def test_resize(self): table = SeparateChainingHashTable(size=11) for i in range(20): table.put(f\'key{i}\', f\'value{i}\') self.assertEqual(len(table), 20) self.assertTrue(all(table.get(f\'key{i}\') == f\'value{i}\' for i in range(20))) if __name__ == \'__main__\': unittest.main() ```","solution":"class SeparateChainingHashTable: def __init__(self, size=11): self.size = size self.table = [[] for _ in range(self.size)] self._len = 0 # count of elements def _hash(self, key): return hash(key) % self.size def put(self, key, value): bucket_index = self._hash(key) for pair in self.table[bucket_index]: if pair[0] == key: pair[1] = value return self.table[bucket_index].append([key, value]) self._len += 1 if self._len / self.size > 0.75: self.resize() def get(self, key): bucket_index = self._hash(key) for pair in self.table[bucket_index]: if pair[0] == key: return pair[1] return None def del_(self, key): bucket_index = self._hash(key) for pair in self.table[bucket_index]: if pair[0] == key: self.table[bucket_index].remove(pair) self._len -= 1 return def resize(self): old_table = self.table new_size = self.size * 2 self.size = new_size self.table = [[] for _ in range(new_size)] self._len = 0 # Reset element count and let put() handle it for bucket in old_table: for key, value in bucket: self.put(key, value) # Rehash and insert into new table def __len__(self): return self._len"},{"question":"# Missing Number in Sequence Given an array of unique integers within the range ([0, n]), write a function to find the missing number from the sequence. The numbers in the input do not necessarily appear in sorted order, and the sequence is guaranteed to have exactly one missing number. The difference between consecutive integers cannot be more than 1. **Function Signature**: ```python def find_missing_number(nums: List[int]) -> int: ``` **Input**: - `nums` (List[int]): A list of unique integers within the range ([0, n]). **Output**: - An integer representing the missing number in the sequence. **Example**: ```python # Example 1: nums = [4, 1, 3, 0, 6, 5, 2] # Explanation: The missing number is 7 as the numbers from 0 to 6 are present. # Example 2: nums = [0, 1, 2, 3, 4] # Explanation: The missing number is 5 as the sequence is complete up to 4. ``` **Constraints**: - The array length is ( n ). - The different numbers within the array are unique. **Hint**: - Consider using arithmetic properties or bit manipulation to derive the missing number efficiently. **Edge Cases**: - An empty array should be handled correctly. - If all integers from ([0, n]) are present, return the next integer ( n+1 ).","solution":"def find_missing_number(nums): Returns the missing number in the sequence [0, n] from the given list of unique integers. :param nums: A list of unique integers within the range [0, n] :return: The missing number in the sequence n = len(nums) total_sum = n * (n + 1) // 2 # Sum of all numbers from 0 to n current_sum = sum(nums) # Sum of the given numbers return total_sum - current_sum"},{"question":"Context: You are working as a software developer at a tech company, and your team is in charge of developing a smart city navigation software. One of the tasks you need to complete involves finding various types of paths through a city\'s road network, which is represented as a graph. Task: Implement a function to find the longest path between two nodes in an undirected graph. The city roads are bidirectional with no cyclic paths, simplifying the problem. The road network is represented as an adjacency list. Requirements: 1. **Function Signature**: ```python def find_longest_path(graph: Dict[str, List[str]], start: str, end: str) -> List[str]: ``` 2. **Input**: - `graph` (Dict[str, List[str]]): The adjacency list representing the graph. - `start` (str): The starting city node. - `end` (str): The destination city node. 3. **Output**: - (List[str]): A list of city nodes representing the longest path from `start` to `end`. If no path exists, return an empty list. 4. **Constraints**: - The graph is undirected and acyclic. - The cities are represented as strings. - It is guaranteed that `start` and `end` nodes are present in the graph. Examples: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } find_longest_path(graph, \'A\', \'F\') # Expected output: [\'A\', \'C\', \'F\'] ``` Please ensure your implementation handles edge cases such as disconnected nodes or no available path between `start` and `end`. Performance: Strive for optimal performance and avoid unnecessary computations.","solution":"def find_longest_path(graph, start, end): def dfs(current_node, end, visited, path): visited.add(current_node) path.append(current_node) if current_node == end: # We have reached the destination if len(path) > len(dfs.longest_path): dfs.longest_path = list(path) else: for neighbor in graph[current_node]: if neighbor not in visited: dfs(neighbor, end, visited, path) path.pop() visited.remove(current_node) dfs.longest_path = [] visited = set() path = [] dfs(start, end, visited, path) return dfs.longest_path"},{"question":"# Question: Implement a Binary Search Tree with Insertion and Search Objective You are required to implement a Binary Search Tree (BST) in which we can insert new values and search for existing values. Task Implement the following methods for a Binary Search Tree: 1. `insert(val: int)`: Inserts a value `val` into the BST. 2. `search(val: int) -> bool`: Searches for the value `val` in the BST and returns `True` if it exists, `False` otherwise. Constraints - The `val` will be an integer. - The number of operations will not exceed 10^4. # Input - Values to be inserted or searched will be integers between -10^4 and 10^4. # Output - For `search`, return `True` or `False` indicating the presence of the value in the BST. # Example ```python # Create an instance of BST bst = BST() # Insert values bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) # Search values print(bst.search(10)) # Output: True print(bst.search(5)) # Output: True print(bst.search(6)) # Output: False ``` # Implementation Constraints - Do not use any external libraries or built-in data structures for trees. - Ensure the insertion and search operations maintain the BST properties. Additional Information - The BST class can be initialized without parameters. - Implement the `TreeNode` class provided to represent the nodes in the script. ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val: int): # Your code to insert \'val\' in the BST def search(self, val: int) -> bool: # Your code to search \'val\' in the BST ```","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val: int): if not self.root: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left: self._insert(node.left, val) else: node.left = TreeNode(val) else: if node.right: self._insert(node.right, val) else: node.right = TreeNode(val) def search(self, val: int) -> bool: return self._search(self.root, val) def _search(self, node, val): if not node: return False if node.val == val: return True elif val < node.val: return self._search(node.left, val) else: return self._search(node.right, val)"},{"question":"# Coding Challenge: Encode and Decode Strings You are tasked with designing the two functions `encode` and `decode` to convert a list of strings into a single encoded string and then back to its original form. These functions should demonstrate your understanding of string manipulation, handling edge cases, and ensuring the correctness of data integrity throughout the process. Function Definitions 1. `encode(strs: List[str]) -> str`: - **Input**: A list of strings `strs`. - **Output**: A single string encoding the entire list of strings. 2. `decode(s: str) -> List[str]`: - **Input**: A single encoded string `s`. - **Output**: A list of original strings that were encoded in `s`. Requirements * When encoding, prepend each string with its length followed by a colon. * Ensure the decoding method correctly interprets the encoded format and retrieves the original list of strings. * Your solution should handle edge cases such as empty strings and varying string lengths. Example ```python # Example Usage: strs = [\\"hello\\", \\"world\\", \\"python\\"] encoded_str = encode(strs) # Should return: \\"5:hello5:world6:python\\" decoded_list = decode(encoded_str) # Should return: [\\"hello\\", \\"world\\", \\"python\\"] ``` Constraints * The length of each string in the list will not exceed 10^4. * The total number of strings in the list will not exceed 10^4. * You may assume the encoded string fits in memory. Implement the functions `encode` and `decode` accordingly: ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str # Your implementation here def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] # Your implementation here ``` Test your functions to ensure they work as expected with various edge cases.","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str return \'\'.join(f\\"{len(s)}:{s}\\" for s in strs) def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] i, n = 0, len(s) result = [] while i < n: j = i while s[j] != \':\': j += 1 length = int(s[i:j]) result.append(s[j+1:j+1+length]) i = j + 1 + length return result"},{"question":"You are tasked with finding a specific element in a large dataset. The dataset is represented as an array, and the elements are not sorted. You need to implement an efficient search function that can handle multiple queries and provide the index of the query element if it exists in the array. Write a function `multi_query_search` that takes two parameters: 1. `array`: a list of integers where the integers may repeat. 2. `queries`: a list of integers where each integer is a query element you need to search in the `array`. The function should return a list of integers where each integer is the index of the corresponding query element found in the `array`. If a query element is not found, return -1 for that query. Input Format * `array`: A list of integers with length `n` (1 <= n <= 10^6). * `queries`: A list of integers with length `m` (1 <= m <= 10^5). Output Format * Return a list of integers where each integer represents the index of the corresponding element from `queries` found in `array`. If an element is not found, return -1 at that position. Constraints * Array elements and query elements are in the range of -10^9 to 10^9. * The function must have an efficient implementation to handle the upper constraints efficiently. # Example ```python array = [5, 3, 7, 9, 1, 4, 2, 6, 8] queries = [3, 6, 10, 2, 5] # The function should return [1, 7, -1, 6, 0] def multi_query_search(array, queries): # Your code here # Function call example: print(multi_query_search(array, queries)) # expected output: [1, 7, -1, 6, 0] ``` # Notes * Ensure that your function efficiently handles large inputs. * Consider corner cases like empty arrays, and ensure that your implementation is robust.","solution":"def multi_query_search(array, queries): Returns the index of each query element in array. If a query element is not found, returns -1. # Create a dictionary to store the first occurrence index of each element in the array index_map = {} for idx, num in enumerate(array): if num not in index_map: index_map[num] = idx # For each query, use the index map to find the index or return -1 if not found result = [] for query in queries: result.append(index_map.get(query, -1)) return result"},{"question":"You are tasked with creating a program that generates all possible abbreviations of a given word. An abbreviation is formed by replacing some letters with their respective counts of consecutive omitted letters. Function Signature ```python def generate_abbreviations(word: str) -> list: ``` Input - `word` (string): The word that needs to be abbreviated. (0 ≤ `len(word)` ≤ 20) Output - `list`: A list of all possible abbreviations for the given word. Examples ```python generate_abbreviations(\'word\') => [\'word\', \'wor1\', \'wo1d\', \'wo2\', \'w1rd\', \'w1r1\', \'w2d\', \'w3\', \'1ord\', \'1or1\', \'1o1d\', \'1o2\', \'2rd\', \'2r1\', \'3d\', \'4\'] generate_abbreviations(\'\') => [\'\'] generate_abbreviations(\'a\') => [\'a\', \'1\'] ``` Constraints * Handle the edge cases properly. * Ensure the solution is efficient in terms of both time and space for words of up to length 20. Performance Requirements The function must run within reasonable time limits for the given constraints, reflecting an understanding of the balance between computational efficiency and comprehensive exploration of possibilities. Implementation Hint Use a recursive backtracking approach to explore all possible abbreviations.","solution":"def generate_abbreviations(word: str) -> list: def backtrack(index, current, count): if index == len(word): # If the current position is at the end of the word, # append the current abbreviation along with remaining count if any. result.append(current + (str(count) if count > 0 else \'\')) else: # Recurse by including the current character (with previous count if any). backtrack(index + 1, current + (str(count) if count > 0 else \'\') + word[index], 0) # Recurse by omitting the current character and increase the count. backtrack(index + 1, current, count + 1) result = [] backtrack(0, \\"\\", 0) return result"},{"question":"# Binary Search Implementation and Analysis Objective: Implement the binary search algorithm in a sorted array and then analyze its performance on different types of data inputs. Additionally, handle any potential edge cases to ensure robust implementation. Problem Statement: Given a sorted array of integers `arr` and an integer `target`, write a function `binary_search` that implements the binary search algorithm both iteratively and recursively. The function should return the index of the target if found, otherwise it should return -1. Function Signature: ```python def binary_search_iter(arr: List[int], target: int) -> int: pass def binary_search_recur(arr: List[int], low: int, high: int, target: int) -> int: pass ``` Input: * `arr` : List[int] - A sorted list of integers. * `target`: int - The integer value to be searched within the array. Output: * Return the index of the target element if it is found in the array. Otherwise, return -1. Constraints: * The length of `arr` will be between 1 and 10^5. * The values in `arr` will be integers between -10^9 and 10^9. * `target` will be an integer between -10^9 and 10^9. Guidelines: 1. Your solution should handle edge cases such as an empty array, array with one element, and duplicated elements. 2. Discuss the time and space complexity of your implementation in the comments. 3. Ensure the approach handles the recursive call stack efficiently without causing a stack overflow. 4. Write test cases to validate your implementation. Example: ```python arr = [-10, -3, 0, 5, 9, 12, 13] target = 9 # Expected Output: 4 arr = [1, 4, 5, 6, 7, 9, 9, 12] target = 8 # Expected Output: -1 ```","solution":"from typing import List def binary_search_iter(arr: List[int], target: int) -> int: Perform binary search iteratively on a sorted array. Returns the index of the target if found, otherwise returns -1. low, high = 0, len(arr) - 1 while low <= high: mid = (low + high) // 2 if arr[mid] == target: return mid elif arr[mid] < target: low = mid + 1 else: high = mid - 1 return -1 def binary_search_recur(arr: List[int], low: int, high: int, target: int) -> int: Perform binary search recursively on a sorted array. Returns the index of the target if found, otherwise returns -1. if low <= high: mid = (low + high) // 2 if arr[mid] == target: return mid elif arr[mid] < target: return binary_search_recur(arr, mid + 1, high, target) else: return binary_search_recur(arr, low, mid - 1, target) return -1 # Time complexity for both iterative and recursive binary search is O(log n). # Space complexity for iterative binary search is O(1). # Space complexity for recursive binary search is O(log n) due to the call stack."},{"question":"You are tasked with implementing a Range Minimum Query (RMQ) using a Segment Tree. You need to initialize the tree, build it, handle point updates, and efficiently query a range for the minimum value. # Requirements - Implement the Segment Tree with the following methods: * `__init__(self, arr)`: Initializes the segment tree with the given array of integers. * `build_tree(self)`: Constructs the segment tree. * `update(self, p, v)`: Updates the element at position `p` with value `v`. * `query(self, l, r)`: Returns the minimum value in the range [l, r]. # Input and Output Formats - **Initialization**: - Input: A list of integers. - Output: None - **Update**: - Input: Two integers `p` (position), and `v` (new value). - Output: None - **Query**: - Input: Two integers `l` (left index) and `r` (right index). - Output: Integer representing the minimum value in the range [l, r]. # Constraints - 1 ≤ length of the array ≤ 10^5 - -10^9 ≤ array element value ≤ 10^9 - There can be up to 10^4 update and query operations. # Example ```python arr = [2, 4, 5, 3, 4] # Initialize the segment tree seg_tree = SegmentTree(arr) # Query the range from index 2 to 4 print(seg_tree.query(2, 4)) # Output: 3 # Update the element at index 3 to 6 seg_tree.update(3, 6) # Query again after update print(seg_tree.query(0, 3)) # Output: 2 ``` # Algorithm 1. **Initialization**: Store the array elements in a tree structure. 2. **Build Tree**: Iteratively build the tree by calculating the minimum for each segment. 3. **Update**: Adjust the tree to reflect the new value at the specified position. 4. **Query**: Traverse the tree to find the minimum value in the specified range. ```python class SegmentTree: def __init__(self, arr): self.tree = [None for _ in range(len(arr))] + arr self.size = len(arr) self.build_tree() def build_tree(self): for i in range(self.size - 1, 0, -1): self.tree[i] = min(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, p, v): p += self.size self.tree[p] = v while p > 1: p = p // 2 self.tree[p] = min(self.tree[p * 2], self.tree[p * 2 + 1]) def query(self, l, r): l, r = l + self.size, r + self.size res = float(\'inf\') while l <= r: if l % 2 == 1: res = min(res, self.tree[l]) if r % 2 == 0: res = min(res, self.tree[r]) l, r = (l + 1) // 2, (r - 1) // 2 return res ```","solution":"class SegmentTree: def __init__(self, arr): self.size = len(arr) self.tree = [0] * (2 * self.size) self.build_tree(arr) def build_tree(self, arr): # Initialize the second half of the tree with the array elements for i in range(self.size): self.tree[self.size + i] = arr[i] # Build the rest of the tree for i in range(self.size - 1, 0, -1): self.tree[i] = min(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, p, v): # Update the value at position p p += self.size self.tree[p] = v # Update the rest of the tree while p > 1: p //= 2 self.tree[p] = min(self.tree[2 * p], self.tree[2 * p + 1]) def query(self, l, r): # Get the minimum value in range [l, r] res = float(\'inf\') l += self.size r += self.size + 1 while l < r: if l % 2 == 1: res = min(res, self.tree[l]) l += 1 if r % 2 == 1: r -= 1 res = min(res, self.tree[r]) l //= 2 r //= 2 return res"},{"question":"# Problem Description You are given two strings `s` and `t` where `t` is generated by randomly shuffling `s` and adding one additional character at a random position. Write a function `find_difference(s, t)` that identifies the additional character in `t`. # Input * `s` and `t` are strings that consist of only lowercase letters. * String `t` contains all characters of string `s` plus one additional character. # Output * Return the single character that was added to `t`. # Constraints * Both strings `s` and `t` are non-empty. * It is guaranteed that `t` will always be exactly one character longer than `s`. * The additional character in `t` is distinct and not in `s`. # Example ```python # Example 1 s = \\"abcd\\" t = \\"abecd\\" # Output: \'e\' # Example 2 s = \\"xyz\\" t = \\"xayz\\" # Output: \'a\' ``` # Solution Template ```python def find_difference(s, t): ret = 0 for ch in s + t: ret = ret ^ ord(ch) return chr(ret) ``` # Explanation The algorithm makes use of the XOR operation to find the single character difference. By iterating over the concatenated strings `s` and `t`, every character is XORed together. Since identical characters cancel each other out, the result will be the character that exists only in `t`. # Detailed Steps 1. Initialize a result variable `ret` to 0. 2. Concatenate both strings and iterate over each character. 3. Convert the character to its ASCII value using `ord()`, then XOR it with `ret`. 4. Return the character for the final result using `chr()`, which will be the additional character in `t`.","solution":"def find_difference(s, t): Identifies the additional character in string t which is not in s. :param s: Original string :param t: Shuffled string with one additional character :return: The additional character in t ret = 0 for ch in s + t: ret ^= ord(ch) return chr(ret)"},{"question":"# Assignment: Optimized GCD and LCM Calculation You are tasked with implementing and optimizing a set of utility functions for computing the Greatest Common Divisor (GCD) and Least Common Multiple (LCM) for two integers. In addition to the traditional approach, you need to ensure that bitwise operations are leveraged for efficiency, especially for large input values. # Requirements 1. **Function:** `gcd(a: int, b: int) -> int` - **Input:** Two non-negative integers `a` and `b`. - **Output:** The GCD of `a` and `b`. - **Constraints:** - Both `a` and `b` should be positive integers, and if any one of them is zero, raise a `ValueError`. 2. **Function:** `gcd_bit(a: int, b: int) -> int` - **Input:** Two non-negative integers `a` and `b`. - **Output:** The GCD of `a` and `b` using bitwise operations. - **Constraints:** - Both `a` and `b` should be positive integers, only positive integer inputs should be considered valid. 3. **Function:** `lcm(a: int, b: int) -> int` - **Input:** Two non-negative integers `a` and `b`. - **Output:** The LCM of `a` and `b`. - **Constraints:** - Both `a` and `b` should be non-zero positive integers, requiring GCD correctness for accurate results. 4. **Function:** `trailing_zero(x: int) -> int` - **Input:** A non-negative integer `x`. - **Output:** The count of trailing zeros in the binary representation of `x`. # Scenario: Imagine you are developing an encryption module that relies on fast calculations of GCD and LCM, which will be used to build large keys. Your task is to ensure the cryptographic algorithms can handle large prime numbers efficiently and securely. Edge cases, error handling, and optimization are critical. # Example Usage: ```python print(gcd(48, 18)) # Output: 6 print(lcm(48, 18)) # Output: 144 print(trailing_zero(40)) # Output: 3 print(gcd_bit(48, 18)) # Output: 6 ``` # Submission: Your solution should include: 1. Implementations of `gcd`, `gcd_bit`, `lcm`, and `trailing_zeros` with appropriate error handling. 2. Discuss the complexity analysis of each implemented function. 3. Write unit tests covering various edge cases and typical use cases for these algorithms. # Evaluation Criteria: - **Correctness**: Accurate results for given inputs. - **Efficiency**: Time and space complexity align with the described expectations. - **Edge Cases**: Proper handling of common and extreme cases. - **Code Readability**: Maintainable and understandable code quality with appropriate comments.","solution":"def gcd(a, b): Compute the Greatest Common Divisor (GCD) of two integers using Euclid\'s algorithm. if a <= 0 or b <= 0: raise ValueError(\\"Both a and b should be positive integers.\\") while b: a, b = b, a % b return a def trailing_zero(x): Count the number of trailing zeros in the binary representation of x. if x <= 0: raise ValueError(\\"x should be a positive integer.\\") count = 0 while x & 1 == 0: x >>= 1 count += 1 return count def gcd_bit(a, b): Compute the Greatest Common Divisor (GCD) using bitwise operations (Algorithm by Stein). if a <= 0 or b <= 0: raise ValueError(\\"Both a and b should be positive integers.\\") if a == b: return a if a == 0: return b if b == 0: return a k = min(trailing_zero(a), trailing_zero(b)) a >>= trailing_zero(a) while b != 0: b >>= trailing_zero(b) if a > b: a, b = b, a b = b - a return a << k def lcm(a, b): Compute the Least Common Multiple (LCM) using the GCD. if a <= 0 or b <= 0: raise ValueError(\\"Both a and b should be positive integers.\\") return a * b // gcd(a, b)"},{"question":"Implementing Enhanced Ternary Search Scenario: Suppose you are working for a company that handles large datasets, and you have learned about the efficiency of the ternary search algorithm over binary search for specific sorted datasets. Your task is to implement an enhanced version of ternary search that handles additional requirements. Requirements: * Write a function `enhanced_ternary_search` that employs the ternary search algorithm to find a given element in a sorted array. * The function should take the following inputs: - A sorted array of integers `arr`. - An integer `key` representing the value to be searched. - A boolean `return_index` which, if true, should return the index of the key; otherwise, it should return a boolean indicating whether the element exists in the array. * If the `key` is found, return the index or `True/False` based on `return_index`. * If the `key` is not found, return -1 or `False`. Constraints: * You can assume that the array may have up to (10^7) elements. * Optimize for time complexity. Input and Output Format: * The function signature should be as follows: ```python def enhanced_ternary_search(arr: List[int], key: int, return_index: bool) -> Union[int, bool]: ``` * Examples: ```python # Example 1 arr = [1, 3, 5, 7, 9, 11, 13, 15] key = 7 return_index = True # Expected Output: 3 # Example 2 arr = [1, 3, 5, 7, 9, 11, 13, 15] key = 4 return_index = False # Expected Output: False ``` Provide a robust solution ensuring optimal performance and handling edge cases as mentioned.","solution":"from typing import List, Union def enhanced_ternary_search(arr: List[int], key: int, return_index: bool) -> Union[int, bool]: Perform a ternary search to find the key in a sorted array. Parameters: arr (List[int]): A sorted array of integers. key (int): The integer value to search for. return_index (bool): If true, return the index of the key, else return a boolean indicating presence. Returns: Union[int, bool]: Index of the key or a boolean indicating presence. left, right = 0, len(arr) - 1 while left <= right: one_third = left + (right - left) // 3 two_third = right - (right - left) // 3 if arr[one_third] == key: return one_third if return_index else True if arr[two_third] == key: return two_third if return_index else True if key < arr[one_third]: right = one_third - 1 elif key > arr[two_third]: left = two_third + 1 else: left = one_third + 1 right = two_third - 1 return -1 if return_index else False"},{"question":"# Scenario You are working as part of a software engineering team that needs to implement an efficient search function for a mapping application. The map data is represented as a matrix wherein both rows and columns are sorted in non-decreasing order. To achieve the best performance within the given constraints, you are required to implement a key search algorithm for this matrix format. # Task Implement the function `search_in_sorted_matrix(matrix, key)` that efficiently searches for the given `key` in the `matrix`. If the key is found, return its position as a tuple `(row, column)`, otherwise return `None`. # Function Signature ```python def search_in_sorted_matrix(matrix: List[List[int]], key: int) -> Optional[Tuple[int, int]]: ``` # Input * `matrix` : List of lists of integers representing the 2D matrix. Each row and column is sorted in non-decreasing order. (`1 <= len(matrix) <= 1000`, `1 <= len(matrix[0]) <= 1000`, `-10^9 <= matrix[i][j] <= 10^9`) * `key` : Integer to search for in the matrix. # Output * Tuple of integers representing the position `(row, column)` if the key is found. * `None` if the key is not present in the matrix. # Example ```python matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 print(search_in_sorted_matrix(matrix, key)) # Output: (1, 2) key = 6 print(search_in_sorted_matrix(matrix, key)) # Output: None ``` # Constraints & Notes 1. The rows and columns of the matrix are sorted in non-decreasing order. 2. The function should be optimized for time complexity `O(m + n)` and space complexity `O(1)`. 3. Handle edge cases such as the key being the first or last element in the matrix or the matrix having only one row or one column.","solution":"from typing import List, Optional, Tuple def search_in_sorted_matrix(matrix: List[List[int]], key: int) -> Optional[Tuple[int, int]]: Searches for a key in a 2D matrix where rows and columns are sorted in non-decreasing order. Returns the position (row, column) if the key is found, otherwise returns None. if not matrix: return None rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 # Start from the top-right corner while row < rows and col >= 0: if matrix[row][col] == key: return (row, col) elif matrix[row][col] > key: col -= 1 # Move left else: row += 1 # Move down return None"},{"question":"# Flatten Nested Arrays You are given an array that may contain nested arrays of varying depths. Your task is to write efficient functions to flatten such an array into a single-level array. Consider edge cases and optimize for both time and space complexity. Write two functions: 1. `flatten(input_arr: list) -> list`: This function takes a nested array and returns a single-level array containing all the elements of the original nested structure. 2. `flatten_iter(iterable: Iterable) -> Iterator`: This function takes a nested iterable and returns a generator. The generator should produce elements from the nested structure flattening it without using additional memory for storing the entire flattened structure. # Function Details Function 1: `flatten` - **Input**: A nested array `input_arr` consisting of integers, lists, tuples, or any mix thereof. - **Output**: A flat list containing all the elements of the original nested structure. - **Constraints**: - Do not use built-in Python flatten libraries. - Handle variable depth of nesting. Function 2: `flatten_iter` - **Input**: A nested iterable `iterable` (e.g., lists, tuples). - **Output**: An iterator (generator) yielding elements from the nested structure in flattened form. - **Constraints**: - Do not consume excessive memory by storing the entire flattened structure. # Example ```python # Example 1: input_arr = [1, [2, [3, 4], 5], 6] output_arr = flatten(input_arr) print(output_arr) # Output: [1, 2, 3, 4, 5, 6] # Example 2: iterable = [1, [2, [3, [4, 5]], 6]] output_iter = flatten_iter(iterable) print(list(output_iter)) # Output: [1, 2, 3, 4, 5, 6] ``` # Performance Requirements - Aim for O(n) time complexity where n is the number of elements including all nesting levels. - Ensure space complexity is managed efficiently, especially for the generator implementation. # Additional Notes - Consider how your solution handles strings, which are iterables but should not be expanded. - Aim for clarity and efficiency in your recursive or iterative approach. - Include error handling for unexpected input types.","solution":"from typing import List, Iterable, Iterator, Union def flatten(input_arr: Union[list, tuple]) -> list: Flattens a nested array into a single-level array. flat_list = [] for item in input_arr: if isinstance(item, (list, tuple)): flat_list.extend(flatten(item)) else: flat_list.append(item) return flat_list def flatten_iter(iterable: Iterable) -> Iterator: Flattens a nested iterable using a generator. for item in iterable: if isinstance(item, (list, tuple)): yield from flatten_iter(item) else: yield item"},{"question":"# Binary Search Implementation Challenge Description: You are tasked with implementing a binary search algorithm to locate a target element within a sorted array of integers. Ensure that you handle both the iterative and recursive approaches. You should also take care of edge cases and provide a solution that is efficient in terms of time complexity. Function Specifications: * **Function 1**: binary_search_iterative(array, target) * **Input**: A list of integers `array`, sorted in ascending order, and an integer `target` which is the value to be searched. * **Output**: The index of the target element in the array if it is present; otherwise, return -1. * **Function 2**: binary_search_recursive(array, target, low, high) * **Input**: A list of integers `array`, sorted in ascending order, an integer `target` which is the value to be searched, integers `low` and `high` which are the starting and ending indices of the array or subarray. * **Output**: The index of the target element in the array if it is present; otherwise, return -1. Constraints: - All elements in the array are unique. - The array length will not exceed 10^6. - The target element can be any integer (both negative and positive). Examples: 1. Example 1 (Iterative): ```python array = [1, 3, 5, 7, 9, 11] target = 5 binary_search_iterative(array, target) -> 2 ``` 2. Example 2 (Recursive): ```python array = [1, 2, 3, 4, 5, 6] target = 4 low = 0 high = 5 binary_search_recursive(array, target, low, high) -> 3 ``` 3. Example 3 (Element not found): ```python array = [10, 20, 30, 40, 50] target = 25 binary_search_iterative(array, target) -> -1 binary_search_recursive(array, target, 0, len(array) - 1) -> -1 ``` Guidelines: - Make sure that your recursive solution does not exceed maximum recursion depth. - Check for edge conditions such as empty arrays and single-element arrays. - Aim to write concise and optimized code. Submission: Implement both functions in the language of your choice and test them with the given examples and additional test cases created by you.","solution":"def binary_search_iterative(array, target): Perform a binary search using iterative approach. :param array: List[int] - Sorted list of integers :param target: int - Target integer to find :return: int - Index of the target in array or -1 if not found low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: low = mid + 1 else: high = mid - 1 return -1 def binary_search_recursive(array, target, low, high): Perform a binary search using recursive approach. :param array: List[int] - Sorted list of integers :param target: int - Target integer to find :param low: int - Starting index of the current subarray :param high: int - Ending index of the current subarray :return: int - Index of the target in array or -1 if not found if low > high: return -1 mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: return binary_search_recursive(array, target, mid + 1, high) else: return binary_search_recursive(array, target, low, mid - 1)"},{"question":"# Scenario You are tasked with maintaining a playlist of songs stored in a singly linked list. Sometimes users want to remove multiple songs at once based on their indices in the playlist. You need to implement a function that can efficiently remove a range of songs from the playlist. # Task Write a function `remove_range(head, start, end)` that takes the head of a singly linked list and two integers, `start` and `end`. This function should remove all elements from the start index to the end index inclusive. # Input - `head`: The head node of the singly linked list. - `start`: Integer representing the starting index (0-based). - `end`: Integer representing the ending index (inclusive, 0-based). # Output - The head of the modified linked list or `None` if the list becomes empty. # Constraints - The linked list contains at least one element. - `0 <= start <= end < size of linked list`. # Example For a playlist represented by the linked list: [8, 13, 17, 4, 9, 12, 98, 41, 7, 23, 0, 92] Calling the function as `remove_range(head, 3, 8)` should modify the list to: [8, 13, 17, 23, 0, 92] # Notes - Handle the edge case where the start index is 0. - Ensure you manage the next pointers correctly to avoid memory leaks or logical errors. - Write the function without using extra space other than temporary variables for node traversal.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_range(head, start, end): if start == 0: current = head for _ in range(end + 1): if current is not None: current = current.next return current current = head for _ in range(start - 1): if current is not None: current = current.next if current and current.next: temp = current.next for _ in range(end - start + 1): if temp is not None: temp = temp.next current.next = temp return head"},{"question":"**Question**: Implement a sorting function using the Stooge Sort algorithm and analyze its performance compared to more efficient algorithms like QuickSort. **Scenario**: You are tasked to implement the Stooge Sort algorithm to sort an array of integers. Your implementation should be recursive and follow the steps described in the algorithm. Additionally, you need to compare its performance with the QuickSort algorithm by conducting performance tests on various sizes of random arrays and then reporting your findings. **Function Signature**: ```python def stooge_sort(arr: List[int]) -> List[int]: ``` **Input and Output**: - Input: A list of integers (e.g., `[4, 2, 7, 1, 9, 3]`) - Output: A sorted list of integers (e.g., `[1, 2, 3, 4, 7, 9]`) **Constraints**: - You must implement the Stooge Sort recursively. - You cannot use built-in sort functions. - You need to handle empty arrays and arrays with one element. **Performance Requirements**: - Analyze and report the time complexity in both theory and practice by comparing the implementation with QuickSort with test cases on varying sizes (e.g., 100, 1000, 5000, 10000 elements). - Provide your insights on when (if ever) Stooge Sort might be practical. **Example**: ```python # Your function def stooge_sort(arr: List[int]) -> List[int]: def stooge_recursive(arr, l, h): if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stooge_recursive(arr, l, h - t) stooge_recursive(arr, l + t, h) stooge_recursive(arr, l, h - t) if not arr: return [] res = arr[:] stooge_recursive(res, 0, len(res) - 1) return res # Test input_data = [4, 2, 7, 1, 9, 3] print(stooge_sort(input_data)) # Output should be [1, 2, 3, 4, 7, 9] ``` After implementing and testing the above function, you should perform a performance comparison with QuickSort on various array sizes and provide your analysis of the results.","solution":"def stooge_sort(arr: list[int]) -> list[int]: def stooge_recursive(arr, l, h): if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stooge_recursive(arr, l, h - t) stooge_recursive(arr, l + t, h) stooge_recursive(arr, l, h - t) if not arr: return [] res = arr[:] stooge_recursive(res, 0, len(res) - 1) return res"},{"question":"You are given a string of words, where words are separated by spaces. Your task is to reverse the order of words in the string. Words consist of only alphabetic characters and are separated by a single space. # Function Signature ```python def reverse_words_in_string(s: str) -> str: ``` # Input * `s` (str): A string containing words separated by spaces (1 <= len(s) <= 10^5). # Output * (str): A string with the words reversed. # Constraints * The input string will contain only alphabetic characters and spaces. * There will be no trailing or leading spaces and no multiple spaces between words. # Example ```python s = \\"hello world\\" assert reverse_words_in_string(s) == \\"world hello\\" s = \\"data structures and algorithms\\" assert reverse_words_in_string(s) == \\"algorithms and structures data\\" ``` # Explanation 1. For the input `\\"hello world\\"`, the words are reversed to form `\\"world hello\\"`. 2. For the input `\\"data structures and algorithms\\"`, the words are reversed to form `\\"algorithms and structures data\\"`. # Notes * Consider edge cases like a single word or an empty string. * You will need to write a helper function to reverse elements within the array.","solution":"def reverse_words_in_string(s: str) -> str: Reverses the order of words in the string s. Args: s (str): A string containing words separated by spaces. Returns: str: A string with the words in reversed order. # Split the string into a list of words words = s.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list back into a string with spaces return \' \'.join(reversed_words)"},{"question":"Implement an Optimized Random Sorting Algorithm Context Bogo Sort is a humorous yet impractical sorting algorithm that works by randomly shuffling an array until it is sorted. You are tasked with creating a more practical version of a similarly random-based sorting algorithm, called **Improved Randomized Sort**, which employs randomization but is more efficient and uses the concept of divide and conquer to sort an array. Task Write a function `improved_random_sort(arr: List[int]) -> List[int]:` that takes a list of integers and returns the sorted list using an improved randomized algorithm. The core idea should still incorporate randomness for sorting, but it should aim to reduce the number of random permutations significantly compared to Bogo Sort. Expected Input and Output * **Input**: A list of integers `arr`. * **Output**: A sorted list with the same integers in ascending order. Example ```python >>> arr = [3, 1, 4, 1, 5, 9, 2] >>> improved_random_sort(arr) [1, 1, 2, 3, 4, 5, 9] ``` Constraints * Do not use existing sort functions (like `sorted` from Python\'s standard library). * Aim to dramatically reduce the average-case time complexity compared to Bogo Sort. * Handle edge cases such as empty lists, lists with one element, and lists with duplicate elements. * The function should be efficient enough to handle moderately sized lists (up to 100 elements) without excessively long run times. Hints 1. Consider using a random element as a pivot and splitting/merging the array around it. 2. Ensure recursive or iterative good performance with decrease-and-conquer strategies.","solution":"import random def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def randomized_partition(arr, low, high): random_index = random.randint(low, high) arr[random_index], arr[high] = arr[high], arr[random_index] return partition(arr, low, high) def randomized_quick_sort(arr, low, high): if low < high: pi = randomized_partition(arr, low, high) randomized_quick_sort(arr, low, pi - 1) randomized_quick_sort(arr, pi + 1, high) def improved_random_sort(arr): Sorts an array using an improved randomized sorting algorithm. if not arr or len(arr) == 1: return arr randomized_quick_sort(arr, 0, len(arr) - 1) return arr"},{"question":"# Missing Number Finder Given an array of unique integers `nums` in the range` [0..n]`, return the missing number in the sequence. The difference between consecutive integers cannot be more than 1. If the sequence is already complete, the function should return the next integer in the sequence. Requirements: - Implement two functions `find_missing_number(nums)` and `find_missing_number2(nums)` using the XOR method and the Summation method respectively. - Both functions should have a time complexity of O(n). - Both functions should have a space complexity of O(1). Input: - An array of unique integers `nums` of length n where `0 <= nums.length <= 10^5`. Output: - An integer representing the missing number in the sequence or the next integer in the sequence if it is complete. Examples: 1. Input: `nums = [4, 1, 3, 0, 6, 5, 2]` Output: `7` 2. Input: `nums = [0, 1, 3]` Output: `2` Constraints: - You cannot use additional data structures. - The array may be unsorted. # Function Signatures ```python def find_missing_number(nums): # Implement the XOR method here def find_missing_number2(nums): # Implement the Summation method here ```","solution":"def find_missing_number(nums): Finds the missing number in the sequence using the XOR method. n = len(nums) xor_sum = n # Start with n because the missing number could be n for i in range(n): xor_sum ^= i xor_sum ^= nums[i] return xor_sum def find_missing_number2(nums): Finds the missing number in the sequence using the Summation method. n = len(nums) total_sum = n * (n + 1) // 2 # Sum of the first n natural numbers array_sum = sum(nums) return total_sum - array_sum"},{"question":"# Binary Heap Operations You are given a class structure `BinaryHeap` to implement a min heap, where the smallest element is always at the root of the tree. Your task is to implement the `insert` and `remove_min` methods for this class, ensuring that the heap properties are always maintained. Class Structure Overview: - `perc_up(i)`: This helper function ensures the element at index `i` is moved up the tree to restore the min heap property. - `insert(val)`: This method inserts a new value into the heap, maintaining the heap property. - `min_child(i)`: This helper function returns the index of the smaller child of the element at index `i`. - `perc_down(i)`: This helper function ensures the element at index `i` is moved down the tree to restore the min heap property. - `remove_min()`: This method removes the minimum element (the root), reorders the heap, and maintains the heap property. # Requirements: 1. **Insert**: - Add the new value `val` to the heap, ensuring the min heap property is maintained. - Complexity: O(log N) 2. **Remove_Min**: - Remove the smallest element (the root) from the heap, ensuring the min heap property is maintained. - Complexity: O(log N) # Input Format: - `insert(val)`: Integer `val`, the value to be added to the heap. - `remove_min()`: No input arguments. Returns the smallest element in the heap (an integer). # Output Format: - `insert(val)`: No output. - `remove_min()`: Return the smallest element in the heap. # Constraints: - All values inserted are integers. - Methods will be called in any valid order. # Example: ```python heap = BinaryHeap() heap.insert(4) heap.insert(50) heap.insert(7) print(heap.remove_min()) # Should output 4 heap.insert(2) print(heap.remove_min()) # Should output 2 print(heap.remove_min()) # Should output 7 ``` # Implementation: Implement the `insert` and `remove_min` methods in the `BinaryHeap` class: ```python class BinaryHeap(AbstractHeap): Binary Heap Class def __init__(self): self.current_size = 0 self.heap = [(0)] def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i//2] = self.heap[i//2], self.heap[i] i = i // 2 def insert(self, val): self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def min_child(self, i): if 2 * i + 1 > self.current_size: return 2 * i if self.heap[2 * i] > self.heap[2 * i + 1]: return 2 * i + 1 return 2 * i def perc_down(self, i): while 2 * i <= self.current_size: mc = self.min_child(i) if self.heap[i] > self.heap[mc]: self.heap[i], self.heap[mc] = self.heap[mc], self.heap[i] i = mc def remove_min(self): root = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() self.perc_down(1) return root ``` Make sure to handle all edge cases and maintain the min heap property throughout.","solution":"class BinaryHeap: Binary Heap Class def __init__(self): self.current_size = 0 self.heap = [0] def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i//2] = self.heap[i//2], self.heap[i] i = i // 2 def insert(self, val): self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def min_child(self, i): if 2 * i + 1 > self.current_size: return 2 * i if self.heap[2 * i] > self.heap[2 * i + 1]: return 2 * i + 1 return 2 * i def perc_down(self, i): while 2 * i <= self.current_size: mc = self.min_child(i) if self.heap[i] > self.heap[mc]: self.heap[i], self.heap[mc] = self.heap[mc], self.heap[i] i = mc def remove_min(self): if self.current_size == 0: return None root = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() if self.current_size > 0: self.perc_down(1) return root"},{"question":"**Problem Description**: You are tasked with finding a set of unique numbers within a given range where each number has the special property: the sum of its digits each raised to consecutive powers yields the number itself. For instance, 89 has this property since `8**1 + 9**2 = 89`. Write a function `special_sum_property_numbers(low, high)` that returns a list of such numbers within the range [low, high] (inclusive). # Function Signature ```python def special_sum_property_numbers(low: int, high: int) -> List[int]: # Your implementation here ``` # Input - Two integers `low` and `high` such that `1 <= low <= high <= 1000`. # Output - A list of integers that possess the special property within the given range. The list should be sorted in increasing order. # Constraints - Ensure your solution optimally handles large ranges close to the upper constraint (e.g., low = 1, high = 1000). - Avoid using advanced libraries for manipulating sequences; rely on basic operations and data structures. # Example Usage ```python assert special_sum_property_numbers(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert special_sum_property_numbers(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert special_sum_property_numbers(80, 150) == [89, 135] ``` **Scenario Context**: Imagine you are exploring properties of numbers for a mathematical research paper and want to list out all numbers between 1 and 1000 that meet this interesting criterion. This function would allow you to identify such numbers in any given range efficiently.","solution":"from typing import List def special_sum_property_numbers(low: int, high: int) -> List[int]: def has_special_property(n: int) -> bool: digits = list(map(int, str(n))) sum_of_powers = sum(digit ** (index + 1) for index, digit in enumerate(digits)) return sum_of_powers == n result = [] for number in range(low, high + 1): if has_special_property(number): result.append(number) return result"},{"question":"# Scenario You are developing a software for combinatorial calculations for a mathematical research institute. One of the core functionalities required is to compute binomial coefficients efficiently as the results are frequently used in various probability calculations and combinatorial problems. # Your Task Write a Python function `binomial_coefficient(n: int, k: int) -> int` to compute the binomial coefficient using an iterative approach to avoid recursion depth limitations and enhance efficiency. # Input * `n`: A positive integer, representing the total number of items. * `k`: A non-negative integer, representing the number of items to choose. # Output * Returns an integer representing the binomial coefficient (C(n, k)), the number of ways to choose `k` items from `n` items. # Constraints * (0 leq k leq n leq 10^6) # Example 1. `binomial_coefficient(5, 0)` should return `1` 2. `binomial_coefficient(8, 2)` should return `28` 3. `binomial_coefficient(500, 300)` should return a very large integer as the result of this binomial coefficient. # Requirements * Your solution must be optimized to handle large values as specified in the constraints. * Avoid using recursion to prevent stack overflow issues with large inputs.","solution":"def binomial_coefficient(n: int, k: int) -> int: Calculate the binomial coefficient C(n, k) using an iterative approach. # Handle the edge cases if k < 0 or k > n: return 0 if k == 0 or k == n: return 1 # Take advantage of symmetry property C(n, k) == C(n, n - k) if k > n - k: k = n - k result = 1 for i in range(k): result *= (n - i) result //= (i + 1) return result"},{"question":"# Question: Advanced Palindrome Checker Implement a Python function that checks if a given string is a palindrome, considering only alphanumeric characters and ignoring case. Additionally, the function should address the following requirements: 1. Handle mixed case and punctuation by normalizing the string to lowercase and removing non-alphanumeric characters. 2. Allow for different algorithmic approaches specified as an argument to the function, such as using a two-pointer technique, a stack, or reversing the string. 3. Ensure the function handles edge cases gracefully, such as empty strings, single characters, and strings with only punctuation. Your task is to implement the `check_palindrome` function which encapsulates the different variations of palindrome checking and performs operations based on the chosen method. **Function Signature**: ```python def check_palindrome(s: str, method: str = \\"two_pointer\\") -> bool: ``` **Parameters**: - `s` (str): The input string which may contain any characters. - `method` (str, optional): The method to be used for checking the palindrome. It can be \\"two_pointer\\", \\"reverse\\", \\"stack\\", or \\"deque\\". Default is \\"two_pointer\\". **Returns**: - `bool`: `True` if the input string is a palindrome considering only alphanumeric characters and ignoring case; otherwise, `False`. **Constraints**: - The string length `n` will be in the range [0, 10^5]. **Examples**: ```python check_palindrome(\\"A man, a plan, a canal: Panama\\", \\"two_pointer\\") # Output: True check_palindrome(\\"race a car\\", \\"reverse\\") # Output: False check_palindrome(\\"\\", \\"stack\\") # Output: True check_palindrome(\\" \\", \\"deque\\") # Output: True check_palindrome(\\"Able was I, I saw eLba\\", \\"stack\\") # Output: True ``` **Note**: - You must handle different methods by delegating to appropriate helper functions (`check_palindrome_two_pointer`, `check_palindrome_reverse`, `check_palindrome_stack`, `check_palindrome_deque`). **Implementation Tips**: - Write a helper function to remove punctuation and normalize the string. - Implement separate functions for each method and dispatch to these functions from `check_palindrome` based on the `method` argument.","solution":"import re from collections import deque def normalize_string(s): return re.sub(r\'[^a-zA-Z0-9]\', \'\', s).lower() def check_palindrome_two_pointer(s): normalized = normalize_string(s) left, right = 0, len(normalized) - 1 while left < right: if normalized[left] != normalized[right]: return False left += 1 right -= 1 return True def check_palindrome_reverse(s): normalized = normalize_string(s) return normalized == normalized[::-1] def check_palindrome_stack(s): normalized = normalize_string(s) stack = list(normalized) for char in normalized: if char != stack.pop(): return False return True def check_palindrome_deque(s): normalized = normalize_string(s) d = deque(normalized) while len(d) > 1: if d.popleft() != d.pop(): return False return True def check_palindrome(s: str, method: str = \\"two_pointer\\") -> bool: if method == \\"two_pointer\\": return check_palindrome_two_pointer(s) elif method == \\"reverse\\": return check_palindrome_reverse(s) elif method == \\"stack\\": return check_palindrome_stack(s) elif method == \\"deque\\": return check_palindrome_deque(s) else: raise ValueError(\\"Invalid method. Choose from \'two_pointer\', \'reverse\', \'stack\', or \'deque\'.\\")"},{"question":"Consider a scenario where you need to create a filtering system for a sensor\'s output. The sensor outputs an array of temperature readings in degrees Celsius. Your task is to filter out the readings that fall outside a specified range to focus on significant data. **Function Specification**: - **Function Name**: `filter_temperatures` - **Parameters**: * A list of integers `readings`: This list contains temperature readings from a sensor. * An integer `min_temp` (default to `None`): The minimum bound for valid temperature readings. * An integer `max_temp` (default to `None`): The maximum bound for valid temperature readings. - **Returns**: A list of integers filtered to only include readings within the specified range `[min_temp, max_temp]`, inclusive. If `min_temp` or `max_temp` is `None`, it should not impose that boundary. **Constraints**: 1. The length of the array `readings` can be between `0` to `10^6`. 2. Temperature values in `readings` can range from `-100°C` to `100°C`. 3. `min_temp` and `max_temp` if provided, will be within the valid range of temperature values. **Edge Cases**: 1. The array could be empty. 2. All values in the array might fall completely outside the specified range. 3. Both `min_temp` and `max_temp` might be `None`. **Example Usage**: ```python assert filter_temperatures([34, 12, -5, 16, 27, 3], min_temp=10, max_temp=30) == [12, 16, 27] assert filter_temperatures([34, 12, -5, 16, 27, 3], max_temp=10) == [-5, 3] assert filter_temperatures([34, 12, -5, 16, 27, 3], min_temp=30) == [34] assert filter_temperatures([], min_temp=10, max_temp=30) == [] assert filter_temperatures([34, 12, -5, 16, 27, 3]) == [34, 12, -5, 16, 27, 3] ``` Implement the function `filter_temperatures` considering the above specification and constraints.","solution":"def filter_temperatures(readings, min_temp=None, max_temp=None): Filters the temperature readings to only include the ones within the specified range. :param readings: List of temperature readings (integers). :param min_temp: Minimum temperature bound (inclusive). Default is None. :param max_temp: Maximum temperature bound (inclusive). Default is None. :return: List of filtered temperature readings. filtered_readings = [] for reading in readings: if (min_temp is None or reading >= min_temp) and (max_temp is None or reading <= max_temp): filtered_readings.append(reading) return filtered_readings"},{"question":"<|Analysis Begin|> # Algorithm/Data Structure Identification * **Algorithm**: Pattern Matching * **Type**: Hash Table based mapping * **Purpose**: The given algorithm checks if a string `str` follows a specified pattern `pattern`. This means each character in the pattern should map uniquely to a word in the string, forming a bijection. # Complexity * **Time Complexity**: (O(n)) - where (n) is the number of characters in the pattern or words in the string. * **Space Complexity**: (O(n)) - due to the use of dictionary and set for mappings and uniqueness checks. # Principles 1. **Initialization**: Create a dictionary to map patterns to words and a set to track unique words. 2. **Splitting**: Split `str` into words while checking if the length matches the pattern length. 3. **Mapping**: Iterate through the pattern and string simultaneously: - Check if the character from the pattern is in the dictionary. - If not in the dictionary, map it and check for any clashes. - If in the dictionary, ensure the mapping is consistent. 4. **Validation**: Return `True` if all conditions hold, otherwise `False`. # Characteristics & Applications * **Properties**: - Bijection (one-to-one correspondence) between pattern and string words. - Non-empty word mapping. * **Common Use Cases**: - Syntax validation in compilers. - Matching commands to defined symbolic representations in computing. * **Strengths/Limitations**: - **Strengths**: - Efficient time complexity due to single-pass checks. - Simple logic for validation using hashing. - **Limitations**: - Assumes well-formed input without illegal characters or empty words. - Mapping uniqueness strictly enforced, can’t allow flexible pattern compliance. # Implementation Challenges * **Edge Cases**: - Different lengths of pattern and words in the string. - Multiple characters of the pattern mapping to the same word in the string. * **Performance Bottlenecks**: - Overloaded hash table operations when handling unusually large patterns/strings. * **Error Scenarios**: - Pattern character not being properly mapped leading to inaccurate results. - Overlapping mappings ignored due to set conditions. * **Optimization Points**: - Potentially simplifying check conditions or optimizing dictionary/set usage. <|Analysis End|> <|Question Begin|> # Problem Statement You are given a pattern and a string. Your task is to determine if the string follows the same pattern, which means that there must be a bijection between a letter in the pattern and a non-empty word in the string. # Function Signature ```python def word_pattern(pattern: str, string: str) -> bool: ``` # Input - `pattern`: a string containing only lowercase letters. - `string`: a string containing lowercase words separated by single spaces. # Output - Returns `True` if the provided string follows the specified pattern, otherwise returns `False`. # Constraints - You can assume the pattern contains only lowercase letters. - Words in the string are separated by a single space. - Length of `pattern` is between 1 and 10^4. - Length of `string` doesn\'t exceed 10^4. # Examples 1. **Input**: pattern = \\"abba\\", string = \\"dog cat cat dog\\" **Output**: `True` 2. **Input**: pattern = \\"abba\\", string = \\"dog cat cat fish\\" **Output**: `False` 3. **Input**: pattern = \\"aaaa\\", string = \\"dog cat cat dog\\" **Output**: `False` 4. **Input**: pattern = \\"abba\\", string = \\"dog dog dog dog\\" **Output**: `False` # Notes 1. Consider edge cases where pattern and string length do not match. 2. Ensure a one-to-one mapping between each character in the pattern and a word in the string. |Question End|","solution":"def word_pattern(pattern: str, string: str) -> bool: words = string.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False if word in word_to_char: if word_to_char[word] != char: return False char_to_word[char] = word word_to_char[word] = char return True"},{"question":"# Coding Challenge: Implement a Custom Bubble Sort Context You are required to implement a custom version of the Bubble Sort algorithm with additional improvements. Your task is to enhance the robustness and performance of the traditional Bubble Sort algorithm. Objective Write a function that sorts an array of integers in ascending order using an optimized version of the Bubble Sort algorithm. Additionally, you are required to handle potential edge cases and ensure the function is efficient. Task Implement the function `optimized_bubble_sort(arr: List[int]) -> List[int]`, where: - `arr` is a list of integers that needs to be sorted. # Requirements 1. **Output**: * Return the sorted array in ascending order. 2. **Constraints**: * The function should handle empty arrays and arrays with a single element. * The function should be efficient, avoiding unnecessary iterations and swaps. 3. **Performance**: * Use an optimization to detect if the array is already sorted and terminate early if applicable. 4. **Edge Cases**: * Include checks for arrays with duplicate values and arrays that are in reverse order. * Your function should perform well for these scenarios. Example ```python Example Input: [64, 34, 25, 12, 22, 11, 90] Example Output: [11, 12, 22, 25, 34, 64, 90] Example Input: [5, 1, 4, 2, 8] Example Output: [1, 2, 4, 5, 8] Example Input: [1, 2, 3, 4, 5] Example Output: [1, 2, 3, 4, 5] # Already sorted array should not undergo unnecessary swaps. ``` Additional Notes * Utilize the bubble sort principle but incorporate early termination optimization. * Ensure that the function returns correct output for all edge cases provided. Good luck, and happy coding!","solution":"from typing import List def optimized_bubble_sort(arr: List[int]) -> List[int]: n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if not swapped: break return arr"},{"question":"Implementing and Enhancing Diffie-Hellman Key Exchange The goal of this question is to verify your understanding of the Diffie-Hellman key exchange process and associated number-theoretic functions. You will implement an enhanced Diffie-Hellman key exchange algorithm incorporating optimized versions of prime checking, and primitive root finding functions. Your implementation should be efficient and handle various edge cases. Part 1: Prime Checking Implement an optimized version of the `prime_check` function that handles large numbers efficiently. **Function Signature**: ```python def optimized_prime_check(num: int) -> bool: ``` **Input**: * `num` (int): The integer to check for primality (1 <= num <= 10^12). **Output**: * `bool`: `True` if `num` is a prime number, `False` otherwise. **Constraints**: * Ensure your implementation can handle edge cases like 1, small primes, and very large numbers up to 10^12. Part 2: Primitive Root Finding Implement the `find_primitive_root` function that efficiently finds all primitive roots of `n` using an optimized approach. **Function Signature**: ```python def optimized_find_primitive_root(n: int) -> list: ``` **Input**: * `n` (int): The integer for which to find primitive roots (1 <= n <= 10^6). **Output**: * `list`: A list of all primitive roots of `n`. **Constraints**: * Your implementation should be efficient and able to handle the upper limit of the input size. Part 3: Enhanced Diffie-Hellman Key Exchange Using your optimized functions, implement the `enhanced_diffie_hellman_key_exchange` function that performs the Diffie-Hellman key exchange and verifies the shared key. **Function Signature**: ```python def enhanced_diffie_hellman_key_exchange(a: int, p: int, option: Optional[int] = None) -> bool: ``` **Input**: * `a` (int): The primitive root modulo `p`. * `p` (int): A large prime number. * `option` (Optional[int]): If provided, should print the details of the key exchange process. **Output**: * `bool`: `True` if the shared keys match, `False` otherwise. **Constraints**: * Ensure the function handles edge cases like non-prime `p` or incorrect primitive roots. * Print informative error messages for invalid inputs. # Example Usage ```python assert optimized_prime_check(11) is True assert optimized_prime_check(4) is False assert optimized_find_primitive_root(7) == [3, 5] assert optimized_find_primitive_root(1) == [0] assert enhanced_diffie_hellman_key_exchange(3, 23, option=1) is True assert enhanced_diffie_hellman_key_exchange(2, 23) is False ``` **Notes**: * Focus on implementing efficient and correct solutions for each part. * Ensure your code is well-documented and follows best practices. * Function performance and edge case handling will be crucial evaluation criteria.","solution":"import math from typing import List, Optional def optimized_prime_check(num: int) -> bool: Efficiently checks if a number is prime. :param num: An integer to check for primality (1 <= num <= 10^12). :return: True if `num` is a prime number, False otherwise. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def optimized_find_primitive_root(n: int) -> List[int]: Finds all primitive roots of n. :param n: An integer for which to find primitive roots (1 <= n <= 10^6). :return: A list of all primitive roots of `n`. if n == 1: return [0] # Check if n is prime def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True if not is_prime(n): return [] phi = n - 1 factors = [] for i in range(2, int(math.sqrt(phi)) + 1): if phi % i == 0: factors.append(i) while phi % i == 0: phi //= i if phi > 1: factors.append(phi) def is_primitive_root(x): for factor in factors: if pow(x, (n - 1) // factor, n) == 1: return False return True primitive_roots = [] for i in range(2, n): if is_primitive_root(i): primitive_roots.append(i) return primitive_roots def enhanced_diffie_hellman_key_exchange(a: int, p: int, option: Optional[int] = None) -> bool: Performs the Diffie-Hellman key exchange and verifies the shared key. :param a: The primitive root modulo p. :param p: A large prime number. :param option: If provided, should print the details of the key exchange process. :return: True if the shared keys match, False otherwise. if not optimized_prime_check(p): if option is not None: print(f\\"Error: {p} is not a prime number.\\") return False if a not in optimized_find_primitive_root(p): if option is not None: print(f\\"Error: {a} is not a primitive root of {p}.\\") return False A_private = 4 # Example private number for Alice B_private = 3 # Example private number for Bob A_public = pow(a, A_private, p) B_public = pow(a, B_private, p) shared_key_Alice = pow(B_public, A_private, p) shared_key_Bob = pow(A_public, B_private, p) if option is not None: print(f\\"Alice\'s public key: {A_public}\\") print(f\\"Bob\'s public key: {B_public}\\") print(f\\"Alice\'s computed shared key: {shared_key_Alice}\\") print(f\\"Bob\'s computed shared key: {shared_key_Bob}\\") return shared_key_Alice == shared_key_Bob"},{"question":"# Question: Implement a Doubly Linked List for Task Tracking You are tasked with implementing a `DoublyLinkedList` class that will be used to maintain a to-do list, where tasks can be added, traversed, and removed efficiently. This list should support bidirectional navigation to allow users to easily navigate through their tasks. Class Specification Implement the following methods for the `DoublyLinkedList` class: 1. **`add_task(value: str) -> None`**: - Adds a new task with the specified value to the end of the list. 2. **`remove_task(value: str) -> bool`**: - Removes the first occurrence of a task with the specified value from the list. - Returns `True` if the task was found and removed, `False` otherwise. 3. **`traverse_forward() -> list`**: - Returns a list of all tasks from head to tail. 4. **`traverse_backward() -> list`**: - Returns a list of all tasks from tail to head. 5. **`get_task(index: int) -> str`**: - Returns the value of the task at the specified index. - Raises an `IndexError` if the index is out of bounds. Constraints - The list should handle a variable number of tasks efficiently. - Maximum number of tasks is 1000. - You cannot use Python\'s built-in list methods except for traversals and simple operations like assignment. ```python class DoublyLinkedList: class Node: def __init__(self, value): self.value = value self.next = None self.prev = None def __init__(self): self.head = None self.tail = None def add_task(self, value: str) -> None: pass def remove_task(self, value: str) -> bool: pass def traverse_forward(self) -> list: pass def traverse_backward(self) -> list: pass def get_task(self, index: int) -> str: pass ``` Example: ```python # Example usage: tasks = DoublyLinkedList() tasks.add_task(\\"Task 1\\") tasks.add_task(\\"Task 2\\") print(tasks.traverse_forward()) # Output: [\\"Task 1\\", \\"Task 2\\"] print(tasks.traverse_backward()) # Output: [\\"Task 2\\", \\"Task 1\\"] tasks.add_task(\\"Task 3\\") print(tasks.get_task(1)) # Output: \\"Task 2\\" tasks.remove_task(\\"Task 2\\") print(tasks.traverse_forward()) # Output: [\\"Task 1\\", \\"Task 3\\"] ``` Implement the `DoublyLinkedList` class to handle these requirements and constraints.","solution":"class DoublyLinkedList: class Node: def __init__(self, value): self.value = value self.next = None self.prev = None def __init__(self): self.head = None self.tail = None def add_task(self, value: str) -> None: new_node = self.Node(value) if not self.head: self.head = self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def remove_task(self, value: str) -> bool: current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next if current.next: current.next.prev = current.prev if current == self.head: self.head = current.next if current == self.tail: self.tail = current.prev return True current = current.next return False def traverse_forward(self) -> list: result = [] current = self.head while current: result.append(current.value) current = current.next return result def traverse_backward(self) -> list: result = [] current = self.tail while current: result.append(current.value) current = current.prev return result def get_task(self, index: int) -> str: current = self.head for i in range(index): if not current: raise IndexError(\\"Index out of bounds\\") current = current.next if not current: raise IndexError(\\"Index out of bounds\\") return current.value"},{"question":"<|Analysis Begin|> # Core Identification * **Algorithm/Data Structure**: This is an algorithm to find the Lowest Common Ancestor (LCA) in a binary tree. * **Type**: Tree traversal algorithm. * **Main Purpose**: To determine the closest shared ancestor of two nodes in a binary tree. # Complexity * **Time Complexity**: O(N), where N is the number of nodes in the tree—each node is visited once. * **Space Complexity**: O(H), where H is the height of the tree—accounting for the recursion stack space. # Principles * **Operational Steps**: 1. If the current node is `None`, return `None`. 2. If the current node is either `p` or `q`, return the current node. 3. Recursively traverse the left and right subtrees to find the LCA. 4. If both left and right recursive calls return non-`None` values, the current node is the LCA. 5. Otherwise, return the non-`None` result from the recursive calls. # Characteristics & Applications * **Properties**: * Utilizes depth-first search (DFS) through recursion. * Ensures a node can be a descendant of itself. * **Common Use Cases**: * Situations involving hierarchical structures like family trees, organizational charts. * Network analysis where common nodes need to be determined. * **Strengths/Limitations**: * **Strengths**: Efficient with linear time complexity, simple and intuitive recursive solution. * **Limitations**: Uses recursion, which may lead to stack overflow for very deep trees. # Implementation Challenges * **Edge Cases**: * One or both nodes are not present in the tree. * The tree is highly unbalanced (degenerated to linked list). * **Performance Bottlenecks**: * The recursive nature might consume significant stack space. * **Error Scenarios**: * If the inputs are not valid nodes in the tree, the algorithm might not return correct results. * **Optimization Points**: * Use iterative methods to avoid recursion stack overflow. <|Analysis End|> <|Question Begin|> # Lowest Common Ancestor in a Binary Tree Problem Statement You are given a binary tree and two nodes within that tree. Your task is to write a function to identify the lowest common ancestor (LCA) of these two nodes. According to the definition: \\"The lowest common ancestor of two nodes `p` and `q` in a binary tree is the lowest (i.e., deepest) node that has both `p` and `q` as descendants (we allow a node to be a descendant of itself).\\" # Function Signature ```python def find_lowest_common_ancestor(root: \'TreeNode\', p: \'TreeNode\', q: \'TreeNode\') -> \'TreeNode\': pass ``` # Input * `root`: The root node of the binary tree of type `TreeNode`. * `p`: A node in the binary tree. * `q`: Another node in the binary tree. # Output * The function should return the node that is the LCA of `p` and `q`. # Constraints * All TreeNode values are unique. * `p` and `q` are different and will exist in the binary tree. # Example Example 1 ```python # Tree: # 3 # / # 5 1 # /| | # 6 2 0 8 # / # 7 4 # LCA of 5 and 1 find_lowest_common_ancestor(root, root.left, root.right) # should return 3 ``` Example 2 ```python # Tree: # 3 # / # 5 1 # /| | # 6 2 0 8 # / # 7 4 # LCA of 5 and 4 find_lowest_common_ancestor(root, root.left, root.left.right.right) # should return 5 ``` # Notes * Ensure the nodes `p` and `q` belong to the tree rooted at `root`. * Consider edge cases where `p` or `q` is the root node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_lowest_common_ancestor(root: \'TreeNode\', p: \'TreeNode\', q: \'TreeNode\') -> \'TreeNode\': if root is None or root == p or root == q: return root left = find_lowest_common_ancestor(root.left, p, q) right = find_lowest_common_ancestor(root.right, p, q) if left and right: return root return left if left else right"},{"question":"You are tasked with implementing the Selection Sort algorithm with an additional feature. Your implementation should sort an array of integers in ascending order. Additionally, it should have a \'simulation\' mode which prints the state of the array at each iteration step. # Input - An array `arr` of integers with maximum length `1000`. - A boolean `simulation` which indicates whether to print the array state at each iteration. # Output - Return the sorted array. - If `simulation` is True, print the array in its current state at the end of each iteration starting from 0. # Constraints - `arr[i]` is an integer in the range `-10^5` to `10^5`. # Example ```python # Example Call 1 selection_sort([64, 25, 12, 22, 11], simulation=False) # Output: [11, 12, 22, 25, 64] # Example Call 2 selection_sort([64, 25, 12, 22, 11], simulation=True) # Output: # iteration 0 : 64 25 12 22 11 # iteration 1 : 11 25 12 22 64 # iteration 2 : 11 12 25 22 64 # iteration 3 : 11 12 22 25 64 # iteration 4 : 11 12 22 25 64 # iteration 5 : 11 12 22 25 64 ``` # Implementation Implement the `selection_sort` function according to the description above and ensure it meets the performance requirements.","solution":"def selection_sort(arr, simulation=False): n = len(arr) for i in range(n): # Assume the minimum is the current element min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j # Swap the found minimum element with the first element arr[i], arr[min_idx] = arr[min_idx], arr[i] # Print the array state if simulation is True if simulation: print(f\\"iteration {i} : {\' \'.join(map(str, arr))}\\") return arr"},{"question":"You are tasked with implementing a function that determines whether two strings `s` and `t` are exactly one edit distance apart. An edit is defined as an insertion, deletion, or substitution of a single character. # Function Signature ```python def one_edit_apart(s: str, t: str) -> bool: ``` # Input - `s` and `t`: Two input strings (0 ≤ |s|,|t| ≤ 10⁴). # Output - Returns a boolean indicating whether the strings are one edit distance apart. # Constraints - You must ensure an optimal solution with a linear time complexity. # Examples 1. `one_edit_apart(\\"abc\\", \\"ab\\")` -> `True` 2. `one_edit_apart(\\"abc\\", \\"abcd\\")` -> `True` 3. `one_edit_apart(\\"abc\\", \\"abx\\")` -> `True` 4. `one_edit_apart(\\"abc\\", \\"abc\\")` -> `False` 5. `one_edit_apart(\\"abc\\", \\"abxy\\")` -> `False` # Scenario In a text editor application, you want to provide user feedback suggesting potential corrections for slight mistakes they might make while typing. To constrain the problem, assume that you only suggest corrections if the mistake is just one edit away from a correct word. As a lead developer, you need to write a function to determine whether two words are one edit distance apart. # Notes - Consider all possible one edit transformations: insert a character, delete a character, or substitute a character.","solution":"def one_edit_apart(s: str, t: str) -> bool: Determine if strings s and t are exactly one edit distance apart. An edit can be an insertion, deletion, or substitution of a single character. len_s, len_t = len(s), len(t) if abs(len_s - len_t) > 1: return False if len_s > len_t: # Ensure s is the shorter string. s, t = t, s len_s, len_t = len_t, len_s found_difference = False i, j = 0, 0 while i < len_s and j < len_t: if s[i] != t[j]: if found_difference: return False found_difference = True if len_s == len_t: i += 1 else: i += 1 j += 1 # If lengths are different, we could only edit the extra character at the end of the longer string. if i == len_s and j == len_t - 1: return True return found_difference or (len_s != len_t)"},{"question":"# Word Pattern Matching **Objective**: Write a function `word_pattern` that checks if a given string follows a specified pattern of letters. **Input Format**: - A string `pattern` containing only lowercase letters with length (1 leq text{len(pattern)} leq 100). - A string `str` containing lowercase words separated by single spaces with length (1 leq text{len(str)} leq 1000). **Output Format**: - Return `True` if the string `str` follows the pattern. - Return `False` otherwise. **Example**: ```python pattern = \\"abba\\" str = \\"dog cat cat dog\\" Output: True pattern = \\"abba\\" str = \\"dog cat cat fish\\" Output: False pattern = \\"aaaa\\" str = \\"dog cat cat dog\\" Output: False pattern = \\"abba\\" str = \\"dog dog dog dog\\" Output: False ``` **Constraints**: - You may assume `pattern` contains only lowercase letters. - You may assume `str` contains lowercase words separated by a single space. **Performance Requirements**: - The solution should have a time complexity of O(n) where n is the length of the input string `str`. **Task**: Implement the function `word_pattern(pattern, str)` to solve the problem.","solution":"def word_pattern(pattern, str): Check if str follows the pattern. :param pattern: A string containing only lowercase letters. :param str: A string containing lowercase words separated by single spaces. :return: True if str follows the pattern, else False. words = str.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: char_to_word[char] = word if word in word_to_char: if word_to_char[word] != char: return False else: word_to_char[word] = char return True"},{"question":"You are a software engineer at a company developing an advanced communications network system that requires detecting clusters of closely interconnected devices. Your task is to implement a function to find the number of Strongly Connected Components (SCCs) in a directed graph representing the network. Using Kosaraju’s algorithm, write a function `strongly_connected_components(V: int, edges: List[Tuple[int, int]]) -> int` that: - Takes an integer `V` representing the number of vertices (devices). - Takes a list of tuples `edges`, where each tuple `(u, v)` represents a directed edge from vertex `u` to vertex `v`. Your implementation should follow the steps of Kosaraju\'s algorithm to return the number of SCCs in the graph. **Constraints**: - `1 <= V <= 10^5` - `0 <= len(edges) <= 10^6` - Each vertex is a non-negative integer less than `V`. **Example**: ```python def strongly_connected_components(V: int, edges: List[Tuple[int, int]]) -> int: # Your implementation here # Test case V = 6 edges = [(0, 2), (1, 0), (2, 3), (3, 1), (3, 4), (4, 5), (5, 4)] print(strongly_connected_components(V, edges)) # Output: 2 ``` **Explanation**: The graph with the provided vertices and edges has 2 strongly connected components: 1. {0, 1, 2, 3} 2. {4, 5} **Hints**: 1. Use a stack to store the finishing times of vertices from the first DFS traversal. 2. Use adjacency lists to represent the graph and its transpose. 3. A vertex identified in the second DFS pass belongs to an SCC starting from that vertex.","solution":"from typing import List, Tuple def strongly_connected_components(V: int, edges: List[Tuple[int, int]]) -> int: def dfs(node, graph, visited, stack): visited[node] = True for neighbor in graph[node]: if not visited[neighbor]: dfs(neighbor, graph, visited, stack) stack.append(node) def reverse_graph(V, edges): reversed_graph = [[] for _ in range(V)] for u, v in edges: reversed_graph[v].append(u) return reversed_graph def fill_order(V, graph): visited = [False] * V stack = [] for i in range(V): if not visited[i]: dfs(i, graph, visited, stack) return stack def kosaraju(V, edges): graph = [[] for _ in range(V)] for u, v in edges: graph[u].append(v) stack = fill_order(V, graph) reversed_graph = reverse_graph(V, edges) visited = [False] * V num_sccs = 0 while stack: node = stack.pop() if not visited[node]: components_stack = [] dfs(node, reversed_graph, visited, components_stack) num_sccs += 1 return num_sccs return kosaraju(V, edges)"},{"question":"# Scenario Imagine you are a software developer working on a graphical user interface that presents various data structures. One of the features involves flipping a binary tree horizontally to provide a mirror image of the current structure. # Task Write a function to invert a given binary tree. # Function Signature ```python def invert_binary_tree(root: TreeNode) -> TreeNode: ``` # Input - `root`: The root node of a binary tree. Each node has two children, `left` and `right`. # Output - Returns the root node of the inverted binary tree. # Constraints - The number of nodes in the binary tree is in the range `[0, 100]`. - Node values are not relevant to the inversion process and should be preserved. # Example Given a binary tree: ``` 4 / 2 7 / / 1 3 6 9 ``` The function should return the root of the following inverted tree: ``` 4 / 7 2 / / 9 6 3 1 ``` # Notes - Carefully consider edge cases, such as when the tree is empty or contains only one node. - Aim for a solution that has optimal time and space complexity.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_binary_tree(root: TreeNode) -> TreeNode: if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the children nodes invert_binary_tree(root.left) invert_binary_tree(root.right) return root"},{"question":"# Question: Given a nested dictionary, implement a function `pretty_print_tree(tree: dict) -> None` that prints the elements in a structured manner. Each key at the top level should be printed on a new line followed by its associated values. Values that are lists will be indented, and strings directly followed by \'->\'. Additional nested dictionaries should start on a new line and be further indented. Input: - `tree`: A nested dictionary where keys are strings and values are lists containing strings, integers, and possibly other dictionaries. Output: - The function should print the tree structure as specified, without returning any value. Constraints: - The dictionary is arbitrarily nested but will not be deeper than three levels for simplicity. - You may assume the dictionary will always follow the structure outlined with lists being elements of the dictionary. # Example: ```python tree_structure = { \'a\': [\'Adam\', {\'Book\': 4}], \'b\': [\'Bill\', {\'Computer\': 5}, {\'TV\': 6}, \'Jill\', {\'Sports\': 1}], \'c\': [\'Bill\', {\'Sports\': 3}], \'d\': [\'Adam\', {\'Computer\': 3}, \'Quin\', {\'Computer\': 3}], \'e\': [\'Quin\', {\'Book\': 5}, {\'TV\': 2}], \'f\': [\'Adam\', {\'Computer\': 7}] } pretty_print_tree(tree_structure) ``` Expected Output: ``` a Adam Book -> 4 b Bill Computer -> 5 TV -> 6 Jill Sports -> 1 c Bill Sports -> 3 d Adam Computer -> 3 Quin Computer -> 3 e Quin Book -> 5 TV -> 2 f Adam Computer -> 7 ``` **Note**: Ensure that your solution efficiently handles the dictionary traversals and indentation as illustrated in the example.","solution":"def pretty_print_tree(tree): def print_dict(d, indent=0): for key, value in d.items(): if isinstance(value, list): for item in value: if isinstance(item, dict): print(\' \' * indent + f\\"{key} -> {item}\\") print_dict(item, indent + 4) else: print(\' \' * indent + f\\"{key} -> {item}\\") else: print(\' \' * indent + f\\"{key} -> {value}\\") for key, values in tree.items(): print(f\\"{key}\\") for value in values: if isinstance(value, dict): print_dict(value, 4) else: print(f\\" {value}\\")"},{"question":"**Scenario**: You\'re developing a stack-based editor that supports undo operations. To efficiently manage the edits, you need to implement a dynamic stack that can handle multiple operations while managing memory and ensuring performance. **Task**: Implement a `MinStack` class that extends the `ArrayStack` class to support an additional operation `get_min()` which returns the minimum element in the stack. The `get_min()` operation should have a constant time complexity. **Input/Output**: * The class will have the following methods: * `push(value: int) -> None`: Push the given value onto the stack. * `pop() -> int`: Remove and return the top element from the stack. * `peek() -> int`: Return the top element without removing it from the stack. * `is_empty() -> bool`: Check whether the stack is empty. * `get_min() -> int`: Return the minimum element in the stack. * `push()`, `pop()`, `peek()`, and `get_min()` methods will each be called independently and in any order. * Example: ```python # Initialize the stack min_stack = MinStack() # Push elements onto the stack min_stack.push(3) min_stack.push(5) print(min_stack.get_min()) # Output: 3 min_stack.push(2) min_stack.push(1) print(min_stack.get_min()) # Output: 1 min_stack.pop() print(min_stack.get_min()) # Output: 2 min_stack.pop() print(min_stack.peek()) # Output: 5 print(min_stack.get_min()) # Output: 3 ``` **Constraints**: * The stack will only contain integer values. * The `get_min()` should have a time complexity of O(1).","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, value: int) -> None: self.stack.append(value) if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self) -> int: if not self.stack: raise IndexError(\\"pop from empty stack\\") value = self.stack.pop() if value == self.min_stack[-1]: self.min_stack.pop() return value def peek(self) -> int: if not self.stack: raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def is_empty(self) -> bool: return len(self.stack) == 0 def get_min(self) -> int: if not self.min_stack: raise IndexError(\\"get_min from empty stack\\") return self.min_stack[-1]"},{"question":"**Problem Statement**: You are tasked with implementing an **Autocomplete System** using a Trie data structure. This system will be initialized with a list of words and will provide support for efficiently returning all words that have a given prefix. # Function Specifications Implement a class `AutocompleteSystem` with the following methods: 1. **Constructor**: Initialize the Trie data structure. 2. **insert(word: str)**: Inserts a word into the Trie. 3. **search(word: str) -> bool**: Returns `True` if the word is in the Trie, and `False` otherwise. 4. **starts_with(prefix: str) -> List[str]**: Returns a list of all words in the Trie that start with the given prefix. # Input Format - `word` (for insert and search) and `prefix` (for starts_with) will be non-empty strings of lowercase letters \'a\' to \'z\'. - The `word` in `insert` can be any valid English word from 1 to 100 characters long. - The `prefix` will have between 1 and 100 characters. - Multiple words can have the same prefix. # Output Format - The `starts_with` method returns all strings in lexicographical order that start with the given prefix. - If no such strings exist, return an empty list. Here is an initial structure for your implementation: ```python class TrieNode: def __init__(self): self.children = collections.defaultdict(TrieNode) self.is_word = False class AutocompleteSystem: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: # Your implementation here pass def search(self, word: str) -> bool: # Your implementation here pass def starts_with(self, prefix: str) -> List[str]: # Your implementation here pass # Example usage: # autocomplete = AutocompleteSystem() # autocomplete.insert(\\"apple\\") # autocomplete.insert(\\"app\\") # print(autocomplete.starts_with(\\"ap\\")) # Output: [\\"app\\", \\"apple\\"] # print(autocomplete.search(\\"apple\\")) # Output: True # print(autocomplete.search(\\"apply\\")) # Output: False ``` # Constraints - Ensure your implementation efficiently handles the space complexity. - Pay attention to edge cases such as inserting duplicate words, searching for words not in the Trie, and handling prefixes that match partially.","solution":"import collections from typing import List class TrieNode: def __init__(self): self.children = collections.defaultdict(TrieNode) self.is_word = False class AutocompleteSystem: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: node = node.children[char] node.is_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_word def starts_with(self, prefix: str) -> List[str]: node = self.root result = [] for char in prefix: if char not in node.children: return [] node = node.children[char] def dfs(current_node: TrieNode, path: str): if current_node.is_word: result.append(path) for (next_char, next_node) in current_node.children.items(): dfs(next_node, path + next_char) dfs(node, prefix) result.sort() return result"},{"question":"# Factorial Calculation with Enhanced Features In this task, you are required to implement a factorial calculation function with support for calculating results modulo `mod` if provided. You should handle both iterative and recursive implementations. Implement the following functions: 1. `factorial(n, mod=None)`: - **Input**: - An integer `n` (0 ≤ n ≤ 1000). - An optional integer `mod` (1 ≤ `mod` ≤ 10^9). - **Output**: The factorial of `n` (i.e., `n!`) or `n! % mod` if `mod` is provided. - If the input is not a non-negative integer or `mod` is not a positive integer, raise a `ValueError`. 2. `factorial_recur(n, mod=None)`: - **Input**: - An integer `n` (0 ≤ n ≤ 1000). - An optional integer `mod` (1 ≤ `mod` ≤ 10^9). - **Output**: The factorial of `n` (i.e., `n!`) or `n! % mod` if `mod` is provided. - If the input is not a non-negative integer or `mod` is not a positive integer, raise a `ValueError`. Your function should ensure efficient computation for the provided constraints and handle edge cases properly. **Constraints**: - `n` will be a non-negative integer not exceeding 1000. - `mod` will be a positive integer up to 10^9, if provided. **Function Signature**: ```python def factorial(n: int, mod: int = None) -> int: pass def factorial_recur(n: int, mod: int = None) -> int: pass ``` **Examples**: ```python factorial(5) # Output: 120 factorial(5, 3) # Output: 0 (because 120 % 3 = 0) factorial(0) # Output: 1 factorial_recur(5) # Output: 120 factorial_recur(5, 3) # Output: 0 (because 120 % 3 = 0) factorial_recur(0) # Output: 1 ``` Ensure your implementations are robust and efficient.","solution":"def factorial(n: int, mod: int = None) -> int: if not isinstance(n, int) or n < 0 or n > 1000: raise ValueError(\\"n must be a non-negative integer not exceeding 1000\\") if mod is not None and (not isinstance(mod, int) or mod <= 0): raise ValueError(\\"mod must be a positive integer if provided\\") result = 1 for i in range(1, n + 1): result *= i if mod: result %= mod return result def factorial_recur(n: int, mod: int = None) -> int: if not isinstance(n, int) or n < 0 or n > 1000: raise ValueError(\\"n must be a non-negative integer not exceeding 1000\\") if mod is not None and (not isinstance(mod, int) or mod <= 0): raise ValueError(\\"mod must be a positive integer if provided\\") if n == 0: return 1 if not mod: return n * factorial_recur(n - 1) else: return (n * factorial_recur(n - 1, mod)) % mod"},{"question":"# Problem You need to implement a function to find the minimum and maximum value in a given Binary Search Tree (BST). The tree structure, insertion, and search operations are already taken care of by the class `BST`. Your task is to add the following two methods to the `BST` class: 1. `find_min()` - This function should return the minimum value stored in the BST. 2. `find_max()` - This function should return the maximum value stored in the BST. # Input Format * The `BST` will be pre-populated with a series of integer values using the given `insert` method. * The methods `find_min()` and `find_max()` will be called to return the minimum and maximum value in the tree, respectively. # Output Format * The function `find_min()` should return an integer representing the minimum value in the BST. * The function `find_max()` should return an integer representing the maximum value in the BST. # Constraints * The BST will contain at least one node when the functions are called. # Example Given the following BST: ``` 10 / 6 15 / / 4 9 12 24 / 20 30 ``` Sample Calls: ```python bst = BST() bst.insert(10) bst.insert(15) bst.insert(6) bst.insert(4) bst.insert(9) bst.insert(12) bst.insert(24) bst.insert(20) bst.insert(30) print(bst.find_min()) # Output: 4 print(bst.find_max()) # Output: 30 ``` # Requirements Add the following two methods to the `BST` class in the provided code snippet: ```python class BST(object): # [other methods] def find_min(self): # Write your implementation here def find_max(self): # Write your implementation here ``` # Performance Ensure that your implementation: * Runs in O(h) time complexity, where h is the height of the tree. * Uses O(1) additional space.","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.key: if node.left is None: node.left = Node(key) else: self._insert(node.left, key) else: if node.right is None: node.right = Node(key) else: self._insert(node.right, key) def find_min(self): if not self.root: return None current = self.root while current.left is not None: current = current.left return current.key def find_max(self): if not self.root: return None current = self.root while current.right is not None: current = current.right return current.key"},{"question":"# Primality Testing and Application You are required to implement a function `prime_factors` to determine the prime factorization of a given integer ( n ). The algorithm should efficiently decompose the number into its prime factors using the primality check provided. Function Signature ```python def prime_factors(n: int) -> List[int]: ``` Input * An integer ( n ) where ( 1 leq n leq 10^7 ). Output * A list of integers representing the prime factors of ( n ), sorted in ascending order. Constraints * Ensure your solution runs efficiently for large ( n ). * If ( n ) is a prime number itself, the list should contain only ( n ). * For ( n = 1 ), return an empty list. Scenario In many areas such as number theory, cryptography, and computer science, it\'s often necessary to decompose a number into its prime factors. For example, in cryptographic algorithms based on RSA, prime factorization is used extensively. Examples ```python # Example 1 print(prime_factors(28)) # Output: [2, 2, 7] # Example 2 print(prime_factors(29)) # Output: [29] # Example 3 print(prime_factors(1)) # Output: [] # Example 4 print(prime_factors(100)) # Output: [2, 2, 5, 5] ```","solution":"from typing import List def prime_factors(n: int) -> List[int]: Returns the prime factors of the given integer n, sorted in ascending order. if n <= 1: return [] factors = [] # Check the number of 2s that divide n while n % 2 == 0: factors.append(2) n //= 2 # n must be odd at this point # a factor must be less than or equal to √n. for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: factors.append(i) n //= i # If n is a prime number greater than 2 if n > 2: factors.append(n) return factors"},{"question":"# Question You are given a list of integers representing students\' marks in an exam. Your task is to find the first occurrence of a student who has scored a specific mark. Function Signature ```python def find_student_by_mark(marks: List[int], target_mark: int) -> int ``` Input * `marks`: List of integers representing students\' marks. - It should handle empty lists. - The list may contain duplicate values. * `target_mark`: An integer representing the mark of the student you are looking for. Output * Return the index of the first student who has achieved `target_mark`. * If `target_mark` is not found in `marks`, return -1. Constraints * The length of `marks` can range from 0 to 10^6. * Marks values are non-negative integers (0 to 100). Example ```python # Example 1 marks = [85, 97, 75, 85, 75, 60] target_mark = 75 find_student_by_mark(marks, target_mark) # Output: 2 # Example 2 marks = [50, 40, 70, 90] target_mark = 100 find_student_by_mark(marks, target_mark) # Output: -1 # Example 3 marks = [] target_mark = 30 find_student_by_mark(marks, target_mark) # Output: -1 ``` **Note**: The solution should be efficient enough to handle the upper constraint limits.","solution":"from typing import List def find_student_by_mark(marks: List[int], target_mark: int) -> int: Returns the index of the first occurrence of target_mark in marks list. If target_mark is not found, returns -1. try: return marks.index(target_mark) except ValueError: return -1"},{"question":"Question **Context**: You are working on a data analysis project and need to quickly compute the frequency distribution of various items in a list. To achieve this, you will implement a function that generates a histogram of the list values. # Task Write a Python function `get_histogram(input_list: list) -> dict:` that takes a list of unordered values and returns a dictionary where the keys are the unique elements from the list and the values are the frequencies of these elements. # Input * A list `input_list` containing `n` elements, where (0 leq n leq 10^6). * Each element in the list can be any hashable type (integer, string, etc.). # Output * A dictionary where keys are the unique elements from the list and the values are their respective frequencies. # Constraints * The elements in the list are hashable and can include a mix of data types. * The list input can be empty, and in this case, the resulting histogram should also be empty. # Example ```python # Example 1 input_list = [3, 3, 2, 1] print(get_histogram(input_list)) # Expected Output: {1: 1, 2: 1, 3: 2} # Example 2 input_list = [2, 3, 5, 5, 5, 6, 4, 3, 7] print(get_histogram(input_list)) # Expected Output: {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} # Example 3 input_list = [] print(get_histogram(input_list)) # Expected Output: {} ``` # Notes * Consider edge cases like an empty list or a list with mixed data types. * Aim to achieve the optimal performance in terms of time and space complexity.","solution":"def get_histogram(input_list): Returns a dictionary where keys are the unique elements from the input_list and values are the frequencies of these elements. histogram = {} for item in input_list: if item in histogram: histogram[item] += 1 else: histogram[item] = 1 return histogram"},{"question":"# Digit Power Sum Numbers You are given a range of integers, defined by `low` and `high`. A number in this range is a \\"digit power sum number\\" if the sum of its digits each raised to the power of its position (starting from 1) equals the number itself. For example: - 89 is a digit power sum number because 8^1 + 9^2 = 89. - 135 is a digit power sum number because 1^1 + 3^2 + 5^3 = 135. Write a function `find_digit_power_sum(low, high)` that returns a list of all digit power sum numbers in the given range inclusive. Input: * `low` (int): The lower boundary of the range, `1 <= low <= high`. * `high` (int): The upper boundary of the range. Output: * A list of integers representing all the digit power sum numbers in the range `[low, high]`. Constraints: - You need to return these numbers in ascending order. - Ensure that your solution is optimized to handle larger ranges efficiently. Function signature: ```python def find_digit_power_sum(low: int, high: int) -> list: ``` Example: ```python assert find_digit_power_sum(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert find_digit_power_sum(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert find_digit_power_sum(10, 150) == [89, 135] ``` Hints: - Consider edge cases at the boundaries of the range. - Analyze the time complexity to ensure the function runs efficiently even for larger ranges. - Think about the limitations and possible performance improvements.","solution":"def find_digit_power_sum(low: int, high: int) -> list: result = [] for num in range(low, high + 1): sum_digit_powers = sum(int(digit) ** (idx + 1) for idx, digit in enumerate(str(num))) if sum_digit_powers == num: result.append(num) return result"},{"question":"You are given an array and a function. Write a class `EnhancedSegmentTree` that inherits from the provided `SegmentTree`. Extend the segment tree class to support updates efficiently. Your class should include a method to update an element at a specific index and ensure that subsequent range queries reflect this update. To illustrate: 1. Build the segment tree from the provided array using the given function. 2. Implement a method `update(index, value)` to update the value at the specified index of the array. 3. Ensure the segment tree is updated so that future queries reflect this change. 4. Implement a query method `query(L, R)` to fetch the result of the function applied over the segment `[L, R]` of the array. # Input & Output * Input: * List `arr` of integers. * Function `fn`. * Integer `index` for updating array element. * Integer `value` to update at specified index. * Two integers `L`, `R` for range query. * Output: * Query result after the segment update. # Example ```python # Define initial array arr = [2, 4, 5, 3, 4] # Define function (e.g., sum, max) fn = sum # Create an instance of EnhancedSegmentTree my_tree = EnhancedSegmentTree(arr, fn) # Perform queries print(my_tree.query(1, 3)) # Output should be the result of sum from index 1 to 3 # Update element at index 2 my_tree.update(2, 8) # Perform the query again after update print(my_tree.query(1, 3)) # Output should reflect the updated value at index 2 ``` # Constraints * 1 <= len(arr) <= 10^5 * array values and index values are within the standard integer range. # Requirements * Clearly written implementation with only required methods and transparent logic. * Proper handling of edge cases.","solution":"class SegmentTree: def __init__(self, data, fn): self.n = len(data) self.fn = fn self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.fn(self.tree[i * 2], self.tree[i * 2 + 1]) def query(self, l, r): l += self.n r += self.n res = 0 while l < r: if l % 2: res = self.fn(res, self.tree[l]) l += 1 if r % 2: r -= 1 res = self.fn(res, self.tree[r]) l //= 2 r //= 2 return res def update(self, idx, value): pass # To be implemented in inherited class class EnhancedSegmentTree(SegmentTree): def build(self, data): Extend build method to support range queries. super().build(data) def update(self, idx, value): Update the segment tree data at index \'idx\' with the value \'value\'. idx += self.n self.tree[idx] = value while idx > 1: idx //= 2 self.tree[idx] = self.fn(self.tree[2 * idx], self.tree[2 * idx + 1]) # Example usage if __name__ == \\"__main__\\": arr = [2, 4, 5, 3, 4] fn = lambda x, y: x + y enhanced_tree = EnhancedSegmentTree(arr, fn) print(enhanced_tree.query(1, 4)) # Example query from index 1 to index 3 enhanced_tree.update(2, 8) # Update operation at index 2 changing value to 8 print(enhanced_tree.query(1, 4)) # Query again to check updated values"},{"question":"# Rabin-Karp Algorithm Enhancement Problem Statement You are given a pattern and a text, and you need to find the first occurrence of the pattern in the text using the Rabin-Karp algorithm. Your implementation needs to handle a larger character set (including digits and special characters), and address hash collision issues. Constraints 1. The pattern and the text can contain any printable ASCII characters. 2. The algorithm should return the starting index of the first occurrence of the pattern in the text. 3. If the pattern is not found, the function should return -1. Input Format - `pattern`: a non-empty string representing the substring to be searched. - `text`: a potentially empty string representing the text within which the pattern is to be searched. Output Format - Return an integer indicating the starting index of the first occurrence of the pattern in the text, or -1 if the pattern is not found. Performance Requirements - The solution should handle up to 100,000 characters efficiently. - Optimize for minimal hash collisions and ensure correctness. Function Signature ```python def rabin_karp_enhanced(pattern: str, text: str) -> int: pass ``` # Example ```python print(rabin_karp_enhanced(\\"aba\\", \\"abacabadabacaba\\")) # Output: 0 print(rabin_karp_enhanced(\\"dab\\", \\"abacabadabacaba\\")) # Output: 7 print(rabin_karp_enhanced(\\"xyz\\", \\"abacabadabacaba\\")) # Output: -1 ```","solution":"def rabin_karp_enhanced(pattern: str, text: str) -> int: Finds the first occurrence of the pattern in the text using the Rabin-Karp algorithm. :param pattern: The substring to be searched. :param text: The text within which the pattern is to be searched. :return: The starting index of the first occurrence of the pattern in the text, or -1 if the pattern is not found. if len(pattern) > len(text): return -1 base = 256 # Number of characters in the input alphabet prime = 101 # A prime number to use for hashing pattern_length = len(pattern) text_length = len(text) pattern_hash = 0 text_hash = 0 h = 1 for i in range(pattern_length - 1): h = (h * base) % prime for i in range(pattern_length): pattern_hash = (base * pattern_hash + ord(pattern[i])) % prime text_hash = (base * text_hash + ord(text[i])) % prime for i in range(text_length - pattern_length + 1): if pattern_hash == text_hash: if text[i:i + pattern_length] == pattern: return i if i < text_length - pattern_length: text_hash = (base * (text_hash - ord(text[i]) * h) + ord(text[i + pattern_length])) % prime if text_hash < 0: text_hash += prime return -1"},{"question":"# Question: Counting Connected Components using DFS Context In the land of Graphonia, cities are represented as nodes, and roads connecting them are represented as edges in a graph. The Mayor of Graphonia wants to know how many isolated groups of cities (connected components) exist in the country. Your task is to count the number of connected groups of cities using Depth-First Search (DFS). Problem Statement Write a function `count_connected_components(n, edges)` that takes two arguments: 1. `n` (int): The number of cities (nodes). 2. `edges` (list of tuples): A list of roads (edges) where each tuple (u, v) indicates a two-way road between city `u` and city `v`. Your function should return an integer representing the number of connected components in the graph. Constraints * 1 <= `n` <= 10^4 * 0 <= number of edges <= 10^4 * 1 <= `u`, `v` <= `n` Example ```python # Example input n = 7 edges = [(1, 2), (2, 4), (4, 5), (6, 5), (3, 7)] # Example output result = count_connected_components(n, edges) print(result) # Output: 2 ``` Function Signature ```python def count_connected_components(n, edges) -> int: # Your code here pass ``` Notes - A connected component is a subset of cities such that any city can be reached from any other city in the same subset. - Cities with no roads should be considered as individual connected components. Hint: Use a depth-first search (DFS) to explore the graph and count how many separate groups of connected nodes exist.","solution":"def count_connected_components(n, edges): def dfs(node, visited, adjacency_list): stack = [node] while stack: current = stack.pop() if not visited[current]: visited[current] = True for neighbor in adjacency_list[current]: if not visited[neighbor]: stack.append(neighbor) # Adjacency list representation of the graph adjacency_list = {i: [] for i in range(1, n+1)} for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) visited = {i: False for i in range(1, n+1)} connected_components_count = 0 for node in range(1, n+1): if not visited[node]: dfs(node, visited, adjacency_list) connected_components_count += 1 return connected_components_count"},{"question":"# Question: **Strongly Connected Graph Detection** In graph theory, a *strongly connected component* (SCC) of a directed graph is a maximal strongly connected subgraph. A directed graph is said to be strongly connected if there is a path in each direction between each pair of vertices of the graph (i.e., from each vertex to every other vertex, and vice versa). You are given a directed graph represented as an adjacency list. Implement the function `is_strongly_connected` that checks if the entire graph is one strongly connected component. Function Signature: ```python def is_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: ``` Input: - `vertex_count`: an integer V (1 <= V <= 1000), the number of vertices. - `edges`: a list of tuples (u, v), where each tuple represents a directed edge from vertex u to vertex v. Output: - Return `True` if the graph is strongly connected, `False` otherwise. Constraints: - Vertices are labeled with integers from 0 to V-1. - The graph may have no edges or multiple edges. - Self-loops (edges where u = v) are allowed. Example: ```python assert is_strongly_connected(4, [(0, 1), (1, 2), (2, 0), (1, 3), (3, 1)]) == True assert is_strongly_connected(4, [(0, 1), (1, 2), (2, 0), (1, 3)]) == False ``` **Explanation**: 1. The first example graph is strongly connected as there is a path between any pair of vertices. 2. In the second example, vertex 3 does not have any outgoing edges to reach other vertices, so it\'s not strongly connected. Implement your solution keeping the above analysis and instructions in mind.","solution":"from typing import List, Tuple def dfs(graph: List[List[int]], start: int, visited: List[bool]): stack = [start] while stack: node = stack.pop() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) def is_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: if vertex_count == 1: return True graph = [[] for _ in range(vertex_count)] reverse_graph = [[] for _ in range(vertex_count)] for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) # Check reachability from the first node in the original graph visited = [False] * vertex_count visited[0] = True dfs(graph, 0, visited) if not all(visited): return False # Check reachability from the first node in the reversed graph visited = [False] * vertex_count visited[0] = True dfs(reverse_graph, 0, visited) return all(visited)"},{"question":"# Question **Objective**: Implement an algorithm that processes a list of integers, ensuring that each element appears at most **N** times, while preserving the original order. # Function Specification Input * `array` (List[int]): A list of integers. * `n` (int): The maximum number of times any given element should appear in the output list. Output * List[int]: A new list where no element appears more than ( N ) times. # Constraints * The list may contain up to (10^5) elements. * ( N ) is a positive integer between 1 and (10^3). * Elements in the list range from (-10^6) to (10^6). # Requirements 1. Your solution should have a time complexity of ( O(n) ). 2. You must maintain the original order of elements in the resulting list. # Example Example Input ```python array = [1, 2, 3, 1, 2, 1, 2, 3] n = 2 ``` Example Output ```python [1, 2, 3, 1, 2, 3] ``` In the example above, the number `1` and `2` appear more than twice in the input list but are restricted to twice only in the output list, while maintaining order. # Function Signature ```python def delete_nth(array: List[int], n: int) -> List[int]: # Your code here ``` Implement the `delete_nth` function and ensure it adheres to the provided specifications and performance requirements.","solution":"def delete_nth(array, n): Processes a list of integers ensuring each element appears at most `n` times while preserving the original order. :param array: List[int] - A list of integers. :param n: int - The maximum number of times any given element should appear in the list. :return: List[int] - A new list where no element appears more than `n` times. result = [] counts = {} for element in array: if counts.get(element, 0) < n: result.append(element) counts[element] = counts.get(element, 0) + 1 return result"},{"question":"# Priority Queue Enhancement using a Min-Heap Problem Statement In a scheduling system, tasks are added with a certain priority and must be executed according to this priority. To optimize the performance, you are required to enhance the existing priority queue implementation by using a min-heap data structure instead of a linear array. Task Implement a Min-Heap based priority queue supporting the following operations: 1. `push(item, priority)`: Adds a new element to the priority queue with a given priority. 2. `pop()`: Removes and returns the element with the lowest priority. 3. `size()`: Returns the number of elements in the priority queue. Input and Output * `push(item, priority)`: Adds the element `item` with the associated `priority` to the queue. * `pop()`: Returns the item with the lowest priority. * `size()`: Returns the current size of the priority queue as an integer. Constraints * Task priorities are integers ranging from -10^6 to 10^6. * The priority queue can hold up to 10^5 items. * The implementation should efficiently handle frequent insertions and deletions. Example ```python pq = PriorityQueue() pq.push(\'Task1\', 3) pq.push(\'Task2\', 1) pq.push(\'Task3\', 2) print(pq.pop()) # Output: \'Task2\' pq.push(\'Task4\', 0) print(pq.size()) # Output: 3 print(pq.pop()) # Output: \'Task4\' print(pq.pop()) # Output: \'Task3\' ``` Notes * The implementation should utilize a min-heap to minimize the time complexity of insertion and extraction operations. * Ensure edge cases like popping from an empty queue are handled gracefully.","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] self.entry_finder = {} self.REMOVED = \'<removed-task>\' self.counter = 0 def push(self, item, priority): Add a new task or update the priority of an existing task if item in self.entry_finder: self.remove_task(item) count = self.counter entry = [priority, count, item] self.entry_finder[item] = entry heapq.heappush(self.heap, entry) self.counter += 1 def remove_task(self, item): Mark an existing task as REMOVED. Raise KeyError if not found. entry = self.entry_finder.pop(item) entry[-1] = self.REMOVED def pop(self): Remove and return the lowest priority task. Raise KeyError if empty. while self.heap: priority, count, item = heapq.heappop(self.heap) if item is not self.REMOVED: del self.entry_finder[item] return item raise KeyError(\'pop from an empty priority queue\') def size(self): Return the number of tasks in the priority queue. return len(self.entry_finder)"},{"question":"# Decoding Ways You are given a string representing an encoded message containing digits. You need to implement a function that determines the total number of ways to decode it, using the given character-to-number mapping: ``` \'A\' -> 1 \'B\' -> 2 ... \'Z\' -> 26 ``` For example, the encoded message \\"12\\" could be decoded as \\"AB\\" (1 2) or \\"L\\" (12). Hence, it has 2 possible decodings. Function Signature ```python def decode_ways(encoded_message: str) -> int: pass ``` Input - `encoded_message`: a non-empty string of digits with length `1 <= len(encoded_message) <= 100`. Output - Return a single integer representing the number of ways to decode the given message. Constraints - The message will only contain numeric characters (\'0\'-\'9\'). - The input string will not be empty and will not exceed 100 characters in length. Example 1. When `encoded_message = \\"226\\"`, the function should return `3`, since the message could be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6), or \\"BBF\\" (2 2 6). 2. When `encoded_message = \\"10\\"`, the function should return `1`, as there is only one valid decoding: \\"J\\" (10). Notes 1. Ensure to handle edge cases such as string starting with \'0\', consecutive zeros, and invalid substring patterns. 2. Optimize for both time and space where possible.","solution":"def decode_ways(encoded_message: str) -> int: if not encoded_message or encoded_message[0] == \'0\': return 0 n = len(encoded_message) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 if encoded_message[0] != \'0\' else 0 for i in range(2, n + 1): one_digit = int(encoded_message[i-1:i]) two_digits = int(encoded_message[i-2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i-1] if 10 <= two_digits <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"Context Given a singly linked list, your task is to write a function that reverses the linked list. Function Signature ```python def reverse_linked_list(head): :type head: ListNode :rtype: ListNode ``` Input - `head`: The head node of a singly linked list. Output - The new head node of the reversed linked list. Constraints - The linked list contains nodes with integer values. - The length of the linked list is between 0 and 10^6. Requirements - Implement an in-place algorithm with O(n) time complexity and O(1) space complexity. - Avoid using additional data structures (e.g., arrays, stacks). - Handle all edge cases gracefully (e.g., empty list, single node list). Example **Example 1** ```plaintext Input: 1 -> 2 -> 3 -> 4 Output: 4 -> 3 -> 2 -> 1 ``` **Example 2** ```plaintext Input: None Output: None ``` **Example 3** ```plaintext Input: 5 Output: 5 ``` Note: The given linked list is represented by reference to the head node, and your function should return the new head of the reversed list.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_linked_list(head): Reverses a singly linked list. :param head: ListNode - The head node of the singly linked list. :return: ListNode - The new head node of the reversed singly linked list. prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"You are given a plaintext string and a fixed integer shift value. Implement a function `caesar_cipher(s, k)` that encrypts the string using the Caesar Cipher method. The function should maintain the casing and leave non-alphabet characters unchanged. # Function Signature ```python def caesar_cipher(s: str, k: int) -> str: ``` # Input - `s` (string): The input plaintext string that can contain uppercase letters, lowercase letters, and non-alphabetic characters. - `k` (int): The fixed integer value representing the number of positions each letter should be shifted by. # Output - A string representing the encrypted text. # Constraints - 1 ≤ length of `s` ≤ 1000 - 0 ≤ `k` ≤ 1000 # Example ```python assert caesar_cipher(\\"Hello, World!\\", 3) == \\"Khoor, Zruog!\\" assert caesar_cipher(\\"abcXYZ\\", 4) == \\"efgBCD\\" assert caesar_cipher(\\"Shift123\\", 1) == \\"Tijgu123\\" ``` # Notes 1. Your solution should work efficiently for all input sizes within the given constraints. 2. Ensure to handle wrapping of letters beyond \'z\' and \'Z\'. 3. Maintain the integrity and positions of all non-alphabetic characters.","solution":"def caesar_cipher(s: str, k: int) -> str: Encrypts the string s using Caesar Cipher method with fixed integer shift value k. encrypted_text = [] for char in s: if char.isalpha(): shift_base = ord(\'A\') if char.isupper() else ord(\'a\') shifted_char = chr((ord(char) - shift_base + k) % 26 + shift_base) encrypted_text.append(shifted_char) else: encrypted_text.append(char) return \'\'.join(encrypted_text)"},{"question":"# Coding Challenge: Encode and Decode Strings Problem Statement: You are tasked with designing an algorithm to encode a list of strings into a single string. This encoded string can then be sent over the network or stored, and later decoded back into the original list of strings without any loss of information. Requirements: 1. Implement the function `encode(strs: List[str]) -> str` which: - Takes a list of strings `strs` and returns a single encoded string. 2. Implement the function `decode(s: str) -> List[str]` which: - Takes an encoded string `s` and returns the original list of strings. Expected Behavior: - The encode function should convert the list of strings into a single string where each string is prefixed with its length followed by a colon. - The decode function should parse the single string back into the original list of strings based on the length information. Input and Output Format: - `encode` Input: List of strings `strs` - `encode` Output: Encoded string - `decode` Input: Encoded string `s` - `decode` Output: List of strings Constraints: - Each string in the list may contain any character including numeric digits and colons. - The functions should handle edge cases such as empty strings within the list. - The implementation should be efficient in time and space complexity, aiming to maintain linear complexity relative to input size. Example: ```python assert encode([\\"hello\\", \\"world\\"]) == \\"5:hello5:world\\" assert decode(\\"5:hello5:world\\") == [\\"hello\\", \\"world\\"] assert encode([\\"\\"]) == \\"0:\\" assert decode(\\"0:\\") == [\\"\\"] assert encode([]) == \\"\\" assert decode(\\"\\") == [] ``` Additional Context: This algorithm is instrumental in scenarios requiring data transmission where strings need to be packed efficiently. By providing length delimiters and parsing instructions, it ensures the integrity of the original data while keeping the encoded representation compact.","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. Each string is prefixed by its length followed by a colon. encoded_str = \\"\\".join(f\\"{len(s)}:{s}\\" for s in strs) return encoded_str def decode(s: str) -> List[str]: Decodes a single string to a list of strings. The single string contains each string prefixed by its length followed by a colon. strs = [] i = 0 while i < len(s): j = s.find(\':\', i) length = int(s[i:j]) i = j + 1 strs.append(s[i:i + length]) i += length return strs"},{"question":"# Problem Description You are tasked with writing a function `is_merge(s: str, part1: str, part2: str) -> bool` that determines whether the string `s` can be formed by interleaving the characters of `part1` and `part2` while maintaining the order of characters as they appear in `part1` and `part2`. # Input * A string `s` with a length between 0 and 1000. * A string `part1` with a length between 0 and |s|. * A string `part2` with a length between 0 and |s|. # Output * A boolean value: `True` if `s` can be formed by interleaving `part1` and `part2`, otherwise `False`. # Constraints * All strings consist of uppercase/lowercase letters only. * The combined length of `part1` and `part2` is equal to the length of `s`. # Example ```python assert is_merge(\'codewars\', \'cdw\', \'oears\') == True assert is_merge(\'abc\', \'ab\', \'cd\') == False assert is_merge(\'aabcc\', \'abc\', \'ac\') == True assert is_merge(\'aabcc\', \'ab\', \'acbd\') == False ``` # Notes * Your solution should handle edge cases such as empty strings and unequal lengths appropriately. * Aim for an optimized solution considering time and space complexity. # Additional Challenge (Optional) * Implement the `is_merge` function using dynamic programming to optimize the performance.","solution":"def is_merge(s: str, part1: str, part2: str) -> bool: if len(s) != len(part1) + len(part2): return False dp = [[False] * (len(part2) + 1) for _ in range(len(part1) + 1)] dp[0][0] = True for i in range(1, len(part1) + 1): dp[i][0] = dp[i - 1][0] and part1[i - 1] == s[i - 1] for j in range(1, len(part2) + 1): dp[0][j] = dp[0][j - 1] and part2[j - 1] == s[j - 1] for i in range(1, len(part1) + 1): for j in range(1, len(part2) + 1): dp[i][j] = (dp[i - 1][j] and part1[i - 1] == s[i + j - 1]) or (dp[i][j - 1] and part2[j - 1] == s[i + j - 1]) return dp[len(part1)][len(part2)]"},{"question":"You are given a nested dictionary representing a hierarchical organizational structure. Your task is to implement a function that prints this hierarchy in a formatted manner, clearly showing different levels of the hierarchy. # Function Signature ```python def print_hierarchy(hierarchy: dict) -> None: ``` # Input - `hierarchy` (dict): A nested dictionary where keys represent entities at the current level of hierarchy and values can be either strings or lists of further nested dictionaries. # Output - The function should print the hierarchy to the standard output in a specified format. # Constraints - The dictionary can be empty. - The depth of the hierarchy is limited by the recursion limit of Python (typically around 1000). # Expected Output Your function should print the hierarchy such that: - Each entity at the current level is followed by its nested entities, indented to represent their hierarchical level. - Ensure output format for indentation: - Use \\" -> \\" to separate different hierarchical levels. - Indent nested entities with a newline followed by a space for each hierarchy level. # Example ```python example_hierarchy = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6, [\'Jill\', \'Sports\', 1]], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, [\'Quin\', \'Computer\', 3]], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } print_hierarchy(example_hierarchy) ``` # Expected Output ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` # Note - Handling of mixed-type contents in the hierarchy (strings, lists, other dictionaries) correctly is essential for correctly printing different levels of the structure. - Manage recursion carefully to avoid stack overflow for deeply nested structures.","solution":"def print_hierarchy(hierarchy: dict) -> None: Prints the hierarchy to the standard output in a formatted manner. def _print_level(entity, level=0): indent = \' \' * level * 4 if isinstance(entity, dict): for key, value in entity.items(): print(f\\"{indent}{key}\\") _print_level(value, level + 1) elif isinstance(entity, list): for item in entity: _print_level(item, level) else: print(f\\"{indent}{entity}\\") for key, value in hierarchy.items(): _print_level({key: value})"},{"question":"**Anagram Checker with Extended Character Set** Given two strings, determine if they are anagrams of each other. The strings may contain any printable ASCII characters, and the check should be case-insensitive. You must handle all edge cases, including empty strings and strings with special characters. # Function Signature ```python def extended_anagram(s1: str, s2: str) -> bool: pass ``` # Input * `s1` (string): The first string to compare. Length is between 0 and 10^5. * `s2` (string): The second string to compare. Length is between 0 and 10^5. # Output * Return `True` if the strings are anagrams, `False` otherwise. # Constraints * The comparison should be case-insensitive. * Handle all printable ASCII characters from 32 (\' \') to 126 (\'~\'). # Example ```python assert extended_anagram(\\"apple\\", \\"pleap\\") == True assert extended_anagram(\\"Apple\\", \\"pleap\\") == True assert extended_anagram(\\"apple\\", \\"apple!\\") == False assert extended_anagram(\\"\\", \\"\\") == True assert extended_anagram(\\"Dormitory\\", \\"Dirty room!\\") == False assert extended_anagram(\\"The eyes\\", \\"They see\\") == True ``` # Hints * Use an array of size 95 (for all printable ASCII characters) to count frequencies. * Normalize characters to lower case before counting.","solution":"def extended_anagram(s1: str, s2: str) -> bool: Determines if two strings are anagrams of each other, considering all printable ASCII characters and making the comparison case-insensitive. # Normalize strings to lower case to make the comparison case insensitive s1 = s1.lower() s2 = s2.lower() # If lengths differ, they cannot be anagrams if len(s1) != len(s2): return False # Use dictionaries to count frequencies of characters count1 = {} count2 = {} for char in s1: if char in count1: count1[char] += 1 else: count1[char] = 1 for char in s2: if char in count2: count2[char] += 1 else: count2[char] = 1 # Compare the two dictionaries return count1 == count2"},{"question":"You are provided an array of integers. Your task is to implement the Merge Sort algorithm to sort the array in ascending order. Your implementation must adhere to the following requirements and constraints: Input * An array `arr` with `n` integers, where `0 <= n <= 10^5` and `-10^9 <= arr[i] <= 10^9`. Output * Return the array sorted in ascending order. # Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: Sorts the given array in ascending order using the Merge Sort algorithm. ``` # Constraints 1. The runtime complexity of your implementation should be O(n log(n)). 2. The auxiliary space complexity should be O(n). # Example ```python # Example 1 arr = [3, 5, 1, 4, 2] output = merge_sort(arr) # output should be [1, 2, 3, 4, 5] # Example 2 arr = [-1, 3, -4, 2, 0] output = merge_sort(arr) # output should be [-4, -1, 0, 2, 3] ``` # Notes * Consider edge cases such as an empty array or an array with a single element. * Implement an efficient merging step to ensure the minimum required auxiliary space is used.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr # Split the array into two halves mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) # Merge the two halves return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: sorted_array = [] i = j = 0 # Merge the two arrays while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_array.append(left[i]) i += 1 else: sorted_array.append(right[j]) j += 1 # Append any remaining elements from left or right sorted_array.extend(left[i:]) sorted_array.extend(right[j:]) return sorted_array"},{"question":"You are tasked with helping a text editor implement an autocorrect feature by writing a function to compute the edit distance between two given words. The edit distance is a measure of how dissimilar two strings are to one another, defined by the minimum number of operations required to transform one string into the other. The operations allowed are insertions, deletions, or substitutions of characters. # Function Signature ```python def optimized_edit_distance(word_a: str, word_b: str) -> int: Calculate and return the edit distance between two strings word_a and word_b. ``` # Input - `word_a`: A non-empty string consisting of lowercase alphabetical characters (1 ≤ len(word_a) ≤ 5000). - `word_b`: A non-empty string consisting of lowercase alphabetical characters (1 ≤ len(word_b) ≤ 5000). # Output - Return an integer representing the edit distance between `word_a` and `word_b`. # Example *Example 1:* ```python word_a = \\"kitten\\" word_b = \\"sitting\\" assert optimized_edit_distance(word_a, word_b) == 3 ``` *Explanation:* The edit distance between \\"kitten\\" and \\"sitting\\" can be achieved in the following steps: 1. kitten -> sitten (substitution) 2. sitten -> sittin (substitution) 3. sittin -> sitting (insertion) *Example 2:* ```python word_a = \\"intention\\" word_b = \\"execution\\" assert optimized_edit_distance(word_a, word_b) == 5 ``` *Explanation:* The edit distance between \\"intention\\" and \\"execution\\" can be achieved in the following steps: 1. intention -> inention (deletion) 2. inention -> enention (substitution) 3. enention -> exention (substitution) 4. exention -> exection (substitution) 5. exection -> execution (insertion) # Constraints - Perform the computation efficiently to handle the maximum input size. - Focus on optimizing both time and space complexity as much as possible. # Notes - Consider whether it\'s feasible to reduce the space complexity from O(length_a * length_b) to linear space.","solution":"def optimized_edit_distance(word_a: str, word_b: str) -> int: Calculate and return the edit distance between two strings word_a and word_b using a space optimized dynamic programming approach. len_a, len_b = len(word_a), len(word_b) # Edge cases if len_a == 0: return len_b if len_b == 0: return len_a # Initialize the previous row and current row previous_row = list(range(len_b + 1)) current_row = [0] * (len_b + 1) for i in range(1, len_a + 1): current_row[0] = i for j in range(1, len_b + 1): insert_cost = current_row[j-1] + 1 delete_cost = previous_row[j] + 1 substitute_cost = previous_row[j-1] + (1 if word_a[i-1] != word_b[j-1] else 0) current_row[j] = min(insert_cost, delete_cost, substitute_cost) # Swap rows previous_row, current_row = current_row, previous_row return previous_row[len_b]"},{"question":"You are developing a navigation system for a Unix-based file system. Your task is to write a function that takes an absolute Unix-style file path and simplifies it to its canonical form. The canonical path should have: 1. A single slash (\\"/\\") as a separator between directory names. 2. No trailing slashes. 3. No references to the current directory (\\"./\\") or parent directory (\\"../\\") unless the path is entirely in the root directory (\\"/\\"). The input path will always begin with a slash (\\"/\\"). Inputs: 1. `path` (string): The absolute Unix-style file path, e.g., \\"/home/\\", \\"/a/./b/../../c/\\". Outputs: 1. `result` (string): The simplified canonical path. Constraints: - The length of `path` will be between 1 and 3000. - The input will be a valid Unix-style path. Performance Requirements: - Time complexity should be O(n), where n is the length of the path string. - Space complexity should be O(n), where n is the length of the path string. # Function Signature ```python def simplify_path(path: str) -> str: pass ``` # Examples ```python assert simplify_path(\\"/home/\\") == \\"/home\\" assert simplify_path(\\"/a/./b/../../c/\\") == \\"/c\\" assert simplify_path(\\"/../\\") == \\"/\\" assert simplify_path(\\"/home//foo/\\") == \\"/home/foo\\" assert simplify_path(\\"/a/b/c/./../../g\\") == \\"/a/g\\" ``` # Edge Cases - Path contains multiple slashes: should be simplified to a single slash separator. - Path contains \\"..\\" at the beginning or middle: should step up directory levels correctly.","solution":"def simplify_path(path: str) -> str: Simplifies the given Unix-style absolute file path. parts = path.split(\\"/\\") stack = [] for part in parts: if part == \\"\\" or part == \\".\\": continue elif part == \\"..\\": if stack: stack.pop() else: stack.append(part) return \\"/\\" + \\"/\\".join(stack)"},{"question":"# Fibonacci Problem: Optimized Computation Given a non-negative integer `n`, write a Python function `fibo_optimized(n)` that efficiently computes the n-th Fibonacci number. Your implementation should aim to minimize both time and space complexity, making it suitable for very large values of `n`. Function Signature ```python def fibo_optimized(n: int) -> int: ``` Input - `n`: a non-negative integer (0 ≤ n ≤ 10^6). Output - Returns the n-th Fibonacci number. Constraints - You must implement an efficient algorithm with both time complexity O(n) and space complexity O(1). - Your function should handle very large n values efficiently and correctly. Performance Requirements - Your solution should have linear time complexity. - Ensure low space usage by avoiding the storage of all Fibonacci numbers up to n. Example ```python print(fibo_optimized(10)) # Output: 55 print(fibo_optimized(100)) # Output: 354224848179261915075 ``` Edge Cases - Handle the minimum input value (e.g., n = 0). - Ensure correctness for very large inputs within the given constraints.","solution":"def fibo_optimized(n: int) -> int: Efficiently computes the n-th Fibonacci number using an iterative approach with constant space complexity. if n == 0: return 0 elif n == 1: return 1 prev, curr = 0, 1 for _ in range(2, n + 1): prev, curr = curr, prev + curr return curr"},{"question":"# Red-Black Tree Implementation and Testing A company uses a custom data structure to handle the access and management of user roles and permissions in their system. This structure frequently requires the handling of dynamic datasets with frequent insertions and deletions while maintaining a balanced state for performance enhancements. They use a Red-Black Tree for this. You are required to implement two key functionalities: 1. **Insert any number of nodes and ensure their proper placement maintaining the Red-Black tree properties**. 2. **Display the in-order traversal of the tree, detailing each node\'s value and color**. # Function Signature Please implement the following methods of the `RBTree` class: ```python def insert(self, node: RBNode) -> None: Insert a new node into the RBTree and ensure it stays balanced. def inorder(self) -> list: Perform an in-order traversal of the tree and return a list of dictionaries containing each node\'s value and color. ``` # Input and Output Formats - `insert(self, node)` takes an instance of `RBNode` as input and inserts it into the tree while maintaining its properties. - `inorder(self)` performs an in-order traversal of the tree, returning a list of dictionaries, each containing `val` and `color`. Color should be represented as `red` or `black`. # Constraints - Each node value is an integer in the range 0 to 1000. - At most 1000 operations will be performed on the tree. # Example ```python rb_tree = RBTree() nodes = [11, 2, 14, 1, 7, 15, 5, 8, 4] for value in nodes: rb_node = RBNode(value, True) rb_tree.insert(rb_node) print(rb_tree.inorder()) # Expected Output: # [{\'val\': 1, \'color\': \'black\'}, {\'val\': 2, \'color\': \'red\'}, {\'val\': 4, \'color\': \'black\'}, ... ] ``` By implementing `insert` and `inorder` correctly, you will ensure that the red-black properties are maintained, and provide an efficient view into the tree structure.","solution":"class RBNode: def __init__(self, val, red=True, left=None, right=None, parent=None): self.val = val self.red = red self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.NIL_LEAF = RBNode(val=None, red=False) # Our nil leaf, used to represent the end of the tree. self.root = self.NIL_LEAF def insert(self, node): node.left = self.NIL_LEAF node.right = self.NIL_LEAF node.red = True self._insert_node(self.root, node) self._fix_insert(node) def _insert_node(self, current, node): if self.root == self.NIL_LEAF: self.root = node self.root.red = False return if node.val < current.val: if current.left == self.NIL_LEAF: current.left = node node.parent = current else: self._insert_node(current.left, node) else: if current.right == self.NIL_LEAF: current.right = node node.parent = current else: self._insert_node(current.right, node) def _rotate_left(self, node): right_child = node.right node.right = right_child.left if right_child.left != self.NIL_LEAF: right_child.left.parent = node right_child.parent = node.parent if node.parent is None: self.root = right_child elif node == node.parent.left: node.parent.left = right_child else: node.parent.right = right_child right_child.left = node node.parent = right_child def _rotate_right(self, node): left_child = node.left node.left = left_child.right if left_child.right != self.NIL_LEAF: left_child.right.parent = node left_child.parent = node.parent if node.parent is None: self.root = left_child elif node == node.parent.right: node.parent.right = left_child else: node.parent.left = left_child left_child.right = node node.parent = left_child def _fix_insert(self, node): while node != self.root and node.parent.red: if node.parent == node.parent.parent.left: uncle = node.parent.parent.right if uncle.red: node.parent.red = uncle.red = False node.parent.parent.red = True node = node.parent.parent else: if node == node.parent.right: node = node.parent self._rotate_left(node) node.parent.red = False node.parent.parent.red = True self._rotate_right(node.parent.parent) else: uncle = node.parent.parent.left if uncle.red: node.parent.red = uncle.red = False node.parent.parent.red = True node = node.parent.parent else: if node == node.parent.left: node = node.parent self._rotate_right(node) node.parent.red = False node.parent.parent.red = True self._rotate_left(node.parent.parent) self.root.red = False def inorder(self): result = [] self._inorder_helper(self.root, result) return result def _inorder_helper(self, node, result): if node != self.NIL_LEAF: self._inorder_helper(node.left, result) if node.val is not None: result.append({\'val\': node.val, \'color\': \'red\' if node.red else \'black\'}) self._inorder_helper(node.right, result)"},{"question":"You are helping a friend practice for their physical fitness test which involves climbing stairs. You know that to get to the top of the stairs, there are specific sequences of 1-step and 2-step moves one can take to exactly reach the top. The task is to write a function to determine the number of distinct ways one can exactly climb to the top given the number of steps. # Function Specifications Implement a function `distinct_ways_to_climb` which computes the number of distinct ways to reach the top of the staircase. ```python def distinct_ways_to_climb(steps: int) -> int: pass ``` # Input - `steps` (1 ≤ steps ≤ 10^6): an integer representing the number of steps to get to the top. # Output - Returns an integer, the number of distinct ways to reach the top, following the rule that you can either take a step of 1 or 2 steps at a time. # Constraints - Efficiency is key; the function should handle input size as large as 10^6 without running into performance issues. - Aim to optimize for both time and space complexity as much as possible. # Example ```python print(distinct_ways_to_climb(2)) # Output: 2 print(distinct_ways_to_climb(3)) # Output: 3 print(distinct_ways_to_climb(10)) # Output: 89 ``` # Implementation Use dynamic programming principles to efficiently determine the number of ways to climb the stairs. You might get inspiration from the classic Fibonacci series where each position is the sum of the two preceding numbers. Implement this either by maintaining an array or by using an optimized approach.","solution":"def distinct_ways_to_climb(steps: int) -> int: Returns the number of distinct ways to climb a staircase with a given number of steps where each move can be either a step of 1 or 2 steps. if steps == 1: return 1 elif steps == 2: return 2 a, b = 1, 2 for _ in range(3, steps + 1): a, b = b, a + b return b"},{"question":"# **Question: Implement the \\"Largest Island\\" Problem with Union-Find** You are given an `n x n` binary matrix `grid` where grid[i][j] is `0` (representing water) or `1` (representing land). An island is a 4-directionally connected group of `1`s. You can change at most one digit `0` to `1` to form an island. Return the size of the largest island in `grid` after flipping at most one `0` to `1`. # **Function Signature** ```python def largest_island(grid: List[List[int]]) -> int: ``` # **Input** * `grid`: List[List[int]] - A binary matrix of size `n x n` (1 <= n <= 50). # **Output** * `Returns`: Int - The size of the largest island that can be obtained by flipping at most one `0` to `1`. # **Constraints** * The grid contains only 0s and 1s. * The dimensions of the grid are: 1 ≤ n ≤ 50. # **Examples** Example 1: ```python grid = [ [1, 0], [0, 1] ] assert largest_island(grid) == 3 ``` Here, we can change either 0 to 1 to get a connected group of three `1`s. Example 2: ```python grid = [ [1, 1], [1, 0] ] assert largest_island(grid) == 4 ``` Here, we can change the single `0` to `1` to get a connected group of four `1`s. # **Implementation Details** 1. Use the Union-Find data structure to keep track of connected components. 2. Traverse the grid to combine all adjacent lands into sets. 3. Evaluate the impact of flipping each water cell to land and determine the maximum island size that could be obtained by this flip. 4. Handle edge scenarios where the grid might already be fully land, or flips make no further impact.","solution":"from typing import List def largest_island(grid: List[List[int]]) -> int: n = len(grid) # Size of the grid parent = {} size = {} def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootX] = rootY size[rootY] += size[rootX] for r in range(n): for c in range(n): if grid[r][c] == 1: parent[(r, c)] = (r, c) size[(r, c)] = 1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for r in range(n): for c in range(n): if grid[r][c] == 1: for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < n and grid[nr][nc] == 1: union((r, c), (nr, nc)) max_area = max(size.values(), default=0) for r in range(n): for c in range(n): if grid[r][c] == 0: seen = set() area = 1 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < n and grid[nr][nc] == 1: root = find((nr, nc)) if root not in seen: seen.add(root) area += size[root] max_area = max(max_area, area) return max_area"},{"question":"# Question You are required to implement a function that multiplies two positive integers using only bitwise operations and addition (which we\'ve covered already) and returns the product. This exercise will assess your understanding of bitwise manipulation and fundamental arithmetic operations without relying on direct multiplication. Function Signature: ```python def multiply_bitwise(a: int, b: int) -> int: ``` # Input/Output: * **Input**: - `a`: A positive integer (1 <= a <= 10^5) - `b`: A positive integer (1 <= b <= 10^5) * **Output**: - Returns the product of `a` and `b`. # Constraints: * You are only allowed to use bitwise operations and the previously shown `add_bitwise_operator` function. * No direct multiplication (*) operator is allowed. * Ensure that the solution is efficient in terms of both time and space complexity. # Performance Requirements: * The solution must perform within a reasonable time frame for the given constraints. * Your implementation should aim for the best possible time complexity given the constraints. # Example: * **Input**: `a = 3`, `b = 5` * **Output**: `15` * **Input**: `a = 6`, `b = 7` * **Output**: `42` # Tips: 1. Think about how multiplication can be broken down into a series of addition operations. 2. Use bitwise shift operations to aid in the multiplication process, similar to a \\"shift-and-add\\" method.","solution":"def add_bitwise(a, b): Function to add two integers using only bitwise operations. while b != 0: carry = a & b a = a ^ b b = carry << 1 return a def multiply_bitwise(a: int, b: int) -> int: Multiplies two positive integers using bitwise operations and addition. result = 0 while b != 0: if b & 1: # If the last bit is 1, add `a` to the result result = add_bitwise(result, a) a <<= 1 # Shift `a` to the left by one (equivalent to multiplying by 2) b >>= 1 # Shift `b` to the right by one (equivalent to dividing by 2) return result"},{"question":"# Question: Circular Robot Movement Validator You are given a robot that starts at the origin (0, 0) of a coordinate system. The robot takes a series of steps given by a move string, where each character in the string represents a direction that the robot moves. The valid moves are: * \'U\' for up (increasing the y coordinate by 1) * \'D\' for down (decreasing the y coordinate by 1) * \'L\' for left (decreasing the x coordinate by 1) * \'R\' for right (increasing the x coordinate by 1) Write a function `is_circle(moves: str) -> bool` that returns `True` if the series of moves returns the robot to the origin, and `False` otherwise. Input * `moves` (1 <= len(moves) <= 10^4): A string consisting of the characters \'U\', \'D\', \'L\', \'R\'. Output * `True` if the robot returns to the origin after the move sequence. * `False` otherwise. # Example ```python assert is_circle(\\"UD\\") == True assert is_circle(\\"LL\\") == False assert is_circle(\\"RRDDLU\\") == False assert is_circle(\\"UDLR\\") == True ``` Constraints and Considerations * The function should handle the input within the given constraints efficiently. * Consider edge cases like an empty string, alternating sequence of moves, etc. * Aim for an optimal time complexity of O(n) and a space complexity of O(1). # Context Assume the robot operates in an open field without any obstacles and all moves are discrete and uniform. --- Write your function below this line --- ```python def is_circle(moves: str) -> bool: x, y = 0, 0 for move in moves: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return x == 0 and y == 0 ```","solution":"def is_circle(moves: str) -> bool: x, y = 0, 0 for move in moves: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return x == 0 and y == 0"},{"question":"# **Question:** Implement an Enhanced Trie with Additional Methods **Scenario**: You are tasked with developing an advanced predictive text feature for your company\'s new messaging application. To support autocomplete suggestions, you need to enhance the Trie data structure. Besides the standard insert, search, and startsWith methods, you are required to implement additional methods to delete a word and countWordsWithPrefix. # Requirements: 1. **insert(word: str) -> None**: * Insert a word into the Trie. 2. **search(word: str) -> bool**: * Return `True` if the word exists in the Trie, otherwise return `False`. 3. **starts_with(prefix: str) -> bool**: * Return `True` if there is any word in the Trie that starts with the given prefix, otherwise return `False`. 4. **delete(word: str) -> None**: * Delete a word from the Trie if it exists. Do nothing if the word doesn\'t exist. 5. **count_words_with_prefix(prefix: str) -> int**: * Return the number of words in the Trie that start with the given prefix. **Function Signatures:** ```python class Trie: def __init__(self): # Initialize the Trie def insert(self, word: str) -> None: # Insert a word into the Trie def search(self, word: str) -> bool: # Return True if the word exists in the Trie, otherwise return False def starts_with(self, prefix: str) -> bool: # Return True if there is any word in the Trie # that starts with the given prefix, otherwise return False def delete(self, word: str) -> None: # Delete a word from the Trie if it exists def count_words_with_prefix(self, prefix: str) -> int: # Return the number of words in the Trie # that start with the given prefix ``` # Constraints: * You may assume that all inputs consist of lowercase letters a-z. * Input word or prefix length is in the range [1, 2000]. * The total number of words inserted into the Trie will not exceed 10^6. # Example: ```python trie = Trie() trie.insert(\\"apple\\") print(trie.search(\\"apple\\")) # Output: True print(trie.search(\\"app\\")) # Output: False print(trie.starts_with(\\"app\\")) # Output: True trie.insert(\\"app\\") print(trie.search(\\"app\\")) # Output: True trie.delete(\\"apple\\") print(trie.search(\\"apple\\")) # Output: False print(trie.count_words_with_prefix(\\"app\\")) # Output: 1 ``` **Explanation**: * The first `search(\\"apple\\")` returns `True` because \\"apple\\" was inserted. * The `search(\\"app\\")` returns `False` initially because it was not inserted, but `starts_with(\\"app\\")` returns `True` since \\"apple\\" starts with \\"app\\". * After inserting \\"app\\", `search(\\"app\\")` returns `True`. * The `delete(\\"apple\\")` removes \\"apple\\" from the trie, so `search(\\"apple\\")` returns `False`. * The `count_words_with_prefix(\\"app\\")` returns `1` because only \\"app\\" is left starting with \\"app\\".","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False self.prefix_count = 0 class Trie: def __init__(self): self.root = TrieNode() def _find_node(self, word): node = self.root for char in word: if char in node.children: node = node.children[char] else: return None return node def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.prefix_count += 1 node.is_end_of_word = True def search(self, word: str) -> bool: node = self._find_node(word) return node is not None and node.is_end_of_word def starts_with(self, prefix: str) -> bool: return self._find_node(prefix) is not None def delete(self, word: str) -> None: if not self.search(word): return node = self.root stack = [] for char in word: stack.append((node, char)) node = node.children[char] node.is_end_of_word = False while stack: parent, char = stack.pop() parent.children[char].prefix_count -= 1 if parent.children[char].prefix_count == 0: del parent.children[char] def count_words_with_prefix(self, prefix: str) -> int: node = self._find_node(prefix) if node is None: return 0 return node.prefix_count"},{"question":"# Problem Context You are tasked to implement a simple string encoder and decoder for a messaging system. The goal is to serialize an array of strings into a single string so that it can be transmitted over a network. The receiver should be able to accurately reconstruct the original list of strings from the received encoded string. # Task Write two functions, `encode` and `decode`: 1. `encode` - Accepts a list of strings and returns an encoded string. 2. `decode` - Accepts an encoded string and returns a list of the original strings. # Functions Signature ```python def encode(strs: List[str]) -> str: pass def decode(s: str) -> List[str]: pass ``` # Input - `encode`: A list of strings `strs` (0 <= |strs| <= 10^4, 0 <= |str| <= 10^4 for each string). - `decode`: A single string `s` which is the encoded version of a list of strings. # Output - `encode`: A single string representing the encoded list. - `decode`: A list of strings reconstructed from the encoded string. # Constraints - Do not use any built-in serialization/deserialization libraries. - Ensure to handle special characters and digits in the string properly. # Example ```python # Example 1 strs = [\\"hello\\", \\"world\\"] encoded_string = encode(strs) print(encoded_string) # Output: \\"5:hello5:world\\" print(decode(encoded_string)) # Output: [\\"hello\\", \\"world\\"] # Example 2 strs = [\\"aaa\\", \\"bb\\", \\"c\\"] encoded_string = encode(strs) print(encoded_string) # Output: \\"3:aaa2:bb1:c\\" print(decode(encoded_string)) # Output: [\\"aaa\\", \\"bb\\", \\"c\\"] ``` # Notes - Consider any special characters and ensure they are encoded in a way they can be correctly interpreted during decoding. - Assure that empty input lists and strings are handled correctly in both functions.","solution":"def encode(strs): Encodes a list of strings to a single string. Args: strs (List[str]): The list of strings to encode. Returns: str: The encoded string. encoded_str = \'\' for s in strs: encoded_str += f\'{len(s)}:{s}\' return encoded_str def decode(s): Decodes a single string into a list of strings. Args: s (str): The encoded string. Returns: List[str]: The list of original strings. strs = [] i = 0 while i < len(s): # Find the position of the delimiter j = i while s[j] != \':\': j += 1 # Extract length of the word length = int(s[i:j]) # Extract the word word = s[j+1:j+1+length] strs.append(word) # Move to the next encoded word i = j + 1 + length return strs"},{"question":"# Question Given a word, write a function `generate_abbreviations(word: str) -> List[str]` that returns a list of all possible abbreviations of the given word. For this problem, an abbreviation is defined as replacing any number of non-overlapping and consecutive characters with their count. You must generate all possible abbreviations for the input word. # Input & Output Formats * **Input**: A single string `word` with length between 0 and 20. * **Output**: A list of strings containing all possible abbreviations of the input word. # Constraints & Limitations * The length of `word` will not exceed 20 characters. * The output list does not need to be sorted. # Example **Input**: `\\"word\\"` **Output**: ``` [ \'word\', \'wor1\', \'wo1d\', \'wo2\', \'w1rd\', \'w1r1\', \'w2d\', \'w3\', \'1ord\', \'1or1\', \'1o1d\', \'1o2\', \'2rd\', \'2r1\', \'3d\', \'4\' ] ``` **Edge Case Example** **Input**: `\\"\\"` (empty string) **Output**: ``` [\\"\\"] ``` **Single Character Example** **Input**: `\\"a\\"` **Output**: ``` [\\"a\\", \\"1\\"] ``` # Additional Considerations Be sure your function handles edge cases including: * Empty input * Single character words * Words with repeating characters Your function should be efficient enough to handle the maximum input size comfortably, as the number of abbreviations grows exponentially with the length of the word.","solution":"from typing import List def generate_abbreviations(word: str) -> List[str]: def helper(word, pos, cur, count, result): if pos == len(word): if count > 0: cur += str(count) result.append(cur) else: # Abbreviate this character helper(word, pos + 1, cur, count + 1, result) # Keep this character helper(word, pos + 1, cur + (str(count) if count > 0 else \'\') + word[pos], 0, result) result = [] helper(word, 0, \'\', 0, result) return result"},{"question":"# Linked List Order Verification Problem Statement You are given a singly linked list and need to determine if it is sorted in strictly increasing order. Task Write a function `is_sorted(head)` that accepts the head node of a singly linked list. It should return `True` if the linked list is sorted in increasing order, and `False` otherwise. An empty list should be considered sorted. Requirements 1. The function must handle: - An empty list. - Lists with negative and positive values. - Lists with duplicate values. 2. **Complexity Constraints**: - **Time Complexity**: O(n) - **Space Complexity**: O(1) Input - `head`: A node representing the head of a singly linked list where each node has an integer `val` and reference to the next node (`next`). Output - Return `True` if the linked list is sorted in strictly increasing order, otherwise return `False`. Example ```python # Example 1: Null (Empty list) Input: head = None Output: True # Example 2: Input: head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, None)))) Output: True # Example 3: Input: head = ListNode(1, ListNode(2, ListNode(-1, ListNode(3, None)))) Output: False ``` Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head: ListNode) -> bool: # implementation here pass ``` Ensure that your implementation correctly handles all edge cases and performs efficiently within the given constraints.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head: ListNode) -> bool: if not head: # Empty list is considered sorted return True current = head while current.next: if current.val >= current.next.val: return False current = current.next return True"},{"question":"# Finding the Added Character Context: You are a forensic data analyst trying to determine whether a message has been tampered with. You are provided with two strings: the original message and a potentially compromised message which is the original one with exactly one character added to it. Your task is to identify this additional character. Problem Statement: Write a function `find_difference(s: str, t: str) -> str` that finds and returns the character that was added to string `t`. Both `s` and `t` consist of only lowercase letters, and the length of `t` is exactly one more than the length of `s`. Input: - `s`: A string of lowercase letters (1 <= len(s) <= 10^5). - `t`: A string of lowercase letters (len(t) = len(s) + 1). Output: - A single lowercase letter which is the added character. Constraints: - The input strings contain only lowercase letters. - The length of `t` is exactly one more than the length of `s`. Example: ```python s = \\"abcd\\" t = \\"abecd\\" # Output: \'e\' ``` Function Signature: ```python def find_difference(s: str, t: str) -> str: # Your code here ``` Hints: - Understand the property of the XOR operation. - Consider how XORing the characters in both strings can leave you with the unique character added in `t`. You can make use of the `ord()` function which returns the Unicode code point for a given character in implementing your solution.","solution":"def find_difference(s: str, t: str) -> str: Returns the character that was added to string t compared to string s. # XOR all characters of both strings result = 0 for char in s: result ^= ord(char) for char in t: result ^= ord(char) # Convert the result back to a character return chr(result)"},{"question":"**Scenario**: Imagine you are developing a software tool to analyze chemical compositions and their possible combinations. As part of the tool, you need a functionality to determine the number of ways a particular element\'s atoms (represented by a positive integer) can be split into smaller groups of atoms. **Task**: Implement a function `integer_decomposition(n)` that computes the number of ways a given positive integer `n` can be decomposed into the sum of other positive integers. Function Signature ```python def integer_decomposition(n: int) -> int: ``` # Input * `n` (1 ≤ `n` ≤ 100) - a positive integer denoting the number of atoms. # Output * Returns an integer indicating the number of ways to decompose the given integer into sums of smaller integers. # Constraints * Ensure the function handles the upper limit efficiently. * Use dynamic programming to achieve the solution. # Example 1. Input: `4` Output: `5` Explanation: ``` 4 = 4 4 = 3 + 1 4 = 2 + 2 4 = 2 + 1 + 1 4 = 1 + 1 + 1 + 1 ``` 2. Input: `7` Output: `15` Explanation: ``` 7 = 7 7 = 6 + 1 7 = 5 + 2 7 = 5 + 1 + 1 7 = 4 + 3 7 = 4 + 2 + 1 7 = 4 + 1 + 1 + 1 7 = 3 + 3 + 1 7 = 3 + 2 + 2 7 = 3 + 2 + 1 + 1 7 = 3 + 1 + 1 + 1 + 1 7 = 2 + 2 + 2 + 1 7 = 2 + 2 + 1 + 1 + 1 7 = 2 + 1 + 1 + 1 + 1 + 1 7 = 1 + 1 + 1 + 1 + 1 + 1 + 1 ``` # Notes * Consider utilizing a 2-dimensional array or a similar data structure to store intermediate results. * Focus on handling space and time efficiently within the provided constraints.","solution":"def integer_decomposition(n: int) -> int: Return the number of ways to decompose the given integer into sums of smaller integers. dp = [[0 for _ in range(n + 1)] for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = 1 for i in range(1, n + 1): for j in range(1, n + 1): if j - i >= 0: dp[i][j] = dp[i-1][j] + dp[i][j - i] else: dp[i][j] = dp[i-1][j] return dp[n][n]"},{"question":"# Background You are working with numerical systems and need to convert integers to different base representations and vice versa. Given the constraints of your project, you need to write functions from scratch, handling bases spanning from binary (base 2) to alphanumeric (base 36). # Problem Statement Implement two functions: 1. **`int_to_base(num, base)`**: converts an integer into its string representation in a given base. 2. **`base_to_int(str_to_convert, base)`**: converts a string in a given base back to its decimal integer representation. # Function Specifications: `int_to_base(num, base)` * **Input:** * `num` (integer): The integer to be converted. (-10^9 <= num <= 10^9) * `base` (integer): The base for conversion. (2 <= base <= 36) * **Output:** * A string representing the given integer in the specified base. For negative numbers, the string should have a \'-\' prefix. `base_to_int(str_to_convert, base)` * **Input:** * `str_to_convert` (string): The string representation of the number in the given base. * `base` (integer): The base of the number. (2 <= base <= 36) * **Output:** * An integer that is the decimal representation of the input string. # Constraints - Do not use any built-in functions for base conversion. - Ensure correct handling of edge cases such as zero, negative values, and invalid base ranges. # Example ```python assert int_to_base(5, 2) == \'101\' assert int_to_base(-15, 16) == \'-F\' assert base_to_int(\'101\', 2) == 5 assert base_to_int(\'-F\', 16) == -15 ``` Write your implementations for `int_to_base` and `base_to_int` below: ```python def int_to_base(num, base): # Your code here def base_to_int(str_to_convert, base): # Your code here ```","solution":"def int_to_base(num, base): if not (2 <= base <= 36): raise ValueError(\\"Base must be between 2 and 36 (inclusive)\\") chars = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" if num == 0: return \\"0\\" sign = \\"-\\" if num < 0 else \\"\\" num = abs(num) result = [] while num > 0: result.append(chars[num % base]) num //= base return sign + \\"\\".join(reversed(result)) def base_to_int(str_to_convert, base): if not (2 <= base <= 36): raise ValueError(\\"Base must be between 2 and 36 (inclusive)\\") chars = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" str_to_convert = str_to_convert.upper() sign = -1 if str_to_convert[0] == \'-\' else 1 str_to_convert = str_to_convert.lstrip(\'-\') num = 0 for char in str_to_convert: num = num * base + chars.index(char) return sign * num"},{"question":"# In-order Traversal of a Binary Tree **Scenario**: You are tasked with implementing an in-order traversal for a binary tree. This task is common in operations involving binary trees such as sorting and evaluating expressions from syntax trees. The traversal should return a list of node values in in-order sequence. # Function Details Implement the following function: ```python def in_order_traversal(root): Perform in-order traversal of a binary tree. :param root: Node, the root of the binary tree :return: List[int], the list of node values in in-order sequence pass ``` # Input * `root`: The root node of the binary tree. Each node contains: * `val` (int): The node\'s value. * `left` (Node): Reference to the left child node. * `right` (Node): Reference to the right child node. # Output * Return a list of integers representing the nodes visited in in-order sequence. # Constraints * The number of nodes in the binary tree is in the range [0, 10000]. * Values of the node\'s val will be in the range [0, 100000]. # Requirements 1. Ensure the solution adheres to the O(n) time complexity. 2. Handle all possible edge cases such as empty trees. # Example ```python class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example Tree: # 4 # / # 2 6 # / / # 1 3 5 7 root = Node(4) root.left = Node(2, Node(1), Node(3)) root.right = Node(6, Node(5), Node(7)) assert in_order_traversal(root) == [1, 2, 3, 4, 5, 6, 7] ``` # Notes Ensure to handle `None` nodes and deep recursion effectively. Consider both recursive and iterative implementations for a well-rounded understanding.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def in_order_traversal(root): Perform in-order traversal of a binary tree. :param root: Node, the root of the binary tree :return: List[int], the list of node values in in-order sequence result = [] def helper(node): if node: helper(node.left) result.append(node.val) helper(node.right) helper(root) return result"},{"question":"# Merge Sorted Linked Lists You are given two linked lists, each containing a sorted sequence of integers. Your task is to merge these two linked lists into one sorted linked list and return the head of the new list. Function Signature ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def merge_sorted_lists(l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]: # Implement this function ``` Input Format * `l1` and `l2` are the heads of two singly-linked lists. Both lists are sorted in non-decreasing order. * Each ListNode contains: * `value`: An integer value (can be negative). * `next`: A pointer/reference to the next ListNode or None. Output Format * Return the head of the merged singly-linked list which remains sorted in non-decreasing order. Constraints * Both linked lists can be empty, in which case, return None. * The elements of the linked lists are integers with no specific constraints on their values. Performance Requirements * The implementation should run in O(n + m) time complexity where n and m are the lengths of the input lists. * It should use O(1) additional space, if possible. Example ```python # Given the linked lists: # l1: 1 -> 3 -> 5 # l2: 2 -> 4 -> 6 # The merged list should be: # merged: 1 -> 2 -> 3 -> 4 -> 5 -> 6 l1 = ListNode(1, ListNode(3, ListNode(5))) l2 = ListNode(2, ListNode(4, ListNode(6))) merged_head = merge_sorted_lists(l1, l2) # Expected output: A new linked list with values 1 -> 2 -> 3 -> 4 -> 5 -> 6 ``` Explanation In the above example, two sorted linked lists (1 -> 3 -> 5 and 2 -> 4 -> 6) are merged into a single sorted linked list (1 -> 2 -> 3 -> 4 -> 5 -> 6).","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def merge_sorted_lists(l1, l2): dummy = ListNode() tail = dummy while l1 and l2: if l1.value < l2.value: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next if l1: tail.next = l1 if l2: tail.next = l2 return dummy.next"},{"question":"Scenario You are developing a tool to help digital forensics investigators quickly identify an additional file that appears in a directory listing, which may indicate a recently added suspect file. Although the tool\'s primary focus is on digital files, you start with a simpler problem involving character strings to prototype the core algorithm. Problem Statement Write a function `find_difference(s: str, t: str) -> str` that takes two strings `s` and `t` as arguments. String `t` is generated by randomly shuffling string `s` and then adding one more letter at a random position. Your task is to find the letter that was added in string `t`. # Function Signature ```python def find_difference(s: str, t: str) -> str: # Your code here ``` # Input - `s` (str): A string containing only lowercase English letters (length 0 ≤ len(s) ≤ 10^5). - `t` (str): A string containing only lowercase English letters (length len(s) + 1). # Output - Return a single character that was added to string `t`. # Constraints - It is guaranteed that `t` is a random shuffle of `s` with one additional character. # Example ```python s = \\"abcd\\" t = \\"abecd\\" # Output: \'e\' ``` # Performance Requirements - The solution should run in (O(n)) time complexity and use (O(1)) additional space. # Hint Utilize the properties of the XOR bitwise operator to identify the unique character.","solution":"def find_difference(s: str, t: str) -> str: Returns the single character that was added to string `t`. xor_sum = 0 for char in s: xor_sum ^= ord(char) for char in t: xor_sum ^= ord(char) return chr(xor_sum)"},{"question":"# Question: Flooding Distance Propagation You are given a ( m times n ) grid initialized with the following values: - `-1`: A wall or an obstacle. - `0`: A gate. - `INF`: Infinity (2147483647) means an empty room. You may assume that the distance to a gate is less than this value. Write a function `walls_and_gates(rooms)` that fills each empty room with the distance to its nearest gate. If it is impossible to reach a gate, the room should remain filled with `INF`. Function Signature: ```python def walls_and_gates(rooms: List[List[int]]) -> None: pass ``` Input - `rooms`: A 2D list where `rooms[i][j]` represents the state of the cell (either `-1`, `0`, or `INF`). - The length of `rooms` (number of rows) and the length of `rooms[0]` (number of columns) are within the range ([1, 10^4]). Output - The function should modify the `rooms` grid in place. Constraints - You may not use built-in functions that directly solve the problem. Example Given the grid: ``` INF -1 0 INF INF INF INF -1 INF -1 INF -1 0 -1 INF INF ``` After running your function, the grid should be: ``` 3 -1 0 1 2 2 1 -1 1 -1 2 -1 0 -1 3 4 ``` Hints 1. Think about how you can efficiently propagate the distances from all gates simultaneously. 2. Consider alternative graph traversal algorithms if necessary.","solution":"from collections import deque from typing import List def walls_and_gates(rooms: List[List[int]]) -> None: if not rooms: return INF = 2147483647 m, n = len(rooms), len(rooms[0]) queue = deque() # Enqueue all gates (0) positions for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) # Directions array for moving up, down, left, right directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: x, y = queue.popleft() for dx, dy in directions: new_x, new_y = x + dx, y + dy if 0 <= new_x < m and 0 <= new_y < n and rooms[new_x][new_y] == INF: rooms[new_x][new_y] = rooms[x][y] + 1 queue.append((new_x, new_y))"},{"question":"In statistical analysis, it\'s often useful to remove outliers to get a more accurate measure of central tendency. Write a function `trimmean` in Python that computes the trimmed mean of an array of integers. This function should discard a specified percentage of the highest and lowest values before calculating the mean of the remaining values. # Function Definition ```python def trimmean(arr: List[int], per: int) -> float: pass ``` # Input - `arr`: A list of integers `(1 <= len(arr) <= 10^5)`. - `per`: An integer indicating the percentage of values to remove from both the high and low ends of the array `(0 <= per <= 100)`. # Output - Returns the trimmed mean as a floating-point number. # Constraints - The elements of `arr` are bounded by `-10^5 <= arr[i] <= 10^5`. - The function should have a time complexity of `O(n log n)` or better due to necessary sorting. # Example ```python print(trimmean([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 20)) # Output: 5.5 print(trimmean([6, 2, 4, 8, 10, -3, -1, 5], 25)) # Output: 4.5 ``` # Explanation 1. In the first example, 20% of the elements are removed from both ends, leaving `[3, 4, 5, 6, 7, 8]`. The mean of these values is 5.5. 2. In the second example, 25% of the elements are removed from both ends, leaving `[2, 4, 5, 6]`. The mean of these values is 4.25. # Edge Cases - If `per` is 0, the trimmed mean is just the regular mean of the entire array. - If `per` is 100, handle gracefully (e.g., return 0 or some default mean).","solution":"from typing import List def trimmean(arr: List[int], per: int) -> float: Calculate the trimmed mean of the array after removing a specified percentage of the highest and lowest values. :param arr: List of integers. :param per: Integer representing the percentage of elements to remove from both ends of the array. :return: Floating point number representing the trimmed mean. if not arr: return 0.0 n = len(arr) remove_count = (per * n) // 100 # If the per is 100, we remove all elements. This can be handled by returning 0. if remove_count * 2 >= n: return 0.0 # Sort the array sorted_arr = sorted(arr) # Compute the trimmed array trimmed_arr = sorted_arr[remove_count:n-remove_count] # Calculate the mean of the trimmed array trimmed_mean = sum(trimmed_arr) / len(trimmed_arr) return trimmed_mean"},{"question":"# Binary Tree Path Enumeration You are given the root node of a binary tree. Write a function that enumerates all root-to-leaf paths and returns them as a list of strings. # Requirements 1. **Function Signature**: `def binary_tree_paths(root):` 2. **Input**: - `root`: The root node of a binary tree. Each node contains an integer value, and a binary tree is defined using the `TreeNode` class. 3. **Output**: - A list of strings, where each string represents a path from the root to a leaf in the format \\"node1->node2->...->nodeN\\". # Constraints - The number of nodes in the tree does not exceed 1000. - Node values are integers. # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example tree # 1 # / # 2 3 # # 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(5) print(binary_tree_paths(root)) # Output: [\\"1->2->5\\", \\"1->3\\"] ``` # Scenario Imagine you are developing a system for storing and retrieving routes in a navigation app. Each intersection and pathway in the route is represented as a node in a binary tree. You need a function to list all possible navigation routes from the starting point (root) to the destination (leaves). # Notes 1. A leaf is a node with no children. 2. Each path should start with the root node value and end with a leaf node value.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): Returns all root-to-leaf paths in the binary tree. :param root: TreeNode, the root of the binary tree :return: List of strings, each representing a path def construct_paths(node, path): if node: path += str(node.val) if not node.left and not node.right: # if leaf node paths.append(path) else: path += \\"->\\" # extend the current path construct_paths(node.left, path) construct_paths(node.right, path) paths = [] construct_paths(root, \\"\\") return paths"},{"question":"You are given the task of implementing a function to calculate the binomial coefficient ( C(n, k) ), also known as \\"n choose k\\", using a bottom-up dynamic programming approach. This version should address the limitations of deep recursion by storing intermediate results iteratively. # Function Signature ```python def dynamic_binomial_coefficient(n: int, k: int) -> int: Calculate the binomial coefficient, C(n, k), with non-recursive dynamic programming approach. Parameters: n (int): Number of elements in the set (n >= 0). k (int): Number of elements to choose (0 <= k <= n). Returns: int: The binomial coefficient C(n, k). Raises: ValueError: If k > n. Example: >>> dynamic_binomial_coefficient(5, 0) 1 >>> dynamic_binomial_coefficient(8, 2) 28 >>> dynamic_binomial_coefficient(500, 300) 5054949849935535817667719165973249533761635252733275327088189563256013971725761702359997954491403585396607971745777019273390505201262259748208640 ``` # Description * **Input**: * `n` (int): A non-negative integer representing the total number of elements in the set. * `k` (int): A non-negative integer representing the number of elements to choose. * **Output**: * An integer representing the binomial coefficient ( C(n, k) ). * **Constraints**: * ( 0 leq k leq n ) * ( n geq 0 ) * **Performance Requirements**: * Optimize for large values of n and k using a bottom-up dynamic programming approach to prevent excessive memory use and redundant calculations. # Implement dynamic_binomial_coefficient function and ensure it passes the given examples.","solution":"def dynamic_binomial_coefficient(n: int, k: int) -> int: Calculate the binomial coefficient, C(n, k), with non-recursive dynamic programming approach. Parameters: n (int): Number of elements in the set (n >= 0). k (int): Number of elements to choose (0 <= k <= n). Returns: int: The binomial coefficient C(n, k). Raises: ValueError: If k > n. if k > n: raise ValueError(\\"k cannot be greater than n\\") # Take advantage of the symmetry property C(n, k) = C(n, n-k) # to minimize the number of computations k = min(k, n - k) # Create a list to store intermediate results C = [0] * (k + 1) # nC0 is always 1 C[0] = 1 # Calculate the binomial coefficient in a bottom-up manner for i in range(1, n + 1): # Calculate next row of pascal triangle using the previous row # Go backward to prevent overwriting the array elements that we need to use for j in range(min(i, k), 0, -1): C[j] = C[j] + C[j - 1] return C[k]"},{"question":"Context You are developing a new sorting feature for a management system that handles small to medium-sized datasets. To ensure stability and simplicity, you have decided to use the Bubble Sort algorithm. However, you want to enhance the existing implementation to make it more useful for debugging purposes by including a feature to output each swap and step. Task Implement an enhanced bubble sort function `enhanced_bubble_sort(arr, detailed=False)` which sorts the array in ascending order. If `detailed` is set to `True`, the function should output detailed information about the sorting process, including each swap and iteration step. Your function should handle common edge cases and perform the sorting efficiently. Function Signature ```python def enhanced_bubble_sort(arr: List[int], detailed: bool = False) -> List[int]: ``` Input - `arr` (List[int]): A list of integers to be sorted. - `detailed` (bool, optional): If set to `True`, output each swap and iteration details during the sort process. Default is `False`. Output - Returns the sorted list of integers. Constraints - You may assume that `arr` can contain up to 10^3 elements. - All elements in `arr` are integers within the range -10^6 to 10^6. Example ```python arr = [5, 1, 4, 2, 8] print(enhanced_bubble_sort(arr, detailed=True)) ``` Expected Output (if detailed is True) ``` Initial array: [5, 1, 4, 2, 8] Iteration 1: 1 5 4 2 8 Swap elements at positions 0 and 1: [1, 5, 4, 2, 8] Iteration 1: 1 4 5 2 8 Swap elements at positions 2 and 3: [1, 4, 2, 5, 8] Iteration 1: 1 4 2 5 8 Swap elements at positions 1 and 2: [1, 2, 4, 5, 8] Iteration 2: 1 2 4 5 8 Final sorted array: [1, 2, 4, 5, 8] ``` Ensure your implementation handles edge cases effectively and performs within the constraints. Include any optimizations that can improve the algorithm\'s performance, especially for already sorted input arrays.","solution":"from typing import List def enhanced_bubble_sort(arr: List[int], detailed: bool = False) -> List[int]: n = len(arr) if detailed: print(f\\"Initial array: {arr}\\") for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if detailed: print(f\\"Swap elements at positions {j} and {j+1}: {arr}\\") if detailed: print(f\\"Iteration {i+1}: {arr}\\") if not swapped: break if detailed: print(f\\"Final sorted array: {arr}\\") return arr"},{"question":"# Coding Challenge Scenario You are tasked with creating a function that processes a list of words and a list of symbols. The goal is to find the longest matching symbol in each word and enclose that symbol in square brackets. If a word matches multiple symbols of the same length, the first occurrence should be considered. Function Signature ```python def annotate_words_with_symbols(words: List[str], symbols: List[str]) -> List[str]: Annotate given words with the longest matching symbols surrounded by square brackets. :param words: List of words to be processed. :param symbols: List of symbols to match within words. :return: List of words with matched symbols enclosed in square brackets. ``` Input - `words`: Array of strings (1 ≤ length ≤ 1000) - `symbols`: Array of strings (1 ≤ length ≤ 100), where each symbol can have variable lengths but at most 100 characters. Output - List of words with the longest matched symbol enclosed in square brackets. Examples ```python words = [\\"Amazon\\", \\"Microsoft\\", \\"Google\\"] symbols = [\\"i\\", \\"Am\\", \\"cro\\", \\"Na\\", \\"le\\", \\"abc\\"] assert annotate_words_with_symbols(words, symbols) == [\\"[Am]azon\\", \\"Mi[cro]soft\\", \\"Goog[le]\\"] ``` Constraints - A symbol can be matched in multiple words. - If a word contains multiple matching symbols, choose the longest one. - If multiple symbols of the same length match, choose the first one encountered in the list of symbols. Performance Requirements - Your algorithm should aim for efficiency in both time and space complexities.","solution":"from typing import List def annotate_words_with_symbols(words: List[str], symbols: List[str]) -> List[str]: Annotate given words with the longest matching symbols surrounded by square brackets. :param words: List of words to be processed. :param symbols: List of symbols to match within words. :return: List of words with matched symbols enclosed in square brackets. annotated_words = [] for word in words: longest_match = \\"\\" for symbol in symbols: if symbol in word: # Check if the symbol is longer than the current longest match if len(symbol) > len(longest_match): longest_match = symbol # Replace the first occurrence of the longest match with that match in brackets if longest_match: word = word.replace(longest_match, f\\"[{longest_match}]\\", 1) annotated_words.append(word) return annotated_words"},{"question":"# Magic Number Check **Objective**: Write a function `magic_number` that returns `True` if a number is a magic number, and `False` otherwise. A magic number is a number which when repeatedly summing the digits results in a single digit 1. **Function Signature**: ```python def magic_number(n: int) -> bool: pass ``` **Input**: - A single integer `n` where `0 <= n <= 10^9`. **Output**: - A boolean value `True` if `n` is a magic number, otherwise `False`. **Example**: ```python magic_number(50113) # returns True magic_number(1234) # returns True magic_number(199) # returns True magic_number(111) # returns False ``` **Constraints**: - The number `n` will be a whole number. - Must handle edge cases such as single digits directly and large numbers within the range. **Performance Requirement**: - The implementation must handle the worst case efficiently under the given constraints. **Scenario**: Imagine you are developing a feature for a mathematical app that evaluates interesting properties of numbers. One of the features is to detect \\"magic numbers.\\" You\'ve been tasked to implement this feature so that users can input any number up to one billion, and it will check if it\'s a magic number. **Instructions**: Implement the function following the above specifications and ensure it passes all the provided example cases, and you consider edge cases and performance constraints.","solution":"def magic_number(n: int) -> bool: Returns True if a number is a magic number, otherwise False. A magic number is a number which when repeatedly summing the digits results in a single digit 1. # Function to calculate the sum of digits of a number def sum_of_digits(num: int) -> int: return sum(int(digit) for digit in str(num)) while n >= 10: # Repeat until we get a single digit number n = sum_of_digits(n) return n == 1"},{"question":"# Question Title: Counting \'1\' Bits Using Brian Kernighan\'s Algorithm Problem Statement: Write a function `count_one_bits` that takes an unsigned integer and returns the number of \'1\' bits (also known as the Hamming weight) it has. Use Brian Kernighan\'s algorithm for the implementation. Given two implementations below, one in a recursive manner and another iteratively, write the iterative solution which is more efficient in terms of space complexity. Input: - An unsigned integer `n` (0 <= n <= 2^32 - 1). Output: - An integer representing the number of \'1\' bits in the binary representation of the input integer. Examples: ``` Example 1: Input: n = 11 (Binary: 00000000000000000000000000001011) Output: 3 Example 2: Input: n = 128 (Binary: 00000000000000000000000010000000) Output: 1 Example 3: Input: n = 0 (Binary: 00000000000000000000000000000000) Output: 0 ``` Constraints: - The function should handle large inputs efficiently. - Return the count of \'1\' bits accurately. - Aim for a solution with O(k) time complexity and O(1) space complexity using the iterative method. Function Signature: ```python def count_one_bits(n: int) -> int: # Your code here ``` Notes: - You may assume the input to be non-negative and within the specified range of an unsigned 32-bit integer. - Focus on the iterative solution to avoid recursion depth issues.","solution":"def count_one_bits(n: int) -> int: Returns the number of \'1\' bits in the binary representation of the given unsigned integer using Brian Kernighan\'s algorithm. count = 0 while n: n &= n - 1 # Drop the lowest set bit count += 1 return count"},{"question":"# Run-Length Encoding Decoder Enhancements Objective Enhance the `decode_rle` function so that it can handle erroneous or malformed input strings gracefully. The enhanced function should retain the original behavior for correctly formatted input and raise appropriate errors or handle erroneous cases explicitly. Problem Statement You are provided with a function `decode_rle` that takes a string encoded with run-length encoding and returns the original string. You need to extend this function so it can handle edge cases where the input does not conform to a valid RLE format. Requirements 1. The input to `decode_rle` is a string that follows the run-length encoding format. 2. The function should: * Raise a `ValueError` exception if it encounters any improperly formatted portion in the input string. * Retain existing functionality for correctly formatted input strings. 3. Formatted string examples that the function should correctly decode: * \\"2a3b4c1d\\" -> \\"aabbbccccd\\" * \\"10x\\" -> \\"xxxxxxxxxx\\" 4. Malformed string examples that you need to handle: * \\"2a3b4\\" (missing character after the last count). * \\"a3b\\" (count missing before a character). Function Signature ```python def decode_rle(input: str) -> str: Decodes a run-length encoded string. :param input: str - A string in RLE format. :return: str - The decoded string. :raises ValueError: if the input string is malformed. pass ``` Constraints * The input string can contain any printable ASCII characters. * The counts in the input string are positive integers and can be multi-digit. Example ```python # Valid input print(decode_rle(\\"3a2b4c\\")) # Output: \\"aaabbcccc\\" # Malformed input print(decode_rle(\\"3a2b4\\")) # Raises ValueError: Malformed input string. print(decode_rle(\\"a2b\\")) # Raises ValueError: Malformed input string. ``` Implement the `decode_rle` function that adheres to the above specifications.","solution":"def decode_rle(input: str) -> str: Decodes a run-length encoded string. :param input: str - A string in RLE format. :return: str - The decoded string. :raises ValueError: if the input string is malformed. if not input: return \\"\\" result = [] i = 0 while i < len(input): if not input[i].isdigit(): raise ValueError(\\"Malformed input string: expected digit at position {}\\".format(i)) # Extract number num_start = i while i < len(input) and input[i].isdigit(): i += 1 if i == len(input) or not input[i].isalpha(): raise ValueError(\\"Malformed input string: expected character after number at position {}\\".format(i)) num = int(input[num_start:i]) char = input[i] result.append(char * num) i += 1 return \'\'.join(result)"},{"question":"You are given an array of words and an array of symbols. Your task is to bracket the longest matching symbol within each word. If the word contains more than one symbol, you must choose the one with the longest length. # Input 1. An array of strings `words`, where `1 <= words.length <= 1000` and `1 <= words[i].length <= 100`. 2. An array of strings `symbols`, where `1 <= symbols.length <= 100` and `1 <= symbols[j].length <= 50`. # Output Return an array of strings, where each word has its matching symbol bracketed. If no matching symbol is found in a word, the word remains unchanged. # Constraints - Only the longest match for each word should be bracketed. - Case sensitivity should be considered for matching. # Example Input ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] ``` Output ```python [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` # Instructions: 1. Write a function `match_symbols(words: List[str], symbols: List[str]) -> List[str]` that implements the above requirements. 2. Optimize your function for time and space complexities. 3. Consider edge cases with overlapping symbols and words with no matches.","solution":"from typing import List def match_symbols(words: List[str], symbols: List[str]) -> List[str]: result = [] for word in words: longest_symbol = \\"\\" for symbol in symbols: if symbol in word and len(symbol) > len(longest_symbol): longest_symbol = symbol if longest_symbol: word = word.replace(longest_symbol, f\\"[{longest_symbol}]\\") result.append(word) return result"},{"question":"You have been tasked to implement cosine similarity calculation between two vectors in a machine learning pre-processing pipeline. This involves comparing two vectors to measure how similar they are to each other. Cosine similarity is often used in text mining to compare documents or in collaborative filtering for recommender systems. # Function Signature ```python def cosine_similarity(vec1: list, vec2: list) -> float: pass ``` # Input - `vec1`: A list of floats representing the first vector. (1 <= len(vec1) <= 10^5) - `vec2`: A list of floats representing the second vector. (1 <= len(vec2) <= 10^5) # Output - A float value representing the cosine similarity between the two vectors. # Constraints - Both vectors must be of the same length. If they are not, raise a `ValueError` with a descriptive message. - The similarity measure should account for the possibility of zero elements within the vectors. # Examples Example 1: ```python # Input vec1 = [1, 1, 1] vec2 = [1, 2, -1] # Output 0.47140452079103173 ``` Example 2: ```python # Input vec1 = [0, 0, 0] vec2 = [1, 2, 3] # Output raise ValueError(\\"The L2 norm of at least one vector is zero, causing a division by zero error.\\") ``` # Notes 1. The function should handle large vectors efficiently. 2. Be mindful of performance and computational overhead as you may encounter vectors with lengths up to 100,000. 3. Consider implementing helper functions to keep the main function clean and readable. # Hint The cosine similarity between two vectors is computed as follows: [ text{cosine similarity} = frac{A cdot B}{||A|| cdot ||B||} ] where (A cdot B) is the dot product of vectors A and B, and (||A||) and (||B||) are the L2 norms of vectors A and B, respectively.","solution":"import math def cosine_similarity(vec1, vec2): Calculate cosine similarity between two vectors. Parameters: vec1 (list of float): The first vector. vec2 (list of float): The second vector. Returns: float: The cosine similarity between vec1 and vec2. if len(vec1) != len(vec2): raise ValueError(\\"Both vectors must be of the same length.\\") dot_product = sum(a*b for a, b in zip(vec1, vec2)) norm_vec1 = math.sqrt(sum(a*a for a in vec1)) norm_vec2 = math.sqrt(sum(b*b for b in vec2)) if norm_vec1 == 0 or norm_vec2 == 0: raise ValueError(\\"The L2 norm of at least one vector is zero, causing a division by zero error.\\") return dot_product / (norm_vec1 * norm_vec2)"},{"question":"**Run-Length Encoding/Decoding** Run-length encoding (RLE) is a simple form of data compression where consecutive elements are replaced with a count and a value. For example, `AAAABBBCCDAA` becomes `4A3B2C1D2A`. Decoding this string would bring it back to its original form: `AAAABBBCCDAA`. Implement two functions, `encode_rle` and `decode_rle`, following the given specifications. Function Specifications 1. **`encode_rle(input: str) -> str`**: - **Input**: A string `input` containing the data to be compressed. - **Output**: A string representing the run-length encoded data. 2. **`decode_rle(input: str) -> str`**: - **Input**: A string `input` containing the run-length encoded data. - **Output**: A string representing the decompressed data. Constraints - All input strings will be non-empty and will only contain uppercase English letters (A-Z). - The encoded string for decoding will follow the correct format, i.e., pairs of counts followed by characters. Examples **Example 1**: - `encode_rle(\\"AAAABBBCCDAA\\")` -> `\'4A3B2C1D2A\'` - `decode_rle(\\"4A3B2C1D2A\\")` -> `\'AAAABBBCCDAA\'` **Example 2**: - `encode_rle(\\"AABBBCCCC\\")` -> `\'2A3B4C\'` - `decode_rle(\\"2A3B4C\\")` -> `\'AABBBCCCC\'` **Example 3**: - `encode_rle(\\"ABCD\\")` -> `\'1A1B1C1D\'` - `decode_rle(\\"1A1B1C1D\\")` -> `\'ABCD\'` Notes - Be attentive to edge cases like the string \\"A\\" (which should encode to \\"1A\\") or \\"AAAAAAAAAAAA\\" (which should encode to \\"12A\\"). - Ensure that your implementation handles the entire range of provided constraints and formats correctly.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded_str = \\"\\" count = 1 prev_char = input[0] for char in input[1:]: if char == prev_char: count += 1 else: encoded_str += f\\"{count}{prev_char}\\" count = 1 prev_char = char encoded_str += f\\"{count}{prev_char}\\" return encoded_str def decode_rle(input: str) -> str: decoded_str = \\"\\" i = 0 while i < len(input): count_str = \\"\\" while input[i].isdigit(): count_str += input[i] i += 1 count = int(count_str) char = input[i] decoded_str += char * count i += 1 return decoded_str"},{"question":"**Determine Path Availability in a Directed Graph** You are given a directed graph, and your task is to determine if there exists a path between two nodes. You are expected to utilize the Depth First Search (DFS) algorithm to solve this problem. Implement a function `is_path_available` that takes the following parameters: 1. `vertex_count` (int): The number of vertices in the graph. 2. `edges` (List[Tuple[int, int]]): A list of directed edges where each edge is represented as a tuple (`source`, `target`). 3. `source` (int): The source vertex. 4. `target` (int): The target vertex. The function should return a boolean value indicating whether there is a path from `source` to `target`. # Input Format ```plaintext - An integer vertex_count, representing the number of vertices. - A list of tuples edges, where each tuple (u, v) represents a directed edge from vertex u to vertex v. - An integer source, representing the starting vertex. - An integer target, representing the end vertex. ``` # Output Format ```plaintext - A boolean value (True or False), indicating whether a path exists from source to target. ``` # Constraints - 1 <= vertex_count <= 10^5 - 0 <= number of edges <= 10^5 - 0 <= source, target < vertex_count # Examples **Example 1:** ```python vertex_count = 4 edges = [(0, 1), (1, 2), (2, 3), (3, 0)] source = 0 target = 3 is_path_available(vertex_count, edges, source, target) ``` Output: `True` **Example 2:** ```python vertex_count = 4 edges = [(0, 1), (1, 2), (2, 3)] source = 3 target = 0 is_path_available(vertex_count, edges, source, target) ``` Output: `False` # Requirements & Guidelines 1. Use Depth First Search (DFS) for determining the path. 2. Ensure that your implementation is efficient and can handle large inputs within the given constraints. 3. Handle all edge cases including isolated nodes and cyclic graphs. # Additional Notes - Avoid utilizing global variables. Encapsulate your logic within the function `is_path_available`. - Write clean, readable, and well-commented code.","solution":"def is_path_available(vertex_count, edges, source, target): Determines if there is a path from `source` to `target` in a directed graph. :param vertex_count: Number of vertices in the graph. :param edges: List of directed edges represented as tuples (source, target). :param source: The starting vertex. :param target: The end vertex. :return: True if there is a path from source to target, False otherwise. # Create an adjacency list from the edges adj_list = [[] for _ in range(vertex_count)] for u, v in edges: adj_list[u].append(v) # Initialize a set to keep track of visited vertices visited = set() def dfs(v): Helper function to perform DFS. if v == target: return True if v in visited: return False visited.add(v) for neighbor in adj_list[v]: if dfs(neighbor): return True return False # Start DFS from the source vertex return dfs(source)"},{"question":"# Scenario: You are developing a diagnostics tool to analyze binary data sequences. Given an integer represented in its binary form, it is possible to flip exactly one bit in the sequence (from 0 to 1). Your task is to find the maximum length of consecutive \'1s\' that can be obtained by flipping one bit in the binary representation of the number. # Function Signature: ```python def flip_bit_longest_seq(num: int) -> int: pass ``` # Input: - A single integer `num` where `0 <= num <= 2^31 - 1`. # Output: - An integer representing the maximum length of consecutive \'1s\' after flipping exactly one bit from 0 to 1. # Constraints: - You must flip exactly one bit. - The function should handle edge cases gracefully. # Example: Example 1: ```plaintext Input: 1775 (Binary: 11011101111) Output: 8 Explanation: By flipping the second zero from the right, we get the sequence 11011111111 which has 8 consecutive \'1\'s. ``` Example 2: ```plaintext Input: 0 Output: 1 Explanation: By flipping the only zero bit to a one, we get the sequence \'1\' which has 1 consecutive \'1\'. ``` # Notes: - Consider different binary structures, including continuous blocks of \'1\'s separated by a single \'0\', or multiple blocks. - Edge cases must be managed within the defined constraints, especially considering integers at the boundary limits.","solution":"def flip_bit_longest_seq(num: int) -> int: Returns the maximum length of consecutive \'1s\' that can be obtained by flipping exactly one bit (0 to 1) in the binary representation of the given integer `num`. # Convert number to binary and strip leading \'0b\' binary = bin(num)[2:] # Keep track of the max length of ones max_length = 0 # Split the binary number by \'0\'s, which will give blocks of consecutive \'1\'s blocks = binary.split(\'0\') # Edge case: if there is no \'0\' in the binary representation if \'0\' not in binary: return len(binary) + 1 # Check the length of 1s in each block and consider merging by flipping one \'0\' for i in range(len(blocks)): # The length of current block current_block_length = len(blocks[i]) # If there are adjacent blocks of 1s separated by one 0, consider flipping that 0 if i < len(blocks) - 1: next_block_length = len(blocks[i + 1]) max_length = max(max_length, current_block_length + next_block_length + 1) else: max_length = max(max_length, current_block_length + 1) return max_length"},{"question":"You are given an array of integers and the task is to implement a function that sorts the given array using the Bucket Sort algorithm. However, within each bucket, use the Quick Sort algorithm instead of Insertion Sort to improve the performance. # Function Signature ```python def bucket_sort(arr: List[int]) -> List[int]: ``` # Input: - A list of integers `arr` where (1 leq len(arr) leq 10^5) and (0 leq arr[i] leq 10^6). # Output: - A sorted list of integers. # Constraints: - You need to use bucket sort for sorting the elements. - Quick Sort should be used for sorting elements within each bucket to improve the performance. # Example: ```python # Input arr = [4, 1, 7, 3, 5, 2, 6, 8] # Output [1, 2, 3, 4, 5, 6, 7, 8] ``` # Hints: 1. Calculate an appropriate number of buckets based on the input size. 2. Ensure correct implementation of Quick Sort to handle the sorting within each bucket. 3. Take edge cases into consideration, such as empty input array and arrays with repeated single values. # Performance Requirements: - Aim for an average time complexity of (O(n log n)) with careful bucket and sorting implementation.","solution":"from typing import List def quick_sort(arr: List[int]) -> List[int]: Helper function to perform Quick Sort. if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right) def bucket_sort(arr: List[int]) -> List[int]: Function to perform Bucket Sort with Quick Sort inside each bucket. if len(arr) == 0: return arr min_value = min(arr) max_value = max(arr) bucket_count = len(arr) # Initialize buckets buckets = [[] for _ in range(bucket_count)] # Distribute elements into buckets for num in arr: # Calculate appropriate bucket index if max_value - min_value == 0: # to avoid division by zero index = 0 else: index = (num - min_value) * (bucket_count - 1) // (max_value - min_value) buckets[index].append(num) # Sort each bucket and concatenate the result sorted_array = [] for bucket in buckets: sorted_array.extend(quick_sort(bucket)) return sorted_array"},{"question":"# Context You are working on a cross-platform application that needs to send and receive multi-byte integer data. Depending on the platform, the byte order (endianness) may vary. You need to implement endianness conversion functions to translate integers to byte arrays and vice versa efficiently. # Task Implement two functions: 1. `int_to_bytes_endian(num, endian)` - Converts an integer `num` to its byte array representation according to the specified endianness (`endian` being either \'big\' or \'little\'). 2. `bytes_to_int_endian(bytestr, endian)` - Converts a byte array `bytestr` back to an integer according to the specified endianness (`endian` being either \'big\' or \'little\'). # Requirements - **Function 1: int_to_bytes_endian(num, endian)** * **Input**: * `num` (int): A non-negative integer. * `endian` (str): A string that can be either \'big\' or \'little\'. * **Output**: * `bytes`: Byte array representation of the integer. - **Function 2: bytes_to_int_endian(bytestr, endian)** * **Input**: * `bytestr` (bytes): A byte array. * `endian` (str): A string that can be either \'big\' or \'little\'. * **Output**: * `int`: The integer represented by the byte array. # Examples ```python # Example 1 print(int_to_bytes_endian(1024, \'big\')) # Output: b\'x04x00\' print(bytes_to_int_endian(b\'x04x00\', \'big\')) # Output: 1024 # Example 2 print(int_to_bytes_endian(1024, \'little\')) # Output: b\'x00x04\' print(bytes_to_int_endian(b\'x00x04\', \'little\')) # Output: 1024 # Example 3 print(int_to_bytes_endian(1, \'big\')) # Output: b\'x01\' print(bytes_to_int_endian(b\'x01\', \'big\')) # Output: 1 # Example 4 print(int_to_bytes_endian(1, \'little\')) # Output: b\'x01\' print(bytes_to_int_endian(b\'x01\', \'little\')) # Output: 1 ``` # Constraints * The input integer `num` will be non-negative. * The byte array `bytestr` will be non-empty. * Handle any necessary validation to ensure `endian` parameter is either \'big\' or \'little\'.","solution":"def int_to_bytes_endian(num, endian): Converts an integer `num` to its byte array representation according to the specified endianness. Parameters: num (int): A non-negative integer. endian (str): A string that can be either \'big\' or \'little\'. Returns: bytes: Byte array representation of the integer. assert endian in [\'big\', \'little\'], \\"Endianness must be \'big\' or \'little\'\\" if num == 0: return b\'x00\' num_bytes = (num.bit_length() + 7) // 8 return num.to_bytes(num_bytes, byteorder=endian) def bytes_to_int_endian(bytestr, endian): Converts a byte array `bytestr` back to an integer according to the specified endianness. Parameters: bytestr (bytes): A byte array. endian (str): A string that can be either \'big\' or \'little\'. Returns: int: The integer represented by the byte array. assert endian in [\'big\', \'little\'], \\"Endianness must be \'big\' or \'little\'\\" return int.from_bytes(bytestr, byteorder=endian)"},{"question":"Context: You are a software developer tasked with implementing a tool that processes a list of words by embedding specific symbols within them. The symbols that need to be embedded should be chosen based on predefined rules and must be highlighted by surrounding them with square brackets. Objective: Write a Python function `highlight_symbols(words: List[str], symbols: List[str]) -> List[str]` that processes a list of words and embeds the specified symbols within the words according to the following rules: 1. If a word contains one or more symbols, embed only the longest matching symbol. 2. If no symbols match a word, leave the word unchanged. 3. If multiple symbols match a word and they are of the same length, choose the one that appears first in the symbols array. 4. Symbols should be case-sensitive. Input: - `words`: A list of strings representing words e.g., `[\'Amazon\', \'Microsoft\', \'Google\']`. - `symbols`: A list of strings representing symbols e.g., `[\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\']`. Output: - A list of strings with the symbols embedded within the respective words e.g., `[\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\']`. Constraints: - Symbols only contain lowercase and uppercase alphabetic characters and are case-sensitive. - Assume 1 ≤ len(words), len(symbols) ≤ 1000 - Assume each word length and symbol length ≤ 100 Example: ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] # Expected output: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` Implementation Constraints: - Optimize the solution to handle up to the given limits efficiently. - Aim for a solution that is better than O(n^2), where n is the number of words. Implement the function: ```python def highlight_symbols(words: List[str], symbols: List[str]) -> List[str]: # Your implementation here pass ```","solution":"from typing import List def highlight_symbols(words: List[str], symbols: List[str]) -> List[str]: Processes a list of words and embeds the specified symbols within the words based on specific rules. highlighted_words = [] # Sort the symbols by length in descending order and by original order for same length sorted_symbols = sorted(symbols, key=lambda x: (-len(x), symbols.index(x))) for word in words: embedded = False for symbol in sorted_symbols: if symbol in word: # Add the highlighted word to the result list highlighted_words.append(word.replace(symbol, f\\"[{symbol}]\\")) embedded = True break if not embedded: highlighted_words.append(word) return highlighted_words"},{"question":"Design and implement a function to sort an array using a variation of Heap Sort. Specifically, you are required to write a function `hybrid_heap_sort` that dynamically chooses between max-heap sort or min-heap sort based on the initial ordering of the array. If more than half of the array elements are already sorted in ascending order, use min-heap sort. Otherwise, use max-heap sort. # Requirements * **Input Format**: * An array of integers `arr`. * **Output Format**: * The sorted array of integers `arr`. * **Constraints**: * 1 ≤ len(arr) ≤ 10^6 # Implementation ```python def hybrid_heap_sort(arr): # Your implementation should use the helper functions provided below as needed. pass def max_heap_sort(arr, simulation=False): iteration = 0 if simulation: print(\\"iteration\\", iteration, \\":\\", *arr) for i in range(len(arr) - 1, 0, -1): iteration = max_heapify(arr, i, simulation, iteration) if simulation: iteration = iteration + 1 print(\\"iteration\\", iteration, \\":\\", *arr) return arr def max_heapify(arr, end, simulation, iteration): last_parent = (end - 1) // 2 # Iterate from last parent to first for parent in range(last_parent, -1, -1): current_parent = parent # Iterate from current_parent to last_parent while current_parent <= last_parent: # Find greatest child of current_parent child = 2 * current_parent + 1 if child + 1 <= end and arr[child] < arr[child + 1]: child = child + 1 # Swap if child is greater than parent if arr[child] > arr[current_parent]: arr[current_parent], arr[child] = arr[child], arr[current_parent] current_parent = child if simulation: iteration = iteration + 1 print(\\"iteration\\", iteration, \\":\\", *arr) # If no swap occurred, no need to keep iterating else: break arr[0], arr[end] = arr[end], arr[0] return iteration def min_heap_sort(arr, simulation=False): iteration = 0 if simulation: print(\\"iteration\\", iteration, \\":\\", *arr) for i in range(0, len(arr) - 1): iteration = min_heapify(arr, i, simulation, iteration) return arr def min_heapify(arr, start, simulation, iteration): end = len(arr) - 1 last_parent = (end - start - 1) // 2 for parent in range(last_parent, -1, -1): current_parent = parent while current_parent <= last_parent: # Find lesser child of current_parent child = 2 * current_parent + 1 if child + 1 <= end - start and arr[child + start] > arr[child + 1 + start]: child = child + 1 # Swap if child is less than parent if arr[child + start] < arr[current_parent + start]: arr[current_parent + start], arr[child + start] = arr[child + start], arr[current_parent + start] current_parent = child if simulation: iteration = iteration + 1 print(\\"iteration\\", iteration, \\":\\", *arr) else: break return iteration ``` **Explanation**: * Write a function `hybrid_heap_sort` to determine if more than half of the elements are sorted in ascending order. * If yes, apply `min_heap_sort`; otherwise, apply `max_heap_sort`. * Ensure the function handles edge cases and performs efficiently for the input size constraints. **Input/Output Examples**: *Example 1*: ```python input: [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] ``` *Example 2*: ```python input: [] output: [] ``` *Example 3*: ```python input: [1] output: [1] ```","solution":"def hybrid_heap_sort(arr): if len(arr) <= 1: return arr # Determine if more than half the array is sorted in ascending order sorted_count = sum(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) if sorted_count >= len(arr) // 2: return min_heap_sort(arr) else: return max_heap_sort(arr) def max_heap_sort(arr): def heapify(arr, n, i): largest = i l = 2 * i + 1 r = 2 * i + 2 if l < n and arr[l] > arr[largest]: largest = l if r < n and arr[r] > arr[largest]: largest = r if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest) n = len(arr) for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0) return arr def min_heap_sort(arr): def heapify(arr, n, i): smallest = i l = 2 * i + 1 r = 2 * i + 2 if l < n and arr[l] < arr[smallest]: smallest = l if r < n and arr[r] < arr[smallest]: smallest = r if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] heapify(arr, n, smallest) n = len(arr) for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) for i in range(n - 1, 0, -1): arr[0], arr[i] = arr[i], arr[0] heapify(arr, i, 0) arr.reverse() return arr"},{"question":"# Scenario You are tasked with sorting an array of numbers in certain conditions: the array could be small, nearly sorted, or in an arbitrary order. To test your grasp of sorting algorithms, you need to implement the Insertion Sort algorithm covered in your recent lessons. # Problem Statement Write a function `insertion_sort_desc(arr)` that sorts an array of integers in **descending order** using the Insertion Sort algorithm. # Input Format * A list `arr` of integers. # Output Format * A list of integers sorted in descending order. # Constraints * The number of elements in the list `n` (0 ≤ n ≤ 1000). * Each element in the list `arr[i]` (-10^5 ≤ arr[i] ≤ 10^5). # Example Example 1: Input: ```python arr = [4, 2, 7, 1, 3] ``` Output: ```python [7, 4, 3, 2, 1] ``` Example 2: Input: ```python arr = [] ``` Output: ```python [] ``` # Requirements * Implement the function using the Insertion Sort algorithm. * Ensure the function handles edge cases such as an empty list or a single-element list correctly.","solution":"def insertion_sort_desc(arr): Sorts an array of integers in descending order using the Insertion Sort algorithm. :param arr: List of integers to be sorted. :return: List of integers sorted in descending order. # Iterate over each element in the array from the second element onwards for i in range(1, len(arr)): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are less than key, # to one position ahead of their current position while j >= 0 and arr[j] < key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"# Question: Implement and Analyze a Recursive Sorting Algorithm You are given an implementation of the Stooge Sort algorithm. Your task is to modify and optimize the given algorithm for improved performance. You are free to choose any optimization techniques, including changing the algorithm to a more efficient one if necessary. Requirements 1. **Function Signature**: Implement the function `optimized_sort(arr: List[int]) -> List[int]`. 2. **Input**: A list of integers `arr` of length `n` (1 <= n <= 10^5). 3. **Output**: Return a sorted list of integers. 4. **Constraints**: Ensure your solution handles larger input sizes efficiently. 5. **Performance Requirements**: Aim for better than O(n^2.709) time complexity. Example: ```python # Input arr = [64, 34, 25, 12, 22, 11, 90] # Function Call sorted_arr = optimized_sort(arr) # Output print(sorted_arr) # [11, 12, 22, 25, 34, 64, 90] ``` In your implementation, consider the following: - Ensure edge cases are handled (e.g., empty arrays, single element arrays). - Implement error checking and validation of input. - Optimize the recursion to reduce overhead if possible.","solution":"from typing import List def optimized_sort(arr: List[int]) -> List[int]: Sorts the array using TimSort, which has a time complexity of O(n log n). if not isinstance(arr, list): raise ValueError(\\"Input must be a list of integers.\\") for item in arr: if not isinstance(item, int): raise ValueError(\\"All elements in the array must be integers.\\") return sorted(arr)"},{"question":"Interpolation Search Implementation **Objective**: Write a function to perform interpolation search on a sorted array of integers. **Function Signature**: ```python def interpolation_search(array: List[int], search_key: int) -> int: ``` # Problem Description: You are tasked with implementing the interpolation search algorithm for a given sorted array of integers. Given a sorted array `array` and an integer `search_key`, your function should return the index of the `search_key` if it exists in the array, and `-1` if it does not. # Input: * `array`: A list of integers sorted in increasing order. The length of the array will be between 0 and 10^6. * `search_key`: An integer that needs to be found in the array. # Output: * An integer representing the index of the `search_key` in the `array`. If `search_key` is not found, return `-1`. # Constraints: * The array elements are uniformly distributed and sorted in non-decreasing order. * Maximum and minimum values of elements in `array` can range from `-10^6` to `10^6`. * The search_key value can range from `-10^6` to `10^6`. # Performance Requirements: * The solution should aim for an average case time complexity of O(log2(log2 n)) and must handle up to 10^6 array elements efficiently. # Example: ```python >>> interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) 2 >>> interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) -1 >>> interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) -1 >>> interpolation_search([], 10) -1 ``` # Additional Notes: - Handle edge cases such as empty arrays and arrays with single elements. - Ensure the search operations don\'t result in division errors.","solution":"from typing import List def interpolation_search(array: List[int], search_key: int) -> int: Perform interpolation search on a sorted array. Parameters: array (List[int]): A list of sorted integers search_key (int): The integer value to search for in the array Returns: int: The index of search_key in the array, or -1 if not found low, high = 0, len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Moving Average Calculation with Sum Optimization **Objective**: Implement a class that calculates the moving average of the last `size` integer elements provided to it, optimizing the sum calculation. **Scenario**: You are tasked with improving the implementation of a moving average calculator to handle real-time data streams efficiently. The existing implementation recalculates the sum of the elements in every call, which can be slow for larger windows. Your goal is to enhance the `MovingAverage` class such that the average is computed in constant time after each new element is added. **Task**: Refactor the `MovingAverage` class to maintain a running sum of the elements within the window. This will eliminate the need to repeatedly compute the sum of the deque elements. Implement the required changes and ensure the class meets the performance criteria. **Function Definition**: ```python class MovingAverage: def __init__(self, size: int): Initialize your data structure here. :type size: int self.queue = deque(maxlen=size) self.size = size self.current_sum = 0 def next(self, val: int) -> float: :type val: int :rtype: float if len(self.queue) == self.size: self.current_sum -= self.queue[0] self.queue.append(val) self.current_sum += val return self.current_sum / len(self.queue) ``` **Inputs and Outputs**: * `__init__(self, size:int)`: Initializes the MovingAverage object with a window size of `size`. * `next(self, val:int) -> float`: Adds the integer `val` to the stream and returns the moving average of the last `size` integers. **Constraints**: * 1 <= size <= 1000 * -10^4 <= val <= 10^4 * The function `next` will be called at most 10^5 times. **Example Usage**: ```python m = MovingAverage(3) print(m.next(1)) # Output: 1.0 print(m.next(10)) # Output: 5.5 print(m.next(3)) # Output: 4.66667 print(m.next(5)) # Output: 6.0 ``` **Performance Requirement**: * Each call to `next` should run in O(1) time.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): Initialize your data structure here. :type size: int self.queue = deque(maxlen=size) self.size = size self.current_sum = 0 def next(self, val: int) -> float: Adds the integer val to the stream and returns the moving average of the last `size` integers. :type val: int :rtype: float if len(self.queue) == self.size: self.current_sum -= self.queue[0] self.queue.append(val) self.current_sum += val return self.current_sum / len(self.queue)"},{"question":"You are tasked with developing a function that takes two non-negative integers and returns both their Greatest Common Divisor (GCD) and Least Common Multiple (LCM). The solution will test your understanding of the Euclidean algorithm, binary operations, and handling of edge cases in integer inputs. Function Signature ```python def gcd_and_lcm(a: int, b: int) -> (int, int): Computes the Greatest Common Divisor and Least Common Multiple of integers a and b. Arguments: a -- First non-negative integer b -- Second non-negative integer Returns: (gcd, lcm) -- Tuple containing the GCD and LCM of a and b. ``` # Requirements 1. Implement the Euclidean Algorithm to find the GCD. 2. Compute the LCM based on the result of the GCD. 3. Ensure the calculation is efficient, especially for large integers. 4. Handle edge cases, including scenarios where one or both integers are zero. # Constraints - Both `a` and `b` are non-negative integers (0 ≤ a, b ≤ 10^9). - The function should handle inputs efficiently within the given constraints. # Examples 1. Input: `gcd_and_lcm(15, 25)` Output: `(5, 75)` 2. Input: `gcd_and_lcm(0, 10)` Output: `(10, 0)` 3. Input: `gcd_and_lcm(18, 24)` Output: `(6, 72)` # Notes 1. For number pairs where either `a` or `b` is zero, define: - `gcd(a, 0) = a` if `a ≠ 0` - `gcd(0, b) = b` if `b ≠ 0` - `lcm(a, 0) = 0` or `lcm(0, b) = 0` since the product of any number with zero is zero.","solution":"def gcd(a, b): Returns the Greatest Common Divisor (GCD) of integers a and b using the Euclidean Algorithm. while b: a, b = b, a % b return a def gcd_and_lcm(a: int, b: int) -> (int, int): Computes the Greatest Common Divisor and Least Common Multiple of integers a and b. Arguments: a -- First non-negative integer b -- Second non-negative integer Returns: (gcd, lcm) -- Tuple containing the GCD and LCM of a and b. if a == 0: return (b, 0) if b == 0: return (a, 0) gcd_value = gcd(a, b) lcm_value = (a * b) // gcd_value return (gcd_value, lcm_value)"},{"question":"You are given two strings `word1` and `word2`. Your task is to write a function `min_distance_optimized(word1, word2)` that computes the minimum number of delete operations required to make `word1` and `word2` the same. This function should be an optimized version of the given solution, focusing on reducing the space complexity while maintaining or improving the time complexity. Input Format * Two strings `word1` and `word2`. Output Format * A single integer representing the minimum number of delete operations required. Constraint * The length of `word1` and `word2` will be at most 500. Example ```plaintext Input: word1 = \\"sea\\", word2 = \\"eat\\" Output: 2 Explanation: You need one step to make \\"sea\\" to \\"ea\\" and another step to make \\"eat\\" to \\"ea\\". ``` Function Signature ```python def min_distance_optimized(word1: str, word2: str) -> int: # Your code here ``` Requirements * **Performance**: The solution must run in (O(m times n)) time complexity, where (m) and (n) are the lengths of `word1` and `word2`. The space complexity should be (O(min(m, n))). Instructions 1. Focus on reducing the space complexity of the dynamic programming approach. 2. Handle edge cases, such as when one or both strings are empty. 3. Ensure your solution is well-commented to explain your logic.","solution":"def min_distance_optimized(word1: str, word2: str) -> int: Returns the minimum number of delete operations required to make word1 and word2 the same. m, n = len(word1), len(word2) if m < n: word1, word2 = word2, word1 m, n = n, m # Initialize two rows for dynamic programming prev_dp = list(range(n + 1)) curr_dp = [0] * (n + 1) for i in range(1, m + 1): curr_dp[0] = i for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: curr_dp[j] = prev_dp[j - 1] else: curr_dp[j] = 1 + min(prev_dp[j], curr_dp[j - 1]) prev_dp, curr_dp = curr_dp, prev_dp return prev_dp[n]"},{"question":"Context: You are building a feature for a graphical user interface which requires displaying data from a binary tree in a zigzag pattern. This pattern alternates the order of nodes in each level of the tree (left-to-right followed by right-to-left and so on). Assume you are provided with a binary tree and your task is to implement the zigzag level order traversal function. Task: Implement the function `zigzag_level(root)`, which takes the root of a binary tree and returns a list of lists of node values, representing the zigzag level order traversal of the binary tree. Function Signature: ```python def zigzag_level(root): # your code here ``` Input: * `root`: A `TreeNode` object representing the root of a binary tree. `TreeNode` is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output: * Return a list of lists of integers, where each list represents a level in zigzag order. Example: ```python # Given binary tree [3,9,20,null,null,15,7], # 3 # / # 9 20 # / # 15 7 # The zigzag level order traversal will be: # [ # [3], # [20,9], # [15,7] # ] root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) assert zigzag_level(root) == [ [3], [20,9], [15,7] ] ``` Constraints: * The number of nodes in the binary tree will not exceed 2000. * Each node\'s value is a distinct integer. Notes: * Performance should be considered. An optimal solution should have (O(n)) time complexity. * Handle edge cases such as empty trees and trees with single nodes.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right from collections import deque def zigzag_level(root): if not root: return [] result = [] nodes_queue = deque([root]) left_to_right = True while nodes_queue: level_size = len(nodes_queue) level_nodes = deque() for _ in range(level_size): node = nodes_queue.popleft() if left_to_right: level_nodes.append(node.val) else: level_nodes.appendleft(node.val) if node.left: nodes_queue.append(node.left) if node.right: nodes_queue.append(node.right) result.append(list(level_nodes)) left_to_right = not left_to_right return result"},{"question":"# Question: Sequential Digit Powers Representation **Context**: Given a positive range of integers, we want to find all numbers that can be represented in a specific way where the sum of their digits raised to consecutive powers equals the number itself. For example, 135 can be expressed as 1^1 + 3^2 + 5^3 = 135. **Your Task**: Write a function `find_self_power_numbers` that given two integers `low` and `high` returns a list of such numbers within the given inclusive range. **Function Signature**: ```python def find_self_power_numbers(low: int, high: int) -> List[int]: ``` **Input**: * `low` (int): The lower limit of the range (1 ≤ low ≤ 10^6). * `high` (int): The upper limit of the range (low ≤ high ≤ 10^6). **Output**: * List[int]: A list of numbers within the range [low, high] that satisfy the described property. **Performance Requirements**: - The algorithm should efficiently handle the maximum range. **Example**: ```python assert find_self_power_numbers(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert find_self_power_numbers(1, 150) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89, 135] ``` **Notes**: * Ensure your solution is optimized for large range inputs. * You should handle edge cases when `low` and `high` are at their limits.","solution":"from typing import List def find_self_power_numbers(low: int, high: int) -> List[int]: def is_self_power_number(n): str_n = str(n) total = sum(int(digit) ** (idx + 1) for idx, digit in enumerate(str_n)) return total == n result = [] for num in range(low, high + 1): if is_self_power_number(num): result.append(num) return result"},{"question":"# Quick Sort Visualization with Recursive Call Count As a sorting algorithm enthusiast, you have been tasked to not only implement the Quick Sort algorithm but also track the number of recursive calls made throughout the sorting process. This will help in understanding the depth and efficiency of the recursion. Task: Write a function `quick_sort_with_recursion_count(arr: List[int]) -> Tuple[List[int], int]` that sorts the given list `arr` using the Quick Sort algorithm and returns a tuple. The tuple should contain the sorted list and the total number of recursive calls made during the sorting process. Input: * A list of integers `arr` where: * `1 <= len(arr) <= 10^5` * `-10^9 <= arr[i] <= 10^9` * Assume that the list can contain duplicate values. Output: * A tuple containing: 1. A list of integers sorted in ascending order. 2. An integer representing the total number of recursive calls made during sorting. Constraints: * Ensure your solution handles the edge cases such as an array with all identical elements or a completely sorted array. * The function should be performant enough to handle large lists efficiently within the given constraints. Example: ```python sorted_array, recursion_count = quick_sort_with_recursion_count([3, 6, 8, 10, 1, 2, 1]) print(sorted_array) # Output: [1, 1, 2, 3, 6, 8, 10] print(recursion_count) # Output: Number of recursive calls made ``` Focus on both the correctness of the sorting algorithm and the accuracy of the recursive call count.","solution":"from typing import List, Tuple def quick_sort_with_recursion_count(arr: List[int]) -> Tuple[List[int], int]: def quick_sort(arr: List[int], low: int, high: int) -> int: if low < high: pi, rec_count = partition(arr, low, high) left_rec_count = quick_sort(arr, low, pi - 1) right_rec_count = quick_sort(arr, pi + 1, high) return rec_count + left_rec_count + right_rec_count + 2 return 0 def partition(arr: List[int], low: int, high: int): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] < pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i+1], arr[high] = arr[high], arr[i+1] return i + 1, 1 arr_copy = arr[:] recursion_count = quick_sort(arr_copy, 0, len(arr_copy) - 1) return arr_copy, recursion_count"},{"question":"Scenario You\'re working on a file management system that needs to handle both URLs and filesystem paths efficiently. One common requirement is to split full path strings into two parts: the directory part and the file name. However, paths sometimes may not contain a directory, or they may end with a slash. Your task is to implement a robust function that splits these paths correctly. Task Write a function `robust_split(path: str) -> List[str]` that splits the input path string into a directory and file name. If the string does not contain any \'/\', the directory should be an empty string, and the file name should be the entire input string. If the string ends with \'/\', the file name should be an empty string, and the directory should be the entire input string excluding the trailing \'/\'. Function Signature ```python from typing import List def robust_split(path: str) -> List[str]: # your code here ``` Input - `path` (str): A non-empty string representing a URL or file path. Output - (List[str]): A list with two elements: [directory part, file name part]. Constraints - The length of the path will be between 1 and 10^5. - The input will not contain any invalid characters (e.g., incorrect path symbols). Examples 1. `robust_split(\\"https://algorithms/unix/test.py\\")` should return `[\\"https://algorithms/unix\\", \\"test.py\\"]`. 2. `robust_split(\\"algorithms/unix/test.py\\")` should return `[\\"algorithms/unix\\", \\"test.py\\"]`. 3. `robust_split(\\"filename\\")` should return `[\\"\\", \\"filename\\"]`. 4. `robust_split(\\"path/to/dir/\\")` should return `[\\"path/to/dir\\", \\"\\"]`. Note You need to consider edge cases such as: - A string without any slashes: treat the entire string as the file name. - A string ending with a slash: treat the entire string (excluding the trailing slash) as the directory.","solution":"from typing import List def robust_split(path: str) -> List[str]: # Check if the path just ends with a slash if path.endswith(\'/\'): return [path[:-1], \'\'] # Split the path into directory and filename idx = path.rfind(\'/\') if idx == -1: return [\'\', path] directory = path[:idx] filename = path[idx+1:] return [directory, filename]"},{"question":"# Scenario A leading software company facing performance issues in database queries involving aggregate operations on large datasets has decided to use Segment Trees for optimization. # Task Implement a SegmentTree class that supports efficient range queries and updates on an array. The class should support different commutative functions (such as sum, max, etc.) provided at initialization. # Function Specifications - **Class `SegmentTree`**: 1. **Constructor**: `__init__(self, arr: List[T], function: Callable[[T, T], T])` - _Parameters_: - `arr`: List of elements. - `function`: Commutative function for segment results (e.g., sum, max). - _Functionality_: Initialize the segment tree with the given array and function. 2. **Method `update(self, index: int, value: T) -> None`** - _Parameters_: - `index`: Position in the original array to update. - `value`: New value to set at the given position. - _Functionality_: Update the value at the given index and adjust the segment tree. 3. **Method `query(self, left: int, right: int) -> T`** - _Parameters_: - `left`: Left endpoint of the range query (inclusive). - `right`: Right endpoint of the range query (inclusive). - _Functionality_: Return the result of the commutative function applied to the segment between `left` and `right`. # Input and Output Examples - Example 1: ```python mytree = SegmentTree([2, 4, 5, 3, 4], max) print(mytree.query(2, 4)) # Output: 5 mytree.update(3, 6) print(mytree.query(0, 3)) # Output: 6 ``` - Example 2: ```python mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) print(mytree.query(0, 6)) # Output: 64 mytree.update(2, -10) print(mytree.query(0, 6)) # Output: 52 ``` - Example 3: ```python mytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1])) print(mytree.query(0, 2)) # Output: (9, 13) mytree.update(2, (-1, 2)) print(mytree.query(0, 2)) # Output: (4, 10) ``` # Constraints - The commutative function provided should always return the same type of value as the inputs. - Assume all array elements have valid types compatible with the commutative function. - Inputs must be validated outside this class.","solution":"from typing import List, Callable, TypeVar T = TypeVar(\'T\') class SegmentTree: def __init__(self, arr: List[T], function: Callable[[T, T], T]): self.n = len(arr) self.function = function self.tree = [None] * (2 * self.n) self._build(arr) def _build(self, arr: List[T]): for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, index: int, value: T): index += self.n self.tree[index] = value while index > 1: index //= 2 self.tree[index] = self.function(self.tree[2 * index], self.tree[2 * index + 1]) def query(self, left: int, right: int) -> T: left += self.n right += self.n + 1 result = None while left < right: if left % 2: if result is None: result = self.tree[left] else: result = self.function(result, self.tree[left]) left += 1 if right % 2: right -= 1 if result is None: result = self.tree[right] else: result = self.function(result, self.tree[right]) left //= 2 right //= 2 return result"},{"question":"**Problem Statement**: You have been hired as a financial analyst and are given an array representing the daily profit or loss of a particular stock over a period. Your task is to write a function that finds the maximum possible profit that can be made by buying and then subsequently selling once. The profits and losses over the days are provided in an integer array. **Function Signature**: ```python def find_max_profit(profits: List[int]) -> int: pass ``` **Input**: - `profits`: A list of integers where each integer represents the profit/loss for that day, and its length is between 1 and 10^5. **Output**: - Returns an integer representing the maximum profit possible over any contiguous period of days. **Constraints**: - The array `profits` will not be empty. - The values in the array can be negative, indicating a loss. **Examples**: 1. `find_max_profit([1, 2, -3, 4, 5, -7, 23])` should return `25`. 2. `find_max_profit([-2, -3, 4, -1, -2, 1, 5, -3])` should return `7`. 3. `find_max_profit([-1, -2, -3, -4])` should return `-1` (maximum subarray will be the least negative single element). **Scenario**: Lucy is a stock market investor. She analyzed the daily profit/loss values for the last few months stored in an array. She wants to determine the maximum profit she could have earned on any consecutive days during this period. It\'s your job to help her with this analysis. Remember, if the array contains only negative numbers, your function should return the largest (least negative) single number, as buying and selling on the same day would minimize the loss. **Instructions**: You need to implement the `find_max_profit` function in Python. It should correctly process and return the maximum possible profit for given daily profit/loss arrays.","solution":"from typing import List def find_max_profit(profits: List[int]) -> int: This function finds the maximum possible profit that can be made by buying and then subsequently selling once. max_profit = float(\'-inf\') current_sum = 0 for profit in profits: current_sum += profit if current_sum > max_profit: max_profit = current_sum if current_sum < 0: current_sum = 0 return max_profit"},{"question":"# FizzBuzz with Twist - Other Multiples **Scenario**: You are asked to extend the classic FizzBuzz problem with additional requirements. The basic rules remain the same, but now you must also handle additional multiples and associated strings. **Problem Statement**: Create a function `extended_fizzbuzz(n, multiples)` that generates a list of numbers from 1 to N with substitutions according to given multiples and their respective strings. **Function Signature**: ```python def extended_fizzbuzz(n: int, multiples: dict) -> list: ``` **Input**: - `n`: An integer (1 <= n <= 10^6), the upper limit of the sequence. - `multiples`: A dictionary where keys are integers representing multiples and values are strings to substitute. **Output**: - A list of length N, where each element is substituted based on the provided multiples. **Constraints**: - Elements in the `multiples` dictionary have unique keys. - Common FizzBuzz replacements (3 -> \\"Fizz\\", 5 -> \\"Buzz\\") are included in the dictionary. - The dictionary can handle up to 10 different multiples. **Example**: ```python extended_fizzbuzz(15, {3: \\"Fizz\\", 5: \\"Buzz\\", 7: \\"Bizz\\"}) ``` **Expected Output**: ``` [1, 2, \\"Fizz\\", 4, \\"Buzz\\", \\"Fizz\\", \\"Bizz\\", 8, \\"Fizz\\", \\"Buzz\\", 11, \\"Fizz\\", 13, \\"Bizz\\", \\"FizzBuzz\\"] ``` Here, \\"Bizz\\" is an additional substitution for multiples of 7. **Performance Requirement**: Your function should run efficiently for values of n up to 1,000,000. **Guidelines**: 1. Validate the input to ensure `n` is an integer greater than or equal to 1. 2. Ensure that the multiples dictionary has appropriate entries and unique keys. 3. Implement the function such that it iterates through the sequence, checks the conditions, and appends the correct value to the result list. 4. Minimize memory footprint and optimize the looping mechanism to handle large values efficiently.","solution":"def extended_fizzbuzz(n, multiples): Generates a list of numbers from 1 to n with substitutions based on provided multiples and their respective strings. Args: n (int): The upper limit of the sequence. multiples (dict): A dictionary where keys are multiples and values are strings to substitute. Returns: list: A list with the FizzBuzz substitutions. result = [] for num in range(1, n + 1): output = \\"\\" for multiple, substitution in multiples.items(): if num % multiple == 0: output += substitution if not output: output = num result.append(output) return result"},{"question":"You are required to implement additional functionalities in the given `SeparateChainingHashTable` class focusing on efficiency and maintaining the core properties of a hash table. Task 1. **Resizing Mechanism**: Implement an automatic resizing mechanism that triggers when the load factor exceeds 0.75. The table should double in size in such a scenario. Ensure all existing keys are rehashed and placed into the new table. 2. **Contains Method**: Implement a `contains` method that helps check if a key exists in the hash table. The method should return `True` if the key exists and `False` otherwise. 3. **Clear Method**: Implement a `clear` method that removes all key-value pairs from the hash table, resetting it to its initial empty state. Requirements * The table should resize efficiently, maintaining the average time complexity of O(1) for `put` and `get` operations. * The `contains` method should have a time complexity of O(1) on average. * The `clear` method should completely wipe existing entries in O(n) time where n is the number of key-value pairs. Input and Output formats * **Input**: * For resizing, automatically handled when the number of elements exceeds a certain threshold. * For `contains` method: A single key. * For `clear` method: No input. * **Output**: * For `contains` method: A boolean (True/False). * For `clear` method: No output. The internal state of the hash table should be empty. Constraints * The initial size of the hash table is always a prime number. * Keys will be strings, and values can be of any type. * Implement the methods in the `SeparateChainingHashTable` class. Your task is to submit the code for the updated class including the three new functionalities described above. Example Usage ```python table = SeparateChainingHashTable() table.put(\'apple\', \'fruit\') table.put(\'carrot\', \'vegetable\') print(table.contains(\'apple\')) # Output: True print(table.contains(\'banana\')) # Output: False # Simulate inserting elements to trigger resize for i in range(10): table.put(f\'key{i}\', f\'value{i}\') print(len(table)) # Check the length to ensure elements are added table.clear() print(len(table)) # Output: 0 print(table.contains(\'apple\')) # Output: False ```","solution":"class SeparateChainingHashTable: def __init__(self, initial_capacity=7): self.capacity = initial_capacity self.size = 0 self.table = [[] for _ in range(self.capacity)] def hash_function(self, key): return hash(key) % self.capacity def put(self, key, value): index = self.hash_function(key) for pair in self.table[index]: if pair[0] == key: pair[1] = value return self.table[index].append([key, value]) self.size += 1 # Check if resizing is needed if self.size / self.capacity > 0.75: self.resize() def get(self, key): index = self.hash_function(key) for pair in self.table[index]: if pair[0] == key: return pair[1] return None def contains(self, key): index = self.hash_function(key) for pair in self.table[index]: if pair[0] == key: return True return False def clear(self): self.size = 0 self.table = [[] for _ in range(self.capacity)] def resize(self): old_table = self.table self.capacity *= 2 self.table = [[] for _ in range(self.capacity)] self.size = 0 for bucket in old_table: for key, value in bucket: self.put(key, value) def __len__(self): return self.size"},{"question":"Scenario: Imagine you are working on designing seating arrangements for an event where attendees have specific preferences. Each attendee has a height and a preference for how many attendees taller than them should be in front of them. Your task is to reconstruct the list of attendees in the correct order based on these preferences. Objective: Write a function `reconstruct_queue(people)` that takes in a list of attendees described by their height and preferences, and returns the list sorted according to the given constraints. Function Signature: ```python def reconstruct_queue(people): :type people: List[List[int]] :rtype: List[List[int]] ``` Input: * `people`: A list of pairs `[[h1, k1], [h2, k2], ...]` where `hi` is the height of the ith person and `ki` is the number of people in front of this person who have a height greater than or equal to `hi`. * Constraints: * The number of people (n) is less than 1,100. * Heights are positive integers (1 ≤ h ≤ 100). * Preferences `ki` are non-negative integers (0 ≤ k ≤ n-1). Output: * The function should return the list of people arranged in the correct order. Examples: ```python # Example 1 input = [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]] output = [[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7, 1]] # Example 2 input = [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]] output = [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6,0]] ``` Constraints: * Make sure your solution runs with a time complexity of at most O(n^2). Notes: * Ensure the function handles edge cases such as an empty list. * Think through the insertion order necessary to maintain the constraints efficiently.","solution":"def reconstruct_queue(people): Reconstructs the queue based on the height and the number of people in front of each person who have a height greater than or equal to theirs. :param people: List[List[int]] - List of pairs [h, k] where h is height and k is the number of people in front with height ≥ h. :return: List[List[int]] - The reconstructed queue. # Sort the people by height in descending order. If heights are the same, sort by the number of people in front in ascending order. people.sort(key=lambda x: (-x[0], x[1])) # Initialize an empty queue to insert people in the required order. queue = [] # Insert each person into the queue using their k-value as the position index. for person in people: queue.insert(person[1], person) return queue"},{"question":"Given two strings, write a function `advanced_anagram(s1, s2)` to determine if they are anagrams of each other. Unlike the initial basic algorithm, your function needs to handle case-insensitivity and ignore non-alphabet characters (i.e., characters outside \'a\' to \'z\' and \'A\' to \'Z\'). # Input/Output * **Input**: - Two strings `s1` and `s2` (1 ≤ len(s1), len(s2) ≤ 10^5) - Each string may contain any ASCII characters. * **Output**: - Return `True` if the strings are anagrams, and `False` otherwise. # Constraints - The function should be efficient, running within O(n) time complexity and O(1) space complexity. - The function should handle characters in a case-insensitive manner and should ignore non-alphabet characters. # Example ```python advanced_anagram(\\"A man, a plan, a canal: Panama\\", \\"amanaPlan a canal: Panam a\\") -> True advanced_anagram(\\"apple\\", \\"pleap\\") -> True advanced_anagram(\\"Hello, World!\\", \\"dlroW ,Oellh\\") -> True advanced_anagram(\\"apple\\", \\"cherry\\") -> False ``` # Implementation Implement the function `advanced_anagram(s1, s2)` according to the specifications: ```python def advanced_anagram(s1, s2): # Your code here pass ```","solution":"def advanced_anagram(s1, s2): from collections import Counter # Filter and convert both strings to lowercase alphabet-only strings filtered_s1 = \'\'.join(c.lower() for c in s1 if c.isalpha()) filtered_s2 = \'\'.join(c.lower() for c in s2 if c.isalpha()) # Compare the Counter results of both filtered strings return Counter(filtered_s1) == Counter(filtered_s2)"},{"question":"# Diffie-Hellman and Primality Utility Implementation In this exercise, you will enhance the provided Diffie-Hellman Key Exchange implementation along with accompanying mathematical utilities. The purpose is to assess your understanding of both cryptographic protocols and fundamental mathematical computations. Problem Statement Enhance and optimize the following set of functions related to the Diffie-Hellman key exchange process. Your enhanced code should: 1. Ensure correct execution of the Diffie-Hellman Key Exchange. 2. Handle edge cases and error conditions effectively. 3. Optimize the performance for large inputs. Expected Functions 1. **prime_check(num: int) -> bool** 2. **find_order(a: int, n: int) -> int** 3. **euler_totient(n: int) -> int** 4. **find_primitive_root(n: int) -> List[int]** 5. **diffie_hellman_key_exchange(a: int, p: int, option: Optional[int]=None) -> bool** Constraints - (1 leq num leq 10^6) - (1 leq a, n, p leq 10^6) - You should consider performance optimizations for handling large prime checks, iterative loops, and avoid excessive recursion. - Handle edge cases gracefully and provide meaningful error messages. Input and Output Examples ```python # Prime check assert prime_check(7) == True assert prime_check(18) == False # Finding Order assert find_order(2, 15) == 4 assert find_order(8, 16) == -1 # Invalid case, returns -1 # Euler\'s Totient Function assert euler_totient(10) == 4 assert euler_totient(1) == 1 # Finding Primitive Roots assert find_primitive_root(14) == [3, 5] assert find_primitive_root(18) == [] # Diffie-Hellman Key Exchange # Ensures Alice and Bob calculate the same shared key. assert diffie_hellman_key_exchange(5, 23) == True assert diffie_hellman_key_exchange(2, 18) == False # 18 is not prime ``` Use this problem statement to build the function implementations correctly, ensuring efficient handling of edge cases and corner situations.","solution":"from typing import List, Optional import math def prime_check(num: int) -> bool: Checks if a given number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def find_order(a: int, n: int) -> int: Finds the order of element \'a\' modulo \'n\'. if math.gcd(a, n) != 1: return -1 # a and n must be coprime order = 1 power_mod = a % n while power_mod != 1: power_mod = (power_mod * a) % n order += 1 return order def euler_totient(n: int) -> int: Computes Euler\'s Totient Function of n. if n == 0: return 0 result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result def find_primitive_root(n: int) -> List[int]: Finds all primitive roots of n. if not prime_check(n): return [] phi = euler_totient(n) prime_factors = set() p = 2 m = phi while p * p <= m: if m % p == 0: prime_factors.add(p) while m % p == 0: m //= p p += 1 if m > 1: prime_factors.add(m) roots = [] for r in range(2, n): flag = True for factor in prime_factors: if pow(r, phi // factor, n) == 0 or pow(r, phi // factor, n) == 1: flag = False break if flag: roots.append(r) return roots def diffie_hellman_key_exchange(a: int, p: int, option: Optional[int] = None) -> bool: Executes the Diffie-Hellman key exchange algorithm. if not prime_check(p): return False g = find_primitive_root(p)[0] # Always pick the first primitive root. if g is None: return False A = pow(g, a, p) B = pow(g, a, p) # Simulating Bob\'s side with same \'a\' for consistency. # Shared key calculation shared_key_A = pow(B, a, p) shared_key_B = pow(A, a, p) return shared_key_A == shared_key_B"},{"question":"You are given an unsorted singly linked list. Your task is to write a Python function to remove duplicate nodes without using any additional data structures (such as sets or hash tables). # Function Signature ```python def remove_duplicates(head: Node) -> None: pass ``` # Input - `head` (Node): The head node of the linked list. Each node has the following structure: ```python class Node: def __init__(self, val=None): self.val = val self.next = None ``` # Output - The function should modify the given linked list in place and remove any duplicate nodes. # Example Consider the provided linked list: ``` A -> A -> B -> C -> D -> C -> F -> G ``` After calling `remove_duplicates`, the linked list should be: ``` A -> B -> C -> D -> F -> G ``` # Constraints - Your solution should not use any additional data structures like sets or hash tables. - The linked list can contain strings. - The function should handle lists of various lengths, including empty lists and single-element lists. # Performance - Time Complexity: O(N^2) - Space Complexity: O(1) # Edge Cases Consider the following edge cases: 1. An empty linked list. 2. Linked list with only one element. 3. Interspersed duplicates (e.g., `A -> B -> A -> B -> C`). # Additional Information - You may assume that the given list nodes will always contain valid data (non-None values). # Tasks 1. Implement the function `remove_duplicates` to remove duplicates as per the described behavior. 2. Test your function extensively to handle edge cases and varied input sizes.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates(head: Node) -> None: if not head: return current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"# Scenario: You are developing a configuration management tool that needs to process file paths provided by users. Often, users may provide relative paths or paths with the tilde (`~`) symbol representing their home directory. To ensure consistency, you need to convert these into absolute paths. # Task: Write a function `convert_to_absolute_path(file_path: str) -> str` that takes a relative file path (which may include the tilde `~` symbol) as input and returns the absolute path. # Function Signature: ```python def convert_to_absolute_path(file_path: str) -> str: ``` # Input: - `file_path` (str): A relative file path, potentially including the tilde (`~`) symbol. # Output: - Returns the absolute path (str) corresponding to the given relative path. # Constraints: - Assume the `file_path` is a valid string referencing typical file paths. - The function should handle empty paths gracefully and return the appropriate absolute path. # Example: ```python print(convert_to_absolute_path(\\"~/documents/report.txt\\")) # Might output: \\"/home/username/documents/report.txt\\" depending on the user\'s home directory. print(convert_to_absolute_path(\\"config/settings.json\\")) # Might output: \\"/current/working/directory/config/settings.json\\" depending on the current working directory. ``` # Performance Requirements: - The function should run efficiently in O(n) time complexity, where n is the length of the path string.","solution":"import os def convert_to_absolute_path(file_path: str) -> str: Converts a relative file path, including one with a tilde (~), to an absolute file path. # Expand user home directory if the path contains ~ expanded_path = os.path.expanduser(file_path) # Get absolute path absolute_path = os.path.abspath(expanded_path) return absolute_path"},{"question":"# Knapsack Problem Implementation You are tasked with implementing the 0/1 Knapsack Problem using dynamic programming. The objective is to determine the maximum summarized value of items that can be fit into a knapsack with a given capacity. # Function Signature ```python def get_maximum_value(items: List[Item], capacity: int) -> int: ``` # Input - `items`: A list of `Item` objects. Each `Item` object has two attributes: - `value` (int): The value of the item. - `weight` (int): The weight of the item. - `capacity` (int): The maximum capacity of the knapsack. # Output - Returns an integer representing the maximum value that can be achieved with the given knapsack capacity. # Constraints - `1 <= len(items) <= 1000` - `0 <= capacity <= 10^4` - `0 <= value, weight <= 10^4` # Example ```python >>> items = [Item(60, 5), Item(50, 3), Item(70, 4), Item(30, 2)] >>> capacity = 5 >>> get_maximum_value(items, capacity) 80 ``` # Description You are provided with the class `Item` defined as follows: ```python class Item: def __init__(self, value, weight): self.value = value self.weight = weight ``` # Task - Implement the function `get_maximum_value` that calculates the maximum value of items that can be put in a knapsack with a given capacity. - Consider edge cases, such as items with zero value or weight, and capacities of zero. Optimize your solution for performance. # Hints - Use a dynamic programming approach where you update a DP array to keep track of the maximum value for each capacity up to the given knapsack capacity. - Loop through items and update the DP array from the back to avoid overwriting values needed for future calculations.","solution":"from typing import List class Item: def __init__(self, value, weight): self.value = value self.weight = weight def get_maximum_value(items: List[Item], capacity: int) -> int: n = len(items) dp = [0] * (capacity + 1) for item in items: for wt in range(capacity, item.weight - 1, -1): dp[wt] = max(dp[wt], dp[wt - item.weight] + item.value) return dp[capacity]"},{"question":"Context You have been hired as a software developer for a company that manages large datasets represented as binary search trees (BSTs). One of the frequent operations required is finding the in-order successor of a given node in the BST for certain analytics. Task Write a function `find_inorder_successor(root, key)` to find the in-order successor of a given key in a BST. The function should return the value of the in-order successor if it exists, otherwise return `None`. Function Signature ```python def find_inorder_successor(root: TreeNode, key: int) -> Union[int, None]: pass ``` Input - `root`: The root node of a binary search tree (BST). - `key`: An integer representing the value for which you want to find the in-order successor. Output - An integer representing the value of the in-order successor if it exists, otherwise `None`. Constraints - All node values in the BST are unique. - Your implementation should aim to have a time complexity of O(h) where h is the height of the tree. # Example ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None # Example Usage: # Construct the BST root = TreeNode(20) root.left = TreeNode(10) root.right = TreeNode(30) root.left.left = TreeNode(5) root.left.right = TreeNode(15) root.right.left = TreeNode(25) root.right.right = TreeNode(35) key = 15 # The in-order successor of 15 is 20. assert find_inorder_successor(root, key) == 20 key = 35 # The in-order successor of 35 is None because there\'s no larger node. assert find_inorder_successor(root, key) == None ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_inorder_successor(root, key): def find_min(node): while node.left is not None: node = node.left return node successor = None current = root while current is not None: if key < current.val: successor = current current = current.left elif key > current.val: current = current.right else: if current.right is not None: successor = find_min(current.right) break return successor.val if successor else None"},{"question":"Given a directed graph with `N` vertices numbered from `0` to `N-1`, you need to determine if there exists a path between two given nodes `source` and `target`. The graph is represented using an adjacency list. # Input * `N` (1 ≤ N ≤ 10^5): An integer representing the number of vertices. * `edges` (0 ≤ edges.length ≤ 2 × 10^5): A list of pairs [[u, v], ...] where `u` and `v` are integers (0 ≤ u, v < N), representing a directed edge from node `u` to node `v`. * `source` and `target` (0 ≤ source, target < N): Two integers representing the start and end nodes respectively. # Output * Return `True` if there is a path from `source` to `target`, otherwise return `False`. # Constraints * Multiple edges between two vertices should be considered only once. * The graph may contain cycles. * The function must run within a reasonable time limit for the given constraints. # Function Signature `def has_path(N: int, edges: List[List[int]], source: int, target: int) -> bool:` # Example ```python def has_path(N: int, edges: List[List[int]], source: int, target: int) -> bool: # your code here # Example 1 N = 4 edges = [[0, 1], [0, 2], [1, 2], [2, 0], [2, 3], [3, 3]] source = 1 target = 3 print(has_path(N, edges, source, target)) # Output: True # Example 2 N = 3 edges = [[0, 1], [1, 2], [2, 0]] source = 0 target = 2 print(has_path(N, edges, source, target)) # Output: True # Example 3 N = 3 edges = [[0, 1], [1, 2]] source = 2 target = 0 print(has_path(N, edges, source, target)) # Output: False ``` # Detailed Solution For this problem, you are required to implement a function `has_path` which performs DFS to check the existence of a path between the `source` and `target` nodes on the directed graph represented by an adjacency list. Implement necessary optimizations and handle edge cases appropriately.","solution":"from typing import List def has_path(N: int, edges: List[List[int]], source: int, target: int) -> bool: from collections import defaultdict, deque # Build adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Perform BFS to check path from source to target queue = deque([source]) visited = set() while queue: node = queue.popleft() if node == target: return True if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return False"},{"question":"**Cycle Detection in a Directed Graph** **Background**: You are working for a software development company that detects deadlocks in a distributed system. Each process in your system can be seen as a node, and a dependency of process A on process B (i.e., A waits for B) can be represented as a directed edge from vertex A to vertex B. Your task is to detect if any cycles exist in these dependencies, indicating potential deadlocks. **Problem Statement**: Given a directed graph, determine if it contains any cycles. **Function Signature**: ```python def contains_cycle(graph: dict) -> bool: # Determine if the graph contains a cycle # Return True if cycles are present, otherwise False ``` **Input**: - `graph`: A dictionary representation of a directed graph where keys are vertex identifiers (strings) and values are lists of vertices (neighbors). **Output**: - Return `True` if the graph contains at least one cycle, otherwise return `False`. **Constraints**: - The graph has at most 1000 vertices. - Vertex identifiers are strings with a maximum length of 10 characters. **Example**: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(contains_cycle(graph)) # Output: True ``` **Performance Requirements**: - The solution should run efficiently within the provided constraints, utilizing DFS to achieve O(V + E) time complexity. **Description**: Your task is to implement the `contains_cycle` function to detect cycles in the given directed graph. Ensure your implementation accounts for all edge cases, potential performance bottlenecks, and handles errors correctly.","solution":"def contains_cycle(graph: dict) -> bool: Detects if there is a cycle in the given directed graph. Parameters: graph (dict): A dictionary where keys are vertex identifiers and values are lists of adjacent vertices. Returns: bool: True if the graph contains a cycle, False otherwise. def dfs(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): return True visiting.remove(node) visited.add(node) return False visited = set() visiting = set() for node in graph: if node not in visited: if dfs(node): return True return False"},{"question":"# Comprehension of Data Compression with Run-Length Encoding/Decoding Context: You are working with a team developing software for compressing and decompressing large datasets. To optimize storage, you\'ve decided to implement a run-length encoding (RLE) algorithm. Your task is to implement both encoding and decoding functions for this algorithm. Your Task: Write two functions: `encode_rle` and `decode_rle`. These should implement the run-length encoding and decoding processes respectively. 1. **Function: `encode_rle`** - **Input**: A string `input`. - **Output**: Returns a string where consecutive data values are represented as a count and a character. If `input` is empty, return an empty string. - **Constraints**: * Only characters in the string are a-z and space. 2. **Function: `decode_rle`** - **Input**: A string `input` which is the encoded string. - **Output**: Returns the original string by decoding the RLE encoded string. - **Constraints**: * The input follows the run-length encoding format, ensuring valid counts and characters. Input Format: * For `encode_rle`: A single string of lowercase letters and spaces. * For `decode_rle`: A run-length encoded string consisting of digit-character pairs. Output Format: * For `encode_rle`: A string representing the encoded form. * For `decode_rle`: A string representing the decoded form. Example: ```python ex1: encode_rle(\\"aaaabbbcc\\") -> \\"4a3b2c\\" ex2: decode_rle(\\"4a3b2c\\") -> \\"aaaabbbcc\\" ex3: encode_rle(\\"\\") -> \\"\\" ex4: decode_rle(\\"\\") -> \\"\\" ``` Performance Requirements: - Ensure that the algorithm works efficiently for inputs up to lengths of 10^6 characters. - Your solution should be in O(n) time complexity for both encoding and decoding. **Implement the functions according to the specified requirements.**","solution":"def encode_rle(input_str): if not input_str: return \\"\\" encoded_str = [] count = 1 prev_char = input_str[0] for char in input_str[1:]: if char == prev_char: count += 1 else: encoded_str.append(f\\"{count}{prev_char}\\") prev_char = char count = 1 encoded_str.append(f\\"{count}{prev_char}\\") return \'\'.join(encoded_str) def decode_rle(encoded_str): if not encoded_str: return \\"\\" decoded_str = [] count = \\"\\" for char in encoded_str: if char.isdigit(): count += char else: decoded_str.append(char * int(count)) count = \\"\\" return \'\'.join(decoded_str)"}]'),C={name:"App",components:{PoemCard:S},data(){return{searchQuery:"",visibleCount:4,poemsData:O,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},N={class:"search-container"},z={class:"card-container"},F={key:0,class:"empty-state"},L=["disabled"],R={key:0},Y={key:1};function j(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",N,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):d("",!0)]),t("div",z,[(n(!0),i(b,null,w(a.displayedPoems,(o,f)=>(n(),v(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",F,' No results found for "'+u(s.searchQuery)+'". ',1)):d("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",Y,"Loading...")):(n(),i("span",R,"See more"))],8,L)):d("",!0)])}const B=c(C,[["render",j],["__scopeId","data-v-6cfa2876"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/47.md","filePath":"drive/47.md"}'),P={name:"drive/47.md"},G=Object.assign(P,{setup(r){return(e,l)=>(n(),i("div",null,[x(B)]))}});export{M as __pageData,G as default};
