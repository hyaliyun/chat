import{_ as h,o as n,c as i,a as t,m as c,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},A={class:"review-content"};function I(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",A,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const C=h(k,[["render",I],["__scopeId","data-v-72d22e7d"]]),N=JSON.parse('[{"question":"# Advanced Problem: Lowest Common Ancestor in a Binary Tree Scenario As a software engineer involved in the development of a large-scale application, you need to implement a feature that determines the lowest common ancestor (LCA) of two nodes in a binary tree. This is a fundamental task in various applications, such as network routing algorithms and genealogy software. Requirements * **Function Signature**: Implement the function `find_lca(root: TreeNode, node1: TreeNode, node2: TreeNode) -> TreeNode`. * **Input**: - `root` (TreeNode): The root of the binary tree. - `node1` (TreeNode): The first node for which the LCA is being calculated. - `node2` (TreeNode): The second node for which the LCA is being calculated. * **Output**: - Return the TreeNode that represents the lowest common ancestor of `node1` and `node2`. Constraints 1. Each node in the binary tree contains a unique integer value. 2. Both `node1` and `node2` are guaranteed to exist in the binary tree. 3. The binary tree can have up to `10^5` nodes. 4. TreeNode class is defined with: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` Performance Requirements - The solution must handle large inputs efficiently. - Aim for a time complexity of O(n), where n is the number of nodes in the tree. Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_lca(root: TreeNode, node1: TreeNode, node2: TreeNode) -> TreeNode: if not root: return None if root == node1 or root == node2: return root left = find_lca(root.left, node1, node2) right = find_lca(root.right, node1, node2) if left and right: return root return left if left else right # Example usage: # Constructing the binary tree: # 3 # / # 5 1 # / / # 6 2 0 8 # / # 7 4 root = TreeNode(3) root.left = TreeNode(5) root.right = TreeNode(1) root.left.left = TreeNode(6) root.left.right = TreeNode(2) root.right.left = TreeNode(0) root.right.right = TreeNode(8) root.left.right.left = TreeNode(7) root.left.right.right = TreeNode(4) node1 = root.left # Node with value 5 node2 = root.left.right.right # Node with value 4 # Expected output: Node with value 5 print(find_lca(root, node1, node2).val) ``` Ensure that your implementation passes various edge cases such as: 1. When the nodes are at different depths. 2. When one node is the ancestor of the other. 3. When the two nodes are in different subtrees.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_lca(root: TreeNode, node1: TreeNode, node2: TreeNode) -> TreeNode: if not root: return None if root == node1 or root == node2: return root left_lca = find_lca(root.left, node1, node2) right_lca = find_lca(root.right, node1, node2) if left_lca and right_lca: return root return left_lca if left_lca else right_lca"},{"question":"# Context You are tasked with implementing a simplified version of the `set` data structure in Python that supports basic operations such as insertion, deletion, membership checking, and union/intersection of two sets. Your implementation should mimic the behavior of Python\'s built-in `set`. # Problem Statement Implement a `SimpleSet` class that supports the following methods: - `add(self, element)`: Adds the element to the set if it is not already present. - `remove(self, element)`: Removes the element from the set. Raises a `KeyError` if the element is not found. - `contains(self, element)`: Returns `True` if the element is in the set, `False` otherwise. - `__len__(self)`: Returns the number of elements in the set. - `union(self, other_set)`: Returns a new `SimpleSet` that is the union of the current set and `other_set`. - `intersection(self, other_set)`: Returns a new `SimpleSet` that is the intersection of the current set and `other_set`. # Requirements 1. Your `SimpleSet` must use a hash table to store elements to ensure efficient operations. 2. Handle hash collisions using chaining (linked lists). 3. The initial capacity of the hash table should be 8. 4. Dynamically resize the table when the load factor exceeds 0.75. # Constraints - Your implementation should aim for an average time complexity of O(1) for add, remove, and contains operations. - Use Python\'s built-in `hash` function for hashing elements. - Elements will not be None and will be hashable. # Input/Output - There is no direct input/output. Implement the class and methods as specified below: ```python class SimpleSet: def __init__(self, initial_capacity=8): # Initialize your data structure pass def add(self, element): # Add element to the set pass def remove(self, element): # Remove element from the set pass def contains(self, element): # Check if the element exists in the set pass def __len__(self): # Return the number of elements in the set pass def union(self, other_set): # Return a new SimpleSet containing elements from both sets pass def intersection(self, other_set): # Return a new SimpleSet containing elements common to both sets pass ``` # Example Usage ```python set1 = SimpleSet() set1.add(\\"a\\") set1.add(\\"b\\") set1.add(\\"c\\") set2 = SimpleSet() set2.add(\\"b\\") set2.add(\\"c\\") set2.add(\\"d\\") print(set1.contains(\\"a\\")) # Output: True print(set1.contains(\\"d\\")) # Output: False set1.remove(\\"a\\") print(len(set1)) # Output: 2 union_set = set1.union(set2) print(len(union_set)) # Output: 4 intersection_set = set1.intersection(set2) print(len(intersection_set)) # Output: 2 print(intersection_set.contains(\\"b\\")) # Output: True ``` This question is designed to be consistent with the style, length, difficulty level, and topic alignment of the sample question provided. It focuses on implementing a basic data structure with essential methods and requiring consideration of efficiency and proper handling of hash collisions.","solution":"class SimpleSet: def __init__(self, initial_capacity=8): self.capacity = initial_capacity self.size = 0 self.buckets = [[] for _ in range(self.capacity)] def _hash(self, element): return hash(element) % self.capacity def _resize(self): new_capacity = self.capacity * 2 new_buckets = [[] for _ in range(new_capacity)] for bucket in self.buckets: for element in bucket: index = hash(element) % new_capacity new_buckets[index].append(element) self.capacity = new_capacity self.buckets = new_buckets def add(self, element): if not self.contains(element): if self.size / self.capacity > 0.75: self._resize() index = self._hash(element) self.buckets[index].append(element) self.size += 1 def remove(self, element): index = self._hash(element) bucket = self.buckets[index] if element in bucket: bucket.remove(element) self.size -= 1 else: raise KeyError(f\\"{element} not found in the set\\") def contains(self, element): index = self._hash(element) bucket = self.buckets[index] return element in bucket def __len__(self): return self.size def union(self, other_set): result_set = SimpleSet() for bucket in self.buckets: for element in bucket: result_set.add(element) for bucket in other_set.buckets: for element in bucket: result_set.add(element) return result_set def intersection(self, other_set): result_set = SimpleSet() for bucket in self.buckets: for element in bucket: if other_set.contains(element): result_set.add(element) return result_set"},{"question":"# Question Given a non-negative integer `n`, implement a function that returns the factorial of `n`. The factorial of a non-negative integer `n` is the product of all positive integers less than or equal to `n` and is denoted by `n!`. Your task is to write a function `factorial` that takes an integer as input and returns its factorial. Function Signature ```python def factorial(n: int) -> int: pass ``` Input - An integer `n` (0 <= n <= 20). Output - An integer representing the factorial of `n`. Constraints - The input integer `n` will be within the range of 0 to 20, ensuring the result can be held in a standard integer type without overflow. Example ```python # Example 1 n = 5 print(factorial(n)) # Output: 120 # Example 2 n = 0 print(factorial(n)) # Output: 1 # Example 3 n = 3 print(factorial(n)) # Output: 6 ``` Additional Notes - Consider edge cases such as the smallest input (n = 0) and the largest input (n = 20). - Ensure that your implementation is efficient and correctly handles the input constraints. - Write clean and readable code with comments to explain the recursive or iterative approach used.","solution":"def factorial(n: int) -> int: Returns the factorial of a non-negative integer n. Args: n (int): A non-negative integer whose factorial is to be computed. Returns: int: The factorial of the input integer n. if n == 0: return 1 # By definition, 0! is 1 result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"# Movie Ranking System You have been asked to create a function that generates rankings for a list of movies based on their ratings. Each movie has a unique identifier and a rating score. The function should return a list of tuples, where each tuple contains the movie identifier and its relative rank. Function Signature ```python def rank_movies(movies: List[Tuple[str, float]]) -> List[Tuple[str, int]]: Ranks the given list of movies based on their ratings. Parameters: - movies (List[Tuple[str, float]]): A list of tuples where each tuple contains: - a string representing the movie identifier (unique name or ID), - a float representing the movie\'s rating (a value between 0.0 and 10.0). Returns: - List[Tuple[str, int]]: A list of tuples where each tuple contains: - the movie identifier, - the rank of the movie (integer) where 1 is the highest rank. Movies with the same rating should receive the same rank. The next rank after a tie will skip the number of tied movies to maintain sequential ranking. ``` Additional Constraints and Information: 1. **Input Validation**: - Each movie identifier must be a non-empty string. - Each rating must be a float value in the range 0.0 to 10.0. - The input list must contain at least one movie. 2. **Edge Cases**: - Multiple movies with the same rating (ties). - Invalid movie identifier (empty string). - Invalid rating (out of range). 3. **Ranking Format**: - The highest rating should be ranked as 1. - Movies with the same rating should share the same rank, and there should be a gap before the next rank. Examples: ```python >>> rank_movies([(\\"Movie A\\", 8.5), (\\"Movie B\\", 9.2), (\\"Movie C\\", 7.8), (\\"Movie D\\", 9.2)]) [(\'Movie B\', 1), (\'Movie D\', 1), (\'Movie A\', 3), (\'Movie C\', 4)] >>> rank_movies([(\\"Movie X\\", 5.5), (\\"Movie Y\\", 5.5), (\\"Movie Z\\", 9.0)]) [(\'Movie Z\', 1), (\'Movie X\', 2), (\'Movie Y\', 2)] >>> rank_movies([(\\"Alpha\\", 10.0)]) [(\'Alpha\', 1)] >>> rank_movies([]) Traceback (most recent call last): ... ValueError: The input list must contain at least one movie. >>> rank_movies([(\\"Invalid\\", 11.0)]) Traceback (most recent call last): ... ValueError: Rating must be a float between 0.0 and 10.0. >>> rank_movies([(\\"\\", 5.0)]) Traceback (most recent call last): ... ValueError: Movie identifier must be a non-empty string. ``` Write the `rank_movies` function in Python as per the described requirements.","solution":"from typing import List, Tuple def rank_movies(movies: List[Tuple[str, float]]) -> List[Tuple[str, int]]: Ranks the given list of movies based on their ratings. Parameters: - movies (List[Tuple[str, float]]): A list of tuples where each tuple contains: - a string representing the movie identifier (unique name or ID), - a float representing the movie\'s rating (a value between 0.0 and 10.0). Returns: - List[Tuple[str, int]]: A list of tuples where each tuple contains: - the movie identifier, - the rank of the movie (integer) where 1 is the highest rank. if not movies: raise ValueError(\\"The input list must contain at least one movie.\\") for movie_id, rating in movies: if not isinstance(movie_id, str) or not movie_id: raise ValueError(\\"Movie identifier must be a non-empty string.\\") if not (isinstance(rating, float) and 0.0 <= rating <= 10.0): raise ValueError(\\"Rating must be a float between 0.0 and 10.0.\\") # Sort movies by rating in descending order, the highest rating first movies_sorted = sorted(movies, key=lambda x: (-x[1], x[0])) result = [] current_rank = 1 for i, (movie_id, rating) in enumerate(movies_sorted): if i > 0 and movies_sorted[i-1][1] != rating: current_rank = i + 1 result.append((movie_id, current_rank)) return result"},{"question":"# City Grid: Shortest Path with Obstacles You are to write a function that calculates the shortest path from the top-left to the bottom-right of a grid representing a city. Each cell in the grid can either be an empty space or an obstacle. You can only move up, down, left, or right. If it is impossible to reach the bottom-right cell, your function should return -1. Function Signature ```python def shortest_path_with_obstacles(grid: list[list[int]]) -> int: pass ``` Requirements: 1. Construct a path-finding algorithm that handles obstacles within the city grid. 2. The output should be the minimum number of steps from the top-left to the bottom-right corner or -1 if no such path exists. Function Implementation: * **Input**: A 2D list of integers `grid`, where each integer is either 0 (representing an empty space) or 1 (representing an obstacle). * **Output**: An integer representing the minimum number of steps required to reach the bottom-right corner or -1 if no path exists. Example ```python >>> shortest_path_with_obstacles([[0, 0, 0], [1, 1, 0], [0, 0, 0]]) 4 >>> shortest_path_with_obstacles([[0, 1], [1, 0]]) -1 ``` Constraints * The grid dimensions will be between 1x1 and 1000x1000. * Ensure that your algorithm efficiently handles large grids, considering time complexity. Notes Remember to handle edge cases gracefully: * A grid where the start or end point is blocked by an obstacle should immediately return -1. * Consider implementing popular pathfinding algorithms like BFS (Breadth-First Search) for optimality given the grid constraints. Good luck!","solution":"from collections import deque def shortest_path_with_obstacles(grid: list[list[int]]) -> int: rows, cols = len(grid), len(grid[0]) # If the starting or ending point is an obstacle, return -1 immediately. if grid[0][0] == 1 or grid[rows - 1][cols - 1] == 1: return -1 # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS initialization queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) # Set to keep track of visited cells while queue: current_row, current_col, steps = queue.popleft() # If we reach the bottom-right corner if current_row == rows - 1 and current_col == cols - 1: return steps # Explore all possible directions for dr, dc in directions: new_row, new_col = current_row + dr, current_col + dc # Check if the new position is within bounds and not blocked if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 0: if (new_row, new_col) not in visited: visited.add((new_row, new_col)) queue.append((new_row, new_col, steps + 1)) # If no path found, return -1 return -1"},{"question":"# Dynamic Memory Allocation Simulation for Linked List Scenario: You are tasked with simulating a dynamic memory allocator for a singly linked list in a system with constrained memory. Design and implement a class that manages a fixed-size memory block as an array and handles dynamic allocation and deallocation of nodes for a linked list within that memory block. Requirements: 1. **Memory Block Management**: Implement a memory simulator that initializes with a fixed-size block and supports allocation and deallocation of nodes. 2. **Linked List Operations**: Methods for inserting and deleting nodes in the linked list, as well as retrieving data. 3. **Error Handling**: Properly handle attempts to allocate memory when the block is full or attempting to access invalid memory addresses. Input & Output: * **Function Signatures**: ```python class MemoryAllocator: def __init__(self, size: int): # Initialize a memory block of the given fixed size pass def allocate(self, value: int) -> int: # Allocate memory for a node with the given value and return its index pass def deallocate(self, index: int) -> None: # Deallocate the memory block at the given index pass def get(self, index: int) -> int: # Get the value at the given index pass class LinkedList: def __init__(self, allocator: MemoryAllocator): # Initialize the linked list with a given memory allocator pass def insert(self, value: int) -> None: # Insert a new node with the given value pass def delete(self, value: int) -> bool: # Delete the node with the given value and return whether it was successful pass def find(self, value: int) -> int: # Find the index of the node with the given value or -1 if not found pass ``` * **Constraints**: * The memory block is represented as an array of fixed size where each element can store a value and a pointer(index) to the next node. * The allocator should raise `MemoryError` with the message \\"Out of memory\\" when there is no more space to allocate a new node. * The allocator should raise `ValueError` with the message \\"Invalid memory address\\" when trying to access or deallocate an invalid index. Example: ```python # Example usage: allocator = MemoryAllocator(size=10) linked_list = LinkedList(allocator) # Insert values into the linked list linked_list.insert(5) linked_list.insert(10) linked_list.insert(15) # Find node indices index = linked_list.find(10) assert index != -1 # Delete a value from the linked list assert linked_list.delete(10) == True assert linked_list.find(10) == -1 # Attempt to allocate more nodes than available would raise MemoryError try: for i in range(11): linked_list.insert(i) except MemoryError as e: assert str(e) == \\"Out of memory\\" ``` Implementation Details: Provide your implementation for the `MemoryAllocator` and `LinkedList` classes following the specifications and requirements provided.","solution":"class MemoryAllocator: def __init__(self, size: int): self.size = size self.memory = [None] * size self.used = [False] * size def allocate(self, value: int) -> int: for i in range(self.size): if not self.used[i]: self.memory[i] = (value, None) self.used[i] = True return i raise MemoryError(\\"Out of memory\\") def deallocate(self, index: int) -> None: if index < 0 or index >= self.size or not self.used[index]: raise ValueError(\\"Invalid memory address\\") self.memory[index] = None self.used[index] = False def get(self, index: int) -> (int, int): if index < 0 or index >= self.size or not self.used[index]: raise ValueError(\\"Invalid memory address\\") return self.memory[index] def set_next(self, index: int, next_index: int) -> None: if index < 0 or index >= self.size or not self.used[index]: raise ValueError(\\"Invalid memory address\\") value, _ = self.memory[index] self.memory[index] = (value, next_index) class LinkedList: def __init__(self, allocator: MemoryAllocator): self.allocator = allocator self.head = None def insert(self, value: int) -> None: new_index = self.allocator.allocate(value) if self.head is None: self.head = new_index else: current_index = self.head while True: _, next_index = self.allocator.get(current_index) if next_index is None: break current_index = next_index self.allocator.set_next(current_index, new_index) def delete(self, value: int) -> bool: if self.head is None: return False prev_index = None current_index = self.head while current_index is not None: current_value, next_index = self.allocator.get(current_index) if current_value == value: if prev_index is None: self.head = next_index else: _, _ = self.allocator.get(prev_index) self.allocator.set_next(prev_index, next_index) self.allocator.deallocate(current_index) return True prev_index = current_index current_index = next_index return False def find(self, value: int) -> int: current_index = self.head while current_index is not None: current_value, next_index = self.allocator.get(current_index) if current_value == value: return current_index current_index = next_index return -1"},{"question":"# Coding Question: Validate and Compute Course Grade **Objective:** Implement a function that calculates the final grade for a student based on a simplified grading system. Problem Statement: You need to write a function `calculate_grade(assignments: list, exam: float) -> str` that computes the final grade for a student based on their assignment scores and exam score according to the following rules: 1. Assignments collectively contribute 50% to the final grade. 2. The exam contributes 50% to the final grade. 3. The function must ensure that all assignment scores and the exam score are within a valid range of 0 to 100. The final grade should be a letter grade based on the following scale: - 90 to 100: \'A\' - 80 to 89: \'B\' - 70 to 79: \'C\' - 60 to 69: \'D\' - 0 to 59: \'F\' Function Signature: ```python def calculate_grade(assignments: list, exam: float) -> str: pass ``` Input: - A list `assignments` containing integers or floats, each representing a score between 0 and 100. The list can have variable length but will have at least one score. - A single float `exam`, representing the exam score between 0 and 100. Output: - A single character string representing the final grade (\'A\', \'B\', \'C\', \'D\', or \'F\'). Constraints: - The length of `assignments` is at least 1. - Each element in `assignments` is between 0 and 100 inclusive. - The `exam` score is between 0 and 100 inclusive. - The function must raise a `ValueError` if any score in `assignments` or `exam` is out of the valid range. Example: ```python # Example usage: result = calculate_grade(assignments=[85, 90, 92], exam=88) # Expected output: \'B\' print(result) result = calculate_grade(assignments=[70, 75], exam=80) # Expected output: \'C\' print(result) result = calculate_grade(assignments=[50, 50, 60], exam=55) # Expected output: \'F\' print(result) ``` Implement the `calculate_grade` function in Python ensuring proper validation and computation according to the given rules.","solution":"def calculate_grade(assignments: list, exam: float) -> str: # Validate the input scores if not all(0 <= score <= 100 for score in assignments) or not (0 <= exam <= 100): raise ValueError(\\"Scores must be between 0 and 100.\\") # Calculate the average of assignment scores average_assignment_score = sum(assignments) / len(assignments) # Calculate the final numeric grade final_numeric_grade = (0.5 * average_assignment_score) + (0.5 * exam) # Determine the final letter grade based on the numeric grade if 90 <= final_numeric_grade <= 100: return \'A\' elif 80 <= final_numeric_grade < 90: return \'B\' elif 70 <= final_numeric_grade < 80: return \'C\' elif 60 <= final_numeric_grade < 70: return \'D\' else: return \'F\'"},{"question":"# Coding Question: Cumulative Sum of Squares Write a Python function to calculate the cumulative sum of squares for given positive integers. Given a list of positive integers, the function should return a new list where each element at position `i` is the cumulative sum of squares of the elements from the start of the list up to `i`. Your Task Implement the function `cumulative_sum_of_squares(nums: list[int]) -> list[int]` that follows these rules: 1. Accepts one parameter: * `nums` (list of int): A list of positive integers. 2. Returns a new list where each element at position `i` is the cumulative sum of squares of the elements from the start of the list up to `i`. 3. If the list is empty, return an empty list. 4. Return an empty list if any of the elements in the list are non-positive integers. Example Usage ```python assert cumulative_sum_of_squares([1, 2, 3]) == [1, 5, 14] assert cumulative_sum_of_squares([3, 1, 4, 1, 5]) == [9, 10, 26, 27, 52] assert cumulative_sum_of_squares([5, 5, 5]) == [25, 50, 75] assert cumulative_sum_of_squares([]) == [] assert cumulative_sum_of_squares([0, 2, 3]) == [] ``` Constraints * `1 <= nums[i] <= 10^3` for all valid `i` * `0 <= len(nums) <= 10^3` Performance Requirements * Aim for an efficient solution with O(n) time complexity. * Ensure correctness and precision in arithmetic calculations. # Notes * Utilize Python\'s list and mathematical operations to create the solution. * Handle edge cases, such as an empty list or invalid elements, carefully.","solution":"def cumulative_sum_of_squares(nums): Returns the cumulative sum of squares of the elements in the list. If the list has non-positive integers, returns an empty list. If the list is empty, returns an empty list. if any(n <= 0 for n in nums): return [] result = [] cumulative_sum = 0 for num in nums: cumulative_sum += num ** 2 result.append(cumulative_sum) return result"},{"question":"# Problem Statement You are tasked with designing a function that reads a list of sentence strings and capitalizes the first letter of each word in those sentences. The function should also remove any leading or trailing whitespace. However, it should preserve any internal spaces exactly as provided. # Function Signature ```python def format_sentences(sentences: list[str]) -> list[str]: ``` # Input * `sentences`: A list of strings where each string represents a sentence. Each string can be of varying length. # Output * A list of strings where each string has the first letter of each word capitalized, and leading and trailing whitespace removed. # Constraints * `sentences` will contain between 1 and 1000 sentence strings. * Each sentence string will be of length between 1 and 1000 characters. * Sentences can include alphabets, numbers, punctuation marks, and spaces. # Example Input ```python sentences = [ \\" this is a test. \\", \\" another example, here! \\", \\"the quick brown fox \\", \\" jumps over the lazy dog. \\" ] ``` Output ```python [ \\"This Is A Test.\\", \\"Another Example, Here!\\", \\"The Quick Brown Fox\\", \\"Jumps Over The Lazy Dog.\\" ] ``` # Notes * The function should efficiently process each sentence regardless of its length. * It should not alter any internal spaces or original punctuation. * Ensure to handle edge cases such as empty strings or strings with only whitespace.","solution":"def format_sentences(sentences: list[str]) -> list[str]: Capitalizes the first letter of each word in each sentence and removes leading and trailing whitespace. Args: sentences (list of str): List of sentence strings. Returns: list of str: List of formatted sentence strings. formatted_sentences = [] for sentence in sentences: formatted_sentence = \' \'.join(word.capitalize() for word in sentence.strip().split()) formatted_sentences.append(formatted_sentence) return formatted_sentences"},{"question":"# Coding Assessment Question Scenario You are developing a route calculator for a delivery company that operates in a grid-based city. Your task is to find the shortest path from the starting warehouse to the target delivery destination using the A* (A-star) search algorithm. Function to Implement Implement the function `a_star_search(grid: list, start: tuple, goal: tuple) -> list` which finds the shortest path in a 2D grid from the start point to the goal point. Input 1. `grid`: A 2D list of integers where `0` represents a traversable cell and `1` denotes an obstacle. 2. `start`: A tuple `(x, y)` representing the starting coordinates in the grid. 3. `goal`: A tuple `(x, y)` representing the target coordinates in the grid. Output The function should return a list of tuples representing the shortest path from start to goal. If no path exists, return an empty list. Constraints 1. The grid dimensions are between 1 and 100. 2. The start and goal coordinates are within the grid bounds. 3. Ensure that edge cases like completely blocked paths or start equals goal are handled appropriately. Performance Requirements - The function should handle grids of up to 100x100 efficiently. - Aim for a time complexity of O(N * log(N)) where N is the number of cells in the grid. Example ```python grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0], ] start = (0, 0) goal = (4, 4) assert a_star_search(grid, start, goal) == [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (2, 3), (3, 3), (4, 3), (4, 4)] ``` **Note**: Consider using a heuristic function such as Manhattan distance to prioritize the search towards the goal.","solution":"import heapq def heuristic(a, b): return abs(a[0] - b[0]) + abs(a[1] - b[1]) def a_star_search(grid, start, goal): rows, cols = len(grid), len(grid[0]) open_set = [] heapq.heappush(open_set, (0, start)) came_from = {} g_score = {start: 0} f_score = {start: heuristic(start, goal)} directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while open_set: f_current, current = heapq.heappop(open_set) if current == goal: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) path.reverse() return path x, y = current for dx, dy in directions: neighbor = (x + dx, y + dy) if 0 <= neighbor[0] < rows and 0 <= neighbor[1] < cols and grid[neighbor[0]][neighbor[1]] == 0: tentative_g_score = g_score[current] + 1 if tentative_g_score < g_score.get(neighbor, float(\'inf\')): came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal) heapq.heappush(open_set, (f_score[neighbor], neighbor)) return []"},{"question":"# Binary Search Tree: Lowest Common Ancestor **Context**: Consider a Binary Search Tree (BST), and you are given two nodes in the tree. Your task is to find their lowest common ancestor (LCA). A lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself). # Task Write a function `find_lca` that determines the lowest common ancestor of two given nodes in a binary search tree. You may use the following class structure and method signatures: ```python class TreeNode: def __init__(self, data: Any, left: TreeNode = None, right: TreeNode = None) -> None: self.data = data self.left = left self.right = right class BinaryTree: def __init__(self) -> None: self.root = None def insert(self, data: Any) -> None: if self.root is None: self.root = TreeNode(data) else: self._insert_recursive(self.root, data) def _insert_recursive(self, node: TreeNode, data: Any) -> None: if data < node.data: if node.left is None: node.left = TreeNode(data) else: self._insert_recursive(node.left, data) else: if node.right is None: node.right = TreeNode(data) else: self._insert_recursive(node.right, data) def find_lca(root: TreeNode, node1: TreeNode, node2: TreeNode) -> TreeNode: # Your implementation here return ``` # Input * `root`: The root node of the BST. * `node1` and `node2`: Two nodes in the BST for which you need to find the lowest common ancestor. # Output * Return the node (TreeNode instance) that is the lowest common ancestor of `node1` and `node2`. # Constraints * Assume all TreeNode values are unique. * Consider edge cases such as the node1 or node2 being the same node or one of them being the root itself. # Example ```python # Consider the given example tree tree = BinaryTree() tree.insert(20) tree.insert(10) tree.insert(30) tree.insert(5) tree.insert(15) tree.insert(25) tree.insert(35) node1 = tree.root.left # Node with value 10 node2 = tree.root.right.left # Node with value 25 result = find_lca(tree.root, node1, node2) print(result.data) # Output should be 20 ``` Provide thorough edge case handling and ensure your implementation is efficient.","solution":"class TreeNode: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right class BinaryTree: def __init__(self): self.root = None def insert(self, data): if self.root is None: self.root = TreeNode(data) else: self._insert_recursive(self.root, data) def _insert_recursive(self, node, data): if data < node.data: if node.left is None: node.left = TreeNode(data) else: self._insert_recursive(node.left, data) else: if node.right is None: node.right = TreeNode(data) else: self._insert_recursive(node.right, data) def find_lca(root, node1, node2): while root: if root.data > node1.data and root.data > node2.data: root = root.left elif root.data < node1.data and root.data < node2.data: root = root.right else: return root return None"},{"question":"# Coding Assessment Question **Scenario**: You are a software developer at a logistics company developing a transportation management system. One of your tasks is to help optimize delivery routes by ensuring vehicles do not exceed their weight limits. For this, you need to write programs that calculate the total weight, determine the heaviest item, and find the maximum possible number of items that can be loaded without exceeding the weight limit. # Task Implement a set of functions to support these calculations. Specifically, you need to implement `calculate_total_weight`, `find_heaviest_item`, and `max_items_within_weight` that perform the following tasks respectively. Ensure the functions handle edge cases robustly according to the specifications provided below. # Specifications 1. **calculate_total_weight**: * **Input**: - `weights` (list of floats): A list representing the weights of different items. * **Output**: - Total weight (float). 2. **find_heaviest_item**: * **Input**: - `weights` (list of floats): A list representing the weights of different items. * **Output**: - Weight of the heaviest item (float). * **Constraints**: - If the list is empty, return `None`. 3. **max_items_within_weight**: * **Input**: - `weights` (list of floats): A list representing the weights of different items. - `max_weight` (float): Maximum weight capacity. * **Output**: - Maximum number of items that can be carried without exceeding the weight limit (int). * **Constraints**: - The input list can contain zero or more items. - Weights are non-negative floats. - `max_weight` is a non-negative float. # Implementation Write your solution in Python. The overall time complexity for each function should be efficient. # Example Usage ```python print(calculate_total_weight([10.5, 20.75, 15.0])) # Output: 46.25 print(find_heaviest_item([10.5, 20.75, 15.0])) # Output: 20.75 print(max_items_within_weight([10.5, 15.0, 20.75, 5.0], 30.0)) # Output: 2 ```","solution":"def calculate_total_weight(weights): Returns the total weight of a list of items. return sum(weights) def find_heaviest_item(weights): Returns the weight of the heaviest item in the list. If the list is empty, returns None. return max(weights, default=None) def max_items_within_weight(weights, max_weight): Returns the maximum number of items that can be carried without exceeding the weight limit. weights.sort() total_weight = 0 count = 0 for weight in weights: if total_weight + weight <= max_weight: total_weight += weight count += 1 else: break return count"},{"question":"**Scenario**: You are developing a tool that involves processing and manipulating lists of numerical data. As part of this development, you need to implement additional utility functions for analyzing and transforming lists of integers. # Task 1. **Function: `mode`**: - Write a function `mode` that accepts a list of integers and returns an integer representing the mode (the number that appears most frequently in the list). - If there are multiple modes, return the smallest one. - If the list is empty, return `None`. 2. **Function: `reverse_sublist`**: - Write a function `reverse_sublist` that accepts a list of integers and two indices, `start` and `end`. - The function should reverse the sublist from `start` to `end` (inclusive). - If `start` or `end` is out of bounds, raise an `IndexError` with an appropriate message. 3. **Function: `largest_sum_subarray`**: - Write a function `largest_sum_subarray` that accepts a list of integers and returns the sum of the contiguous subarray with the largest sum. - Implement this function using Kadane\'s algorithm for optimal performance. # Input and Output Format - **Input**: - For `mode`: param `numbers` (List[int]) - For `reverse_sublist`: params `lst` (List[int]), `start` (int), `end` (int) - For `largest_sum_subarray`: param `lst` (List[int]) - **Output**: - For `mode`: return the most frequently occurring integer (int). - For `reverse_sublist`: return the modified list. - For `largest_sum_subarray`: return the largest sum of a contiguous subarray (int). # Constraints - The input list for all functions will contain at most 10^4 integers. - The integers in the list can range from -10^6 to 10^6. # Example ```python # Function `mode` result_mode = mode([1, 2, 3, 2, 4, 2, 5, 3, 3]) # returns 2 # Function `reverse_sublist` modified_list = reverse_sublist([1, 2, 3, 4, 5], 1, 3) # returns [1, 4, 3, 2, 5] # Function `largest_sum_subarray` max_sum = largest_sum_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) # returns 6 (from subarray [4, -1, 2, 1]) ```","solution":"def mode(numbers): Returns the mode (most frequent number) of a list of integers. If there are multiple modes, return the smallest one. If the list is empty, return None. if not numbers: return None from collections import Counter freq = Counter(numbers) max_freq = max(freq.values()) # Get all numbers with the highest frequency modes = [num for num, count in freq.items() if count == max_freq] return min(modes) def reverse_sublist(lst, start, end): Reverses the sublist from start to end (inclusive). If start or end is out of bounds, raise an IndexError. if start < 0 or end >= len(lst) or start > end: raise IndexError(\\"start or end index out of bounds.\\") lst[start:end+1] = lst[start:end+1][::-1] return lst def largest_sum_subarray(lst): Returns the sum of the contiguous subarray with the largest sum. Uses Kadane\'s algorithm for optimal performance. if not lst: return 0 max_current = max_global = lst[0] for num in lst[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Multiples of a Number Given an integer `n`, write a function `find_multiples(n: int) -> List[int]` that returns a list of all the multiples of `n` up to 10 times `n` inclusive. Input * An integer `n` (2 ≤ n ≤ 1000). Output * A list of integers containing the multiples of `n` up to 10 times `n`. Example ```python assert find_multiples(3) == [3, 6, 9, 12, 15, 18, 21, 24, 27, 30] assert find_multiples(5) == [5, 10, 15, 20, 25, 30, 35, 40, 45, 50] assert find_multiples(11) == [11, 22, 33, 44, 55, 66, 77, 88, 99, 110] ``` # Context You are developing a function to generate multiples of a given integer. This function can be used in various applications such as generating sequences, solving mathematical problems, or in any situation where repetitive increments of a base integer are required. # Notes Consider edge cases such as: * The smallest possible value for `n`. * The largest possible value for `n`. * Ensuring the order and correct calculation of multiples.","solution":"from typing import List def find_multiples(n: int) -> List[int]: Returns a list of all the multiples of n up to 10 times n inclusive. return [n * i for i in range(1, 11)]"},{"question":"# Problem Statement **Scenario**: A robotics engineer is working on a path-finding algorithm for a robot that navigates through a grid. The grid consists of cells, some of which are impassable, and the robot needs to find the shortest path from a starting cell to a target cell. **Task**: Implement a function `shortest_path(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> int` to find the shortest path from the starting point to the target point in a 2D grid. The grid cells have values `0` for passable cells and `1` for impassable cells. **Function Signature**: ```python def shortest_path(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> int ``` **Input**: - `grid`: A 2D list of integers (`List[List[int]]`) representing the grid. `0` denotes a passable cell, and `1` denotes an impassable cell. The grid dimensions can be `1 <= rows, cols <= 500`. - `start`: A tuple `(x, y)` representing the starting cell in the grid. - `target`: A tuple `(x, y)` representing the target cell in the grid. **Output**: - An integer representing the length of the shortest path from the `start` cell to the `target` cell. If there is no possible path, return `-1`. # Constraints: - `1 <= rows, cols <= 500` - All values in `grid` are either `0` or `1`. - The start and target cells are within grid bounds and are passable (i.e., `grid[start[0]][start[1]] == 0` and `grid[target[0]][target[1]] == 0`). # Requirements: - Use breadth-first search (BFS) to explore the shortest path in the grid. - Ensure the solution handles edge cases such as start equals target and scenarios where no path exists efficiently. # Performance: - The function should operate efficiently, with a time complexity ideally in the order of O(rows * cols). # Example: ```python grid = [ [0, 1, 0, 0, 0], [0, 0, 0, 1, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 0, 0] ] assert shortest_path(grid, (0, 0), (4, 4)) == 8 assert shortest_path(grid, (0, 0), (1, 2)) == 3 assert shortest_path(grid, (0, 0), (4, 0)) == -1 ``` **Note**: The function should handle all edge cases, including the smallest and largest possible grid sizes, and should provide the correct results efficiently for large input grids.","solution":"from collections import deque from typing import List, Tuple def shortest_path(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> int: def is_within_bounds(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) def bfs(): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = set() queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited.add((start[0], start[1])) while queue: x, y, dist = queue.popleft() if (x, y) == target: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_within_bounds(nx, ny) and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 if grid[start[0]][start[1]] == 1 or grid[target[0]][target[1]] == 1: return -1 return bfs()"},{"question":"# Problem Statement Create a function `evaluate_expression` that evaluates a given arithmetic expression string to compute its value. The expression string contains non-negative integers and the operators `+`, `-`, `*`, `/`. The integer division should truncate toward zero. You should ensure the function handles the operator precedence correctly: multiplication and division have higher precedence than addition and subtraction. Operators of the same precedence should be applied from left to right. Function Signature ```python def evaluate_expression(expression: str) -> int: pass ``` Input - **Expression**: A string containing non-negative integers and the operators `+`, `-`, `*`, `/` (1 ≤ |expression| ≤ 100). Output - Returns an integer representing the result of evaluating the expression. Constraints - The input expression is a valid arithmetic expression. - Division by zero should not occur. - The result after any division should be truncated toward zero. Examples 1. Example 1 ```python expression = \\"3+2*2\\" assert evaluate_expression(expression) == 7 ``` Explanation: Multiplication has higher precedence than addition, so the expression is evaluated as `3 + (2 * 2)` which equals `7`. 2. Example 2 ```python expression = \\" 3/2 \\" assert evaluate_expression(expression) == 1 ``` Explanation: Division of 3 by 2 truncates toward zero, resulting in `1`. 3. Example 3 ```python expression = \\" 3+5 / 2 \\" assert evaluate_expression(expression) == 5 ``` Explanation: First, the division is performed as `5 / 2` resulting in `2`, then addition is carried out as `3 + 2` resulting in `5`. # Additional Information You can implement the function using a stack to properly handle operator precedence and ensure the correct order of operations. Consider removing any spaces in the input string to simplify processing. Handling integer division carefully is crucial for achieving the correct result.","solution":"def evaluate_expression(expression: str) -> int: Evaluates a given arithmetic expression string and computes its value. The expression contains non-negative integers and the operators +, -, *, /. def apply_operator(operands, operator): right = operands.pop() left = operands.pop() if operator == \'+\': operands.append(left + right) elif operator == \'-\': operands.append(left - right) elif operator == \'*\': operands.append(left * right) elif operator == \'/\': operands.append(int(left / right)) # Truncate towards zero # Remove spaces from the expression expression = expression.replace(\' \', \'\') operands = [] operators = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 operands.append(num) i -= 1 # to counter the last increment else: while (operators and operators[-1] in \\"*/\\" and expression[i] in \\"+-*/\\" or operators and operators[-1] in \\"+-\\" and expression[i] in \\"+-\\"): apply_operator(operands, operators.pop()) operators.append(expression[i]) i += 1 while operators: apply_operator(operands, operators.pop()) return operands[0]"},{"question":"# Question: Implement and Simulate a Queue Service with Processing Priority in Python Scenario You are building a task processing system where tasks can be added to a queue and processed based on their priority. Tasks with higher priority should be processed before tasks with lower priority. In addition, tasks with the same priority should be processed in the order they were added to the queue (FIFO for tasks of the same priority). Task 1. Implement a class `PriorityQueue` that supports addition and processing of tasks based on their priority: - The class should have an `add_task(priority: int, task: str)` method to add a task with a given priority. - The class should have a `process_task() -> str` method to process a task from the queue. - If no tasks are available to be processed, the `process_task` method should raise an `IndexError` with a suitable error message. 2. Implement a function `simulate_queue_service(tasks: List[Tuple[int, str]]) -> List[str]` that takes a list of tasks (each represented as a tuple of priority and task description) and returns the order in which tasks are processed. Input and Output Formats - **Input**: - For the function `add_task(priority: int, task: str)`, priority is an integer (higher value means higher priority) and task is a string. - For the method `simulate_queue_service(tasks: List[Tuple[int, str]])`, tasks is a list of tuples where each tuple contains an integer priority and a string task description. - **Output**: - The `process_task` method should return the task description (str) of the processed task. - The `simulate_queue_service` function should return a list of task descriptions in the order they are processed. Constraints: - Tasks can have any non-negative integer priority. - Strings for tasks\' descriptions should be non-empty and contain a maximum of 255 characters. - Implementations should handle up to 10,000 tasks efficiently. Performance Requirements: - The addition and processing of tasks should be optimized for performance, leveraging data structures that support priority-based operations. Implementation Hints: - You may use the `heapq` module or implement your own priority-based queue using appropriate data structures. - Ensure tasks with the same priority preserve the order in which they were added. Requirements: - Include error handling to catch and report incorrect inputs. - Add comments and documentation to describe the functionality and logic of key sections of your code. ```python import heapq from typing import List, Tuple class PriorityQueue: def __init__(self): self.queue = [] self.counter = 0 # To maintain FIFO order for tasks with the same priority def add_task(self, priority: int, task: str): heapq.heappush(self.queue, (-priority, self.counter, task)) self.counter += 1 def process_task(self) -> str: if not self.queue: raise IndexError(\\"No tasks available to process.\\") return heapq.heappop(self.queue)[2] def simulate_queue_service(tasks: List[Tuple[int, str]]) -> List[str]: pq = PriorityQueue() for priority, task in tasks: pq.add_task(priority, task) processed_tasks = [] while True: try: processed_tasks.append(pq.process_task()) except IndexError: break return processed_tasks # Sample usage: # tasks = [(2, \\"task1\\"), (3, \\"task2\\"), (1, \\"task3\\"), (3, \\"task4\\")] # print(simulate_queue_service(tasks)) # Expected order: [\\"task2\\", \\"task4\\", \\"task1\\", \\"task3\\"] ```","solution":"import heapq from typing import List, Tuple class PriorityQueue: def __init__(self): self.queue = [] self.counter = 0 # To maintain FIFO order for tasks with the same priority def add_task(self, priority: int, task: str): Adds a task with given priority to the queue. Higher priority tasks are added with negative priority to maintain a max-heap property. heapq.heappush(self.queue, (-priority, self.counter, task)) self.counter += 1 def process_task(self) -> str: Processes (removes and returns) the task with the highest priority from the queue. If the queue is empty, raises an IndexError. if not self.queue: raise IndexError(\\"No tasks available to process.\\") return heapq.heappop(self.queue)[2] def simulate_queue_service(tasks: List[Tuple[int, str]]) -> List[str]: Takes a list of tasks as (priority, task description) and processes them in the order of their priority. Returns the list of processed task descriptions in the order they were processed. pq = PriorityQueue() for priority, task in tasks: pq.add_task(priority, task) processed_tasks = [] while True: try: processed_tasks.append(pq.process_task()) except IndexError: break return processed_tasks # Sample usage: # tasks = [(2, \\"task1\\"), (3, \\"task2\\"), (1, \\"task3\\"), (3, \\"task4\\")] # print(simulate_queue_service(tasks)) # Expected order: [\\"task2\\", \\"task4\\", \\"task1\\", \\"task3\\"]"},{"question":"# Problem Statement You are tasked with implementing a custom data structure called `StockPriceTracker` to efficiently handle the following operations on stock prices in real-time: 1. **Initialization**: Initialize the data structure. 2. **Add Price**: Add the latest stock price with a provided timestamp. 3. **Update Price**: Update the stock price at a specific timestamp. 4. **Current Price**: Return the current/latest stock price. 5. **Max Price**: Return the maximum stock price recorded so far. 6. **Min Price**: Return the minimum stock price recorded so far. Your implementation must ensure efficient processing of these operations even as the number of prices grows. # Function Signatures ```python class StockPriceTracker: def __init__(self) -> None: Initializes the data structure. def add_price(self, timestamp: int, price: int) -> None: Adds a new stock price with the given timestamp. def update_price(self, timestamp: int, price: int) -> None: Updates the stock price at the given timestamp. def current_price(self) -> int: Returns the latest stock price. def max_price(self) -> int: Returns the maximum stock price recorded so far. def min_price(self) -> int: Returns the minimum stock price recorded so far. ``` # Input Constraints - The `timestamp` values will be unique integers and strictly increasing. - The `price` values are integers between `1` and `10^6`. - At any point in time, there will be at most `10^5` timestamps with associated prices. - The operations may be invoked frequently, and the data structure should handle updates and queries efficiently. # Example Usage ```python # Initialize the data structure tracker = StockPriceTracker() # Add prices with respective timestamps tracker.add_price(1, 100) tracker.add_price(2, 150) tracker.add_price(3, 120) # Get the current/latest stock price print(tracker.current_price()) # Output: 120 # Get the maximum price recorded so far print(tracker.max_price()) # Output: 150 # Get the minimum price recorded so far print(tracker.min_price()) # Output: 100 # Update the stock price at timestamp 2 tracker.update_price(2, 200) # Get the current/latest stock price print(tracker.current_price()) # Output: 120 # Get the maximum price recorded so far print(tracker.max_price()) # Output: 200 # Get the minimum price recorded so far print(tracker.min_price()) # Output: 100 ``` # Constraints - You must handle edge cases such as no prices being added yet when queries are made. - Ensure performance efficiency to handle real-time updates and frequent queries effectively. This problem tests your ability to design and implement a real-time data tracking system with efficient query and update capabilities.","solution":"class StockPriceTracker: def __init__(self) -> None: Initializes the data structure. self.prices = {} self.timestamps = [] self.current_timestamp = None def add_price(self, timestamp: int, price: int) -> None: Adds a new stock price with the given timestamp. self.prices[timestamp] = price self.timestamps.append(timestamp) self.current_timestamp = timestamp def update_price(self, timestamp: int, price: int) -> None: Updates the stock price at the given timestamp. if timestamp in self.prices: self.prices[timestamp] = price if timestamp == self.current_timestamp: self.current_timestamp = timestamp def current_price(self) -> int: Returns the latest stock price. if self.current_timestamp is None: raise ValueError(\\"No prices recorded yet.\\") return self.prices[self.current_timestamp] def max_price(self) -> int: Returns the maximum stock price recorded so far. if not self.prices: raise ValueError(\\"No prices recorded yet.\\") return max(self.prices.values()) def min_price(self) -> int: Returns the minimum stock price recorded so far. if not self.prices: raise ValueError(\\"No prices recorded yet.\\") return min(self.prices.values())"},{"question":"# Problem Statement You have been tasked with implementing a simple text editor that handles basic string operations. The editor should be able to perform the following: 1. Insert a substring at a specific position in the current text. 2. Delete a substring from the current text starting at a specific position. 3. Undo the last operation to restore the text to its previous state. You need to implement a class `SimpleEditor` that manages these operations and their reversals. # Requirements Class Definition: ```python class SimpleEditor: def __init__(self): self.text = \\"\\" self.history = [] def insert(self, pos: int, substring: str) -> None: pass def delete(self, pos: int, length: int) -> None: pass def undo(self) -> None: pass ``` Methods 1. **insert(pos: int, substring: str) -> None**: - Inserts `substring` into `self.text` at the position `pos`. - Stores the operation details in `self.history` for potential undo. 2. **delete(pos: int, length: int) -> None**: - Deletes `length` characters from `self.text` starting at the position `pos`. - Stores the operation details in `self.history` for potential undo. 3. **undo() -> None**: - Reverts the last insertion or deletion, restoring `self.text` to its previous state. - Raises an exception if there are no operations to undo. # Input - `pos`: An integer representing the position in the current text where the operation should be performed. - `substring`: A string to be inserted at the specified position. - `length`: An integer specifying the number of characters to be deleted starting from the specified position. # Constraints - The `pos` will always be a valid index within the bounds of the current text for insertion or deletion. - The `length` for deletion will always be valid, i.e., `pos + length` will not exceed the current length of the text. - Multiple consecutive `undo` operations should be supported, provided there are operations to undo. # Example ```python editor = SimpleEditor() # Perform operations editor.insert(0, \\"hello\\") # text = \\"hello\\" editor.insert(5, \\" world\\") # text = \\"hello world\\" editor.delete(5, 6) # text = \\"hello\\" # Undo operations editor.undo() # undo delete, text = \\"hello world\\" editor.undo() # undo insert \\" world\\", text = \\"hello\\" print(editor.text) # Output: \\"hello\\" ``` # Performance Requirements - The time complexity for each method should be optimal, ensuring real-time performance for insertion, deletion, and undo. - Space complexity should accommodate the need for storing operation history but remain manageable. Implement the `SimpleEditor` class to handle the text editing functions and their respective undo functionalities effectively.","solution":"class SimpleEditor: def __init__(self): self.text = \\"\\" self.history = [] def insert(self, pos: int, substring: str) -> None: # Perform the insert operation self.text = self.text[:pos] + substring + self.text[pos:] # Save the operation to history for undo self.history.append((\'insert\', pos, substring)) def delete(self, pos: int, length: int) -> None: # Save the part of the text to be deleted to history for undo deleted_part = self.text[pos:pos + length] self.text = self.text[:pos] + self.text[pos + length:] # Save the operation to history for undo self.history.append((\'delete\', pos, deleted_part)) def undo(self) -> None: if not self.history: raise Exception(\\"No operations to undo\\") # Get the last operation op_type, pos, text = self.history.pop() if op_type == \'insert\': # For an insert operation, remove the inserted text self.text = self.text[:pos] + self.text[pos + len(text):] elif op_type == \'delete\': # For a delete operation, reinsert the deleted text self.text = self.text[:pos] + text + self.text[pos:]"},{"question":"# Problem Statement You are tasked with developing a function for a library management system that categorizes books based on the decade they were published. Your objective is to write a function that takes a list of publication years and returns the count of books published in each decade. # Function Signature ```python def categorize_books(years: List[int]) -> Dict[int, int]: pass ``` # Input - A list of integers, `years`, where each integer represents the publication year of a book. (1 ≤ length of `years` ≤ 10^5, 1800 ≤ year ≤ 2023) # Output - A dictionary where the keys are decades (e.g., 1980, 1990) and the values are the counts of books published in those decades. # Constraints - The function should consider decades from 1800 onwards. - Aim to achieve an efficient time complexity. # Examples 1. **Example 1:** - Input: `years = [1983, 1990, 1992, 2001, 2019, 2023]` - Output: `{1980: 1, 1990: 2, 2000: 1, 2010: 1, 2020: 1}` - Explanation: The books are categorized into decades as follows: - One book from the 1980s. - Two books from the 1990s. - One book from the 2000s. - One book from the 2010s. - One book from the 2020s. 2. **Example 2:** - Input: `years = [2005, 1965, 1980, 1981, 1982, 2020]` - Output: `{2000: 1, 1960: 1, 1980: 3, 2020: 1}` - Explanation: The books are categorized into decades as follows: - One book from the 2000s. - One book from the 1960s. - Three books from the 1980s. - One book from the 2020s. 3. **Example 3:** - Input: `years = [1923, 1947, 1984, 1910, 2003]` - Output: `{1920: 1, 1940: 1, 1980: 1, 1910: 1, 2000: 1}` - Explanation: The books are categorized into decades as follows: - One book from the 1920s. - One book from the 1940s. - One book from the 1980s. - One book from the 1910s. - One book from the 2000s. # Performance Requirements Your solution should be efficient with a linear time complexity, (O(n)), where (n) is the number of publication years.","solution":"from typing import List, Dict def categorize_books(years: List[int]) -> Dict[int, int]: Categorizes a list of publication years into the respective decades and counts the number of books published in each decade. Parameters: years (List[int]): A list of integers where each integer represents the publication year of a book. Returns: Dict[int, int]: A dictionary where the keys are decades and the values are the counts of books published in those decades. decade_count = {} for year in years: decade = (year // 10) * 10 if decade in decade_count: decade_count[decade] += 1 else: decade_count[decade] = 1 return decade_count"},{"question":"Task Write a function that reads a log file and extracts the timestamps of all error messages. The function should parse through a log file, identify lines that report errors, and return a list of timestamps associated with each of those error messages. # Details **Function Signature**: ```python def extract_error_timestamps(log_file: str) -> List[str]: ... ``` # Parameters - `log_file`: A string representing the path to the log file to be analyzed. # Output - A list of strings where each string is a timestamp associated with an error message in the log file. # Constraints - Assume the log file is well-formed with each line adhering to the format: `[TIMESTAMP] [LOG LEVEL] [MESSAGE]`. - Timestamps are in ISO 8601 format (e.g., `2023-10-12T14:48:00Z`). - Log levels can be one of the following: `INFO`, `WARN`, `ERROR`, `DEBUG`. # Example Assume `log_file` contains the following lines: ``` [2023-10-12T14:48:00Z] INFO Application started [2023-10-12T14:49:00Z] ERROR Failed to connect to database [2023-10-12T14:50:00Z] WARN Server response delayed [2023-10-12T14:51:00Z] ERROR Null pointer exception [2023-10-12T14:52:00Z] DEBUG User logged in ``` The function should return: ```python [\'2023-10-12T14:49:00Z\', \'2023-10-12T14:51:00Z\'] ``` # Guidelines - Ensure the function efficiently reads and processes the log file. - Handle potential edge cases, such as empty log files or log files without error messages. - You may assume that the log file can fit in memory for the purpose of this task. ```python from typing import List def extract_error_timestamps(log_file: str) -> List[str]: error_timestamps = [] with open(log_file, \'r\') as file: for line in file: parts = line.strip().split(\' \', 2) if len(parts) >= 3: timestamp, log_level, _ = parts[0], parts[1], parts[2] if log_level == \'ERROR\': error_timestamps.append(timestamp[1:-1]) # Removing square brackets from timestamp return error_timestamps # Example usage log_file_content = \'\'\'[2023-10-12T14:48:00Z] INFO Application started [2023-10-12T14:49:00Z] ERROR Failed to connect to database [2023-10-12T14:50:00Z] WARN Server response delayed [2023-10-12T14:51:00Z] ERROR Null pointer exception [2023-10-12T14:52:00Z] DEBUG User logged in\'\'\' with open(\'sample_log_file.log\', \'w\') as f: f.write(log_file_content) print(extract_error_timestamps(\'sample_log_file.log\')) # Expected: [\'2023-10-12T14:49:00Z\', \'2023-10-12T14:51:00Z\'] ```","solution":"from typing import List def extract_error_timestamps(log_file: str) -> List[str]: error_timestamps = [] with open(log_file, \'r\') as file: for line in file: parts = line.strip().split(\' \', 2) if len(parts) >= 3: timestamp, log_level, _ = parts[0], parts[1], parts[2] if log_level == \'ERROR\': error_timestamps.append(timestamp[1:-1]) # Removing square brackets from timestamp return error_timestamps # Example usage log_file_content = \'\'\'[2023-10-12T14:48:00Z] INFO Application started [2023-10-12T14:49:00Z] ERROR Failed to connect to database [2023-10-12T14:50:00Z] WARN Server response delayed [2023-10-12T14:51:00Z] ERROR Null pointer exception [2023-10-12T14:52:00Z] DEBUG User logged in\'\'\' with open(\'sample_log_file.log\', \'w\') as f: f.write(log_file_content) print(extract_error_timestamps(\'sample_log_file.log\')) # Expected: [\'2023-10-12T14:49:00Z\', \'2023-10-12T14:51:00Z\']"},{"question":"# Prime Factorization Solver # Background Prime factorization is the process of determining the prime numbers that multiply together to give a certain original number. This concept is fundamental in various fields of mathematics and computer science, especially within number theory and cryptography. # Problem You are required to write a function `prime_factors(n: int) -> list` that returns the prime factors of a given integer `n`. # Inputs - `n`: An integer greater than 1. # Outputs A list of integers representing the prime factors of `n`. Each prime factor should appear in the list as many times as it divides `n`. # Constraints - The input integer n will always be greater than 1. # Examples ```python assert prime_factors(28) == [2, 2, 7] assert prime_factors(50) == [2, 5, 5] assert prime_factors(97) == [97] ``` **Your task** is to implement the `prime_factors` function that computes the prime factors of the given integer accurately. Ensure that you: - Efficiently find and list all the prime factors of `n`. - Handle large values of `n` within a reasonable time frame.","solution":"def prime_factors(n): Returns a list of the prime factors of n. factors = [] # Divide out all 2\'s first while n % 2 == 0: factors.append(2) n //= 2 # Then try odd numbers starting from 3 divisor = 3 while n != 1 and divisor * divisor <= n: while n % divisor == 0: factors.append(divisor) n //= divisor divisor += 2 # If there\'s any prime number greater than sqrt(n) left if n > 1: factors.append(n) return factors"},{"question":"# Coding Assessment Question **Scenario**: You are developing a logistics system that tracks the inventory of multiple warehouses. Each warehouse has a set number of items, and each item can be either essential or non-essential. Your goal is to determine the total number of essential items across all warehouses and the warehouse with the highest number of essential items. **Task**: Implement a Python function `inventory_analysis` that takes a list of dictionaries, each representing a warehouse and containing the counts of essential and non-essential items. The function should return the total number of essential items and the index of the warehouse with the highest number of essential items. **Function Signature**: ```python def inventory_analysis(warehouses: list) -> tuple: Analyze the inventory of multiple warehouses to find the total number of essential items and the warehouse with the highest count of essential items. Parameters: - warehouses (list): A list of dictionaries, where each dictionary has two keys: - \'essential\' (int): Count of essential items in the warehouse (non-negative) - \'non_essential\' (int): Count of non-essential items in the warehouse (non-negative) Returns: - tuple: A tuple with two elements: - int: Total number of essential items across all warehouses - int: Index of the warehouse with the highest number of essential items Exceptions: - Raise ValueError if any count is negative. pass ``` **Constraints**: - Ensure all item counts are non-negative. - There will be at least one warehouse in the input list. **Performance Requirements**: - The function should run in linear time O(n) where n is the number of warehouses. **Examples**: ```python >>> warehouses = [ {\'essential\': 50, \'non_essential\': 30}, {\'essential\': 75, \'non_essential\': 50}, {\'essential\': 65, \'non_essential\': 20} ] >>> inventory_analysis(warehouses) (190, 1) >>> warehouses = [ {\'essential\': 20, \'non_essential\': 15}, {\'essential\': 10, \'non_essential\': 5}, {\'essential\': 20, \'non_essential\': 1} ] >>> inventory_analysis(warehouses) (50, 0) >>> warehouses = [ {\'essential\': 20, \'non_essential\': -5}, {\'essential\': 10, \'non_essential\': 5} ] Traceback (most recent call last): ... ValueError: All item counts must be non-negative ```","solution":"def inventory_analysis(warehouses): Analyze the inventory of multiple warehouses to find the total number of essential items and the warehouse with the highest count of essential items. Parameters: - warehouses (list): A list of dictionaries, where each dictionary has two keys: - \'essential\' (int): Count of essential items in the warehouse (non-negative) - \'non_essential\' (int): Count of non-essential items in the warehouse (non-negative) Returns: - tuple: A tuple with two elements: - int: Total number of essential items across all warehouses - int: Index of the warehouse with the highest number of essential items Exceptions: - Raise ValueError if any count is negative. total_essentials = 0 max_essentials = -1 index_of_max = -1 for i, warehouse in enumerate(warehouses): essential = warehouse[\'essential\'] non_essential = warehouse[\'non_essential\'] if essential < 0 or non_essential < 0: raise ValueError(\\"All item counts must be non-negative\\") total_essentials += essential if essential > max_essentials: max_essentials = essential index_of_max = i return (total_essentials, index_of_max)"},{"question":"Write a function that simulates a throttle controller for an electric vehicle. The throttle controller takes a desired speed and current speed as inputs and determines the throttle percentage to achieve the desired speed. The function should consider if the vehicle is currently accelerating or decelerating and adjust the throttle accordingly. # Function Definition Implement the function `throttle_controller(desired_speed, current_speed)` that takes in two numerical values: - `desired_speed`: The speed the vehicle aims to reach (in km/h), - `current_speed`: The current speed of the vehicle (in km/h). # Return Format The function should return a dictionary with the following keys and their corresponding values: - `\'throttle\'`: Throttle percentage required to reach the desired speed. (a float value between 0 and 100) - `\'action\'`: A string indicating whether the vehicle should \'accelerate\', \'maintain\', or \'decelerate\' its speed. # Constraints - Both `desired_speed` and `current_speed` are floating-point numbers between 0 and 200 km/h. - If `desired_speed` equals to `current_speed`, the throttle percentage should be 0 and the action should be \'maintain\'. - If `desired_speed` is greater than `current_speed`, the throttle percentage should be calculated based on the difference where full throttle (100%) corresponds to a 50 km/h speed difference. - If `desired_speed` is less than `current_speed`, the throttle percentage should be 0 and the action should be \'decelerate\'. # Example ```python desired_speed = 80 current_speed = 50 result = throttle_controller(desired_speed, current_speed) # Expected Output: # { # \'throttle\': 60.0, # \'action\': \'accelerate\' # } desired_speed = 120 current_speed = 120 result = throttle_controller(desired_speed, current_speed) # Expected Output: # { # \'throttle\': 0.0, # \'action\': \'maintain\' # } ``` # Additional Information - The throttle percentage should be a linear interpolation between 0 and 100 based on the difference in speeds. - Assume that the vehicle\'s maximum throttle capacity corresponds proportionally to the speed difference up to 50 km/h. Use appropriate logic to ensure the throttle percentage does not exceed 100%.","solution":"def throttle_controller(desired_speed, current_speed): Determines the throttle percentage and action for an electric vehicle to reach the desired speed from the current speed. Parameters: desired_speed (float): The speed the vehicle aims to reach in km/h. current_speed (float): The current speed of the vehicle in km/h. Returns: dict: A dictionary with \'throttle\' and \'action\' keys. # Initialize the result dictionary result = {\'throttle\': 0.0, \'action\': \'\'} # Calculate the speed difference speed_difference = desired_speed - current_speed if speed_difference > 0: # Accelerate result[\'action\'] = \'accelerate\' result[\'throttle\'] = min((speed_difference / 50.0) * 100, 100) elif speed_difference < 0: # Decelerate result[\'action\'] = \'decelerate\' result[\'throttle\'] = 0.0 else: # Maintain result[\'action\'] = \'maintain\' result[\'throttle\'] = 0.0 return result"},{"question":"# Question: Efficient String Compression Algorithm Context In data compression, run-length encoding (RLE) is a simple and effective method where consecutive elements (runs) are stored as a single data value and count. Your task is to implement an optimized algorithm that compresses a given string using RLE but in a way that minimizes the length of the resulting compressed string, while ensuring performance optimization suitable for very large input strings. Task Write a Python function `compress_string(s: str) -> str` that compresses the input string `s` using run-length encoding. Implementation Details - **Input**: - `s` (str): A string consisting of uppercase English letters (A-Z) with a maximum length of ( 10^6 ). - **Output**: - Return the run-length encoded version of the string `s`. - The encoding format should be such that character counts are concatenated directly to the character. For example, \\"AAABBC\\" would be compressed to \\"A3B2C1\\". Constraints - Your solution should be optimized to handle the maximum input length efficiently. - Ensure that the solution minimizes both time and space complexity. Example ```python assert compress_string(\\"AAABBC\\") == \\"A3B2C1\\" assert compress_string(\\"AAABBCAA\\") == \\"A3B2C1A2\\" assert compress_string(\\"A\\" * 1000000) == \\"A1000000\\" ``` Hints - Consider using an iterative approach to avoid the overhead associated with recursion in Python. - Efficiently handle the string concatenation to avoid excessive time complexity due to repeated string operations. - Pre-allocate space or utilize efficient data structures like lists to build the result. **Note**: Ensure to handle edge cases such as very short strings or strings with no repeating characters effectively.","solution":"def compress_string(s: str) -> str: Compress a string using run-length encoding. Args: s (str): The input string consisting of uppercase English letters. Returns: str: The run-length encoded version of the string. if not s: return s result = [] count = 1 current_char = s[0] for char in s[1:]: if char == current_char: count += 1 else: result.append(current_char + str(count)) current_char = char count = 1 result.append(current_char + str(count)) return \'\'.join(result)"},{"question":"# Coding Question: Circular Buffer Implementation Scenario You have been tasked to implement a circular buffer (ring buffer), which is a fixed-size data structure that uses a single, fixed-size buffer as if it were connected end-to-end. This type of data structure is useful in managing data for real-time applications such as buffering data streams. Requirements - Implement a class `CircularBuffer` that creates a circular buffer of a given size. - The class should have methods to add items to the buffer (`write`), read items from the buffer (`read`), and check if the buffer is empty or full. - Ensure the buffer overwrites the oldest data when it becomes full. Class and Methods ```python class CircularBuffer: def __init__(self, size: int): # constructor to initialize the buffer pass def write(self, value: any) -> None: # method to write data to the buffer pass def read(self) -> any: # method to read data from the buffer pass def is_empty(self) -> bool: # method to check if the buffer is empty pass def is_full(self) -> bool: # method to check if the buffer is full pass ``` Constraints 1. The size of the circular buffer will be a positive integer greater than 1. 2. The buffer should handle different data types (integers, strings, objects, etc.). 3. Ensure that read and write operations have an O(1) time complexity. Examples ```python buffer = CircularBuffer(3) buffer.write(1) buffer.write(2) print(buffer.read()) # 1 buffer.write(3) buffer.write(4) print(buffer.read()) # 2 print(buffer.read()) # 3 print(buffer.is_empty()) # False print(buffer.is_full()) # False buffer.write(5) print(buffer.is_full()) # True buffer.write(6) print(buffer.read()) # 5 (4 was overwritten by 6) print(buffer.read()) # 6 print(buffer.is_empty()) # True ``` Ensure your implementation passes these examples and adheres to the specified constraints after testing.","solution":"class CircularBuffer: def __init__(self, size: int): self.size = size self.buffer = [None] * size self.start = 0 self.end = 0 self.is_empty_flag = True def write(self, value: any) -> None: if not self.is_empty_flag and self.start == self.end: self.start = (self.start + 1) % self.size # Overwrite the oldest data self.buffer[self.end] = value self.end = (self.end + 1) % self.size self.is_empty_flag = False def read(self) -> any: if self.is_empty_flag: raise IndexError(\\"Read from empty buffer\\") value = self.buffer[self.start] self.buffer[self.start] = None self.start = (self.start + 1) % self.size if self.start == self.end: self.is_empty_flag = True return value def is_empty(self) -> bool: return self.is_empty_flag def is_full(self) -> bool: return not self.is_empty_flag and self.start == self.end"},{"question":"# Text File Line Counter Context: You are working on a text processing tool that needs to analyze text files. One of the functions you need to implement is a line counter which counts the number of lines that match given criteria. This particular function focuses on counting lines that contain a specific keyword and are not empty. Function Signature: ```python def count_lines_with_keyword(file_path: str, keyword: str) -> int: pass ``` Input: - `file_path`: A string representing the path to the text file. - `keyword`: A string representing the keyword to search for in each line. Output: - An integer representing the number of non-empty lines in the file that contain the specified keyword. Constraints: - Each line in the file should be treated independently. - Lines that are empty (only contain whitespace characters) should not be counted. - The search for the keyword should be case-sensitive. - Assume that the file exists and is accessible for reading. Example: Consider a text file `example.txt` with the following content: ``` Hello World This is a sample text file. It contains multiple lines. Some lines contain the keyword. keyword: Python Do not count this line. ``` If `keyword = \'keyword\'`: ```python file_path = \'example.txt\' keyword = \'keyword\' print(count_lines_with_keyword(file_path, keyword)) # Output: 2 ``` - The lines \\"Some lines contain the keyword.\\" and \\"keyword: Python\\" contain the keyword. - The empty line is not counted. # Requirements: - Implement the `count_lines_with_keyword` function to read the file, process each line according to the given criteria, and return the correct count. - Avoid reading the entire file into memory if possible, to handle large files efficiently. - Ensure edge cases (e.g., files with no matching lines, files with only empty lines) are correctly handled.","solution":"def count_lines_with_keyword(file_path: str, keyword: str) -> int: Function to count non-empty lines in a text file that contain a specific keyword. Args: file_path (str): The path to the file. keyword (str): The keyword to search for. Returns: int: The number of non-empty lines that contain the keyword. count = 0 with open(file_path, \'r\') as file: for line in file: # Strip the line to remove leading/trailing whitespace characters stripped_line = line.strip() if stripped_line and keyword in stripped_line: count += 1 return count"},{"question":"# Binary String Summation Background Binary numbers are the foundation of all digital systems. Sometimes, it is necessary to add two binary numbers to get a resultant binary number as a string. When adding binary numbers, if the sum of two bits is greater than 1, we carry over to the next higher bit. This process is similar to the addition of decimal numbers but in the binary system. Task Write a function `binary_sum(bin1: str, bin2: str) -> str` that takes two binary strings and returns their sum as a binary string. Input - `bin1`: A string representing a binary number. - `bin2`: A string representing a binary number. Output - Returns a string which is the sum of the two binary numbers. Constraints - The input strings will only contain \'0\'s and \'1\'s. - The length of each input string is between 1 and 1000. Example ```python >>> binary_sum(\'1010\', \'1101\') \'10111\' >>> binary_sum(\'101\', \'1\') \'110\' >>> binary_sum(\'0\', \'0\') \'0\' ``` Additional Notes - Leading zeros in the output should be minimized (i.e., the output should not have leading zeros). - The function needs to handle cases where the binary strings are of different lengths. Your task is to implement this `binary_sum` function correctly and efficiently.","solution":"def binary_sum(bin1: str, bin2: str) -> str: Returns the sum of two binary numbers represented as strings. # Normalize lengths max_len = max(len(bin1), len(bin2)) bin1 = bin1.zfill(max_len) bin2 = bin2.zfill(max_len) carry = 0 result = [] for i in range(max_len - 1, -1, -1): total_sum = int(bin1[i]) + int(bin2[i]) + carry carry = total_sum // 2 result.append(str(total_sum % 2)) if carry: result.append(\'1\') result.reverse() return \'\'.join(result).lstrip(\'0\') or \'0\'"},{"question":"# Question: Implement a Circular Queue with Dynamic Resizing Your task is to implement a circular queue with dynamic resizing in Python. The circular queue should automatically resize when it becomes full. Specifically: 1. **Implement a class `CircularQueue`** that supports standard queue operations (`enqueue`, `dequeue`, `is_empty`, `is_full`, `size`). 2. **Add dynamic resizing**: When the queue becomes full, it should double its capacity. **Class Definition and Method Signatures**: ```python class CircularQueue: def __init__(self, capacity: int = 4): pass def enqueue(self, item: int) -> None: pass def dequeue(self) -> int: pass def is_empty(self) -> bool: pass def is_full(self) -> bool: pass def size(self) -> int: pass ``` **Input/Output**: - The `CircularQueue` class should be initialized with an integer `capacity`, representing the initial capacity of the queue. - `enqueue` method accepts an `item` to be added to the queue. - `dequeue` method removes and returns the item from the front of the queue. - `is_empty` method returns `True` if the queue is empty; otherwise, it returns `False`. - `is_full` method returns `True` if the queue is full; otherwise, it returns `False`. - `size` method returns the current number of items in the queue. **Constraints**: - The initial capacity of the queue will always be a positive integer. - Handle the resizing efficiently to ensure enqueue and dequeue operations remain optimal. - Properly manage the circular nature of the queue to maintain correct order of elements after resizing. Example Usage: ```python cq = CircularQueue(2) print(cq.is_empty()) # Output: True cq.enqueue(1) cq.enqueue(2) print(cq.is_full()) # Output: True cq.enqueue(3) print(cq.size()) # Output: 3 (queue should have resized when the third element was added) print(cq.dequeue()) # Output: 1 print(cq.dequeue()) # Output: 2 print(cq.dequeue()) # Output: 3 print(cq.is_empty()) # Output: True ``` Ensure to test your `CircularQueue` implementation comprehensively, including edge cases like enqueuing into a full queue, dequeuing from an empty queue, and the resizing functionality.","solution":"class CircularQueue: def __init__(self, capacity: int = 4): self.queue = [None] * capacity self.capacity = capacity self.front = 0 self.rear = 0 self.count = 0 def enqueue(self, item: int) -> None: if self.is_full(): self.resize(2 * self.capacity) self.queue[self.rear] = item self.rear = (self.rear + 1) % self.capacity self.count += 1 def dequeue(self) -> int: if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") item = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.count -= 1 return item def is_empty(self) -> bool: return self.count == 0 def is_full(self) -> bool: return self.count == self.capacity def size(self) -> int: return self.count def resize(self, new_capacity: int) -> None: new_queue = [None] * new_capacity for i in range(self.count): new_queue[i] = self.queue[(self.front + i) % self.capacity] self.queue = new_queue self.capacity = new_capacity self.front = 0 self.rear = self.count"},{"question":"**[Question 2]: Implement a function `find_peak_element(nums: List[int]) -> int` that finds a peak element in an input list where a peak element is an element that is greater than its neighbors. The function should return the index of any one of the peak elements. Assume the list may contain multiple peaks, in which case you can return the index of any peak.** # Function Signature: ```python def find_peak_element(nums: List[int]) -> int: ``` # Input: * `nums` (List[int]): A list of integers where `1 ≤ len(nums) ≤ 10^4`. # Output: * An integer representing the index of a peak element in the list. In case of multiple peaks, the index of any one of them can be returned. # Constraints: * The input list will always have at least one peak element. * The elements `nums[i]` where `0 ≤ i ≤ len(nums) - 1` can be any valid integer. * If the list has only one element, that element is considered to be a peak element. # Examples: ```python >>> nums = [1, 2, 3, 1] >>> find_peak_element(nums) 2 >>> nums = [1, 2, 1, 3, 5, 6, 4] >>> find_peak_element(nums) 5 >>> nums = [1] >>> find_peak_element(nums) 0 >>> nums = [2, 1] >>> find_peak_element(nums) 0 >>> nums = [1, 2, 3, 4, 5] >>> find_peak_element(nums) 4 ``` # Notes: * Peak elements are elements that are strictly greater than their neighbors. * Consider edge cases where the peak element may be at the start or the end of the list. * The function should be optimized to perform efficiently even for large input sizes (up to 10,000 elements).","solution":"from typing import List def find_peak_element(nums: List[int]) -> int: Finds a peak element in the list nums and returns its index. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] < nums[mid + 1]: left = mid + 1 else: right = mid return left"},{"question":"# Problem: Generate N-Dimensional Hypercube You are tasked with writing a function that generates the vertices and the edges of an n-dimensional hypercube, also known as an n-cube or measure polytope, where `n` is the number of dimensions. # Requirements 1. **Input**: - An integer `n` representing the number of dimensions. Assume (0 leq n leq 7). 2. **Output**: - A list of tuples representing the vertices of the n-dimensional hypercube. - A set of tuples representing the edges of the n-dimensional hypercube, where each tuple contains two vertices indicating an edge. # Hypercube Definition - **Vertices**: An n-dimensional hypercube has (2^n) vertices. Each vertex can be defined as a binary vector of length `n` with each element being either 0 or 1. - **Edges**: An edge connects two vertices if their binary vectors differ by exactly one bit. # Function Specification Implement a function `generate_hypercube(n)` that accepts: - `n`: An integer representing the number of dimensions. and returns: - A list of tuples where each tuple is a vertex in the hypercube. - A set of tuples where each tuple represents an edge connecting two vertices. # Constraints 1. The function should handle all edge cases, including `n = 0` where the hypercube is a single point. 2. Optimize your algorithm to handle up to 7 dimensions efficiently. # Example ```python vertices, edges = generate_hypercube(2) print(vertices) # Output: [(0, 0), (0, 1), (1, 0), (1, 1)] print(edges) # Output: {((0, 0), (0, 1)), ((0, 0), (1, 0)), ((1, 1), (0, 1)), ((1, 1), (1, 0))} ``` # Notes 1. **Vertices**: Ensure that the vertices are represented as tuples of binary values. 2. **Edges**: Ensure that each edge connects vertices differing by exactly one bit without duplication. 3. **Efficiency**: Pay attention to the performance, especially for higher dimensions, while generating vertices and edges. Create the function `generate_hypercube(n)` to meet the specific requirements and constraints, ensuring to test with various values of `n` for expected outputs.","solution":"from itertools import combinations def generate_hypercube(n): Generates the vertices and edges of an n-dimensional hypercube. Parameters: n (int): The number of dimensions of the hypercube. Returns: tuple: A list of vertices and a set of edges representing the hypercube. # Generate vertices vertices = [] for i in range(2**n): vertex = tuple((i >> j) & 1 for j in range(n)) vertices.append(vertex) # Generate edges edges = set() for v1, v2 in combinations(vertices, 2): # Calculate the Hamming distance between v1 and v2 if sum(a != b for a, b in zip(v1, v2)) == 1: edges.add((v1, v2)) return vertices, edges"},{"question":"# Context You are provided with a set of images and a target image. Your task is to implement an image search algorithm that identifies the closest matching image from the set, based on pixel intensity differences. You need to write functions to calculate the difference between two images and find the most similar one. # Requirements 1. Implement a function to calculate the pixel intensity difference between two images. 2. Implement a function to find the image from the set that has the smallest difference to the target image. 3. Ensure that your implementation can handle images of the same size and format. # Input/Output 1. **Function**: `calculate_difference(image1, image2)` - **Arguments**: - `image1`: 2D list representing the first image (each element is a pixel intensity value). - `image2`: 2D list representing the second image (same size as `image1`). - **Returns**: Integer value representing the total absolute pixel intensity difference between the two images. 2. **Function**: `find_closest_image(image_set, target_image)` - **Arguments**: - `image_set`: List of 2D lists, each representing an image. - `target_image`: 2D list representing the target image. - **Returns**: Index of the image in `image_set` which is the closest match to `target_image`. # Constraints - Images are represented as 2D lists of integers (pixel intensity values). - Each image in the `image_set` and the `target_image` have the same dimensions. - Pixel intensity values range from 0 to 255. # Example ```python image_set = [ [[0, 1, 2], [3, 4, 5], [6, 7, 8]], [[9, 10, 11], [12, 13, 14], [15, 16, 17]], [[18, 19, 20], [21, 22, 23], [24, 25, 26]] ] target_image = [[10, 10, 10], [10, 10, 10], [10, 10, 10]] def calculate_difference(image1, image2): difference = 0 for i in range(len(image1)): for j in range(len(image1[0])): difference += abs(image1[i][j] - image2[i][j]) return difference def find_closest_image(image_set, target_image): min_difference = float(\'inf\') min_index = -1 for index, image in enumerate(image_set): difference = calculate_difference(image, target_image) if difference < min_difference: min_difference = difference min_index = index return min_index closest_index = find_closest_image(image_set, target_image) print(closest_index) # Expected output: Index of the image which is the closest match to the target. For example, 1 due to least difference. ``` # Criteria - Correct calculation of pixel intensity differences. - Efficient search for the closest matching image. - Robustness against varying intensities and dimensions adherence.","solution":"def calculate_difference(image1, image2): Calculate the total absolute pixel intensity difference between two images. Args: image1 (list of list of int): The first image. image2 (list of list of int): The second image. Returns: int: The total absolute pixel intensity difference. difference = 0 for i in range(len(image1)): for j in range(len(image1[0])): difference += abs(image1[i][j] - image2[i][j]) return difference def find_closest_image(image_set, target_image): Find the image from the set that has the smallest difference to the target image. Args: image_set (list of list of list of int): Set of images. target_image (list of list of int): The target image. Returns: int: Index of the image in the image_set which is the closest match to the target image. min_difference = float(\'inf\') min_index = -1 for index, image in enumerate(image_set): difference = calculate_difference(image, target_image) if difference < min_difference: min_difference = difference min_index = index return min_index"},{"question":"# Design and Implement a Simple Trie for Word Storage Scenario You are required to design and implement a simple Trie (prefix tree) to store and search for words efficiently. The Trie should at least contain functions to insert a word, search for a word, and check if there is any word that starts with a given prefix. Requirements Implement the `SimpleTrie` with the following methods: 1. **`__init__(self)`**: Initialize the Trie. 2. **`insert(self, word)`**: Insert a word into the Trie. 3. **`search(self, word)`**: Search for a word in the Trie. 4. **`starts_with(self, prefix)`**: Check if there is any word in the Trie that starts with the given prefix. Input and Output Format - **Input**: You will receive a sequence of operations in the format: - `\\"insert word\\"` to insert a word. - `\\"search word\\"` to search for a word. - `\\"starts_with prefix\\"` to check for a prefix. - `\\"exit\\"` to end the sequence. - **Output**: For each search, print `True` or `False` indicating if the word was found. For each starts_with operation, print `True` or `False` if there is any word that starts with the given prefix. Constraints - Assume all words consist of lowercase English letters. - Handle the case-insensitive scenario (convert all input words to lowercase before processing). - The length of a single word will not exceed 100 characters. Function Signature ```python class SimpleTrie: def __init__(self): pass def insert(self, word: str): pass def search(self, word: str) -> bool: pass def starts_with(self, prefix: str) -> bool: pass def process_operations(operations: List[str]) -> List[str]: pass ``` Example ```python trie = SimpleTrie() trie.insert(\\"hello\\") trie.insert(\\"world\\") print(trie.search(\\"hello\\")) # Output: True print(trie.search(\\"helloo\\")) # Output: False print(trie.search(\\"wor\\")) # Output: False print(trie.starts_with(\\"hel\\")) # Output: True print(trie.starts_with(\\"wo\\")) # Output: True print(trie.starts_with(\\"wr\\")) # Output: False ``` Implement the `SimpleTrie` and ensure it handles all specified operations correctly and efficiently according to the analysis.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class SimpleTrie: def __init__(self): self.root = TrieNode() def insert(self, word): Inserts a word into the Trie. node = self.root word = word.lower() for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): Searches for a word in the Trie. Returns True if the word is found, False otherwise. node = self.root word = word.lower() for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix): Checks if there is any word in the Trie that starts with the given prefix. Returns True if there is a word with the prefix, False otherwise. node = self.root prefix = prefix.lower() for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"# Coding Assessment Question Scenario You are developing a data processing module that works on sequences of numbers. One of the key tasks is to normalize the values in a sequence such that the normalized values lie between 0 and 1. This is a common preprocessing step in machine learning models, where you need to scale values to a range that can be easily interpreted and processed by algorithms. Objective Implement a function named `normalize_sequence` that takes a list of numbers and returns a new list where each number is normalized according to the formula: ``` normalized_value = (value - min_value) / (max_value - min_value) ``` where `min_value` and `max_value` are the minimum and maximum values in the input list, respectively. Function Signature ```python def normalize_sequence(nums: list) -> list: Normalize the numbers in the input list to be between 0 and 1. Args: - nums (list): A list of integers or floats. Returns: - list: A list of normalized numbers. ``` Input * A list `nums` containing integers or float numbers. Output * A list of normalized numbers where each number lies between 0 and 1 inclusive. Constraints * The list `nums` contains at least one element. * All numbers in `nums` are real numbers (integers or floats). * The list may contain positive, negative, or zero values. Example ```python assert normalize_sequence([1, 2, 3, 4, 5]) == [0.0, 0.25, 0.5, 0.75, 1.0] assert normalize_sequence([10, 20, 30, 40, 50]) == [0.0, 0.25, 0.5, 0.75, 1.0] assert normalize_sequence([-1, 0, 1]) == [0.0, 0.5, 1.0] assert normalize_sequence([5, 5, 5]) == [0.0, 0.0, 0.0] ``` Notes * For sequences where all elements are the same, the normalized values should all be 0, as the `max_value` equals `min_value`, resulting in normalization being undefined, and thus defaulting to 0. * Consider edge cases with the smallest and largest numbers possible (including large floats and integers).","solution":"def normalize_sequence(nums: list) -> list: Normalize the numbers in the input list to be between 0 and 1. Args: - nums (list): A list of integers or floats. Returns: - list: A list of normalized numbers. min_value = min(nums) max_value = max(nums) if min_value == max_value: # If all elements are the same, return a list of zeros return [0.0] * len(nums) return [(x - min_value) / (max_value - min_value) for x in nums]"},{"question":"# Question: Find the Next Permutation You are tasked with implementing a function that finds the next lexicographical permutation of a list of integers. The next permutation is the permutation that follows the given one in lexicographical order. If no such permutation exists (i.e., the list is in descending order), the function should rearrange the list into its first permutation (sorted in ascending order). Write a function `next_permutation(arr: list[int]) -> list[int]` that computes the next permutation in place and returns the modified list. **Function Signature:** ```python def next_permutation(arr: list[int]) -> list[int]: pass ``` **Input:** - `arr` (list of int): A non-empty list of integers which may include duplicate values. **Output:** - A list of integers representing the next permutation. **Constraints:** - The length of `arr` is between 1 and 1000. **Examples:** ```python next_permutation([1, 2, 3]) -> [1, 3, 2] next_permutation([3, 2, 1]) -> [1, 2, 3] next_permutation([1, 1, 5]) -> [1, 5, 1] next_permutation([1, 3, 2]) -> [2, 1, 3] ``` **Explanation:** - For `[1, 2, 3]`, the next permutation is `[1, 3, 2]`. - For `[3, 2, 1]`, there is no next permutation, so it returns the smallest permutation: `[1, 2, 3]`. - For `[1, 1, 5]`, the next permutation is `[1, 5, 1]`. - For `[1, 3, 2]`, the next permutation is `[2, 1, 3]`. Write a function implementing this logic by ensuring efficient computation, proper handling of duplicates, and correctness.","solution":"def next_permutation(arr): Computes the next lexicographical permutation of the specified list of integers. n = len(arr) if n <= 1: return arr # Step 1: Find the largest index k such that arr[k] < arr[k + 1] k = n - 2 while k >= 0 and arr[k] >= arr[k + 1]: k -= 1 if k == -1: # The array is in descending order, no larger permutation possible arr.reverse() return arr # Step 2: Find the largest index l greater than k such that arr[k] < arr[l] l = n - 1 while arr[k] >= arr[l]: l -= 1 # Step 3: Swap the value of arr[k] with that of arr[l] arr[k], arr[l] = arr[l], arr[k] # Step 4: Reverse the sequence from arr[k + 1] to the end arr[k + 1:] = reversed(arr[k + 1:]) return arr"},{"question":"# Sorting Algorithms Performance Comparison Scenario: You are a software engineer at a tech company that needs to analyze and compare the performance of various sorting algorithms. Your team has decided to implement three different sorting algorithms and measure their execution times on a variety of datasets. This will help in understanding which algorithm performs best under certain conditions. Task: Your task is to implement three sorting functions and a runner function that executes these sorting functions on the given datasets and measures their execution times. # Functions to Implement: 1. **`bubble_sort(arr)`**: * **Input**: * `arr` (list of ints): An unsorted list of integers. * **Output**: * A list of integers sorted in non-decreasing order using the Bubble Sort algorithm. 2. **`merge_sort(arr)`**: * **Input**: * `arr` (list of ints): An unsorted list of integers. * **Output**: * A list of integers sorted in non-decreasing order using the Merge Sort algorithm. 3. **`quick_sort(arr)`**: * **Input**: * `arr` (list of ints): An unsorted list of integers. * **Output**: * A list of integers sorted in non-decreasing order using the Quick Sort algorithm. 4. **`performance_comparison(arr_list)`**: * **Input**: * `arr_list` (list of lists of ints): A list containing multiple unsorted lists of integers. * **Output**: * A dictionary where the keys are the sorting algorithm names (`\'BubbleSort\'`, `\'MergeSort\'`, `\'QuickSort\'`) and the values are lists of the execution times for each input list in `arr_list`. # Constraints: * The list `arr` in the sorting functions should not be empty. * The values in `arr` should be integers. * The function `performance_comparison` should use the system time to measure execution times (consider using `time.time()`). # Example: ```python # Example usage and expected outputs arr_list = [ [64, 34, 25, 12, 22, 11, 90], [38, 27, 43, 3, 9, 82, 10], [5, 1, 4, 2, 8] ] sorted_lists = { \'BubbleSort\': [bubble_sort(arr.copy()) for arr in arr_list], \'MergeSort\': [merge_sort(arr.copy()) for arr in arr_list], \'QuickSort\': [quick_sort(arr.copy()) for arr in arr_list] } performance = performance_comparison(arr_list) print(sorted_lists) # Expected output: # { # \'BubbleSort\': [[11, 12, 22, 25, 34, 64, 90], [3, 9, 10, 27, 38, 43, 82], [1, 2, 4, 5, 8]], # \'MergeSort\': [[11, 12, 22, 25, 34, 64, 90], [3, 9, 10, 27, 38, 43, 82], [1, 2, 4, 5, 8]], # \'QuickSort\': [[11, 12, 22, 25, 34, 64, 90], [3, 9, 10, 27, 38, 43, 82], [1, 2, 4, 5, 8]] # } print(performance) # Expected output might vary but should look like: # { # \'BubbleSort\': [0.0002, 0.00015, 0.0001], # \'MergeSort\': [0.0001, 0.00011, 0.00009], # \'QuickSort\': [0.0001, 0.00008, 0.00007] # } ``` Your implementation should ensure that the sorting functions are correctly implemented and the performance comparison function accurately measures and returns the execution times. # Notes - Ensure that `bubble_sort`, `merge_sort`, and `quick_sort` can handle large lists efficiently. - Properly document your functions and handle possible edge cases gracefully.","solution":"import time def bubble_sort(arr): Returns a sorted list using the Bubble Sort algorithm. n = len(arr) for i in range(n): for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr def merge_sort(arr): Returns a sorted list using the Merge Sort algorithm. if len(arr) > 1: mid = len(arr) // 2 L = arr[:mid] R = arr[mid:] merge_sort(L) merge_sort(R) i = j = k = 0 while i < len(L) and j < len(R): if L[i] < R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 while i < len(L): arr[k] = L[i] i += 1 k += 1 while j < len(R): arr[k] = R[j] j += 1 k += 1 return arr def quick_sort(arr): Returns a sorted list using the Quick Sort algorithm. if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right) def performance_comparison(arr_list): Measures the performance of different sorting algorithms on given datasets. times = { \'BubbleSort\': [], \'MergeSort\': [], \'QuickSort\': [] } for arr in arr_list: arr_copy = arr.copy() start_time = time.time() bubble_sort(arr_copy) times[\'BubbleSort\'].append(time.time() - start_time) arr_copy = arr.copy() start_time = time.time() merge_sort(arr_copy) times[\'MergeSort\'].append(time.time() - start_time) arr_copy = arr.copy() start_time = time.time() quick_sort(arr_copy) times[\'QuickSort\'].append(time.time() - start_time) return times"},{"question":"# Coding Assessment Question Context: In computer science, string manipulation, especially finding subsequences, is a vital skill utilized in various algorithms and data structures. One common problem is identifying common subsequences within strings, which is essential in DNA sequencing, text processing, and more. Task: Write a function `longest_common_subsequence(str1, str2)` that finds the length of the longest subsequence common to both `str1` and `str2`. A subsequence is a sequence derived by deleting some or none of the characters from a string without changing the order of the remaining characters. Requirements: 1. Implement a function `longest_common_subsequence(str1: str, str2: str) -> int`. 2. The function should: - Raise a `ValueError` if either of the inputs is an empty string. - Raise a `TypeError` if the inputs are not strings. 3. The solution should efficiently compute and return the length of the longest common subsequence of the two input strings. Input: - `str1` (str): The first string (1 ≤ len(str1) ≤ 1000). - `str2` (str): The second string (1 ≤ len(str2) ≤ 1000). Output: - Returns the length of the longest common subsequence of `str1` and `str2`. Constraints: - The function must handle large input string lengths efficiently. - Use dynamic programming for optimal performance. Performance Expectations: - Expected time complexity is (O(m times n)), where (m) and (n) are the lengths of `str1` and `str2` respectively. Example: ```python >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 # The longest common subsequence is \\"ace\\" >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 # There is no common subsequence >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 # The longest common subsequence is \\"abc\\" >>> longest_common_subsequence(\\"bl\\", \\"yby\\") 1 # The longest common subsequence is \\"b\\" ``` Edge Cases: - Input of empty strings should raise a `ValueError`. - Non-string inputs should raise a `TypeError`.","solution":"def longest_common_subsequence(str1, str2): Finds the length of the longest common subsequence between str1 and str2. Args: str1 (str): The first string. str2 (str): The second string. Returns: int: The length of the longest common subsequence. Raises: ValueError: If either str1 or str2 is an empty string. TypeError: If either str1 or str2 is not a string. if not isinstance(str1, str) or not isinstance(str2, str): raise TypeError(\\"Inputs must be strings.\\") if len(str1) == 0 or len(str2) == 0: raise ValueError(\\"Inputs must not be empty strings.\\") m, n = len(str1), len(str2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"Context In many data processing tasks, it becomes useful to identify duplicates within a list and their positions. In programming, creating an efficient way to not only detect duplicates but also track their occurrences can be crucial, especially when dealing with large datasets. Problem You are given a list of elements, which can be integers, floats, or strings. Your task is to create a function that returns a dictionary where each key is a duplicate element from the list and the value is a list of indices at which that element occurs. **Input**: - A list of elements which can include integers, floats, or strings. **Output**: - A dictionary where each key is a duplicate element from the list and the value is a list of indices at which that element occurs in the list. **Function Signature**: ```python def find_duplicates(lst: list) -> dict: # your code here ``` # Constraints: 1. The input list can be empty. 2. Elements in the list may appear more than twice. 3. Ensure your solution handles large lists efficiently in terms of both time and space complexity. # Example: ```python >>> lst = [1, 3, 7, 8, 8, 3, 5, 1, 9] >>> find_duplicates(lst) {1: [0, 7], 3: [1, 5], 8: [3, 4]} >>> lst = [\'a\', \'b\', \'b\', \'c\', \'a\', \'a\'] >>> find_duplicates(lst) {\'a\': [0, 4, 5], \'b\': [1, 2]} ``` Implement the `find_duplicates` function to return the expected output.","solution":"def find_duplicates(lst: list) -> dict: Returns a dictionary where each key is a duplicate element from the list and the value is a list of indices at which that element occurs. element_indices = {} duplicates = {} for index, element in enumerate(lst): if element in element_indices: element_indices[element].append(index) duplicates[element] = element_indices[element] else: element_indices[element] = [index] return {k: v for k, v in duplicates.items() if len(v) > 1}"},{"question":"# Question: Implement a Directed Cycle Detector You are tasked with implementing a function to detect whether a directed graph contains any cycles. Your function should identify all distinct cycles in the given graph. Function Signature ```python def detect_directed_cycles(graph: dict) -> list: ``` Input * `graph`: A dictionary representing a directed graph where keys are vertex identifiers and values are lists of neighboring vertex identifiers. Output * A list of lists, where each inner list contains the vertices of one detected cycle in the graph. If no cycles are detected, return an empty list. Constraints * The graph will have at most 10^3 vertices and 10^4 edges. * The vertex identifiers are non-negative integers. Requirements 1. Use Depth First Search (DFS) to identify cycles. 2. Avoid visiting previously visited vertices in the same recursion stack. 3. Ensure the solution can handle graphs with no edges and empty graphs. 4. Return cycles in a consistent order, starting from the smallest vertex in each cycle. # Example ```python test_graph_1 = {0: [1], 1: [2], 2: [0], 3: [4], 4: [5], 5: [3]} test_graph_2 = {0: [1, 2], 1: [2], 2: []} test_graph_3 = {0: [1], 1: [2], 2: [3], 3: [1], 4: [5, 6], 5: [], 6: [4]} assert detect_directed_cycles(test_graph_1) == [[0, 1, 2], [3, 4, 5]] assert detect_directed_cycles(test_graph_2) == [] assert detect_directed_cycles(test_graph_3) == [[1, 2, 3], [4, 6]] ``` In this question, your task is to implement a cycle detection algorithm for directed graphs using DFS. The main goal is to find all distinct cycles and return them in a specified format.","solution":"def detect_directed_cycles(graph): def dfs(vertex, visited, stack, path): visited[vertex] = True stack[vertex] = True path.append(vertex) for neighbor in graph.get(vertex, []): if not visited[neighbor]: cycle_detected = dfs(neighbor, visited, stack, path) if cycle_detected: return True elif stack[neighbor]: cycle_start_index = path.index(neighbor) cycles.append(path[cycle_start_index:]) return True stack[vertex] = False path.pop() return False visited = {v: False for v in graph} stack = {v: False for v in graph} cycles = [] for vertex in graph: if not visited[vertex]: dfs(vertex, visited, stack, []) return cycles"},{"question":"# Coding Assessment Question You are given an array of integers where each integer appears exactly twice except for one integer that appears exactly once. Your task is to implement a function that finds the integer that appears only once. Function Signature ```python def single_number(nums: List[int]) -> int: ``` Input - `nums` (List[int]): A list of integers where each integer appears exactly twice except for one integer that appears exactly once. Output - `int`: The integer that appears only once. Constraints 1. The array will have at least one element and will meet the given conditions. 2. The function should aim to achieve linear time complexity O(n) and constant space complexity O(1). Example ```python assert single_number([2, 1, 4, 5, 2, 4, 1]) == 5 assert single_number([1, 2, 3, 4, 3, 2, 1]) == 4 assert single_number([7, 3, 5, 4, 5, 3, 4]) == 7 assert single_number([1]) == 1 ``` Explanation Given an array, the `single_number` function should identify the number that only appears once. Utilize a mathematical approach such as bitwise manipulation (XOR operation) to efficiently find the single number, considering the constraints on time and space complexity. Ensure robust handling of edge cases, like arrays with minimal elements.","solution":"from typing import List def single_number(nums: List[int]) -> int: Finds the integer that appears only once in the array where each other integer appears exactly twice. Args: nums (List[int]): A list of integers where each integer appears exactly twice except for one integer that appears exactly once. Returns: int: The integer that appears only once. result = 0 for num in nums: result ^= num return result"},{"question":"# Coding Assessment Question **Scenario**: As part of a software development team, you have been assigned to create a utility function to analyze and manipulate a dataset of numerical values. One of the key requirements is to compute the maximum sum of a contiguous subsequence in an array of integers. This function will be integrated into a larger data analysis tool that needs to handle substantial datasets efficiently. # Problem Statement: Implement a function `max_subarray_sum(arr: List[int]) -> int` that computes the maximum sum of any contiguous subarray in the given list of integers `arr`. # Requirements: 1. **Input**: - A list of integers `arr` with length `n`. 2. **Output**: - An integer representing the maximum sum of any contiguous subarray in the list. 3. **Constraints**: - The length of the list `arr` will be between 1 and 10^4. - The elements of `arr` will be between `-10^5` and `10^5`. # Examples: ```python >>> max_subarray_sum([1, -3, 2, 1, -1]) 3 >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([5, 4, -1, 7, 8]) 23 ``` # Guidelines: * Your solution should efficiently handle the input size and constraints, ideally with a time complexity of O(n). * Consider edge cases such as when all elements are negative or there\'s only one element in the list. * Think about using a well-known algorithm such as Kadane\'s Algorithm to achieve the desired performance. # Hints: * **Kadane\'s Algorithm**: It involves iterating through the array while maintaining a running sum of the maximum subarray ending at the current position. * Be mindful of resetting the running total to the current element if it becomes larger than the existing running total plus the current element. Good luck! Your implementation could greatly enhance the efficiency and performance of the data analysis tool.","solution":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Computes the maximum sum of any contiguous subarray in the given list of integers. if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Coding Assessment Question A common task in data analysis involves finding patterns or anomalies in sequences of numerical data. One intuitive and powerful approach is to use a method called the sliding window. This technique involves computing a particular metric over a fixed-size window of the data as it slides from the start to the end of the sequence. Write a function `sliding_window_mean_var` that calculates the mean and variance for each window position in a given sequence of numbers. The function will take the sequence, the window size, and the step size as input parameters. **Function Signature**: ```python def sliding_window_mean_var(sequence, window_size, step_size): pass ``` # Input and Output - **Input**: - `sequence` - A list of integers or floats representing the numerical data. - `window_size` - An integer representing the size of the window. - `step_size` - An integer representing the number of positions to move the window for each step. - **Output**: - Returns a list of tuples. Each tuple contains two elements: the mean and the variance of the values within the current window. # Constraints - The window size will be a positive integer less than or equal to the length of the sequence. - The step size will be a positive integer less than or equal to the length of the sequence. - The sequence will have at least one element. # Requirements & Performance - Avoid recomputing the mean and variance from scratch on overlapping segments. - Handle edge cases, like when the window extends beyond the sequence\'s length. # Example ```python sequence = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] window_size = 3 step_size = 2 out = sliding_window_mean_var(sequence, window_size, step_size) print(out) # Expected Output (example with window_size=3 and step_size=2): # [(2.0, 0.6666666666666666), (4.0, 0.6666666666666666), (6.0, 0.6666666666666666), (8.0, 0.6666666666666666)] ``` Make sure to efficiently compute the mean and variance for each sliding window position, using appropriate numerical methods to ensure accuracy and performance.","solution":"def sliding_window_mean_var(sequence, window_size, step_size): Calculate the mean and variance for each sliding window position. Parameters: - sequence: List of integers or floats. - window_size: Integer representing the size of the window. - step_size: Integer representing the number of positions to move the window for each step. Returns: - A list of tuples. Each tuple contains the mean and variance of the values within the current window. if not sequence or window_size <= 0 or step_size <= 0: return [] means_vars = [] for i in range(0, len(sequence) - window_size + 1, step_size): window = sequence[i:i + window_size] mean = sum(window) / window_size variance = sum((x - mean) ** 2 for x in window) / window_size means_vars.append((mean, variance)) return means_vars"},{"question":"# Coding Assessment Question Context: You are working on a system that needs to manage a large number of tasks with specified deadlines and priorities. To optimize the planning, you need to sort the tasks based on their deadlines first and their priorities second. Each task is represented by a tuple containing a task name, a deadline, and a priority level. Task: Write a function `organize_tasks(task_list: list[tuple[str, str, int]]) -> list[tuple[str, str, int]]` that accepts a list of tasks, where each task is represented by a tuple `(task_name: str, deadline: str, priority: int)` and returns a new list of tasks sorted by their deadlines (in ascending order). If two tasks have the same deadline, they should be sorted by their priority (in descending order). Function Signature: ```python def organize_tasks(task_list: list[tuple[str, str, int]]) -> list[tuple[str, str, int]]: ``` Input: * A list of tasks `task_list` where each task is a tuple `(task_name: str, deadline: str, priority: int)`. * The `deadline` string is formatted as `YYYY-MM-DD`. * The `priority` is an integer where a higher number indicates higher priority. Output: * A new list of tasks sorted by their deadlines in ascending order and by their priorities in descending order for tasks with the same deadline. Constraints: * The input list will contain between 1 and 10^5 tasks. * Task names are non-empty strings. * Deadlines are valid date strings formatted as `YYYY-MM-DD`. * Priority levels are non-negative integers. Example: ```python task_list = [ (\\"task1\\", \\"2023-05-01\\", 1), (\\"task2\\", \\"2023-05-01\\", 2), (\\"task3\\", \\"2023-04-01\\", 3), (\\"task4\\", \\"2023-04-01\\", 1) ] assert organize_tasks(task_list) == [ (\\"task3\\", \\"2023-04-01\\", 3), (\\"task4\\", \\"2023-04-01\\", 1), (\\"task2\\", \\"2023-05-01\\", 2), (\\"task1\\", \\"2023-05-01\\", 1) ] ``` Performance Requirements: * The solution should operate within O(n log n) time complexity for sorting. Summary: Implement the `organize_tasks` function to sort the tasks by their deadlines first and by their priorities second, ensuring the sorting logic is efficient and meets the given constraints. Handle edge cases such as ties in deadlines and varying priority values.","solution":"def organize_tasks(task_list): Sorts tasks based on deadlines in ascending order and priorities in descending order. Args: task_list (list): A list of tuples where each tuple contains task_name (str), deadline (str in YYYY-MM-DD format), and priority (int). Returns: list: A sorted list of tuples. return sorted(task_list, key=lambda task: (task[1], -task[2]))"},{"question":"# Longest Continuous Increasing Subsequence **Objective**: Write a function that finds the length of the longest continuous increasing subsequence (LCIS) in an array of integers. Function Signature ```python def find_lcis_length(arr: list[int]) -> int: pass ``` Input - A list of integers `arr` where (1 leq text{len}(arr) leq 10^5) and (-10^9 leq text{arr}[i] leq 10^9). Output - An integer representing the length of the longest continuous increasing subsequence. Constraints - If the list is empty, return 0. - Consider performance for large arrays, aiming for a linear time complexity solution. Example ```python assert find_lcis_length([]) == 0 assert find_lcis_length([10, 9, 2, 5, 3, 7, 101, 18]) == 4 # The sequence is [2, 5, 3, 7, 101] assert find_lcis_length([1, 3, 5, 4, 7]) == 3 # The sequence is [1, 3, 5] assert find_lcis_length([2, 2, 2, 2]) == 1 # The sequence is [2] assert find_lcis_length([1, 3, 5, 7, 9]) == 5 # The sequence is the entire array [1, 3, 5, 7, 9] ``` Guidance 1. Traverse the list once while maintaining the length of the current increasing subsequence. 2. Reset the subsequence length whenever a non-increasing element is encountered. 3. Keep track of the maximum length found during the traversal. Testing - Validate the function with provided examples. - Consider edge cases such as empty lists, lists with all equal elements, and strictly increasing or decreasing arrays. - Ensure efficiency is maintained, especially for the upper input limits. This problem tests your ability to implement linear scan algorithms efficiently and handle edge cases effectively. Good luck!","solution":"def find_lcis_length(arr: list[int]) -> int: Returns the length of the longest continuous increasing subsequence in the array. if not arr: return 0 max_len = 1 current_len = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_len += 1 max_len = max(max_len, current_len) else: current_len = 1 return max_len"},{"question":"# Intermediate Problem: Implementing a Binary Tree Level Order Traversal with Depth Tracking Scenario You are required to implement a binary tree traversal algorithm that not only collects nodes in level order but also includes the depth at which each node is found. This helps in further processing where the depth information of nodes is crucial. # Problem Statement Write a Python function `level_order_with_depth(root)` that performs a level order traversal on a given binary tree and returns a list of tuples where each tuple contains a node value and its corresponding depth. Requirements: 1. **Input**: - `root`: The root node of the binary tree. Each node in the binary tree has the following structure: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` 2. **Output**: - The function should return a list of tuples. Each tuple contains two elements: the node value and its depth (starting from 0 for the root node). 3. **Constraints**: - The function should handle cases where the input binary tree is empty. - Ensure the function works efficiently for large trees. # Example Consider the following binary tree: ``` 3 / 9 20 / 15 7 ``` ```python root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) print(level_order_with_depth(root)) ``` Output should be: ``` [(3, 0), (9, 1), (20, 1), (15, 2), (7, 2)] ``` # Additional Notes: - Implement the solution using a queue to facilitate level order traversal. - Validate the tree structure before traversal to avoid exceptions. - Ensure to handle any edge cases, such as trees with only one node or unbalanced trees. # Hint: Utilize a queue where each element is a tuple containing a node and its depth. Perform a breadth-first search (BFS), enqueueing children nodes with incremented depth values as you traverse.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def level_order_with_depth(root): Returns a list of tuples containing node values and their corresponding depths from a level order traversal of the binary tree. if not root: return [] result = [] queue = [(root, 0)] while queue: node, depth = queue.pop(0) result.append((node.val, depth)) if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return result"},{"question":"# Question: Fibonacci Sequence with a Twist Background The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, typically starting with 0 and 1. For example, the first ten Fibonacci numbers are: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34. In this problem, we are introducing a twist to the traditional Fibonacci sequence. Instead of starting with 0 and 1, you can start with any two non-negative integers, and you need to generate a sequence based on this new starting point. Problem Description You are to write a Python function `twisted_fibonacci(a: int, b: int, n: int) -> list[int]` that returns the first `n` numbers of a Fibonacci-like sequence starting with integers `a` and `b`. Input - Two integers `a` and `b` (0 ≤ a, b ≤ 1000), representing the first two numbers in the sequence. - An integer `n` (1 ≤ n ≤ 50), representing the number of terms to generate in the sequence. Output - A list of integers, containing the first `n` numbers of the derived sequence starting with `a` and `b`. Constraints - Ensure that `a` and `b` are non-negative integers within the provided range. - Validate that `n` is positive and within the provided range. Notes - The sequence should begin with `a` and `b`, followed by the sum of the last two numbers repeatedly. - Optimize your solution to handle the maximum constraints efficiently. Examples ```python >>> twisted_fibonacci(3, 5, 5) [3, 5, 8, 13, 21] >>> twisted_fibonacci(1, 2, 7) [1, 2, 3, 5, 8, 13, 21] >>> twisted_fibonacci(0, 1, 10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> twisted_fibonacci(5, 8, 6) [5, 8, 13, 21, 34, 55] ``` Implementation Implement your function using list iteration or recursion for efficient calculation of the sequence. Ensure the initial terms are included and correctly generate subsequent terms by summing the last two numbers properly.","solution":"def twisted_fibonacci(a: int, b: int, n: int) -> list[int]: Returns the first `n` numbers of a Fibonacci-like sequence starting with integers `a` and `b`. if n == 1: return [a] elif n == 2: return [a, b] sequence = [a, b] for i in range(2, n): next_value = sequence[-1] + sequence[-2] sequence.append(next_value) return sequence"},{"question":"# Challenging Coding Assessment Question Context Sorting algorithms are a fundamental concept in computer science, vital for efficient data manipulation and processing. Understanding and implementing various sorting techniques forms a core part of algorithmic proficiency. Task Implement a function `merge_sort(arr: List[int]) -> List[int]` that takes a list of integers and returns a new list containing the same integers sorted in ascending order using the Merge Sort algorithm. Merge Sort is a divide-and-conquer algorithm that takes advantage of recursive splitting and merging of lists. Input and Output Formats: ```python from typing import List def merge_sort(arr: List[int]) -> List[int]: pass # Example usage: print(merge_sort([38, 27, 43, 3, 9, 82, 10])) # Output: [3, 9, 10, 27, 38, 43, 82] print(merge_sort([])) # Output: [] ``` Constraints: * The input list can contain between `0` and `10^5` integers. * Each integer in the list will be between `-10^9` and `10^9`. Requirements: 1. **Recursive Splitting:** Implement the algorithm to recursively divide the list into sublists until each sublist contains a single element or is empty. 2. **Efficient Merging:** Merge the sublists back together in a manner that results in a sorted list. 3. **Edge Cases:** Handle edge cases such as empty lists and lists with a single element. Performance Goals: * Aim for O(n log n) time complexity, as expected from the Merge Sort algorithm. * Manage space complexity to be as efficient as possible, given the recursive nature of the algorithm. Implement the `merge_sort` function, ensuring it adheres to the above specifications and performs optimally for all given constraints.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr # Find the middle point to divide the array into two halves mid = len(arr) // 2 # Call merge_sort recursively on the two halves left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) # Merge the two sorted halves return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: sorted_array = [] i = j = 0 # Traverse both arrays and insert the smaller element into sorted_array while i < len(left) and j < len(right): if left[i] < right[j]: sorted_array.append(left[i]) i += 1 else: sorted_array.append(right[j]) j += 1 # Collect the remaining elements from the left array (if any) while i < len(left): sorted_array.append(left[i]) i += 1 # Collect the remaining elements from the right array (if any) while j < len(right): sorted_array.append(right[j]) j += 1 return sorted_array"},{"question":"# Problem Statement You are assigned to develop a function that identifies all prime numbers within a given range using the Sieve of Eratosthenes algorithm. This classic algorithm efficiently finds all prime numbers up to a specified integer and is widely employed in cryptographic applications and number theory research. # The context A fintech company developing a new cryptographic protocol requires an efficient algorithm to generate prime numbers within a range. Your task is to build this function so that their protocol can be securely tested and benchmarked against various scenarios. # Function Specification Implement the `sieve_of_eratosthenes` function to find all prime numbers up to a specified integer. Function Signature ```python def sieve_of_eratosthenes(n: int) -> list: pass ``` Inputs * `n`: An integer representing the upper limit of the range (0 to n inclusive). Outputs * A list of integers representing all prime numbers from 2 up to `n`. Constraints * Ensure `n` is a non-negative integer. * Optimize for time and space complexity. # Example ```python print(sieve_of_eratosthenes(10)) # Expected output: [2, 3, 5, 7] print(sieve_of_eratosthenes(20)) # Expected output: [2, 3, 5, 7, 11, 13, 17, 19] ``` # Hints * Initialize a boolean array of size (n + 1) with True values. * Skip even numbers to optimize the algorithm. * Mark multiples of each prime starting from 2 as False.","solution":"def sieve_of_eratosthenes(n: int) -> list: Find all prime numbers up to n using the Sieve of Eratosthenes algorithm. Args: n (int): The upper limit of the range to find primes in (inclusive). Returns: list: A list of prime numbers up to n. if n < 2: return [] sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not primes p = 2 while p * p <= n: if sieve[p]: for i in range(p * p, n + 1, p): sieve[i] = False p += 1 return [p for p, is_prime in enumerate(sieve) if is_prime]"},{"question":"# Question: Implementing Dijkstra\'s Algorithm for Single-Source Shortest Paths Dijkstra\'s Algorithm is used to find the shortest path between nodes in a graph. You will be expected to implement Dijkstra\'s Algorithm to determine the shortest paths from a specified starting vertex to all other vertices in a given weighted, undirected graph. **Objective**: Write a function `dijkstra_shortest_paths(graph, start_vertex)` that computes the shortest paths from the `start_vertex` to all other vertices using Dijkstra\'s Algorithm and returns the distances. **Function Signature**: ```python def dijkstra_shortest_paths(graph: Dict[int, List[Tuple[int, int]]], start_vertex: int) -> Dict[int, int]: pass ``` **Input**: - `graph`: A dictionary representing the adjacency list of an undirected graph with weights. For example, `{1: [(2, 1), (3, 4)], 2: [(1, 1), (3, 2)], 3: [(1, 4), (2, 2)]}` where each tuple `(vertex, weight)` represents an edge and its weight. - `start_vertex`: An integer representing the starting vertex from which the shortest paths will be calculated. **Output**: - A dictionary where the keys are the vertices and the values are the shortest distances from the `start_vertex` to each vertex. If a vertex is unreachable from the `start_vertex`, its distance should be represented as `float(\'inf\')`. **Constraints**: - The graph will have at most 100 vertices. - The weight of each edge is a positive integer. - Self-loops or multiple edges between any pair of vertices are not allowed. **Example**: ```python graph1 = {1: [(2, 1), (3, 4)], 2: [(1, 1), (3, 2)], 3: [(1, 4), (2, 2)]} start_vertex1 = 1 output1 = dijkstra_shortest_paths(graph1, start_vertex1) # Expected output: {1: 0, 2: 1, 3: 3} graph2 = {1: [(2, 5)], 2: [(1, 5), (3, 2)], 3: [(2, 2)]} start_vertex2 = 1 output2 = dijkstra_shortest_paths(graph2, start_vertex2) # Expected output: {1: 0, 2: 5, 3: 7} graph3 = {1: [(2, 2), (3, 6)], 2: [(1, 2), (3, 3)], 3: [(1, 6), (2, 3)]} start_vertex3 = 2 output3 = dijkstra_shortest_paths(graph3, start_vertex3) # Expected output: {1: 2, 2: 0, 3: 3} ``` Tips for implementation: - Use a priority queue to efficiently retrieve the next vertex with the smallest tentative distance. - Update the distances for adjacent vertices and keep track of visited vertices. - Ensure to handle edge cases such as disconnected graphs and unreachable vertices.","solution":"import heapq from typing import Dict, List, Tuple def dijkstra_shortest_paths(graph: Dict[int, List[Tuple[int, int]]], start_vertex: int) -> Dict[int, int]: # Initialization distances = {vertex: float(\'inf\') for vertex in graph} distances[start_vertex] = 0 priority_queue = [(0, start_vertex)] # (distance, vertex) while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in graph[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Coding Assessment Question You have been hired as a software developer for a fast-growing e-commerce platform. The platform needs to build a recommendation system that suggests related products based on user shopping behavior. Your task is to refactor and add new features to improve the existing recommendation system. Your tasks are: 1. **Implement a function to fetch and display related product details from a new recommendation API.** - Use the same format as the existing recommendation API data, including product name, price, and availability. - This time, fetch data from an alternative API endpoint, such as \\"https://new-recommendation-api.com/related-products\\". 2. **Enhance error handling:** - Implement a robust error-handling mechanism to manage scenarios such as network failures, API errors, and unexpected data formats. - Ensure that your implementation logs appropriate error messages and retries failed requests up to a specified limit. 3. **Extend the features:** - Modify the `display_related_products` function to include additional data - user ratings and number of reviews (if available from the new API). - Ensure the system displays this additional data and handles cases where this information might not be available. 4. **Optimize product recommendations:** - Improve the recommendation algorithm for better time complexity and accuracy. - Incorporate user purchase history and product categories to enhance the relevance of the suggestions. **Input:** - An integer representing the retry limit for failed network requests. **Output:** - A formatted list or table displaying the related products based on the alternative API, including product name, price, availability, user ratings, and number of reviews. **Constraints:** - The alternative API endpoint must return data in a JSON format containing the related product details. - User purchase history and product categories will be provided as inputs in standard formats. - Ensure you handle up to 3 retries for failed network requests. **Scenario Context:** Imagine an online retailer switching to a new recommendation API provider without affecting their users\' shopping experience. The system must continue to suggest accurate and relevant related products based on the user\'s shopping behavior and history.","solution":"import requests import logging logging.basicConfig(level=logging.INFO, format=\'%(asctime)s - %(levelname)s - %(message)s\') def fetch_related_products(api_endpoint, retry_limit=3): Fetch related products from a given API endpoint with retry mechanism. :param api_endpoint: str - The API endpoint to fetch related products from. :param retry_limit: int - Number of retries for failed network requests. :return: list - A list of related product details fetched from the API. attempts = 0 while attempts < retry_limit: try: response = requests.get(api_endpoint) response.raise_for_status() return response.json() except requests.RequestException as e: logging.error(f\\"Network request failed: {e}\\") attempts += 1 logging.error(\\"Max retry limit reached. Failed to fetch related product details.\\") return [] def display_related_products(api_data): Format and display the related products including additional data if available. :param api_data: list - List of related product details fetched from the API. if not api_data: logging.info(\\"No related products to display.\\") return for product in api_data: name = product.get(\'name\', \'N/A\') price = product.get(\'price\', \'N/A\') availability = product.get(\'availability\', \'N/A\') rating = product.get(\'user_rating\', \'N/A\') reviews = product.get(\'num_reviews\', \'N/A\') print(f\\"Product Name: {name}\\") print(f\\"Price: {price}\\") print(f\\"Availability: {availability}\\") print(f\\"User Rating: {rating}\\") print(f\\"Number of Reviews: {reviews}\\") print(\\"-\\" * 40) def improved_recommendation_algorithm(user_purchase_history, product_categories): Improves the recommendation algorithm based on purchase history and product categories. :param user_purchase_history: list - List of products previously purchased by the user. :param product_categories: list - List of product categories relevant to the user. :return: list - Improved list of recommended products. recommended_products = [] # Example logic (this can be enhanced further) for category in product_categories: if category not in user_purchase_history: recommended_products.append(category) return recommended_products api_endpoint = \\"https://new-recommendation-api.com/related-products\\" retry_limit = 3 user_purchase_history = [\'Electronics\', \'Books\'] product_categories = [\'Electronics\', \'Books\', \'Clothing\', \'Home Appliances\'] # Fetch related products and display related_products = fetch_related_products(api_endpoint, retry_limit) display_related_products(related_products) # Get improved recommendations improved_recommendations = improved_recommendation_algorithm(user_purchase_history, product_categories) print(f\\"Improved Recommendations: {improved_recommendations}\\")"},{"question":"# Scenario: You are working on a data processing application that involves generating statistical summaries from a list of integers. One of the requirements is to find the mode(s) of the list. The mode is the number that appears most frequently in the list. If there are multiple numbers with the same highest frequency, you should return all of them in ascending order. # Task: Write a function named `find_modes` that takes a single argument, which is a list of integers, and returns a list of integers representing the mode(s) in ascending order. # Constraints: * The input list can have 0 or more elements. * If the input list is empty, return an empty list. * The integers can be positive or negative. # Function Signature: ```python def find_modes(numbers: list[int]) -> list[int]: ``` # Examples: ```python # Example 1 find_modes([1, 2, 3, 2, 4, 2, 3]) # Output: [2] # Example 2 find_modes([4, 4, 1, 1, 2, 2]) # Output: [1, 2, 4] # Example 3 find_modes([9]) # Output: [9] # Example 4 find_modes([-1, -1, -2, -2]) # Output: [-2, -1] # Example 5 find_modes([]) # Output: [] ``` # Requirements: 1. Implement the function `find_modes`. 2. Ensure the function handles edge cases, such as an empty list and multiple modes correctly. 3. Optimize your solution for clarity and efficiency.","solution":"def find_modes(numbers: list[int]) -> list[int]: if not numbers: return [] from collections import Counter count = Counter(numbers) max_freq = max(count.values()) modes = [num for num, freq in count.items() if freq == max_freq] return sorted(modes)"},{"question":"# Problem Statement Given a string of characters, write a function to determine whether the string is a \\"valid\\" encoding of a message where each character is mapped to its corresponding numeric position in the alphabet (A=1, B=2, ..., Z=26) and the numbers are concatenated. The function should check whether the given string can be split into a sequence of alphabetic characters (considering single and double digit mappings). # Requirements * Implement a function `is_valid_encoding` that takes a single string as input and returns a boolean indicating whether the string is a valid encoding. * Handle edge cases such as strings including characters \'0\' and other constraints derived from the mapping. * Ensure that the function operates in linear time relative to the input string length. # Input and Output * **Input**: A string `s` consisting of digits. For example: - \\"123\\" - \\"226\\" - \\"06\\" - \\"301\\" * **Output**: A boolean indicating if the encoding is valid (True or False). # Constraints 1. The input string contains only numeric digits (0-9). 2. The length of the input string will not exceed 100 characters. 3. The string should be interpreted such that substrings \\"10\\" to \\"26\\" are valid (except \\"20\\", \\"30\\", ... \\"90\\" are invalid). # Example Scenarios Example 1: * **Input**: `\\"123\\"` * **Output**: `True` * **Explanation**: Can be decoded as \\"1-2-3\\" (\\"ABC\\") or \\"12-3\\" (\\"LC\\"). Example 2: * **Input**: `\\"226\\"` * **Output**: `True` * **Explanation**: Can be decoded as \\"2-2-6\\" (\\"BBF\\") or \\"22-6\\" (\\"VF\\"). Example 3: * **Input**: `\\"06\\"` * **Output**: `False` * **Explanation**: \\"0\\" cannot be mapped to any letter. Example 4: * **Input**: `\\"301\\"` * **Output**: `False` * **Explanation**: \\"30\\" is not a valid mapping. Write the function `is_valid_encoding(s: str) -> bool` to determine the validity of the encoded message as described.","solution":"def is_valid_encoding(s): Determines whether the given string is a valid encoding of a message where each character is mapped to its corresponding position in the alphabet. :param s: A string containing only digits (0-9). :return: A boolean indicating whether the string is a valid encoding. if not s or s[0] == \'0\': return False n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): one_digit = int(s[i-1:i]) two_digits = int(s[i-2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i-1] if 10 <= two_digits <= 26: dp[i] += dp[i-2] return dp[n] > 0"},{"question":"# Coding Challenge Context Binary search is a search algorithm that finds the position of a target value within a sorted array. Binary search compares the target value to the middle element of the array; if they are not equal, the half in which the target cannot lie is eliminated and the search continues on the remaining half, again taking the middle element to compare to the target value, and repeating this until the target value is found. Task Write a Python function to implement binary search. The function should return the index of the target value in the sorted array, or -1 if the target is not found. Function Signature ```python def binary_search(arr: List[int], target: int) -> int: pass ``` Input * `arr` (List[int]): A list of integers sorted in ascending order. * `target` (int): The integer value to be searched in the array. Output * (int): The index of the `target` in the array, or -1 if `target` is not found. Constraints * 1 ≤ len(arr) ≤ 10^5 * -10^9 ≤ arr[i], target ≤ 10^9 Examples ```python >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) 4 >>> binary_search([10, 20, 30, 40, 50, 60, 70], 35) -1 >>> binary_search([-10, -5, 0, 5, 10, 15, 20], -5) 1 ``` Notes * The returned index is 0-based. * Assume the array contains no duplicate values. * The function should not use Python\'s built-in search functionalities, but should implement the binary search algorithm directly. Edge Cases * If the `target` is the first or the last element, the function should return the corresponding index. * If the target element is not present in the list, the function should return -1.","solution":"from typing import List def binary_search(arr: List[int], target: int) -> int: Perform binary search to find the index of target in arr. Params: arr : List[int] : A list of integers sorted in ascending order. target: int : The integer value to be searched. Returns: int: Index of target in arr if found, else -1. left, right = 0, len(arr) - 1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Coding Challenge Given the problem of evaluating balanced binary trees, you need to implement a function that determines whether a binary tree is height-balanced and returns the maximum depth of the tree. A *height-balanced binary tree* is defined as: 1. A tree in which the left and right subtrees of every node differ in height by no more than 1. 2. Both the left and right subtrees are height-balanced themselves. **Objective**: Write a function `is_balanced_and_depth(root: Optional[TreeNode]) -> Tuple[bool, int]` that: * **Input**: - `root`: The root node of the binary tree, where `TreeNode` is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` * **Output**: Returns a tuple (is_balanced, depth): - `is_balanced` (boolean): `True` if the tree is height-balanced, `False` otherwise. - `depth` (integer): The maximum depth of the tree. # Example Usage: ```python # Example 1: # Input: [3,9,20,None,None,15,7] # Binary tree representation: # 3 # / # 9 20 # / # 15 7 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) assert is_balanced_and_depth(root) == (True, 3) # Example 2: # Input: [1,2,2,3,3,None,None,4,4] # Binary tree representation: # 1 # / # 2 2 # / # 3 3 # / # 4 4 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(2) root.left.left = TreeNode(3) root.left.right = TreeNode(3) root.left.left.left = TreeNode(4) root.left.left.right = TreeNode(4) assert is_balanced_and_depth(root) == (False, 4) ``` # Constraints: 1. Each node stores an integer value. 2. The function should handle empty trees (where `root` is `None`). 3. Aim for optimal time complexity by avoiding redundant calculations. # Guidelines: - Implement a recursive depth-first search to explore the tree. - For each node, calculate the depths of its left and right subtrees. - Check the height-balancing condition and propagate the result while tracking the depth.","solution":"from typing import Optional, Tuple class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced_and_depth(root: Optional[TreeNode]) -> Tuple[bool, int]: Determines if the binary tree is height-balanced and returns the maximum depth. Args: root (TreeNode): The root node of the binary tree. Returns: Tuple[bool, int]: A tuple where the first element indicates if the tree is balanced, and the second element is the maximum depth of the tree. if not root: return True, 0 def check_balance_and_depth(node: Optional[TreeNode]) -> Tuple[bool, int]: if not node: return True, 0 left_balanced, left_depth = check_balance_and_depth(node.left) right_balanced, right_depth = check_balance_and_depth(node.right) current_depth = max(left_depth, right_depth) + 1 current_balanced = (left_balanced and right_balanced and abs(left_depth - right_depth) <= 1) return current_balanced, current_depth return check_balance_and_depth(root)"},{"question":"# Movie Recommendation System with Collaborative Filtering You are tasked with implementing a simple movie recommendation system using collaborative filtering. The goal is to recommend movies to a user based on the ratings of other users with similar preferences. You will use a user-item rating matrix and cosine similarity to find the most similar users. Function Specification: Implement the function `recommend_movies(user_id: int, ratings: List[List[int]], top_n: int = 5) -> List[int]`. This function should: 1. Calculate the cosine similarity between the target user and all other users in the dataset. 2. Identify the top-N most similar users. 3. Recommend movies to the target user that the similar users have rated highly but the target user has not yet rated. Input: - `user_id` (int): The ID of the user to recommend movies to. - `ratings` (List[List[int]]): A 2D list representing the user-item rating matrix, where `ratings[i][j]` is the rating given by user `i` to movie `j`. A rating of 0 indicates that the movie has not been rated by the user. - `top_n` (int): The number of similar users to consider for recommendations. Defaults to 5. Constraints: - There will be at least one user and one movie in the dataset. - Ratings are integers in the range 1 to 5 or 0 if not rated. - The user IDs and movie IDs are 0-indexed. Output: - A list of movie IDs (integers) that are recommended to the user, sorted by predicted rating in descending order. Return an empty list if no recommendations can be made. Example Usage: ```python if __name__ == \\"__main__\\": ratings = [ [4, 0, 3, 5], [5, 1, 0, 4], [0, 4, 4, 1], [3, 5, 4, 0] ] result = recommend_movies(0, ratings, top_n = 2) print(result) # Output might look like [2, 1] ``` In this example, the user with ID 0 will get movie recommendations based on the ratings of the two most similar users. Notes: - You may use libraries like `numpy` or `scipy` to compute cosine similarity efficiently. - Ensure your implementation handles empty or sparse rating matrices gracefully. - Consider edge cases such as all movies already rated by the user, or users with no overlap in movie ratings.","solution":"from typing import List, Tuple import numpy as np def recommend_movies(user_id: int, ratings: List[List[int]], top_n: int = 5) -> List[int]: def cosine_similarity(vec1, vec2): num = np.dot(vec1, vec2) denom = np.linalg.norm(vec1) * np.linalg.norm(vec2) if denom == 0: return 0 return num / denom user_ratings = np.array(ratings[user_id]) similarities = [] for i, other_ratings in enumerate(ratings): if i != user_id: similarity = cosine_similarity(user_ratings, other_ratings) similarities.append((similarity, i)) # Sort users by similarity in descending order similarities.sort(reverse=True, key=lambda x: x[0]) top_similar_users = [user_index for _, user_index in similarities[:top_n]] score_sums = np.zeros(user_ratings.shape) similarity_sums = np.zeros(user_ratings.shape) for similar_user_id in top_similar_users: similar_user_ratings = np.array(ratings[similar_user_id]) rating_mask = (user_ratings == 0) & (similar_user_ratings > 0) score_sums[rating_mask] += similar_user_ratings[rating_mask] similarity_sums[rating_mask] += 1 with np.errstate(divide=\'ignore\', invalid=\'ignore\'): predicted_ratings = np.true_divide(score_sums, similarity_sums) predicted_ratings[similarity_sums == 0] = 0 recommendation_indices = np.argsort(predicted_ratings)[::-1] recommended_movies = [i for i in recommendation_indices if user_ratings[i] == 0 and predicted_ratings[i] > 0] return recommended_movies"},{"question":"# Spelling Correction Using Trie Structure **Context**: As part of an auto-correction feature in a text editor, you aim to develop a spelling correction mechanism. You will implement a simplified version of this feature using the Trie (prefix tree) data structure to store a dictionary of correct words and then provide suggestions based on this structure. **Task**: Implement a class `SpellingCorrector` with the following methods: 1. `insert(word: str) -> None`: Inserts a word into the dictionary. 2. `search(query: str) -> bool`: Searches for the exact match of the query word in the dictionary. 3. `suggest(prefix: str) -> List[str]`: Returns all words from the dictionary that start with the given prefix. Suggestions should be sorted lexicographically. **Requirements**: 1. The dictionary should be implemented using a Trie structure for efficient insertion and search operations. 2. The `insert` method should handle multiple insertions and duplicate words gracefully. 3. The `search` method should return `True` if the word exists in the dictionary, otherwise `False`. 4. The `suggest` method should return an empty list if no suggestions are found. **Input**: - The `insert` method takes a single word as a string. - The `search` method takes a single query word as a string. - The `suggest` method takes a single prefix as a string. **Output**: - The `search` method returns a boolean value. - The `suggest` method returns a list of strings. **Constraints**: - Words will only consist of lowercase English letters. - Length of each word/pre-fix is between 1 and 100. - The number of words to be inserted into the Trie will not exceed 10,000. **Example**: ```python corrector = SpellingCorrector() corrector.insert(\\"hello\\") corrector.insert(\\"helium\\") corrector.insert(\\"help\\") corrector.insert(\\"hero\\") corrector.insert(\\"her\\") print(corrector.search(\\"hello\\")) # Output: True print(corrector.search(\\"heron\\")) # Output: False print(corrector.suggest(\\"he\\")) # Output: [\'helium\', \'hello\', \'help\', \'her\', \'hero\'] print(corrector.suggest(\\"xyz\\")) # Output: [] ``` **Edge Cases**: - `corrector.search(\\"\\")` should return `False`. - `corrector.suggest(\\"\\")` is assumed to return all words sorted lexicographically in the dictionary if there are any, otherwise an empty list. - Multiple identical words should not cause errors during insertion, search or suggestion.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class SpellingCorrector: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, query: str) -> bool: node = self.root for char in query: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def suggest(self, prefix: str) -> list: node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] return self._collect_words(node, prefix) def _collect_words(self, node, prefix): words = [] if node.is_end_of_word: words.append(prefix) for char, next_node in node.children.items(): words.extend(self._collect_words(next_node, prefix + char)) return sorted(words)"},{"question":"# Memory Efficient String Reversal You are required to implement a function to reverse a string in place without using any extra space for another string or list. The function should modify the input string itself and return it. # Instructions 1. Implement the following function: ```python def in_place_reverse(s: list[str]) -> list[str]: Reverses the input string in place without using extra space for another string or list. :param s: Input string represented as a list of characters :return: The same list with characters reversed # Implement the function body ``` # Constraints: - The input string will be provided as a list of characters, e.g., `[\'h\', \'e\', \'l\', \'l\', \'o\']`. - The input string will not be empty. - The input string will have a maximum length of 1000 characters. # Example: ```python input_list = [\'h\', \'e\', \'l\', \'l\', \'o\'] result = in_place_reverse(input_list) print(result) # Output: [\'o\', \'l\', \'l\', \'e\', \'h\'] input_list = [\'a\', \'b\', \'c\', \'d\'] result = in_place_reverse(input_list) print(result) # Output: [\'d\', \'c\', \'b\', \'a\'] ``` # Notes: - You may use a two-pointer approach to reverse the string. - Do not use any extra lists or strings. - Ensure the function modifies the input list in place and returns it. This question tests your understanding of in-place algorithms and your ability to manipulate data structures efficiently.","solution":"def in_place_reverse(s: list[str]) -> list[str]: Reverses the input string in place without using extra space for another string or list. :param s: Input string represented as a list of characters :return: The same list with characters reversed left, right = 0, len(s) - 1 while left < right: s[left], s[right] = s[right], s[left] left += 1 right -= 1 return s"},{"question":"# Context: You have been hired by a company that is enhancing their data analysis toolkit. A common task they require is to efficiently compute the rolling average (also known as the moving average) over a window of a given size for their time-series datasets. They need you to implement this functionality. # Task: Create a function `rolling_average` that computes the rolling average over a specified window size for a given list of numbers representing a time-series dataset. # Requirements: 1. **Function Implementation:** - Implement a function `rolling_average(data: List[float], window_size: int) -> List[float]` that returns a list of the rolling averages. 2. **Edge Case Handling:** - Handle cases where the window size is larger than the dataset. - Ensure the function returns an empty list if the input data list is empty. 3. **Testing:** - Demonstrate the correctness of your implementation with several test cases. **Input and Output formats:** - **Input:** - `data`: A list of floats representing the time-series data. - `window_size`: An integer representing the size of the window for which to compute the rolling average. - **Output:** A list of floats containing the rolling averages for the provided window size. **Constraints:** - The input list can contain both positive and negative floats. - The window size will be a positive integer. # Example: ```python def rolling_average(data: List[float], window_size: int) -> List[float]: if not data or window_size > len(data): return [] averages = [] for i in range(len(data) - window_size + 1): window = data[i:i + window_size] averages.append(sum(window) / window_size) return averages # Example test case data = [1.0, 2.0, 3.0, 4.0, 5.0] window_size = 3 assert rolling_average(data, window_size) == [2.0, 3.0, 4.0] data = [10, 20, 30, 40, 50, 60] window_size = 2 assert rolling_average(data, window_size) == [15.0, 25.0, 35.0, 45.0, 55.0] # Edge case: window size larger than data length data = [1.0, 2.0] window_size = 3 assert rolling_average(data, window_size) == [] # Edge case: empty data data = [] window_size = 2 assert rolling_average(data, window_size) == [] ``` **Note:** Do not forget to handle the necessary imports and to write your implementation in a way that is efficient and easy to understand.","solution":"from typing import List def rolling_average(data: List[float], window_size: int) -> List[float]: if not data or window_size > len(data): return [] averages = [] for i in range(len(data) - window_size + 1): window = data[i:i + window_size] averages.append(sum(window) / window_size) return averages"},{"question":"# Matrix Diagonal Traverse Problem Statement Write a function `findDiagonalOrder(matrix: List[List[int]]) -> List[int]` that returns the diagonal order traversal of a given `m x n` matrix. The traversal starts at the top left corner of the matrix and traverses diagonally alternating between upwards and downwards directions. Input - A list of lists `matrix` containing integers, where `matrix[i][j]` represents the element at the ith row and jth column of the matrix. - `0 ≤ m, n ≤ 10^4` Output - A list of integers representing the elements of the given matrix in diagonal order. Example ```python >>> findDiagonalOrder([ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ]) [1, 2, 4, 7, 5, 3, 6, 8, 9] >>> findDiagonalOrder([ [ 1, 2 ], [ 3, 4 ] ]) [1, 2, 3, 4] ``` Explanation For the first matrix `[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ]`, the diagonal order traversal is `1, 2, 4, 7, 5, 3, 6, 8, 9`. For the second matrix `[ [ 1, 2 ], [ 3, 4 ] ]`, the diagonal order traversal is `1, 2, 3, 4`. Constraints - The matrix may be empty, returning an empty list in that scenario. - Ensure an efficient traversal of the matrix with a time complexity close to O(m * n).","solution":"def findDiagonalOrder(matrix): Returns the diagonal order traversal of the given matrix. if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) result = [] for d in range(m + n - 1): intermediate = [] if d % 2 == 0: r = min(d, m - 1) c = d - r while r >= 0 and c < n: intermediate.append(matrix[r][c]) r -= 1 c += 1 else: c = min(d, n - 1) r = d - c while c >= 0 and r < m: intermediate.append(matrix[r][c]) r += 1 c -= 1 result.extend(intermediate) return result"},{"question":"# **Array Rotation using Reversal Algorithm** You are asked to implement a function that rotates an array by a specified number of elements to the left using the reversal algorithm. The reversal algorithm provides an efficient way to perform this task in-place in linear time and with constant space. **Function Signature** ```python def rotate_array(arr: List[int], d: int) -> None: pass ``` **Parameters** * `arr` (List[int]): A list of integers. * `d` (int): The number of elements to rotate to the left. **Returns** * None. The function modifies the list `arr` in place. **Constraints and Assumptions** * `1 <= len(arr) <= 10^5` * `0 <= d < len(arr)` * The list `arr` will contain only integers. **Performance Requirements** * The function must operate in O(n) time complexity, where n is the length of the array. * Use O(1) extra space, excluding the input array. **Example** ```python >>> arr = [1, 2, 3, 4, 5, 6, 7] >>> rotate_array(arr, 3) >>> arr [4, 5, 6, 7, 1, 2, 3] >>> arr = [1, 2, 3, 4, 5] >>> rotate_array(arr, 2) >>> arr [3, 4, 5, 1, 2] ``` **Implementation Notes** 1. **Reverse operation**: Create a helper function to reverse a sublist of `arr` given the start and end indices. 2. **Reversal steps**: * **Step 1**: Reverse the first segment of the array from index `0` to `d-1`. * **Step 2**: Reverse the second segment of the array from index `d` to the end. * **Step 3**: Reverse the entire array to achieve the final rotated state. 3. **In-place modification**: The function should modify the array `arr` directly without returning a new array. **Your Task** Implement the function `rotate_array` as per the given signature and specifications.","solution":"from typing import List def rotate_array(arr: List[int], d: int) -> None: def reverse(arr: List[int], start: int, end: int) -> None: while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 n = len(arr) d = d % n # in case d is larger than the array length # Reverse the first part reverse(arr, 0, d - 1) # Reverse the remaining part reverse(arr, d, n - 1) # Reverse the whole array reverse(arr, 0, n - 1)"},{"question":"# Coding Question Context Given a directed graph, your task is to find all strongly connected components (SCCs) using Kosaraju\'s Algorithm. Implement the function to return the SCCs of the graph. Function Signature ```python def find_sccs(graph: GraphDirected[T]) -> List[List[T]]: ``` Input The function receives one parameter: - `graph`: An instance of `GraphDirected` which represents the directed graph. Output - The function should return a list of lists, where each list is a strongly connected component containing the nodes within that SCC. Constraints - The graph will contain at least one node. - The nodes will be labeled with unique values. Example ```python graph = GraphDirected() graph.add_edge(\\"a\\", \\"b\\") graph.add_edge(\\"b\\", \\"c\\") graph.add_edge(\\"c\\", \\"a\\") graph.add_edge(\\"b\\", \\"d\\") graph.add_edge(\\"d\\", \\"e\\") graph.add_edge(\\"e\\", \\"d\\") result = find_sccs(graph) print(result) # Output should be [[\'a\', \'b\', \'c\'], [\'d\', \'e\']] (order of nodes in SCCs can vary) ``` Hint Kosaraju\'s Algorithm involves two passes of Depth-First Search (DFS): 1. Perform a DFS to compute the finish times of each node. 2. Transpose the graph. 3. Perform DFS on the transposed graph in the order of decreasing finish times. Keep track of visited nodes to avoid processing the same node multiple times.","solution":"from collections import defaultdict from typing import List, TypeVar, Generic, DefaultDict, Set T = TypeVar(\'T\') class GraphDirected(Generic[T]): def __init__(self): self.graph: DefaultDict[T, List[T]] = defaultdict(list) def add_edge(self, src: T, dest: T): self.graph[src].append(dest) def get_nodes(self) -> Set[T]: return set(self.graph.keys()).union({node for nodes in self.graph.values() for node in nodes}) def find_sccs(graph: GraphDirected[T]) -> List[List[T]]: def dfs_stack(node: T, visited: Set[T], stack: List[T]): visited.add(node) for neighbour in graph.graph[node]: if neighbour not in visited: dfs_stack(neighbour, visited, stack) stack.append(node) def dfs_scc(node: T, visited: Set[T], component: List[T], transpose_graph: DefaultDict[T, List[T]]): visited.add(node) component.append(node) for neighbour in transpose_graph[node]: if neighbour not in visited: dfs_scc(neighbour, visited, component, transpose_graph) stack = [] visited = set() for node in graph.get_nodes(): if node not in visited: dfs_stack(node, visited, stack) transpose_graph = defaultdict(list) for node in graph.graph: for neighbour in graph.graph[node]: transpose_graph[neighbour].append(node) visited.clear() sccs = [] while stack: node = stack.pop() if node not in visited: component = [] dfs_scc(node, visited, component, transpose_graph) sccs.append(component) return sccs"},{"question":"# Coding Assessment Question Context You are tasked with developing a function to assist operations in a logistics company. The company needs to quickly evaluate different delivery routes based on distance and expected delivery times during varying traffic conditions. Using the A* search algorithm and considering distance and time as factors, your function should find the optimal delivery route from one location to another in a weighted directed graph representing a city\'s road network. Problem Statement Implement the function `find_optimal_delivery_route` to determine the optimal delivery route from a given start to a destination in a weighted directed graph. The weights represent the time required to traverse each edge, and the heuristic function should estimate time to reach the destination considering traffic conditions. Function Signature ```python from typing import List, Tuple, Dict def find_optimal_delivery_route(graph: Dict[int, List[Tuple[int, float]]], start: int, destination: int, heuristic: Dict[int, float]) -> Tuple[float, List[int]]: ``` Input * `graph` (Dict[int, List[Tuple[int, float]]]): A dictionary where keys are node identifiers and values are lists of tuples representing connected nodes and travel times to them. * `start` (int): The starting node identifier. * `destination` (int): The destination node identifier. * `heuristic` (Dict[int, float]): A dictionary where keys are node identifiers and values are heuristic estimates of travel time to the destination node. Output * A tuple containing: - The total estimated time from the start node to the destination node, or `float(\'inf\')` if no path is found. - A list of node identifiers representing the sequence of nodes in the optimal path from start to destination, or an empty list if no path is found. Constraints * All node identifiers are within the bounds of the graph. * The graph consists of at least one node and one edge. * Start and destination nodes are defined and within graph boundaries. * A path may not always exist between the start and destination nodes (i.e., the function should handle and return accurate output for the failure scenario). Example ```python >>> graph = { ... 1: [(2, 4.0), (3, 2.0)], ... 2: [(3, 1.0), (4, 5.0)], ... 3: [(4, 3.0)], ... 4: [] ... } >>> heuristic = {1: 7.0, 2: 6.0, 3: 2.0, 4: 0.0} >>> find_optimal_delivery_route(graph, 1, 4, heuristic) (5.0, [1, 3, 4]) >>> graph = { ... 1: [(2, 1.0)], ... 2: [(3, 4.0)], ... 3: [] ... } >>> heuristic = {1: 5.0, 2: 4.0, 3: 0.0} >>> find_optimal_delivery_route(graph, 1, 3, heuristic) (5.0, [1, 2, 3]) >>> graph = { ... 1: [(2, 2.0)], ... 2: [(3, 2.0)], ... 3: [(4, 2.0)], ... 4: [(1, 2.0)] ... } >>> heuristic = {1: 4.0, 2: 3.0, 3: 1.0, 4: 0.0} >>> find_optimal_delivery_route(graph, 1, 5, heuristic) (float(\'inf\'), []) ``` Notes - Test the function thoroughly with edge cases and varying graph structures. - Optimize for performance when possible, especially for larger graphs. - Ensure accurate handling of cases where no path exists.","solution":"from typing import List, Tuple, Dict import heapq def find_optimal_delivery_route(graph: Dict[int, List[Tuple[int, float]]], start: int, destination: int, heuristic: Dict[int, float]) -> Tuple[float, List[int]]: Finds the optimal delivery route from start to destination using A* search algorithm. Arguments: graph -- Dictionary where keys are node identifiers and values are lists of tuples representing connected nodes and travel times to them. start -- The starting node identifier. destination -- The destination node identifier. heuristic -- Dictionary where keys are node identifiers and values are heuristic estimates of travel time to the destination node. Returns: Tuple containing: - The total estimated time from start to destination, or float(\'inf\') if no path is found. - A list of node identifiers representing the sequence of nodes in the optimal path, or an empty list if no path is found. open_set = [(heuristic[start], start)] # priority queue storing (f_score, node) came_from = {} # to track the optimal path g_score = {node: float(\'inf\') for node in graph} g_score[start] = 0 f_score = {node: float(\'inf\') for node in graph} f_score[start] = heuristic[start] while open_set: _, current = heapq.heappop(open_set) if current == destination: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) path.reverse() return g_score[destination], path for neighbor, travel_time in graph.get(current, []): tentative_g_score = g_score[current] + travel_time if tentative_g_score < g_score[neighbor]: # found a better path came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = g_score[neighbor] + heuristic[neighbor] heapq.heappush(open_set, (f_score[neighbor], neighbor)) return float(\'inf\'), []"},{"question":"# Scenario You are building a simple string manipulation utility for processing large textual data. One common operation is to reverse the order of words in a sentence while maintaining the order of characters within each word. For example, the sentence \\"Hello World from OpenAI\\" should be transformed to \\"OpenAI from World Hello\\". # Task Write a function: ```python reverse_words_in_sentence(sentence: str) -> str ``` - This function should take a sentence and return a new sentence with the words in reversed order. # Constraints * The input string will consist of words separated by single spaces. * There will be no leading or trailing spaces in the input string. * The input string will only contain alphabetic characters (a-z, A-Z) and spaces. * The input string will have at least one word. # Input and Output Formats * **Function**: * Input: A string `sentence`. * Output: A string with words in reversed order. Example ```python >>> reverse_words_in_sentence(\\"Hello World from OpenAI\\") \'OpenAI from World Hello\' >>> reverse_words_in_sentence(\\"Python is fun\\") \'fun is Python\' >>> reverse_words_in_sentence(\\"Data Science\\") \'Science Data\' ``` # Edge Cases 1. A sentence with a single word: ```python >>> reverse_words_in_sentence(\\"Hello\\") \'Hello\' ``` 2. A sentence with two words: ```python >>> reverse_words_in_sentence(\\"Hello World\\") \'World Hello\' ```","solution":"def reverse_words_in_sentence(sentence: str) -> str: This function reverses the order of words in a given sentence while maintaining the order of characters within each word. Parameters: sentence (str): The input sentence. Returns: str: The sentence with words in reversed order. words = sentence.split(\\" \\") reversed_words = words[::-1] return \\" \\".join(reversed_words)"},{"question":"# Problem Description You are given an array of strings where each string represents words separated by single spaces. Your task is to sort the words in each string alphabetically while maintaining their relative order of occurrence in the original string. # Task Implement a function that accepts an array of strings and returns a new array where each string\'s words have been sorted alphabetically within themselves. # Function Signature ```python def sort_words_in_strings(strings: list[str]) -> list[str]: pass ``` # Input - `strings` (list): A list of strings, each consisting of words separated by a single space. # Output - Return a new list of strings where each string’s words are sorted alphabetically while maintaining their original order of appearance. # Constraints - Each string will consist of lowercase alphabets and spaces only. - Each string will have at least one word. - No leading or trailing spaces in the strings. # Examples ```python assert sort_words_in_strings([\\"hello world\\", \\"this is a test\\", \\"sorting is fun\\"]) == [\\"hello world\\", \\"a is test this\\", \\"fun is sorting\\"] assert sort_words_in_strings([\\"banana apple\\", \\"lucid lens\\", \\"simple example\\"]) == [\\"apple banana\\", \\"lens lucid\\", \\"example simple\\"] assert sort_words_in_strings([\\"a single word\\"]) == [\\"a word single\\"] assert sort_words_in_strings([\\"z y x c b a\\"]) == [\\"a b c x y z\\"] ``` # Hints - Split each string into words, sort the words alphabetically, and then join them back into a string. - Ensure to preserve the order of occurrence relative to each other in the sorted words.","solution":"def sort_words_in_strings(strings: list[str]) -> list[str]: Sorts the words in each string of the input list alphabetically while maintaining the order of appearance. sorted_strings = [] for s in strings: words = s.split() words.sort() sorted_strings.append(\' \'.join(words)) return sorted_strings"},{"question":"# Coding Assessment Question In the context of string manipulations and pattern recognition, you\'ve been tasked with creating a utility that validates and formats alphanumeric sequences as serial numbers. A valid serial number must follow the specified rules below: - It must be exactly 12 characters long. - It should contain only uppercase letters and digits. - It must start with exactly three uppercase letters. - It must end with exactly three digits. Write a function `format_serial_number` that validates whether a given string is a valid serial number. If the input string is valid, reformat the serial number by inserting hyphens between every three characters to enhance readability. **Function Signature**: ```python def format_serial_number(serial): pass ``` # Input and Output - **Input**: - `serial` - A string representing the alphanumeric sequence to be validated and formatted. - **Output**: - Returns a string representing the reformatted serial number if valid. - Returns `\\"Invalid serial number\\"` if the input does not meet the validation criteria. # Constraints - The input string will have a maximum length of 50 characters. - Avoid using external libraries for string validation and formatting. # Example ```python print(format_serial_number(\\"ABC123DEF456\\")) # Expected Output: \\"ABC-123-DEF-456\\" print(format_serial_number(\\"AB1234DEF456\\")) # Expected Output: \\"Invalid serial number\\" print(format_serial_number(\\"ABCDEFGHIJKL\\")) # Expected Output: \\"Invalid serial number\\" print(format_serial_number(\\"ABC123DEF45G\\")) # Expected Output: \\"Invalid serial number\\" ``` Make sure to handle edge cases such as strings with incorrect length, invalid characters, incorrect patterns, and logically format the serial number for better readability.","solution":"def format_serial_number(serial): Validates and formats a given serial number. - serial: str - The input string to be validated and formatted. - Returns: str - The formatted serial number or \\"Invalid serial number\\". if len(serial) != 12: return \\"Invalid serial number\\" if not serial[:3].isalpha() or not serial[:3].isupper(): return \\"Invalid serial number\\" if not serial[-3:].isdigit(): return \\"Invalid serial number\\" for c in serial[3:-3]: if not c.isalnum() or c.islower(): return \\"Invalid serial number\\" return f\\"{serial[:3]}-{serial[3:6]}-{serial[6:9]}-{serial[9:]}\\""},{"question":"# Question: Implement a Linked List Based Stack Context A stack is a linear data structure that follows a Last In First Out (LIFO) principle. Traditionally, stacks can be implemented using arrays or linked lists. In this task, you are required to implement a stack using a singly linked list. Objective Write a class `LinkedListStack` that uses a singly linked list to manage stack operations. Implement methods to push elements onto the stack, pop elements from the stack, and check if the stack is empty. Methods to Implement * `push(value: int) -> None`: Adds a value to the top of the stack. * `pop() -> int`: Removes and returns the value from the top of the stack. If the stack is empty, return -1. * `is_empty() -> bool`: Returns `True` if the stack is empty, `False` otherwise. Input and Output * **Input**: * For `push`: An integer value to be added to the stack. * For `pop`: No input. * For `is_empty`: No input. * **Outputs**: * For `push`: No output (the stack is modified in place). * For `pop`: An integer value from the top of the stack or -1 if the stack is empty. * For `is_empty`: A boolean indicating if the stack is empty or not. Constraints * The stack can handle a large number of push and pop operations efficiently. * All values pushed onto the stack will be integers. Examples ```python stack = LinkedListStack() # Initially the stack is empty assert stack.is_empty() == True # Pushing values onto the stack stack.push(10) stack.push(20) stack.push(30) # The stack is no longer empty assert stack.is_empty() == False # Popping values from the stack assert stack.pop() == 30 assert stack.pop() == 20 # The stack should still have one value assert stack.is_empty() == False # Popping the last value assert stack.pop() == 10 # The stack is now empty assert stack.is_empty() == True # Popping from an empty stack should return -1 assert stack.pop() == -1 ``` Implementation Hint You might consider defining a `Node` class to represent each element in the linked list. The `LinkedListStack` class will maintain a reference to the top of the stack, which is the last pushed node. ```python class Node: def __init__(self, value: int): self.value = value self.next = None class LinkedListStack: def __init__(self): self.top = None def push(self, value: int) -> None: new_node = Node(value) new_node.next = self.top self.top = new_node def pop(self) -> int: if self.top is None: return -1 popped_value = self.top.value self.top = self.top.next return popped_value def is_empty(self) -> bool: return self.top is None ```","solution":"class Node: def __init__(self, value: int): self.value = value self.next = None class LinkedListStack: def __init__(self): self.top = None def push(self, value: int) -> None: new_node = Node(value) new_node.next = self.top self.top = new_node def pop(self) -> int: if self.top is None: return -1 popped_value = self.top.value self.top = self.top.next return popped_value def is_empty(self) -> bool: return self.top is None"},{"question":"# Coding Question: Dynamic Programming Path Finder In this task, you are required to find the number of unique paths from the top-left corner to the bottom-right corner of a grid, given some cells in the grid are blocked and cannot be traversed. Your job is to create an efficient function to solve this problem using dynamic programming. # Requirements: 1. Implement the `find_unique_paths(matrix: list[list[int]]) -> int` function. 2. The function should return the number of unique paths from the top-left corner to the bottom-right corner of the 2D matrix. 3. A path can only be constructed by moving either down or right at any point in time. 4. If any cell in the matrix is 1, it is blocked and you cannot traverse through it. If it is 0, it is open and can be traversed. 5. The dimensions of the matrix and the entries within it are guaranteed to be non-negative integers. # Input: * `matrix`: A 2D list of integers where 0 represents an open cell and 1 represents a blocked cell. # Output: * An integer representing the number of unique paths from the top-left corner to the bottom-right corner of the matrix. # Constraints: * The matrix is non-empty and its size is at most 100x100. * The start cell (top-left) and the end cell (bottom-right) will always be open (i.e., they will be 0). # Function Signature: ```python def find_unique_paths(matrix: list[list[int]]) -> int: pass ``` # Example: ```python matrix = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert find_unique_paths(matrix) == 2 # Expected unique paths: 2 matrix = [ [0, 1], [0, 0] ] assert find_unique_paths(matrix) == 1 # Expected unique paths: 1 matrix = [ [0, 0, 0], [1, 1, 0], [0, 0, 0] ] assert find_unique_paths(matrix) == 1 # Expected unique paths: 1 matrix = [ [0, 0, 1], [0, 1, 0], [1, 0, 0] ] assert find_unique_paths(matrix) == 0 # Expected unique paths: 0 since no path exists due to blockages ``` # Additional Notes: * Ensure to test your function with diverse cases, including edge cases where the path is entirely blocked, or the matrix is larger in size. * Aim for an optimal space-time complexity solution by leveraging dynamic programming principles efficiently.","solution":"def find_unique_paths(matrix): rows, cols = len(matrix), len(matrix[0]) # Create a DP table dp = [[0] * cols for _ in range(rows)] # Initialize the top-left corner dp[0][0] = 1 # Fill the DP table for r in range(rows): for c in range(cols): # If this cell is blocked, skip it if matrix[r][c] == 1: dp[r][c] = 0 else: # If it isn\'t the first row, add the number of ways from the cell above if r > 0: dp[r][c] += dp[r-1][c] # If it isn\'t the first column, add the number of ways from the cell to the left if c > 0: dp[r][c] += dp[r][c-1] # Return the number of unique paths to the bottom-right corner return dp[rows-1][cols-1]"},{"question":"# Coding Problem: You are given a set of operations to simulate on a stack-based machine. The machine executes the following instructions: - **PUSH X**: Push the integer `X` onto the stack. - **POP**: Pop the top element from the stack. - **INC X Y**: Increment the bottom `X` elements of the stack by `Y`. The machine should maintain and return the state of the stack after performing all operations provided in sequence. Problem Statement: Implement a function `stack_machine(operations: List[str]) -> List[int]` that processes a list of operations and returns the state of the stack after all operations have been executed. # Function Signature: ```python def stack_machine(operations: List[str]) -> List[int]: ``` # Input: - A list of strings `operations` representing the sequence of operations to be performed (1 ≤ len(operations) ≤ 1000). # Output: - A list of integers representing the final state of the stack after all operations are executed. # Constraints: - The stack is initially empty. - If an invalid POP operation is encountered (i.e., popping from an empty stack), ignore that operation. - The operations containing numbers (PUSH and INC) will have valid integer values. - `INC` operations will increment the bottom min(X, len(stack)) elements of the stack. # Example: ```python assert stack_machine([\\"PUSH 4\\", \\"PUSH 5\\", \\"POP\\", \\"PUSH 6\\", \\"INC 2 1\\"]) == [5, 7] assert stack_machine([\\"PUSH 1\\", \\"PUSH 2\\", \\"PUSH 3\\", \\"INC 2 2\\", \\"POP\\", \\"INC 1 2\\"]) == [5, 2] ``` # Detailed Requirements: - Implement helper functions if necessary for modularity. - Validate input to handle edge cases as described in constraints. # Performance Requirements: - Ensure your solution handles the maximum input size efficiently. - Opt for an optimal way to increment the bottom elements to avoid unnecessary overhead. # Example Scenario: Given the operations: [\\"PUSH 3\\", \\"PUSH 4\\", \\"POP\\", \\"PUSH 5\\", \\"INC 1 2\\"]: 1. PUSH 3: [3] 2. PUSH 4: [3, 4] 3. POP: [3] 4. PUSH 5: [3, 5] 5. INC 1 2: [5, 5] (increment the bottom 1 element by 2) Resulting stack state would be [5, 5].","solution":"def stack_machine(operations): stack = [] for operation in operations: if operation.startswith(\\"PUSH\\"): _, value = operation.split() stack.append(int(value)) elif operation == \\"POP\\": if stack: stack.pop() elif operation.startswith(\\"INC\\"): _, count, increment = operation.split() count = int(count) increment = int(increment) for i in range(min(count, len(stack))): stack[i] += increment return stack"},{"question":"# Problem Statement: You need to write a function that for a given positive integer `n`, returns a list of integers representing the number of 1s in the binary representation of each number from 0 to `n`. # Function Signature ```python def count_bits(n: int) -> list: pass ``` # Input - `n`: A non-negative integer. # Output - A list of integers where the ith element is the number of 1s in the binary representation of the integer i, for 0 ≤ i ≤ n. # Constraints - 0 ≤ n ≤ 10^5 # Performance Requirements - The function should run efficiently, ideally with a linear time complexity relative to the value of `n`. - It should use space proportional to the number of results (i.e., O(n)). # Examples ```python >>> count_bits(5) [0, 1, 1, 2, 1, 2] >>> count_bits(0) [0] >>> count_bits(1) [0, 1] >>> count_bits(2) [0, 1, 1] ``` # Additional Notes - Pay attention to handling edge cases where `n` is 0. - Consider using efficient algorithms to solve the problem, instead of computing the binary representation and counting bits directly for each number.","solution":"def count_bits(n: int) -> list: Returns a list of integers representing the number of 1s in the binary representation of each number from 0 to `n`. result = [0] * (n + 1) for i in range(1, n + 1): result[i] = result[i >> 1] + (i & 1) return result"},{"question":"# Problem: Word Frequency Count You have been asked to implement a function that counts the frequencies of words in a given list of sentences. Your function should be scalable and able to handle large volumes of text efficiently. Additionally, the function should ignore case when counting words. # Function Signature ```python def word_frequency(sentences: List[str]) -> Dict[str, int]: pass ``` # Input 1. `sentences` (list of strings): A list of sentences where each sentence is a string. # Output * A dictionary where keys are the words (in lowercase), and values are their respective frequencies. # Constraints 1. The input list will contain at most 10^5 sentences. 2. Each sentence will contain at most 100 words. 3. Words consist of alphabetic characters only. # Example ```python sentences = [ \\"Hello world\\", \\"The quick brown fox jumps over the lazy dog\\", \\"Hello again world\\" ] print(word_frequency(sentences)) # Expected Output: {\'hello\': 2, \'world\': 2, \'the\': 2, \'quick\': 1, \'brown\': 1, \'fox\': 1, \'jumps\': 1, \'over\': 1, \'lazy\': 1, \'dog\': 1, \'again\': 1} ``` # Scenario You are developing a text processing module for an analytics application. This module will be used to analyze customer feedback, social media posts, and other text data to identify the most common terms and gain insights into prevalent themes and topics discussed. The word frequency function is a core component of this module, providing foundational statistics for further analysis. Implementing an efficient and accurate word counting function is critical to ensure timely and reliable outcomes for the application users.","solution":"from typing import List, Dict from collections import defaultdict import re def word_frequency(sentences: List[str]) -> Dict[str, int]: word_count = defaultdict(int) for sentence in sentences: words = re.findall(r\'bw+b\', sentence.lower()) for word in words: word_count[word] += 1 return dict(word_count)"},{"question":"# Problem Statement: You are given a list of words and a pattern. Each word in the list of words must match the specified pattern. A word matches the pattern if there is a bijection between letters in the pattern and letters in the word (i.e., a one-to-one correspondence). Write a function to find all words in the list that match the given pattern. # Input: * `List[str] words`: A list of words. * `str pattern`: A string pattern consisting of lowercase letters. # Output: * Return a `List[str]` - a list containing all words that match the given pattern. # Constraints: * The number of words will be in the range `[1, 10^4]`. * The length of each word and the pattern will be in the range `[1, 20]`. * All words and the pattern will contain only lowercase English letters. # Example: ```python # Example 1: # Input: # words = [\\"abc\\", \\"deq\\", \\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"] # pattern = \\"abb\\" # Output: [\\"mee\\", \\"aqq\\"] # Example 2: # Input: # words = [\\"a\\", \\"b\\", \\"c\\"] # pattern = \\"a\\" # Output: [\\"a\\", \\"b\\", \\"c\\"] ``` # Notes: * A word matches the pattern if characters in the pattern can be mapped to characters in the word and vice versa, such that no two characters can map to the same character. * The order of characters must be preserved in both the word and the pattern. * Each character in the pattern must map to exactly one character in the word, and each character in the word must map to exactly one character in the pattern. # Function Signature: ```python def find_and_replace_pattern(words: List[str], pattern: str) -> List[str]: # Implementation here ```","solution":"def matches(word, pattern): if len(word) != len(pattern): return False w_to_p, p_to_w = {}, {} for w, p in zip(word, pattern): if w in w_to_p and w_to_p[w] != p: return False if p in p_to_w and p_to_w[p] != w: return False w_to_p[w] = p p_to_w[p] = w return True def find_and_replace_pattern(words, pattern): Returns a list of words that match the given pattern return [word for word in words if matches(word, pattern)]"},{"question":"# Question: Forest Coverage Calculation You are working as an environmental data analyst tasked with assessing the changes in forest cover over an array of land parcels. Each parcel may either be forested or non-forested. You need to implement functionality that calculates the percentage change in forested parcels over a given period. Your Task 1. Implement a function `calculate_forest_coverage` that returns the percentage of land parcels that are forested. 2. Implement a function `forest_coverage_change` that computes the percentage change in forest coverage between two different periods. Function Signatures ```python def calculate_forest_coverage(parcels: list[bool]) -> float: pass def forest_coverage_change(parcels_period_1: list[bool], parcels_period_2: list[bool]) -> float: pass ``` # Parameters * **parcels**: List of booleans where `True` represents a forested parcel and `False` represents a non-forested parcel. * **parcels_period_1**: List of booleans for the first period of land parcels. * **parcels_period_2**: List of booleans for the second period of land parcels. # Returns * For `calculate_forest_coverage`: a float representing the percentage of forested land parcels. * For `forest_coverage_change`: a float representing the percentage change in forest coverage between the two periods. # Examples ```python # Example for calculate_forest_coverage calculate_forest_coverage([True, False, True, True, False]) # Expected: 60.0 # Example for forest_coverage_change forest_coverage_change([True, False, True], [False, True, True]) # Expected: 0.0 ``` # Constraints * Both lists must be of the same length. * Utilize efficient calculations to ensure the solution scales well with large datasets.","solution":"def calculate_forest_coverage(parcels: list[bool]) -> float: Calculate the percentage of land parcels that are forested. Args: parcels: A list of booleans where True represents a forested parcel and False represents a non-forested parcel. Returns: A float representing the percentage of forested land parcels. if not parcels: return 0.0 total_parcels = len(parcels) forested_parcels = parcels.count(True) return (forested_parcels / total_parcels) * 100.0 def forest_coverage_change(parcels_period_1: list[bool], parcels_period_2: list[bool]) -> float: Computes the percentage change in forest coverage between two periods. Args: parcels_period_1: A list of booleans for the first period of land parcels. parcels_period_2: A list of booleans for the second period of land parcels. Returns: A float representing the percentage change in forest coverage between the two periods. if len(parcels_period_1) != len(parcels_period_2): raise ValueError(\\"The two periods must have the same number of parcels.\\") coverage_period_1 = calculate_forest_coverage(parcels_period_1) coverage_period_2 = calculate_forest_coverage(parcels_period_2) return coverage_period_2 - coverage_period_1"},{"question":"# Matrix Rotation without Extra Space # Problem Statement You are given an `n x n` 2D matrix representing an image, where each cell in the matrix contains an integer representing a pixel\'s value. Write a function to rotate the image by 90 degrees (clockwise) without using any extra space for another matrix. The rotation should be performed in-place. # Task Write a function `rotate(matrix: List[List[int]]) -> None` that rotates the given `n x n` matrix by 90 degrees clockwise. # Input - A list of list of integers `matrix` where each inner list represents a row in the matrix. The matrix is guaranteed to be square (`n x n`). # Output - The function should return `None` as the matrix should be altered in-place. # Constraints - `1 <= n <= 100` - Each value in the matrix is an integer between `-1000` and `1000`. # Examples ```python # Example 1 matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate(matrix) # matrix becomes: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] # Example 2 matrix = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate(matrix) # matrix becomes: # [ # [15, 13, 2, 5], # [14, 3, 4, 1], # [12, 6, 8, 9], # [16, 7, 10, 11] # ] # Example 3 matrix = [ [1] ] rotate(matrix) # matrix remains: # [ # [1] # ] # Example 4 matrix = [ [1, 2], [3, 4] ] rotate(matrix) # matrix becomes: # [ # [3, 1], # [4, 2] # ] ``` # Explanation To solve the problem, perform the following steps: 1. **Transpose the Matrix**: Swap the elements at positions `(i, j)` with `(j, i)`. 2. **Reverse Each Row**: As each row is now a column due to transposition, reversing each row gives the required 90 degrees rotation. # Note Ensure the operations are done in-place without using additional memory for storing another matrix or complex data structures outside the constraints.","solution":"def rotate(matrix): Rotates the input n x n matrix by 90 degrees clockwise in place. Parameters: matrix (List[List[int]]): A square matrix to be rotated Returns: None n = len(matrix) # Step 1: Transpose the matrix (swap rows and columns) for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Coding Assessment Question As a software developer, you are tasked with designing an efficient algorithm to analyze and compress a specific type of data sequence. The goal is to determine the maximum number of consecutive elements that share the same characteristics and provide an optimized solution for large datasets. **Scenario**: You are given a list of integers where each integer represents a certain characteristic of the data. You need to identify the maximum length of any contiguous subarray within this list where all elements are the same. **Function Signature**: ```python def max_consecutive_integers(data: List[int]) -> int: pass ``` **Input**: - `data`: A list of integers (0 <= len(data) <= 10^6) representing the characteristics of the data. **Output**: - Returns a single integer representing the length of the longest contiguous subarray where all elements are the same. **Constraints**: - The solution should be optimized to handle very large lists efficiently. - Utilize efficient algorithms and data structures to achieve the required performance. **Examples**: ```python assert max_consecutive_integers([1, 1, 2, 2, 2, 3]) == 3 assert max_consecutive_integers([4, 4, 4, 4, 4]) == 5 assert max_consecutive_integers([1, 2, 3, 4, 5]) == 1 assert max_consecutive_integers([]) == 0 assert max_consecutive_integers([5, 5, 5, 1, 1, 1, 5, 5]) == 3 ``` **Notes**: - Consider edge cases, such as an empty list or a list with all unique elements. - Aim to use linear time complexity to handle large input sizes efficiently. - Provide comments and document your code for readability and maintainability. Best of luck!","solution":"from typing import List def max_consecutive_integers(data: List[int]) -> int: # Edge case: if the list is empty, return 0 if not data: return 0 max_len = current_len = 1 # Initialize lengths for i in range(1, len(data)): if data[i] == data[i - 1]: current_len += 1 # Increment length of current consecutive segment else: max_len = max(max_len, current_len) # Update max length if current is greater current_len = 1 # Reset current length for a new segment return max(max_len, current_len) # Consider the last segment"},{"question":"# Problem Statement Your task is to implement a class `StringManipulation` that provides several string processing methods. The class should include the following methods that handle common string manipulation tasks. Ensure that you address all possible edge cases and add appropriate error handling wherever necessary. # Method Specifications: 1. **is_palindrome(s: str) -> bool**: - Checks whether the given string `s` is a palindrome. - **Input**: A single string `s` (1 <= len(s) <= 10^5). - **Output**: A boolean value - `True` if `s` is a palindrome, `False` otherwise. - **Constraints**: Raise a ValueError if `s` is empty. 2. **anagram_check(s1: str, s2: str) -> bool**: - Determines if `s1` and `s2` are anagrams of each other. - **Input**: Two strings `s1` and `s2` (1 <= len(s1), len(s2) <= 10^5). - **Output**: A boolean value - `True` if `s1` and `s2` are anagrams, `False` otherwise. - **Constraints**: Raise a ValueError if either `s1` or `s2` is empty. 3. **most_common_character(s: str) -> tuple**: - Returns the character that appears the most frequently in the string `s` along with its frequency. - **Input**: A single string `s` (1 <= len(s) <= 10^5). - **Output**: A tuple containing the character and its count in the string `(char, count)`. - **Constraints**: Raise a ValueError if `s` is empty. 4. **reverse_words(s: str) -> str**: - Reverses the order of words in the given string `s`. - **Input**: A single string `s` (1 <= len(s) <= 10^5). - **Output**: A string with the words in reverse order. - **Constraints**: Raise a ValueError if `s` is empty. # Implementation Details - Ensure all methods handle the worst-case scenarios efficiently. - Use appropriate helper functions if necessary, but they should be encapsulated within the class. - Python\'s built-in string and collection functions can be utilized to simplify the implementation. - Properly handle invalid inputs according to the constraints specified for each method. Here is an initial structure of the class for reference: ```python class StringManipulation: def is_palindrome(self, s: str) -> bool: # Your code here pass def anagram_check(self, s1: str, s2: str) -> bool: # Your code here pass def most_common_character(self, s: str) -> tuple: # Your code here pass def reverse_words(self, s: str) -> str: # Your code here pass ``` **Note** - Ensure to adhere to the method signatures. - Use efficient algorithms to handle large strings. - Raise a `ValueError` for invalid inputs as per method constraints. # Example Usage ```python sm = StringManipulation() print(sm.is_palindrome(\\"radar\\")) # Output: True print(sm.anagram_check(\\"listen\\", \\"silent\\")) # Output: True print(sm.most_common_character(\\"ababa\\")) # Output: (\'a\', 3) print(sm.reverse_words(\\"hello world\\")) # Output: \\"world hello\\" ```","solution":"class StringManipulation: def is_palindrome(self, s: str) -> bool: if not s: raise ValueError(\\"String is empty\\") return s == s[::-1] def anagram_check(self, s1: str, s2: str) -> bool: if not s1 or not s2: raise ValueError(\\"One of the strings is empty\\") return sorted(s1) == sorted(s2) def most_common_character(self, s: str) -> tuple: if not s: raise ValueError(\\"String is empty\\") from collections import Counter counter = Counter(s) most_common = counter.most_common(1)[0] return most_common def reverse_words(self, s: str) -> str: if not s: raise ValueError(\\"String is empty\\") words = s.split() reversed_words = \' \'.join(reversed(words)) return reversed_words"},{"question":"# Problem Description You are given a dictionary `items` where keys are item names (strings) and values are their quantities (integers). Your task is to write a function `sort_items_by_quantity` that returns a sorted list of item names based on their quantities in descending order. # Input * `items` (dict): A dictionary containing item names as keys and their quantities as values. The quantities are all positive integers. # Output * The function should return a list of item names sorted by their quantities in descending order. If two items have the same quantity, they should be sorted in ascending order alphabetically by their names. # Constraints * The dictionary can contain between 0 and 1000 items. * All item names are unique strings. * All quantities are positive integers. # Example ```python >>> sort_items_by_quantity({\'apples\': 5, \'bananas\': 3, \'cherries\': 5}) [\'apples\', \'cherries\', \'bananas\'] >>> sort_items_by_quantity({\'apples\': 2, \'bananas\': 10, \'oranges\': 7}) [\'bananas\', \'oranges\', \'apples\'] >>> sort_items_by_quantity({\'apples\': 2, \'bananas\': 2, \'cherries\': 2}) [\'apples\', \'bananas\', \'cherries\'] >>> sort_items_by_quantity({}) [] ``` # Requirements * Implement the function `sort_items_by_quantity` that meets the specifications. * Ensure the code passes all edge cases and efficiently handles the constraints.","solution":"def sort_items_by_quantity(items): Sorts the items dictionary by their quantities in descending order. If two items have the same quantity, they are sorted alphabetically. Args: items (dict): A dictionary containing item names as keys and their quantities as values. Returns: list: A list of item names sorted by their quantities in descending order. sorted_items = sorted(items.items(), key=lambda x: (-x[1], x[0])) return [item[0] for item in sorted_items]"},{"question":"# Question: You are tasked with implementing a function to simulate a simplified version of a file system\'s path normalization process. Your task is to create a function `normalize_path` that takes a file path as input and returns the simplified canonical path. **Function Signature**: ```python def normalize_path(path: str) -> str: # implement the function ``` # Requirements: 1. **Input Format**: - `path`: A string representing the file system path. It consists of uppercase and lowercase English alphabets, digits, and the characters `\'/\'`, `\'.\'`, and `\'..\'`. 2. **Output Format**: - A string representing the canonical path. # Constraints: - The length of the path will be in the range `1` to `10^4`. # Performance Requirements: - The algorithm should handle the maximum input size efficiently. # Example: ```python print(normalize_path(\\"/home/\\")) # Output: \\"/home\\" print(normalize_path(\\"/../\\")) # Output: \\"/\\" print(normalize_path(\\"/home//foo/\\")) # Output: \\"/home/foo\\" print(normalize_path(\\"/a/./b/../../c/\\")) # Output: \\"/c\\" print(normalize_path(\\"/a/../../b/../c//.//\\"))# Output: \\"/c\\" print(normalize_path(\\"/a//b////c/d//././/..\\"))# Output: \\"/a/b/c\\" ``` # Function Behavior: 1. Treat multiple `\'/\'` as a single `\'/\'`. 2. Resolve components `\'.\'` and `\'..\'` to navigate the directories. 3. Return the canonical path starting with a `\'/\'`. # Additional Notes: - Ensure that the path normalization handles all edge cases, including paths that lead outside the root directory. - The result should not end with a trailing slash unless it\'s the root directory `\'/\'`. # Hints: * Consider using a stack to effectively resolve the path components. * Simulate the path traversal using the stack operations to handle `\'.\'` and `\'..\'`.","solution":"def normalize_path(path: str) -> str: Normalizes the given file system path to its canonical form. parts = path.split(\\"/\\") stack = [] for part in parts: if part == \\"..\\": if stack: stack.pop() elif part == \\".\\" or not part: continue else: stack.append(part) return \\"/\\" + \\"/\\".join(stack)"},{"question":"# Question: Sum of Unique Elements Background Working with lists is a fundamental skill in programming. Often, you need to process lists to filter out duplicates and perform calculations on the remaining unique elements. This exercise requires developing an algorithm that identifies unique elements in a list and computes their sum. Task Implement a function to compute the sum of unique elements in a given list of integers. Function Signature ```python def sum_of_unique(lst: list) -> int: pass ``` Input * A list of integers, `lst`. Output * An integer representing the sum of unique elements in the list. Constraints * The length of `lst` will be between `1` and `10^5`. * Each integer in `lst` will be between `-10^6` and `10^6`. Example ```python assert sum_of_unique([1, 2, 3, 2, 1, 4]) == 10 assert sum_of_unique([5, 5, 5, 5]) == 5 assert sum_of_unique([1, 2, 3, 4]) == 10 assert sum_of_unique([-1, 2, -1, -2, 3]) == 3 ``` Detailed Description * You must implement the `sum_of_unique` function. * The function should take a list of integers as input and return the sum of all unique elements in the list. * For example, for the list `[1, 2, 3, 2, 1, 4]`, the function should return `10` since `1` and `2` are duplicates and should only be counted once each, together with `3` and `4`. * Ensure that the function efficiently handles larger lists up to the given constraint limits. Hints * Use a set or a similar data structure to track unique elements. * Iterate through the list and build a collection of unique elements. * Calculate the sum of elements in this unique collection.","solution":"def sum_of_unique(lst: list) -> int: Compute the sum of unique elements in a given list. unique_elements = set(lst) return sum(unique_elements)"},{"question":"# Array Pair Sum You need to write a function that checks if a given array contains two distinct elements that add up to a specified target sum. The function should be efficient and handle large inputs gracefully. Implementation Details: Implement a function `has_pair_with_sum(arr: list, target_sum: int) -> bool` with the following specifications: - The function takes a list of integers `arr` and an integer `target_sum` as input. - The function returns `True` if there are two distinct elements in the array that add up to `target_sum`, otherwise returns `False`. Input: - A list `arr` of integers. The list may be empty or contain up to 10^6 elements. - An integer `target_sum` which can be positive, negative, or zero. Output: - A boolean value `True` if there exists a pair of distinct elements in the array whose sum is equal to `target_sum`, otherwise `False`. Constraints: - Your solution should aim to achieve O(n) time complexity where n is the number of elements in the array. - The array can contain both positive and negative integers. Example: ```python assert has_pair_with_sum([10, 15, 3, 7], 17) == True # 10 + 7 = 17 assert has_pair_with_sum([1, 2, 3, 4, 5], 10) == False # No pairs sum up to 10 assert has_pair_with_sum([], 5) == False # Empty array assert has_pair_with_sum([0, -1, 2, -3, 1], -2) == True # -3 + 1 = -2 ``` Points to Consider: - Make use of a set to store the elements and check if the complement of the current element (i.e., `target_sum - current_element`) exists in the set. - Ensure that you do not use the same element twice to form the pair. - Handle edge cases such as empty arrays or arrays with only one element appropriately.","solution":"def has_pair_with_sum(arr, target_sum): Checks if there are two distinct elements in the array that add up to target_sum. seen = set() for number in arr: if target_sum - number in seen: return True seen.add(number) return False"},{"question":"# Problem Scenario/Context An \\"H-Tree\\" is a fractal structure composed of interconnected line segments resembling the letter \\"H\\". The structure starts with a base case and grows by recursively adding smaller \\"H\\" shapes at the ends of each segment. The depth of the recursion determines the level of detail in the H-Tree, with deeper levels adding exponentially more segments. # Task You are to write a function `h_tree_segment_count` that takes in a single integer parameter `depth` indicating the level of recursion in the H-Tree. The function should return the total number of line segments that form the H-Tree at the given depth. Function Signature ```python def h_tree_segment_count(depth: int) -> int: pass ``` Input * `depth` (int): The depth of recursion in the H-Tree, 0 ≤ depth ≤ 10. Output * `int`: The total number of line segments in the H-Tree at the given depth. # Constraints * Integer operations must be used. * The function should efficiently calculate the number of segments for the given depth without excessive recursion. # Example ```python >>> h_tree_segment_count(0) 1 >>> h_tree_segment_count(1) 5 >>> h_tree_segment_count(2) 21 ``` # Explanation The first few levels of an H-Tree segment count: - Depth 0: Single segment (1) - Depth 1: Center segment plus four segments (1 + 4*1 = 5) - Depth 2: Each of the segments from depth 1 spawns 4 new segments but the overlapping segments are counted once (5 + 4*4 = 21)","solution":"def h_tree_segment_count(depth: int) -> int: Returns the number of segments in an H-Tree of a given depth. Parameters: depth (int): The depth of the H-Tree. Returns: int: The total number of segments in the H-Tree. if depth == 0: return 1 return 4 * h_tree_segment_count(depth - 1) + 1"},{"question":"# Coding Assessment Question Scenario: You have been assigned to create a function that helps to analyze the relationships between people in terms of social influence from recommendations. Given a network where each person can recommend a product to other people, the objective is to find out how many people can be influenced starting from a particular person. Task: Write a function `influenced_count(start: str, network: Dict[str, List[str]]) -> int` that computes the total number of people who can be influenced by the individual `start`, either directly or indirectly, based on the provided recommendation network. Input: 1. `start`: A string representing the unique identifier of the starting person. 2. `network`: A dictionary where keys are person identifiers and values are lists of people whom they can recommend products to. Output: - An integer representing the total number of unique individuals who can be influenced by the start person (excluding the start person). Constraints: - Each person is uniquely identifiable by the string key. - There may be no recommendations (empty lists but not necessarily empty dictionary values). - The input network is acyclic and can have disconnected components. Example: ```python start = \\"A\\" network = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"C\\", \\"D\\"], \\"C\\": [\\"E\\"], \\"D\\": [], \\"E\\": [\\"D\\"], \\"F\\": [\\"G\\"], \\"G\\": [\\"F\\"] } print(influenced_count(start, network)) # Output: 4 (B, C, D, E) ``` # Performance Requirements: - The function should traverse the network efficiently and handle up to 10,000 people. - Aim for a time complexity of O(V + E). Note: - Make sure to test for cases with no connections or isolated people. - Consider using graph traversal algorithms like Depth-First Search (DFS) or Breadth-First Search (BFS) to solve the problem.","solution":"def influenced_count(start, network): Given a starting person and a network of recommendations, this function returns the total number of unique individuals who can be influenced by the start person. influenced_set = set() stack = [start] while stack: person = stack.pop() if person not in influenced_set: influenced_set.add(person) stack.extend(network.get(person, [])) # Remove \'start\' from the result count influenced_set.remove(start) return len(influenced_set)"},{"question":"# Problem Statement: You are required to implement a nearest neighbor search algorithm for finding the closest points to a given query point from a set of points in a 2-D plane. The challenge is to implement the following functionalities: 1. **Distance Calculation**: Write a function to compute the Euclidean distance between two points. 2. **Finding the Nearest Neighbor**: Implement a function to search for the nearest point to the given query point using a k-d tree for efficient querying. 3. **Handling Edge Cases**: Ensure the algorithm correctly handles cases where multiple points have the same distance to the query point. # Function Signature: ```python from typing import List, Tuple def euclidean_distance(a: Tuple[int, int], b: Tuple[int, int]) -> float: pass def build_kd_tree(points: List[Tuple[int, int]]) -> object: pass def find_nearest_neighbor(tree: object, query: Tuple[int, int]) -> Tuple[int, int]: pass ``` # Input: * `points`: A list of tuples representing the points in the 2-D plane (~1 <= len(points) <= 10^6~). Each tuple contains two integers (x, y). * `query`: A tuple representing the query point (x, y) that we want to find the nearest neighbors for (~-10^9 <= x, y <= 10^9~). # Output: * Return the nearest point to the query point as a tuple of two integers (x, y). # Constraints: * Ensure the solution handles large lists of points efficiently. * Optimize both the time complexity for building the k-d tree and the querying process. * Multiple points with the same distance should return the one that appears first in the input list. # Example: ```python points = [(1, 2), (3, 4), (5, 6), (9, 9)] query = (3, 3) assert find_nearest_neighbor(build_kd_tree(points), query) == (3, 4) points = [(1, 1), (2, 2), (3, 3)] query = (2, 3) assert find_nearest_neighbor(build_kd_tree(points), query) == (2, 2) points = [(-1, 2), (2, -1), (0, 0)] query = (1, 1) assert find_nearest_neighbor(build_kd_tree(points), query) == (0, 0) ``` # Note: 1. The primary objective is to build a k-d tree for the given points to enable efficient nearest neighbor search. 2. Implement the distance calculation function to assist in finding the nearest neighbor. 3. Ensure to test edge cases such as points with the same or minimal identical distances. 4. Use custom data structures and algorithms to avoid reliance on specialized libraries while demonstrating efficient and optimized code.","solution":"from typing import List, Tuple import heapq import math def euclidean_distance(a: Tuple[int, int], b: Tuple[int, int]) -> float: Computes the Euclidean distance between two points a and b. return math.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) class Node: def __init__(self, point: Tuple[int, int], left: \'Node\' = None, right: \'Node\' = None, axis=0): self.point = point self.left = left self.right = right self.axis = axis def build_kd_tree(points: List[Tuple[int, int]], depth: int = 0) -> Node: Builds a k-d tree from a list of points. if not points: return None k = 2 # 2-D space axis = depth % k points.sort(key=lambda x: x[axis]) median_index = len(points) // 2 return Node( point=points[median_index], left=build_kd_tree(points[:median_index], depth + 1), right=build_kd_tree(points[median_index + 1:], depth + 1), axis=axis ) def find_nearest_neighbor(tree: Node, query: Tuple[int, int]) -> Tuple[int, int]: Finds the nearest neighbor in k-d tree to the given query point. best = [None, float(\'inf\')] def recursive_search(node: Node): if node is None: return point = node.point axis = node.axis distance = euclidean_distance(query, point) if distance < best[1]: best[0], best[1] = point, distance diff = query[axis] - point[axis] close, away = (node.left, node.right) if diff <= 0 else (node.right, node.left) recursive_search(close) if diff ** 2 < best[1]: recursive_search(away) recursive_search(tree) return best[0]"},{"question":"# Weather Data Processing Function Objective: You are required to implement a function that processes weather data from the OpenWeather API. The function should take three input parameters: the city name, the country code, and the API key. The function should return a dictionary containing the temperature, weather description, and humidity level for the specified city, or an appropriate error message if the retrieval fails. Function Signature: ```python def get_weather_data(city: str, country_code: str, api_key: str) -> dict: ``` Inputs: 1. `city` (str): The name of the city to get the weather information for (e.g., \'London\', \'Paris\'). 2. `country_code` (str): The 2-character country code corresponding to the city (e.g., \'GB\', \'FR\'). 3. `api_key` (str): Your OpenWeather API key. Outputs: 1. (dict): A dictionary with keys \'temperature\', \'weather_description\', and \'humidity\', or an error message if the retrieval fails. Constraints: 1. The `city` parameter should be a valid city name. 2. The `country_code` parameter should be a valid 2-character country code. 3. The `api_key` should be provided. Requirements: 1. Handle different types of errors, including HTTP errors, invalid city or country codes, and JSON parsing issues. 2. Optimize the function to handle up to 60 API requests per minute. # Example: ```python # Example usage: weather_data = get_weather_data(\'London\', \'GB\', \'your_api_key\') print(weather_data) # Expected output: A dictionary with the weather data, e.g., # {\'temperature\': 15.5, \'weather_description\': \'light rain\', \'humidity\': 82} # or an error message. ``` # Notes: 1. You can assume that the API base URL and endpoint is given as `\\"https://api.openweathermap.org/data/2.5/weather\\"`. 2. The API documentation is available at https://openweathermap.org/current. 3. Implement error handling for common issues such as invalid city names, country codes, API errors, and missing API keys. 4. Your implementation should aim for clarity, maintainability, and robustness. Good luck, and happy coding!","solution":"import requests def get_weather_data(city: str, country_code: str, api_key: str) -> dict: Fetches weather data from OpenWeather API. Parameters: city (str): Name of the city. country_code (str): 2-character country code. api_key (str): OpenWeather API key. Returns: dict: A dictionary containing temperature, weather description, and humidity if successful, or an error message if the retrieval fails. base_url = \\"https://api.openweathermap.org/data/2.5/weather\\" params = { \'q\': f\\"{city},{country_code}\\", \'appid\': api_key, \'units\': \'metric\' } try: response = requests.get(base_url, params=params) response.raise_for_status() data = response.json() return { \'temperature\': data[\'main\'][\'temp\'], \'weather_description\': data[\'weather\'][0][\'description\'], \'humidity\': data[\'main\'][\'humidity\'] } except requests.exceptions.HTTPError as http_err: return {\\"error\\": f\\"HTTP error occurred: {http_err}\\"} except requests.exceptions.RequestException as err: return {\\"error\\": f\\"Error occurred: {err}\\"} except KeyError as key_err: return {\\"error\\": f\\"Unexpected data format: {key_err}\\"}"},{"question":"# Advanced Coding Assessment Question Context You are tasked with developing a system for managing orders in a restaurant. Each order consists of multiple items, and the restaurant needs to keep track of quantities and manage inventory accordingly. You need to implement functionalities to add new orders, update existing ones, and retrieve summary details. Problem Statement Implement a class `OrderManager` that manages orders and keeps track of inventory. 1. Implement the class `OrderManager` with the following methods: - `__init__(self)` which initializes an empty orders list and an empty inventory dictionary. - `add_order(self, order_id: int, items: dict[str, int]) -> None` which adds a new order with the given ID and the specified items. Each item is represented by a name (string) and a quantity (integer). If the order ID already exists, update the existing order quantities accordingly. - `get_order(self, order_id: int) -> dict` which retrieves the order details for the given order ID. If the order does not exist, raise a `ValueError` with a meaningful message. - `get_inventory_summary(self) -> dict` which returns a summary of the inventory, showing the total quantity of each item. 2. Ensure proper handling of edge cases: - Handle updates to orders correctly by summing quantities for duplicate items. - Provide meaningful error messages for invalid order IDs. Constraints * An order can\'t contain negative quantities. * An item name will be a non-empty string of maximum length 50. * The maximum number of unique items across all orders is 10^4. Function Signatures * `class OrderManager` - `__init__(self) -> None` - `add_order(self, order_id: int, items: dict[str, int]) -> None` - `get_order(self, order_id: int) -> dict` - `get_inventory_summary(self) -> dict` Input and Output * `OrderManager.__init__()` - **Initialization**: Initializes an empty orders list and an empty inventory dictionary. * `OrderManager.add_order(order_id: int, items: dict[str, int]) -> None` - **Input**: An integer `order_id` and a dictionary `items` where keys are item names (strings) and values are quantities (integers). - **Output**: None. Adds the order to the system or updates the existing order quantities. * `OrderManager.get_order(order_id: int) -> dict` - **Input**: An integer `order_id`. - **Output**: A dictionary with item names as keys and quantities as values. - **Raises**: `ValueError` if the order ID is invalid or the order doesn\'t exist. * `OrderManager.get_inventory_summary() -> dict` - **Output**: A dictionary summarizing the inventory with item names as keys and total quantities as values. Example Usage ```python om = OrderManager() # Add new orders om.add_order(1, {\'burger\': 2, \'fries\': 1}) om.add_order(2, {\'pizza\': 1, \'burger\': 1}) # Update an existing order om.add_order(1, {\'burger\': 1, \'soda\': 2}) # Retrieve specific order details print(om.get_order(1)) # Outputs: {\'burger\': 3, \'fries\': 1, \'soda\': 2} print(om.get_order(2)) # Outputs: {\'pizza\': 1, \'burger\': 1} # Invalid order retrieval try: print(om.get_order(3)) except ValueError as e: print(e) # Outputs: Order ID not found # Get inventory summary print(om.get_inventory_summary()) # Outputs: {\'burger\': 4, \'fries\': 1, \'pizza\': 1, \'soda\': 2} ```","solution":"class OrderManager: def __init__(self): self.orders = {} self.inventory = {} def add_order(self, order_id: int, items: dict[str, int]) -> None: if order_id not in self.orders: self.orders[order_id] = {} for item, quantity in items.items(): if quantity < 0: raise ValueError(f\\"Quantity for item \'{item}\' cannot be negative\\") if item in self.orders[order_id]: added_quantity = self.orders[order_id][item] else: added_quantity = 0 self.orders[order_id][item] = added_quantity + quantity if item in self.inventory: self.inventory[item] += quantity else: self.inventory[item] = quantity def get_order(self, order_id: int) -> dict: if order_id not in self.orders: raise ValueError(\\"Order ID not found\\") return self.orders[order_id] def get_inventory_summary(self) -> dict: return self.inventory"},{"question":"# Coding Challenge: Efficient Pathfinding in a Graph As a software engineer working on a navigation system, you need to implement an efficient algorithm to find the shortest path between two nodes in a weighted graph. Given an undirected graph represented as an adjacency list, your task is to implement Dijkstra\'s algorithm to find the shortest path from a starting node to a destination node. **Objective**: Implement Dijkstra\'s algorithm to compute the shortest path from a given start node to a target node in a weighted graph. # Task **Method Signature**: ```python def dijkstra( graph: dict[int, list[tuple[int, int]]], start_node: int, destination_node: int ) -> list[int]: pass ``` **Inputs**: 1. `graph (dict[int, list[tuple[int, int]]]`): An adjacency list representing the graph where keys are node identifiers (int) and values are lists of tuples (neighboring node identifier, edge weight). 2. `start_node (int)`: The node from which the path search begins. 3. `destination_node (int)`: The node to which the shortest path is to be found. **Outputs**: - **Returns**: A list of integers representing the nodes in the shortest path from `start_node` to `destination_node` in order. If no path exists, return an empty list. **Constraints**: - All node identifiers are non-negative integers. - All edge weights are positive integers. # Example Given a graph represented as follows: ```python graph = { 0: [(1, 1), (2, 4)], 1: [(0, 1), (2, 2), (3, 5)], 2: [(0, 4), (1, 2), (3, 1)], 3: [(1, 5), (2, 1)], } ``` If `start_node = 0` and `destination_node = 3`, the method should return `[0, 1, 2, 3]`, which is the shortest path from node 0 to node 3. # Implementation Requirements - Use a priority queue (min-heap) to efficiently retrieve the next node with the shortest known distance. - Maintain a distance table to track the shortest distance from `start_node` to each node. - Keep track of the preceding node for each node in the shortest path. - Reconstruct the shortest path from `start_node` to `destination_node` using the preceding node information. - Include comprehensive test cases covering various graph configurations and edge cases.","solution":"import heapq def dijkstra(graph, start_node, destination_node): Returns the shortest path from start_node to destination_node using Dijkstra\'s algorithm. # Initialize the priority queue priority_queue = [(0, start_node)] # (distance, node) # Initialize a dict to store the shortest distance to each node distances = {node: float(\'inf\') for node in graph} distances[start_node] = 0 # Initialize a dict to store the previous node for each node in the path previous_nodes = {node: None for node in graph} # Set to track visited nodes visited = set() while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_node in visited: continue visited.add(current_node) if current_node == destination_node: break for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(priority_queue, (distance, neighbor)) # Reconstruct the shortest path path = [] node = destination_node while node is not None: path.insert(0, node) node = previous_nodes[node] if path[0] != start_node: # If there\'s no valid path return [] return path"},{"question":"# Background Sorting algorithms are fundamental in computer science and are used to arrange elements in a particular order. Bubble sort is a simple comparison-based algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The process is repeated until the list is sorted. # Problem Statement Write a function `bubble_sort(arr: List[int]) -> List[int]` that performs the bubble sort algorithm on a list of integers and returns the sorted list. # Input - `arr`: A list of integers that needs to be sorted. # Output - A list of integers sorted in non-decreasing order. # Constraints - The length of the list will not exceed 10^4. - The integers in the list will be within the range -10^6 to 10^6. - The list may contain duplicate elements. # Example ```python arr = [64, 34, 25, 12, 22, 11, 90] result = bubble_sort(arr) print(result) # Output should be [11, 12, 22, 25, 34, 64, 90] ``` # Notes - Focus on writing clean and efficient code. - Handle edge cases where the list could be empty or contain only one element, which should be returned as is. # Hints - Use a nested loop to traverse the list and compare adjacent elements. - Implement optimization to stop the algorithm if the list becomes sorted before completing all passes.","solution":"from typing import List def bubble_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the bubble sort algorithm. Parameters: arr (List[int]): The list of integers to be sorted. Returns: List[int]: The sorted list in non-decreasing order. n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if not swapped: break return arr"},{"question":"# Problem Statement You are given a `words` list of strings, where each string consists of only lowercase English letters. Your task is to write a function that determines the maximum number of non-overlapping subsequential pairs of strings from the list such that the reversed version of one string exists in the list. # Function Signature ```python def max_reversed_pairs(words: List[str]) -> int: Given a list of strings `words`, returns the maximum number of non-overlapping subsequential pairs where one string is the reverse of the other. Parameters: words (List[str]): the list of strings. Returns: int: the maximum number of non-overlapping pairs. ``` # Input - A list of strings `words` (1 ≤ len(words) ≤ 10^3, 1 ≤ len(words[i]) ≤ 100), where each string consists of only lowercase English letters. # Output - An integer representing the maximum number of non-overlapping subsequential pairs of reversed strings. # Example Usage ```python assert max_reversed_pairs([\\"abcd\\", \\"dcba\\", \\"lls\\", \\"s\\", \\"sssll\\"]) == 1 assert max_reversed_pairs([\\"bat\\", \\"tab\\", \\"cat\\"]) == 1 assert max_reversed_pairs([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\", \\"g\\"]) == 0 ``` # Explanation The function should count how many pairs of strings can be formed such that one string is the reverse of the other, without using any string more than once in any pair. For instance, in the first example above, \\"abcd\\" and \\"dcba\\" form a pair. The function should then find the maximum of such unique pairs. # Additional Notes - Consider edge cases where the list includes only one string or has no possible pairs. - Efficiently handle checking and pairing strings by making use of data structures such as sets or dictionaries for quick look-up of reversed versions. This problem tests your ability to manipulate strings, particularly checking for palindromic properties, and to use efficient data structures or algorithms to maximize pairing possibilities.","solution":"from typing import List def max_reversed_pairs(words: List[str]) -> int: Given a list of strings `words`, returns the maximum number of non-overlapping subsequential pairs where one string is the reverse of the other. Parameters: words (List[str]): the list of strings. Returns: int: the maximum number of non-overlapping pairs. # Use a dictionary to store the frequency of each word word_count = {} for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 # Initialize the count for pairs count_pairs = 0 # Iterate over the words to find its reverse pair for word in words: reverse_word = word[::-1] # Check if the reverse word is in the dictionary and both are present if reverse_word in word_count and word_count[reverse_word] > 0 and word_count[word] > 0: if word == reverse_word: # If the word is a palindrome itself, we need two counts of it to make a pair if word_count[word] >= 2: word_count[word] -= 2 count_pairs += 1 else: # General case for non-palindromic pairs word_count[word] -= 1 word_count[reverse_word] -= 1 count_pairs += 1 return count_pairs"},{"question":"# Task: Implementing a Flexible N-ary Tree Traversal You need to implement a traversal function for an N-ary tree and allow different traversal orders (pre-order, post-order). The function should be robust to handle edge cases and maintain performance efficiency for large trees. # Input: 1. **Node class with the definition `Node(val, children)`**: - `val` is an integer representing the node\'s value. - `children` is a list of Node objects representing the node’s children. 2. **Node, `root`**: The root node of the N-ary tree. 3. **string, `traversal_order`**: The order of traversal which can be either `\\"pre-order\\"` or `\\"post-order\\"`. # Output: - **list of integers**: A list of node values following the specified traversal order. # Constraints: - The tree may contain zero or more nodes. - If there are no nodes, the result should be an empty list. # Performance Requirements: - Ensure the traversal algorithm is efficient for large trees. - Maintain clarity and conciseness in the traversal logic. - Handle edge cases like empty trees or trees with single nodes gracefully. # Example: ```python # Example usage: class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] root = Node(1, [Node(2), Node(3, [Node(6), Node(7)]), Node(4, [Node(8)]), Node(5)]) assert nary_tree_traversal(root, \\"pre-order\\") == [1, 2, 3, 6, 7, 4, 8, 5] assert nary_tree_traversal(root, \\"post-order\\") == [2, 6, 7, 3, 8, 4, 5, 1] empty_tree = None assert nary_tree_traversal(empty_tree, \\"pre-order\\") == [] assert nary_tree_traversal(empty_tree, \\"post-order\\") == [] single_node = Node(10) assert nary_tree_traversal(single_node, \\"pre-order\\") == [10] assert nary_tree_traversal(single_node, \\"post-order\\") == [10] ``` # Additional Notes: - Clearly define the Node class and its attributes. - Ensure pre-order traversal processes the node before its children and post-order processes the children before the node. - Consider using recursion or stack-based approaches to manage traversal effectively.","solution":"class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def nary_tree_traversal(root, traversal_order): Traverses an N-ary tree in the specified order (pre-order or post-order). Parameters: root (Node): The root node of the N-ary tree traversal_order (str): The order of traversal which can be either \\"pre-order\\" or \\"post-order\\" Returns: list of int: A list of node values in the specified traversal order if not root: return [] result = [] if traversal_order == \\"pre-order\\": def pre_order(node): if node: result.append(node.val) for child in node.children: pre_order(child) pre_order(root) elif traversal_order == \\"post-order\\": def post_order(node): if node: for child in node.children: post_order(child) result.append(node.val) post_order(root) else: raise ValueError(\\"Invalid traversal order. Must be \'pre-order\' or \'post-order\'\\") return result"},{"question":"# Problem Statement You are required to write a function `find_top_companies` that processes employee data to discover the top companies based on various criteria. The function should be able to: 1. Sort the companies based on the number of employees. 2. Filter companies that exceed a specified minimum number of employees. 3. Group companies by their industry and calculate the total number of employees within each industry. # Function Signature ```python def find_top_companies( company_data: list, min_employees: int = 0, sort_by: str = \\"employees\\" ) -> tuple: Process and analyze company employee data. Parameters: - company_data (list): A list of dictionaries containing company information, including \'name\', \'employees\', \'industry\'. - min_employees (int): The minimum number of employees a company must have to be included in the results. Default is 0. - sort_by (str): The field by which the results should be sorted. Default is \\"employees\\". Returns: - tuple: Two elements tuple - list: Sorted list of companies meeting the minimum employee requirement. - dict: Dictionary with industries as keys and total number of employees per industry as values. ``` # Input/Output Examples Input ```python find_top_companies( [ {\\"name\\": \\"Company A\\", \\"employees\\": 150, \\"industry\\": \\"Technology\\"}, {\\"name\\": \\"Company B\\", \\"employees\\": 75, \\"industry\\": \\"Finance\\"}, {\\"name\\": \\"Company C\\", \\"employees\\": 300, \\"industry\\": \\"Technology\\"}, {\\"name\\": \\"Company D\\", \\"employees\\": 50, \\"industry\\": \\"Healthcare\\"}, ], min_employees=100, sort_by=\\"employees\\" ) ``` Output ```python ( [ {\\"name\\": \\"Company C\\", \\"employees\\": 300, \\"industry\\": \\"Technology\\"}, {\\"name\\": \\"Company A\\", \\"employees\\": 150, \\"industry\\": \\"Technology\\"} ], { \\"Technology\\": 450, \\"Finance\\": 75, \\"Healthcare\\": 50 } ) ``` # Constraints and Requirements 1. The company_data parameter is mandatory and should be a list of dictionaries containing \'name\', \'employees\', and \'industry\' keys. 2. The min_employees and sort_by parameters are optional. Default min_employees is 0, and default sort_by is \\"employees\\". 3. The function should filter out companies that do not meet the min_employees criteria. 4. Sort the filtered companies based on the sort_by field, which can be either \\"employees\\" or \\"name\\". 5. Aggregate the number of employees by industry for all companies, not just those meeting the min_employees criteria. 6. Ensure the sorting and filtering processes are efficient for large datasets. # Performance Requirements 1. Handle a list of up to 100,000 company entries efficiently. 2. Ensure minimal memory usage by optimizing dictionary and list operations. # Context This function can be utilized in data analysis of corporate structures, human resources insights, and industry-specific market research.","solution":"def find_top_companies(company_data, min_employees=0, sort_by=\\"employees\\"): Process and analyze company employee data. Parameters: - company_data (list): A list of dictionaries containing company information, including \'name\', \'employees\', \'industry\'. - min_employees (int): The minimum number of employees a company must have to be included in the results. Default is 0. - sort_by (str): The field by which the results should be sorted. Default is \\"employees\\". Returns: - tuple: Two elements tuple - list: Sorted list of companies meeting the minimum employee requirement. - dict: Dictionary with industries as keys and total number of employees per industry as values. if sort_by not in (\\"employees\\", \\"name\\"): raise ValueError(f\\"Invalid sort_by value \'{sort_by}\'. Must be either \'employees\' or \'name\'.\\") # Filter companies based on min_employees filtered_companies = [company for company in company_data if company[\'employees\'] >= min_employees] # Sort the filtered list based on the sort_by field sorted_companies = sorted(filtered_companies, key=lambda x: x[sort_by], reverse=(sort_by == \\"employees\\")) # Aggregate number of employees by industry industry_totals = {} for company in company_data: industry = company[\'industry\'] employees = company[\'employees\'] if industry in industry_totals: industry_totals[industry] += employees else: industry_totals[industry] = employees return sorted_companies, industry_totals"},{"question":"# Coding Assessment Question: Advanced Tic-Tac-Toe Solver Introduction Tic-Tac-Toe is a classic 3x3 grid game where two players, X and O, take turns to place their marks on the grid. The player who succeeds in placing three of their marks in a horizontal, vertical, or diagonal row wins the game. If the grid is full and no player has won, the game is considered a draw. You are given a partially completed Tic-Tac-Toe grid. Your task is to determine the best move for the current player (X or O) to either win or avoid losing if possible. If no winning or blocking move is available, choose the best possible move according to simple strategy heuristics. Task Implement a function `tic_tac_toe_move(grid, player)` that takes the current grid configuration and the current player (\'X\' or \'O\'), and returns the best move as a tuple `(row, col)` representing the position on the grid (0-indexed). If the grid is already complete or no moves are possible, return `None`. Function Signature ```python def tic_tac_toe_move(grid: List[List[str]], player: str) -> Union[Tuple[int, int], None]: pass ``` Input * `grid`: A list of lists representing the 3x3 Tic-Tac-Toe grid. Each cell contains \'X\', \'O\', or \'\' (empty). * `player`: A string representing the current player, either \'X\' or \'O\'. Output * Return a tuple `(row, col)` representing the best move for the current player. * Return `None` if the grid is complete or no valid moves exist. Constraints * The grid will always be a 3x3 list of lists. * The player will always be either \'X\' or \'O\'. Example ```python grid = [ [\'X\', \'O\', \'X\'], [\'\', \'O\', \'\'], [\'X\', \'\', \'O\'] ] player = \'X\' print(tic_tac_toe_move(grid, player)) # Output could be (1, 0) or (1, 2) or (2, 1) depending on the heuristics used grid = [ [\'X\', \'O\', \'X\'], [\'O\', \'O\', \'X\'], [\'X\', \'X\', \'O\'] ] player = \'O\' print(tic_tac_toe_move(grid, player)) # Output should be None as the grid is full ``` Guidelines * Check for any winning/losing positions and prioritize them. * Use simple heuristics like placing in the center or corners if no immediate win/blocking move is available. * Aim to make the game engaging and implement an effective opponent strategy. Note You can utilize the helper functions provided below for checking win conditions and evaluating possible moves: ```python def tic_tac_toe_move(grid, player): # Implement the function body pass def check_win(grid, player): # Check if a specific player has won in the current grid pass # Define any other required helper functions here. ```","solution":"def tic_tac_toe_move(grid, player): # Helper function to check if the player has a winning move def check_win(grid, player): for row in range(3): if all([grid[row][col] == player for col in range(3)]): return True for col in range(3): if all([grid[row][col] == player for row in range(3)]): return True if all([grid[i][i] == player for i in range(3)]) or all([grid[i][2 - i] == player for i in range(3)]): return True return False # Check if a move is valid def is_valid_move(grid, row, col): return grid[row][col] == \'\' # Try to find a winning move or block the opponent\'s winning move opponent = \'O\' if player == \'X\' else \'X\' for i in range(3): for j in range(3): if is_valid_move(grid, i, j): grid[i][j] = player if check_win(grid, player): return (i, j) grid[i][j] = opponent if check_win(grid, opponent): grid[i][j] = \'\' return (i, j) grid[i][j] = \'\' # Heuristic preference: center, corners, then sides pref_moves = [(1, 1), (0, 0), (0, 2), (2, 0), (2, 2), (0, 1), (1, 0), (1, 2), (2, 1)] for move in pref_moves: if is_valid_move(grid, move[0], move[1]): return move # If no moves left, return None return None"},{"question":"# Coding Assessment Question Context In many natural language processing tasks, text segmentation and tokenization are fundamental steps. This involves breaking down a string of text into its constituent words or tokens, while properly handling special cases such as punctuation and contractions. Problem Statement Your task is to implement a Python function that segments a given string of text into tokens, ensuring that punctuation is treated as separate tokens and preserving the case of the original text. Contractions should be split into their component words, and multiple spaces should be reduced to a single space in the final token list. Function Signature ```python def tokenize_text(text: str) -> List[str]: ``` Input - `text` (str): A string of text that may contain words, punctuation, and spaces. Output - A list of strings, each representing a token. Punctuation marks should each be their own token, and contractions should be split. Constraints - The input string `text` must be non-empty. Raise `ValueError` if it is empty. - Tokens should be separated by single spaces in the output list. Examples ```python >>> tokenize_text(\\"Hello, world! I\'m testing this function.\\") [\'Hello\', \',\', \'world\', \'!\', \'I\', \\"\'m\\", \'testing\', \'this\', \'function\', \'.\'] >>> tokenize_text(\\" Hello world! \\") [\'Hello\', \'world\', \'!\'] >>> tokenize_text(\\"It\'s a test-case.\\") [\\"It\\", \\"\'s\\", \\"a\\", \\"test\\", \\"-\\", \\"case\\", \\".\\"] >>> tokenize_text(\\"\\") Traceback (most recent call last): ... ValueError: Input text must not be empty >>> tokenize_text(\\"This is a test.\\") [\'This\', \'is\', \'a\', \'test\', \'.\'] ``` Additional Notes Ensure your implementation handles edge cases such as multiple spaces, punctuation at the beginning or end of the string, and common English contractions. You may use regular expressions to assist with splitting and tokenizing the text. Good luck!","solution":"from typing import List import re def tokenize_text(text: str) -> List[str]: if not text: raise ValueError(\\"Input text must not be empty\\") # Regex to match words, contractions and punctuations separately token_pattern = re.compile(r\\"w+|\'w+|[^ws]\\") # Find all matches according to the regex pattern tokens = token_pattern.findall(text) return tokens"},{"question":"# Palindrome Checking with Preprocessing Create a function that checks if the given string, after converting it to lowercase and removing all non-alphanumeric characters, is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and case). Implement the function `is_preprocessed_palindrome(input_str: str) -> bool` that: * Takes a single string as input. * Converts the string to lowercase. * Removes all non-alphanumeric characters. * Returns `True` if the processed string is a palindrome. * Returns `False` otherwise. Function Signature ```python def is_preprocessed_palindrome(input_str: str) -> bool: pass ``` # Input * `input_str`: A string containing alphanumeric characters and possibly other symbols. # Output * Returns `True` if the processed string is a palindrome. * Returns `False` otherwise. # Examples Here are some sample test cases for your implementation: ```python assert is_preprocessed_palindrome(\\"A man, a plan, a canal, Panama!\\") == True assert is_preprocessed_palindrome(\\"Racecar\\") == True assert is_preprocessed_palindrome(\\"No lemon, no melon\\") == True assert is_preprocessed_palindrome(\\"Hello, World!\\") == False ``` # Notes 1. The function should handle empty strings gracefully and return `True` (an empty string is trivially a palindrome). 2. The input string may contain uppercase letters, punctuation, and other symbols which should be ignored in the palindrome check.","solution":"def is_preprocessed_palindrome(input_str: str) -> bool: Checks if the given string, after converting it to lowercase and removing all non-alphanumeric characters, is a palindrome. # Convert to lowercase input_str = input_str.lower() # Remove non-alphanumeric characters filtered_str = \'\'.join(char for char in input_str if char.isalnum()) # Check if the filtered string is a palindrome return filtered_str == filtered_str[::-1]"},{"question":"# Word Frequency Analyzer You are tasked with developing a text analysis tool that identifies the frequency of each unique word in a given document. The tool should disregard common stop words and be case-insensitive. The output should be a sorted list of words by their frequency in descending order. # Your Task: Write a function `word_frequency_analyzer(text, stop_words)` that: 1. Splits the input text into words. 2. Removes stop words and converts the remaining words to lowercase. 3. Calculates the frequency of each unique word. 4. Returns a list of tuples, each containing a word and its frequency, sorted by frequency in descending order. ```python def word_frequency_analyzer(text: str, stop_words: list[str]) -> list[tuple[str, int]]: # Your implementation here pass ``` # Input: - `text`: A string containing the input document text. - `stop_words`: A list of common stop words to be excluded from the analysis. # Output: - A list of tuples where each tuple contains: - A string representing a word. - An integer representing the frequency of the word, sorted by frequency in descending order. # Constraints: - 1 <= length of text <= 10000 characters - 1 <= length of stop_words <= 100 - The text contains only alphabets and spaces. # Example: ```python text = \\"The quick brown fox jumps over the lazy dog. The dog was not amused.\\" stop_words = [\\"the\\", \\"over\\", \\"was\\", \\"not\\"] result = word_frequency_analyzer(text, stop_words) print(result) ``` Output: ``` [(\'dog\', 2), (\'quick\', 1), (\'brown\', 1), (\'fox\', 1), (\'jumps\', 1), (\'lazy\', 1), (\'amused\', 1)] ``` # Notes: - Make sure to handle punctuation and whitespace correctly. - Optimize the function to handle large texts efficiently. - Consider edge cases such as all words being stop words or repeated words.","solution":"def word_frequency_analyzer(text: str, stop_words: list[str]) -> list[tuple[str, int]]: from collections import Counter import re # Convert text to lowercase and split by non-alphabetic characters words = re.findall(r\'b[a-z]+b\', text.lower()) # Remove stop words words_filtered = [word for word in words if word not in stop_words] # Count frequencies word_count = Counter(words_filtered) # Sort by frequency in descending order sorted_word_count = sorted(word_count.items(), key=lambda item: item[1], reverse=True) return sorted_word_count"},{"question":"# String Manipulation and Character Frequency You are required to implement a function that takes a string as input and returns a new string where each character is followed by the number of times it appears in the original string. The function should also validate the input to ensure it is a string. Requirements: 1. **Input**: A string `text` consisting of English alphabets (both uppercase and lowercase). 2. **Output**: A new string where each character is followed by its frequency count from the original string. **Function Signature:** ```python def char_frequency(text: str) -> str: ``` Constraints: 1. The input string may contain both uppercase and lowercase English letters. 2. The function should raise a `TypeError` with the message `\\"Input must be a string\\"` if the input is not a string. 3. The function is case-sensitive, meaning \'a\' and \'A\' are considered different characters. # Example Usage: - Example 1: ```python >>> char_frequency(\\"apple\\") \'a1p2l1e1\' ``` - Example 2: ```python >>> char_frequency(\\"banana\\") \'b1a3n2\' ``` # Additional Examples: - Input: `char_frequency(\\"Hello\\")` - Output: `\'H1e1l2o1\'` - Input: `char_frequency(\\"Coding\\")` - Output: `\'C1o1d1i1n1g1\'` Note: - Ensure to handle edge cases where inputs may be empty strings or strings with varying cases. - Optimize for clear and efficient string manipulation to achieve the expected functionality.","solution":"def char_frequency(text: str) -> str: Returns a string where each character is followed by the number of times it appears in the original string. if not isinstance(text, str): raise TypeError(\\"Input must be a string\\") from collections import Counter frequency = Counter(text) result = \\"\\" seen = set() for ch in text: if ch not in seen: result += f\\"{ch}{frequency[ch]}\\" seen.add(ch) return result"},{"question":"# Coding Assessment Question Scenario You are working on an analytics dashboard which requires a module to efficiently find the median of a dynamically updating list of numbers. This feature is critical for real-time data analysis and reporting. Task Implement a Python class to manage a list of numbers and calculate the median whenever a new number is added. Class Signature ```python class MedianFinder: def __init__(self): # Initializes the MedianFinder object pass def addNum(self, num: int) -> None: # Adds a integer number from the data stream to the data structure pass def findMedian(self) -> float: # Returns the median of all elements so far pass ``` Input - `addNum(num: int)`: an integer number to add to the data structure. - `findMedian()`: no parameters. Output - `findMedian()`: a float representing the median of all elements so far. Example ```python medianFinder = MedianFinder() medianFinder.addNum(1) medianFinder.addNum(2) assert medianFinder.findMedian() == 1.5 # median of [1, 2] medianFinder.addNum(3) assert medianFinder.findMedian() == 2.0 # median of [1, 2, 3] ``` Constraints - The number of elements added to the data structure will be at most 10^5. - The elements in the data stream will range from -10^5 to 10^5. - The data structure should ensure that the median can be found in efficient time complexity. Notes Ensure to handle edge cases of both small and large datasets. Describe the methodology and any assumptions in your implementation.","solution":"import heapq class MedianFinder: def __init__(self): Initialize two heaps: - max_heap for the lower half of the numbers - min_heap for the upper half of the numbers self.max_heap = [] # Max heap to store the lower half of numbers self.min_heap = [] # Min heap to store the upper half of numbers def addNum(self, num: int) -> None: Add a new number to the data structure. # Add to max_heap (inverted min heap) heapq.heappush(self.max_heap, -num) # Ensure the max element of the max_heap is smaller than the min element of min_heap if self.max_heap and self.min_heap and (-self.max_heap[0] > self.min_heap[0]): val = -heapq.heappop(self.max_heap) heapq.heappush(self.min_heap, val) # Balance the heaps if they have different lengths if len(self.max_heap) > len(self.min_heap) + 1: val = -heapq.heappop(self.max_heap) heapq.heappush(self.min_heap, val) if len(self.min_heap) > len(self.max_heap): val = heapq.heappop(self.min_heap) heapq.heappush(self.max_heap, -val) def findMedian(self) -> float: Find the median of all numbers. if len(self.max_heap) > len(self.min_heap): return float(-self.max_heap[0]) return (-self.max_heap[0] + self.min_heap[0]) / 2.0"},{"question":"# Sorting Organizer As an organizer of a sports tournament, you are responsible for sorting the players according to their scores at the end of each round. Write a function that takes a list of player scores and returns a list of player names sorted in descending order of their scores. In the case of a tie, the player whose name comes first alphabetically should appear first. Requirements: 1. The function should accept a list of tuples, where each tuple consists of the player\'s name (a string) and their score (an integer). 2. The function should return a list of player names, sorted first by their scores in descending order, and secondarily by name in ascending order (alphabetically) in case of ties. Input: * A list of tuples, where each tuple contains: * `player_name` (str): The name of the player. * `score` (int): The score of the player. Output: * A list of player names (str) sorted as described. Function Signature: ```python def sort_players_by_score(player_scores: list) -> list: pass ``` Example: ```python # Example usage: assert sort_players_by_score([(\\"Alice\\", 50), (\\"Bob\\", 75), (\\"Charlie\\", 75), (\\"Dave\\", 60)]) == [\\"Bob\\", \\"Charlie\\", \\"Dave\\", \\"Alice\\"] assert sort_players_by_score([(\\"Alice\\", 20), (\\"Bob\\", 20), (\\"Charlie\\", 30), (\\"Dave\\", 10)]) == [\\"Charlie\\", \\"Alice\\", \\"Bob\\", \\"Dave\\"] ``` Constraints: * `1 <= len(player_scores) <= 10^4` * `1 <= len(player_name) <= 100` * The player\'s name consists of only lowercase or uppercase English letters. * `0 <= score <= 10^6` Implement the function `sort_players_by_score` according to the given specifications.","solution":"def sort_players_by_score(player_scores): Sort players by their scores in descending order. In case of a tie, sort alphabetically by the player\'s name in ascending order. # Sort first by score in descending order (hence -score) # Then by name alphabetically in case of tie sorted_players = sorted(player_scores, key=lambda x: (-x[1], x[0])) # Extract and return only the player names return [player[0] for player in sorted_players]"},{"question":"# Sum of Nested List Weights Problem Statement Given a nested list of integers, where each element is either an integer or a list of integers/nested lists, you need to implement a function `depth_sum` to calculate the sum of the integers weighted by their depth. The depth of an integer is the number of lists that contain it. Function Signature ```python def depth_sum(nested_list): pass ``` Input - `nested_list`: A list of integers or nested lists of integers. The depth of the nested lists is between 1 and 1000, and the total number of integers in all nested lists does not exceed 1000. Output - Returns an integer, which is the sum of all integers in the list weighted by their depth. Constraints - Each integer can be positive or negative. - The nested list can contain empty lists. Example ```python assert depth_sum([1, [4, [6]]]) == 27 # 1*1 + 4*2 + 6*3 assert depth_sum([1, [2, [3, [4]]]]) == 1*1 + 2*2 + 3*3 + 4*4 assert depth_sum([1, [-4, [6]]]) == 1*1 + (-4)*2 + 6*3 assert depth_sum([[1, 1], 2, [1, 1]]) == 1*2 + 1*2 + 2*1 + 1*2 + 1*2 assert depth_sum([[[[[1]]]]]) == 1*5 assert depth_sum([]) == 0 ``` Detailed Explanation 1. Use a helper function to recursively traverse the nested list, maintaining the current depth. 2. When encountering an integer, multiply it by its depth and add it to a running sum. 3. For lists, recursively process each element, incrementing the depth with each level of nesting. 4. Return the total sum of all integers weighted by their respective depths. Implement the `depth_sum` function based on the described logic.","solution":"def depth_sum(nested_list, depth=1): Calculate the sum of integers in a nested list weighted by their depth. total_sum = 0 for element in nested_list: if isinstance(element, list): total_sum += depth_sum(element, depth + 1) else: total_sum += element * depth return total_sum"},{"question":"# Temperature Conversion with Ranges In this assessment, you will implement a function to convert a given temperature from Fahrenheit to Celsius and categorize it into specific temperature ranges. The function should perform the conversion using the following formula: [ C = frac{5}{9} times (F - 32) ] where: - ( C ) is the Celsius temperature. - ( F ) is the Fahrenheit temperature. # Temperature Ranges: Based on the Celsius temperature calculated, categorize the temperature into one of the following ranges: - \\"Very Cold\\" if ( C < 0 ) - \\"Cold\\" if ( 0 leq C < 10 ) - \\"Warm\\" if ( 10 leq C < 25 ) - \\"Hot\\" if ( 25 leq C < 35 ) - \\"Very Hot\\" if ( C geq 35 ) # Requirements: 1. Implement the function `convert_and_categorize_temperature()` with the following signature: ```python def convert_and_categorize_temperature(fahrenheit: float) -> tuple: ``` 2. The function should return a tuple containing two elements: - The converted Celsius temperature rounded to two decimal places. - The corresponding temperature range as a string. 3. Ensure the function raises a `ValueError` with the message \\"Invalid Temperature\\" if the input temperature in Fahrenheit is less than -459.67 (absolute zero in Fahrenheit). # Function Signature ```python def convert_and_categorize_temperature(fahrenheit: float) -> tuple: ``` # Examples ```python # Example 1 print(convert_and_categorize_temperature(32)) # Output: (0.0, \\"Cold\\") # Example 2 print(convert_and_categorize_temperature(67)) # Output: (19.44, \\"Warm\\") # Example 3: Below absolute zero should raise an exception try: print(convert_and_categorize_temperature(-500)) except ValueError as e: print(e) # Output: Invalid Temperature ``` Implement the function and ensure it handles the constraints, edge cases, and performs the required calculations accurately.","solution":"def convert_and_categorize_temperature(fahrenheit: float) -> tuple: Converts a Fahrenheit temperature to Celsius and categorizes it into a specific range. Args: - fahrenheit (float): Temperature in Fahrenheit. Returns: - A tuple where the first element is the Celsius temperature rounded to two decimal places, and the second element is a string representing the temperature range. Raises: - ValueError: If the input temperature in Fahrenheit is less than -459.67. if fahrenheit < -459.67: raise ValueError(\\"Invalid Temperature\\") celsius = (5 / 9) * (fahrenheit - 32) celsius_rounded = round(celsius, 2) if celsius_rounded < 0: category = \\"Very Cold\\" elif 0 <= celsius_rounded < 10: category = \\"Cold\\" elif 10 <= celsius_rounded < 25: category = \\"Warm\\" elif 25 <= celsius_rounded < 35: category = \\"Hot\\" else: category = \\"Very Hot\\" return (celsius_rounded, category)"},{"question":"# String Compression Task **Objective**: Implement a string compression algorithm that reduces the size of the string by using counts of repeated characters. **Context**: You are developing a feature for an application that processes large amounts of text data. To optimize storage and transmission, you want to compress the strings using a basic form of run-length encoding. Requirements You need to write a function `string_compression(s: str) -> str` that compresses the input string by replacing sequences of the same character with that character followed by the count of occurrences. If the compressed string is not shorter than the original string, the function should return the original string. 1. **Read the string** and identify consecutive repeated characters. 2. **Compress the string** by replacing sequences of repeated characters with the character and the count. 3. **Return the original string** if the compressed version is not shorter. Specifications * **Input**: A string `s` to be compressed. * **Output**: The function should return the compressed version of the string if it is shorter than the original, otherwise return the original string. Constraints * The string can contain both uppercase and lowercase letters (a-z, A-Z) and is case-sensitive. * The length of the string can be up to 10^5 characters. * The string can be empty. Performance Requirements * The solution should handle large inputs efficiently, with a linear time complexity of O(n), where n is the length of the string. Example ```python def string_compression(s: str) -> str: if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed.append(s[i-1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_str = \'\'.join(compressed) return compressed_str if len(compressed_str) < len(s) else s print(string_compression(\\"aabcccccaaa\\")) # Output: \\"a2b1c5a3\\" print(string_compression(\\"abcd\\")) # Output: \\"abcd\\" print(string_compression(\\"\\")) # Output: \\"\\" ``` **Note**: Ensure you properly test your implementation using a variety of string inputs to verify the correctness and compression efficiency.","solution":"def string_compression(s: str) -> str: if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed.append(s[i-1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_str = \'\'.join(compressed) return compressed_str if len(compressed_str) < len(s) else s"},{"question":"# Problem: Implement a Graph-Based Shortest Path Finder with Constraints **Context**: You are provided with a base class `Graph` that models a graph using adjacency lists. Your task is to extend and implement an algorithm that finds the shortest path between two nodes, considering additional constraints such as maximum path length or prohibitive nodes. **Problem Statement**: Extend the `Graph` class to include a function `find_shortest_path_with_constraints` which computes the shortest path from a starting node to a target node under specified constraints. # Requirements * **Class Extension**: Extend the `Graph` class to `ConstrainedGraph`. * Add methods to set and handle constraints such as maximum path length and list of prohibitive nodes. * **Function Implementation**: * `find_shortest_path_with_constraints(start: str, end: str, max_length: int, prohibitive_nodes: list[str]) -> list[str]` * Inputs: - `start`: The starting node. - `end`: The target node. - `max_length`: The maximum allowable length (number of edges) for the path. - `prohibitive_nodes`: A list of nodes that cannot be part of the path. * Output: - A list of nodes representing the shortest path from the start node to the end node that meets the constraints. If such a path does not exist, return an empty list. # Example ```python adjacency_list = { \'a\': [(\'b\', 1), (\'c\', 2)], \'b\': [(\'a\', 1), (\'d\', 3)], \'c\': [(\'a\', 2), (\'d\', 1)], \'d\': [(\'b\', 3), (\'c\', 1)] } # Initialize ConstrainedGraph with the adjacency list graph = ConstrainedGraph(adjacency_list) # Set constraints max_length = 3 prohibitive_nodes = [\'c\'] # Find the shortest path with constraints result = graph.find_shortest_path_with_constraints(\'a\', \'d\', max_length, prohibitive_nodes) # result is expected to return: # [\'a\', \'b\', \'d\'] or [] if no valid path exists ``` # Constraints * Ensure that the maximum path length constraint is strictly adhered to. * Handle cases where the start or end node is in the list of prohibitive nodes gracefully. * The prohibitive nodes list may contain nodes that do not exist in the graph, ensure these are ignored. * Assume all edge weights are positive integers and undirected. * Constraints should be managed without significantly increasing the computational complexity. **Note**: Consider using a graph traversal algorithm such as Breadth-First Search (BFS) modified to check for constraints like path length and node prohibition.","solution":"import heapq class Graph: def __init__(self, adjacency_list): self.adjacency_list = adjacency_list class ConstrainedGraph(Graph): def __init__(self, adjacency_list): super().__init__(adjacency_list) def find_shortest_path_with_constraints(self, start, end, max_length, prohibitive_nodes): prohibitive_nodes = set(prohibitive_nodes) if start in prohibitive_nodes or end in prohibitive_nodes: return [] queue = [(0, start, [])] visited = set() while queue: (cost, current, path) = heapq.heappop(queue) if current in visited: continue path = path + [current] if current == end: if len(path) - 1 <= max_length: return path visited.add(current) for neighbor, weight in self.adjacency_list.get(current, []): if neighbor not in visited and neighbor not in prohibitive_nodes: heapq.heappush(queue, (cost + weight, neighbor, path)) return []"},{"question":"# Factorial Series Sum **Objective**: Implement a function that computes the sum of factorials for a given positive integer. **Problem Statement**: You are given a positive integer `n`. Your task is to write a function `factorial_series_sum(n: int) -> int` that: 1. Calculates the factorial of each integer from `1` to `n`. 2. Computes the sum of these factorials. **Factorial Definition**: - The factorial of a non-negative integer `n` is the product of all positive integers less than or equal to `n` (denoted as `n!`). - `0!` is defined as `1`. **Function Signature**: ```python def factorial_series_sum(n: int) -> int: pass ``` # Input: - An integer `n` (1 <= n <= 20) # Output: - An integer representing the sum of factorials from `1` to `n`. # Examples: ```python >>> factorial_series_sum(3) 9 # Explanation: 1! + 2! + 3! = 1 + 2 + 6 = 9 >>> factorial_series_sum(5) 153 # Explanation: 1! + 2! + 3! + 4! + 5! = 1 + 2 + 6 + 24 + 120 = 153 >>> factorial_series_sum(1) 1 # Explanation: 1! = 1 >>> factorial_series_sum(0) 1 # Explanation: 0! = 1 ``` **Constraints**: - Ensure the solution handles the upper limit efficiently. - Avoid using built-in functions for factorial to demonstrate the implementation clearly.","solution":"def factorial_series_sum(n: int) -> int: Computes the sum of factorials from 1! to n! Parameters: n (int): A positive integer (1 <= n <= 20) Returns: int: The sum of the factorials from 1! to n! if n < 0: raise ValueError(\\"n must be a positive integer\\") def factorial(x): if x == 0 or x == 1: return 1 result = 1 for i in range(2, x + 1): result *= i return result sum_factorials = 0 for i in range(1, n + 1): sum_factorials += factorial(i) return sum_factorials"},{"question":"# Programming Assessment Question Context Working with strings is a fundamental skill in programming. Understanding how to manipulate and analyze strings is crucial. In this task, you will build a function that helps detect palindromes under certain constraints. Task **Objective:** Write a function that checks if two given substrings of a string are palindromes and if they are the same length. # Requirements * **Function Signature**: ```python def check_substrings_are_palindromes(s: str, substr1_start: int, substr1_end: int, substr2_start: int, substr2_end: int) -> bool: ``` * **Inputs**: - `s`: A string in which the substrings are located. - `substr1_start`: The starting index (inclusive) of the first substring. - `substr1_end`: The ending index (inclusive) of the first substring. - `substr2_start`: The starting index (inclusive) of the second substring. - `substr2_end`: The ending index (inclusive) of the second substring. * **Output**: - Returns `True` if both substrings are palindromes and are the same length, otherwise returns `False`. # Constraints * The input string, `s`, will have a length `n` such that `1 <= n <= 10^4`. * The indices `substr1_start`, `substr1_end`, `substr2_start`, and `substr2_end` will be within valid bounds of the string. # Example Scenarios 1. **Example 1**: ```python check_substrings_are_palindromes(\\"madamracecar\\", 0, 4, 6, 11) # Returns: True ``` (Explanation: \\"madam\\" and \\"racecar\\" are both palindromes and have lengths 5 and 6 respectively, thus not matching in length.) 2. **Example 2**: ```python check_substrings_are_palindromes(\\"aabbaa\\", 0, 2, 3, 5) # Returns: True ``` (Explanation: \\"aab\\" and \\"baa\\" are not palindromes, but they are of the same length, so the function returns True.) 3. **Example 3**: ```python check_substrings_are_palindromes(\\"abcdedcba\\", 1, 3, 5, 7) # Returns: False ``` (Explanation: \\"bcd\\" and \\"dcb\\" are palindromes but are not the same length). # Additional Requirements * Your implementation should handle edge cases where the substrings are outside the bounds of the string or when the substrings are of length 1. * It should also efficiently check for palindromes without unnecessary operations.","solution":"def is_palindrome(substring: str) -> bool: Checks if the given substring is a palindrome. return substring == substring[::-1] def check_substrings_are_palindromes(s: str, substr1_start: int, substr1_end: int, substr2_start: int, substr2_end: int) -> bool: Checks if the substrings of s from substr1_start to substr1_end and from substr2_start to substr2_end are palindromes and if they are the same length. substr1 = s[substr1_start:substr1_end+1] substr2 = s[substr2_start:substr2_end+1] return len(substr1) == len(substr2) and is_palindrome(substr1) and is_palindrome(substr2)"},{"question":"# Question: String Subsequence Checker In this problem, you are tasked with implementing a function that checks if the characters of a given string `s1` form a subsequence of another string `s2`. A subsequence is derived from another string by deleting some or none of the characters without changing the order of the remaining characters. # Tasks: 1. Write a function `is_subsequence(s1: str, s2: str) -> bool` that checks whether `s1` is a subsequence of `s2`. 2. The function should return `True` if `s1` is a subsequence of `s2`, and `False` otherwise. # Input: - Two strings `s1` and `s2` of lengths between 1 and 1000. # Output: - A boolean value indicating whether `s1` is a subsequence of `s2`. # Constraints: - The function should handle both upper and lower case characters. - The solution should operate in O(n) time complexity, where n is the length of `s2`. # Examples: ```python >>> is_subsequence(\\"abc\\", \\"ahbgdc\\") True >>> is_subsequence(\\"axc\\", \\"ahbgdc\\") False >>> is_subsequence(\\"hello\\", \\"hellllo\\") True >>> is_subsequence(\\"hello\\", \\"heoll\\") False ``` # Notes: - Traverse `s2` and check for the presence and order of characters of `s1`. - Utilize a two-pointer technique to achieve linear time complexity for efficient processing. This question requires understanding of string operations and efficient iteration mechanisms, much like the provided case conversion function enhancement task.","solution":"def is_subsequence(s1, s2): Returns True if s1 is a subsequence of s2, otherwise False. it = iter(s2) return all(char in it for char in s1)"},{"question":"# Coding Assessment Question **Context**: In computer graphics and digital image processing, certain operations involve transforming points within a coordinate system. A common transformation is rotating a point around the origin, and you need to implement such functionality. **Problem Statement**: Implement a function that rotates a given point (x, y) by a specified angle around the origin (0, 0). The angle will be provided in degrees, and the function should return the new coordinates of the point after rotation. # Function Signature: ```python def rotate_point(x: float, y: float, angle: float) -> tuple[float, float]: pass ``` # Input: 1. **x (float)**: The x-coordinate of the point. 2. **y (float)**: The y-coordinate of the point. 3. **angle (float)**: The angle in degrees by which the point should be rotated. # Output: Returns a tuple (new_x, new_y) representing the coordinates of the point after being rotated by the given angle around the origin. # Constraints: 1. ( -10^9 leq x, y leq 10^9 ) 2. ( -360.0 leq angle leq 360.0 ) 3. Use the standard trigonometric functions from Python\'s math library to implement the rotation. # Example: ```python assert rotate_point(1.0, 0.0, 90.0) == (0.0, 1.0) assert rotate_point(0.0, 1.0, -45.0) == (0.7071, 0.7071) assert rotate_point(2.0, 2.0, 180.0) == (-2.0, -2.0) ``` # Explanation: 1. In the first example, rotating point (1.0, 0.0) by 90 degrees results in (0.0, 1.0). 2. In the second example, rotating point (0.0, 1.0) by -45 degrees results in (0.7071, 0.7071). 3. In the third example, rotating point (2.0, 2.0) by 180 degrees results in (-2.0, -2.0). # Notes: - Ensure to handle floating-point arithmetic with precision by rounding the results to 4 decimal places. - Use radians in trigonometric functions: To convert degrees to radians, multiply by `π/180`.","solution":"import math def rotate_point(x: float, y: float, angle: float) -> tuple[float, float]: Rotates point (x, y) by the specified angle around the origin (0, 0). The angle is provided in degrees. Returns the new coordinates (new_x, new_y). # Convert angle from degrees to radians radians = angle * (math.pi / 180) # Calculate the new coordinates new_x = x * math.cos(radians) - y * math.sin(radians) new_y = x * math.sin(radians) + y * math.cos(radians) # Round the results to 4 decimal places new_x = round(new_x, 4) new_y = round(new_y, 4) return (new_x, new_y)"},{"question":"# String Compression You are tasked with implementing a string compression algorithm that reads a string and outputs its compressed version. The compressed string will replace sequences of repeated characters with a single character followed by the count of repeated characters. If the compressed string is not smaller than the original string, return the original string. Problem Statement: Implement a **compress_string** function that accepts a string and returns its compressed version or the original string if the compressed version is not shorter. Function Signature: ```python def compress_string(s: str) -> str: pass ``` Input: * `s`: A string consisting of lowercase Latin letters. Output: * Returns the compressed string if it is shorter, otherwise returns the original string. Constraints: * The length of the string `n` is such that (0 le n le 10^5). Guidelines: 1. If the input string is empty, return an empty string. 2. For compression, consecutive repeated characters should be replaced with the character followed by its count. 3. If the compressed version of the string is equal to or longer than the original string, return the original string. Example: ```python >>> compress_string(\'aabcccccaaa\') \'a2b1c5a3\' >>> compress_string(\'abc\') \'abc\' >>> compress_string(\'\') \'\' >>> compress_string(\'aaaaa\') \'a5\' ``` Explanation: - In the first example, \'aabcccccaaa\' is compressed to \'a2b1c5a3\', which is shorter. - In the second example, \'abc\' remains \'abc\' as its compressed form \'a1b1c1\' is not shorter. - In the third example, the empty string remains empty. - In the fourth example, \'aaaaa\' is compressed to \'a5\'.","solution":"def compress_string(s: str) -> str: if not s: return s compressed = [] count = 1 length = len(s) for i in range(1, length): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_string = \'\'.join(compressed) if len(compressed_string) < length: return compressed_string else: return s"},{"question":"# Implement a Custom K-means Algorithm You are to implement a custom K-means clustering algorithm from scratch without using any libraries that provide this functionality directly (e.g., scikit-learn). The K-means clustering algorithm partitions a set of `n` points into `K` clusters in which each point belongs to the cluster with the nearest mean (centroid). Your task is to implement the functions: `initialize_centroids`, `assign_clusters`, `update_centroids`, and `fit_predict`. Requirements: 1. The `initialize_centroids` function should select K initial centroids from the dataset. 2. The `assign_clusters` function should assign each data point to the nearest centroid. 3. The `update_centroids` function should compute the new centroids as the mean of all points assigned to each cluster. 4. The `fit_predict` function should iterate between `assign_clusters` and `update_centroids` until convergence (or a maximum of `n_iter` iterations). # Input and Output Formats: 1. **Input**: - `features` (numpy.ndarray): A 2D array of shape (num_samples, num_features) representing the input features. - `K` (int): The number of clusters. - `n_iter` (int): The maximum number of iterations. 2. **Output**: - `centroids` (numpy.ndarray): A 2D array of shape (K, num_features) representing the final centroids. - `labels` (numpy.ndarray): A 1D array of shape (num_samples,) representing the cluster assignment of each input sample. # Constraints: - ( text{num_samples} leq 10^4 ) - ( text{num_features} leq 100 ) - ( text{K} leq 100 ) - ( text{n_iter} leq 300 ) # Testing and Performance: - Implement a test case using a synthetic dataset (e.g., using `make_blobs` from sklearn). - Your implementation should converge to a stable clustering. ```python import numpy as np from sklearn.datasets import make_blobs import matplotlib.pyplot as plt class KMeans: def __init__(self, K: int, n_iter: int = 100) -> None: Initialize the KMeans clustering class. Parameters: - K (int): The number of clusters. - n_iter (int): The maximum number of iterations. self.K = K self.n_iter = n_iter def initialize_centroids(self, features: np.ndarray) -> np.ndarray: Randomly initialize K centroids from the dataset. Parameters: - features (np.ndarray): The dataset. Returns: - np.ndarray: Initial centroids. np.random.seed(42) indices = np.random.choice(features.shape[0], self.K, replace=False) return features[indices] def assign_clusters(self, features: np.ndarray, centroids: np.ndarray) -> np.ndarray: Assign each data point to the nearest centroid. Parameters: - features (np.ndarray): The dataset. - centroids (np.ndarray): Current centroids. Returns: - np.ndarray: Cluster assignments. distances = np.linalg.norm(features[:, np.newaxis] - centroids, axis=2) return np.argmin(distances, axis=1) def update_centroids(self, features: np.ndarray, labels: np.ndarray) -> np.ndarray: Update centroids to the mean of assigned points. Parameters: - features (np.ndarray): The dataset. - labels (np.ndarray): Cluster assignments. Returns: - np.ndarray: Updated centroids. new_centroids = np.array([features[labels == k].mean(axis=0) for k in range(self.K)]) return new_centroids def fit_predict(self, features: np.ndarray) -> tuple: Fit the KMeans model to the dataset and return the cluster assignments. Parameters: - features (np.ndarray): The dataset. Returns: - tuple: Final centroids and cluster assignments. centroids = self.initialize_centroids(features) for _ in range(self.n_iter): labels = self.assign_clusters(features, centroids) new_centroids = self.update_centroids(features, labels) if np.all(centroids == new_centroids): break centroids = new_centroids return centroids, labels if __name__ == \\"__main__\\": # Create synthetic dataset X, _ = make_blobs(n_samples=300, centers=4, n_features=2, random_state=42) # Apply KMeans K = 4 kmeans = KMeans(K) centroids, labels = kmeans.fit_predict(X) # Plot the clustering result plt.scatter(X[:, 0], X[:, 1], c=labels, cmap=\'viridis\', marker=\'o\') plt.scatter(centroids[:, 0], centroids[:, 1], s=300, c=\'red\', marker=\'x\') plt.title(\'KMeans Clustering\') plt.show() ``` In this question, you implement the K-means algorithm from scratch, maintaining an iterative approach to update centroids and assign clusters. The example provided uses synthetic data to visualize the clustering output, ensuring alignment with existing question styles and complexities.","solution":"import numpy as np class KMeans: def __init__(self, K: int, n_iter: int = 100) -> None: Initialize the KMeans clustering class. Parameters: - K (int): The number of clusters. - n_iter (int): The maximum number of iterations. self.K = K self.n_iter = n_iter def initialize_centroids(self, features: np.ndarray) -> np.ndarray: Randomly initialize K centroids from the dataset. Parameters: - features (np.ndarray): The dataset. Returns: - np.ndarray: Initial centroids. np.random.seed(42) indices = np.random.choice(features.shape[0], self.K, replace=False) return features[indices] def assign_clusters(self, features: np.ndarray, centroids: np.ndarray) -> np.ndarray: Assign each data point to the nearest centroid. Parameters: - features (np.ndarray): The dataset. - centroids (np.ndarray): Current centroids. Returns: - np.ndarray: Cluster assignments. distances = np.linalg.norm(features[:, np.newaxis] - centroids, axis=2) return np.argmin(distances, axis=1) def update_centroids(self, features: np.ndarray, labels: np.ndarray) -> np.ndarray: Update centroids to the mean of assigned points. Parameters: - features (np.ndarray): The dataset. - labels (np.ndarray): Cluster assignments. Returns: - np.ndarray: Updated centroids. new_centroids = np.array([features[labels == k].mean(axis=0) for k in range(self.K)]) return new_centroids def fit_predict(self, features: np.ndarray) -> tuple: Fit the KMeans model to the dataset and return the cluster assignments. Parameters: - features (np.ndarray): The dataset. Returns: - tuple: Final centroids and cluster assignments. centroids = self.initialize_centroids(features) for _ in range(self.n_iter): labels = self.assign_clusters(features, centroids) new_centroids = self.update_centroids(features, labels) if np.all(centroids == new_centroids): break centroids = new_centroids return centroids, labels"},{"question":"# Coding Assessment Question Context You are responsible for organizing a series of tasks for a project. Each task may depend on the completion of other tasks before it can begin. This collection of tasks and their dependencies can be represented as a directed acyclic graph (DAG). Problem Statement Implement an algorithm to perform topological sorting on a directed acyclic graph (DAG). Your implementation should return an ordering of the tasks such that for every directed edge `u -> v`, task `u` comes before task `v` in the ordering. Input - **num_tasks** (Integer): Number of tasks (nodes) in the graph. - **dependencies** (List of List of Integers): Each element is a list of two integers `[u, v]` where task `u` must be completed before task `v`. Output - A list of task indices representing the topologically sorted order of the tasks. If there are multiple valid orderings, return any one of them. Constraints - `1 <= num_tasks <= 1000` - `0 <= len(dependencies) <= num_tasks * (num_tasks - 1) / 2` - All task indices are unique integers ranging from `0` to `num_tasks - 1`. Function Signature ```python def topological_sort(num_tasks: int, dependencies: List[List[int]]) -> List[int]: pass ``` Example ```python input: num_tasks = 5 dependencies = [ [0, 1], [0, 2], [1, 3], [2, 3], [3, 4] ] output: [0, 1, 2, 3, 4] # or any valid topological ordering, e.g., [0, 2, 1, 3, 4] ``` Notes * Ensure your function handles the scenario where if there\'s a cycle in the graph (though the definition of the input guarantees the graph is acyclic). * Consider using Kahn\'s algorithm or Depth-First Search (DFS) to achieve the topological sort efficiently.","solution":"from typing import List from collections import deque, defaultdict def topological_sort(num_tasks: int, dependencies: List[List[int]]) -> List[int]: # Create adjacency list and compute in-degrees adj_list = defaultdict(list) in_degree = [0] * num_tasks for u, v in dependencies: adj_list[u].append(v) in_degree[v] += 1 # Initialize queue with nodes of in-degree 0 zero_in_degree_queue = deque([i for i in range(num_tasks) if in_degree[i] == 0]) topological_order = [] while zero_in_degree_queue: node = zero_in_degree_queue.popleft() topological_order.append(node) # Decrease the in-degree of the node\'s neighbors for neighbor in adj_list[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) if len(topological_order) == num_tasks: return topological_order else: return [] # Return an empty list if the graph has a cycle (which shouldn\'t happen per problem constraints)"},{"question":"# Problem Statement You are required to implement a function that checks whether a given string follows a specific pattern. The function will take two input parameters: 1. **pattern**: A string representing the desired pattern to match. 2. **str**: A string of words separated by spaces. Each character in the `pattern` corresponds to a word in the `str`. The function should return `True` if both the pattern and the string of words follow the same pattern, and `False` otherwise. # Input Format - `pattern`: A non-empty string of lowercase letters with a length no greater than 100. - `str`: A string of words separated by spaces, with the total length of the string no greater than 1000. # Output Format - Return `True` if the string of words matches the pattern, otherwise, return `False`. # Constraints - Each character in the `pattern` represents a single word in the `str`. - The words in `str` are delimited by a single space. # Function Signature ```python def word_pattern(pattern: str, str: str) -> bool: pass ``` # Example Input ```python pattern = \\"abba\\" str = \\"dog cat cat dog\\" ``` Output ```python True ``` Input ```python pattern = \\"abba\\" str = \\"dog cat cat fish\\" ``` Output ```python False ``` Input ```python pattern = \\"aaaa\\" str = \\"dog dog dog dog\\" ``` Output ```python True ``` Input ```python pattern = \\"abba\\" str = \\"dog dog dog dog\\" ``` Output ```python False ``` # Notes - Ensure your solution handles cases where the number of words in `str` doesn\'t match the length of `pattern`. - Consider edge cases such as an empty pattern or a single-character pattern. - Aim for an efficient solution with a time complexity within acceptable bounds given the constraints.","solution":"def word_pattern(pattern: str, str: str) -> bool: words = str.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False if word in word_to_char: if word_to_char[word] != char: return False char_to_word[char] = word word_to_char[word] = char return True"},{"question":"# Question: Employee Data Processing from Multiple Sources You are tasked with creating a Python function to merge and process employee data from two different data sources: a JSON file and a CSV file. Your function should clean the data, merge it into a single structure, and perform some basic calculations. Function Signature ```python def process_employee_data(json_file_path: str, csv_file_path: str) -> dict: Processes and merges employee data from a JSON file and a CSV file, and performs basic calculations. :param json_file_path: A string representing the file path to the JSON file. :param csv_file_path: A string representing the file path to the CSV file. :return: A dictionary containing the processed employee data and summary statistics. :raises ValueError: If any file is not found or if the data is invalid. pass ``` # Requirements 1. **Input**: - `json_file_path`: Path to the JSON file containing employee data. - `csv_file_path`: Path to the CSV file containing employee data. 2. **Output**: A dictionary with the following structure: - `\\"merged_data\\"`: A list of dictionaries, where each dictionary represents a merged employee record. - `\\"average_salary\\"`: The average salary of all employees. 3. **Errors**: Raise a `ValueError` if any file is not found or if the data is invalid. # Constraints - Assume valid file formats and employee data but ensure proper error handling for file I/O. - The JSON file contains a list of employee records, each with fields `\\"employee_id\\"`, `\\"name\\"`, and `\\"department\\"`. - The CSV file contains records with columns `\\"employee_id\\"`, `\\"salary\\"`, and `\\"join_date\\"`. - Merge the data based on the `employee_id` field. - If an employee exists in one source but not the other, still include them in the merged data with missing fields as `None`. # Performance - The function should efficiently handle files up to 10,000 employee records each. # Example ```python # Example JSON and CSV file contents for testing (use your own paths and data). # JSON file (employees.json) [ {\\"employee_id\\": \\"101\\", \\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\"}, {\\"employee_id\\": \\"102\\", \\"name\\": \\"Bob\\", \\"department\\": \\"Sales\\"}, {\\"employee_id\\": \\"103\\", \\"name\\": \\"Charlie\\", \\"department\\": \\"HR\\"} ] # CSV file (employees.csv) employee_id,salary,join_date 101,75000,2020-01-15 102,50000,2019-03-10 104,62000,2021-06-01 # Define the function implementation here. json_file_path = \\"employees.json\\" csv_file_path = \\"employees.csv\\" try: result = process_employee_data(json_file_path, csv_file_path) print(result) except ValueError as e: print(repr(e)) ```","solution":"import json import csv def process_employee_data(json_file_path: str, csv_file_path: str) -> dict: Processes and merges employee data from a JSON file and a CSV file, and performs basic calculations. :param json_file_path: A string representing the file path to the JSON file. :param csv_file_path: A string representing the file path to the CSV file. :return: A dictionary containing the processed employee data and summary statistics. :raises ValueError: If any file is not found or if the data is invalid. try: with open(json_file_path, \'r\') as json_file: json_data = json.load(json_file) with open(csv_file_path, \'r\') as csv_file: csv_reader = csv.DictReader(csv_file) csv_data = [row for row in csv_reader] except FileNotFoundError as e: raise ValueError(f\\"File not found: {e.filename}\\") except json.JSONDecodeError: raise ValueError(\\"Invalid JSON data\\") # Create a dictionary to merge the data by employee_id employee_dict = {} for record in json_data: emp_id = record[\'employee_id\'] employee_dict[emp_id] = { \'employee_id\': emp_id, \'name\': record[\'name\'], \'department\': record.get(\'department\', None), \'salary\': None, \'join_date\': None } for record in csv_data: emp_id = record[\'employee_id\'] if emp_id not in employee_dict: employee_dict[emp_id] = { \'employee_id\': emp_id, \'name\': None, \'department\': None, \'salary\': record[\'salary\'], \'join_date\': record[\'join_date\'] } else: employee_dict[emp_id][\'salary\'] = record[\'salary\'] employee_dict[emp_id][\'join_date\'] = record[\'join_date\'] merged_data = list(employee_dict.values()) # Calculate the average salary total_salary = 0 salary_count = 0 for employee in merged_data: if employee[\'salary\'] is not None: total_salary += int(employee[\'salary\']) salary_count += 1 average_salary = total_salary / salary_count if salary_count > 0 else 0 return { \'merged_data\': merged_data, \'average_salary\': average_salary }"},{"question":"# Coding Assessment Question Scenario You are working on a team that develops a social media platform. As part of the platform, users can tag other users in their posts using the \\"@\\" symbol followed by the username. Your task is to write a function that extracts all mentioned usernames from a given text. Task Write a function `extract_usernames` that takes a string as input and returns a list of usernames mentioned in the text. A valid username is defined by a contiguous sequence of alphanumeric characters and underscores (\'_\') immediately following the \\"@\\" symbol. Usernames are case-sensitive. Input * A single string `text` (1 ≤ |text| ≤ 10^6) where |text| represents the length of the string. Output * A list of strings where each string is a username mentioned in the input text. Constraints * The function must handle strings up to 1,000,000 characters efficiently. * Consider usernames that may appear at the beginning, middle, or end of the text. * Usernames can be separated by spaces, punctuation, or any other non-alphanumeric character. Example ```python assert extract_usernames(\\"Hello @user1!\\") == [\\"user1\\"] assert extract_usernames(\\"@user2 and @user3 are friends.\\") == [\\"user2\\", \\"user3\\"] assert extract_usernames(\\"No mentions here!\\") == [] assert extract_usernames(\\"@user_4_test mixed with @user5!\\") == [\\"user_4_test\\", \\"user5\\"] assert extract_usernames(\\"@user_6 @user_7 @8user_8\\") == [\\"user_6\\", \\"user_7\\", \\"8user_8\\"] ``` Notes * Ensure that your solution correctly handles edge cases such as usernames followed by punctuation or appearing at the end of the text. * Avoid using regular expressions for username extraction to make your solution more efficient.","solution":"def extract_usernames(text): Extracts usernames mentioned in the input text. Parameters: text (str): The input text containing potential mentions. Returns: list: A list of extracted usernames. usernames = [] n = len(text) i = 0 while i < n: if text[i] == \'@\': i += 1 # Skip the \'@\' symbol start = i while i < n and (text[i].isalnum() or text[i] == \'_\'): i += 1 if start != i: usernames.append(text[start:i]) else: i += 1 return usernames"},{"question":"# Question: Implementing a Custom Queue You are tasked with implementing a queue using a custom data structure. The queue should support standard queue operations like enqueue, dequeue, peek, and checking if the queue is empty. You are to use a linked list for internal storage of the queue elements. Function Specification ```python class Node: def __init__(self, value): self.value = value self.next = None class CustomQueue: def __init__(self): self.front = None self.rear = None def enqueue(self, value: int) -> None: Adds an element to the end of the queue. Parameters: value (int): The value to be added to the queue. def dequeue(self) -> int: Removes and returns the element from the front of the queue. Returns: int: The value of the front element. Raises: IndexError: If the queue is empty. def peek(self) -> int: Returns the element at the front of the queue without removing it. Returns: int: The value of the front element. Raises: IndexError: If the queue is empty. def is_empty(self) -> bool: Checks if the queue is empty. Returns: bool: True if the queue is empty, False otherwise. ``` Requirements 1. **Input Constraints**: * All values enqueued will be integers. 2. **Output**: * The methods will return the respective values as specified. 3. **Edge Cases**: * Attempting to dequeue or peek from an empty queue should raise an `IndexError` with an appropriate message. * The operations should handle the queue efficiently with linked list properties. Example Usage: ```python queue = CustomQueue() queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) assert queue.peek() == 1 assert queue.dequeue() == 1 assert queue.dequeue() == 2 assert queue.is_empty() == False assert queue.dequeue() == 3 assert queue.is_empty() == True try: queue.dequeue() # Should raise an IndexError except IndexError as e: print(e) ```","solution":"class Node: def __init__(self, value): self.value = value self.next = None class CustomQueue: def __init__(self): self.front = None self.rear = None def enqueue(self, value: int) -> None: new_node = Node(value) if self.rear is None: self.front = self.rear = new_node else: self.rear.next = new_node self.rear = new_node def dequeue(self) -> int: if self.front is None: raise IndexError(\\"dequeue from empty queue\\") value = self.front.value self.front = self.front.next if self.front is None: self.rear = None return value def peek(self) -> int: if self.front is None: raise IndexError(\\"peek from empty queue\\") return self.front.value def is_empty(self) -> bool: return self.front is None"},{"question":"Question # Problem: You are tasked with implementing a function that will reorder an unsorted integer array such that all odd numbers come before all even numbers, while preserving their relative order within their respective groups (odd and even). # Function Signature: ```python def reorder_array(arr: list) -> list: pass ``` # Input: - `arr`: A list of integers, where `1 <= len(arr) <= 1000`. # Output: - A list of integers sorted such that all odd numbers appear before even numbers. The relative order of odd and even numbers should remain the same as in the input. # Constraints: - The array will contain only integers. - The length of the array will be between 1 and 1000. # Example: ```python # Example 1: arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] result = reorder_array(arr) # Expected output: [1, 3, 5, 7, 9, 2, 4, 6, 8] # Example 2: arr = [4, 3, 2, 1] result = reorder_array(arr) # Expected output: [3, 1, 4, 2] # Example 3: arr = [2, 4, 6, 8] result = reorder_array(arr) # Expected output: [2, 4, 6, 8] # Example 4: arr = [1, 3, 5, 7] result = reorder_array(arr) # Expected output: [1, 3, 5, 7] ``` # Notes: - Pay attention to the relative ordering of the numbers within their respective groups. - Consider edge cases such as arrays with all odd or all even numbers, and arrays of minimal length.","solution":"def reorder_array(arr): Reorders the array such that all odd numbers come before all even numbers while preserving their relative order. odds = [x for x in arr if x % 2 != 0] evens = [x for x in arr if x % 2 == 0] return odds + evens"},{"question":"A company uses a reward point system to incentivize its employees. Each employee is given a list of points earned from various tasks. However, only certain continuous subsequences of these points can be considered for calculating the final score. You are tasked with implementing a function that finds the maximum sum of any continuous subsequence in the list of points. # Function Signature ```python def max_subsequence_sum(points: List[int]) -> int: Find the maximum sum of any continuous subsequence in the list `points`. :param points: A list of integers representing points earned by an employee from various tasks. :return: The maximum possible sum of any continuous subsequence. Constraints: - The length of the list `points` will be at least 1 and at most 10^5. - Each integer in `points` will be in the range of -10^4 to 10^4. Example: >>> max_subsequence_sum([1, -2, 3, 10, -4, 7, 2, -5]) 18 # (3 + 10 + -4 + 7 + 2) ``` # Constraints 1. The length of the `points` list will be at least 1 and no more than 100,000. 2. Each integer in `points` will be between -10,000 and 10,000 inclusive. # Input Guarantee: - The input list will contain at least one integer. - The input list will not exceed the specified length and number constraints. # Performance Requirements - Your implementation should handle the upper constraint efficiently. - Consider using an algorithmic approach that optimizes for linear time complexity. # Examples: ```python assert max_subsequence_sum([1, -2, 3, 10, -4, 7, 2, -5]) == 18 assert max_subsequence_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7 assert max_subsequence_sum([5, -1, -2, 3, 4, -10, 9, 1]) == 10 ``` Implement the function below and ensure your solution considers possible edge cases and is optimized for performance.","solution":"def max_subsequence_sum(points): max_current = max_global = points[0] for point in points[1:]: max_current = max(point, max_current + point) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Context You are building a small arithmetic expression evaluator that can handle basic operations: addition, subtraction, multiplication, and division. The expressions are represented as strings and may include nested parentheses to indicate the order of operations. # Problem Statement Write a function `evaluate_expression(expression: str) -> float` that takes a valid arithmetic expression as a string and returns the computed result as a float. Requirements: 1. The function must handle the four basic operations: `+`, `−`, `*`, `/`. 2. It must correctly interpret and prioritize operations inside parentheses. 3. The input expression will only contain non-negative integers and the operators specified above. 4. Division by zero should raise an `ZeroDivisionError`. Input and Output Formats: * **Input**: A string `expression` representing the arithmetic expression. The length of the expression will not exceed 100 characters. * **Output**: The computed result as a float. Example Usage: ```python print(evaluate_expression(\\"3+5*2\\")) # Output: 13.0 print(evaluate_expression(\\"(3+5)*2\\")) # Output: 16.0 print(evaluate_expression(\\"10/(2+3)\\")) # Output: 2.0 print(evaluate_expression(\\"(8/(4-2))/2\\")) # Output: 2.0 print(evaluate_expression(\\"5-3+(2*6)/3\\")) # Output: 6.0 print(evaluate_expression(\\"10/(2-2)\\")) # Raises ZeroDivisionError ``` Constraints: 1. The input expression will be a valid arithmetic expression containing non-negative integers and the operators specified. 2. No invalid characters or malformed expressions will be provided. 3. Division by zero should be properly handled by raising a `ZeroDivisionError`. # Performance Requirement The function should evaluate the expression in a reasonable time given the constraints on expression length. Good luck and ensure your solution handles edge cases properly!","solution":"import ast import operator def evaluate_expression(expression: str) -> float: Evaluates a valid arithmetic expression string containing non-negative integers and the operators +, -, *, / with proper handling of parentheses and division by zero. Args: expression (str): The arithmetic expression to evaluate. Returns: float: The result of the evaluated expression. Raises: ZeroDivisionError: If there is a division by zero in the expression. def eval_(node): if isinstance(node, ast.Num): return node.n elif isinstance(node, ast.BinOp): left = eval_(node.left) right = eval_(node.right) if isinstance(node.op, ast.Add): return left + right elif isinstance(node.op, ast.Sub): return left - right elif isinstance(node.op, ast.Mult): return left * right elif isinstance(node.op, ast.Div): if right == 0: raise ZeroDivisionError(\\"division by zero\\") return left / right tree = ast.parse(expression, mode=\'eval\') return float(eval_(tree.body))"},{"question":"# Coding Assessment Question Objective You are tasked with determining the minimum number of operations required to transform one given string into another using dynamic programming. The allowed operations are insertion, deletion, and substitution of a single character. Function Signature ```python def min_operations(str1: str, str2: str) -> int: :param str1: str, the source string. :param str2: str, the target string. :return: int, the minimum number of operations required to transform str1 into str2. Constraints: 1 <= len(str1), len(str2) <= 1000 str1 and str2 can contain any printable ASCII characters. Example: >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"flaw\\", \\"lawn\\") 2 >>> min_operations(\\"intention\\", \\"execution\\") 5 ``` Guidelines 1. **Core Requirements**: - Implement a dynamic programming solution to compute the minimum number of operations. - Ensure the input strings fall within the specified constraints: `1 <= len(str1), len(str2) <= 1000`. 2. **Expected Input/Output**: - Input: Two strings `str1` and `str2`. - Output: An integer representing the minimum number of operations required to transform `str1` into `str2`. 3. **Performance**: - The solution should be efficient and handle the specified constraints within a reasonable time frame. 4. **Edge Cases**: - Properly handle the scenario where one string is empty. - Consider the case where the strings are already identical. 5. **Error Handling**: - Throw appropriate error messages for invalid inputs not complying with the constraints. Good Luck!","solution":"def min_operations(str1: str, str2: str) -> int: Returns the minimum number of operations required to transform str1 into str2. The allowed operations are insertion, deletion, and substitution of a single character. :param str1: str, the source string. :param str2: str, the target string. :return: int, the minimum number of operations required to transform str1 into str2. m, n = len(str1), len(str2) # Create a 2D DP array to store the minimum number of operations dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the DP array for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If str1 is empty, insert all characters of str2 elif j == 0: dp[i][j] = i # If str2 is empty, delete all characters of str1 elif str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no new operation needed else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Substitute return dp[m][n]"},{"question":"# Hexadecimal to Decimal Conversion Scenario In many computer science applications, it is often necessary to convert numbers between different bases. One common scenario is converting a number from hexadecimal (base-16) to decimal (base-10). Your task is to implement a function that performs this conversion accurately. Function Signature ```python def hex_to_decimal(hex_string: str) -> int: Convert a hexadecimal string to its decimal representation. Raises a ValueError if the input string contains invalid hexadecimal characters. Parameters: hex_string (str): A string representing a hexadecimal number. Returns: int: The decimal representation of the hexadecimal number. Example: >>> hex_to_decimal(\\"1A3F\\") 6719 >>> hex_to_decimal(\\"FF\\") 255 >>> hex_to_decimal(\\"abc\\") 2748 Constraints: * The input string consists of valid hexadecimal digits (0-9 and A-F or a-f). * The input string will have a length of at most 10 characters. * The function should handle both uppercase and lowercase hexadecimal digits. ``` Requirements 1. The function should validate that the input string consists only of valid hexadecimal digits (0-9, a-f, A-F). Raise a `ValueError` with the message \\"Invalid hexadecimal string\\" if this condition is not met. 2. Implement the conversion from hexadecimal to decimal manually, without using built-in functions that directly perform the conversion. 3. The function should correctly handle both uppercase and lowercase hexadecimal digits. 4. Ensure the solution is efficient and handles edge cases such as an empty string, which should raise a `ValueError`. Constraints * You must not use any built-in conversion functions (`int()` with base parameter, for example). * The function should handle and correctly convert hexadecimal strings of up to 10 characters in length.","solution":"def hex_to_decimal(hex_string: str) -> int: Convert a hexadecimal string to its decimal representation. Raises a ValueError if the input string contains invalid hexadecimal characters. Parameters: hex_string (str): A string representing a hexadecimal number. Returns: int: The decimal representation of the hexadecimal number. if not hex_string: raise ValueError(\\"Invalid hexadecimal string\\") # Define valid hexadecimal characters valid_hex_chars = \'0123456789abcdefABCDEF\' decimal_value = 0 hex_string = hex_string.lower() for index, char in enumerate(hex_string): if char not in valid_hex_chars: raise ValueError(\\"Invalid hexadecimal string\\") # Calculate the decimal value if \'0\' <= char <= \'9\': decimal_value = decimal_value * 16 + (ord(char) - ord(\'0\')) elif \'a\' <= char <= \'f\': decimal_value = decimal_value * 16 + (ord(char) - ord(\'a\') + 10) return decimal_value"},{"question":"# Distinct Subsequences Calculation Write a Python function to count the number of distinct subsequences of a given string. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Function Signature ```python def distinct_subsequences(string: str) -> int: Calculate the number of distinct subsequences for a given string. Args: string (str): The input string for which distinct subsequences are counted. Returns: int: The number of distinct subsequences. ``` Input Format - A single string `string` (1 ≤ len(string) ≤ 1000) from which the distinct subsequences are to be calculated. Output Format - An integer representing the number of distinct subsequences. Constraints 1. The string will contain only lowercase English letters. Example ```python assert distinct_subsequences(\\"abc\\") == 8 # \\"\\", \\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"ac\\", \\"bc\\", \\"abc\\" assert distinct_subsequences(\\"aaa\\") == 4 # \\"\\", \\"a\\", \\"aa\\", \\"aaa\\" assert distinct_subsequences(\\"abcd\\") == 16 # 2^4 = 16 (since all letters are unique) ``` Scenario This problem can be useful in text analysis and data compression contexts, where identifying unique patterns/subsequences within the text is required. For example, in DNA sequence analysis, counting subsequences can be valuable in understanding genetic variability. Additional Requirements Ensure that your function can handle the upper limits of the input size efficiently. Provide a brief testing code to validate the implementation.","solution":"def distinct_subsequences(string: str) -> int: Calculate the number of distinct subsequences for a given string. Args: string (str): The input string for which distinct subsequences are counted. Returns: int: The number of distinct subsequences. n = len(string) # dp[i] will store the number of distinct subsequences of length i dp = [1] + [0] * n last_occurrence = {} for i in range(1, n + 1): dp[i] = 2 * dp[i - 1] if string[i - 1] in last_occurrence: dp[i] -= dp[last_occurrence[string[i - 1]] - 1] last_occurrence[string[i - 1]] = i return dp[n]"},{"question":"# Problem Statement You are given a matrix of integers and a target integer. Your task is to implement an efficient search algorithm to find the position of the target integer in the matrix. If the target is not found, return `(-1, -1)`. The matrix is sorted in increasing order both row-wise and column-wise. # Input Format * **matrix**: A list of lists of integers where each list represents a row in the matrix. (1 ≤ len(matrix), len(matrix[0]) ≤ 1000) * **target**: An integer to search within the matrix (-10^9 ≤ target ≤ 10^9) # Output Format * Return a tuple `(i, j)` representing the row and column indices of the target integer in the matrix if found, otherwise return `(-1, -1)`. # Example ```python >>> search_matrix([[1, 4, 7, 11], [2, 5, 8, 12], [3, 6, 9, 16], [10, 13, 14, 17]], 5) (1, 1) >>> search_matrix([[1, 4, 7, 11], [2, 5, 8, 12], [3, 6, 9, 16], [10, 13, 14, 17]], 20) (-1, -1) >>> search_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 7) (2, 0) >>> search_matrix([[1]], 1) (0, 0) >>> search_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 10) (-1, -1) ``` # Constraints * The matrix will always contain integers sorted in ascending order both row-wise and column-wise. # Performance Requirements Your implementation should be efficient to handle matrices up to 1000x1000 in size. # Hints 1. Start from the top-right or bottom-left corner of the matrix. 2. Use the matrix\'s properties to eliminate one row or column at each step.","solution":"def search_matrix(matrix, target): Search for the target integer in a sorted 2D matrix and return its position. If the target is not found, return (-1, -1). if not matrix or not matrix[0]: return (-1, -1) rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 # start from the top-right corner while row < rows and col >= 0: if matrix[row][col] == target: return (row, col) elif matrix[row][col] > target: col -= 1 # move left else: row += 1 # move down return (-1, -1)"},{"question":"# Problem Statement You are given the head of a singly linked list and a target integer value `x`. Write a function to partition the linked list such that all nodes less than `x` come before nodes greater than or equal to `x`. You should preserve the original relative order of the nodes in each of the two partitions. Function Signature ```python def partition_linked_list(head: Optional[ListNode], x: int) -> Optional[ListNode]: pass ``` Input - `head`: Optional[ListNode] - The head of the linked list. - `x`: int - The partitioning integer (1 <= x <= 10^9). Output - `returns`: Optional[ListNode] - The head of the modified linked list after partition. Constraints - The number of nodes in the list is in the range `[0, 200]`. - The value of each node in the linked list is an integer in the range `[-10^4, 10^4]`. # Examples ```python >>> class ListNode: ... def __init__(self, val=0, next=None): ... self.val = val ... self.next = next >>> def list_to_linked_list(lst): ... head = ListNode(lst[0]) ... current = head ... for value in lst[1:]: ... current.next = ListNode(value) ... current = current.next ... return head >>> def linked_list_to_list(head): ... lst = [] ... while head: ... lst.append(head.val) ... head = head.next ... return lst >>> head = list_to_linked_list([1, 4, 3, 2, 5, 2]) >>> x = 3 >>> result_head = partition_linked_list(head, x) >>> linked_list_to_list(result_head) [1, 2, 2, 4, 3, 5] >>> head = list_to_linked_list([2, 1]) >>> x = 2 >>> result_head = partition_linked_list(head, x) >>> linked_list_to_list(result_head) [1, 2] ``` # Note - Make sure to preserve the original relative order of the nodes in their respective partitions. - Consider edge cases such as empty input list or all nodes having values equal to `x`. - Think about the memory and time complexity of your solution to ensure it is efficient.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partition_linked_list(head: ListNode, x: int) -> ListNode: if head is None: return None less_head = ListNode(0) greater_head = ListNode(0) less = less_head greater = greater_head current = head while current: if current.val < x: less.next = current less = less.next else: greater.next = current greater = greater.next current = current.next # End the list of greater elements greater.next = None # Attach the less list to the greater list less.next = greater_head.next return less_head.next def list_to_linked_list(lst): if not lst: return None head = ListNode(lst[0]) current = head for value in lst[1:]: current.next = ListNode(value) current = current.next return head def linked_list_to_list(head): lst = [] while head: lst.append(head.val) head = head.next return lst"},{"question":"# Coding Assessment Problem: You are developing a function to handle data processing for a transportation company. Specifically, you need to analyze journey times and determine routes that have minimum combined travel times. # Problem Statement **Objective**: Write a function `find_optimal_routes(journeys: List[Tuple[str, str, int]], start: str, end: str) -> int` that calculates the minimum total travel time from the specified start location to the end location. # Input and Output: * **Input**: * `journeys` - A list of tuples where each tuple contains three elements: a starting location (a string), a destination location (a string), and the travel time in minutes (an integer). * `start` - A string representing the starting location. * `end` - A string representing the ending location. * **Output**: * An integer representing the minimum total travel time from the start location to the end location. If there is no possible route, return -1. # Constraints: * (1 leq text{len(journeys)} leq 10^4) * The travel times are non-negative integers. * Locations are case-sensitive strings. * Your solution should be efficient enough to handle the upper constraint within a reasonable time frame. # Example: ```python def test_find_optimal_routes(): journeys = [ (\\"A\\", \\"B\\", 10), (\\"B\\", \\"C\\", 20), (\\"A\\", \\"C\\", 40), (\\"C\\", \\"D\\", 5), (\\"B\\", \\"D\\", 25) ] assert find_optimal_routes(journeys, \\"A\\", \\"D\\") == 35 ``` # Requirements: 1. **Function Implementation**: Implement the required function with the provided signature. 2. **Complexity Consideration**: Optimize for performance, considering the potential size and nature of the input. 3. **Edge Cases**: Consider scenarios where there may be no valid route from the start to the end. # Additional Information: - The problem might involve implementing graph traversal algorithms (e.g., Dijkstra\'s algorithm) to find the shortest path. - Ensure that your implementation efficiently handles both small and large input sizes within the provided constraints.","solution":"from typing import List, Tuple import heapq from collections import defaultdict, deque def find_optimal_routes(journeys: List[Tuple[str, str, int]], start: str, end: str) -> int: # Create a graph from the journeys list graph = defaultdict(list) for src, dest, time in journeys: graph[src].append((dest, time)) # Min-heap to keep track of the shortest paths min_heap = [(0, start)] shortest_paths = {start: 0} while min_heap: curr_time, curr_loc = heapq.heappop(min_heap) if curr_loc == end: return curr_time for neighbor, travel_time in graph[curr_loc]: time = curr_time + travel_time if neighbor not in shortest_paths or time < shortest_paths[neighbor]: shortest_paths[neighbor] = time heapq.heappush(min_heap, (time, neighbor)) return -1"},{"question":"# Coding Assessment Question: Implementing Dynamic Programming to Solve the Knapsack Problem You are given the classic problem of the 0/1 knapsack, where you are to determine the maximum value that can be packed into the knapsack without exceeding its weight capacity. The values and weights of the items are provided, and each item can be included only once. **Objective**: Create a function `knapsack` that takes in the maximum capacity of the knapsack, the weights of the items, and the values of the items, and returns the maximum value that can be achieved without exceeding the capacity. # Function Signature ```python def knapsack(capacity: int, weights: list[int], values: list[int]) -> int: pass ``` # Input - `capacity` (int): The maximum weight capacity of the knapsack. - `weights` (list of int): A list containing the weights of the items. - `values` (list of int): A list containing the values of the items. # Output - Returns an integer representing the maximum value that can be achieved without exceeding the capacity of the knapsack. # Constraints - `capacity` should be a non-negative integer. - `weights` and `values` should be non-empty lists of the same length, where each element is a non-negative integer. - The number of items `n` should not exceed 1000. - The weight and value of each item should not exceed 10000. # Requirements - Implement the `knapsack` function using a dynamic programming approach. - Utilize a 2D array to store intermediate results and avoid redundant calculations. # Example ```python # Sample weights and values weights = [1, 3, 4, 5] values = [1, 4, 5, 7] capacity = 7 # Calculating the maximum value that can be achieved result = knapsack(capacity, weights, values) print(\\"Maximum value in Knapsack:\\", result) # Expected Output: 9 ``` # Hints - Create a 2D array `dp` where `dp[i][j]` represents the maximum value that can be achieved with a capacity `j` using the first `i` items. - For each item, either include it in the knapsack or exclude it, and update the `dp` array accordingly. - The value at `dp[n][capacity]` will contain the maximum value that can be achieved with the given capacity. --- I hope this new question seamlessly integrates into the given set by matching the style, complexity, and scope of the sample question.","solution":"def knapsack(capacity: int, weights: list[int], values: list[int]) -> int: n = len(weights) # dp array to store the maximum value by capacity and number of items dp = [[0] * (capacity + 1) for _ in range(n + 1)] # Build the dp array for i in range(1, n + 1): for w in range(capacity + 1): if weights[i - 1] <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]) else: dp[i][w] = dp[i - 1][w] return dp[n][capacity]"},{"question":"# Task You are required to implement a function that applies a moving average filter to a given list of numerical samples. This function should consider a specified window size and calculate the moving average for each position in the list. # Function Signature ```python def apply_moving_average(samples: list[float], window_size: int) -> list[float]: pass ``` # Input * `samples (list[float])`: A list of float values representing the samples to be filtered. * `window_size (int)`: An integer representing the window size for the moving average filter. # Output * A list of float values representing the filtered samples, where each value is the average of the values within the window. # Constraints * `1 <= len(samples) <= 10^5` * `1 <= window_size <= len(samples)` * The function should handle potential edge cases, such as window sizes of 1 or values at the boundaries of the list. # Example ```python # Sample data to filter samples = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # Applying a moving average filter with a window size of 3 filtered_samples = apply_moving_average(samples, 3) print(filtered_samples) ``` # Expected Output ```python [2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0] ``` # Notes The `apply_moving_average` function should be implemented efficiently to handle large lists of samples. For example, you can use a sliding window approach to maintain a running sum, ensuring the function runs in linear time.","solution":"def apply_moving_average(samples: list[float], window_size: int) -> list[float]: Applies a moving average filter to the given list of samples with the specified window size. Parameters: samples (list[float]): The list of float samples to filter. window_size (int): The size of the moving average window. Returns: list[float]: The filtered samples as a list of floats. if not samples or window_size <= 0 or window_size > len(samples): return [] window_sum = sum(samples[:window_size]) moving_averages = [window_sum / window_size] for i in range(len(samples) - window_size): window_sum += samples[i + window_size] - samples[i] moving_averages.append(window_sum / window_size) return moving_averages"},{"question":"# **Question: Build a Customizable Matrix Class with Complex Operations** Your task is to design and implement a customizable matrix class with various matrix operations, ensuring compatibility and efficiency. **Requirements:** 1. **Class Implementation**: - Implement a `CustomMatrix` class. - The class should support basic matrix operations: addition, subtraction, multiplication, and transpose. - The class must also support advanced operations: determinant calculation, inversion, and solving systems of linear equations. 2. **Function Implementation**: - `__init__(self, data)`: Initializes the matrix with a 2D list or a 2D NumPy array. - `add(self, other)`: Adds the current matrix with another, returning the result. - `subtract(self, other)`: Subtracts another matrix from the current matrix, returning the result. - `multiply(self, other)`: Multiplies the current matrix with another (dot product), returning the result. - `transpose(self)`: Computes and returns the transpose of the current matrix. - `determinant(self)`: Calculates and returns the determinant of the current matrix. - `inverse(self)`: Computes and returns the inverse of the current matrix. - `solve(self, b)`: Solves the system of linear equations `Ax = b`, where `A` is the current matrix and `b` is a vector or matrix of constants. 3. **I/O Specifications**: - **Input**: - Matrix data (`data`): A 2D list or a 2D NumPy array representing the matrix. - Another matrix (`other`): For addition, subtraction, and multiplication operations. - Vector or matrix (`b`): For solving systems of linear equations. - **Output**: - A new `CustomMatrix` instance for addition, subtraction, multiplication, transpose, and inverse operations. - A float for the determinant. - A vector or matrix as the solution for the system of linear equations. **Constraints**: - No direct use of third-party libraries for the matrix operations (e.g., NumPy for calculations such as determinant and inversion). - You are allowed to use NumPy for array manipulations and initialization. # Example Usage: ```python import numpy as np # Defining matrices data_A = [[1, 2], [3, 4]] data_B = [[5, 6], [7, 8]] matrix_A = CustomMatrix(data_A) matrix_B = CustomMatrix(data_B) # Basic operations added_matrix = matrix_A.add(matrix_B) subtracted_matrix = matrix_A.subtract(matrix_B) multiplied_matrix = matrix_A.multiply(matrix_B) transposed_matrix = matrix_A.transpose() # Advanced operations det_A = matrix_A.determinant() inverse_A = matrix_A.inverse() # Solving linear system Ax = b b = [5, 7] solution = matrix_A.solve(b) print(\\"Added Matrix:n\\", added_matrix) print(\\"Subtracted Matrix:n\\", subtracted_matrix) print(\\"Multiplied Matrix:n\\", multiplied_matrix) print(\\"Transposed Matrix:n\\", transposed_matrix) print(\\"Determinant of A:\\", det_A) print(\\"Inverse of A:n\\", inverse_A) print(\\"Solution to Ax = b:\\", solution) ``` In the example above, you should focus on implementing the methods for matrix operations to handle various requirements efficiently and accurately. Ensure compatibility with different matrix sizes and shapes where applicable.","solution":"import numpy as np class CustomMatrix: def __init__(self, data): if isinstance(data, list): self.data = np.array(data) elif isinstance(data, np.ndarray): self.data = data else: raise ValueError(\\"Input data must be a 2D list or a 2D NumPy array.\\") def add(self, other): if isinstance(other, CustomMatrix): result = self.data + other.data return CustomMatrix(result) else: raise ValueError(\\"The other parameter must be a CustomMatrix instance.\\") def subtract(self, other): if isinstance(other, CustomMatrix): result = self.data - other.data return CustomMatrix(result) else: raise ValueError(\\"The other parameter must be a CustomMatrix instance.\\") def multiply(self, other): if isinstance(other, CustomMatrix): result = np.dot(self.data, other.data) return CustomMatrix(result) else: raise ValueError(\\"The other parameter must be a CustomMatrix instance.\\") def transpose(self): result = self.data.T return CustomMatrix(result) def determinant(self): return np.linalg.det(self.data) def inverse(self): inv_data = np.linalg.inv(self.data) return CustomMatrix(inv_data) def solve(self, b): solution = np.linalg.solve(self.data, b) return solution def __repr__(self): return f\\"CustomMatrix({self.data.tolist()})\\""},{"question":"# Coding Assessment Question Implement a Minesweeper game solver. The goal is to design an algorithm that unveils cells in the Minesweeper grid according to the following rules: 1. **Initialization**: Start with a grid of a defined width and height with a specified number of mines randomly placed. 2. **User Input**: - The user can click on a cell to reveal it. - If the cell is a mine, mark it as \'X\' (representing a loss). - If the cell is not a mine, display the number of adjacent mines. - A revealed cell with zero adjacent mines should trigger a \\"flood fill\\" revealing adjacent non-mine cells recursively. 3. **Game States**: - **Win**: The game is won if all non-mine cells are revealed. - **Loss**: The game is lost if a mine is revealed. 4. **Display**: Consistently display the current state of the grid, with cells hiding mines (\'#\'), revealed cells showing mine counts, or \'X\' for a revealed mine. 5. **Mine Distribution**: Implement a method to ensure a random yet balanced placement of mines on the grid. Function Signature: ```python class Minesweeper: def __init__(self, width: int, height: int, mine_count: int) -> None: ... def click(self, x: int, y: int) -> None: ... def display(self) -> None: ... ``` Your Task: Implement the `Minesweeper` class and the game functionalities. Your implementation should ensure cells are correctly unveiled based on user input, mines and numbers are displayed accurately, and the game ends upon winning or revealing a mine. Handle edge cases such as clicks on the borders effectively. The grid should be updated dynamically as the user clicks cells. Constraints: - Grid dimensions: 2 <= width, height <= 100. - Mine count: 1 <= mine_count < width * height. - Ensure random mine placement avoids initial revealed cell. Given this setup, you can verify correctness by: - Ensuring mines are properly hidden and counts displayed upon reveal. - Confirming the flood fill mechanism correctly reveals connected cells with zero adjacent mines. - Observing win and loss conditions being triggered accurately.","solution":"import random class Minesweeper: def __init__(self, width: int, height: int, mine_count: int) -> None: self.width = width self.height = height self.mine_count = mine_count self.grid = [[\'#\' for _ in range(width)] for _ in range(height)] self.mines_grid = [[False for _ in range(width)] for _ in range(height)] self.revealed = [[False for _ in range(width)] for _ in range(height)] self.adjacent_mines = [[0 for _ in range(width)] for _ in range(height)] self.game_over = False self.win = False self._place_mines() def _place_mines(self): placed_mines = 0 while placed_mines < self.mine_count: x = random.randint(0, self.width - 1) y = random.randint(0, self.height - 1) if not self.mines_grid[y][x]: # this spot doesn\'t already have a mine self.mines_grid[y][x] = True self._update_adjacent_cells(x, y) placed_mines += 1 def _update_adjacent_cells(self, x: int, y: int): directions = [(-1, -1), (0, -1), (1, -1), (-1, 0), (1, 0), (-1, 1), (0, 1), (1, 1)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < self.width and 0 <= ny < self.height: self.adjacent_mines[ny][nx] += 1 def click(self, x: int, y: int) -> None: if self.game_over: return if self.mines_grid[y][x]: self.grid[y][x] = \'X\' self.game_over = True else: self._reveal_recursive(x, y) self._check_win_condition() self.display() def _reveal_recursive(self, x: int, y: int): if self.revealed[y][x]: return self.revealed[y][x] = True if self.adjacent_mines[y][x] > 0: self.grid[y][x] = str(self.adjacent_mines[y][x]) else: self.grid[y][x] = \'0\' directions = [(-1, -1), (0, -1), (1, -1), (-1, 0), (1, 0), (-1, 1), (0, 1), (1, 1)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < self.width and 0 <= ny < self.height: self._reveal_recursive(nx, ny) def _check_win_condition(self): unmapped_cells = 0 for y in range(self.height): for x in range(self.width): if self.grid[y][x] == \'#\' and not self.mines_grid[y][x]: unmapped_cells += 1 if unmapped_cells == 0: self.win = True self.game_over = True def display(self) -> None: for row in self.grid: print(\' \'.join(row)) print() # Example usage: # game = Minesweeper(10, 10, 10) # game.click(0, 0) # game.display()"},{"question":"# Problem Statement Implement a simplified file system simulation that allows basic file and directory operations. Your file system should support operations for creating, deleting, and retrieving the contents of files and directories, as well as moving and renaming them. # Objectives 1. **Class `FileSystem`:** - **Method `create(path: str, is_directory: bool = False) -> None`:** - **Input**: - `path`: a string representing the path where the file or directory will be created. - `is_directory`: a boolean indicating whether to create a file or a directory. Defaults to `False` (file). - **Output**: None. - **Constraints**: - If a file or directory already exists at the specified `path`, raise a `ValueError`. - **Requirements**: - Create the specified file or directory at the given `path`. - **Method `delete(path: str) -> None`:** - **Input**: - `path`: a string representing the path of the file or directory to delete. - **Output**: None. - **Constraints**: - If no file or directory exists at the specified `path`, raise a `FileNotFoundError`. - **Requirements**: - Remove the file or directory at the given `path`. - **Method `move(src_path: str, dest_path: str) -> None`:** - **Input**: - `src_path`: a string representing the source path of the file or directory to move. - `dest_path`: a string representing the destination path where the file or directory will be moved. - **Output**: None. - **Constraints**: - If no file or directory exists at `src_path`, raise a `FileNotFoundError`. - If a file or directory already exists at `dest_path`, raise a `ValueError`. - **Requirements**: - Move the file or directory from `src_path` to `dest_path`. - **Method `rename(path: str, new_name: str) -> None`:** - **Input**: - `path`: a string representing the path of the file or directory to rename. - `new_name`: a string representing the new name for the file or directory. - **Output**: None. - **Constraints**: - If no file or directory exists at `path`, raise a `FileNotFoundError`. - If a file or directory already exists with the new name in the same directory, raise a `ValueError`. - **Requirements**: - Rename the file or directory at the given `path` to `new_name`. - **Method `list_contents(path: str) -> list`:** - **Input**: - `path`: a string representing the path of the directory to list contents of. - **Output**: A list of strings representing the names of files and directories within the specified directory. - **Constraints**: - If no directory exists at the specified `path`, raise a `FileNotFoundError`. - **Requirements**: - Return the names of files and directories within the specified directory. # Examples ```python fs = FileSystem() # Create directories and files fs.create(\\"/a\\", is_directory=True) fs.create(\\"/a/b.txt\\") fs.create(\\"/a/c\\", is_directory=True) fs.create(\\"/a/c/d.txt\\") # List contents of directory assert fs.list_contents(\\"/a\\") == [\\"b.txt\\", \\"c\\"] assert fs.list_contents(\\"/a/c\\") == [\\"d.txt\\"] # Move file fs.move(\\"/a/b.txt\\", \\"/a/c/b.txt\\") assert fs.list_contents(\\"/a\\") == [\\"c\\"] assert fs.list_contents(\\"/a/c\\") == [\\"b.txt\\", \\"d.txt\\"] # Rename file fs.rename(\\"/a/c/d.txt\\", \\"e.txt\\") assert fs.list_contents(\\"/a/c\\") == [\\"b.txt\\", \\"e.txt\\"] # Delete file fs.delete(\\"/a/c/e.txt\\") assert fs.list_contents(\\"/a/c\\") == [\\"b.txt\\"] # Delete directory fs.delete(\\"/a/c\\") assert fs.list_contents(\\"/a\\") == [] ``` You are expected to implement the `FileSystem` class and its methods to pass all the example scenarios and properly handle edge cases.","solution":"class FileSystem: def __init__(self): self.fs = {} def _navigate_to(self, path): components = path.strip(\'/\').split(\'/\') curr = self.fs for comp in components: if comp: if comp not in curr or not isinstance(curr[comp], dict): raise FileNotFoundError(f\\"Path {path} does not exist.\\") curr = curr[comp] return curr def _parent_path_and_name(self, path): parts = path.strip(\'/\').split(\'/\') if len(parts) == 1: return \\"/\\", parts[0] parent_path = \'/\' + \'/\'.join(parts[:-1]) name = parts[-1] return parent_path, name def create(self, path: str, is_directory: bool = False) -> None: parent_path, name = self._parent_path_and_name(path) parent_dir = self._navigate_to(parent_path) if name in parent_dir: raise ValueError(f\\"File or directory already exists at path {path}.\\") if is_directory: parent_dir[name] = {} else: parent_dir[name] = None def delete(self, path: str) -> None: parent_path, name = self._parent_path_and_name(path) parent_dir = self._navigate_to(parent_path) if name not in parent_dir: raise FileNotFoundError(f\\"No file or directory exists at path {path}.\\") del parent_dir[name] def move(self, src_path: str, dest_path: str) -> None: parent_src_path, src_name = self._parent_path_and_name(src_path) parent_dest_path, dest_name = self._parent_path_and_name(dest_path) src_dir = self._navigate_to(parent_src_path) dest_dir = self._navigate_to(parent_dest_path) if src_name not in src_dir: raise FileNotFoundError(f\\"No file or directory exists at path {src_path}.\\") if dest_name in dest_dir: raise ValueError(f\\"File or directory already exists at path {dest_path}.\\") dest_dir[dest_name] = src_dir[src_name] del src_dir[src_name] def rename(self, path: str, new_name: str) -> None: parent_path, name = self._parent_path_and_name(path) parent_dir = self._navigate_to(parent_path) if name not in parent_dir: raise FileNotFoundError(f\\"No file or directory exists at path {path}.\\") if new_name in parent_dir: raise ValueError(f\\"A file or directory with the name {new_name} already exists.\\") parent_dir[new_name] = parent_dir[name] del parent_dir[name] def list_contents(self, path: str) -> list: dir_ = self._navigate_to(path) if not isinstance(dir_, dict): raise FileNotFoundError(f\\"No directory exists at path {path}.\\") return sorted(dir_.keys())"},{"question":"# Problem Statement: Reorder List by Frequency and Value Given an array of integers, write a function `reorder_by_frequency(nums: List[int]) -> List[int]` that reorders the elements based on the frequency of the numbers. The ordered list should be such that higher frequency numbers come first. If multiple elements have the same frequency, they should appear in ascending order. # Input * A list of integers `nums` representing the array. # Output * A list of integers reordered based on the described frequency and value constraints. # Constraints * The length of `nums` will be between 1 and 10,000 * Each element in `nums` will be between -10,000 and 10,000 # Example ```python >>> reorder_by_frequency([3, 3, 1, 2, 2, 2, 4]) [2, 2, 2, 3, 3, 1, 4] >>> reorder_by_frequency([3, 3, 1, 1, 1, 2, 2]) [1, 1, 1, 2, 2, 3, 3] >>> reorder_by_frequency([9, 8, 7, 8, 7, 7]) [7, 7, 7, 8, 8, 9] >>> reorder_by_frequency([-1, -1, -2, -2, -2, 0]) [-2, -2, -2, -1, -1, 0] ``` # Function Signature: ```python def reorder_by_frequency(nums: List[int]) -> List[int]: # Your code here pass ``` Your task is to implement the function `reorder_by_frequency` that processes the list of integers as specified.","solution":"from typing import List from collections import Counter def reorder_by_frequency(nums: List[int]) -> List[int]: Reorder the elements based on the frequency of the numbers. Higher frequency numbers come first. If there\'s a tie, numbers are sorted in ascending order. # Get the frequency of each number using Counter frequency = Counter(nums) # Sort the numbers primarily by frequency (high to low) and by number value (low to high) sorted_nums = sorted(nums, key=lambda x: (-frequency[x], x)) return sorted_nums"},{"question":"# Coding Assessment Question Background: As part of a text processing utility, you need to create a function that takes a list of sentences and returns a summary of word frequencies, excluding common stop words. The summary should include the count of each word appearing in the sentences, case-insensitive. Task: You need to implement a function `summarize_word_frequencies(sentences: List[str], stop_words: List[str]) -> Dict[str, int]` that takes a list of sentences and a list of stop words as input, and returns a dictionary with the frequency of each word, excluding the stop words. The function should follow these steps: 1. Tokenize the sentences into words. Ensure that the tokenization is case-insensitive. 2. Exclude the words that are listed in the stop words. 3. Count the frequency of the remaining words. 4. Return a dictionary where the keys are the words and the values are their respective counts. Input: - `sentences` (List[str]): A list of sentences where each sentence is a string. - `stop_words` (List[str]): A list of stop words where each stop word is a string. Output: - Returns a dictionary with the keys being the words and the values being the word counts. Constraints: - The function should handle punctuation and special characters gracefully. - The function should handle large input efficiently. Example: Given the sentences `[\\"The quick brown fox jumps over the lazy dog.\\", \\"A quick red fox jumps high over the lazy dog.\\"]` and stop words `[\\"the\\", \\"over\\", \\"a\\", \\"of\\", \\"to\\"]`, the function could return: ```python { \'quick\': 2, \'brown\': 1, \'fox\': 2, \'jumps\': 2, \'lazy\': 2, \'dog\': 2, \'red\': 1, \'high\': 1 } ``` Function Signature: ```python def summarize_word_frequencies(sentences: List[str], stop_words: List[str]) -> Dict[str, int]: pass ```","solution":"import re from collections import defaultdict from typing import List, Dict def summarize_word_frequencies(sentences: List[str], stop_words: List[str]) -> Dict[str, int]: word_count = defaultdict(int) stop_words_set = set(stop_words) for sentence in sentences: # Tokenize the sentence to words, converting to lowercase and removing punctuation words = re.findall(r\'bw+b\', sentence.lower()) for word in words: if word not in stop_words_set: word_count[word] += 1 return dict(word_count)"},{"question":"# Problem Statement The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, typically starting with 0 and 1. While this is a well-known problem, optimizing its computation for large values is essential in computer science. # Implement the Function ```python def fibonacci(n: int) -> int: Calculate the n-th Fibonacci number using an optimized algorithm. Parameters: - n (int): The position of the Fibonacci sequence to compute. Returns: - result (int): The n-th Fibonacci number. Example: >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(10) 55 >>> fibonacci(50) 12586269025 Constraints: - n is a non-negative integer. - 0 <= n <= 100. pass ``` # Requirements: 1. **Efficiency**: * Implement the function using an iterative approach or dynamic programming technique to ensure efficient computation for large values of n. 2. **Handling Input**: * Ensure the function handles the edge cases where n is 0 or 1. 3. **Space Optimization**: * Optimize the implementation to use constant or logarithmic space. Implement the `fibonacci` function as described. Use the provided test cases to ensure your function works correctly.","solution":"def fibonacci(n: int) -> int: Calculate the n-th Fibonacci number using an optimized algorithm. Parameters: - n (int): The position of the Fibonacci sequence to compute. Returns: - result (int): The n-th Fibonacci number. Example: >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(10) 55 >>> fibonacci(50) 12586269025 Constraints: - n is a non-negative integer. - 0 <= n <= 100. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Coding Assessment Question **Problem Statement:** You are given a library for working with basic polynomial arithmetic. The library includes methods for adding, subtracting, multiplying, and evaluating polynomials. A polynomial is represented as a list of coefficients, starting with the constant term. **Objective:** Write a function `perform_polynomial_operations` that takes a list of polynomial operations and returns the corresponding results. The operations to be supported are `\\"add\\"`, `\\"subtract\\"`, `\\"multiply\\"`, and `\\"evaluate\\"`. **Function Signature:** ```python def perform_polynomial_operations(operations: List[Tuple[str, Union[List[int], Tuple[List[int], int]]]]) -> List[Union[List[int], int]]: ``` **Input:** * `operations`: A list of tuples where each tuple contains: - A string indicating the operation type: `\\"add\\"`, `\\"subtract\\"`, `\\"multiply\\"`, or `\\"evaluate\\"`. - The corresponding operands: - For `\\"add\\"`, `\\"subtract\\"`, and `\\"multiply\\"`: a list of two polynomials represented as lists of integers. - For `\\"evaluate\\"`: a tuple containing a polynomial and an integer value at which the polynomial should be evaluated. **Output:** * A list containing the results of each operation: - For `\\"add\\"`, `\\"subtract\\"`, and `\\"multiply\\"`: a list of integers representing the resultant polynomial coefficients. - For `\\"evaluate\\"`: an integer representing the evaluated result at the given point. **Constraints:** * Each polynomial will have non-negative integer coefficients. * The degree of polynomials will not exceed 100. * Evaluation will be within the integer range. **Example:** ```python operations = [ (\\"add\\", [[1, 2, 3], [4, 0, 5]]), (\\"subtract\\", [[7, 2], [5, 1, 1]]), (\\"multiply\\", [[1, 1], [1, -1]]), (\\"evaluate\\", ([1, 0, -3], 2)) ] result = perform_polynomial_operations(operations) print(result) # Output: [[5, 2, 8], [2, 1, -1], [1, 0, -1], -3] ``` **Requirements:** 1. Implement the function `perform_polynomial_operations` that properly handles the polynomial arithmetic operations. 2. Ensure the function handles edge cases correctly (e.g., different polynomial degrees). 3. Thoroughly test the function with various inputs representing different polynomial operations and evaluations.","solution":"from typing import List, Tuple, Union def add_polynomials(poly1, poly2): result = [0] * max(len(poly1), len(poly2)) for i in range(len(poly1)): result[i] += poly1[i] for i in range(len(poly2)): result[i] += poly2[i] return result def subtract_polynomials(poly1, poly2): result = [0] * max(len(poly1), len(poly2)) for i in range(len(poly1)): result[i] += poly1[i] for i in range(len(poly2)): result[i] -= poly2[i] return result def multiply_polynomials(poly1, poly2): result = [0] * (len(poly1) + len(poly2) - 1) for i in range(len(poly1)): for j in range(len(poly2)): result[i + j] += poly1[i] * poly2[j] return result def evaluate_polynomial(poly, x): result = 0 for i in range(len(poly)): result += poly[i] * (x ** i) return result def perform_polynomial_operations(operations: List[Tuple[str, Union[List[int], Tuple[List[int], int]]]]) -> List[Union[List[int], int]]: results = [] for operation in operations: op_type = operation[0] operands = operation[1] if op_type == \\"add\\": result = add_polynomials(operands[0], operands[1]) elif op_type == \\"subtract\\": result = subtract_polynomials(operands[0], operands[1]) elif op_type == \\"multiply\\": result = multiply_polynomials(operands[0], operands[1]) elif op_type == \\"evaluate\\": result = evaluate_polynomial(operands[0], operands[1]) results.append(result) return results"},{"question":"# Coding Challenge: Directed Weighted Graph Shortest Path You are given a function `shortest_path` for finding the shortest path from a starting node to all other nodes in a directed weighted graph. This function utilizes Dijkstra\'s algorithm. To further challenge your understanding, you\'ll enhance the function to handle a graph represented as an adjacency list and return the shortest path distances in a sorted order by node identifier. Task Modify the given `shortest_path` function to sort the output distances by the node identifier. Function Signature ```python def enhanced_shortest_path(graph: Dict[int, List[Tuple[int, float]]], start: int) -> List[Tuple[int, float]]: pass ``` Input Description - `graph` - A dictionary where keys are node identifiers (integers) and values are lists of tuples. Each tuple contains: * An integer representing a neighboring node, * A float representing the weight of the edge to that neighboring node. - `start` - An integer representing the starting node from which to calculate the shortest paths. Output Description - Return a list of tuples, where each tuple contains: * An integer representing the node identifier, * A float representing the shortest distance from the start node to that node. - The list should be sorted by the node identifiers in ascending order. Constraints - Ensure that the graph can handle up to 1000 nodes. - The graph may contain cycles and should be a connected graph. - Each edge weight will be a positive float. Example ```python graph = { 0: [(1, 4.0), (2, 1.0)], 1: [(3, 1.0)], 2: [(1, 2.0), (3, 5.0)], 3: [] } start = 0 print(enhanced_shortest_path(graph, start)) # Output: [(0, 0.0), (1, 3.0), (2, 1.0), (3, 4.0)] ``` Points to Consider - Be mindful of computational constraints when working with larger graphs. - Ensure accuracy in distance calculations and correct handling of edge cases. - Include appropriate error checking for inputs and outputs.","solution":"import heapq from typing import Dict, List, Tuple def enhanced_shortest_path(graph: Dict[int, List[Tuple[int, float]]], start: int) -> List[Tuple[int, float]]: # Initialize distances with infinity, and distance to start node as 0 distances = {node: float(\'inf\') for node in graph} distances[start] = 0.0 # Priority queue to select the next node with the smallest distance pq = [(0.0, start)] heapq.heapify(pq) while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) # Convert distances to a sorted list of tuples sorted_distances = sorted(distances.items()) return sorted_distances"},{"question":"# Coding Question Context: You\'ve been asked to develop a system for processing shopping lists and optimizing the order of items based on the sections of the store they belong to. Objective: Implement a function that takes a shopping list and reorders it based on predefined sections of a store. Each section has a unique identifier and the order is determined by the sequence of these identifiers. Function Signature: ```python def reorder_shopping_list(item_sections: dict, shopping_list: list, section_order: list) -> list: :param item_sections: dict : a dictionary where the keys are item names and the values are section identifiers. :param shopping_list: list : a list of items to be purchased. :param section_order: list : a list representing the order in which sections should be visited. :return: list : the shopping list reordered based on the given section order. Example: >>> items = { ... \'milk\': \'dairy\', \'cheese\': \'dairy\', ... \'apple\': \'produce\', \'banana\': \'produce\', \'carrot\': \'produce\', ... \'chicken\': \'meat\', \'beef\': \'meat\', \'pork\': \'meat\' ... } >>> shopping = [\'banana\', \'milk\', \'chicken\', \'apple\', \'beef\'] >>> order = [\'produce\', \'dairy\', \'meat\'] >>> reorder_shopping_list(items, shopping, order) [\'banana\', \'apple\', \'milk\', \'chicken\', \'beef\'] >>> shopping = [\'pork\', \'carrot\', \'cheese\'] >>> reorder_shopping_list(items, shopping, order) [\'carrot\', \'cheese\', \'pork\'] ``` Requirements: * **Input**: * `item_sections` - a dictionary mapping items to their respective store sections. * `shopping_list` - a list of items to be purchased. * `section_order` - a list defining the order in which sections should be processed. * **Output**: * Returns a new list representing the reordered shopping list based on the section order. Constraints: * The `shopping_list` will only contain items present in the `item_sections` dictionary. * The `section_order` contains all sections used in the `item_sections`. * The shopping list should maintain the original sequence of items within each section. Edge Cases: * When `shopping_list` contains items from the same section. * When the `shopping_list` is empty. * When an item appears multiple times in the `shopping_list`. Your function should ensure the items are ordered to optimize navigation through the store efficiently.","solution":"def reorder_shopping_list(item_sections, shopping_list, section_order): Reorders the shopping list based on predefined store sections. :param item_sections: dict : a dictionary where the keys are item names and the values are section identifiers. :param shopping_list: list : a list of items to be purchased. :param section_order: list : a list representing the order in which sections should be visited. :return: list : the shopping list reordered based on the given section order. # Create a dictionary to hold items for each section based on section_order section_items = {section: [] for section in section_order} # Assign items from the shopping_list to their respective section lists for item in shopping_list: section = item_sections[item] section_items[section].append(item) # Construct the ordered shopping list by iterating through section_order ordered_list = [] for section in section_order: ordered_list.extend(section_items[section]) return ordered_list # Example usage (These are examples, not part of the function implementation): # items = { # \'milk\': \'dairy\', \'cheese\': \'dairy\', # \'apple\': \'produce\', \'banana\': \'produce\', \'carrot\': \'produce\', # \'chicken\': \'meat\', \'beef\': \'meat\', \'pork\': \'meat\' # } # shopping = [\'banana\', \'milk\', \'chicken\', \'apple\', \'beef\'] # order = [\'produce\', \'dairy\', \'meat\'] # print(reorder_shopping_list(items, shopping, order)) # Output: [\'banana\', \'apple\', \'milk\', \'chicken\', \'beef\']"},{"question":"# Question: Implement a Custom Sorting Algorithm You are tasked with implementing a custom sorting function that sorts a list of integers in a specific manner. The sorting function should first segregate the even and odd numbers, with all even numbers appearing before any odd number. Within each of those groups (even and odd), the numbers should be sorted in ascending order. Your task is to: 1. Implement the \'custom_sort\' method that segregates and then sorts the integers accordingly. 2. Ensure that the sorting works correctly for both even and odd numbers in various combinations. Requirements: - Your `custom_sort` method should accept one parameter: - `nums`: A list of integers. Input: - `nums` (List[int]): A list of integers to be sorted. Output: - `sorted_nums` (List[int]): A sorted list of integers where even numbers appear before odd numbers, and each group is sorted in ascending order. Constraints: - The list can be empty. - The integers in the list can be both negative and positive. # Example: ```python # Example input: nums = [3, 1, 2, 4, 5, 7, 6] # Expected output: # sorted_nums = [2, 4, 6, 1, 3, 5, 7] ``` Function signature: ```python def custom_sort(nums: List[int]) -> List[int]: pass ``` Write the `custom_sort` function to complete the task as described above.","solution":"from typing import List def custom_sort(nums: List[int]) -> List[int]: Returns a list of integers sorted such that all even numbers appear before all odd numbers, and both groups are sorted in ascending order. evens = sorted([num for num in nums if num % 2 == 0]) odds = sorted([num for num in nums if num % 2 != 0]) return evens + odds"},{"question":"# Problem Statement: You are developing a software for a library that maintains a catalog of books. Each book has a title, author, year of publication, and a genre. The software should allow the library to filter and sort books based on various criteria to manage their collection efficiently. # Requirements: 1. **Input**: * A list of books, each described by a tuple: (title, author, year, genre). * Two optional parameters: * A filter function that defines the conditions to include a book. * A sort key function to define the sorting order of the books. 2. **Output**: * A filtered and sorted list of books (each represented by a tuple: (title, author, year, genre)). # Constraints: * The list of books will have a length between 1 to 1000. * The year will be an integer between 1000 and the current year. * The title and author will be strings with lengths between 1 and 100. * The genre will be a string with a length between 1 and 50. # Instructions: 1. Implement a `Book` class to encapsulate the attributes and behaviors of a book. 2. Create a function `build_catalog` that takes lists of titles, authors, years, and genres, and returns a list of `Book` objects. 3. Define a function `filter_and_sort_books`, which filters and sorts the catalog of books based on the provided functions. * This function should accept the list of `Book` objects, a filter function, and a sort key function. 4. Write test cases to verify the implementation. # Function Signatures: ```python class Book: def __init__(self, title, author, year, genre): pass def build_catalog(titles, authors, years, genres): pass def filter_and_sort_books(books, filter_func=None, sort_key_func=None): pass ``` # Example: ```python if __name__ == \\"__main__\\": titles = [\\"Book A\\", \\"Book B\\", \\"Book C\\", \\"Book D\\"] authors = [\\"Author X\\", \\"Author Y\\", \\"Author Z\\", \\"Author W\\"] years = [1999, 2005, 2010, 2017] genres = [\\"Fantasy\\", \\"Science Fiction\\", \\"Mystery\\", \\"Fantasy\\"] books = build_catalog(titles, authors, years, genres) # Filter books published after 2000 and sort by title filtered_sorted_books = filter_and_sort_books(books, lambda x: x.year > 2000, lambda x: x.title) print(filtered_sorted_books) # Output: [(Book B, Author Y, 2005, Science Fiction), (Book C, Author Z, 2010, Mystery), (Book D, Author W, 2017, Fantasy)] ```","solution":"class Book: def __init__(self, title, author, year, genre): self.title = title self.author = author self.year = year self.genre = genre def __repr__(self): return f\\"({self.title}, {self.author}, {self.year}, {self.genre})\\" def build_catalog(titles, authors, years, genres): return [Book(title, author, year, genre) for title, author, year, genre in zip(titles, authors, years, genres)] def filter_and_sort_books(books, filter_func=None, sort_key_func=None): if filter_func: books = filter(filter_func, books) if sort_key_func: books = sorted(books, key=sort_key_func) return list(books)"},{"question":"# Scenario You are employed as a software developer at a company that provides mobile applications for meal planning and nutrition tracking. One of the key features is to generate balanced meal plans that comply with specific dietary restrictions and nutrient requirements. Your task is to implement a function that validates the nutritional adequacy of provided meal plans based on given constraints. # Task Description Implement a Python function `validate_meal_plan` that checks if a given meal plan meets the required nutritional values for calories and protein. Each meal consists of several food items, and each food item has a specified number of calories and grams of protein. # Function Signature ```python def validate_meal_plan( meal_plan: list[list[dict[str, float]]], req_calories: float, req_protein: float ) -> list[bool]: ``` # Input - `meal_plan`: A list of meals, where each meal is a list of food items. Each food item is represented as a dictionary with keys `calories` and `protein` corresponding to their nutritional values (positive floats). - `req_calories`: A positive float representing the required total number of calories for each meal. - `req_protein`: A positive float representing the required total grams of protein for each meal. # Output - A list of boolean values, where each boolean indicates whether the respective meal in the meal plan meets both the required calorie and protein values. # Constraints - You must handle invalid inputs (e.g., negative values, missing keys) by raising a `ValueError`. - The length of the input list `meal_plan` is guaranteed to be non-empty. # Performance Requirements - Your solution should iterate through each meal and each food item in an efficient manner. - Ensure the time complexity of O(m * n), where m represents the number of meals and n represents the number of food items per meal. # Example ```python # Example 1 meal_plan = [ [{\\"calories\\": 200, \\"protein\\": 15}, {\\"calories\\": 300, \\"protein\\": 20}], [{\\"calories\\": 150, \\"protein\\": 10}, {\\"calories\\": 250, \\"protein\\": 15}], [{\\"calories\\": 400, \\"protein\\": 30}] ] req_calories = 500 req_protein = 30 # Expected: [True, False, False] print(validate_meal_plan(meal_plan, req_calories, req_protein)) # Example 2 meal_plan = [ [{\\"calories\\": 250, \\"protein\\": 20}, {\\"calories\\": 300, \\"protein\\": 25}], [{\\"calories\\": 200, \\"protein\\": 15}, {\\"calories\\": 400, \\"protein\\": 30}] ] req_calories = 550 req_protein = 40 # Expected: [True, True] print(validate_meal_plan(meal_plan, req_calories, req_protein)) ``` # Notes - Each food item dictionary will always contain \'calories\' and \'protein\' keys. - Nevertheless, validate that the values for calories and protein are positive floats and that the required nutritional values are also positive. - If any constraint is not met, raise a `ValueError`.","solution":"def validate_meal_plan( meal_plan: list[list[dict[str, float]]], req_calories: float, req_protein: float ) -> list[bool]: Validates if each meal in the meal plan meets the required calories and protein. Raises a ValueError for negative or invalid values. Parameters: meal_plan (list[list[dict[str, float]]]): A list of meals, each meal is a list of food items. req_calories (float): Required total number of calories for each meal. req_protein (float): Required total grams of protein for each meal. Returns: list[bool]: A list of boolean values indicating if each meal meets the required values. # Check for invalid input values if req_calories <= 0 or req_protein <= 0: raise ValueError(\\"Required calories and protein must be positive values.\\") validated_meals = [] for meal in meal_plan: total_calories = 0 total_protein = 0 for item in meal: if \'calories\' not in item or \'protein\' not in item: raise ValueError(\\"Each food item must contain \'calories\' and \'protein\' keys.\\") if not isinstance(item[\'calories\'], (int, float)) or not isinstance(item[\'protein\'], (int, float)): raise ValueError(\\"\'calories\' and \'protein\' values must be numeric.\\") if item[\'calories\'] < 0 or item[\'protein\'] < 0: raise ValueError(\\"Calories and protein values must be positive floats.\\") total_calories += item[\'calories\'] total_protein += item[\'protein\'] if total_calories >= req_calories and total_protein >= req_protein: validated_meals.append(True) else: validated_meals.append(False) return validated_meals"},{"question":"Matrix Multiplication and Transposition You are provided with a function to multiply two matrices and return the result. Your task is to extend the functionality of this function by adding another feature: computing the transpose of the resultant matrix after the multiplication. # Instructions: 1. Implement a function `matrix_multiplication(matrix_a, matrix_b)` which computes the product of two matrices. 2. Implement a function `transpose_matrix(matrix)` which computes the transpose of a matrix. 3. Modify `matrix_multiplication_with_transpose` to: * Perform matrix multiplication using the `matrix_multiplication` function. * Compute the transpose of the product using the `transpose_matrix` function. # Input: * Two matrices `matrix_a` and `matrix_b` for multiplication. # Output: * The resultant matrix product. * The transpose of the resultant matrix. # Constraints: * Ensure the matrices are compatible for multiplication (i.e., the number of columns in the first matrix is equal to the number of rows in the second matrix). * Use numPy for matrix operations. * Handle edge cases where matrices may be empty or contain non-numeric values by returning appropriate error messages. # Example: ```python matrix_a = np.array([[1, 2], [3, 4]]) matrix_b = np.array([[5, 6], [7, 8]]) ``` # Function Signature: ```python def matrix_multiplication(matrix_a: np.ndarray, matrix_b: np.ndarray) -> np.ndarray: pass def transpose_matrix(matrix: np.ndarray) -> np.ndarray: pass def matrix_multiplication_with_transpose(matrix_a: np.ndarray, matrix_b: np.ndarray) -> Tuple[np.ndarray, np.ndarray]: pass # Usage Example result_matrix, transposed_matrix = matrix_multiplication_with_transpose(matrix_a, matrix_b) print(result_matrix) # Should print the product of matrix_a and matrix_b print(transposed_matrix) # Should print the transpose of the product matrix ``` This new question maintains the style, complexity, and technical challenge of the original example while introducing a new problem domain related to matrix operations.","solution":"import numpy as np def matrix_multiplication(matrix_a, matrix_b): Multiplies two matrices and returns the result. if matrix_a.shape[1] != matrix_b.shape[0]: raise ValueError(\\"Incompatible dimensions for matrix multiplication\\") return np.dot(matrix_a, matrix_b) def transpose_matrix(matrix): Computes and returns the transpose of a matrix. return np.transpose(matrix) def matrix_multiplication_with_transpose(matrix_a, matrix_b): Multiplies two matrices and returns the product and its transpose. product_matrix = matrix_multiplication(matrix_a, matrix_b) transposed_matrix = transpose_matrix(product_matrix) return product_matrix, transposed_matrix"},{"question":"# Problem Statement Context As part of a social network analysis tool, you need to analyze connections between users. One particular analysis involves identifying the \\"friends of friends\\" for a given user. This task is essential for understanding how information can spread throughout the network. Task Implement a function to find all unique \\"friends of friends\\" for a given user in a social network. The social network is represented as a dictionary where the keys are user IDs and the values are lists of friends (also represented by user IDs). The function should return a list of unique friends of friends for the given user\'s ID, excluding the user\'s direct friends and the user themselves. Function Signature ```python def find_friends_of_friends(network: dict, user_id: int) -> list: pass ``` Input Format - A dictionary `network` where: * Keys are integers representing user IDs. * Values are lists of integers representing friends of the corresponding user ID. * Each user ID and friend ID will be a positive integer. - An integer `user_id` representing the user for whom to find friends of friends. Output Format - A list of integers representing unique friends of friends for the given user, excluding direct friends and the user themselves. Constraints - The network will contain between 1 and 100,000 users. - Each list of friends will contain between 0 and 1,000 friends. Example ```python network = { 1: [2, 3], 2: [1, 4], 3: [1, 5], 4: [2, 6], 5: [3, 7], 6: [4], 7: [5] } assert find_friends_of_friends(network, 1) == [4, 5] assert find_friends_of_friends(network, 2) == [5, 6] assert find_friends_of_friends(network, 3) == [4, 7] ``` Requirements - Ensure your solution handles edge cases such as users with no friends, users with all friends sharing the same friends set, and large networks with deep connections. Notes - The resulting list should contain only unique user IDs. - The ordering of the resulting list does not matter.","solution":"def find_friends_of_friends(network, user_id): Finds unique friends of friends for a given user excluding the user\'s direct friends and the user themselves. Args: network (dict): A dictionary where keys are user IDs and values are lists of friends (user IDs). user_id (int): The user ID for whom to find friends of friends. Returns: list: A list of unique friends of friends\' user IDs. if user_id not in network: return [] direct_friends = set(network[user_id]) friends_of_friends = set() for friend in direct_friends: if friend in network: friends_of_friends.update(network[friend]) # Exclude the original user and their direct friends friends_of_friends.discard(user_id) friends_of_friends -= direct_friends return list(friends_of_friends)"},{"question":"# Context You are tasked with developing a simplified file management system for a custom filesystem. Each file is represented by a unique identifier and has various properties such as name, size, and creation timestamp. You need to implement functionalities to add, remove, and retrieve file information efficiently. # Problem Statement Implement a class `FileSystem` with the following methods: 1. `add_file(file_id: int, name: str, size: int, timestamp: int)` 2. `remove_file(file_id: int) -> bool` 3. `get_file_info(file_id: int) -> dict` 4. `get_files_by_size(min_size: int, max_size: int) -> List[int]` Method Descriptions: * **add_file**: Adds a new file to the system with the given properties: `file_id`, `name`, `size`, and `timestamp`. * **remove_file**: Removes the file identified by `file_id`. Returns `True` if the file exists and is removed, `False` otherwise. * **get_file_info**: Retrieves information of the file identified by `file_id`. Returns a dictionary with keys `name`, `size`, and `timestamp` if the file exists, `None` otherwise. * **get_files_by_size**: Returns a list of file identifiers for files whose sizes are within the inclusive range `[min_size, max_size]`. Input and Output Formats: * **Input**: - `file_id`: An integer representing the unique file identifier (0 <= file_id <= 10^6). - `name`: A string representing the name of the file (1 <= len(name) <= 100). - `size`: An integer representing the size of the file in bytes (0 <= size <= 2^31 - 1). - `timestamp`: An integer representing the creation timestamp of the file (0 <= timestamp <= 2^31 - 1). - `min_size`, `max_size`: Integers representing the size range to filter files (0 <= min_size <= max_size <= 2^31-1). * **Output**: As described in the method descriptions above. Constraints: 1. `file_id` must be unique and cannot be reused once removed. 2. Each method should handle edge cases appropriately, such as non-existent files. Example Usage: ```python fs = FileSystem() fs.add_file(1, \\"fileA.txt\\", 150, 1609459200) # Adds file with id 1 print(fs.get_file_info(1)) # Output: {\'name\': \'fileA.txt\', \'size\': 150, \'timestamp\': 1609459200} print(fs.remove_file(1)) # Output: True print(fs.remove_file(1)) # Output: False fs.add_file(2, \\"fileB.txt\\", 300, 1609459300) # Adds file with id 2 fs.add_file(3, \\"fileC.txt\\", 450, 1609459400) # Adds file with id 3 print(fs.get_files_by_size(200, 400)) # Output: [2] # Attempt to get info of a removed file print(fs.get_file_info(1)) # Output: None ``` # Performance Requirement All methods should perform their operations efficiently. The `add_file`, `remove_file`, and `get_file_info` methods should aim for O(1) average time complexity, while `get_files_by_size` should be optimally implemented for performance with larger datasets. Good luck with your implementation and account for all edge cases!","solution":"class FileSystem: def __init__(self): self.files = {} def add_file(self, file_id: int, name: str, size: int, timestamp: int): if file_id not in self.files: self.files[file_id] = { \'name\': name, \'size\': size, \'timestamp\': timestamp } def remove_file(self, file_id: int) -> bool: if file_id in self.files: del self.files[file_id] return True return False def get_file_info(self, file_id: int) -> dict: return self.files.get(file_id, None) def get_files_by_size(self, min_size: int, max_size: int) -> list: return [file_id for file_id, file_info in self.files.items() if min_size <= file_info[\'size\'] <= max_size]"},{"question":"# Question: Product Recommendation Algorithm You are asked to develop a product recommendation system for an e-commerce website. Your task is to implement a function that recommends a list of products to a user based on their browsing and purchase history. Requirements 1. Implement the function `recommend_products(user_id: int, user_data: dict, product_catalog: list) -> list` 2. The function should: - Take the `user_id` representing the ID of the user for whom recommendations are being generated. - Use the `user_data`, a dictionary where keys are user IDs and values are nested dictionaries with keys `browsing_history` and `purchase_history`. Each history is a list of product IDs. - Use the `product_catalog`, a list of dictionaries where each dictionary has keys `product_id`, `category`, and `popularity_score`. - Recommend products based on the highest popularity score in categories frequently browsed and purchased by the user but exclude already bought products. Input * `user_id` (int): User ID for whom recommendations are being generated. * `user_data` (dict): Dictionary containing each user\'s browsing and purchase history. * `product_catalog` (list): List of dictionaries with details of available products. Output * A list of recommended product IDs, sorted by their popularity score in descending order. Constraints * If there are ties in popularity scores, sort the products with the same scores by their `product_id` in ascending order. * Ensure the list of recommendations does not include products already purchased by the user. * The function should handle cases where the user\'s browsing and purchase history are empty. Example ```python user_data = { 1: { \\"browsing_history\\": [101, 102, 103], \\"purchase_history\\": [101, 104] }, 2: { \\"browsing_history\\": [201, 202], \\"purchase_history\\": [202] } } product_catalog = [ {\\"product_id\\": 101, \\"category\\": \\"Electronics\\", \\"popularity_score\\": 90}, {\\"product_id\\": 102, \\"category\\": \\"Books\\", \\"popularity_score\\": 85}, {\\"product_id\\": 103, \\"category\\": \\"Books\\", \\"popularity_score\\": 80}, {\\"product_id\\": 104, \\"category\\": \\"Electronics\\", \\"popularity_score\\": 75}, {\\"product_id\\": 105, \\"category\\": \\"Books\\", \\"popularity_score\\": 70}, ] recommend_products(1, user_data, product_catalog) > [102, 103, 105] ``` # Additional Notes * Focus on categories that the user has shown interest in (both browsing and purchase history). * Optimize the function to ensure recommendations are generated efficiently, even with a large dataset. * Implement appropriate error handling to manage cases where the user ID does not exist in the provided `user_data`.","solution":"def recommend_products(user_id: int, user_data: dict, product_catalog: list) -> list: Recommend products to a user based on their browsing and purchase history. Arguments: user_id (int) -- ID of the user for whom to generate recommendations user_data (dict) -- Dictionary containing browsing and purchase history for users product_catalog (list) -- List of product details containing product_id, category, and popularity score Returns: list -- Recommended products sorted by their popularity score in descending order # Get user history if user_id not in user_data: return [] browsing_history = user_data[user_id].get(\'browsing_history\', []) purchase_history = user_data[user_id].get(\'purchase_history\', []) # Get categories of interest from browsing and purchase history categories_of_interest = set() for product in product_catalog: if product[\'product_id\'] in browsing_history or product[\'product_id\'] in purchase_history: categories_of_interest.add(product[\'category\']) # Filter products based on categories of interest and exclude those already purchased recommended_products = [ product for product in product_catalog if product[\'category\'] in categories_of_interest and product[\'product_id\'] not in purchase_history ] # Sort recommended products by popularity score (descending) and product_id (ascending) recommended_products.sort(key=lambda x: (-x[\'popularity_score\'], x[\'product_id\'])) # Return the product IDs of the recommended products return [product[\'product_id\'] for product in recommended_products]"},{"question":"# Problem: Implementing a Queue Using Two Stacks You are tasked with implementing a queue using two stacks. This is a common interview problem that tests understanding of stack and queue data structures, and the ability to manipulate them to achieve desired behaviors. Your task is to create a class `QueueUsingStacks` which simulates the behavior of a queue (FIFO: First-In-First-Out) by using two stacks (which are LIFO: Last-In-First-Out). # Class Details: - **Attributes**: - `stack1`: A Python list to use as the first stack. - `stack2`: A Python list to use as the second stack. - **Methods**: - `__init__()`: Initializes the two stacks. - `enqueue(element)`: Adds an element to the end of the queue. - `dequeue()`: Removes and returns the element at the front of the queue. If the queue is empty, it should raise an `IndexError` with the message \\"Queue is empty\\". - `peek()`: Returns the element at the front of the queue without removing it. If the queue is empty, it should raise an `IndexError` with the message \\"Queue is empty\\". - `is_empty()`: Returns `True` if the queue is empty, otherwise returns `False`. # Expected Class Signature: ```python class QueueUsingStacks: def __init__(self): pass def enqueue(self, element: int) -> None: pass def dequeue(self) -> int: pass def peek(self) -> int: pass def is_empty(self) -> bool: pass ``` # Example: ```python queue = QueueUsingStacks() queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) print(queue.dequeue()) # Output: 1 print(queue.peek()) # Output: 2 print(queue.is_empty()) # Output: False queue.dequeue() queue.dequeue() print(queue.is_empty()) # Output: True ``` # Notes: 1. The `enqueue` operation should take O(1) time. 2. The `dequeue` and `peek` operations should take O(n) time in the worst case where n is the number of elements in the queue, but the amortized time complexity should be O(1). 3. Ensure your implementation handles edge cases such as performing a `dequeue` or `peek` operation on an empty queue by raising an `IndexError`. This problem will test your ability to work with data structures and understand the mechanics of stacks and queues in Python.","solution":"class QueueUsingStacks: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, element: int) -> None: self.stack1.append(element) def dequeue(self) -> int: if self.is_empty(): raise IndexError(\\"Queue is empty\\") if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() def peek(self) -> int: if self.is_empty(): raise IndexError(\\"Queue is empty\\") if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2[-1] def is_empty(self) -> bool: return not (self.stack1 or self.stack2)"},{"question":"# Question: Implement a Compressed Trie (Radix Tree) Context A Compressed Trie, or Radix Tree, is a space-optimized version of a standard trie that merges nodes without branching into combined nodes. This question requires you to implement a simplified version of a compressed trie to store and search for strings with shared prefixes efficiently. Task 1. Implement a `CompressedTrie` class with methods to insert strings and search for strings and prefixes. 2. Your implementation should maintain the space efficiency of a compressed trie. 3. Analyze the performance differences between a standard trie and a compressed trie. Class Signature ```python class CompressedTrie: def __init__(self): pass def insert(self, word: str) -> None: pass def search(self, word: str) -> bool: pass def starts_with(self, prefix: str) -> bool: pass ``` Input * `word`: String to be inserted or searched in the trie. * `prefix`: String prefix to be checked for in the trie. Output * `insert`: No output, inserts the word into the trie. * `search`: Returns `True` if the word is in the trie, otherwise `False`. * `starts_with`: Returns `True` if there is any word in the trie that starts with the given prefix, otherwise `False`. Constraints * Words and prefixes will consist only of lowercase English letters. * 1 <= len(word), len(prefix) <= 2000 * Number of operations (insert, search, starts_with) <= 10^5 Requirements * Your solution should effectively manage memory and handle a large number of operations efficiently. * Ensure the insertion and search operations work within reasonable time limits given the constraints. * The compressed trie must handle common prefixes correctly. Example ```python >>> trie = CompressedTrie() >>> trie.insert(\\"apple\\") >>> trie.search(\\"apple\\") True >>> trie.search(\\"app\\") False >>> trie.starts_with(\\"app\\") True >>> trie.insert(\\"app\\") >>> trie.search(\\"app\\") True ``` Notes * Focus on optimizing the trie structure to merge nodes without branching into combined nodes. * Handle edge cases such as empty strings appropriately (though the constraints specify that words and prefixes will have a minimum length of 1). * Include comprehensive tests to validate your `CompressedTrie` implementation.","solution":"class CompressedTrie: def __init__(self): self.children = {} self.is_end_of_word = False def insert(self, word: str) -> None: node = self while word: found = False for key in node.children: if word.startswith(key): prefix_len = len(key) node = node.children[key] word = word[prefix_len:] found = True break if not found: node.children[word] = CompressedTrie() node = node.children[word] word = \\"\\" node.is_end_of_word = True def search(self, word: str) -> bool: node = self while word: found = False for key in node.children: if word.startswith(key): prefix_len = len(key) node = node.children[key] word = word[prefix_len:] found = True break if not found: return False return node.is_end_of_word def starts_with(self, prefix: str) -> bool: node = self while prefix: found = False for key in node.children: if prefix.startswith(key): prefix_len = len(key) node = node.children[key] prefix = prefix[prefix_len:] found = True break elif key.startswith(prefix): return True if not found: return False return True"},{"question":"# Question: Merge Intervals with Additional Reporting Context: You are given a list of intervals where each interval is a pair of integers representing the start and end times. Your task is to merge overlapping intervals and provide additional reporting on the operations performed. Task: Write a function `merge_intervals_with_reporting(intervals)` that merges overlapping intervals from the given list and provides a detailed report for each merge operation. The report should include the before and after states of merged intervals. Input: * `intervals`: A list of tuples, where each tuple represents an interval `(start, end)` with integer values `start` and `end`. Output: * A tuple `(merged_intervals, report)` where: - `merged_intervals` is a list of merged intervals sorted by the start time. - `report` is a list of dictionaries, where each dictionary contains the following: - `before`: A list of intervals that were merged in this operation. - `after`: The resulting interval after the merge. Examples: ```python >>> merge_intervals_with_reporting([(1, 3), (2, 4), (5, 7), (6, 8)]) ([(1, 4), (5, 8)], [{\'before\': [(1, 3), (2, 4)], \'after\': (1, 4)}, {\'before\': [(5, 7), (6, 8)], \'after\': (5, 8)}]) >>> merge_intervals_with_reporting([(1, 10), (2, 6), (8, 10)]) ([(1, 10)], [{\'before\': [(1, 10), (2, 6)], \'after\': (1, 10)}, {\'before\': [(1, 10), (8, 10)], \'after\': (1, 10)}]) >>> merge_intervals_with_reporting([(1, 5), (2, 3), (4, 6), (7, 9)]) ([(1, 6), (7, 9)], [{\'before\': [(1, 5), (2, 3)], \'after\': (1, 5)}, {\'before\': [(1, 5), (4, 6)], \'after\': (1, 6)}]) ``` Constraints: * Each interval\'s start will always be less than or equal to its end. * Intervals may not be initially sorted. * Do not use external libraries for sorting and merging. * Ensure optimal and clear implementation with appropriate intermediate steps and documentation for merging process.","solution":"def merge_intervals_with_reporting(intervals): Merges overlapping intervals and provides a detailed report for each merge operation. Parameters: intervals (list of tuples): List of intervals where each interval is represented as (start, end) Returns: tuple: (merged_intervals, report) merged_intervals: List of merged intervals sorted by the start time. report: List of dictionaries with details of merge operations. if not intervals: return [], [] # Step 1: Sort intervals by the start time intervals.sort(key=lambda x: x[0]) merged_intervals = [] report = [] current_interval = intervals[0] for interval in intervals[1:]: if interval[0] <= current_interval[1]: # Overlapping intervals, merge them report.append({ \'before\': [current_interval, interval], \'after\': (current_interval[0], max(current_interval[1], interval[1])) }) current_interval = (current_interval[0], max(current_interval[1], interval[1])) else: # Non-overlapping interval, add the current_interval to merged_intervals merged_intervals.append(current_interval) current_interval = interval # Add the last interval merged_intervals.append(current_interval) return merged_intervals, report"},{"question":"# Determine Final Velocity of a Falling Object As part of a physics simulation, you need to compute the final velocity of an object that is dropped from a certain height above the ground. The velocity of the object just before it hits the ground can be calculated using the following formula derived from the principles of free fall: [ v = sqrt{2gh} ] where: * `v` is the final velocity of the object in meters per second (m/s). * `g` is the acceleration due to gravity (`9.8 m/s²` on the surface of the Earth). * `h` is the height from which the object is dropped in meters. Write a function `final_velocity(height: float) -> float` that takes the height from which the object is dropped and returns its final velocity before impact. **Input:** * `height` (float): The height of the object in meters, where `height >= 0`. **Output:** * Return a float representing the final velocity in meters per second. **Constraints:** * If the height is negative, raise a `ValueError` with the message \\"The height cannot be negative\\". # Example: ```python >>> final_velocity(5) 9.899494936611665 >>> final_velocity(0) 0.0 >>> final_velocity(20) 19.79898987322333 >>> final_velocity(10) 14.0 ``` *Note: The function may be tested using a Python testing library to validate correctness.*","solution":"import math def final_velocity(height: float) -> float: Calculate the final velocity of an object falling from a given height. Parameters: height (float): The height from which the object is dropped in meters, should be non-negative. Returns: float: The final velocity in meters per second. Raises: ValueError: If the height is negative. if height < 0: raise ValueError(\\"The height cannot be negative\\") g = 9.8 # acceleration due to gravity in m/s^2 return math.sqrt(2 * g * height)"},{"question":"# Coding Assessment Question Scenario: In a social media platform, influencers and users post content that receives likes. You are tasked with analyzing the popularity of posts by finding the post with the highest number of likes. Sometimes there can be multiple posts that have the highest and same number of likes. Task: Write a Python function that finds the post IDs which have the maximum number of likes. If multiple posts have the same highest number of likes, return a list of all such post IDs sorted in ascending order. Function Signature: ```python def most_liked_posts(posts: List[Tuple[int, int]]) -> List[int]: ``` Input: * A list of tuples `posts`, where each tuple consists of: * An integer `post_id` (1 ≤ post_id ≤ 10^6) - representing the unique ID of the post. * An integer `likes` (0 ≤ likes ≤ 10^9) - representing the number of likes the post has received. Output: * A list of integers representing the post IDs with the highest number of likes, sorted in ascending order. Examples: ```python assert most_liked_posts([(1, 100), (2, 200), (3, 150), (4, 200)]) == [2, 4] assert most_liked_posts([(10, 250), (11, 250), (12, 250)]) == [10, 11, 12] assert most_liked_posts([(101, 300), (102, 100), (103, 300)]) == [101, 103] assert most_liked_posts([(10, 500), (11, 1000)]) == [11] assert most_liked_posts([(1, 500), (2, 500), (3, 500), (4, 20)]) == [1, 2, 3] ``` Notes: - Ensure the function works efficiently with the upper bounds of inputs. - Pay attention to the sorting requirement for multiple posts having the same maximum number of likes.","solution":"from typing import List, Tuple def most_liked_posts(posts: List[Tuple[int, int]]) -> List[int]: if not posts: return [] max_likes = 0 result = [] for post_id, likes in posts: if likes > max_likes: max_likes = likes result = [post_id] elif likes == max_likes: result.append(post_id) return sorted(result)"},{"question":"# Scenario: You are working for a company that needs to maintain a log of user activities on their platform. The activities need to be recorded in a specific order, and the company wants to quickly access the most recent activities. # Problem Statement: Your task is to implement a class called `ActivityLog` that allows recording activities in a log and retrieving the list of the most recent activities. Implementation Requirements: - Implement the `ActivityLog` class with the following methods: - `add_activity(activity: str) -> None`: Adds a new activity to the log. - `get_recent_activities(n: int) -> List[str]`: Returns the `n` most recent activities, with the most recent activity appearing first in the list. # Constraints: 1. Activities are represented as strings. 2. The log should efficiently handle up to 10^6 activities. 3. Calls to `get_recent_activities` will always request a number `n` that does not exceed the total number of activities in the log. Example: Assuming you have an `ActivityLog` instance as follows: ```python log = ActivityLog() log.add_activity(\\"login\\") log.add_activity(\\"view_page\\") log.add_activity(\\"logout\\") ``` After adding the activities, calling `log.get_recent_activities(2)` will return `[\\"logout\\", \\"view_page\\"]`. # Instructions: 1. Implement the `ActivityLog` class with the described methods. 2. Ensure it runs correctly for the example scenarios. 3. Handle edge cases such as requesting more activities than available in the log. Good luck!","solution":"class ActivityLog: def __init__(self): self.activities = [] def add_activity(self, activity: str) -> None: self.activities.append(activity) def get_recent_activities(self, n: int) -> list: return self.activities[-n:][::-1]"},{"question":"# Text File Merger In this assessment, you are asked to implement a Python function that merges the content of two text files into a new file. This function should demonstrate your understanding of file operations, string handling, and error management in Python. Function Signature ```python def merge_files(file1_path: str, file2_path: str, output_path: str) -> bool: Merges the content of `file1` and `file2` into a new file `output_path`. :param file1_path: Path to the first text file. :param file2_path: Path to the second text file. :param output_path: Path where the merged content should be saved. :return: True if the merging is successful, False otherwise. ``` Instructions 1. **File Reading**: Open and read the content of both `file1` and `file2`. Handle cases where a file may not exist. 2. **Content Merging**: Merge the content of the two files line by line, alternating lines from each file into the new file. 3. **File Writing**: Save the merged content into `output_path`. 4. **Error Handling**: Ensure proper error handling for file read/write operations. 5. **Return Value**: Return `True` if the merging is successful, otherwise return `False`. Constraints - Assume both input files are text files with UTF-8 encoding. - Handle scenarios where the input files are of different lengths. - Ensure to close all file streams properly even in case of an error. Example Input: ```python file1_path = \\"file1.txt\\" file2_path = \\"file2.txt\\" output_path = \\"merged.txt\\" success = merge_files(file1_path, file2_path, output_path) ``` Expected Output: The function should merge the contents of `file1.txt` and `file2.txt` line by line into `merged.txt` and return `True` if the operation is successful. Important Points - Make sure to handle exceptions and edge cases, such as missing files or permission issues. - If one file is shorter, append the remaining lines of the longer file to the end of the new file.","solution":"def merge_files(file1_path: str, file2_path: str, output_path: str) -> bool: Merges the content of `file1` and `file2` into a new file `output_path`. :param file1_path: Path to the first text file. :param file2_path: Path to the second text file. :param output_path: Path where the merged content should be saved. :return: True if the merging is successful, False otherwise. try: with open(file1_path, \'r\', encoding=\'utf-8\') as file1, open(file2_path, \'r\', encoding=\'utf-8\') as file2, open(output_path, \'w\', encoding=\'utf-8\') as output_file: file1_lines = file1.readlines() file2_lines = file2.readlines() max_lines = max(len(file1_lines), len(file2_lines)) for i in range(max_lines): if i < len(file1_lines): output_file.write(file1_lines[i]) if i < len(file2_lines): output_file.write(file2_lines[i]) return True except Exception as e: print(f\\"An error occurred: {e}\\") return False"},{"question":"# Problem: Circular Array Rotation You are given an array of integers and a number of rotations that should be performed on the array. Each rotation operation involves shifting the array elements to the right by one position, with the last element wrapping around to the first position. After performing the specified number of rotations, you need to implement a function to answer queries about the new position of elements in the array. # Function Signature: ```python def circular_array_rotation(arr: List[int], rotations: int, queries: List[int]) -> List[int]: This function performs the specified number of rotations on the input array and answers questions about the new position of elements based on their original index. Args: arr (List[int]): The initial array of integers. rotations (int): The number of right rotations to perform on the array. queries (List[int]): A list of indices for which we need to return the value after rotation. Returns: List[int]: A list of integers representing the values at the queried indices after the rotations. pass ``` # Input: * `arr`: A list of integers (1 <= len(arr) <= 10^5). * `rotations`: An integer representing the number of rotations to be performed (0 <= rotations <= 10^5). * `queries`: A list of indices for which the post-rotation values need to be returned (1 <= len(queries) <= 10^5). # Output: * A list of integers representing the values at the queried indices after the rotations. # Example: ```python arr = [3, 8, 9, 7, 6] rotations = 3 queries = [0, 1, 2] result = circular_array_rotation(arr, rotations, queries) print(result) # Output: [9, 7, 6] # Explanation: # After 3 rotations, the array becomes [9, 7, 6, 3, 8]. # So, the element at index 0 is 9, at index 1 is 7, and at index 2 is 6. ``` # Hints: * Consider the effect of rotations when the number of rotations is greater than the length of the array. * Think about how to handle rotations efficiently without actually modifying the array repeatedly. * Use modulo operation to determine the new positions of elements in the array.","solution":"from typing import List def circular_array_rotation(arr: List[int], rotations: int, queries: List[int]) -> List[int]: This function performs the specified number of rotations on the input array and answers questions about the new position of elements based on their original index. Args: arr (List[int]): The initial array of integers. rotations (int): The number of right rotations to perform on the array. queries (List[int]): A list of indices for which we need to return the value after rotation. Returns: List[int]: A list of integers representing the values at the queried indices after the rotations. n = len(arr) rotations = rotations % n # Effective number of rotations # Create a rotated version of array rotated_arr = arr[-rotations:] + arr[:-rotations] # Prepare the result based on the queries result = [rotated_arr[i] for i in queries] return result"},{"question":"# K-th Smallest Element in a Sorted Matrix Given an `n x n` matrix where each of the rows and columns are sorted in ascending order, write a function `kth_smallest(matrix: List[List[int]], k: int) -> int` that returns the k-th smallest element in the matrix. **Input**: - `matrix` (List of List of int): An `n x n` 2D list where each row and column are sorted in ascending order. - `k` (int): The position (1-indexed) of the element to find. **Output**: - An integer representing the k-th smallest element in the matrix. **Constraints**: - `matrix` is a 2D list where each of the rows and columns are sorted in ascending order. - `n` is the size of the matrix (the side length). - `1 <= k <= n^2`. - You must handle invalid inputs by raising an assertion error with a message indicating the specific constraint violated. # Examples ```python kth_smallest([ [1, 5, 9], [10, 11, 13], [12, 13, 15] ], 8) # Output: 13 kth_smallest([ [-5, -4], [-3, -1] ], 2) # Output: -4 kth_smallest([], 1) # Raises AssertionError: \\"Matrix cannot be empty\\" kth_smallest([[1]], 0) # Raises AssertionError: \\"k must be within the valid range, got k=0\\" ``` # Explanation In the function `kth_smallest`, start by ensuring that the matrix is not empty and that `k` is within the valid range. Utilize a min-heap to aid in efficiently finding the k-th smallest element. By pushing the first element of each row into the heap, and then repeatedly extracting the smallest element and pushing the next element in the same row, you can systematically find the k-th smallest element in a time-efficient manner. Implement the function to manage the performance requirements and handle edge cases appropriately.","solution":"from typing import List import heapq def kth_smallest(matrix: List[List[int]], k: int) -> int: if not matrix or not matrix[0]: raise AssertionError(\\"Matrix cannot be empty\\") n = len(matrix) if k < 1 or k > n * n: raise AssertionError(f\\"k must be within the valid range, got k={k}\\") # Min-heap to store the elements min_heap = [] # Initialize the heap with the first element of each row for r in range(min(n, k)): # We only need up to the first k rows heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Iterate k-1 times to pop the smallest element while k > 0: element, r, c = heapq.heappop(min_heap) k -= 1 if k == 0: return element if c + 1 < n: # Push the next element in the same row heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))"},{"question":"# Problem Statement You are given a sequence of `n` integers representing the height of buildings aligned in a row. The width of each building is `1 unit`. You need to determine the maximum area of rectangle that can be formed in the histogram created by these aligned buildings. Each rectangle\'s width must be continuous, and the rectangle must be contained entirely within the histogram. # Objective Write a function `max_histogram_area(building_heights: List[int]) -> int` that: - Receives a list of non-negative integers `building_heights` representing the heights of buildings. - Returns the maximum rectangular area that can be formed in the histogram. # Rules & Constraints 1. The input `building_heights` will be a list of non-negative integers. 2. If the list is empty, return `0`. 3. If any value in `building_heights` is negative, raise a `ValueError` with the message: `\\"all building heights must be non-negative integers\\"`. 4. The function should be efficient enough to handle lists with up to `100,000` elements. # Examples ```python >>> max_histogram_area([2, 1, 5, 6, 2, 3]) 10 >>> max_histogram_area([1, 1, 1, 1]) 4 >>> max_histogram_area([]) 0 >>> max_histogram_area([0, 0, 0]) 0 >>> max_histogram_area([3, 6, 5, 7, 4, 8, 1, 0]) 20 >>> max_histogram_area([3, 6, -5, 7, 4]) Traceback (most recent call last): ... ValueError: all building heights must be non-negative integers ``` # Notes - Consider edge cases like empty list, consecutive buildings with the same height, and lists containing zeroes. - Demonstrate a good grasp of stack-based algorithms or any other efficient approach to solve the problem. - Optimize to handle large inputs within a reasonable amount of time.","solution":"from typing import List def max_histogram_area(building_heights: List[int]) -> int: Returns the maximum rectangular area in the histogram created by building_heights. if any(h < 0 for h in building_heights): raise ValueError(\\"all building heights must be non-negative integers\\") n = len(building_heights) if n == 0: return 0 stack = [] max_area = 0 for i in range(n): while stack and building_heights[stack[-1]] > building_heights[i]: h = building_heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) while stack: h = building_heights[stack.pop()] w = n if not stack else n - stack[-1] - 1 max_area = max(max_area, h * w) return max_area"},{"question":"# Context A company requires a scheduling system that efficiently handles meeting room reservations. Each reservation has a start and end time, and you need to ensure no two meetings overlap. The system should support adding new reservations, removing existing ones, and querying the availability of a time slot. # Task Implement a class named `MeetingScheduler`, which uses an interval tree or any efficient data structure to manage the meeting reservations. The class should support the following operations: 1. `add_reservation(self, start: int, end: int) -> None`: Adds a new reservation with the given start and end times. Raise a `ValueError` if the reservation overlaps with an existing one. 2. `remove_reservation(self, start: int, end: int) -> None`: Removes the reservation with the exact start and end times. Raise a `ValueError` if no such reservation exists. 3. `is_available(self, start: int, end: int) -> bool`: Returns `True` if the specified time slot is available (i.e., not overlapping with any existing reservation), `False` otherwise. 4. `get_all_reservations(self) -> list[tuple[int, int]]`: Returns a list of all reservations as tuples of (start, end) times, sorted by the start time. # Constraints * The start and end times are integers in the range [0, 10^6]. * The system will handle at most 10^5 reservations. # Performance Requirements Ensure all functions have efficient time complexity, aiming to keep insert, delete, and search operations within O(log n) time on average for a balanced implementation. # Class signature ```python class MeetingScheduler: def __init__(self) -> None: pass def add_reservation(self, start: int, end: int) -> None: pass def remove_reservation(self, start: int, end: int) -> None: pass def is_available(self, start: int, end: int) -> bool: pass def get_all_reservations(self) -> list[tuple[int, int]]: pass ``` # Example Usage ```python ms = MeetingScheduler() ms.add_reservation(10, 20) ms.add_reservation(30, 40) ms.add_reservation(50, 60) print(ms.is_available(20, 30)) # True print(ms.is_available(15, 25)) # False ms.remove_reservation(30, 40) print(ms.is_available(30, 40)) # True print(ms.get_all_reservations()) # [(10, 20), (50, 60)] ```","solution":"import bisect class MeetingScheduler: def __init__(self) -> None: # Store sorted list of reservations as tuples (start, end) self.reservations = [] def _find_position(self, start: int, end: int): Find insertion position using binary search to ensure efficient insertion/search/removal. return bisect.bisect_left(self.reservations, (start, end)) def add_reservation(self, start: int, end: int) -> None: if start >= end: raise ValueError(\\"Invalid reservation times: start time must be less than end time.\\") position = self._find_position(start, end) # Check for overlaps with adjacent reservations if (position > 0 and self.reservations[position - 1][1] > start) or (position < len(self.reservations) and self.reservations[position][0] < end): raise ValueError(\\"Reservation overlaps with an existing reservation.\\") # Insert the reservation while maintaining sorted order self.reservations.insert(position, (start, end)) def remove_reservation(self, start: int, end: int) -> None: position = self._find_position(start, end) if position >= len(self.reservations) or self.reservations[position] != (start, end): raise ValueError(\\"No such reservation exists.\\") # Remove the exact reservation self.reservations.pop(position) def is_available(self, start: int, end: int) -> bool: if start >= end: return False position = self._find_position(start, end) # Check if the desired slot does not overlap with surrounding reservations if (position > 0 and self.reservations[position - 1][1] > start) or (position < len(self.reservations) and self.reservations[position][0] < end): return False return True def get_all_reservations(self) -> list[tuple[int, int]]: return list(self.reservations)"},{"question":"# Problem Statement You are given a list of non-negative integers representing points scored in a game session, and a specified window size. Implement a function to calculate and return the maximum sum of points that can be obtained from any contiguous subarray of size equal to the window size. If the list is empty or the window size is larger than the elements in the array, return 0. # Function Signature ```python def max_window_sum(points: list[int], window_size: int) -> int: ``` # Input 1. `points` (list of int): A list of non-negative integers representing points scored in a game session. 2. `window_size` (int): An integer representing the size of the window to consider for summing points. # Output * `int`: The maximum sum of points from any contiguous subarray with the specified window size, or 0 if the input list is empty or if the window size is larger than the list size. # Constraints * The list can contain up to (10^6) elements. * The value of each integer in the list will be between (0) and (10^6). * The window size will be a positive integer. # Requirements * Your solution should have a time complexity of (O(N)), where (N) is the number of elements in the list. * Optimize space complexity to be (O(1)). # Example ```python assert max_window_sum([1, 2, 3, 4, 5, 6, 1], 3) == 15 assert max_window_sum([1, 2, 3, 4], 2) == 7 assert max_window_sum([1], 1) == 1 assert max_window_sum([], 3) == 0 assert max_window_sum([4, 2, 10, 1, 5, 6], 2) == 15 assert max_window_sum([2, 1, 5, 1, 3, 2], 3) == 9 ``` Consider carefully edge cases such as empty lists, where the window size equals the number of elements in the list, and when the window size is larger than the list size. Utilize a sliding window approach to efficiently compute the result.","solution":"def max_window_sum(points: list[int], window_size: int) -> int: Calculate the maximum sum of points from any contiguous subarray with the specified window size. :param points: List of non-negative integers representing points scored in a game session. :param window_size: Integer representing the size of the window to consider for summing points. :return: The maximum sum of points from any contiguous subarray with the specified window size, or 0 if conditions are not met. n = len(points) # If the list is empty or the window size is larger than the number of elements if n == 0 or window_size > n: return 0 # Calculate the sum of the first window size elements window_sum = sum(points[:window_size]) max_sum = window_sum # Use sliding window technique to find the maximum sum of a window of size k for i in range(window_size, n): window_sum += points[i] - points[i - window_size] if window_sum > max_sum: max_sum = window_sum return max_sum"},{"question":"# Coding Assessment Question: Directory Tree Listing Context: You are working with file systems and need to generate a structured representation of a directory tree. The goal is to implement a function that outputs a visually appealing and indented string representation of a directory hierarchy. Task: Implement the `directory_tree` function that lists all files and subdirectories within a given directory in an indented, hierarchical format. Function Signature: ```python def directory_tree(directory: str) -> str: pass ``` Input: - `directory` (str): Path to the directory for which the tree structure needs to be generated. Output: - A single string (`tree_structure`) representing the directory tree in an indented format similar to the output of the `tree` command in UNIX systems. Constraints: - Only include directories and files under the top-level directory provided as input. - Represent directories using a trailing slash (`/`). - The listing should include the current directory provided in the input as the top-level node. - Sub-levels should be indented with four spaces (`\\" \\"`). - Handle edge cases such as empty directories or directories containing hidden files (files starting with a `.`). Example: ```python directory = \\"path/to/directory\\" # Assuming the directory structure is as follows: # path/to/directory/ # ├── file1.txt # ├── file2.txt # ├── subdir1/ # │ ├── file3.txt # │ └── subdir2/ # │ └── file4.txt # └── .hiddenfile tree_structure = directory_tree(directory) print(tree_structure) ``` Expected output: ```plaintext directory/ file1.txt file2.txt .hiddenfile subdir1/ file3.txt subdir2/ file4.txt ``` **Note**: The function should correctly traverse the directory structure, handle edge cases, and format the output to visually represent the hierarchy and indentation levels.","solution":"import os def directory_tree(directory: str) -> str: Generates a hierarchically structured representation of the directory tree. :param directory: Top-level directory path for which the tree structure needs to be generated. :return: A string representing the directory tree. if not os.path.isdir(directory): return \\"The provided path is not a directory.\\" def build_tree(current_directory, indent=\\"\\"): tree_str = \\"\\" items = sorted(os.listdir(current_directory)) for item in items: path = os.path.join(current_directory, item) if os.path.isdir(path): tree_str += f\\"{indent}{item}/n\\" tree_str += build_tree(path, indent + \\" \\") else: tree_str += f\\"{indent}{item}n\\" return tree_str result = os.path.basename(directory.rstrip(\'/\')) + \\"/n\\" result += build_tree(directory, \\" \\") return result"},{"question":"# Genetic Algorithm for Solving the Knapsack Problem Context As a computer science enthusiast, you have been tasked with solving the classic Knapsack problem using a Genetic Algorithm. The problem is defined as follows: You have a set of items, each with a weight and a value, and a knapsack that has a maximum weight capacity. You need to determine the number of each item to include in the knapsack so that the total weight is less than or equal to the knapsack\'s capacity, and the total value is as large as possible. Task Implement a Genetic Algorithm to solve the Knapsack problem. Your implementation will: 1. Initialize a population of possible solutions. 2. Evaluate the fitness of each solution based on the total value and weight constraints. 3. Perform selection, crossover, and mutation to generate new solutions. 4. Iterate through a specified number of generations or until a stopping criterion is met. 5. Return the best solution found and its total value. Function Signature ```python def genetic_algorithm_knapsack( weights: List[int], values: List[int], max_weight: int, population_size: int = 50, crossover_rate: float = 0.8, mutation_rate: float = 0.05, generations: int = 100 ) -> Tuple[List[int], int]: # your implementation here pass ``` Input * **weights**: A list of integers representing the weights of the items. * **values**: A list of integers representing the values of the items. * **max_weight**: An integer representing the maximum weight capacity of the knapsack. * **population_size**: An integer representing the number of individuals in the population (default 50). * **crossover_rate**: A floating-point value representing the rate of crossover (default 0.8). * **mutation_rate**: A floating-point value representing the rate of mutation (default 0.05). * **generations**: An integer representing the number of generations to run the algorithm (default 100). Output * Returns a tuple containing: - A list of integers representing the number of each item included in the knapsack. - An integer representing the total value of the knapsack. Constraints * Ensure that the total weight of the knapsack does not exceed the maximum weight capacity. * Validate the implementation works correctly irrespective of the initial population. **Notes**: * Be mindful of edge cases where a valid solution might not be initially present in the population. * Test your implementation with various item lists and knapsack capacities to ensure robustness. Example ```python # Example function call solution, total_value = genetic_algorithm_knapsack( weights=[2, 3, 4, 5], values=[3, 4, 5, 6], max_weight=5, population_size=50, crossover_rate=0.8, mutation_rate=0.05, generations=100 ) print(\\"Solution:\\", solution) print(\\"Total Value:\\", total_value) ```","solution":"import random from typing import List, Tuple def genetic_algorithm_knapsack( weights: List[int], values: List[int], max_weight: int, population_size: int = 50, crossover_rate: float = 0.8, mutation_rate: float = 0.05, generations: int = 100 ) -> Tuple[List[int], int]: def generate_individual(): return [random.randint(0, 1) for _ in range(len(weights))] def generate_population(): return [generate_individual() for _ in range(population_size)] def evaluate_fitness(individual): total_weight = total_value = 0 for gene, weight, value in zip(individual, weights, values): if gene: total_weight += weight total_value += value if total_weight > max_weight: return 0 # weight limit exceeded return total_value def select_individual_by_tournament(population): tournament_size = 3 selected = random.sample(population, tournament_size) selected = sorted(selected, key=lambda x: evaluate_fitness(x), reverse=True) return selected[0] def crossover(parent1, parent2): if random.random() < crossover_rate: pt = random.randint(1, len(weights) - 1) return parent1[:pt] + parent2[pt:], parent2[:pt] + parent1[pt:] else: return parent1, parent2 def mutate(individual): for i in range(len(individual)): if random.random() < mutation_rate: individual[i] = 1 - individual[i] return individual population = generate_population() for generation in range(generations): next_generation = [] for _ in range(population_size // 2): parent1 = select_individual_by_tournament(population) parent2 = select_individual_by_tournament(population) offspring1, offspring2 = crossover(parent1, parent2) next_generation.extend([mutate(offspring1), mutate(offspring2)]) population = sorted(next_generation, key=lambda x: evaluate_fitness(x), reverse=True)[:population_size] best_individual = max(population, key=lambda x: evaluate_fitness(x)) best_value = evaluate_fitness(best_individual) return best_individual, best_value"},{"question":"# Binary Tree Traversal Task Binary trees are a foundational data structure in computer science. There are several methods to traverse a binary tree, the most common of which are in-order, pre-order, and post-order traversal methods. **In-order Traversal**: Visit the left subtree, then the root, and then the right subtree. **Pre-order Traversal**: Visit the root, then the left subtree, and then the right subtree. **Post-order Traversal**: Visit the left subtree, then the right subtree, and then the root. Your task is to implement three functions in Python to perform each of the above tree traversal methods on a given binary tree. # Function Signatures ```python def inorder_traversal(root: \'TreeNode\') -> List[int]: pass def preorder_traversal(root: \'TreeNode\') -> List[int]: pass def postorder_traversal(root: \'TreeNode\') -> List[int]: pass ``` # Input: * `root`: The root node of a binary tree, where the TreeNode class is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output: * The function should return a list of integers representing the values of the nodes visited in the traversal order. # Constraints: * The number of nodes in the tree is in the range [0, 10^4]. * `-10^5 <= Node.val <= 10^5` # Requirements: 1. Implement the traversals using both recursive and iterative approaches. 2. Raise a `ValueError` with an appropriate message if the input tree does not adhere to the specified constraints. # Examples: ```python # Example binary tree: # 1 # / # 2 3 # / # 4 5 # Example TreeNode initialization: root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) assert inorder_traversal(root) == [4, 2, 5, 1, 3] assert preorder_traversal(root) == [1, 2, 4, 5, 3] assert postorder_traversal(root) == [4, 5, 2, 3, 1] # Single node tree root = TreeNode(1) assert inorder_traversal(root) == [1] assert preorder_traversal(root) == [1] assert postorder_traversal(root) == [1] # Empty tree root = None assert inorder_traversal(root) == [] assert preorder_traversal(root) == [] assert postorder_traversal(root) == [] ``` Implement the functions in Python and test them considering the provided examples and edge cases.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): if not isinstance(val, int) or val < -10**5 or val > 10**5: raise ValueError(\\"Node value should be within the range of [-10^5, 10^5]\\") self.val = val self.left = left self.right = right def inorder_traversal(root: Optional[TreeNode]) -> List[int]: def inorder(node, result): if node: inorder(node.left, result) result.append(node.val) inorder(node.right, result) result = [] inorder(root, result) return result def preorder_traversal(root: Optional[TreeNode]) -> List[int]: def preorder(node, result): if node: result.append(node.val) preorder(node.left, result) preorder(node.right, result) result = [] preorder(root, result) return result def postorder_traversal(root: Optional[TreeNode]) -> List[int]: def postorder(node, result): if node: postorder(node.left, result) postorder(node.right, result) result.append(node.val) result = [] postorder(root, result) return result"},{"question":"**Objective**: Implement a function to perform topological sorting on a given directed acyclic graph (DAG) represented using an adjacency list. **Function Signature**: `def topological_sort(graph: Dict[int, List[int]]) -> List[int]:` **Input**: - `graph`: A dictionary where keys are node identifiers (integers) and values are lists of integers representing the nodes each key node points to. **Output**: - A list of integers representing the nodes in topologically sorted order. **Constraints**: - The graph will be a DAG with at most 1000 vertices. **Performance Requirements**: - The algorithm should run in O(V + E) time complexity, where V is the number of vertices and E is the number of edges. - The space complexity should be O(V). **Example**: ```python graph = { 5: [2, 0], 4: [0, 1], 3: [1], 2: [3], 1: [], 0: [], } print(topological_sort(graph)) # Expected Output: [4, 5, 2, 3, 1, 0] or [5, 4, 2, 3, 1, 0] or any other correct topological ordering ``` **Scenario**: In project management, tasks (nodes) need to be completed following certain dependencies (edges). A task can only begin after all its dependent tasks are completed. You are asked to generate a sequence for the task completions that adheres to these dependencies, ensuring that the project is correctly and efficiently planned. **Clarifications**: - The output list should contain all the nodes present in the graph. - There could be multiple correct answers; any valid topological order is acceptable.","solution":"from typing import List, Dict def topological_sort(graph: Dict[int, List[int]]) -> List[int]: Perform a topological sort on a given directed acyclic graph (DAG) represented using an adjacency list. Parameters: graph (Dict[int, List[int]]): The adjacency list of the graph. Returns: List[int]: A list of nodes in topologically sorted order. from collections import defaultdict, deque # Container for in-degrees of each node in_degree = defaultdict(int) for node in graph: if node not in in_degree: in_degree[node] = 0 for neighbor in graph[node]: in_degree[neighbor] += 1 # Queue to maintain nodes with zero in-degree zero_in_degree_queue = deque([node for node in in_degree if in_degree[node] == 0]) topological_order = [] while zero_in_degree_queue: current_node = zero_in_degree_queue.popleft() topological_order.append(current_node) # For all the neighbors of the current node for neighbor in graph[current_node]: in_degree[neighbor] -= 1 # If in-degree becomes zero, add it to the queue if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If topological order includes all the nodes, return it if len(topological_order) == len(graph): return topological_order else: # The graph was not a DAG or did not include all nodes raise ValueError(\\"Graph has cycles or is not a valid DAG\\") # Example usage: # graph = { # 5: [2, 0], # 4: [0, 1], # 3: [1], # 2: [3], # 1: [], # 0: [], # } # print(topological_sort(graph)) # # Expected Output: [4, 5, 2, 3, 1, 0] or [5, 4, 2, 3, 1, 0] or any other correct topological ordering"},{"question":"**String Transformation** **Background**: Working with strings and character transformations is a common problem in algorithms, often related to dynamic programming and combinatorial problems where specific change operations need to be applied. **Problem Statement**: Write a function `transform_string(s: str, transformations: List[Tuple[int, str]]) -> str` that performs a series of transformations on a given string based on specified operations. **Implementation Details**: 1. The function takes a string `s` and a list of transformations. 2. Each transformation is a tuple where the first element is the index of the character to replace, and the second element is the replacement character. 3. Apply all transformations in the order they are given to obtain the final modified string. 4. Return the final string after all transformations have been applied. **Input**: * `s` (str): A string of length `n` where 1 ≤ `n` ≤ 10^5. * `transformations` (List[Tuple[int, str]]): A list of tuples with each tuple containing an index (0 ≤ index < n) and a replacement character. The number of transformations can be up to 10^4. **Output**: * `transformed_string` (str): The transformed string after all operations have been applied. **Constraints**: * The input string `s` will have only lowercase alphabetical characters. * Each index specified in the transformations is valid and within the bounds of the string `s`. * Replacement character will be a lowercase alphabetical character. **Performance Requirements**: * Your implementation should efficiently handle the given constraints. **Example**: ```python # Example 1 s = \\"abcdef\\" transformations = [(0, \'z\'), (4, \'y\')] \'\'\' Transformations: 1. Replace character at index 0 with \'z\': \\"zbcdef\\" 2. Replace character at index 4 with \'y\': \\"zbcdyf\\" \'\'\' assert transform_string(s, transformations) == \\"zbcdyf\\" # Example 2 s = \\"hello\\" transformations = [(1, \'a\'), (3, \'p\'), (4, \'y\')] \'\'\' Transformations: 1. Replace character at index 1 with \'a\': \\"hallo\\" 2. Replace character at index 3 with \'p\': \\"halpo\\" 3. Replace character at index 4 with \'y\': \\"halpy\\" \'\'\' assert transform_string(s, transformations) == \\"halpy\\" ``` *Note*: Ensure your function handles edge cases properly as highlighted in the analysis.","solution":"from typing import List, Tuple def transform_string(s: str, transformations: List[Tuple[int, str]]) -> str: s_list = list(s) for index, char in transformations: s_list[index] = char return \'\'.join(s_list)"},{"question":"# Problem Statement Design a file system simulation that can handle a series of file manipulation commands. Your task is to implement a class called `FileSystem` that supports the following functionalities: 1. Creating a file with a given name and content. 2. Appending content to an existing file. 3. Reading the content of a file. 4. Deleting a file from the system. Implement the class with the following methods: ```python class FileSystem: def __init__(self): Initializes the file system with an empty structure. pass def create_file(self, name: str, content: str) -> None: Creates a new file with the given name and content. Parameters: - name: The name of the file to be created. - content: The initial content of the file. Raises: - ValueError: If a file with the given name already exists. pass def append_content(self, name: str, content: str) -> None: Appends content to an existing file. Parameters: - name: The name of the file to be appended to. - content: The content to append to the file. Raises: - ValueError: If the file does not exist. pass def read_file(self, name: str) -> str: Reads the content of the file with the given name. Parameters: - name: The name of the file to be read. Returns: - The content of the file as a string. Raises: - ValueError: If the file does not exist. pass def delete_file(self, name: str) -> None: Deletes the file with the given name from the system. Parameters: - name: The name of the file to be deleted. Raises: - ValueError: If the file does not exist. pass ``` # Input/Output Format - **Input**: Each method accepts parameters as described above. - **Output**: Methods do not return any output except for `read_file`, which returns the content of the file. # Constraints - File names will be unique, case-sensitive strings of 1 to 100 characters. - File content will be string data of arbitrary length, but should be handled efficiently. - Assume the file system is initially empty. # Example ```python fs = FileSystem() fs.create_file(\\"example.txt\\", \\"Hello, World!\\") fs.append_content(\\"example.txt\\", \\" Welcome to the file system.\\") content = fs.read_file(\\"example.txt\\") assert content == \\"Hello, World! Welcome to the file system.\\" fs.delete_file(\\"example.txt\\") fs.read_file(\\"example.txt\\") # Should raise ValueError ``` # Implementation Tips - Use a dictionary to store filenames as keys and file content as values. - Make sure to handle edge cases like trying to read, append, or delete files that do not exist. - Ensure that creating a file with an existing name raises a `ValueError`.","solution":"class FileSystem: def __init__(self): Initializes the file system with an empty structure. self.files = {} def create_file(self, name: str, content: str) -> None: Creates a new file with the given name and content. Parameters: - name: The name of the file to be created. - content: The initial content of the file. Raises: - ValueError: If a file with the given name already exists. if name in self.files: raise ValueError(\\"File already exists\\") self.files[name] = content def append_content(self, name: str, content: str) -> None: Appends content to an existing file. Parameters: - name: The name of the file to be appended to. - content: The content to append to the file. Raises: - ValueError: If the file does not exist. if name not in self.files: raise ValueError(\\"File does not exist\\") self.files[name] += content def read_file(self, name: str) -> str: Reads the content of the file with the given name. Parameters: - name: The name of the file to be read. Returns: - The content of the file as a string. Raises: - ValueError: If the file does not exist. if name not in self.files: raise ValueError(\\"File does not exist\\") return self.files[name] def delete_file(self, name: str) -> None: Deletes the file with the given name from the system. Parameters: - name: The name of the file to be deleted. Raises: - ValueError: If the file does not exist. if name not in self.files: raise ValueError(\\"File does not exist\\") del self.files[name]"},{"question":"**Question: Sort Colors** Sorting a small discrete set of values can often be optimized beyond general-purpose sorting algorithms. One well-known example is sorting an array consisting of only a few distinct colors. You are tasked with implementing a function that sorts an array of n objects colored red, white, or blue, where the colors are represented by the integers 0, 1, and 2 respectively. Your function should sort the array in-place and must use constant space. # Function Specification **Function**: `sort_colors` **Input**: * `nums` (List[int]): A list of integers where each integer is either 0, 1, or 2. **Output**: * None. The `nums` list should be sorted in-place. # Constraints 1. The length of `nums` is n where 1 <= n <= 300. 2. Each element in `nums` is either 0, 1, or 2. # Requirements * Implement the **Dutch National Flag algorithm** by Edsger W. Dijkstra. * Ensure the solution sorts the array in a single pass using constant extra space. # Example ```python >>> nums = [2, 0, 2, 1, 1, 0] >>> sort_colors(nums) >>> nums [0, 0, 1, 1, 2, 2] >>> nums = [1, 2, 0] >>> sort_colors(nums) >>> nums [0, 1, 2] >>> nums = [0, 0, 0, 0] >>> sort_colors(nums) >>> nums [0, 0, 0, 0] >>> nums = [2, 2, 1, 1, 0, 0] >>> sort_colors(nums) >>> nums [0, 0, 1, 1, 2, 2] ``` # Function Signature ```python from typing import List def sort_colors(nums: List[int]) -> None: pass ``` Implement the function `sort_colors` to meet the requirements and constraints laid out in the problem description.","solution":"from typing import List def sort_colors(nums: List[int]) -> None: Sorts the input list nums in-place such that all 0s come first, followed by all 1s, and then all 2s at the end. # Define pointers for current position, left boundary of 1s and right boundary of 1s low, mid, high = 0, 0, len(nums) - 1 # Traverse the list with the mid pointer while mid <= high: if nums[mid] == 0: # Swap the elements at low and mid and move both pointers forward nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: # Move the mid pointer forward mid += 1 else: # Swap the elements at mid and high and move the high pointer backward nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"# Problem Description: Array Rotation Given an array `arr` of integers and an integer `k`, write a class named `ArrayRotator`. This class should contain methods to rotate the array to the right by `k` steps. The rotation means that each element of the array will shift to its right by `k` positions and the elements at the end will wrap around back to the start of the array. # Objectives - Implement a class `ArrayRotator` with the following methods: - `__init__(self, arr, k)`: Initializes the object with the array `arr` and the integer `k`. - `rotate(self)`: Rotates the array by `k` steps and returns the rotated array. - Ensure the solution is efficient in both time and space complexity. # Input Format - List of integers `arr`. - An integer `k`, indicating the number of steps to rotate the array. # Output Format - A list of integers representing the rotated array. # Constraints - `1 <= len(arr) <= 10^5` - `-10^4 <= arr[i] <= 10^4` - `0 <= k <= 10^5` # Performance Requirements - Aim for **O(n)** time complexity, where `n` is the length of the array. - Use O(1) additional space (excluding the input and output arrays). # Example 1 ```python arr = [1, 2, 3, 4, 5] k = 2 rotator = ArrayRotator(arr, k) print(rotator.rotate()) # Output: [4, 5, 1, 2, 3] ``` # Example 2 ```python arr = [-1, -100, 3, 99] k = 1 rotator = ArrayRotator(arr, k) print(rotator.rotate()) # Output: [99, -1, -100, 3] ``` # Notes - Pay attention to cases where `k` is greater than the length of the list. - Ensure that your solution does not mutate the input array directly if it is not allowed by the use case; instead, work with a copy of the array if necessary.","solution":"class ArrayRotator: def __init__(self, arr, k): self.arr = arr self.k = k def rotate(self): n = len(self.arr) k = self.k % n # to handle cases where k > n # Rotating the array by slicing return self.arr[-k:] + self.arr[:-k]"},{"question":"# Binary Search Tree Balancing You are tasked with implementing a function `balance_bst` that takes the root of a Binary Search Tree (BST) and returns a new root of a height-balanced BST with the same node values. A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than 1. Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def balance_bst(root: TreeNode) -> TreeNode: Given the root of a Binary Search Tree, return a balanced Binary Search Tree with the same node values. Parameters: root (TreeNode): The root of the unbalanced BST. Returns: TreeNode: The root of the balanced BST. pass ``` Requirements 1. **Input/Output**: - **Input**: - `root` (TreeNode): The root node of the input BST. - **Output**: - `TreeNode`: The root node of the balanced BST. 2. **Implementation Details**: - Create a function to perform an in-order traversal of the BST to get a sorted list of node values. - Create a helper function to build a balanced BST from the sorted list. - Ensure the balanced BST maintains the order and properties of a Binary Search Tree. 3. **Helper Functions**: - `inorder_traversal`: Perform in-order traversal to retrieve node values in sorted order. - `sorted_array_to_bst`: Construct a balanced BST from the sorted array of node values. 4. **Performance**: - Focus on clarity, proper use of recursion, and ensuring your algorithm handles large trees efficiently. Example ```python # Define the TreeNode class and example input tree class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def print_bst_inorder(root): return ( print_bst_inorder(root.left) + [root.val] + print_bst_inorder(root.right) if root else [] ) # Example tree construction root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) root.right.right.right = TreeNode(4) root.right.right.right.right = TreeNode(5) # Balancing the BST balanced_root = balance_bst(root) print(\\"Balanced BST In-order Traversal:\\", print_bst_inorder(balanced_root)) ``` Your task is to implement the `balance_bst` function to achieve the expected functionality.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def balance_bst(root: TreeNode) -> TreeNode: Given the root of a Binary Search Tree, return a balanced Binary Search Tree with the same node values. # Helper function to perform in-order traversal and return sorted list of values def inorder_traversal(node): if not node: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) # Helper function to construct a balanced BST from a sorted list def sorted_array_to_bst(nums): if not nums: return None mid = len(nums) // 2 node = TreeNode(nums[mid]) node.left = sorted_array_to_bst(nums[:mid]) node.right = sorted_array_to_bst(nums[mid + 1:]) return node # Get the in-order traversal of the original BST sorted_values = inorder_traversal(root) # Construct and return a balanced BST from the sorted values return sorted_array_to_bst(sorted_values)"},{"question":"# Problem Statement **Context**: As a software engineer at a logistics company, you are tasked with optimizing route schedules. One of your key responsibilities is to design a function that can detect the most common routes taken by delivery trucks. Task Write a Python function `most_common_routes` that identifies the most frequent routes taken from a list of routes. Each route is represented as a list of strings indicating the stops made by the truck in a single trip. Requirements: * The function should handle empty lists and lists with single routes gracefully. * In case of ties (multiple routes having the same frequency), all tied routes should be returned. * The order of the returned routes doesn\'t matter. Function Signature ```python def most_common_routes(routes: List[List[str]]) -> List[List[str]]: pass ``` # Input * `routes`: A list of lists of strings, where each inner list represents a route taken by a truck. # Output * A list of lists of strings, where each inner list represents one of the most common routes. # Constraints * The length of `routes` will be between `0` and `10^5`. * Each route (inner list) will contain between `1` and `100` stops. * Each stop (string) will have a length between `1` and `100`. # Example ```python >>> most_common_routes([[\\"A\\", \\"B\\", \\"C\\"], [\\"A\\", \\"B\\", \\"C\\"], [\\"D\\", \\"E\\", \\"F\\"], [\\"A\\", \\"B\\", \\"C\\"], [\\"D\\", \\"E\\", \\"F\\"], [\\"G\\", \\"H\\"]]) [[\'A\', \'B\', \'C\']] >>> most_common_routes([[\\"A\\", \\"B\\"], [\\"C\\", \\"D\\"], [\\"A\\", \\"B\\", \\"C\\"], [\\"C\\", \\"D\\"]]) [[\'A\', \'B\'], [\'C\', \'D\']] ``` # Note * If the input list is empty, the function should return an empty list. * Use a dictionary or `collections.Counter` to track the frequency of each route.","solution":"from typing import List from collections import Counter def most_common_routes(routes: List[List[str]]) -> List[List[str]]: if not routes: return [] route_counter = Counter(tuple(route) for route in routes) max_freq = max(route_counter.values(), default=0) most_common = [list(route) for route, freq in route_counter.items() if freq == max_freq] return most_common"},{"question":"# Jewel Heist Journey A team of thieves is planning a heist on a sequence of houses, where each house contains a certain amount of jewels. The team wants to maximize the amount of jewels they can steal. However, to avoid triggering the alarm, they cannot steal from two consecutive houses. **Objective**: Write a function `maximum_jewels(houses: List[int]) -> int` that returns the maximum number of jewels the thieves can steal without robbing two consecutive houses. **Function Signature**: ```python def maximum_jewels(houses: List[int]) -> int: pass ``` **Input**: - `houses` (List[int]): a list of non-negative integers where each integer represents the amount of jewels in each house. **Output**: - Returns the maximum number of jewels that can be stolen without triggering the alarm. **Example**: ```python >>> maximum_jewels([2, 3, 2]) 4 >>> maximum_jewels([1, 2, 3, 1]) 4 >>> maximum_jewels([5, 5, 10, 100, 10, 5]) 110 ``` # Detailed Requirements: Your function should: 1. Iterate through the list of houses and use dynamic programming to keep track of the maximum jewels that can be stolen up to each house. 2. Ensure that no two consecutive houses are robbed. 3. Return the maximum value possible according to the aforementioned rules. # Constraints: - The length of the list `houses` will be between `0` and `100`, inclusive. - Each element in the list will be between `0` and `1000`, inclusive. # Notes: - If there are no houses (`houses` is an empty list), the result should be `0`. - The function should handle edge cases such as list length of `1` or `2` efficiently. - Use regular arithmetic operations and list indexing to keep track of solutions and optimize the heist strategy. **Hint**: Consider using an array to keep track of the maximum jewels stolen up to each house, leveraging the previous states to make decisions for the current house.","solution":"from typing import List def maximum_jewels(houses: List[int]) -> int: if not houses: return 0 if len(houses) == 1: return houses[0] if len(houses) == 2: return max(houses[0], houses[1]) dp = [0] * len(houses) dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, len(houses)): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[-1]"},{"question":"# Context You are designing a system that implements dynamic scheduling for a multitasking environment. To efficiently manage task scheduling based on priority and execution order, you need to develop a specialized heap that supports both min-heap and max-heap operations simultaneously. # Problem Statement Implement a **DualHeap** class that maintains two heaps (one min-heap and one max-heap) to enable efficient insertion, deletion, and dynamic median computation. # Function Requirements 1. **Initializer**: `__init__(self) -> None` - Initialize two heaps (min-heap and max-heap). 2. **Insert**: `insert(self, value: int) -> None` - Insert a value into the appropriate heap. - Time Complexity: (O(log n)) 3. **Delete**: `delete(self, value: int) -> None` - Remove a value from the heaps. - Time Complexity: (O(log n)) 4. **Get Median**: `get_median(self) -> float` - Get the median value of all inserted values. If there is an even number of values, return the average of the two middle values. - Time Complexity: (O(1)) 5. **Get Min**: `get_min(self) -> int` - Get the minimum value from the min-heap. - Time Complexity: (O(1)) 6. **Get Max**: `get_max(self) -> int` - Get the maximum value from the max-heap. - Time Complexity: (O(1)) # Input Format - Inputs differ for each function and are described above where applicable. # Output Format - Outputs should match the function descriptions mentioned above. # Constraints - You may assume that the value for all **insert** and **delete** operations will always be integers within the range ([-10^9, 10^9]). - The function `get_median` must handle both integer and floating-point results depending on the context. # Example ```python # Initializing the dual heap heap = DualHeap() # Inserting values heap.insert(10) heap.insert(5) heap.insert(15) heap.insert(20) # Getting the median print(heap.get_median()) # Outputs 12.5 # Getting the minimum value print(heap.get_min()) # Outputs 5 # Getting the maximum value print(heap.get_max()) # Outputs 20 # Deleting a value heap.delete(10) # Getting the median again print(heap.get_median()) # Outputs 10 # Getting the minimum value after deletion print(heap.get_min()) # Outputs 5 # Getting the maximum value after deletion print(heap.get_max()) # Outputs 20 ```","solution":"import heapq class DualHeap: def __init__(self) -> None: self.min_heap = [] self.max_heap = [] self.elements = set() def insert(self, value: int) -> None: # Insert value into both heaps heapq.heappush(self.min_heap, value) heapq.heappush(self.max_heap, -value) self.elements.add(value) def delete(self, value: int) -> None: # Lazy deletion: mark the value to be deleted and clean up on access if value in self.elements: self.elements.remove(value) else: raise ValueError(\\"Value not found in heaps\\") def get_median(self) -> float: valid_min_heap = [x for x in self.min_heap if x in self.elements] valid_max_heap = [-x for x in self.max_heap if -x in self.elements] if not valid_min_heap or not valid_max_heap: raise ValueError(\\"Heap is empty\\") min_len = len(valid_min_heap) max_len = len(valid_max_heap) if min_len == max_len: return (valid_min_heap[0] + valid_max_heap[0]) / 2.0 elif min_len > max_len: return float(valid_min_heap[0]) else: return float(valid_max_heap[0]) def get_min(self) -> int: while self.min_heap[0] not in self.elements: heapq.heappop(self.min_heap) return self.min_heap[0] def get_max(self) -> int: while -self.max_heap[0] not in self.elements: heapq.heappop(self.max_heap) return -self.max_heap[0]"},{"question":"# Task: Movie Rental System with Late Fee Calculation A movie rental system charges a fee based on how long a movie is rented. If a movie is returned late, an additional late fee is charged per day. Your task is to calculate the total rental fee including any late fees if applicable. Function Signature ```python def calculate_rental_fee( daily_fee: float, rental_days: int, return_days: int, late_fee_per_day: float ) -> float: ``` Parameters - **daily_fee** (*float*): The fee charged per day for renting the movie. - **rental_days** (*int*): The number of days the movie was originally rented for. - **return_days** (*int*): The number of days after renting that the movie is actually returned. - **late_fee_per_day** (*float*): The additional fee charged per day after the due date. All parameters must be non-negative. If any parameter is negative, raise a `ValueError` with the message `\\"All parameters must be non-negative.\\"` Output - **Returns** (*float*): The total fee for renting the movie, including any late fees. Requirements 1. The total rental fee should be calculated as: [ text{Total Fee} = (text{daily_fee} times text{rental_days}) + (text{late_fee_per_day} times text{late_days}) ] where `late_days` is the number of days the movie is returned late (i.e., `max(0, return_days - rental_days)`). 2. Ensure that all parameters are non-negative and raise a `ValueError` for any negative values. Example ```python # Example 1: rental_fee = calculate_rental_fee(5.0, 3, 5, 2.0) print(rental_fee) # Output: 19.0 # Example 2: rental_fee = calculate_rental_fee(7.0, 2, 2, 3.0) print(rental_fee) # Output: 14.0 # Example 3: rental_fee = calculate_rental_fee(8.0, 4, 4, 1.5) print(rental_fee) # Output: 32.0 ``` You are required to write well-documented, readable, and efficient code to achieve this.","solution":"def calculate_rental_fee(daily_fee: float, rental_days: int, return_days: int, late_fee_per_day: float) -> float: Calculate the total rental fee including any late fees if applicable. Parameters: daily_fee (float): The fee charged per day for renting the movie. rental_days (int): The number of days the movie was originally rented for. return_days (int): The number of days after renting that the movie is actually returned. late_fee_per_day (float): The additional fee charged per day after the due date. Returns: float: The total fee for renting the movie, including any late fees. Raises: ValueError: If any parameter is negative. if daily_fee < 0 or rental_days < 0 or return_days < 0 or late_fee_per_day < 0: raise ValueError(\\"All parameters must be non-negative.\\") late_days = max(0, return_days - rental_days) total_fee = (daily_fee * rental_days) + (late_fee_per_day * late_days) return total_fee"},{"question":"# Unique Number in a Singly Linked List Scenario You are given a singly linked list where every number appears exactly twice except for one number which appears only once. Your task is to find the unique number in the linked list. Task You need to define a function `findUniqueNumber` that takes the head of a singly linked list and returns the unique number. Function Signature ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def findUniqueNumber(head: ListNode) -> int: pass ``` Requirements 1. **Input**: The input is the head node of a singly linked list. 2. **Output**: The output should be the unique number that appears only once in the linked list. 3. **Constraints**: * The number of nodes `n` in the linked list will be in the range `1 <= n <= 10^5`. * All node values are integers and within the range `−10^9 <= node.value <= 10^9`. Example ```python # Example 1 # Input: 1 -> 2 -> 3 -> 2 -> 1 # Output: 3 # Example 2 # Input: 4 -> 1 -> 2 -> 1 -> 2 # Output: 4 # Example 3 # Input: 7 -> 5 -> 7 # Output: 5 # Helper code to create linked list and find unique number def create_linked_list(values): if not values: return None head = ListNode(values[0]) current = head for value in values[1:]: current.next = ListNode(value) current = current.next return head # Creating linked list for example 1 values = [1, 2, 3, 2, 1] head = create_linked_list(values) print(findUniqueNumber(head)) # Output: 3 # Creating linked list for example 2 values = [4, 1, 2, 1, 2] head = create_linked_list(values) print(findUniqueNumber(head)) # Output: 4 # Creating linked list for example 3 values = [7, 5, 7] head = create_linked_list(values) print(findUniqueNumber(head)) # Output: 5 ``` Solution Outline - Traverse the linked list and use a dictionary to count occurrences of each number. - Traverse the dictionary to find the number with a count of one. - Return the unique number.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def findUniqueNumber(head: ListNode) -> int: # Dictionary to hold the count of each number count_dict = {} current = head # Traverse the linked list to count occurrences of each number while current: if current.value in count_dict: count_dict[current.value] += 1 else: count_dict[current.value] = 1 current = current.next # Traverse the dictionary to find the number with a count of one for number, count in count_dict.items(): if count == 1: return number"},{"question":"# Sort a List of Words by Length **Scenario**: You are a software engineer tasked with developing a function that sorts a list of words based on their lengths. The goal is to order the words such that shorter words appear before longer ones. If two words have the same length, their order relative to each other should remain unchanged (i.e., retain their original order). **Task**: Implement a function that takes a list of words and returns a new list with the words sorted by their lengths. Ensure the function preserves the relative order of words that have the same length, achieving stability in the sorting process. **Function Signature**: ```python def sort_by_length(words: list) -> list: Sorts the input list of words based on their length. Args: words (list): the list of words to be sorted. Returns: list: a new list with words sorted by length. ``` **Input**: - `words`: a list of strings where `0 <= len(words) <= 10^4` and `1 <= len(words[i]) <= 50`. **Output**: - The function should return a new list with the words sorted by their lengths in ascending order. **Constraints**: - The function should preserve the original relative order of words that have the same length (stable sort). **Examples**: ```python # Sample Input/Output 1 >>> sort_by_length([\\"python\\", \\"is\\", \\"awesome\\", \\"and\\", \\"fun\\"]) [\\"is\\", \\"and\\", \\"fun\\", \\"python\\", \\"awesome\\"] # Sample Input/Output 2 >>> sort_by_length([\\"quick\\", \\"brown\\", \\"fox\\", \\"jumps\\", \\"over\\", \\"the\\", \\"lazy\\", \\"dog\\"]) [\\"fox\\", \\"the\\", \\"dog\\", \\"over\\", \\"lazy\\", \\"quick\\", \\"brown\\", \\"jumps\\"] # Sample Input/Output 3 >>> sort_by_length([\\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\"]) [\\"one\\", \\"two\\", \\"four\\", \\"five\\", \\"three\\"] # Sample Input/Output 4 >>> sort_by_length([\\"a\\", \\"list\\", \\"of\\", \\"varied\\", \\"length\\"]) [\\"a\\", \\"of\\", \\"list\\", \\"length\\", \\"varied\\"] # Sample Input/Output 5 >>> sort_by_length([]) [] ``` **Requirements**: - Ensure that your solution efficiently handles the given constraints. - Consider using a key function in the sorting process to maintain stability. - Add test cases to validate the correctness and stability of the sort.","solution":"def sort_by_length(words): Sorts the input list of words based on their length. Args: words (list): the list of words to be sorted. Returns: list: a new list with words sorted by length. # Using sorted function with key based on length to ensure stability return sorted(words, key=len)"},{"question":"# Coding Assignment: Implement a Custom Binary Search Tree with Unique Features Scenario You are a software engineer at a tech company tasked with developing a custom Binary Search Tree (BST) with additional functionality for a client’s proprietary database management system. The BST should support insertion, deletion, and searching of nodes while ensuring the tree remains balanced for optimal performance in lookups and modifications. Problem Statement Implement a custom Binary Search Tree (BST) class with the following features: 1. Standard BST operations: insert(), delete(), search(). 2. A function to find the kth smallest element in the tree. 3. A function to balance the tree after every insertion and deletion to ensure optimal performance. Requirements 1. **Class Signature**: Define a class `CustomBST` with methods: - `insert(self, key: int) -> None` - `delete(self, key: int) -> None` - `search(self, key: int) -> bool` - `find_kth_smallest(self, k: int) -> int` - `balance(self) -> None` 2. **Method Descriptions**: - `insert(key: int)`: Inserts a node with the specified key into the BST. - `delete(key: int)`: Deletes the node with the specified key from the BST. - `search(key: int)`: Returns True if a node with the specified key exists in the BST, otherwise False. - `find_kth_smallest(k: int)`: Returns the k-th smallest element in the BST. - `balance()`: Balances the BST to ensure minimal height. 3. **Constraints**: - The BST should handle large datasets efficiently (10,000+ elements). - All keys are unique integers. - The tree must be balanced after every insertion and deletion to optimize search and modification operations. 4. **Performance Requirements**: - Aim for solutions that maintain logarithmic time complexity for searches, insertions, and deletions. - Ensure the balancing operation executes within a reasonable timeframe for large datasets. Example ```python bst = CustomBST() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) assert bst.search(7) == True assert bst.search(1) == False assert bst.find_kth_smallest(3) == 7 bst.delete(5) assert bst.search(5) == False bst.balance() ``` Notes 1. Implement the class `CustomBST` with the described methods and features. 2. Consider using data structures such as AVL Tree or Red-Black Tree for self-balancing. 3. Ensure your implementation can handle various edge cases, such as inserting into an empty tree or deleting the only node in the tree. 4. Test your implementation with a variety of inputs to ensure robustness and efficiency.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class CustomBST: def __init__(self): self.root = None def insert(self, key: int) -> None: self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._balance(node) def delete(self, key: int) -> None: self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node elif key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._get_min_value_node(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._balance(node) def search(self, key: int) -> bool: return self._search(self.root, key) def _search(self, node, key): if not node: return False if node.key == key: return True elif key < node.key: return self._search(node.left, key) else: return self._search(node.right, key) def find_kth_smallest(self, k: int) -> int: count = [0] result = [None] self._find_kth_smallest(self.root, k, count, result) return result[0] def _find_kth_smallest(self, node, k, count, result): if not node or result[0] is not None: return self._find_kth_smallest(node.left, k, count, result) count[0] += 1 if count[0] == k: result[0] = node.key return self._find_kth_smallest(node.right, k, count, result) def balance(self) -> None: keys = [] self._inorder_traversal(self.root, keys) self.root = self._sorted_array_to_bst(keys, 0, len(keys) - 1) def _inorder_traversal(self, node, keys): if node: self._inorder_traversal(node.left, keys) keys.append(node.key) self._inorder_traversal(node.right, keys) def _sorted_array_to_bst(self, keys, start, end): if start > end: return None mid = (start + end) // 2 node = TreeNode(keys[mid]) node.left = self._sorted_array_to_bst(keys, start, mid - 1) node.right = self._sorted_array_to_bst(keys, mid + 1, end) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return node def _get_height(self, node): return node.height if node else 0 def _get_min_value_node(self, node): current = node while current.left is not None: current = current.left return current def _balance(self, node): if not node: return node balance_factor = self._get_balance_factor(node) if balance_factor > 1: if self._get_balance_factor(node.left) < 0: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance_factor < -1: if self._get_balance_factor(node.right) > 0: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _get_balance_factor(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y"},{"question":"Problem Description You are given an integer array and a target sum. Your task is to write a function that checks whether there exist two distinct indices in the array such that the elements at those indices sum up to the target sum. # Requirements 1. Implement a method `find_two_sum_indices` to determine if two such indices exist. 2. If such indices exist, return them as a tuple `(index1, index2)` in ascending order of indices. 3. If no such indices exist, raise a `ValueError` with a descriptive message. # Input and Output * **Input**: * A list of integers, e.g., `[1, 2, 3, 4, 5]`. * An integer representing the target sum. * **Output**: * A tuple of two integers representing the indices, e.g., `(0, 3)`. * If no such indices exist, raise a `ValueError` with a descriptive message. # Constraints * The array contains at least two elements. * The array consists of integers. * Indices are zero-based. # Example Scenarios 1. **Example 1**: * Array: `[2, 7, 11, 15]` * Target Sum: `9` * Expected Output: `(0, 1)` 2. **Example 2**: * Array: `[3, 2, 4]` * Target Sum: `6` * Expected Output: `(1, 2)` 3. **Example 3**: * Array: `[1, 2, 3, 4, 5]` * Target Sum: `10` * Expected Output: Raise `ValueError` with the message `\\"No two sum solution for target 10\\"` # Implementation Template ```python def find_two_sum_indices(nums, target): Determine if two distinct indices exist such that the elements at those indices sum to the target. :param nums: List of integers. :param target: Integer representing the target sum. :return: Tuple of two integers representing the indices. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i raise ValueError(f\\"No two sum solution for target {target}\\") ``` Complete the method `find_two_sum_indices` to fulfill the requirements specified. Implement the algorithm correctly to ensure accurate identification of the indices that sum up to the target value.","solution":"def find_two_sum_indices(nums, target): Determine if two distinct indices exist such that the elements at those indices sum to the target. :param nums: List of integers. :param target: Integer representing the target sum. :return: Tuple of two integers representing the indices. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i raise ValueError(f\\"No two sum solution for target {target}\\")"},{"question":"# Problem Statement Create a function that simulates a basic **bank account system** that supports deposit, withdrawal, and balance inquiry operations. You need to ensure that only valid transactions are performed and that the account balance never becomes negative. # Requirements 1. **Deposit Method**: Allows the user to deposit a specified amount into the account. 2. **Withdrawal Method**: Allows the user to withdraw a specified amount from the account, as long as the balance is sufficient for the withdrawal. 3. **Balance Inquiry Method**: Allows the user to check the current balance of the account. # Input/Output - **Input**: The operations (`\\"deposit\\", \\"withdraw\\", \\"balance\\"`) along with their respective parameters. - **Output**: The current balance of the account after each valid transaction. # Constraints 1. The deposit amount must be a positive integer. 2. The withdrawal amount must be a positive integer and less than or equal to the current balance. 3. For simplicity, assume that the balance starts at zero and there are no overdraft fees. # Function Signature ```python class BankAccount: def __init__(self): pass def deposit(self, amount: int) -> None: pass def withdraw(self, amount: int) -> bool: pass def balance(self) -> int: pass ``` # Example ```python # Example Usage: account = BankAccount() account.deposit(100) print(account.balance()) # Outputs: 100 result = account.withdraw(50) print(result) # Outputs: True print(account.balance()) # Outputs: 50 result = account.withdraw(60) print(result) # Outputs: False print(account.balance()) # Outputs: 50 ``` # Implementation Details 1. The `__init__` method initializes the account with a balance of zero. 2. The `deposit` method increases the account balance by the specified amount. 3. The `withdraw` method decreases the account balance by the specified amount if there are sufficient funds and returns `True`. Otherwise, it returns `False`. 4. The `balance` method returns the current balance of the account.","solution":"class BankAccount: def __init__(self): self._balance = 0 def deposit(self, amount: int) -> None: if amount > 0: self._balance += amount def withdraw(self, amount: int) -> bool: if 0 < amount <= self._balance: self._balance -= amount return True else: return False def balance(self) -> int: return self._balance"},{"question":"# Problem Statement Write a function that converts a given positive integer into its equivalent Roman numeral representation. The function should handle numbers from 1 to 3999. Implement the following function: 1. `int_to_roman(num: int) -> str` Function Definition * **`int_to_roman`**: * **Input**: * `num` (int): The integer value to be converted to a Roman numeral. * **Output**: * `str`: The Roman numeral representation of the input number. Roman Numeral Rules Roman numerals are represented by combinations of the following symbols: * `I`: 1 * `V`: 5 * `X`: 10 * `L`: 50 * `C`: 100 * `D`: 500 * `M`: 1000 There are rules to combine these symbols: * Numbers are formed by combining symbols and their values. * Symbols are placed in order from left to right, starting with the largest value to create the largest possible numeral. * When a smaller numeral appears before a larger numeral, it is subtracted; otherwise, it is added: * For example: `IV` (4), `IX` (9), `XL` (40), `XC` (90), `CD` (400), `CM` (900) Constraints * `num` should be a positive integer between 1 and 3999 inclusive. * If `num` is outside this range, raise a `ValueError` with the message: `\\"int_to_roman() requires a positive integer between 1 and 3999\\"`. Examples * `int_to_roman(58)` should return `\\"LVIII\\"`. * `int_to_roman(1994)` should return `\\"MCMXCIV\\"`. * `int_to_roman(4000)` should raise a `ValueError`.","solution":"def int_to_roman(num): Convert a given positive integer into its equivalent Roman numeral representation. Handles numbers from 1 to 3999. if num < 1 or num > 3999: raise ValueError(\\"int_to_roman() requires a positive integer between 1 and 3999\\") val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_numeral = \\"\\" for i in range(len(val)): while num >= val[i]: num -= val[i] roman_numeral += syb[i] return roman_numeral"},{"question":"# Graph Connectivity Check Graph data structures are widely used to represent interconnected data and are crucial in various applications like social networks, transportation systems, and computer networks. # Problem Statement Given an undirected graph represented as an adjacency list, implement two functionalities to enhance the graph\'s analysis capability: 1. **Check Connected**: - Implement a method `is_connected() -> bool` that checks if the graph is connected. A graph is considered connected if there is a path between any two nodes. 2. **Find Components**: - Implement a method `connected_components() -> List[List[int]]` that returns all the connected components of the graph. Each component is represented as a list of nodes. # Expected Methods Implementation `is_connected` Method - **Input**: None. - **Output**: A boolean `True` if the graph is connected, `False` otherwise. - **Constraints**: Ensure O(V + E) time complexity for the connectivity check, where V is the number of vertices and E is the number of edges. `connected_components` Method - **Input**: None. - **Output**: A list of lists where each inner list contains nodes belonging to the same connected component. - **Constraints**: Ensure O(V + E) time complexity for finding all connected components. # Example Here\'s an example scenario and expected output: ```python graph = Graph() graph.add_edge(1, 2) graph.add_edge(2, 3) graph.add_edge(4, 5) assert graph.is_connected() == False assert sorted([sorted(component) for component in graph.connected_components()]) == [[1, 2, 3], [4, 5]] graph.add_edge(3, 4) assert graph.is_connected() == True assert graph.connected_components() == [[1, 2, 3, 4, 5]] ``` *Note: You are required to implement the `is_connected` and `connected_components` methods, ensuring not to modify the basic structure and other existing methods of the Graph class.* # Class Structure for Reference Below is a basic structure of the Graph class for your reference: ```python class Graph: def __init__(self): self.adjacency_list = {} def add_edge(self, u: int, v: int): if u not in self.adjacency_list: self.adjacency_list[u] = [] if v not in self.adjacency_list: self.adjacency_list[v] = [] self.adjacency_list[u].append(v) self.adjacency_list[v].append(u) def is_connected(self) -> bool: # Implement this method pass def connected_components(self) -> List[List[int]]: # Implement this method pass ```","solution":"class Graph: def __init__(self): self.adjacency_list = {} def add_edge(self, u: int, v: int): if u not in self.adjacency_list: self.adjacency_list[u] = [] if v not in self.adjacency_list: self.adjacency_list[v] = [] self.adjacency_list[u].append(v) self.adjacency_list[v].append(u) def is_connected(self) -> bool: if not self.adjacency_list: return True visited = set() nodes = list(self.adjacency_list.keys()) self._dfs(nodes[0], visited) return len(visited) == len(self.adjacency_list) def _dfs(self, node, visited): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) stack.extend(neighbour for neighbour in self.adjacency_list[current] if neighbour not in visited) def connected_components(self) -> list: visited = set() components = [] for node in self.adjacency_list: if node not in visited: component = [] self._dfs_collect(node, visited, component) components.append(component) return components def _dfs_collect(self, node, visited, component): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) component.append(current) stack.extend(neighbour for neighbour in self.adjacency_list[current] if neighbour not in visited)"},{"question":"# Fibonacci Sequence Generator with Matrix Exponentiation # Background: The Fibonacci sequence is a classic example of a recurrence relation, where each term is the sum of the two preceding ones. While a simple recursive or iterative solution can generate Fibonacci numbers, matrix exponentiation offers a method that can achieve this in logarithmic time complexity. # Your Task: Implement the `fib_matrix_expo` function designed to compute the N-th Fibonacci number using matrix exponentiation. # Function Signature: ```python def fib_matrix_expo( n: int ) -> int: ``` # Input: 1. **n (int)**: The position in the Fibonacci sequence to compute, where 0 <= n <= 10^18. # Output: - **nth_fibonacci (int)**: The N-th Fibonacci number. # Constraints: - The position `n` is a non-negative integer and can be as large as 10^18. - The result may require handling very large integers, ensure your solution efficiently manages such cases. # Requirements: 1. Implement matrix exponentiation to solve the problem. 2. Ensure optimal time complexity of O(log n). 3. Your function should be able to handle large input sizes efficiently. 4. Avoid recursion due to Python\'s recursion limit. # Example: ```python print(fib_matrix_expo(0)) # Output: 0 print(fib_matrix_expo(1)) # Output: 1 print(fib_matrix_expo(10)) # Output: 55 print(fib_matrix_expo(50)) # Output: 12586269025 ``` # Additional Task: 1. Provide unit tests to validate your `fib_matrix_expo` function for a range of inputs, including edge cases and large values of `n`. Use Python\'s built-in unit testing framework, `unittest`. # Hint: Matrix exponentiation can be summarized as: - Constructing the transformation matrix: ``` T = | 1 1 | | 1 0 | ``` - Using exponentiation by squaring to compute T^n efficiently. The N-th Fibonacci number can then be derived from this result.","solution":"def fib_matrix_expo(n: int) -> int: Compute the N-th Fibonacci number using matrix exponentiation. if n == 0: return 0 elif n == 1: return 1 def multiply_matrices(a, b): Multiplies two 2x2 matrices return [ [a[0][0] * b[0][0] + a[0][1] * b[1][0], a[0][0] * b[0][1] + a[0][1] * b[1][1]], [a[1][0] * b[0][0] + a[1][1] * b[1][0], a[1][0] * b[0][1] + a[1][1] * b[1][1]] ] def matrix_power(matrix, power): Efficiently raises the matrix to the specified power using exponentiation by squaring result = [[1, 0], [0, 1]] # Identity matrix base = matrix while power > 0: if power % 2 == 1: result = multiply_matrices(result, base) base = multiply_matrices(base, base) power //= 2 return result # Transformation matrix for Fibonacci sequence transformation_matrix = [[1, 1], [1, 0]] # Raise the transformation matrix to the (n-1)th power result_matrix = matrix_power(transformation_matrix, n - 1) return result_matrix[0][0]"},{"question":"You are tasked with developing a function that approximates the area under a given curve `fnc` over an interval `[x_start, x_end]` using adaptive trapezoidal rule. To evaluate your understanding of numerical integration and adaptive techniques, your function should follow these guidelines: # Function Signature ```python def adaptive_trapezoidal( fnc: Callable[[float], float], x_start: float, x_end: float, initial_steps: int = 10, tolerance: float = 1e-5 ) -> float: ``` # Input - `fnc`: A callable function representing the curve to be integrated. - `x_start`: A float indicating the start of the integration interval. - `x_end`: A float indicating the end of the interval. - `initial_steps`: The initial number of steps to start the integration process (default 10). - `tolerance`: The maximum acceptable error for the approximation to refine the steps (default 1e-5). # Output - Returns a float representing the approximated area under the curve. # Constraints - `x_start` must be less than `x_end`. - The function `fnc` is continuous over the interval `[x_start, x_end]`. - The approximation must adaptively refine the number of steps to achieve the desired tolerance, especially for curves with varying rates of change. # Example ```python import math def g(x): return math.exp(-x**2) print(adaptive_trapezoidal(g, 0, 1)) ``` Expected output should be a float representing the area under the curve `g(x) = exp(-x^2)` from `0` to `1`. **Note**: Ensure your function handles edge cases robustly and achieves the desired accuracy efficiently through adaptive step refinement.","solution":"from typing import Callable def adaptive_trapezoidal( fnc: Callable[[float], float], x_start: float, x_end: float, initial_steps: int = 10, tolerance: float = 1e-5 ) -> float: def trapezoidal_rule(f, a, b, n): h = (b - a) / n sum_ = 0.5 * (f(a) + f(b)) for i in range(1, n): sum_ += f(a + i * h) return sum_ * h # Initial approximation current_steps = initial_steps area = trapezoidal_rule(fnc, x_start, x_end, current_steps) while True: # Refine the number of steps new_steps = 2 * current_steps new_area = trapezoidal_rule(fnc, x_start, x_end, new_steps) # Check if the approximation is within the desired tolerance if abs(new_area - area) < tolerance: return new_area # Update step count and area for next iteration current_steps = new_steps area = new_area"},{"question":"# Matrix Rotation Check Problem Statement You are given two n x n matrices. Write a function to determine if one matrix is a rotation of the other. Two matrices are said to be rotations of each other if we can obtain one matrix by rotating the other matrix 90 degrees clockwise any number of times (including zero times). Requirements Implement the following method: ```python def are_rotations(matrix1: List[List[int]], matrix2: List[List[int]]) -> bool: Check if matrix2 is a rotation of matrix1. Parameters: matrix1 (List[List[int]]): First n x n matrix. matrix2 (List[List[int]]): Second n x n matrix. Returns: bool: True if matrix2 is a rotation of matrix1, False otherwise. Example: >>> matrix1 = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> matrix2 = [ ... [7, 4, 1], ... [8, 5, 2], ... [9, 6, 3] ... ] >>> are_rotations(matrix1, matrix2) True >>> matrix3 = [ ... [3, 2, 1], ... [6, 5, 4], ... [9, 8, 7] ... ] >>> are_rotations(matrix1, matrix3) False ``` Your implementation must: - Rotate `matrix1` by 90 degrees clockwise up to three times and check if any of the rotations match `matrix2`. - Return `True` if any rotation of `matrix1` matches `matrix2`, otherwise return `False`. Input and Output - **Input**: Two n x n matrices, `matrix1` and `matrix2`. - **Output**: Boolean value indicating if `matrix2` is a rotation of `matrix1`. Constraints - The function should handle square matrices with side length up to 100. - Optimize for time and space complexity as much as possible while handling the constraints. Example ```python >>> matrix1 = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> matrix2 = [ ... [7, 4, 1], ... [8, 5, 2], ... [9, 6, 3] ... ] >>> print(are_rotations(matrix1, matrix2)) # Output: True >>> matrix3 = [ ... [3, 2, 1], ... [6, 5, 4], ... [9, 8, 7] ... ] >>> print(are_rotations(matrix1, matrix3)) # Output: False ``` # Note - Ensure the matrix rotation is implemented correctly to facilitate accurate comparisons. - Consider edge cases like matrices with repeated values or single-element matrices.","solution":"from typing import List def rotate_matrix_90_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates a given NxN matrix 90 degrees clockwise. n = len(matrix) rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated def are_rotations(matrix1: List[List[int]], matrix2: List[List[int]]) -> bool: Check if matrix2 is a rotation of matrix1. if matrix1 == matrix2: return True rotated_matrix = matrix1 for _ in range(3): # Rotate up to three times (90, 180, 270 degrees) rotated_matrix = rotate_matrix_90_clockwise(rotated_matrix) if rotated_matrix == matrix2: return True return False"},{"question":"**Context**: Searching for specific elements in a collection is a common operation in programming. The Binary Search algorithm excels in finding elements efficiently in sorted arrays due to its logarithmic time complexity. It is particularly useful when dealing with large datasets. # Problem Statement Implement a modified version of the Binary Search algorithm to find the first and last occurrence of a given target integer in a sorted list of integers. Additionally, ensure your algorithm handles gracefully when the target integer is not present in the list. # Requirements * **Function Name**: `find_first_last_occurrence` * **Input**: A sorted list of integers `sorted_list`, an integer `target` * **Output**: A tuple containing the first and last indices of the target integer in the list. If the target is not found, return (-1, -1). # Constraints - Do not use built-in search functions. - Your implementation should have a time complexity of O(log n). # Example ```python def find_first_last_occurrence(sorted_list: list, target: int) -> tuple: # Your code here # Examples: print(find_first_last_occurrence([1, 2, 2, 2, 3, 4, 5], 2)) # Output: (1, 3) print(find_first_last_occurrence([1, 2, 2, 2, 3, 4, 5], 3)) # Output: (4, 4) print(find_first_last_occurrence([1, 2, 2, 2, 3, 4, 5], 6)) # Output: (-1, -1) print(find_first_last_occurrence([1, 1, 1, 1, 1, 1, 1], 1)) # Output: (0, 6) print(find_first_last_occurrence([], 2)) # Output: (-1, -1) ``` # Special Considerations - Make sure to account for edge cases, such as the list being empty, the target not present in the list, and the list containing only one element. - If the target appears multiple times, ensure that the first occurrence is correctly identified as the smallest index, and the last occurrence is the largest index where the target appears. # Testing Create a series of unit tests to validate your function under different scenarios including edge cases, different target values, and various list sizes.","solution":"def find_first_last_occurrence(sorted_list, target): def binary_search(find_first): low, high, result = 0, len(sorted_list) - 1, -1 while low <= high: mid = (low + high) // 2 if sorted_list[mid] == target: result = mid if find_first: high = mid - 1 # Move left for the first occurrence else: low = mid + 1 # Move right for the last occurrence elif sorted_list[mid] < target: low = mid + 1 else: high = mid - 1 return result first_occurrence = binary_search(find_first=True) if first_occurrence == -1: return (-1, -1) last_occurrence = binary_search(find_first=False) return (first_occurrence, last_occurrence)"},{"question":"# Question: Container With Most Water You are given `n` non-negative integers `a_1, a_2, ..., a_n`. Each represents a point at coordinate `(i, ai)`. `n` vertical lines are drawn such that the two endpoints of the line `i` is at `(i, ai)` and `(i, 0)`. Find two lines, which, together with the x-axis forms a container, such that the container contains the most water. **Function Signature**: ```python def max_area(heights: list[int]) -> int: ... ``` # Input - `heights`: A list of non-negative integers. (2 ≤ len(heights) ≤ 10^5, 0 ≤ heights[i] ≤ 10^4). # Output - Return an integer representing the maximum amount of water a container can store. # Constraints * The function should execute in O(n) time complexity and use constant extra space. # Examples ```python # Example 1 assert max_area([1,8,6,2,5,4,8,3,7]) == 49 # Example 2 assert max_area([1,1]) == 1 # Example 3 assert max_area([4,3,2,1,4]) == 16 # Example 4 assert max_area([1,2,1]) == 2 # Example 5 assert max_area([1,2,4,3]) == 4 # Example 6 assert max_area([3,9,3,4,7,2,12,6]) == 45 ``` # Description - Your task is to implement the function `max_area(heights: list[int]) -> int` which returns the maximum amount of water the container can store. - **Container Formation**: * Any two lines from the list can form a container. * The distance between the two lines represents the width of the container. * The shorter line between the two represents the height of the container. * The area of water that the container can hold is equal to width multiplied by the height. # Notes * Use a two-pointer approach to solve this problem within the constraints. * Consider edge cases such as lists with only two elements.","solution":"def max_area(heights): Returns the maximum amount of water a container can store. left = 0 right = len(heights) - 1 max_water = 0 while left < right: h = min(heights[left], heights[right]) w = right - left max_water = max(max_water, h * w) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"# Question: Implement Newton Fractal Visualization Based on your understanding of fractals, implement a function to generate an image of the Newton fractal. The Newton fractal is generated by applying Newton\'s method to find the roots of a polynomial, typically ( z^3 - 1 ). # The Newton Fractal Function Implement the function `newton_fractal_image` with the following signature: ```python def newton_fractal_image( image_width: int, image_height: int, polynomial_roots: list, figure_center_x: float = 0.0, figure_center_y: float = 0.0, figure_width: float = 3.2, max_step: int = 50, tolerance: float = 1e-6, use_detailed_color_coding: bool = True, ) -> Image.Image: Generates an image of the Newton fractal for the given polynomial roots. Parameters: - image_width (int): Width of the image in pixels. - image_height (int): Height of the image in pixels. - polynomial_roots (list): List of complex numbers representing the roots of the polynomial. - figure_center_x (float): X-coordinate of the center of the image in the complex plane. - figure_center_y (float): Y-coordinate of the center of the image in the complex plane. - figure_width (float): Width of the figure in the complex plane. - max_step (int): Maximum number of iterations. - tolerance (float): Tolerance for considering convergence. - use_detailed_color_coding (bool): Whether to use detailed color coding based on convergence and iterations. Returns: - Image.Image: The generated image of the Newton fractal. pass ``` # Requirements 1. **Complex Mapping**: Each pixel should correspond to a point in the complex plane. 2. **Newton Iterations**: For each point, apply Newton\'s method to approximate the roots, ( z_{n+1} = z_n - f(z_n) / f\'(z_n) ), where ( f(z) = z^3 - 1 ) and ( f\'(z) = 3z^2 ). 3. **Convergence Check**: Determine convergence based on whether the distance to any root is within the tolerance. 4. **Color Coding**: Use detailed color-coding functions to color the pixels based on which root the point converges to and the number of iterations. 5. **Performance**: Handle large images and extensive iterations efficiently. # Example Usage Generate and display a Newton fractal with the polynomial ( z^3 - 1 ): ```python if __name__ == \\"__main__\\": polynomial_roots = [1, -0.5 + 0.86602540378j, -0.5 - 0.86602540378j] img = newton_fractal_image(800, 600, polynomial_roots) img.show() ``` # Constraints * Image dimensions are positive integers, typically in the range of [100, 2000]. * Polynomial roots are complex numbers. * Tolerance is a small positive floating-point number, typically in the range of [1e-10, 1e-3]. * Maximum steps are positive integers, typically in the range of [10, 500]. # Performance Considerations Efficiency is a key aspect. Aim to optimize the implementation, especially for generating high-resolution images with many iterations.","solution":"import numpy as np from PIL import Image def newton_fractal_image( image_width: int, image_height: int, polynomial_roots: list, figure_center_x: float = 0.0, figure_center_y: float = 0.0, figure_width: float = 3.2, max_step: int = 50, tolerance: float = 1e-6, use_detailed_color_coding: bool = True, ) -> Image.Image: Generates an image of the Newton fractal for the given polynomial roots. Parameters: - image_width (int): Width of the image in pixels. - image_height (int): Height of the image in pixels. - polynomial_roots (list): List of complex numbers representing the roots of the polynomial. - figure_center_x (float): X-coordinate of the center of the image in the complex plane. - figure_center_y (float): Y-coordinate of the center of the image in the complex plane. - figure_width (float): Width of the figure in the complex plane. - max_step (int): Maximum number of iterations. - tolerance (float): Tolerance for considering convergence. - use_detailed_color_coding (bool): Whether to use detailed color coding based on convergence and iterations. Returns: - Image.Image: The generated image of the Newton fractal. roots = np.array(polynomial_roots) color_map = [ (0, 255, 0), # green (0, 0, 255), # blue (255, 0, 0) # red ] # Normalize figure width figure_height = figure_width * image_height / image_width x_range = np.linspace(figure_center_x - figure_width / 2, figure_center_x + figure_width / 2, image_width) y_range = np.linspace(figure_center_y - figure_height / 2, figure_center_y + figure_height / 2, image_height) xv, yv = np.meshgrid(x_range, y_range) z = xv + 1j * yv output = np.zeros((image_height, image_width, 3), dtype=np.uint8) for i in range(max_step): # Newton iteration z -= (z**3 - 1) / (3 * z**2) for j, root in enumerate(roots): mask = np.abs(z - root) < tolerance output[mask, :] = color_map[j % len(color_map)] if mask.all(): break img = Image.fromarray(output) return img"},{"question":"# Question: **String Transformation to Balanced Parantheses** You are given a string consisting of only two characters, `\'(\'` and `\')\'`. Your task is to determine the minimum number of operations required to make the string balanced. A string is considered balanced if every opening parenthesis `\'(\'` can find a corresponding closing parenthesis `\')\'` to form pairs. Expected Function Signature ```python def min_operations_to_balance(s: str) -> int: pass ``` # Input * A string `s` of length `1 <= len(s) <= 10^6` consisting of characters `\'(\'` and `\')\'`. # Output * An integer representing the minimum number of operations required to make the string balanced. * An operation involves either adding or removing a parenthesis. # Constraints * You may assume the input string consists of a mix of `\'(\'` and `\')\'` characters. # Performance Requirements * Your solution should be efficient, with a time complexity roughly linear to the length of the string. # Example ```python assert min_operations_to_balance(\\"(()\\") == 1 assert min_operations_to_balance(\\"())(\\") == 2 assert min_operations_to_balance(\\"(((\\") == 3 assert min_operations_to_balance(\\"()\\") == 0 assert min_operations_to_balance(\\"(()))(()()(\\") == 3 ``` # Additional Edge Cases * An empty string is already balanced and should return `0`. * A string with all opening parentheses or all closing parentheses will require the length of the string in operations. * Strings with equal numbers of opening and closing parentheses but unbalanced need operations to balance. --- # Problem Explanation To solve this problem, we need to ensure all opening parentheses have matching closing parentheses, which can be achieved by: 1. Keeping track of unmatched opening and closing parentheses as we iterate through the string. 2. Calculating the total number of necessary operations to balance the count. # Implementation Notes * Use a counter to keep track of unmatched `\'(\'` as we traverse the string. * Increment the counter for each `\'(\'` and decrement it for each `\')\'`. * If the counter goes negative, it means there\'s an unmatched `\')\'`, and we increment the required operations. * At the end of traversal, add the remaining unmatched `\'(\'` count to the required operations, as each one needs a matching `\')\'`. By following the above plan, we ensure the given string becomes balanced using minimal operations.","solution":"def min_operations_to_balance(s: str) -> int: Determines the minimum number of operations required to make the string balanced. left_unmatched = 0 operations = 0 for char in s: if char == \'(\': left_unmatched += 1 else: if left_unmatched > 0: left_unmatched -= 1 else: operations += 1 operations += left_unmatched return operations"},{"question":"# Problem Statement You are given a list of keywords and a target string. Your task is to implement the following functions: 1. **Substring Search**: Implement a function to find all starting indices of substrings in the target string that are permutations of the keywords. 2. **Anagram Grouping**: Implement a function to group the keywords that are anagrams of each other. # Function Signature ```python def find_permutations_in_string(keywords: List[str], target: str) -> List[int]: @param: keywords (List of strings): List of keywords @param: target (str): The target string @return: List of starting indices of substrings in the target that are permutations of the keywords Example: >>> find_permutations_in_string([\\"ab\\", \\"ba\\"], \\"baba\\") [0, 1, 2] >>> find_permutations_in_string([\\"a\\"], \\"aaaa\\") [0, 1, 2, 3] pass def group_anagrams(keywords: List[str]) -> List[List[str]]: @param: keywords (List of strings): List of keywords @return: A list of lists where each sublist contains anagrams of each other Example: >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\'eat\', \'tea\', \'ate\'], [\'tan\', \'nat\'], [\'bat\']] >>> group_anagrams([\\"\\"]) [[\'\']] pass ``` # Input/Output * **Input**: - `keywords`: A list of strings representing the keywords. - `target`: A string in which to search for permutations of keywords. * **Output**: - A list of starting indices of substrings in the target string that are permutations of the keywords (for `find_permutations_in_string`). - A list of lists where each sublist contains anagrams of each other (for `group_anagrams`). # Constraints * The length of `target` will be between 1 and 1000. * The length of each keyword will be between 1 and 100. * The number of keywords will not exceed 100. # Performance Requirements * Aim for time complexity O(n * m) where n is the length of the target string and m is the length of the keyword, for the substring permutation search. * Aim for time complexity O(n * k log k) where n is the number of keywords and k is the length of the longest keyword, for the anagram grouping function. This ensures efficient handling of large inputs. # Scenario Consider using the functions to process text data in search engines where you need to find occurrences of certain patterns (anagram permutations) and group similar search terms (anagrams) for optimization and analysis.","solution":"from collections import defaultdict from typing import List def find_permutations_in_string(keywords: List[str], target: str) -> List[int]: Finds all starting indices of substrings in the target string that are permutations of the keywords. def is_permutation(s1: str, s2: str) -> bool: return sorted(s1) == sorted(s2) result = [] keywords_set = set(keywords) keyword_length = min(len(keyword) for keyword in keywords) for i in range(len(target) - keyword_length + 1): substring = target[i:i + keyword_length] for keyword in keywords_set: if is_permutation(substring, keyword): result.append(i) break return result def group_anagrams(keywords: List[str]) -> List[List[str]]: Groups the keywords that are anagrams of each other. anagram_map = defaultdict(list) for keyword in keywords: sorted_keyword = \\"\\".join(sorted(keyword)) anagram_map[sorted_keyword].append(keyword) return list(anagram_map.values())"},{"question":"# Merge Sorted Linked Lists You are tasked with merging multiple sorted linked lists into one sorted linked list. The linked lists are provided as inputs, and your goal is to merge them efficiently to produce a single sorted linked list. **Input/Output:** - **Input**: The input consists of: 1. `lists` - A list of linked lists, where each linked list is sorted in ascending order. Each linked list is represented as a `ListNode` object. - **Output**: The merged sorted linked list as a `ListNode` object. # Requirements: 1. **Handling Edge Cases**: - Ensure the function handles an empty list of linked lists correctly. - Ensure proper handling of linked lists with varying lengths. 2. **Performance Optimizations**: - Aim for linearithmic time complexity, i.e., O(N log k), where N is the total number of nodes and k is the number of linked lists. - Utilize data structures that allow efficient retrieval of the smallest element, such as a heap. # Function Signature: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[ListNode]) -> ListNode: pass ``` # Example: ```python # Example usage: # Converting array to linked list for the input def array_to_linked_list(arr): if not arr: return None head = ListNode(arr[0]) current = head for val in arr[1:]: current.next = ListNode(val) current = current.next return head lists = [array_to_linked_list([1, 4, 5]), array_to_linked_list([1, 3, 4]), array_to_linked_list([2, 6])] merged_list = merge_k_sorted_lists(lists) # Linked list converted back to array for output def linked_list_to_array(node): arr = [] while node: arr.append(node.val) node = node.next return arr print(linked_list_to_array(merged_list)) # Expected Output: [1, 1, 2, 3, 4, 4, 5, 6] ``` # Constraints: - Assume all inputs are valid unless stated otherwise. - Each list node contains an integer value. - The total number of nodes across all lists does not exceed 10^4. # Notes: - Utilize a priority queue (min-heap) to efficiently merge k sorted linked lists. - Ensure that your solution handles large inputs efficiently in terms of both time and space complexity. Good luck!","solution":"from typing import List, Optional import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: # A min-heap to keep track of the nodes in sorted order min_heap = [] # Initialize the heap with the head of each linked list for i, node in enumerate(lists): if node: heapq.heappush(min_heap, (node.val, i, node)) # Dummy node to serve as the head of the result merged linked list dummy = ListNode() current = dummy # Extract the minimum element from the heap and add the next node from the same list into the heap while min_heap: val, i, node = heapq.heappop(min_heap) current.next = node current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, i, node.next)) return dummy.next"},{"question":"# Coding Assessment Question **Context**: You are working for an e-commerce company that provides personalized product recommendations to users. One of the features involves generating a list of product recommendations based on the user\'s browsing history. The input data includes product categories and the corresponding scores indicating user interest in each category. # Task Write a function `product_recommendations` that takes a user\'s browsing history and returns a list of recommended product categories. The recommendations are based on the highest scores in the user\'s interest data. # Function Signature ```python def product_recommendations(browsing_history: dict) -> list: ``` # Input - `browsing_history` (dict): A dictionary where keys are product categories (strings) and values are interest scores (integers). # Output - Returns a list of recommended product categories sorted by interest scores in descending order. If two categories have the same score, they should be ordered alphabetically. # Constraints - The `browsing_history` will contain between 1 and 20 product categories. - Interest scores are integers between 1 and 100. # Example ```python browsing_history = { \\"Electronics\\": 85, \\"Books\\": 75, \\"Clothing\\": 90, \\"Home & Kitchen\\": 85 } print(product_recommendations(browsing_history)) ``` Expected Output: ``` [\'Clothing\', \'Electronics\', \'Home & Kitchen\', \'Books\'] ``` # Additional Information 1. Ensure your function handles edge cases such as empty input gracefully. 2. The function should be efficient, especially for the upper limit of input size. 3. In real-world scenarios, this function will be used to dynamically generate recommendation lists for user profiles in the e-commerce system.","solution":"def product_recommendations(browsing_history: dict) -> list: Returns a list of recommended product categories sorted by interest scores in descending order. If two categories have the same score, they should be sorted alphabetically. # Sorting the dictionary items first by score in descending order and then alphabetically by product category sorted_categories = sorted(browsing_history.items(), key=lambda x: (-x[1], x[0])) # Extracting the sorted category names recommended_categories = [category for category, score in sorted_categories] return recommended_categories"},{"question":"# Image Processing with Edge Detection You are tasked with implementing an edge detection algorithm using the Sobel operator. You will create a function that processes grayscale images to highlight their edges based on the gradient magnitude. Instructions 1. Implement a function `detect_edges` that takes a 2D numpy array representing a grayscale image and returns a 2D numpy array of the same dimensions with the gradients\' magnitude (edges) highlighted. * Apply the Sobel operator to compute the gradient in the x-direction and y-direction. * Combine these gradients to compute the gradient magnitude. * Normalize the output image to ensure pixel values are in the range [0, 255]. 2. Test your implementation using sample grayscale images. Include a visual comparison between the original grayscale image and the edge-detected image using appropriate plotting functions. Expected Input and Output * **Input**: * `image`: A 2D numpy array representing the grayscale image. * **Output**: * The function returns a 2D numpy array of the same dimensions, representing the processed image with edges detected. Performance Requirements * Ensure your function works efficiently within time constraints for typical image sizes of up to 1000x1000 pixels. Example ```python import numpy as np from scipy import ndimage import matplotlib.pyplot as plt def detect_edges(image): sobel_x = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]) sobel_y = np.array([[-1, -2, -1], [0, 0, 0], [1, 2, 1]]) grad_x = ndimage.convolve(image, sobel_x) grad_y = ndimage.convolve(image, sobel_y) gradient_magnitude = np.sqrt(grad_x**2 + grad_y**2) gradient_magnitude = (gradient_magnitude / gradient_magnitude.max()) * 255 return gradient_magnitude.astype(np.uint8) # Example usage of detect_edges function image = np.random.rand(300, 300) * 255 plt.subplot(1, 2, 1) plt.title(\\"Original Image\\") plt.imshow(image, cmap=\'gray\') edge_image = detect_edges(image) plt.subplot(1, 2, 2) plt.title(\\"Edge Detected Image\\") plt.imshow(edge_image, cmap=\'gray\') plt.show() ``` You are expected to write your own `detect_edges` function and demonstrate its use with a sample grayscale image of your choice.","solution":"import numpy as np from scipy import ndimage def detect_edges(image): Detect edges in a grayscale image using the Sobel operator. Parameters: image (2D np.array): Input grayscale image. Returns: 2D np.array: Image with edges highlighted. # Define the Sobel operator kernels. sobel_x = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]) sobel_y = np.array([[-1, -2, -1], [0, 0, 0], [1, 2, 1]]) # Compute the gradient in the x and y directions. grad_x = ndimage.convolve(image, sobel_x) grad_y = ndimage.convolve(image, sobel_y) # Compute the gradient magnitude. gradient_magnitude = np.sqrt(grad_x ** 2 + grad_y ** 2) # Normalize the gradient magnitude to the range [0, 255]. gradient_magnitude = (gradient_magnitude / gradient_magnitude.max()) * 255 return gradient_magnitude.astype(np.uint8)"},{"question":"# Problem Statement Write a function `sum_of_divisors` to calculate the sum of all divisors of a given number `n`. # Input * An integer `n` where `1 <= n <= 10^6` # Output * An integer which is the sum of all divisors of `n`. # Constraints * The function should have an optimal time complexity, ideally better than O(n). # Examples * Example 1: ```python sum_of_divisors(6) ``` Expected Output: ``` 12 ``` * Example 2: ```python sum_of_divisors(28) ``` Expected Output: ``` 56 ``` # Additional Context Consider the cases where `n` is a prime number, a perfect number, or a highly composite number. The solution should handle large inputs efficiently within the provided constraints. The mathematical properties of divisors can be utilized to devise an optimal solution. Write the function `sum_of_divisors` to accomplish this task.","solution":"def sum_of_divisors(n): Calculate the sum of all divisors of a given number n. if n == 1: return 1 total_sum = 1 + n # 1 and n are always divisors sqrt_n = int(n**0.5) for i in range(2, sqrt_n + 1): if n % i == 0: total_sum += i if i != n // i: total_sum += n // i return total_sum"},{"question":"# Context: You\'re developing a module to handle various matrix operations for a numerical computing library. One of the operations frequently used is finding the diagonal sum of a square matrix. Diagonal sums are useful in various domains such as linear algebra, graphics, and more. # Problem Statement: Write a function `calculate_diagonal_sum(matrix: List[List[int]]) -> int` that takes a square matrix (a list of `N` lists, each containing `N` integers) and returns an integer representing the sum of its primary diagonal elements. If the input is not a square matrix, the function should raise a `ValueError` with the message \\"Invalid input: Matrix is not square\\". Input and Output Formats: * **Input**: A single argument `matrix` which is a list of `N` lists, each containing `N` integers. * **Output**: An integer representing the sum of the primary diagonal elements of the matrix. Constraints and Limitations: * The input is guaranteed to be a list of lists of integers. * The function should validate that the matrix is square, i.e., all internal lists must have the same length as the number of lists in the matrix. Example: ```python >>> calculate_diagonal_sum([[1, 2, 3], ... [4, 5, 6], ... [7, 8, 9]]) 15 >>> calculate_diagonal_sum([[10, 20], ... [30, 40]]) 50 >>> calculate_diagonal_sum([[5]]) 5 >>> calculate_diagonal_sum([[1, 2, 3], ... [4, 5, 6]]) Traceback (most recent call last): ... ValueError: Invalid input: Matrix is not square >>> calculate_diagonal_sum([[1, 2], ... [4]]) Traceback (most recent call last): ... ValueError: Invalid input: Matrix is not square ``` Performance Requirements: * The solution should ideally run in O(N) time complexity, where `N` is the dimension of the matrix.","solution":"def calculate_diagonal_sum(matrix): Calculates the sum of the primary diagonal elements of a square matrix. :param matrix: List of N lists, each containing N integers representing a square matrix. :returns: Integer representing the sum of the primary diagonal elements. :raises ValueError: If the input is not a square matrix. n = len(matrix) # Number of rows in the matrix # Check if matrix is a square matrix if not all(len(row) == n for row in matrix): raise ValueError(\\"Invalid input: Matrix is not square\\") # Calculate the sum of the primary diagonal diagonal_sum = sum(matrix[i][i] for i in range(n)) return diagonal_sum"},{"question":"# Problem Statement In computer graphics, color blending is a common operation where two colors are combined to produce a new color. The most prevalent blending mode is called \\"alpha blending,\\" where each color has an associated alpha value (opacity), indicating its transparency. Task Write a function `alpha_blend` that calculates the resulting color from blending two colors using their RGBA values. Function Signature ```python def alpha_blend(color1: tuple, color2: tuple) -> tuple: ``` Input * `color1` (tuple): A tuple of four integers representing the first color in RGBA format (red, green, blue, alpha). The values for red, green, blue range from 0 to 255, and alpha ranges from 0 to 1. * `color2` (tuple): A tuple of four integers representing the second color in RGBA format (red, green, blue, alpha). The values for red, green, blue range from 0 to 255, and alpha ranges from 0 to 1. Output * Returns a tuple of four integers representing the blended color in RGBA format. Constraints * The function should ensure that the RGBA values are within their respective ranges. If any value is out of range, raise a `ValueError` with an appropriate message. * For blending, use the given formula to calculate the resulting color components: [ text{output_color}.red = text{color1.red} times text{color1.alpha} + text{color2.red} times (1 - text{color1.alpha}) ] [ text{output_color}.green = text{color1.green} times text{color1.alpha} + text{color2.green} times (1 - text{color1.alpha}) ] [ text{output_color}.blue = text{color1.blue} times text{color1.alpha} + text{color2.blue} times (1 - text{color1.alpha}) ] [ text{output_color}.alpha = text{color1.alpha} + text{color2.alpha} ] * The resulting alpha should not exceed 1. Cap the output alpha at 1 if necessary. Performance Requirements * The function should run efficiently with a time complexity of O(1). Example Usage ```python >>> alpha_blend((255, 0, 0, 0.5), (0, 0, 255, 0.5)) (127, 0, 127, 1.0) >>> alpha_blend((0, 255, 0, 0.3), (0, 0, 255, 0.7)) (0, 76, 178, 1.0) >>> alpha_blend((255, 255, 255, 1), (0, 0, 0, 0.5)) (255, 255, 255, 1.0) >>> alpha_blend((256, 0, 0, 0.5), (0, 0, 255, 0.5)) Traceback (most recent call last): ... ValueError: Red value out of range ``` Notes - The resulting color\'s RGBA values should be integers where RGB are between 0-255 inclusive, and A is a float between 0-1 inclusive. - Ensure validation checks are in place and handle error scenarios accordingly. - The formula assumes pre-multiplied alpha blending.","solution":"def alpha_blend(color1: tuple, color2: tuple) -> tuple: def validate_color(color): if not(0 <= color[0] <= 255): raise ValueError(\\"Red value out of range\\") if not(0 <= color[1] <= 255): raise ValueError(\\"Green value out of range\\") if not(0 <= color[2] <= 255): raise ValueError(\\"Blue value out of range\\") if not(0 <= color[3] <= 1): raise ValueError(\\"Alpha value out of range\\") validate_color(color1) validate_color(color2) r1, g1, b1, a1 = color1 r2, g2, b2, a2 = color2 r = int(r1 * a1 + r2 * (1 - a1)) g = int(g1 * a1 + g2 * (1 - a1)) b = int(b1 * a1 + b2 * (1 - a1)) a = min(a1 + a2, 1.0) return (r, g, b, a)"},{"question":"# Problem Statement **Context:** You are given a list of logs where each log represents an event with a start and end time in a 24-hour format. Your task is to determine the maximum number of overlapping events at any point in time. This will help to identify the peak load period of the system. **Definition:** - Each log entry is a tuple of two strings, representing the start and end times of an event in \\"HH:MM\\" format. - The start time is inclusive, and the end time is exclusive. - If an event spans an entire minute, it starts at the given start time and ends at the start of the next minute. For example: - For the log `[(\\"10:00\\", \\"10:05\\"), (\\"10:03\\", \\"10:08\\")]`, the maximum number of overlapping events is 2. - If the log is `[(\\"10:00\\", \\"10:05\\"), (\\"10:06\\", \\"10:08\\")]`, the maximum number of overlapping events is 1. **Requirements:** Implement the following function: ```python def max_overlapping_events(logs: list) -> int: Determines the maximum number of overlapping events from the given list of logs. Args: logs (list): A list where each element is a tuple of start and end times in \\"HH:MM\\" format Returns: int: The maximum number of overlapping events at any point in time pass ``` **Input:** - `logs`: A list of tuples containing start and end times of events in \\"HH:MM\\" format **Output:** - An integer representing the maximum number of overlapping events at any point in time **Examples:** ```python assert max_overlapping_events([(\\"10:00\\", \\"10:05\\"), (\\"10:03\\", \\"10:08\\")]) == 2 assert max_overlapping_events([(\\"10:00\\", \\"10:05\\"), (\\"10:06\\", \\"10:08\\")]) == 1 assert max_overlapping_events([(\\"09:00\\", \\"10:00\\"), (\\"09:30\\", \\"09:45\\"), (\\"09:45\\", \\"10:15\\")]) == 2 assert max_overlapping_events([(\\"08:00\\", \\"08:30\\"), (\\"08:15\\", \\"08:45\\"), (\\"10:00\\", \\"11:00\\")]) == 2 assert max_overlapping_events([]) == 0 ``` **Constraints:** - The start and end times are formatted as \\"HH:MM\\". - The events occur within a single 24-hour period (00:00 to 23:59).","solution":"def max_overlapping_events(logs): Determines the maximum number of overlapping events from the given list of logs. Args: logs (list): A list where each element is a tuple of start and end times in \\"HH:MM\\" format Returns: int: The maximum number of overlapping events at any point in time # Convert time to minutes from the start of the day for easy comparison def time_to_minutes(time): hours, minutes = map(int, time.split(\\":\\")) return hours * 60 + minutes # Create events list with (+1 for start, -1 for end) events = [] for start, end in logs: events.append((time_to_minutes(start), 1)) events.append((time_to_minutes(end), -1)) # Sort events first by time, then by type of event (start before end if they are at the same time) events.sort(key=lambda x: (x[0], x[1])) max_overlap = 0 current_overlap = 0 # Traverse through the events to find the peak overlap for time, event_type in events: current_overlap += event_type max_overlap = max(max_overlap, current_overlap) return max_overlap"},{"question":"# Question: Implement a Median Filter for Image Processing in Python Scenario You are developing an image processing application that needs to reduce noise in images. One common technique for noise reduction is the median filter, which replaces each pixel\'s value with the median value of the intensities in the pixel\'s neighborhood. Task 1. Implement a class `MedianFilter` with a method `apply_filter` that takes a 2D numpy array representing an image and an integer `kernel_size` representing the size of the square neighborhood and returns the filtered image. 2. Write a function `configure_median_filter(kernel_size: int) -> MedianFilter` that initializes and returns a `MedianFilter` instance using the provided `kernel_size`. 3. Write a script that applies your median filter to a sample image and displays the original and filtered images side by side using `matplotlib`. Input and Output Formats - **Input**: - A 2D numpy array `image` representing a grayscale image. - An integer `kernel_size` that specifies the size of the neighborhood (must be an odd number). - **Output**: - The `apply_filter` method should return a 2D numpy array representing the filtered image. - The script should display the original and filtered images side by side. Constraints: - The `kernel_size` must be an odd integer. - The `kernel_size` should be at least 3 and at most 9. - The input image dimensions should be at least `kernel_size` x `kernel_size`. Performance Requirements: - The `apply_filter` method should apply the median filter efficiently even for large images. Implementation Hints: - Utilize numpy for efficient array manipulations. - Leverage `scipy.ndimage.median_filter` if necessary. Requirements: - Ensure your code includes sufficient error-checking and handles edge cases appropriately. - Add brief documentation and comments explaining your key decisions and logic. ```python import numpy as np from scipy.ndimage import median_filter import matplotlib.pyplot as plt class MedianFilter: def __init__(self, kernel_size: int): self.kernel_size = kernel_size def apply_filter(self, image: np.ndarray) -> np.ndarray: if not (self.kernel_size % 2 == 1): raise ValueError(\\"kernel_size must be an odd integer\\") if self.kernel_size < 3 or self.kernel_size > 9: raise ValueError(\\"kernel_size must be between 3 and 9\\") return median_filter(image, size=self.kernel_size) def configure_median_filter(kernel_size: int) -> MedianFilter: if kernel_size % 2 == 0: raise ValueError(\\"kernel_size must be an odd integer\\") if kernel_size < 3 or kernel_size > 9: raise ValueError(\\"kernel_size must be between 3 and 9\\") return MedianFilter(kernel_size) # Sample usage: # Load a sample grayscale image image = np.random.rand(100, 100) * 255 # A random grayscale image for illustration image = image.astype(np.uint8) # Configure median filter median_filter_instance = configure_median_filter(5) # Apply median filter filtered_image = median_filter_instance.apply_filter(image) # Display original and filtered images fig, axes = plt.subplots(1, 2, figsize=(10, 5)) axes[0].imshow(image, cmap=\'gray\') axes[0].set_title(\'Original Image\') axes[0].axis(\'off\') axes[1].imshow(filtered_image, cmap=\'gray\') axes[1].set_title(\'Filtered Image\') axes[1].axis(\'off\') plt.show() ```","solution":"import numpy as np from scipy.ndimage import median_filter import matplotlib.pyplot as plt class MedianFilter: def __init__(self, kernel_size: int): if kernel_size % 2 == 0: raise ValueError(\\"kernel_size must be an odd integer\\") if kernel_size < 3 or kernel_size > 9: raise ValueError(\\"kernel_size must be between 3 and 9\\") self.kernel_size = kernel_size def apply_filter(self, image: np.ndarray) -> np.ndarray: if image.ndim != 2: raise ValueError(\\"Input image must be a 2D numpy array\\") if image.shape[0] < self.kernel_size or image.shape[1] < self.kernel_size: raise ValueError(\\"Image dimensions should be at least kernel_size x kernel_size\\") return median_filter(image, size=self.kernel_size) def configure_median_filter(kernel_size: int) -> MedianFilter: return MedianFilter(kernel_size) # Sample usage: # Load a sample grayscale image image = np.random.rand(100, 100) * 255 # A random grayscale image for illustration image = image.astype(np.uint8) # Configure median filter median_filter_instance = configure_median_filter(5) # Apply median filter filtered_image = median_filter_instance.apply_filter(image) # Display original and filtered images fig, axes = plt.subplots(1, 2, figsize=(10, 5)) axes[0].imshow(image, cmap=\'gray\') axes[0].set_title(\'Original Image\') axes[0].axis(\'off\') axes[1].imshow(filtered_image, cmap=\'gray\') axes[1].set_title(\'Filtered Image\') axes[1].axis(\'off\') plt.show()"},{"question":"# Matrix Multiplication Verification and Augmentation In this problem, you are tasked with verifying the multiplication of two matrices and augmenting the resulting product matrix based on certain criteria. You will implement a function `verify_and_augment_matrices` that takes two 2-dimensional matrices (as lists of lists) and performs the following operations: 1. Verify if the matrices can be multiplied (i.e., the number of columns in the first matrix equals the number of rows in the second matrix). 2. If they can be multiplied, compute the product matrix. 3. Augment the product matrix by appending a new row that consists of the column-wise sums of the product matrix. # Function Specification: Function: ```python def verify_and_augment_matrices(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]: pass ``` # Input: - `matrix_a`: A list of lists of integers representing the first matrix. - `matrix_b`: A list of lists of integers representing the second matrix. # Output: - A list of lists representing the augmented product matrix. # Constraints: - Both input matrices, `matrix_a` and `matrix_b`, are non-empty and contain at least one element. - Each matrix is well-formed, i.e., each row in a matrix has the same number of elements. - Elements of the matrices are integers. # Example: ```python # Example input matrices matrix_a = [ [1, 2, 3], [4, 5, 6] ] matrix_b = [ [7, 8], [9, 10], [11, 12] ] # Function call result = verify_and_augment_matrices(matrix_a, matrix_b) # Expected output print(result) # Output should be: # [ # [58, 64], # [139, 154], # [197, 218] # ] ``` # Additional Requirements: 1. If the matrices cannot be multiplied, raise a `ValueError` with the message: `\'Incompatible matrices for multiplication.\'`. 2. Ensure the computation aligns with matrix multiplication arithmetic rules. 3. Ensure proper validation to avoid index errors or misaligned dimensions. # Explanation: 1. **Matrix Verification**: Ensure the number of columns in `matrix_a` matches the number of rows in `matrix_b`. 2. **Matrix Multiplication**: Compute the resulting product matrix by implementing the standard matrix multiplication formula. 3. **Augmentation**: Compute the sum of each column in the product matrix and add this as a new row to the matrix. ```python def verify_and_augment_matrices(matrix_a, matrix_b): # Verify matrix dimensions if len(matrix_a[0]) != len(matrix_b): raise ValueError(\'Incompatible matrices for multiplication.\') # Initialize product matrix with zeroes product_matrix = [[0 for _ in range(len(matrix_b[0]))] for _ in range(len(matrix_a))] # Perform matrix multiplication for i in range(len(matrix_a)): for j in range(len(matrix_b[0])): for k in range(len(matrix_b)): product_matrix[i][j] += matrix_a[i][k] * matrix_b[k][j] # Calculate column sums column_sums = [sum(row[j] for row in product_matrix) for j in range(len(product_matrix[0]))] # Augment product matrix with column sums product_matrix.append(column_sums) return product_matrix # Example usage matrix_a = [ [1, 2, 3], [4, 5, 6] ] matrix_b = [ [7, 8], [9, 10], [11, 12] ] result = verify_and_augment_matrices(matrix_a, matrix_b) print(result) ``` This implementation validates the dimensions of the input matrices, multiplies them if valid, and augments the product matrix by appending a new row containing the sums of each column in the product matrix.","solution":"def verify_and_augment_matrices(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]: # Verify matrix dimensions if len(matrix_a[0]) != len(matrix_b): raise ValueError(\'Incompatible matrices for multiplication.\') # Initialize product matrix with zeroes product_matrix = [[0 for _ in range(len(matrix_b[0]))] for _ in range(len(matrix_a))] # Perform matrix multiplication for i in range(len(matrix_a)): for j in range(len(matrix_b[0])): for k in range(len(matrix_b)): product_matrix[i][j] += matrix_a[i][k] * matrix_b[k][j] # Calculate column sums column_sums = [sum(row[j] for row in product_matrix) for j in range(len(product_matrix[0]))] # Augment product matrix with column sums product_matrix.append(column_sums) return product_matrix"},{"question":"# Rotate Image Coding Assessment Question Context You are developing photo editing software that includes various image manipulation features. One of the core functionalities your users frequently request is the ability to rotate their images. Your task is to write a function that rotates a given N x N 2D matrix representing an image by 90 degrees clockwise. Description Write a function `rotate_image(matrix: list[list[int]]) -> None` that modifies the input matrix in-place to achieve a 90-degree clockwise rotation. The image is represented by an N x N 2D matrix where each cell contains an integer representing the pixel value. # Input - A square 2D list (`matrix`) representing the image. # Output - The function does not return anything. The input matrix should be modified in-place. # Constraints - The given matrix is N x N where `1 <= N <= 1000`. - Matrix cells contain integers. # Example ```python # Given the following matrix # [ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9] # ] matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_image(matrix) # After rotating by 90 degrees clockwise, the matrix should be # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` # Notes - Ensure your function modifies the input matrix in-place without using any additional space for another matrix. - Consider the edge cases such as the smallest and largest possible sizes of the matrix. - Optimize your function to handle larger matrices efficiently. Implement the `rotate_image` function to achieve the above requirements.","solution":"def rotate_image(matrix: list[list[int]]) -> None: Rotates the given NxN matrix by 90 degrees clockwise. Modifies the matrix in-place. n = len(matrix) # First step: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Second step: Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Question: Implement a Function to Simplify Expressions with Parentheses, Variables, and Addition/Subtraction Context You are a software engineer developing a tool to simplify mathematical expressions. The tool should parse expressions that include integer variables, addition, subtraction, and parentheses, and compute the result. You can assume all variables have integer values and are given in a dictionary. Task 1. Implement a function `simplify_expression(expr: str, vars: Dict[str, int]) -> int` that: - Takes a string `expr` representing a mathematical expression. - Uses a dictionary `vars` mapping variable names to their integer values. - Returns the simplified result as an integer. 2. The expression will be free from invalid characters and always properly balanced in terms of parentheses, but the function should handle potential edge cases related to arithmetic. Implementation Constraints - Handle nested parentheses correctly. - Handle addition and subtraction with variables. - Variables are case-sensitive. - The function should have linear time complexity, O(n), where n is the length of the expression string. Input and Output - **Input**: - `expr` is a string representing the mathematical expression. - `vars` is a dictionary mapping variable names (strings) to their integer values. - **Output**: An integer representing the simplified result. Examples ```python assert simplify_expression(\\"a + b - c\\", {\\"a\\": 5, \\"b\\": 10, \\"c\\": 3}) == 12 assert simplify_expression(\\"(a + (b - c)) + d\\", {\\"a\\": 1, \\"b\\": 7, \\"c\\": 2, \\"d\\": 3}) == 9 assert simplify_expression(\\"(x + y) - (z - w)\\", {\\"x\\": 10, \\"y\\": 20, \\"z\\": 5, \\"w\\": 2}) == 27 assert simplify_expression(\\"((p + q) - r)\\", {\\"p\\": 6, \\"q\\": 4, \\"r\\": 3}) == 7 assert simplify_expression(\\"u - (v + (w - x))\\", {\\"u\\": 10, \\"v\\": 1, \\"w\\": 2, \\"x\\": 1}) == 8 ``` Notes 1. The function should replace all variables with their values before performing arithmetic operations. 2. Ensure that nested and multiple levels of parentheses are correctly handled. 3. Variables\' names consist of alphabetical characters only.","solution":"def simplify_expression(expr: str, vars: dict) -> int: def eval_expr(expression, variables): stack, num, sign = [], 0, 1 result = 0 i = 0 while i < len(expression): char = expression[i] if char.isdigit(): num = num * 10 + int(char) elif char.isalpha(): var_name = \'\' while i < len(expression) and expression[i].isalpha(): var_name += expression[i] i += 1 i -= 1 num = variables[var_name] elif char == \'+\': result += sign * num num, sign = 0, 1 elif char == \'-\': result += sign * num num, sign = 0, -1 elif char == \'(\': stack.append(result) stack.append(sign) result, sign = 0, 1 elif char == \')\': result += sign * num result *= stack.pop() result += stack.pop() num = 0 i += 1 return result + sign * num return eval_expr(expr, vars)"},{"question":"**Problem Statement**: You are tasked with creating a function that simulates the behavior of a simple deterministic finite automaton (DFA) for a given set of rules and states. The function will check if a given string is accepted by the DFA based on its transition rules. **Function Specifications**: 1. **define_dfa**: - **Input**: `states: Dict[int, Dict[str, int]]` - A dictionary where keys are state identifiers (integers) and values are dictionaries mapping input characters to subsequent states. - **Output**: A function that represents the DFA with transitions based on the given rules. 2. **is_accepted**: - **Input**: `dfa: Callable[[str], bool]`, `initial_state: int`, `accepting_states: List[int]`, `input_string: str` - A DFA function, an initial state, a list of accepting states, and a string to check. - **Output**: `bool` - A boolean indicating if the input string is accepted by the DFA. When calling `define_dfa`, the function should return a nested function that takes an input string and processes it according to the DFA rules to check for acceptance. **Details**: The DFA operates by starting at the initial state and consuming input characters sequentially, transitioning through states as defined by the `states` dictionary. If after processing all input characters the DFA is in one of the accepting states, the string is accepted. **Constraints**: - The DFA states will be represented as integers. - Input characters will be lowercase English letters (`a-z`). - The `states` dictionary will ensure valid transitions for all possible inputs from each state. **Example**: ```python # Example DFA definition: states = { 0: {\'a\': 1, \'b\': 0}, 1: {\'a\': 1, \'b\': 2}, 2: {\'a\': 1, \'b\': 0}, } # Initial state: 0 # Accepting states: [2] dfa = define_dfa(states) print(is_accepted(dfa, 0, [2], \\"aab\\")) # Expected Output: True print(is_accepted(dfa, 0, [2], \\"aaa\\")) # Expected Output: False ``` # Implementation You need to implement the following functions: ```python def define_dfa(states: Dict[int, Dict[str, int]]) -> Callable[[str], bool]: # Implement the DFA definition returning a function pass def is_accepted(dfa: Callable[[str], bool], initial_state: int, accepting_states: List[int], input_string: str) -> bool: # Implement the function to check if the input string is accepted by the DFA pass ```","solution":"from typing import Callable, Dict, List def define_dfa(states: Dict[int, Dict[str, int]]) -> Callable[[int, str], bool]: def dfa(initial_state: int, input_string: str) -> int: current_state = initial_state for char in input_string: if char in states[current_state]: current_state = states[current_state][char] else: return -1 # Invalid transition return current_state return dfa def is_accepted(dfa: Callable[[int, str], bool], initial_state: int, accepting_states: List[int], input_string: str) -> bool: final_state = dfa(initial_state, input_string) return final_state in accepting_states"},{"question":"Median of Two Sorted Arrays Finding the median of two sorted arrays is a classic problem in computer science that tests your understanding of efficient searching and merging techniques. The median is the middle value in a list when it is sorted. If the list size is even, the median is the average of the two middle values. # Problem Statement You need to write a function that finds the median of two sorted arrays. # Input * Two sorted arrays `arr1` and `arr2` of sizes `m` and `n`, respectively. # Output * The median of the two arrays combined. # Constraints * Both arrays `arr1` and `arr2` are sorted in ascending order. * The combined length of the arrays will be `1 <= m + n <= 2*10^3`. * The elements of the arrays can be any integer, either positive or negative. # Example: ```python >>> median_of_two_arrays([1, 3], [2]) 2.0 >>> median_of_two_arrays([1, 2], [3, 4]) 2.5 >>> median_of_two_arrays([0, 0], [0, 0]) 0.0 >>> median_of_two_arrays([], [1]) 1.0 >>> median_of_two_arrays([2], []) 2.0 ``` # Task Implement the `median_of_two_arrays` function such that it finds the median efficiently.","solution":"def median_of_two_arrays(arr1, arr2): Finds the median of two sorted arrays. Parameters: arr1 (list[int]): The first sorted array. arr2 (list[int]): The second sorted array. Returns: float: The median of the two sorted arrays combined. merged = [] i, j = 0, 0 m, n = len(arr1), len(arr2) while i < m and j < n: if arr1[i] < arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 # Append the remaining elements while i < m: merged.append(arr1[i]) i += 1 while j < n: merged.append(arr2[j]) j += 1 # Find the median total_length = m + n if total_length % 2 == 1: return float(merged[total_length // 2]) else: mid1 = total_length // 2 mid2 = mid1 - 1 return (merged[mid1] + merged[mid2]) / 2"},{"question":"# Coding Assessment Question **Scenario**: In data processing and algorithm design, arrays are fundamental structures for storing and organizing collections of data. Efficiently manipulating arrays is crucial for various applications such as sorting algorithms, search procedures, and dynamic programming solutions. For instance, finding unique elements in a dataset or merging sorted arrays requires competency in array manipulation techniques. **Problem Statement**: You are required to implement functions that manipulate arrays to find unique elements and merge sorted arrays while preserving the sorted order. Design the following functions in Python: 1. `find_unique_elements(arr: List[int]) -> List[int]`: This function returns a list of unique elements from the given array `arr`. 2. `merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]`: This function merges two sorted arrays `arr1` and `arr2` and returns a single sorted array. # Function Signatures ```python def find_unique_elements(arr: List[int]) -> List[int]: pass def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: pass ``` # Input and Output Format * **Input**: * `arr` (List[int]): An array of integers which may contain duplicates. * `arr1`, `arr2` (List[int]): Two sorted arrays of integers. * **Output**: * `find_unique_elements` returns a list of unique integers from `arr` in the order they first appear. * `merge_sorted_arrays` returns a single list containing all the elements from `arr1` and `arr2` in sorted order. # Constraints * The arrays `arr`, `arr1`, and `arr2` can have up to 10^5 elements. * The integers within the arrays can range from -10^9 to 10^9. # Example ```python assert find_unique_elements([1, 2, 2, 3, 4, 4, 5]) == [1, 2, 3, 4, 5] assert find_unique_elements([7, 8, 9, 7, 8, 10]) == [7, 8, 9, 10] assert merge_sorted_arrays([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] assert merge_sorted_arrays([-5, 0, 2], [-6, -3, 1]) == [-6, -5, -3, 0, 1, 2] ``` Implement these functions as specified, ensuring efficient handling of large arrays using appropriate algorithms and data structures.","solution":"from typing import List def find_unique_elements(arr: List[int]) -> List[int]: Returns a list of unique elements from the given array. seen = set() unique_elements = [] for element in arr: if element not in seen: seen.add(element) unique_elements.append(element) return unique_elements def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: Merges two sorted arrays and returns a single sorted array. i, j = 0, 0 merged_array = [] while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 merged_array.extend(arr1[i:]) merged_array.extend(arr2[j:]) return merged_array"},{"question":"# Question Scenario: As part of a software development project, you are creating a system that tracks sales transactions, and you need to generate unique identifiers for each transaction. Each identifier is to consist of a prefix, a random numeric component, and a postfix. Task: Implement the function `generate_identifier` that takes two strings as input, a `prefix` and a `postfix`, and returns a unique identifier string. The identifier should: 1. Begin with the given `prefix`. 2. Contain a randomly generated 6-digit number. 3. End with the given `postfix`. Implementation: 1. Define the function `generate_identifier(prefix: str, postfix: str) -> str`. 2. Ensure the function handles the following: * The `prefix` and `postfix` should be concatenated appropriately with the random numeric component. * The random numeric component must be always 6 digits long. * Each generated identifier should be unique within a single execution (no duplicates). 3. Make use of Python\'s `random` library to generate the 6-digit number. Input: * Two strings `prefix` and `postfix`. Output: * A string representing the unique identifier. Constraints: * The lengths of `prefix` and `postfix` strings do not exceed 100 characters. * The inputs `prefix` and `postfix` consist only of alphanumeric characters (a-z, A-Z, 0-9). Examples: ```python >>> generate_identifier(\\"TRXN\\", \\"2021\\") \\"TRXN1234562021\\" # Output may vary due to randomness >>> generate_identifier(\\"INV\\", \\"Q3\\") \\"INV987654Q3\\" # Output may vary due to randomness >>> generate_identifier(\\"ORDER\\", \\"SHIP\\") \\"ORDER456789SHIP\\" # Output may vary due to randomness ``` Performance Requirements: The function should efficiently generate the unique identifier, and it should ensure that each generated identifier is unique in a single run of the program, even if called multiple times. # Note: For the examples above, the 6-digit numeric component is randomly generated, so the exact output will vary each time the function is called. Ensure to handle randomness in generating this component.","solution":"import random def generate_identifier(prefix: str, postfix: str) -> str: Generates a unique identifier consisting of a prefix, a 6-digit random numeric component, and a postfix. Args: prefix (str): The prefix of the identifier. postfix (str): The postfix of the identifier. Returns: str: The generated unique identifier. random_number = f\\"{random.randint(0, 999999):06d}\\" return f\\"{prefix}{random_number}{postfix}\\""},{"question":"# Problem Statement You are helping to create a component of a drawing application that involves manipulating and analyzing shapes represented as polygons. Each polygon is represented by a list of points (tuples of x, y coordinates), which are vertices of the polygon in order. Your task is to implement the following functionalities: 1. **Polygon Perimeter Calculation**: Implement a function to calculate the perimeter of a given polygon. 2. **Polygon Intersection Check**: Implement a function to determine if two given polygons intersect with each other. # Function Signature ```python def polygon_perimeter(polygon: list) -> float: @param: polygon (list of tuples, where each tuple represents a vertex (x, y) of the polygon) @return: the perimeter of the polygon Example: >>> polygon_perimeter([(0, 0), (4, 0), (4, 3), (0, 3)]) 14.0 pass def polygons_intersect(polygon1: list, polygon2: list) -> bool: @param: polygon1 (list of tuples, where each tuple represents a vertex (x, y) of the first polygon) @param: polygon2 (list of tuples, where each tuple represents a vertex (x, y) of the second polygon) @return: True if the polygons intersect, False otherwise Example: >>> polygons_intersect([(0, 0), (4, 0), (4, 3), (0, 3)], [(2, 2), (6, 2), (6, 5), (2, 5)]) True >>> polygons_intersect([(0, 0), (4, 0), (4, 3), (0, 3)], [(5, 5), (9, 5), (9, 8), (5, 8)]) False pass ``` # Input/Output * **Input**: - For `polygon_perimeter`: A list of tuples representing the vertices of the polygon. - For `polygons_intersect`: Two lists of tuples each representing the vertices of two polygons. * **Output**: - For `polygon_perimeter`: A float representing the perimeter of the polygon. - For `polygons_intersect`: A boolean value indicating whether the two polygons intersect. # Constraints * The vertices of the polygon will be given in order. * There will be no self-intersecting polygons. * Each polygon will have at least 3 vertices and at most 1000 vertices. * The input coordinates are integers where each coordinate (x, y) has an absolute value less than or equal to 10,000. # Scenario The functionalities could be used in a drawing application that allows users to create and manipulate shapes. Being able to calculate the perimeter of drawn shapes is essential for functions like stroke measurements and material estimation. Checking for polygon intersections is important for detecting overlaps between different shapes on the canvas, which may affect rendering, physics simulations, or user interactions.","solution":"import math def polygon_perimeter(polygon: list) -> float: Calculate the perimeter of a polygon given its vertices. polygon: list of tuples (x, y) representing vertices of the polygon in order. return: float representing the perimeter of the polygon perimeter = 0.0 n = len(polygon) for i in range(n): x1, y1 = polygon[i] x2, y2 = polygon[(i + 1) % n] perimeter += math.dist((x1, y1), (x2, y2)) return perimeter def polygons_intersect(polygon1: list, polygon2: list) -> bool: Determine if two given polygons intersect with each other. polygon1: list of tuples (x, y) representing vertices of the first polygon. polygon2: list of tuples (x, y) representing vertices of the second polygon. return: boolean value. True if the polygons intersect, else False. def on_segment(p, q, r): if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])): return True return False def orientation(p, q, r): val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]) if val == 0: return 0 return 1 if val > 0 else 2 def do_intersect(p1, q1, p2, q2): o1 = orientation(p1, q1, p2) o2 = orientation(p1, q1, q2) o3 = orientation(p2, q2, p1) o4 = orientation(p2, q2, q1) if o1 != o2 and o3 != o4: return True if o1 == 0 and on_segment(p1, p2, q1): return True if o2 == 0 and on_segment(p1, q2, q1): return True if o3 == 0 and on_segment(p2, p1, q2): return True if o4 == 0 and on_segment(p2, q1, q2): return True return False def polygon_intersects_polygon(poly1, poly2): for i in range(len(poly1)): for j in range(len(poly2)): if do_intersect(poly1[i], poly1[(i + 1) % len(poly1)], poly2[j], poly2[(j + 1) % len(poly2)]): return True return False return polygon_intersects_polygon(polygon1, polygon2)"},{"question":"# Problem Statement You are given a list of integers representing the heights of buildings along a street. Your task is to calculate the number of buildings that have a view of the sunset when viewed from the left to the right of the list. A building has a view of the sunset if all the buildings before it in the list have a smaller height. Input - A list of integers `heights` of length `n` (1 ≤ n ≤ 10^5), where each integer represents the height of a building. Output - Return an integer that represents the number of buildings with a view of the sunset. Example ```python >>> count_sunset_view_buildings([7, 4, 8, 2, 9]) 3 >>> count_sunset_view_buildings([1, 2, 3, 4, 5]) 5 >>> count_sunset_view_buildings([5, 4, 3, 2, 1]) 1 ``` Constraints - The list of heights will only contain positive integers. - The heights of buildings are all unique. Requirements - The implementation should run in linear time O(n). Additional Notes To solve this problem, you can iterate through the list while maintaining the maximum height encountered so far and count the building heights greater than this max height.","solution":"def count_sunset_view_buildings(heights): Returns the number of buildings that have a view of the sunset when viewed from left to right. Parameters: heights (list of int): The heights of buildings along the street. Returns: int: The number of buildings with a view of the sunset. max_height = float(\'-inf\') count = 0 for height in heights: if height > max_height: count += 1 max_height = height return count"},{"question":"# Missing Number in Arithmetic Sequence You are tasked with finding the missing number in an arithmetic sequence. An arithmetic sequence is a sequence of numbers in which the difference between any two consecutive terms is constant. You will be given an array representing the sequence with one number missing. # Task Write a function `missing_number(sequence: List[int]) -> int` that takes a list of integers representing the arithmetic sequence and returns the missing number. # Expected Input and Output Format Input: * `sequence` is a list of integers representing the arithmetic sequence with one number missing. The list will have at least three elements, and the missing element will ensure the properties of the sequence are maintained. Output: * A single integer representing the missing number in the sequence. # Constraints and Limitations - The arithmetic sequence will have at least three elements after the missing number is included. - The list will contain no duplicates. - The sequence may include negative numbers. # Example Example 1: ```python assert missing_number([5, 10, 15, 25, 30]) == 20 ``` Here, the sequence should be `[5, 10, 15, 20, 25, 30]` with a difference of 5. The missing number is `20`. Example 2: ```python assert missing_number([-2, 0, 2, 6]) == 4 ``` Here, the sequence should be `[-2, 0, 2, 4, 6]` with a difference of 2. The missing number is `4`. # Notes: 1. The difference between consecutive elements in the sequence is constant. 2. There will always be exactly one number missing from the sequence. 3. Return the missing number that allows the sequence to maintain its arithmetic property.","solution":"def missing_number(sequence): Returns the missing number in the arithmetic sequence. n = len(sequence) # Calculate the common difference (using the first two elements) difference = (sequence[-1] - sequence[0]) // n # Expected value calculation for i in range(1, n): expected_value = sequence[0] + i * difference if sequence[i] != expected_value: return expected_value # Example usage print(missing_number([5, 10, 15, 25, 30])) # Output should be 20 print(missing_number([-2, 0, 2, 6])) # Output should be 4"},{"question":"# Coding Assessment Question You are tasked with implementing a function that takes a positive integer `n` and returns the `n`th term in the Fibonacci sequence. The Fibonacci sequence is defined as follows: - The first term is 0. - The second term is 1. - Each subsequent term is the sum of the two preceding ones. Your function should efficiently compute the result even for larger values of `n`. # Function Signature: ```python def fibonacci(n: int) -> int: ``` # Input: - `n` (int): A positive integer indicating the term number in the Fibonacci sequence. # Output: - Returns an integer representing the `n`th term in the Fibonacci sequence. # Constraints: - ( 1 leq n leq 10^5 ) # Examples: - Example 1: ```python print(fibonacci(1)) # Output: 0 ``` - Example 2: ```python print(fibonacci(2)) # Output: 1 ``` - Example 3: ```python print(fibonacci(10)) # Output: 34 ``` - Example 4: ```python print(fibonacci(50)) # Output: 7778742049 ``` # Notes: - You are encouraged to use a dynamic programming approach to handle larger values of `n` efficiently. - Memoization or an iterative approach are both acceptable, but solutions that involve simple recursion will likely be inefficient for larger `n`.","solution":"def fibonacci(n: int) -> int: Returns the nth term in the Fibonacci sequence. if n == 1: return 0 elif n == 2: return 1 a, b = 0, 1 for _ in range(3, n + 1): a, b = b, a + b return b"},{"question":"# Coding Assessment Question Scenario: Your task is to develop a utility function for monitoring a network by checking the IP addresses that are currently active. For simplicity, we\'ll use IPv4 addresses, and you need to identify and return the active IP addresses in a sorted order. Task: Write a Python function `get_active_ips(logs: List[str]) -> List[str]` that: * Takes a list of strings called `logs` where each string represents a log entry in the format \\"IP_ADDRESS - STATUS\\". * Extracts the unique IP addresses that have a status of \\"ACTIVE\\". * Returns a sorted list of these active IP addresses. # Specifications: * **Input**: A list of strings `logs` where each string is formatted as \\"IP_ADDRESS - STATUS\\". * **Output**: A sorted list of unique IP addresses that have a status of \\"ACTIVE\\". # Constraints: * The IP addresses in the logs will follow valid IPv4 format. * The status will be either \\"ACTIVE\\" or \\"INACTIVE\\". * You may assume that the list `logs` is non-empty. * If no IP addresses are active, return an empty list. Example Inputs and Outputs: 1. `get_active_ips([\\"192.168.0.1 - ACTIVE\\", \\"192.168.0.2 - INACTIVE\\", \\"192.168.0.1 - ACTIVE\\"])` should return `[\'192.168.0.1\']` 2. `get_active_ips([\\"10.0.0.1 - ACTIVE\\", \\"192.168.1.1 - ACTIVE\\", \\"10.0.0.1 - INACTIVE\\", \\"192.168.1.2 - ACTIVE\\"])` should return `[\'10.0.0.1\', \'192.168.1.1\', \'192.168.1.2\']` 3. `get_active_ips([\\"127.0.0.1 - INACTIVE\\", \\"10.0.0.2 - INACTIVE\\"])` should return `[]` # Edge Cases: 1. All the IP addresses have a status of \\"INACTIVE\\". 2. Multiple log entries for the same IP address with varying statuses. 3. The input list `logs` is non-empty, but contains only entries with \\"INACTIVE\\" status. # Example Error Handling: 1. If the input does not follow the \\"IP_ADDRESS - STATUS\\" format, raise a `ValueError` with the message \\"Invalid log entry format\\". 2. If the input list contains an invalid IP address format, raise a `ValueError` with the message \\"Invalid IP address format\\". # Note: Ensure your function handles all edge cases as specified to maintain robustness and correctness of your implementation.","solution":"from typing import List import re def validate_ip(ip: str) -> bool: Validate an IP address to ensure it follows a valid IPv4 format. pattern = re.compile( r\'^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}\' r\'(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\' ) return pattern.match(ip) is not None def get_active_ips(logs: List[str]) -> List[str]: Returns a sorted list of unique IP addresses that have a status of \\"ACTIVE\\". active_ips = set() for log in logs: try: ip, status = log.split(\' - \') except ValueError: raise ValueError(\\"Invalid log entry format\\") if not validate_ip(ip): raise ValueError(\\"Invalid IP address format\\") if status == \\"ACTIVE\\": active_ips.add(ip) return sorted(active_ips)"},{"question":"# Problem Statement # Find the Missing Number You are given an array of integers containing `n` distinct numbers taken from the range `0` to `n`. Write a function `find_missing_number(arr: List[int]) -> int` that finds the single number in the range that is missing from the array. # Input * `arr` - A list of integers (length `n`, contains distinct numbers from `0` to `n`, where one number is missing). # Output An integer representing the missing number from the array. # Constraints * The length of the array (`n`) will be in the range 1 ≤ n ≤ 10^5. * Ensure that your solution has O(n) time complexity and uses O(1) extra space. # Example ```python def test_find_missing_number(): assert find_missing_number([3, 0, 1]) == 2 assert find_missing_number([0, 1, 3, 4, 5]) == 2 assert find_missing_number([0, 1]) == 2 assert find_missing_number([0, 3, 4, 1, 2, 5, 7, 6]) == 8 print(\\"All test cases pass\\") test_find_missing_number() ``` # Note To verify the correctness of your solution, you can run the provided test cases. Ensure your function performs efficiently within the given constraints.","solution":"def find_missing_number(arr): Find the missing number in the given list. Args: arr: List[int] -- list of n distinct numbers taken from the range 0 to n Returns: int -- the missing number from the list n = len(arr) total_sum = n * (n + 1) // 2 # sum of first n numbers (inclusive of n) array_sum = sum(arr) return total_sum - array_sum"},{"question":"# Sum of Unique Primes Problem Statement: Given an array of integers, determine the sum of all unique prime numbers present in the array. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Your task is to implement a function that takes an array of integers and returns the sum of its unique prime numbers. Input: - A list of integers `arr` (0 <= len(arr) <= 10^6, -10^6 <= arr[i] <= 10^6 for 0 <= i < len(arr)). Output: - Return the sum of all unique prime numbers present in the array. Example: ```python sum_of_unique_primes([3, 11, 11, 4, 5, -2, 2, 6, 3]) # Output: 21 (3 + 11 + 5 + 2) sum_of_unique_primes([4, 6, 8, 10]) # Output: 0 sum_of_unique_primes([7, 7, 9, 9, 7]) # Output: 7 ``` Constraints: - Focus on optimizing the performance for large input sizes, consider using efficient algorithms or data structures. - Prime-checking should be efficient to handle large potential inputs. Implementation Requirements: - Ensure that the function handles edge cases such as an empty array or negative numbers correctly. - Consider using a set to keep track of the unique numbers and a sieve algorithm for prime checking. Starter Code: ```python from math import isqrt def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def sum_of_unique_primes(arr): Calculate the sum of all unique prime numbers in the given array. :param arr: list: the list of integers to check :return: int: sum of unique prime numbers unique_numbers = set(arr) prime_sum = sum(x for x in unique_numbers if is_prime(x)) return prime_sum # Example usage: if __name__ == \\"__main__\\": arr = list(map(int, input(\\"Enter numbers separated by space: \\").strip().split())) result = sum_of_unique_primes(arr) print(f\\"The sum of unique primes is {result}.\\") ```","solution":"from math import isqrt def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def sum_of_unique_primes(arr): Calculate the sum of all unique prime numbers in the given array. :param arr: list: the list of integers to check :return: int: sum of unique prime numbers unique_numbers = set(arr) prime_sum = sum(x for x in unique_numbers if is_prime(x) and x > 1) return prime_sum"},{"question":"# Question You are asked to implement a function that detects peaks in a given 1D NumPy array of data. Peaks are defined as points that are higher than their immediate neighbors. Your function should be able to handle typical edge cases, such as arrays with all identical values, or very short arrays (less than three elements). The provided Python function `detect_peaks` should return the indices of the peak elements in the array. Here\'s the outline of the steps you\'ll need to follow for peak detection: 1. Iterate through the array elements with indices from 1 to the second last element. 2. Check if the current element is greater than its immediate neighbors. 3. Return the indices of all such peak elements. Function Signature ```python def detect_peaks(data: np.ndarray) -> List[int]: pass ``` **Constraints**: - The input array will have at least one element. - The input array can contain negative values. - If the array has fewer than three elements, handle the edge cases as appropriate. **Example**: ```python import numpy as np data1 = np.array([1, 3, 1, 2, 5, 6, 4]) data2 = np.array([1, 1, 1, 1]) data3 = np.array([3]) peak_indices1 = detect_peaks(data1) peak_indices2 = detect_peaks(data2) peak_indices3 = detect_peaks(data3) print(peak_indices1) # Expected output: [1, 5] print(peak_indices2) # Expected output: [] print(peak_indices3) # Expected output: [0] or [] ``` **Explanation**: - For `data1`, the peaks are at indices 1 (value 3) and 5 (value 6). - For `data2`, there are no peaks since all values are identical. - For `data3`, depending on your implementation, having only one element might either count as a peak or not.","solution":"import numpy as np from typing import List def detect_peaks(data: np.ndarray) -> List[int]: Detects peaks in a 1D NumPy array. Peaks are defined as elements that are greater than their immediate neighbors. if len(data) == 0: return [] if len(data) == 1: return [0] # Only one element, considered as a peak itself if len(data) == 2: return [] # Two elements can\'t have a peak peak_indices = [] for i in range(1, len(data) - 1): if data[i] > data[i - 1] and data[i] > data[i + 1]: peak_indices.append(i) return peak_indices"},{"question":"# Coding Assessment Question Context: String permutation problems are a common challenge in computer science and are often utilized in interviews to test a candidate\'s understanding of recursion and backtracking. Given two strings, we need to determine if one string is a permutation of the other. Task: Write a function `are_permutations(str1, str2)` that checks if two given strings are permutations of each other. Requirements: 1. Implement a function `are_permutations(str1: str, str2: str) -> bool`. 2. The function should: - Raise a `ValueError` if either string is empty or if their lengths differ. - Determine if `str1` and `str2` are permutations of each other and return `True` or `False`. 3. The function should be case-sensitive (\'abc\' is not a permutation of \'ABC\') and consider spaces. Input: - `str1` (str): The first string. - `str2` (str): The second string. Output: - Returns `True` if `str1` and `str2` are permutations of each other, `False` otherwise. Constraints: - Assume the length of each string is at most 100,000 characters. - Optimize the solution for performance, considering the constraints. Performance Expectations: - Expected time complexity is ( O(n log n) ) if sorting is used or ( O(n) ) if hashmaps are used, where n is the length of the strings. Example: ```python >>> are_permutations(\\"abc\\", \\"bca\\") True >>> are_permutations(\\"abc\\", \\"abcd\\") False >>> are_permutations(\\"abc \\", \\" cba\\") True >>> are_permutations(\\"abc\\", \\"ABC\\") False ``` Edge Cases: - Input of empty strings should raise a `ValueError`. - Strings of different lengths should return `False`. # Solution Outline: - The function first checks if the lengths of the two strings are different or either string is empty, raising a `ValueError` if any of these conditions are met. - If the strings have the same length, the function proceeds to check if they contain the same characters in the same frequency, which can be efficiently done using a hashmap or by sorting both strings and comparing them directly.","solution":"def are_permutations(str1, str2): Checks if two given strings are permutations of each other. :param str1: The first string. :param str2: The second string. :return: True if str1 and str2 are permutations of each other, False otherwise. :raises ValueError: If either string is empty or if their lengths differ. if not str1 or not str2: raise ValueError(\\"Strings must not be empty.\\") if len(str1) != len(str2): return False return sorted(str1) == sorted(str2)"},{"question":"# Coding Assessment Question **Objective:** Write a function to find the smallest missing positive integer from an unsorted list of integers. The solution should have an optimal time complexity of O(n). **Function Signature:** ```python def find_smallest_missing_positive(nums: list[int]) -> int: pass ``` **Input/Output Format:** - Input: A list of integers `nums` which may contain both negative and positive numbers and zeros. - Output: Return the smallest missing positive integer from the list. **Constraints:** - The length of the list `nums` is between 1 and 10^5. - The values in the list `nums` are in the range [-10^6, 10^6]. **Example:** ```python assert find_smallest_missing_positive([3, 4, -1, 1]) == 2 assert find_smallest_missing_positive([1, 2, 0]) == 3 assert find_smallest_missing_positive([7, 8, 9, 11, 12]) == 1 assert find_smallest_missing_positive([1, 1, 0, -1, -2]) == 2 assert find_smallest_missing_positive([2]) == 1 ``` **Performance Requirements:** - The solution should run in O(n) time and use O(1) extra space (excluding the input space). **Scenario:** You are asked to implement a key feature for a data integrity check in a database system. The system needs to quickly determine the smallest missing positive integer from a list of record identifiers to maintain a sequential and efficient identifier allocation. This check needs to be performed optimally to support data integrity guarantees even when the dataset is large.","solution":"def find_smallest_missing_positive(nums: list[int]) -> int: n = len(nums) # Step 1: Mark numbers which are out of the range (1 to n) for i in range(n): if nums[i] <= 0 or nums[i] > n: nums[i] = n + 1 # Step 2: Mark the index corresponding to the number for i in range(n): num = abs(nums[i]) if num <= n: nums[num - 1] = -abs(nums[num - 1]) # Step 3: Find the first index which is not marked for i in range(n): if nums[i] > 0: return i + 1 # Step 4: If all indices are marked, return n + 1 return n + 1"},{"question":"**Graph Traversal Path Finding** You are given a weighted undirected graph represented using an adjacency list. Your task is to implement an algorithm that finds the shortest path between two nodes using Dijkstra\'s algorithm. # Task 1. **Implement Dijkstra\'s Algorithm**: Create a function `dijkstra(graph, start_node, end_node)` that computes the shortest path from `start_node` to `end_node`. 2. **Graph Representation**: - Nodes are numbered from `0` to `N-1`. - The graph is represented as an adjacency list where `graph[i]` contains a list of tuples `(neighbor, weight)` representing the neighboring nodes and the weight of the edge connecting them. # Requirements 1. **dijkstra**: - Input: Graph (as an adjacency list), `start_node` (integer), `end_node` (integer). - Output: The shortest distance from `start_node` to `end_node`. - If there is no path from `start_node` to `end_node`, return `-1`. # Constraints - The number of nodes `N` in the graph is at most `10^4`. - Each edge weight is a positive integer. # Example ```python graph = [ [(1, 2), (2, 4)], # Edges from node 0 [(0, 2), (2, 1), (3, 7)], # Edges from node 1 [(0, 4), (1, 1), (3, 2)], # Edges from node 2 [(1, 7), (2, 2)] # Edges from node 3 ] print(dijkstra(graph, 0, 3)) # Output: 5 print(dijkstra(graph, 1, 0)) # Output: 2 print(dijkstra(graph, 0, 4)) # Output: -1 (if node 4 does not exist in the graph) ``` Please ensure the implementation is efficient and can handle the maximum constraints.","solution":"import heapq def dijkstra(graph, start_node, end_node): Computes the shortest path from start_node to end_node in a weighted graph using Dijkstra\'s algorithm. Returns the shortest distance or -1 if no such path exists. # Initialize the priority queue with the start node and distance priority_queue = [(0, start_node)] # Dictionary to store the shortest distance to each node distances = {node: float(\'inf\') for node in range(len(graph))} distances[start_node] = 0 while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If the current node is the end node, return the distance if current_node == end_node: return current_distance # If the current distance is greater than the recorded distance, continue if current_distance > distances[current_node]: continue # Explore neighboring nodes for neighbor, weight in graph[current_node]: distance = current_distance + weight # Only consider this new path if it is shorter if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) # If the end node was never reached, return -1 return -1 if distances[end_node] == float(\'inf\') else distances[end_node]"},{"question":"# Context You are part of a puzzle-loving developer group, and you enjoy crafting creative problem-solving activities. Your group wants to use a conceptually simple but logically challenging algorithm to demonstrate the importance of understanding looping constructs and conditionals in programming. # Task Implement a function called `reversefibonacci(n)` which generates a list of the first `n` Fibonacci numbers in reverse order. The Fibonacci sequence: 1. The first two numbers are: `fib(0) = 0` and `fib(1) = 1`. 2. Each subsequent number is the sum of the previous two: `fib(n) = fib(n-1) + fib(n-2)` for `n > 1`. # Specifications * **Input Format**: - A single integer, `n`, indicating the number of Fibonacci numbers to generate. * **Constraints**: - `n` is an integer such that `0 <= n <= 30`. * **Output Format**: - A list of the first `n` Fibonacci numbers in reverse order. # Example ```python >>> reversefibonacci(0) [] >>> reversefibonacci(1) [0] >>> reversefibonacci(2) [1, 0] >>> reversefibonacci(5) [3, 2, 1, 1, 0] >>> reversefibonacci(10) [34, 21, 13, 8, 5, 3, 2, 1, 1, 0] ``` # Notes - Ensure your function handles all edge cases, including `n = 0` and `n = 1`. - Consider the efficiency and readability of your code. While the constraints allow for straightforward solutions, aim for clarity in demonstrating the fundamental concepts of looping and conditionals. This problem tests your ability to manage loop constructs and simple list operations, providing practice in algorithmic thinking with a familiar, yet creatively twisted, problem.","solution":"def reversefibonacci(n): Generates a list of the first `n` Fibonacci numbers in reverse order. :param n: Number of Fibonacci numbers to generate :return: List of Fibonacci numbers in reverse order if n == 0: return [] fibonacci_sequence = [0, 1] for i in range(2, n): next_fib = fibonacci_sequence[-1] + fibonacci_sequence[-2] fibonacci_sequence.append(next_fib) return fibonacci_sequence[:n][::-1]"},{"question":"# Problem Statement: Warehouse Inventory Management System You are required to implement a `WarehouseInventory` class in Python to manage the inventory of a warehouse. This system should enable adding, updating, and querying the inventory efficiently. # Requirements: 1. **Add Item**: Add items to the inventory. If the item already exists, increase the quantity. 2. **Remove Item**: Remove items from the inventory. Ensure the quantity to be removed does not exceed the current stock. 3. **Update Item Quantity**: Update the quantity of a specific item directly. 4. **Query Item**: Return the details of a specific item. 5. **Inventory Summary**: Provide a summary of all items including their quantity. # Class and Method Specifications: * `__init__`: Initialize the inventory. * `add_item(item_name: str, quantity: int)`: Adds a specific quantity of the item to the inventory. * `remove_item(item_name: str, quantity: int)`: Removes a specific quantity of the item from the inventory. * `update_item_quantity(item_name: str, quantity: int)`: Updates the quantity directly to the specified number. * `query_item(item_name: str) -> dict`: Returns a dictionary with item details (name and quantity). * `inventory_summary() -> dict`: Returns a dictionary with item names as keys and their quantities as values. # Input Constraints: * `item_name`: A string containing only alphabetic characters (case-insensitive, but stored in lowercase). * `quantity`: An integer with a value between 0 and 10,000. # Edge Cases: * Attempting to remove more items than available in inventory should raise an `InsufficientStockError` (custom exception). * Adding an item with zero or negative quantity should not affect the inventory. * Updating an item with zero or negative quantity should remove the item from the inventory. # Example: ```python # Creating a new warehouse inventory instance warehouse = WarehouseInventory() # Adding items warehouse.add_item(\\"Widget\\", 50) warehouse.add_item(\\"Widget\\", 10) # Querying items print(warehouse.query_item(\\"widget\\")) # Output: {\'name\': \'widget\', \'quantity\': 60} # Removing items warehouse.remove_item(\\"Widget\\", 30) # Updating item quantity warehouse.update_item_quantity(\\"widget\\", 100) # Inventory summary print(warehouse.inventory_summary()) # Output: {\'widget\': 100} ``` # Hint: You may want to create a custom exception class `InsufficientStockError` to handle scenarios where there is an attempt to remove more items than available. NaNvalues should not be allowed for item quantities. Implementing efficient data structures such as dictionaries will ensure optimal performance for lookups and updates in the inventory system. Custom Exception Example: ```python class InsufficientStockError(Exception): pass ```","solution":"class InsufficientStockError(Exception): pass class WarehouseInventory: def __init__(self): self.inventory = {} def add_item(self, item_name: str, quantity: int): item_name = item_name.lower() if quantity > 0: if item_name in self.inventory: self.inventory[item_name] += quantity else: self.inventory[item_name] = quantity def remove_item(self, item_name: str, quantity: int): item_name = item_name.lower() if item_name not in self.inventory: raise InsufficientStockError(f\\"Item \'{item_name}\' not found in inventory.\\") if quantity > self.inventory[item_name]: raise InsufficientStockError(f\\"Insufficient stock for item \'{item_name}\'.\\") self.inventory[item_name] -= quantity if self.inventory[item_name] == 0: del self.inventory[item_name] def update_item_quantity(self, item_name: str, quantity: int): item_name = item_name.lower() if quantity <= 0: if item_name in self.inventory: del self.inventory[item_name] else: self.inventory[item_name] = quantity def query_item(self, item_name: str) -> dict: item_name = item_name.lower() if item_name in self.inventory: return {\'name\': item_name, \'quantity\': self.inventory[item_name]} return {} def inventory_summary(self) -> dict: return self.inventory"},{"question":"# Question: A company wants to track the inventory of its product lines using a dynamic inventory system. Each product has a unique identifier, name, quantity in stock, and price per unit. Implement a class `Inventory` in Python that provides methods to add a new product, update the stock of an existing product, remove a product, and display the inventory in a sorted manner (sorted by product name). # Objective: Develop a class `Inventory` that helps manage and track products. Enhance its functionality by adding sorting capabilities and other inventory management methods. # Requirements: 1. **Data Members**: - A list to store product records. Each record is a dictionary with keys `id`, `name`, `quantity`, and `price`. 2. **Methods**: - `add_product(id: str, name: str, quantity: int, price: float) -> None`: Adds a new product to the inventory. If the product id already exists, raise a `ValueError`. - `update_stock(id: str, quantity: int) -> None`: Updates the stock quantity of an existing product. If the product id does not exist, raise a `ValueError`. - `remove_product(id: str) -> None`: Removes a product from the inventory using its identifier. If the product id does not exist, raise a `ValueError`. - `display_inventory() -> str`: Returns a string representation of the inventory, sorted by product name. # Example: ```python class Inventory: def __init__(self): self.products = [] def add_product(self, id: str, name: str, quantity: int, price: float) -> None: Adds a new product to the inventory. Args: - id: Unique identifier for the product. - name: Name of the product. - quantity: Number of items in stock. - price: Price per unit. Raises: - ValueError: If the product id already exists. if any(product[\'id\'] == id for product in self.products): raise ValueError(f\\"Product ID {id} already exists.\\") self.products.append({\'id\': id, \'name\': name, \'quantity\': quantity, \'price\': price}) def update_stock(self, id: str, quantity: int) -> None: Updates the stock of an existing product. Args: - id: Unique identifier for the product. - quantity: New stock quantity. Raises: - ValueError: If the product id does not exist. for product in self.products: if product[\'id\'] == id: product[\'quantity\'] = quantity return raise ValueError(f\\"Product ID {id} not found.\\") def remove_product(self, id: str) -> None: Removes a product from the inventory. Args: - id: Unique identifier for the product. Raises: - ValueError: If the product id does not exist. for product in self.products: if product[\'id\'] == id: self.products.remove(product) return raise ValueError(f\\"Product ID {id} not found.\\") def display_inventory(self) -> str: Displays the inventory sorted by product name. Returns: - A string representation of the sorted inventory. sorted_inventory = sorted(self.products, key=lambda x: x[\'name\']) display_str = \'n\'.join( f\\"ID: {product[\'id\']}, Name: {product[\'name\']}, Quantity: {product[\'quantity\']}, Price: {product[\'price\']:.2f}\\" for product in sorted_inventory) return display_str # Example usage: inventory = Inventory() inventory.add_product(\\"001\\", \\"Laptop\\", 10, 999.99) inventory.add_product(\\"002\\", \\"Smartphone\\", 20, 499.99) inventory.update_stock(\\"002\\", 25) inventory.remove_product(\\"001\\") print(inventory.display_inventory()) # Output: # ID: 002, Name: Smartphone, Quantity: 25, Price: 499.99 ``` # Instructions: 1. Implement the `Inventory` class with the specified methods. 2. Ensure the methods handle edge cases such as adding a product with an existing ID, updating or removing non-existent products. 3. Test the class with various scenarios including adding, updating, removing products, and displaying the inventory.","solution":"class Inventory: def __init__(self): self.products = [] def add_product(self, id: str, name: str, quantity: int, price: float) -> None: Adds a new product to the inventory. Args: - id: Unique identifier for the product. - name: Name of the product. - quantity: Number of items in stock. - price: Price per unit. Raises: - ValueError: If the product id already exists. if any(product[\'id\'] == id for product in self.products): raise ValueError(f\\"Product ID {id} already exists.\\") self.products.append({\'id\': id, \'name\': name, \'quantity\': quantity, \'price\': price}) def update_stock(self, id: str, quantity: int) -> None: Updates the stock of an existing product. Args: - id: Unique identifier for the product. - quantity: New stock quantity. Raises: - ValueError: If the product id does not exist. for product in self.products: if product[\'id\'] == id: product[\'quantity\'] = quantity return raise ValueError(f\\"Product ID {id} not found.\\") def remove_product(self, id: str) -> None: Removes a product from the inventory. Args: - id: Unique identifier for the product. Raises: - ValueError: If the product id does not exist. for product in self.products: if product[\'id\'] == id: self.products.remove(product) return raise ValueError(f\\"Product ID {id} not found.\\") def display_inventory(self) -> str: Displays the inventory sorted by product name. Returns: - A string representation of the sorted inventory. sorted_inventory = sorted(self.products, key=lambda x: x[\'name\']) display_str = \'n\'.join( f\\"ID: {product[\'id\']}, Name: {product[\'name\']}, Quantity: {product[\'quantity\']}, Price: {product[\'price\']:.2f}\\" for product in sorted_inventory) return display_str"},{"question":"# Question You are provided with a string `s` consisting of lowercase letters and an integer `n`. Your task is to write a function `shift_string(s: str, n: int) -> str` that returns a new string with each character in the original string shifted `n` positions forward in the alphabet. If the shift moves past \'z\', it should wrap around to \'a\'. Constraints: - The shift amount `n` will always be a non-negative integer. - The string `s` will contain only lowercase letters (\'a\' to \'z\') and will have a length between 1 and 100. Example: ```python >>> shift_string(\\"abc\\", 1) \'bcd\' >>> shift_string(\\"xyz\\", 3) \'abc\' >>> shift_string(\\"hello\\", 13) \'uryyb\' >>> shift_string(\\"apple\\", 25) \'zookd\' >>> shift_string(\\"shiftme\\", 52) \'shiftme\' >>> shift_string(\\"wraparound\\", 26) \'wraparound\' >>> shift_string(\\"negative\\", 0) \'negative\' >>> shift_string(\\"overshift\\", 130) \'overshift\' ``` Notes: - Your function should handle the wrap-around correctly by using modulo arithmetic. - Ensure your solution efficiently processes the string even at its maximum length.","solution":"def shift_string(s: str, n: int) -> str: Shifts each character in the string s by n positions forward in the alphabet. Wraps around if the shift moves past \'z\'. shifted_string = [] for char in s: shifted_char = chr((ord(char) - ord(\'a\') + n) % 26 + ord(\'a\')) shifted_string.append(shifted_char) return \'\'.join(shifted_string)"},{"question":"# Movie Data Analyzer You are tasked with creating a function that analyzes a list of movies to provide insights about certain attributes of those movies. The function will receive a list of movies where each movie is a dictionary containing details such as the title, release year, genre, rating, and director. The function should be able to calculate various statistics based on user-specified criteria. # Function Signature ```python def analyze_movies(movies: list, criteria: str, sub_criteria: str = None) -> dict: ... ``` # Input Descriptions - `movies` (list): A list of dictionaries, where each dictionary represents a movie with the following structure: * \\"title\\" (str): The title of the movie. * \\"year\\" (int): The release year of the movie. * \\"genre\\" (str): The genre of the movie. * \\"rating\\" (float): The rating of the movie (e.g., IMDB rating). * \\"director\\" (str): The director of the movie. - `criteria` (str): The primary criteria by which to analyze the movies. Possible values are: * \\"year\\": Analyze movies based on their release year. * \\"genre\\": Analyze movies based on their genre. * \\"director\\": Analyze movies based on their director. * \\"rating\\": Analyze movies based on their rating. - `sub_criteria` (str, optional): The secondary criteria to further filter or group the analysis. If provided, the function should consider this sub-criteria while analyzing. Possible values depend on the primary criteria: * If `criteria` is \\"year\\", sub-criteria can be \\"top_rated\\". * If `criteria` is \\"genre\\", sub-criteria can be \\"highest_grossing\\". * If `criteria` is \\"director\\", sub-criteria can be \\"most_movies\\". * If `criteria` is \\"rating\\", sub-criteria can be \\"most_critic_acclaimed\\". # Output Description The function should return a dictionary with analysis results based on the criteria and sub-criteria specified. # Constraints 1. If `criteria` is not one of the specified values, the function should raise a `ValueError` with an appropriate message. 2. If `sub_criteria` is provided but is not valid for the given `criteria`, the function should raise a `ValueError` with an appropriate message. 3. The function should handle edge cases such as an empty movies list or movies with missing fields gracefully. # Example ```python # Sample movie data movies = [ {\\"title\\": \\"Movie A\\", \\"year\\": 2020, \\"genre\\": \\"Action\\", \\"rating\\": 8.2, \\"director\\": \\"Director X\\"}, {\\"title\\": \\"Movie B\\", \\"year\\": 2021, \\"genre\\": \\"Comedy\\", \\"rating\\": 7.3, \\"director\\": \\"Director Y\\"}, {\\"title\\": \\"Movie C\\", \\"year\\": 2020, \\"genre\\": \\"Action\\", \\"rating\\": 8.5, \\"director\\": \\"Director X\\"}, {\\"title\\": \\"Movie D\\", \\"year\\": 2019, \\"genre\\": \\"Drama\\", \\"rating\\": 6.9, \\"director\\": \\"Director Z\\"}, {\\"title\\": \\"Movie E\\", \\"year\\": 2021, \\"genre\\": \\"Action\\", \\"rating\\": 7.8, \\"director\\": \\"Director X\\"} ] # Analyze movies by year, finding the top-rated movie for each year result = analyze_movies(movies, criteria=\\"year\\", sub_criteria=\\"top_rated\\") print(result) ``` # Expected Result: ```python { 2020: {\\"title\\": \\"Movie C\\", \\"rating\\": 8.5}, 2021: {\\"title\\": \\"Movie E\\", \\"rating\\": 7.8}, 2019: {\\"title\\": \\"Movie D\\", \\"rating\\": 6.9} } ``` # Additional Information Ensure the function is efficient and can handle a large list of movies. Validate inputs and handle potential errors gracefully. Provide meaningful error messages for invalid inputs or if the required data is missing.","solution":"def analyze_movies(movies: list, criteria: str, sub_criteria: str = None) -> dict: if criteria not in [\'year\', \'genre\', \'director\', \'rating\']: raise ValueError(\\"Invalid primary criteria. Choose from \'year\', \'genre\', \'director\', \'rating\'.\\") if sub_criteria and sub_criteria not in [\'top_rated\', \'highest_grossing\', \'most_movies\', \'most_critic_acclaimed\']: raise ValueError(\\"Invalid sub-criteria. Refer to the documentation for valid sub-criteria.\\") result = {} if criteria == \'year\': for movie in movies: year = movie[\'year\'] if year not in result: result[year] = [] result[year].append(movie) if sub_criteria == \'top_rated\': for year in result: result[year] = max(result[year], key=lambda m: m.get(\'rating\', 0)) result[year] = {\\"title\\": result[year][\'title\'], \\"rating\\": result[year][\'rating\']} elif criteria == \'genre\': for movie in movies: genre = movie[\'genre\'] if genre not in result: result[genre] = [] result[genre].append(movie) if sub_criteria == \'highest_grossing\': for genre in result: result[genre] = max(result[genre], key=lambda m: m.get(\'rating\', 0)) result[genre] = {\\"title\\": result[genre][\'title\'], \\"rating\\": result[genre][\'rating\']} elif criteria == \'director\': for movie in movies: director = movie[\'director\'] if director not in result: result[director] = [] result[director].append(movie) if sub_criteria == \'most_movies\': most_movies_director = max(result, key=lambda d: len(result[d])) result = {most_movies_director: len(result[most_movies_director])} elif criteria == \'rating\': sorted_movies = sorted(movies, key=lambda m: m.get(\'rating\', 0), reverse=True) result = {\\"top_rated\\": sorted_movies[0:1]} return result"},{"question":"# Question: Calculate Harmonic Mean of Fractions You need to write a function `harmonic_mean_of_fractions(fraction_list)` that takes in a list of tuples, where each tuple contains two integers representing the numerator and the denominator (((a, b))) of a fraction. The function should return the harmonic mean of these fractions. The harmonic mean of ( n ) numbers ( x_1, x_2, ..., x_n ) is defined as (frac{n}{frac{1}{x_1} + frac{1}{x_2} + ... + frac{1}{x_n}}). For fractions, (frac{a}{b}), the reciprocal is (frac{b}{a}). Function Signature ```python def harmonic_mean_of_fractions(fraction_list: List[Tuple[int, int]]) -> float: ``` Input * `fraction_list` (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers, representing the numerator and the denominator of a fraction. Output * Returns the harmonic mean of the fractions as a floating-point number. Constraints * Both numerator and denominator will be positive integers. * The list will contain at least one fraction. * Implementations should handle potential divisions by zero efficiently. Example ```python harmonic_mean_of_fractions([(1, 2), (3, 4), (5, 6)]) # Should return approximately 0.509, calculated from the fractions 1/2, 3/4, and 5/6. harmonic_mean_of_fractions([(1, 2), (2, 3)]) # Should return approximately 0.545, calculated from the fractions 1/2 and 2/3. ``` Notes 1. Implement the function to handle floating-point precision efficiently. 2. Ensure to handle edge cases where potential divisions by zero are present correctly. This scenario may occur if the numerator of any fraction is zero. 3. **Performance requirements**: The function should operate in O(n) time complexity where n is the number of (numerator, denominator) pairs provided.","solution":"def harmonic_mean_of_fractions(fraction_list): Calculate the harmonic mean of a list of fractions. Parameters: fraction_list (List[Tuple[int, int]]): List of tuples representing the fractions. Returns: float: Harmonic mean of the fractions. n = len(fraction_list) reciprocal_sum = 0.0 for a, b in fraction_list: # Ensure denominator is not zero if a == 0: return 0.0 reciprocal_sum += b / a return n / reciprocal_sum"},{"question":"# Coding Question: Develop an Optimized Trie-based Dictionary Search System **Context**: The Trie data structure (a type of search tree) is excellent for implementing dynamic dictionary search, such as auto-complete or spell checking. It allows efficient insertions and lookups for strings by storing characters successively. **Challenge**: Your goal is to implement an enhanced version of the `TrieDictionary` class. This class should provide methods for adding words, searching for words, and suggesting auto-completions based on given prefixes. **Function Signature**: ```python class TrieDictionary: def __init__(self) -> None: self.root = TrieNode() def insert(self, word: str) -> None: pass def search(self, word: str) -> bool: pass def suggest(self, prefix: str) -> list[str]: pass ``` **Detailed Requirements**: 1. **Initialization**: - A `TrieDictionary` instance should have an empty root node upon creation. 2. **Insert Function**: - The `insert` method should add a word to the Trie. Each node represents a character in the word, and nodes are linked to form the full word. 3. **Search Function**: - The `search` method should return `True` if a given word exists in the Trie and `False` otherwise. This method should check for complete words, not just prefixes. 4. **Suggest Function**: - The `suggest` method should return a list of words that complete the given prefix. If the prefix matches no words in the Trie, return an empty list. - Optimize the method to handle large datasets, ensuring suggestions are retrieved efficiently. **Constraints**: - Words consist of only lowercase English letters (`a`-`z`). - The length of each word and prefix is between 1 and 100 characters. - In typical use cases, words inserted into the Trie will not exceed 100,000. **Performance Requirements**: - Ensure the `insert` and `search` methods run in O(m) time, where m is the length of the word. - The `suggest` method should be optimized to quickly return relevant auto-completions in linear time relative to the number of matching words. **Example**: ```python >>> trie = TrieDictionary() >>> trie.insert(\\"apple\\") >>> trie.insert(\\"app\\") >>> trie.insert(\\"apricot\\") >>> trie.search(\\"app\\") True >>> trie.search(\\"apple\\") True >>> trie.search(\\"apex\\") False >>> trie.suggest(\\"ap\\") [\\"apple\\", \\"app\\", \\"apricot\\"] >>> trie.suggest(\\"b\\") [] ``` In this exercise, balance efficiency with practical implementation limits, ensuring the Trie structure handles inserts, searches, and auto-completions effectively within the provided constraints.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class TrieDictionary: def __init__(self) -> None: self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def suggest(self, prefix: str) -> list: node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] return self._find_words_from_node(node, prefix) def _find_words_from_node(self, node, prefix): suggestions = [] if node.is_end_of_word: suggestions.append(prefix) for char, next_node in node.children.items(): suggestions.extend(self._find_words_from_node(next_node, prefix + char)) return suggestions"},{"question":"# Digit Sum Calculator Objective You are required to implement a function that calculates the sum of the digits of a given non-negative integer until a single-digit result is achieved. Function Signature ```python def digit_sum(number: int) -> int: ``` Input - `number`: A non-negative integer (0 ≤ number ≤ 10^18). Output - The function should return a single-digit integer which is the result of iteratively summing the digits of the input number until a single-digit number is produced. Constraints - The function should handle input values efficiently, even for the upper limit. - The iterative process should continue until only one digit remains. Example ```python number = 12345 digit_sum(number) # Returns: 6 (1 + 2 + 3 + 4 + 5 = 15, 1 + 5 = 6) number = 987654321 digit_sum(number) # Returns: 9 (9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 = 45, 4 + 5 = 9) ``` Additional Context The function should use an efficient approach to repeatedly sum the digits of the number. Consider the mathematical properties of digit sums to optimize the solution when dealing with large numbers.","solution":"def digit_sum(number: int) -> int: Returns the sum of the digits of a given non-negative integer until a single-digit result is achieved. if number == 0: return 0 while number >= 10: number = sum(int(digit) for digit in str(number)) return number"},{"question":"You are provided with a list of integers and a target sum. Your task is to implement the `two_sum` algorithm that identifies whether there are any two distinct integers in the list that add up to the target sum. The algorithm should be efficient, aiming for an average-case time complexity of O(n) by utilizing a hash map for lookups. # Function Signature ```python def two_sum(arr: list[int], target: int) -> bool: pass ``` # Input - `arr`: A list of integers (1 ≤ len(arr) ≤ 10^5; -10^9 ≤ arr[i] ≤ 10^9 for all integers in `arr`). - `target`: An integer (-10^9 ≤ target ≤ 10^9) representing the desired sum of two integers. # Output - Return `True` if there exist two distinct integers in the list that add up to the target sum. - Return `False` otherwise. # Constraints 1. Your implementation should aim to achieve an average-case time complexity of O(n). 2. You need to ensure that the two integers are distinct elements from the list. 3. Consider handling edge cases, such as multiple pairs adding up to the target sum or large input sizes. # Examples ```python assert two_sum([2, 7, 11, 15], 9) == True assert two_sum([3, 2, 4], 6) == True assert two_sum([3, 3], 6) == True assert two_sum([1, 2, 3, 4, 5], 10) == False assert two_sum([-1, -2, -3, -4, -5], -8) == True assert two_sum([1, 5, 3, 7], 10) == True ``` # Additional Notes 1. In the example [2, 7, 11, 15] with a target sum of 9, the integers 2 and 7 add up to the target sum. 2. Ensure that the solution works efficiently for large input sizes and handles edge cases like negative numbers and duplicate values correctly.","solution":"def two_sum(arr: list[int], target: int) -> bool: Returns True if there are any two distinct integers in the list that add up to the target sum, otherwise returns False. Utilizes a hash map to achieve average-case time complexity of O(n). complement_map = {} for num in arr: complement = target - num if complement in complement_map: return True complement_map[num] = True return False"},{"question":"# Question: Implementing a Basic Calculator for Operations on Fractions You are to develop a function that takes a list of arithmetic expressions involving fractions and returns their results as simplified fractions. The fraction expressions can include addition (`+`), subtraction (`-`), multiplication (`*`), and division (`/`) operations. # Function Signature ```python def evaluate_fractions(expressions: List[str]) -> List[str]: Evaluate a list of arithmetic expressions involving fractions and return their results as simplified fractions. :param expressions: List[str] - A list of strings, each string representing an arithmetic expression involving fractions. :return: List[str] - A list of strings, each string representing the simplified result of the corresponding input expression. >>> evaluate_fractions([\\"1/2 + 1/3\\", \\"2/3 * 3/4\\", \\"5/6 - 1/2\\", \\"7/8 / 2/3\\"]) [\\"5/6\\", \\"1/2\\", \\"1/3\\", \\"21/16\\"] ``` # Input - `expressions`: A list of strings where each string is an arithmetic expression containing two fractions and one of the four basic operations (`+`, `-`, `*`, `/`). # Output - A list of strings where each string is the simplified result of the corresponding arithmetic expression. The fractions should be presented in the simplest form. # Constraints - Each fraction in the expressions will be represented as `a/b`, where `a` and `b` are integers and `b` is not zero. - The input list will contain at most 1,000 expressions. - Handle integer overflow issues properly. - Each arithmetic expression will only involve two fractions and one operator. # Example ```python expressions = [\\"1/2 + 1/3\\", \\"2/3 * 3/4\\", \\"5/6 - 1/2\\", \\"7/8 / 2/3\\"] output = evaluate_fractions(expressions) # Expected output: [\\"5/6\\", \\"1/2\\", \\"1/3\\", \\"21/16\\"] ``` # Notes: - You should ensure that fractions are simplified (i.e., the greatest common divisor of numerator and denominator should be 1). - Remember to handle division by converting it to multiplication by the reciprocal. ```python from fractions import Fraction from typing import List def evaluate_fractions(expressions: List[str]) -> List[str]: results = [] for exp in expressions: frac_1, operator, frac_2 = exp.split() f1 = Fraction(frac_1) f2 = Fraction(frac_2) if operator == \'+\': result = f1 + f2 elif operator == \'-\': result = f1 - f2 elif operator == \'*\': result = f1 * f2 elif operator == \'/\': result = f1 / f2 results.append(str(result)) return results ```","solution":"from fractions import Fraction from typing import List def evaluate_fractions(expressions: List[str]) -> List[str]: results = [] for exp in expressions: frac_1, operator, frac_2 = exp.split() f1 = Fraction(frac_1) f2 = Fraction(frac_2) if operator == \'+\': result = f1 + f2 elif operator == \'-\': result = f1 - f2 elif operator == \'*\': result = f1 * f2 elif operator == \'/\': result = f1 / f2 results.append(str(result)) return results"},{"question":"# Maximize Water Containers Between Buildings You are given a list of non-negative integers representing the heights of buildings. The goal is to determine the maximum amount of water that can be contained between any two buildings when selecting the buildings from the list. This is achieved by using the two-pointer technique to find the optimal pair of buildings. Problem Statement You need to write a function that takes a list of integers representing the heights of buildings and returns the maximum volume of water that can be held between any two buildings. # Function Signature ```python def max_water_contained(heights): Uses the two-pointer technique to find the maximum amount of water that can be contained between two buildings. :param heights: List of non-negative integers representing the heights of buildings. :return: Maximum volume of water that can be held. pass ``` # Requirements 1. **Function Implementation**: Implement the `max_water_contained` function. It should take a list of building heights and return the maximum volume of water that can be held between any two buildings. 2. **Efficiency**: The function should be optimized for performance, ideally operating in O(n) time complexity. 3. **Correctness**: Ensure that the function correctly calculates the volume of water using the two-pointer technique. 4. **Constraints**: The list of heights will contain at least two buildings and all heights are non-negative integers. # Input - `heights`: List of non-negative integers representing the heights of buildings. Example Input ```python heights = [1, 8, 6, 2, 5, 4, 8, 3, 7] ``` # Output - Return a single integer representing the maximum volume of water that can be held. Example Output ```python 49 ``` # Constraints - The number of buildings (length of the list `heights`) will be at most 10^5. - Height of each building will be between 0 and 10^4 inclusive.","solution":"def max_water_contained(heights): Uses the two-pointer technique to find the maximum amount of water that can be contained between two buildings. :param heights: List of non-negative integers representing the heights of buildings. :return: Maximum volume of water that can be held. left = 0 right = len(heights) - 1 max_water = 0 while left < right: # Calculate the width width = right - left # Calculate the height height = min(heights[left], heights[right]) # Calculate the area current_water = width * height # Update the maximum water if current area is bigger max_water = max(max_water, current_water) # Move the pointers inward if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"# Playlist Manager with Track Reordering Design and implement a `PlaylistManager` class that allows for the management of a playlist of tracks. The class should support adding tracks, removing tracks, and reordering the tracks based on user preference. Additionally, it should be able to display the current order of tracks in the playlist. Class Definition Your task is to implement the `PlaylistManager` class with the following methods: - `add_track(track_name: str)`: Adds a new track to the end of the playlist. If the playlist exceeds 200 tracks, raise an `OverFlowError`. - `remove_track(track_name: str)`: Removes the specified track from the playlist. If the track is not found, raise a `ValueError`. - `reorder_track(track_name: str, new_position: int)`: Moves the specified track to the new position in the playlist. If the new position is out of range, raise an `IndexError`. If the track is not found, raise a `ValueError`. - `__str__() -> str`: Returns a string representation of the current playlist, with each track name listed on a new line. Requirements: 1. The class should handle up to 200 tracks. 2. Track names are unique strings. 3. Efficiently manage track reordering and retrieval of the playlist state. 4. Handle appropriate exceptions as described. Constraints: - Track names are case-sensitive strings. - Positions in the playlist are zero-based indices. ```python class OverFlowError(Exception): pass class PlaylistManager: def __init__(self): self.tracks = [] def add_track(self, track_name: str) -> None: if len(self.tracks) >= 200: raise OverFlowError(\\"Playlist cannot exceed 200 tracks.\\") self.tracks.append(track_name) def remove_track(self, track_name: str) -> None: try: self.tracks.remove(track_name) except ValueError: raise ValueError(f\\"Track {track_name} not found in playlist.\\") def reorder_track(self, track_name: str, new_position: int) -> None: if new_position < 0 or new_position >= len(self.tracks): raise IndexError(\\"New position is out of range.\\") try: self.tracks.remove(track_name) self.tracks.insert(new_position, track_name) except ValueError: raise ValueError(f\\"Track {track_name} not found in playlist.\\") def __str__(self) -> str: return \\"n\\".join(self.tracks) # Example usage: # pm = PlaylistManager() # pm.add_track(\\"Track A\\") # pm.add_track(\\"Track B\\") # pm.add_track(\\"Track C\\") # print(pm) # pm.reorder_track(\\"Track B\\", 0) # print(pm) # pm.remove_track(\\"Track C\\") # print(pm) # try: # pm.reorder_track(\\"Track D\\", 1) # except ValueError: # print(\\"Track D not found in playlist.\\") ``` The above class definition includes the necessary structure. Implement the methods to satisfy the described functionality and ensure robustness against mentioned edge cases.","solution":"class OverFlowError(Exception): pass class PlaylistManager: def __init__(self): self.tracks = [] def add_track(self, track_name: str) -> None: if len(self.tracks) >= 200: raise OverFlowError(\\"Playlist cannot exceed 200 tracks.\\") self.tracks.append(track_name) def remove_track(self, track_name: str) -> None: try: self.tracks.remove(track_name) except ValueError: raise ValueError(f\\"Track {track_name} not found in playlist.\\") def reorder_track(self, track_name: str, new_position: int) -> None: if new_position < 0 or new_position >= len(self.tracks): raise IndexError(\\"New position is out of range.\\") try: self.tracks.remove(track_name) self.tracks.insert(new_position, track_name) except ValueError: raise ValueError(f\\"Track {track_name} not found in playlist.\\") def __str__(self) -> str: return \\"n\\".join(self.tracks)"},{"question":"# Task: Develop a Log File Analyzer Scenario You are tasked with developing a log file analyzer. The script must read a log file, extract specific types of log entries, calculate statistics, and generate summaries. The log file contains entries with timestamps, log levels, and messages. Requirements 1. **Function Implementation**: Implement the function `analyze_log_file(file_path: str) -> Dict[str, Any]` - **Input**: A file path to the log file (str). - **Output**: A dictionary (Dict[str, Any]) containing: - The total number of log entries. - The number of entries for each log level (INFO, WARNING, ERROR, etc.). - The most frequent log message and its count. - The first and last timestamp of log entries. 2. **Constraints**: - The log file format is consistent, with each entry on a new line. - Each log entry is prefixed with a timestamp in the format `YYYY-MM-DD HH:MM:SS`. - Following the timestamp, each log entry should have a log level (e.g., INFO, WARNING, ERROR), then the message. 3. **Performance Requirements**: - The function must efficiently process large log files without excessive memory usage. - Implement logic to handle log entries with missing or malformed data. Example Log File ``` 2023-06-01 12:00:00 INFO Starting process 2023-06-01 12:05:00 WARNING Low disk space 2023-06-01 12:07:00 ERROR Process failed 2023-06-01 12:09:00 INFO Retrying process 2023-06-01 12:15:00 INFO Process completed 2023-06-01 12:17:00 WARNING High memory usage ``` Example Usage ```python file_path = \'system.log\' results = analyze_log_file(file_path) print(results) ``` Additional Considerations - Ensure your implementation includes robust error handling for potential file I/O issues and malformed log entries. - Test with log files consisting of various entry counts and levels to ensure reliable statistic calculations and summaries.","solution":"from typing import Dict, Any from collections import defaultdict, Counter import re def analyze_log_file(file_path: str) -> Dict[str, Any]: Analyzes a log file and extracts statistics and summaries. :param file_path: Path to the log file :return: A dictionary with the total number of log entries, entries per log level, the most frequent log message and its count, and the first and last timestamp of log entries. log_entries = [] log_levels_count = defaultdict(int) messages_count = Counter() first_timestamp = last_timestamp = None log_entry_pattern = re.compile(r\'(d{4}-d{2}-d{2} d{2}:d{2}:d{2}) (w+) (.+)\') with open(file_path, \'r\') as file: for line in file: match = log_entry_pattern.match(line.strip()) if match: timestamp, log_level, message = match.groups() if not first_timestamp: first_timestamp = timestamp last_timestamp = timestamp log_entries.append((timestamp, log_level, message)) log_levels_count[log_level] += 1 messages_count[message] += 1 total_entries = len(log_entries) if messages_count: most_frequent_message, most_frequent_count = messages_count.most_common(1)[0] else: most_frequent_message, most_frequent_count = None, 0 return { \'total_entries\': total_entries, \'log_levels\': dict(log_levels_count), \'most_frequent_message\': most_frequent_message, \'most_frequent_count\': most_frequent_count, \'first_timestamp\': first_timestamp, \'last_timestamp\': last_timestamp }"},{"question":"# DNA Sequence Complement Given a DNA sequence represented by a string containing the characters \'A\', \'T\', \'C\', and \'G\', write a function that returns the complementary DNA strand. The complementary rules are as follows: - \'A\' complements \'T\' - \'T\' complements \'A\' - \'C\' complements \'G\' - \'G\' complements \'C\' The function should validate the input and raise appropriate errors when necessary. Function Signature ```python def dna_complement(dna_sequence: str) -> str: pass ``` Input * `dna_sequence` (str): A string representing the DNA sequence. It must only contain the characters \'A\', \'T\', \'C\', and \'G\'. Output * Returns the complementary DNA strand as a string. Constraints * `1 <= len(dna_sequence) <= 10^6` Performance Requirements The function should be efficient and operate in linear time, O(n), for the given constraints. Example ```python # Example Usage assert dna_complement(\\"ATCG\\") == \\"TAGC\\" assert dna_complement(\\"GATTACA\\") == \\"CTAATGT\\" assert dna_complement(\\"CCGG\\") == \\"GGCC\\" assert dna_complement(\\"A\\") == \\"T\\" assert dna_complement(\\"TGCAGTA\\") == \\"ACGTCAT\\" ``` Error Scenarios * If `dna_sequence` contains any character other than \'A\', \'T\', \'C\', or \'G\', raise `ValueError(\\"Invalid DNA sequence\\")`. Additional Notes * Ensure to handle edge cases such as an empty string and sequences of maximum length. * Consider using a dictionary to map the complementary pairs for efficient look-ups.","solution":"def dna_complement(dna_sequence: str) -> str: Returns the complement of the given DNA sequence. Args: dna_sequence (str): Input DNA sequence with characters \'A\', \'T\', \'C\', and \'G\'. Returns: str: Complementary DNA sequence. Raises: ValueError: If the input sequence contains invalid characters. complement = {\'A\': \'T\', \'T\': \'A\', \'C\': \'G\', \'G\': \'C\'} # Validate input for char in dna_sequence: if char not in complement: raise ValueError(\\"Invalid DNA sequence\\") # Generate complement sequence return \'\'.join(complement[char] for char in dna_sequence)"},{"question":"# Coding Assessment Question You are asked to implement a function that normalizes a given vector of numbers. Normalizing a vector adjusts the values proportionally so that the vector has a magnitude (length) of 1. This is a common task in various data processing pipelines, including machine learning, where normalized data often leads to better model performance. Problem Statement Write a function `normalize_vector(vector: list[float]) -> list[float]` that takes a vector (a list of floats) and returns the normalized vector. If the vector has a magnitude of zero, the function should return a list of zeros of the same length. Input and Output Formats - **Input**: - `vector`: A list of floats representing the vector to be normalized. - **Output**: - A list of floats representing the normalized vector. Constraints - The vector should have at least one element. - The function should handle both positive and negative numbers. - The precision of the normalized values should be up to 6 decimal places. Examples: ```python >>> normalize_vector([3.0, 4.0]) [0.6, 0.8] >>> normalize_vector([1.0, 1.0, 1.0, 1.0]) [0.5, 0.5, 0.5, 0.5] >>> normalize_vector([0.0, 0.0, 0.0]) [0.0, 0.0, 0.0] ``` Function Signature ```python def normalize_vector(vector: list[float]) -> list[float]: ``` # Explanation: - The magnitude of a vector is calculated using the formula: [ text{magnitude} = sqrt{sum_{i=1}^{n} text{vector}_i^2} ] where ( n ) is the number of elements in the vector and ( text{vector}_i ) represents the i-th element in the vector. - To normalize the vector, each element is divided by the magnitude: [ text{normalized_vector}_i = frac{text{vector}_i}{text{magnitude}} ] - If the magnitude of the vector is zero, the normalized vector should consist of zeros. Ensure the precision of the normalized vector values to 6 decimal places to meet the requirements of many practical applications.","solution":"def normalize_vector(vector: list[float]) -> list[float]: Normalizes the given vector to have a magnitude of 1. Parameters: vector (list of float): The input vector to be normalized. Returns: list of float: The normalized vector with a magnitude of 1. import math # Calculate the magnitude of the vector magnitude = math.sqrt(sum(x ** 2 for x in vector)) # If the magnitude is zero, return a vector of zeros of the same length if magnitude == 0: return [0.0] * len(vector) # Normalize the vector normalized_vector = [round(x / magnitude, 6) for x in vector] return normalized_vector"},{"question":"# Context: You are improving the performance of an e-commerce website, and one of the key features is to generate unique order IDs for each transaction. To guarantee uniqueness and avoid collision, you need to create a function that generates a unique identifier based on the current timestamp. # Problem Statement: Write a function `generate_unique_order_id(timestamp: int) -> str` that takes a Unix timestamp as input and returns a unique string identifier. The identifier should be a mix of the timestamp and a random alphanumeric suffix to ensure uniqueness. Additionally, your function should validate the input and raise a `ValueError` if the input is not a valid Unix timestamp. Input and Output Formats: * **Input**: A single argument `timestamp` which is an integer representing a Unix timestamp (number of seconds since Jan 1, 1970). * **Output**: A string that combines the timestamp and a random alphanumeric suffix to form a unique order ID. Constraints and Limitations: * The input is guaranteed to be a positive integer. * The function should consider edge cases and validate the input. * The random suffix should be 5 characters long and can include both uppercase letters and digits. Example: ```python >>> generate_unique_order_id(1633072800) \'1633072800AX4C1\' >>> generate_unique_order_id(1609459200) \'1609459200BW2M5\' >>> generate_unique_order_id(-1633072800) Traceback (most recent call last): ... ValueError: Input must be a valid Unix timestamp >>> generate_unique_order_id(\'notatimestamp\') Traceback (most recent call last): ... ValueError: Input must be a valid Unix timestamp >>> generate_unique_order_id(1625097600.123) Traceback (most recent call last): ... ValueError: Input must be a valid Unix timestamp ``` Performance Requirements: * The solution should generate the unique identifier in O(1) time complexity for string operations and random alphanumeric generation.","solution":"import random import string def generate_unique_order_id(timestamp: int) -> str: Generates a unique order ID based on a Unix timestamp and a random alphanumeric suffix. Args: timestamp: An integer representing a Unix timestamp. Returns: A string that combines the timestamp and a 5 character long random alphanumeric suffix. Raises: ValueError: If the input is not a valid Unix timestamp. if not isinstance(timestamp, int) or timestamp < 0: raise ValueError(\\"Input must be a valid Unix timestamp\\") suffix = \'\'.join(random.choices(string.ascii_uppercase + string.digits, k=5)) return f\\"{timestamp}{suffix}\\""},{"question":"# Coding Assessment Question: Prime Factor Sum Checker **Context**: In number theory, the sum of the prime factors of a number is the total sum of all prime factors including their multiplicities. For example, the number 12 has prime factors [2, 2, 3], and the sum of these factors is (2 + 2 + 3 = 7). # Task: Write a function `is_prime_sum_equal` that determines if the sum of the prime factors of a given positive integer is equal to a given target sum. The function should handle various edge cases and input constraints accordingly. # Function Signature: ```python def is_prime_sum_equal(number: int, target_sum: int) -> bool: ``` # Input: * `number` (int): The integer to be factored, where (2 leq number leq 10^6). * `target_sum` (int): The target sum to be checked, where ( 0 leq target_sum leq 10^6 ). # Output: * `bool`: Returns `True` if the sum of the prime factors of the number is equal to the target sum, otherwise `False`. # Constraints: * Raise a `ValueError` if `number` is not an integer. * Raise a `ValueError` if `number` is less than 2. * Raise a `ValueError` if `target_sum` is not an integer. * Ensure the function\'s performance is efficient to handle the input constraints. # Examples: ```python assert is_prime_sum_equal(12, 7) == True # 12 -> [2, 2, 3], sum is 7 assert is_prime_sum_equal(28, 13) == True # 28 -> [2, 2, 7], sum is 11 assert is_prime_sum_equal(29, 29) == True # 29 -> [29], sum is 29 assert is_prime_sum_equal(30, 10) == False # 30 -> [2, 3, 5], sum is 10 assert is_prime_sum_equal(100, 10) == False # 100 -> [2, 2, 5, 5], sum is 14 assert is_prime_sum_equal(100, 14) == True # 100 -> [2, 2, 5, 5], sum is 14 assert is_prime_sum_equal(\\"20\\", 15) == ValueError(\\"number must be an integer\\") assert is_prime_sum_equal(15, \\"10\\") == ValueError(\\"target_sum must be an integer\\") assert is_prime_sum_equal(1.5, 2) == ValueError(\\"number must be an integer\\") ``` # Requirements: * Implement the function with an efficient algorithm, considering the provided constraints. * Validate input to ensure it meets the specified criteria. * Ensure the function is robust against various edge cases and handle exceptions properly.","solution":"def is_prime_sum_equal(number: int, target_sum: int) -> bool: Determine if the sum of the prime factors of a given positive integer is equal to a given target sum. Parameters: number (int): The integer to be factored, where 2 <= number <= 10^6. target_sum (int): The target sum to be checked, where 0 <= target_sum <= 10^6. Returns: bool: True if the sum of prime factors of the number is equal to the target sum, otherwise False. if not isinstance(number, int): raise ValueError(\\"number must be an integer\\") if number < 2: raise ValueError(\\"number must be at least 2\\") if not isinstance(target_sum, int): raise ValueError(\\"target_sum must be an integer\\") def prime_factors(n): i = 2 factors = [] # Check number of twos while n % i == 0: factors.append(i) n //= i i = 3 # Check odd factors from 3 upwards while i * i <= n: while n % i == 0: factors.append(i) n //= i i += 2 if n > 1: factors.append(n) return factors factors = prime_factors(number) return sum(factors) == target_sum"},{"question":"# Coding Assessment Question Problem Statement You are given the implementation of an Insertion Sort algorithm, which is a simple, comparison-based sorting algorithm. Your task is to write a function that will test this algorithm against multiple input scenarios and compare the results with Python\'s built-in sorting function (`sorted`) to ensure accuracy. Additionally, you must verify that the sort is stable. Function Signature ```python def validate_insertion_sort( test_cases: list[list[int]], sorted_cases: list[list[int]], ) -> bool: Validate the Insertion Sort algorithm against Python\'s built-in sorting function for accuracy and stability. Parameters ---------- test_cases : list of list of int List containing lists of integers to be sorted. sorted_cases : list of list of int List containing the expected sorted lists for comparison. Returns ------- bool True if the Insertion Sort algorithm correctly sorts all the given lists and maintains stability, False otherwise. ``` Detailed Requirements 1. **Input and Output**: - **Input**: - `test_cases`: A list of lists (each list contains integers) that need to be sorted. - `sorted_cases`: A list of lists containing the expected sorted results for each corresponding test case. - **Output**: - Return a single boolean value indicating if all tests passed. 2. **Constraints**: - Each inner list can contain positive or negative integers. - Each list can contain duplicate values, testing the stability of the sort. 3. **Performance Requirements**: - The function should correctly handle multiple lists of integers. - Compare results obtained via `insertion_sort` with results from `sorted` and check for stability. 4. **Scenario**: - Validate both the correctness and stability of the Insertion Sort algorithm against a set of integer lists. Example ```python def insertion_sort(arr: list[int]) -> list[int]: for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def validate_insertion_sort( test_cases: list[list[int]], sorted_cases: list[list[int]], ) -> bool: for i, test_case in enumerate(test_cases): sorted_result = insertion_sort(test_case.copy()) # Validate against expected sorted result if sorted_result != sorted_cases[i]: return False # Validate against built-in sorted function if sorted_result != sorted(test_case): return False # Check for stability for j in range(len(test_case) - 1): if test_case[j] == test_case[j + 1]: original_indices = [k for k in range(len(sorted_result)) if sorted_result[k] == test_case[j]] if original_indices != sorted(original_indices): return False return True # Example usage test_cases = [ [4, 2, 2, 8, 3, 3, 1], [12, 11, 13, 5, 6, 7] ] sorted_cases = [ [1, 2, 2, 3, 3, 4, 8], [5, 6, 7, 11, 12, 13] ] print(validate_insertion_sort(test_cases, sorted_cases)) # Should print: True ``` --- This question mirrors the style, complexity, and scope of the provided example question. It assumes knowledge of a specific algorithm (insertion sort), requires implementation of a validation function that checks against built-in Python functionality, and ensures a comprehensive test suite including stability checks.","solution":"def insertion_sort(arr): for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def validate_insertion_sort(test_cases, sorted_cases): for i, test_case in enumerate(test_cases): # Apply insertion sort sorted_result = insertion_sort(test_case.copy()) # Validate against expected sorted result if sorted_result != sorted_cases[i]: return False # Validate against built-in sorted function if sorted_result != sorted(test_case): return False return True"},{"question":"**Question**: Minimum Spanning Tree Using Prim\'s Algorithm **Context**: Given an undirected, weighted graph represented as an adjacency list, your task is to find the Minimum Spanning Tree (MST) using Prim\'s Algorithm. The MST of a graph is a subset of the edges that connects all vertices together without any cycles and with the minimum possible total edge weight. **Details**: 1. Implement a function `prim_mst(graph: Dict[int, List[Tuple[int, int]]], num_nodes: int) -> List[Tuple[int, int, int]]` that: - Takes a graph (as an adjacency list) and the number of nodes. - Returns a list of edges in the MST in the format (node1, node2, weight). 2. You may assume that the graph nodes are indexed from 0 to `num_nodes-1`. **Input Format**: - `graph` : A dictionary where keys are node identifiers (integers) and values are lists of tuples. Each tuple represents an adjacent node and the edge weight as `(adjacent_node, weight)`. - `num_nodes` : An integer representing the number of nodes. **Output Format**: - A list of tuples where each tuple represents an edge in the MST as (node1, node2, weight). **Constraints**: - The graph is connected. - The graph has at least one node. - There are no negative edge weights. **Examples**: ```python def prim_mst(graph, num_nodes): # Your implementation here # Example usage: g1 = { 0: [(1, 2), (3, 6)], 1: [(0, 2), (2, 3), (3, 8), (4, 5)], 2: [(1, 3), (4, 7)], 3: [(0, 6), (1, 8)], 4: [(1, 5), (2, 7)] } print(prim_mst(g1, 5)) # Output: # [(0, 1, 2), (1, 2, 3), (1, 4, 5), (0, 3, 6)] g2 = { 0: [(1, 10), (2, 6), (3, 5)], 1: [(0, 10), (3, 15)], 2: [(0, 6), (3, 4)], 3: [(0, 5), (1, 15), (2, 4)] } print(prim_mst(g2, 4)) # Output: # [(0, 3, 5), (3, 2, 4), (0, 1, 10)] ```","solution":"import heapq from typing import List, Tuple, Dict def prim_mst(graph: Dict[int, List[Tuple[int, int]]], num_nodes: int) -> List[Tuple[int, int, int]]: mst = [] visited = [False] * num_nodes min_heap = [(0, 0, 0)] # Initialize the min heap with (weight, start_node, end_node) while len(mst) < num_nodes - 1: weight, u, v = heapq.heappop(min_heap) if not visited[v]: visited[v] = True if u != v: mst.append((u, v, weight)) for next_v, next_w in graph[v]: if not visited[next_v]: heapq.heappush(min_heap, (next_w, v, next_v)) return mst"},{"question":"# String Reversal and Occurrence Count **Context:** In various text processing applications, reversing strings and counting specific character occurrences are fundamental tasks. These operations are common in coding interviews, text processing software, and other programming scenarios involving string manipulations. You are tasked with implementing a function to reverse a given string and count the occurrences of each character within the reversed string. **Objective:** Write a function `reverse_string_count_occurrences(s: str) -> dict` that takes a string and returns a dictionary where the keys are characters from the reversed string, and the values are the respective counts of their occurrences. **Function Signature:** ```python def reverse_string_count_occurrences(s: str) -> dict: pass ``` **Inputs:** * `s` (str): A string of length between 1 and 1000 characters, consisting of lowercase and uppercase alphabetic characters. **Outputs:** * dict: A dictionary where each key is a character from the reversed input string, and each value is the count of occurrences of that character in the reversed string. **Constraints:** * The input string will only contain alphabetic characters (both lowercase and uppercase). * The returned dictionary should contain counts for all characters present in the reversed string. **Example:** ```python >>> reverse_string_count_occurrences(\\"hello\\") {\'o\': 1, \'l\': 2, \'e\': 1, \'h\': 1} >>> reverse_string_count_occurrences(\\"Python\\") {\'n\': 1, \'o\': 1, \'h\': 1, \'t\': 1, \'y\': 1, \'P\': 1} >>> reverse_string_count_occurrences(\\"aAbBcC\\") {\'C\': 1, \'c\': 1, \'B\': 1, \'b\': 1, \'A\': 1, \'a\': 1} ``` **Challenge:** Implement the function `reverse_string_count_occurrences` to accurately reverse the string and count character occurrences efficiently. Ensure it handles edge cases, including strings of maximum length and varying character cases.","solution":"def reverse_string_count_occurrences(s: str) -> dict: Reverses the given string and counts the occurrences of each character in the reversed string. Args: s (str): The input string to be reversed and counted. Returns: dict: A dictionary where keys are characters from the reversed string, and values are the counts of those characters. reversed_str = s[::-1] char_count = {} for char in reversed_str: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"# Coding Assessment Question Scenario: Distributed Matrix Multiplication You are implementing a distributed computing system where large matrix multiplications are offloaded to a cluster of machines. Your task is to design a distributed matrix multiplication algorithm that divides the workload among multiple nodes to optimize performance. Task Implement a function `distributed_matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]` that takes two matrices A and B and returns their product. The multiplication and summation of elements should be performed in parallel using distributed computing. Function Signature ```python def distributed_matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Multiplies two matrices A and B using a distributed computing approach. Parameters: A (List[List[int]]): A 2D list representing matrix A. B (List[List[int]]): A 2D list representing matrix B. Returns: List[List[int]]: The resulting matrix after multiplication. ``` Input - `A`: A 2D list of integers representing matrix A of size MxN (1 <= M, N <= 500) - `B`: A 2D list of integers representing matrix B of size NxP (1 <= N, P <= 500) Output - A 2D list of integers representing the product of matrices A and B of size MxP. Constraints - You must use multiprocessing to achieve parallelism. - Ensure proper synchronization between processes to avoid race conditions. - Consider edge cases such as matrices with a dimension of size one, matrices with all elements being zero, and matrices with negative elements. Example ```python from typing import List # Example function call A = [ [1, 2], [3, 4]] B = [ [5, 6], [7, 8]] result = distributed_matrix_multiplication(A, B) print(result) # Output: [[19, 22], [43, 50]] ``` Guidelines - Utilize the provided code snippets as a reference for creating and managing processes/nodes. - Focus on dividing the matrix multiplication task into smaller chunks that can be distributed across nodes. - Aim to minimize synchronization bottlenecks to enhance performance. - Ensure that your implementation handles potential errors gracefully and considers network latency and node failures in a realistic distributed computing environment.","solution":"from typing import List from multiprocessing import Pool def single_element_multiplication(args): A, B, i, j = args return sum(A[i][k] * B[k][j] for k in range(len(B))) def distributed_matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: if not A or not B or len(A[0]) != len(B): # If either matrix is empty or dimensions mismatch, return an empty matrix return [] M, N, P = len(A), len(A[0]), len(B[0]) # Create a pool for parallel processing pool = Pool() # Create arguments for each element in the result matrix args = [(A, B, i, j) for i in range(M) for j in range(P)] # Perform parallel computation for each element in the result matrix result_flat = pool.map(single_element_multiplication, args) # Reshape the flat list to a 2D list (MxP) result = [result_flat[i * P:(i + 1) * P] for i in range(M)] # Close the pool pool.close() pool.join() return result"},{"question":"# Coding Assessment: Implementing K-Means Clustering **Objective**: Implement the K-Means Clustering algorithm to group a set of instances into clusters. You will use the provided utility functions as a reference to create new components to demonstrate your understanding. # Problem Statement Given a series of steps and predefined functions for K-Means Clustering, implement additional functionality to further cluster unknown instances using the K-Means algorithm. Your task is to complete the clustering process, follow a given standard, and handle edge cases appropriately. # Scenario A company wants to use K-Means to group their customer data into different segments. They have historical data with known clusters (for validation). Your role is to implement the clustering algorithm and use it to group new customer data based on their features. # Requirements 1. **Function to Fit K-Means Model**: * Input: `data` (2D list of feature values), `k` (number of clusters). * Output: Dictionary containing the centroids of the clusters. 2. **Function to Assign Clusters**: * Input: `data` (2D list of feature values), `centroids` (list of centroids returned by the fit function). * Output: List of assigned cluster indices for each data instance. 3. **Utility Function to Calculate Sum of Squares**: * Input: `data` (2D list of feature values), `centroids` (list of centroids), `labels` (list of cluster indices). * Output: Total within-cluster sum of squares (WCSS). # Input and Output Format **Function 1: fit_kmeans_model** ```python def fit_kmeans_model(data: list[list[float]], k: int) -> dict: pass ``` **Function 2: assign_clusters** ```python def assign_clusters(data: list[list[float]], centroids: list[list[float]]) -> list[int]: pass ``` **Function 3: calculate_wcss** ```python def calculate_wcss(data: list[list[float]], centroids: list[list[float]], labels: list[int]) -> float: pass ``` # Constraints * Assume that the number of clusters `k` is a positive integer less than or equal to the number of data points. * The data is non-empty and well-formed. * Use the Euclidean distance metric for distance calculations. # Example ```python # Example data data = [ [1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [6.0, 9.0], ] # Fit the K-Means model with 2 clusters centroids = fit_kmeans_model(data, 2) # Assign clusters to the data points labels = assign_clusters(data, centroids) print(labels) # Expected output: [0, 0, 1, 1] # Calculate within-cluster sum of squares wcss = calculate_wcss(data, centroids, labels) print(wcss) # Expected output: (a float value representing the total WCSS) ``` * **Edge Cases**: * Handle cases where data points are equidistant from multiple centroids. * Ensure the function can handle clusters without any assigned points. * The algorithm should converge even for small k values (e.g., k=1). # Submission Complete the missing functions to fit the K-Means model, assign clusters to data points, and calculate within-cluster sum of squares. Ensure your solution passes provided examples and edge cases effectively.","solution":"import random from typing import List, Dict def euclidean_distance(point1: List[float], point2: List[float]) -> float: return sum((x - y) ** 2 for x, y in zip(point1, point2)) ** 0.5 def fit_kmeans_model(data: List[List[float]], k: int) -> Dict[int, List[float]]: # Randomly initialize the centroids centroids = {i: data[random.randint(0, len(data) - 1)] for i in range(k)} def closest_centroid(point: List[float]) -> int: return min(centroids.keys(), key=lambda c: euclidean_distance(point, centroids[c])) for _ in range(100): # assuming a max of 100 iterations for convergence # Assign points to the nearest centroid clusters = {i: [] for i in range(k)} for point in data: key = closest_centroid(point) clusters[key].append(point) # Calculate new centroids new_centroids = {} for key, points in clusters.items(): if points: # avoid division by zero new_centroids[key] = [sum(dim) / len(dim) for dim in zip(*points)] else: new_centroids[key] = centroids[key] # retain the old centroid if no points are assigned # Check for convergence if all(centroids[key] == new_centroids[key] for key in centroids): break centroids = new_centroids return centroids def assign_clusters(data: List[List[float]], centroids: Dict[int, List[float]]) -> List[int]: def closest_centroid(point: List[float]) -> int: return min(centroids.keys(), key=lambda c: euclidean_distance(point, centroids[c])) return [closest_centroid(point) for point in data] def calculate_wcss(data: List[List[float]], centroids: Dict[int, List[float]], labels: List[int]) -> float: wcss = 0.0 for point, label in zip(data, labels): wcss += euclidean_distance(point, centroids[label]) ** 2 return wcss"},{"question":"# Question: Find the Second Largest Element in a List **Problem Description**: Write a function `find_second_largest(nums: List[int]) -> int` that returns the second largest element in a list of integers. Your function should handle edge cases such as lists with less than two distinct elements by raising an error. **Input Format**: - A list of integers `nums` which can contain duplicate values. **Output Format**: - An integer that is the second largest distinct element in the list. **Constraints**: - The input list should contain at least two distinct elements. If not, raise a `ValueError` with the message \\"Not enough distinct elements\\". - Do not use Python\'s built-in sorting functions. **Function Signature**: ```python def find_second_largest(nums: List[int]) -> int: ``` **Examples**: ```python >>> find_second_largest([4, 1, 3, 2]) 3 >>> find_second_largest([4, 4, 4, 4]) Traceback (most recent call last): ... ValueError: Not enough distinct elements >>> find_second_largest([1, 2, 3, 4, 5]) 4 >>> find_second_largest([5, 5, 5, 6, 6]) 5 >>> find_second_largest([-2, -3, -1]) -2 >>> find_second_largest([10]) Traceback (most recent call last): ... ValueError: Not enough distinct elements >>> find_second_largest([10, 10, 20, 20, 30]) 20 ``` **Performance Requirement**: - The function should operate in linear time relative to the length of the input list.","solution":"from typing import List def find_second_largest(nums: List[int]) -> int: if len(nums) < 2: raise ValueError(\\"Not enough distinct elements\\") first_largest = float(\'-inf\') second_largest = float(\'-inf\') for num in nums: if num > first_largest: second_largest = first_largest first_largest = num elif num > second_largest and num != first_largest: second_largest = num if second_largest == float(\'-inf\'): raise ValueError(\\"Not enough distinct elements\\") return second_largest"},{"question":"# Problem Statement You are tasked with creating a function to analyze a range of numbers and determine the first number within that range which is divisible by a given divisor. The challenge involves generating numbers within a specified range and applying a divisibility check. Task Write a function `find_first_divisible(start: int, end: int, divisor: int) -> int` that finds and returns the first number within a given range `[start, end]` that is divisible by the specified divisor. If no such number exists within the range, return `-1`. Input * `start` (int): The starting number of the range. (1 ≤ start ≤ 10,000) * `end` (int): The ending number of the range (inclusive). (start ≤ end ≤ 10,000) * `divisor` (int): The integer by which the numbers in the range are to be divided. (1 ≤ divisor ≤ 100) Output * Returns an integer which is the first number within the range `[start, end]` that is divisible by `divisor`. If there is no such number, it returns `-1`. Constraints * The solution should efficiently handle the range and the divisibility check within the given constraints. * Consider different edge cases such as when no numbers in the range are divisible by the divisor or when `start` equals `end`. # Example ```python assert find_first_divisible(1, 10, 2) == 2 assert find_first_divisible(3, 9, 5) == 5 assert find_first_divisible(5, 5, 1) == 5 assert find_first_divisible(7, 14, 3) == 9 assert find_first_divisible(1, 5, 7) == -1 assert find_first_divisible(50, 75, 13) == 52 ``` Additional Notes Make sure to consider the range additional tests might occupy and ensure that the solution works within those bounds efficiently following best coding practices.","solution":"def find_first_divisible(start: int, end: int, divisor: int) -> int: Function to find the first number within range [start, end] that is divisible by the specified divisor. Returns the first divisible number or -1 if no divisible number is found. for number in range(start, end + 1): if number % divisor == 0: return number return -1"},{"question":"# Problem Statement You have been provided with the implementation of a basic algorithm for inverting matrices. However, this implementation does not handle all edge cases and may not be optimal for certain scenarios. Your task is to extend the matrix inversion function to: 1. **Verify if the Input Matrix is Square and Non-Singular**: Incorporate a check to ensure that the input matrix is square and non-singular. If the matrix fails this check, raise a suitable exception with the message \\"Matrix is not square or is singular.\\" 2. **Improve Numerical Stability**: Integrate a more numerically stable algorithm, such as the LU decomposition method, to invert matrices. # Task 1. **Implement Matrix Inversion with Error Handling**: - Verify that the input matrix is square (same number of rows and columns). - Ensure the matrix is non-singular (invertible). 2. **Implement LU Decomposition for Inversion**: - Use the LU decomposition method to compute the matrix inverse. - Utilize NumPy\'s built-in functions for efficiency. # Input and Output * **Input**: * `matrix`: (N times N) NumPy array, square matrix to be inverted. * **Output**: * If the matrix is square and non-singular, return an (N times N) NumPy array representing the inverse of the input matrix. * If the matrix is not square or is singular, raise a ValueError with the message: \\"Matrix is not square or is singular.\\" # Example ```python import numpy as np matrix = np.array([ [4, 7], [2, 6] ]) try: inv_matrix = invert_matrix_with_lu(matrix) print(inv_matrix) except ValueError as e: print(e) ``` # Constraints * The input matrix will be provided as a NumPy array. * Efficiently handle the matrix inversion using LU decomposition. * Ensure proper error handling for non-square or singular matrices. # Implementation Extend the code provided and define the function `invert_matrix_with_lu`: ```python import numpy as np from numpy.linalg import LinAlgError def invert_matrix_with_lu(matrix): # Check if matrix is square if matrix.shape[0] != matrix.shape[1]: raise ValueError(\\"Matrix is not square or is singular\\") try: # Compute LU decomposition P, L, U = np.linalg.lu(matrix) # Find the inverse using LU decomposition inv_matrix = np.linalg.inv(U) @ np.linalg.inv(L) @ P.T return inv_matrix except LinAlgError: raise ValueError(\\"Matrix is not square or is singular\\") ``` # Explanation The provided code defines the function `invert_matrix_with_lu` which: 1. Checks if the input matrix `matrix` is square. If not, it raises a `ValueError`. 2. Uses LU decomposition to compute the inverse. 3. If LU decomposition fails (indicating a singular matrix), a `ValueError` is raised.","solution":"import numpy as np from scipy.linalg import lu, inv from numpy.linalg import LinAlgError def invert_matrix_with_lu(matrix): Inverts a given square and non-singular matrix using LU decomposition. Parameters: matrix (np.ndarray): The square matrix to invert. Returns: np.ndarray: Inverse of the input matrix if it\'s square and non-singular. Raises: ValueError: If the matrix is not square or is singular. # Check if matrix is square if matrix.shape[0] != matrix.shape[1]: raise ValueError(\\"Matrix is not square or is singular\\") try: # Perform LU decomposition P, L, U = lu(matrix) # Compute the inverse using the decomposed matrices inv_U = inv(U) inv_L = inv(L) inv_P = P.T inv_matrix = inv_U @ inv_L @ inv_P return inv_matrix except LinAlgError: raise ValueError(\\"Matrix is not square or is singular\\")"},{"question":"# **Find the Kth Smallest Element in Two Sorted Arrays** Given two sorted arrays of integers, find the k-th smallest element in the combined sorted arrays. **Function Signature**: ```python def find_kth_element(nums1: list[int], nums2: list[int], k: int) -> int: pass ``` # **Input**: - `nums1`: A list of integers in non-decreasing order (0 ≤ len(nums1) ≤ 10^5) - `nums2`: A list of integers in non-decreasing order (0 ≤ len(nums2) ≤ 10^5) - `k`: An integer (1 ≤ k ≤ (len(nums1) + len(nums2))) # **Output**: - An integer representing the k-th smallest element in the merged array. # **Constraints**: - If one of the input arrays is empty, the function should handle the scenario and find the k-th smallest element in the non-empty array. - The input arrays may contain negative numbers. # **Examples**: - `find_kth_element([1, 3, 5], [2, 4, 6], 4)` should return `4` - `find_kth_element([1, 2], [3, 4], 2)` should return `2` - `find_kth_element([0, 0], [0, 0], 3)` should return `0` - `find_kth_element([], [1], 1)` should return `1` - `find_kth_element([-1000], [1000], 2)` should return `1000` - `find_kth_element([-5, 3, 6], [-10, -3, 2], 5)` should return `3` # **Notes**: - The algorithm should be efficient enough to handle large inputs as mentioned in the constraints. - Aim for an approach that has better than O(n + m) complexity where n and m are the lengths of `nums1` and `nums2` respectively. A binary search approach is recommended for efficiency.","solution":"def find_kth_element(nums1: list[int], nums2: list[int], k: int) -> int: if len(nums1) > len(nums2): return find_kth_element(nums2, nums1, k) if not nums1: return nums2[k-1] if k == 1: return min(nums1[0], nums2[0]) i = min(len(nums1), k // 2) j = min(len(nums2), k // 2) if nums1[i - 1] > nums2[j - 1]: return find_kth_element(nums1, nums2[j:], k - j) else: return find_kth_element(nums1[i:], nums2, k - i)"},{"question":"# Coding Assessment Question Context Working with matrices is a fundamental skill in computer science, especially in data processing and scientific computations. Matrix manipulations can often be optimized and tackled using various algorithmic strategies. Task Write a function `rotate_matrix_90(mat: List[List[int]]) -> List[List[int]]` that rotates an NxN matrix 90 degrees clockwise. Input and Output Formats * **Input**: * `mat (List[List[int]])`: An NxN matrix (2 ≤ N ≤ 1000) represented as a list of lists, where each element is an integer. * **Output**: * A new NxN matrix that represents the original matrix rotated 90 degrees clockwise. Constraints and Performance Requirements * Ensure that the time complexity for the rotation is optimal. * The transformed matrix should not modify the original matrix. Special Notes 1. Consider matrix index manipulations to achieve the rotation. 2. Take into account edge cases such as minimum size NxN matrices (2x2). Example ```python from typing import List def rotate_matrix_90(mat: List[List[int]]) -> List[List[int]]: pass ``` **Example Usage:** ```python >>> rotate_matrix_90([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix_90([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90([[1]]) [[1]] ``` This question ensures that candidates can perform matrix manipulations, which is crucial for various applications in computer science, and the constraints push them to think about both time and space optimizations.","solution":"from typing import List def rotate_matrix_90(mat: List[List[int]]) -> List[List[int]]: Rotates a given NxN matrix 90 degrees clockwise. Args: mat (List[List[int]]): A 2D list representing the NxN matrix. Returns: List[List[int]]: A new 2D list representing the rotated matrix. n = len(mat) rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = mat[i][j] return rotated"},{"question":"# Coding Assessment Question Context: In a given integer matrix of size `n x m`, a \\"zigzag\\" path is a path that starts at any cell in the first row and proceeds to the bottom row, moving to an adjacent cell either directly below, or diagonally left below, or diagonally right below in the next row. The cost of a zigzag path is defined as the sum of the values of the cells visited by the path. Task: Write a function `minimum_zigzag_path(matrix: List[List[int]]) -> int` that computes the minimum cost of a zigzag path from the first row to the last row. The function should implement the following steps: 1. Verify the dimensions of the matrix and handle any cases where the matrix might not be suitable for path computation. 2. Implement an algorithm to dynamically compute the minimum path cost by evaluating all possible moves. 3. Return the minimum path cost. Input: * `matrix`: A list of lists of integers, where each list represents a row of the matrix. (1 <= n, m <= 1000). Output: * Integer representing the minimum cost of a zigzag path from the first row to the last row. Constraints: * Each cell in the matrix contains a non-negative integer. * The function should efficiently handle the upper limit case (n, m = 1000). Example: ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert minimum_zigzag_path(matrix1) == 12 # Path: (1) -> (4) -> (7) matrix2 = [ [10, 10, 2], [10, 5, 10], [2, 2, 2] ] assert minimum_zigzag_path(matrix2) == 9 # Path: (2) -> (5) -> (2) ``` Good luck! Ensure your algorithm handles edge cases and large inputs efficiently.","solution":"from typing import List def minimum_zigzag_path(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 n, m = len(matrix), len(matrix[0]) dp = [[float(\'inf\')] * m for _ in range(n)] # Initialize the first row of dp array for j in range(m): dp[0][j] = matrix[0][j] # Fill the dp table to find minimum zigzag path costs for i in range(1, n): for j in range(m): dp[i][j] = min( dp[i-1][j], # from directly above dp[i-1][j-1] if j > 0 else float(\'inf\'), # from diagonally left above dp[i-1][j+1] if j < m-1 else float(\'inf\') # from diagonally right above ) + matrix[i][j] # The result will be the minimum value in the last row of dp array return min(dp[-1])"},{"question":"# Problem Statement You are working on a software library for geometry calculations, and one of the key functionalities needed is to determine if a given point lies inside a rectangle. In this task, the rectangle is defined by two of its opposite corners. Given two points representing the opposite corners of the rectangle `(x1, y1)` and `(x2, y2)`, and a third point `(x, y)`, write a function `is_point_in_rectangle(x1: float, y1: float, x2: float, y2: float, x: float, y: float) -> bool` that returns `True` if the point `(x, y)` lies inside or on the border of the rectangle, and `False` otherwise. Make sure to handle edge cases and invalid inputs appropriately. Function Signature ```python def is_point_in_rectangle(x1: float, y1: float, x2: float, y2: float, x: float, y: float) -> bool: pass ``` Input and Output - **Input**: Six floating-point numbers `x1`, `y1`, `x2`, `y2`, `x`, `y` representing the coordinates of the rectangle\'s opposite corners and the coordinates of the point to check. - **Output**: A boolean value indicating whether the point `(x, y)` is inside or on the border of the rectangle. Constraints - Coordinates (`x1`, `y1`, `x2`, `y2`, `x`, `y`) will be floating point numbers. Requirements - Consider the smallest rectangle defined by the corners `(x1, y1)` and `(x2, y2)`. - Ensure that the function works correctly for valid floating-point inputs. # Examples ```python >>> is_point_in_rectangle(1, 1, 4, 4, 2, 2) True >>> is_point_in_rectangle(1, 1, 4, 4, 5, 5) False >>> is_point_in_rectangle(1, 1, 4, 4, 4, 4) True >>> is_point_in_rectangle(1, 1, 4, 4, 1, 4) True >>> is_point_in_rectangle(-3.0, -1.0, 2.0, 3.0, -1.5, 1.0) True >>> is_point_in_rectangle(-3.0, -1.0, 2.0, 3.0, 2.5, 2.0) False ``` Validate the function with the provided examples and ensure that the function adheres to the specifications outlined above.","solution":"def is_point_in_rectangle(x1: float, y1: float, x2: float, y2: float, x: float, y: float) -> bool: Determines if a given point (x, y) is inside or on the border of the rectangle defined by the opposite corners (x1, y1) and (x2, y2). min_x = min(x1, x2) max_x = max(x1, x2) min_y = min(y1, y2) max_y = max(y1, y2) return min_x <= x <= max_x and min_y <= y <= max_y"},{"question":"# Problem: Implement a Priority Queue using a Min-Heap Background A priority queue is a data structure that allows for retrieving elements according to their priority. One efficient way to implement a priority queue is using a min-heap, where the element with the smallest priority is always at the root. Your task is to implement a PriorityQueue class that uses a min-heap. Task Implement a `PriorityQueue` class in Python that uses a min-heap to manage elements. Input - Various operations on the priority queue as described below. Operations 1. `insert(item, priority)`: Adds an item to the priority queue with the given priority. 2. `extract_min()`: Removes and returns the item with the smallest priority. 3. `peek_min()`: Returns the item with the smallest priority without removing it. 4. `is_empty()`: Returns `True` if the priority queue is empty, `False` otherwise. Constraints 1. Assume no two items will have the same priority. 2. All priorities are integers. 3. The priority queue should support at least 100,000 operations efficiently. Example ```python import heapq class PriorityQueue: def __init__(self): self.heap = [] def insert(self, item, priority): heapq.heappush(self.heap, (priority, item)) def extract_min(self): if not self.is_empty(): return heapq.heappop(self.heap)[1] else: raise IndexError(\\"extract_min from an empty priority queue\\") def peek_min(self): if not self.is_empty(): return self.heap[0][1] else: raise IndexError(\\"peek_min from an empty priority queue\\") def is_empty(self): return len(self.heap) == 0 # Example usage if __name__ == \\"__main__\\": pq = PriorityQueue() pq.insert(\\"task1\\", 3) pq.insert(\\"task2\\", 1) pq.insert(\\"task3\\", 2) print(pq.peek_min()) # Output: \\"task2\\" print(pq.extract_min()) # Output: \\"task2\\" print(pq.is_empty()) # Output: False print(pq.extract_min()) # Output: \\"task3\\" print(pq.extract_min()) # Output: \\"task1\\" print(pq.is_empty()) # Output: True ```","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] def insert(self, item, priority): heapq.heappush(self.heap, (priority, item)) def extract_min(self): if not self.is_empty(): return heapq.heappop(self.heap)[1] else: raise IndexError(\\"extract_min from an empty priority queue\\") def peek_min(self): if not self.is_empty(): return self.heap[0][1] else: raise IndexError(\\"peek_min from an empty priority queue\\") def is_empty(self): return len(self.heap) == 0"},{"question":"# Question You are given a binary tree where each node contains an integer value. Your task is to implement a function that returns the right side view of the tree. The right side view of the binary tree is the set of nodes visible when the tree is viewed from the right side. Function Signature ```python def right_side_view(root: TreeNode) -> list[int]: pass ``` Input * root: a `TreeNode` representing the root of a binary tree (1 ≤ Number of nodes in the tree ≤ 1000). Output * A list of integers representing the values of nodes visible from the right side of the tree. Constraints * All node values are unique. Example Assume the `TreeNode` class is already defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` ```python # Example 1 # Tree: # 1 # / # 2 3 # # 5 4 # Right Side View: [1, 3, 4] root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(5) root.right.right = TreeNode(4) assert right_side_view(root) == [1, 3, 4] # Example 2 # Tree: # 1 # / # 2 3 # / # 4 5 # Right Side View: [1, 3, 5] root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.right.right = TreeNode(5) assert right_side_view(root) == [1, 3, 5] # Example 3 # Tree: # 1 # Right Side View: [1] root = TreeNode(1) assert right_side_view(root) == [1] # Example 4 # Tree: (Empty tree) # Right Side View: [] assert right_side_view(None) == [] ``` Explanation In this task, you need to traverse a binary tree and collect the visible nodes when viewed from the right side. Use level-order traversal to ensure the visibility of rightmost nodes at each level of the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root: TreeNode) -> list[int]: if not root: return [] queue = [root] result = [] while queue: level_length = len(queue) for i in range(level_length): node = queue.pop(0) if i == level_length - 1: result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"You are required to design and implement a class to manage a book library system. The library system should support adding books, searching for books, and borrowing books. # Context The class `Library` should manage a collection of books. Each book will have a title, author, and a unique identifier (ID). The system should allow adding new books, searching for books by either title or author, and borrowing books by their ID. # Class Definition ```python class Library: A class to represent a library system that manages books. def __init__(self): Initialize an empty library. pass def add_book(self, book_id: int, title: str, author: str): Add a new book to the library. :param book_id: A unique integer identifier for the book. :param title: The title of the book. :param author: The author of the book. pass def search_books_by_title(self, title: str) -> list[dict]: Search for books by their title. :param title: The title to search for. :return: A list of dictionaries with keys \'id\', \'title\', and \'author\' of matching books. pass def search_books_by_author(self, author: str) -> list[dict]: Search for books by their author. :param author: The author to search for. :return: A list of dictionaries with keys \'id\', \'title\', and \'author\' of matching books. pass def borrow_book(self, book_id: int) -> bool: Borrow a book from the library. :param book_id: The unique identifier of the book to borrow. :return: True if the book was successfully borrowed, False if the book ID is not found. pass ``` # Requirements 1. Implement the `Library` class with the methods described in the class definition. 2. The `add_book` method should allow adding a new book to the library. 3. The `search_books_by_title` and `search_books_by_author` methods should return a list of matching books as dictionaries. 4. The `borrow_book` method should mark a book as borrowed and return `False` if the book is not available. 5. Handle edge cases, such as borrowing a non-existent book or searching for books with no matches. # Input Constraints * Each book will have a unique integer `book_id`. * The library can contain multiple books with the same title or author. * All string inputs are case-sensitive. # Example ```python # Example Usage of the Library class library = Library() library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") library.add_book(2, \\"1984\\", \\"George Orwell\\") library.add_book(3, \\"To Kill a Mockingbird\\", \\"Harper Lee\\") print(library.search_books_by_title(\\"1984\\")) # Expected output: [{\'id\': 2, \'title\': \'1984\', \'author\': \'George Orwell\'}] print(library.search_books_by_author(\\"George Orwell\\")) # Expected output: [{\'id\': 2, \'title\': \'1984\', \'author\': \'George Orwell\'}] print(library.borrow_book(2)) # Expected output: True print(library.borrow_book(2)) # Expected output: False (book already borrowed) ``` # Guidelines * Implement the methods efficiently, ensuring they run in a reasonable time for a large number of books. * Use appropriate data structures to manage the books and optimize search operations. * Comment your code to explain the logic and any assumptions made.","solution":"class Library: A class to represent a library system that manages books. def __init__(self): Initialize an empty library. self.books = {} self.borrowed_books = set() def add_book(self, book_id: int, title: str, author: str): Add a new book to the library. :param book_id: A unique integer identifier for the book. :param title: The title of the book. :param author: The author of the book. if book_id not in self.books: self.books[book_id] = {\'id\': book_id, \'title\': title, \'author\': author} def search_books_by_title(self, title: str) -> list[dict]: Search for books by their title. :param title: The title to search for. :return: A list of dictionaries with keys \'id\', \'title\', and \'author\' of matching books. return [book for book in self.books.values() if book[\'title\'] == title] def search_books_by_author(self, author: str) -> list[dict]: Search for books by their author. :param author: The author to search for. :return: A list of dictionaries with keys \'id\', \'title\', and \'author\' of matching books. return [book for book in self.books.values() if book[\'author\'] == author] def borrow_book(self, book_id: int) -> bool: Borrow a book from the library. :param book_id: The unique identifier of the book to borrow. :return: True if the book was successfully borrowed, False if the book ID is not found or already borrowed. if book_id in self.books and book_id not in self.borrowed_books: self.borrowed_books.add(book_id) return True return False"},{"question":"# URL Shortener **Context**: In this exercise, you will create a URL shortening service. The function will take a long URL and produce a shorter version, and it should also be able to retrieve the original URL from the shortened version. # Task: Implement a class `UrlShortener` which has the following methods: - `shorten_url` which takes a URL as input and returns a short alias. - `retrieve_url` which takes a short alias as input and returns the original URL. # Requirements: 1. **Initialization**: When instantiated, `UrlShortener` should start with an empty database for storing URL mappings. 2. **Input for `shorten_url`**: A string representing a long URL (e.g., \\"https://www.example.com/path/to/resource\\"). 3. **Output for `shorten_url`**: A string representing the shortened URL (e.g., \\"http://short.url/abc123\\"). 4. **Input for `retrieve_url`**: A string representing the shortened URL (e.g., \\"http://short.url/abc123\\"). 5. **Output for `retrieve_url`**: A string representing the original long URL (e.g., \\"https://www.example.com/path/to/resource\\"). 6. **Constraints**: - The short alias can be an alphanumeric string of 6 characters. - Ensure there are no collisions in the URL mappings. - In case of invalid alias, `retrieve_url` should return `None`. ```python import random import string class UrlShortener: def __init__(self): self.url_mapping = {} self.short_url_prefix = \\"http://short.url/\\" def shorten_url(self, long_url: str) -> str: short_alias = self._generate_short_alias() while short_alias in self.url_mapping: short_alias = self._generate_short_alias() short_url = self.short_url_prefix + short_alias self.url_mapping[short_url] = long_url return short_url def retrieve_url(self, short_url: str) -> str: return self.url_mapping.get(short_url, None) def _generate_short_alias(self) -> str: Generates a random alphanumeric string of length 6. return \'\'.join(random.choice(string.ascii_letters + string.digits) for _ in range(6)) if __name__ == \\"__main__\\": # Example usage url_shortener = UrlShortener() long_url_example = \\"https://www.example.com/path/to/resource\\" short_url = url_shortener.shorten_url(long_url_example) print(\\"Short URL:\\", short_url) # Output should be a short URL starting with \\"http://short.url/\\" retrieved_url = url_shortener.retrieve_url(short_url) print(\\"Original URL:\\", retrieved_url) # Output should be \\"https://www.example.com/path/to/resource\\" ``` Test your class with different examples to ensure it works correctly and handles edge cases appropriately.","solution":"import random import string class UrlShortener: def __init__(self): self.url_mapping = {} self.short_url_prefix = \\"http://short.url/\\" def shorten_url(self, long_url: str) -> str: short_alias = self._generate_short_alias() while short_alias in self.url_mapping: short_alias = self._generate_short_alias() short_url = self.short_url_prefix + short_alias self.url_mapping[short_url] = long_url return short_url def retrieve_url(self, short_url: str) -> str: return self.url_mapping.get(short_url, None) def _generate_short_alias(self) -> str: Generates a random alphanumeric string of length 6. return \'\'.join(random.choice(string.ascii_letters + string.digits) for _ in range(6))"},{"question":"# Problem Scenario You are developing a feature that automatically adjusts message priorities in a messaging queue system. To optimize message handling, you need to prioritize messages based on their urgency levels. The levels are defined as follows: \\"low\\", \\"medium\\", and \\"high\\". Messages with the same priority level maintain their original order. # Task Write a function `sort_messages_by_priority(messages: list) -> list`. Your function should: 1. Take as input a list of tuples. Each tuple contains a message (string) and its priority level (string) in the format `(\\"message\\", \\"priority\\")`. 2. Return a new sorted list of messages by their priority levels in ascending order with \\"low\\" as the highest priority and \\"high\\" as the lowest priority. 3. Preserve the relative order of messages with the same priority. # Expected Input and Output Input: * A list of tuples, `messages`. - Example: `[(\\"msg1\\", \\"high\\"), (\\"msg2\\", \\"low\\"), (\\"msg3\\", \\"medium\\"), (\\"msg4\\", \\"low\\")]` Output: * A list of tuples sorted by priority level. - Example: `[(\\"msg2\\", \\"low\\"), (\\"msg4\\", \\"low\\"), (\\"msg3\\", \\"medium\\"), (\\"msg1\\", \\"high\\")]` # Constraints: * The length of the list will be at most 5,000. * The priority levels will always be one of: \\"low\\", \\"medium\\", \\"high\\". # Performance Requirements: * Your solution should efficiently handle sorting based on the specified priority levels, maintaining stability for messages of the same priority. # Example ```python def sort_messages_by_priority(messages: list) -> list: # Implement the function to sort messages by their priority levels pass # Example usage: print(sort_messages_by_priority([(\\"msg1\\", \\"high\\"), (\\"msg2\\", \\"low\\"), (\\"msg3\\", \\"medium\\"), (\\"msg4\\", \\"low\\")])) # Output: [(\\"msg2\\", \\"low\\"), (\\"msg4\\", \\"low\\"), (\\"msg3\\", \\"medium\\"), (\\"msg1\\", \\"high\\")] ``` Provide your implementation of the `sort_messages_by_priority()` function following the described requirements.","solution":"def sort_messages_by_priority(messages): Sort messages by their priority levels. Parameters: messages (list): List of tuples, each containing a message and its priority level. Returns: list: Sorted list of tuples based on priority levels. priority_order = {\\"low\\": 0, \\"medium\\": 1, \\"high\\": 2} return sorted(messages, key=lambda x: priority_order[x[1]])"},{"question":"# Coding Assessment Question You have an implementation to handle a simplified version of a \\"Histograph\\", where each bar can be aligned vertically with the previous bar, but never start lower than the previous bar. Given an input list representing the heights of bars in the histogram (bar heights are non-negative integers), your task is to efficiently compute the total area of the histograph. Function Signature ```python def total_histogram_area(heights: list[int]) -> int: pass ``` Input - A list of integers `heights` (0 ≤ len(heights) ≤ 10^5) where each integer represents the height of a bar in the histogram and the list is sorted in non-decreasing order. Output - An integer representing the total area of the histograph. # Constraints 1. The list will always be sorted in non-decreasing order. 2. Any solution that runs in O(n) time complexity is acceptable. 3. The bar heights are non-negative integers (0 ≤ heights[i] ≤ 10^6). # Examples ```python >>> total_histogram_area([1, 2, 3, 4, 5]) 15 >>> total_histogram_area([0, 2, 2, 2]) 6 >>> total_histogram_area([1, 1, 2, 3]) 7 >>> total_histogram_area([5, 5, 5]) 15 >>> total_histogram_area([3, 4, 4, 5, 6]) 22 ``` # Notes 1. Remember that since the bars can only align vertically in non-decreasing order, every bar adds its height times its width to the total area. 2. Ensure to handle the edge case where the list is empty, which should return an area of 0.","solution":"def total_histogram_area(heights): Calculate the total area of the histogram where each bar can be aligned vertically with the previous bar, with each bar starting at the level of the previous bar or higher. :param heights: List of non-negative integers representing the heights of the histogram bars. :return: Integer representing the total area of the histogram. if not heights: return 0 total_area = 0 for height in heights: total_area += height return total_area"},{"question":"# Greatest Common Divisor of Factorials **Objective**: Write a function to compute the greatest common divisor (GCD) of the factorials of two given numbers. **Scenario**: In number theory, factorials are the product of all positive integers less than or equal to a given positive integer. The gcd of two numbers is the largest positive integer that divides both of them without leaving a remainder. Given two parameters `a` and `b`, you need to compute the gcd of `a!` and `b!`. # Function Signature ```python def gcd_of_factorials(a: int, b: int) -> int: This function returns the gcd of the factorials of two given numbers. Parameters: a (int): First non-negative integer. Should be >= 0. b (int): Second non-negative integer. Should be >= 0. Returns: int: The gcd of a! and b!. pass ``` # Input - `a` (integer): A non-negative integer (0 ≤ a ≤ 100). - `b` (integer): A non-negative integer (0 ≤ b ≤ 100). # Output - Returns an integer which is the gcd of `a!` and `b!`. # Constraints - Python\'s `math.factorial` and `math.gcd` functions should be utilized to handle large numbers and perform efficient calculations. # Example ```python >>> gcd_of_factorials(5, 10) 120 >>> gcd_of_factorials(7, 12) 5040 >>> gcd_of_factorials(3, 8) 6 >>> gcd_of_factorials(0, 0) 1 ``` # Notes 1. To compute the gcd of factorials of two numbers, it\'s optimal to use the smaller number\'s factorial, as the gcd of `a!` and `b!` is `min(a, b)!`. 2. Ensure the solution is efficient within the given constraints. **Write your solution below:** ```python import math def gcd_of_factorials(a: int, b: int) -> int: # Compute the factorial of the smaller of the two numbers min_number = min(a, b) return math.factorial(min_number) ```","solution":"import math def gcd_of_factorials(a: int, b: int) -> int: This function returns the gcd of the factorials of two given numbers. Parameters: a (int): First non-negative integer. Should be >= 0. b (int): Second non-negative integer. Should be >= 0. Returns: int: The gcd of a! and b!. # Compute the factorial of the smaller of the two numbers min_number = min(a, b) return math.factorial(min_number)"},{"question":"# Question Implement a function `flatten_dict` that takes a nested dictionary and converts it into a flat dictionary, concatenating the keys at different levels with a specified separator. The function should handle dictionaries nested to any level and return a dictionary with \\"/\\" separating the keys. # Required Function Signature ```python def flatten_dict(d: dict, parent_key: str = \\"\\", sep: str = \\"/\\") -> dict: pass ``` # Example ```python >>> flatten_dict({\\"a\\": 1, \\"b\\": {\\"c\\": 2, \\"d\\": {\\"e\\": 3, \\"f\\": 4}}, \\"g\\": 5}) {\\"a\\": 1, \\"b/c\\": 2, \\"b/d/e\\": 3, \\"b/d/f\\": 4, \\"g\\": 5} >>> flatten_dict({\\"a\\": {\\"b\\": {\\"c\\": {\\"d\\": {\\"e\\": 1}}}}}, sep=\\"-\\") {\\"a-b-c-d-e\\": 1} >>> flatten_dict({}) {} >>> flatten_dict({\\"key\\": {\\"subkey\\": {\\"subsubkey\\": \\"value\\"}}}) {\\"key/subkey/subsubkey\\": \\"value\\"} ``` # Constraints * The keys in the dictionaries will be strings. * The values in the dictionaries will be either strings, integers, floats, or other dictionaries. * The separator `sep` will be a string of length 1. # Description Write a function `flatten_dict` that takes a nested dictionary `d` and flattens it such that each key path is concatenated using the specified separator `sep`. If no separator is specified, use \\"/\\" as the default separator. The nested dictionary can have any level of nesting. The key for each entry in the flat dictionary should represent the path to that entry in the nested dictionary, with the keys at each level joined by the separator. For instance, given a nested dictionary `{\\"a\\": 1, \\"b\\": {\\"c\\": 2, \\"d\\": 3}}`, the function should return `{\\"a\\": 1, \\"b/c\\": 2, \\"b/d\\": 3}` using the default separator \\"/\\". Ensure that the function can handle edge cases such as empty dictionaries and that it can process nested dictionaries with varying depths of nesting.","solution":"def flatten_dict(d, parent_key=\\"\\", sep=\\"/\\"): items = {} for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.update(flatten_dict(v, new_key, sep=sep)) else: items[new_key] = v return items"},{"question":"# Balanced Parentheses: Extended Validation You are required to implement an extended version of a balanced parentheses checker that can handle additional types of brackets and recognize nested structures effectively. # Task Implement a function `is_valid_brackets_sequence` that determines if a given string containing multiple types of brackets is valid. A string is considered valid if all types of brackets are properly opened and closed, and the brackets are correctly nested. # Specifications Function: `is_valid_brackets_sequence` - **Input**: A string `s` containing the characters \'(\', \')\', \'{\', \'}\', \'[\', \']\', \'<\', \'>\', and other alphabetic characters. - **Output**: Boolean value - `True` if `s` is a valid bracket sequence; `False` otherwise. # Constraints 1. The input string `s` can have length up to 10^4. 2. The input string `s` may contain letters and whitespace which should be ignored while validating the brackets. 3. Consider only the following pairs: `()`, `{}`, `[]`, `<>`. # Examples ```python >>> is_valid_brackets_sequence(\\"a(b)c{d[e]f}g<h>i\\") True >>> is_valid_brackets_sequence(\\"a(b{c)d}\\") False >>> is_valid_brackets_sequence(\\"Example 123 () { <> [test] }\\") True >>> is_valid_brackets_sequence(\\"Some < text with [ mismatched ( brackets )\\") False >>> is_valid_brackets_sequence(\\"a<<b>>\\") True ``` # Implementation ```python def is_valid_brackets_sequence(s: str) -> bool: stack = [] bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\', \'>\': \'<\'} opening_brackets = set(bracket_map.values()) for char in s: if char in opening_brackets: stack.append(char) elif char in bracket_map: if stack and stack[-1] == bracket_map[char]: stack.pop() else: return False return not stack ``` Ensure that your function handles various types of brackets correctly, considers only the relevant characters for validation, and performs efficiently for long input strings.","solution":"def is_valid_brackets_sequence(s: str) -> bool: stack = [] bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\', \'>\': \'<\'} opening_brackets = set(bracket_map.values()) for char in s: if char in opening_brackets: stack.append(char) elif char in bracket_map: if stack and stack[-1] == bracket_map[char]: stack.pop() else: return False return not stack"},{"question":"# Problem Statement You are given an `n`x`n` matrix representing an image as a list of lists. Each element represents the grayscale value of a pixel. The task is to write a Python function that performs a 90-degree clockwise rotation of the image in place. # Input - A single integer `n` (1 ≤ n ≤ 100), representing the size of the matrix. - An `n`x`n` list of lists (matrix) of integers where each element is between 0 and 255 (inclusive). # Output - The rotated matrix as an `n`x`n` list of lists (matrix). # Constraints - The matrix is always an `n`x`n` square. - Each element in the matrix represents a grayscale value between 0 and 255 (inclusive). # Requirements 1. Your solution should rotate the matrix in place, using only O(1) extra space. 2. Optimize for performance within the given constraints. 3. Provide complete and well-documented code. # Example Consider the following example of a matrix: Input ``` n = 4 matrix = [ [ 1, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12], [13, 14, 15, 16] ] ``` Output ``` [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] ``` # Function Signature ```python def rotate_matrix_clockwise(matrix: List[List[int]]) -> List[List[int]]: # Add your implementation here ``` # Implementation Implement the `rotate_matrix_clockwise` function and ensure it rotates the matrix correctly for the given example and other test cases that meet the constraints.","solution":"def rotate_matrix_clockwise(matrix): Rotates an n x n matrix 90 degrees clockwise in place. Parameters: matrix (List[List[int]]): The n x n matrix to be rotated. Returns: None: The matrix is modified in place. n = len(matrix) # First step is to transpose the matrix. for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Second step is to reverse each row. for i in range(n): matrix[i].reverse()"},{"question":"# Coding Assessment Question Problem Statement **Context**: Lisa is a software engineer working on a system that deals with time intervals. She needs a utility to merge overlapping intervals for better resource management. Each interval is represented as a tuple consisting of a start and end time, and intervals are considered overlapping if they intersect or touch each other. **Task**: Implement a function `merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]` that takes a list of intervals and returns a list of merged intervals. **Function Signature**: ```python def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: ``` **Parameters**: - `intervals` (List[Tuple[int, int]]): A list of intervals represented as tuples of two integers (start, end), where `0 <= start < end <= 10^5`. **Returns**: - (List[Tuple[int, int]]): A list of merged intervals, sorted by their start time. **Examples**: ```python assert merge_intervals([(1, 3), (2, 4), (5, 7), (6, 8)]) == [(1, 4), (5, 8)] assert merge_intervals([(1, 5), (2, 6), (8, 10), (15, 18)]) == [(1, 6), (8, 10), (15, 18)] assert merge_intervals([(1, 4), (4, 5)]) == [(1, 5)] assert merge_intervals([(1, 2), (3, 4), (5, 6)]) == [(1, 2), (3, 4), (5, 6)] ``` **Notes**: * The merging should be done in-place if possible to optimize space. * The resulting list should be sorted by the start times of the intervals. * Consider edge cases such as an empty list or a list with only one interval which should be returned as is. **Scenario**: Lisa is working on a feature that requires efficient resource allocation over time intervals. Your task is to help her by writing an effective interval merging algorithm.","solution":"from typing import List, Tuple def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merges a list of intervals so that any overlapping intervals are combined. Parameters: intervals (List[Tuple[int, int]]): A list of intervals represented as tuples (start, end). Returns: List[Tuple[int, int]]: A list of merged intervals. # If the list of intervals is empty or has one interval, return it as is. if not intervals or len(intervals) == 1: return intervals # Sort the intervals by their start time. intervals.sort(key=lambda x: x[0]) merged = [] start, end = intervals[0] for i in range(1, len(intervals)): current_start, current_end = intervals[i] if current_start <= end: # There is an overlap, so we merge the intervals. end = max(end, current_end) else: # No overlap, add the previous merged interval to the list and update the start and end. merged.append((start, end)) start, end = current_start, current_end # Add the last merged interval. merged.append((start, end)) return merged"},{"question":"# AVL Tree Insertion and Balancing You are required to implement an AVL Tree from scratch and perform insertion operations that maintain the height-balanced property. An AVL Tree is a self-balancing binary search tree where the difference between the heights of left and right subtrees cannot be more than one for all nodes. # Problem 1. **Implement the AVL Tree Node**: - Write a class `AVLNode` to represent a node in an AVL Tree. - Each node should store its own value, height, and pointers to its left and right children. 2. **Implement the AVL Tree Insertion**: - Write a function `insert(node, value)` to insert a `value` into the AVL Tree and return the new root of the tree. - After insertion, ensure that the tree remains balanced by performing necessary rotations (left rotation, right rotation, left-right rotation, right-left rotation). # Function Signatures ```python class AVLNode: def __init__(self, value:int, left:Optional[\'AVLNode\']=None, right:Optional[\'AVLNode\']=None, height:int=1): self.value = value self.left = left self.right = right self.height = height def insert(node: Optional[AVLNode], value: int) -> AVLNode: # Implement this function ``` # Requirements 1. **Input**: - `insert(node, value)`: the root of the AVL Tree `node` and an integer `value` to insert. 2. **Output**: - Returns the new root of the AVL Tree after insertion and rebalancing. 3. **Constraints**: - Nodes in the AVL Tree contain unique integer values. - The tree should remain balanced after each insertion. # Example Inserting values into the AVL Tree: ```python root = None values = [10, 20, 30, 40, 50, 25] for value in values: root = insert(root, value) # AVL Tree should be balanced after each insertion ``` # Additional Notes - Ensure your AVL Tree handles edge cases like inserting into an empty tree. - Correctly update and maintain the height of each node after insertion and rotation operations. - Optimize for both space and time complexity.","solution":"class AVLNode: def __init__(self, value: int, left: \'AVLNode\' = None, right: \'AVLNode\' = None, height: int = 1): self.value = value self.left = left self.right = right self.height = height def insert(node: AVLNode, key: int) -> AVLNode: # Base case: If the tree is empty, return a new node if not node: return AVLNode(key) # Recursive case: Insert key into the left or right subtree if key < node.value: node.left = insert(node.left, key) else: node.right = insert(node.right, key) # Update height of this ancestor node node.height = 1 + max(get_height(node.left), get_height(node.right)) # Get the balance factor of this ancestor node to check whether # this node became unbalanced balance = get_balance(node) # If the node becomes unbalanced, then there are four cases # Left Left Case if balance > 1 and key < node.left.value: return right_rotate(node) # Right Right Case if balance < -1 and key > node.right.value: return left_rotate(node) # Left Right Case if balance > 1 and key > node.left.value: node.left = left_rotate(node.left) return right_rotate(node) # Right Left Case if balance < -1 and key < node.right.value: node.right = right_rotate(node.right) return left_rotate(node) # Return the (unchanged) node pointer return node def get_height(node: AVLNode) -> int: if not node: return 0 return node.height def get_balance(node: AVLNode) -> int: if not node: return 0 return get_height(node.left) - get_height(node.right) def right_rotate(z: AVLNode) -> AVLNode: y = z.left T3 = y.right # Perform rotation y.right = z z.left = T3 # Update heights z.height = 1 + max(get_height(z.left), get_height(z.right)) y.height = 1 + max(get_height(y.left), get_height(y.right)) # Return the new root return y def left_rotate(z: AVLNode) -> AVLNode: y = z.right T2 = y.left # Perform rotation y.left = z z.right = T2 # Update heights z.height = 1 + max(get_height(z.left), get_height(z.right)) y.height = 1 + max(get_height(y.left), get_height(y.right)) # Return the new root return y"},{"question":"# Tree Traversal and Depth Calculation You are tasked with developing a function that analyzes a binary tree structure and extracts specific insights related to its depth and traversal characteristics. Your function should demonstrate your understanding of tree data structures and traversal algorithms. # Objective Write a function `analyze_binary_tree(root: TreeNode) -> dict` that takes the root of a binary tree as input and returns a dictionary with key insights related to the binary tree. # Input * `root` (TreeNode): The root node of a binary tree. Each TreeNode has the following attributes: - `val` (int): The value of the node. - `left` (TreeNode): The left child node. - `right` (TreeNode): The right child node. # Output * `insights` (dict): A dictionary containing the following key insights: - `max_depth` (int): The maximum depth of the binary tree. - `preorder_traversal` (list): A list of node values in preorder traversal order. - `inorder_traversal` (list): A list of node values in inorder traversal order. - `postorder_traversal` (list): A list of node values in postorder traversal order. # Constraints * You need to handle edge cases such as an empty tree. * Ensure that the solution is efficient in terms of time and space complexity. # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def analyze_binary_tree(root: TreeNode) -> dict: # Your implementation here pass # Example usage: root = TreeNode(1) root.left = TreeNode(2, TreeNode(4), TreeNode(5)) root.right = TreeNode(3) insights = analyze_binary_tree(root) print(insights) # Output: # { # \\"max_depth\\": 3, # \\"preorder_traversal\\": [1, 2, 4, 5, 3], # \\"inorder_traversal\\": [4, 2, 5, 1, 3], # \\"postorder_traversal\\": [4, 5, 2, 3, 1] # } ``` Ensure your implementation follows the guidelines provided, handles edge cases, and efficiently processes the data.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def analyze_binary_tree(root: TreeNode) -> dict: if not root: return { \\"max_depth\\": 0, \\"preorder_traversal\\": [], \\"inorder_traversal\\": [], \\"postorder_traversal\\": [] } def max_depth(node): if not node: return 0 left_depth = max_depth(node.left) right_depth = max_depth(node.right) return max(left_depth, right_depth) + 1 def preorder_traversal(node): return [node.val] + preorder_traversal(node.left) + preorder_traversal(node.right) if node else [] def inorder_traversal(node): return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) if node else [] def postorder_traversal(node): return postorder_traversal(node.left) + postorder_traversal(node.right) + [node.val] if node else [] insights = { \\"max_depth\\": max_depth(root), \\"preorder_traversal\\": preorder_traversal(root), \\"inorder_traversal\\": inorder_traversal(root), \\"postorder_traversal\\": postorder_traversal(root) } return insights"},{"question":"# Scenario You are developing a scheduling application for a company\'s meeting rooms. Each meeting room has a predefined list of available time slots for bookings. Your task is to implement a function that finds all time slots during which at least one meeting room is available. # Task Implement the function `find_available_time_slots(slots: Dict[str, List[Tuple[str, str]]]) -> List[Tuple[str, str]]` that finds all available time slots across all meeting rooms. A time slot is considered available if it is present in at least one of the meeting rooms\' lists. # Input * `slots` (Dict[str, List[Tuple[str, str]]]): A dictionary where keys are room names (strings) and values are lists of tuples representing available time slots. Each tuple contains two strings in the \\"HH:MM\\" format representing the start time and end time of the slot. # Output * (List[Tuple[str, str]]): A list of tuples representing the available time slots across all rooms. Each tuple consists of two strings in the \\"HH:MM\\" format. # Examples ```python find_available_time_slots({ \\"Room1\\": [(\\"09:00\\", \\"10:00\\"), (\\"11:00\\", \\"12:00\\")], \\"Room2\\": [(\\"09:00\\", \\"10:00\\"), (\\"13:00\\", \\"14:00\\")], \\"Room3\\": [(\\"12:00\\", \\"13:00\\"), (\\"14:00\\", \\"15:00\\")] }) # Expected Output: [(\'09:00\', \'10:00\'), (\'11:00\', \'12:00\'), (\'13:00\', \'14:00\'), (\'12:00\', \'13:00\'), (\'14:00\', \'15:00\')] find_available_time_slots({ \\"RoomA\\": [(\\"08:00\\", \\"09:00\\")], \\"RoomB\\": [(\\"09:00\\", \\"10:00\\")], \\"RoomC\\": [(\\"10:00\\", \\"11:00\\")] }) # Expected Output: [(\'08:00\', \'09:00\'), (\'09:00\', \'10:00\'), (\'10:00\', \'11:00\')] find_available_time_slots({ \\"RoomX\\": [(\\"10:00\\", \\"11:00\\"), (\\"14:00\\", \\"15:00\\")], \\"RoomY\\": [(\\"12:00\\", \\"13:00\\"), (\\"14:00\\", \\"15:00\\")], \\"RoomZ\\": [(\\"10:00\\", \\"11:00\\"), (\\"12:00\\", \\"13:00\\"), (\\"16:00\\", \\"17:00\\")] }) # Expected Output: [(\'10:00\', \'11:00\'), (\'14:00\', \'15:00\'), (\'12:00\', \'13:00\'), (\'16:00\', \'17:00\')] ``` # Constraints * All time slots are in the \\"HH:MM\\" format. * Time slots within each room do not overlap. * There can be up to 20 meeting rooms. * Each room may have up to 10 time slots. # Performance Requirements Ensure your implementation handles the merging of time slots efficiently. # Additional Notes - Feel free to use any standard library functions necessary for sorting and managing the list of time slots. - Ensure that the output list does not contain duplicate time slots.","solution":"def find_available_time_slots(slots): Given a dictionary of meeting rooms and their available time slots, returns a list of all unique time slots during which at least one meeting room is available. Args: slots (dict): A dictionary where keys are room names (strings) and values are lists of tuples representing available time slots. Each tuple contains two strings in the \\"HH:MM\\" format representing the start time and end time of the slot. Returns: list: A list of unique tuples representing the available time slots across all rooms. all_slots = set() for room in slots: for slot in slots[room]: all_slots.add(slot) return sorted(list(all_slots))"},{"question":"# Question: Analyze and Reverse Polish Notation (RPN) Evaluation Scenario You need to develop a function that evaluates expressions written in Reverse Polish Notation (RPN). Reverse Polish notation is a mathematical notation in which every operator follows all of its operands. It is also known as postfix notation. Task Implement a function `evaluate_rpn(tokens: list) -> int` that evaluates the given expression and returns the result. Each token in the array can be an integer, one of the binary operators (`+`, `-`, `*`, `/`), or an expression in which division should truncate toward zero. Input * `tokens`: A list of strings representing an RPN expression. The length of the list will be `n` where `1 <= n <= 1000`. * Each string in the list represents either an integer or one of the operators. Output * An integer representing the result of evaluating the RPN expression. Constraints * Division between two integers should truncate toward zero. * The token list is guaranteed to represent a valid RPN expression. Performance Requirements * Your solution should aim to operate within O(n) time complexity. Example 1. Input: `[\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]` Output: `9` Explanation: The expression \\"2 1 +\\" becomes \\"3\\", and \\"3 3 *\\" becomes \\"9\\". 2. Input: `[\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"]` Output: `6` Explanation: The expression \\"13 5 /\\" becomes \\"2\\", and \\"4 2 +\\" becomes \\"6\\". 3. Input: `[\\"10\\", \\"6\\", \\"9\\", \\"3\\", \\"+\\", \\"-11\\", \\"*\\", \\"/\\", \\"*\\", \\"17\\", \\"+\\", \\"5\\", \\"+\\"]` Output: `22` Explanation: - \\"3 + -11\\" becomes \\"-8\\" - \\"9 -8 *\\" becomes \\"-72\\" - \\"6 -72 /\\" becomes \\"0\\" (truncated towards zero) - \\"10 0 *\\" becomes \\"0\\" - \\"0 17 +\\" becomes \\"17\\" - \\"17 5 +\\" becomes \\"22\\" Edge Cases to Consider * Single-element list * Elements that may cause integer truncation Additional Challenge * Implement error handling for invalid input. * Optimize the function to handle very large expressions efficiently.","solution":"def evaluate_rpn(tokens): Evaluates the given expression in Reverse Polish Notation and returns the result. stack = [] for token in tokens: if token in \\"+-*/\\": b = stack.pop() a = stack.pop() if token == \\"+\\": stack.append(a + b) elif token == \\"-\\": stack.append(a - b) elif token == \\"*\\": stack.append(a * b) elif token == \\"/\\": # Truncate towards zero for integer division stack.append(int(a / b)) else: stack.append(int(token)) return stack[0]"},{"question":"# Scenario: You are building a text editor that supports basic functionalities like inserting, deleting, and undoing the last operation. Your primary focus is to implement these functionalities efficiently. # Requirements: 1. **Insert operation** should add a substring at a specified position within the text. 2. **Delete operation** should remove a substring from a specified position with a given length. 3. **Undo operation** should revert the text to the state before the last insert or delete operation. # Function Specification: 1. **Insert Function**: ```python def insert(self, pos: int, substring: str) -> None: Inserts a substring into the text at the given position. Parameters: pos (int): Position to insert the substring. substring (str): Substring to be inserted. # Your implementation here ``` 2. **Delete Function**: ```python def delete(self, pos: int, length: int) -> None: Deletes a substring from the text starting at the given position with the specified length. Parameters: pos (int): Starting position of the deletion. length (int): Number of characters to delete. # Your implementation here ``` 3. **Undo Function**: ```python def undo(self) -> None: Reverts the text to the state before the last insert or delete operation. # Your implementation here ``` # Constraints: - **String Length**: 0 <= length of the text <= 10^5 - **Position**: 0 <= pos <= current length of the text - **Substring Length**: 0 <= length of the substring <= 10^5 # Performance Requirements: - All functions should be designed to handle the worst-case scenario within acceptable time limits. # Example Usage: ```python # Initialize the text editor with an empty text editor = TextEditor() # Insert the string \\"hello\\" at position 0 editor.insert(0, \\"hello\\") # Text: \\"hello\\" # Insert the string \\" world\\" at position 5 editor.insert(5, \\" world\\") # Text: \\"hello world\\" # Delete 6 characters from position 5 (start of \\" world\\") editor.delete(5, 6) # Text: \\"hello\\" # Undo the last operation (deletion), bringing back \\"hello world\\" editor.undo() # Text: \\"hello world\\" # Undo the previous operation (insertion of \\" world\\"), leaving only \\"hello\\" editor.undo() # Text: \\"hello\\" ``` Ensure that the insert, delete, and undo operations follow the constraints and perform efficiently.","solution":"class TextEditor: def __init__(self): self.text = \\"\\" self.history = [] def insert(self, pos: int, substring: str) -> None: Inserts a substring into the text at the given position. self.history.append(self.text) self.text = self.text[:pos] + substring + self.text[pos:] def delete(self, pos: int, length: int) -> None: Deletes a substring from the text starting at the given position with the specified length. self.history.append(self.text) self.text = self.text[:pos] + self.text[pos + length:] def undo(self) -> None: Reverts the text to the state before the last insert or delete operation. if self.history: self.text = self.history.pop()"},{"question":"# Background You are managing data for a small pharmaceutical company. The company needs to track the number of different drug orders made each day for each of its products. The orders are stored in a list of dictionaries, where each dictionary represents an order and contains the product name and the quantity of the product ordered. # Problem Write a function `summarize_orders` that returns a summary of the total number of orders for each product within a given list of orders. # Function Signature ```python def summarize_orders(orders: List[Dict[str, int]]) -> Dict[str, int]: pass ``` # Input * `orders` (List[Dict[str, int]]): A list of dictionaries. Each dictionary contains: - `product` (str): The name of the product. - `quantity` (int): The number of units ordered. # Output * Returns a dictionary where the keys are product names and the values are the total number of units ordered for each product. # Example ```python orders = [ {\\"product\\": \\"Aspirin\\", \\"quantity\\": 10}, {\\"product\\": \\"Ibuprofen\\", \\"quantity\\": 5}, {\\"product\\": \\"Aspirin\\", \\"quantity\\": 3}, {\\"product\\": \\"Acetaminophen\\", \\"quantity\\": 2} ] summarize_orders(orders) # Returns {\'Aspirin\': 13, \'Ibuprofen\': 5, \'Acetaminophen\': 2} ``` # Constraints * Each order dictionary contains non-empty strings for `product` and non-negative integers for `quantity`. * The list of orders may be empty, in which case the function should return an empty dictionary. # Additional Notes * Ensure the function handles large lists efficiently with minimal complexity. * Consider the possibility of orders containing different products, and accurately summarize the total number of units for each unique product.","solution":"from typing import List, Dict def summarize_orders(orders: List[Dict[str, int]]) -> Dict[str, int]: summary = {} for order in orders: product = order[\'product\'] quantity = order[\'quantity\'] if product in summary: summary[product] += quantity else: summary[product] = quantity return summary"},{"question":"# Element-wise Matrix Exponential Context In this problem, we will focus on the implementation of a function that computes the element-wise exponential of a given matrix. This function will be useful when dealing with transformations in scientific computing and machine learning. Task Description You need to complete the function `matrix_exponential` which computes the element-wise exponential of a given 2D numpy array (matrix). The function should ensure efficiency and handle large values gracefully to avoid numerical overflow issues. Input - A 2D numpy array `matrix` containing real numbers. Output - A 2D numpy array of the same shape as the input, with each element being the exponential of the corresponding input element. Constraints - The function must handle edge cases of very large or very small values gracefully, preventing overflow/underflow issues. - The function should utilize numpy for efficient computation. - The input matrix can be of any arbitrary size. Examples ```python >>> import numpy as np >>> matrix_exponential(np.array([[0, 1], [2, -1]])) array([[1. , 2.71828183], [7.3890561 , 0.36787944]]) >>> matrix_exponential(np.array([[-2, -3], [-1, 0]])) array([[0.13533528, 0.04978707], [0.36787944, 1. ]]) >>> matrix_exponential(np.array([[1e-10, 1e10], [5, -5]])) array([[1. , inf], [148.4131591, 0.00673795]]) ``` In the last example, observe that very large input values like `1e10` are handled by returning `inf`.","solution":"import numpy as np def matrix_exponential(matrix): Computes the element-wise exponential of the given 2D numpy array (matrix). Parameters: matrix (np.ndarray): 2D numpy array of real numbers Returns: np.ndarray: A 2D numpy array with the element-wise exponential of the input return np.exp(matrix)"},{"question":"# Scenario A telecommunication company wants to ensure optimal performance of their network by detecting any potential issues with the connectivity. They need to determine if their network is connected and which nodes (if any) are disconnected. The network is represented as a graph where nodes are the network stations, and edges are the direct communication lines between them. # Problem Statement You are given an undirected graph represented as an adjacency list. Each list index represents a node, and the corresponding list contains the indices of the nodes that are directly connected to it by an edge. Implement the function **find_disconnected_nodes** that determines whether the graph is fully connected. If not, return a list of nodes that are disconnected from the main component (the largest connected subgraph), sorted in ascending order. If the graph is fully connected, return an empty list. # Function Signature ```python def find_disconnected_nodes(adj_list: List[List[int]]) -> List[int]: ``` # Input - **adj_list**: A list of lists where the i-th list contains the nodes that are directly connected to the i-th node. # Output - Returns a list of integers representing the nodes that are disconnected from the main component. The list should be sorted in ascending order. If the graph is fully connected, return an empty list. # Constraints - (1 leq text{len(adj_list)} leq 1000) - (0 leq text{adj_list[i][j]} < text{len(adj_list)}) - The graph can have disconnected components, but no self-loops or duplicate edges. # Example ```python adj_list = [ [1, 2], [0, 3], [0], [1], [5], [4] ] print(find_disconnected_nodes(adj_list)) # Expected output: [4, 5] adj_list = [ [1, 2, 3], [0, 2, 3], [0, 1, 3], [0, 1, 2] ] print(find_disconnected_nodes(adj_list)) # Expected output: [] ``` # Constraints and Performance Notes - Ensure the solution is efficient, with a reasonable runtime performance for the given constraints. - Your solution should ideally utilize graph traversal algorithms like Depth-First Search (DFS) or Breadth-First Search (BFS).","solution":"from typing import List def find_disconnected_nodes(adj_list: List[List[int]]) -> List[int]: def dfs(node, visited): stack = [node] while stack: current_node = stack.pop() if current_node not in visited: visited.add(current_node) for neighbor in adj_list[current_node]: if neighbor not in visited: stack.append(neighbor) n = len(adj_list) visited = set() # Start DFS from the first node dfs(0, visited) # Check for any node not visited disconnected_nodes = [node for node in range(n) if node not in visited] return sorted(disconnected_nodes)"},{"question":"# Coding Assessment Question Task You are required to write a Python function that implements a basic text-based Minesweeper game. The game should be able to initialize a grid, display it, and reveal cells based on user inputs. Function Specifications Write a class `Minesweeper` that provides the following methods: * `__init__(self, rows: int, columns: int, mines: int) -> None`: Initializes the Minesweeper game with the given number of rows, columns, and mines. The grid cells are stored in a 2D list. * `display(self) -> None`: Displays the current state of the grid. Covered cells should be shown as `#`, revealed cells should show the number of adjacent mines or `M` if the cell itself contains a mine. * `reveal(self, row: int, column: int) -> bool`: Reveals the cell at the given row and column. If the cell contains a mine, the game is over and it returns `False`. Otherwise, it returns `True`. Constraints * The number of rows, columns, and mines are positive integers such that `1 <= rows, columns <= 20` and `0 <= mines < rows * columns`. * Mines should be placed randomly in the grid. * The initial display state of the grid should hide all cells. * If the user reveals a mine, the game should end. * Try to handle invalid inputs gracefully. * Ensure the performance allows for reasonably fast initialization and grid operations. Example **Initialization:** ```python game = Minesweeper(5, 5, 3) ``` **Display Grid (initial state):** ``` # # # # # # # # # # # # # # # # # # # # # # # # # ``` **Reveal a cell:** ```python game.reveal(0, 0) game.display() ``` **Possible Output after Reveal:** ``` 1 # # # # # # # # # # # # # # # # # # # # # # # # ``` This indicates that the top-left cell was revealed to have `1` adjacent mine. Additional Information * The placement of mines should be random for every new game instance. * Revealing a cell with no adjacent mines should reveal all adjacent cells recursively. * You should ensure the game is functional and visually clear when displayed in a standard console. Performance Requirements * Initialization and reveal operations should be efficient, performing within a fraction of a second for the worst case given the constraints. Ensure your class design is clean and modular to allow for future expansions and modifications.","solution":"import random class Minesweeper: def __init__(self, rows: int, columns: int, mines: int) -> None: self.rows = rows self.columns = columns self.mines = mines self.grid = [[\'#\' for _ in range(columns)] for _ in range(rows)] self.mine_locations = set() self._initialize_grid() def _initialize_grid(self): # Place mines randomly on the grid mine_count = 0 while mine_count < self.mines: r = random.randint(0, self.rows - 1) c = random.randint(0, self.columns - 1) if (r, c) not in self.mine_locations: self.mine_locations.add((r, c)) mine_count += 1 # Calculate adjacent mines for each cell self.grid_values = [[0 for _ in range(self.columns)] for _ in range(self.rows)] for r in range(self.rows): for c in range(self.columns): if (r, c) in self.mine_locations: self.grid_values[r][c] = \'M\' else: self.grid_values[r][c] = self._count_adjacent_mines(r, c) def _count_adjacent_mines(self, row: int, col: int) -> int: count = 0 for dr in [-1, 0, 1]: for dc in [-1, 0, 1]: if dr == 0 and dc == 0: continue nr, nc = row + dr, col + dc if 0 <= nr < self.rows and 0 <= nc < self.columns: if (nr, nc) in self.mine_locations: count += 1 return count def display(self) -> None: for row in self.grid: print(\' \'.join(row)) def reveal(self, row: int, col: int) -> bool: if (row, col) in self.mine_locations: self.grid[row][col] = \'M\' return False self._reveal_recursive(row, col) return True def _reveal_recursive(self, row: int, col: int): if not (0 <= row < self.rows and 0 <= col < self.columns): return if self.grid[row][col] != \'#\': return if self.grid_values[row][col] == \'M\': return self.grid[row][col] = str(self.grid_values[row][col]) if self.grid_values[row][col] == 0: for dr in [-1, 0, 1]: for dc in [-1, 0, 1]: if dr != 0 or dc != 0: self._reveal_recursive(row + dr, col + dc)"},{"question":"# Question: Implementing a Simple Event-Driven System in Python **Scenario:** You are working on a simulation system that processes a sequence of events. Each event influences the state of the system, and these interactions need to be modeled accurately. An event can be something like \\"arrival of a packet,\\" \\"start of a transaction,\\" or \\"completion of a task.\\" Your task is to build a simple event-driven simulation system that can register events, process them based on their type, and maintain a log of system states. **Task:** Implement a class `EventDrivenSystem` that manages and processes events. The system should maintain a state dictionary and a log of all processed events. **Class Signature:** ```python class EventDrivenSystem: def __init__(self) -> None: pass def register_event(self, event_type: str, action: Callable[[Dict[str, Any]], None]) -> None: pass def process_event(self, event_type: str, **kwargs) -> None: pass def get_state(self) -> Dict[str, Any]: pass def get_log(self) -> List[Dict[str, Any]]: pass ``` **Input Methods:** - `register_event(event_type, action)`: Registers a new event type with the specified action. The action is a callable that takes the system\'s current state dictionary and modifies it. - `process_event(event_type, **kwargs)`: Processes an event of the given type and updates the system state based on the registered action. - `get_state()`: Returns the current state of the system. - `get_log()`: Returns the log of all processed events. **Output:** - `get_state()`: Returns a dictionary that represents the current state of the system. - `get_log()`: Returns a list of dictionaries, where each dictionary represents the state of the system after processing each event. **Example:** ```python >>> def add_packet(state): >>> state[\'packets\'] = state.get(\'packets\', 0) + 1 >>> def complete_task(state): >>> state[\'tasks\'] = state.get(\'tasks\', 0) + 1 >>> system = EventDrivenSystem() >>> system.register_event(\'arrival\', add_packet) >>> system.register_event(\'completion\', complete_task) >>> system.process_event(\'arrival\') >>> system.process_event(\'completion\') >>> system.process_event(\'arrival\') >>> print(system.get_state()) {\'packets\': 2, \'tasks\': 1} >>> print(system.get_log()) [{\'packets\': 1}, {\'packets\': 1, \'tasks\': 1}, {\'packets\': 2, \'tasks\': 1}] ``` **Explanation:** In this example, the `EventDrivenSystem`: 1. Registers two event types (\\"arrival\\" and \\"completion\\") with their respective actions. 2. Processes three events: two arrivals and one completion. 3. Maintains and updates the system state (`get_state()`) and logs each state after event processing (`get_log()`).","solution":"from typing import Callable, Dict, List, Any class EventDrivenSystem: def __init__(self) -> None: self.state = {} self.log = [] self.event_actions = {} def register_event(self, event_type: str, action: Callable[[Dict[str, Any]], None]) -> None: self.event_actions[event_type] = action def process_event(self, event_type: str, **kwargs) -> None: if event_type in self.event_actions: self.event_actions[event_type](self.state) # Capture current state in log self.log.append(self.state.copy()) def get_state(self) -> Dict[str, Any]: return self.state def get_log(self) -> List[Dict[str, Any]]: return self.log"},{"question":"# Find Missing Number in a Sequence You are given a list of integers representing a sequence that should contain every number from 1 to `n` exactly once, except for one missing number. Write a function to find the missing number in this sequence. # Your Task: Write a function `find_missing_number(sequence, n)` that: 1. Computes the missing number in the sequence. 2. Returns the missing number. ```python def find_missing_number(sequence: list[int], n: int) -> int: # Your implementation here pass ``` # Input: - `sequence`: A list of integers containing the numbers from 1 to `n` with exactly one number missing. - `n`: An integer representing the total number of elements that should be in the sequence (including the missing number). # Output: - The function returns the missing number. # Constraints: - 1 <= n <= 100 - Each number in the sequence is unique and between 1 and `n`. # Example: ```python sequence = [1, 2, 4, 5] n = 5 missing_number = find_missing_number(sequence, n) print(missing_number) ``` Output: ``` 3 ``` # Notes: - Consider optimizing the solution for larger values within the given constraint. - Ensure to handle edge cases such as the first or last number being the missing one.","solution":"def find_missing_number(sequence: list[int], n: int) -> int: Returns the missing number in the sequence from 1 to n. :param sequence: List of integers containing the numbers from 1 to n with one missing. :param n: Total number of elements that should be in the sequence (including the missing number). :return: The missing number. # Using the formula for the sum of the first n natural numbers: n * (n + 1) / 2 total_sum = n * (n + 1) // 2 sequence_sum = sum(sequence) # The missing number is the difference between the expected sum and the actual sum return total_sum - sequence_sum"},{"question":"# Coding Assessment Question Scenario A robotics company is developing a delivery robot that needs to navigate a grid-like city to deliver packages. The robot can only move up, down, left, or right and it needs to find the shortest path from its starting position to the delivery point. The city grid might have obstacles that the robot cannot pass through. Task Write a Python function `shortest_path(grid: list, start: tuple, end: tuple) -> int` that calculates the shortest path from the starting position to the ending position in a grid where `1` represents an obstacle and `0` represents a free cell. Function Signature ```python def shortest_path(grid: list, start: tuple, end: tuple) -> int: ``` Input - `grid`: a 2D list of integers where `0` represents a free cell and `1` represents an obstacle. - `start`: a tuple `(x, y)` representing the robot\'s starting position. - `end`: a tuple `(x, y)` representing the robot\'s intended ending position. Output - Return an integer representing the length of the shortest path from start to end, or `-1` if no path exists. Constraints - The dimensions of `grid` will be `m x n` where `1 <= m, n <= 100`. - The start and end positions will always be within the grid bounds and in free cells. - All elements in `grid` will be either `0` or `1`. Examples ```python >>> shortest_path([[0, 0, 0], [1, 1, 0], [1, 0, 0]], (0, 0), (2, 2)) 4 >>> shortest_path([[0, 1], [0, 0]], (0, 0), (1, 1)) 2 >>> shortest_path([[0, 1], [1, 0]], (0, 0), (1, 1)) -1 ``` Requirements - Your solution should handle large grids efficiently. - Ensure the proper handling of edge cases, such as when the start or end position is surrounded by obstacles.","solution":"from collections import deque def shortest_path(grid: list, start: tuple, end: tuple) -> int: Calculates the shortest path from the starting position to the ending position in a grid where 1 represents an obstacle and 0 represents a free cell. Args: grid (list): A 2D list representing the grid. start (tuple): A tuple representing the starting position (x, y). end (tuple): A tuple representing the ending position (x, y). Returns: int: The length of the shortest path from start to end, or -1 if no path exists. if start == end: return 0 m, n = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start, 0)]) visited = set([start]) while queue: (x, y), dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: if (nx, ny) == end: return dist + 1 queue.append(((nx, ny), dist + 1)) visited.add((nx, ny)) return -1"},{"question":"# Coding Assessment Question **Scenario**: You are contributing to a software system that requires secure password validation. The system demands that passwords meet specific criteria to enhance security. You need to implement a function that checks whether a given password adheres to these criteria. **Task**: Write a function `validate_password` that: - Takes a single argument, `password`, which is a string. - Returns `True` if the `password` is valid according to the criteria defined below, and `False` otherwise. - The password must meet the following requirements: - It should have at least 8 characters. - It should contain at least one uppercase letter. - It should contain at least one lowercase letter. - It should contain at least one digit. - It should contain at least one special character from the set `!@#%^&*()-_+=`. **Input**: - A single string, `password`. **Output**: - A boolean, `True` if the password meets all the criteria, `False` otherwise. **Constraints**: - The function should have a linear time complexity O(n), where `n` is the length of the password string. - Be mindful of checking all the criteria in an efficient manner. **Function Signature**: ```python def validate_password(password: str) -> bool: ``` **Examples**: ```python validate_password(\\"A1b#cD\\") # Expected output: False (Too short) validate_password(\\"Abcdefgh\\") # Expected output: False (No digit and special character) validate_password(\\"Abcd1234\\") # Expected output: False (No special character) validate_password(\\"abcd1234#\\") # Expected output: False (No uppercase letter) validate_password(\\"ABCD1234#\\") # Expected output: False (No lowercase letter) validate_password(\\"Abc1234#\\") # Expected output: True validate_password(\\"GoodPass123\\") # Expected output: False (No special character) validate_password(\\"Perfect@123\\") # Expected output: True ``` Write comprehensive test cases to verify the correctness of your implementation. The function should pass all provided example cases, ensuring that passwords are validated correctly according to the defined criteria.","solution":"def validate_password(password: str) -> bool: Validates the given password based on specific criteria: - At least 8 characters long - Contains at least one uppercase letter - Contains at least one lowercase letter - Contains at least one digit - Contains at least one special character from the set `!@#%^&*()-_+=` if len(password) < 8: return False has_upper = has_lower = has_digit = has_special = False special_characters = set(\\"!@#%^&*()-_+=\\") for char in password: if char.isupper(): has_upper = True elif char.islower(): has_lower = True elif char.isdigit(): has_digit = True elif char in special_characters: has_special = True return has_upper and has_lower and has_digit and has_special"},{"question":"# Problem Statement You have been tasked to develop a program that aids biologists in determining the gender of a DNA sample using the presence of specific sex chromosomes. The function should analyze the DNA sequence provided and identify the gender based on chromosome presence. # Task Implement a function `determine_gender` that processes a DNA sequence string and determines the gender based on the following criteria: - The presence of both \'X\' and \'Y\' chromosomes indicates MALE. - The presence of two \'X\' chromosomes indicates FEMALE. - Any other configuration should be returned as UNKNOWN. Function Signature ```python def determine_gender(dna_sequence: str) -> str: ``` Input * `dna_sequence` (str): A string representing the DNA sequence consisting of the letters \'X\' and \'Y\'. Output * (str): Returns \\"MALE\\" if the sequence contains both \'X\' and \'Y\' chromosomes, \\"FEMALE\\" if it contains at least two \'X\' chromosomes and no \'Y\', and \\"UNKNOWN\\" for any other configuration. Constraints * The DNA sequence string will only contain the characters \'X\' and \'Y\' and will have a length between 1 and 10 inclusive. # Example ```python assert determine_gender(\\"XX\\") == \\"FEMALE\\" assert determine_gender(\\"XY\\") == \\"MALE\\" assert determine_gender(\\"X\\") == \\"UNKNOWN\\" assert determine_gender(\\"YYY\\") == \\"UNKNOWN\\" ``` # Notes 1. You may assume the input string will always be uppercase. 2. Ensure to handle edge cases where the sequence length is minimal or maximal within the specified range. 3. Document any assumptions or additional considerations in your solution. 4. Consider performance implications, but assume the constraints will remain within reason.","solution":"def determine_gender(dna_sequence: str) -> str: Determines the gender based on the given DNA sequence. Presence of both \'X\' and \'Y\' chromosomes indicates MALE. Presence of two \'X\' chromosomes and no \'Y\' chromosome indicates FEMALE. Any other configuration returns UNKNOWN. Parameters: dna_sequence (str): A string representation of the DNA sequence consisting of \'X\' and \'Y\' characters. Returns: str: \\"MALE\\" if the sequence contains both \'X\' and \'Y\' chromosomes, \\"FEMALE\\" if it contains at least two \'X\' chromosomes and no \'Y\', \\"UNKNOWN\\" for any other configuration. if \'X\' in dna_sequence and \'Y\' in dna_sequence: return \\"MALE\\" elif dna_sequence.count(\'X\') >= 2 and \'Y\' not in dna_sequence: return \\"FEMALE\\" else: return \\"UNKNOWN\\""},{"question":"# Question Context: You are developing a utility to analyze and process text. Part of this utility involves identifying the most frequent substring within a given length from a given text data. The most frequent substring is defined as the substring that appears the most times within the provided length constraint. If multiple substrings have the same highest frequency, return the lexicographically smallest one. Task: Write a Python function `most_frequent_substring(text: str, length: int) -> str` that receives a string `text` and an integer `length`, and returns the most frequent substring of the given length. If two substrings have the same frequency, the lexicographically smallest one should be returned. Input: - `text` (str): A string of lowercase English letters. - `length` (int): An integer representing the length of substrings to be analyzed. (1 ≤ `length` ≤ len(text)) Output: - Return a string representing the most frequent substring of the provided length. Constraints: - The provided text will contain only lowercase English letters. - Ensure your solution runs efficiently for large text sizes (text length ≤ 10^5). Example: ```python assert most_frequent_substring(\\"banana\\", 2) == \\"an\\" assert most_frequent_substring(\\"abcabcabc\\", 3) == \\"abc\\" assert most_frequent_substring(\\"aabbaabbaabb\\", 2) == \\"aa\\" ``` Additional Notes: Consider edge cases such as very small or very large inputs to ensure efficiency and correctness in all scenarios.","solution":"def most_frequent_substring(text: str, length: int) -> str: Returns the most frequent substring of given length from the text. If multiple substrings have the same frequency, returns the lexicographically smallest one. from collections import defaultdict substring_count = defaultdict(int) # Iterate over all possible substrings of the given length for i in range(len(text) - length + 1): substring = text[i:i + length] substring_count[substring] += 1 # Find the most frequency substring, with tiebreaker for lexicographically smallest most_frequent = None max_count = 0 for substr, count in substring_count.items(): if count > max_count or (count == max_count and substr < most_frequent): most_frequent = substr max_count = count return most_frequent"},{"question":"# Problem Statement: You are given a list of non-negative integers which represents heights of buildings in a row. Write a function to calculate the total amount of water that can be trapped between the buildings when viewed from the side. Water is trapped between buildings based on their heights, so the amount of trapped water is determined by the heights of the buildings and the relative differences between them. Requirements: 1. **Function Name**: `calculate_trapped_water` 2. **Input**: A list of non-negative integers representing the heights of the buildings. 3. **Output**: Returns a single integer which is the total amount of trapped water. Constraints: * The list length can range from 0 to 10000. * Each height value in the list is a non-negative integer less than or equal to (10^5). Example: ```python def calculate_trapped_water(heights: list) -> int: # Your implementation here # Example Usage >>> calculate_trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> calculate_trapped_water([4, 2, 0, 3, 2, 5]) 9 >>> calculate_trapped_water([4, 0, 2, 5]) 6 ``` Notes: 1. The function should efficiently handle lists with varying heights and lengths. 2. Ensure the implementation can process large lists with tens of thousands of elements. 3. Consider edge cases such as very short lists or lists with all identical heights. 4. You may use two-pointer technique or dynamic programming approach to solve the problem efficiently. Detailed Steps: 1. **Initialize**: Create variables to track the total water trapped and indices or auxiliary lists as needed for the selected approach. 2. **Traverse and Calculate**: - For each building, determine the maximum height to the left and right. - Calculate the trapped water above each building based on the minimum of these heights and subtract the building\'s height. 3. **Sum the Results**: Aggregate the total trapped water and return it as the result.","solution":"def calculate_trapped_water(heights): Calculate the total amount of trapped water given the heights of buildings. :param heights: List[int] - A list of non-negative integers representing the heights of the buildings. :return: int - The total amount of trapped water. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water # Example Usage print(calculate_trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])) # Output: 6 print(calculate_trapped_water([4, 2, 0, 3, 2, 5])) # Output: 9 print(calculate_trapped_water([4, 0, 2, 5])) # Output: 6"},{"question":"# Coding Challenge: Merge and Sort Two Lists with Custom Conditions Context: You are tasked with implementing a function that merges and sorts elements from two given lists based on custom sorting conditions. This function is part of a larger project that requires flexible and efficient data manipulation. Task: Implement a function `merge_and_sort_lists(list1: list[int], list2: list[int]) -> list[int]` that: 1. Merges two lists of integers into one. 2. Sorts the merged list such that all even numbers appear before any odd numbers. 3. Sorts even and odd numbers in ascending order respectively. Implementation Details: * **Input**: * `list1`: A list of integers. * `list2`: A list of integers. * **Output**: * A list of integers sorted as per the above conditions. * **Constraints**: * The length of each list (list1 and list2) can be up to 10^6. * Values of integers in the lists lie between -10^9 and 10^9. Examples: ```python >>> merge_and_sort_lists([10, 15, 20], [1, 3, 2]) [2, 10, 20, 1, 3, 15] >>> merge_and_sort_lists([4, 6, 9], [8, 7, 3]) [4, 6, 8, 3, 7, 9] >>> merge_and_sort_lists([], [11, 12, 7]) [12, 7, 11] >>> merge_and_sort_lists([5, 5, 5], []) [5, 5, 5] ``` Ensure that the function handles large inputs efficiently and maintains the custom sorting order strictly. Use efficient algorithms and data structures to merge and sort the lists.","solution":"def merge_and_sort_lists(list1, list2): Merges two lists of integers and sorts them such that all even numbers appear before any odd numbers. Sorts even and odd numbers in ascending order respectively. :param list1: List of integers. :param list2: List of integers. :return: Merged and sorted list of integers. merged_list = list1 + list2 evens = sorted([x for x in merged_list if x % 2 == 0]) odds = sorted([x for x in merged_list if x % 2 != 0]) return evens + odds"},{"question":"Scenario You are hired by a logistics company to optimize their package delivery routes. To do this, you need to write a function that will calculate the shortest path between two locations in a grid city map. The city grid consists of streets and intersections, and you need to take into account that some streets may be blocked. Function Specification # Function Name `shortest_path` # Inputs - `grid` (List[List[int]]): A 2D list representing the city map. Each element can be: - `0` (empty intersection, can be used). - `1` (blocked intersection, cannot be used). - `start` (Tuple[int, int]): A tuple representing the starting intersection coordinates `(row, col)`. - `end` (Tuple[int, int]): A tuple representing the ending intersection coordinates `(row, col)`. # Output - An integer representing the length of the shortest path from the start to the end. If no such path exists, return `-1`. # Constraints - `1 <= len(grid) <= 100` - `1 <= len(grid[0]) <= 100` - The start and end intersections will always be empty (`0`). # Example Cases Example 1 ```python grid = [ [0, 0, 0, 1], [1, 1, 0, 1], [0, 0, 0, 0], [1, 0, 1, 0] ] assert shortest_path(grid, (0, 0), (2, 3)) == 5 ``` Example 2 ```python grid = [ [0, 1], [1, 0] ] assert shortest_path(grid, (0, 0), (1, 1)) == -1 ``` Example 3 ```python grid = [ [0, 0, 0], [0, 1, 0], [0, 1, 0], [0, 0, 0] ] assert shortest_path(grid, (0, 0), (3, 2)) == 5 ``` Example 4 ```python grid = [ [0, 0, 1, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] assert shortest_path(grid, (0, 3), (2, 4)) == 3 ``` Notes - Use Breadth-First Search (BFS) for finding the shortest path as it is well-suited for unweighted grid maps. - Make sure to handle edge cases such as fully blocked paths or the start and end locations being the same. - Ensure the function operates within the constraints efficiently.","solution":"from collections import deque def shortest_path(grid, start, end): Returns the length of the shortest path from start to end in a grid. If no such path exists, returns -1. rows, cols = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] # Down, Right, Up, Left def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and grid[x][y] == 0 queue = deque([(start[0], start[1], 0)]) # (row, col, distance) grid[start[0]][start[1]] = 1 # Mark the start position as visited while queue: x, y, dist = queue.popleft() if (x, y) == end: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): queue.append((nx, ny, dist + 1)) grid[nx][ny] = 1 # Mark as visited return -1"},{"question":"# Context You are given a social network dataset where each row represents a friendship relationship, with columns indicating the user IDs of two friends. The goal is to identify the number of connected components (clusters of friends) in the network. # Requirements Implement a function `find_connected_components` that will analyze the dataset to determine the total number of connected components within the social network using a graph traversal algorithm like Depth First Search (DFS) or Breadth First Search (BFS). # Function Specification ```python def find_connected_components(friendships: List[Tuple[int, int]]) -> int: Determine the number of connected components in the social network. :param friendships: List of tuples, where each tuple (a, b) represents a friendship relationship between user a and user b. :return: int, the total number of connected components in the network. pass ``` # Input - `friendships` - List of tuples where each tuple `(a, b)` indicates a friendship between user `a` and user `b`. # Output - Returns an integer representing the number of connected components in the network. # Example ```python # Example input friendships = [(1, 2), (2, 3), (4, 5)] # Running the function components = find_connected_components(friendships) print(components) # Example Output: 2 ``` # Constraints - Ensure all user IDs are positive integers. - The list can be empty, in which case the result should be 0. - There can be up to 10,000 users and 20,000 friendships. # Notes - Consider edge cases such as disconnected users, or all users being part of the same cluster. - Efficient graph traversal algorithms (DFS/BFS) should be used to handle large datasets effectively. By analyzing and adhering to the structure, complexity, and scope of the provided sample question, this new question offers a related problem in a different context—focusing on graph theory within the domain of social networks.","solution":"from typing import List, Tuple def find_connected_components(friendships: List[Tuple[int, int]]) -> int: def bfs(node): queue = [node] visited.add(node) while queue: current = queue.pop(0) for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) if not friendships: return 0 graph = {} for a, b in friendships: if a not in graph: graph[a] = [] if b not in graph: graph[b] = [] graph[a].append(b) graph[b].append(a) visited = set() count = 0 for node in graph: if node not in visited: count += 1 bfs(node) return count"},{"question":"# Subarray with Maximum Sum You are tasked with writing a function to find the subarray that has the maximum sum from a given list of integers. The function should return both the maximum sum and the subarray itself. Function Signature ```python def max_subarray_sum(arr: list[int]) -> tuple[int, list[int]]: ``` Inputs - `arr` (list of int): The list of integers from which to find the subarray with the maximum sum. Output - (tuple): A tuple where the first element is the maximum sum (int), and the second element is the list of integers representing the subarray with the maximum sum. Constraints - The input list can be empty. - All integers in the list can be positive, negative, or zero. - The subarray with the maximum sum must be contiguous. Example Usage ```python >>> max_subarray_sum([1, -3, 2, 1, -1]) (3, [2, 1]) >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) (7, [4, -1, -2, 1, 5]) >>> max_subarray_sum([1]) (1, [1]) >>> max_subarray_sum([]) (0, []) ``` Explanation Write a function that: 1. Identifies the subarray within the input list where the sum of its elements is maximized. 2. Returns the maximum sum along with the corresponding subarray. The function should efficiently handle empty lists and various arrangements of positive, negative, or zero integers within the list. This problem can be approached using Kadane\'s algorithm, which aims to solve the problem in linear time.","solution":"def max_subarray_sum(arr): if not arr: return (0, []) max_sum = float(\'-inf\') current_sum = 0 start = end = s = 0 for i in range(len(arr)): current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum start = s end = i if current_sum < 0: current_sum = 0 s = i + 1 return (max_sum, arr[start:end+1])"},{"question":"# Coding Question Problem Statement Create a function that computes the Longest Common Subsequence (LCS) of two given strings. In addition to calculating the LCS itself, the function should also track and return the number of dynamic programming table cells evaluated during the calculation. Requirements 1. **Function Definition**: - Input: Two strings `s1` and `s2`. - Output: A tuple `(lcs, cell_count)` where `lcs` is the longest common subsequence of `s1` and `s2`, and `cell_count` is the number of table cells evaluated during computation. 2. **Constraints**: - The length of both strings can be up to `1000`. 3. **Performance**: - Solutions should be efficient and handle the maximum input size comfortably, ideally utilizing dynamic programming. Example ```python assert longest_common_subsequence(\\"ABCBDAB\\", \\"BDCABC\\") == (\\"BCAB\\", 42) assert longest_common_subsequence(\\"XMJYAUZ\\", \\"MZJAWXU\\") == (\\"MJAU\\", 49) assert longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") == (\\"GTAB\\", 35) ``` Implementation Details Please implement the following function: ```python def longest_common_subsequence(s1: str, s2: str) -> Tuple[str, int]: Calculate the longest common subsequence using dynamic programming. Returns: (lcs, cell_count): Tuple containing the Longest Common Subsequence and the number of cells evaluated. n, m = len(s1), len(s2) dp = [[0] * (m + 1) for _ in range(n + 1)] cell_count = 0 # Fill dp table and count cells for i in range(1, n + 1): for j in range(1, m + 1): cell_count += 1 if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Reconstruct LCS from dp table lcs = [] while n > 0 and m > 0: if s1[n - 1] == s2[m - 1]: lcs.append(s1[n - 1]) n -= 1 m -= 1 elif dp[n - 1][m] >= dp[n][m - 1]: n -= 1 else: m -= 1 return \'\'.join(reversed(lcs)), cell_count ```","solution":"def longest_common_subsequence(s1: str, s2: str) -> tuple: Calculate the longest common subsequence using dynamic programming. Returns: (lcs, cell_count): Tuple containing the Longest Common Subsequence and the number of cells evaluated. n, m = len(s1), len(s2) dp = [[0] * (m + 1) for _ in range(n + 1)] cell_count = 0 # Fill dp table and count cells for i in range(1, n + 1): for j in range(1, m + 1): cell_count += 1 # Count the evaluated cell if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Reconstruct LCS from dp table lcs = [] while n > 0 and m > 0: if s1[n - 1] == s2[m - 1]: lcs.append(s1[n - 1]) n -= 1 m -= 1 elif dp[n - 1][m] >= dp[n][m - 1]: n -= 1 else: m -= 1 return \'\'.join(reversed(lcs)), cell_count"},{"question":"# Binary Search Tree Balancing Challenge Scenario You are tasked with developing a binary search tree (BST) that maintains balance to ensure efficient performance. A balanced BST is one where the height difference between the left and right subtrees of any node is minimized, typically guaranteeing O(log n) time complexity for insertions, deletions, and searches. Task Implement a class named `BalancedBST` with the following requirements: Class: `BalancedBST` 1. **Attributes**: * `root` (TreeNode): The root node of the BST initialized to `None`. 2. **Methods**: * `__init__(self)`: Constructor to initialize the BST. * `insert(self, key)`: Inserts a key into the BST and ensures the tree remains balanced using AVL rotations. * `delete(self, key)`: Deletes a key from the BST and ensures the tree remains balanced using AVL rotations. * `search(self, key)`: Searches for and returns the node containing the given key in the BST. * `inorder_traversal(self, node)`: Performs an in-order traversal starting from the given node and returns a list of keys. * `balance_factor(self, node)`: Computes and returns the balance factor of the given node. * `height(self, node)`: Computes and returns the height of the given node. * `rotate_left(self, z)`: Performs a left rotation around the given node `z` and returns the new subtree root. * `rotate_right(self, z)`: Performs a right rotation around the given node `z` and returns the new subtree root. Constraints and Limitations * The BST should be balanced using AVL rotations (single or double). * Ensure that insertion and deletion operations maintain the balanced property of the BST. * Support basic integer keys. Input and Output Formats * Use the following methods for interaction with the BST: ```python class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class BalancedBST: def __init__(self): # Initialize an empty BST def insert(self, key): # Insert key into the BST and balance def delete(self, key): # Delete key from the BST and balance def search(self, key): # Search and return node with the given key def inorder_traversal(self, node): # Perform in-order traversal and return list of keys def balance_factor(self, node): # Compute and return balance factor of the node def height(self, node): # Compute and return height of the node def rotate_left(self, z): # Perform left rotation around node z def rotate_right(self, z): # Perform right rotation around node z ``` Example ```python # Create a balanced binary search tree bst = BalancedBST() # Insert keys bst.insert(10) bst.insert(20) bst.insert(30) bst.insert(40) bst.insert(50) bst.insert(25) # Perform in-order traversal print(bst.inorder_traversal(bst.root)) # Output should be a sorted list [10, 20, 25, 30, 40, 50] # Search for a key node = bst.search(25) print(node.key) # Output: 25 # Delete a key bst.delete(40) print(bst.inorder_traversal(bst.root)) # Output should be a sorted list without 40 [10, 20, 25, 30, 50] ``` Ensure your implementation correctly maintains the balance of the binary search tree through AVL rotations during insertions and deletions.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class BalancedBST: def __init__(self): self.root = None def height(self, node): if not node: return 0 return node.height def balance_factor(self, node): if not node: return 0 return self.height(node.left) - self.height(node.right) def rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.height(z.left), self.height(z.right)) y.height = 1 + max(self.height(y.left), self.height(y.right)) return y def rotate_right(self, z): y = z.left T2 = y.right y.right = z z.left = T2 z.height = 1 + max(self.height(z.left), self.height(z.right)) y.height = 1 + max(self.height(y.left), self.height(y.right)) return y def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self.height(node.left), self.height(node.right)) balance = self.balance_factor(node) if balance > 1 and key < node.left.key: return self.rotate_right(node) if balance < -1 and key > node.right.key: return self.rotate_left(node) if balance > 1 and key > node.left.key: node.left = self.rotate_left(node.left) return self.rotate_right(node) if balance < -1 and key < node.right.key: node.right = self.rotate_right(node.right) return self.rotate_left(node) return node def search(self, key): return self._search(self.root, key) def _search(self, node, key): if node is None or node.key == key: return node if key < node.key: return self._search(node.left, key) return self._search(node.right, key) def inorder_traversal(self, node): result = [] self._inorder_traversal(node, result) return result def _inorder_traversal(self, node, result): if node: self._inorder_traversal(node.left, result) result.append(node.key) self._inorder_traversal(node.right, result) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._get_min_value_node(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) if not node: return node node.height = 1 + max(self.height(node.left), self.height(node.right)) balance = self.balance_factor(node) if balance > 1 and self.balance_factor(node.left) >= 0: return self.rotate_right(node) if balance > 1 and self.balance_factor(node.left) < 0: node.left = self.rotate_left(node.left) return self.rotate_right(node) if balance < -1 and self.balance_factor(node.right) <= 0: return self.rotate_left(node) if balance < -1 and self.balance_factor(node.right) > 0: node.right = self.rotate_right(node.right) return self.rotate_left(node) return node def _get_min_value_node(self, node): if node is None or node.left is None: return node return self._get_min_value_node(node.left)"},{"question":"# Coding Question: Implement a Calculator for Combinatorial Sum Context Combinatorial mathematics involves the study of countable, discrete structures. One prominent problem is calculating the sum of binomial coefficients, which finds application in various domains such as probability theory, algebra, and computer science. This task evaluates your ability to implement efficient combinatorial algorithms. Problem Statement You need to write a function **combinatorial_sum(n: int, k: int) -> int** that calculates the sum of binomial coefficients from C(n, 0) to C(n, k) efficiently. Input/Output Formats - **Function: `combinatorial_sum(n: int, k: int) -> int`** - **Input**: Two integers `n` and `k`. - **Output**: An integer representing the sum of binomial coefficients from C(n, 0) to C(n, k). - **Constraints**: `0 ≤ k ≤ n ≤ 1000` Detailed Requirements - Mathematics: - The binomial coefficient C(n, k) is given by the formula: C(n, k) = n! / (k! * (n - k)!) - The sum of binomial coefficients from C(n, 0) to C(n, k) can be computed efficiently using properties of binomial theorems instead of calculating each term individually. - **Edge Cases**: - Handle cases where k or n are zero. - Ensure to compute the sum efficiently to avoid factorial overflow errors. - **Performance**: - The function should be optimized for runtime efficiency, keeping the constraints in mind. Example ```python >>> combinatorial_sum(5, 2) 16 # Explanation: 1 + 5 + 10 (=> C(5,0) + C(5,1) + C(5,2)) >>> combinatorial_sum(6, 3) 42 # Explanation: 1 + 6 + 15 + 20 (=> C(6,0) + C(6,1) + C(6,2) + C(6,3)) >>> combinatorial_sum(10, 0) 1 # Explanation: 1 (=> C(10,0)) >>> combinatorial_sum(7, 7) 128 # Explanation: Sum of all C(7, k) for k = 0 to 7 ``` Performance Goal - Ensure the function runs efficiently even for larger values of `n`, utilizing properties of combinatorics and avoiding direct computation of factorials where possible.","solution":"def combinatorial_sum(n, k): Calculate the sum of binomial coefficients from C(n, 0) to C(n, k). Args: n (int): The upper index of the binomial coefficient. k (int): The lower limit up to which we calculate the sum of binomial coefficients. Returns: int: The sum of binomial coefficients from C(n, 0) to C(n, k). # Using mathematical property: Sum of binomial coefficients from C(n, 0) to C(n, k) can be computed using Pascal\'s Identity. # P(n, k) = P(n-1, k-1) + P(n-1, k) # Pascal\'s triangle is used here for building the binomial coefficients row C = [0] * (k + 1) C[0] = 1 # C(n, 0) is always 1 for any n for i in range(1, n + 1): for j in range(min(i, k), 0, -1): C[j] = C[j] + C[j - 1] if i <= k: C[i] = 1 return sum(C)"},{"question":"# Programming Assessment: Task Scheduler You are tasked with designing a `TaskScheduler` class to help manage and schedule tasks efficiently. This class should support adding tasks, removing tasks, and executing tasks based on their scheduled time. Scenario Your company wants to create a task scheduling system that can handle various tasks and execute them at their specified times. The task scheduler needs to prioritize tasks efficiently and handle execution without blocking the main thread. # Task Details: 1. **Class and Method Implementation**: - **Method 1**: Implement an `add_task` method to add a new task to the scheduler. - **Method 2**: Implement a `remove_task` method to remove a task from the scheduler by its ID. - **Method 3**: Implement an `execute_tasks` method that checks for due tasks and executes them. 2. **Expected Input and Output**: - **add_task**: - Input: `task_id` (str), `run_time` (datetime), `function_to_run` (Callable), `args` (Tuple) - Output: Success message. - **remove_task**: - Input: `task_id` (str) - Output: Success or failure message. - **execute_tasks**: - No input parameters. - Output: Executes all due tasks and prints their status. 3. **Constraints and Limitations**: - Ensure tasks are executed on time. - Allow tasks to be scheduled at future points in time. - Handle race conditions and potential concurrency issues gracefully. 4. **Performance Requirements**: - Efficiently manage and execute tasks with minimal delay. - Use multithreading or asynchronous programming to handle task execution without blocking. # Method Signatures: ```python from typing import Callable, Tuple from datetime import datetime import threading class TaskScheduler: ... def add_task(self, task_id: str, run_time: datetime, function_to_run: Callable, args: Tuple) -> str: pass def remove_task(self, task_id: str) -> str: pass def execute_tasks(self) -> None: pass ... ``` # Notes: - Use Python’s `threading` or `asyncio` library to handle task execution. - Store tasks in a way that is easy to check for due tasks (consider using a priority queue). - Ensure that the class and methods are thoroughly tested. # Example: ```python # Example usage of the add_task method scheduler = TaskScheduler() current_time = datetime.now() scheduler.add_task(\\"task1\\", current_time + timedelta(seconds=30), print, (\\"Task 1 executed\\",)) # Example usage of the remove_task method scheduler.remove_task(\\"task1\\") # Example execution of the execute_tasks method scheduler.execute_tasks() ``` Complete the methods and ensure they work as described.","solution":"from datetime import datetime, timedelta from typing import Callable, Tuple import threading import time import heapq class TaskScheduler: def __init__(self): self.tasks = [] self.task_lock = threading.Lock() self.task_map = {} def add_task(self, task_id: str, run_time: datetime, function_to_run: Callable, args: Tuple) -> str: with self.task_lock: if task_id in self.task_map: return f\\"Task with ID {task_id} already exists.\\" task = (run_time, task_id, function_to_run, args) heapq.heappush(self.tasks, task) self.task_map[task_id] = task return f\\"Task {task_id} added successfully.\\" def remove_task(self, task_id: str) -> str: with self.task_lock: if task_id not in self.task_map: return f\\"Task with ID {task_id} does not exist.\\" # Remove task from the heap (inefficient but acceptable for this use case) self.tasks = [task for task in self.tasks if task[1] != task_id] heapq.heapify(self.tasks) del self.task_map[task_id] return f\\"Task {task_id} removed successfully.\\" def execute_tasks(self) -> None: now = datetime.now() tasks_to_run = [] with self.task_lock: while self.tasks and self.tasks[0][0] <= now: run_time, task_id, function_to_run, args = heapq.heappop(self.tasks) if task_id in self.task_map: tasks_to_run.append((function_to_run, args)) del self.task_map[task_id] def run_task(function_to_run: Callable, args: Tuple): threading.Thread(target=function_to_run, args=args).start() for function_to_run, args in tasks_to_run: run_task(function_to_run, args) def _execute_thread(self): while True: self.execute_tasks() time.sleep(1) # Check every second def start(self): threading.Thread(target=self._execute_thread, daemon=True).start() scheduler = TaskScheduler() scheduler.start()"},{"question":"# Coding Assessment Question You have been provided with a Python script that processes a large CSV file containing sales data. The script currently reads the entire file into memory, which is inefficient for very large files. Your objective is to refactor the script to handle large files efficiently, incorporating streaming and other enhancements. Requirements: 1. **Efficiency Enhancements**: * Modify the script to process the CSV file in a memory-efficient manner using streaming. * Implement batching to control the number of rows processed at a time (e.g., in batches of 1000 rows). 2. **Error Handling Enhancements**: * Implement robust error handling to manage corrupted rows gracefully. * Add logging for any rows that cannot be processed due to errors, along with the reason for failure. 3. **Configurable Enhancements**: * Allow users to specify the batch size for processing rows. * Add an option to skip or stop processing upon encountering a critical error. # Expected Input and Output: * **Input**: - `file_path` (str) - Path to the CSV file. - `batch_size` (int) - Number of rows to process in each batch. - `stop_on_error` (bool) - Whether to stop processing when a critical error occurs. * **Output**: Returns an integer indicating the number of successfully processed rows or an appropriate error message if processing fails. # Constraints: * The CSV file can have up to 1 million rows. * Handle CSV files with various delimiters (comma, semicolon, tab). * Ensure minimal memory usage by avoiding loading the entire file into memory. * Handle scenarios where the file structure is slightly inconsistent (e.g., missing fields) without stopping the entire process. # Function Signature: ```python def process_large_csv_file( file_path: str, batch_size: int = 1000, stop_on_error: bool = False ) -> int: # Your implementation here ``` # Example Usage: ```python rows_processed = process_large_csv_file( file_path=\\"sales_data.csv\\", batch_size=500, stop_on_error=True ) print(f\\"{rows_processed} rows were successfully processed.\\") ``` Your task is to implement the `process_large_csv_file` function according to the requirements and constraints specified above. Be sure to include appropriate comments and documentation for clarity.","solution":"import csv import logging def process_large_csv_file(file_path: str, batch_size: int = 1000, stop_on_error: bool = False) -> int: Processes a large CSV file in a memory-efficient way using streaming and batching. Args: file_path (str): Path to the CSV file. batch_size (int): Number of rows to process in each batch. stop_on_error (bool): Whether to stop processing on encountering a critical error. Returns: int: The number of successfully processed rows. rows_processed = 0 failed_rows = 0 logging.basicConfig(filename=\'csv_processor.log\', level=logging.ERROR, format=\'%(asctime)s - %(levelname)s - %(message)s\') try: with open(file_path, mode=\'r\') as file: reader = csv.reader(file) headers = next(reader, None) # Get headers if present batch = [] for row in reader: if len(row) != len(headers): logging.error(f\\"Corrupted row (wrong number of fields): {row}\\") failed_rows += 1 if stop_on_error: raise ValueError(f\\"Encountered corrupted row: {row}\\") continue batch.append(row) if len(batch) >= batch_size: process_batch(batch) rows_processed += len(batch) batch = [] if batch: process_batch(batch) rows_processed += len(batch) except Exception as e: logging.error(f\\"Critical error encountered: {e}\\") if stop_on_error: raise print(f\\"Processed rows: {rows_processed}, Failed rows: {failed_rows}\\") return rows_processed def process_batch(batch): Simulate processing of a batch of rows. # Here would be any processing logic needed for each batch of rows. pass"},{"question":"# Scenario A shipping company uses a custom binary file format to store daily shipping records. Each record contains the following data types in sequence: an integer representing the package ID, a short integer for the weight of the package in grams, a float for the shipping cost, and 50 characters for the destination address. They want you to write functions to read these records from the binary file and summarize the shipping information. # Task 1. **Function Requirement: `read_shipping_records`** - **Purpose**: Create a function to read and return the list of shipping records from a binary file. - **Input**: - `file_path: str`: The file path of the binary file containing the shipping records. - **Output**: - Returns a list of dictionaries, where each dictionary contains the data of a single shipping record with keys: `\'package_id\'`, `\'weight\'`, `\'cost\'`, and `\'destination\'`. 2. **Function Requirement: `summarize_shipping`** - **Purpose**: Create a function to summarize the total weight and cost from a list of shipping records. - **Input**: - `records: List[Dict]`: A list of dictionaries containing shipping records. - **Output**: - Returns a dictionary with keys `\'total_weight\'` and `\'total_cost\'` containing the aggregated weight in kilograms and total cost respectively. # Constraints - Ensure error handling for file reading issues and invalid file formats. - Properly manage binary file reading and decoding of values. - Must handle edge cases like empty records, invalid file paths, etc. - The functions should raise custom exceptions with meaningful messages for critical errors. # Example ```python # Example Usage file_path = \\"shipping_records.bin\\" # 1. Read shipping records from binary file records = read_shipping_records(file_path) print(records) # Expected output: List of dictionaries with shipping records # 2. Summarize total weight and cost from records summary = summarize_shipping(records) print(summary) # Expected output: {\'total_weight\': X.XX, \'total_cost\': Y.YY} ```","solution":"import struct from typing import List, Dict class ShippingRecordError(Exception): pass def read_shipping_records(file_path: str) -> List[Dict]: records = [] record_format = \'i h f 50s\' record_size = struct.calcsize(record_format) try: with open(file_path, \'rb\') as f: while True: record_data = f.read(record_size) if not record_data: break if len(record_data) != record_size: raise ShippingRecordError(\\"Incomplete record found\\") package_id, weight, cost, destination = struct.unpack(record_format, record_data) destination = destination.decode(\'utf-8\').strip(\'x00\') records.append({ \'package_id\': package_id, \'weight\': weight, \'cost\': cost, \'destination\': destination }) except (FileNotFoundError, IOError) as e: raise ShippingRecordError(f\\"Error reading file: {str(e)}\\") return records def summarize_shipping(records: List[Dict]) -> Dict: total_weight_grams = sum(record[\'weight\'] for record in records) total_cost = sum(record[\'cost\'] for record in records) summary = { \'total_weight\': total_weight_grams / 1000, # converting grams to kilograms \'total_cost\': total_cost } return summary"},{"question":"Bank Transaction Reconciliation You are working on a system that reconciles bank transactions by matching them with account statements. Write a function to match the transactions based on their dates and amounts while handling possible variations. Requirements: 1. **Function Definition**: ```python def reconcile_transactions(bank_transactions: list, account_statements: list) -> bool: ``` 2. **Input**: * `bank_transactions` (list): List of dictionaries, each containing `date` (string in the format \\"YYYY-MM-DD\\") and `amount` (float). Example: `{\\"date\\": \\"2023-09-25\\", \\"amount\\": -120.50}` * `account_statements` (list): List of dictionaries, each containing `date` (string in the format \\"YYYY-MM-DD\\") and `amount` (float). Example: `{\\"date\\": \\"2023-09-25\\", \\"amount\\": -120.50}` 3. **Output**: * Return `True` if all bank transactions can be reconciled with the account statements, otherwise `False`. 4. **Constraints**: * Transactions are considered reconciled if they have the same date and amount (including time for deposits and withdrawals). * Handle cases where discrepancies might occur due to minor variations (e.g., bank rounding). * The function must efficiently handle up to 100 transactions in each list. 5. **Performance Requirements**: * The function should run efficiently with a computational complexity of O(N log N) or better, where N is the length of the longer list. Example: ```python bank_transactions = [ {\\"date\\": \\"2023-09-25\\", \\"amount\\": -120.50}, {\\"date\\": \\"2023-09-26\\", \\"amount\\": 150.00}, {\\"date\\": \\"2023-09-27\\", \\"amount\\": -75.25} ] account_statements = [ {\\"date\\": \\"2023-09-25\\", \\"amount\\": -120.50}, {\\"date\\": \\"2023-09-27\\", \\"amount\\": -75.25}, {\\"date\\": \\"2023-09-26\\", \\"amount\\": 150.00} ] result = reconcile_transactions(bank_transactions, account_statements) # The \'result\' would be: # True ``` Implementation Tips: * Use a matching algorithm that efficiently pairs transactions based on date and amount. * Consider using sorting and binary search to optimize performance. * Implement robust handling of minor discrepancies.","solution":"from typing import List, Dict def reconcile_transactions(bank_transactions: List[Dict[str, float]], account_statements: List[Dict[str, float]]) -> bool: Returns True if all bank transactions can be reconciled with account statements based on date and amount, otherwise False. # Sort transactions by date and then by amount bank_transactions = sorted(bank_transactions, key=lambda x: (x[\'date\'], x[\'amount\'])) account_statements = sorted(account_statements, key=lambda x: (x[\'date\'], x[\'amount\'])) # Compare the sorted lists return bank_transactions == account_statements"},{"question":"# Longest Common Subsequence Monitoring You are tasked with implementing a function that computes the length of the Longest Common Subsequence (LCS) between two strings. Additionally, the function should produce the LCS itself. Function Signature: ```python def lcs_with_traceback(str1: str, str2: str) -> Tuple[int, str]: ``` Input: - `str1` (str): First input string. - `str2` (str): Second input string. Output: - A tuple containing: 1. The length of the LCS (int). 2. The LCS (str). Constraints: - Both `str1` and `str2` can be empty such that 0 <= len(str1), len(str2) <= 1000. - Only valid ASCII characters will be used. Examples: ```python >>> lcs_with_traceback(\\"abcde\\", \\"ace\\") (3, \'ace\') >>> lcs_with_traceback(\\"abc\\", \\"abc\\") (3, \'abc\') >>> lcs_with_traceback(\\"abc\\", \\"def\\") (0, \'\') >>> lcs_with_traceback(\\"\\", \\"abc\\") (0, \'\') ``` Description: 1. Implement the `lcs_with_traceback` function to first compute the length of the LCS using dynamic programming. 2. Extend your implementation to backtrack and reconstruct the LCS from the dynamic programming table. 3. Ensure efficiency by handling edge cases and large inputs appropriately. # Additional Instructions: - Focus on constructing the dynamic programming table for the LCS length calculation. - Use an auxiliary table to track the choices made during the dynamic programming solution so you can reconstruct the LCS at the end. - Aim for a solution with a time complexity of O(m*n), where m and n are the lengths of the input strings.","solution":"from typing import Tuple def lcs_with_traceback(str1: str, str2: str) -> Tuple[int, str]: m, n = len(str1), len(str2) # DP table to store lengths of longest common subsequence dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp table for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = 1 + dp[i - 1][j - 1] else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Reconstructing LCS from the dp table by backtracking lcs_length = dp[m][n] lcs_str = [] i, j = m, n while i > 0 and j > 0: if str1[i - 1] == str2[j - 1]: lcs_str.append(str1[i - 1]) i -= 1 j -= 1 elif dp[i - 1][j] > dp[i][j - 1]: i -= 1 else: j -= 1 lcs_str.reverse() # reverse to get correct order return (lcs_length, \'\'.join(lcs_str))"},{"question":"# Reversing Segments Without Multiplies/Divides You are tasked with creating a function that reverses segments of a given list without using multiplication or division operations. Given a list and a group size, your function should reverse elements in groups of the specified size. If the last group is smaller than the specified size, reverse that segment as well. Requirements - **Function Name**: `reverse_segments` - **Input**: A list `array: list` and an integer `k: int`. - **Output**: The modified list with every k segments reversed in place. Constraints 1. The input list can contain any mix of data types. 2. The length of `array` will be `0 <= len(array) <= 10^4`. 3. The integer `k` will be `1 <= k <= len(array)`. 4. You may not use multiplication or division operations. Expected Performance - The implementation should reverse the elements in place. - The function should handle the edge cases efficiently, e.g., when `k` is 1 (no change). # Example ```python reverse_segments([1, 2, 3, 4, 5, 6], 2) # Output: [2, 1, 4, 3, 6, 5] reverse_segments([1, 2, 3, 4, 5, 6, 7], 3) # Output: [3, 2, 1, 6, 5, 4, 7] reverse_segments([\'a\', \'b\', \'c\', \'d\', \'e\'], 2) # Output: [\'b\', \'a\', \'d\', \'c\', \'e\'] reverse_segments([], 3) # Output: [] reverse_segments([10], 1) # Output: [10] ``` # Implementation Details - Ensure that your function can handle empty lists gracefully. - Direct manipulation of the list elements is required without auxiliary arrays. - Implement the logic to swap elements in place based on the specified segment size `k`. Note Do not use Python\'s slicing tricks or libraries directly. Implement the reversal logic from scratch according to the detailed principles.","solution":"def reverse_segments(array, k): Reverses segments of the given list in place. Parameters: array (list): The list of elements to be reversed in segments. k (int): The size of the segments to be reversed. Returns: list: The list with reversed segments. n = len(array) for start in range(0, n, k): end = min(start + k - 1, n - 1) while start < end: array[start], array[end] = array[end], array[start] start += 1 end -= 1 return array"},{"question":"# Word Pattern Matching Problem Description Given a pattern and a string s, find if s follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s. Function Signature ```python def word_pattern(pattern: str, s: str) -> bool: Returns True if s follows the given pattern; otherwise, False. Args: pattern (str): A string representing the pattern to follow. s (str): A string of words. Returns: bool: True if s follows the pattern, False otherwise. pass ``` Requirements - **Input**: - `pattern`: a string representing the pattern consisting of lowercase letters. - `s`: a string consisting of lowercase words separated by a single space. - **Output**: - Return `True` if `s` follows the given pattern; otherwise, `False`. Constraints - The length of `pattern` is between 1 and 3000. - The length of `s` is between 1 and 3000. - Words in `s` are separated by a single space. Example ```python >>> word_pattern(\\"abba\\", \\"dog cat cat dog\\") True >>> word_pattern(\\"abba\\", \\"dog cat cat fish\\") False >>> word_pattern(\\"aaaa\\", \\"dog dog dog dog\\") True >>> word_pattern(\\"abba\\", \\"dog dog dog dog\\") False ``` Discussion - Ensure that no two different letters in the pattern map to the same word. - Likewise, no two different words in the string can map to the same letter in the pattern. - Consider edge cases such as empty pattern or empty string, though given constraints already limit these scenarios. Isolate and test the function with different patterns and corresponding strings to validate correctness and efficiency.","solution":"def word_pattern(pattern: str, s: str) -> bool: words = s.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for p, w in zip(pattern, words): if p in char_to_word: if char_to_word[p] != w: return False else: char_to_word[p] = w if w in word_to_char: if word_to_char[w] != p: return False else: word_to_char[w] = p return True"},{"question":"# Coding Assessment Question Scenario You are working for a software company that manipulates large sets of data. One of the common tasks is to find the largest difference between any two elements in a dataset. While this can be achieved with a straightforward nested iteration method, the large size of the datasets necessitates a more efficient approach. Your task is to implement a solution that efficiently finds this maximum difference in linear time. Task Write a function `max_difference` that takes a list of integers and returns the maximum absolute difference between any two elements in the list. # Function Signature ```python def max_difference(numbers: list[int]) -> int: pass ``` # Input * `numbers`: A list of integers, `numbers` (0 ≤ len(numbers) ≤ 10^5). # Output * An integer representing the maximum absolute difference between any two elements in the list. # Constraints * The function should have a time complexity of O(n). * Handle edge cases gracefully, such as when the list is empty. # Example ```python assert max_difference([3, 6, 2, 7, 5]) == 5 # The largest difference is between 7 and 2 assert max_difference([]) == 0 # No elements, so the difference is 0 assert max_difference([10]) == 0 # Only one element, so the difference is 0 assert max_difference([1, 9, 2, 5, 6]) == 8 # The largest difference is between 1 and 9 ``` # Notes * Your implementation should correctly handle edge cases such as empty arrays and arrays with repeated elements. * Pay attention to the requirement of linear time complexity. * Write clean, readable code with appropriate comments.","solution":"def max_difference(numbers: list[int]) -> int: Returns the maximum absolute difference between any two elements in the list. :param numbers: List of integers :return: Maximum absolute difference if len(numbers) < 2: return 0 min_val = float(\'inf\') max_val = float(\'-inf\') for num in numbers: if num < min_val: min_val = num if num > max_val: max_val = num return max_val - min_val"},{"question":"# Coding Challenge: Manipulate and Query a Nested Dictionary Problem Statement You are given a nested dictionary that represents the organizational structure of a company. Each key represents a department, and its value is another dictionary that contains sub-departments or employees. The goal is to implement functionality that allows querying and manipulating this nested structure. Write a class `CompanyStructure` containing functions to: 1. Add a new department or employee. 2. Remove a department or employee. 3. Retrieve all employees from a specified department, including all its sub-departments. Class Signature ```python class CompanyStructure: def __init__(self, structure: dict): pass def add(self, path: list, name: str): pass def remove(self, path: list): pass def get_all_employees(self, department: str) -> list: pass ``` Input Parameters * `structure` (dict): A nested dictionary representing the company structure. Each key is a department name, and its value is another dictionary or a list of employees. * `path` (list): A list representing the path to a department or employee, specified as strings. * `name` (str): The name of the new department or employee to add. Output * The `add` method should update the structure by adding the specified department or employee at the given path. * The `remove` method should update the structure by removing the specified department or employee at the given path. * The `get_all_employees` method should return a list of all employees in the specified department and its sub-departments. Constraints * The initial structure can be deeply nested, but the path will always be valid for the `add` and `remove` methods. * If removing a department, all sub-departments and employees under it should also be removed. * The `get_all_employees` method should collect all employees recursively from the specified department downwards. Example ```python structure = { \'HR\': { \'Recruitment\': [\'Alice\', \'Bob\'], \'Training\': [\'Charlie\'], }, \'Engineering\': { \'Development\': { \'Frontend\': [\'Dave\'], \'Backend\': [\'Eve\'], }, \'QA\': [\'Faythe\'] } } company = CompanyStructure(structure) company.add([\'Engineering\', \'DevOps\'], \'Grace\') # Adds \'Grace\' to \'DevOps\' under \'Engineering\' company.remove([\'HR\', \'Recruitment\', \'Alice\']) # Removes \'Alice\' from \'Recruitment\' under \'HR\' print(company.get_all_employees(\'HR\')) # Expected Output: [\'Bob\', \'Charlie\'] print(company.get_all_employees(\'Engineering\')) # Expected Output: [\'Dave\', \'Eve\', \'Faythe\', \'Grace\'] ``` Requirements * Implement the `add`, `remove`, and `get_all_employees` methods in the `CompanyStructure` class. * Ensure that your data structure manipulation is efficient and handles deep nesting effectively. * Include proper exception handling where necessary.","solution":"class CompanyStructure: def __init__(self, structure: dict): self.structure = structure def add(self, path: list, name: str): current = self.structure for department in path: if department not in current: current[department] = {} current = current[department] if isinstance(current, list): current.append(name) else: current[name] = {} def remove(self, path: list): current = self.structure *path_to_parent, last_entry = path for department in path_to_parent: current = current[department] if isinstance(current, list): current.remove(last_entry) else: del current[last_entry] def get_all_employees(self, department: str) -> list: employees = [] def collect_employees(d): if isinstance(d, list): employees.extend(d) elif isinstance(d, dict): for sub_department in d.values(): collect_employees(sub_department) collect_employees(self.structure.get(department, {})) return employees"},{"question":"# Question You are required to implement a function that interacts with the Twitter API to fetch the latest tweets from the authenticated user\'s timeline. This function should securely handle the authentication token and properly process the response to return a list of dictionary objects encapsulating tweet details. Function Signature ```python def fetch_latest_tweets(auth_token: str, count: int) -> list[dict[str, Any]]: ``` Input * `auth_token` (str): A valid Twitter Bearer token passed as a string. * `count` (int): The number of latest tweets to fetch (maximum value is 50). Output * Returns a list of dictionaries, where each dictionary contains details about a tweet such as: * `id` (str): Tweet ID * `text` (str): The text content of the tweet * `created_at` (str): Timestamp of when the tweet was created * `user` (dict): Dictionary with details about the user who posted the tweet, containing: * `id` (str): User ID * `name` (str): User\'s name * `screen_name` (str): User\'s Twitter handle Constraints * You must not hardcode the token within your Python file. * The request to the Twitter API should be authenticated using the Bearer token. * Handle potential exceptions gracefully and ensure the function returns an empty list in case of any errors. * Ensure the `count` parameter does not exceed 50. Example ```python import os def fetch_latest_tweets(auth_token: str, count: int) -> list[dict[str, Any]]: # Your implementation here pass if __name__ == \\"__main__\\": auth_token = os.environ.get(\\"TWITTER_BEARER_TOKEN\\", \\"\\") tweets = fetch_latest_tweets(auth_token, 5) for tweet in tweets: print(tweet) ``` Ensure you: 1. Verify the presence of the authentication token. 2. Make an authenticated request to the API URL `https://api.twitter.com/2/tweets`. 3. Parse the JSON response. 4. Handle any errors and return an empty list in case of failures. Notes: * Use the `requests` library for handling HTTP requests. * The response from the API will be in JSON format. * Aim to write clean, maintainable, and well-documented code.","solution":"import requests from typing import List, Dict, Any def fetch_latest_tweets(auth_token: str, count: int) -> List[Dict[str, Any]]: Fetches the latest tweets from the authenticated user\'s timeline. Arguments: - auth_token: str - A valid Twitter Bearer token as a string. - count: int - The number of latest tweets to fetch (maximum value is 50). Returns: - A list of dictionaries, where each dictionary contains details about a tweet. if not auth_token: return [] if count > 50: count = 50 url = \\"https://api.twitter.com/2/tweets\\" headers = { \\"Authorization\\": f\\"Bearer {auth_token}\\", } params = { \\"count\\": count } try: response = requests.get(url, headers=headers, params=params) response.raise_for_status() tweets = response.json() result = [] for tweet in tweets.get(\'data\', []): tweet_info = { \'id\': tweet[\'id\'], \'text\': tweet[\'text\'], \'created_at\': tweet[\'created_at\'], \'user\': { \'id\': tweet[\'user\'][\'id\'], \'name\': tweet[\'user\'][\'name\'], \'screen_name\': tweet[\'user\'][\'screen_name\'] } } result.append(tweet_info) return result except Exception: return []"},{"question":"# Sorting Employee Data by Salary Scenario: You are tasked with building an application feature that sorts a list of employee data by their salary in ascending or descending order. The employee data includes their name, ID, and salary. Task: Write a Python function `sort_employees(employees: List[Dict[str, Any]], order: str) -> List[Dict[str, Any]]` that sorts a list of employee dictionaries by their salary. Requirements: 1. The input list `employees` contains dictionaries, each with the keys \\"name\\", \\"id\\", and \\"salary\\". 2. The `order` parameter is a string that can either be \\"asc\\" for ascending order or \\"desc\\" for descending order. 3. Return the sorted list based on the salary in the specified order. 4. Ensure the function handles potential edge cases, such as non-numeric salaries or duplicate entries. # Function Signature ```python def sort_employees(employees: List[Dict[str, Any]], order: str) -> List[Dict[str, Any]]: pass ``` Input * `employees`: A list of dictionaries, where each dictionary contains: - `name`: A string representing the employee\'s name (e.g., \\"John Doe\\"). - `id`: An integer representing the employee\'s ID (e.g., 101). - `salary`: A numeric value representing the employee\'s salary (e.g., 55000). * `order`: A string indicating the order of sorting: - \\"asc\\": sort in ascending order. - \\"desc\\": sort in descending order. Constraints * Assume all salary values are numeric. * There should not be more than 10,000 employees in the list. Output * A list of dictionaries sorted by the `salary` key in the specified order. Example ```python employees = [ {\\"name\\": \\"Alice\\", \\"id\\": 2, \\"salary\\": 70000}, {\\"name\\": \\"Bob\\", \\"id\\": 1, \\"salary\\": 50000}, {\\"name\\": \\"Charlie\\", \\"id\\": 3, \\"salary\\": 60000} ] order = \\"asc\\" # Expected output: # [ # {\\"name\\": \\"Bob\\", \\"id\\": 1, \\"salary\\": 50000}, # {\\"name\\": \\"Charlie\\", \\"id\\": 3, \\"salary\\": 60000}, # {\\"name\\": \\"Alice\\", \\"id\\": 2, \\"salary\\": 70000} # ] sorted_employees = sort_employees(employees, order) ``` Notes * Utilize Python\'s built-in sorting functionalities for the implementation. * Handle invalid input gracefully, such as an invalid `order` string. * The solution should execute efficiently and handle edge cases properly.","solution":"from typing import List, Dict, Any def sort_employees(employees: List[Dict[str, Any]], order: str) -> List[Dict[str, Any]]: Sorts a list of employees by their salary in the specified order. Args: employees (List[Dict[str, Any]]): A list of dictionaries, each containing employee data. order (str): The order to sort by (\\"asc\\" for ascending, \\"desc\\" for descending). Returns: List[Dict[str, Any]]: The sorted list of employees. if order not in [\\"asc\\", \\"desc\\"]: raise ValueError(\\"Invalid order: must be \'asc\' or \'desc\'\\") return sorted(employees, key=lambda x: x[\\"salary\\"], reverse=(order == \\"desc\\"))"},{"question":"# Odd Sum Sequence Write a function that receives a positive integer n and returns the sum of the first n odd numbers. The function should be efficient and handle edge cases properly. Function Signature ```python def sum_of_odds(n: int) -> int: Calculates the sum of the first n odd numbers. Args: n (int): The number of first odd numbers to sum. Returns: int: The sum of the first n odd numbers. Raises: ValueError: If `n` is not a positive integer. pass ``` # Example ```python assert sum_of_odds(1) == 1 assert sum_of_odds(2) == 4 assert sum_of_odds(3) == 9 assert sum_of_odds(10) == 100 try: sum_of_odds(0) # n should be positive except ValueError as ve: assert str(ve) == \\"Input must be a positive integer\\" except Exception as e: assert False, f\\"Unexpected exception {e}\\" try: sum_of_odds(-5) # n should not be negative except ValueError as ve: assert str(ve) == \\"Input must be a positive integer\\" except Exception as e: assert False, f\\"Unexpected exception {e}\\" ``` # Constraints 1. `n` must be a positive integer. 2. If `n` is zero or negative, raise a `ValueError` with the message \\"Input must be a positive integer\\". # Performance Requirements The solution should be optimized to handle large values of `n`, up to 10,000 efficiently.","solution":"def sum_of_odds(n: int) -> int: Calculates the sum of the first n odd numbers. Args: n (int): The number of first odd numbers to sum. Returns: int: The sum of the first n odd numbers. Raises: ValueError: If `n` is not a positive integer. if n <= 0: raise ValueError(\\"Input must be a positive integer\\") # Using the formula for the sum of the first n odd numbers: n^2 return n * n"},{"question":"# Merge Unique Sorted Lists You are required to demonstrate your understanding of merging sorted lists by implementing a function that takes two sorted lists of integers and returns a single sorted list containing the unique elements from both lists. The core of this task is understanding how to efficiently merge two sorted lists and eliminate duplicates. You will analyze the provided requirements and then implement a solution following the guidelines. Function Signature ```python def merge_unique_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: pass ``` Requirements 1. The function should accept two sorted lists of integers and return a single sorted list containing unique elements from both. 2. Assume both input lists are already sorted in ascending order. 3. The function must handle: - Two empty lists. - One empty and one non-empty list. - Lists with all identical elements. - Lists with all unique elements. - Lists with overlapping elements. 4. Demonstrate your implementation by writing test cases for each of these edge cases. 5. Use Python\'s built-in assertion mechanism to validate your outputs. Constraints * Do not use any built-in set functions to remove duplicates. * The function should operate with a time complexity of O(n + m), where n and m are the lengths of the input lists. * Ensure your solution runs efficiently on both small and large lists. Example Usage Here are some examples of expected input and output: ```python assert merge_unique_sorted_lists([1, 3, 5], [2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert merge_unique_sorted_lists([1, 2, 3], [1, 2, 3]) == [1, 2, 3] assert merge_unique_sorted_lists([1, 1, 1], [2, 2, 2]) == [1, 2] assert merge_unique_sorted_lists([], [5, 6, 7]) == [5, 6, 7] assert merge_unique_sorted_lists([-1, 0, 1], [-2, -1, 0]) == [-2, -1, 0, 1] assert merge_unique_sorted_lists([], []) == [] ``` Test your implementation rigorously to cover all edge cases. Explain in comments how each test case validates a specific aspect of the algorithm.","solution":"def merge_unique_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: Merges two sorted lists and returns a list of unique elements sorted. merged_list = [] i, j = 0, 0 # Using two-pointer technique to merge lists while i < len(list1) and j < len(list2): if list1[i] < list2[j]: if not merged_list or merged_list[-1] != list1[i]: merged_list.append(list1[i]) i += 1 elif list1[i] > list2[j]: if not merged_list or merged_list[-1] != list2[j]: merged_list.append(list2[j]) j += 1 else: if not merged_list or merged_list[-1] != list1[i]: merged_list.append(list1[i]) i += 1 j += 1 # Append remaining elements from list1 if any while i < len(list1): if not merged_list or merged_list[-1] != list1[i]: merged_list.append(list1[i]) i += 1 # Append remaining elements from list2 if any while j < len(list2): if not merged_list or merged_list[-1] != list2[j]: merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Scenario You are tasked with building a simple recommendation engine for a movie-streaming service. The service uses user ratings to recommend movies to other users who have not yet watched them. Your task is to implement a class that can gather and process movie ratings to produce recommendations. # Task Implement a class `MovieRecommender` in Python that can store movies, allow users to rate movies, and generate recommendations based on these ratings. The class should support the following operations: adding movies, adding ratings, and generating recommendations. # Requirements 1. **add_movie(movie_title)**: Add a new movie to the system. 2. **rate_movie(user, movie_title, rating)**: Allow a user to rate a specific movie (rating is an integer between 1 and 5). 3. **get_recommendations(user)**: Generate a list of movie recommendations for a user. The list should contain movies that the user has not rated yet, sorted by the average rating (highest first). # Constraints - Movies should only be added once. - Each user should only rate a movie once. - Recommendations should be efficient to compute. - If multiple movies have the same average rating, they should be sorted alphabetically. # Input and Output - **add_movie(movie_title)**: Single parameter `movie_title` (a string). - **rate_movie(user, movie_title, rating)**: Three parameters `user` (a string), `movie_title` (a string), and `rating` (an integer between 1 and 5). - **get_recommendations(user)**: Single parameter `user` (a string), returns a list of movie titles (strings). # Example ```python recommender = MovieRecommender() recommender.add_movie(\\"Inception\\") recommender.add_movie(\\"The Matrix\\") recommender.add_movie(\\"Interstellar\\") recommender.rate_movie(\\"Alice\\", \\"Inception\\", 5) recommender.rate_movie(\\"Bob\\", \\"The Matrix\\", 4) recommender.rate_movie(\\"Alice\\", \\"The Matrix\\", 3) recommender.rate_movie(\\"Charlie\\", \\"Interstellar\\", 4) print(recommender.get_recommendations(\\"Alice\\")) # Output: [\\"Interstellar\\"] print(recommender.get_recommendations(\\"Bob\\")) # Output: [\\"Inception\\", \\"Interstellar\\"] print(recommender.get_recommendations(\\"Charlie\\")) # Output: [\\"Inception\\", \\"The Matrix\\"] ``` # Implementation Challenge Implement the `MovieRecommender` class to appropriately handle the described rating system and generate accurate recommendations based on user ratings. The implementation should account for efficiency in terms of both time and space complexity.","solution":"class MovieRecommender: def __init__(self): self.movies = {} self.user_ratings = {} def add_movie(self, movie_title): if movie_title not in self.movies: self.movies[movie_title] = [] def rate_movie(self, user, movie_title, rating): if movie_title not in self.movies: raise ValueError(\\"Movie not found\\") if not (1 <= rating <= 5): raise ValueError(\\"Rating should be between 1 and 5\\") if user not in self.user_ratings: self.user_ratings[user] = {} if movie_title in self.user_ratings[user]: raise ValueError(\\"User has already rated this movie\\") self.user_ratings[user][movie_title] = rating self.movies[movie_title].append(rating) def get_recommendations(self, user): if user not in self.user_ratings: return sorted(self.movies.keys()) rated_movies = set(self.user_ratings[user].keys()) recommendations = [] for movie_title, ratings in self.movies.items(): if movie_title not in rated_movies: avg_rating = sum(ratings) / len(ratings) if ratings else 0 recommendations.append((avg_rating, movie_title)) return [movie for _, movie in sorted(recommendations, key=lambda x: (-x[0], x[1]))]"},{"question":"# Coding Question: Implement a Custom Memory Allocator **Context**: Custom memory allocators are critical for performance-sensitive applications where efficient memory management is required. They allow for optimized allocation and deallocation patterns based on the application\'s specific needs. **Challenge**: You need to develop a simple custom memory allocator class `CustomAllocator`. This allocator will manage a fixed-size block of memory, allowing for dynamic allocations and deallocations. The core functionality will involve handling requests to allocate and free memory blocks within a pre-allocated memory pool. **Function Signature**: ```python class CustomAllocator: def __init__(self, total_size: int) -> None: pass def allocate(self, size: int) -> int: pass def free(self, address: int) -> None: pass ``` **Detailed Requirements**: 1. **Initialization**: The constructor should accept a single parameter: - `total_size`: The size of the memory pool to manage. 2. **Allocate Method**: - The `allocate` method should take an integer `size` and allocate a block of memory of that size. - It should return the starting address of the allocated block. - If there is not enough available memory, it should raise an appropriate exception. 3. **Free Method**: - The `free` method should take an integer `address` which represents the starting address of a previously allocated block. - It should deallocate the memory block starting at the given address. - It should maintain a list of free blocks to reuse memory efficiently. **Constraints**: - The `total_size` will be a positive integer, specifying the number of bytes in the memory pool. - The `size` provided to `allocate` will be a positive integer less than or equal to `total_size`. - The `address` provided to `free` will always be a valid address returned by a previous `allocate` call. **Performance Requirements**: - Both the `allocate` and `free` methods should operate efficiently with regards to time complexity, ensuring reasonable performance for typical usage patterns. **Example**: ```python >>> allocator = CustomAllocator(100) >>> addr1 = allocator.allocate(10) >>> addr2 = allocator.allocate(20) >>> print(addr1, addr2) 0 10 >>> allocator.free(addr1) >>> addr3 = allocator.allocate(5) >>> print(addr3) 0 ```","solution":"class CustomAllocator: def __init__(self, total_size: int) -> None: self.total_size = total_size self.free_blocks = [(0, total_size)] # List of tuples (address, size), initially whole memory is free. def allocate(self, size: int) -> int: for i, (start, free_size) in enumerate(self.free_blocks): if free_size >= size: if free_size == size: self.free_blocks.pop(i) else: self.free_blocks[i] = (start + size, free_size - size) return start raise MemoryError(\\"Not enough memory available to allocate\\") def free(self, address: int) -> None: for i, (start, size) in enumerate(self.free_blocks): if start > address: self.free_blocks.insert(i, (address, size)) break else: self.free_blocks.append((address, size)) self._merge_free_blocks() def _merge_free_blocks(self): merged_blocks = [] for block in sorted(self.free_blocks): if not merged_blocks or merged_blocks[-1][0] + merged_blocks[-1][1] < block[0]: merged_blocks.append(block) else: merged_blocks[-1] = (merged_blocks[-1][0], merged_blocks[-1][1] + block[1]) self.free_blocks = merged_blocks"},{"question":"# Coding Assessment Question Question: Write a function that simulates a basic inventory system for a small store. The inventory system tracks the quantity of different items available in the store and supports operations to add, remove, and check stock levels of items. 1. **Input**: - A list of operations where each operation is represented as a tuple. The first element of the tuple is a string indicating the operation type: `\\"add\\"`, `\\"remove\\"`, or `\\"check\\"`. The second element is the item name (a string), and the third element (for add/remove) is an integer representing the quantity. For the `\\"check\\"` operation, the third element will be ignored. 2. **Output**: - For each `\\"check\\"` operation, output the current quantity of the specified item. 3. **Constraints**: - Item names are alphanumeric strings of length between 1 and 50. - Quantities are non-negative integers. - If a remove operation tries to decrease the quantity of an item below zero, set the quantity to zero instead. - Number of operations (input list length) does not exceed 10,000. 4. **Performance Requirements**: - Ensure the inventory operations are efficient and scalable for large number of operations. Implementation: Write a function `inventory_system` in Python that takes the above input and returns the results of the check operations. Function signature: ```python def inventory_system(operations: List[Tuple[str, str, int]]) -> List[int]: ``` Example: ```python # Input operations = [ (\\"add\\", \\"apple\\", 10), (\\"add\\", \\"banana\\", 5), (\\"remove\\", \\"apple\\", 3), (\\"check\\", \\"apple\\", 0), (\\"check\\", \\"banana\\", 0), (\\"remove\\", \\"banana\\", 10), (\\"check\\", \\"banana\\", 0) ] # Output [7, 5, 0] ``` Description: Implement an inventory management system that updates stock levels based on a sequence of operations. Each operation either adds to, removes from, or checks the quantity of an item. For each `\\"check\\"` operation, return the current quantity of the item. Ensure the implementation handles updates and queries efficiently, especially for scenarios involving numerous operations.","solution":"def inventory_system(operations): Simulates a basic inventory system for a small store. Params: operations: List[Tuple[str, str, int]] - List of operations to be performed on the inventory. Returns: List[int] - Results of the check operations. inventory = {} results = [] for operation in operations: op_type, item, qty = operation if op_type == \\"add\\": if item not in inventory: inventory[item] = 0 inventory[item] += qty elif op_type == \\"remove\\": if item in inventory: inventory[item] -= qty # Ensure quantity doesn\'t go below zero if inventory[item] < 0: inventory[item] = 0 elif op_type == \\"check\\": results.append(inventory.get(item, 0)) return results"},{"question":"# Coding Assessment Question You are tasked with creating a function that computes the number of distinct ways to climb a staircase with `n` steps, given that you can climb either 1, 2, or 3 steps at a time. Objective Implement the function `distinct_ways_to_climb(n: int) -> int` that takes an integer `n` as input and returns the number of distinct ways to climb a staircase of `n` steps. Input * An integer `n` where `1 ≤ n ≤ 1,000,000`. Output * An integer representing the number of distinct ways to climb the staircase. Example ```python >>> distinct_ways_to_climb(4) 7 >>> distinct_ways_to_climb(10) 274 >>> distinct_ways_to_climb(20) 121415 ``` Constraints * Utilize dynamic programming for an efficient solution. * Your implementation should run in O(n) time complexity and use O(n) space complexity. Explanation Given a staircase of `n` steps, the number of ways to reach the nth step is the sum of the ways to reach the (n-1)th, (n-2)th, and (n-3)th steps. # Scenario You are developing a fitness app that offers users various challenges and exercises. One feature allows users to set goals for climbing stairs. To motivate them, the app shows the number of distinct ways they can achieve their goal using either 1, 2, or 3 steps at a time. Implementing this function will help in accurately calculating and displaying the distinct ways of reaching the set goal.","solution":"def distinct_ways_to_climb(n): Returns the number of distinct ways to climb a staircase of n steps, given that you can take 1, 2, or 3 steps at a time. if n == 1: return 1 if n == 2: return 2 if n == 3: return 4 dp = [0] * (n + 1) dp[1], dp[2], dp[3] = 1, 2, 4 for i in range(4, n + 1): dp[i] = dp[i-1] + dp[i-2] + dp[i-3] return dp[n]"},{"question":"# Customer Review Analyzer You are tasked with enhancing a basic customer review analyzer script written in Python. The current implementation fetches customer reviews, performs a sentiment analysis on the text, and then summarizes the results. Your goal is to improve the accuracy and efficiency of the script by addressing its shortcomings and implementing additional features. # Requirements 1. **Function Implementation**: Create a function `analyze_reviews(reviews: list, api_key: str) -> dict` that: * Takes a list of customer reviews (strings) and an API key for a sentiment analysis service as input. * Returns a dictionary with keys \'positive\', \'negative\', and \'neutral\', each containing a list of corresponding reviews. * Uses an external sentiment analysis API for determining the sentiment of each review. * Batches the review texts to minimize the number of API calls. 2. **Error Handling**: * Gracefully handles HTTP errors, JSON parsing errors, and API rate limits. * Logs meaningful error messages to help debug issues. 3. **Performance Optimization**: Ensure that the script processes large volumes of reviews efficiently by using techniques such as batching and parallel processing. 4. **Testing and Validation**: * Provide a set of test cases to validate your function. * Ensure your function can handle edge cases such as empty lists, invalid API keys, and network timeouts. # Scenario Context A customer service team at an e-commerce company frequently analyzes customer feedback to improve their products and services. They require a reliable and efficient script that can accurately categorize customer reviews by sentiment using a third-party API. # Input and Output * Input: A list of customer reviews and an API key. * Output: A dictionary with categorized reviews by sentiment or an appropriate error message. # Constraints * The reviews provided will be well-formed strings. * The API key will be a valid string but might have usage limits. * Ensure efficient processing for a large number of reviews. ```python import requests import logging from concurrent.futures import ThreadPoolExecutor # Function to enhance def analyze_reviews(reviews: list, api_key: str, batch_size: int = 10) -> dict: Analyzes customer reviews, categorizing them by sentiment using an external API. :param reviews: List of customer reviews (strings) :param api_key: API key for sentiment analysis service :param batch_size: Number of reviews to process in a single API call :return: Dictionary categorizing reviews into \'positive\', \'negative\', and \'neutral\' sentiment_url = \\"https://api.sentimentanalysis.com/analyze\\" headers = {\\"Authorization\\": f\\"Bearer {api_key}\\"} results = { \\"positive\\": [], \\"negative\\": [], \\"neutral\\": [] } def process_batch(batch): try: response = requests.post(sentiment_url, json={\\"texts\\": batch}, headers=headers) response.raise_for_status() sentiments = response.json() for review, sentiment in zip(batch, sentiments): if sentiment[\\"label\\"] == \\"positive\\": results[\\"positive\\"].append(review) elif sentiment[\\"label\\"] == \\"negative\\": results[\\"negative\\"].append(review) else: results[\\"neutral\\"].append(review) except requests.RequestException as e: logging.error(f\\"Error processing batch: {e}\\") with ThreadPoolExecutor() as executor: for i in range(0, len(reviews), batch_size): batch = reviews[i:i + batch_size] executor.submit(process_batch, batch) return results if __name__ == \\"__main__\\": reviews = [ \\"Great product, really loved it!\\", \\"Terrible experience, would not recommend.\\", \\"It was okay, nothing special.\\", # Add more reviews as needed for testing ] api_key = input(\\"Enter your API key: \\").strip() try: categorized_reviews = analyze_reviews(reviews, api_key) print(\\"Positive Reviews: \\", categorized_reviews[\\"positive\\"]) print(\\"Negative Reviews: \\", categorized_reviews[\\"negative\\"]) print(\\"Neutral Reviews: \\", categorized_reviews[\\"neutral\\"]) except Exception as e: print(f\\"Failed to analyze reviews: {e}\\") ```","solution":"import requests import logging from concurrent.futures import ThreadPoolExecutor def analyze_reviews(reviews: list, api_key: str, batch_size: int = 10) -> dict: Analyzes customer reviews, categorizing them by sentiment using an external API. :param reviews: List of customer reviews (strings) :param api_key: API key for sentiment analysis service :param batch_size: Number of reviews to process in a single API call :return: Dictionary categorizing reviews into \'positive\', \'negative\', and \'neutral\' sentiment_url = \\"https://api.sentimentanalysis.com/analyze\\" headers = {\\"Authorization\\": f\\"Bearer {api_key}\\"} results = { \\"positive\\": [], \\"negative\\": [], \\"neutral\\": [] } def process_batch(batch): nonlocal results try: response = requests.post(sentiment_url, json={\\"texts\\": batch}, headers=headers) response.raise_for_status() sentiments = response.json() for review, sentiment in zip(batch, sentiments): if sentiment[\\"label\\"] == \\"positive\\": results[\\"positive\\"].append(review) elif sentiment[\\"label\\"] == \\"negative\\": results[\\"negative\\"].append(review) else: results[\\"neutral\\"].append(review) except requests.RequestException as e: logging.error(f\\"Error processing batch: {e}\\") with ThreadPoolExecutor() as executor: for i in range(0, len(reviews), batch_size): batch = reviews[i:i + batch_size] executor.submit(process_batch, batch) return results"},{"question":"# Neural Network Backpropagation Implementation You are required to implement a simple feedforward neural network from scratch and perform backpropagation to train the network. Implement the following functions: 1. **initialize_weights** - To initialize the weight matrices for the network. 2. **feedforward** - To compute the output of the network given an input sample. 3. **backpropagation** - To perform backpropagation and update weights based on the error. 4. **train_network** - To train the neural network using the provided training data. # Function Definitions Function 1: initialize_weights ```python def initialize_weights(input_size: int, hidden_size: int, output_size: int) -> tuple: Initialize weight matrices for a neural network with one hidden layer. Args: - input_size (int): Number of neurons in the input layer. - hidden_size (int): Number of neurons in the hidden layer. - output_size (int): Number of neurons in the output layer. Returns: - tuple: A tuple containing the initialized weight matrices for input to hidden and hidden to output layers. ``` Function 2: feedforward ```python def feedforward(weights: tuple, sample: list[float]) -> list[float]: Compute the feedforward output of the network. Args: - weights (tuple): Tuple containing weight matrices for input to hidden and hidden to output layers. - sample (list[float]): Input sample vector. Returns: - list[float]: Output vector from the network. ``` Function 3: backpropagation ```python def backpropagation(weights: tuple, sample: list[float], target: list[float], learning_rate: float) -> tuple: Perform backpropagation and update the weights. Args: - weights (tuple): Tuple containing weight matrices for input to hidden and hidden to output layers. - sample (list[float]): Input sample vector. - target (list[float]): Target output vector. - learning_rate (float): Learning rate for weight updates. Returns: - tuple: Updated weight matrices after backpropagation. ``` Function 4: train_network ```python def train_network(training_samples: list[list[float]], targets: list[list[float]], input_size: int, hidden_size: int, output_size: int, epochs: int, learning_rate: float) -> tuple: Train the neural network using the provided training data. Args: - training_samples (list[list[float]]): List of input samples. - targets (list[list[float]]): List of target output vectors corresponding to the training samples. - input_size (int): Number of neurons in the input layer. - hidden_size (int): Number of neurons in the hidden layer. - output_size (int): Number of neurons in the output layer. - epochs (int): Number of training epochs. - learning_rate (float): Learning rate for weight updates. Returns: - tuple: Trained weight matrices for input to hidden and hidden to output layers. ``` # Input and Output - **Input**: - training_samples: List of input sample vectors (each vector is a list of floats). - targets: List of target output vectors (each vector is a list of floats). - input_size: Integer representing the number of neurons in the input layer. - hidden_size: Integer representing the number of neurons in the hidden layer. - output_size: Integer representing the number of neurons in the output layer. - epochs: Integer representing the number of training epochs. - learning_rate: Float representing the learning rate for updating weights. - **Output**: - For training, the updated weight matrices. - For feedforward, the output vector from the neural network. # Constraints - The training samples and target arrays contain only floats. - Arrays have lengths within the range [1, 1000]. - The learning rate (`learning_rate`) is a float within the range [0.0, 1.0]. - Number of epochs is an integer within the range [1, 1000]. - Number of neurons (for input, hidden, and output layers) are integers within the range [1, 100]. # Additional Notes - Optimize your code for both time and space complexities. - Handle edge cases like zero or negative learning rates gracefully. - Comments and docstrings are encouraged for code clarity. # Example Usage ```python training_samples = [[0.5, 0.2], [0.1, 0.4], [0.6, 0.9], [0.3, 0.7]] targets = [[1.0], [0.0], [1.0], [0.0]] input_size = 2 hidden_size = 3 output_size = 1 epochs = 10 learning_rate = 0.01 # Train neural network trained_weights = train_network(training_samples, targets, input_size, hidden_size, output_size, epochs, learning_rate) # Perform feedforward on a new sample sample = [0.1, 0.3] output = feedforward(trained_weights, sample) print(f\\"Network output: {output}\\") ```","solution":"import numpy as np def initialize_weights(input_size: int, hidden_size: int, output_size: int) -> tuple: Initialize weight matrices for a neural network with one hidden layer. np.random.seed(42) # For reproducibility w1 = np.random.randn(input_size, hidden_size) * 0.01 w2 = np.random.randn(hidden_size, output_size) * 0.01 return w1, w2 def sigmoid(x): return 1 / (1 + np.exp(-x)) def sigmoid_derivative(x): return sigmoid(x) * (1 - sigmoid(x)) def feedforward(weights: tuple, sample: list[float]) -> list[float]: Compute the feedforward output of the network. w1, w2 = weights sample = np.array(sample) # Forward pass z1 = np.dot(sample, w1) a1 = sigmoid(z1) z2 = np.dot(a1, w2) a2 = sigmoid(z2) return a2.tolist() def backpropagation(weights: tuple, sample: list[float], target: list[float], learning_rate: float) -> tuple: Perform backpropagation and update the weights. w1, w2 = weights sample = np.array(sample) target = np.array(target) # Forward pass z1 = np.dot(sample, w1) a1 = sigmoid(z1) z2 = np.dot(a1, w2) a2 = sigmoid(z2) # Calculate errors output_error = a2 - target hidden_error = np.dot(output_error, w2.T) * sigmoid_derivative(z1) # Calculate gradients gradient_w2 = np.outer(a1, output_error) gradient_w1 = np.outer(sample, hidden_error) # Update weights w2 -= learning_rate * gradient_w2 w1 -= learning_rate * gradient_w1 return w1, w2 def train_network(training_samples: list[list[float]], targets: list[list[float]], input_size: int, hidden_size: int, output_size: int, epochs: int, learning_rate: float) -> tuple: Train the neural network using the provided training data. # Initialize weights weights = initialize_weights(input_size, hidden_size, output_size) # Training loop for epoch in range(epochs): for sample, target in zip(training_samples, targets): weights = backpropagation(weights, sample, target, learning_rate) return weights"},{"question":"# String Pattern Replacement You\'ve been provided with the foundation for a text processing script that performs various operations on a given string. # Problem Statement Your task is to implement a new function called **replace_pattern** that replaces all occurrences of a specified pattern within a given string with a replacement string. Function Details Your function should find all non-overlapping occurrences of the specified pattern in the input string and replace them with the given replacement string. # Requirements 1. **Function Signature**: ```python def replace_pattern(input_string, pattern, replacement): # your code here ``` 2. **Input**: - `input_string`: A string where the pattern replacements will occur. - `pattern`: The pattern to search for within the input string. - `replacement`: The string to replace the pattern with. 3. **Output**: - A new string with all the non-overlapping occurrences of the pattern replaced by the replacement string. 4. **Constraints**: - `input_string`, `pattern`, and `replacement` are non-empty strings. - Pattern occurrences in the string are case sensitive. 5. **Performance**: - Implement the function efficiently to handle large input strings and patterns. # Examples ```python # Example 1 input_string = \\"Hello there. Hello world.\\" pattern = \\"Hello\\" replacement = \\"Hi\\" result = replace_pattern(input_string, pattern, replacement) print(result) # Expected Output: \\"Hi there. Hi world.\\" # Example 2 input_string = \\"abcabcabc\\" pattern = \\"abc\\" replacement = \\"123\\" result = replace_pattern(input_string, pattern, replacement) print(result) # Expected Output: \\"123123123\\" # Example 3 input_string = \\"xyz xyz xyz\\" pattern = \\"xyz\\" replacement = \\"abc\\" result = replace_pattern(input_string, pattern, replacement) print(result) # Expected Output: \\"abc abc abc\\" ``` Consider edge cases such as when the pattern appears at the beginning or end of the string, or multiple times in succession. Ensure that your solution correctly handles overlapping patterns by replacing non-overlapping ones only.","solution":"def replace_pattern(input_string, pattern, replacement): Replaces all non-overlapping occurrences of the pattern in the input string with the replacement string. return input_string.replace(pattern, replacement)"},{"question":"# Problem Description You are required to implement a function that determines the longest sequence of consecutive identical characters in a given string. Your solution should efficiently handle the string and return the length of the longest such sequence. # Function Signature ```python def longest_consecutive_character_sequence(s: str) -> int: ``` # Input * `s` (str): A non-empty string consisting of only lowercase alphabetical characters. (1 ≤ len(s) ≤ 10^5) # Output * **Return** the length of the longest sequence of consecutive identical characters in the string. # Examples ```python assert longest_consecutive_character_sequence(\\"aaabbbaac\\") == 3 assert longest_consecutive_character_sequence(\\"abcdefghijklmnopqrstuvwxyz\\") == 1 assert longest_consecutive_character_sequence(\\"aaaaa\\") == 5 assert longest_consecutive_character_sequence(\\"abbbccdddde\\") == 4 ``` # Constraints and Requirements * The function should process the string in a linear pass. * You should manage indices and character comparisons efficiently to achieve optimal performance. * Consider edge cases like very short or very long strings, and ensure the solution handles the largest possible inputs within acceptable time limits. # Additional Information * Think about optimizing the code to minimize unnecessary checks and operations. * Pay attention to the initial and final segments of the string, which might contain the longest sequence.","solution":"def longest_consecutive_character_sequence(s: str) -> int: Returns the length of the longest sequence of consecutive identical characters in the string s. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"# Coding Assessment Question **Problem Statement:** Implement an algorithm to flatten a binary search tree into a sorted linked list in-place. Given the root of a binary search tree, transform it such that the resulting linked list is in ascending order, where each node points to the next node (right child) and there are no left children. **Function Signature**: ```python def flatten_bst_to_linked_list(root: TreeNode) -> TreeNode: ``` **Expected Input/Output**: The function will accept the root node of the binary search tree and return the head node of the resulting linked list. **Constraints**: - The binary search tree may contain up to 10,000 nodes. - Node values are integers. - The transformation should be performed in-place with O(1) extra space requirement, not counting the space required by the input tree itself. **Example**: Given the binary search tree (pre-constructed): ```python # Constructed binary search tree is: # 5 # / # 3 7 # / / # 2 4 6 8 root = TreeNode(5) root.left = TreeNode(3) root.right = TreeNode(7) root.left.left = TreeNode(2) root.left.right = TreeNode(4) root.right.left = TreeNode(6) root.right.right = TreeNode(8) ``` **Output**: - The flattened binary search tree will be transformed into a linked list: `2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8` **Note**: - You should aim to write a solution that leverages the properties of BST (e.g., left subtree nodes are always less than the root, right subtree nodes are always greater than the root). - Consider edge cases like empty tree and trees with only a single node in your implementation.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten_bst_to_linked_list(root: TreeNode) -> TreeNode: Flatten a binary search tree into a sorted linked list in-place. if not root: return None # Create a dummy node to act as the previous node in the linked list dummy = TreeNode(-1) prev = dummy def inorder(node): nonlocal prev if not node: return inorder(node.left) # Current node processing prev.right = node node.left = None # Move prev to current node prev = node inorder(node.right) inorder(root) return dummy.right"},{"question":"# Coding Assessment Question Scenario You are working on a text processing toolkit that includes various word count statistics. One of the frequently requested features is to provide a summary of the top N most frequent words found in a given textual input. Problem Statement Implement a function that takes an input string and returns a list of the top N most frequent words along with their respective counts. The function should ignore case and treat words with different casing as the same word. Punctuation and special characters (except for apostrophes within words) should be removed, and words should be considered as sequences of alphabetic characters and apostrophes. Function Requirements and Constraints 1. **Function Signature** ```python def top_n_frequent_words(text: str, n: int) -> List[Tuple[str, int]] ``` 2. **Parameters**: * `text` - a string consisting of any characters including alphabets, digits, and special characters. * `n` - an integer representing the number of top frequent words to retrieve. 3. **Return Value**: * A list of tuples, where each tuple contains a word (in lowercase) and its frequency count. The list should be sorted in descending order by count. If two words have the same count, they should be sorted alphabetically in ascending order. Example Cases * `top_n_frequent_words(\\"Hello, hello! How are you? Are you doing well in your programming? Well, well, well...\\", 3)` should return `[(\'well\', 4), (\'are\', 2), (\'hello\', 2)]` * `top_n_frequent_words(\\"It is a long established fact that a reader will be distracted by the readable content.\\", 5)` should return `[(\'a\', 2), (\'by\', 1), (\'content\', 1), (\'distracted\', 1), (\'established\', 1)]` # Function Description 1. **Function: `top_n_frequent_words(text: str, n: int) -> List[Tuple[str, int]]`** - This function processes the input text to find the most frequent words while ignoring case sensitivity. - Punctuation and special characters should be removed, except for apostrophes that are part of words. - The function returns a list of tuples containing words and their counts, sorted by frequency and then alphabetically for words with the same frequency. Write your function to handle edge cases such as empty strings, strings with no alphabetic characters, and cases where `n` is larger than the number of unique words in the text.","solution":"import re from collections import Counter from typing import List, Tuple def top_n_frequent_words(text: str, n: int) -> List[Tuple[str, int]]: Given a string of text and an integer n, this function returns a list of top n most frequent words with their respective counts, sorted by frequency in descending order and alphabetically for ties. # Convert text to lowercase text = text.lower() # Use regex to find words, allowing for internal apostrophes words = re.findall(r\\"b[a-z\']+b\\", text) # Count frequencies using Counter word_counts = Counter(words) # Sort by frequency (desc) and alphabetically (asc) sorted_word_counts = sorted(word_counts.items(), key=lambda x: (-x[1], x[0])) # Return top n words return sorted_word_counts[:n]"},{"question":"# Coding Challenge Context: You\'re given a problem of encoding a string using a basic form of Run-Length Encoding (RLE). In this problem, consecutive identical characters in the string are represented as a single character followed by the count of repetitions. Objective: Write a function `rle_encode(input_string: str) -> str` that takes one string input and returns its run-length encoded version. Input: The input will be a single string `input_string` where `1 <= len(input_string) <= 10^5`, consisting of lowercase English letters only. Output: The output should be a string which is the run-length encoded version of the input. Constraints: - The function should handle edge cases (e.g., very short strings, all characters are the same). - The solution should consider efficient processing for large input sizes up to 100,000 characters. Examples: ```python >>> rle_encode(\\"aaabbccd\\") \\"a3b2c2d1\\" >>> rle_encode(\\"rrrrr\\") \\"r5\\" >>> rle_encode(\\"ab\\") \\"a1b1\\" >>> rle_encode(\\"a\\") \\"a1\\" >>> rle_encode(\\"bbcccaa\\") \\"b2c3a2\\" ``` Performance Requirement: Ensure that your approach runs within acceptable time limits for the upper constraint, considering potential large input sizes. Good luck!","solution":"def rle_encode(input_string: str) -> str: Perform run-length encoding on the input string. Parameters: input_string (str): The string to be encoded. Returns: str: Run-length encoded version of the input string. if not input_string: return \\"\\" encoded_string = [] current_char = input_string[0] count = 0 for char in input_string: if char == current_char: count += 1 else: encoded_string.append(current_char + str(count)) current_char = char count = 1 # Append the last set of character and its count encoded_string.append(current_char + str(count)) return \\"\\".join(encoded_string)"},{"question":"# Problem: Rotate N x N Matrix You are provided with a square matrix of integers and your task is to write a function that rotates this matrix 90 degrees in the clockwise direction. You should perform this rotation in-place, meaning you cannot use any additional data structures or create a new matrix. # Function Signature: ```python def rotate_matrix(matrix: List[List[int]]) -> None: This function rotates the matrix 90 degrees clockwise in place. Args: matrix (List[List[int]]): A 2D list representing the N x N matrix. Returns: None. The function modifies the matrix in place. pass ``` # Input: * `matrix`: A list of lists of integers where each inner list represents a row in the N x N matrix. # Constraints: * The size of the matrix (N) will be in the range [1, 100]. * Each element in the matrix can be any integer value. # Output: * The function modifies the input `matrix` in place to rotate it 90 degrees clockwise. # Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) print(matrix) # Output should be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] matrix = [ [1, 2], [3, 4] ] rotate_matrix(matrix) print(matrix) # Output should be: # [ # [3, 1], # [4, 2] # ] ``` # Hints: * Consider the layers of the matrix from the outermost to the innermost. * You can perform the rotation by moving elements in groups of four at a time. * Think about how elements in the first row move to become elements in the last column and so on.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: This function rotates the matrix 90 degrees clockwise in place. Args: matrix (List[List[int]]): A 2D list representing the N x N matrix. Returns: None. The function modifies the matrix in place. n = len(matrix) for layer in range(n // 2): first = layer last = n - 1 - layer for i in range(first, last): offset = i - first # Save the top element top = matrix[first][i] # Move left element to top matrix[first][i] = matrix[last - offset][first] # Move bottom element to left matrix[last - offset][first] = matrix[last][last - offset] # Move right element to bottom matrix[last][last - offset] = matrix[i][last] # Assign top element to right matrix[i][last] = top"},{"question":"# Problem Statement You are given a string `s` consisting of lowercase English letters, and an integer `k`. Your task is to determine the longest substring of `s` where you can replace at most `k` characters to ensure all characters of the substring are the same. Function Signature ```python def longest_repeating_character_replacement(s: str, k: int) -> int: pass ``` Input - `s`: A string of lowercase English letters with length between 1 and `10^5`. - `k`: An integer between 0 and `10^4`. Output - Returns an integer representing the length of the longest substring of `s` where you can replace at most `k` characters to make all characters in the substring the same. Constraints - The length of the input string `s` is between `1` and `10^5`. - The value of `k` is between `0` and `10^4`. Example ```python # Example 1 s = \\"ABAB\\" k = 2 assert longest_repeating_character_replacement(s, k) == 4 # Example 2 s = \\"AABABBA\\" k = 1 assert longest_repeating_character_replacement(s, k) == 4 # Example 3 s = \\"AAABBC\\" k = 2 assert longest_repeating_character_replacement(s, k) == 5 # Example 4 s = \\"AAAA\\" k = 2 assert longest_repeating_character_replacement(s, k) == 4 ``` Notes - Ensure to handle edge cases such as the string consisting of a single character or when `k` is zero. - Consider utilizing a sliding window approach to efficiently solve the problem within the given constraints. - Validate the input assumptions before processing to avoid runtime errors.","solution":"def longest_repeating_character_replacement(s: str, k: int) -> int: Returns the length of the longest substring where we can replace at most k characters to make all characters the same. left = 0 max_count = 0 count = {} for right in range(len(s)): char = s[right] count[char] = count.get(char, 0) + 1 max_count = max(max_count, count[char]) if (right - left + 1) - max_count > k: count[s[left]] -= 1 left += 1 return len(s) - left"},{"question":"# Binary Classification Using Logistic Regression You are given a dataset containing various features of individuals and their diabetes status. Your task is to implement a function using `Logistic Regression` that trains on these features to predict whether an individual has diabetes or not. Follow these specific steps for implementation: **Function Implementation:** 1. **Function Signature**: `def logistic_regression_predict(data: dict) -> np.ndarray:` 2. **Input**: The input will be a dictionary with two keys: - `data`: A list of lists where each inner list represents the features of an individual. - `target`: A list of labels (0 or 1), where 1 indicates diabetes and 0 indicates no diabetes, corresponding to each list of features in `data`. 3. **Process**: - Split the dataset into training and testing sets using a 70-30 ratio for training and testing respectively. - Train the Logistic Regression classifier using the training dataset. - Predict the diabetes status for the test dataset. 4. **Output**: A numpy array containing the predicted labels (0 or 1) for the test dataset. **Constraints**: - Ensure that all necessary preprocessing of the data is performed within the function. - Use appropriate Logistic Regression hyperparameters to ensure model performance. - Evaluate the model performance using accuracy, precision, recall, and F1-score. **Example**: ```python >>> data = { ... \\"data\\": [ ... [1.0, 89.0, 66.0, 23.0, 94.0, 28.1, 0.167, 21.0], ... [0.0, 137.0, 40.0, 35.0, 168.0, 43.1, 2.288, 33.0], ... # Add more feature sets ... ], ... \\"target\\": [0, 1, # Add more labels ... ] ... } >>> logistic_regression_predict(data) array([0, 1]) # Example output representing predicted labels (not actual) ``` **Note**: The example provided in the main function of the code snippet is based on the Pima Indians Diabetes database. Refer to this example for guidance on processing and feature extraction. Good luck, and ensure your solution is well-tested across multiple scenarios to validate its robustness!","solution":"import numpy as np from sklearn.model_selection import train_test_split from sklearn.linear_model import LogisticRegression from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score def logistic_regression_predict(data: dict) -> np.ndarray: Train a Logistic Regression model on the dataset and predict diabetes status. Args: - data (dict): A dictionary with \'data\' containing feature lists and \'target\' containing labels. Returns: - np.ndarray: Array containing the predicted labels (0 or 1) for the test dataset. features = np.array(data[\'data\']) labels = np.array(data[\'target\']) # Splitting the data into training and testing sets (70% train, 30% test) X_train, X_test, y_train, y_test = train_test_split(features, labels, test_size=0.3, random_state=42) # Training Logistic Regression Model model = LogisticRegression(max_iter=1000) model.fit(X_train, y_train) # Predict on the test set y_pred = model.predict(X_test) # Calculate performance metrics accuracy = accuracy_score(y_test, y_pred) precision = precision_score(y_test, y_pred) recall = recall_score(y_test, y_pred) f1 = f1_score(y_test, y_pred) # Print the performance metrics print(f\'Accuracy: {accuracy:.4f}\') print(f\'Precision: {precision:.4f}\') print(f\'Recall: {recall:.4f}\') print(f\'F1 Score: {f1:.4f}\') return y_pred"},{"question":"# Minimum Cost to Connect All Points You are given an array `points` representing `n` points in a 2D plane, where `points[i] = [xi, yi]`. You need to find the minimum cost to connect all the points considering the Manhattan distance, such that every pair of points is connected directly or indirectly. The Manhattan distance between two points `(xi, yi)` and `(xj, yj)` is `|xi - xj| + |yi - yj|`. # Implementation Requirements: 1. **Graph Construction**: Implement a method to construct a graph where each point is a vertex and each pair of points has an edge with weight equal to the Manhattan distance between them. 2. **Minimum Spanning Tree**: Use Prim\'s algorithm or Kruskal\'s algorithm to find the minimum spanning tree of the graph, ensuring that all points are connected with the minimum cost. 3. **Handle Input**: The input should be read as a list of points in a 2D plane. Below is a template to help you get started: ```python import heapq class Solution: def minCostConnectPoints(self, points: List[List[int]]) -> int: n = len(points) if n == 0: return 0 # Priority queue to store (cost, point) tuples min_heap = [(0, 0)] visited = set() total_cost = 0 while len(visited) < n: cost, i = heapq.heappop(min_heap) if i in visited: continue total_cost += cost visited.add(i) for j in range(n): if j not in visited: dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]) heapq.heappush(min_heap, (dist, j)) return total_cost # Example usage points = [[0,0],[2,2],[3,10],[5,2],[7,0]] sol = Solution() print(sol.minCostConnectPoints(points)) # Output: 20 ``` # Input: - The `points` array of shape `(n, 2)` where n is the number of points. # Output: - An integer representing the minimum cost to connect all points. # Constraints: - `1 <= n <= 1000` - `-10^6 <= xi, yi <= 10^6` - All points are distinct. # Example Input: ```python points = [[0,0],[2,2],[3,10],[5,2],[7,0]] sol = Solution() print(sol.minCostConnectPoints(points)) # Output: 20 ``` Output: ``` 20 ``` # Explanation: - The minimum cost to connect all the given points using Manhattan distance is 20. The output should be verified with the computing the minimal spanning tree, connecting all nodes with minimal distance systematically.","solution":"import heapq from typing import List class Solution: def minCostConnectPoints(self, points: List[List[int]]) -> int: def manhattan_distance(p1, p2): return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) n = len(points) if n == 0: return 0 # Priority queue to store (cost, point) tuples min_heap = [(0, 0)] visited = set() total_cost = 0 while len(visited) < n: cost, i = heapq.heappop(min_heap) if i in visited: continue total_cost += cost visited.add(i) for j in range(n): if j not in visited: dist = manhattan_distance(points[i], points[j]) heapq.heappush(min_heap, (dist, j)) return total_cost"},{"question":"# Question: Implement an Anagram Validator Function Context: In many text processing applications, it is essential to determine if two strings are anagrams of each other. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Requirements: Implement a function `are_anagrams` that: - Takes two parameters: `string1` and `string2`. - Returns `True` if the two strings are anagrams of each other and `False` otherwise. - The function should be case insensitive and ignore spaces, punctuation, and non-alphabetic characters. Function Signature: ```python def are_anagrams(string1: str, string2: str) -> bool: ``` Input: - `string1` (str): The first string to compare. - `string2` (str): The second string to compare. Output: - Returns a boolean value indicating whether the two strings are anagrams of each other. Constraints: - The strings may include spaces, punctuation, and non-alphabetic characters, which should be ignored during comparison. Example: ```python result = are_anagrams(\\"Astronomer\\", \\"Moon starer\\") print(result) # Output: True result = are_anagrams(\\"Hello, World!\\", \\"dlroW ,olleH\\") print(result) # Output: True result = are_anagrams(\\"Programming\\", \\"Gram Ring Mop\\") print(result) # Output: True result = are_anagrams(\\"One\\", \\"Two\\") print(result) # Output: False ``` Implement the function according to the above specifications and ensure it correctly identifies anagrams while ignoring cases and irrelevant characters.","solution":"import re def are_anagrams(string1: str, string2: str) -> bool: Determine if two strings are anagrams of each other, ignoring spaces, punctuation, and case mismatches. # Remove non-alphabetical characters and convert to lower case filtered_string1 = re.sub(r\'[^A-Za-z]\', \'\', string1).lower() filtered_string2 = re.sub(r\'[^A-Za-z]\', \'\', string2).lower() # Sort the characters and compare return sorted(filtered_string1) == sorted(filtered_string2)"},{"question":"# Bank Account Transaction History You are working on a banking application where users need to keep track of their transaction history. Implement a class `BankAccount` that allows users to deposit, withdraw, and view their transaction history. Class Declaration: ```python class BankAccount: def __init__(self, initial_balance: float): pass def deposit(self, amount: float) -> None: pass def withdraw(self, amount: float) -> None: pass def get_balance(self) -> float: pass def get_transaction_history(self) -> list: pass ``` Function Descriptions: - `__init__(self, initial_balance: float)`: Initializes the bank account with an initial balance. - `deposit(self, amount: float) -> None`: Adds the specified amount to the account balance. Records the transaction. - `withdraw(self, amount: float) -> None`: Deducts the specified amount from the account balance if there are sufficient funds. Records the transaction. - `get_balance(self) -> float`: Returns the current balance of the account. - `get_transaction_history(self) -> list`: Returns a list of all transactions. Each transaction should be represented as a tuple in the format `(transaction_type: str, amount: float, balance_after_transaction: float)`. `transaction_type` can be either \'deposit\' or \'withdrawal\'. Constraints: - All amounts are non-negative floats. - Withdrawals that exceed the current balance should not be processed and should not be recorded as a transaction. Example: ```python account = BankAccount(1000.0) account.deposit(500.0) account.withdraw(200.0) account.deposit(100.0) print(account.get_balance()) # Expected output: 1400.0 print(account.get_transaction_history()) # Expected output: [(\'deposit\', 500.0, 1500.0), (\'withdrawal\', 200.0, 1300.0), (\'deposit\', 100.0, 1400.0)] ```","solution":"class BankAccount: def __init__(self, initial_balance: float): self.balance = initial_balance self.transactions = [] def deposit(self, amount: float) -> None: self.balance += amount self.transactions.append((\'deposit\', amount, self.balance)) def withdraw(self, amount: float) -> None: if amount <= self.balance: self.balance -= amount self.transactions.append((\'withdrawal\', amount, self.balance)) def get_balance(self) -> float: return self.balance def get_transaction_history(self) -> list: return self.transactions"},{"question":"# Binary Search Tree - Height Calculation Scenario Sara is creating a data storage system that uses a binary search tree (BST) to organize and retrieve data efficiently. She needs a function to determine the height of the tree to analyze its balance and performance characteristics. Objective Using the provided BST class, enhance it by implementing a method to calculate the height of the tree. The height of a binary tree is the number of edges on the longest path from the root to a leaf node. Requirements * **Function Specifications**: * Traverse the tree to determine its height. * Validate and handle the case for an empty tree. * **Constraints**: * The tree is not necessarily balanced. * The tree nodes contain integer values. * **Performance**: * Aim for efficient traversal, ideally O(n) where n is the number of nodes in the tree. Implementation Expand the following class template with an additional method `height`, which returns the height of the tree: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int) -> None: Inserts a value into the Binary Search Tree (BST). >>> bst = BinarySearchTree() >>> bst.insert(10) >>> bst.insert(5) >>> bst.insert(15) >>> bst.insert(2) >>> bst.insert(7) if not self.root: self.root = TreeNode(value) else: self._insert(self.root, value) def _insert(self, node: TreeNode, value: int) -> None: if value < node.value: if node.left: self._insert(node.left, value) else: node.left = TreeNode(value) else: if node.right: self._insert(node.right, value) else: node.right = TreeNode(value) def height(self) -> int: Returns the height of the binary search tree. >>> bst = BinarySearchTree() >>> bst.insert(10) >>> bst.insert(5) >>> bst.insert(15) >>> bst.insert(2) >>> bst.insert(7) >>> bst.height() 2 # Your implementation here ``` Complete the implementation of `height` method. Ensure that the function accurately calculates the height of the BST by traversing its nodes recursively. Note: Do not edit any provided methods (`__init__`, `insert`, `_insert`). Only add and complete the `height` method.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int) -> None: if not self.root: self.root = TreeNode(value) else: self._insert(self.root, value) def _insert(self, node: TreeNode, value: int) -> None: if value < node.value: if node.left: self._insert(node.left, value) else: node.left = TreeNode(value) else: if node.right: self._insert(node.right, value) else: node.right = TreeNode(value) def height(self) -> int: def _height(node: TreeNode) -> int: if not node: return -1 left_height = _height(node.left) right_height = _height(node.right) return 1 + max(left_height, right_height) return _height(self.root)"},{"question":"# Coding Assessment Question Scenario: You are developing a feature for a music library management system that allows users to query and manipulate playlists. One of the functionalities required is to identify the most frequent song in a playlist, which is useful for creating a \\"Top Hits\\" feature within the application. Task: Write a Python function `most_frequent_song(playlist: List[str]) -> str` that: * Takes a single argument `playlist`, which is a list of song names (strings). * Returns the name of the most frequently occurring song in the playlist. # Specifications: * **Input**: A list of strings `playlist`, where each string represents a song name. * **Output**: A single string representing the most frequently occurring song in the playlist. # Constraints: * The input list `playlist` will have at least one song. * If there are multiple songs with the same highest frequency, return the one that appears first in the playlist. * Song names are case-sensitive; \\"Song A\\" and \\"song a\\" are considered different songs. Example Inputs and Outputs: 1. `most_frequent_song([\\"song1\\", \\"song2\\", \\"song1\\", \\"song2\\", \\"song1\\"])` should return `\'song1\'` 2. `most_frequent_song([\\"a\\", \\"b\\", \\"b\\", \\"a\\", \\"a\\"])` should return `\'a\'` 3. `most_frequent_song([\\"x\\", \\"y\\", \\"z\\", \\"x\\", \\"x\\"])` should return `\'x\'` 4. `most_frequent_song([\\"hit\\", \\"song\\", \\"hit\\", \\"song\\", \\"song\\", \\"hit\\"])` should return `\'hit\'` 5. `most_frequent_song([\\"pop\\", \\"rock\\", \\"pop\\", \\"pop\\", \\"rock\\", \\"rock\\"])` should return `\'pop\'` # Example Error Handling: * If the input list is empty, raise a `ValueError` with the message \\"Playlist cannot be empty\\". # Note: Remember to handle all edge cases as specified to ensure the robustness of your function. Ensure that the function works efficiently for playlists with a large number of songs.","solution":"from typing import List def most_frequent_song(playlist: List[str]) -> str: Returns the most frequently occurring song in the playlist. If there are multiple songs with the same highest frequency, returns the one that appears first. if not playlist: raise ValueError(\\"Playlist cannot be empty\\") song_count = {} max_frequency = 0 most_frequent = None for song in playlist: if song not in song_count: song_count[song] = 1 else: song_count[song] += 1 if song_count[song] > max_frequency: max_frequency = song_count[song] most_frequent = song elif song_count[song] == max_frequency and playlist.index(song) < playlist.index(most_frequent): most_frequent = song return most_frequent"},{"question":"# Text File Analysis and Summary **Context**: You are provided with a large text file containing an extensive collection of news articles. Your task is to analyze the file to determine several key statistical metrics about the content within the articles. # Task: 1. **Read and Process**: Write a function to read the text file and process its content. 2. **Word Count**: Determine the total number of words in the text. 3. **Unique Words**: Find the number of unique words in the text. 4. **Most Frequent Words**: Identify the top 10 most frequently occurring words, along with their frequencies. 5. **Statistics Summary**: Present a summary of the text\'s word count, number of unique words, and the frequencies of the top 10 most frequent words. # Inputs: - **file_path**: Path to the text file containing the news articles. # Expected Output: - Print the total number of words in the text. - Print the number of unique words in the text. - Print the top 10 most frequent words with their frequencies. - Print a summary report containing the above statistics. # Code Constraints: - Use Python standard libraries for file operations and text processing. - Ensure your code handles large files efficiently. - Include meaningful comments and print statements for analysis and debugging purposes. Here is the skeleton of the program you need to implement: ```python import os from collections import Counter def read_text_file(file_path): Read the content of the text file and return it as a string. with open(file_path, \'r\', encoding=\'utf-8\') as file: content = file.read() return content def process_text(content): Process the text content and return a list of words. words = content.lower().split() words = [word.strip(\'.,!?\\";:()[]\') for word in words] return words def get_text_statistics(words): Calculate total word count, unique word count, and most frequent words. total_words = len(words) unique_words = len(set(words)) word_frequencies = Counter(words) most_common_words = word_frequencies.most_common(10) return total_words, unique_words, most_common_words def print_statistics(total_words, unique_words, most_common_words): Print the text statistics. print(f\\"Total number of words: {total_words}\\") print(f\\"Number of unique words: {unique_words}\\") print(\\"Top 10 most frequent words:\\") for word, freq in most_common_words: print(f\\"{word}: {freq}\\") def main(): file_path = \'news_articles.txt\' if not os.path.exists(file_path): print(f\\"The file {file_path} does not exist.\\") return content = read_text_file(file_path) words = process_text(content) total_words, unique_words, most_common_words = get_text_statistics(words) print_statistics(total_words, unique_words, most_common_words) if __name__ == \\"__main__\\": main() ``` # Evaluation - You will be evaluated on correctly implementing the text processing and statistical calculations. - Efficiently handling large text files and ensuring accurate word counts. - Clear and concise code with appropriate function naming and comments.","solution":"import os from collections import Counter def read_text_file(file_path): Read the content of the text file and return it as a string. with open(file_path, \'r\', encoding=\'utf-8\') as file: content = file.read() return content def process_text(content): Process the text content and return a list of words. words = content.lower().split() words = [word.strip(\'.,!?\\";:()[]\') for word in words] return words def get_text_statistics(words): Calculate total word count, unique word count, and most frequent words. total_words = len(words) unique_words = len(set(words)) word_frequencies = Counter(words) most_common_words = word_frequencies.most_common(10) return total_words, unique_words, most_common_words def print_statistics(total_words, unique_words, most_common_words): Print the text statistics. print(f\\"Total number of words: {total_words}\\") print(f\\"Number of unique words: {unique_words}\\") print(\\"Top 10 most frequent words:\\") for word, freq in most_common_words: print(f\\"{word}: {freq}\\") def analyze_text_file(file_path): Main function to analyze the given text file and print statistics. if not os.path.exists(file_path): print(f\\"The file {file_path} does not exist.\\") return content = read_text_file(file_path) words = process_text(content) total_words, unique_words, most_common_words = get_text_statistics(words) print_statistics(total_words, unique_words, most_common_words)"},{"question":"# Task: Implement a function named `generate_subsets` that generates all possible subsets of a given list of unique integers. # Requirements: - The function should take one parameter: - `nums` (List[int]): a list of unique integers. - The function should return a list of lists, where each sublist is a unique subset of the input list. # Constraint: - The output should not contain any duplicate subsets. - Subsets should be ordered lexicographically (based on integer values within each subset). # Examples: ```python >>> generate_subsets([1, 2, 3]) [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] >>> generate_subsets([0]) [[], [0]] ```","solution":"def generate_subsets(nums): Generate all possible subsets of the given list of unique integers. def backtrack(start, path): result.append(path[:]) for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() nums.sort() # Ensure the order of subsets is lexicographical result = [] backtrack(0, []) return result"},{"question":"# Array Rotation You are required to implement a function that rotates the elements of an array to the right by a given number of steps. The rotation operation shifts each element of the array to the right by one place, and the last element moves to the first position. This process is repeated `k` times. Your function should take an array `arr` and an integer `k` as input and return the rotated array. # Input - An array `arr` consisting of integers. - An integer `k` indicating the number of rotation steps. # Output - An array representing the rotated version of the input array. # Constraints - The length of the array `arr` is between 1 and 100. - The value of `k` is between 0 and 100. - Examples to consider: - If `k` is 0, the array remains unchanged. - If `k` is greater than the length of the array, rotation should wrap around such that only the remainder when `k` is divided by the array\'s length matters. # Example ```python def rotate_array(arr: list, k: int) -> list: Rotate the array to the right by k steps. :param arr: list of integers :param k: integer :return: list of integers >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_array([1, 2, 3], 4) [3, 1, 2] >>> rotate_array([1], 10) [1] >>> rotate_array([], 2) [] n = len(arr) if n == 0: return [] k = k % n # Simplify k return arr[-k:] + arr[:-k] if __name__ == \\"__main__\\": print(rotate_array([1, 2, 3, 4, 5, 6, 7], 3)) ``` # Task: Implement the `rotate_array` function to rotate the elements of the array `arr` to the right by `k` steps while ensuring that the solution correctly handles various edge cases and constraints.","solution":"def rotate_array(arr: list, k: int) -> list: Rotate the array to the right by k steps. :param arr: list of integers :param k: integer :return: list of integers n = len(arr) if n == 0: return [] k = k % n # Simplify k return arr[-k:] + arr[:-k]"},{"question":"# Task: Student Grade Management System You have been tasked to develop a simple student grade management system for a school. The system should be able to add students, assign grades for different subjects, and compute grade point averages (GPA). Part 1: Adding Students Write a class `Student` that: - Initializes with the student\'s name (a string) and an empty dictionary for grades. ```python class Student: def __init__(self, name: str): self.name = name self.grades = {} ``` Part 2: Assigning Grades Add a method `add_grade(subject: str, grade: float)` to the `Student` class that: - Takes a subject (a string) and a grade (a float between 0 and 100 inclusive). - Adds the grade to the student\'s record for the specified subject. - If the subject already has a grade, it should replace the old grade with the new one. Part 3: Calculating GPA Add a method `calculate_gpa() -> float` to the `Student` class that: - Calculates the GPA of the student. The GPA is the average of all the grades divided by 25. - Returns the GPA rounded to two decimal places. Constraints: - The grade for any subject must be between 0 and 100 inclusive. - If a grade is added or replaced, ensure it falls within the valid range. Example ```python student = Student(\'John Doe\') student.add_grade(\'Math\', 80) student.add_grade(\'Science\', 90) student.add_grade(\'Literature\', 70) print(student.calculate_gpa()) # Output: 3.2 student.add_grade(\'Math\', 85) # Updating Math grade print(student.calculate_gpa()) # Output: 3.0 ``` # Requirements - Ensure appropriate error handling for invalid grades. - Handle cases where there are no grades yet when calculating GPA. - Incorporate any necessary utility functions for modular implementation. Implement the `Student` class and both `add_grade` and `calculate_gpa` methods in Python.","solution":"class Student: def __init__(self, name: str): self.name = name self.grades = {} def add_grade(self, subject: str, grade: float): if not 0 <= grade <= 100: raise ValueError(\\"Grade must be between 0 and 100 inclusive.\\") self.grades[subject] = grade def calculate_gpa(self) -> float: if not self.grades: return 0.0 average_grade = sum(self.grades.values()) / len(self.grades) gpa = average_grade / 25 return round(gpa, 2)"},{"question":"# Matrix Diagonal Sum Calculation You are tasked with creating a function to calculate the sum of the elements on the two main diagonals of a square matrix. The function should work for any NxN integer matrix, where \'N\' is the size of the matrix. Requirements: 1. Implement a function `diagonalSum(matrix: List[List[int]]) -> int` that takes a single parameter `matrix`, which is a list of lists of integers representing the NxN matrix. 2. The function should return an integer representing the sum of the numbers on the two main diagonals. Note that if `N` is odd, the center element must be counted only once. Expected Input and Output: - Input: A list of lists of integers representing an NxN matrix. - Output: An integer representing the sum of the diagonal elements. Constraints: - The matrix size, `N`, will be between 1 and 1000. - The elements of the matrix are integers in the range [-1000, 1000]. Performance Requirements: - Time Complexity: (O(N)), as you need to iterate through the matrix diagonals. - Space Complexity: (O(1)), only a few integer variables are needed. # Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(diagonalSum(matrix)) # Output: 25 matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] print(diagonalSum(matrix)) # Output: 68 ``` Implement the function `diagonalSum` to fulfill the above requirements.","solution":"def diagonalSum(matrix): Calculate the sum of the diagonals of a given NxN matrix. n = len(matrix) total_sum = 0 for i in range(n): total_sum += matrix[i][i] # Primary diagonal total_sum += matrix[i][n - 1 - i] # Secondary diagonal # If the matrix size is odd, subtract the middle element once if n % 2 == 1: total_sum -= matrix[n // 2][n // 2] return total_sum"},{"question":"# Problem Statement You are given a list of strings, where each string contains multiple space-separated words. Your task is to implement a function `reverse_each_word` that processes each string and returns a list of strings where each word in the original string is reversed, but the order of the words remains the same. # Requirements Function Signature ```python def reverse_each_word(strings: list) -> list: ``` Input * `strings`: A list of strings, where each string may contain multiple words separated by spaces. Output * A list of strings, where each word in the input strings is reversed, but the order of the words within each string stays intact. Constraints * You may assume that each string contains at least one word. # Example ```python >>> reverse_each_word([\\"hello world\\", \\"python is fun\\", \\"keep coding\\"]) [\\"olleh dlrow\\", \\"nohtyp si nuf\\", \\"peek gnidoc\\"] >>> reverse_each_word([\\"a b c\\", \\"reverse words\\"]) [\\"a b c\\", \\"esrever sdrow\\"] >>> reverse_each_word([\\"singleword\\"]) [\\"drowelgnis\\"] ``` # Caveats * Ensure your function handles empty strings gracefully and returns an empty string in such cases within the output list. * The function should maintain the original spacing of the words within each string. In your implementation, you can utilize string manipulation techniques to reverse each word individually while preserving the original word order in each input string.","solution":"def reverse_each_word(strings: list) -> list: Processes each string in the input list, reversing each word while maintaining their original order. :param strings: List of strings where each string contains words separated by spaces. :return: List of strings with each word reversed and their order maintained. result = [] for s in strings: reversed_words = \' \'.join(word[::-1] for word in s.split()) result.append(reversed_words) return result"},{"question":"# Context To gauge your ability to implement dynamic programming solutions, consider the classic \\"Knapsack Problem\\". Given a set of items, each with a weight and a value, determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible. # Requirements 1. Implement the `knapsack` function using dynamic programming to solve the problem. 2. Ensure your function correctly calculates the maximum value that can be accommodated within the weight limit. 3. Efficiently handle the input size within the algorithm\'s constraints. # Input/Output 1. **Function**: `knapsack(weight_limit, items)` - **Arguments**: - `weight_limit`: An integer, representing the maximum weight the knapsack can carry. - `items`: List of tuples `[(weight1, value1), (weight2, value2), ..., (weightN, valueN)]` where each tuple represents an item with a corresponding weight and value. - **Returns**: An integer, the maximum value achievable within the given weight limit. # Constraints - Weight limit is a positive integer. - Each item\'s weight and value are positive integers. - Number of items `N` is up to 1000. - Weights can be up to 10,000. # Example ```python weight_limit = 50 items = [(10, 60), (20, 100), (30, 120)] max_value = knapsack(weight_limit, items) print(max_value) # Output: 220 ``` # Criteria - Correct implementation of the dynamic programming approach. - Thorough handling of edge cases (e.g., no items, weight limit of zero). - Efficient solution regarding both time and space complexity.","solution":"def knapsack(weight_limit, items): Solves the knapsack problem using dynamic programming. :param weight_limit: Maximum weight the knapsack can carry :param items: List of tuples [(weight1, value1), (weight2, value2), ...] :return: Maximum value achievable within the given weight limit N = len(items) dp = [0] * (weight_limit + 1) for weight, value in items: for w in range(weight_limit, weight - 1, -1): dp[w] = max(dp[w], dp[w - weight] + value) return dp[weight_limit]"},{"question":"# Assessment Question: Context: You are building a data processing pipeline that involves manipulating and transforming lists of integers. One specific task involves finding a \\"windowed average\\" over a list with a sliding window of a fixed size. Task: Implement a function called `windowed_average` that calculates the average of each contiguous sublist (window) of a specified size from a given list of integers. # Function Signature: ```python def windowed_average(nums: list, k: int) -> list: ``` # Input: - `nums`: a list of `n` integers. - `k`: an integer representing the window size. # Output: - Return a list of floats representing the windowed averages. # Constraints: - The length of `nums` is at least `k`. - Elements in `nums` will be integers. - `k` is a positive integer, and `k` <= length of `nums`. # Example: ```python >>> nums = [1, 2, 3, 4, 5] >>> k = 3 >>> windowed_average(nums, k) [2.0, 3.0, 4.0] >>> nums = [10, 20, 30, 40, 50] >>> k = 2 >>> windowed_average(nums, k) [15.0, 25.0, 35.0, 45.0] ``` # Description: - For each valid sublist of length `k`, calculate the average of the sublist. - The function should return a list of these averages. - The output list will have a length of `n - k + 1`. Notes: - Ensure that your function handles lists efficiently, especially for larger values of `n`. - The input and output formats should match the examples.","solution":"def windowed_average(nums: list, k: int) -> list: This function calculates the average of each contiguous sublist (window) of a specified size from a given list of integers. averages = [] for i in range(len(nums) - k + 1): window = nums[i:i + k] window_avg = sum(window) / k averages.append(window_avg) return averages"},{"question":"# Array Manipulation: Finding the Missing Number Context Jennifer is working on a problem that involves finding a missing number from a sequence. She has an array that contains `n` distinct integers ranging from `0` to `n`. However, one number is missing from this range. Jennifer needs to determine which number is missing to complete the sequence. Your task is to help Jennifer by implementing a function to find the missing number efficiently. Task Implement a function `find_missing_number(nums: List[int]) -> int` that takes a list of integers `nums` and returns the missing number in the sequence. Input Format - A single list `nums` containing `n` integers, where `0 <= n <= 10^5`. Output Format - Return the missing integer in the range from `0` to `n`. Constraints - The list `nums` will contain all distinct integers from `0` to `n`, except one integer which will be missing. Examples ```python assert find_missing_number([3, 0, 1]) == 2 assert find_missing_number([9, 6, 4, 2, 3, 5, 7, 0, 1]) == 8 assert find_missing_number([0, 1]) == 2 assert find_missing_number([1]) == 0 ``` Requirements 1. Implement the `find_missing_number` function with the specified constraints. 2. Ensure that the function executes efficiently, even for the maximum input size. # Solution Note One efficient approach to solve this problem is to use the formula for the sum of the first `n` natural numbers to calculate the expected sum and subtract the sum of the elements in the array from it to find the missing number.","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Returns the missing number from the range 0 to len(nums). n = len(nums) expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"# Binary Tree Paths Consider a binary tree where each node contains an integer value. Your task is to implement a function that finds all possible paths from the root node to the leaf nodes, and each path should be represented as a list of integers from the root node to a leaf node. **Task**: Write a function that generates all the root-to-leaf paths in the binary tree. **Function Signature**: ```python class TreeNode: def __init__(self, x: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = x self.left = left self.right = right def binary_tree_paths(root: TreeNode) -> list: Finds all root-to-leaf paths in a binary tree. Args: root (TreeNode): The root node of the binary tree. Returns: list: A list of lists, where each inner list represents a path from the root to a leaf. ``` **Input/Output**: - **Input**: The root node of a binary tree. - **Output**: A list of lists, where each inner list contains the values of nodes from root to leaf. **Constraints**: - The number of nodes in the binary tree can be up to 10^4. - Each node value can be any integer. - The binary tree can be unbalanced. - The binary tree can be empty, in which case an empty list should be returned. **Examples**: ```python # Example 1: root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(5) >>> binary_tree_paths(root) [[1, 2, 5], [1, 3]] # Example 2: root = TreeNode(1) >>> binary_tree_paths(root) [[1]] # Example 3: root = TreeNode() >>> binary_tree_paths(root) [[0]] # Example 4: root = None >>> binary_tree_paths(root) [] ``` **Additional Challenge**: Implement your solution using both recursive and iterative approaches, and benchmark their performances. Discuss the pros and cons of each approach in the comments.","solution":"class TreeNode: def __init__(self, x: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = x self.left = left self.right = right def binary_tree_paths(root: TreeNode) -> list: def paths_recursion(node, path, result): if node is None: return path.append(node.val) if node.left is None and node.right is None: result.append(list(path)) else: if node.left: paths_recursion(node.left, path, result) if node.right: paths_recursion(node.right, path, result) path.pop() result = [] paths_recursion(root, [], result) return result"},{"question":"# Question You are tasked with creating a feature for a data processing application that compresses and decompresses text files using a simple Run-Length Encoding (RLE) algorithm. Run-Length Encoding is a lossless data compression technique where consecutive data elements are replaced by just one data value and the count of its repetitions. Implement two functions, `compress` and `decompress`, to handle the RLE compression and decompression: Function 1: `compress` * **Input**: A string `text` containing the data to be compressed. * **Output**: A string representing the compressed data where each sequence of the same character is replaced by a single character followed by the number of its repetitions. * **Constraints**: - The input string can contain uppercase and lowercase English letters, digits, and special characters. - The input string may have any length from 0 to `10^5`. - If a character appears only once, do not include a number after it in the output. Function 2: `decompress` * **Input**: A string `compressed_text` containing the compressed data generated by the `compress` function. * **Output**: A string representing the original uncompressed data. * **Constraints**: - The input string will be properly formatted compressed data according to the RLE algorithm. **Example Usage**: ```python assert compress(\\"AAABBBCCDAA\\") == \\"A3B3C2DA2\\" assert decompress(\\"A3B3C2DA2\\") == \\"AAABBBCCDAA\\" assert compress(\\"X\\") == \\"X\\" assert decompress(\\"X\\") == \\"X\\" assert compress(\\"aabbaaa\\") == \\"a2b2a3\\" assert decompress(\\"a2b2a3\\") == \\"aabbaaa\\" ``` Create these functions and demonstrate their usage by implementing a sample `main` function. # Solution ```python def compress(text): if not text: return \\"\\" result = [] count = 1 for i in range(1, len(text)): if text[i] == text[i - 1]: count += 1 else: result.append(text[i - 1] + (str(count) if count > 1 else \\"\\")) count = 1 result.append(text[-1] + (str(count) if count > 1 else \\"\\")) return \\"\\".join(result) def decompress(compressed_text): if not compressed_text: return \\"\\" result = [] i = 0 while i < len(compressed_text): char = compressed_text[i] count = 1 i += 1 count_str = [] while i < len(compressed_text) and compressed_text[i].isdigit(): count_str.append(compressed_text[i]) i += 1 if count_str: count = int(\\"\\".join(count_str)) result.append(char * count) return \\"\\".join(result) # Example usage def main(): assert compress(\\"AAABBBCCDAA\\") == \\"A3B3C2DA2\\" assert decompress(\\"A3B3C2DA2\\") == \\"AAABBBCCDAA\\" assert compress(\\"X\\") == \\"X\\" assert decompress(\\"X\\") == \\"X\\" assert compress(\\"aabbaaa\\") == \\"a2b2a3\\" assert decompress(\\"a2b2a3\\") == \\"aabbaaa\\" main() ```","solution":"def compress(text): if not text: return \\"\\" result = [] count = 1 for i in range(1, len(text)): if text[i] == text[i - 1]: count += 1 else: result.append(text[i - 1] + (str(count) if count > 1 else \\"\\")) count = 1 result.append(text[-1] + (str(count) if count > 1 else \\"\\")) return \\"\\".join(result) def decompress(compressed_text): if not compressed_text: return \\"\\" result = [] i = 0 while i < len(compressed_text): char = compressed_text[i] count = 1 i += 1 count_str = [] while i < len(compressed_text) and compressed_text[i].isdigit(): count_str.append(compressed_text[i]) i += 1 if count_str: count = int(\\"\\".join(count_str)) result.append(char * count) return \\"\\".join(result)"},{"question":"# Fibonacci Sequence Modifier You are tasked with creating a function that computes the modified Fibonacci sequence, where each term is the sum of the previous three terms in the sequence. The first three terms are given, and the sequence is defined as follows: [ F(n) = F(n-1) + F(n-2) + F(n-3) ] for ( n > 3 ). The first three terms are fixed: [ F(1) = a, F(2) = b, F(3) = c ] Write a function `modified_fibonacci(a: int, b: int, c: int, n: int) -> int` that: 1. Takes four integers `a`, `b`, `c`, and `n` where 1 <= `n`. 2. Returns the nth term in the modified Fibonacci sequence. 3. Raises a `ValueError` for inputs less than 1 for `n`. 4. Raises a `TypeError` for inputs `a`, `b`, `c`, or `n` that aren\'t integers. # Constraints 1. The function must handle inputs up to at least 100,000 efficiently. 2. Ensure your implementation is clear and handles edge cases according to the error specifications. # Input * `a`: An integer representing the first term ( F(1) ). * `b`: An integer representing the second term ( F(2) ). * `c`: An integer representing the third term ( F(3) ). * `n`: An integer representing which term in the modified Fibonacci sequence to calculate (1 <= `n`). # Output * An integer representing the nth term of the modified Fibonacci sequence. # Examples ```python >>> modified_fibonacci(1, 2, 3, 1) 1 >>> modified_fibonacci(1, 2, 3, 2) 2 >>> modified_fibonacci(1, 2, 3, 3) 3 >>> modified_fibonacci(1, 2, 3, 4) 6 >>> modified_fibonacci(1, 2, 3, 5) 11 >>> modified_fibonacci(0, 0, 0, 10) 0 >>> modified_fibonacci(1, 2, 3, 0) Traceback (most recent call last): ... ValueError: Input value of [n=0] must be a positive integer >>> modified_fibonacci(1, 2, 3, \'4\') Traceback (most recent call last): ... TypeError: Input value of [n=4] must be an integer ``` Write your solution below: ```python def modified_fibonacci(a: int, b: int, c: int, n: int) -> int: if not all(isinstance(x, int) for x in (a, b, c, n)): raise TypeError(\\"Input values must be integers\\") if n < 1: raise ValueError(f\\"Input value of [n={n}] must be a positive integer\\") if n == 1: return a elif n == 2: return b elif n == 3: return c f1, f2, f3 = a, b, c for _ in range(4, n + 1): f_next = f1 + f2 + f3 f1, f2, f3 = f2, f3, f_next return f3 # You may add your own test cases to validate the implementation: if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"def modified_fibonacci(a: int, b: int, c: int, n: int) -> int: if not all(isinstance(x, int) for x in (a, b, c, n)): raise TypeError(\\"Input values must be integers\\") if n < 1: raise ValueError(f\\"Input value of [n={n}] must be a positive integer\\") if n == 1: return a elif n == 2: return b elif n == 3: return c f1, f2, f3 = a, b, c for _ in range(4, n + 1): f_next = f1 + f2 + f3 f1, f2, f3 = f2, f3, f_next return f3"},{"question":"# Binary Tree Traversal You are asked to implement two functions `preorderTraversal` and `inorderTraversal` to perform Preorder and Inorder traversal of a binary tree, respectively. # Function Specifications Function 1: Preorder Traversal ```python def preorderTraversal(root: \'TreeNode\') -> List[int]: This function performs a preorder traversal on a binary tree. Args: root : TreeNode : the root node of the binary tree. Returns: List[int] : a list of node values in the order they were visited during the traversal. ``` Function 2: Inorder Traversal ```python def inorderTraversal(root: \'TreeNode\') -> List[int]: This function performs an inorder traversal on a binary tree. Args: root : TreeNode : the root node of the binary tree. Returns: List[int] : a list of node values in the order they were visited during the traversal. ``` # Input/Output Format * **Input**: - `root`: A TreeNode representing the root of the binary tree. Nodes in the tree are defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` * **Output**: - Returns a list of integers representing the values of the nodes in the order they were visited during the traversal. # Constraints - The number of nodes in the tree will be in the range `[0, 100]`. - The value of each node in the tree is an integer in the range `[-1000, 1000]`. - You can assume the binary tree is a valid binary tree. # Example Example 1: Preorder Traversal Input: ```python root = TreeNode(1) root.right = TreeNode(2) root.right.left = TreeNode(3) ``` Output: ```python [1, 2, 3] ``` Example 2: Inorder Traversal Input: ```python root = TreeNode(1) root.right = TreeNode(2) root.right.left = TreeNode(3) ``` Output: ```python [1, 3, 2] ``` # Implementation Write the implementations of the functions as specified. Ensure you handle edge cases and provide meaningful output. Use iterative or recursive approaches as needed to accomplish the tasks.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def preorderTraversal(root): This function performs a preorder traversal on a binary tree. Args: root : TreeNode : the root node of the binary tree. Returns: List[int] : a list of node values in the order they were visited during the traversal. result = [] def dfs(node): if not node: return result.append(node.val) dfs(node.left) dfs(node.right) dfs(root) return result def inorderTraversal(root): This function performs an inorder traversal on a binary tree. Args: root : TreeNode : the root node of the binary tree. Returns: List[int] : a list of node values in the order they were visited during the traversal. result = [] def dfs(node): if not node: return dfs(node.left) result.append(node.val) dfs(node.right) dfs(root) return result"},{"question":"# Path from Source to Destination in a Graph **Context:** You are given a directed graph represented by \'n\' vertices and \'m\' edges. Your task is to determine if there is a path from a given source vertex `src` to a destination vertex `dest` using Depth-First Search (DFS). **Function Signature:** ```python def is_path(n: int, edges: List[Tuple[int, int]], src: int, dest: int) -> bool: ``` **Input:** * `n`: An integer representing the number of vertices (0 <= n <= 10^5). * `edges`: A list of tuples, where each tuple (u, v) represents a directed edge from vertex u to vertex v. * `src`: An integer representing the source vertex (0 <= src < n). * `dest`: An integer representing the destination vertex (0 <= dest < n). **Output:** * A boolean value indicating whether there is a path from `src` to `dest`. **Constraints:** * 1 <= m <= 2*10^5 * The vertices are zero-indexed. **Performance Requirements:** * The solution must efficiently handle the upper constraint limits for both time and space. **Example:** ```python # Example 1 n = 5 edges = [(0, 1), (1, 2), (2, 3), (3, 4)] src = 0 dest = 4 is_path(n, edges, src, dest) # Output: True # Example 2 n = 5 edges = [(0, 1), (1, 2), (2, 3), (4, 3)] src = 0 dest = 4 is_path(n, edges, src, dest) # Output: False ``` **Assignment:** Implement the `is_path` function to determine if there is a path from `src` to `dest` using DFS based on the provided signature. **Evaluation Criteria:** * Correctness and Efficiency of the solution. * Handling of edge cases. * Clarity and readability of the implemented code.","solution":"from typing import List, Tuple def is_path(n: int, edges: List[Tuple[int, int]], src: int, dest: int) -> bool: # Create adjacency list for the graph graph = [[] for _ in range(n)] for u, v in edges: graph[u].append(v) # Depth First Search to determine if there is a path from src to dest visited = [False] * n def dfs(vertex): if vertex == dest: return True visited[vertex] = True for neighbor in graph[vertex]: if not visited[neighbor]: if dfs(neighbor): return True return False return dfs(src)"},{"question":"# Question: Polynomial Evaluation Create a function to evaluate a polynomial given its coefficients and a value for the variable. The polynomial should be evaluated using Horner\'s method, which is an efficient algorithm to reduce the time complexity of polynomial evaluation to O(n). # Instructions: 1. **Function Signature**: Implement a function `evaluate_polynomial(coefficients: list[float], x: float) -> float` 2. **Parameters**: - `coefficients`: A list of floating-point numbers representing the coefficients of the polynomial. The length of the list represents the degree of the polynomial + 1. - `x`: A floating-point value for the variable at which the polynomial needs to be evaluated. 3. **Output**: The function should return a floating-point number which is the result of the polynomial evaluated at `x`. 4. **Constraints**: - The coefficients list can include both positive and negative numbers, as well as zero. - The length of the `coefficients` list will be at least 1. - Consider edge cases such as evaluating at `x = 0` or having all coefficients as zero. 5. **Performance**: Aim to use Horner\'s method for an efficient evaluation with O(n) time complexity. # Example: ```python def evaluate_polynomial(coefficients: list[float], x: float) -> float: # Implementation here # Example Usage coef = [1.0, -2.0, 3.0] # Represents the polynomial 1 - 2x + 3x^2 x_val = 2.0 result = evaluate_polynomial(coef, x_val) print(result) # Expected Output: 9.0 ``` # Notes: * In Horner\'s method, the polynomial a_0 + a_1*x + a_2*x^2 + ... + a_n*x^n is evaluated as: a_0 + x*(a_1 + x*(a_2 + x*(... + x*a_n)...)). * Make sure to handle any floating-point arithmetic issues, such as precision errors, during the evaluation process. * The return value should be precise to at least two decimal places.","solution":"def evaluate_polynomial(coefficients: list[float], x: float) -> float: Returns the result of the polynomial evaluated at `x` using Horner\'s method. Parameters: coefficients (list[float]): List of coefficients of the polynomial. x (float): The value at which the polynomial needs to be evaluated. Returns: float: The result of the polynomial evaluation at `x`. result = 0.0 for coefficient in reversed(coefficients): result = result * x + coefficient return result"},{"question":"# Question: Largest Subsequent Non-Repeated Character Sequence You are required to solve a problem involving character sequences. Write a function `largest_non_repeated_subsequence` that takes a string and returns the length of the longest subsequence where no character is repeated. A subsequence of a string is obtained by deleting zero or more characters from the string without changing the order of the remaining characters. Input: - A string `s` consisting of lowercase English letters. Constraints: - `1 <= len(s) <= 1000` Output: - An integer representing the length of the longest subsequence with no repeated characters. Example: ```python def largest_non_repeated_subsequence(s: str) -> int: pass # Example Usage # should return 3 because the longest non-repeated subsequence can be \\"abc\\" print(largest_non_repeated_subsequence(\\"aabbcc\\")) # should return 7 since \\"abcdefg\\" is already without repeating characters print(largest_non_repeated_subsequence(\\"abcdefg\\")) # should return 1 since any single character is the longest sequence possible print(largest_non_repeated_subsequence(\\"aa\\")) ``` Ensure your solution efficiently handles edge cases and the maximum constraint for input size. Validate correctness with diverse test cases to ensure robustness.","solution":"def largest_non_repeated_subsequence(s: str) -> int: Returns the length of the longest subsequence with no repeated characters. unique_characters = set(s) return len(unique_characters)"},{"question":"# Coding Assessment Question Context: As part of a group project, you\'re assigned to work on an image processing application. One of your tasks is to implement a feature where the program identifies and counts the number of distinct colors in a given image. The image will be represented as a 2D list of tuples where each tuple consists of three integers representing the RGB values of the color. Task: 1. Implement a function to find the number of distinct colors in the image. 2. Implement a function to convert the 2D list into a more manageable format for processing. 3. Include a main function to accept the image input, process it, and output the result. Requirements: 1. **Function `count_distinct_colors(image: List[List[Tuple[int, int, int]]]) -> int`** - Receives a 2D list representing the image. - Returns the number of distinct RGB colors in the image. 2. **Function `flatten_image(image: List[List[Tuple[int, int, int]]]) -> List[Tuple[int, int, int]]`** - Receives the same 2D list and converts it into a flat list of RGB tuples for easier processing. 3. **Function `main()`** - Accepts a 2D list as input from the user. - Uses the `flatten_image` function to prepare the input for processing. - Utilizes the `count_distinct_colors` function to find and print the number of distinct colors in the image. Constraints: - Each pixel tuple will have three integers (0 ≤ each ≤ 255) representing RGB values. - The size of the image is within reasonable limits (e.g., maximum dimensions 100x100). Example: For the input image: ``` [ [(255, 0, 0), (0, 255, 0)], [(0, 0, 255), (255, 0, 0)] ] ``` - `flatten_image` should return: ``` [(255, 0, 0), (0, 255, 0), (0, 0, 255), (255, 0, 0)] ``` - `count_distinct_colors` should return: ``` 3 ```","solution":"from typing import List, Tuple def count_distinct_colors(image: List[List[Tuple[int, int, int]]]) -> int: Returns the number of distinct RGB colors in the image. colors_set = set() for row in image: for pixel in row: colors_set.add(pixel) return len(colors_set) def flatten_image(image: List[List[Tuple[int, int, int]]]) -> List[Tuple[int, int, int]]: Converts a 2D list of RGB tuples into a flat list of RGB tuples. flat_list = [] for row in image: flat_list.extend(row) return flat_list def main(): Main function to accept image input, process it, and print the number of distinct colors. image = [ [(255, 0, 0), (0, 255, 0)], [(0, 0, 255), (255, 0, 0)] ] flattened_image = flatten_image(image) distinct_color_count = count_distinct_colors(image) print(f\\"Number of distinct colors: {distinct_color_count}\\") if __name__ == \\"__main__\\": main()"},{"question":"# Problem Statement You are tasked with implementing a function that identifies the native format of a given license plate number from a list of defined formats. Given a list of possible formats, the function should return the matching format or \\"Unknown\\" if no formats match. # Detailed Instructions Function Signature ```python def identify_license_plate(plate: str, formats: list) -> str: pass ``` Inputs - `plate` (str): The license plate number to be checked (consists of alphanumeric characters). - `formats` (list): A list of format strings defining possible valid formats. Each format string consists of `#` representing a digit (0-9) and `@` representing a letter (A-Z or a-z). Output - (str): The matching format string from the list or \\"Unknown\\" if no format matches. # Requirements 1. The function must accurately match the license plate to one of the provided formats. 2. Handle varying lengths and types of formats efficiently. 3. Ensure input validation and edge case handling, such as: - Empty format list - Plate string does not match any format - Plate with mixed case letters should still be valid if format allows for letters. 4. Assume that the plate string will not contain any special characters or spaces. # Constraints - The function should run efficiently even with a large list of formats. - The length of the `plate` will not exceed 100 characters. - Formats list can contain up to 100 different format strings. # Examples ```python >>> identify_license_plate(\\"ABC123\\", [\\"@@@#\\", \\"#@@@\\", \\"#@@\\"]) \'@@@#\' >>> identify_license_plate(\\"12345\\", [\\"#\\", \\"@@@\\"]) \'#\' >>> identify_license_plate(\\"XYZ789\\", [\\"@@\\", \\"@@@\\"]) \'Unknown\' >>> identify_license_plate(\\"abc123\\", [\\"@@@#\\"]) \'@@@#\' >>> identify_license_plate(\\"123ABC\\", [\\"#@@@\\", \\"@@\\", \\"@@@\\"]) \'#@@@\' >>> identify_license_plate(\\"\\", [\\"@@@\\", \\"#\\"]) \'Unknown\' ``` Implement the `identify_license_plate` function to successfully identify the correct format or determine that the format is unknown. Ensure the solution is well-tested for a variety of cases and handles all edge cases appropriately.","solution":"def identify_license_plate(plate: str, formats: list) -> str: Identify the native format of a given license plate number from a list of defined formats. Parameters: - plate (str): The license plate number to be checked (consists of alphanumeric characters). - formats (list): A list of format strings defining possible valid formats. Returns: - (str): The matching format string from the list or \\"Unknown\\" if no format matches. def matches_format(plate, fmt): if len(plate) != len(fmt): return False for p_char, f_char in zip(plate, fmt): if f_char == \'#\' and not p_char.isdigit(): return False if f_char == \'@\' and not p_char.isalpha(): return False return True for fmt in formats: if matches_format(plate, fmt): return fmt return \\"Unknown\\""},{"question":"Permutate String with Constraints You are tasked with permutating a given string based on a set of constraints. Specifically, you need to generate all unique permutations of the input string that meet the following conditions: 1. The string can contain alphanumerical characters and special characters. 2. The length of the string is between 1 and 8 characters inclusive. 3. The permutation must be in lexicographical order. 4. Duplicate permutations must not be included in the result. # Problem Statement Implement the method `permute` in a `PermutationGenerator` class to generate all unique permutations of the input string in lexicographical order. # Constraints 1. The input string can include any character (alphanumeric and special characters). 2. 1 <= len(input_string) <= 8 # Input Format ```plaintext - A single string input that needs to be permutated. ``` # Output Format ```plaintext - A list of strings containing all unique permutations in lexicographical order. ``` # Example ```python input_string = \\"abc\\" generator = PermutationGenerator(input_string) result = generator.permute() print(result) # Output should be: # [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] ``` # Implementation Create the `PermutationGenerator` class with the `permute` method. Ensure the `permute` method generates all unique permutations in lexicographical order and returns them as a list of strings. 1. Utilize backtracking or any other efficient algorithm to generate permutations. 2. Ensure the method handles cases with duplicate characters correctly by generating unique permutations. ```python from itertools import permutations class PermutationGenerator: def __init__(self, input_string: str): self.input_string = input_string def permute(self) -> list[str]: # Use permutations from itertools and ensure results are unique perm_set = set(permutations(self.input_string)) perm_list = sorted(\'\'.join(p) for p in perm_set) return perm_list ``` # Notes 1. Focus on efficiency and correctness to ensure the solution handles the upper limits of input constraints within acceptable time bounds. 2. Handle special characters and duplicates appropriately to generate unique permutations in the correct order.","solution":"from itertools import permutations class PermutationGenerator: def __init__(self, input_string: str): self.input_string = input_string def permute(self) -> list[str]: # Generate all permutations using itertools.permutations perm_set = set(permutations(self.input_string)) # Convert permutation tuples back to strings and sort the result lexicographically perm_list = sorted(\'\'.join(p) for p in perm_set) return perm_list"},{"question":"# Coding Assessment Question: Balanced String Splits In this task, your goal is to count the minimum number of splits required to divide a given string into balanced parts. A string is considered balanced if the number of \'L\' characters is equal to the number of \'R\' characters. Write a function `balanced_string_splits` that takes a single input string and returns an integer representing the number of balanced splits that can be obtained. # Input Format - A single string `s` consisting of \'L\' and \'R\' characters only (1 ≤ |s| ≤ 10^4). # Output Format - Return an integer representing the minimum number of balanced splits possible. # Constraints - The string will only contain characters \'L\' and \'R\'. - The string will always have at least one balanced split. # Example Example 1: ```python >> balanced_string_splits(\\"RLRRLLRLRL\\") ``` **Output:** ```python 4 ``` # Explanation: - The given string `RLRRLLRLRL` can be split into 4 balanced parts: [\\"RL\\", \\"RRLL\\", \\"RL\\", \\"RL\\"]. Example 2: ```python >> balanced_string_splits(\\"RLLLLRRRLR\\") ``` **Output:** ```python 3 ``` # Explanation: - The string `RLLLLRRRLR` can be split into 3 balanced parts: [\\"RL\\", \\"LLLRRR\\", \\"LR\\"]. # Function Signature ```python def balanced_string_splits(s: str) -> int: pass ``` # Explanation: To solve this problem: - Initialize a counter for \'L\' and \'R\' characters, and a counter for the balanced splits. - Iterate through the string, updating the character counters accordingly. - Each time the counters for \'L\' and \'R\' match, increment the balanced splits counter and reset the character counters. - Continue until the end of the string, and return the balanced splits counter.","solution":"def balanced_string_splits(s: str) -> int: balanced_splits = 0 count = 0 for char in s: if char == \'L\': count += 1 elif char == \'R\': count -= 1 if count == 0: balanced_splits += 1 return balanced_splits"},{"question":"# Problem Statement You are tasked with implementing a system that detects and corrects spelling errors in a given text. The system will use a dictionary of known words to identify misspelled words and suggest possible corrections based on edit distance. The edit distance is defined as the minimum number of operations (insertions, deletions, or substitutions) required to transform one word into another. # Function Signature ```python def correct_spelling(text: str, dictionary: set) -> str: pass ``` # Input - `text`: A string representing the input text containing potentially misspelled words. Words are separated by spaces, and punctuation should be ignored. - `dictionary`: A set of strings representing the collection of known correct words. # Output - A string with the text where misspelled words are replaced with their most probable correction based on the shortest edit distance. # Constraints - The input text will contain between 1 and 10,000 words, each word having between 1 and 50 characters. - The dictionary will contain between 1,000 and 100,000 words, each word having between 1 and 50 characters. - The text will only contain lowercase alphabetic characters and spaces. # Example ```python # Example usage text = \\"the quikc bron fox jmps ovr the lazi dog\\" dictionary = {\\"the\\", \\"quick\\", \\"brown\\", \\"fox\\", \\"jumps\\", \\"over\\", \\"lazy\\", \\"dog\\"} # Example expected output # It should correct the text to \\"the quick brown fox jumps over the lazy dog\\" correct_spelling(text, dictionary) ``` # Task Description 1. **Parsing Text**: Implement a function to parse the input text and split it into individual words, ignoring punctuation. 2. **Edit Distance Calculation**: Implement a helper function to calculate the edit distance between two words. 3. **Correction Mechanism**: For each word in the text that is not in the dictionary, find the closest match from the dictionary based on the minimum edit distance. 4. **Edge Cases & Performance**: Handle edge cases such as words with multiple equally close corrections and ensure the solution is efficient for large texts and dictionaries. By implementing the `correct_spelling` function, you will enable the system to produce corrected text even when input contains common spelling mistakes.","solution":"def edit_distance(word1, word2): Calculate the edit distance between two words. dp = [[0] * (len(word2) + 1) for _ in range(len(word1) + 1)] for i in range(len(word1) + 1): for j in range(len(word2) + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) return dp[len(word1)][len(word2)] def correct_spelling(text, dictionary): Correct the spelling errors in the text using the provided dictionary. words = text.split() def find_closest_word(word): if word in dictionary: return word closest_word = None min_distance = float(\'inf\') for dict_word in dictionary: distance = edit_distance(word, dict_word) if distance < min_distance: min_distance = distance closest_word = dict_word return closest_word corrected_words = [find_closest_word(word) for word in words] return \' \'.join(corrected_words)"},{"question":"# Scenario You are building an e-commerce application and need to implement a feature that dynamically adjusts the prices of items based on their sale velocity. The more a particular item sells within a specified time window, the higher its price should become, and vice versa. # Problem Create a function `adjust_prices(items: list[tuple[str, int, int]], sales: list[tuple[str, int]]) -> list[tuple[str, int]]` to adjust the prices of items based on their sales. Each item in the `items` list is represented as a tuple containing the item\'s name, its initial price, and a price adjustment factor. The `sales` list contains tuples representing the item name and the number of units sold. Input * `items`: A list of tuples. Each tuple contains three elements: - a string representing the item name, - an integer representing the initial price of the item, - an integer representing the price adjustment factor. * `sales`: A list of tuples. Each tuple contains two elements: - a string representing the item name, - an integer representing the number of units sold. Output * A list of tuples where each tuple contains: - a string representing the item name, - an integer representing the adjusted price of the item. Constraints * Each item\'s name in `items` is unique. * Each sale\'s item name in `sales` will exist in `items`. * The price adjustment factor is a positive integer. # Example ```python def adjust_prices(items: list[tuple[str, int, int]], sales: list[tuple[str, int]]) -> list[tuple[str, int]]: # Function body here # Example data items = [(\\"itemA\\", 100, 5), (\\"itemB\\", 150, 3), (\\"itemC\\", 200, 2)] sales = [(\\"itemA\\", 20), (\\"itemB\\", 30), (\\"itemC\\", 10)] result = adjust_prices(items, sales) print(result) # Should print a list with adjusted prices, e.g., [(\\"itemA\\", 200), (\\"itemB\\", 240), (\\"itemC\\", 220)] ``` Performance Requirement * The solution should efficiently update prices based on the provided sales data. # Note You need to ensure that the implemented function correctly adjusts each item\'s price by adding the product of its sales count and its adjustment factor to its initial price.","solution":"def adjust_prices(items: list[tuple[str, int, int]], sales: list[tuple[str, int]]) -> list[tuple[str, int]]: # Create a dictionary of sales for quick lookup sales_dict = {name: units_sold for name, units_sold in sales} adjusted_prices = [] for name, initial_price, adjustment_factor in items: units_sold = sales_dict.get(name, 0) adjusted_price = initial_price + (units_sold * adjustment_factor) adjusted_prices.append((name, adjusted_price)) return adjusted_prices"},{"question":"# Problem Statement The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. Mathematically, the Fibonacci sequence Fn is defined by the recurrence relation: [ F(n) = F(n-1) + F(n-2) ] with seed values: [ F(0) = 0, F(1) = 1 ] The Zeckendorf representation of a number is a way of representing it as a sum of non-consecutive Fibonacci numbers. According to Zeckendorf\'s theorem, every positive integer can be uniquely represented as the sum of one or more distinct, non-consecutive Fibonacci numbers. Your task is to write a function `zeckendorf_representation` that takes a positive integer `num` and returns its Zeckendorf representation as a list of distinct, non-consecutive Fibonacci numbers in descending order. # Input - An integer `num` where 1 ≤ num ≤ 10^6 representing the number to be represented in Zeckendorf form. # Output - A list of integers representing the Fibonacci numbers that form the Zeckendorf representation of `num`. # Constraints - 1 ≤ num ≤ 10^6 # Example ```python def test_zeckendorf_representation(): assert zeckendorf_representation(100) == [89, 8, 3] assert zeckendorf_representation(20) == [13, 5, 2] assert zeckendorf_representation(32) == [21, 8, 3] assert zeckendorf_representation(50) == [34, 13, 3] assert zeckendorf_representation(1) == [1] ``` Implement the function `zeckendorf_representation` such that it passes the above test cases. # Additional Notes - You should precompute the Fibonacci sequence up to the maximum value just above 10^6 for efficient representation. - Pay attention to efficiently finding the largest Fibonacci number less than or equal to the given `num` during the representation process.","solution":"def zeckendorf_representation(num): Returns the Zeckendorf representation of a given number. The representation is a sum of distinct and non-consecutive Fibonacci numbers. # Generate all Fibonacci numbers up to num fibs = [1, 2] # use 2 instead of 1 as per the non-consecutive Fibonacci sequence starting from 1, 2... while True: next_fib = fibs[-1] + fibs[-2] if next_fib > num: break fibs.append(next_fib) # To ensure we iterate from the largest number, reverse the list fibs.reverse() # To store the Zeckendorf representation result = [] for fib in fibs: if num >= fib: num -= fib result.append(fib) return result"},{"question":"# Task You are required to manage a task scheduler that handles overlapping intervals efficiently. # Problem Statement Given a list of intervals, each defined by a start and end time, your task is to implement a function that finds the minimum number of meeting rooms required to accommodate all the intervals without any overlaps. Input * An integer `n` representing the number of intervals. * An array of tuples, where each tuple `(start, end)` represents the start and end time of an interval. Output * An integer representing the minimum number of meeting rooms required. Constraints * `1 <= n <= 10^5` * `0 <= start < end <= 10^9` Example ```plaintext Input: 3 (0, 30) (5, 10) (15, 20) Output: 2 ``` # Explanation The intervals `(0, 30)` and `(5, 10)` overlap, so at least 2 meeting rooms are needed. The interval `(15, 20)` doesn\'t overlap with `(5, 10)` but overlaps with `(0, 30)`. # Instructions * Implement the function `min_meeting_rooms(n: int, intervals: list[tuple[int, int]]) -> int`. * Ensure the implementation efficiently handles the constraints. * Your solution should consider sorting and using a min-heap to keep track of end times. # Notes * You should take advantage of Python\'s `heapq` library for the priority queue implementation. * The intervals list is not necessarily sorted. * Focus on the efficiency of your solution, particularly regarding time complexity. This problem assesses your understanding of interval management and efficient use of priority queues.","solution":"import heapq def min_meeting_rooms(n, intervals): Returns the minimum number of meeting rooms required to accommodate all intervals. Args: n (int): The number of intervals. intervals (list of tuples): List containing intervals (start, end). Returns: int: Minimum number of meeting rooms required. # Edge case: If there are no intervals, return 0 if n == 0: return 0 # Sort the intervals by start time intervals.sort(key=lambda x: x[0]) # Create a min-heap to keep track of end times of meetings min_heap = [] # Add the end time of the first meeting heapq.heappush(min_heap, intervals[0][1]) # Iterate over the remaining intervals for i in range(1, n): # If the current meeting starts after the earliest ending meeting, pop from heap if intervals[i][0] >= min_heap[0]: heapq.heappop(min_heap) # Push the end time of the current meeting into the heap heapq.heappush(min_heap, intervals[i][1]) # The size of the heap will be the minimum number of meeting rooms needed return len(min_heap)"},{"question":"# Problem Description Bob enjoys solving math puzzles, and he\'s currently interested in finding the greatest common divisor (GCD) of two integers. Your task is to help Bob by implementing an algorithm to compute the GCD of two given integers using the Euclidean algorithm. # Requirements 1. Implement a method `calculate_gcd` that accepts two integer inputs and returns their GCD. 2. The function should handle positive, negative, and zero values for the input integers. # Input and Output * **Input**: * Two integers representing the numbers for which the GCD is to be calculated. * **Output**: * An integer representing the GCD of the two input integers. # Constraints * The input integers can range from `-10^9` to `10^9`. * The GCD of zero and any non-zero number is the absolute value of the non-zero number. * The GCD of two zeroes is zero. # Example Scenarios 1. **Example 1**: * Input: `48, 18` * Expected Output: `6` 2. **Example 2**: * Input: `-54, 24` * Expected Output: `6` 3. **Example 3**: * Input: `0, 5` * Expected Output: `5` 4. **Example 4**: * Input: `0, 0` * Expected Output: `0` # Implementation Template ```python def calculate_gcd(a, b): Calculate the greatest common divisor (GCD) of two integers using the Euclidean algorithm. :param a: First integer :param b: Second integer :return: Integer representing the GCD of \'a\' and \'b\' if a == 0 and b == 0: return 0 a, b = abs(a), abs(b) while b: a, b = b, a % b return a ``` Use the provided template and complete the `calculate_gcd` method ensuring it correctly implements the Euclidean algorithm to determine the GCD of the two integers as specified.","solution":"def calculate_gcd(a, b): Calculate the greatest common divisor (GCD) of two integers using the Euclidean algorithm. :param a: First integer :param b: Second integer :return: Integer representing the GCD of \'a\' and \'b\' if a == 0 and b == 0: return 0 a, b = abs(a), abs(b) while b: a, b = b, a % b return a"},{"question":"# Reversing a Linked List Scenario In computer science, a linked list is a common data structure. Reversing a linked list is a frequent operation which tests understanding of pointers and node manipulation. Task Write a function `reverse_linked_list(head: ListNode) -> ListNode` that takes the head node of a singly linked list and returns the head node of the reversed linked list. Specifications **Function Signature** ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: pass ``` **Input** - `head` (ListNode): The head node of the singly linked list. **Output** - (ListNode): The new head node of the reversed singly linked list. **Constraints** - The length of the linked list will be between 0 and 10^6. - Each node’s value will be between -10^9 and 10^9. **Performance Requirements** - The solution should complete in linear time, i.e., O(n). Examples ```python # Example 1: # Input: 1 -> 2 -> 3 -> 4 -> 5 # Output: 5 -> 4 -> 3 -> 2 -> 1 # Example 2: # Input: None # Output: None # Example 3: # Input: 1 -> 2 # Output: 2 -> 1 # Example 4: # Input: 1 # Output: 1 ``` **Implementation Notes** - Define a `ListNode` class with an initializer that sets the value and the next pointer. - Ensure the function correctly handles edge cases such as an empty linked list (i.e., `head` is `None`). - Optimize for large lists, ensuring that the reversal operates in linear time. Good luck! Make sure your solution is efficient and takes care of potential edge cases properly.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: prev = None current = head while current is not None: next_node = current.next # store reference to the next node current.next = prev # reverse the link prev = current # move prev and current one step forward current = next_node return prev"},{"question":"# Question: You are given a list of `n` friends. Each friend can either be matched with another friend or remain single. Your task is to calculate the number of ways to pair up or leave single all `n` friends. Note that the pairs are unordered, meaning that (a, b) is considered the same as (b, a). **Function Signature**: ```python def count_friend_pairings(n: int) -> int: Calculates the number of ways to pair up or leave single `n` friends. :param n: An integer representing the number of friends. :return: An integer representing the number of ways to pair up or leave single the friends. Example: >>> count_friend_pairings(3) 4 Constraints: - 1 <= n <= 100 ``` **Requirements**: 1. Use dynamic programming to solve the problem. 2. Ensure the function handles edge cases (e.g., n = 1). 3. The function should exhibit a time complexity of O(n). **Example**: ```python >>> count_friend_pairings(4) 10 ```","solution":"def count_friend_pairings(n: int) -> int: Calculates the number of ways to pair up or leave single `n` friends. :param n: An integer representing the number of friends. :return: An integer representing the number of ways to pair up or leave single the friends. if n <= 1: return 1 # Initialize a list to store solutions to subproblems dp = [0] * (n + 1) # Base cases dp[0] = 1 # One way to pair zero friends (do nothing) dp[1] = 1 # One way to pair one friend (leave them single) # Fill dp array using the recursive relation for i in range(2, n + 1): dp[i] = dp[i - 1] + (i - 1) * dp[i - 2] return dp[n]"},{"question":"# Problem Description You are responsible for managing a large stream of real-time data using a priority queue to implement a scheduling system. Your task is to enhance the Priority Queue with new functionalities and ensure it can efficiently handle dynamic updates. # Objectives 1. Implement the `merge_with` method to merge another priority queue into the current one. 2. Improve the Priority Queue to support deletion of an arbitrary element efficiently. 3. Optimize the Priority Queue to handle changes dynamically by ensuring efficient insertion, deletion, and retrieval of elements. # Requirements Part 1: `merge_with` * **Function Signature**: `def merge_with(self, other: \'PriorityQueue\') -> None` * **Inputs**: Another `PriorityQueue` instance `other`. * **Outputs**: No return value; the current priority queue should be modified to include all elements of `other`, and `other` should be emptied. Part 2: Efficient Element Deletion * **Enhance the Priority Queue**: - Implement the `delete(self, element: Any) -> bool` method to delete an arbitrary element. - The method should return `True` if the element was successfully deleted, otherwise `False`. - Ensure the deletion maintains the heap property. Part 3: Dynamic Handling * **Optimize the Priority Queue**: - Implement a mechanism for dynamic updates: - Ensure that additions and deletions maintain the heap property. - Optimize the data structure for real-time updates with minimal performance impact. # Input and Output Format ```python # Example for Part 1 pq1 = PriorityQueue() pq1.insert(20, 15, 10) pq2 = PriorityQueue() pq2.insert(25, 5, 12) pq1.merge_with(pq2) print(pq1.peek()) # Output should be 5 print(pq2.is_empty()) # Output should be True # Example for Part 2 pq = PriorityQueue() pq.insert(20, 15, 10, 5) success = pq.delete(15) print(success) # Output should be True print(pq.peek()) # Output should be 5 (assuming it maintains min-heap property) # Example for Part 3 pq = PriorityQueue() pq.insert(30, 20, 10, 40) pq.delete(20) print(pq.peek()) # Output should be 10 pq.insert(5) print(pq.peek()) # Output should be 5 (assuming it maintains min-heap property) ``` Performance and Constraints - Ensure efficient time complexity for insertions, deletions, and merging operations. - Handle edge cases such as attempting to delete non-existent elements or merging with an empty priority queue. # Function Details 1. `merge_with(self, other: \'PriorityQueue\') -> None` 2. `delete(self, element: Any) -> bool` 3. `insert(self, *values) -> Self` 4. `peek(self) -> Any` 5. `is_empty(self) -> bool` 6. Other necessary functions to maintain the heap property during dynamic updates. # Scenario Imagine you are working on a task scheduler for a distributed computing system. The scheduler needs to manage the priorities of various tasks in real-time, merging tasks from different sources and handling updates promptly. By implementing an enhanced priority queue with the ability to merge efficiently and delete specific elements, you can ensure that your task scheduler remains responsive and efficient, providing optimal performance for the distributed system.","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] self.entry_finder = {} # mapping of tasks to entries self.REMOVED = \'<removed-task>\' # placeholder for a removed task self.counter = 0 def insert(self, *values): for value in values: if value in self.entry_finder: self.delete(value) count = self.counter entry = [value, count] self.entry_finder[value] = entry heapq.heappush(self.heap, entry) self.counter += 1 def merge_with(self, other: \'PriorityQueue\') -> None: for value in other.heap: if value[1] != self.REMOVED: self.insert(value[0]) other.clear() def delete(self, element) -> bool: if element in self.entry_finder: entry = self.entry_finder.pop(element) entry[1] = self.REMOVED return True return False def peek(self): while self.heap: value, count = heapq.heappop(self.heap) if count != self.REMOVED: self.entry_finder[value] = [value, self.counter] heapq.heappush(self.heap, [value, self.counter]) return value return None def is_empty(self) -> bool: return not bool(self.entry_finder) def clear(self): self.heap = [] self.entry_finder = {} self.counter = 0"},{"question":"# Palindrome Substring Finder **Context**: A palindrome is a word, phrase, number, or other sequences of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization). Detecting palindromic substrings within a string is an intriguing problem with applications in pattern recognition, bioinformatics, and text processing. You have several functions to find palindromic substrings within a string: 1. `find_palindromes_sub1(s: str) -> List[str]` 2. `find_palindromes_sub2(s: str) -> List[str]` 3. `find_palindromes_sub3(s: str) -> List[str]` # Task Your task is to implement a new function that returns all distinct palindromic substrings in a given string using a method different from the provided functions. Your solution will be assessed based on correctness, uniqueness of the approach, and efficiency in handling various edge cases. # Specification * **Function Name**: `improved_find_palindromes` * **Input**: - `s` (str): a string which may contain letters, numbers, and symbols * **Output**: - Returns `List[str]`: a list of distinct palindromic substrings in the given string. # Constraints - The input string `s` will have a maximum length of `1000` characters. - Your solution should handle edge cases such as empty strings, single-character strings, and strings without any palindromic substrings. - Your implementation should not replicate the provided functions directly but aim to offer a different and possibly more optimized approach. # Examples ```python >>> improved_find_palindromes(\\"ababa\\") [\\"a\\", \\"aba\\", \\"ababa\\", \\"b\\", \\"bab\\"] >>> improved_find_palindromes(\\"abc\\") [\\"a\\", \\"b\\", \\"c\\"] >>> improved_find_palindromes(\\"\\") [] >>> improved_find_palindromes(\\"a\\") [\\"a\\"] >>> improved_find_palindromes(\\"racecar\\") [\\"a\\", \\"aceca\\", \\"c\\", \\"cec\\", \\"r\\", \\"racecar\\", \\"e\\"] ``` # Additional Requirement Include a brief paragraph in your solution describing why your approach is distinct and any trade-offs made. # Bonuses 1. **Runtime Efficiency**: Provide a runtime analysis comparing your implementation with the given functions for large strings. 2. **Memory Efficiency**: Discuss any memory overhead reductions your implementation achieves compared to other popular methods such as expanding centers.","solution":"def improved_find_palindromes(s: str) -> list: Returns all distinct palindromic substrings in the given string. def is_palindrome(sub: str) -> bool: return sub == sub[::-1] palindromes = set() n = len(s) # Check for each substring for i in range(n): for j in range(i + 1, n + 1): sub = s[i:j] if is_palindrome(sub): palindromes.add(sub) return sorted(list(palindromes)) # Explanation: # This approach uses a simple nested loop to generate all possible substrings. # It then checks if each substring is a palindrome and adds it to a set to ensure uniqueness. # This approach is distinct from expanding center methods or dynamic programming as it directly generates substrings. # The trade-off here is potentially higher time complexity due to the nested loop structure, # but it simplifies the handling of all unique palindromic substrings directly via a set."},{"question":"# Problem Statement You are given two integers `start` and `end`, and a function `f` that applies a mathematical operation (such as addition, multiplication, etc.) to its input. Your task is to find the smallest integer `x` within the range `[start, end]` (inclusive) for which the result of `f(x)` is odd. **Function Signature**: ```python def find_odd_output(f: Callable[[int], int], start: int, end: int) -> int: ``` # Input: - `f`: A function that takes an integer input and returns an integer output. - `start`: An integer representing the starting point of the range. - `end`: An integer representing the ending point of the range. # Output: - Returns the smallest integer `x` in the range `[start, end]` such that `f(x)` is an odd number. - If no such `x` exists, return `-1`. # Constraints: - `-10^9 <= start <= end <= 10^9` - The function `f` will be a deterministic function (no random behavior). - The range `[start, end]` will contain at least one integer. # Examples: ```python def example_func(x): return 2 * x + 1 assert find_odd_output(example_func, 0, 10) == 0 def example_func_2(x): return x * x - 4 assert find_odd_output(example_func_2, 0, 10) == 1 def example_func_3(x): return 2 * x assert find_odd_output(example_func_3, 0, 10) == -1 ``` # Note: - Consider edge cases where the range might be very large. - Assume the function `f` will always return an integer when given an integer. - Do not assume any specific property of the function `f` other than it being deterministic and returning integers.","solution":"from typing import Callable def find_odd_output(f: Callable[[int], int], start: int, end: int) -> int: Returns the smallest integer x within the range [start, end] for which the result of f(x) is odd. If no such x exists, returns -1. for x in range(start, end + 1): if f(x) % 2 != 0: # Check if the result of f(x) is odd return x return -1 # Return -1 if no odd output is found in the range"},{"question":"# Coding Challenge You are tasked with analyzing multiple data streams to find the most frequently occurring intervals within a set of time ranges. Each interval is represented by its start and end times. **Objective**: Write a function `find_most_frequent_interval(intervals: List[Tuple[int, int]]) -> Tuple[int, int]` that: * **Input**: - `intervals`: A list of tuples, each containing two integers representing the start and end times of intervals (0 ≤ start < end ≤ 1,000,000). * **Output**: Returns a tuple with the start and end times of the most frequently occurring interval. If there are multiple intervals with the same frequency, return the one with the smallest start time. If there is still a tie, return the one with the smallest end time. # Example Usage: ```python assert find_most_frequent_interval([(1, 3), (2, 5), (1, 2), (1, 3), (3, 5)]) == (1, 3) assert find_most_frequent_interval([(1, 4), (2, 6), (2, 4), (3, 5), (4, 6)]) == (2, 4) assert find_most_frequent_interval([(5, 10), (1, 2), (1, 2), (2, 4), (1, 2)]) == (1, 2) ``` # Constraints: 1. Each interval is defined by a pair of integers (start, end), where 0 ≤ start < end ≤ 1,000,000. 2. You can assume the input list will always contain at least one interval. # Guidelines: - Use a collection (such as a dictionary) to count the frequency of each interval. - Ensure the function efficiently handles the sorting and selection process for large lists of intervals. - Carefully handle cases where intervals overlap or coincide. **Note**: Your implementation should strive for both correctness and efficiency, given the potential size of the input data.","solution":"from typing import List, Tuple from collections import Counter def find_most_frequent_interval(intervals: List[Tuple[int, int]]) -> Tuple[int, int]: Returns the most frequently occurring interval. In case of a tie, returns the smallest start time, and if still tied, the smallest end time. counter = Counter(intervals) # Sorting: first by frequency (in descending order), then by start (in ascending order), # and then by end (in ascending order) most_frequent_interval = sorted(counter.items(), key=lambda x: (-x[1], x[0][0], x[0][1]))[0][0] return most_frequent_interval"},{"question":"# Scenario You are designing a URL shortening service similar to Bitly. The service should be able to generate a unique shortened URL for a long URL and store the mapping. Additionally, it should retrieve the original long URL when given a shortened URL. # Task Implement a class called `URLShortener` that provides the following functionalities: 1. **shorten_url(long_url: str) -> str** - Generates and returns a unique shortened URL for the given `long_url`. 2. **get_long_url(short_url: str) -> str** - Retrieves and returns the original long URL corresponding to the given `short_url`. If the `short_url` does not exist, return an empty string. Constraints - The length of the long URL is between 1 and 10^3 characters. - The shortened URL should be a concise alphanumeric string. - The service should handle up to 10^6 URLs. - Ensure that the same long URL always maps to the same short URL. Performance Requirements - The `shorten_url` operation should be efficient in generating the shortened URL. - The `get_long_url` operation should retrieve the original URL in constant or near-constant time. Example ```python url_shortener = URLShortener() # Shortening URLs short_url1 = url_shortener.shorten_url(\\"https://www.example.com/firstlongurl\\") short_url2 = url_shortener.shorten_url(\\"https://www.example.com/secondlongurl\\") # Retrieving long URLs print(url_shortener.get_long_url(short_url1)) # Output: \\"https://www.example.com/firstlongurl\\" print(url_shortener.get_long_url(short_url2)) # Output: \\"https://www.example.com/secondlongurl\\" ``` Implement the `URLShortener` class ensuring efficient URL shortening and retrieval, as well as considering possible edge cases.","solution":"import hashlib class URLShortener: def __init__(self): self.url_map = {} self.reverse_map = {} def shorten_url(self, long_url: str) -> str: # Use MD5 hash for generating a fixed and consistent short URL short_url = hashlib.md5(long_url.encode()).hexdigest()[:8] if short_url not in self.url_map: self.url_map[short_url] = long_url self.reverse_map[long_url] = short_url return self.reverse_map[long_url] def get_long_url(self, short_url: str) -> str: return self.url_map.get(short_url, \\"\\")"},{"question":"# Memory-Efficient Fibonacci Sequence Generator **Problem Statement:** You are required to generate and return the first `n` numbers of the Fibonacci sequence. The Fibonacci sequence is defined as follows: - `F(0) = 0` - `F(1) = 1` - `F(n) = F(n-1) + F(n-2)` for `n >= 2` While it\'s easy to use an array to store all the Fibonacci numbers up to `n`, this problem requires a memory-efficient solution. Only two variables should be used to keep track of the necessary sequence values as you iterate to the `n-th` number. **Function Signature:** ```python def fibonacci_sequence(n: int) -> list: Generates the first n Fibonacci numbers in a memory-efficient manner. :param n: The length of the Fibonacci sequence to generate. :return: A list containing the first n Fibonacci numbers. pass ``` **Input:** * An integer `n` where: * (0 leq n leq 10^5) **Output:** * The function should return a list of the first `n` Fibonacci numbers. **Constraints:** * You must use only a constant amount of extra memory to generate the Fibonacci numbers (in terms of space complexity, O(1) auxiliary space). * The solution must be efficient enough to handle the upper constraint within a reasonable time frame. **Example Test Cases:** 1. `fibonacci_sequence(5)` should return `[0, 1, 1, 2, 3]`. 2. `fibonacci_sequence(1)` should return `[0]`. 3. `fibonacci_sequence(10)` should return `[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]`. 4. `fibonacci_sequence(0)` should return `[]`. **Performance Requirements:** * Ensure that your solution is optimized for both time and space to handle the maximum constraint efficiently. **Note:** * Use only two variables to keep track of the required sequence values as you compute each Fibonacci number. * Edge cases such as n = 0 and n = 1 should be handled gracefully.","solution":"def fibonacci_sequence(n: int) -> list: if n == 0: return [] elif n == 1: return [0] fib_sequence = [0, 1] a, b = 0, 1 for _ in range(2, n): a, b = b, a + b fib_sequence.append(b) return fib_sequence"},{"question":"# Context You are tasked with analyzing sentiment from text data and classifying it as positive or negative. This involves using a Naive Bayes classifier to process a labeled training dataset and then predict sentiments on a test dataset. You need to implement functions to preprocess the text, calculate the necessary probabilities, and classify new instances. # Requirements 1. Implement functions to preprocess text (tokenization and normalization). 2. Train the Naive Bayes classifier on the provided training data. 3. Predict the sentiment of new instances using the trained model. # Input/Output 1. **Function**: `train_naive_bayes(train_data)` - **Arguments**: - `train_data`: List of tuples `[(\\"text1\\", \\"positive/negative\\"), (\\"text2\\", \\"positive/negative\\"), ...]`. - **Returns**: A model containing word probabilities for both classes. 2. **Function**: `predict_naive_bayes(model, test_data)` - **Arguments**: - `model`: A dictionary containing trained probabilities for both classes. - `test_data`: List of strings `[\\"text1\\", \\"text2\\", ...]`. - **Returns**: List of predicted labels `[\\"positive\\", \\"negative\\", ...]`. # Constraints - The training data is labeled with balanced classes. - Test data does not contain any labels. - Assume no missing data or empty instances. # Example ```python train_data = [(\\"I love this product\\", \\"positive\\"), (\\"This is the worst service ever\\", \\"negative\\"), (\\"Absolutely wonderful experience\\", \\"positive\\"), (\\"I hate the taste\\", \\"negative\\")] test_data = [\\"This service is amazing\\", \\"I will never buy this product again\\"] model = train_naive_bayes(train_data) predicted_labels = predict_naive_bayes(model, test_data) print(predicted_labels) # Output might be: [\\"positive\\", \\"negative\\"] ``` # Criteria - Correct implementation of text preprocessing techniques. - Accurate calculation of probabilities during training. - Correct sentiment classification of the test data. - Efficiency and scalability of the implementation.","solution":"import re from collections import defaultdict from math import log def preprocess_text(text): Tokenize and normalize text (convert to lowercase). tokens = re.findall(r\'bw+b\', text.lower()) return tokens def train_naive_bayes(train_data): Train a Naive Bayes classifier. word_counts = {\'positive\': defaultdict(int), \'negative\': defaultdict(int)} class_counts = {\'positive\': 0, \'negative\': 0} total_words = {\'positive\': 0, \'negative\': 0} for text, label in train_data: tokens = preprocess_text(text) class_counts[label] += 1 for token in tokens: word_counts[label][token] += 1 total_words[label] += 1 # Calculate probabilities model = { \'word_probs\': { \'positive\': {}, \'negative\': {}, }, \'class_probs\': { \'positive\': log(class_counts[\'positive\'] / len(train_data)), \'negative\': log(class_counts[\'negative\'] / len(train_data)), } } vocabulary = set() for token_counts in word_counts.values(): vocabulary.update(token_counts.keys()) vocab_size = len(vocabulary) for word in vocabulary: model[\'word_probs\'][\'positive\'][word] = log( (word_counts[\'positive\'][word] + 1) / (total_words[\'positive\'] + vocab_size) ) model[\'word_probs\'][\'negative\'][word] = log( (word_counts[\'negative\'][word] + 1) / (total_words[\'negative\'] + vocab_size) ) return model def predict_naive_bayes(model, test_data): Predict sentiments for given test data. predictions = [] for text in test_data: tokens = preprocess_text(text) positive_prob = model[\'class_probs\'][\'positive\'] negative_prob = model[\'class_probs\'][\'negative\'] for token in tokens: if token in model[\'word_probs\'][\'positive\']: positive_prob += model[\'word_probs\'][\'positive\'][token] if token in model[\'word_probs\'][\'negative\']: negative_prob += model[\'word_probs\'][\'negative\'][token] if positive_prob > negative_prob: predictions.append(\'positive\') else: predictions.append(\'negative\') return predictions"},{"question":"# Problem Description You are given a User class that implements a basic user profile system. Your task is to extend the User class to support managing friends for each user. Specifically, you need to implement methods for adding a friend, removing a friend, and checking if a user has a specific friend. The user profiles are identified by unique usernames, which are strings. # Objective Extend the User class by implementing the following methods: - `add_friend` - `remove_friend` - `is_friend` # Class and Method Specifications **Class Definition:** ```python class User: def __init__(self, username: str): self.username = username self.friends = set() def add_friend(self, friend: User) -> None: pass def remove_friend(self, friend: User) -> None: pass def is_friend(self, friend: User) -> bool: pass ``` **Method Signatures:** ```python def add_friend(self, friend: User) -> None: # Add friend to the user\'s friends set def remove_friend(self, friend: User) -> None: # Remove friend from the user\'s friends set def is_friend(self, friend: User) -> bool: # Return True if friend is in the user\'s friends set, otherwise False ``` **Constraints:** - The username for each user is unique. - A user cannot add themselves as a friend. - Attempting to add the same friend multiple times should not create duplicates. - Removing a user who is not a friend should not raise an error. # Requirements: 1. Each method should manage the `friends` attribute which is a set of User objects. 2. The methods should handle edge cases appropriately, such as adding/removing invalid friends. 3. Ensure efficient operations on the friends set. # Examples: 1. **Example 1:** ```python user1 = User(\\"alice\\") user2 = User(\\"bob\\") user1.add_friend(user2) print(user1.is_friend(user2)) # Output: True user1.remove_friend(user2) print(user1.is_friend(user2)) # Output: False ``` 2. **Example 2:** ```python user1 = User(\\"alice\\") user2 = User(\\"bob\\") print(user1.is_friend(user2)) # Output: False ``` # Notes: 1. Ensure that the `friends` set contains unique User objects and manipulates the data correctly. 2. Implement adequate testing to cover edge cases and basic functionalities. ```python class User: def __init__(self, username: str): self.username = username self.friends = set() def add_friend(self, friend: \'User\') -> None: if friend is not self and friend not in self.friends: self.friends.add(friend) def remove_friend(self, friend: \'User\') -> None: self.friends.discard(friend) def is_friend(self, friend: \'User\') -> bool: return friend in self.friends ```","solution":"class User: def __init__(self, username: str): self.username = username self.friends = set() def add_friend(self, friend: \'User\') -> None: if friend is not self and friend not in self.friends: self.friends.add(friend) def remove_friend(self, friend: \'User\') -> None: self.friends.discard(friend) def is_friend(self, friend: \'User\') -> bool: return friend in self.friends"},{"question":"# Problem Statement You are required to develop a class called `Book`, which represents a book in a library system. A `Book` should adhere to the following requirements: 1. **Initialization**: A book is initialized with a title, author, ISBN, and a genre. 2. **Availability Check**: Implement a method to check if the book is available or currently checked out. 3. **Borrow and Return**: Implement methods to borrow and return the book, ensuring the book can only be borrowed if it is currently available and returned if it is already checked out. # Implementation Details - Create a `Book` class that: - Is initialized with the following attributes: - `title`: a string representing the title of the book. - `author`: a string representing the author of the book. - `isbn`: a string representing the International Standard Book Number. - `genre`: a string representing the genre of the book. - `available`: a boolean indicating whether the book is available, initialized to `True`. - Implement the following methods: - `is_available()`: returns `True` if the book is available, `False` otherwise. - `borrow()`: sets the book to not available if it is currently available, raising an error if the book is already borrowed. - `return_book()`: sets the book to available if it is currently not available, raising an error if the book is already available. # Input & Output Formats - **Input**: The book will be initialized with a title, author, ISBN, and genre. Methods will be called to check availability, borrow, and return the book. - `Book(title: str, author: str, isbn: str, genre: str)` - **Output**: Methods for checking availability, borrowing, and returning the book will not return any value, but may raise errors on invalid operations. # Constraints - All input strings (title, author, ISBN, genre) are non-empty. - The initial availability of a book is always `True`. # Example ```python b = Book(\'The Great Gatsby\', \'F. Scott Fitzgerald\', \'978-0743273565\', \'Fiction\') print(b.is_available()) # Expected output: True b.borrow() print(b.is_available()) # Expected output: False # b.borrow() # Should raise ValueError: Book is already borrowed. b.return_book() print(b.is_available()) # Expected output: True ```","solution":"class Book: def __init__(self, title, author, isbn, genre): self.title = title self.author = author self.isbn = isbn self.genre = genre self.available = True def is_available(self): return self.available def borrow(self): if not self.available: raise ValueError(\\"Book is already borrowed.\\") self.available = False def return_book(self): if self.available: raise ValueError(\\"Book is already available.\\") self.available = True"},{"question":"# Sorting Algorithm Performance Analysis You are given a list of integers and a specific sorting algorithm implementation. Your task is to assess the performance of this sorting algorithm by implementing a function called `analyze_sort_performance` that measures the time taken to sort the list and validate if the sorted output is correct. # Objective Write a function `analyze_sort_performance(sort_function: callable, unsorted_list: List[int]) -> Dict[str, Any]` that: - Sorts the `unsorted_list` using the provided `sort_function`. - Measures the time taken to sort the list. - Validates if the list is correctly sorted. - Returns a dictionary with the sorting time and a boolean indicating whether the sort was successful. # Input/Output - **Input**: - `sort_function` (callable): A function that takes a list of integers and sorts it. - `unsorted_list` (List[int]): A list of integers that need to be sorted. - **Output**: - A dictionary with keys: - `\\"time_taken\\"` (float): The time taken to sort the list in seconds. - `\\"is_sorted\\"` (bool): A boolean indicating whether the list was correctly sorted. # Constraints: - The `unsorted_list` can contain up to 1,000,000 integers. - The `sort_function` should be a valid function that sorts a list of integers. # Performance Requirement: - The validation step should not significantly affect the overall timing measurement. - The time measurement should be precise and accurate to the fraction of a second. # Example Here is an example of how your function might be used: ```python import time def example_sort_function(lst): return sorted(lst) unsorted_list = [3, 1, 2, 5, 4] performance = analyze_sort_performance(example_sort_function, unsorted_list) print(performance) # Output might be {\\"time_taken\\": 0.0001, \\"is_sorted\\": True} ``` # Context Understanding the performance and correctness of sorting algorithms is crucial in computer science. This task assesses both the efficiency and accuracy of sorting algorithms, providing a comprehensive evaluation of their practicality in real-world applications. # Note You do not need to handle input or output via user input, just implement the function `analyze_sort_performance`. Ensure you test the performance only and do not include any additional input/output handling beyond what is specified.","solution":"import time from typing import Callable, List, Dict, Any def analyze_sort_performance(sort_function: Callable[[List[int]], List[int]], unsorted_list: List[int]) -> Dict[str, Any]: start_time = time.time() sorted_list = sort_function(unsorted_list[:]) # avoid mutation of original list end_time = time.time() time_taken = end_time - start_time is_sorted = sorted_list == sorted(unsorted_list) return {\\"time_taken\\": time_taken, \\"is_sorted\\": is_sorted}"},{"question":"# Context You are given a list of integers where each integer represents the height of a building. You need to find the two buildings that trap the most water between them after a significant rainfall. The concept here is similar to the \\"container with most water\\" problem. # Function Signature Write a function called `max_trapped_water` that takes in a list of integers and returns an integer. # Input * A single list of integers ( heights ) where each integer is non-negative and represents the height of a building. - ( 0 leq len(heights) leq 10^5 ) - ( 0 leq heights[i] leq 10^4 ) # Output * Returns the maximum amount of water that can be trapped between any two buildings. # Constraints 1. Your implementation should be efficient with a time complexity of ( O(n) ). 2. Assume that no two buildings are at the same position on the x-axis and there are no negative heights. # Examples * `max_trapped_water([1, 8, 6, 2, 5, 4, 8, 3, 7])` should return `49`. * `max_trapped_water([1, 1])` should return `1`. * `max_trapped_water([4, 3, 2, 1, 4])` should return `16`. * `max_trapped_water([])` should return `0`. * `max_trapped_water([1, 4, 5, 3, 2])` should return `6`. # Implementation Carefully consider how to utilize a two-pointer technique to traverse the heights list from both ends towards the center to achieve the optimal solution efficiency.","solution":"def max_trapped_water(heights): Returns the maximum amount of water that can be trapped between any two buildings represented by heights list. if not heights: return 0 left, right = 0, len(heights) - 1 max_water = 0 while left < right: width = right - left current_height = min(heights[left], heights[right]) current_water = width * current_height max_water = max(max_water, current_water) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"# Coding Assessment Question Sorting algorithms are fundamental in computer science and are crucial for efficiently organizing data. One of the more complex sorting algorithms is the Heap Sort, which uses a binary heap data structure to sort elements. **Objective**: Implement a Heap Sort algorithm to sort a list of integers in non-decreasing order and demonstrate the correctness of your implementation with various test cases. Requirements: 1. **Heap Sort Implementation**: * Construct a Heap Sort function that will sort the given list of integers. * Ensure that your implementation handles typical edge cases, such as an empty list and a list of identical elements. 2. **Heap Operations**: * Implement the necessary heap operations, such as `heapify` and `build_heap`, to support the sorting process. 3. **Validation**: * Write test cases to verify the correctness of your implementation. * Use a variety of input scenarios, including sorted lists, reverse-sorted lists, and lists with duplicate values. Function Signature ```python from typing import List def heap_sort(arr: List[int]) -> None: Perform a heap sort on the provided list of integers in-place. Args: arr : List[int] - The list of integers to be sorted. Returns: None - The sorting is performed in-place. # Your code here ``` Example Usage: ```python # Example test case 1 arr1 = [3, 6, 2, 8, 4, 1] heap_sort(arr1) print(arr1) # Output should be: [1, 2, 3, 4, 6, 8] # Example test case 2 arr2 = [10, 20, 30, 40, 50] heap_sort(arr2) print(arr2) # Output should be: [10, 20, 30, 40, 50] # Example test case 3 arr3 = [2, 2, 2, 2, 2] heap_sort(arr3) print(arr3) # Output should be: [2, 2, 2, 2, 2] ``` Constraints: 1. The list can contain up to 10^5 elements. 2. Each integer in the list is in the range of -10^9 to 10^9. 3. Ensure that the implementation is efficient in both time and space complexity. 4. The sorting should be performed in-place, meaning no additional list should be used for sorting. Context: Heap Sort is a comparison-based sorting technique that sorts an array using the binary heap data structure. This exercise tests your understanding of the heap data structure and its operations, as well as your ability to implement a complex sorting algorithm and ensure its efficiency and correctness.","solution":"from typing import List def heapify(arr: List[int], n: int, i: int) -> None: largest = i # Initialize largest as root left = 2 * i + 1 # left = 2*i + 1 right = 2 * i + 2 # right = 2*i + 2 # Check if left child exists and is greater than root if left < n and arr[largest] < arr[left]: largest = left # Check if right child exists and is greater than root if right < n and arr[largest] < arr[right]: largest = right # Swap and continue heapifying if root is not largest if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # swap heapify(arr, n, largest) def heap_sort(arr: List[int]) -> None: n = len(arr) # Build a maxheap for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) # One by one extract elements for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap heapify(arr, i, 0)"},{"question":"# Question Title: Weather Data Fetcher with Caching # Scenario You are responsible for developing a utility to fetch and display current weather conditions for a specified city using the OpenWeatherMap API. To optimize performance and reduce redundant API calls, implement a caching mechanism that stores the weather data for each city for a specified duration. # Requirements 1. **Data Fetching**: - Use the `requests` library to send a GET request to the OpenWeatherMap API endpoint `http://api.openweathermap.org/data/2.5/weather`. - The function should accept the city name, API key, and a cache duration (in seconds) as input parameters. 2. **Caching**: - Implement an in-memory cache using a dictionary where the key is the city name and the value is a tuple containing the fetched weather data and the timestamp of when the data was fetched. - The function should check the cache before making an API call. If the cached data is older than the specified cache duration, an API call should be made to fetch fresh data. 3. **Error Handling**: - Handle potential HTTP errors (e.g., 404, 500) and network issues (e.g., timeouts). - Raise appropriate exceptions if the API key is missing or invalid. 4. **Data Parsing**: - Parse the JSON response to extract the following weather information: temperature (in Celsius), weather description, and humidity. - Organize the extracted data into a named tuple `WeatherData` with fields `temperature`, `description`, and `humidity`. # Function Signature Implement the following function: ```python from typing import NamedTuple class WeatherData(NamedTuple): temperature: float description: str humidity: int def get_weather(city: str, api_key: str, cache_duration: int = 600) -> WeatherData: pass ``` # Input - `city` (str): The name of the city for which to fetch weather data. - `api_key` (str): The API key required to access the OpenWeatherMap API. - `cache_duration` (int): The duration for which the weather data should be cached, in seconds. # Output The function should return a `WeatherData` named tuple containing: - `temperature`: The current temperature in Celsius. - `description`: A brief description of the current weather conditions. - `humidity`: The current humidity percentage. # Constraints - Use the `requests` library for making API calls. - Implement an in-memory caching mechanism to store and retrieve weather data efficiently. - Handle potential errors gracefully and raise exceptions for invalid input. # Example Usage ```python api_key = \\"your_api_key_here\\" weather = get_weather(\\"New York\\", api_key) fmt = \\"Temperature: {} °C, Description: {}, Humidity: {}%\\" print(fmt.format(weather.temperature, weather.description, weather.humidity)) ``` Expected output: ``` Temperature: 22.5 °C, Description: clear sky, Humidity: 50% ``` Write your implementation of `get_weather` and ensure it meets the requirements specified above.","solution":"import requests import time from typing import NamedTuple class WeatherData(NamedTuple): temperature: float description: str humidity: int # In-memory cache weather_cache = {} def get_weather(city: str, api_key: str, cache_duration: int = 600) -> WeatherData: current_time = time.time() # Check for cached data if city in weather_cache: cached_data, timestamp = weather_cache[city] if current_time - timestamp < cache_duration: return cached_data # Fetch fresh data url = f\\"http://api.openweathermap.org/data/2.5/weather\\" params = { \'q\': city, \'appid\': api_key, \'units\': \'metric\' } try: response = requests.get(url, params=params) response.raise_for_status() data = response.json() temperature = data[\'main\'][\'temp\'] description = data[\'weather\'][0][\'description\'] humidity = data[\'main\'][\'humidity\'] weather_data = WeatherData(temperature, description, humidity) # Update cache weather_cache[city] = (weather_data, current_time) return weather_data except requests.exceptions.HTTPError as http_err: raise Exception(f\\"HTTP error occurred: {http_err}\\") except Exception as err: raise Exception(f\\"Other error occurred: {err}\\")"},{"question":"# Problem Statement: Scenario: A developer is working with string manipulations and needs to create a function that converts an integer to an English-like string representation. Your task is to help the developer by writing an efficient algorithm that converts any integer within a given range to its corresponding English words. Function Signature: ```python def int_to_english(n: int) -> str: pass ``` Input: 1. **n** (int): The integer to be converted into English words. Output: - **words** (str): The English words representation of the integer. Constraints: - -1,000,000 <= `n` <= 1,000,000 Requirements: - The function should handle large inputs efficiently. - Proper error handling for invalid inputs is required. - Pay attention to singular and plural forms in English words. Example: ```python print(int_to_english(123)) # Expected output: \\"one hundred twenty-three\\" print(int_to_english(-45)) # Expected output: \\"negative forty-five\\" print(int_to_english(1000000)) # Expected output: \\"one million\\" ``` Additional Information: - Ensure the function handles negative numbers by prefixing \\"negative\\". - Consider edge cases, such as zero, and plural forms correctly. Helper Functions: Use the following dictionaries and helper functions to assist in converting the numbers: ```python NUMS_1_19 = [ \\"zero\\", \\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\", \\"six\\", \\"seven\\", \\"eight\\", \\"nine\\", \\"ten\\", \\"eleven\\", \\"twelve\\", \\"thirteen\\", \\"fourteen\\", \\"fifteen\\", \\"sixteen\\", \\"seventeen\\", \\"eighteen\\", \\"nineteen\\" ] TENS = [\\"\\", \\"\\", \\"twenty\\", \\"thirty\\", \\"forty\\", \\"fifty\\", \\"sixty\\", \\"seventy\\", \\"eighty\\", \\"ninety\\"] THOUSANDS = [\\"\\", \\"thousand\\", \\"million\\"] def helper(n: int) -> str: if n == 0: return \\"\\" elif n < 20: return NUMS_1_19[n] elif n < 100: return TENS[n // 10] + (\\"\\" if n % 10 == 0 else \\"-\\" + NUMS_1_19[n % 10]) elif n < 1000: return NUMS_1_19[n // 100] + \\" hundred\\" + (\\"\\" if n % 100 == 0 else \\" \\" + helper(n % 100)) def int_to_english(n: int) -> str: if n == 0: return NUMS_1_19[0] if n < 0: return \\"negative \\" + int_to_english(-n) result = \\"\\" for idx, value in enumerate(THOUSANDS): if n % 1000 != 0: result = helper(n % 1000) + (\\"\\" if value == \\"\\" else \\" \\" + value) + (\\"\\" if result == \\"\\" else \\" \\" + result) n //= 1000 if n == 0: break return result.strip() ```","solution":"NUMS_1_19 = [ \\"zero\\", \\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\", \\"six\\", \\"seven\\", \\"eight\\", \\"nine\\", \\"ten\\", \\"eleven\\", \\"twelve\\", \\"thirteen\\", \\"fourteen\\", \\"fifteen\\", \\"sixteen\\", \\"seventeen\\", \\"eighteen\\", \\"nineteen\\" ] TENS = [\\"\\", \\"\\", \\"twenty\\", \\"thirty\\", \\"forty\\", \\"fifty\\", \\"sixty\\", \\"seventy\\", \\"eighty\\", \\"ninety\\"] THOUSANDS = [\\"\\", \\"thousand\\", \\"million\\"] def helper(n: int) -> str: if n == 0: return \\"\\" elif n < 20: return NUMS_1_19[n] elif n < 100: return TENS[n // 10] + (\\"\\" if n % 10 == 0 else \\"-\\" + NUMS_1_19[n % 10]) elif n < 1000: return NUMS_1_19[n // 100] + \\" hundred\\" + (\\"\\" if n % 100 == 0 else \\" \\" + helper(n % 100)) def int_to_english(n: int) -> str: if n == 0: return NUMS_1_19[0] if n < 0: return \\"negative \\" + int_to_english(-n) result = \\"\\" for idx, value in enumerate(THOUSANDS): if n % 1000 != 0: result = helper(n % 1000) + (\\"\\" if value == \\"\\" else \\" \\" + value) + (\\"\\" if result == \\"\\" else \\" \\" + result) n //= 1000 if n == 0: break return result.strip()"},{"question":"# Longest Common Subsequence Context Given two sequences, you need to find the length of their longest common subsequence (LCS). A subsequence is a sequence that appears in the same relative order, but not necessarily consecutively. Objectives 1. Write a function to determine the length of the LCS of two given sequences. 2. Provide an additional function to reconstruct the LCS. Functions 1. **Length of LCS** ```python def lcs_length(seq1, seq2): Determine the length of the longest common subsequence between two sequences. :param seq1: The first sequence (a string or a list) :param seq2: The second sequence (a string or a list) :return: An integer representing the length of the LCS ``` 2. **Reconstruct LCS** ```python def reconstruct_lcs(seq1, seq2, lcs_matrix): Reconstruct the longest common subsequence from the previously computed matrix. :param seq1: The first sequence (a string or a list) :param seq2: The second sequence (a string or a list) :param lcs_matrix: The matrix used to determine the LCS length :return: The longest common subsequence as a list (or string, matching the input sequences) ``` Input - **Sequences**: Two sequences, which can be either strings or lists of characters. Output - The length of the longest common subsequence. - The longest common subsequence itself. Constraints * The length of each sequence will not exceed 1000. * Sequences consist of alphanumeric characters. Example ```python seq1 = \\"AGGTAB\\" seq2 = \\"GXTXAYB\\" length = lcs_length(seq1, seq2) lcs_matrix = [ ... ] # Matrix generated inside lcs_length function lcs_string = reconstruct_lcs(seq1, seq2, lcs_matrix) print(f\\"LCS length: {length}\\") print(f\\"LCS: {lcs_string}\\") ``` Expected output: ``` LCS length: 4 LCS: \\"GTAB\\" ``` Note: The provided matrix in the example is a placeholder—actual implementation must generate and utilize the LCS matrix internally.","solution":"def lcs_length(seq1, seq2): Determine the length of the longest common subsequence between two sequences. :param seq1: The first sequence (a string or a list) :param seq2: The second sequence (a string or a list) :return: An integer representing the length of the LCS m, n = len(seq1), len(seq2) # Create a matrix to store lengths of longest common subsequence lcs_matrix = [[0] * (n + 1) for _ in range(m + 1)] # Build the matrix from bottom up for i in range(m): for j in range(n): if seq1[i] == seq2[j]: lcs_matrix[i + 1][j + 1] = lcs_matrix[i][j] + 1 else: lcs_matrix[i + 1][j + 1] = max(lcs_matrix[i + 1][j], lcs_matrix[i][j + 1]) return lcs_matrix[m][n], lcs_matrix def reconstruct_lcs(seq1, seq2, lcs_matrix): Reconstruct the longest common subsequence from the previously computed matrix. :param seq1: The first sequence (a string or a list) :param seq2: The second sequence (a string or a list) :param lcs_matrix: The matrix used to determine the LCS length :return: The longest common subsequence as a list (or string, matching the input sequences) i, j = len(seq1), len(seq2) lcs = [] while i > 0 and j > 0: if seq1[i - 1] == seq2[j - 1]: lcs.append(seq1[i - 1]) i -= 1 j -= 1 elif lcs_matrix[i - 1][j] >= lcs_matrix[i][j - 1]: i -= 1 else: j -= 1 lcs.reverse() return \'\'.join(lcs) if isinstance(seq1, str) else lcs"},{"question":"# Coding Challenge You are tasked with designing a function to generate all unique combinations of a given length from a list of distinct integers. **Objective**: Write a function `unique_combinations(nums: List[int], length: int) -> List[List[int]]` that: * **Input**: - `nums`: A list of distinct integers (1 ≤ len(nums) ≤ 15). - `length`: The length of each combination, an integer (1 ≤ length ≤ len(nums)). * **Output**: Returns a list of lists, where each sublist is a unique combination of the specified length. The combinations should be sorted in ascending order. # Example Usage: ```python assert unique_combinations([1, 2, 3, 4], 2) == [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]] assert unique_combinations([1, 3, 5], 1) == [[1], [3], [5]] assert unique_combinations([1, 2, 3, 4], 3) == [[1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]] ``` # Constraints: 1. The function should return combinations in lexicographical order. 2. Make use of suitable Python libraries for generating combinations efficiently. # Guidelines: - Utilize the itertools library to generate combinations. - Ensure the function returns results in the required format, sorted correctly. - Handle edge cases such as the combination length being 1 or equal to the length of the input list adeptly. **Note**: Focus on the correct application of combinatorial algorithms and efficient use of standard libraries.","solution":"from itertools import combinations from typing import List def unique_combinations(nums: List[int], length: int) -> List[List[int]]: Generate all unique combinations of a given length from a list of distinct integers and return them sorted in ascending order. return [list(combo) for combo in combinations(sorted(nums), length)]"},{"question":"# Coding Assessment Question Objective: Implement a function to find the longest sequence of consecutive numbers in a list that forms a palindrome. Your function should identify the longest sub-list that is palindromic and return its length. Description: You are given a list of integers. Write a function `longest_palindromic_subsequence` that identifies the longest sub-list within the input list where the sequence is a palindrome, i.e., it reads the same forward and backward. Input: - A list of integers where the length is between 1 and 1000, inclusive. Output: - Return an integer representing the length of the longest palindromic subsequence in the list. Constraints: - If no palindromic subsequence is found, return 0. - The list may have negative and positive integers. Example: ```python input_list = [2, 4, -1, 7, 4, -1, 4, 2] expected_output = 5 # The longest palindromic sequence is [-1, 7, 4, -1] input_list_2 = [1, 2, 3, 4, 5] expected_output_2 = 1 # The longest palindromic sequence is either [1], [2], [3], [4], or [5] ``` Function Signature: ```python def longest_palindromic_subsequence(nums: list) -> int: pass ``` Implementation Instructions: 1. A subsequence is defined as a contiguous sequence of elements within the list. 2. Optimize for readability and performance, considering the constraints. 3. Ensure to check all potential subsequences, employing efficient methods to verify palindrome properties. 4. You may use additional helper functions if necessary.","solution":"def longest_palindromic_subsequence(nums): Function to find the length of the longest palindromic subsequence in the list. n = len(nums) if n == 0: return 0 # Create a table to store lengths of longest palindromic subsequence dp = [[0] * n for _ in range(n)] # All substrings of length 1 are palindromic for i in range(n): dp[i][i] = 1 # Check palindromes of length 2 to n for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if nums[i] == nums[j] and length == 2: dp[i][j] = 2 elif nums[i] == nums[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1]"},{"question":"# Scenario You are a software engineer working on a new web application. One of the features requires the ability to paginate through a large dataset efficiently. Users should be able to specify the number of records per page and retrieve any specific page of data. # Problem Statement Write a function called `paginate_data` that paginates a given list of records. Your function should take in a list of records, the number of records per page, and a page number, and return the records for that specific page. # Function Signature ```python def paginate_data(records: list, records_per_page: int, page_number: int) -> list: pass ``` # Input - `records` (list): A list of records, where each record is represented as a dictionary. - `records_per_page` (int): The number of records to display on each page. - `page_number` (int): The page number (1-indexed) to retrieve. # Output - Returns a list of records for the specified page. If the page number is out of bounds, return an empty list. # Constraints - `records` list can have up to `10^6` records. - `records_per_page` is a positive integer (1 to `10^5`). - `page_number` is a positive integer (1 ≤ page_number ≤ ceil(len(records) / records_per_page)). - The function should handle cases where the list is empty or the page number is out of range. # Examples ```python >>> records = [ {\\"id\\": 1, \\"name\\": \\"Alice\\"}, {\\"id\\": 2, \\"name\\": \\"Bob\\"}, {\\"id\\": 3, \\"name\\": \\"Charlie\\"}, {\\"id\\": 4, \\"name\\": \\"David\\"}, {\\"id\\": 5, \\"name\\": \\"Eve\\"} ] >>> paginate_data(records, 2, 1) [{\\"id\\": 1, \\"name\\": \\"Alice\\"}, {\\"id\\": 2, \\"name\\": \\"Bob\\"}] >>> paginate_data(records, 2, 2) [{\\"id\\": 3, \\"name\\": \\"Charlie\\"}, {\\"id\\": 4, \\"name\\": \\"David\\"}] >>> paginate_data(records, 2, 3) [{\\"id\\": 5, \\"name\\": \\"Eve\\"}] >>> paginate_data(records, 2, 4) [] ``` # Notes Ensure your implementation efficiently calculates the start and end indices based on the page number and records per page.","solution":"def paginate_data(records: list, records_per_page: int, page_number: int) -> list: Paginates the given list of records. Args: records (list): A list of records, where each record is represented as a dictionary. records_per_page (int): The number of records to display on each page. page_number (int): The page number (1-indexed) to retrieve. Returns: list: The records for the specified page. If the page number is out of bounds, return an empty list. if records_per_page < 1 or page_number < 1: return [] start_index = (page_number - 1) * records_per_page end_index = start_index + records_per_page if start_index >= len(records): return [] return records[start_index:end_index]"},{"question":"**Profit Maximization with Ad Budget Allocation** # Background A company wants to allocate its advertising budget across different channels to maximize the profit generated from those channels. Each channel has a specific cost and an estimated profit that can be generated from it. You can decide to allocate the entire budget to one channel, split it among some or all channels or do not allocate any budget to a channel. The goal is to find the maximum profit obtainable with the given budget. # Problem You are to implement a function `max_ad_profit(channels: list[Channel], budget: int) -> int` that calculates the maximum possible profit that can be achieved by distributing the advertising budget across the available channels. # Function Signature ```python from dataclasses import dataclass @dataclass class Channel: cost: int profit: int def max_ad_profit(channels: list[Channel], budget: int) -> int: # Implement your solution here ``` # Input * `channels` (list of `Channel`): A list of channels where each channel is represented with `Channel(cost: int, profit: int)`. * `budget` (int): The total advertising budget. # Output * Returns the maximum profit that can be achieved with the given budget as an integer. # Constraints * `0 <= budget <= 10^9` * `0 <= len(channels) <= 1000` * `1 <= channel.cost, channel.profit <= 1000` # Examples 1. `max_ad_profit([Channel(10, 60), Channel(20, 100), Channel(30, 120)], 50)` should return `220` 2. `max_ad_profit([Channel(5, 30), Channel(10, 60), Channel(15, 90)], 30)` should return `180` 3. `max_ad_profit([Channel(10, 60)], 1)` should return `0` 4. `max_ad_profit([], 50)` should return `0` # Instructions * Ensure your function handles edge cases such as: - An empty list of channels. - A budget of 0. - Channels that cannot be used because their costs are greater than the available budget. * Your implementation should consider each combination of channels to find the optimal profit. * The function should raise a `ValueError` if the budget is negative. # Evaluation Criteria * Correctness: The function returns correct results for all test cases. * Efficiency: The solution is optimized for performance within given constraints. * Edge Case Handling: Proper handling of edge cases and error scenarios. * Code Quality: Clear and readable code with appropriate comments.","solution":"from dataclasses import dataclass @dataclass class Channel: cost: int profit: int def max_ad_profit(channels: list[Channel], budget: int) -> int: if budget < 0: raise ValueError(\\"Budget cannot be negative\\") n = len(channels) dp = [0] * (budget + 1) for i in range(n): for j in range(budget, channels[i].cost - 1, -1): dp[j] = max(dp[j], dp[j - channels[i].cost] + channels[i].profit) return dp[budget]"},{"question":"# Problem Overview Create a function that reads an input text file and counts the frequency of each word, ignoring case and punctuation. The function must then write the frequency counts to an output file, with each word and its respective count on a new line, sorted in descending order of frequency. If two words have the same frequency, they should be sorted alphabetically. # Function Signature ```python def word_frequency_counter(input_file: str, output_file: str) -> None: pass ``` # Input * `input_file`: A string representing the path to the input text file. * `output_file`: A string representing the path to the output text file. # Output * Writes the frequency counts to the output file. Each line of the output file should contain a word (all lowercase) followed by its frequency count, separated by a space. # Constraints 1. The input will always be a valid text file. 2. The words are case-insensitive and punctuation should be ignored. 3. Punctuation includes any non-alphanumeric character. # Examples Assume `input.txt` contains the following text: ``` Hello, world! This is a test. Hello world. ``` Example 1: Input: ```python word_frequency_counter(\'input.txt\', \'output.txt\') ``` Contents of `output.txt`: ``` hello 2 world 2 a 1 is 1 test 1 this 1 ``` # Notes * Ensure that the implementation handles various edge cases such as empty files or files with only punctuation. * Your solution should be efficient, leveraging appropriate data structures for counting and sorting. * Make use of libraries for text processing to simplify handling of punctuation and case folding.","solution":"import re from collections import Counter def word_frequency_counter(input_file: str, output_file: str) -> None: with open(input_file, \'r\') as file: text = file.read().lower() # Use regular expressions to remove punctuation and split the text into words words = re.findall(r\'bw+b\', text) # Count the frequency of each word counter = Counter(words) # Sort the words first by frequency (descending), then alphabetically sorted_words = sorted(counter.items(), key=lambda item: (-item[1], item[0])) # Write the sorted frequency counts to the output file with open(output_file, \'w\') as file: for word, count in sorted_words: file.write(f\\"{word} {count}n\\")"},{"question":"Question: Finding Shortest Path in a Grid # Context You are working on a navigation system for a robot that operates in a rectangular grid. The grid is represented as a 2D matrix where each cell may either be an open space (0) or an obstacle (1). The robot can move up, down, left, or right (but not diagonally) to an adjacent cell. Your task is to find the shortest path from the top-left corner of the grid to the bottom-right corner. # Task Write a function `shortest_path(grid)` that takes a binary matrix as input and returns the length of the shortest path from the top-left to the bottom-right corner, or -1 if no such path exists. # Implementation Details Function Signature ```python def shortest_path(grid: list[list[int]]) -> int: pass ``` Input * `grid`: A list of lists of integers (0s and 1s), representing the 2D binary matrix. * The matrix will have dimensions `MxN` (where `1 <= M, N <= 1000`). Output * An integer representing the length of the shortest path from the top-left to the bottom-right corner. If no valid path exists, return -1. Constraints * The solution should be efficient in terms of time complexity, aiming for O(M * N). * Space complexity should be managed properly, ideally O(M * N) in the worst case. # Example Input ```python grid = [ [0, 0, 0, 1], [0, 1, 0, 0], [0, 0, 1, 0], [1, 0, 0, 0] ] ``` Output ```python 7 ``` Explanation 1. The shortest path from the top-left corner (0, 0) to the bottom-right corner (3, 3) is: (0,0) -> (0,1) -> (1,1) -> (1,2) -> (2,2) -> (2,3) -> (3,3). 2. The total length of this path is 7 steps. # Note * Handle edge cases like when the start or end positions are obstacles, and grids with multiple paths of varying lengths. * Perform bounds checks to avoid accessing invalid indices. * Use appropriate algorithms such as Breadth-First Search (BFS) for finding the shortest path in an unweighted grid.","solution":"from collections import deque def shortest_path(grid: list[list[int]]) -> int: if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() if row == rows - 1 and col == cols - 1: return dist for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < rows and 0 <= c < cols and grid[r][c] == 0 and (r, c) not in visited: visited.add((r, c)) queue.append((r, c, dist + 1)) return -1"},{"question":"# Problem Statement You are developing a library management system and need to implement a function to determine the overdue status of a borrowed book. Each book has a due date, and you need to calculate whether a book is overdue based on the current date and the due date. If a book is overdue, you also need to calculate the number of days it is overdue. Function Signature ```python def check_overdue_status(due_date: str, current_date: str) -> Tuple[bool, int]: pass ``` # Input * `due_date` - a string representing the due date of the book in the format \\"YYYY-MM-DD\\". * `current_date` - a string representing the current date in the format \\"YYYY-MM-DD\\". # Output * Returns a tuple: - The first element is a boolean that is `True` if the book is overdue, and `False` otherwise. - The second element is an integer representing the number of days the book is overdue. If the book is not overdue, this should be `0`. # Constraints * `due_date` and `current_date` will be valid dates in the format \\"YYYY-MM-DD\\". * `due_date` will be a past or present date relative to `current_date`. # Requirements * If `due_date` is after `current_date`, return `(False, 0)`. * Otherwise, return `(True, number_of_overdue_days)`. # Examples ```python >>> check_overdue_status(due_date=\\"2023-09-21\\", current_date=\\"2023-09-25\\") (True, 4) >>> check_overdue_status(due_date=\\"2023-09-21\\", current_date=\\"2023-09-21\\") (False, 0) >>> check_overdue_status(due_date=\\"2023-09-21\\", current_date=\\"2023-09-20\\") (False, 0) >>> check_overdue_status(due_date=\\"2022-12-31\\", current_date=\\"2023-01-10\\") (True, 10) >>> check_overdue_status(due_date=\\"2023-10-05\\", current_date=\\"2023-10-05\\") (False, 0) ``` # Notes * Use standard libraries for date manipulation. * Be mindful of edge cases such as when the current date is the same as the due date, among others.","solution":"from datetime import datetime from typing import Tuple def check_overdue_status(due_date: str, current_date: str) -> Tuple[bool, int]: Determines if a borrowed book is overdue and by how many days. Parameters: - due_date (str): The due date in format \\"YYYY-MM-DD\\". - current_date (str): The current date in format \\"YYYY-MM-DD\\". Returns: - Tuple[bool, int]: A tuple containing a boolean indicating if the book is overdue, and an integer representing the number of days it is overdue. due = datetime.strptime(due_date, \\"%Y-%m-%d\\").date() current = datetime.strptime(current_date, \\"%Y-%m-%d\\").date() if current <= due: return (False, 0) else: overdue_days = (current - due).days return (True, overdue_days)"},{"question":"# Question: Array Sum and Product Write a function that takes a list of integers and returns both the sum and the product of the elements in the list. The function should efficiently compute the sum and product without using built-in sum and product functions, handling large lists gracefully. Function Signature ```python def sum_and_product(nums: list[int]) -> tuple[int, int]: # Your code here ``` # Input - `nums` (list[int]): A list of integers. The list can be empty. # Output - Returns a tuple of two integers: the first being the sum of the elements and the second being the product of the elements. # Constraints - The `nums` list should only contain integer elements. - Handle edge cases such as an empty list by returning (0, 1). # Example ```python assert sum_and_product([1, 2, 3, 4]) == (10, 24) assert sum_and_product([5, -1, 2]) == (6, -10) assert sum_and_product([10]) == (10, 10) assert sum_and_product([]) == (0, 1) assert sum_and_product([0, 1, 2, 3]) == (6, 0) assert sum_and_product([-1, -1, -1, -1]) == (-4, 1) # considering that -1 * -1 * -1 * -1 = 1 ``` # Notes - Make sure to handle both negative numbers and zero properly. - Implement the solution with efficiency in mind to ensure good performance for large input sizes.","solution":"def sum_and_product(nums: list[int]) -> tuple[int, int]: Returns the sum and product of the elements in the list. If the list is empty, returns (0, 1). if not nums: return (0, 1) total_sum = 0 total_product = 1 for num in nums: total_sum += num total_product *= num return (total_sum, total_product)"},{"question":"# Coding Assessment Question You are tasked with creating a function that calculates the distance between two points on a 2D plane. This calculation is fundamental for various applications, ranging from game development to geographical data analysis. # Task Write a function `calculate_distance` that takes four parameters: - `x1` (float): The x-coordinate of the first point. - `y1` (float): The y-coordinate of the first point. - `x2` (float): The x-coordinate of the second point. - `y2` (float): The y-coordinate of the second point. The function should return the Euclidean distance between the two points. Ensure that your function handles various values, including negative coordinates. Function Signature ```python def calculate_distance(x1: float, y1: float, x2: float, y2: float) -> float: ``` Input/Output Formats - The input consists of: - `x1`: A float representing the x-coordinate of the first point. - `y1`: A float representing the y-coordinate of the first point. - `x2`: A float representing the x-coordinate of the second point. - `y2`: A float representing the y-coordinate of the second point. - The output is: - A float representing the Euclidean distance between the two points. Constraints - -10000.0 ≤ `x1`, `y1`, `x2`, `y2` ≤ 10000.0 Performance Requirements - The calculation must be performed in constant time, O(1). - The function should handle floating-point precision correctly. # Example ```python >>> calculate_distance(0, 0, 3, 4) 5.0 >>> calculate_distance(1.5, 2.5, 3.5, 4.5) 2.8284271247461903 >>> calculate_distance(-1, -1, 1, 1) 2.8284271247461903 >>> calculate_distance(0, 0, 0, 0) 0.0 >>> calculate_distance(-3, -4, -1, -2) 2.8284271247461903 >>> calculate_distance(10000.0, 10000.0, -10000.0, -10000.0) 28284.2712474619 ```","solution":"import math def calculate_distance(x1: float, y1: float, x2: float, y2: float) -> float: Calculates the Euclidean distance between two points (x1, y1) and (x2, y2) on a 2D plane. return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)"},{"question":"**Question**: You are developing a program to calculate the amount of solar energy generated by a solar panel given certain parameters. The amount of energy generated by a solar panel depends on the efficiency of the panel, the area of the panel, and the amount of sunlight received per day. Given the equation for solar energy: [ E = eta cdot A cdot H ] Where: - ( E ) is the energy generated in kilowatt-hours (kWh). - ( eta ) is the efficiency of the solar panel (a value between 0 and 1). - ( A ) is the area of the solar panel in square meters (m²). - ( H ) is the average daily sunlight in kilowatt-hours per square meter (kWh/m²/day). **Function Specification**: You need to implement the function `calculate_solar_energy` that calculates one of the three parameters (energy, efficiency, area) given the other two. If a parameter is unknown, it will be provided as zero, and your function should compute and return that value. *Input Parameters*: - `energy` (float): the energy generated in kilowatt-hours. Should be zero if unknown. - `efficiency` (float): the efficiency of the solar panel. Should be zero if unknown. - `area` (float): the area of the solar panel in square meters. Should be zero if unknown. - `sunlight` (float): the average daily sunlight in kilowatt-hours per square meter. *Output*: - A dictionary specifying the calculated value for the parameter with the key as parameter name (`\'energy\'`, `\'efficiency\'`, `\'area\'`) and its corresponding value. *Constraints*: 1. Only one of the parameters will be zero. 2. All input parameters must be non-negative. 3. None of the parameters other than the unknown one will be zero. 4. The efficiency should be a value between 0 and 1. 5. Sunlight per day should be greater than 0. *Example*: ```python >>> calculate_solar_energy(energy=0, efficiency=0.15, area=20, sunlight=5) {\'energy\': 15.0} >>> calculate_solar_energy(energy=18, efficiency=0, area=25, sunlight=4.8) {\'efficiency\': 0.15} >>> calculate_solar_energy(energy=9.6, efficiency=0.12, area=0, sunlight=4) {\'area\': 20.0} ``` *Error Handling*: - Raise a `ValueError` if more than one parameter is zero. - Raise a `ValueError` if any parameter is negative. - Raise a `ValueError` if the efficiency is not between 0 and 1. - Raise a `ValueError` if sunlight is not greater than zero. Implement the function `calculate_solar_energy` to fulfill the requirements above.","solution":"def calculate_solar_energy(energy, efficiency, area, sunlight): Calculate one of the three parameters (energy, efficiency, area) given the other two. Parameters: - energy (float): the energy generated in kilowatt-hours. Should be zero if unknown. - efficiency (float): the efficiency of the solar panel. Should be zero if unknown. - area (float): the area of the solar panel in square meters. Should be zero if unknown. - sunlight (float): the average daily sunlight in kilowatt-hours per square meter. Returns: - A dictionary specifying the calculated value for the unknown parameter. if energy < 0 or efficiency < 0 or area < 0 or sunlight <= 0: raise ValueError(\\"All input parameters must be non-negative and sunlight must be greater than zero.\\") if efficiency != 0 and not (0 <= efficiency <= 1): raise ValueError(\\"Efficiency should be a value between 0 and 1.\\") parameters = [energy, efficiency, area] zero_count = parameters.count(0) if zero_count != 1: raise ValueError(\\"Exactly one of the parameters (energy, efficiency, area) should be zero.\\") if energy == 0: energy = efficiency * area * sunlight return {\'energy\': energy} elif efficiency == 0: efficiency = energy / (area * sunlight) return {\'efficiency\': efficiency} elif area == 0: area = energy / (efficiency * sunlight) return {\'area\': area}"},{"question":"# Question: Sum of Unique Positive Integers Background You are given a list of integers that may contain duplicates and negative numbers. In most scenarios, you are only interested in the unique positive integers within the list. The task is to compute the sum of these unique positive numbers to derive meaningful insights from the data. Objective Implement a function that takes a list of integers and returns the sum of all unique positive integers found within the list. Function Signature ```python def sum_unique_positive(values: list[int]) -> int: pass ``` Input * `values` (list[int]): A list of integers which may include duplicates and negative values. Output * int: The sum of all unique positive integers in the list. Constraints * The `values` list can be empty, in which case you should return 0. * Negative numbers and zeros should not be included in the sum calculation. Example ```python >>> sum_unique_positive([1, -2, 3, 5, 3, 1]) 9 >>> sum_unique_positive([-1, -2, 0, -3]) 0 >>> sum_unique_positive([7, 8, 9, 7, 8, 9]) 24 >>> sum_unique_positive([]) 0 ``` Guidelines * Consider using a set to keep track of unique positive integers found in the list. * Ensure that only positive integers are considered while performing the sum. * Optimize your solution to handle large lists efficiently.","solution":"def sum_unique_positive(values: list[int]) -> int: Returns the sum of all unique positive integers in the list. unique_positives = {x for x in values if x > 0} return sum(unique_positives)"},{"question":"# Scenario: You are responsible for implementing a string similarity measure based on the Jaccard index. This measure should be used to compare two strings and return a similarity score. The Jaccard index is defined as the size of the intersection divided by the size of the union of two sets. For strings, convert them into sets of characters and calculate the Jaccard index. # Requirements: 1. **Jaccard Similarity Function** should calculate the similarity between two strings based on their character sets. # Function Specification: 1. **Jaccard Similarity Function**: ```python def jaccard_similarity(str1: str, str2: str) -> float: Calculates the Jaccard similarity between two strings. Parameters: str1 (str): The first string. str2 (str): The second string. Returns: float: Jaccard similarity score between the two strings. # Your implementation here ``` # Constraints: - **String Length**: 1 <= length of each string <= 1000 - Strings will contain only lowercase English letters (\'a\' to \'z\'). # Performance Requirements: - The function should run in linear time with respect to the combined length of the two strings. # Example Usage: ```python # Strings to compare string1 = \\"hello\\" string2 = \\"jello\\" # Calculate the Jaccard similarity similarity = jaccard_similarity(string1, string2) # Should return 0.6 # Strings with no common characters string3 = \\"abc\\" string4 = \\"xyz\\" # Calculate the Jaccard similarity similarity2 = jaccard_similarity(string3, string4) # Should return 0.0 ``` Ensure that the Jaccard similarity function follows the constraints and performs efficiently.","solution":"def jaccard_similarity(str1: str, str2: str) -> float: Calculates the Jaccard similarity between two strings. Parameters: str1 (str): The first string. str2 (str): The second string. Returns: float: Jaccard similarity score between the two strings. set1 = set(str1) set2 = set(str2) intersection = set1.intersection(set2) union = set1.union(set2) if not union: return 0.0 return len(intersection) / len(union)"},{"question":"# Roth\'s Theorem Finder Scenario: You have been given a task to implement a function that verifies if a given list of integers satisfies Roth\'s theorem. Roth\'s theorem states that for any positive integer ( n ), if a sequence of positive integers has no arithmetic progression of length ( 3 ), then the list must contain ( n ) distinct numbers. An arithmetic progression of length 3 means there exist indices ( i, j, k ) such that ( i < j < k ) and ( a[j] - a[i] = a[k] - a[j] ). Task: Implement a function `has_arithmetic_progression_of_3` to determine whether a given list of integers contains any arithmetic progression of length 3. Function Signature: ```python def has_arithmetic_progression_of_3(numbers: list) -> bool: Check if the given list of integers contains any arithmetic progression of length 3. :param list numbers: List of integers to check. :return bool: True if there exists an arithmetic progression of length 3, otherwise False. Example: >>> has_arithmetic_progression_of_3([1, 5, 7, 10]) True >>> has_arithmetic_progression_of_3([1, 2, 4, 5]) False >>> has_arithmetic_progression_of_3([1, 3, 6]) False >>> has_arithmetic_progression_of_3([1, 4, 7, 10, 13]) True >>> has_arithmetic_progression_of_3([2, 6, 9, 12]) True # Your implementation goes here ``` Constraints: - The input list `numbers` can have length up to (10^5). - The elements of `numbers` will be integers and can be negative. - The function should run in (O(n^2)) time complexity or better. Performance Requirement: - Aim to handle the worst-case input efficiently within the given constraints. Test your implementation with provided examples and additional test cases to ensure its correctness and performance.","solution":"def has_arithmetic_progression_of_3(numbers): Check if the given list of integers contains any arithmetic progression of length 3. :param list numbers: List of integers to check. :return bool: True if there exists an arithmetic progression of length 3, otherwise False. n = len(numbers) s = set(numbers) for i in range(n): for j in range(i + 1, n): diff = numbers[j] - numbers[i] third_element = numbers[j] + diff if third_element in s: return True return False"},{"question":"# Graph Path Finder with Shortest Distance and Path Reconstruction You are required to implement a class `Graph` that represents a weighted, undirected graph. Your task is to ensure the class supports efficient computation of the shortest paths between nodes using Dijkstra\'s algorithm. Additionally, the class should be able to reconstruct the path taken to achieve the shortest distance. Class Definition Implement the `Graph` class with the following methods: - `add_edge(node1: int, node2: int, weight: int)`: Adds an edge between `node1` and `node2` with the given `weight`. - `shortest_path(start: int, end: int) -> Tuple[int, List[int]]`: Computes the shortest distance from `start` node to `end` node and returns a tuple containing the shortest distance and the corresponding path as a list of nodes. If no path exists, return `(float(\'inf\'), [])`. Requirements: 1. The graph should handle up to 1000 nodes and 10000 edges. 2. The graph is undirected, meaning an edge from `node1` to `node2` implies an edge from `node2` to `node1`. 3. Ensure the algorithm efficiently computes the shortest path using Dijkstra\'s algorithm. 4. The `shortest_path` method should correctly reconstruct the path taken to arrive at the shortest distance. Constraints: - All node identifiers are integers. - Edge weights are non-negative integers. ```python from typing import List, Tuple import heapq class Graph: def __init__(self): self.graph = {} def add_edge(self, node1: int, node2: int, weight: int) -> None: if node1 not in self.graph: self.graph[node1] = [] if node2 not in self.graph: self.graph[node2] = [] self.graph[node1].append((node2, weight)) self.graph[node2].append((node1, weight)) def shortest_path(self, start: int, end: int) -> Tuple[int, List[int]]: if start not in self.graph or end not in self.graph: return (float(\'inf\'), []) pq = [(0, start)] distances = {node: float(\'inf\') for node in self.graph} distances[start] = 0 previous_nodes = {node: None for node in self.graph} while pq: current_distance, current_node = heapq.heappop(pq) if current_node == end: break if current_distance > distances[current_node]: continue for neighbor, weight in self.graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(pq, (distance, neighbor)) path = [] if distances[end] != float(\'inf\'): path_node = end while path_node is not None: path.append(path_node) path_node = previous_nodes[path_node] path.reverse() return (distances[end], path) # Example usage: # g = Graph() # g.add_edge(1, 2, 4) # g.add_edge(1, 3, 2) # g.add_edge(2, 3, 5) # g.add_edge(2, 4, 10) # g.add_edge(3, 4, 3) # print(g.shortest_path(1, 4)) # Output: (5, [1, 3, 4]) # print(g.shortest_path(1, 5)) # Output: (float(\'inf\'), []) ``` The above class definition includes the structure and methods needed to create the graph and find the shortest path. Ensure that your implementation satisfies the required functionality and handles edge cases appropriately.","solution":"from typing import List, Tuple import heapq class Graph: def __init__(self): self.graph = {} def add_edge(self, node1: int, node2: int, weight: int) -> None: if node1 not in self.graph: self.graph[node1] = [] if node2 not in self.graph: self.graph[node2] = [] self.graph[node1].append((node2, weight)) self.graph[node2].append((node1, weight)) def shortest_path(self, start: int, end: int) -> Tuple[int, List[int]]: if start not in self.graph or end not in self.graph: return (float(\'inf\'), []) pq = [(0, start)] distances = {node: float(\'inf\') for node in self.graph} distances[start] = 0 previous_nodes = {node: None for node in self.graph} while pq: current_distance, current_node = heapq.heappop(pq) if current_node == end: break if current_distance > distances[current_node]: continue for neighbor, weight in self.graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(pq, (distance, neighbor)) path = [] if distances[end] != float(\'inf\'): path_node = end while path_node is not None: path.append(path_node) path_node = previous_nodes[path_node] path.reverse() return (distances[end], path)"},{"question":"# Coding Assessment Question Context: Understanding data structures such as linked lists and how to reverse them is crucial in programming. Reversing a linked list iteratively or recursively is a common interview problem. Task: Write a function `reverse_linked_list(head: Optional[ListNode]) -> Optional[ListNode]` that reverses a singly linked list. Input: * A linked list, with `head` being the first node of the list (or `None` if the list is empty). Output: * The head of the reversed linked list. Constraints: * The linked list node is defined as: ```python class ListNode: def __init__(self, val: int = 0, next: Optional[\'ListNode\'] = None): self.val = val self.next = next ``` * You are not allowed to use extra space, i.e., the solution should be in-place. Performance Requirements: * The function should run in O(n) time complexity where n is the number of nodes in the linked list. * Space complexity should be O(1), given the constraint on no extra space. Example: ```python def reverse_linked_list(head: Optional[ListNode]) -> Optional[ListNode]: # Your implementation here # Test cases def print_list(node: Optional[ListNode]): while node: print(node.val, end=\\" -> \\") node = node.next print(\\"None\\") head = ListNode(1, ListNode(2, ListNode(3, ListNode(4)))) reversed_head = reverse_linked_list(head) print_list(reversed_head) # Output: 4 -> 3 -> 2 -> 1 -> None head = ListNode(1, ListNode(2)) reversed_head = reverse_linked_list(head) print_list(reversed_head) # Output: 2 -> 1 -> None head = None reversed_head = reverse_linked_list(head) print_list(reversed_head) # Output: None ``` Note: * Focus on correctly handling cases such as an empty linked list or a linked list with only one node. * Ensure the reversed list maintains the correct order of elements and proper handling of node pointers.","solution":"from typing import Optional class ListNode: def __init__(self, val: int = 0, next: Optional[\'ListNode\'] = None): self.val = val self.next = next def reverse_linked_list(head: Optional[ListNode]) -> Optional[ListNode]: prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"**Scenario**: You are contributing to a road navigation system that simulates vehicle movements along a city grid. The system needs to determine the final destination of a vehicle traveling from a starting point following a set of directional commands. **Problem**: Given a start position `(x, y)` on the grid, and a list of directional commands, write a function `final_position` which returns the final coordinates of the vehicle after executing all commands. # Function Signature ```python def final_position(x: int, y: int, commands: List[str]) -> Tuple[int, int]: pass ``` # Input Format * `x` (int): Initial x-coordinate of the vehicle. * `y` (int): Initial y-coordinate of the vehicle. * `commands` (List[str]): A list of string commands where each command represents a direction (\'up\', \'down\', \'left\', \'right\'). # Output Format * **Return** (Tuple[int, int]): A tuple representing the final x and y coordinates of the vehicle. # Constraints * The commands list will have at most 10^4 commands. * Each direction command moves the vehicle exactly 1 unit in the corresponding direction. * The vehicle’s path is based on grid lines; assume no wrap-around or off-grid movement. # Example ```python # Example 1 x, y, commands = 0, 0, [\'up\', \'up\', \'left\', \'down\'] print(final_position(x, y, commands)) # Expected output: (-1, 1) # Example 2 x, y, commands = 10, 10, [\'down\', \'down\', \'right\'] print(final_position(x, y, commands)) # Expected output: (11, 8) ``` # Additional Requirements 1. Ensure the function is efficient and can handle the upper limit of commands within a reasonable time. 2. Implement edge case checks for scenarios where the initial position or commands list may lead to minimal or no movement. 3. Provide unit tests for your function covering typical movement scenarios, edge cases (like empty commands), and large command sets.","solution":"from typing import List, Tuple def final_position(x: int, y: int, commands: List[str]) -> Tuple[int, int]: Determines the final coordinates of the vehicle after executing all commands. Args: x (int): Initial x-coordinate of the vehicle. y (int): Initial y-coordinate of the vehicle. commands (List[str]): A list of string commands where each command represents a direction (\'up\', \'down\', \'left\', \'right\'). Returns: Tuple[int, int]: A tuple representing the final x and y coordinates of the vehicle. for command in commands: if command == \'up\': y += 1 elif command == \'down\': y -= 1 elif command == \'left\': x -= 1 elif command == \'right\': x += 1 return (x, y)"},{"question":"# Scenario You are a software engineer developing a system for a streaming service that needs to determine the most popular times for video streaming, given user activity data. Your task is to implement a function to find overlapping time intervals from user activity logs and determine the time period with the highest number of concurrent users. # Task Implement a function that finds the time interval with the maximum overlap from a given list of user activity periods. # Function Signature ```python def find_peak_activity_period(time_intervals): ``` # Inputs - `time_intervals` (List[Tuple[int, int]]): A list of tuples where each tuple `(start, end)` represents the start and end times of a user\'s activity period. Time is represented as an integer (number of seconds from the beginning of the day). # Outputs - A tuple `(start, end, max_users)` where: - `start` (int): The start time of the time interval with the maximum overlap. - `end` (int): The end time of the time interval with the maximum overlap. - `max_users` (int): The number of users active during this peak period. # Constraints - The list of `time_intervals` will have at most `10^4` elements. - The intervals are within a 24-hour period, so `0 <= start < end <= 86400`. # Example Given the user activity intervals: ``` time_intervals = [ (60, 120), (90, 150), (110, 160), (180, 240) ] ``` The function should output: ``` (110, 120, 3) ``` # Remarks - Ensure your solution efficiently handles the input size within the constraints. - Consider edge cases where intervals might overlap only partially or not overlap at all.","solution":"def find_peak_activity_period(time_intervals): Find the time interval with the highest number of concurrent users. :param time_intervals: List[Tuple[int, int]], list of user activity periods (start, end). :return: Tuple[int, int, int], the start and end time of the interval with the maximum overlap and the number of concurrent users. # Extract all start and end times events = [] for start, end in time_intervals: events.append((start, \'start\')) events.append((end, \'end\')) # Sort events first by time, then by type (\'end\' before \'start\') events.sort(key=lambda x: (x[0], x[1] == \'start\')) max_users = 0 current_users = 0 peak_start = peak_end = 0 for i in range(len(events) - 1): event = events[i] if event[1] == \'start\': current_users += 1 else: current_users -= 1 if current_users > max_users: max_users = current_users peak_start = events[i][0] peak_end = events[i + 1][0] return (peak_start, peak_end, max_users)"},{"question":"Problem Statement You are developing a software module to simulate and validate the connections in a simple resistor network. Write a program that: 1. Takes a list of resistances and a configuration type (`\\"series\\"` or `\\"parallel\\"`). 2. Computes the equivalent resistance of the entire network based on the given configuration. 3. Ensures all provided resistances are positive, raising an appropriate error for invalid inputs. 4. Returns the calculated equivalent resistance in ohms. # Input Format * A list of floating-point numbers representing resistances (in ohms). * A string indicating the configuration type, either `\\"series\\"` or `\\"parallel\\"`. # Output Format * Print one line: The equivalent resistance of the network in ohms. # Constraints * All input resistance values must be positive. * The list of resistances will have at least one resistance value. # Example Input ``` [100.0, 200.0, 300.0] \\"series\\" ``` Output ``` Equivalent Resistance: 600.0 ohms ``` Input ``` [100.0, 200.0, 300.0] \\"parallel\\" ``` Output ``` Equivalent Resistance: 54.54545454545454 ohms ``` # Function Signature The implementation should include a function with the following signature: ```python def equivalent_resistance(resistances: list, configuration: str) -> float: pass ``` # Requirements 1. Make sure that your function handles invalid inputs gracefully by raising a `ValueError` with the message \\"All resistance values must be positive\\". 2. Use the provided input format and constraints to ensure correctness. 3. Ensure that you have clearly written and optimized code for performance. # Additional Notes - For series configuration, the equivalent resistance is the sum of all resistances. - For parallel configuration, the equivalent resistance is calculated using the formula: [ frac{1}{R_{text{eq}}} = sum_{i=1}^{n} frac{1}{R_i} ]","solution":"def equivalent_resistance(resistances, configuration): Computes the equivalent resistance of a resistor network. Parameters: resistances (list): A list of floating-point numbers representing resistances (in ohms). configuration (str): A string indicating the configuration type, either \\"series\\" or \\"parallel\\". Returns: float: The equivalent resistance of the network in ohms. Raises: ValueError: If any resistance value is not positive. # Ensure all resistances are positive if not all(r > 0 for r in resistances): raise ValueError(\\"All resistance values must be positive\\") if configuration == \\"series\\": return sum(resistances) elif configuration == \\"parallel\\": return 1 / sum(1/r for r in resistances) else: raise ValueError(\\"Invalid configuration type. Use \'series\' or \'parallel\'.\\") # Example usage # resistances = [100.0, 200.0, 300.0] # configuration = \\"series\\" # print(\\"Equivalent Resistance:\\", equivalent_resistance(resistances, configuration), \\"ohms\\")"},{"question":"# Array Rotation by K Steps You are to implement a function that rotates elements of an array to the right by `k` steps. This exercise will test your understanding of array manipulations and handling cyclic shifts. **Function Signature:** ```python def rotate_array(arr: List[int], k: int) -> List[int]: ``` **Input:** - `arr`: A list of integers. (Range: 1 <= len(arr) <= 10^5, -10^9 <= arr[i] <= 10^9) - `k`: An integer indicating the number of steps to rotate. (Range: 0 <= k <= 10^5) **Output:** - A list of integers representing the array after it has been rotated to the right by `k` steps. **Constraints:** - The rotation should be performed in place for optimal space complexity. - Consider edge cases where `k` is equal to or greater than the length of the array. **Performance Requirements:** - The function should operate in O(n) time complexity where n is the length of the array. - The function should aim for O(1) additional space complexity, not counting the space for the input array. # Scenario Imagine you are developing a feature for a scheduling application where user events can be shifted right by a given number of time units. Your task is to implement this shifting operation efficiently, so users see their events properly adjusted in the new time slots. # Example ```python >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_array([-1, -100, 3, 99], 2) [3, 99, -1, -100] >>> rotate_array([1], 0) [1] >>> rotate_array([], 3) [] >>> rotate_array([1, 2, 3], 3) [1, 2, 3] ``` **Note:** This task examines your ability to manipulate arrays, manage indices, and handle edge cases with cyclic rotations effectively.","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the elements of the array to the right by k steps. n = len(arr) if n == 0: return arr k = k % n # Ensure k is within the bounds of the array length return arr[-k:] + arr[:-k]"},{"question":"# Question: Implement a Simple Neural Network from Scratch In this task, you will build a simple feedforward neural network with a single hidden layer from scratch using only numpy. This will help you understand the basics of neural networks, including forward pass, loss calculations, and backward pass for parameter updates. Objectives: 1. Implement the following functions to build the neural network: 1. **Initialize Parameters** 2. **Forward Pass** 3. **Compute Loss** 4. **Backward Pass** 5. **Update Parameters** 2. Your implementation should handle edge cases and raise appropriate errors for invalid inputs. Function Specifications: **Initialize Parameters** ```python def initialize_parameters(input_dim: int, hidden_dim: int, output_dim: int) -> dict: Parameters: - input_dim: Integer, dimension of the input features - hidden_dim: Integer, number of units in the hidden layer - output_dim: Integer, dimension of the output layer Returns: - dict: Dictionary containing initialized weights and biases ``` **Forward Pass** ```python def forward_pass(X: np.ndarray, parameters: dict) -> dict: Parameters: - X: Input data of shape (n_samples, input_dim) - parameters: Dictionary containing weights and biases Returns: - dict: Dictionary containing activations and linear combinations for each layer ``` **Compute Loss** ```python def compute_loss(y_true: np.ndarray, y_pred: np.ndarray) -> float: Parameters: - y_true: True class labels of shape (n_samples, output_dim) - y_pred: Predicted probabilities of shape (n_samples, output_dim) Returns: - float: Computed loss value ``` **Backward Pass** ```python def backward_pass(X: np.ndarray, y_true: np.ndarray, parameters: dict, cache: dict) -> dict: Parameters: - X: Input data of shape (n_samples, input_dim) - y_true: True class labels of shape (n_samples, output_dim) - parameters: Dictionary containing weights and biases - cache: Dictionary containing activations and linear combinations for each layer Returns: - dict: Dictionary containing gradients with respect to each parameter ``` **Update Parameters** ```python def update_parameters(parameters: dict, grads: dict, learning_rate: float = 0.01) -> dict: Parameters: - parameters: Dictionary containing weights and biases - grads: Dictionary containing gradients with respect to each parameter - learning_rate: Float, learning rate for parameter updates Returns: - dict: Updated dictionary containing weights and biases ``` Constraints: 1. Ensure the input arrays (`X`, `y_true`) are numpy arrays. 2. Handle mismatched dimensions of input arrays and parameters using appropriate error messages. 3. Ensure values in `y_true` are properly formatted as one-hot encoded arrays. Example Usage: ```python input_dim = 3 hidden_dim = 4 output_dim = 2 # Initialize parameters parameters = initialize_parameters(input_dim, hidden_dim, output_dim) # Input data (2 samples, 3 features) X = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]) # True labels (one-hot encoded, 2 samples, 2 classes) y_true = np.array([[1, 0], [0, 1]]) # Forward pass cache = forward_pass(X, parameters) # Compute loss loss = compute_loss(y_true, cache[\'A2\']) print(loss) # Output: Calculated loss value # Backward pass grads = backward_pass(X, y_true, parameters, cache) # Update parameters parameters = update_parameters(parameters, grads) ``` You need to write these functions from scratch. Efficiently use numpy operations to handle matrix manipulations. Good luck!","solution":"import numpy as np def initialize_parameters(input_dim: int, hidden_dim: int, output_dim: int) -> dict: Initializes weights and biases of the neural network. np.random.seed(42) W1 = np.random.randn(input_dim, hidden_dim) * 0.01 b1 = np.zeros((1, hidden_dim)) W2 = np.random.randn(hidden_dim, output_dim) * 0.01 b2 = np.zeros((1, output_dim)) return {\\"W1\\": W1, \\"b1\\": b1, \\"W2\\": W2, \\"b2\\": b2} def sigmoid(z): return 1 / (1 + np.exp(-z)) def forward_pass(X: np.ndarray, parameters: dict) -> dict: Perform forward pass through the neural network. W1, b1, W2, b2 = parameters[\'W1\'], parameters[\'b1\'], parameters[\'W2\'], parameters[\'b2\'] Z1 = np.dot(X, W1) + b1 A1 = np.tanh(Z1) Z2 = np.dot(A1, W2) + b2 A2 = sigmoid(Z2) cache = {\\"Z1\\": Z1, \\"A1\\": A1, \\"Z2\\": Z2, \\"A2\\": A2} return cache def compute_loss(y_true: np.ndarray, y_pred: np.ndarray) -> float: Computes the loss using binary cross-entropy. m = y_true.shape[0] loss = -1 / m * np.sum(y_true * np.log(y_pred) + (1 - y_true) * np.log(1 - y_pred)) return loss def backward_pass(X: np.ndarray, y_true: np.ndarray, parameters: dict, cache: dict) -> dict: Perform backward pass to compute gradients. m = X.shape[0] W1, W2 = parameters[\'W1\'], parameters[\'W2\'] A1, A2 = cache[\'A1\'], cache[\'A2\'] dZ2 = A2 - y_true dW2 = 1/m * np.dot(A1.T, dZ2) db2 = 1/m * np.sum(dZ2, axis=0, keepdims=True) dA1 = np.dot(dZ2, W2.T) dZ1 = dA1 * (1 - np.power(A1, 2)) dW1 = 1/m * np.dot(X.T, dZ1) db1 = 1/m * np.sum(dZ1, axis=0, keepdims=True) grads = {\\"dW1\\": dW1, \\"db1\\": db1, \\"dW2\\": dW2, \\"db2\\": db2} return grads def update_parameters(parameters: dict, grads: dict, learning_rate: float = 0.01) -> dict: Update parameters using gradient descent. parameters[\'W1\'] -= learning_rate * grads[\'dW1\'] parameters[\'b1\'] -= learning_rate * grads[\'db1\'] parameters[\'W2\'] -= learning_rate * grads[\'dW2\'] parameters[\'b2\'] -= learning_rate * grads[\'db2\'] return parameters"},{"question":"# Problem Statement Given a string `s` consisting of lowercase English letters, determine the length of the longest anagram-free substring. An anagram-free substring is a substring that does not have any two different characters that can be rearranged to form each other. Implement a function `longest_anagram_free_substring(s)` that finds the length of the longest anagram-free substring in `s`. # Input Format - `s` - A string with length in the range [1, 10000], composed of lowercase English letters. # Output Format Return an integer representing the length of the longest anagram-free substring. # Constraints - The string `s` will have a length of at least 1 and at most 10,000. # Example Example 1 ```python print(longest_anagram_free_substring(\\"abcde\\")) ``` Output: ``` 5 ``` Example 2 ```python print(longest_anagram_free_substring(\\"abba\\")) ``` Output: ``` 2 ``` Example 3 ```python print(longest_anagram_free_substring(\\"abcdabc\\")) ``` Output: ``` 4 ``` # Function Signature ```python def longest_anagram_free_substring(s: str) -> int: # Your code here ``` # Notes - The function should efficiently compute the length of the longest anagram-free substring, avoiding excessive recomputation. - Consider using a sliding window or hash map approach to manage and check the substrings within the provided constraints. - Ensure the solution handles edge cases such as single-character strings or strings with repeated characters effectively.","solution":"def longest_anagram_free_substring(s: str) -> int: Returns the length of the longest anagram-free substring in the given string `s`. max_len = 0 start = 0 char_freq = {} for end in range(len(s)): char = s[end] if char not in char_freq: char_freq[char] = 0 char_freq[char] += 1 while char_freq[char] > 1: char_freq[s[start]] -= 1 if char_freq[s[start]] == 0: del char_freq[s[start]] start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"# Palindromic Square Check You are required to find the smallest integer `n` greater than 10 such that `n^2` (n squared) is a palindromic number. A number is called palindromic if it reads the same backward as forward. **Function Signature**: ```python def find_palindromic_square() -> int: pass ``` # Description: - **Input**: No input required. - **Output**: Return the smallest integer `n` > 10 such that `n^2` is palindromic. # Constraints: - You must efficiently search for such an integer `n`. - Careful consideration is needed for checking palindromicity to ensure both correctness and performance. # Examples: 1. `find_palindromic_square()` should return `11` because `11^2 = 121`, which is a palindrome. 2. If the next palindromic square is needed beyond a certain value (e.g., beyond `11`), ensure that your approach can scale to check larger values as necessary. # Notes: - The problem requires generating squares of integers and checking each one for the palindromic property. - Optimization is key, as checking each number one by one without smarter logic may be inefficient for larger ranges. Implement the function `find_palindromic_square` that meets these requirements. Ensure that it is correct and can handle larger integers if necessary.","solution":"def find_palindromic_square() -> int: Finds and returns the smallest integer n greater than 10 such that n^2 is a palindromic number. def is_palindrome(num: int) -> bool: Checks if a given number is a palindrome. s = str(num) return s == s[::-1] n = 11 while True: square = n * n if is_palindrome(square): return n n += 1"},{"question":"# Image Processing - Edge Detection **Context**: You\'re working on a software that processes digital images for computer vision applications. One fundamental task is edge detection, an important step in understanding the structure and features within an image. **Problem Statement**: Write a function `sobel_edge_detection(image: list[list[int]]) -> list[list[int]]` that takes a grayscale image represented as a 2D list of integers and returns a new image where edges are highlighted using the Sobel operator. # Instructions: 1. **Input**: - `image`: A 2D list of integers representing a grayscale image, where each integer\'s value ranges from 0 (black) to 255 (white). ```python image: list[list[int]] = [ [intensity_11, intensity_12, ..., intensity_1m], [intensity_21, intensity_22, ..., intensity_2m], ..., [intensity_n1, intensity_n2, ..., intensity_nm] ] ``` 2. **Output**: - A 2D list of the same dimensions as the input, where each element represents the intensity of the detected edges at that pixel, also ranging from 0 to 255. 3. **Constraints**: - The input image will have dimensions ( n times m ) where ( 1 leq n, m leq 1000 ). - The pixel intensities will be between 0 and 255 inclusively. # Examples: Input: ```python image = [ [255, 255, 255, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 255, 255, 255] ] ``` Output: ```python [ [0, 255, 255, 0], [255, 255, 255, 255], [255, 255, 255, 255], [0, 255, 255, 0] ] ``` Input: ```python image = [ [0, 0, 0, 0], [0, 255, 255, 0], [0, 255, 255, 0], [0, 0, 0, 0] ] ``` Output: ```python [ [0, 255, 255, 0], [255, 0, 0, 255], [255, 0, 0, 255], [0, 255, 255, 0] ] ``` Handle errors gracefully: ```python sobel_edge_detection([]) # Should raise ValueError: The image is empty or invalid. ``` # Notes: 1. The Sobel operator uses two 3x3 kernels to calculate the gradient in the x and y directions, typically represented as follows: ```python Gx = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]] Gy = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]] ``` 2. Convolve these kernels over the image to compute the gradient magnitude at each pixel, then normalize the results to the range [0, 255]. 3. Ensure to handle the borders of the image properly, either by padding or ignoring the edges.","solution":"def sobel_edge_detection(image): if not image or not image[0]: raise ValueError(\\"The image is empty or invalid.\\") import math # Sobel operator kernels Gx = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]] Gy = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]] rows, cols = len(image), len(image[0]) new_image = [[0 for _ in range(cols)] for _ in range(rows)] for i in range(1, rows - 1): for j in range(1, cols - 1): gx = sum(Gx[m][n]*image[i+m-1][j+n-1] for m in range(3) for n in range(3)) gy = sum(Gy[m][n]*image[i+m-1][j+n-1] for m in range(3) for n in range(3)) magnitude = math.sqrt(gx**2 + gy**2) new_image[i][j] = min(int(magnitude), 255) return new_image"},{"question":"**Topological Sorting Using Kahn\'s Algorithm** Context: Topological Sorting of a directed acyclic graph (DAG) is a linear ordering of its vertices such that for every directed edge `uv` from vertex `u` to vertex `v`, `u` comes before `v` in the ordering. Kahn\'s algorithm is an efficient method to perform a topological sort using the concept of in-degree of vertices. Problem Statement: Given a directed acyclic graph described by vertices `n` and edges `m`, your task is to implement Kahn\'s algorithm and output one possible topological ordering of the graph. Input: - The first line contains two integers `n` and `m` (`0 <= n <= 10000`, `0 <= m <= 50000`), representing the number of vertices and edges respectively. - The next `m` lines each contain two integers `u` and `v` (`0 <= u, v < n`) indicating a directed edge from vertex `u` to vertex `v`. Output: - Output should be a single line containing the vertices in one possible topological order, separated by spaces. - If there are multiple valid topological orderings, output any one of them. Constraints: - The graph is guaranteed to be a DAG (does not contain any cycles). - Assume all vertex numbers are indexed from 0 to n-1. Example: **Input:** ``` 6 6 5 2 5 0 4 0 4 1 2 3 3 1 ``` **Output:** ``` 4 5 0 2 3 1 ``` (Another valid output could be: `5 4 2 0 3 1` or any other valid topological ordering) # Implementation Requirements: - You need to implement the main method `topological_sort()` that returns the topological order as a list of vertices. - Ensure robustness to edge cases such as disconnected graphs and graphs with no edges. Good luck!","solution":"from collections import deque, defaultdict def topological_sort(n, m, edges): in_degree = [0] * n adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) in_degree[v] += 1 queue = deque([i for i in range(n) if in_degree[i] == 0]) topological_order = [] while queue: node = queue.popleft() topological_order.append(node) for neighbor in adj_list[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) return topological_order def parse_input(input_string): lines = input_string.strip().split(\'n\') n, m = map(int, lines[0].split()) edges = [list(map(int, line.split())) for line in lines[1:]] return n, m, edges"},{"question":"**Problem Statement**: You are tasked with automating a simple task management system, where tasks can be added, removed, marked as complete, and listed out. Each task has a description and a status (either \'incomplete\' or \'complete\'). Write a Python class `TaskManager` that has the following methods: 1. `add_task(description: str) -> None`: Adds a new task with the given description and marks it as \'incomplete\'. 2. `remove_task(description: str) -> bool`: Removes the task with the given description. Returns True if the task was successfully removed, or False if the task was not found. 3. `complete_task(description: str) -> bool`: Marks the task with the given description as \'complete\'. Returns True if the task was successfully marked, or False if the task was not found. 4. `list_tasks() -> list[tuple[str, str]]`: Returns a list of all tasks as tuples, where each tuple contains the task description and its status. **Function Signature**: ```python class TaskManager: def add_task(self, description: str) -> None: pass def remove_task(self, description: str) -> bool: pass def complete_task(self, description: str) -> bool: pass def list_tasks(self) -> list[tuple[str, str]]: pass ``` **Example**: ```python tm = TaskManager() tm.add_task(\\"Buy groceries\\") tm.add_task(\\"Answer emails\\") tm.complete_task(\\"Buy groceries\\") tm.list_tasks() # Output: [(\\"Buy groceries\\", \\"complete\\"), (\\"Answer emails\\", \\"incomplete\\")] tm.remove_task(\\"Answer emails\\") tm.list_tasks() # Output: [(\\"Buy groceries\\", \\"complete\\")] ``` **Constraints/Limitations**: - If `add_task` is called with a description that already exists, it should not add the task again. - It is guaranteed that `description` for each task will be unique and will be a non-empty string. - If `complete_task` or `remove_task` is called with a description that does not exist, they should return False. - Ensure that your implementation is efficient and avoids unnecessary operations. **Additional Notes**: - Use appropriate data structures to maintain and manage the tasks. - Consider edge cases, such as attempting to complete or remove tasks that do not exist.","solution":"class TaskManager: def __init__(self): self.tasks = {} def add_task(self, description: str) -> None: if description not in self.tasks: self.tasks[description] = \'incomplete\' def remove_task(self, description: str) -> bool: if description in self.tasks: del self.tasks[description] return True return False def complete_task(self, description: str) -> bool: if description in self.tasks: self.tasks[description] = \'complete\' return True return False def list_tasks(self) -> list[tuple[str, str]]: return list(self.tasks.items())"},{"question":"# Coding Challenge Question: Sum of All Subarray Minimums **Context**: In array manipulation, finding the sum of the minimum values of all possible subarrays of an array can be an interesting and challenging problem. This problem tests your ability to efficiently compute this sum using appropriate data structures and algorithms. Problem Statement Implement a function `sum_of_subarray_mins(arr: list[int]) -> int` that takes an array of integers and returns the sum of the minimum values of all possible subarrays. For efficiency, you must aim for a solution that is better than the brute-force approach. Input * A list of integers. Example: `[3, 1, 2, 4]`. Output * An integer representing the sum of the minimum values of all subarrays. Constraints * The array length (`n`) can be 1 <= n <= 10^4. * Each element (`arr[i]`) is an integer such that 1 <= arr[i] <= 10^5. Expectations 1. Efficient computation of the sum of subarray minimums. 2. Correct usage of data structures and algorithms to optimize performance. 3. Handling of arrays with different lengths and values properly. Example ```python >>> sum_of_subarray_mins([3, 1, 2, 4]) 17 # Explanation: # All subarrays of [3,1,2,4] are: # [3] -> 3 # [1] -> 1 # [2] -> 2 # [4] -> 4 # [3,1] -> 1 # [1,2] -> 1 # [2,4] -> 2 # [3,1,2] -> 1 # [1,2,4] -> 1 # [3,1,2,4] -> 1 # Sum: 3+1+2+4+1+1+2+1+1+1 = 17 >>> sum_of_subarray_mins([11, 81, 94, 43, 3]) 444 ``` Implementation Challenge * Consider utilizing monotonic stacks to efficiently find the sum. * Optimize your solution to handle arrays up to the maximum constraint. Feel free to define helper functions if needed.","solution":"def sum_of_subarray_mins(arr): Returns the sum of the minimum values of all possible subarrays of input array. MOD = 10**9 + 7 n = len(arr) # Initialize previous and next less element arrays prev = [-1] * n next = [n] * n # Monotonic stack for finding previous less element stack = [] for i in range(n): while stack and arr[stack[-1]] > arr[i]: stack.pop() if stack: prev[i] = stack[-1] stack.append(i) # Monotonic stack for finding next less element stack = [] for i in range(n-1, -1, -1): while stack and arr[stack[-1]] >= arr[i]: stack.pop() if stack: next[i] = stack[-1] stack.append(i) # Calculate the sum of subarray minimums result = 0 for i in range(n): result = (result + arr[i] * (i - prev[i]) * (next[i] - i)) % MOD return result"},{"question":"# Context and Problem Statement You are a software developer tasked with implementing a part of a permissions system. In this system, users and roles have hierarchical relationships, and permissions propagate in the hierarchy. Specifically, a user inherits permissions from their direct role, and a role can inherit permissions from its parent role. Given this structure, you need to determine the effective permissions for a user. # Task Implement a function `effective_permissions(permissions: List[str], user_roles: Dict[str, List[str]], role_hierarchy: Dict[str, str]) -> Dict[str, Set[str]]` that takes: 1. **permissions** (List[str]): A list of strings representing the permissions in the system. 2. **user_roles** (Dict[str, List[str]]): A dictionary where each key is a user and the value is a list of roles assigned to that user. 3. **role_hierarchy** (Dict[str, str]): A dictionary where each key is a role, and the value is the parent role from which it inherits permissions. Note that roles at the top of the hierarchy will not appear as keys, meaning they have no parent roles. The function should return a dictionary where each key is a user and the value is the set of all effective permissions for that user. # Input and Output Formats **Input:** * A list of strings `permissions`. * A dictionary `user_roles`. * A dictionary `role_hierarchy`. **Output:** * A dictionary where each key is a user and the value is a set of strings representing the effective permissions. # Constraints * `1 <= len(permissions) <= 10^4` * `1 <= len(user_roles), len(role_hierarchy) <= 10^3` * Strings in `permissions` are distinct and non-empty. * Each user has at least one role. * The role hierarchy is acyclic. # Example ```python permissions = [\\"read\\", \\"write\\", \\"execute\\"] user_roles = { \\"Alice\\": [\\"Admin\\"], \\"Bob\\": [\\"User\\"], \\"Charlie\\": [\\"User\\", \\"Manager\\"] } role_hierarchy = { \\"User\\": \\"Guest\\", \\"Manager\\": \\"User\\", \\"Admin\\": \\"Manager\\" } # Assume permissions are granted as follows: # Guest: {\\"read\\"} # User: {\\"write\\"} # Manager: {\\"execute\\"} # Admin: {\\"read\\", \\"write\\", \\"execute\\"} assert effective_permissions(permissions, user_roles, role_hierarchy) == { \\"Alice\\": {\\"read\\", \\"write\\", \\"execute\\"}, \\"Bob\\": {\\"read\\", \\"write\\"}, \\"Charlie\\": {\\"read\\", \\"write\\", \\"execute\\"} } ``` # Explanation: 1. Alice has the role \\"Admin\\" and inherits permissions from \\"Manager\\", \\"User\\", and \\"Guest\\". 2. Bob has the role \\"User\\" and inherits permissions from \\"Guest\\". 3. Charlie has the roles \\"User\\" and \\"Manager\\" and inherits permissions from \\"Guest\\". # Follow-up: Provide an analysis of the function\'s time and space complexity, considering the potential size and structure of the role hierarchy and user roles.","solution":"def effective_permissions(permissions, user_roles, role_hierarchy): Returns a dictionary of users with their effective permissions. def get_permissions_for_role(role, role_hierarchy, memo): if role in memo: return memo[role] perms = permissions.get(role, set()) if role in role_hierarchy: perms.update(get_permissions_for_role(role_hierarchy[role], role_hierarchy, memo)) memo[role] = perms return perms memo = {} user_effective_permissions = {} for user, roles in user_roles.items(): effective_perms = set() for role in roles: effective_perms.update(get_permissions_for_role(role, role_hierarchy, memo)) user_effective_permissions[user] = effective_perms return user_effective_permissions"},{"question":"# Coding Challenge: You are tasked with developing a function to merge two sorted lists into one sorted list. The function should handle both integers and floating-point numbers and should maintain the order after merging. # Objective: Write a function `merge_sorted_lists` that: 1. Takes two lists of sorted elements that can include both integers and floating-point numbers. 2. Returns a single list containing all the elements from both input lists in ascending order. Expected Input and Output: * **Input**: * Two lists of numbers (integers and/or floating). * **Output**: * A single sorted list containing all the elements in ascending order. Performance Requirements: * The function should efficiently merge the lists with a time complexity of O(n + m) where `n` and `m` are the lengths of the input lists. * The space complexity should be O(n + m) due to the merged output list. Constraints and Considerations: * Assume both input lists are already sorted. * Consider edge cases such as one or both lists being empty. * Ensure the solution works efficiently for both small and large lists. * Validate the inputs to ensure they are lists containing only numbers. # Example: ```python def merge_sorted_lists(list1: list, list2: list) -> list: pass print(merge_sorted_lists([1, 3.5, 5], [2, 4, 6.0])) # Expected output: [1, 2, 3.5, 4, 5, 6.0] print(merge_sorted_lists([-10, -3, 0], [-5, 1.5, 7])) # Expected output: [-10, -5, -3, 0, 1.5, 7] print(merge_sorted_lists([], [2, 4.5, 6])) # Expected output: [2, 4.5, 6] print(merge_sorted_lists([1.1, 2.2], [])) # Expected output: [1.1, 2.2] ``` # Note: * Provide a detailed explanation of your implementation choices and any assumptions made.","solution":"def merge_sorted_lists(list1, list2): Merge two sorted lists into one sorted list. Args: list1: List of sorted numbers (integers and/or floats). list2: List of sorted numbers (integers and/or floats). Returns: A single list containing all the elements from both input lists in ascending order. # Validate input if not all(isinstance(x, (int, float)) for x in list1 + list2): raise ValueError(\\"Both input lists must contain only numbers.\\") merged_list = [] i, j = 0, 0 n, m = len(list1), len(list2) # Traverse both lists and append smaller element to the merged_list while i < n and j < m: if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Append remaining elements of list1 while i < n: merged_list.append(list1[i]) i += 1 # Append remaining elements of list2 while j < m: merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Problem: K-th Largest Element in an Array Given an integer array `nums` and an integer `k`, implement a function to return the k-th largest element in the array. Note that it is the k-th largest element in the sorted order, not the k-th distinct element. # Function Signature ```python def find_kth_largest(nums: List[int], k: int) -> int: ``` # Input * A list of integers `nums` with size `n` (1 ≤ n ≤ 10^5), where each element in the array is in the range `[-10^4, 10^4]`. * An integer `k` (1 ≤ k ≤ n). # Output * Return a single integer: the k-th largest element in the array. # Examples ```python >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4 >>> find_kth_largest([1], 1) 1 ``` # Constraints * Time complexity should be within O(n log n) to meet the requirements for `n` up to `10^5`. # Hints 1. Consider sorting the array and then finding the element at the appropriate index. 2. There are more efficient algorithms like using a min-heap of size `k` to solve the problem in O(n log k) time.","solution":"from typing import List def find_kth_largest(nums: List[int], k: int) -> int: Returns the k-th largest element in the specified list of numbers. nums.sort(reverse=True) return nums[k-1]"},{"question":"# Length of Longest Substring Without Repeating Characters In this problem, you are asked to determine the length of the longest substring in a given string that does not have any repeating characters. This is a common problem in string manipulation and is often used to test understanding of sliding window techniques and hash tables. Your task is to implement the function `length_of_longest_substring(s: str) -> int` that returns the length of the longest substring without repeating characters in the provided string. Input - `s`: A string consisting of alphanumeric characters and possibly some special characters. It is guaranteed that the string has a length [0, 10^4]. Output - An integer representing the length of the longest substring without repeating characters. Examples ```python >>> length_of_longest_substring(\\"abcabcbb\\") 3 # Explanation: The answer is \\"abc\\", which the length is 3. >>> length_of_longest_substring(\\"bbbbb\\") 1 # Explanation: The answer is \\"b\\", with the length of 1. >>> length_of_longest_substring(\\"pwwkew\\") 3 # Explanation: The answer is \\"wke\\", with the length of 3. >>> length_of_longest_substring(\\"\\") 0 # Explanation: The input string is empty, so the length of the longest substring is 0. ``` Constraints - The function should be efficient in terms of time and space complexity. - The solution should handle edge cases such as an empty string gracefully. Notes - You can use data structures like sets or dictionaries to keep track of the characters in the current window. - Utilize a sliding window approach to ensure that the solution runs in linear time.","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. # Dictionary to store the last positions of each character char_index_map = {} # Initialize the start of the window and the max length start = 0 max_length = 0 for end, char in enumerate(s): # If the character is found in the dictionary and is inside the current window if char in char_index_map and char_index_map[char] >= start: # Move the start to the right of the last position of the character start = char_index_map[char] + 1 # Update the current character\'s last position char_index_map[char] = end # Update the max length max_length = max(max_length, end - start + 1) return max_length"},{"question":"# Problem Statement You need to implement a class `IntervalSet` that manages a dynamic set of integer intervals, supporting the following operations: 1. **Initialization**: Create an empty interval set. 2. **Add Interval**: Add a closed interval [start, end] to the set. 3. **Remove Interval**: Remove a specific interval [start, end] from the set. 4. **Check Overlap**: Determine if a given interval overlaps with any interval in the set. 5. **Merge Overlapping Intervals**: Merge all overlapping intervals in the set and return the new set of intervals. # Function Signatures ```python class IntervalSet: def __init__(self) -> None: Initializes an empty set of intervals. def add_interval(self, start: int, end: int) -> None: Adds a closed interval [start, end] to the set. def remove_interval(self, start: int, end: int) -> None: Removes the specific interval [start, end] from the set. def check_overlap(self, start: int, end: int) -> bool: Returns True if the interval [start, end] overlaps with any interval in the set, False otherwise. def merge_intervals(self) -> list[tuple[int, int]]: Merges all overlapping intervals and returns the new set of intervals as a list of tuples. ``` # Input Constraints - Intervals are defined by integers where start <= end. - Intervals can have negative and positive bounds. - Operations on intervals must be efficient to handle up to `10^5` intervals. # Example Usage ```python # Initialize the interval set is_set = IntervalSet() # Add intervals is_set.add_interval(1, 5) is_set.add_interval(10, 15) is_set.add_interval(20, 25) # Check overlap print(is_set.check_overlap(3, 6)) # Output: True print(is_set.check_overlap(6, 9)) # Output: False # Remove interval is_set.remove_interval(10, 15) print(is_set.check_overlap(10, 15)) # Output: False # Merge intervals is_set.add_interval(12, 18) is_set.add_interval(6, 8) print(is_set.merge_intervals()) # Output: [(1, 8), (12, 18), (20, 25)] ``` # Constraints - The class should handle edge cases such as adding an existing interval, removing a non-existing interval, and merging non-overlapping intervals efficiently. - Ensure your implementation considers performance, especially for merging and checking overlaps. # Implementation Notes - Focus on efficient data structures that allow for quick interval addition, removal, and overlap checks. - Pay attention to how intervals intersect and merge logically to avoid redundant operations.","solution":"class IntervalSet: def __init__(self) -> None: Initializes an empty set of intervals. self.intervals = [] def add_interval(self, start: int, end: int) -> None: Adds a closed interval [start, end] to the set. self.intervals.append((start, end)) self.intervals.sort() def remove_interval(self, start: int, end: int) -> None: Removes the specific interval [start, end] from the set. if (start, end) in self.intervals: self.intervals.remove((start, end)) def check_overlap(self, start: int, end: int) -> bool: Returns True if the interval [start, end] overlaps with any interval in the set, False otherwise. for interval in self.intervals: if max(start, interval[0]) <= min(end, interval[1]): return True return False def merge_intervals(self) -> list: Merges all overlapping intervals and returns the new set of intervals as a list of tuples. if not self.intervals: return [] merged = [] self.intervals.sort() current_start, current_end = self.intervals[0] for start, end in self.intervals[1:]: if start <= current_end: current_end = max(current_end, end) else: merged.append((current_start, current_end)) current_start, current_end = start, end merged.append((current_start, current_end)) self.intervals = merged return merged"},{"question":"**Context**: You are developing a text-based game where a player can explore a grid-based 2D world. Each cell in the grid can either be an empty space or an obstacle. The player can move up, down, left, or right, but cannot move into cells that contain obstacles. Your task is to implement a pathfinding feature that allows the player to determine if there is a valid path from their current position to a target position within the grid. **Objective**: Implement a pathfinding algorithm (Breadth-First Search) to determine if a path exists from the player\'s current position to a target position in the grid. **Requirements**: 1. **Function Signature**: ```python def is_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool: ... ``` 2. **Functionality**: * Use Breadth-First Search (BFS) to explore possible paths from the start position to the target position. 3. **Implementation Details**: * The grid is represented as a 2D list of integers, where `0` represents an empty cell and `1` represents an obstacle. * The start and end positions are tuples `(x, y)` indicating the coordinates within the grid. * Return `True` if there is a valid path from the start to the end, and `False` otherwise. * Ensure that movements are restricted to up, down, left, and right directions only. # Input and Output Formats * **Input**: * `grid` (List[List[int]]): A 2D list representing the world\'s grid. * `start` (Tuple[int, int]): The starting coordinates of the player. * `end` (Tuple[int, int]): The target coordinates the player wants to reach. * **Output**: * A boolean indicating whether there is a valid path from the start to the end. # Constraints 1. Assume inputs are all valid. 2. Grid will be non-empty and rectangular. 3. Start and end positions will be valid grid coordinates. # Example ```python grid = [ [0, 0, 0, 1], [1, 1, 0, 1], [0, 0, 0, 0], [0, 1, 1, 0] ] start = (0, 0) end = (3, 3) print(is_path(grid, start, end)) # Expected: True (a valid path exists) ``` 1. **Explanation**: * Initial position: (0, 0) * Possible path: (0, 0) -> (1, 0) -> (2, 0) -> (2, 1) -> (2, 2) -> (2, 3) -> (3, 3) # Additional Notes - Ensure your solution handles edge cases such as start position being the same as the end position and grids with no valid paths.","solution":"from typing import List, Tuple from collections import deque def is_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool: Uses Breadth-First Search (BFS) to determine if there is a valid path from start to end in a grid where 0 represents an empty cell and 1 represents an obstacle. :param grid: List[List[int]], representing the grid (2D matrix) :param start: Tuple[int, int], representing the starting coordinates (x, y) :param end: Tuple[int, int], representing the target coordinates (x, y) :return: bool, True if there is a valid path from start to end, otherwise False if start == end: return True rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right queue = deque([start]) visited[start[0]][start[1]] = True while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and grid[nx][ny] == 0: if (nx, ny) == end: return True queue.append((nx, ny)) visited[nx][ny] = True return False"},{"question":"# Scenario You are developing a data processing application that deals with time-series data for various sensors. One of the features requires detecting peaks in the data to identify significant events. A peak is defined as a data point that is strictly greater than its immediate neighbors. # Task Write a function `detect_peaks` that takes a list of integers representing the time-series data and returns a list of indices where peaks occur. Assume that the time-series data has at least three data points. # Function Signature ```python def detect_peaks(data: list[int]) -> list[int]: ``` # Input - `data`: A list of integers representing the time-series data. # Output - Returns a list of integers representing the indices of the peaks in the given list. # Constraints - The input list will always have a minimum length of 3. - Peaks cannot occur at the first or last position of the list. # Examples ```python print(detect_peaks([1, 2, 3, 2, 1])) # Output: [2] print(detect_peaks([0, 6, 0, 6, 0])) # Output: [1, 3] print(detect_peaks([1, 2, 2, 1, 3, 2, 3, 1, 2, 1])) # Output: [4, 6, 8] print(detect_peaks([1, 2, 3, 4, 5, 6, 7, 8, 9])) # Output: [] ``` # Notes - The first and last elements of the list cannot be peaks since they do not have both neighbors. - Peaks are only counted if they are strictly greater than their neighbors, not equal to them. - Optimal performance is appreciated but correctness and clarity are the primary goals. - Think about edge cases such as consecutive elements being equal or the presence of multiple peaks close to each other.","solution":"def detect_peaks(data: list[int]) -> list[int]: Detect peaks in a list of integers representing time-series data. A peak is a data point that is strictly greater than its immediate neighbors. Parameters: data: A list of integers representing the time-series data. Returns: A list of integers representing the indices of the peaks in the given list. peaks = [] for i in range(1, len(data) - 1): if data[i] > data[i - 1] and data[i] > data[i + 1]: peaks.append(i) return peaks"},{"question":"Title: Find the Missing Number in a Consecutive Integer Sequence # Description You are to write a function that finds the missing number from a given list of `n` consecutive integers, starting from `1` up to `n+1`. The input list will contain `n` integers, and exactly one of these integers will be missing. Your function should handle cases where the input is not a list of integers by raising a `ValueError` with the message \\"Input must be a list of integers.\\" # Function Signature ```python def find_missing_number(nums: list) -> int: pass ``` # Input * `nums` (list): A list of `n` consecutive integers from `1` to `n+1`, with exactly one integer missing. # Output * Returns the missing integer. # Constraints * The function should only accept a list of integers. * If the input `nums` is not a list of integers, raise a `ValueError` with the message \\"Input must be a list of integers\\". * Aim to solve the problem in linear time O(n) and constant space O(1). # Examples ```python find_missing_number([1, 2, 4, 5, 6]) # returns 3 find_missing_number([2, 3, 4, 6, 7, 8, 1, 5, 9]) # returns 10 find_missing_number([1, 3]) # returns 2 find_missing_number([3, 4, 1, 2]) # returns 5 ``` # Notes * Make sure to test the function with edge cases such as the smallest and largest possible inputs. * Consider the use of the sum formula for the first `n` natural numbers to achieve optimal performance.","solution":"def find_missing_number(nums): Returns the missing number from the list of n consecutive integers starting from 1 to n+1. # Validate input if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums): raise ValueError(\\"Input must be a list of integers\\") n = len(nums) + 1 # Calculate the expected sum of first n natural numbers (1 through n) expected_sum = n * (n + 1) // 2 # Calculate the actual sum of numbers in the list actual_sum = sum(nums) # The missing number is the difference between the expected sum and actual sum return expected_sum - actual_sum"},{"question":"# Question Given an integer array `arr` and an integer `k`, write a Python function `find_top_k_frequent(arr: List[int], k: int) -> List[int]`. This function should return the `k` most frequent elements in the array. If there is a tie for the `k`th position in terms of frequency, return the elements with the smallest values. # Input - An integer array `arr` (1 ≤ len(arr) ≤ 10^5, -10^4 ≤ arr[i] ≤ 10^4) - An integer `k` (1 ≤ k ≤ len(arr)) # Output - Return a list containing `k` integers. # Example ```python >>> find_top_k_frequent([1, 1, 1, 2, 2, 3], 2) [1, 2] ``` ```python >>> find_top_k_frequent([4, 4, 4, 3, 3, 2, 1, 1], 3) [4, 1, 3] ``` # Explanation - In the first example, the array `[1, 1, 1, 2, 2, 3]` has `1` with a frequency of 3, `2` with a frequency of 2, and `3` with a frequency of 1. The top 2 frequent elements are `[1, 2]`. - In the second example, the array `[4, 4, 4, 3, 3, 2, 1, 1]` has `4` with a frequency of 3, `1` with a frequency of 2, `3` with a frequency of 2, and `2` with a frequency of 1. The top 3 frequent elements are `[4, 1, 3]` because `1` and `3` have the same frequency but `1` is smaller than `3`. # Constraints 1. Sort the frequencies efficiently and handle ties by using a sorting method that ensures elements with the same frequency are sorted by their values. 2. Implement the solution to ensure it runs within reasonable time complexity, particularly for large arrays. # Tips - Use a dictionary or counter to count the frequency of each element. - Use a heap or sorting approach to extract the top `k` elements based on frequency.","solution":"from typing import List from collections import Counter def find_top_k_frequent(arr: List[int], k: int) -> List[int]: Returns the k most frequent elements in the array. If there is a tie for the kth position, return the elements with the smallest values. count = Counter(arr) # Sorting by frequency (descending) and then by value (ascending) sorted_items = sorted(count.items(), key=lambda x: (-x[1], x[0])) # Extract the top k elements return [item[0] for item in sorted_items[:k]]"},{"question":"# Coding Assessment Question: Check if an Array is a Valid Mountain Array **Background**: You are tasked with creating a function to determine if a given array of integers is a \\"mountain array.\\" An array is considered a mountain array if it satisfies the following conditions: 1. The array has at least three elements. 2. There exists an index `i` such that: - `arr[0]` < `arr[1]` < ... < `arr[i]` - `arr[i]` > `arr[i+1]` > ... > `arr[n-1]` **Function Description**: Write a function `is_mountain_array(arr: List[int]) -> bool` that checks whether the given array is a mountain array. Input: * `arr`: a list of integers, with the length of the array `n` (1 ≤ n ≤ 10000). Output: * A boolean value `True` if the array is a mountain array, otherwise `False`. Constraints: * The algorithm should be efficient and run in O(n) time complexity. Example: ```python assert is_mountain_array([2, 1]) == False assert is_mountain_array([3, 5, 5]) == False assert is_mountain_array([0, 3, 2, 1]) == True assert is_mountain_array([0, 2, 3, 4, 5, 2, 1, 0]) == True assert is_mountain_array([1, 2, 0, 2]) == False ``` Additional Context: 1. A valid mountain array must strictly increase and then strictly decrease after the peak. 2. The peak element must not be the first or last element of the array. ```python def is_mountain_array(arr: List[int]) -> bool: n = len(arr) if n < 3: return False i = 0 while i < n-1 and arr[i] < arr[i+1]: i += 1 if i == 0 or i == n-1: return False while i < n-1 and arr[i] > arr[i+1]: i += 1 return i == n-1 ```","solution":"from typing import List def is_mountain_array(arr: List[int]) -> bool: n = len(arr) if n < 3: return False i = 0 while i < n - 1 and arr[i] < arr[i + 1]: i += 1 if i == 0 or i == n - 1: return False while i < n - 1 and arr[i] > arr[i + 1]: i += 1 return i == n - 1"},{"question":"# Coding Question: Longest Consecutive Sequence Scenario You are developing a feature for a productivity tool that helps users manage their tasks more efficiently. One of the key functionalities is to analyze patterns in task completion rates. Problem Given a list of integers representing the days on which tasks were completed, write a function to find the length of the longest consecutive sequence of days. A consecutive sequence indicates the user completed tasks on sequential days without breaks. Function Signature ```python def longest_consecutive_sequence(days: List[int]) -> int: ``` Input * A list of integers `days` where each integer represents a day on which a task was completed. Output * An integer representing the length of the longest consecutive sequence of task completion days. Constraints * Each day will be a positive integer. * The size of the list `days` will be between 0 and 10^6 inclusive. * The days in `days` are unique and sorted in non-decreasing order. Performance Requirements * Your solution should have linear or better time complexity. Example ```python >>> longest_consecutive_sequence([1, 2, 3, 4, 5]) 5 >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2]) 4 >>> longest_consecutive_sequence([100, 4, 200, 1, 2, 3]) 4 >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([7]) 1 ``` Note: * In the first example, the consecutive sequence is `1, 2, 3, 4, 5`. * In the second example, the longest consecutive sequence is `1, 2, 3, 4`. Edge Cases * An empty list should return `0`. * A list with one element should return `1`. Implement the function `longest_consecutive_sequence`.","solution":"from typing import List def longest_consecutive_sequence(days: List[int]) -> int: if not days: return 0 days_set = set(days) # Use a set for O(1) look-ups longest_streak = 0 for day in days_set: # Only check for the start of a sequence if day - 1 not in days_set: current_day = day current_streak = 1 while current_day + 1 in days_set: current_day += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Question Style Context You have been hired to create a module for a basic payroll system. One of the core functionalities requires calculating the net salary of employees after applying deductions and bonuses. Task Implement a function that computes the net salary given the gross salary, total deductions, and total bonuses. Function Specification ```python def calculate_net_salary(gross_salary: float, total_deductions: float, total_bonuses: float) -> float: This function should calculate the net salary by considering the gross salary, deductions, and bonuses. Arguments: gross_salary (float): the gross salary of the employee. total_deductions (float): the total amount of deductions. total_bonuses (float): the total amount of bonuses. Returns: float: The net salary after applying deductions and bonuses. Raises: ValueError: if any of the input values are negative. Example: >>> calculate_net_salary(5000, 500, 600) 5100.0 >>> calculate_net_salary(4000, 300, 0) 3700.0 >>> calculate_net_salary(3000, 0, 150) 3150.0 >>> calculate_net_salary(3000, -100, 150) Raises ValueError: All input values must be non-negative pass # Your code here ``` Constraints 1. All input values must be non-negative. 2. Only floating-point numbers should be used or returned. 3. Deductions cannot exceed the gross salary. Performance Requirements The expected time complexity should be O(1) and the space complexity should be O(1). Your Task Implement the function `calculate_net_salary` as specified. Ensure that your function passes all the given test cases.","solution":"def calculate_net_salary(gross_salary: float, total_deductions: float, total_bonuses: float) -> float: This function should calculate the net salary by considering the gross salary, deductions, and bonuses. Arguments: gross_salary (float): the gross salary of the employee. total_deductions (float): the total amount of deductions. total_bonuses (float): the total amount of bonuses. Returns: float: The net salary after applying deductions and bonuses. Raises: ValueError: if any of the input values are negative. if gross_salary < 0 or total_deductions < 0 or total_bonuses < 0: raise ValueError(\\"All input values must be non-negative\\") if total_deductions > gross_salary: raise ValueError(\\"Deductions cannot exceed the gross salary\\") net_salary = gross_salary - total_deductions + total_bonuses return net_salary"},{"question":"# Question: Implementing a Web Scraper with Caching Mechanism You are tasked with building a basic web scraper which retrieves web content and caches the responses to speed up subsequent requests to the same URLs. The cache should store the timestamp of when each URL was last fetched and control stale data based on a specified cache duration. # Function Requirements 1. **Web Scraper**: - **Function Name**: `fetch_content` - **Parameters**: - `url` (str): The URL of the webpage to be fetched. - `cache_duration` (int): The duration, in seconds, before the cached content is considered stale. - **Returns**: - The content of the webpage as a string if the retrieval is successful. - `None` if the retrieval fails. 2. **Cache Mechanism**: - Implement a cache storing both the content and the timestamp of the last fetch for each URL. - If the cached content is stale (based on `cache_duration`), fetch the content again and update the cache. # Constraints - Use only the standard libraries `requests`, `time`, `hashlib`, and `os`. - Assume the target URLs always return HTML content. - Handle HTTP errors gracefully. - Cache storage should be implemented using an in-memory dictionary. - Optimize the function to handle up to 1000 unique URLs efficiently. # Performance Requirements - Ensure that the content is fetched within a reasonable time for each web request. - The cache should effectively reduce redundant web requests, given that repeated requests for the same URL within the cache duration should not require a new network call. # Example Sample Usage ```python # First call, content fetched from web content1 = fetch_content(\'http://example.com\', 3600) print(content1) # Second call, cached content is used time.sleep(10) content2 = fetch_content(\'http://example.com\', 3600) print(content2) # Ensure contents fetched in the subsequent call using cache are the same assert content1 == content2 # Wait for cache to become stale time.sleep(3700) content3 = fetch_content(\'http://example.com\', 3600) # The contents should have been fetched again assert content1 != content3 ``` Write your implementation for the `fetch_content` function. # Solution Template Below is the solution template that provides a starting point for your implementation: ```python import requests import time import hashlib import os # Cache dictionary to store retrieved content and timestamps cache = {} def fetch_content(url, cache_duration): current_time = time.time() url_hash = hashlib.md5(url.encode()).hexdigest() if url_hash in cache: content, timestamp = cache[url_hash] if current_time - timestamp < cache_duration: return content else: del cache[url_hash] try: response = requests.get(url) if response.status_code == 200: content = response.text cache[url_hash] = (content, current_time) return content except Exception as e: print(f\\"Error fetching the URL {url}: {e}\\") return None # You may run this function with sample URL provided you have a stable network connection # to verify its functionality if __name__ == \'__main__\': url = \'http://example.com\' duration = 3600 # 1 hour cache duration print(fetch_content(url, duration)) ``` This template includes the basic setup for caching web scraper and needs to be completed as per the requirements.","solution":"import requests import time import hashlib # Cache dictionary to store retrieved content and timestamps cache = {} def fetch_content(url, cache_duration): current_time = time.time() url_hash = hashlib.md5(url.encode()).hexdigest() if url_hash in cache: content, timestamp = cache[url_hash] if current_time - timestamp < cache_duration: return content else: del cache[url_hash] try: response = requests.get(url) if response.status_code == 200: content = response.text cache[url_hash] = (content, current_time) return content except Exception as e: print(f\\"Error fetching the URL {url}: {e}\\") return None"},{"question":"# Task: Implement a Tagging System for Blog Articles Background You are working as a software engineer at a blogging platform. Your task is to implement a tagging system that allows authors to apply multiple tags to their articles. Tags help in categorizing articles and making it easy to search for related content. Requirements 1. **Input**: * A list of articles, where each article is represented as a dictionary with at least `id` (integer), `title` (string), and `content` (string) keys. * A list of tags, where each tag is represented as a dictionary with at least `id` (integer) and `name` (string) keys. * A list of tag connections, where each connection is represented as a dictionary with `article_id` (integer) and `tag_id` (integer) keys. ```python articles = [ {\'id\': 1, \'title\': \'Python Basics\', \'content\': \'Introduction to Python.\'}, {\'id\': 2, \'title\': \'Advanced Python\', \'content\': \'In-depth Python topics.\'}, {\'id\': 3, \'title\': \'Web Development\', \'content\': \'Building websites with Python.\'} ] tags = [ {\'id\': 1, \'name\': \'Python\'}, {\'id\': 2, \'name\': \'Programming\'}, {\'id\': 3, \'name\': \'Web Development\'} ] connections = [ {\'article_id\': 1, \'tag_id\': 1}, {\'article_id\': 1, \'tag_id\': 2}, {\'article_id\': 2, \'tag_id\': 1}, {\'article_id\': 2, \'tag_id\': 2}, {\'article_id\': 3, \'tag_id\': 3} ] ``` 2. **Output**: * A dictionary where each key is an article id and the value is a list of tag names associated with that article. ```python { 1: [\'Python\', \'Programming\'], 2: [\'Python\', \'Programming\'], 3: [\'Web Development\'] } ``` 3. **Constraints**: * Ensure all articles and tags are processed correctly. * If an article has no associated tags, it should have an empty list as the value in the output dictionary. * The input lists can be of variable length. 4. **Performance**: * Ensure that the solution handles a large number of articles and tags efficiently. * Avoid unnecessary operations and optimize lookups. Function Signature ```python def build_tagging_system(articles: list[dict], tags: list[dict], connections: list[dict]) -> dict[int, list[str]]: pass ``` Example Usage ```python articles = [ {\'id\': 1, \'title\': \'Python Basics\', \'content\': \'Introduction to Python.\'}, {\'id\': 2, \'title\': \'Advanced Python\', \'content\': \'In-depth Python topics.\'}, {\'id\': 3, \'title\': \'Web Development\', \'content\': \'Building websites with Python.\'} ] tags = [ {\'id\': 1, \'name\': \'Python\'}, {\'id\': 2, \'name\': \'Programming\'}, {\'id\': 3, \'name\': \'Web Development\'} ] connections = [ {\'article_id\': 1, \'tag_id\': 1}, {\'article_id\': 1, \'tag_id\': 2}, {\'article_id\': 2, \'tag_id\': 1}, {\'article_id\': 2, \'tag_id\': 2}, {\'article_id\': 3, \'tag_id\': 3} ] tagging_system = build_tagging_system(articles, tags, connections) print(tagging_system) # Output: {1: [\'Python\', \'Programming\'], 2: [\'Python\', \'Programming\'], 3: [\'Web Development\']} ```","solution":"def build_tagging_system(articles: list[dict], tags: list[dict], connections: list[dict]) -> dict[int, list[str]]: Builds a tagging system for blog articles. :param articles: A list of articles, each represented as a dictionary with \'id\', \'title\', and \'content\' keys. :param tags: A list of tags, each represented as a dictionary with \'id\' and \'name\' keys. :param connections: A list of connections, each represented as a dictionary with \'article_id\' and \'tag_id\' keys. :return: A dictionary where each key is an article id and the value is a list of tag names associated with that article. # Create a dictionary to map tag ids to tag names tag_names = {tag[\'id\']: tag[\'name\'] for tag in tags} # Initialize a dictionary to hold the result result = {article[\'id\']: [] for article in articles} # Populate the result dictionary with tag names for connection in connections: article_id = connection[\'article_id\'] tag_id = connection[\'tag_id\'] if article_id in result: result[article_id].append(tag_names[tag_id]) return result"},{"question":"# Context String manipulation is a core aspect of many programming tasks including data processing, text analysis, and algorithm development. Efficiently handling and transforming strings is essential for applications that process large volumes of textual data. # Problem Statement You are required to implement a class `StringTransformer` with the following methods: 1. **reverse_words**: A method to reverse the order of words in a given string. 2. **encode_run_length**: A method to perform run-length encoding on a given string. # Function Specifications: reverse_words: **Input**: - A string `s` containing multiple words separated by spaces. **Output**: - Returns a new string with the order of words reversed. The words themselves should not be reversed. encode_run_length: **Input**: - A string `s` containing consecutive characters that need to be encoded. **Output**: - Returns a new string that represents the run-length encoding of the input string. Each run of the same character is replaced by the character followed by the count of its repeats. # Example: ```python st = StringTransformer() # Should print \'world Hello\' print(st.reverse_words(\'Hello world\')) # Output: \'world Hello\' # Should print \'a2b1c5a3\' print(st.encode_run_length(\'aabcccccaaa\')) # Output: \'a2b1c5a3\' ``` # Constraints: - The input string for `reverse_words` can be assumed to contain only letters and spaces, without leading or trailing spaces, and words are separated by a single space. - The input string for `encode_run_length` can be assumed to contain only lowercase letters, and the encoding should preserve the order of characters in the original string. # Additional Notes: - For `reverse_words`, consider edge cases like an empty string or a single word. - For `encode_run_length`, ensure that characters are properly grouped and counted.","solution":"class StringTransformer: def __init__(self): pass def reverse_words(self, s: str) -> str: Reverses the order of words in the given string. return \' \'.join(s.split()[::-1]) def encode_run_length(self, s: str) -> str: Performs run-length encoding on the given string. if not s: return \\"\\" encoded_string = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: encoded_string.append(current_char + str(count)) current_char = char count = 1 # Append the last run of characters encoded_string.append(current_char + str(count)) return \'\'.join(encoded_string)"},{"question":"# Coding Challenge: String Anagram Checks Objective: Develop a program to check if a list of given pairs of strings are anagrams of each other and summarize the results. Detailed Task Description: 1. **Function Implementations**: - Implement `are_anagrams(str1: str, str2: str) -> bool`: This function should determine if the two provided strings are anagrams of each other. 2. **Main Function**: - Implement `check_anagrams(pairs: List[Tuple[str, str]]) -> List[bool]`: This function should take a list of string pairs, check if each pair consists of anagrams, and return a list of Boolean values representing the results. Input: - A list of tuples where each tuple contains two strings. Output: - A list of Boolean values where each value corresponds to whether the respective string pair is an anagram (True) or not (False). Constraints: - The strings will consist of lowercase alphabets only. - The length of each string pair will not exceed 1000 characters. - You can assume there will be no whitespace or special characters. Example: Suppose the input list of pairs is: ```python pairs = [ (\\"listen\\", \\"silent\\"), (\\"triangle\\", \\"integral\\"), (\\"apple\\", \\"papel\\"), (\\"rat\\", \\"car\\"), (\\"night\\", \\"thing\\") ] ``` - \\"listen\\" and \\"silent\\" are anagrams: True - \\"triangle\\" and \\"integral\\" are anagrams: True - \\"apple\\" and \\"papel\\" are anagrams: True - \\"rat\\" and \\"car\\" are not anagrams: False - \\"night\\" and \\"thing\\" are anagrams: True Thus, the function should return: ```python [True, True, True, False, True] ``` Function Signatures: - are_anagrams(str1: str, str2: str) -> bool - check_anagrams(pairs: List[Tuple[str, str]]) -> List[bool]","solution":"from typing import List, Tuple def are_anagrams(str1: str, str2: str) -> bool: Determines if the two provided strings are anagrams of each other. return sorted(str1) == sorted(str2) def check_anagrams(pairs: List[Tuple[str, str]]) -> List[bool]: Checks if each pair of strings in the list are anagrams and returns a list of Boolean values representing the results. results = [] for str1, str2 in pairs: results.append(are_anagrams(str1, str2)) return results"},{"question":"# Adaptive Weather Forecasting: Data Processor Implementation In this task, you will implement a class `WeatherDataProcessor` that processes raw weather data to generate useful forecasts. The class will contain methods to calculate average temperature, detect significant weather events, and validate temperature readings. You will be provided with tuples representing daily weather data. Each tuple consists of the minimum temperature, maximum temperature, and a description of any significant weather event that occurred on that day. For instance: ``` (15.5, 28.7, \\"Rain\\") ``` You need to implement methods that perform computations and validations based on this data. # Class and Methods Specification: Class: ```python class WeatherDataProcessor: def __init__(self, weather_data: list): pass def calculate_average_temperature(self) -> float: pass def detect_significant_events(self) -> list: pass def validate_data(self) -> None: pass ``` # Method Description: * `__init__(self, weather_data: list)`: Initialize the `WeatherDataProcessor` instance with a list of tuples, where each tuple represents the weather data for a particular day. * `calculate_average_temperature(self) -> float`: Calculates and returns the average temperature for the given data set. The average temperature for each day is calculated as `(min_temp + max_temp) / 2`. The overall average is then derived from daily averages. * `detect_significant_events(self) -> list`: Returns a list of unique weather events detected in the dataset. * `validate_data(self) -> None`: Validates the weather data. Ensures that: 1. The minimum temperature is less than or equal to the maximum temperature for each day. 2. The temperatures are within a realistic range (e.g., -100 to 60 degrees Celsius). # Constraints: - The `weather_data` will be a list of tuples with each tuple containing two float values and a string. - Temperatures are in degrees Celsius and events will always be valid strings. # Examples: ```python weather_data = [ (15.5, 28.7, \\"Rain\\"), (18.0, 30.2, \\"Sunny\\"), (10.0, 25.8, \\"Cloudy\\"), (22.5, 35.1, \\"Rain\\"), (17.3, 31.0, \\"Sunny\\"), ] weather_processor = WeatherDataProcessor(weather_data) # Example for calculating average temperature: avg_temp = weather_processor.calculate_average_temperature() print(avg_temp) # Expected output: 23.63 (average calculated over daily averages) # Example for detecting significant events: events = weather_processor.detect_significant_events() print(events) # Expected output: [\'Rain\', \'Sunny\', \'Cloudy\'] # Example for data validation: weather_processor.validate_data() # Should not raise errors if data is valid. Will raise ValueError if validation fails. ``` Additional validation: 1. If a day\'s min temperature is greater than the max temperature, raise a ValueError with the message: `\'Invalid temperature range in data.\'`. 2. If temperatures are out of the realistic range (-100 to 60 degrees Celsius), raise a ValueError with the message: `\'Temperature readings out of realistic range.\'`.","solution":"class WeatherDataProcessor: def __init__(self, weather_data: list): self.weather_data = weather_data def calculate_average_temperature(self) -> float: total_avg_temp = 0 for min_temp, max_temp, _ in self.weather_data: daily_avg_temp = (min_temp + max_temp) / 2 total_avg_temp += daily_avg_temp return total_avg_temp / len(self.weather_data) def detect_significant_events(self) -> list: events = set() for _, _, event in self.weather_data: events.add(event) return list(events) def validate_data(self) -> None: for min_temp, max_temp, _ in self.weather_data: if min_temp > max_temp: raise ValueError(\'Invalid temperature range in data.\') if not (-100 <= min_temp <= 60) or not (-100 <= max_temp <= 60): raise ValueError(\'Temperature readings out of realistic range.\')"},{"question":"Problem Write a function that reads the contents of a text file, identifies all numeric strings within the file, converts them to integers, and then returns the product of these integers. If there are no numeric strings in the file, the function should return 1. # Function Signature ```python def compute_product_of_numbers(file_path: str) -> int: pass ``` # Input: * `file_path (str)`: The path to the text file. # Output: * `int`: The product of all numeric strings found in the text file. If none, return 1. # Constraints: * The text file will not exceed a size of 100 KB. * Numeric strings consist of consecutive digits `0-9`. * The file may have multiple lines and a mixture of alphanumeric characters and symbols. # Performance Requirements: * The solution should efficiently handle reading and processing the text file. # Example: ```python # Assume file content is: # \\"The price is 50 dollars for 2 items. # You only need 1 because we offer a discount.\\" assert compute_product_of_numbers(\\"path/to/file.txt\\") == 100 ``` Explanation: * The numeric strings found in the file are \\"50\\", \\"2\\", and \\"1\\". * The product of these numbers is 50 * 2 * 1 = 100. # Notes: - Consider handling cases where the file might contain no numeric strings. - Ensure that numbers are correctly identified and parsed from the text.","solution":"import re def compute_product_of_numbers(file_path: str) -> int: Reads a file, identifies all numeric strings, converts them to integers, and returns the product of these integers. If no numeric strings are found, it returns 1. product = 1 found_number = False with open(file_path, \'r\') as file: content = file.read() numbers = re.findall(r\'d+\', content) for number in numbers: product *= int(number) found_number = True return product if found_number else 1"},{"question":"# Sum of Array Except for the Element Itself You are required to implement a function that takes an array of integers and returns a new array such that each element at index `i` of the new array is the sum of all the elements in the original array except the one at `i`. # Function Signature ```python def sum_except_self(arr: List[int]) -> List[int]: pass ``` # Input - A list of integers `arr` where `2 <= len(arr) <= 10^5` and `-10^4 <= arr[i] <= 10^4`. # Output - A list of integers where each element is the sum of all the elements in the original array except for the one at the corresponding index. # Constraints - The length of the input list will be at least 2 and at most 100,000. - The integers in the input list will be in the range -10,000 to 10,000. # Performance Requirements - The solution should have a time complexity of O(n), where n is the number of elements in the input list. - The solution should use O(n) space, not including the input and output lists. # Examples ```python >>> sum_except_self([1, 2, 3, 4]) [9, 8, 7, 6] >>> sum_except_self([5, 1, 1, 2, 3]) [7, 11, 11, 10, 9] >>> sum_except_self([0, 0, 0]) [0, 0, 0] ``` # Notes - You should not use division in the computation of the final list. - Think about how you can use prefix and suffix sums to achieve the desired result efficiently. - Handle edge cases appropriately, such as an array with all zeros.","solution":"from typing import List def sum_except_self(arr: List[int]) -> List[int]: Returns a new array such that each element at index `i` of the new array is the sum of all the elements in the original array except the one at `i`. n = len(arr) result = [0] * n # Calculate prefix sum prefix_sum = 0 for i in range(n): result[i] = prefix_sum prefix_sum += arr[i] # Calculate suffix sum and add to prefix sum in result suffix_sum = 0 for i in range(n - 1, -1, -1): result[i] += suffix_sum suffix_sum += arr[i] return result"},{"question":"# Prefix Tree (Trie) Implementation & Search The following class definition initiates a node for a prefix tree (trie): ```python class TrieNode: def __init__(self) -> None: self.children = {} self.is_end_of_word = False ``` # Function Implementation Using the `TrieNode` class, implement a prefix tree (trie) for a given list of words. Create necessary methods to construct the trie from the list and to check if a given word exists in the trie, as well as a method to get all words that start with a given prefix. Requirements 1. **Function Name**: `construct_trie` * **Input**: A list of strings \'words\' of length k (1 ≤ k ≤ 10^4), where each word has a length in the range 1 ≤ len(word) ≤ 100. * **Output**: The root node of the constructed trie. 2. **Function Name**: `contains_word` * **Input**: The root node of a trie and a string \'word\'. * **Output**: `True` if the word is present in the trie, otherwise `False`. 3. **Function Name**: `words_with_prefix` * **Input**: The root node of a trie and a string \'prefix\'. * **Output**: A list of words from the trie that start with the given prefix. If no words match, return an empty list. # Example: ```python words = [\\"banana\\", \\"band\\", \\"bee\\", \\"absolute\\", \\"acorn\\"] root = construct_trie(words) print(contains_word(root, \\"band\\")) # Output: True print(contains_word(root, \\"bandana\\")) # Output: False print(words_with_prefix(root, \\"ba\\")) # Output: [\\"banana\\", \\"band\\"] print(words_with_prefix(root, \\"ab\\")) # Output: [\\"absolute\\"] ``` # Constraints * Your trie construction function must be efficient with a time complexity of O(k * m), where m is the average length of the words. * The `contains_word` function must have a time complexity of O(m), where m is the length of the word. * The `words_with_prefix` function must have a time complexity of O(p + z), where p is the length of the prefix and z is the total length of the words with the given prefix. Implement the `construct_trie`, `contains_word`, and `words_with_prefix` functions below.","solution":"class TrieNode: def __init__(self) -> None: self.children = {} self.is_end_of_word = False def construct_trie(words): root = TrieNode() for word in words: node = root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True return root def contains_word(root, word): node = root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def words_with_prefix(root, prefix): result = [] node = root for char in prefix: if char not in node.children: return result node = node.children[char] def dfs(current_node, path): if current_node.is_end_of_word: result.append(path) for char, child_node in current_node.children.items(): dfs(child_node, path + char) dfs(node, prefix) return result"},{"question":"# Fibonacci Heap Key Decrease and Extraction You are required to implement operations for decreasing the key of a node and extracting the minimum key node from a Fibonacci heap. These operations are vital for various applications, including Dijkstra\'s algorithm and Prim\'s algorithm. # Function Signatures ```python class FibonacciHeapNode: def __init__(self, key: int): self.key = key self.degree = 0 self.parent = None self.child = None self.left = self self.right = self self.mark = False class FibonacciHeap: def __init__(self): self.min_node = None self.total_nodes = 0 def insert(self, key: int): # Insert logic def decrease_key(self, node: FibonacciHeapNode, new_key: int): # Decrease key logic def extract_min(self) -> FibonacciHeapNode: # Extract min logic ``` # Parameters * `FibonacciHeapNode` class constructor: * `key` (int): The key of the node being created. * `FibonacciHeap` class methods: * `insert(key: int)`: Inserts a new node with the specified key into the Fibonacci heap. * `decrease_key(node: FibonacciHeapNode, new_key: int)`: Decreases the key of the specified node to `new_key`. Raises ValueError if `new_key` is greater than the current key of the node. * `extract_min()`: Removes and returns the node with the minimum key from the Fibonacci heap. # Expected Output * `FibonacciHeapNode`: The extracted node from the `extract_min()` method. # Constraints * The keys are distinct integers. * You may assume that the `decrease_key` method will never be called with a `new_key` that is greater than the current key of the node. # Example ```python fh = FibonacciHeap() fh.insert(10) fh.insert(4) fh.insert(15) min_node = fh.extract_min() assert min_node.key == 4 node1 = FibonacciHeapNode(10) fh.insert(5) fh.insert(node1.key) fh.decrease_key(node1, 1) min_node = fh.extract_min() assert min_node.key == 1 ``` # Notes 1. You need to maintain the Fibonacci heap properties during the operations. 2. Ensure that your implementation adheres to the logarithmic amortized time complexity for the key operations (`decrease_key` and `extract_min`). 3. Consider implementing helper methods to maintain cleanliness and modularity in your code. 4. Add appropriate test cases to verify the correctness and performance of your methods.","solution":"class FibonacciHeapNode: def __init__(self, key: int): self.key = key self.degree = 0 self.parent = None self.child = None self.left = self self.right = self self.mark = False class FibonacciHeap: def __init__(self): self.min_node = None self.total_nodes = 0 def insert(self, key: int): node = FibonacciHeapNode(key) self.min_node = self._merge_with_root_list(self.min_node, node) self.total_nodes += 1 def decrease_key(self, node: FibonacciHeapNode, new_key: int): if new_key > node.key: raise ValueError(\\"New key is greater than current key.\\") node.key = new_key parent = node.parent if parent and node.key < parent.key: self._cut(node, parent) self._cascading_cut(parent) if node.key < self.min_node.key: self.min_node = node def extract_min(self) -> FibonacciHeapNode: min_node = self.min_node if min_node is not None: if min_node.child is not None: children = [x for x in self._iterate(min_node.child)] for child in children: self._merge_with_root_list(self.min_node, child) child.parent = None self._remove_from_root_list(min_node) if min_node == min_node.right: self.min_node = None else: self.min_node = min_node.right self._consolidate() self.total_nodes -= 1 return min_node def _iterate(self, start): node = start while True: yield node node = node.right if node == start: break def _merge_with_root_list(self, root, node): if root is None: return node if node is None: return root if node.key < root.key: root, node = node, root node.left.right = node.right node.right.left = node.left node.right = root node.left = root.left root.left.right = node root.left = node return root def _remove_from_root_list(self, node): if node.right == node: return node.left.right = node.right node.right.left = node.left def _consolidate(self): A = [None] * self.total_nodes nodes = [x for x in self._iterate(self.min_node)] for node in nodes: d = node.degree while A[d] is not None: y = A[d] if node.key > y.key: node, y = y, node self._link(y, node) A[d] = None d += 1 A[d] = node self.min_node = None for i in range(len(A)): if A[i] is not None: if self.min_node is None: self.min_node = A[i] else: A[i].left.right = A[i].right A[i].right.left = A[i].left A[i].left = self.min_node A[i].right = self.min_node.right self.min_node.right.left = A[i] self.min_node.right = A[i] if A[i].key < self.min_node.key: self.min_node = A[i] def _link(self, y, x): self._remove_from_root_list(y) y.left = y.right = y y.parent = x if x.child is None: x.child = y else: y.right = x.child y.left = x.child.left x.child.left.right = y x.child.left = y x.degree += 1 y.mark = False def _cut(self, x, y): if x.right == x: y.child = None else: x.left.right = x.right x.right.left = x.left if y.child == x: y.child = x.right y.degree -= 1 self._merge_with_root_list(self.min_node, x) x.parent = None x.mark = False def _cascading_cut(self, y): z = y.parent if z is not None: if not y.mark: y.mark = True else: self._cut(y, z) self._cascading_cut(z)"},{"question":"# Coding Assessment Question: Implementing the Absolute Difference Function Context Calculating the absolute difference between two numbers is a common operation in many algorithms, including those involved in sorting, searching, and various optimization problems. This exercise will help you demonstrate your understanding of basic arithmetic operations and handling edge cases related to numerical inputs. Problem Statement Write a function `absolute_difference(a: int, b: int) -> int` that returns the absolute difference between two integers `a` and `b`. Input and Output * The input will be two integers `a` and `b`. * The output should be an integer that represents the absolute difference between `a` and `b`. Constraints * The input values `a` and `b` will be valid integers within the range of -10^6 to 10^6. * Ensure the implementation is efficient with O(1) time complexity. Edge Cases * Consider how to handle positive and negative values. * Ensure the output is always a non-negative integer. Example ```python def absolute_difference(a: int, b: int) -> int: Return the absolute difference between a and b. :param a: first integer :param b: second integer :return: the absolute difference between a and b. >>> absolute_difference(5, 3) 2 >>> absolute_difference(-5, 3) 8 >>> absolute_difference(-5, -3) 2 >>> absolute_difference(5, 5) 0 pass ``` Implement the function and ensure it passes all the provided tests.","solution":"def absolute_difference(a: int, b: int) -> int: Return the absolute difference between a and b. :param a: first integer :param b: second integer :return: the absolute difference between a and b. return abs(a - b)"},{"question":"# Coding Question: Implement a CSV Column Extractor **Objective**: Write a Python function that reads a CSV file and returns the values of a specified column as a list. To achieve this, your function should: 1. Read the CSV file using the csv library. 2. Extract the values from the specified column. 3. Handle any potential errors, such as when the CSV file does not exist or the column is not found. **Function Signature**: ```python def get_csv_column_values(file_path: str, column_name: str) -> list: pass ``` **Input**: - `file_path` (str): The path to the CSV file. - `column_name` (str): The name of the column to extract values from. **Output**: - `list`: A list of values from the specified column in the CSV file. **Constraints**: - The CSV file will not exceed 10MB in size. - The column name will not exceed 100 characters in length. - You must handle potential file I/O errors and parsing errors. - Assume that the CSV file is well-formed and delimited by commas. **Performance Requirements**: - The function must read the file and extract the column efficiently. - The function should handle large files within a reasonable time frame. **Example**: ```python values = get_csv_column_values(\\"data.csv\\", \\"Name\\") print(values) # Should print the list of values under the \\"Name\\" column in the CSV file \\"data.csv\\" ``` **Additional Notes**: - Use appropriate error handling to manage file not found and column not found scenarios. - Ensure the function works for CSV files with and without headers. **Testing**: - Test with various CSV files with different structures and sizes to verify the correctness and robustness of your implementation. - Consider edge cases such as empty files, missing columns, and files with various encoding.","solution":"import csv def get_csv_column_values(file_path: str, column_name: str) -> list: values = [] try: with open(file_path, mode=\'r\', newline=\'\') as csvfile: reader = csv.DictReader(csvfile) if column_name not in reader.fieldnames: raise ValueError(f\\"Column \'{column_name}\' not found in the CSV file.\\") for row in reader: values.append(row[column_name]) except FileNotFoundError: raise FileNotFoundError(f\\"The file \'{file_path}\' does not exist.\\") except Exception as e: raise e return values"},{"question":"# Text Classification with NLP and Sklearn For this assessment, you are tasked with implementing a Natural Language Processing (NLP) pipeline to classify movie reviews as positive or negative. You will use the sklearn library to preprocess the text data, vectorize it using TF-IDF, and train a logistic regression classifier. **Problem**: 1. Implement a function `text_preprocessing` that preprocesses the input textual data. 2. Implement a function `logistic_regression_model` that trains the logistic regression model and predicts the class of reviews. 3. Implement a `main` function to run the entire process and evaluate the model. # Input: 1. A dictionary `data` with keys: * `reviews` - A list of strings, each representing a movie review. * `labels` - A list of integers (0 or 1), where 0 indicates a negative review and 1 indicates a positive review. # Output: 1. A callable logistic regression classifier function. 2. A prediction output array of movie review classes for the test dataset. # Constraints: * Use TF-IDF vectorizer provided by sklearn. * Ensure the evaluation metrics (Accuracy and F1-Score) are calculated correctly. * Handle any missing or incorrect input data rationally. # Example: ```python # Expected data format for input dictionary example_data = { \\"reviews\\": [\\"I love this movie!\\", \\"Terrible film, do not watch.\\", ...], \\"labels\\": [1, 0, ...] } # Define the functions def text_preprocessing(data): # Perform text preprocessing (tokenization, stop word removal, etc.) pass def logistic_regression_model(train_reviews, train_labels, test_reviews): # Train Logistic Regression model and perform prediction on test data pass def main(): # Running the model pass if __name__ == \\"__main__\\": main() ``` # Evaluation: Evaluate your solution based on: 1. Correctness: Does the function accurately classify the movie reviews? 2. Efficiency: Is your solution optimized for given constraints? 3. Robustness: Does your solution handle edge cases gracefully?","solution":"import re from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.linear_model import LogisticRegression from sklearn.model_selection import train_test_split from sklearn.metrics import accuracy_score, f1_score def text_preprocessing(text): Preprocess the input text data by removing non-alphabetic characters, converting to lowercase, and removing extra spaces. text = re.sub(r\'[^a-zA-Zs]\', \'\', text) text = text.lower() text = re.sub(r\'s+\', \' \', text).strip() return text def logistic_regression_model(train_reviews, train_labels, test_reviews): Train a logistic regression model on train_reviews and train_labels, and predict the class of test_reviews. vectorizer = TfidfVectorizer() X_train = vectorizer.fit_transform(train_reviews) X_test = vectorizer.transform(test_reviews) model = LogisticRegression() model.fit(X_train, train_labels) predictions = model.predict(X_test) return predictions def main(data): reviews = data.get(\'reviews\', []) labels = data.get(\'labels\', []) if not reviews or not labels or len(reviews) != len(labels): raise ValueError(\\"Invalid input data\\") processed_reviews = [text_preprocessing(review) for review in reviews] train_reviews, test_reviews, train_labels, test_labels = train_test_split( processed_reviews, labels, test_size=0.2, random_state=42 ) predictions = logistic_regression_model(train_reviews, train_labels, test_reviews) accuracy = accuracy_score(test_labels, predictions) f1 = f1_score(test_labels, predictions) return accuracy, f1, predictions"},{"question":"# Problem Statement You need to calculate all valid passwords from a given set of character pairs that follow a specific transformation rule. A valid password must be a combination of three-character subsets from the input string where the sum of the ASCII values of these three characters is divisible by 3. # Objectives 1. Write a function `generate_valid_passwords(pairs: List[Tuple[str, str]], limit: int) -> List[str]` that, given a list of tuples containing character pairs and an integer `limit`, generates all valid passwords and returns a list of those passwords. # Function Signature ```python def generate_valid_passwords(pairs: List[Tuple[str, str]], limit: int) -> List[str]: # Implementation ``` # Input - `pairs`: A list of tuples containing pairs of characters, e.g., `[(\'a\', \'b\'), (\'c\', \'d\'), (\'e\', \'f\')]`. - `limit`: An integer representing the maximum number of passwords to generate. # Output - A list of strings, where each string is a valid password. # Constraints - Each pair will have exactly 2 distinct characters, and there will be at most 20 pairs. - Each character in the pairs is a lowercase letter, \'a\' to \'z\'. - The `limit` will be at most 100. - The combinations should be case-sensitive and consider permutations of the characters. # Example ```python >>> pairs = [(\'a\', \'b\'), (\'c\', \'d\'), (\'e\', \'f\')] >>> limit = 5 >>> generate_valid_passwords(pairs, limit) [\'aca\', \'aeb\', \'bfa\', \'bec\', \'dfc\'] ``` # Guidelines 1. Use itertools or another efficient method to generate combinations and permutations of the characters in the pairs. 2. Check each generated combination to see if it meets the criteria for a valid password 3. Ensure that the total number of passwords generated does not exceed the given limit.","solution":"from typing import List, Tuple from itertools import permutations def generate_valid_passwords(pairs: List[Tuple[str, str]], limit: int) -> List[str]: Generates valid passwords from character pairs such that the sum of the ASCII values of the characters in a password is divisible by 3. all_chars = {char for pair in pairs for char in pair} valid_passwords = [] # Generate permutations of length 3 from the set of all unique characters for perm in permutations(all_chars, 3): if sum(ord(char) for char in perm) % 3 == 0: valid_passwords.append(\'\'.join(perm)) if len(valid_passwords) == limit: break return valid_passwords"},{"question":"# Merge Multiple Lists Without Duplicates You are tasked with creating a function that takes multiple lists and merges them into one list without duplicates. The resulting list should maintain the original order of first occurrences from the input lists. Implementation Details: Implement the function `merge_lists(*lists: List[int]) -> List[int]` with the following specifications: - The function takes any number of lists of integers as arguments. - The function returns a list of integers that contains unique elements, preserving the order of their first appearance across all input lists. Input: - A variable number of lists (`lists`) where each list contains integers. Output: - A list containing unique integers from `lists` in the order of their first appearance. Constraints: - Each list in `lists` will contain between 0 and 10^3 integers. - The number of lists provided to the function will be between 1 and 10^3. Example: ```python assert merge_lists([1, 2, 3], [3, 4, 5], [6, 7, 1]) == [1, 2, 3, 4, 5, 6, 7] assert merge_lists([10, 20, 30], [30, 20, 10], [40, 50]) == [10, 20, 30, 40, 50] assert merge_lists([1, 1, 1], [1, 1], [1]) == [1] assert merge_lists([1, 2, 3], [], [4, 5], [6, 7, 8]) == [1, 2, 3, 4, 5, 6, 7, 8] assert merge_lists([]) == [] ``` Points to Consider: - Ensure no duplicates are present in the final merged list. - Maintain the order of the first appearance of each unique element. - Handle input where some of the lists may be empty.","solution":"def merge_lists(*lists): Merges multiple lists into a single list without duplicates, preserving the order of the first occurrence of each element. Parameters: lists: A variable number of lists containing integers. Returns: A list of integers with unique elements, maintaining the order of their first appearance. seen = set() result = [] for lst in lists: for item in lst: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"Problem Statement You are developing an inventory management system for a small store. The system needs to keep track of items, their prices, and the quantities in stock. Your task is to implement a function that generates a summarized inventory report displaying the most expensive items. # Input - A dictionary `inventory` where keys are the item names (strings) and values are tuples containing the price per unit (float) and the quantity in stock (integer). # Output - A list of strings, each string being the name of an item. The list should be ordered by price in descending order. If two items have the same price, order them by their name in ascending order. # Constraints - Each item\'s price is between 0.01 and 10000.00, inclusive. - Each item\'s quantity is a non-negative integer. - There will be no more than 100 items in the inventory. # Example Consider the following inventory: ```python inventory = { \\"apple\\": (0.50, 50), \\"banana\\": (0.75, 30), \\"cherry\\": (1.50, 20), \\"date\\": (1.50, 15) } ``` The function `generate_inventory_report(inventory)` should return: ```python [\\"cherry\\", \\"date\\", \\"banana\\", \\"apple\\"] ``` # Guidance 1. Create a list by iterating through the dictionary and sorting elements based on the specified criteria. 2. Utilize Python\'s built-in sorting functions effectively. # Sample Function Definition ```python def generate_inventory_report(inventory: dict[str, tuple[float, int]]) -> list[str]: # Your code here ``` # Note Ensure your solution handles the sorting and tuple operations correctly and efficiently.","solution":"def generate_inventory_report(inventory): Generates a summarized inventory report displaying the most expensive items. Args: inventory (dict): A dictionary where keys are item names (strings) and values are tuples containing the price per unit (float) and the quantity in stock (integer). Returns: list: A list of strings, each string being the name of an item, ordered by price in descending order and by name in ascending order where prices are equal. # Sort based on price in descending order and then based on names in ascending order sorted_items = sorted(inventory.items(), key=lambda item: (-item[1][0], item[0])) # Extract just the names of the items sorted_item_names = [item[0] for item in sorted_items] return sorted_item_names"},{"question":"# Sorting a List of Dictionaries by Key You are given a list of dictionaries and a key by which to sort them. Your task is to write a function that sorts the list of dictionaries based on the specified key in ascending order. If two dictionaries have the same value for the sorting key, they should remain in their original order relative to each other (maintain stability). # Function Signature ```python def sort_dicts(dicts: List[Dict[str, Any]], key: str) -> List[Dict[str, Any]]: pass ``` # Input - `dicts`: A list of dictionaries containing keys and values, where each dictionary has at least the specified key. - `key`: A string representing the key on which to sort the list of dictionaries. # Output - A list of dictionaries sorted by the specified key in ascending order. # Constraints - The list contains at least one dictionary and the specified key exists in each dictionary. - The values corresponding to the specified key are comparable (i.e., they support the `<`, `<=`, `>`, and `>=` operators). # Example ```python dicts = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"score\\": 85}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"score\\": 75}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"score\\": 90} ] key = \\"age\\" print(sort_dicts(dicts, key)) ``` # Explanation The function `sort_dicts` should sort the dictionaries in the input list based on the \\"age\\" key in ascending order. In this example, the sorted list will be: ```python [ {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"score\\": 75}, {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"score\\": 85}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"score\\": 90} ] ``` # Notes - Ensure your function maintains sorting stability, i.e., if two dictionaries have the same value for the sorting key, their original order should remain unchanged. - Consider edge cases where the list might be very large or the dictionaries have complex structures. - Optimize your implementation for performance where possible, particularly regarding the sorting algorithm choice.","solution":"from typing import List, Dict, Any def sort_dicts(dicts: List[Dict[str, Any]], key: str) -> List[Dict[str, Any]]: Sorts a list of dictionaries based on a given key in ascending order. Parameters: dicts (List[Dict[str, Any]]): List of dictionaries to sort. key (str): Key by which to sort the dictionaries. Returns: List[Dict[str, Any]]: Sorted list of dictionaries. return sorted(dicts, key=lambda x: x[key])"},{"question":"You are given a city with several isolated road segments. Initially, each road segment is represented as a separate connected component. The city planning committee has decided to add new roads to connect these segments to form a larger network. **Task**: Perform a series of road-building operations and determine which operation, if any, first connects all segments into a single connected network. **Function Signature**: ```python def connect_segments(n: int, operations: List[Tuple[int, int]]) -> int: Args: n : int : Number of isolated road segments (each segment initially in a separate connected component) operations : List[Tuple[int, int]] : A list of tuples where each tuple (u, v) signifies building a new road between segments u and v. Returns: int : The 1-based index of the operation that first connects all segments into one component, or -1 if it never happens. ``` # Input * Integer `n` representing the number of isolated road segments (1 ≤ n ≤ 10^5). * List `operations` of road-building operations [(u, v), ...] (0 ≤ u, v < n). # Output * An integer representing the 1-based index of the operation that first connects all segments into one component. If all segments cannot be connected, return -1. # Example ```python operations = [(0, 1), (1, 2), (3, 4), (2, 3)] print(connect_segments(5, operations)) # Output: 4 ``` # Explanation - After connecting segments 0 and 1, we have 4 components remaining. - After connecting segments 1 and 2, we have 3 components remaining. - After connecting segments 3 and 4, we have 2 components remaining. - After connecting segments 2 and 3, all segments are connected into a single component. Since this is the 4th operation (1-based index), the output is 4. # Constraints * Efficiently handle union-find operations to avoid time limits, using both path compression and union by rank heuristics.","solution":"from typing import List, Tuple def connect_segments(n: int, operations: List[Tuple[int, int]]) -> int: Args: n : int : Number of isolated road segments (each segment initially in a separate connected component) operations : List[Tuple[int, int]] : A list of tuples where each tuple (u, v) signifies building a new road between segments u and v. Returns: int : The 1-based index of the operation that first connects all segments into one component, or -1 if it never happens. # Union-Find data structure with path compression and union by rank parent = list(range(n)) rank = [0] * n components = n def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: nonlocal components if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 components -= 1 for index, (u, v) in enumerate(operations): union(u, v) if components == 1: return index + 1 return -1"},{"question":"# Question: Warehouse Inventory Count You are tasked with managing inventory in a large warehouse. The inventory is represented by a list of tuples, where each tuple consists of an item type (string) and the number of units of that item (integer). Write a function to compute the total count of all items in the inventory for a given item type. If the item type does not exist in the inventory, the function should return 0. **Function Signature** ```python def total_units(inventory: list[tuple[str, int]], item_type: str) -> int: pass ``` **Input** - `inventory` (List[Tuple[str, int]]): A list of tuples containing item types and their respective unit counts. - `item_type` (str): The type of item whose total unit count needs to be calculated. **Output** - Returns an integer representing the total count of units for the specified item type. **Constraints** - `1 <= len(inventory) <= 10^5` - `1 <= len(item_type) <= 100` - `0 <= units <= 1000` for each tuple in the inventory **Example** ```python inventory = [ (\\"apple\\", 10), (\\"banana\\", 5), (\\"apple\\", 4), (\\"orange\\", 7) ] assert total_units(inventory, \\"apple\\") == 14 # 10 + 4 units assert total_units(inventory, \\"banana\\") == 5 # 5 units assert total_units(inventory, \\"cherry\\") == 0 # no such item type assert total_units(inventory, \\"orange\\") == 7 # 7 units ``` **Explanation** Implement the `total_units` function by: 1. Iterating through the inventory list. 2. Summing up the unit counts for the specified `item_type`. 3. Returning the total count. This function should efficiently handle large lists while ensuring utmost accuracy.","solution":"def total_units(inventory: list[tuple[str, int]], item_type: str) -> int: Computes the total count of units for a specified item type in the inventory. Parameters: - inventory: a list of tuples, where each tuple consists of an item type (str) and number of units (int). - item_type: the type of item whose total unit count needs to be calculated (str). Returns: - int: Total count of units for the specified item type. Returns 0 if the item type does not exist in the inventory. total = 0 for item in inventory: if item[0] == item_type: total += item[1] return total # Example usage: inventory = [ (\\"apple\\", 10), (\\"banana\\", 5), (\\"apple\\", 4), (\\"orange\\", 7) ] assert total_units(inventory, \\"apple\\") == 14 assert total_units(inventory, \\"banana\\") == 5 assert total_units(inventory, \\"cherry\\") == 0 assert total_units(inventory, \\"orange\\") == 7"},{"question":"# Coding Question: Online Store Inventory Management An online store requires a function to manage its product inventory. The store keeps track of products and their quantities in an inventory system, and it needs a function to update this inventory based on purchase transactions. Each transaction either buys a single product, reducing its inventory, or returns a single product, increasing its inventory. The function must handle situations where a purchase is attempted for an out-of-stock product. Objective Write a function `update_inventory(inventory: dict, transactions: list)` that takes the following parameters: - `inventory` (dict): A dictionary representing the store\'s inventory where keys are product names (strings) and values are quantities (integers). - `transactions` (list): A list of transactions where each transaction is a tuple (str, str), with the first string being the product name and the second string being either \\"buy\\" or \\"return\\". Function Specifications: * The function should update the inventory quantities based on the transactions. * If a \\"buy\\" transaction is attempted on an out-of-stock product, the function should print an error message and skip that transaction. * After processing all transactions, the function should return the updated inventory dictionary. Input: - `inventory` (dict): e.g., {\\"apple\\": 5, \\"banana\\": 2, \\"orange\\": 0} - `transactions` (list): e.g., [(\\"apple\\", \\"buy\\"), (\\"banana\\", \\"buy\\"), (\\"orange\\", \\"buy\\"), (\\"apple\\", \\"return\\")] Output: - A dictionary where keys are product names and values are updated quantities after processing all transactions. Constraints: - Each transaction affects a single product. - The product names in the transactions are guaranteed to be present in the inventory. - Quantity values in the inventory are non-negative integers. Example Function Call: ```python inventory = {\\"apple\\": 5, \\"banana\\": 2, \\"orange\\": 0} transactions = [(\\"apple\\", \\"buy\\"), (\\"banana\\", \\"buy\\"), (\\"orange\\", \\"buy\\"), (\\"apple\\", \\"return\\")] updated_inventory = update_inventory(inventory, transactions) print(updated_inventory) ``` This should produce output similar to: ``` Error: Cannot buy \'orange\' as it is out of stock. {\'apple\': 4, \'banana\': 1, \'orange\': 0} ``` # Additional Notes: - Make sure to handle the possibility of purchasing from an out-of-stock product gracefully by printing a meaningful error message. - The \\"return\\" transactions should be straightforward since they only increment the product\'s quantity.","solution":"def update_inventory(inventory, transactions): Updates the inventory quantities based on the transactions. Parameters: inventory (dict): A dictionary where keys are product names (strings) and values are quantities (integers). transactions (list): A list of transactions where each transaction is a tuple (str, str), with the first string being the product name and the second string being either \\"buy\\" or \\"return\\". Returns: dict: The updated inventory dictionary. for product, action in transactions: if action == \\"buy\\": if inventory[product] > 0: inventory[product] -= 1 else: print(f\\"Error: Cannot buy \'{product}\' as it is out of stock.\\") elif action == \\"return\\": inventory[product] += 1 return inventory"},{"question":"Binary Search Tree with Additional Functionalities You are tasked with implementing a Binary Search Tree (BST) with the following functionalities: 1. Insert nodes into the BST. 2. Search for a given node in the BST. 3. Calculate the height of the BST. 4. Find nodes within a given range. # Function Requirements 1. `insert(self, data)`: Insert a single element into the BST. 2. `search(self, data)`: Search for an element in the BST; return `True` if it exists, otherwise `False`. 3. `height(self)`: Compute the height of the BST. 4. `find_in_range(self, start, end)`: Find and return all nodes within the given range `[start, end]`. # Input and Output - `insert(self, data)` - **Input**: An integer `data`. - **Output**: None. - `search(self, data)` - **Input**: An integer `data`. - **Output**: `True` if the element is found, otherwise `False`. - `height(self)` - **Input**: None. - **Output**: An integer representing the height of the BST. - `find_in_range(self, start, end)` - **Input**: Two integers `start` and `end`, representing the inclusive range. - **Output**: A list of elements within the given range `[start, end]`. # Constraints - Only integer keys are supported. - Duplicates are not allowed in the BST. - The BST should be balanced by only the insertion order; no self-balancing trees like AVL or Red-Black Trees are required. # Example ```python bst = BinarySearchTree() # Insert elements bst.insert(10) bst.insert(20) bst.insert(5) bst.insert(15) print(bst.in_order_traversal()) # => [5, 10, 15, 20] # Search elements print(bst.search(15)) # => True print(bst.search(25)) # => False # Height of the BST print(bst.height()) # => 3 # Find elements in range print(bst.find_in_range(5, 15)) # => [5, 10, 15] ``` # Implementation Implement the necessary methods to complete the `BinarySearchTree` class, ensuring efficient insertion, search, height calculation, and extracting nodes within a range using the properties of binary search trees.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, data): if self.root is None: self.root = Node(data) else: self._insert(self.root, data) def _insert(self, root, data): if data < root.val: if root.left is None: root.left = Node(data) else: self._insert(root.left, data) elif data > root.val: if root.right is None: root.right = Node(data) else: self._insert(root.right, data) def search(self, data): return self._search(self.root, data) def _search(self, root, data): if root is None: return False if root.val == data: return True elif data < root.val: return self._search(root.left, data) else: return self._search(root.right, data) def height(self): return self._height(self.root) def _height(self, root): if root is None: return 0 left_height = self._height(root.left) right_height = self._height(root.right) return max(left_height, right_height) + 1 def find_in_range(self, start, end): result = [] self._find_in_range(self.root, start, end, result) return result def _find_in_range(self, root, start, end, result): if root is None: return if start <= root.val <= end: self._find_in_range(root.left, start, end, result) result.append(root.val) self._find_in_range(root.right, start, end, result) elif root.val < start: self._find_in_range(root.right, start, end, result) else: self._find_in_range(root.left, start, end, result)"},{"question":"# Product Inventory Management As part of a product inventory management system, you are required to implement a function that accepts a list of product names and their respective quantities and returns a dictionary representing the inventory with product names as keys and their quantities as values. # Function Specification **Function Name**: `update_inventory` **Input**: 1. `products` (List[Tuple[str, int]]): A list of tuples where each tuple contains a product name (string) and its quantity (integer). **Output**: - Returns a dictionary where the keys are product names (string) and the values are the total quantities (integer) of those products. # Constraints: - The list of products will contain at most 10^4 entries. - The product names will be non-empty strings consisting of printable ASCII characters. - The quantities will be non-negative integers. # Examples: ```python update_inventory([(\\"apple\\", 10), (\\"banana\\", 5), (\\"apple\\", 3), (\\"orange\\", 7)]) # Output: {\'apple\': 13, \'banana\': 5, \'orange\': 7} update_inventory([(\\"notebook\\", 2), (\\"pen\\", 15), (\\"notebook\\", 3)]) # Output: {\'notebook\': 5, \'pen\': 15} update_inventory([]) # Output: {} ``` # Additional Notes: - Ensure that your function handles cases where the product list is empty. - If a product appears multiple times in the list, sum their quantities in the resulting dictionary. Write the function `update_inventory` such that it aggregates the quantities of products efficiently.","solution":"def update_inventory(products): Update the product inventory based on the list of products and their quantities. Args: products (List[Tuple[str, int]]): A list of tuples where each tuple contains a product name and its quantity. Returns: dict: A dictionary with product names as keys and their corresponding total quantities as values. inventory = {} for product, quantity in products: if product in inventory: inventory[product] += quantity else: inventory[product] = quantity return inventory"},{"question":"# Sort Student Records Challenge Objective You are tasked to implement a function to sort a list of student records based on multiple criteria. Scenario Consider a program that needs to manage and sort student records for a university. Each record contains a student\'s name, age, and GPA (Grade Point Average). The sorting should be reliable and handle different edge cases appropriately. Function Specifications: * **Function Name**: `sort_students` * **Input**: A list of dictionaries, where each dictionary represents a student record with the keys: - `name` (string) - `age` (integer) - `gpa` (float) * **Output**: Returns a sorted list of student records. * **Constraints**: - The sorting should be done first by GPA in descending order, then by age in ascending order, and finally by name in ascending order. - The function should raise a `ValueError` with the message \\"Invalid student record\\" if any student record does not contain the required keys or has invalid types. * **Performance Requirements**: Optimize for clarity and avoid unnecessary complex operations. Example Usage ```python # Example student records students = [ {\\"name\\": \\"Alice\\", \\"age\\": 22, \\"gpa\\": 3.5}, {\\"name\\": \\"Bob\\", \\"age\\": 20, \\"gpa\\": 3.7}, {\\"name\\": \\"Charlie\\", \\"age\\": 22, \\"gpa\\": 3.5}, {\\"name\\": \\"David\\", \\"age\\": 20, \\"gpa\\": 3.9}, {\\"name\\": \\"Eve\\", \\"age\\": 21, \\"gpa\\": 3.7}, ] # Function call sorted_students = sort_students(students) # Sorted student list should be expected_sorted_students = [ {\\"name\\": \\"David\\", \\"age\\": 20, \\"gpa\\": 3.9}, {\\"name\\": \\"Eve\\", \\"age\\": 21, \\"gpa\\": 3.7}, {\\"name\\": \\"Bob\\", \\"age\\": 20, \\"gpa\\": 3.7}, {\\"name\\": \\"Alice\\", \\"age\\": 22, \\"gpa\\": 3.5}, {\\"name\\": \\"Charlie\\", \\"age\\": 22, \\"gpa\\": 3.5}, ] assert sorted_students == expected_sorted_students # Invalid record examples invalid_students = [ {\\"name\\": \\"Alice\\", \\"age\\": 22}, # Missing GPA {\\"name\\": \\"Bob\\", \\"age\\": \\"twenty\\", \\"gpa\\": 3.7}, # Age is not an integer {\\"name\\": \\"Charlie\\", \\"age\\": 22, \\"gpa\\": \\"3.5\\"}, # GPA is not a float ] for record in invalid_students: try: sort_students([record]) except ValueError as e: assert str(e) == \\"Invalid student record\\" ```","solution":"def sort_students(students): Sorts the student records first by GPA in descending order, then by age in ascending order, and finally by name in ascending order. Parameters: students (list): List of dictionaries, where each dictionary has keys \'name\' (string), \'age\' (integer), and \'gpa\' (float). Returns: list: Sorted list of student records. Raises: ValueError: If any student record is invalid. expected_keys = {\'name\', \'age\', \'gpa\'} for student in students: if not expected_keys.issubset(student.keys()): raise ValueError(\\"Invalid student record\\") if not isinstance(student[\'name\'], str): raise ValueError(\\"Invalid student record\\") if not isinstance(student[\'age\'], int): raise ValueError(\\"Invalid student record\\") if not isinstance(student[\'gpa\'], float): raise ValueError(\\"Invalid student record\\") sorted_students = sorted(students, key=lambda x: (-x[\'gpa\'], x[\'age\'], x[\'name\'])) return sorted_students"},{"question":"# Fibonacci Sequence Calculator **Scenario**: You are tasked with creating a tool to aid in computational mathematics, specifically focusing on the Fibonacci sequence, which is a critical concept in computer science and mathematics. **Problem Statement**: Implement a function `custom_fibonacci` that takes in a non-negative integer `n` and returns the `n`-th Fibonacci number. The Fibonacci sequence is defined as: - ( F(0) = 0 ) - ( F(1) = 1 ) - ( F(n) = F(n-1) + F(n-2) ) for ( n > 1 ) The function should use an iterative approach to efficiently compute the Fibonacci number without using recursion to avoid potential stack overflow issues for large values of `n`. **Constraints**: - The input must be a non-negative integer less than or equal to 1000. **Function Signature**: ```python def custom_fibonacci(n: int) -> int: pass ``` # Example ```python >>> custom_fibonacci(0) 0 >>> custom_fibonacci(1) 1 >>> custom_fibonacci(10) 55 >>> custom_fibonacci(20) 6765 ``` # Notes: 1. If the input does not meet the constraints, your function should raise a `ValueError` with the error message \\"Input should be a non-negative integer less than or equal to 1000.\\" 2. You should aim for an efficient solution that runs in (O(n)) time complexity using constant (O(1)) space complexity (excluding the input and output). 3. For consistency in testing, use the following constants if needed: ```python MAX_N = 1000 ```","solution":"def custom_fibonacci(n: int) -> int: Returns the n-th Fibonacci number. if not isinstance(n, int) or n < 0 or n > 1000: raise ValueError(\\"Input should be a non-negative integer less than or equal to 1000.\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Objective You are to implement an efficient function to determine the longest substring of a given string that consists of unique characters. This task assesses your understanding of string manipulation, hashmaps, and efficient algorithm implementation. # Problem Statement Write a Python function `longest_unique_substring(s: str) -> str` that takes a single string (s) and returns the longest substring of (s) that contains all unique characters. # Input and Output: * **Input**: A string (s). * **Output**: The longest substring of (s) that contains all unique characters. # Constraints: 1. (s) will be a non-empty string of arbitrary length. 2. Minimize the time complexity to ensure efficient execution even for long strings. # Function Signature: ```python def longest_unique_substring(s: str) -> str: ``` # Example Input and Output * Input: `s = \\"abcabcbb\\"` * Output: `\\"abc\\"` * Input: `s = \\"bbbbb\\"` * Output: `\\"b\\"` * Input: `s = \\"pwwkew\\"` * Output: `\\"wke\\"` * Input: `s = \\"abcdabcde\\"` * Output: `\\"abcde\\"` # Constraints and Considerations: 1. **Edge Cases**: * The input string consists of identical characters. * The input string has all unique characters. * Non-alphabetic characters in the input string. 2. **Performance**: * Ensure handling of long strings efficiently. * Avoid excessive computational complexity and redundant calculations. # Approach: 1. Utilize a sliding window technique to keep track of unique characters. 2. Use a hashmap or set to track characters within the current window and their indices. 3. Adjust the window size dynamically when a repeated character is encountered. 4. Keep track of the maximum length and starting index of the longest unique substring.","solution":"def longest_unique_substring(s: str) -> str: Returns the longest substring of `s` that contains all unique characters. start = 0 max_len = 0 max_sub_start = 0 seen = {} for idx, char in enumerate(s): if char in seen and seen[char] >= start: start = seen[char] + 1 seen[char] = idx if idx - start + 1 > max_len: max_len = idx - start + 1 max_sub_start = start return s[max_sub_start:max_sub_start + max_len]"},{"question":"# File System Management You are tasked with designing a virtual file system that allows the creation, deletion, and navigation of directories and files. Your file system should support nested directories and files. Problem Statement Implement a `FileSystem` class with the following functionality: 1. **Initialization**: - A constructor that initializes an empty root directory. 2. **Directory Creation**: - Implement a method to create a directory at a specified path. 3. **File Creation**: - Implement a method to create a file with a given name and content at a specified path. 4. **File Reading**: - Implement a method to read the content of a file at a specified path. 5. **File Deletion**: - Implement a method to delete a file at a specified path. 6. **Directory Deletion**: - Implement a method to delete a directory at a specified path. If the directory is not empty, all contents should be recursively deleted. 7. **Navigation**: - Implement methods to change the current directory and to list the contents of the current directory. Example ```python fs = FileSystem() fs.create_directory(\\"/home\\") fs.create_directory(\\"/home/user\\") fs.create_file(\\"/home/user/file1.txt\\", \\"Hello World\\") print(fs.read_file(\\"/home/user/file1.txt\\")) # Output: \\"Hello World\\" fs.create_file(\\"/home/user/file2.txt\\", \\"Another file\\") fs.change_directory(\\"/home/user\\") print(fs.list_directory()) # Output: [\\"file1.txt\\", \\"file2.txt\\"] fs.delete_file(\\"/home/user/file1.txt\\") print(fs.list_directory()) # Output: [\\"file2.txt\\"] fs.delete_directory(\\"/home\\") print(fs.list_directory(\\"/\\")) # Output: [] ``` Constraints - Path names and file names are non-empty strings and contain only alphanumeric characters and slashes (`/`). - Paths are provided in absolute form, starting with the root directory (`/`). - The system should raise appropriate errors if operations are attempted on non-existent paths or if invalid operations are performed (e.g., creating a file in a non-existent directory). Implement the `FileSystem` class with the described methods and properties.","solution":"class FileSystem: def __init__(self): self.root = {\'/\': {}} self.current_directory = \'/\' def _get_element(self, path): elements = path.strip(\'/\').split(\'/\') current = self.root[\'/\'] for element in elements: if element: current = current.get(element, None) if current is None: return None return current def create_directory(self, path): elements = path.strip(\'/\').split(\'/\') current = self.root[\'/\'] for element in elements: if element not in current: current[element] = {} current = current[element] def create_file(self, path, content): *dirs, filename = path.strip(\'/\').split(\'/\') current = self.root[\'/\'] for dir_ in dirs: if dir_ not in current: raise FileNotFoundError(f\\"Directory {dir_} does not exist.\\") current = current[dir_] if filename in current: raise FileExistsError(f\\"File {filename} already exists.\\") current[filename] = content def read_file(self, path): *dirs, filename = path.strip(\'/\').split(\'/\') current = self.root[\'/\'] for dir_ in dirs: if dir_ not in current: raise FileNotFoundError(f\\"Directory {dir_} does not exist.\\") current = current[dir_] if filename not in current: raise FileNotFoundError(f\\"File {filename} does not exist.\\") return current[filename] def delete_file(self, path): *dirs, filename = path.strip(\'/\').split(\'/\') current = self.root[\'/\'] for dir_ in dirs: if dir_ not in current: raise FileNotFoundError(f\\"Directory {dir_} does not exist.\\") current = current[dir_] if filename not in current: raise FileNotFoundError(f\\"File {filename} does not exist.\\") del current[filename] def delete_directory(self, path): elements = path.strip(\'/\').split(\'/\') current = self.root[\'/\'] for element in elements[:-1]: current = current[element] del current[elements[-1]] def change_directory(self, path): if self._get_element(path) is None: raise FileNotFoundError(f\\"Directory {path} does not exist.\\") self.current_directory = path def list_directory(self, path=None): if path is None: path = self.current_directory current = self._get_element(path) if current is None: raise FileNotFoundError(f\\"Directory {path} does not exist.\\") return list(current.keys())"},{"question":"# Time Until Collision **Problem Statement**: In a one-dimensional space, two particles are moving towards each other with constant velocities. Given the initial positions and velocities of these particles, determine the time until they collide. The particles will collide if they occupy the same position at the same time. You are given a function `time_until_collision` that computes the collision time given initial positions and velocities of two particles. The function should: 1. Implement the `time_until_collision` function. 2. Raise appropriate exceptions for the edge cases: - Velocities are equal and positions are different. 3. Ensure that your function passes the provided doctest cases. Function Signature ```python def time_until_collision(pos1: float, vel1: float, pos2: float, vel2: float) -> float: pass ``` Input - `pos1`: A float representing the initial position of the first particle. - `vel1`: A float representing the velocity of the first particle. - `pos2`: A float representing the initial position of the second particle. - `vel2`: A float representing the velocity of the second particle. Output - Returns a float representing the time in seconds until the particles collide. Constraints - The positions (`pos1`, `pos2`) can be any float values. - The velocities (`vel1`, `vel2`) can be any float values. Example ```python >>> time_until_collision(0, 2, 10, -3) 2.0 >>> time_until_collision(0, 1, 0, -1) 0.0 >>> time_until_collision(0, 1, 10, 1) Traceback (most recent call last): ... ValueError: Velocities are equal and positions are different; no collision possible. ``` Additional Requirements - Handle the case where the velocities are equal and positions are different by raising an exception with the message \\"Velocities are equal and positions are different; no collision possible\\". # Solution ```python def time_until_collision(pos1: float, vel1: float, pos2: float, vel2: float) -> float: if vel1 == vel2: if pos1 != pos2: raise ValueError(\\"Velocities are equal and positions are different; no collision possible.\\") return 0.0 # If velocities and positions are the same, they are already at the same position. collision_time = (pos2 - pos1) / (vel1 - vel2) return max(collision_time, 0.0) # collision_time cannot be negative ``` Note: - If the velocities are equal and the initial positions are different, the particles will never collide, hence an exception is raised. - If the particles are initially at the same position, they have already collided, hence the return value is 0.0.","solution":"def time_until_collision(pos1: float, vel1: float, pos2: float, vel2: float) -> float: if vel1 == vel2: if pos1 != pos2: raise ValueError(\\"Velocities are equal and positions are different; no collision possible.\\") return 0.0 # If velocities and positions are the same, they are already at the same position. collision_time = (pos2 - pos1) / (vel1 - vel2) return max(collision_time, 0.0) # collision_time cannot be negative"},{"question":"# Scenario: You are tasked with optimizing a route for delivery drivers. Given a grid representing a city where each cell contains a package value, you need to determine the maximum package value that a driver can collect if they are constrained to moving either to the right or downward, starting from the top-left corner and ending at the bottom-right corner of the grid. # Task: Implement a function `max_package_value(grid: list[list[int]]) -> int` that computes the maximum package value a delivery driver can collect on their route from the top-left to the bottom-right corner of the grid by only moving right or down. # Function Signature: ```python def max_package_value(grid: list[list[int]]) -> int: pass ``` # Input: * `grid`: A 2D list of integers where `grid[i][j]` represents the package value at the cell (i, j) in the grid. # Output: * Return an integer representing the maximum package value that can be collected on the route. # Example: ```python >>> max_package_value([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_package_value([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 ``` # Constraints: * The grid will have dimensions `m x n` where 1 ≤ m, n ≤ 100. * The package values in the grid cells are non-negative integers. # Notes: * The solution should efficiently handle the given constraints. * Consider using dynamic programming to compute the maximum package value.","solution":"def max_package_value(grid): Returns the maximum package value a delivery driver can collect on their route from the top-left to the bottom-right corner of the grid by only moving right or down. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Create a DP table with the same dimensions as the grid dp = [[0] * n for _ in range(m)] # Initialize the first cell with the grid\'s first cell value dp[0][0] = grid[0][0] # Fill in the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill in the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill in the rest of the DP table for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"# Problem Statement You are required to write a function that takes in a non-negative integer and returns its hexadecimal (base-16) string representation in lowercase. This task tests your ability to handle number conversion and string formatting. # Function Signature ```python def integer_to_hexadecimal(number: int) -> str: ``` # Input - `number` (int): A non-negative integer that needs to be converted to its hexadecimal representation. # Output - Returns a string representing the hexadecimal equivalent of the input integer in lowercase. # Constraints - The input integer will be in the range [0, 2^31 - 1]. - The function should raise a `ValueError` with the message \\"Negative value was passed to the function\\" if the input is a negative integer. # Example ```python >>> integer_to_hexadecimal(255) \'ff\' >>> integer_to_hexadecimal(0) \'0\' >>> integer_to_hexadecimal(16) \'10\' >>> integer_to_hexadecimal(-5) Traceback (most recent call last): ... ValueError: Negative value was passed to the function ``` # Performance Requirements - The function should run in O(log(n)) time complexity, where n is the input value. - The function should use O(1) additional space for the output string, not including the space required for the final output. # Guidelines 1. First, handle the edge case of a negative input integer. 2. Handle the edge case where the number is zero. 3. Compute the hexadecimal representation by repeatedly dividing the number by 16 and collecting the remainder. 4. Use a dictionary or string to map remainders to their corresponding hexadecimal characters. 5. Construct the hexadecimal string in the correct order and return it.","solution":"def integer_to_hexadecimal(number: int) -> str: Converts a non-negative integer to its hexadecimal string representation in lowercase. Args: number (int): A non-negative integer to be converted. Returns: str: Hexadecimal string representation of the input integer in lowercase. Raises: ValueError: If a negative integer is passed. if number < 0: raise ValueError(\\"Negative value was passed to the function\\") if number == 0: return \\"0\\" hex_chars = \\"0123456789abcdef\\" hex_result = \\"\\" while number > 0: remainder = number % 16 hex_result = hex_chars[remainder] + hex_result number //= 16 return hex_result"},{"question":"# Converting Decimal to Fraction and Simplification Problem Statement You are given a decimal number represented as a string. Your task is to convert this decimal number to its simplest fractional representation. If the decimal input can be represented as a terminating or repeating decimal fraction, the output must capture this correctly and simplify the fraction to its lowest terms. Task Write a function `decimal_to_fraction` that converts a decimal number represented as a string to a fraction in its simplest form. # Function Signature ```python def decimal_to_fraction(decimal_str: str) -> str: ``` Parameters - `decimal_str` (str): The decimal number represented as a string. Returns - `str`: The simplest fractional representation of the decimal number. Example ```python assert decimal_to_fraction(\\"0.75\\") == \\"3/4\\" assert decimal_to_fraction(\\"0.333\\") == \\"333/1000\\" assert decimal_to_fraction(\\"1.25\\") == \\"5/4\\" assert decimal_to_fraction(\\"0.666666666666\\") == \\"2/3\\" ``` Constraints - The input decimal string will be a valid decimal number (e.g., \\"0.75\\", \\"0.333\\", \\"1.25\\"). - The length of the decimal string will not exceed 15 characters. - The decimal string may represent both terminating and repeating decimals. Scenario You are tasked with developing a feature for a financial software application that converts and simplifies periodic decimal representations into their fractional equivalents for better readability and exact computation. This function is fundamental for the accuracy of their financial models and comparative analytics.","solution":"from fractions import Fraction def decimal_to_fraction(decimal_str: str) -> str: Convert a decimal number represented as a string to its simplest fractional form. fraction = Fraction(decimal_str).limit_denominator() return f\\"{fraction.numerator}/{fraction.denominator}\\""},{"question":"# Problem Statement You are given a list of dates in the format `DD-MM-YYYY`. Your task is to determine the date that is the latest (most recent). If there are multiple latest dates, return the one that appears first in the list. * **Input**: A list of strings `dates` where each string represents a date in the format `DD-MM-YYYY`. * **Output**: A string representing the latest date in the input list in the same format `DD-MM-YYYY`. # Constraints * Dates are properly formatted. * There is at least one date in the list. * The list length does not exceed 1000. # Example Given the list of dates: ```python dates = [\\"12-05-2021\\", \\"25-12-2020\\", \\"01-01-2022\\", \\"12-05-2021\\"] ``` The correct output would be `\\"01-01-2022\\"`. # Function Signature ```python def find_latest_date(dates: list) -> str: pass ``` # Requirements * Efficiently compare dates to find the latest one. * Handle the date format parsing and conversion correctly. * The solution should account for varying list lengths and efficiently handle them in terms of both time and space.","solution":"from datetime import datetime def find_latest_date(dates: list) -> str: Returns the latest date from the list of dates in DD-MM-YYYY format. :param dates: List of dates in DD-MM-YYYY format :return: The latest date in the same format date_format = \\"%d-%m-%Y\\" latest_date = None for date_str in dates: date_obj = datetime.strptime(date_str, date_format) if latest_date is None or date_obj > latest_date: latest_date = date_obj return latest_date.strftime(date_format)"},{"question":"# Problem Statement: Scenario: A software engineer is tasked with analyzing a list of tasks, each associated with a priority level. The goal is to identify the task configuration that yields the maximum possible priority score under certain constraints. Each task can either be included or excluded from the configuration, but only tasks with consecutive priority levels can be included together. Your task is to write an algorithm that determines the highest achievable priority score by selecting a valid configuration of tasks. Function Signature: ```python def max_priority_score(tasks: List[Tuple[int, int]]) -> int: pass ``` Input: 1. **tasks** (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers `(task_id, priority_level)`. Each task has a unique `task_id` and a priority level. Output: - **max_score** (int): The maximum priority score achievable by selecting a valid configuration of tasks. Constraints: - 1 <= len(tasks) <= 10,000 - 1 <= task_id <= 100,000 - 1 <= priority_level <= 100,000 Requirements: - The function should handle large inputs efficiently. - Priority levels must be consecutive in the configuration. - Proper error handling for invalid inputs is required. Example: ```python print(max_priority_score([(1, 3), (2, 4), (3, 5), (4, 1)])) # Expected output: 12 (priority levels 3, 4, 5) print(max_priority_score([(1, 10), (2, 9), (3, 8), (4, 11)])) # Expected output: 30 (priority levels 8, 9, 10, 11) ``` Additional Information: - A valid configuration consists of tasks whose priority levels form a sequence of consecutive integers. - For example, given tasks with priority levels [3, 4, 5, 1], the valid configurations are [3, 4, 5] and [1], with the maximum priority score of 12. **Note**: Ensure that your algorithm efficiently processes the input to determine the optimal configuration. The function should aim for a solution with a time complexity of O(n log n) or better. ```python def max_priority_score(tasks): # Your implementation here print(max_priority_score([(1, 3), (2, 4), (3, 5), (4, 1)])) # Expected output: 12 print(max_priority_score([(1, 10), (2, 9), (3, 8), (4, 11)])) # Expected output: 30 ```","solution":"def max_priority_score(tasks): Returns the maximum priority score achievable by selecting a valid configuration of tasks with consecutive priority levels. if not tasks: return 0 # Sort tasks by priority level sorted_tasks = sorted(tasks, key=lambda x: x[1]) max_score = 0 current_score = 0 previous_priority = None for i in range(len(sorted_tasks)): task_id, priority = sorted_tasks[i] if previous_priority is not None and priority == previous_priority + 1: current_score += priority else: max_score = max(max_score, current_score) current_score = priority previous_priority = priority max_score = max(max_score, current_score) # Handle the last sequence return max_score"},{"question":"# Binary Tree Level Order Traversal Objective Implement a function to perform a level order traversal on a binary tree. Task Write a function `levelOrderTraversal(root: Optional[TreeNode]) -> List[List[int]]`: * **Input**: - The root of a binary tree represented by the `TreeNode` class. * **Output**: - A list of lists, where each sublist contains the values of the nodes at that level from left to right. Function Details # Parameters: `root`: The root node of a binary tree. # Returns: A list of lists where each inner list represents the node values at each level of the tree. # Description: - Use a queue to implement the breadth-first search (BFS) algorithm to traverse the tree level-by-level. - Add the node values at each level to a list. - Continue until all levels have been traversed. Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Create the binary tree # 1 # / # 2 3 # / # 4 5 6 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.right = TreeNode(6) >>> levelOrderTraversal(root) [[1], [2, 3], [4, 5, 6]] ``` # Constraints - The function should handle trees with up to 10,000 nodes efficiently. - Ensure your solution does not use more space than necessary. # Notes: - Consider edge cases such as an empty tree (where root is `None`). - Ensure the function handles trees with varying structures and heights effectively.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def levelOrderTraversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"# Balanced Binary Search Tree Insertion You are asked to implement an algorithm to insert values into a Binary Search Tree (BST) and ensure it remains balanced. The balancing should be done using the AVL tree rotation techniques. # Task Implement an AVL tree to handle insertions and maintain balance by performing necessary rotations. # Input - An integer `N` representing the number of values to be inserted. - `N` integers representing the values to be inserted sequentially into the BST. # Output - Print the pre-order traversal of the height-balanced BST after all insertions are made. # Constraints - `1 <= N <= 10^5` - `-10^6 <= value <= 10^6` # Example Input ``` 7 10 20 30 40 50 25 15 ``` Output ``` 30 20 10 15 25 40 50 ``` # Notes - The AVL tree should always maintain the property of being balanced after each insertion. - Use rotation techniques (left, right, left-right, right-left) as necessary to maintain the balance. - Ensure your solution efficiently handles the given constraints with proper balancing after each insertion.","solution":"class AVLNode: def __init__(self, key): self.key = key self.height = 1 self.left = None self.right = None class AVLTree: def insert(self, root, key): if not root: return AVLNode(key) if key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.getHeight(root.left), self.getHeight(root.right)) balanceFactor = self.getBalance(root) if balanceFactor > 1: if key < root.left.key: return self.rightRotate(root) else: root.left = self.leftRotate(root.left) return self.rightRotate(root) if balanceFactor < -1: if key > root.right.key: return self.leftRotate(root) else: root.right = self.rightRotate(root.right) return self.leftRotate(root) return root def leftRotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.getHeight(z.left), self.getHeight(z.right)) y.height = 1 + max(self.getHeight(y.left), self.getHeight(y.right)) return y def rightRotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.getHeight(z.left), self.getHeight(z.right)) y.height = 1 + max(self.getHeight(y.left), self.getHeight(y.right)) return y def getHeight(self, root): if not root: return 0 return root.height def getBalance(self, root): if not root: return 0 return self.getHeight(root.left) - self.getHeight(root.right) def preOrder(self, root): if not root: return [] return [root.key] + self.preOrder(root.left) + self.preOrder(root.right) def balanced_bst_insertion(N, values): tree = AVLTree() root = None for value in values: root = tree.insert(root, value) return tree.preOrder(root)"},{"question":"# Objective Implement a file processor that performs word frequency analysis and generates a summary report. # Scenario In this problem, you need to implement a class `WordFrequencyAnalyzer` that can read a text file, analyze the frequency of each word, and generate a summary report. This will assess your ability to work with file I/O, data structures, and string manipulation. # Task - Implement the `WordFrequencyAnalyzer` class with the following methods: 1. `__init__(self, filename: str) -> None`: Initializes the object with the provided file name. 2. `analyze(self) -> None`: Reads the file contents, analyzes word frequencies, and stores the results internally. 3. `summary(self, top_n: int) -> str`: Generates a summary report of the top `n` most frequent words. # Implementation Details 1. **Characteristics**: - Words should be considered case-insensitive (e.g., \\"Hello\\" and \\"hello\\" are the same word). - Strip punctuation and special characters from the words. - Calculate the frequency of each unique word. 2. **Input/Output**: - `__init__`: Initializes the analyzer object with the file name. - Input: filename (str) - Output: None - `analyze`: Reads the file and performs word frequency analysis. - Input: None - Output: None - `summary`: Generates a summary report of the top `n` most frequent words. - Input: top_n (int) - Output: summary report (str) 3. **Constraints**: - The file should be a readable text file with typical content length (< 10,000 words). - Handle file reading errors gracefully and provide meaningful error messages. # Example Suppose you have a file `example.txt` containing: ``` Hello, world! This is a test. Hello again. World test, hello. ``` ```python analyzer = WordFrequencyAnalyzer(\\"example.txt\\") analyzer.analyze() report = analyzer.summary(3) print(report) ``` Output: ``` 1. hello: 3 2. world: 2 3. test: 2 ``` 4. **Performance Requirements**: - The solution should be efficient in terms of both time and space, handling reasonably large files without excessive memory usage. # Additional Considerations - Ensure the implementation can handle edge cases, such as empty files or files with only one word. - Utilize appropriate data structures for counting and sorting words efficiently (e.g., dictionaries, Counter from collections module).","solution":"import os import string from collections import Counter class WordFrequencyAnalyzer: def __init__(self, filename: str) -> None: self.filename = filename self.word_counts = Counter() def analyze(self) -> None: Reads the file contents and analyzes word frequencies. if not os.path.isfile(self.filename): raise FileNotFoundError(f\\"File {self.filename} not found.\\") with open(self.filename, \'r\', encoding=\'utf-8\') as file: for line in file: # Remove punctuation and convert to lowercase line = line.translate(str.maketrans(\'\', \'\', string.punctuation)).lower() words = line.split() self.word_counts.update(words) def summary(self, top_n: int) -> str: Generates a summary report of the top n most frequent words. if not self.word_counts: return \\"No words analyzed. Please run analyze() first.\\" most_common_words = self.word_counts.most_common(top_n) summary_lines = [f\\"{i+1}. {word}: {count}\\" for i, (word, count) in enumerate(most_common_words)] return \\"n\\".join(summary_lines)"},{"question":"# Coding Assessment Question: Non-repeating Substring Generator Context You are required to generate the longest substring of a given string that does not contain any repeating characters. Task Write a function `longest_non_repeating_substring(s: str) -> str` that returns the longest substring of the input string `s` that contains no repeating characters. Input * `s`: A string composed of ASCII characters. Output * Returns a string representing the longest substring without repeating characters. Constraints 1. The input string size will be between 0 and 10^4 characters. 2. If there are multiple substrings of the same maximum length, return the first one encountered. Example ```python longest_non_repeating_substring(\\"abcabcbb\\") ``` **Expected Output**: ```python \'abc\' ``` Additional Examples ```python longest_non_repeating_substring(\\"bbbbb\\") ``` **Expected Output**: ```python \'b\' longest_non_repeating_substring(\\"pwwkew\\") ``` **Expected Output**: ```python \'wke\' longest_non_repeating_substring(\\"\\") ``` **Expected Output**: ```python \'\' ``` Notes 1. Ensure that your function handles edge cases, such as an empty input string. 2. Optimize the function to handle inputs at the upper constraint limit efficiently. 3. Make sure the function returns the first longest substring encountered if there are multiple with the same length.","solution":"def longest_non_repeating_substring(s: str) -> str: Returns the longest substring of the input string s that contains no repeating characters. n = len(s) if n == 0: return \\"\\" char_index = {} max_len = 0 start = 0 longest_substr = \\"\\" for i in range(n): if s[i] in char_index and char_index[s[i]] >= start: start = char_index[s[i]] + 1 char_index[s[i]] = i current_len = i - start + 1 if current_len > max_len: max_len = current_len longest_substr = s[start:i+1] return longest_substr"},{"question":"# Coding Challenge Context You are given a string containing a mix of uppercase and lowercase letters. The objective is to find the first non-repeating character in the string and return its index. If the string does not contain any non-repeating characters, return -1. Task Implement a function: ```python def first_unique_character(s: str) -> int: pass ``` Function Signature ```python def first_unique_character(s: str) -> int: ``` Input * A string ( s ) consisting of only lowercase and uppercase English letters, with ( 1 leq text{len(s)} leq 10^5 ). Output * An integer representing the index of the first non-repeating character in the string, or -1 if there is no such character. Examples ```python >>> first_unique_character(\\"leetcode\\") 0 >>> first_unique_character(\\"loveleetcode\\") 2 >>> first_unique_character(\\"aabb\\") -1 ``` Constraints * Ensure that the solution runs efficiently within the provided constraints. * Consider edge cases such as strings with all repeating characters or very long strings.","solution":"def first_unique_character(s: str) -> int: Finds the first non-repeating character in the string and returns its index. If there are no non-repeating characters, returns -1. # First pass to count occurrences of each character count = {} for char in s: count[char] = count.get(char, 0) + 1 # Second pass to find the first unique character for idx, char in enumerate(s): if count[char] == 1: return idx return -1"},{"question":"# Min Heap Checker Context As part of a system that manages prioritization tasks, you need to frequently verify that a given binary tree satisfies the properties of a Min Heap. In a Min Heap, each node is smaller than or equal to its children. You need to implement functionality to check if a binary tree is a Min Heap. Task Implement a function `is_min_heap(root: Optional[TreeNode]) -> bool` that determines if the given binary tree is a Min Heap. Function Signature ```python from typing import Optional class TreeNode: def __init__(self, data: int): self.data = data self.left: Optional[TreeNode] = None self.right: Optional[TreeNode] = None def is_min_heap(root: Optional[TreeNode]) -> bool: # Your code here ``` Additional Requirements * The check should be performed without converting the tree to any other data structures. Utilize recursion or iteration directly on the tree nodes. Input/Output Format * **Input**: - `root`: The root node of the binary tree (`TreeNode` or `None` if the tree is empty). * **Output**: - `True` if the binary tree is a Min Heap, `False` otherwise. Constraints * You may assume the tree structure is a complete binary tree. * The number of nodes in the tree is in the range [0, 1000]. Examples ```python # Example 1 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) is_min_heap(root) # Returns True, as it satisfies Min Heap property # Example 2 root = TreeNode(3) root.left = TreeNode(2) root.right = TreeNode(1) is_min_heap(root) # Returns False, as it doesn\'t satisfy Min Heap property ``` Note Ensure your solution handles cases where the tree is empty or consists of a single node. **Happy Coding!**","solution":"from typing import Optional class TreeNode: def __init__(self, data: int): self.data = data self.left: Optional[TreeNode] = None self.right: Optional[TreeNode] = None def is_min_heap(root: Optional[TreeNode]) -> bool: # Helper function to check min-heap property def check_min_heap(node: Optional[TreeNode]) -> bool: # Base case: if the node is None, it satisfies min-heap property by default if not node: return True # Check if the current node is less than or equal to its left child if node.left and node.data > node.left.data: return False # Check if the current node is less than or equal to its right child if node.right and node.data > node.right.data: return False # Recur for left and right children return check_min_heap(node.left) and check_min_heap(node.right) return check_min_heap(root)"},{"question":"# Coding Assessment Question: Complex String Transformation Objective Develop functions that transform strings through specific parsing and manipulation while ensuring edge cases are handled appropriately. Problem Statement You are given a list of strings. Your task is to: 1. Write a function `extract_digits(strings: list, keep_order: bool = True) -> list` that extracts numeric characters from each string, optionally maintaining their original order. 2. Write a function `reverse_words(strings: list) -> list` that reverses the order of words in each string. Requirements 1. **extract_digits**: * For each string in the input list `strings`, generate a new string containing only the numeric characters. * If `keep_order` is `True`, the digits in the new string must appear in the same order as they appeared in the original string. * If `keep_order` is `False`, reverse the order of the digits in the new string. 2. **reverse_words**: * For each string in the input list `strings`, reverse the order of the words while preserving original white spaces. * Words are defined as sequences of characters separated by spaces. * Ensure leading, trailing, and multiple intermediate spaces are preserved. Example ```python def extract_digits(strings: list, keep_order: bool = True) -> list: # Your implementation here def reverse_words(strings: list) -> list: # Your implementation here # Example usage: strings1 = [\\"abc123\\", \\"def456ghi\\", \\"jk789lm\\"] strings2 = [\\"Hello World\\", \\" This is a test \\"] print(extract_digits(strings1)) # Output: [\\"123\\", \\"456\\", \\"789\\"] print(extract_digits(strings1, keep_order=False)) # Output: [\\"321\\", \\"654\\", \\"987\\"] print(reverse_words(strings2)) # Output: [\\"World Hello\\", \\" test a is This \\"] ``` Constraints * The length of the input list `strings` will be at least 1 and at most (10^5). * Each string in `strings` will have a length between 0 and (10^5) characters. * The characters in each string can include alphabets, digits, spaces, and punctuation. * The output strings should maintain the exact formatting except for the specific transformations required.","solution":"def extract_digits(strings: list, keep_order: bool = True) -> list: Extract numeric characters from each string in the list. Parameters: - strings: list of strings to process - keep_order: If True, maintain the order of digits as in original string; If False, reverse the order of digits in the resulting string. Returns: - List of strings with digits extracted, in the specified order. result = [] for s in strings: digits = \'\'.join([char for char in s if char.isdigit()]) if not keep_order: digits = digits[::-1] result.append(digits) return result def reverse_words(strings: list) -> list: Reverse the order of words in each string in the list. Parameters: - strings: list of strings to process Returns: - List of strings with words in reversed order. result = [] for s in strings: words = s.split(\' \') reversed_words = \' \'.join(words[::-1]) result.append(reversed_words) return result"},{"question":"Move Zeroes to End Objective: **Write a function to move all the zeroes in a list to the end while maintaining the relative order of the non-zero elements. Return the modified list.** Task: **1. `move_zeroes(nums)`** - Parameters: * `nums` (List[int]): A list of integers. - Returns: * `List[int]`: The same list with all zeroes moved to the end while maintaining the order of the non-zero elements. Constraints: * The length of the list is at most 1000. * Each element in the list is an integer ranging from -1000 to 1000. Example Input: ```python nums = [0, 1, 0, 3, 12] ``` Example Output: ```python result = [1, 3, 12, 0, 0] ``` Function Signature: ```python def move_zeroes(nums: List[int]) -> List[int]: pass ``` Brief Scenario: Consider a list of integers where you want to arrange the list such that all zeroes are moved to the end of the list without changing the order of the non-zero elements. Implement a function that accomplishes this in place and returns the sorted list. This task tests your ability to manipulate list elements in an efficient manner.","solution":"from typing import List def move_zeroes(nums: List[int]) -> List[int]: Moves all zeros in the list to the end while maintaining the relative order of the non-zero elements. Parameters: nums (List[int]): A list of integers. Returns: List[int]: The same list with all zeros moved to the end. last_non_zero_found_at = 0 # Move all non-zero elements to the beginning of the list for i in range(len(nums)): if nums[i] != 0: nums[last_non_zero_found_at] = nums[i] last_non_zero_found_at += 1 # Fill the remaining positions with 0 for i in range(last_non_zero_found_at, len(nums)): nums[i] = 0 return nums"},{"question":"# Coding Assessment Question **Background**: Sorting algorithms are fundamental in computer science, and they hold critical significance in various applications due to their efficiency in managing and processing large datasets. One of the most basic yet widely used sorting algorithms is Insertion Sort. It is an efficient algorithm for small datasets and is helpful for some specific cases like almost-sorted data. **Task**: Write a function `insertion_sort` in Python that implements the insertion sort algorithm. Your function should accept a list of integers and return the list sorted in ascending order. # Requirements: 1. **Function Signature**: ```python def insertion_sort(arr: List[int]) -> List[int]: ``` 2. **Input**: - `arr` (List[int]): A list of integers to be sorted. 3. **Output**: - `List[int]`: The sorted list in ascending order. 4. **Constraints**: - The length of the input list will be between 0 and 10^3. - Each element in the list will be an integer within the range of -10^6 to 10^6. 5. **Performance**: - The time complexity for this sorting algorithm on average and the worst-case scenario is O(n^2). - The space complexity should be O(1) as it is an in-place sorting algorithm. # Example: ```python arr = [5, 2, 9, 1, 5, 6] print(insertion_sort(arr)) # Expected output: [1, 2, 5, 5, 6, 9] ``` # Notes: - Ensure your function follows the in-place sorting technique characteristic of insertion sort. - Write comprehensive test cases to confirm your implementation handles edge cases like an empty list, a list with one element, or a list where all elements are the same. # Additional Information: - Insertion Sort works by comparing each element with its predecessors and repeatedly shifting the larger elements to the right to insert the new element in the correct position. - Although it doesn\'t boast the best time complexity for large datasets, its simplicity and efficiency in particular scenarios make it an essential algorithm for foundational understanding.","solution":"from typing import List def insertion_sort(arr: List[int]) -> List[int]: Sorts a list of integers in ascending order using insertion sort algorithm. Args: arr (List[int]): A list of integers to be sorted. Returns: List[int]: The sorted list in ascending order. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"# Coding Assessment Question Objective Implement a Python function to compute the intersection points of two line segments in a 2D plane. This problem will test your understanding of geometry and algorithm implementation. Problem Statement You are given two line segments, each defined by two endpoints. The goal is to determine the coordinates of the intersection point if the segments intersect. If they do not intersect or are collinear, you should indicate that as well. Function Specifications 1. **Function Name**: `find_intersection` 2. **Input Parameters**: - `segment1`: tuple; Two endpoints of the first segment ((x1, y1), (x2, y2)) - `segment2`: tuple; Two endpoints of the second segment ((x3, y3), (x4, y4)) 3. **Output**: - A tuple of three values: 1. Boolean indicating if they intersect. 2. If they intersect, a tuple with the coordinates of the intersection point, else `None`. 3. String message: - \\"Intersecting\\" if they intersect. - \\"Non-intersecting\\" if they do not intersect. - \\"Collinear\\" if the segments are collinear but do not overlap. 4. **Constraints**: - Valid input values are guaranteed by the problem constraints (e.g., all numbers are finite and within safe limits). ```python def find_intersection( segment1: tuple[tuple[float, float], tuple[float, float]], segment2: tuple[tuple[float, float], tuple[float, float]] ) -> tuple[bool, tuple[float, float] | None, str]: Input Parameters: ----------------- segment1: ((x1, y1), (x2, y2)) - Coordinates of the first segment in 2D plane. segment2: ((x3, y3), (x4, y4)) - Coordinates of the second segment in 2D plane. Returns: -------- The function returns a tuple with three elements: 1. Boolean indicating if the segments intersect. 2. The intersection point as a tuple (x, y) if they intersect, otherwise None. 3. A string describing the result: - \\"Intersecting\\" if the segments intersect. - \\"Non-intersecting\\" if they do not intersect and are not collinear. - \\"Collinear\\" if they are collinear but do not overlap. Examples: --------- >>> find_intersection(((1, 1), (4, 4)), ((1, 8), (2, 4))) (False, None, \'Non-intersecting\') >>> find_intersection(((1, 1), (4, 4)), ((2, 2), (6, 6))) (True, (2.0, 2.0), \'Intersecting\') >>> find_intersection(((1, 1), (4, 4)), ((2, 2), (3, 3))) (False, None, \'Collinear\') pass # Your code here ``` Notes: 1. Ensure the function calculates intersection points accurately and efficiently. 2. Make sure to check and handle edge cases such as collinear segments and no intersection properly. 3. Writing modular code and providing comments to enhance readability will be appreciated.","solution":"def find_intersection( segment1: tuple[tuple[float, float], tuple[float, float]], segment2: tuple[tuple[float, float], tuple[float, float]] ) -> tuple[bool, tuple[float, float] | None, str]: Input Parameters: ----------------- segment1: ((x1, y1), (x2, y2)) - Coordinates of the first segment in 2D plane. segment2: ((x3, y3), (x4, y4)) - Coordinates of the second segment in 2D plane. Returns: -------- The function returns a tuple with three elements: 1. Boolean indicating if the segments intersect. 2. The intersection point as a tuple (x, y) if they intersect, otherwise None. 3. A string describing the result: - \\"Intersecting\\" if the segments intersect. - \\"Non-intersecting\\" if they do not intersect and are not collinear. - \\"Collinear\\" if they are collinear but do not overlap. def ccw(A, B, C): return (C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0]) def intersect(A, B, C, D): return ccw(A, C, D) != ccw(B, C, D) and ccw(A, B, C) != ccw(A, B, D) def on_segment(P, Q, R): if (Q[0] <= max(P[0], R[0]) and Q[0] >= min(P[0], R[0]) and Q[1] <= max(P[1], R[1]) and Q[1] >= min(P[1], R[1])): return True return False def orientation(P, Q, R): val = (Q[1] - P[1]) * (R[0] - Q[0]) - (Q[0] - P[0]) * (R[1] - Q[1]) if val == 0: return 0 elif val > 0: return 1 else: return -1 A1, A2 = segment1 B1, B2 = segment2 o1 = orientation(A1, A2, B1) o2 = orientation(A1, A2, B2) o3 = orientation(B1, B2, A1) o4 = orientation(B1, B2, A2) if o1 != o2 and o3 != o4: t1 = ((B1[0] - A1[0]) * (B1[1] - B2[1]) - (B1[1] - A1[1]) * (B1[0] - B2[0])) t2 = ((A2[0] - A1[0]) * (B1[1] - B2[1]) - (A2[1] - A1[1]) * (B1[0] - B2[0])) u = t1 / t2 if t2 else float(\'inf\') x = A1[0] + u * (A2[0] - A1[0]) y = A1[1] + u * (A2[1] - A1[1]) return True, (x, y), \\"Intersecting\\" if (o1 == 0 and on_segment(A1, B1, A2)) or (o2 == 0 and on_segment(A1, B2, A2)) or (o3 == 0 and on_segment(B1, A1, B2)) or (o4 == 0 and on_segment(B1, A2, B2)): return False, None, \\"Collinear\\" return False, None, \\"Non-intersecting\\""},{"question":"# Coding Question: Implement a Balanced Bracket Checker with Custom Brackets You are tasked with implementing a function that checks for balanced brackets in a string. However, in addition to the standard brackets `()`, `[]`, `{}`, you need to support an arbitrary set of custom bracket pairs. # Function Signature ```python def is_balanced(text: str, custom_brackets: List[Tuple[str, str]]) -> bool: pass ``` # Instructions: 1. **Balanced Bracket Checker**: - Given an input string `text` and a list of tuples `custom_brackets`, where each tuple contains a pair of opening and closing bracket characters, implement a function to check if all brackets are balanced in the string. - A bracket pair is considered balanced if for every opening bracket, there is a corresponding closing bracket in the correct order. 2. **Input and Output**: - The function accepts two arguments: 1. `text`: a string containing the characters to be checked. 2. `custom_brackets`: a list of tuples, where each tuple contains exactly two elements - the opening and closing brackets. - The function returns a boolean value: `True` if the brackets are balanced, `False` otherwise. 3. **Constraints**: - You may assume that the input string is non-empty. - The `custom_brackets` list will contain unique bracket pairs that do not overlap with the standard brackets or each other. - The input string `text` contains only characters visible on a standard keyboard. # Example ```python >>> is_balanced(\'a(b)c\', [(\'(\', \')\')]) True >>> is_balanced(\'a(b]c\', [(\'(\', \')\'), (\'[\', \']\')]) False >>> is_balanced(\'<a{b[c]d}e>\', [(\'<\', \'>\'), (\'{\', \'}\'), (\'[\', \']\')]) True >>> is_balanced(\'a(b}c\', [(\'(\', \')\'), (\'{\', \'}\')]) False ``` # Notes: - The function must handle both the standard and custom bracket pairs. - Ensure the implementation efficiently checks for balanced brackets even with multiple types. - Document the code clearly to explain the logic behind the bracket balancing checker.","solution":"from typing import List, Tuple def is_balanced(text: str, custom_brackets: List[Tuple[str, str]]) -> bool: Check if all the brackets in the given text are balanced. Args: text (str): The input text containing brackets to be checked. custom_brackets (List[Tuple[str, str]]): A list of tuples containing custom bracket pairs. Returns: bool: True if all brackets are balanced, False otherwise. stack = [] bracket_map = {opening: closing for opening, closing in custom_brackets} closing_to_opening = {closing: opening for opening, closing in custom_brackets} for char in text: if char in bracket_map: # If the character is an opening bracket stack.append(char) elif char in closing_to_opening: # If the character is a closing bracket if stack and stack[-1] == closing_to_opening[char]: stack.pop() else: return False return not stack"},{"question":"# Question You are given a `Graph` class that represents an unweighted, undirected graph. Extend this class to include a function that finds all connected components in the graph. A connected component is a maximal set of vertices such that there is a path between each pair of vertices in the set. Implement the following function: ```python class Graph: ... def connected_components(self) -> list[list[int]]: Find all connected components in the graph. :return: A list of connected components, where each connected component is represented as a list of vertex indices. ``` Constraints: * The graph is represented as an adjacency list. * The graph may contain up to 1000 vertices. * Aim for efficient time and space complexity. Input: * No additional input parameters (other than the implicit graph structure). Output: * A list of connected components, each component represented as a list of vertices (given as integers). Example: Given the following graph with vertices `0` to `6`: ```python g = Graph() g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(3, 4) g.add_edge(5, 6) print(g.connected_components()) # Output: [[0, 1, 2], [3, 4], [5, 6]] ``` Note: * Vertices should be returned in ascending order within each component. * Components should also be returned in ascending order based on the smallest vertex in each component.","solution":"class Graph: def __init__(self): self.adjacency_list = {} def add_edge(self, v1, v2): if v1 not in self.adjacency_list: self.adjacency_list[v1] = [] if v2 not in self.adjacency_list: self.adjacency_list[v2] = [] self.adjacency_list[v1].append(v2) self.adjacency_list[v2].append(v1) def connected_components(self) -> list[list[int]]: def dfs(vertex, visited, component): stack = [vertex] while stack: v = stack.pop() if v not in visited: visited.add(v) component.append(v) stack.extend(self.adjacency_list.get(v, [])) visited = set() components = [] for vertex in self.adjacency_list: if vertex not in visited: component = [] dfs(vertex, visited, component) components.append(sorted(component)) return sorted(components, key=lambda comp: comp[0])"},{"question":"# Question: Implement a Customizable Linear Regression Model Your task is to implement a basic linear regression model that allows users to customize the model through various parameters and options. Specifically: 1. **Implement a class `LinearRegression`** that includes methods for fitting the model to data, predicting, and evaluating the model performance. 2. **Define methods within the class** to calculate the coefficients using closed-form solution, predict values, and compute the Mean Squared Error (MSE) as the evaluation metric. **Class Interface**: ```python class LinearRegression: def __init__(self, fit_intercept: bool = True): pass def fit(self, X: List[List[float]], y: List[float]) -> None: pass def predict(self, X: List[List[float]]) -> List[float]: pass def mse(self, y_true: List[float], y_pred: List[float]) -> float: pass ``` **Methods**: - `__init__(fit_intercept)`: Initializes the model. `fit_intercept` is a boolean indicating whether to include an intercept term. - `fit(X, y)`: Fits the model to the data. - `predict(X)`: Predicts the target values given input features. - `mse(y_true, y_pred)`: Computes the Mean Squared Error between true and predicted values. **Input**: - `fit_intercept`: A boolean indicating whether to fit the intercept term. - `X`: List of feature vectors. - `y`: List of target values. **Output**: - `fit`: No direct output, but it calculates model coefficients. - `predict`: List of predicted target values. - `mse`: Mean Squared Error of predictions. **Constraints**: - Handle edge cases such as empty datasets and ensure numerical stability. - The solution should avoid excessive computational complexity. Example: ```python # Sample usage model = LinearRegression(fit_intercept=True) X_train = [[1], [2], [3], [4], [5]] y_train = [3, 5, 7, 9, 11] model.fit(X_train, y_train) predictions = model.predict([[6], [7]]) mse_value = model.mse([13, 15], predictions) print(predictions) # Expected: [13.0, 15.0] print(mse_value) # Expected: 0.0 ``` **Implementation Details**: 1. To fit the model, use the normal equation: (theta = (X^T X)^{-1} X^T y). 2. For predictions, calculate (y = Xtheta ). If `fit_intercept` is True, prepend a column of ones to X. 3. For MSE, use the formula: (text{MSE} = frac{1}{n} sum_{i=1}^{n} (y_i - hat{y_i})^2 ). Test your implementation comprehensively using different datasets and configurations.","solution":"import numpy as np from typing import List class LinearRegression: def __init__(self, fit_intercept: bool = True): self.fit_intercept = fit_intercept self.coefficients = None def fit(self, X: List[List[float]], y: List[float]) -> None: X = np.array(X) y = np.array(y) if self.fit_intercept: X = np.insert(X, 0, 1, axis=1) # Add intercept term # Calculate coefficients using the normal equation XtX = X.T.dot(X) Xty = X.T.dot(y) self.coefficients = np.linalg.inv(XtX).dot(Xty) def predict(self, X: List[List[float]]) -> List[float]: X = np.array(X) if self.fit_intercept: X = np.insert(X, 0, 1, axis=1) # Add intercept term return list(X.dot(self.coefficients)) def mse(self, y_true: List[float], y_pred: List[float]) -> float: y_true = np.array(y_true) y_pred = np.array(y_pred) return np.mean((y_true - y_pred) ** 2)"},{"question":"# Reputable Media Content Tracker Context You work for a start-up that helps users track reputations of their favorite media content such as movies, video games, and books. Your task is to create a utility function that accepts a list of media content details and computes their average reputation score. However, some media content might have inappropriate data that should be handled properly. Objective * Implement a function that accepts a list of media content details and calculates the average reputation score for the valid entries. * Ensure comprehensive handling of invalid data, such as non-numeric scores, negative scores, or incomplete data. Function Signature ```python def average_reputation(media: List[Dict[str, Union[str, int, float]]]) -> Dict[str, Union[float, List[Dict[str, Union[str, int, float]]]]]: Calculate the average reputation score for valid media content. Parameters: media (List[Dict[str, Union[str, int, float]]]): A list of dictionaries, each containing \'name\', \'category\', and \'score\'. Returns: Dict[str, Union[float, List[Dict[str, Union[str, int, float]]]]]: A dictionary with two keys \\"average_score\\" and \\"errors\\". \\"average_score\\" holds the average reputation score of valid media content. \\"errors\\" holds a list of invalid media content details. Example: >>> media_content = [ {\\"name\\": \\"Movie A\\", \\"category\\": \\"Movie\\", \\"score\\": 85}, {\\"name\\": \\"Game B\\", \\"category\\": \\"Video Game\\", \\"score\\": 92}, {\\"name\\": \\"Book C\\", \\"category\\": \\"Book\\", \\"score\\": -10}, {\\"name\\": \\"Movie D\\", \\"category\\": \\"Movie\\", \\"score\\": \\"N/A\\"} ] >>> average_reputation(media_content) {\'average_score\': 88.5, \'errors\': [{\\"name\\": \\"Book C\\", \\"category\\": \\"Book\\", \\"score\\": -10}, {\\"name\\": \\"Movie D\\", \\"category\\": \\"Movie\\", \\"score\\": \\"N/A\\"}]} ``` Constraints and Requirements * **Input Constraints**: - Each media content detail is a dictionary with \'name\' (string), \'category\' (string), and \'score\' (int or float). * **Output**: - The function must return a dictionary containing the average score of valid media content and a list of invalid entries. * **Error Handling**: - If the \'score\' is non-numeric or negative, log that entry to the \\"errors\\" list. - Ensure all invalid entries are handled gracefully without affecting the processing of valid entries. * **Performance**: Ensure the function operates efficiently with a complexity of O(n) for n input dictionaries. ```python # Sample Code and Testing def average_reputation(media: List[Dict[str, Union[str, int, float]]]) -> Dict[str, Union[float, List[Dict[str, Union[str, int, float]]]]]: valid_scores = [] errors = [] for item in media: try: score = item[\'score\'] if isinstance(score, (int, float)) and score >= 0: valid_scores.append(score) else: errors.append(item) except (TypeError, ValueError) as e: errors.append(item) average_score = sum(valid_scores) / len(valid_scores) if valid_scores else 0 return {\'average_score\': average_score, \'errors\': errors} # Example Usage media_content = [ {\\"name\\": \\"Movie A\\", \\"category\\": \\"Movie\\", \\"score\\": 85}, {\\"name\\": \\"Game B\\", \\"category\\": \\"Video Game\\", \\"score\\": 92}, {\\"name\\": \\"Book C\\", \\"category\\": \\"Book\\", \\"score\\": -10}, {\\"name\\": \\"Movie D\\", \\"category\\": \\"Movie\\", \\"score\\": \\"N/A\\"} ] result = average_reputation(media_content) print(result) # Output: {\'average_score\': 88.5, \'errors\': [{\'name\': \'Book C\', \'category\': \'Book\', \'score\': -10}, {\'name\': \'Movie D\', \'category\': \'Movie\', \'score\': \'N/A\'}]} ```","solution":"from typing import List, Dict, Union def average_reputation(media: List[Dict[str, Union[str, int, float]]]) -> Dict[str, Union[float, List[Dict[str, Union[str, int, float]]]]]: Calculate the average reputation score for valid media content. Parameters: media (List[Dict[str, Union[str, int, float]]]): A list of dictionaries, each containing \'name\', \'category\', and \'score\'. Returns: Dict[str, Union[float, List[Dict[str, Union[str, int, float]]]]]: A dictionary with two keys \\"average_score\\" and \\"errors\\". \\"average_score\\" holds the average reputation score of valid media content. \\"errors\\" holds a list of invalid media content details. valid_scores = [] errors = [] for item in media: if \'score\' in item and isinstance(item[\'score\'], (int, float)) and item[\'score\'] >= 0: valid_scores.append(item[\'score\']) else: errors.append(item) average_score = sum(valid_scores) / len(valid_scores) if valid_scores else 0.0 return {\'average_score\': average_score, \'errors\': errors}"},{"question":"# Sorting Unique Integers Efficiently You have been assigned to optimize a data processing pipeline that frequently needs to handle large arrays of integers. One of the core operations involves sorting an array of integers, ensuring that only unique values are output and maintaining space efficiency. Function Signature Create a function named `sort_unique_integers`: ```python def sort_unique_integers(numbers: List[int]) -> List[int]: pass ``` Input * `numbers`: A list of integers that may contain duplicates. The list can have a length of up to 10^6 elements. Output * A list of integers sorted in ascending order, containing only unique values. Constraints * The function should handle both small and large input sizes efficiently. * The input list can contain both positive and negative integers, and it may also be empty. * The sorting algorithm should strive for O(n log n) time complexity or better. Example ```python sort_unique_integers([4, 2, 7, 3, 2, 4]) # Output: [2, 3, 4, 7] sort_unique_integers([1, -1, 2, -2, 3, -3, 1]) # Output: [-3, -2, -1, 1, 2, 3] sort_unique_integers([]) # Output: [] ``` Requirements * Your solution should use efficient data structures and sorting algorithms to achieve the best possible performance. * Ensure that your implementation is robust and correctly handles edge cases, such as extremely small or extremely large input lists, and the presence of negative integers. Your solution should demonstrate the ability to implement a sorting and deduplication mechanism that meets the described constraints and performance expectations.","solution":"from typing import List def sort_unique_integers(numbers: List[int]) -> List[int]: This function accepts a list of integers, removes duplicates, sorts it, and returns the sorted list of unique integers. # Use a set to remove duplicates, then convert it back to a list and sort it return sorted(set(numbers))"},{"question":"# Scenario You are building a file system simulation where you need to determine the size of all unique files within a nested directory structure. The directory structure can contain multiple directories and files, and a file can be referred to multiple times through different paths. # Task Implement a function `calculate_total_size` that computes the total size of all unique files given a nested directory structure. # Function Signature ```python def calculate_total_size(directory: dict) -> int: ``` # Input * `directory`: A dictionary representing the root directory, which contains nested dictionaries for directories and integers for file sizes. File names and directory names are the keys. # Output * An integer representing the total size of all unique files in the directory structure. # Constraints * If a file with the same name exists in different directories, it should be counted only once. * The total number of files and directories combined will not exceed 10^4. * File size will be a non-negative integer. # Example Consider the following directory structure: ```python example = { \\"dir1\\": { \\"file1\\": 100, \\"file2\\": 200, \\"dir2\\": { \\"file3\\": 300, \\"file4\\": 400 } }, \\"file1\\": 100, \\"file5\\": 500 } ``` For this example, the function should return 1500 since the unique files are `file1`, `file2`, `file3`, `file4`, and `file5`. # Hints * Use a set to keep track of unique file names encountered during the traversal of the directory structure. * Write a recursive function to traverse through nested dictionaries.","solution":"def calculate_total_size(directory: dict) -> int: Traverses the nested directory structure and returns the total size of all unique files. def traverse(dir, seen_files): total_size = 0 for key, value in dir.items(): if isinstance(value, dict): # Recurse into sub-directory total_size += traverse(value, seen_files) elif isinstance(value, int): # It\'s a file, check if it\'s already seen if key not in seen_files: seen_files.add(key) total_size += value return total_size seen_files = set() return traverse(directory, seen_files)"},{"question":"# Question: Customer Order Processing System Context You are asked to design a customer order processing system for an e-commerce platform. The system should manage customer orders, compute prices with applicable discounts, and ensure efficient order handling. Requirements 1. **Order Management Class (`OrderManager`)**: - Should contain an order queue. - Must support adding new orders with customer information and purchase details. - Should support processing all orders in the queue. 2. **Price Calculation**: - Implement a method `calculate_price` to compute the total price of items, considering the applicable discounts. - Support different discount strategies: percentage-based and fixed amount discounts. 3. **Order Processing Method**: - Implement a method `process_orders` to simulate processing each order, applying the needed calculations to finalize each order. Implementation Details - **Input Format**: - Orders added to the queue contain: customer information, list of item prices, and any applicable discount information. - **Output Format**: - Final order summary after processing all orders including the total price, the applied discount, and the final price after discount. - **Constraints**: - Support a queue with up to 100 orders. - Ensure robustness to handle different types of discounts and multiple items in an order. Function Signature ```python from typing import List, Dict, Union, Callable class OrderManager: def __init__(self): self.orders = [] def add_order(self, customer_info: Dict[str, str], items: List[float], discount: Dict[str, Union[float, Callable[[float], float]]] = None) -> None: pass # Add the order to the queue def calculate_price(self, items: List[float], discount: Dict[str, Union[float, Callable[[float], float]]] = None) -> float: pass # Calculate total price with discount def process_orders(self) -> List[Dict[str, Union[str, float]]]: pass # Process each order in the queue # Example Usage: # order_manager = OrderManager() # order_manager.add_order({\'name\': \'Alice\', \'address\': \'123 Main St\'}, [30.5, 20.0], {\'type\': \'percentage\', \'value\': 10}) # order_manager.add_order({\'name\': \'Bob\', \'address\': \'456 Elm St\'}, [10.0, 15.0], {\'type\': \'fixed\', \'value\': 5}) # summaries = order_manager.process_orders() ``` Performance Requirements - Make sure that adding and processing orders are efficient, even when handling the maximum number of orders. Ensure that price calculation handles cases where no discount is applied effectively.","solution":"from typing import List, Dict, Union, Callable class OrderManager: def __init__(self): self.orders = [] def add_order(self, customer_info: Dict[str, str], items: List[float], discount: Dict[str, Union[str, float]] = None) -> None: self.orders.append({ \'customer_info\': customer_info, \'items\': items, \'discount\': discount }) def calculate_price(self, items: List[float], discount: Dict[str, Union[str, float]] = None) -> float: total_price = sum(items) if not discount: return total_price if discount[\'type\'] == \'percentage\': total_price = total_price * (1 - discount[\'value\'] / 100) elif discount[\'type\'] == \'fixed\': total_price = max(0, total_price - discount[\'value\']) return total_price def process_orders(self) -> List[Dict[str, Union[str, float]]]: processed_orders = [] for order in self.orders: customer_info = order[\'customer_info\'] items = order[\'items\'] discount = order[\'discount\'] total_price_b4_disc = sum(items) final_price = self.calculate_price(items, discount) processed_order = { \'customer_name\': customer_info[\'name\'], \'total_price_before_discount\': total_price_b4_disc, \'final_price_after_discount\': final_price } processed_orders.append(processed_order) return processed_orders # Example Usage: # order_manager = OrderManager() # order_manager.add_order({\'name\': \'Alice\', \'address\': \'123 Main St\'}, [30.5, 20.0], {\'type\': \'percentage\', \'value\': 10}) # order_manager.add_order({\'name\': \'Bob\', \'address\': \'456 Elm St\'}, [10.0, 15.0], {\'type\': \'fixed\', \'value\': 5}) # summaries = order_manager.process_orders()"},{"question":"# Coding Challenge: Analyzing Streaks in a Binary Array Objective Write a function that calculates the longest streak of consecutive ones in a binary array. A binary array is an array containing only 0s and 1s. Detailed Requirements - **Function Signature**: ```python def longest_streak(arr: list) -> int: ``` - **Input**: - `arr`: A list of integers, where each integer is either 0 or 1. - **Output**: - An integer representing the length of the longest streak of consecutive 1s in the array. - **Constraints**: - The list can be empty or contain up to `10^5` elements. - The elements of the list must be either 0 or 1. - Handle edge cases such as the empty list and lists without any 1s or 0s. - **Performance**: - The function should run in O(n) time complexity where \'n\' is the number of elements in the array. - It should use O(1) additional space. Example: ```python >>> longest_streak([1, 1, 0, 1, 1, 1]) 3 >>> longest_streak([0, 0, 0, 0, 0]) 0 >>> longest_streak([1, 1, 1, 1, 1]) 5 >>> longest_streak([0, 1, 0, 1, 0, 1, 1, 0]) 2 >>> longest_streak([]) 0 ``` Guidelines: 1. Implement necessary validation checks for the input array. 2. Ensure the function handles edge cases gracefully: - Return 0 for an empty list or a list without any 1s. 3. Optimize the function to ensure it operates within the time and space constraints. 4. Include `doctest` to validate your solution. ```python def longest_streak(arr: list) -> int: Calculate the longest streak of consecutive 1s in a binary array. Parameters: arr (list): A list of integers, where each integer is either 0 or 1. Returns: int: Length of the longest streak of consecutive 1s. Examples: >>> longest_streak([1, 1, 0, 1, 1, 1]) 3 >>> longest_streak([0, 0, 0, 0, 0]) 0 >>> longest_streak([1, 1, 1, 1, 1]) 5 >>> longest_streak([0, 1, 0, 1, 0, 1, 1, 0]) 2 >>> longest_streak([]) 0 if not isinstance(arr, list): raise ValueError(\\"Input should be a list\\") max_streak = 0 current_streak = 0 for num in arr: if num != 0 and num != 1: raise ValueError(\\"List elements must be 0 or 1\\") if num == 1: current_streak += 1 max_streak = max(max_streak, current_streak) else: current_streak = 0 return max_streak if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"def longest_streak(arr: list) -> int: Calculate the longest streak of consecutive 1s in a binary array. Parameters: arr (list): A list of integers, where each integer is either 0 or 1. Returns: int: Length of the longest streak of consecutive 1s. Examples: >>> longest_streak([1, 1, 0, 1, 1, 1]) 3 >>> longest_streak([0, 0, 0, 0, 0]) 0 >>> longest_streak([1, 1, 1, 1, 1]) 5 >>> longest_streak([0, 1, 0, 1, 0, 1, 1, 0]) 2 >>> longest_streak([]) 0 max_streak = 0 current_streak = 0 for num in arr: if num != 0 and num != 1: raise ValueError(\\"List elements must be 0 or 1\\") if num == 1: current_streak += 1 max_streak = max(max_streak, current_streak) else: current_streak = 0 return max_streak"},{"question":"# Question Context: You are given a list of events, and you want to organize them in such a way that the number of overlapping events is minimized. An event is represented by a start time and an end time. Two events are considered overlapping if one event starts before the other one ends. Task: Write a Python function `minimize_overlaps(events: List[Tuple[int, int]]) -> int` that receives a list of tuples `events`, where each tuple contains two integers representing the start and end times of an event, respectively. Your function should return the minimum number of rooms required to schedule all events without any overlaps. Input: - `events` (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers `(start, end)` representing the start and end times of an event. (1 ≤ len(events) ≤ 10^5, 0 ≤ start < end ≤ 10^9) Output: - Return an integer representing the minimum number of rooms required to hold all the events without overlaps. Constraints: - The solution should efficiently handle the maximum given constraints. Example: ```python assert minimize_overlaps([(0, 30), (5, 10), (15, 20)]) == 2 assert minimize_overlaps([(7, 10), (2, 4)]) == 1 assert minimize_overlaps([(1, 10), (2, 9), (3, 8), (4, 7)]) == 4 ``` Additional Example: ```python assert minimize_overlaps([(0, 50), (10, 20), (25, 35), (20, 30)]) == 3 assert minimize_overlaps([(0, 15), (5, 10), (12, 20), (20, 30)]) == 2 ``` Your implementation should efficiently determine the required number of rooms based on the given event times.","solution":"def minimize_overlaps(events): Given a list of events with start and end times, returns the minimum number of rooms required to host all events without overlapping. :param events: List[Tuple[int, int]], List of tuples where each tuple contains two integers representing the start and end time of an event. :return: int, The minimum number of rooms required to host all events without overlaps. if not events: return 0 # Separate out the start and end times start_times = sorted([event[0] for event in events]) end_times = sorted([event[1] for event in events]) start_pointer, end_pointer = 0, 0 min_rooms, current_rooms = 0, 0 # Use two pointers to traverse the start and end times while start_pointer < len(events): if start_times[start_pointer] < end_times[end_pointer]: current_rooms += 1 start_pointer += 1 else: current_rooms -= 1 end_pointer += 1 min_rooms = max(min_rooms, current_rooms) return min_rooms"},{"question":"# Problem Statement You need to implement the function `majority_element` that takes an array of integers `arr`. In the input array, an element is called a \\"majority element\\" if it appears more than `n // 2` times, where `n` is the length of the array. Your implementation should efficiently determine the majority element if it exists, otherwise, return `None`. # Input & Output Formats - **Input**: - `arr`: A list of integers (1 ≤ length of arr ≤ 10^5) - **Output**: - An integer representing the majority element, or `None` if no such element exists. # Constraints - The elements in `arr` can be both negative and positive integers. - The algorithm should be optimized to handle large arrays efficiently. # Example ```python >>> majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) 4 >>> majority_element([3, 3, 4, 2, 4, 4, 2, 4]) None >>> majority_element([1]) 1 >>> majority_element([2, 2, 1, 1, 1, 2, 2]) 2 ``` # Instructions Implement the `majority_element` function using an efficient algorithm. The Boyer-Moore Voting Algorithm is a suitable approach, as it can find the majority element in linear time with constant space complexity. Hints - The Boyer-Moore Voting Algorithm involves two main phases: 1. Find a candidate for the majority element. 2. Verify that the candidate occurs more than `n // 2` times in the array. - First pass can be used to find a candidate, and a second pass is required to confirm it as the majority element.","solution":"def majority_element(arr): Returns the majority element in the array if it exists, otherwise returns None. candidate = None count = 0 # Phase 1: Find a candidate for num in arr: if count == 0: candidate, count = num, 1 elif num == candidate: count += 1 else: count -= 1 # Phase 2: Verify the candidate if arr.count(candidate) > len(arr) // 2: return candidate else: return None"},{"question":"# Question: Matrix Multiplication Validity Checker You are part of a software engineering team that deals with large datasets represented as matrices. One common operation is matrix multiplication, which requires the dimensions of the matrices to be compatible. Your task is to implement a function that verifies whether two matrices can be legally multiplied. Function Signature: ```python def can_multiply_matrices(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> bool: ``` Input: - **matrix_a**: A list of lists representing the first matrix, where each inner list represents a row. - **matrix_b**: A list of lists representing the second matrix, where each inner list represents a row. Output: - A boolean value: `True` if the matrices can be multiplied; `False` otherwise. Constraints: - The number of rows and columns in each matrix may range from 1 to 1000. - The elements of the matrices are integers in the range of -10^9 to 10^9. - A matrix with `m` rows and `n` columns is represented by a list of `m` lists, each containing `n` integers. Example: ```python >>> can_multiply_matrices([[1, 2, 3], [4, 5, 6]], [[7, 8], [9, 10], [11, 12]]) True >>> can_multiply_matrices([[1, 2]], [[3, 4], [5, 6], [7, 8]]) False ``` Explanation: - In the first example, matrix_a is of size (2, 3) and matrix_b is of size (3, 2). Since the number of columns in the first matrix (3) equals the number of rows in the second matrix (3), the matrices can be multiplied. - In the second example, matrix_a is of size (1, 2) and matrix_b is of size (3, 2). The number of columns in matrix_a (2) does not match the number of rows in matrix_b (3), so the matrices cannot be multiplied. Implement the `can_multiply_matrices` function to accurately determine the compatibility of two matrices for multiplication.","solution":"from typing import List def can_multiply_matrices(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> bool: Returns True if matrix_a and matrix_b can be legally multiplied, False otherwise. A matrix multiplication A * B is possible if and only if the number of columns in A is equal to the number of rows in B. if not matrix_a or not matrix_b: return False num_columns_a = len(matrix_a[0]) num_rows_b = len(matrix_b) return num_columns_a == num_rows_b"},{"question":"# Problem Statement You have been hired to develop a recommendation engine for an online book store. Your first task is to build a function that identifies books with the highest average user rating. Each book can have multiple ratings from different users, and you\'ll have to ensure that only books with a minimum number of ratings are considered. Write a function `top_books` that takes two inputs: a list of tuples representing book ratings and an integer representing the minimum number of ratings required. Each tuple contains three elements: the book\'s title (string), the user id (integer), and the user rating (float, between 0 and 5 inclusive). The function should return a list of book titles sorted in descending order by their average ratings. If multiple books have the same average rating, sort them alphabetically by title. # Function Signature ```python from typing import List, Tuple def top_books(ratings: List[Tuple[str, int, float]], min_ratings: int) -> List[str]: ... ``` # Input * `ratings` - A list of tuples, where each tuple contains: * `title (str)`: The title of the book. * `user_id (int)`: The ID of the user who rated the book. * `rating (float)`: The rating given by the user, between 0 and 5 inclusive. * `min_ratings (int)`: The minimum number of ratings a book must have to be considered. # Output * A list of book titles (strings) sorted in descending order by their average user rating. Books with the same average rating should be sorted alphabetically by title. # Constraints 1. The list `ratings` can be empty. 2. The minimum number of ratings (`min_ratings`) is always a non-negative integer. 3. Each book title in the input list is not empty and is a valid string. # Examples ```python >>> top_books([ ... (\\"Book A\\", 1, 4.5), ... (\\"Book B\\", 2, 4.0), ... (\\"Book A\\", 3, 5.0), ... (\\"Book B\\", 4, 5.0), ... (\\"Book C\\", 5, 3.0), ... (\\"Book A\\", 6, 4.0) ... ], 2) [\'Book A\', \'Book B\'] >>> top_books([ ... (\\"Novel Z\\", 1, 3.5), ... (\\"Novel X\\", 2, 4.0), ... (\\"Novel Y\\", 3, 2.0), ... (\\"Novel Z\\", 4, 2.5), ... (\\"Novel Y\\", 5, 3.0), ... (\\"Novel X\\", 6, 5.0), ... (\\"Novel X\\", 7, 4.0) ... ], 3) [\'Novel X\'] >>> top_books([ ... (\\"Story A\\", 1, 4.0), ... (\\"Story B\\", 2, 4.0), ... (\\"Story A\\", 3, 4.0), ... (\\"Story B\\", 4, 4.0) ... ], 2) [\'Story A\', \'Story B\'] >>> top_books([], 1) [] >>> top_books([ ... (\\"Tale A\\", 1, 2.0), ... (\\"Tale B\\", 2, 3.0), ... (\\"Tale A\\", 3, 3.0), ... (\\"Tale B\\", 4, 2.0), ... (\\"Tale C\\", 5, 5.0) ... ], 2) [\'Tale A\', \'Tale B\'] ``` # Notes 1. Ensure that each book is only considered if the number of ratings for that book is greater than or equal to `min_ratings`. 2. The average rating should be calculated as the sum of all ratings for a book divided by the number of ratings. 3. Handle edge cases where books barely meet or fail the `min_ratings` requirement or when there are no books at all.","solution":"from typing import List, Tuple from collections import defaultdict def top_books(ratings: List[Tuple[str, int, float]], min_ratings: int) -> List[str]: book_ratings_count = defaultdict(int) book_ratings_sum = defaultdict(float) for title, _, rating in ratings: book_ratings_count[title] += 1 book_ratings_sum[title] += rating books_average_ratings = { title: book_ratings_sum[title] / book_ratings_count[title] for title in book_ratings_sum if book_ratings_count[title] >= min_ratings } sorted_books = sorted(books_average_ratings.keys(), key=lambda title: (-books_average_ratings[title], title)) return sorted_books"},{"question":"Scenario To enhance your understanding of dynamic programming and combinatorics, you will implement an algorithm that efficiently counts the number of ways to tile a 2 x n grid using 1 x 2 and 2 x 1 tiles. This problem requires both mathematical insight and programming skills to optimize tiling calculations. # Problem Statement Write a function `num_ways_to_tile(n: int) -> int` that returns the number of ways to tile a 2 x n grid using 1 x 2 and 2 x 1 tiles, where: - `n` is a positive integer representing the width of the grid. # Input * `n` (1 ≤ n ≤ 10^4): The width of the grid. # Output * Return the number of distinct ways to completely cover the 2 x n grid using the given tiles. # Constraints * You must use a dynamic programming approach to ensure efficient computation. # Performance Requirements Your solution must run in O(n) time complexity. # Example ```python def num_ways_to_tile(n: int) -> int: # Implement your function here # Example usage: print(num_ways_to_tile(3)) # Output should be 3 ``` In this example, the function should compute the number of ways to tile a 2 x 3 grid. # Notes 1. Consider the recurrence relation if you place a 2 x 1 tile vertically or two 1 x 2 tiles horizontally. 2. Think about base cases for small values of `n` for initialization and how the number of ways builds up as `n` increases. 3. Utilize space optimization techniques like using constant extra space if possible.","solution":"def num_ways_to_tile(n: int) -> int: Returns the number of ways to tile a 2 x n grid using 1 x 2 and 2 x 1 tiles. if n == 1: return 1 if n == 2: return 2 dp = [0] * (n + 1) dp[1] = 1 # base case: 1 way to fill a 2x1 grid dp[2] = 2 # base case: 2 ways to fill a 2x2 grid for i in range(3, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n]"},{"question":"# Coding Question: Temperature Conversion Tool **Context**: You are working on creating a versatile temperature conversion tool for a climate research application. The tool should convert temperatures between three scales: Celsius, Fahrenheit, and Kelvin. The conversions need to be accurate and follow standard temperature conversion formulas. **Task**: Implement three functions that perform the following temperature conversions: 1. `celsius_to_fahrenheit(celsius: float) -> float` 2. `celsius_to_kelvin(celsius: float) -> float` 3. `fahrenheit_to_kelvin(fahrenheit: float) -> float` These functions should validate the inputs and perform the required conversions based on the provided formulas. **Constraints**: - The temperature values can be any real number. - Values must be rounded to two decimal places. **Formulas**: - Celsius to Fahrenheit: [ F = (C times frac{9}{5}) + 32 ] - Celsius to Kelvin: [ K = C + 273.15 ] - Fahrenheit to Kelvin: [ K = frac{(F + 459.67) times frac{5}{9}} ] Here, ( C ) is the temperature in Celsius, ( F ) is the temperature in Fahrenheit, and ( K ) is the temperature in Kelvin. **Input/Output**: - **Input**: A float number representing the temperature. - **Output**: A float number representing the converted temperature. **Examples**: ```python assert celsius_to_fahrenheit(0) == 32.00 assert celsius_to_kelvin(0) == 273.15 assert fahrenheit_to_kelvin(32) == 273.15 assert celsius_to_fahrenheit(100) == 212.00 assert celsius_to_kelvin(100) == 373.15 assert fahrenheit_to_kelvin(212) == 373.15 ``` Write the functions based on the provided formulas and constraints, ensuring to handle invalid inputs appropriately.","solution":"def celsius_to_fahrenheit(celsius: float) -> float: Converts a temperature from Celsius to Fahrenheit. return round((celsius * 9/5) + 32, 2) def celsius_to_kelvin(celsius: float) -> float: Converts a temperature from Celsius to Kelvin. return round(celsius + 273.15, 2) def fahrenheit_to_kelvin(fahrenheit: float) -> float: Converts a temperature from Fahrenheit to Kelvin. return round((fahrenheit + 459.67) * 5/9, 2)"},{"question":"# Connected Component Count in a Graph You are given an undirected graph represented as an adjacency list. Your task is to count the number of connected components in the graph. Function Signature ```python def count_connected_components(graph: Dict[int, List[int]]) -> int: Returns the number of connected components in the graph. ``` Input * `graph` (Dict[int, List[int]]): A dictionary where each key is a node in the graph, and the value is a list of nodes that are connected to the key node. Output * Returns the count of connected components (int). Constraints * The graph represents an undirected graph with no self-loops and no duplicate edges. * The graph can be empty, containing no nodes. * The graph\'s nodes are denoted by non-negative integers. Examples ```python assert count_connected_components({ 0: [1, 2], 1: [0, 2], 2: [0, 1], 3: [4], 4: [3], 5: [] }) == 3 assert count_connected_components({ 0: [1], 1: [0, 2, 3], 2: [1], 3: [1] }) == 1 assert count_connected_components({}) == 0 assert count_connected_components({0: []}) == 1 ``` Scenario You are working in a network security company that needs to analyze the number of isolated networks within a larger computer network. Each computer (node) is identified by an integer, and connections between computers are bidirectional. You need to identify and count how many isolated groups exist within the entire system to help prioritize which isolated networks to secure first. This function will assist in determining the security reinforcement strategy for the company\'s clients.","solution":"def count_connected_components(graph): def dfs(node, visited): stack = [node] while stack: current = stack.pop() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) visited = set() count = 0 for node in graph: if node not in visited: visited.add(node) dfs(node, visited) count += 1 return count"},{"question":"# Problem Statement Context You are tasked with creating a function to generate the nth number in a unique sequence called a Zig-Zag sequence. In a Zig-Zag sequence, each element alternates between being an even and odd number, starting with 1. For example, the first few terms in the Zig-Zag sequence are: [ 1, 2, 3, 4, 5, 6, ldots ] The alternating property means that regardless of the starting point, the sequence should continue to alternate between even and odd numbers. Function Signature ```python def zig_zag_sequence(start: int, n: int) -> list[int]: ``` Input 1. `start (int)`: The starting number of the sequence. 2. `n (int)`: The number of terms to generate in the sequence. Output * Returns a `list[int]` with the first `n` terms of the Zig-Zag sequence starting from `start`. Constraints * If `n` is less than 1, return an empty list. * The `start` can be either even or odd. Examples ```python >>> zig_zag_sequence(1, 5) [1, 2, 3, 4, 5] >>> zig_zag_sequence(2, 4) [2, 3, 4, 5] >>> zig_zag_sequence(3, 6) [3, 4, 5, 6, 7, 8] >>> zig_zag_sequence(0, 3) [0, 1, 2] >>> zig_zag_sequence(7, 0) [] ``` Additional Requirements: 1. Ensure to handle edge cases where the `start` is zero or a negative integer. 2. Optimize the solution for large values of `n` to ensure performance efficiency.","solution":"def zig_zag_sequence(start: int, n: int) -> list[int]: Generates the first n terms of the Zig-Zag sequence starting from \'start\'. Alternates between even and odd numbers. Parameters: start (int): The starting number of the sequence. n (int): The number of terms to generate in the sequence. Returns: List[int]: The first n terms of the Zig-Zag sequence. if n < 1: return [] return [start + i for i in range(n)]"},{"question":"# Image Metadata Extractor You are developing a tool to analyze images by extracting metadata from image files. Your task is to implement a function that reads an image file and extracts specified metadata attributes. Task 1. Implement a function `extract_metadata(file_path: str, attributes: list) -> dict` that takes the path to an image file and a list of metadata attributes to extract. 2. If an attribute is not present in the image metadata, it should not be included in the result dictionary. Input * **file_path**: a string representing the path to the image file. * **attributes**: a list of strings specifying the metadata attributes to extract, e.g., `[\\"make\\", \\"model\\", \\"datetime\\"]`. Output * **dict**: A dictionary where keys are the attribute names and values are the corresponding metadata values from the image file. Constraints * The function should only return the attributes present in the image metadata. * If the image file does not exist or cannot be read, the function should return an empty dictionary. * Assume the images are in a format that supports metadata extraction (e.g., JPEG). Example Usage ```python metadata = extract_metadata(\\"sample_image.jpg\\", [\\"make\\", \\"model\\", \\"datetime\\"]) print(metadata) # Expected output: {\'make\': \'Canon\', \'model\': \'EOS 80D\', \'datetime\': \'2020:01:01 12:00:00\'}, or an empty dictionary if attributes are missing. ``` Note - Utilize the `PIL` (Pillow) library to open and read image files. - Use the `exif` property to extract metadata from the image. Sample Implementation ```python from PIL import Image def extract_metadata(file_path, attributes): try: image = Image.open(file_path) exif_data = image._getexif() or {} metadata = {attr: exif_data.get(attr) for attr in attributes if attr in exif_data} return metadata except (FileNotFoundError, AttributeError): return {} ```","solution":"from PIL import Image, ExifTags def extract_metadata(file_path, attributes): try: image = Image.open(file_path) exif_data = image._getexif() or {} metadata = {} for tag, value in exif_data.items(): tag_name = ExifTags.TAGS.get(tag) if tag_name in attributes: metadata[tag_name] = value return metadata except (FileNotFoundError, AttributeError, IOError): return {}"},{"question":"Problem Statement You are asked to implement a function that determines if a number is a prime number. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. # Function Signature ```python def is_prime(num: int) -> bool: Determine if a number is a prime number. :param num: The number to check. :return: True if the number is prime, False otherwise. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(1) False >>> is_prime(0) False >>> is_prime(-5) False >>> is_prime(17) True >>> is_prime(20) False >>> is_prime(19) True >>> is_prime(1.5) Traceback (most recent call last): ... TypeError: \'float\' object cannot be interpreted as an integer >>> is_prime(\\"string\\") Traceback (most recent call last): ... TypeError: \'str\' object cannot be interpreted as an integer pass ``` # Constraints 1. The input must be a non-negative integer. 2. The function should return False for numbers less than or equal to 1. 3. The function should handle efficient prime checking for inputs, including large values. # Requirements 1. Create a function `is_prime` that matches the specified signature. 2. Implement the logic to check if a number is prime. 3. Handle edge cases explicitly, raising appropriate error messages for non-integer inputs. 4. Optimize your solution for efficient prime checking, especially for larger integers. # Example Usage * `is_prime(2)` should return `True`. * `is_prime(4)` should return `False`. * `is_prime(-3)` should return `False`. Good luck!","solution":"import math def is_prime(num: int) -> bool: Determine if a number is a prime number. :param num: The number to check. :return: True if the number is prime, False otherwise. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(1) False >>> is_prime(0) False >>> is_prime(-5) False >>> is_prime(17) True >>> is_prime(20) False >>> is_prime(19) True >>> is_prime(1.5) Traceback (most recent call last): ... TypeError: \'float\' object cannot be interpreted as an integer >>> is_prime(\\"string\\") Traceback (most recent call last): ... TypeError: \'str\' object cannot be interpreted as an integer if not isinstance(num, int): raise TypeError(f\\"\'{type(num).__name__}\' object cannot be interpreted as an integer\\") if num <= 1: return False for i in range(2, int(math.sqrt(num)) + 1): if num % i == 0: return False return True"},{"question":"# Coding Assessment Question **Context:** Text processing and string manipulation are critical in a variety of applications, including data parsing, search algorithms, and natural language processing. Efficiently finding patterns within strings can lead to improvements in performance and accuracy for these applications. **Problem Statement:** You are given a string ( S ) and a pattern ( P ). You need to determine the starting index of the first occurrence of an anagram of ( P ) in ( S ). If no such anagram exists, return -1. An anagram of ( P ) is a permutation of ( P ) and must be entirely present in ( S ) without rearranging the characters of ( S ). **Guidelines:** 1. Use a sliding window approach to find the first occurrence of an anagram of ( P ) in ( S ). 2. Write an efficient algorithm that maintains a count of characters to compare the sliding window in ( S ) with ( P ). 3. Ensure that the solution works efficiently even for large inputs. **Function Signature:** ```python def find_anagram_index(s: str, p: str) -> int: pass ``` **Input Format:** - A string ( S ) where ( 1 leq |S| leq 10^5 ) - A string ( P ) where ( 1 leq |P| leq 10^3 ) **Output Format:** - An integer representing the starting index of the first occurrence of an anagram of ( P ) in ( S ). If no such anagram exists, return -1. **Example:** ```python s = \\"cbaebabacd\\" p = \\"abc\\" ``` Output: ```python 0 ``` Explanation: The substring from index 0 to 2 in `s` is \\"cba\\", which is an anagram of `p`. ```python s = \\"abab\\" p = \\"ab\\" ``` Output: ```python 0 ``` Explanation: The substring from index 0 to 1 in `s` is \\"ab\\", which is an anagram of `p`. ```python s = \\"abcde\\" p = \\"fgh\\" ``` Output: ```python -1 ``` Explanation: No anagram of `p` exists in `s`. **Constraints:** - Both input strings will only contain lowercase English letters. **Performance Requirements:** - The solution should work efficiently for the maximum constraints.","solution":"def find_anagram_index(s: str, p: str) -> int: from collections import Counter # Length of pattern and string len_p = len(p) len_s = len(s) # If pattern length is greater than string length, anagram is not possible if len_p > len_s: return -1 # Create frequency counters for pattern and the first window in the string count_p = Counter(p) count_s = Counter(s[:len_p]) # Check initial window if count_p == count_s: return 0 # Slide the window across the string for i in range(len_p, len_s): # Include a new character in the window count_s[s[i]] += 1 # Remove the character that is no longer in the window count_s[s[i - len_p]] -= 1 # Remove zero count keys to match the Counter comparison if count_s[s[i - len_p]] == 0: del count_s[s[i - len_p]] # Check if the updated window matches the pattern counter if count_p == count_s: return i - len_p + 1 # If no match found return -1"},{"question":"# Problem Statement You are tasked with developing a component of a text processing library that involves transforming and analyzing strings. Specifically, you need to create a function that calculates the longest sequence of repeating characters in a given input string. Write a function `longest_repeating_sequence` that identifies and returns the length of the longest sequence of consecutive repeating characters in the input string. # Function Signature ```python def longest_repeating_sequence(text: str) -> int: ``` # Input * `text` (str): A string consisting of printable ASCII characters (0 to 127 characters inclusive). # Output * Returns an integer representing the length of the longest sequence of consecutive repeating characters in the input string. # Constraints * The input string will have at least one character and at most 10,000 characters. * Handle both uppercase and lowercase characters separately, e.g., \'A\' and \'a\' are different characters. * The function must raise a `ValueError` with the message \\"Input must be a non-empty string\\" for: * Empty strings * Non-string inputs (including integers, lists, etc.) # Examples ```python >>> longest_repeating_sequence(\\"aaaaabbbaaaccc\\") 5 >>> longest_repeating_sequence(\\"abcde\\") 1 >>> longest_repeating_sequence(\\"abCCcDdDD\\") 2 >>> longest_repeating_sequence(\\"1111222333444\\") 4 >>> longest_repeating_sequence(\\"xyz\\") 1 >>> longest_repeating_sequence(\\"\\") Traceback (most recent call last): ... ValueError: Input must be a non-empty string >>> longest_repeating_sequence(12345) Traceback (most recent call last): ... ValueError: Input must be a non-empty string >>> longest_repeating_sequence([1, 2, 3, 4, 5]) Traceback (most recent call last): ... ValueError: Input must be a non-empty string ``` # Hints * Iterate through the string while keeping track of the current character\'s repetition count and update the maximum count whenever a new character appears. * Ensure you consider the final sequence in the string after iteration ends.","solution":"def longest_repeating_sequence(text: str) -> int: if not isinstance(text, str) or text == \\"\\": raise ValueError(\\"Input must be a non-empty string\\") max_count = 0 current_count = 1 for i in range(1, len(text)): if text[i] == text[i - 1]: current_count += 1 max_count = max(max_count, current_count) else: current_count = 1 return max(max_count, current_count)"},{"question":"# Detect Cycle in an Undirected Graph Using Disjoint Set Given an undirected graph, determine if the graph contains a cycle. Use the Disjoint Set (Union-Find) data structure to accomplish this task. If there exists a cycle, the method should return `True`. Otherwise, it should return `False`. Implement the following method: ```python def has_cycle(self) -> bool: pass ``` # Function Specification * **Input**: * No parameters required. * **Output**: * Return `True` if the graph contains a cycle, else return `False`. # Constraints * The graph can contain up to 10^4 vertices and 10^4 edges. * Vertices are denoted as integers starting from 0 to V-1. Example ```python g = Graph(3) g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(2, 0) print(g.has_cycle()) # Output: True g2 = Graph(3) g2.add_edge(0, 1) g2.add_edge(1, 2) print(g2.has_cycle()) # Output: False ``` # Explanation 1. In the first example, the graph forms a cycle: 0 -> 1 -> 2 -> 0, hence the method returns `True`. 2. In the second example, the graph does not contain any cycle, thus the method returns `False`. This problem tests your understanding of the Disjoint Set data structure and its application in cycle detection in an undirected graph.","solution":"class Graph: def __init__(self, vertices): self.V = vertices # Number of vertices self.graph = [] # Default dictionary to store the graph def add_edge(self, u, v): self.graph.append([u, v]) # A utility function to find the subset of an element i def find(self, parent, i): if parent[i] == -1: return i if parent[i] != -1: return self.find(parent, parent[i]) # A utility function to do union of two subsets def union(self, parent, x, y): parent[x] = y # The main function to check whether a given graph contains cycle or not def has_cycle(self): parent = [-1] * self.V for u, v in self.graph: x = self.find(parent, u) y = self.find(parent, v) if x == y: return True self.union(parent, x, y) return False"},{"question":"# Missing Number Identifier **Context:** You are given an array that contains `n` distinct numbers taken from the range 0 to `n`. This means there are `n + 1` numbers in the range 0 to `n`, inclusive, but one number is missing from the array. Your task is to identify the missing number. **Task:** Write a function to find the missing number in the given array. **Function Signature:** ```python def find_missing_number(arr: List[int]) -> int: ``` **Input:** - `arr` (list of integers): An array of `n` distinct integers from the range 0 to `n`. **Output:** - `int`: The missing number from the range. **Constraints:** - The length of `arr` will be `n` - Only one number is missing from the range 0 to `n` - 1 <= n <= 10^5 **Example:** ```python >>> find_missing_number([3, 0, 1]) 2 >>> find_missing_number([9, 6, 4, 2, 3, 5, 7, 0, 1]) 8 ``` **Performance Requirements:** - The function should run in O(n) time complexity and use O(1) extra space (excluding the input array). **Explanation:** The function `find_missing_number` should efficiently find the missing number by leveraging mathematical properties or bit manipulation techniques, rather than relying on additional data structures or sorting algorithms.","solution":"from typing import List def find_missing_number(arr: List[int]) -> int: This function finds the missing number in an array that contains n distinct numbers taken from the range 0 to n. The approach used here is to compute the expected sum of the range 0 to n and subtract the sum of the array from it. This difference will be the missing number. n = len(arr) expected_sum = n * (n + 1) / 2 actual_sum = sum(arr) return int(expected_sum - actual_sum)"},{"question":"# Coding Assessment Question Sum of Prime Factors: You need to solve a problem that involves calculating a unique property of an integer. Given an integer `n`, the task is to find the sum of its prime factors (should include each prime factor only once, even if it appears multiple times in the factorization). Your objective is to implement a function that computes this sum for any given positive integer `n`. Function Definition: Implement a function `sum_of_prime_factors(n)` that takes an integer `n` and returns the sum of its prime factors. Input: - An integer `n` (1 ≤ n ≤ 10^6). Output: - An integer, the sum of the unique prime factors of `n`. Example: ```python >>> result = sum_of_prime_factors(28) >>> print(result) 10 ``` Explanation: - The prime factors of 28 are 2 and 7. - The sum is 2 + 7 = 9. Constraints: 1. Your algorithm must be efficient enough to handle the largest inputs within reasonable time limits. 2. Ensure your solution handles edge cases, such as `n` being 1 or a prime number itself. 3. You might need to preprocess data or apply efficient methods like the Sieve of Eratosthenes to find prime factors. Good luck!","solution":"def sum_of_prime_factors(n): Returns the sum of unique prime factors of the given integer n. if n <= 1: return 0 sum_primes = 0 factor = 2 while factor * factor <= n: if n % factor == 0: sum_primes += factor while n % factor == 0: n //= factor factor += 1 if n > 1: sum_primes += n return sum_primes"},{"question":"Inventory Management System Upgrade The goal of this coding task is to upgrade an existing inventory management system by adding new features to improve its functionality and efficiency. The current implementation supports basic inventory operations but lacks advanced features for tracking and managing complicated scenarios. # Task 1. **Implement Bulk Update Functionality**: Add a method to update the quantity of multiple items in the inventory simultaneously. This feature will be useful for updating stock after events such as stocktaking or batch deliveries. 2. **Add Stock Expiry Tracking**: Extend the system to track the expiry dates of perishable items. Implement functionalities to flag and optionally remove items that have expired. 3. **Optimize Retrieval Operations**: Refactor retrieval methods to enhance performance, particularly for large inventories. Focus on minimizing the time complexity and improving the efficiency of searching and filtering operations. # Input and Output - **Input**: Bulk updates will be provided as a dictionary mapping item IDs to their new quantities, and expiry information will be added as a list of tuples containing item IDs and expiry dates. - **Output**: Display messages indicating the status of bulk updates and the removal of expired items, if any. Also, provide a summary of the inventory at the end of an operation. # Constraints - **Integrity**: Ensure that the inventory maintains accurate and consistent data throughout operations. - **Performance**: The system should handle inventories with up to 100,000 items efficiently. - **Expiry Format**: Use the format `YYYY-MM-DD` for dates. - **Bulk Update Restrictions**: Bulk updates should be atomic, meaning either all updates succeed, or none do. # Requirements - **Bulk Update**: Add a method `bulk_update_stock(updates: dict)` to handle updating multiple items\' quantities. - **Expiry Tracking**: Implement methods to add and check expiry dates, and to remove expired items. - **Efficiency**: Refactor existing methods to improve the overall performance of the system. - **Output**: Ensure that status messages are printed for bulk updates and expiry checks. # Example ```python inventory = InventoryManagementSystem() inventory.bulk_update_stock({ \'item_1\': 100, \'item_2\': 150, \'item_3\': 200 }) inventory.add_expiry_dates([ (\'item_1\', \'2024-05-01\'), (\'item_2\', \'2023-11-12\') ]) inventory.check_and_remove_expired_items(current_date=\'2023-12-01\') inventory.display_inventory_summary() # Summary after updates and removals ``` Your task is to modify the `InventoryManagementSystem` class. Ensure to add new methods such as `bulk_update_stock`, `add_expiry_dates`, and `check_and_remove_expired_items`, and update existing methods as needed to support the new features and improve efficiency.","solution":"from datetime import datetime class InventoryManagementSystem: def __init__(self): self.inventory = {} self.expiry_dates = {} def bulk_update_stock(self, updates): Update the quantities of multiple items in the inventory simultaneously. for item_id, quantity in updates.items(): if item_id in self.inventory: self.inventory[item_id] += quantity else: self.inventory[item_id] = quantity print(\\"Bulk update completed successfully.\\") def add_expiry_dates(self, expiry_list): Add expiry dates to items in the inventory. for item_id, expiry_date in expiry_list: self.expiry_dates[item_id] = expiry_date print(\\"Expiry dates added successfully.\\") def check_and_remove_expired_items(self, current_date): Remove items that have expired based on the current date. current_date_obj = datetime.strptime(current_date, \'%Y-%m-%d\') items_to_remove = [item_id for item_id, expiry_date in self.expiry_dates.items() if datetime.strptime(expiry_date, \'%Y-%m-%d\') < current_date_obj] for item_id in items_to_remove: del self.inventory[item_id] del self.expiry_dates[item_id] print(f\\"Removed {len(items_to_remove)} expired items.\\") def display_inventory_summary(self): Display a summary of the current inventory. print(\\"Inventory Summary:\\") for item_id, quantity in self.inventory.items(): expiry_date = self.expiry_dates.get(item_id, \\"N/A\\") print(f\\"{item_id}: {quantity} units, Expiry Date: {expiry_date}\\") # Example usage inventory = InventoryManagementSystem() inventory.bulk_update_stock({ \'item_1\': 100, \'item_2\': 150, \'item_3\': 200 }) inventory.add_expiry_dates([ (\'item_1\', \'2024-05-01\'), (\'item_2\', \'2023-11-12\') ]) inventory.check_and_remove_expired_items(current_date=\'2023-12-01\') inventory.display_inventory_summary() # Summary after updates and removals"},{"question":"# Context Given a series of English sentences, find the most common letter across all sentences, ignoring case. If there is a tie, select the letter that comes first alphabetically. Write a function to determine this letter. # Problem Statement Write a function `most_common_letter(sentences: List[str]) -> str` that takes a list of sentences and returns the most common letter ignoring case. In case of a tie, return the letter that appears first alphabetically. # Expected Input and Output Formats - **Input**: A list of strings. - Example: `[\\"Hello World\\", \\"Python Programming\\", \\"Data Science\\"]` - **Output**: A single character representing the most common letter. - Example for above input: `o` (both \'o\' and \'p\' appear twice, but \'o\' comes first alphabetically) # Constraints 1. Sentences will contain only printable ASCII characters. 2. Sentences can be up to 1000 characters long. 3. The list can contain up to 100 sentences. 4. Each sentence can contain whitespace and punctuation, but only letters should be counted. # Performance Requirements - Your solution should be efficient in terms of both time and space complexities while handling the stated constraints. # Notes - Ignore case; \'A\' and \'a\' are considered the same. - Ignoring non-letter characters in the sentences. - Consider the frequency of each letter and determine the most common one. # Implementation: Implement the function with the following signature: ```python from typing import List def most_common_letter(sentences: List[str]) -> str: # Your implementation here ```","solution":"from typing import List from collections import Counter import string def most_common_letter(sentences: List[str]) -> str: # Combine all sentences into one string combined_text = \' \'.join(sentences).lower() # Filter out only alphabetic characters letters = filter(str.isalpha, combined_text) # Count frequencies of each letter letter_counts = Counter(letters) # Find the most common letter with a tie-breaking rule (alphabetical order) most_common = \'\' highest_count = 0 for letter in string.ascii_lowercase: if letter_counts[letter] > highest_count: highest_count = letter_counts[letter] most_common = letter return most_common"},{"question":"# Genetic Algorithm for Traveling Salesman Problem **Context**: A logistics company has a fleet of trucks to deliver goods across multiple cities. The company wants to determine the most efficient route for each truck to minimize travel distance. They have formulated this as a Traveling Salesman Problem (TSP) and want you to use a genetic algorithm to find an optimal solution. # Task: Implement the `genetic_algorithm_tsp` function to solve the TSP using a genetic algorithm approach. You are provided with a `City` class and a `Route` class with the following attributes: ```python class City: def __init__(self, name, x, y): self.name = name self.x = x self.y = y def distance_to(self, city) -> float: Returns the Euclidean distance to another city. pass # Defined elsewhere class Route: def __init__(self, cities): self.cities = cities def total_distance(self) -> float: Returns the total distance of the route. pass # Defined elsewhere ``` # Function Signature: ```python def genetic_algorithm_tsp( cities: list, population_size: int = 100, mutation_rate: float = 0.01, generations: int = 1000 ) -> Route: pass ``` # Input: - `cities (list of City)`: A list of `City` instances representing the cities to visit. - `population_size (int)`: Number of routes to maintain in each generation. - `mutation_rate (float)`: Probability of mutating a given route. - `generations (int)`: Number of generations to run the genetic algorithm. # Output: - A `Route` instance representing the optimal route with the shortest distance. # Constraints: - The algorithm should effectively handle a large number of cities. - Ensure the algorithm maintains diversity in the population to avoid premature convergence. - Implement crossover and mutation mechanisms to evolve better routes over generations. # Example: ```python # Assume we have a proper implementation of `City` and `Route` class cities = [ City(\\"A\\", 0, 0), City(\\"B\\", 1, 3), City(\\"C\\", 4, 3), City(\\"D\\", 6, 1), ] optimal_route = genetic_algorithm_tsp(cities, population_size=50, mutation_rate=0.02, generations=500) print(\\"Optimized Route:\\") for city in optimal_route.cities: print(f\\"{city.name} ({city.x}, {city.y})\\") print(f\\"Total Distance: {optimal_route.total_distance()}\\") ``` **Expectation**: A solution demonstrating your understanding of genetic algorithms and how they can be applied to TSP, while effectively handling edge cases and optimizing for performance.","solution":"import random import math from typing import List class City: def __init__(self, name, x, y): self.name = name self.x = x self.y = y def distance_to(self, city) -> float: return math.sqrt((self.x - city.x) ** 2 + (self.y - city.y) ** 2) class Route: def __init__(self, cities: List[City]): self.cities = cities self._distance = 0.0 def total_distance(self) -> float: if self._distance == 0: total = 0 for i in range(len(self.cities)): from_city = self.cities[i] to_city = self.cities[(i + 1) % len(self.cities)] total += from_city.distance_to(to_city) self._distance = total return self._distance def create_initial_population(cities, population_size): population = [] for _ in range(population_size): population.append(Route(random.sample(cities, len(cities)))) return population def rank_routes(population): ranked_population = sorted(population, key=lambda route: route.total_distance()) return ranked_population def selection(ranked_population, elite_size): selection_results = [] df = sum([1 / route.total_distance() for route in ranked_population]) fitness = [(1 / route.total_distance()) / df for route in ranked_population] for i in range(elite_size): selection_results.append(ranked_population[i]) cumulative_probability = [] cumulative = 0 for fit in fitness: cumulative += fit cumulative_probability.append(cumulative) for _ in range(len(ranked_population) - elite_size): pick = random.random() for i, route in enumerate(ranked_population): if pick <= cumulative_probability[i]: selection_results.append(route) break return selection_results def breed(parent1, parent2): child_p1 = [] child_p2 = [] gene_a = int(random.random() * len(parent1.cities)) gene_b = int(random.random() * len(parent1.cities)) start_gene = min(gene_a, gene_b) end_gene = max(gene_a, gene_b) for i in range(start_gene, end_gene): child_p1.append(parent1.cities[i]) child_p2 = [city for city in parent2.cities if city not in child_p1] return Route(child_p1 + child_p2) def breed_population(matingpool, elite_size): children = [] length = len(matingpool) - elite_size pool = random.sample(matingpool, len(matingpool)) for i in range(elite_size): children.append(matingpool[i]) for i in range(length): child = breed(pool[i], pool[len(matingpool) - i - 1]) children.append(child) return children def mutate(route, mutation_rate): for swapped in range(len(route.cities)): if random.random() < mutation_rate: swap_with = int(random.random() * len(route.cities)) city1 = route.cities[swapped] city2 = route.cities[swap_with] route.cities[swapped] = city2 route.cities[swap_with] = city1 return route def mutate_population(population, mutation_rate): mutated_population = [] for idx in range(len(population)): mutated_individual = mutate(population[idx], mutation_rate) mutated_population.append(mutated_individual) return mutated_population def next_generation(current_gen, elite_size, mutation_rate): ranked_population = rank_routes(current_gen) selection_results = selection(ranked_population, elite_size) children = breed_population(selection_results, elite_size) next_generation = mutate_population(children, mutation_rate) return next_generation def genetic_algorithm_tsp(cities, population_size=100, mutation_rate=0.01, generations=1000): elite_size = population_size // 5 population = create_initial_population(cities, population_size) for i in range(generations): population = next_generation(population, elite_size, mutation_rate) best_route = rank_routes(population)[0] return best_route"},{"question":"# Circular Dance Formation In a dance competition, participants are positioned in a circular formation. Each participant should know the index of their immediate neighbors for coordination purposes. You are tasked to write a function `circular_neighbors(n: int, index: int) -> Tuple[int, int]` that determines the indices of the immediate left and right neighbors for a participant in a circular dance formation. # Input * `n` (int): The total number of participants in the circle. `n` will be an integer greater than or equal to 3. * `index` (int): The zero-based index of the participant whose neighbors need to be found. The value of `index` will always be a valid index in the circle (i.e., `0 <= index < n`). # Output * Returns a tuple containing two integers: - The index of the participant immediately to the left. - The index of the participant immediately to the right. # Examples ```python >>> circular_neighbors(5, 0) (4, 1) >>> circular_neighbors(5, 1) (0, 2) >>> circular_neighbors(5, 4) (3, 0) >>> circular_neighbors(4, 2) (1, 3) >>> circular_neighbors(6, 3) (2, 4) ``` # Additional Information - Participants are standing in a perfect circle such that the first participant is adjacent to the last participant. - Ensure that your implementation handles all edge cases correctly.","solution":"def circular_neighbors(n, index): Returns the indices of the immediate left and right neighbors for a participant in a circular dance formation. :param n: Total number of participants in the circle (integer >= 3) :param index: The zero-based index of the participant (0 <= index < n) :return: A tuple containing the indices of the left and right neighbors left_neighbor = (index - 1) % n right_neighbor = (index + 1) % n return (left_neighbor, right_neighbor)"},{"question":"# Coding Assessment Question You are given a grid with an ( n times m ) size representing a map of a garden. Each cell in the grid contains a positive integer representing the height of that part of the garden. Your task is to write a function that calculates the maximum difference of heights between any two cells, such that one cell is reachable from the other. A cell can be reached from another cell if both are directly adjacent (horizontally or vertically, but not diagonally). # Function Signature ```python def max_height_difference(grid: List[List[int]]) -> int: Calculate the maximum height difference between any two reachable cells in the grid. :param grid: A 2D list of positive integers representing the height of the parts of the garden. :return: The maximum height difference between any two reachable cells. ``` # Example ```python >>> max_height_difference([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 8 # Detailed explanation: # The maximum height difference is between the cells (0, 0) with height 1 and (2, 2) with height 9. >>> max_height_difference([ ... [2, 3, 7], ... [10, 6, 5], ... [8, 1, 12] ... ]) 11 # Detailed explanation: # The maximum height difference is between the cells (2, 1) with height 1 and (2, 2) with height 12. ``` # Input Constraints * ( 1 leq n, m leq 1000 ) * ( 1 leq text{grid}[i][j] leq 10^6 ) # Requirements * Your solution should be efficient in handling grid sizes up to 1000x1000. * Aim for a time complexity of ( O(n times m) ) and space complexity of ( O(1) ). # Edge Cases * Test with the smallest grid size (1x1). * Validate that all heights are positive integers.","solution":"from typing import List def max_height_difference(grid: List[List[int]]) -> int: Calculate the maximum height difference between any two reachable cells in the grid. :param grid: A 2D list of positive integers representing the height of the parts of the garden. :return: The maximum height difference between any two reachable cells. max_height = float(\'-inf\') min_height = float(\'inf\') for row in grid: for height in row: max_height = max(max_height, height) min_height = min(min_height, height) return max_height - min_height"},{"question":"# Problem Statement You need to implement a function `rotate_array` that takes an array of integers and rotates it to the right by `k` steps, where `k` is a non-negative integer. This means that the elements of the array are shifted to the right by `k` positions, and the elements that fall off the end are wrapped around to the beginning. # Input * An array `arr` of integers. * `1 <= len(arr) <= 10^5` * `-10^9 <= arr[i] <= 10^9` * An integer `k` where `0 <= k <= 10^5`. # Output * The modified array after rotating it to the right by `k` steps. # Constraints * The function should be able to handle large arrays efficiently. * You should aim for an optimal time and space complexity. # Examples * Example 1: ```python rotate_array([1, 2, 3, 4, 5, 6, 7], 3) ``` Expected Output: ``` [5, 6, 7, 1, 2, 3, 4] ``` * Example 2: ```python rotate_array([-1, -100, 3, 99], 2) ``` Expected Output: ``` [3, 99, -1, -100] ``` # Additional Context Imagine you are working with a data processing system that necessitates shifting elements in a data stream for real-time analysis. Efficiently rotating the data with minimal overhead is crucial for maintaining the performance of your application under high load. Your implementation should strive to deliver optimal results to accommodate these constraints. Write the function `rotate_array` that delivers this functionality.","solution":"def rotate_array(arr, k): Rotates the array to the right by k steps. Parameters: arr (list of int): The array of integers to rotate. k (int): The number of steps to rotate the array. Returns: list of int: The rotated array. n = len(arr) k = k % n # In case k is greater than length of array return arr[-k:] + arr[:-k]"},{"question":"# Problem Statement You are given a list of words and a target word. Your task is to implement a function that finds the shortest transformation sequence from the start word to the target word, such that: 1. Only one letter can be changed at a time. 2. Each transformed word must exist in the word list. Note that the start word is always the first word in the list, and the target word is guaranteed to exist in the list. # Function Signature: ```python def word_ladder(word_list: List[str]) -> int: ``` # Input: - `word_list`: A list of strings where the first word is the start word, and the last word is the target word. # Output: - Returns an integer representing the length of the shortest transformation sequence from the start word to the target word. If no such sequence exists, return 0. # Constraints: - The word list contains between 2 and 1000 words. - Each word in the list has the same length, and the length is between 1 and 10. - All words contain lowercase English letters. # Example: ```python word_list = [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"] result = word_ladder(word_list) print(result) # Expected output: 5 (The sequence \\"hit\\" -> \\"hot\\" -> \\"dot\\" -> \\"dog\\" -> \\"cog\\") ``` # Notes: - You are expected to use BFS (Breadth-First Search) to find the shortest transformation sequence. - Return 0 if no such sequence exists. - The word list is guaranteed to have at least two words, and the start word and target word are different.","solution":"from collections import deque from typing import List def word_ladder(word_list: List[str]) -> int: Returns the length of the shortest transformation sequence from the start word to the target word. start = word_list[0] target = word_list[-1] word_set = set(word_list) if start == target: return 1 queue = deque([(start, 1)]) while queue: current_word, steps = queue.popleft() for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i+1:] if next_word == target: return steps + 1 if next_word in word_set: word_set.remove(next_word) queue.append((next_word, steps + 1)) return 0"},{"question":"# Background You are working on a data processing task for an e-commerce platform, where you need to analyze the sales data of various products. The data is provided as a dictionary where the keys are product IDs (strings) and the values are lists of integers representing the daily sales figures for the past month. # Problem Statement Write a function named `analyze_sales_data` in Python that accomplishes the following: 1. Accepts the sales data dictionary. 2. Computes the average daily sales for each product. 3. Identifies the product with the highest average daily sales. 4. Returns a tuple containing the product ID with the highest sales and its average daily sales. # Function Signature ```python def analyze_sales_data(sales_data: dict[str, list[int]]) -> tuple[str, float]: # your code here ``` # Input - `sales_data` (dictionary): A dictionary where keys are product IDs (strings) and values are lists of integers representing daily sales figures. # Output - (tuple): A tuple containing the product ID with the highest average daily sales and its average daily sales as a float. # Constraints - Each list of sales figures will have a minimum length of 1. - All sales figures are non-negative integers. - There will be at least one product in the dictionary. # Example Usage ```python sales_data = { \\"product_1\\": [5, 10, 15, 10, 5], \\"product_2\\": [0, 0, 0, 0, 0], \\"product_3\\": [20, 30, 25, 20, 30] } result = analyze_sales_data(sales_data) print(result) # Output: (\'product_3\', 25.0) ``` # Notes - Ensure the function handles the case where two or more products have the same highest average daily sales by returning any one of them. - Aim for efficient computation to handle large datasets effectively.","solution":"def analyze_sales_data(sales_data: dict[str, list[int]]) -> tuple[str, float]: max_avg_sales = 0 best_product_id = None for product_id, sales in sales_data.items(): avg_sales = sum(sales) / len(sales) if avg_sales > max_avg_sales: max_avg_sales = avg_sales best_product_id = product_id return (best_product_id, max_avg_sales)"},{"question":"# Find the Dominant Color in an Image Context: You are a developer working on a photo-filtering application. One of the features you need to implement is automatic color correction based on the dominant color present in an image. To achieve this, you need to write a function that analyzes the pixels of an image and determines the most frequently occurring color. Task: Write a function `find_dominant_color` that takes in an image represented by a 2D list of RGB tuples and returns the dominant color. # Function Signature ```python def find_dominant_color(image: List[List[Tuple[int, int, int]]]) -> Tuple[int, int, int]: ``` # Parameters: * `image` (List[List[Tuple[int, int, int]]]): A 2D list representing an image, where each element is a tuple containing three integers (R, G, B) in the range [0, 255]. # Returns: * A tuple containing three integers representing the most frequently occurring color in the image. # Constraints: 1. The image will have at least one pixel. 2. Each pixel is represented by a tuple of three integers (R, G, B). 3. In case of ties, return any one of the most frequent colors. # Examples: ```python >>> find_dominant_color([ [(255, 0, 0), (255, 0, 0), (0, 255, 0)], [(0, 255, 0), (0, 255, 0), (0, 255, 0)] ]) (0, 255, 0) >>> find_dominant_color([ [(123, 234, 111), (123, 234, 111), (123, 234, 111)], [(111, 222, 333), (111, 222, 333), (123, 234, 111)] ]) (123, 234, 111) >>> find_dominant_color([ [(50, 50, 50)] ]) (50, 50, 50) ``` **Note**: Your function should handle images with diverse colors efficiently and should be able to tackle edge cases with small or highly uniform images appropriately.","solution":"from typing import List, Tuple from collections import Counter def find_dominant_color(image: List[List[Tuple[int, int, int]]]) -> Tuple[int, int, int]: Determines the most frequently occurring color in an image. Args: image: List of List of RGB tuples representing the image. Returns: The most frequent color as an RGB tuple. # Flatten the list of lists into a single list of pixels flat_pixels = [pixel for row in image for pixel in row] # Count the frequency of each color color_counts = Counter(flat_pixels) # Return the color with the highest frequency dominant_color = color_counts.most_common(1)[0][0] return dominant_color"},{"question":"# Problem Statement: You are required to implement a **Circular Deque** using a Python list. This data structure should support standard deque operations efficiently, including the ability to wrap around and make use of the circular nature of the structure. Function Signatures: 1. `__init__(self, k: int) -> None`: Initialize the deque with a fixed size `k`. 2. `insertFront(self, value: int) -> bool`: Add an item at the front of the Deque. Return `True` if the operation is successful, or `False` if the deque is full. 3. `insertLast(self, value: int) -> bool`: Add an item at the rear of the Deque. Return `True` if the operation is successful, or `False` if the deque is full. 4. `deleteFront(self) -> bool`: Delete an item from the front of the Deque. Return `True` if the operation is successful, or `False` if the deque is empty. 5. `deleteLast(self) -> bool`: Delete an item from the rear of the Deque. Return `True` if the operation is successful, or `False` if the deque is empty. 6. `getFront(self) -> int`: Get the front item from the deque. Return `-1` if the deque is empty. 7. `getRear(self) -> int`: Get the last item from the deque. Return `-1` if the deque is empty. 8. `isEmpty(self) -> bool`: Check whether the deque is empty. 9. `isFull(self) -> bool`: Check whether the deque is full. Constraints: - The integer value `k` will be between `1` and `1000`. - Values inserted into the deque will be integers between `-1000` and `1000`. - There will be at most `2000` operations for each instance of Circular Deque. Example: ```python >>> dq = MyCircularDeque(3) >>> dq.insertLast(1) True >>> dq.insertLast(2) True >>> dq.insertFront(3) True >>> dq.insertFront(4) False >>> dq.getRear() 2 >>> dq.isFull() True >>> dq.deleteLast() True >>> dq.insertFront(4) True >>> dq.getFront() 4 ``` # Implementation: You are required to implement the `MyCircularDeque` class to meet the given specifications. Ensure the implementation handles edge cases correctly and maintains efficient operations throughout.","solution":"class MyCircularDeque: def __init__(self, k: int) -> None: self.size = k self.deque = [0] * k self.front = -1 self.rear = -1 self.count = 0 def insertFront(self, value: int) -> bool: if self.isFull(): return False if self.isEmpty(): self.front = self.rear = 0 else: self.front = (self.front - 1) % self.size self.deque[self.front] = value self.count += 1 return True def insertLast(self, value: int) -> bool: if self.isFull(): return False if self.isEmpty(): self.front = self.rear = 0 else: self.rear = (self.rear + 1) % self.size self.deque[self.rear] = value self.count += 1 return True def deleteFront(self) -> bool: if self.isEmpty(): return False if self.front == self.rear: self.front = self.rear = -1 else: self.front = (self.front + 1) % self.size self.count -= 1 return True def deleteLast(self) -> bool: if self.isEmpty(): return False if self.front == self.rear: self.front = self.rear = -1 else: self.rear = (self.rear - 1 + self.size) % self.size self.count -= 1 return True def getFront(self) -> int: if self.isEmpty(): return -1 return self.deque[self.front] def getRear(self) -> int: if self.isEmpty(): return -1 return self.deque[self.rear] def isEmpty(self) -> bool: return self.count == 0 def isFull(self) -> bool: return self.count == self.size"},{"question":"# Coding Assessment Question Problem Statement: You are given the task of finding the smallest number in a list that is missing from a continuous sequence of 1 to `n` (where `n` is the length of the list). Write a function `find_missing_number(nums: List[int]) -> int` that takes a list of integers and returns the smallest missing number in the continuous sequence starting from 1. Input: * `nums` (1 <= len(nums) <= 10^5): A list of integers representing the sequence, which may contain duplicates. Output: * An integer representing the smallest missing number in the continuous sequence starting from 1. Example: ```python assert find_missing_number([3, 4, -1, 1]) == 2 assert find_missing_number([1, 2, 0]) == 3 assert find_missing_number([7, 8, 9, 11, 12]) == 1 assert find_missing_number([1, 1, 2, 2, 3, 3]) == 4 ``` Constraints: * Your solution must operate within a reasonable time complexity given the constraints. * Efficiently handle lists with large lengths. * Consider edge cases where all elements in the list are negative or very large, or where the list contains duplicates. Performance: * Aim for an optimal solution that minimizes unnecessary computations and can handle the upper limits of the input size.","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Find the smallest missing number from the continuous sequence starting from 1 in the given list. n = len(nums) # Create a set of the numbers for efficient look-up num_set = set(nums) # Start checking each number from 1 up to n+1 for i in range(1, n+2): if i not in num_set: return i"},{"question":"# Problem Statement **Context:** Given a 2D grid of arbitrary size containing integers, imagine you have a starting point and you need to find the longest possible path, either horizontally or vertically, that you can travel without revisiting any cell. However, the path must be in a frame of strictly increasing values to qualify. **Definition:** The task is to implement a function to determine the longest strictly increasing path in the given 2D integer grid. Your path can only continue in four possible directions: - Up - Down - Left - Right You cannot revisit any cell in your path, and you can only move to a cell if its value is strictly greater than the current cell\'s value. **Requirements:** Implement the following function: ```python def longest_increasing_path(grid: list[list[int]]) -> int: Returns the length of the longest strictly increasing path in the grid. Args: grid (list[list[int]]): A 2D list of integers representing the grid. Returns: int: The length of the longest strictly increasing path. pass ``` **Input:** - `grid`: A 2D list of integers representing the grid. **Output:** - An integer representing the length of the longest strictly increasing path in the given grid. **Examples:** ```python assert longest_increasing_path([ [9, 9, 4], [6, 6, 8], [2, 1, 1] ]) == 4 # The path is [1 -> 2 -> 6 -> 9] assert longest_increasing_path([ [3, 4, 5], [3, 2, 6], [2, 2, 1] ]) == 4 # The path is [3 -> 4 -> 5 -> 6] assert longest_increasing_path([ [1] ]) == 1 # The path is [1] ``` **Constraints:** - The dimensions of the grid can be 1x1 up to 100x100 where 1 ≤ grid[i][j] ≤ 10^5. - All cells have distinct values.","solution":"def longest_increasing_path(grid): Returns the length of the longest strictly increasing path in the grid. Args: grid (list[list[int]]): A 2D list of integers representing the grid. Returns: int: The length of the longest strictly increasing path. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) memo = [[-1] * cols for _ in range(rows)] def dfs(x, y): if memo[x][y] != -1: return memo[x][y] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_len = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] > grid[x][y]: max_len = max(max_len, 1 + dfs(nx, ny)) memo[x][y] = max_len return max_len max_path = 0 for i in range(rows): for j in range(cols): max_path = max(max_path, dfs(i, j)) return max_path"},{"question":"**Context**: You are provided with a `TreeNode` class representing nodes in a binary tree. Each node has a `value`, a `left` child, and a `right` child. You realize that the current implementation lacks a method for determining if the tree is balanced. A balanced tree is defined as one where the depth of the two subtrees of every node never differ by more than 1. **Objective:** Implement the `is_balanced` method in the given `BinaryTree` class that checks if the tree is balanced. This method must handle all standard cases effectively, including when the tree is empty. **Function Signature:** ```python def is_balanced(self, root: TreeNode) -> bool: Check if the binary tree is balanced. Params: root (TreeNode): The root node of the binary tree. Returns: bool: True if the tree is balanced, False otherwise. Examples: >>> tree = BinaryTree() >>> tree.root = TreeNode(1) >>> tree.root.left = TreeNode(2) >>> tree.root.right = TreeNode(3) >>> tree.root.left.left = TreeNode(4) >>> tree.root.left.right = TreeNode(5) >>> tree.is_balanced(tree.root) True >>> tree.root.left.left.left = TreeNode(6) >>> tree.is_balanced(tree.root) False ``` **Constraints:** - The function should have a time complexity of O(n) where n is the number of nodes in the tree. - The function should not use any extra space apart from a few variables and recursive call stack (i.e., space complexity should be O(h) where h is the height of the tree). **Examples:** 1. Checking a balanced tree: ```python tree = BinaryTree() tree.root = TreeNode(1) tree.root.left = TreeNode(2) tree.root.right = TreeNode(3) tree.root.left.left = TreeNode(4) tree.root.left.right = TreeNode(5) assert tree.is_balanced(tree.root) == True ``` 2. Checking an unbalanced tree: ```python tree = BinaryTree() tree.root = TreeNode(1) tree.root.left = TreeNode(2) tree.root.right = TreeNode(3) tree.root.left.left = TreeNode(4) tree.root.left.right = TreeNode(5) tree.root.left.left.left = TreeNode(6) assert tree.is_balanced(tree.root) == False ``` 3. Checking an empty tree: ```python tree = BinaryTree() assert tree.is_balanced(tree.root) == True ``` 4. Checking a tree with a single node: ```python tree = BinaryTree() tree.root = TreeNode(1) assert tree.is_balanced(tree.root) == True ```","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self): self.root = None def is_balanced(self, root: TreeNode) -> bool: Check if the binary tree is balanced. def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) if not left_balanced or not right_balanced: return 0, False if abs(left_height - right_height) > 1: return 0, False return max(left_height, right_height) + 1, True _, is_bal = check_balance(root) return is_bal"},{"question":"# Fraction Class Implementation Objective You are given a design brief to create a `Fraction` class that can handle basic arithmetic operations with fractions. Your task is to implement this class with methods to add, subtract, multiply, and divide fractions. Problem Statement A `Fraction` class models a mathematical fraction with a numerator and a denominator. Implement this class with the following methods: 1. **`__init__(self, numerator: int, denominator: int)`** * **Description**: This method initializes a fraction. If the denominator is zero, it should raise a `ValueError`. * **Input**: - `numerator`: an integer representing the numerator of the fraction. - `denominator`: an integer representing the denominator of the fraction. * **Output**: None 2. **`add(self, other: \\"Fraction\\") -> \\"Fraction\\"`** * **Description**: This method returns a new fraction that is the sum of the current fraction and another fraction. * **Input**: - `other`: a `Fraction` object. * **Output**: A new `Fraction` object representing the sum. 3. **`subtract(self, other: \\"Fraction\\") -> \\"Fraction\\"`** * **Description**: This method returns a new fraction that is the difference between the current fraction and another fraction. * **Input**: - `other`: a `Fraction` object. * **Output**: A new `Fraction` object representing the difference. 4. **`multiply(self, other: \\"Fraction\\") -> \\"Fraction\\"`** * **Description**: This method returns a new fraction that is the product of the current fraction and another fraction. * **Input**: - `other`: a `Fraction` object. * **Output**: A new `Fraction` object representing the product. 5. **`divide(self, other: \\"Fraction\\") -> \\"Fraction\\"`** * **Description**: This method returns a new fraction that is the quotient of the current fraction by another fraction. * **Input**: - `other`: a `Fraction` object. * **Output**: A new `Fraction` object representing the quotient. Constraints: 1. The `denominator` in the `__init__` method should not be zero. 2. The `denominator` of the resultant fraction should always be positive. 3. Resulting fractions should always be in the simplest form (i.e., the greatest common divisor of the numerator and denominator should be 1). Example Usage ```python from fractions import gcd class Fraction: def __init__(self, numerator: int, denominator: int): if denominator == 0: raise ValueError(\\"Denominator cannot be zero\\") self.numerator = numerator self.denominator = denominator self.simplify() def simplify(self): greatest_common_divisor = gcd(self.numerator, self.denominator) self.numerator /= greatest_common_divisor self.denominator /= greatest_common_divisor if self.denominator < 0: # Keep denominator positive self.numerator = -self.numerator self.denominator = -self.denominator def add(self, other: \\"Fraction\\") -> \\"Fraction\\": new_num = self.numerator * other.denominator + other.numerator * self.denominator new_den = self.denominator * other.denominator return Fraction(new_num, new_den) def subtract(self, other: \\"Fraction\\") -> \\"Fraction\\": new_num = self.numerator * other.denominator - other.numerator * self.denominator new_den = self.denominator * other.denominator return Fraction(new_num, new_den) def multiply(self, other: \\"Fraction\\") -> \\"Fraction\\": new_num = self.numerator * other.numerator new_den = self.denominator * other.denominator return Fraction(new_num, new_den) def divide(self, other: \\"Fraction\\") -> \\"Fraction\\": new_num = self.numerator * other.denominator new_den = self.denominator * other.numerator return Fraction(new_num, new_den) # Example Usage: frac1 = Fraction(1, 2) frac2 = Fraction(3, 4) frac_sum = frac1.add(frac2) print(frac_sum.numerator, frac_sum.denominator) # Should print 5 4 frac_diff = frac1.subtract(frac2) print(frac_diff.numerator, frac_diff.denominator) # Should print -1 4 frac_prod = frac1.multiply(frac2) print(frac_prod.numerator, frac_prod.denominator) # Should print 3 8 frac_quot = frac1.divide(frac2) print(frac_quot.numerator, frac_quot.denominator) # Should print 2 3 ``` Note: This implementation of the `Fraction` class ensures that all resulting fractions are in their simplest form and the denominator is always positive.","solution":"from math import gcd class Fraction: def __init__(self, numerator: int, denominator: int): if denominator == 0: raise ValueError(\\"Denominator cannot be zero\\") self.numerator = numerator self.denominator = denominator self._simplify() def _simplify(self): common_divisor = gcd(self.numerator, self.denominator) self.numerator //= common_divisor self.denominator //= common_divisor if self.denominator < 0: # Keep denominator positive self.numerator = -self.numerator self.denominator = -self.denominator def add(self, other: \\"Fraction\\") -> \\"Fraction\\": new_num = self.numerator * other.denominator + other.numerator * self.denominator new_den = self.denominator * other.denominator return Fraction(new_num, new_den) def subtract(self, other: \\"Fraction\\") -> \\"Fraction\\": new_num = self.numerator * other.denominator - other.numerator * self.denominator new_den = self.denominator * other.denominator return Fraction(new_num, new_den) def multiply(self, other: \\"Fraction\\") -> \\"Fraction\\": new_num = self.numerator * other.numerator new_den = self.denominator * other.denominator return Fraction(new_num, new_den) def divide(self, other: \\"Fraction\\") -> \\"Fraction\\": new_num = self.numerator * other.denominator new_den = self.denominator * other.numerator if new_den == 0: raise ZeroDivisionError(\\"Cannot divide by a fraction with numerator zero\\") return Fraction(new_num, new_den)"},{"question":"# Coding Question: Generate Fibonacci Sequence Up to N-th Term Context: Bob is working on a project that requires generating a sequence of Fibonacci numbers. The Fibonacci sequence is defined as follows: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n > 1 Your task is to implement a function that returns a list containing the Fibonacci sequence up to the N-th term. Efficient computation and handling of large integers is crucial. Task: Write a function `generate_fibonacci_sequence(n: int) -> List[int]` that generates a list of the first `n` Fibonacci numbers. If the input `n` is not an integer or is negative, the function should raise a `TypeError`. Input and Output Format: * **Input**: A single non-negative integer `n`. * Constraints: * `0 <= n <= 10^5` (Ensure your function efficiently handles very large sequences.) * **Output**: A list of integers representing the Fibonacci sequence up to the N-th term. Example Cases: ```python >>> generate_fibonacci_sequence(5) [0, 1, 1, 2, 3, 5] >>> generate_fibonacci_sequence(0) [0] >>> generate_fibonacci_sequence(1) [0, 1] >>> generate_fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55] >>> generate_fibonacci_sequence(-1) Traceback (most recent call last): ... TypeError: Input value must be a non-negative \'int\' type ``` Constraints: * Ensure your function handles very large sequences efficiently. * Handle edge cases, including the smallest and largest values of `n`. Performance Requirements: * Your solution should run efficiently for input values up to (10^5). Good luck and ensure your code passes the provided example cases!","solution":"def generate_fibonacci_sequence(n: int): Generates a list containing the Fibonacci sequence up to the N-th term. Parameters: n (int): The number of terms in the Fibonacci sequence to generate. Returns: List[int]: A list containing the Fibonacci sequence up to the N-th term. Raises: TypeError: If the input `n` is not an integer or is negative. if not isinstance(n, int) or n < 0: raise TypeError(\\"Input value must be a non-negative \'int\' type\\") if n == 0: return [0] elif n == 1: return [0, 1] fib_sequence = [0, 1] for _ in range(2, n + 1): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence"},{"question":"# Problem Description You are tasked with creating a function that calculates the flight duration given a constant speed and the distance between the two cities. The function must validate that both parameters, speed and distance, are positive. If either parameter is non-positive, the function should raise a `ValueError`. # Function Signature ```python def flight_duration( speed: float, distance: float, ) -> float: pass ``` # Input * **speed** (float): A positive float number representing the speed of the flight in kilometers per hour (km/h). * **distance** (float): A positive float number representing the distance between the two cities in kilometers (km). # Output * **duration** (float): A floating-point number representing the flight duration in hours. # Constraints * Both input parameters must be positive float numbers. * If either parameter is non-positive, the function should raise a `ValueError`. # Examples ```python >>> flight_duration(600, 3000) 5.0 >>> flight_duration(750, 1500) 2.0 >>> flight_duration(900, 4500) 5.0 >>> flight_duration(0, 3000) Traceback (most recent call last): ... ValueError: Both parameters must be positive. >>> flight_duration(600, -1500) Traceback (most recent call last): ... ValueError: Both parameters must be positive. ``` # Note - Assume typical safe flight speeds and realistic distances for commercial flights. - Ensure to handle and test the provided edge cases correctly.","solution":"def flight_duration(speed: float, distance: float) -> float: Calculate flight duration given a constant speed and distance between two cities. Parameters: speed (float): Speed of the flight in kilometers per hour (km/h). Must be positive. distance (float): Distance between the two cities in kilometers (km). Must be positive. Returns: float: Duration of the flight in hours. Raises: ValueError: If either speed or distance is non-positive. # Validate the input parameters if speed <= 0 or distance <= 0: raise ValueError(\\"Both parameters must be positive.\\") # Calculate the duration of the flight duration = distance / speed return duration"},{"question":"# Problem Statement: You are tasked with developing a function that analyzes rainfall data over a period of time and determines the longest contiguous sequence of days with non-decreasing rainfall. The function should take a list of integers representing the amount of rainfall (in millimeters) for each day and return the length of the longest contiguous sequence where each day\'s rainfall is greater than or equal to the previous day\'s rainfall. Function Signature: ```python def longest_non_decreasing_rainfall(rainfall_data: list[int]) -> int: pass ``` # Requirements: - Implement the `longest_non_decreasing_rainfall` function. - The input list will contain non-negative integers. - Handle edge cases such as an empty list, which should return 0. - Ensure the function is efficient in terms of time complexity. # Example Usage: ```python >>> longest_non_decreasing_rainfall([1, 2, 2, 1, 2, 3, 4, 1]) 4 >>> longest_non_decreasing_rainfall([5, 3, 2, 1]) 1 >>> longest_non_decreasing_rainfall([1, 3, 5, 7, 9, 2, 4, 6, 8]) 5 >>> longest_non_decreasing_rainfall([]) 0 ``` # Constraints: - The input list, `rainfall_data`, will have at most length 10^5. - Ensure the function handles large inputs efficiently. - The function should correctly identify and handle edge cases such as all values being the same or strictly decreasing sequences.","solution":"def longest_non_decreasing_rainfall(rainfall_data: list[int]) -> int: Determines the length of the longest contiguous sequence of days with non-decreasing rainfall. if not rainfall_data: return 0 max_length = 1 current_length = 1 for i in range(1, len(rainfall_data)): if rainfall_data[i] >= rainfall_data[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"# String Reversal Background In many programming tasks, it is common to need to manipulate and transform strings. One such transformation is reversing the order of characters in a string. This can be useful in various contexts, such as palindrome checking, data encryption, and formatting outputs. Task Write a function `reverse_string(s: str) -> str` that takes a string input and returns the string with the characters in reverse order. Input - `s`: A string, consisting of any printable ASCII characters, with a length of at least 1 and at most 10^5. Output - Returns a string that is the reverse of the input string. Constraints - The length of the string will always be between 1 and 10^5 inclusive. - The string will contain only printable ASCII characters. Example ```python >>> reverse_string(\\"hello\\") \\"olleh\\" >>> reverse_string(\\"12345\\") \\"54321\\" >>> reverse_string(\\"A man, a plan, a canal, Panama\\") \\"amanaP ,lanac a ,nalp a ,nam A\\" ``` Additional Notes - Ensure that your implementation is efficient and can handle the upper constraint of the input size. - Consider edge cases such as strings with special characters or spaces.","solution":"def reverse_string(s: str) -> str: Returns the reverse of the input string s. return s[::-1]"},{"question":"# Problem Statement You are expected to create a system to validate and analyze log entries for a web server\'s access log. The logs contain records of HTTP requests and their statuses, and your goal is to extract meaningful insights into the behavior of the server\'s traffic. # Requirements 1. Implement a function `analyze_server_logs(log_entries: List[str]) -> dict` that: - Processes a list of log entries where each entry is a string in the common log format. - Analyzes the entries to return a summary dictionary with the following information: - Total number of requests. - Number of successful requests (status codes 200-299). - Number of client errors (status codes 400-499). - Number of server errors (status codes 500-599). - The most requested URL. - The IP address with the most requests. # Input - `log_entries`: A list of strings where each string represents a log entry in the common log format, e.g.: ``` \'127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] \\"GET /apache_pb.gif HTTP/1.0\\" 200 2326\' ``` # Output - Returns a dictionary containing the analysis summary: ```python { \\"total_requests\\": int, \\"successful_requests\\": int, \\"client_errors\\": int, \\"server_errors\\": int, \\"most_requested_url\\": \\"value\\", \\"most_frequent_ip\\": \\"value\\" } ``` # Constraints - Logs are assumed to follow valid common log formats but may vary in content size. - Handle potential parsing issues robustly and ensure the function can process logs efficiently even with a large number of entries. # Example ```python log_entries = [ \'192.168.1.1 - - [01/Dec/2021:10:56:36 -0700] \\"GET /index.html HTTP/1.1\\" 200 612\', \'192.168.1.2 - - [01/Dec/2021:10:57:36 -0700] \\"POST /submit HTTP/1.1\\" 404 326\', \'192.168.1.1 - - [01/Dec/2021:10:58:36 -0700] \\"GET /index.html HTTP/1.1\\" 503 621\', ] result = analyze_server_logs(log_entries) print(result) # Expected Output # { # \\"total_requests\\": 3, # \\"successful_requests\\": 1, # \\"client_errors\\": 1, # \\"server_errors\\": 1, # \\"most_requested_url\\": \\"/index.html\\", # \\"most_frequent_ip\\": \\"192.168.1.1\\" # } ``` # Function Signature ```python def analyze_server_logs(log_entries: List[str]) -> dict: # Your implementation here pass ```","solution":"from collections import defaultdict from typing import List def analyze_server_logs(log_entries: List[str]) -> dict: url_count = defaultdict(int) ip_count = defaultdict(int) summary = { \\"total_requests\\": 0, \\"successful_requests\\": 0, \\"client_errors\\": 0, \\"server_errors\\": 0, \\"most_requested_url\\": None, \\"most_frequent_ip\\": None, } for entry in log_entries: try: parts = entry.split(\\" \\") ip = parts[0] url = parts[6] status = int(parts[8]) # Update overall statistics summary[\\"total_requests\\"] += 1 if 200 <= status < 300: summary[\\"successful_requests\\"] += 1 elif 400 <= status < 500: summary[\\"client_errors\\"] += 1 elif 500 <= status < 600: summary[\\"server_errors\\"] += 1 # Update URL and IP counts url_count[url] += 1 ip_count[ip] += 1 except Exception: continue # Skip invalid log entries # Determine the most requested URL and most frequent IP if url_count: summary[\\"most_requested_url\\"] = max(url_count, key=url_count.get) if ip_count: summary[\\"most_frequent_ip\\"] = max(ip_count, key=ip_count.get) return summary"},{"question":"# Efficient CSV Data Processing with Memory Constraints You are provided with a large CSV file containing sales data. Each row in the CSV file represents a transaction and includes the following columns: `date`, `store_id`, `product_id`, `quantity`, and `price`. Due to memory constraints, you need to process this file line by line and calculate the total sales amount for each store. Task Create a script that reads the CSV file line by line (without loading the entire file into memory) and calculates the total sales amount for each store. The sales amount for a transaction is given by `quantity * price`. Output the results as a dictionary where the keys are `store_id`s and the values are the total sales amounts. Function Signature ```python def calculate_sales(file_path: str) -> dict[int, float]: pass ``` Example ```python # Considering a CSV file \'sales_data.csv\' with the following content: # date,store_id,product_id,quantity,price # 2021-01-01,1,101,2,10.00 # 2021-01-02,1,102,1,20.00 # 2021-01-01,2,101,3,15.00 sales_totals = calculate_sales(\'sales_data.csv\') print(sales_totals) ``` Output: ```python { 1: 40.00, # Store 1: (2*10.00) + (1*20.00) 2: 45.00, # Store 2: (3*15.00) } ``` Constraints 1. Do not load the entire file into memory. 2. Handle numeric precision for sales amount correctly. 3. Handle any potential issues with reading large files efficiently. 4. The input CSV file is guaranteed to be well-formed. Evaluation Criteria 1. Correct handling of large file processing with limited memory. 2. Accurate calculation of total sales amounts for each store. 3. Time and space efficiency of the solution. 4. Code readability and adherence to best practices.","solution":"import csv from collections import defaultdict def calculate_sales(file_path: str) -> dict[int, float]: Reads a CSV file containing sales data and calculates the total sales amount for each store. :param file_path: Path to the CSV file. :return: Dictionary with store_id as keys and total sales amounts as values. sales_totals = defaultdict(float) with open(file_path, mode=\'r\') as file: reader = csv.DictReader(file) for row in reader: store_id = int(row[\'store_id\']) quantity = float(row[\'quantity\']) price = float(row[\'price\']) sales_amount = quantity * price sales_totals[store_id] += sales_amount return dict(sales_totals)"},{"question":"# Knapsack Problem - Maximum Value Problem Description Given a set of items, each with a weight and a value, and a knapsack with a maximum weight capacity, determine the maximum total value that can be accommodated in the knapsack. You can either select or exclude each item, and you cannot fraction the items. Function Signature Write a Python function `knapsack(max_weight: int, weights: List[int], values: List[int]) -> int` that takes three parameters: - `max_weight`: An integer representing the maximum weight the knapsack can carry. - `weights`: A list of integers where `weights[i]` is the weight of the `i-th` item. - `values`: A list of integers where `values[i]` is the value of the `i-th` item. Return The function should return: - An integer representing the maximum value that can be accommodated in the knapsack without exceeding the weight capacity. Constraints - The number of items `N` will be between 1 and 50. - The weight of each item will be between 1 and 100. - The value of each item will be between 1 and 100. - The maximum weight of the knapsack `W` will be between 1 and 1000. Example ```python def knapsack(max_weight: int, weights: List[int], values: List[int]) -> int: # Your code here # Example Test Cases weights1 = [10, 20, 30] values1 = [60, 100, 120] max_weight1 = 50 print(knapsack(max_weight1, weights1, values1)) # Output: 220 weights2 = [1, 2, 3, 8] values2 = [20, 30, 50, 60] max_weight2 = 5 print(knapsack(max_weight2, weights2, values2)) # Output: 80 ``` In these examples, the first set of items can produce a maximum value of 220 within the knapsack\'s weight capacity of 50, while the second set of items can produce a maximum value of 80 within the knapsack\'s weight capacity of 5. Requirements - Implement the `knapsack` function to solve the problem using dynamic programming. - Ensure optimal performance within the given constraints.","solution":"from typing import List def knapsack(max_weight: int, weights: List[int], values: List[int]) -> int: Returns the maximum value that can be accommodated in the knapsack without exceeding the weight capacity. n = len(weights) # dp[i][w] will be the maximum value that can be attained with weight <= w and using first i items dp = [[0 for _ in range(max_weight + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(max_weight + 1): if weights[i - 1] <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]) else: dp[i][w] = dp[i - 1][w] return dp[n][max_weight]"},{"question":"# Question Problem Statement: Write a function to calculate the area of a triangle given its three sides using Heron\'s Formula. Given the lengths of three sides of a triangle, write a Python function `triangle_area(a: float, b: float, c: float) -> float` that returns the area of the triangle. Heron\'s Formula states that: [ text{Area} = sqrt{s cdot (s - a) cdot (s - b) cdot (s - c)} ] where ( s ) is the semi-perimeter of the triangle, computed as: [ s = frac{a + b + c}{2} ] Requirements: * **Input Format**: - Three floats `a`, `b`, and `c`, representing the lengths of the sides of a triangle. * **Output Format**: - A single float, representing the area of the triangle. Example: ``` Input: 3.0, 4.0, 5.0 Output: 6.0 Input: 7.0, 8.0, 9.0 Output: 26.832815729997478 Input: 2.0, 2.0, 3.0 Output: 1.984313483298443 ``` Constraints: * 0 < `a`, `b`, `c` ≤ 1000 * The given sides must form a valid triangle according to the triangle inequality theorem (i.e., (a + b > c), (a + c > b), and (b + c > a)). Additional Notes: 1. You can use the `math` module for square root calculation. 2. Ensure your solution handles cases where the sides do not form a valid triangle by returning an appropriate message or value (e.g., `0.0`). Testing: 1. Test your implementation with known triangles: - ( a = 3, b = 4, c = 5 Rightarrow text{Area} = 6 ) 2. Ensure your solution can handle edge cases: - The smallest possible triangle - Sides that barely satisfy the triangle inequality theorem - Sides that do not form a valid triangle","solution":"import math def triangle_area(a: float, b: float, c: float) -> float: Calculate the area of a triangle given its three sides using Heron\'s Formula. Parameters: a (float): length of the first side b (float): length of the second side c (float): length of the third side Returns: float: area of the triangle, or 0.0 if sides do not form a valid triangle # Check if the sides form a valid triangle if a + b <= c or a + c <= b or b + c <= a: return 0.0 # Calculate the semi-perimeter s = (a + b + c) / 2 # Apply Heron\'s formula to calculate the area area = math.sqrt(s * (s - a) * (s - b) * (s - c)) return area"},{"question":"# Question: Implement Dijkstra\'s Algorithm for Shortest Path You are tasked with creating a routing system to find the shortest path between nodes in a weighted, directed graph. Your goal is to implement Dijkstra\'s algorithm to determine the shortest path from a given source node to all other nodes in the graph. # Requirements: 1. Your function should take a dictionary representing the graph, where keys are node labels and values are lists of tuples representing the adjacent nodes and edge weights. 2. Additionally, the function should take the starting node as an argument. 3. Your function should return a dictionary where keys are node labels and values are the shortest distance from the starting node to that node. # Input: - A dictionary `graph` representing the weighted, directed graph. The keys are node labels (strings), and the values are lists of tuples (adjacent_node_label, edge_weight) where `edge_weight` is a float or integer. - A string `start_node` representing the label of the starting node. # Output: - A dictionary where the keys are node labels, and values are the shortest distances from the `start_node` to the corresponding node. # Constraints: - The graph will not contain negative edge weights. - The graph will be connected, meaning there will be a path between the given start node and any other node. - The input graph will have at least one node. # Example: ```python def dijkstra(graph: dict[str, list[tuple[str, float]]], start_node: str) -> dict[str, float]: # Your implementation here pass # Example Usage graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'A\', 1), (\'C\', 2), (\'D\', 5)], \'C\': [(\'A\', 4), (\'B\', 2), (\'D\', 1)], \'D\': [(\'B\', 5), (\'C\', 1)] } print(dijkstra(graph, \'A\')) # Output: {\'A\': 0, \'B\': 1, \'C\': 3, \'D\': 4} ``` # Notes: - The output should be a dictionary where each key represents a node, and the value is the shortest distance from the start node. - Efficiently handle the data structures to ensure the function operates within reasonable time complexity. - Consider using a priority queue to manage the nodes for which shortest path calculations are ongoing. Implement the `dijkstra` function that matches the specified requirements and evaluate its performance.","solution":"import heapq def dijkstra(graph, start_node): Implements Dijkstra\'s algorithm to find the shortest path from the starting node to all other nodes in the graph. :param graph: Dictionary representing the graph where keys are node labels and values are lists of tuples (adjacent_node_label, edge_weight) :param start_node: The starting node from which to compute shortest paths :return: Dictionary where keys are node labels and values are the shortest distances from the start node # Initialize the distance dictionary with infinity for all nodes except the start node distances = {node: float(\'inf\') for node in graph} distances[start_node] = 0 # Priority queue to hold nodes to explore priority_queue = [(0, start_node)] # Tuple of (distance, node) # Set to hold visited nodes visited = set() while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_node in visited: continue visited.add(current_node) for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"Text-Based Adventure Game Extension The goal of this coding task is to extend the functionality of an existing text-based adventure game engine. The current implementation supports basic player movement, room descriptions, and simple inventory management. We aim to enhance the game with new interactive capabilities and more dynamic game mechanics. # Task 1. **Implement Enemy Interactions**: Add a feature that introduces non-player characters (NPCs) in the form of enemies that the player can encounter. Define basic enemy behaviors such as moving between rooms, attacking, and being defeated by the player. 2. **Enhanced Inventory System**: Extend the inventory system to include equipment with different attributes (e.g., weapons, armor). Implement an `equip` command to allow players to equip and unequip items, affecting their combat capabilities. 3. **Room-Based Traps**: Introduce traps in certain rooms. These traps should have a chance to be triggered when the player enters the room, causing damage, or requiring a skill check to disarm. # Input and Output - **Input**: Text commands from the player (e.g., \\"north\\", \\"attack goblin\\", \\"equip sword\\"). - **Output**: Console descriptions of the game state, interactions, and results of player actions (e.g., \\"You attack the goblin and deal 5 damage\\", \\"You equip the steel armor\\"). # Constraints - **NPC Movement**: Ensure enemies can move between rooms at regular intervals or based on specific triggers. - **Item Attributes**: Implement a range of item attributes (e.g., damage for weapons, defense for armor) and ensure they affect gameplay. - **Player Statistics**: Track and display player health, attack power, defense, and other relevant stats. - **Scalability**: Ensure the game engine can handle an increasing number of rooms, items, and NPCs without significant performance degradation. # Requirements - **Enemy Interactions**: Create classes for enemies and define their behaviors. - **Inventory Enhancement**: Update the inventory system to manage equippable items and their effects on the player. - **Trap Mechanics**: Add functions to define and handle traps within rooms. - **Output**: Provide clear and detailed text descriptions for all new interactions and commands. # Example ```python class AdventureGame: def __init__(self, rooms, items, enemies): self.rooms = rooms self.items = items self.enemies = enemies self.player = Player() def command(self, input_text): # Handle player commands (movement, interaction, inventory management) pass def update(self): # Update game state (enemy movement, trap triggers) pass adventure_game = AdventureGame(existing_rooms, existing_items, existing_enemies) while True: user_input = input(\\"> \\") adventure_game.command(user_input) adventure_game.update() adventure_game.display() ``` Your task is to extend the `AdventureGame` class or its existing structure to incorporate the new features. Ensure all added functionalities align seamlessly with the current game mechanics and enhance the overall gameplay experience.","solution":"import random class Player: def __init__(self): self.health = 100 self.attack_power = 10 self.defense = 5 self.inventory = [] self.equipped_items = {\'weapon\': None, \'armor\': None} def equip(self, item): if item in self.inventory: item_type = item[\'type\'] if item_type in [\'weapon\', \'armor\']: if self.equipped_items[item_type]: self.unequip(item_type) self.equipped_items[item_type] = item self.inventory.remove(item) if item_type == \'weapon\': self.attack_power += item[\'damage\'] elif item_type == \'armor\': self.defense += item[\'defense\'] return f\\"{item[\'name\']} equipped.\\" return \\"Item not in inventory.\\" def unequip(self, item_type): if self.equipped_items[item_type]: item = self.equipped_items[item_type] if item_type == \'weapon\': self.attack_power -= item[\'damage\'] elif item_type == \'armor\': self.defense -= item[\'defense\'] self.inventory.append(item) self.equipped_items[item_type] = None return f\\"{item[\'name\']} unequipped.\\" return f\\"No {item_type} equipped.\\" def attack(self, enemy): damage = self.attack_power - enemy.defense if damage > 0: enemy.health -= damage return f\\"You attack {enemy.name} and deal {damage} damage!\\" def take_damage(self, amount): damage = amount - self.defense if damage > 0: self.health -= damage return f\\"You take {damage} damage!\\" class Enemy: def __init__(self, name, health, attack_power, defense): self.name = name self.health = health self.attack_power = attack_power self.defense = defense def attack(self, player): damage = self.attack_power - player.defense if damage > 0: player.health -= damage return f\\"{self.name} attacks you and deals {damage} damage!\\" def is_alive(self): return self.health > 0 class Trap: def __init__(self, name, damage, disarm_chance): self.name = name self.damage = damage self.disarm_chance = disarm_chance def trigger(self, player): if random.random() > self.disarm_chance: return player.take_damage(self.damage) return \\"Trap disarmed!\\" class Room: def __init__(self, description, enemies=None, traps=None): self.description = description self.enemies = enemies if enemies else [] self.traps = traps if traps else [] def enter(self, player): for trap in self.traps: print(trap.trigger(player)) def remove_enemy(self, enemy): self.enemies.remove(enemy) class AdventureGame: def __init__(self, rooms): self.rooms = rooms self.player = Player() self.current_room = None def start(self, start_room): self.current_room = self.rooms[start_room] print(self.current_room.description) self.current_room.enter(self.player) def command(self, input_text): if input_text.startswith(\\"equip \\"): item_name = input_text[len(\\"equip \\"):] items = [item for item in self.player.inventory if item[\'name\'] == item_name] if items: print(self.player.equip(items[0])) else: print(\\"Item not found in inventory.\\") elif input_text == \\"attack\\": if self.current_room.enemies: enemy = self.current_room.enemies[0] print(self.player.attack(enemy)) if not enemy.is_alive(): self.current_room.remove_enemy(enemy) print(f\\"{enemy.name} is defeated!\\") else: print(enemy.attack(self.player)) else: print(\\"No enemies to attack.\\") def display(self): print(f\\"Player Health: {self.player.health}\\") print(f\\"Player Attack Power: {self.player.attack_power}\\") print(f\\"Player Defense: {self.player.defense}\\") if self.current_room.enemies: for enemy in self.current_room.enemies: print(f\\"Enemy: {enemy.name}, Health: {enemy.health}\\") # Example setup rooms = { \\"start\\": Room(\\"You are in a dark room. There is a door to the north.\\", [Enemy(\\"Goblin\\", 30, 5, 2)], [Trap(\\"Pitfall\\", 10, 0.5)]) } game = AdventureGame(rooms) game.start(\\"start\\")"},{"question":"# Question: Finding the Longest Subsequence with Alternating Even-Odd Property You need to write a Python function that finds the length of the longest subsequence from a list of integers such that the elements in the subsequence have the alternating even-odd property. This means each adjacent element in the subsequence must be alternating between even and odd. Function Signature ```python def longest_alternating_subsequence(arr: List[int]) -> int: This function takes a list of integers and returns the length of the longest subsequence with the alternating even-odd property. Parameters: arr (List[int]) - a list of integers in which the subsequence needs to be identified. Returns: int - the length of the longest subsequence with alternating even-odd property. ``` Parameters * **arr** (List[int]): A list of integers containing elements in which the subsequence needs to be identified. Constraints * 1 ≤ len(arr) ≤ 10,000 * -10^5 ≤ arr[i] ≤ 10^5 for all 0 ≤ i < len(arr) Expected Output * The function should return an integer representing the length of the longest possible subsequence with alternating even and odd numbers. Example ```python print(longest_alternating_subsequence([1, 2, 3, 4, 5, 6])) # Should return 6 print(longest_alternating_subsequence([5, 10, 15, 20, 25])) # Should return 2 print(longest_alternating_subsequence([1, 3, 5, 7, 9])) # Should return 1 print(longest_alternating_subsequence([2, 3, 4, 5, 6, 7])) # Should return 6 ``` Additional Notes 1. In this context, a subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. 2. Remember to handle edge cases, such as when the list contains only even or only odd numbers. The function should return a valid subsequence length under all given constraints.","solution":"from typing import List def longest_alternating_subsequence(arr: List[int]) -> int: if len(arr) == 0: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if (arr[i-1] % 2 == 0 and arr[i] % 2 != 0) or (arr[i-1] % 2 != 0 and arr[i] % 2 == 0): current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"# Task Write a function `sort_alphanumeric_strings` that sorts a list of alphanumeric strings while taking into account both numerical and alphabetical order. # Scenarios Your function will be utilized in inventory systems where products have mixed alphanumeric codes, and accurate sorting is crucial. # Input - A list of strings, each of which consists of both letters and digits (e.g., \\"A12\\", \\"B3\\", \\"A1\\"). # Output - A list of the input strings sorted first by the alphabetical part and then by the numerical part in increasing order. # Constraints 1. All strings will have a consistent format where every string contains letters followed by numbers. 2. The length of the list can be up to 1000 strings. 3. The numerical parts will be non-negative integers and can be arbitrarily large. # Requirements - Implement a custom sorting logic to handle alphanumeric sorting efficiently. - Ensure the result list retains the mixed alphanumeric format and is sorted correctly. # Hints - Consider using regular expressions to separate the alphabetical and numeric parts. - Utilize a custom key in the sorting function to ensure proper comparison. # Example ```python def sort_alphanumeric_strings(strings: list[str]) -> list[str]: import re def custom_sort_key(s): match = re.match(r\\"([a-zA-Z]+)([0-9]+)\\", s) if match: return (match.group(1), int(match.group(2))) return (s, 0) return sorted(strings, key=custom_sort_key) # Example Test Cases: print(sort_alphanumeric_strings([\\"A12\\", \\"A2\\", \\"B3\\", \\"A1\\"])) # Expected output: [\\"A1\\", \\"A2\\", \\"A12\\", \\"B3\\"] print(sort_alphanumeric_strings([\\"C10\\", \\"C2\\", \\"B9\\", \\"B10\\"])) # Expected output: [\\"B9\\", \\"B10\\", \\"C2\\", \\"C10\\"] print(sort_alphanumeric_strings([\\"Z1\\", \\"Y2\\", \\"Z10\\", \\"X3\\"])) # Expected output: [\\"X3\\", \\"Y2\\", \\"Z1\\", \\"Z10\\"] print(sort_alphanumeric_strings([\\"M5\\", \\"M50\\", \\"M15\\", \\"M1\\"])) # Expected output: [\\"M1\\", \\"M5\\", \\"M15\\", \\"M50\\"] print(sort_alphanumeric_strings([\\"A99\\", \\"A9\\", \\"A100\\", \\"A2\\"]))# Expected output: [\\"A2\\", \\"A9\\", \\"A99\\", \\"A100\\"] ``` Note: The above examples assume mixed alphanumeric strings with no spaces or special characters.","solution":"def sort_alphanumeric_strings(strings): import re def custom_sort_key(s): match = re.match(r\\"([a-zA-Z]+)([0-9]+)\\", s) if match: return (match.group(1), int(match.group(2))) return (s, 0) return sorted(strings, key=custom_sort_key)"},{"question":"# Problem: Binary Tree Serialization and Deserialization Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Requirements: - Implement the serialization and deserialization functions: ```python class Codec: def serialize(self, root: TreeNode) -> str: pass def deserialize(self, data: str) -> TreeNode: pass ``` # Input Format - The `serialize` function will be provided with the root of a binary tree. - The `deserialize` function will be provided with a string representing the serialized form of a binary tree. # Output Format - The `serialize` function should return a string representing the serialized form of the binary tree. - The `deserialize` function should return the root of the reconstructed binary tree. # Constraints - The number of nodes in the tree is within the range `[0, 1000]`. - Each node\'s value is an integer within the range `[-1000, 1000]`. # Performance Requirements - You should ensure the functions are optimized for the given constraints and can handle the maximum input size efficiently. # Examples ```python # Example for testing # Define the binary tree as follows: # 1 # / # 2 3 # / # 4 5 # # Corresponding serialized string could be: \\"1,2,3,null,null,4,5\\" # Serialize and deserialize the tree codec = Codec() serialized_data = codec.serialize(root) print(serialized_data) # Output example: \\"1,2,3,null,null,4,5\\" reconstructed_root = codec.deserialize(serialized_data) # reconstructed_root should represent the original tree structure ``` This question requires demonstrating the ability to manipulate tree structures, apply principles of data serialization and deserialization, and ensure the designed algorithms are efficient and maintain the integrity of the tree structure.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Codec: def serialize(self, root: TreeNode) -> str: Encodes a tree to a single string. if not root: return \\"null\\" def helper(node): if not node: return \\"null\\" return f\\"{node.val},{helper(node.left)},{helper(node.right)}\\" return helper(root) def deserialize(self, data: str) -> TreeNode: Decodes your encoded data to tree. def helper(values): val = values.pop(0) if val == \\"null\\": return None node = TreeNode(int(val)) node.left = helper(values) node.right = helper(values) return node values = data.split(\',\') root = helper(values) return root"},{"question":"# Problem: Tic-Tac-Toe Winner Detection You have been asked to write a program to detect the winner in a game of Tic-Tac-Toe. The game board is represented as a list of lists where each element is either \\"X\\", \\"O\\", or an empty string indicating an unused spot. Write a function `detect_winner(board: List[List[str]]) -> Union[str, None]` that takes a 3x3 Tic-Tac-Toe board as input and returns the winner of the game. If there is no winner, the function should return `None`. 1. The function should return \\"X\\" if Player X has won the game. 2. The function should return \\"O\\" if Player O has won the game. 3. The function should return `None` if there is no winner or if the game is still ongoing. Function Signature ```python def detect_winner(board: List[List[str]]) -> Union[str, None]: pass ``` Example ```python # Example usage and expected results board1 = [ [\\"X\\", \\"O\\", \\"X\\"], [\\"O\\", \\"X\\", \\"O\\"], [\\"\\", \\"\\", \\"X\\"] ] print(detect_winner(board1)) # Output should be \'X\' board2 = [ [\\"O\\", \\"O\\", \\"O\\"], [\\"X\\", \\"X\\", \\"\\"], [\\"\\", \\"X\\", \\"X\\"] ] print(detect_winner(board2)) # Output should be \'O\' board3 = [ [\\"X\\", \\"O\\", \\"X\\"], [\\"O\\", \\"X\\", \\"O\\"], [\\"O\\", \\"X\\", \\"O\\"] ] print(detect_winner(board3)) # Output should be \'X\' board4 = [ [\\"X\\", \\"O\\", \\"X\\"], [\\"O\\", \\"\\", \\"O\\"], [\\"\\", \\"X\\", \\"O\\"] ] print(detect_winner(board4)) # Output should be \'O\' board5 = [ [\\"X\\", \\"O\\", \\"X\\"], [\\"O\\", \\"X\\", \\"O\\"], [\\"O\\", \\"\\", \\"X\\"] ] print(detect_winner(board5)) # Output should be None ``` Constraints * The `board` will always be a 3x3 list of lists containing either \\"X\\", \\"O\\", or an empty string. * Each list within the `board` will have exactly 3 elements.","solution":"from typing import List, Union def detect_winner(board: List[List[str]]) -> Union[str, None]: Detects the winner in a game of Tic-Tac-Toe. Returns \\"X\\" if Player X has won, \\"O\\" if Player O has won, or None if there is no winner. # Check rows for row in board: if row[0] != \\"\\" and row[0] == row[1] == row[2]: return row[0] # Check columns for col in range(3): if board[0][col] != \\"\\" and board[0][col] == board[1][col] == board[2][col]: return board[0][col] # Check diagonals if board[0][0] != \\"\\" and board[0][0] == board[1][1] == board[2][2]: return board[0][0] if board[0][2] != \\"\\" and board[0][2] == board[1][1] == board[2][0]: return board[0][2] return None"},{"question":"# Coding Challenge: Unique Character Finder Scenario You are tasked with improving a text-analysis tool that processes large files of written content. One of the features needed is a function that can identify the first non-repeating character in a string. Given the importance of performance and accuracy, it\'s essential to develop this function efficiently. Question Write a Python function that finds the first non-repeating character in a given string. Function Signature ```python def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in the string `s`. If there is no non-repeating character, return an empty string. ``` Input/Output * **Input Format**: A single string `s` containing n characters (1 <= n <= 10^5). * **Output Format**: A single character representing the first non-repeating character. If there is no non-repeating character, return an empty string. Constraints 1. The string `s` contains only lowercase English letters. 2. The function should be optimized for performance given that the input size can be large. Performance Requirement Ensure that your solution runs efficiently even for the maximum input size. Example ```python first_non_repeating_character(\\"swiss\\") # Expected output: \\"w\\" first_non_repeating_character(\\"relevel\\") # Expected output: \\"r\\" first_non_repeating_character(\\"aabbcc\\") # Expected output: \\"\\" ``` **Note**: No additional libraries should be used for handling the string. [End of question]","solution":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in the string `s`. If there is no non-repeating character, return an empty string. # Create a count dictionary to count occurrences of each character count = {} # First pass to count all characters for char in s: count[char] = count.get(char, 0) + 1 # Second pass to find the first non-repeating character for char in s: if count[char] == 1: return char # If no non-repeating character is found, return an empty string return \\"\\""},{"question":"String Transformation with Minimum Steps **Context** You are assigned to implement an algorithm that transforms a given string into a palindrome with the minimum number of character insertions. A palindrome is a string that reads the same backward as forward. **Problem Statement** Write a function `min_insertions_to_palindrome(s: str) -> int` that computes the minimum number of character insertions required to transform a given string into a palindrome. **Function Signature** ```python def min_insertions_to_palindrome(s: str) -> int: pass ``` **Input** - `s` (1 <= len(s) <= 1000): A string of lowercase English letters. **Output** - An integer representing the minimum number of character insertions required. **Example** ```python >>> min_insertions_to_palindrome(\\"abc\\") 2 >>> min_insertions_to_palindrome(\\"race\\") 3 >>> min_insertions_to_palindrome(\\"aabb\\") 2 ``` **Explanation** 1. In the first example, transforming \\"abc\\" into a palindrome can be done in 2 insertions: \\"abc\\" -> \\"abca\\" -> \\"abcba\\". 2. In the second example, transforming \\"race\\" into a palindrome can be done in 3 insertions: \\"race\\" -> \\"ecarace\\". 3. In the third example, transforming \\"aabb\\" into a palindrome can be done in 2 insertions: \\"aabb\\" -> \\"abba\\". **Constraints** - The implementation should be efficient with time complexity (O(n^2)). - The space complexity should not exceed (O(n^2)). **Edge Cases to Consider** 1. Single-character strings: Ensure the function correctly handles strings with just one character. 2. Already palindrome strings: Verify that the function returns zero for strings that are already palindromes. 3. Large string sizes: The function should perform efficiently for strings up to the maximum constraint.","solution":"def min_insertions_to_palindrome(s: str) -> int: Returns the minimum number of insertions required to transform the given string into a palindrome. n = len(s) # Create a dp array where dp[i][j] represents the minimum insertions needed # to make the substring s[i:j+1] a palindrome. dp = [[0] * n for _ in range(n)] # Fill the table for length in range(2, n + 1): # length of the substring for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1 return dp[0][n - 1]"},{"question":"# Coding Assessment Question Scenario You are developing an application for a logistics company to track its fleet of delivery trucks. Trucks move between various locations and record their positions periodically. Each truck\'s movement is represented as a series of position records, and for early analysis, we\'re focusing on 2-dimensional Cartesian coordinates (x, y). Objective Implement a function `longest_distance(truck_positions: Dict[str, List[Tuple[int, int]]]) -> Dict[str, float]` that calculates and returns the longest distance a truck traveled based on its recorded positions. # Description The goal is to determine the maximum straight-line distance between any two recorded positions for each truck in the fleet. # Requirements * You are given a dictionary where keys are truck IDs (strings) and values are lists of tuples representing the x and y coordinates of the truck\'s positions. # Input and Output * **Input**: * `truck_positions` (Dict[str, List[Tuple[int, int]]]): A dictionary with truck IDs and their recorded positions. * **Output**: * `Dict[str, float]`: A dictionary with each truck ID and its longest recorded distance. # Constraints * There will be at least one position record for each truck. * Coordinates are integers, and their absolute values do not exceed 1000. * The number of trucks does not exceed 100. * The number of position records for a single truck does not exceed 500. # Performance Requirements * Your solution should efficiently handle the distance calculations even with the maximum constraints. # Example * `truck_positions = { \\"truck_1\\": [(0, 0), (3, 4), (6, 8)], \\"truck_2\\": [(1, 1), (4, 5), (7, 9)] }` would return `{\\"truck_1\\": 10.0, \\"truck_2\\": 10.0}`. # Implementation Details Use the Euclidean distance formula to calculate distances between positions: [ d = sqrt{(x2 - x1)^2 + (y2 - y1)^2} ] ```python from math import sqrt from typing import List, Tuple, Dict def euclidean_distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float: return sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) def longest_distance(truck_positions: Dict[str, List[Tuple[int, int]]]) -> Dict[str, float]: max_distances = {} # Iterate through each truck and its positions for truck_id, positions in truck_positions.items(): max_distance = 0 # Compare every pair of recorded positions to calculate the distances for i in range(len(positions)): for j in range(i + 1, len(positions)): distance = euclidean_distance(positions[i], positions[j]) # Update the max distance for the current truck if distance > max_distance: max_distance = distance # Store the max distance for the truck max_distances[truck_id] = max_distance return max_distances # Test the solution with the given example truck_positions = { \\"truck_1\\": [(0, 0), (3, 4), (6, 8)], \\"truck_2\\": [(1, 1), (4, 5), (7, 9)] } print(longest_distance(truck_positions)) # Output: {\'truck_1\': 10.0, \'truck_2\': 10.0} ```","solution":"from math import sqrt from typing import List, Tuple, Dict def euclidean_distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float: return sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) def longest_distance(truck_positions: Dict[str, List[Tuple[int, int]]]) -> Dict[str, float]: max_distances = {} # Iterate through each truck and its positions for truck_id, positions in truck_positions.items(): max_distance = 0 # Compare every pair of recorded positions to calculate the distances for i in range(len(positions)): for j in range(i + 1, len(positions)): distance = euclidean_distance(positions[i], positions[j]) # Update the max distance for the current truck if distance > max_distance: max_distance = distance # Store the max distance for the truck max_distances[truck_id] = max_distance return max_distances"},{"question":"# Selective Knapsack Problem You need to implement a solution to the selective knapsack problem, where you aim to maximize the total value by selecting certain items within a given weight capacity while adhering to an additional constraint on the types of items being selected. # Problem You are given a list of items, each with a weight, value, and type. The task is to determine the optimal selection of items such that the total weight does not exceed a given limit, the total value is maximized, and the selection can include at most a specified number of distinct item types. # Function Signature ```python def selective_knapsack( items: list[tuple[int, int, int]], capacity: int, max_types: int ) -> list[int]: ``` # Input * `items` (`list[tuple[int, int, int]]`): A list where each tuple contains three integers representing the weight, value, and type of an item. * `capacity` (`int`): The maximum weight capacity of the knapsack. * `max_types` (`int`): The maximum number of different types of items that can be selected. # Output * Returns a list of integers representing the indices of the selected items that maximize the total value without exceeding the weight capacity and respecting the type constraint. # Constraints * `0 <= len(items) <= 100` * `1 <= capacity <= 1000` * `1 <= max_types <= len(set(item[2] for item in items))` * Each item’s weight, value, and type are non-negative integers. # Example ```python items = [ (2, 3, 1), (3, 4, 2), (4, 5, 3), (5, 8, 1), (6, 9, 2) ] capacity = 10 max_types = 2 selected_items = selective_knapsack(items, capacity, max_types) print(selected_items) # Output could be [0, 1, 3] or another valid selection ``` # Notes 1. Optimize the selection such that the total value is maximized. 2. Ensure that the total weight does not exceed the knapsack capacity. 3. The selection should include items from at most the specified number of distinct types. 4. In case of ties in maximum value, any correct selection is acceptable. # Constraints * `0 <= items[i][0] <= capacity` * `0 <= items[i][1] <= 1000` * `0 <= items[i][2] <= len(items)` This question tests your ability to solve dynamic programming problems with additional type-based constraints and ensures you understand how to balance weight, value, and type restrictions effectively.","solution":"def selective_knapsack(items, capacity, max_types): from functools import lru_cache @lru_cache(None) def knap(index, remaining_capacity, selected_types): if index == len(items): return 0, [] # Case 1: Skip the current item value_1, indices_1 = knap(index + 1, remaining_capacity, selected_types) # Case 2: Include the current item if it\'s possible weight, value, ty = items[index] if weight <= remaining_capacity and (ty in selected_types or len(selected_types) < max_types): if ty in selected_types: value_2, indices_2 = knap(index + 1, remaining_capacity - weight, selected_types) else: value_2, indices_2 = knap(index + 1, remaining_capacity - weight, selected_types + (ty,)) value_2 += value indices_2 = indices_2 + [index] else: value_2, indices_2 = 0, [] # Choose the better option if value_1 > value_2 or (value_1 == value_2 and len(indices_1) < len(indices_2)): return value_1, indices_1 else: return value_2, indices_2 _, result_indices = knap(0, capacity, ()) return result_indices"},{"question":"# 2D Image Transformation **Scenario**: You are working on a simple image processing application that performs basic operations on 2D grayscale images represented as matrices. Each element in the matrix represents the pixel intensity (0-255), where 0 is black, and 255 is white. One of the operations you need to implement is image rotation. **Requirements**: 1. Write a function `rotate_image_90_clockwise(image: List[List[int]]) -> List[List[int]]` that takes a 2D matrix representing a grayscale image and returns a new matrix that is the result of rotating the original image 90 degrees clockwise. 2. Write a function `rotate_image_90_counterclockwise(image: List[List[int]]) -> List[List[int]]` that takes a 2D matrix representing a grayscale image and returns a new matrix that is the result of rotating the original image 90 degrees counterclockwise. **Function Signatures**: ```python def rotate_image_90_clockwise(image: List[List[int]]) -> List[List[int]]: pass def rotate_image_90_counterclockwise(image: List[List[int]]) -> List[List[int]]: pass ``` **Input/Output**: * `rotate_image_90_clockwise`: * **Input**: * A 2D list `image` (a matrix where each sub-list represents a row in a grayscale image). * **Output**: * A new 2D list representing the image rotated 90 degrees clockwise. * `rotate_image_90_counterclockwise`: * **Input**: * A 2D list `image` (a matrix where each sub-list represents a row in a grayscale image). * **Output**: * A new 2D list representing the image rotated 90 degrees counterclockwise. **Constraints**: * The input list will contain integers between 0 and 255 (inclusive). * The input list will be non-empty and all sub-lists will have the same length. * Do not use any external libraries other than built-in ones. * Ensure the functions handle edge cases and raise appropriate errors if the input format is invalid. **Example**: ```python >>> rotate_image_90_clockwise([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_image_90_counterclockwise([[1, 2], [3, 4]]) [[2, 4], [1, 3]] >>> rotate_image_90_clockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_image_90_counterclockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[3, 6, 9], [2, 5, 8], [1, 4, 7]] ``` # Additional Notes: Your solution will be evaluated on correctness, efficiency, and adherence to best coding practices. Ensure to write clean and readable code with appropriate comments, and handle edge cases effectively.","solution":"from typing import List def rotate_image_90_clockwise(image: List[List[int]]) -> List[List[int]]: Rotates the given 2D image 90 degrees clockwise. if not image or not image[0]: return image rows = len(image) cols = len(image[0]) rotated = [[0] * rows for _ in range(cols)] for r in range(rows): for c in range(cols): rotated[c][rows - 1 - r] = image[r][c] return rotated def rotate_image_90_counterclockwise(image: List[List[int]]) -> List[List[int]]: Rotates the given 2D image 90 degrees counterclockwise. if not image or not image[0]: return image rows = len(image) cols = len(image[0]) rotated = [[0] * rows for _ in range(cols)] for r in range(rows): for c in range(cols): rotated[cols - 1 - c][r] = image[r][c] return rotated"},{"question":"# Balanced Binary Tree Check **Context**: You are tasked with ensuring the reliability of a software system by verifying the integrity of its data structures. Specifically, you need to check if a given binary tree is height-balanced. A binary tree is considered height-balanced if the depths of the two subtrees of every node never differ by more than 1. **Requirements**: 1. Implement the `is_balanced` function to determine if the tree is balanced. 2. Ensure the function is efficient in both time and space complexity. **Function Signature**: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: pass ``` **Input**: - `root`: A `TreeNode` object representing the root of the binary tree. **Output**: - Returns `True` if the binary tree is height-balanced, otherwise `False`. **Constraints**: - The number of nodes in the tree will not exceed 10^4. - The tree structure can be varied, and nodes will contain integer values. **Examples**: ```python # Example 1 # Input: [3,9,20,None,None,15,7] # 3 # / # 9 20 # / # 15 7 # Output: True root1 = TreeNode(3) root1.left = TreeNode(9) root1.right = TreeNode(20, TreeNode(15), TreeNode(7)) assert is_balanced(root1) == True # Example 2 # Input: [1,2,2,3,3,None,None,4,4] # 1 # / # 2 2 # / # 3 3 # / # 4 4 # Output: False root2 = TreeNode(1) root2.left = TreeNode(2, TreeNode(3, TreeNode(4), TreeNode(4)), TreeNode(3)) root2.right = TreeNode(2) assert is_balanced(root2) == False # Example 3 # Input: [] # Output: True assert is_balanced(None) == True ``` **Performance Note**: Your function should ideally perform in O(n) time complexity, where n is the number of nodes in the tree. **Hints**: 1. Consider a recursive divide and conquer approach to compute the height of subtrees. 2. Use a helper function to simultaneously compute tree height and balance status.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: def check_balance_and_height(node): if not node: return (True, 0) left_balanced, left_height = check_balance_and_height(node.left) right_balanced, right_height = check_balance_and_height(node.right) if not left_balanced or not right_balanced: return (False, 0) if abs(left_height - right_height) > 1: return (False, 0) return (True, 1 + max(left_height, right_height)) balanced, _ = check_balance_and_height(root) return balanced"},{"question":"# Longest Increasing Subsequence You are developing a feature that helps users analyze their daily step counts over a period of time. One of the metrics that users are interested in is the longest sequence of days where their step counts have been consistently increasing. Your task is to implement a function that finds the longest increasing subsequence among a given list of daily step counts. Function Signature ```python def longest_increasing_subsequence(step_counts: List[int]) -> int: This function computes the length of the longest increasing subsequence in the list of step counts. :param step_counts: List of integers where each integer represents the step count for a day. :return: Integer value representing the length of the longest increasing subsequence. ``` Input 1. **step_counts**: A list of integers representing the step counts for consecutive days. Output * An integer that represents the length of the longest increasing subsequence of step counts. If no such subsequence exists, return 0. Constraints * 1 <= len(step_counts) <= 10^4 * 1 <= step_counts[i] <= 10^6 Example ```python # Example step counts daily_steps = [5, 3, 4, 8, 6, 7] assert longest_increasing_subsequence(daily_steps) == 4 # The sequence [3, 4, 6, 7] assert longest_increasing_subsequence([1, 2, 3, 4, 5]) == 5 # The sequence [1, 2, 3, 4, 5] assert longest_increasing_subsequence([5, 4, 3, 2, 1]) == 1 # The sequence [5] (or any single element) assert longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6 # The sequence [10, 22, 33, 50, 60, 80] ``` Notes * Consider dynamic programming for this algorithm to ensure an efficient solution. * Aim for an O(n log n) solution, though an O(n^2) solution may be acceptable for smaller inputs. * Ensure your solution handles edge cases, such as the input list having only one element.","solution":"from typing import List def longest_increasing_subsequence(step_counts: List[int]) -> int: This function computes the length of the longest increasing subsequence in the list of step counts. :param step_counts: List of integers where each integer represents the step count for a day. :return: Integer value representing the length of the longest increasing subsequence. if not step_counts: return 0 n = len(step_counts) dp = [1] * n for i in range(1, n): for j in range(i): if step_counts[i] > step_counts[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"# Problem Statement You are enlisted to assist in a traffic simulation project by creating a function that calculates the average speed of a vehicle over a series of checkpoints. Each checkpoint is defined by a distance from the start and a timestamp. You will use this data to compute the overall average speed. Function Signature ```python def average_speed(checkpoints: list) -> float: Calculate the average speed of a vehicle given its checkpoints. Checkpoints is a list of tuples, where each tuple contains: - the distance from the start (float) in kilometers - the timestamp in seconds (float) >>> average_speed([(0, 0), (50, 3600), (100, 7200)]) 50.0 >>> average_speed([(0, 0), (120, 7200)]) 60.0 >>> average_speed([(0, 0), (0, 0)]) 0.0 pass ``` # Input - `checkpoints (list of tuples)`: Each tuple contains two float values - distance (in kilometers) from the start and timestamp (in seconds). # Output - `float`: The average speed of the vehicle in km/h. # Constraints - The number of checkpoints will be at least 2. - All distances are non-negative and non-decreasing. - All timestamps are non-negative and increasing. # Requirements 1. **Validity**: Ensure the function accurately calculates the average speed based on the provided checkpoints. 2. **Efficiency**: Given that the series of checkpoints will not exceed reasonable limits (e.g., 10,000), ensure the function processes efficiently. 3. **Error Handling**: Handle edge cases, such as when two consecutive checkpoints have the same distance and time, by returning an average speed of 0. # Example ```python assert average_speed([(0, 0), (50, 3600), (100, 7200)]) == 50.0 assert average_speed([(0, 0), (120, 7200)]) == 60.0 assert average_speed([(0, 0), (0, 0)]) == 0.0 ``` Notes To calculate the average speed: 1. Determine the total distance and total time: [ text{total_distance} = text{distance_at_last_checkpoint} ] [ text{total_time} = text{time_at_last_checkpoint} ] 2. Use the formula: [ text{average_speed} = frac{text{total_distance}}{text{total_time} / 3600} ] where the time is converted from seconds to hours. Implement the function to handle both typical and edge cases as per the provided examples.","solution":"def average_speed(checkpoints): Calculate the average speed of a vehicle given its checkpoints. Checkpoints is a list of tuples, where each tuple contains: - the distance from the start (float) in kilometers - the timestamp in seconds (float) Returns the average speed in km/h. if len(checkpoints) < 2: raise ValueError(\\"There must be at least two checkpoints to calculate the average speed\\") # Get the first and last checkpoint first_distance, first_time = checkpoints[0] last_distance, last_time = checkpoints[-1] total_distance = last_distance - first_distance total_time_hours = (last_time - first_time) / 3600 if total_time_hours == 0: return 0.0 average_speed_kmh = total_distance / total_time_hours return average_speed_kmh"},{"question":"# Problem Statement You are required to implement a function named `detect_anagrams` that identifies anagrams from a given list of strings. An anagram is a word or phrase formed by rearranging the letters of another, typically using all the original letters exactly once. # Function Signature ```python def detect_anagrams(words: list) -> list: Detect groups of anagrams in the provided list of words. Parameters: words (list): A list of strings where each element is a word. Returns: list: A list of lists, where each sublist contains words that are anagrams of each other. pass ``` # Input * `words` is a list of strings where each string is a word. # Output The function returns a list of lists: * Each sublist contains words that are identified as anagrams of each other. * The sublists should not contain duplicates, and each word in the input list should appear in exactly one sublist. * The order of sublists and the order of words within each sublist does not matter. # Constraints * Each word in the input list will contain lowercase alphabetical characters only. * The number of words in the list will not exceed 10^4. * The length of each word will not exceed 100 characters. # Examples ```python assert detect_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"hello\\", \\"helo\\"]) == [[\\"listen\\", \\"silent\\", \\"enlist\\"], [\\"hello\\"], [\\"helo\\"]] assert detect_anagrams([\\"rat\\", \\"tar\\", \\"art\\", \\"star\\", \\"tars\\", \\"cheese\\"]) == [[\\"rat\\", \\"tar\\", \\"art\\"], [\\"star\\", \\"tars\\"], [\\"cheese\\"]] ``` # Scenarios 1. **Basic Functionality**: Identify all groups of anagrams in the provided list of words. 2. **Single Word**: Handle cases where there is only one word in the list. 3. **Duplicate Words**: Ensure no duplicate words exist in the result. 4. **Performance**: Efficiently process lists with a large number of words. # Implementation Hints - Consider using sorting or a hash map for an efficient comparison of anagrams. - Ensure the solution accommodates large lists and long strings by optimizing data structures and algorithms used.","solution":"def detect_anagrams(words: list) -> list: Detect groups of anagrams in the provided list of words. Parameters: words (list): A list of strings where each element is a word. Returns: list: A list of lists, where each sublist contains words that are anagrams of each other. from collections import defaultdict anagrams = defaultdict(list) for word in words: # Sort the characters of the word to create a key key = \'\'.join(sorted(word)) anagrams[key].append(word) # Convert dictionary values to list of lists return list(anagrams.values())"},{"question":"# Number Factorization Function Context Factorization is a fundamental concept in mathematics where an integer is represented as a product of smaller integers. This concept is particularly important in fields such as cryptography, number theory, and algorithm design. Given a number, we need a function that returns its prime factors. Problem Statement Create a function `factorize_number` which takes a positive integer as input and returns the list of its prime factors. Function Signature ```python def factorize_number( n: int ) -> list[int]: ``` Input - `n`: (int) A positive integer greater than 1. Output - Returns a list containing the prime factors of `n` in ascending order. Constraints - The input number `n` will be an integer greater than 1. Examples ```python >>> factorize_number(28) [2, 2, 7] >>> factorize_number(52) [2, 2, 13] >>> factorize_number(97) [97] >>> factorize_number(100) [2, 2, 5, 5] ``` Explanation: 1. **Prime Factorization**: The function should identify and return all prime factors of the input number in a list. 2. **Handling Inputs**: The function should only accept integers greater than 1. 3. **Output Order**: The prime factors should be returned in ascending order. Implementing this function involves determining the smallest prime factor iteratively and dividing the number until it is reduced to 1. This approach ensures that all factors are prime and the list is sorted in ascending order.","solution":"def factorize_number(n: int) -> list[int]: Returns the prime factors of the given positive integer n in ascending order. factors = [] divisor = 2 while n >= divisor: if n % divisor == 0: factors.append(divisor) n //= divisor else: divisor += 1 return factors"},{"question":"# Problem: Implement a Basic Matrix Transpose Function You are tasked with writing a function to transpose a given matrix. The transpose of a matrix is obtained by swapping its rows with its columns. Write a function `transpose_matrix(matrix: List[List[int]]) -> List[List[int]]` that takes a 2D list of integers representing the matrix, and returns its transpose. Function Signature ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: pass ``` Input * `matrix` (List[List[int]]): A 2D list (list of lists) where each sub-list represents a row of the matrix. Output * Returns a new 2D list representing the transposed matrix. Example ```python matrix_1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(transpose_matrix(matrix_1)) # Output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] matrix_2 = [ [1, 2], [3, 4], [5, 6] ] print(transpose_matrix(matrix_2)) # Output: # [ # [1, 3, 5], # [2, 4, 6] # ] matrix_3 = [ [1] ] print(transpose_matrix(matrix_3)) # Output: # [ # [1] # ] ``` Constraints * The input matrix will contain only integers. * The matrix will not be empty and will have at least one row and one column. * The dimensions of the matrix will not exceed 100x100.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Returns the transpose of the given matrix. Args: matrix (List[List[int]]): A 2D list where each sub-list represents a row of the matrix. Returns: List[List[int]]: The transposed matrix. return [list(row) for row in zip(*matrix)]"},{"question":"# Intermediate Problem: Array Manipulation with Prefix Sum Scenario You are given a task to optimize a set of range update operations on an array. The challenge is to efficiently perform a sequence of range increment operations and finally return the maximum value in the array after all operations have been applied. To achieve this, you decide to use a prefix sum array for efficient range updates. Requirements * **Function Signature**: Implement the function `maxValueInArray(n: int, queries: List[Tuple[int, int, int]]) -> int`. * **Input**: - `n` (int): The size of the array (1-indexed). - `queries` (List[Tuple[int, int, int]]): A list of tuples, where each tuple represents a range increment operation `(start, end, increment)`. * **Output**: - Return the maximum value in the array after all the range increment operations. Constraints 1. `1 <= n <= 10^7` 2. `1 <= len(queries) <= 2 * 10^5` 3. Each tuple in `queries` contains three integers `(start, end, increment)`: - `1 <= start <= end <= n` - `1 <= increment <= 10^9` Performance Requirements - Your solution should efficiently handle the input size, aiming for a time complexity of O(n + q), where `q` is the number of queries. Example ```python def maxValueInArray(n: int, queries: List[Tuple[int, int, int]]) -> int: # Implement the function # Example usage: n = 5 queries = [(1, 2, 100), (2, 5, 100), (3, 4, 100)] # Expected output: 200 print(maxValueInArray(n, queries)) ``` Remember to handle edge cases, optimize for performance, and ensure your code is robust and well-documented.","solution":"from typing import List, Tuple def maxValueInArray(n: int, queries: List[Tuple[int, int, int]]) -> int: This function returns the maximum value in an array after applying a series of range increment operations. :param n: Size of the array (1-indexed) :param queries: List of tuples representing range increment operations (start, end, increment) :return: Maximum value in the array after applying all operations # Initialize an array of zeros with an additional slot for easier 1-indexed handling arr = [0] * (n + 1) # Apply the range increment using the prefix sum logic for (start, end, increment) in queries: arr[start - 1] += increment if end < n: arr[end] -= increment # Find the maximum value using the prefix sum array max_value = 0 current_value = 0 for val in arr: current_value += val if current_value > max_value: max_value = current_value return max_value"},{"question":"# Coding Assessment Question: Matrix Transposition **Background**: In linear algebra, the transpose of a matrix is an operation that flips the matrix over its diagonal, switching the row and column indices of each element. This is a common operation used in various fields such as computer graphics, statistical analysis, and machine learning. **Function Description**: Write a function `transpose_matrix(matrix: List[List[int]]) -> List[List[int]]` that takes a 2D list representing a matrix and returns its transpose. Input: * `matrix`: a list of lists where each sublist represents a row of the matrix and contains integers (`1 ≤ len(matrix), len(matrix[0]) ≤ 1000`). Output: * A list of lists representing the transposed matrix. Constraints: * Ensure the function handles edge cases where matrix dimensions are 1xN or Nx1. * The function should handle correctly irregular matrices where the inner lists (rows) might each have a different number of elements. Example: ```python matrix_1 = [ [1, 2, 3], [4, 5, 6] ] assert transpose_matrix(matrix_1) == [ [3, 6], [2, 5], [1, 4] ] matrix_2 = [ [1, 4], [2, 5], [3, 6] ] assert transpose_matrix(matrix_2) == [ [1, 2, 3], [4, 5, 6] ] matrix_3 = [ [1] ] assert transpose_matrix(matrix_3) == [ [1] ] ``` Additional Context: 1. Transposing a matrix is useful for matrix multiplication and solving system of linear equations. 2. In data science, transposing a DataFrame (matrix of data) can be useful for switching between \\"long\\" and \\"wide\\" formats. The resulting function should preserve element-to-element correspondence and handle possible edge cases efficiently.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Transposes a given 2D matrix. Args: matrix (List[List[int]]): The matrix to be transposed. Returns: List[List[int]]: The transposed matrix. return [list(row) for row in zip(*matrix)]"},{"question":"# Problem Statement You have been asked to process a list of dictionaries that represent individuals\' records and calculate the following two specific metrics: the average age and a list of full names. The records can be assumed to have consistent keys. 1. **Calculate the Average Age**: Write a function named `average_age` that takes a list of dictionaries as input. Each dictionary contains the key `age` representing the individual’s age (an integer). The function should return a float representing the average age of all individuals. If the input list is empty or any dictionary does not contain the `age` key, your function should raise a `ValueError`. 2. **Generate a List of Full Names**: Write a function named `full_names` that takes a list of dictionaries as input. Each dictionary contains the keys `first_name` and `last_name`, both representing strings. The function should return a list of strings where each string is the full name (i.e., \'first_name last_name\') of an individual. If any dictionary does not contain `first_name` or `last_name`, your function should raise a `ValueError`. # Requirements * Implement the functions as per the provided function prototypes: ```python def average_age(records: list) -> float: # Your code here def full_names(records: list) -> list: # Your code here ``` * **Input Constraints**: * `records` is a list of dictionaries where each dictionary contains the keys `age`, `first_name`, and `last_name`. * Each `age` value is a non-negative integer. * Each `first_name` and `last_name` value is a non-empty string. * A valid input `records` list consists of at least one dictionary. # Examples The `average_age` function should work as follows: * `average_age([{\\"first_name\\": \\"John\\", \\"last_name\\": \\"Doe\\", \\"age\\": 30}, {\\"first_name\\": \\"Jane\\", \\"last_name\\": \\"Doe\\", \\"age\\": 25}])` should return `27.5`. * `average_age([{\\"first_name\\": \\"Alice\\", \\"last_name\\": \\"Smith\\", \\"age\\": 40}])` should return `40.0`. * `average_age([])` should raise a `ValueError`. The `full_names` function should work as follows: * `full_names([{\\"first_name\\": \\"John\\", \\"last_name\\": \\"Doe\\", \\"age\\": 30}, {\\"first_name\\": \\"Jane\\", \\"last_name\\": \\"Doe\\", \\"age\\": 25}])` should return `[\\"John Doe\\", \\"Jane Doe\\"]`. * `full_names([{\\"first_name\\": \\"Alice\\", \\"last_name\\": \\"Smith\\", \\"age\\": 40}])` should return `[\\"Alice Smith\\"]`. * `full_names([{\\"first_name\\": \\"John\\", \\"age\\": 30}])` should raise a `ValueError`. # Notes: * Ensure that your code is efficient and handles edge cases effectively. * Make sure to use appropriate error handling to manage invalid inputs.","solution":"def average_age(records): Calculate the average age from a list of dictionaries containing ages. :param records: List[Dict] where each dictionary contains an \'age\' key. :return: float representing the average age. :raises: ValueError if the list is empty or any dictionary does not contain an \'age\' key. if not records: raise ValueError(\\"The records list is empty.\\") total_age = 0 count = 0 for record in records: if \'age\' not in record: raise ValueError(\\"A record is missing the \'age\' key.\\") total_age += record[\'age\'] count += 1 return total_age / count if count else 0 def full_names(records): Generate a list of full names from a list of dictionaries containing first and last names. :param records: List[Dict] where each dictionary contains \'first_name\' and \'last_name\' keys. :return: List of strings representing the full names. :raises: ValueError if any dictionary does not contain \'first_name\' or \'last_name\' key. names = [] for record in records: if \'first_name\' not in record or \'last_name\' not in record: raise ValueError(\\"A record is missing the \'first_name\' or \'last_name\' key.\\") names.append(f\\"{record[\'first_name\']} {record[\'last_name\']}\\") return names"},{"question":"# Question: Implement the Ford-Fulkerson Algorithm using BFS for Maximum Flow **Background:** The Ford-Fulkerson algorithm is a method for computing the maximum flow in a flow network. This algorithm uses the concept of augmenting paths to increase the flow until we reach the maximum possible flow. **Task:** Implement the Ford-Fulkerson Algorithm in Python using Breadth-First Search (BFS) to find augmenting paths. Your implementation should optimize the search process with BFS to ensure the shortest augmenting path is selected each time. **Function Signature:** ```python class FlowNetwork: def __init__(self, num_of_nodes: int) -> None: # Initialization function def add_edge(self, u_node: int, v_node: int, capacity: int) -> None: # Adds a directed edge to the flow network with the provided capacity def bfs(self, source: int, sink: int) -> bool: # Uses BFS to find an augmenting path from source to sink def ford_fulkerson(self, source: int, sink: int) -> int: # Executes the Ford-Fulkerson Algorithm and returns the maximum flow ``` **Expected Input and Output Formats:** - `__init__: FlowNetwork(n)`: initializes a flow network with `n` nodes. - `add_edge(u_node: int, v_node: int, capacity: int)`: adds a directed edge from `u_node` to `v_node` with the given capacity. - `bfs(source: int, sink: int) -> bool`: returns `True` if an augmenting path is found from `source` to `sink`, `False` otherwise. - `ford_fulkerson(source: int, sink: int) -> int`: executes the Ford-Fulkerson Algorithm and returns the total maximum flow from `source` to `sink`. **Constraints:** 1. All capacities will be non-negative integers. 2. The flow network should handle both sparse and dense connections efficiently. 3. The number of nodes `n` will be between 2 and 1000. 4. The number of edges `m` will be between 1 and 10000. **Performance Requirements:** The solution should handle flow networks up to the given limits efficiently, leveraging BFS for finding augmenting paths in O(V * E^2) complexity for the Ford-Fulkerson method. **Example:** ```python fn = FlowNetwork(6) for u, v, cap in [(0, 1, 16), (0, 2, 13), (1, 2, 10), (2, 1, 4), (1, 3, 12), (3, 2, 9), (2, 4, 14), (4, 3, 7), (3, 5, 20), (4, 5, 4)]: fn.add_edge(u, v, cap) max_flow = fn.ford_fulkerson(0, 5) print(max_flow) # Expected output: 23 ``` Implement the missing methods in the `FlowNetwork` class to complete the Ford-Fulkerson Algorithm with BFS for path finding and ensure it calculates the maximum flow from the source to the sink accurately.","solution":"from collections import defaultdict, deque class FlowNetwork: def __init__(self, num_of_nodes: int) -> None: self.num_of_nodes = num_of_nodes self.graph = defaultdict(dict) self.residual_graph = defaultdict(dict) def add_edge(self, u_node: int, v_node: int, capacity: int) -> None: self.graph[u_node][v_node] = capacity self.residual_graph[u_node][v_node] = capacity self.residual_graph[v_node][u_node] = 0 def bfs(self, source: int, sink: int, parent: dict) -> bool: visited = [False] * self.num_of_nodes queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v, capacity in self.residual_graph[u].items(): if not visited[v] and capacity > 0: queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def ford_fulkerson(self, source: int, sink: int) -> int: parent = [-1] * self.num_of_nodes max_flow = 0 while self.bfs(source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, self.residual_graph[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] self.residual_graph[u][v] -= path_flow self.residual_graph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Problem Statement Implement a function `is_duplicate_within_k` that checks whether there are any duplicate elements within distance `k` in a given list. This problem is commonly encountered in areas such as detecting duplicate login attempts within a certain time frame or identifying anomalies in a series of sensor data. # Function Signature ```python def is_duplicate_within_k(nums: list[int], k: int) -> bool: Given a list of integers \'nums\' and an integer \'k\', returns True if there are any duplicate elements within distance k, otherwise returns False. Args: nums: list[int] - A list of integers. k: int - An integer representing the maximum distance. Returns: bool - True if duplicates are found within distance k, otherwise False. Examples: >>> is_duplicate_within_k([1, 2, 3, 1], 3) True >>> is_duplicate_within_k([1, 0, 1, 1], 1) True >>> is_duplicate_within_k([1, 2, 3, 4, 5], 3) False >>> is_duplicate_within_k([1, 2, 1, 1], 2) True ``` # Constraints 1. The input list `nums` will always contain integers. 2. The input integer `k` will always be a non-negative integer. 3. The maximum length of the list is (10^5). # Detailed Requirements and Examples 1. **Input** - List of integers `nums`. - Single integer `k` representing the maximum distance within which duplicates should be checked. 2. **Output** - Boolean value indicating the presence of any duplicates within distance `k`. 3. **Example Scenarios** ```python - is_duplicate_within_k([1, 2, 3, 1], 3) -> True - is_duplicate_within_k([1, 0, 1, 1], 1) -> True - is_duplicate_within_k([1, 2, 3, 4, 5], 3) -> False - is_duplicate_within_k([1, 2, 1, 1], 2) -> True ``` # Performance Requirements - Time complexity must be (O(n)), where (n) is the length of the list. - Space complexity must be (O(min(n, k))). # Hints - Use a sliding window (or similar efficient data structures like a hash set) to track the elements within the recent `k` positions. # Error Handling - Assume that the input list `nums` and integer `k` are provided in the correct format and constraints ensure valid values. No need for additional error handling.","solution":"def is_duplicate_within_k(nums: list[int], k: int) -> bool: Given a list of integers \'nums\' and an integer \'k\', returns True if there are any duplicate elements within distance k, otherwise returns False. Args: nums: list[int] - A list of integers. k: int - An integer representing the maximum distance. Returns: bool - True if duplicates are found within distance k, otherwise False. seen = set() for i, num in enumerate(nums): if num in seen: return True seen.add(num) if len(seen) > k: seen.remove(nums[i - k]) return False"},{"question":"# Rough Order of Magnitude Estimation Write a Python function that estimates the rough order of magnitude of an integer array. The function should take a vector of integers and return a dictionary with key-value pairs representing each unique number and its corresponding rough order of magnitude as per the definitions below: - The rough order of magnitude for a number `x` is given by the largest power of 10 less than or equal to `x`. Function Signature ```python def rough_order_magnitude(vector: np.ndarray) -> dict: Parameters: vector (np.ndarray): A numpy array of shape (1, n) consisting of integer values Returns: magnitude_dict (dict): A dictionary where keys are unique integers from the input vector and values are their rough order of magnitude. ``` Input * A numpy array `vector` containing `n` integer numbers. Output * A dictionary where each unique integer from the input vector maps to its rough order of magnitude as an integer. Example ```python >>> rough_order_magnitude(np.array([1, 10, 150, 999, 1000])) {1: 1, 10: 10, 150: 100, 999: 100, 1000: 1000} ``` Constraints * The function should handle both small and large integer values. * Do not use any built-in functions that directly compute order of magnitude. * Time Complexity should be linear in relation to the size of the input vector. # Implementation Requirements 1. Optimize the implemented function for handling large arrays efficiently. 2. Write at least three test cases to assure the correctness of your implementation. 3. Ensure your implementation handles edge cases such as negative numbers and zeros appropriately. # Additional Notes - If the input vector contains zeros or negative numbers, their rough order of magnitude should be set to zero.","solution":"import numpy as np def rough_order_magnitude(vector: np.ndarray) -> dict: Parameters: vector (np.ndarray): A numpy array of shape (1, n) consisting of integer values Returns: magnitude_dict (dict): A dictionary where keys are unique integers from the input vector and values are their rough order of magnitude. magnitude_dict = {} for num in np.unique(vector): if num <= 0: magnitude_dict[num] = 0 else: magnitude = 1 while magnitude * 10 <= num: magnitude *= 10 magnitude_dict[num] = magnitude return magnitude_dict"},{"question":"# Distance Unit Conversion with Additional Features **Objective**: Extend the provided distance unit conversion algorithm to include additional functionality for handling finer granularities and additional units. **Task**: 1. **Core Functionality**: Implement a function `extended_convert_distance` that enhances the existing `convert_distance` function. 2. **Additional Units/Metrics**: Add support for millimeters, micrometers, and kilometers. Ensure that the accurate conversion process incorporates these smaller and larger units. 3. **Handling Compound Units**: Extend the functionality to handle compound units such as \\"2 meters, 35 centimeters, 7 millimeters\\". 4. **Validation and Constraints**: Ensure robust validation and constraints to handle various edge cases as mentioned previously. **Input and Output Formats**: * **Input**: * `distance_value` (float or str): Distance value or a string representing compound distance units. * `unit_from` (str): The initial unit of distance. * `unit_to` (str): The desired unit of distance. * **Output**: The converted distance value (float). **Constraints**: * `distance_value` should be a non-negative number or a valid string representation of compound units. * Both `unit_from` and `unit_to` should be valid units within the extended unit list. **Performance Requirements**: The function should handle typical use cases efficiently with a constant time complexity, O(1). **Function Signature**: ```python def extended_convert_distance(distance_value: float or str, unit_from: str, unit_to: str) -> float: pass ``` **Examples**: 1. `extended_convert_distance(1000, \\"millimeters\\", \\"meters\\")` should return `1.0`. 2. `extended_convert_distance(5, \\"kilometers\\", \\"meters\\")` should return `5000.0`. 3. `extended_convert_distance(\\"2 meters, 35 centimeters, 7 millimeters\\", \\"compound\\", \\"millimeters\\")` should return the equivalent distance in millimeters. **Notes**: 1. Compound units are specified as a string and parsed internally. 2. Ensure all error scenarios such as invalid strings, negative values, or unsupported units are handled gracefully with appropriate error messages.","solution":"def extended_convert_distance(distance_value, unit_from, unit_to): Converts distances between various units including compound units. distance_value: float or str - Distance value or compound distance units string. unit_from: str - Initial unit of distance. unit_to: str - Desired unit of distance. Returns: float - Converted distance value. unit_conversions = { \'millimeters\': 1, \'centimeters\': 10, \'meters\': 1000, \'kilometers\': 1000000, \'micrometers\': 0.001 } def parse_compound_units(compound_string): Parses a compound units string into millimeters. units = compound_string.split(\',\') total_mm = 0 for unit in units: value, unit_type = unit.strip().split() value = float(value) if unit_type not in unit_conversions: raise ValueError(f\\"Unsupported unit in compound value: {unit_type}\\") total_mm += value * unit_conversions[unit_type] return total_mm # If input is a compound unit string if isinstance(distance_value, str): if unit_from != \\"compound\\": raise ValueError(\\"For compound units, the unit_from should be \'compound\'.\\") distance_value = parse_compound_units(distance_value) unit_from = \'millimeters\' if unit_from not in unit_conversions or unit_to not in unit_conversions: raise ValueError(\\"Unsupported unit.\\") distance_in_mm = float(distance_value) * unit_conversions[unit_from] converted_distance = distance_in_mm / unit_conversions[unit_to] return converted_distance"},{"question":"# Problem Statement # Context You are working in a team focused on optimizing data retrieval operations from a database. As part of this effort, you need to write a function that can efficiently generate all unique substrings from a given input string. Generating unique substrings can help in creating indices and improving search operations. # Task Write a function `unique_substrings` that generates all unique substrings from an input string. The function should accept a single string as an input parameter and return a list of all unique substrings in lexicographical order. # Requirements 1. The function should be named `unique_substrings`. 2. The function should take one parameter: - `s` (str): The input string from which to generate unique substrings. 3. The function should return a list of strings, each string being a unique substring of the input string. 4. The list of substrings should be sorted in lexicographical order. # Function Signature ```python def unique_substrings(s: str) -> list[str]: pass ``` # Constraints * The length of string `s` will be between 0 and 1000 characters. * The input string can contain lowercase English letters only. # Example ```python assert unique_substrings(\\"abca\\") == [\\"a\\", \\"ab\\", \\"abc\\", \\"abca\\", \\"b\\", \\"bc\\", \\"bca\\", \\"c\\", \\"ca\\"] assert unique_substrings(\\"banana\\") == [\\"a\\", \\"an\\", \\"ana\\", \\"anan\\", \\"anana\\", \\"b\\", \\"ba\\", \\"ban\\", \\"bana\\", \\"banan\\", \\"banana\\", \\"n\\", \\"na\\", \\"nan\\", \\"nana\\"] assert unique_substrings(\\"aaa\\") == [\\"a\\", \\"aa\\", \\"aaa\\"] assert unique_substrings(\\"\\") == [] assert unique_substrings(\\"abc\\") == [\\"a\\", \\"ab\\", \\"abc\\", \\"b\\", \\"bc\\", \\"c\\"] ``` # Notes Your implementation should be efficient enough to handle the given constraints and ensure that all unique substrings are generated and sorted correctly.","solution":"def unique_substrings(s: str) -> list[str]: Generates all unique substrings from the input string and returns them in lexicographical order. substrings = set() # Generate all substrings and add to set for uniqueness for i in range(len(s)): for j in range(i + 1, len(s) + 1): substrings.add(s[i:j]) # Convert to list and sort unique_substrings_list = sorted(substrings) return unique_substrings_list"},{"question":"# Coding Assessment Question Scenario You are working on a chatbot application that assists users with various inquiries. One of the core features of the chatbot is to provide personalized greetings based on the time of day when the user interacts with it. To accomplish this, you need to write a function that determines the time of day and returns an appropriate greeting. Task Implement a function `generate_greeting` that accepts the current time in 24-hour format and returns a greeting message based on the time of day. Function Signature ```python def generate_greeting(hour: int) -> str: pass ``` Input * `hour`: An integer representing the current hour of the day (0-23). Output * Returns a string containing the appropriate greeting message. The messages should be: - \\"Good morning\\" for hours from 5 to 11 (inclusive) - \\"Good afternoon\\" for hours from 12 to 17 (inclusive) - \\"Good evening\\" for hours from 18 to 21 (inclusive) - \\"Good night\\" for hours from 22 to 4 (inclusive) Constraints * The hour will always be a valid integer in the range of 0 to 23. Example ```python >>> generate_greeting(10) \\"Good morning\\" >>> generate_greeting(14) \\"Good afternoon\\" >>> generate_greeting(19) \\"Good evening\\" >>> generate_greeting(23) \\"Good night\\" >>> generate_greeting(4) \\"Good night\\" ``` Edge Cases * Verify behavior with boundary values (e.g., 4, 5, 11, 12, 17, 18, 21, 22). * Ensure that the function handles all hours from 0 to 23 correctly.","solution":"def generate_greeting(hour: int) -> str: Given the current hour of the day (0-23), return an appropriate greeting message. if 5 <= hour <= 11: return \\"Good morning\\" elif 12 <= hour <= 17: return \\"Good afternoon\\" elif 18 <= hour <= 21: return \\"Good evening\\" else: return \\"Good night\\""},{"question":"# Problem Statement: Imagine you\'re working on developing a course-enrollment management system for a university. One of the requirements is to generate schedules for students based on the courses they have enrolled in. Each course has a specific time slot, and overlaps are not permitted. # Description: Your task is to write a function that takes a list of enrolled courses with their respective time slots and returns a boolean indicating whether the student has a valid schedule without time conflicts. Each course is represented by a tuple containing the start and end times in a 24-hour format (e.g., `(9, 12)` for a course starting at 9:00 AM and ending at 12:00 PM). # Function Signature: ```python def is_schedule_valid(courses: List[Tuple[int, int]]) -> bool: ``` # Constraints: 1. Each course is represented by a tuple `(start, end)` where `0 <= start < end <= 24`. 2. The list will contain between 1 to 10 courses. 3. A student\'s schedule is considered valid if none of the courses overlap. # Inputs: - `courses` (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers representing the start and end times of a course. # Outputs: - Returns a boolean indicating whether the schedule is valid (True if no courses overlap, False otherwise). # Example: ```python >>> is_schedule_valid([(9, 12), (13, 15), (16, 18)]) True >>> is_schedule_valid([(9, 12), (11, 14), (16, 18)]) False >>> is_schedule_valid([(8, 10), (10, 12), (12, 14)]) True >>> is_schedule_valid([(10, 11), (12, 13), (11, 12)]) True ``` Ensure your implementation correctly checks for overlapping time slots and returns the appropriate boolean value indicating the schedule\'s validity. Good luck and happy coding!","solution":"from typing import List, Tuple def is_schedule_valid(courses: List[Tuple[int, int]]) -> bool: Determines if the student\'s schedule is valid without overlapping courses. Args: courses (List[Tuple[int, int]]): List of tuples where each tuple contains the start and end times of a course. Returns: bool: True if the schedule is valid (no overlaps), False otherwise # Sort courses based on their start times courses.sort(key=lambda x: x[0]) for i in range(1, len(courses)): # Compare the end time of the previous course with the start time of the current course if courses[i-1][1] > courses[i][0]: return False return True"},{"question":"# Problem Description: A van der Corput sequence is an example of a low-discrepancy sequence, used to generate points that are uniformly distributed in the unit interval. The n-th number in the base-b van der Corput sequence can be generated by reversing the digits in the base-b representation of n, then converting back to fraction form in the base-10 system. For example, in base 2: - 0 in base-2 is 0, which reversed is still 0, and as a fraction is 0.0 - 1 in base-2 is 1, which reversed is still 1, and as a fraction is 0.1 (1/(2^1)) - 2 in base-2 is 10, which reversed is 01 -> 1 in base-10, and as a fraction is 0.01 (1/(2^2)) - 3 in base-2 is 11, which reversed is still 11 -> 3 in base-10, and as a fraction is 0.11 (1/(2^1) + 1/(2^2)) Your task is to write a function that generates the first `n` elements in the base-b van der Corput sequence and returns them as a list of floats. # Requirements: 1. Write a function `vdc_sequence(n: int, base: int) -> list` that generates the first `n` elements of the base `base` van der Corput sequence. 2. Ensure the function efficiently handles the conversion and sequence generation. # Input: - `n` (int): The number of sequence elements to generate. - `base` (int): The base in which to generate the van der Corput sequence. # Output: - Returns a list of floats representing the first `n` elements of the base `base` van der Corput sequence. Constraints: - 1 ≤ n ≤ 100 - 2 ≤ base ≤ 10 # Example: ```python def vdc_sequence(n: int, base: int) -> list: # Implementation here # Example print(vdc_sequence(5, 2)) # Output: [0.0, 0.5, 0.25, 0.75, 0.125] print(vdc_sequence(5, 3)) # Output: [0.0, 0.3333333333333333, 0.6666666666666666, 0.1111111111111111, 0.4444444444444444] ``` In this example: - `vdc_sequence(5, 2)` should return `[0.0, 0.5, 0.25, 0.75, 0.125]`. - `vdc_sequence(5, 3)` should return `[0.0, 0.3333333333333333, 0.6666666666666666, 0.1111111111111111, 0.4444444444444444]`. # Scoring: - Correctness (50%): The function generates the correct van der Corput sequence elements. - Efficiency (30%): The implementation efficiently computes elements without excessive recomputation for larger values of `n`. - Edge Handling (20%): Properly handles all edge cases including the minimum and maximum values for `n` and `base`.","solution":"def vdc_sequence(n: int, base: int) -> list: def vdc(i, base): vdc_value = 0 denom = 1 while i > 0: i, remainder = divmod(i, base) denom *= base vdc_value += remainder / denom return vdc_value return [vdc(i, base) for i in range(n)]"},{"question":"# Coding Assessment Question Context You are building a mini-command line calculator that can evaluate a specified mathematical expression in infix notation. The calculator should support basic arithmetic operations: addition, subtraction, multiplication, and division. Your task is to parse and evaluate the expression and return the result. Task Write a function `evaluate_expression(expression: str) -> float` that: 1. Evaluates a given arithmetic expression. 2. Supports addition (+), subtraction (-), multiplication (*), and division (/) operators. 3. Handles parentheses for changing the order of operations. Input - `expression`: A string containing a valid arithmetic expression using numbers, operators (+, -, *, /), and parentheses. Output - A float representing the result of the evaluated expression. Constraints - The input expression is guaranteed to be a valid and well-formed arithmetic expression. - Numbers in the expression can be positive or negative and can be integers or floats. - You can assume that division by zero will not be part of the input expression. Performance Requirements - Ensure the code handles expressions of up to length 10⁶ characters within reasonable execution time. Example ```python expression = \\"3 + 4 * 2 / (1 - 5) ^ 2 ^ 3\\" result = evaluate_expression(expression) print(result) # Expected output: 3.0001220703125 ``` Note: For simplification, the example provided does not consider the power (^) operator. In your implementation, you\'re only expected to handle the basic four operators (+, -, *, /). The provided output assumes that ^ has a right-associative property, and the actual complexity of this part can be ignored. Hint - You may find it helpful to first convert the infix expression to a postfix expression (using the Shunting Yard algorithm) and then evaluate the postfix expression.","solution":"def evaluate_expression(expression: str) -> float: Evaluates a given arithmetic expression in infix notation. Args: expression (str): A string containing a valid arithmetic expression. Returns: float: The result of the evaluated expression. def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 def apply_op(operands, operators): right = operands.pop() left = operands.pop() op = operators.pop() if op == \'+\': operands.append(left + right) elif op == \'-\': operands.append(left - right) elif op == \'*\': operands.append(left * right) elif op == \'/\': operands.append(left / right) def evaluate(expression): operands = [] operators = [] i = 0 while i < len(expression): if expression[i] == \' \': i += 1 continue if expression[i] == \'(\': operators.append(expression[i]) elif expression[i].isdigit() or expression[i] == \'.\': val = 0 is_float = False decimal_place = 1 while (i < len(expression) and (expression[i].isdigit() or expression[i] == \'.\')): if expression[i] == \'.\': is_float = True i += 1 continue if is_float: val += (float(expression[i]) / (10 ** decimal_place)) decimal_place += 1 else: val = (val * 10) + int(expression[i]) i += 1 operands.append(float(val)) i -= 1 elif expression[i] == \')\': while len(operators) != 0 and operators[-1] != \'(\': apply_op(operands, operators) operators.pop() else: while (len(operators) != 0 and precedence(operators[-1]) >= precedence(expression[i])): apply_op(operands, operators) operators.append(expression[i]) i += 1 while len(operators) != 0: apply_op(operands, operators) return operands[-1] return evaluate(expression)"},{"question":"# Coding Assessment Question You are given a list of strings where each string represents a binary number. Your task is to write a function that computes the length of the longest consecutive sequence of binary strings where the decimal values of these binary strings form an increasing sequence. # Function Signature ```python def longest_increasing_sequence(binary_list: List[str]) -> int: Calculate the length of the longest increasing sequence of binary strings by their decimal values. :param binary_list: List of binary strings. :return: The length of the longest increasing sequence. ``` # Example ```python >>> longest_increasing_sequence([\\"101\\", \\"110\\", \\"111\\", \\"100\\"]) 3 # Explanation: # The binary values in decimal are: 5, 6, 7, 4. # The longest increasing sequence is: 5, 6, 7. # So the length is 3. >>> longest_increasing_sequence([\\"10\\", \\"11\\", \\"1\\"]) 2 # Explanation: # The binary values in decimal are: 2, 3, 1. # The longest increasing sequence is: 2, 3. # So the length is 2. >>> longest_increasing_sequence([\\"1\\", \\"1\\", \\"1\\"]) 1 # Explanation: # All binary values are the same: 1. # The longest increasing sequence is any single element. # So the length is 1. ``` # Input Constraints * The length of the binary list will be between 1 and 1000. * Each binary string will contain only \'0\'s and \'1\'s. * Each binary string will be at most 10 characters long. # Requirements * Your solution must have a time complexity of O(n log n) or better. * Consider implementing an efficient approach using dynamic programming or other relevant techniques. # Edge Cases * Test with the smallest list containing only one binary string. * Validate that all strings contain valid binary digits (\'0\' or \'1\'). * Consider cases with binary strings of different lengths but ensuring they represent valid binary numbers.","solution":"from typing import List def longest_increasing_sequence(binary_list: List[str]) -> int: Calculate the length of the longest increasing sequence of binary strings by their decimal values. :param binary_list: List of binary strings. :return: The length of the longest increasing sequence. # Convert binary strings to decimal values decimal_list = [int(bin_str, 2) for bin_str in binary_list] n = len(decimal_list) if n == 0: return 0 # Initialize dp array where dp[i] represents the length of the longest # increasing subsequence that ends with decimal_list[i] dp = [1] * n # Compute the length of the longest increasing subsequence for i in range(1, n): for j in range(i): if decimal_list[i] > decimal_list[j]: dp[i] = max(dp[i], dp[j] + 1) # The result is the maximum value in the dp array return max(dp)"},{"question":"# Coding Assessment Question Context You are working on a text-processing library that includes various utilities for manipulating and analyzing strings. One common task is to count the frequency of each word in a given text. Task Implement a function that counts the frequency of each word in an input string and returns a dictionary with words as keys and their respective frequencies as values. The function should be case-insensitive and ignore punctuation marks. Requirements 1. **Function Definition**: Implement a function named `word_count` which computes the frequency of words. 2. **Input**: A string containing words separated by spaces and possibly punctuation marks. 3. **Output**: A dictionary where the keys are words in lower case and values are integers representing the frequency of each word in the input string. 4. **Constraints**: * Ignore punctuation marks such as `.`, `,`, `!`, `?`, `;`, `:` etc. * Consider edge cases like empty string or a string with only punctuation. * Handle different cases of word appearances by converting all to lower case. Function Signature ```python def word_count(text: str) -> dict[str, int]: pass ``` Example 1. Input: `\\"Hello, world! Hello...\\"` Output: `{\\"hello\\": 2, \\"world\\": 1}` 2. Input: `\\"One fish, two fish. Red fish, blue fish.\\"` Output: `{\\"one\\": 1, \\"fish\\": 4, \\"two\\": 1, \\"red\\": 1, \\"blue\\": 1}` 3. Input: `\\"Python is great, isn\'t it? Python is fun.\\"` Output: `{\\"python\\": 2, \\"is\\": 2, \\"great\\": 1, \\"isn\'t\\": 1, \\"it\\": 1, \\"fun\\": 1}` 4. Input: `\\"\\"` Output: `{}` Testing * Ensure to test your `word_count` function with various test cases, including but not limited to strings with different punctuation marks, varying cases, and edge cases. * Verify that the returned dictionary correctly represents the word frequencies as expected.","solution":"import re from collections import defaultdict def word_count(text: str) -> dict[str, int]: This function takes a string input, removes punctuation, converts to lowercase, and returns the frequency of each word in the string. # Remove punctuation using regex and convert string to lowercase text = re.sub(r\'[^ws]\', \'\', text.lower()) # Split the text into words words = text.split() # Use a defaultdict to keep the count of each word word_freq = defaultdict(int) # Count the frequency of each word for word in words: word_freq[word] += 1 # Convert defaultdict to a regular dictionary return dict(word_freq)"},{"question":"# Fibonacci Sequence Calculation The Fibonacci sequence is a series of numbers where each number after the first two is the sum of the two preceding ones. Typically, it starts with 0 and 1. Therefore, the sequence looks like this: 0, 1, 1, 2, 3, 5, 8, 13,... Objective Write a function that computes the nth Fibonacci number. The function should be efficient enough to handle large values of n. Function Signature ```python def fibonacci(n: int) -> int: pass ``` Input - An integer `n` where 0 <= n <= 10^5. The function should raise appropriate exceptions for invalid inputs. Output - The nth Fibonacci number. Constraints - The input `n` must be an integer. - The input `n` must be a non-negative integer (greater than or equal to zero). Error Handling - If the input is not an integer, the function should raise a `TypeError` with the message \\"Input value of [number=<value>] must be an integer\\". - If the input is negative, the function should raise a `ValueError` with the message \\"Input must be a non-negative integer\\". Example ```python >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(10) 55 >>> fibonacci(20) 6765 >>> fibonacci(-5) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer >>> fibonacci(10.5) Traceback (most recent call last): ... TypeError: Input value of [number=10.5] must be an integer ``` # Task Implement the `fibonacci` function to meet the above requirements and handle all specified edge cases.","solution":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number. The function is efficient enough to handle large values of n (up to 10^5). if not isinstance(n, int): raise TypeError(f\\"Input value of [number={n}] must be an integer\\") if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Sum of Distinct Prime Factors Context In the field of cryptography, prime numbers play a crucial role in various algorithms. One of your tasks as a cryptographic analyst is to analyze numbers based on their prime factors. Given a positive integer, you need to find the sum of its distinct prime factors. For example, the number 28 has the prime factors 2 and 7, and their sum is 9. Task Write a function `sum_of_distinct_prime_factors` that computes the sum of all distinct prime factors of a given number `n`. **Function Signature**: ```python def sum_of_distinct_prime_factors(n: int) -> int: pass ``` Input - `n` (int): A positive integer where 1 ≤ n ≤ 10^9. Output - (int): The sum of all distinct prime factors of the given integer `n`. Constraints - Consider edge cases such as prime numbers or the smallest numbers. - Ensure the function runs efficiently for the upper limit of `n`. Examples 1. **Input**: `n = 28` **Output**: `9` (because the distinct prime factors are 2 and 7, and their sum is 2 + 7 = 9) 2. **Input**: `n = 13` **Output**: `13` (13 is a prime number itself, so its only distinct prime factor is 13) 3. **Input**: `n = 60` **Output**: `10` (distinct prime factors are 2, 3, and 5, and their sum is 2 + 3 + 5 = 10) Use the provided algorithm outline in the analysis to implement the `sum_of_distinct_prime_factors` function that meets the requirements outlined. Ensure it passes all provided test cases and edge cases effectively.","solution":"def sum_of_distinct_prime_factors(n: int) -> int: Returns the sum of all distinct prime factors of the given integer n. def smallest_prime_factor(n): if n < 2: return None if n % 2 == 0: return 2 for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return i return n sum_of_primes = 0 while n > 1: spf = smallest_prime_factor(n) sum_of_primes += spf while n % spf == 0: n //= spf return sum_of_primes"},{"question":"# Coding Assessment Question In the course of your work, you need to manipulate lists of numbers to extract meaningful insights. One of the operations required is to shift the elements of a list cyclically. **Function Specification:** Implement the function `cyclic_shift` that takes a list of integers and an integer `k`, and returns the list after shifting its elements to the right `k` times. ```python def cyclic_shift(nums: list[int], k: int) -> list[int]: pass ``` # Input - `nums` (list of integers): The list to be shifted. It may be empty. - `k` (integer): The number of positions to shift the list to the right. # Output - Returns a list of integers that represents the original list after a right cyclic shift by `k` positions. # Constraints - You can assume that all elements in the list will be integers. - The list size is arbitrarily large, and performance should be efficient for large inputs. - `k` can be any integer, including negative or zero. # Requirements - Handle edge cases such as empty lists and `k` being zero or negative values. - The solution should be implemented with a time complexity of (O(n)) and space complexity of (O(1)). # Functionality Tests Ensure your function passes the following test cases: ```python >>> cyclic_shift([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> cyclic_shift([1, 2, 3, 4, 5], -1) [2, 3, 4, 5, 1] >>> cyclic_shift([1, 2, 3], 0) [1, 2, 3] >>> cyclic_shift([1, 2, 3], 3) [1, 2, 3] >>> cyclic_shift([], 4) [] >>> cyclic_shift([10, 20], 1) [20, 10] ``` # Scenario Imagine you are working on a music playlist application. Users want the ability to shuffle their favorite songs but also to quickly shift the order of the playlist to keep the repeatability constrained in a cyclic fashion. Use the `cyclic_shift` function to shift the playlist in a smooth, cyclic manner, improving the user experience.","solution":"def cyclic_shift(nums: list[int], k: int) -> list[int]: Cyclically shifts the elements of a list to the right by k positions. Parameters: nums (list[int]): The list of integers to be shifted. k (int): The number of positions to shift the list. Returns: list[int]: The list after shifting its elements. if not nums: return [] n = len(nums) k = k % n # Normalize k to be within the bounds of 0 to n-1 return nums[-k:] + nums[:-k]"},{"question":"# Problem Statement Objective Write a program in language L that takes an integer N as input and generates all balanced parentheses combinations of N pairs. Motivation This task evaluates your understanding of recursive algorithms and your ability to generate combinatorial structures in a specified programming language. # Requirements 1. **Input**: A single integer N (1 ≤ N ≤ 10). 2. **Output**: A list of strings, each representing a valid combination of N pairs of balanced parentheses. # Constraints - The list of strings should include all possible balanced combinations. - Each combination should use exactly N pairs of parentheses. - The program must be implemented in the specified programming language. - The output list should be sorted in lexicographical order. # Performance - The implementation should execute efficiently given the constraints (i.e., within a reasonable time frame for a combinatorial problem of this size). # Specification Example If you were to solve this in Python, a valid function might resemble: ```python def generate_parentheses(n): result = [] def backtrack(s, left, right): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s + \\"(\\", left + 1, right) if right < left: backtrack(s + \\")\\", right + 1, left) backtrack(\\"\\", 0, 0) return sorted(result) # Example usage: print(generate_parentheses(3)) # Output: [\'((()))\', \'(()())\', \'(())()\', \'()(())\', \'()()()\'] ``` Ensure your solution meets the constraints and functions correctly in language L. Notes - You are encouraged to research backtracking algorithms and combinatorial generation techniques to better understand and implement the solution. - Pay attention to the details of ensuring that all parentheses are balanced, which is crucial for the correctness of the combinations generated.","solution":"def generate_parentheses(n): Generates all combinations of n pairs of balanced parentheses. :param n: int - number of pairs of parentheses :return: list of strings - all combinations of balanced parentheses result = [] def backtrack(s, left, right): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s + \\"(\\", left + 1, right) if right < left: backtrack(s + \\")\\", left, right + 1) backtrack(\\"\\", 0, 0) return sorted(result)"},{"question":"# Scenario You are a software developer tasked with creating a utility for processing search query data. The system should be able to find the most frequent search phrases from a large list of queries, within a specific time frame. # Task Implement a function that finds the top `k` most frequent search phrases from a list of search queries. The function should be able to handle a large input efficiently. # Function Signature ```python def top_k_frequent_phrases(queries, k): ``` # Inputs - `queries` (List[str]): A list of search queries where each query is a string. - `k` (int): An integer representing the number of top frequent phrases to return. # Outputs - A list (List[str]) of the `k` most frequent search phrases in order from most frequent to least frequent. In case of ties, return them sorted lexicographically. # Constraints - `1 <= len(queries) <= 10^5` (The total number of queries is large but manageable) - `1 <= len(query) <= 100` (Each query has a reasonable maximum length) - `1 <= k <= 10^3` (You need to return a manageable number of top results) # Example Given the list of queries: ```python queries = [ \\"apple pie\\", \\"banana split\\", \\"apple cider\\", \\"apple pie\\", \\"banana split\\", \\"chocolate cake\\", \\"apple pie\\", \\"banana split\\" ] k = 2 ``` The function should return: ```python [\\"apple pie\\", \\"banana split\\"] ``` In this case, \\"apple pie\\" and \\"banana split\\" are the most frequent search phrases. # Remarks - You may use any language features or libraries that enable efficient processing of large data sets, such as collections.Counter in Python. - Ensure your solution handles ties properly by outputting the lexicographically smallest phrases when frequencies are the same.","solution":"from collections import Counter def top_k_frequent_phrases(queries, k): Finds the top k most frequent search phrases in the list of queries. Parameters: queries (List[str]): A list of search queries where each query is a string. k (int): An integer representing the number of top frequent phrases to return. Returns: List[str]: A list of the k most frequent search phrases. # Count the frequency of each query freq = Counter(queries) # Use a list comprehension to create a sorted list of phrases most_common_phrases = sorted(freq.items(), key=lambda x: (-x[1], x[0])) # Extract the top k phrases result = [phrase for phrase, count in most_common_phrases[:k]] return result"},{"question":"# Merge Sorted Lists Your task is to implement a function that merges multiple sorted linked lists into a single sorted linked list. # Problem Statement You need to implement a function `merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]` that takes a list of sorted linked lists and returns a single sorted linked list composed of all the elements from the input lists. Function Signature ```python from typing import List, Optional class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: # Your implementation here ``` # Input - `lists`: A list of `ListNode` objects, where each `ListNode` represents the head of a sorted linked list. If a list has no elements, its corresponding head will be `None`. # Output - The function should return a `ListNode` object representing the head of a single merged and sorted linked list. # Examples ```python # Example 1 list1 = ListNode(1, ListNode(4, ListNode(5))) list2 = ListNode(1, ListNode(3, ListNode(4))) list3 = ListNode(2, ListNode(6)) assert merge_k_sorted_lists([list1, list2, list3]).val == 1 # Example 2 assert merge_k_sorted_lists([]) is None # Example 3 empty_list = ListNode() assert merge_k_sorted_lists([empty_list]).val == 0 ``` # Constraints - There can be any number of input lists (including zero lists). - The total number of nodes across all lists will be at most 10^4. - The values in each `ListNode` will be integers in the range `-10^4` to `10^4`. - Each of the input linked lists is sorted in non-decreasing order. # Requirements - The function should efficiently merge all linked lists maintaining their sorted order. - Handle edge cases such as empty lists, single-node lists, and duplicate values gracefully. - Optimize for both time and space complexity, ensuring the solution is effective for larger inputs.","solution":"from typing import List, Optional import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: if not lists: return None min_heap = [] # Fill the heap with the head nodes for i, node in enumerate(lists): if node: heapq.heappush(min_heap, (node.val, i, node)) # Dummy head to help with the merge process dummy = ListNode(0) current = dummy while min_heap: val, i, node = heapq.heappop(min_heap) current.next = ListNode(val) current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, i, node.next)) return dummy.next"},{"question":"# Problem Statement You are given a list of strings, each representing a stream of sensor readings, where each string contains letters and digits. The digits represent readings logged by sensors, and any letters should be considered irrelevant noise. Your task is to implement a function `extract_sensor_readings(sensor_data: list[str]) -> list[int]` that extracts all the digits from each string in the input list and returns them as a list of integers in the order they appear. # Function Signature ```python def extract_sensor_readings(sensor_data: list[str]) -> list[int]: pass ``` # Input * `sensor_data`: A list of strings, where each string contains a mix of letters and digits. The list may contain up to 10^5 strings. # Output * A list of integers representing the extracted sensor readings in the order they appear across all strings. # Constraints * Each string in `sensor_data` can have a length up to 10^4 characters. * Digits in the strings are non-negative integers (0-9). # Example ```python sensor_data1 = [\\"a1b2c3\\", \\"x9y8z7\\", \\"123\\", \\"abc\\"] print(extract_sensor_readings(sensor_data1)) # Output: [1, 2, 3, 9, 8, 7, 1, 2, 3] sensor_data2 = [\\"noDigitsHere\\", \\"justText\\"] print(extract_sensor_readings(sensor_data2)) # Output: [] ``` # Note You can assume that the input list is well-formed and that strings contain only alphanumeric characters. Your implementation should efficiently handle large datasets and return results within a reasonable time frame. Use appropriate data structures and algorithms to ensure an optimal solution.","solution":"def extract_sensor_readings(sensor_data: list[str]) -> list[int]: Extracts digits from each string in sensor_data and returns them as a list of integers. readings = [] for data in sensor_data: for char in data: if char.isdigit(): readings.append(int(char)) return readings"},{"question":"# Problem Statement You are tasked with developing a utility function that anonymizes email addresses in a given string. The function should replace each email address with a placeholder string while preserving the general structure for readability. Specifically, replace the local-part of each email (the part before the `@` symbol) with `***`. # Function Specification `anonymize_emails(text: str) -> str` * **Input**: * `text`: A string that may contain one or more email addresses. * **Output**: * A string where all email addresses have been anonymized. * The local-part of email addresses should be replaced with `***`, retaining the domain part. # Constraints * An email address is defined as a string with the format `local-part@domain`. * The `local-part` consists of alphabetic characters, digits, dots (`.`), hyphens (`-`), and underscores (`_`). * The `local-part` has at least one character. * The `domain` consists of alphabetic characters and dots (`.`), where there is at least one dot. * The input text can contain any printable characters. * The maximum length of the input text is `10^5` characters. # Examples ```python text = \\"Please contact us at support@example.com for further assistance.\\" result = anonymize_emails(text) # Expected Output: \\"Please contact us at ***@example.com for further assistance.\\" text = ( \\"Send your queries to jane.doe@example.com or visit our website. \\" \\"For complaints, contact john_doe-123@company.io.\\" ) result = anonymize_emails(text) # Expected Output: \\"Send your queries to ***@example.com or visit our website. \\" # \\"For complaints, contact ***@company.io.\\" ``` # Hints * Use regular expressions to identify and replace email addresses. * Preserve non-email parts of the text exactly as they are. # Notes * Ensure to handle cases where the email appears at various positions within the text (beginning, middle, end). * Consider edge cases such as multiple emails within the same text or emails with subdomains.","solution":"import re def anonymize_emails(text: str) -> str: Anonymizes email addresses in the given text by replacing the local-part with \'***\'. :param text: A string that may contain one or more email addresses. :return: A string with email addresses anonymized. email_pattern = r\'([a-zA-Z0-9._%+-]+)@([a-zA-Z0-9.-]+.[a-zA-Z]{2,})\' def replace_email(match): local_part = match.group(1) domain_part = match.group(2) return f\'***@{domain_part}\' anonymized_text = re.sub(email_pattern, replace_email, text) return anonymized_text"},{"question":"# Graph Depth-First Search (DFS) Traversal You are tasked with implementing a class `Graph` to represent an undirected graph using an adjacency list and support depth-first search (DFS) traversal. Your class should allow the addition of vertices and edges, and perform a DFS traversal from a given starting vertex, visiting all vertices reachable from that starting vertex. Tasks: 1. **Graph Class Implementation**: - **Initialization**: Initialize an empty adjacency list. - **Add Vertex**: Implement a method to add a vertex to the graph. - **Add Edge**: Implement a method to add an undirected edge between two vertices. - **DFS Traversal**: Implement a method to perform a DFS traversal starting from a given vertex, and return the list of visited vertices in the order they were visited. Constraints: - The graph can contain up to 100 vertices. - Vertex labels are unique strings. - Edges are undirected. - You can assume that the methods will be called with valid input and that the graph is connected. Expected Input and Output Format: - **Input**: Operations by calling various methods. - **Output**: Printed results of operations: Example: ```python # Initialize the graph graph = Graph() # Add vertices graph.add_vertex(\\"A\\") graph.add_vertex(\\"B\\") graph.add_vertex(\\"C\\") graph.add_vertex(\\"D\\") graph.add_vertex(\\"E\\") # Add edges graph.add_edge(\\"A\\", \\"B\\") graph.add_edge(\\"A\\", \\"C\\") graph.add_edge(\\"B\\", \\"D\\") graph.add_edge(\\"C\\", \\"E\\") # Test DFS traversal starting from vertex \\"A\\" visited_vertices = graph.dfs(\\"A\\") print(visited_vertices) # Output: [\'A\', \'B\', \'D\', \'C\', \'E\'] # Test DFS traversal starting from vertex \\"C\\" visited_vertices = graph.dfs(\\"C\\") print(visited_vertices) # Output: [\'C\', \'A\', \'B\', \'D\', \'E\'] ``` Implement the class such that it satisfies the constraints above, handling any edge cases appropriately.","solution":"class Graph: def __init__(self): self.adjacency_list = {} def add_vertex(self, vertex): if vertex not in self.adjacency_list: self.adjacency_list[vertex] = [] def add_edge(self, u, v): if u in self.adjacency_list and v in self.adjacency_list: self.adjacency_list[u].append(v) self.adjacency_list[v].append(u) def dfs(self, start_vertex): visited = set() traversal_order = [] def dfs_recursive(v): if v not in visited: visited.add(v) traversal_order.append(v) for neighbor in self.adjacency_list[v]: dfs_recursive(neighbor) dfs_recursive(start_vertex) return traversal_order"}]'),S={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:N,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},F={class:"search-container"},O={class:"card-container"},z={key:0,class:"empty-state"},R=["disabled"],L={key:0},P={key:1};function D(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",F,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",O,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",z,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",P,"Loading...")):(n(),i("span",L,"See more"))],8,R)):u("",!0)])}const Y=h(S,[["render",D],["__scopeId","data-v-ecdd011b"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/36.md","filePath":"drive/36.md"}'),j={name:"drive/36.md"},V=Object.assign(j,{setup(r){return(e,l)=>(n(),i("div",null,[x(Y)]))}});export{B as __pageData,V as default};
