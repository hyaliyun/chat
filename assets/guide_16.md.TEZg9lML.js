import{_ as m,o as s,c as i,a as t,m as _,t as d,C as h,M as g,U as b,f as l,F as x,p as y,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function E(n,e,u,c,r,a){return s(),i("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),_(d(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),_(d(u.poem.solution),1)])])])}const A=m(q,[["render",E],["__scopeId","data-v-ca995a8b"]]),R=JSON.parse(`[{"question":"def has_pair_with_difference(arr: List[int], k: int) -> str: Determines if there exists a pair of distinct indices (i, j) such that the absolute difference between the elements at those indices is equal to a given integer k. Parameters: arr (List[int]): List of integers. k (int): The target absolute difference. Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". >>> has_pair_with_difference([1, 5, 3, 4, 2], 3) == \\"YES\\" >>> has_pair_with_difference([1, 2, 3, 4], 10) == \\"NO\\" >>> has_pair_with_difference([1, 1, 1, 1, 1, 1], 0) == \\"YES\\"","solution":"def has_pair_with_difference(arr, k): Determines if there exists a pair of distinct indices (i, j) such that the absolute difference between the elements at those indices is equal to a given integer k. Parameters: arr (List[int]): List of integers. k (int): The target absolute difference. Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". seen = set() for num in arr: if num + k in seen or num - k in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def knapsack(n: int, W: int, values: List[int], weights: List[int]) -> int: Determine the maximum total value of items that Anna can carry in her backpack without exceeding the weight limit. Args: n (int): The number of items. W (int): The weight limit of the backpack. values (List[int]): A list of integers representing the values of the items. weights (List[int]): A list of integers representing the weights of the items. Returns: int: The maximum total value of the items that can be carried without exceeding the weight limit. Example: >>> knapsack(4, 10, [60, 100, 120, 30], [2, 4, 6, 1]) 220 >>> knapsack(3, 50, [60, 100, 120], [10, 20, 30]) 220","solution":"def knapsack(n, W, values, weights): # Initialize the dp array with zeros dp = [0] * (W + 1) # Iterate through all items for i in range(n): # Update the dp array from end to start for w in range(W, weights[i] - 1, -1): dp[w] = max(dp[w], dp[w - weights[i]] + values[i]) return dp[W]"},{"question":"def count_inversed_pairs(arr: list) -> int: Count the number of inversed pairs in an array of distinct positive integers where an inversed pair is defined as a pair of indices (i, j) such that i < j and arr[i] > arr[j]. Parameters: arr (list): List of distinct positive integers Returns: int: Number of inversed pairs Examples: >>> count_inversed_pairs([2, 4, 1, 3, 5]) 3 >>> count_inversed_pairs([1, 2, 3, 4, 5]) 0 >>> count_inversed_pairs([5, 4, 3, 2, 1]) 10 >>> count_inversed_pairs([1]) 0 >>> count_inversed_pairs([2, 1]) 1 >>> count_inversed_pairs([1, 2]) 0","solution":"def count_inversed_pairs(arr): Count the number of inversed pairs in the array where an inversed pair is defined as a pair of indices (i, j) such that i < j and arr[i] > arr[j]. Parameters: arr (list): List of distinct positive integers. Returns: int: Number of inversed pairs. def merge_count_split_inv(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_count_split_inv(arr, temp_arr, left, mid, right) return inv_count n = len(arr) temp_arr = [0]*n return merge_sort_and_count(arr, temp_arr, 0, n-1)"},{"question":"def max_sum_trees(heights: List[int]) -> int: Calculate the maximum sum of heights of the remaining trees. The sum is maximized while ensuring that no two consecutive trees are kept. >>> max_sum_trees([3, 2, 5, 10, 7]) 15 >>> max_sum_trees([4, 1, 1, 9]) 13 from solution import max_sum_trees def test_max_sum_trees_basic(): assert max_sum_trees([3, 2, 5, 10, 7]) == 15 def test_max_sum_trees_single(): assert max_sum_trees([4]) == 4 def test_max_sum_trees_two(): assert max_sum_trees([4, 1]) == 4 def test_max_sum_trees_three(): assert max_sum_trees([3, 2, 7]) == 10 def test_max_sum_trees_alternating(): assert max_sum_trees([4, 1, 1, 9]) == 13 def test_max_sum_trees_all_equal(): assert max_sum_trees([4, 4, 4, 4, 4]) == 12 def test_max_sum_trees_decreasing(): assert max_sum_trees([5, 4, 3, 2, 1]) == 9 def test_max_sum_trees_increasing(): assert max_sum_trees([1, 2, 3, 4, 5]) == 9 def test_max_sum_trees_empty(): assert max_sum_trees([]) == 0","solution":"def max_sum_trees(heights): Calculate the maximum sum of heights of the remaining trees. The sum is maximized while ensuring that no two consecutive trees are kept. n = len(heights) if n == 0: return 0 elif n == 1: return heights[0] # Initialize the maximum sums for the first two elements dp = [0] * n dp[0] = heights[0] dp[1] = max(heights[0], heights[1]) # Fill the dp array for the rest of the elements for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + heights[i]) return dp[n-1] # Example usage heights_input = [3, 2, 5, 10, 7] print(max_sum_trees(heights_input)) # Output: 15"},{"question":"def min_moves(initial: str, target: str) -> int: Returns the minimum number of moves required to transform the initial sequence into the target sequence while keeping '@' and '#' in their positions. If the transformation is not possible, returns -1. >>> min_moves(\\"a@b#c\\", \\"c@b#a\\") 3 >>> min_moves(\\"abc@def#gh\\", \\"ghi@def#abc\\") -1 >>> min_moves(\\"m@no#p\\", \\"m@on#p\\") 1 >>> min_moves(\\"a@b#c\\", \\"a@b#c\\") 0 >>> min_moves(\\"a@bc#d\\", \\"a@cb#d\\") 1 >>> min_moves(\\"a@b#c\\", \\"a@#bc\\") -1 >>> min_moves(\\"a@b#c\\", \\"a@d#e\\") -1 >>> min_moves(\\"a@b#cd\\", \\"a@b#c\\") -1","solution":"def min_moves(initial, target): Returns the minimum number of moves required to transform the initial sequence into the target sequence while keeping '@' and '#' in their positions. If the transformation is not possible, returns -1. if len(initial) != len(target): return -1 # Validate '@' and '#' positions if initial.index('@') != target.index('@') or initial.index('#') != target.index('#'): return -1 # Remove '@' and '#' from the sequences initial_filtered = initial.replace('@', '').replace('#', '') target_filtered = target.replace('@', '').replace('#', '') if sorted(initial_filtered) != sorted(target_filtered): return -1 initial_filtered = list(initial_filtered) target_filtered = list(target_filtered) moves = 0 i = 0 while i < len(initial_filtered): if initial_filtered[i] != target_filtered[i]: j = i while initial_filtered[j] != target_filtered[i]: j += 1 while j > i: # Swap adjacent characters initial_filtered[j], initial_filtered[j-1] = initial_filtered[j-1], initial_filtered[j] j -= 1 moves += 1 i += 1 return moves"},{"question":"def minimum_space_stations(n: int, m: int, highways: List[Tuple[int, int]]) -> int: Determine the minimum number of space stations needed so every planet has access to at least one space station either directly or indirectly. >>> minimum_space_stations(6, 5, [(1, 2), (2, 3), (4, 5), (5, 6), (6, 4)]) 2 >>> minimum_space_stations(8, 7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8)]) 1 >>> minimum_space_stations(4, 2, [(1, 2), (3, 4)]) 2 >>> minimum_space_stations(5, 0, []) 5 >>> minimum_space_stations(1, 0, []) 1","solution":"def minimum_space_stations(n, m, highways): from collections import defaultdict, deque # Create a graph graph = defaultdict(list) for u, v in highways: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) def bfs(start): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) # Find all connected components components = 0 for i in range(1, n + 1): if not visited[i]: components += 1 bfs(i) return components # Note: This function takes additional parameter 'highways' which is the list of tuples # This would make testing easier."},{"question":"def process_operations(n, m, operations): Process \`m\` operations on an array of size \`n\` initialized with zeros. Parameters: - n: Size of the array. - m: Number of operations. - operations: List of operations, each operation is a tuple (l, r, x). Returns: A list representing the final state of the array after all operations. # Initialize the array with zeros # Process each operation and update the array accordingly # Return the final state of the array from solution import process_operations def test_single_operation(): assert process_operations(5, 1, [(1, 5, 1)]) == [1, 1, 1, 1, 1] def test_multiple_operations_non_overlapping(): assert process_operations(5, 2, [(1, 2, 1), (3, 5, 2)]) == [1, 1, 2, 2, 2] def test_multiple_operations_overlapping(): assert process_operations(5, 3, [(1, 3, 2), (2, 4, -1), (1, 5, 3)]) == [5, 4, 4, 2, 3] def test_operations_with_negative_values(): assert process_operations(4, 2, [(1, 2, 1), (3, 4, 2)]) == [1, 1, 2, 2] assert process_operations(4, 3, [(1, 3, -2), (2, 4, 3), (1, 2, -1)]) == [-3, 0, 1, 3] def test_large_input(): n, m = 100000, 1 operations = [(1, 100000, 1)] expected_output = [1] * 100000 assert process_operations(n, m, operations) == expected_output","solution":"def process_operations(n, m, operations): Process \`m\` operations on an array of size \`n\` initialized with zeros. Parameters: - n: Size of the array. - m: Number of operations. - operations: List of operations, each operation is a tuple (l, r, x). Returns: A list representing the final state of the array after all operations. arr = [0] * n for l, r, x in operations: for i in range(l-1, r): arr[i] += x return arr"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def construct_postorder_from_pre_in(preorder, inorder): Constructs the binary tree from the given pre-order and in-order traversal sequences and outputs its post-order traversal sequence. >>> construct_postorder_from_pre_in([1, 2, 4, 3], [4, 2, 1, 3]) [4, 2, 3, 1] >>> construct_postorder_from_pre_in([3, 9, 20, 15, 7, 10, 8], [9, 3, 15, 20, 7, 10, 8]) [9, 15, 8, 10, 7, 20, 3]","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree(preorder, inorder): if not preorder or not inorder: return None root_val = preorder.pop(0) root = TreeNode(root_val) inorder_index = inorder.index(root_val) root.left = build_tree(preorder, inorder[:inorder_index]) root.right = build_tree(preorder, inorder[inorder_index + 1:]) return root def postorder_traversal(node): if node: return postorder_traversal(node.left) + postorder_traversal(node.right) + [node.value] return [] def construct_postorder_from_pre_in(preorder, inorder): tree_root = build_tree(preorder.copy(), inorder) return postorder_traversal(tree_root)"},{"question":"def find_length_of_longest_subarray(a: List[int], b: List[int]) -> int: Finds the length of the longest subarray that appears in both arrays a and b. :param a: List[int] - the first array of integers :param b: List[int] - the second array of integers :return: int - the length of the longest common subarray Examples: >>> find_length_of_longest_subarray([1, 2, 3, 2, 1], [3, 2, 1, 4, 7]) 3 >>> find_length_of_longest_subarray([0, 1, 0, 1, 0], [1, 0, 1, 0, 1]) 4 >>> find_length_of_longest_subarray([1], [1]) 1 >>> find_length_of_longest_subarray([1, 2, 3], [4, 5, 6]) 0 >>> find_length_of_longest_subarray([1, 2, 3], [3, 4, 5]) 1 >>> find_length_of_longest_subarray([0, 1, 0, 1, 0], [0, 1, 0, 1, 0]) 5","solution":"def find_length_of_longest_subarray(a, b): Finds the length of the longest subarray that appears in both arrays a and b. :param a: List[int] - the first array of integers :param b: List[int] - the second array of integers :return: int - the length of the longest common subarray n = len(a) # dp table will hold the lengths of the longest common suffixes of substrings dp = [[0] * (n + 1) for _ in range(n + 1)] max_length = 0 for i in range(1, n + 1): for j in range(1, n + 1): if a[i - 1] == b[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_length = max(max_length, dp[i][j]) return max_length"},{"question":"def can_buy_notebooks_and_pens(M: int) -> str: Determines if it is possible to buy a combination of notebooks and pens that costs exactly M dollars. Args: M (int): The total amount of money in dollars. Returns: str: \\"Yes\\" if it is possible to buy the notebooks and pens for exactly M dollars, otherwise \\"No\\". >>> can_buy_notebooks_and_pens(14) \\"Yes\\" >>> can_buy_notebooks_and_pens(30) \\"Yes\\" >>> can_buy_notebooks_and_pens(2) \\"No\\" >>> can_buy_notebooks_and_pens(5) \\"Yes\\" >>> can_buy_notebooks_and_pens(9) \\"Yes\\" >>> can_buy_notebooks_and_pens(13) \\"No\\" >>> can_buy_notebooks_and_pens(18) \\"Yes\\" >>> can_buy_notebooks_and_pens(57) \\"Yes\\" >>> can_buy_notebooks_and_pens(1) \\"No\\"","solution":"def can_buy_notebooks_and_pens(M): Determines if it is possible to buy a combination of notebooks and pens that costs exactly M dollars. for i in range(M // 5 + 1): if (M - i * 5) % 9 == 0: return \\"Yes\\" return \\"No\\""},{"question":"def is_balanced(binary_string: str) -> str: Returns \\"YES\\" if the binary string can be rearranged to make it balanced, otherwise \\"NO\\". def check_balanced_binary_strings(T: int, binary_strings: List[str]) -> List[str]: For each binary string in binary_strings list, returns the list of results determining if they can be rearranged to make balanced. # For T test cases, where binary_strings are the list of binary strings # Example usage: # >>> check_balanced_binary_strings(4, [\\"1100\\", \\"1010\\", \\"1001\\", \\"0110\\"]) # [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] # Unit Test Cases: def test_case_all_balanced(): assert check_balanced_binary_strings(4, [\\"1100\\", \\"1010\\", \\"1001\\", \\"0110\\"]) == [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] def test_case_all_unbalanced(): assert check_balanced_binary_strings(3, [\\"1111\\", \\"0000\\", \\"1110\\"]) == [\\"NO\\", \\"NO\\", \\"NO\\"] def test_case_mixed(): assert check_balanced_binary_strings(4, [\\"1100\\", \\"1111\\", \\"1010\\", \\"1000\\"]) == [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"] def test_case_single_character(): assert check_balanced_binary_strings(2, [\\"0\\", \\"1\\"]) == [\\"NO\\", \\"NO\\"] def test_case_equal_ones_and_zeros(): assert check_balanced_binary_strings(2, [\\"1010\\", \\"0101\\"]) == [\\"YES\\", \\"YES\\"]","solution":"def is_balanced(binary_string): Returns \\"YES\\" if the binary string can be rearranged to make it balanced, otherwise \\"NO\\". count_0 = binary_string.count('0') count_1 = binary_string.count('1') return \\"YES\\" if count_0 == count_1 else \\"NO\\" def check_balanced_binary_strings(T, binary_strings): For each binary string in binary_strings list, returns the list of results determining if they can be rearranged to make balanced. results = [] for binary_string in binary_strings: results.append(is_balanced(binary_string)) return results"},{"question":"def count_substring_occurrences(S, T): Returns the number of times the substring T appears in the string S. Overlapping occurrences are counted. :param S: str, the mixed tray of cookies. :param T: str, the specific cookie taste profile. :return: int, the number of times T appears in S. >>> count_substring_occurrences(\\"ababcabcab\\", \\"abc\\") 2 >>> count_substring_occurrences(\\"aaaaaa\\", \\"aaa\\") 4 >>> count_substring_occurrences(\\"abcdefg\\", \\"hij\\") 0 >>> count_substring_occurrences(\\"aaaaaa\\", \\"a\\") 6 >>> count_substring_occurrences(\\"aabaab\\", \\"aab\\") 2 >>> count_substring_occurrences(\\"test\\", \\"test\\") 1 >>> count_substring_occurrences(\\"abababab\\", \\"ab\\") 4","solution":"def count_substring_occurrences(S, T): Returns the number of times the substring T appears in the string S. Overlapping occurrences are counted. :param S: str, the mixed tray of cookies. :param T: str, the specific cookie taste profile. :return: int, the number of times T appears in S. # Initialize the occurrence count count = 0 # Start searching from the beginning of the string S start = 0 # While we can find the substring T in S starting from 'start' while True: start = S.find(T, start) if start == -1: # No more occurrences found break count += 1 # Move the start position to the next character after the current match start += 1 return count"},{"question":"def shortest_path(N: int, M: int, sx: int, sy: int, tx: int, ty: int, grid: List[List[int]]) -> int: Determines if there is a path from the starting point (sx, sy) to the target point (tx, ty) in a 2D grid and returns the length of the shortest path. Returns -1 if no such path exists. >>> shortest_path(5, 5, 0, 0, 4, 4, [ ... [0, 0, 0, 0, 1], ... [1, 1, 1, 0, 0], ... [0, 0, 0, 0, 0], ... [1, 0, 0, 1, 0], ... [1, 1, 0, 0, 0] ... ]) == 8 >>> shortest_path(4, 4, 0, 0, 3, 3, [ ... [0, 1, 0, 0], ... [0, 1, 0, 1], ... [0, 0, 0, 1], ... [1, 1, 1, 0] ... ]) == -1 >>> shortest_path(3, 3, 0, 0, 2, 2, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 4 >>> shortest_path(3, 3, 0, 0, 2, 2, [ ... [0, 1, 0], ... [1, 1, 1], ... [0, 1, 0] ... ]) == -1 >>> shortest_path(3, 3, 0, 0, 2, 2, [ ... [0, 1, 0], ... [0, 1, 1], ... [0, 0, 0] ... ]) == 4","solution":"from collections import deque def shortest_path(N, M, sx, sy, tx, ty, grid): Returns the length of the shortest path from (sx, sy) to (tx, ty) in the grid. If no such path exists, returns -1. # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Initialize a queue with the starting point and distance queue = deque([(sx, sy, 0)]) # Initialize a set to keep track of visited cells visited = set((sx, sy)) while queue: x, y, dist = queue.popleft() # If we reached the target point if x == tx and y == ty: return dist # Explore all possible moves for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"class UniqueIntegerCollection: A class to manage a collection of unique integers with operations to add, remove, and check for containment. Methods: add(x): Adds integer x to the collection if it is not already present. remove(x): Removes integer x from the collection if it exists. contains(x): Checks if integer x is present in the collection. >>> operations = ['add 5', 'add 10', 'remove 5', 'contains 5', 'contains 10', 'add 10', 'contains 10'] >>> manage_collection(operations) ['false', 'true', 'true'] >>> operations = ['add 1', 'add 2', 'add 3', 'remove 2', 'contains 1', 'contains 2', 'contains 3', 'remove 3', 'contains 3'] >>> manage_collection(operations) ['true', 'false', 'true', 'false'] def __init__(self): self.collection = set() def add(self, x): self.collection.add(x) def remove(self, x): self.collection.discard(x) def contains(self, x): return x in self.collection def manage_collection(operations): unique_collection = UniqueIntegerCollection() results = [] for operation in operations: op = operation.split() if op[0] == 'add': unique_collection.add(int(op[1])) elif op[0] == 'remove': unique_collection.remove(int(op[1])) elif op[0] == 'contains': results.append('true' if unique_collection.contains(int(op[1])) else 'false') return results","solution":"class UniqueIntegerCollection: def __init__(self): self.collection = set() def add(self, x): self.collection.add(x) def remove(self, x): self.collection.discard(x) def contains(self, x): return x in self.collection def manage_collection(operations): unique_collection = UniqueIntegerCollection() results = [] for operation in operations: op = operation.split() if op[0] == 'add': unique_collection.add(int(op[1])) elif op[0] == 'remove': unique_collection.remove(int(op[1])) elif op[0] == 'contains': results.append('true' if unique_collection.contains(int(op[1])) else 'false') return results"},{"question":"def largest_prime_product(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Alisha wants to find the largest number that can be formed using exactly K distinct primes from the list of N primes. The function takes an integer T representing the number of test cases, and a list of tuples where each tuple contains: 1. An integer N representing the number of prime numbers, 2. An integer K representing the number of primes to be used to form the largest number, 3. A list of N prime numbers. The function returns a list of integers where each integer is the largest number possible for the respective test case. If it is not possible to select exactly K primes from the list, the result should be -1. >>> largest_prime_product(2, [(5, 3, [2, 3, 5, 7, 11]), (4, 2, [13, 11, 7, 5])]) [385, 143] >>> largest_prime_product(1, [(3, 4, [2, 3, 5])]) [-1] pass # Test cases to validate the solution import pytest def test_case_one(): T = 2 test_cases = [ (5, 3, [2, 3, 5, 7, 11]), (4, 2, [13, 11, 7, 5]) ] expected = [385, 143] assert largest_prime_product(T, test_cases) == expected def test_case_two(): T = 1 test_cases = [ (5, 5, [2, 3, 5, 7, 11]) ] expected = [2310] assert largest_prime_product(T, test_cases) == expected def test_case_three(): T = 1 test_cases = [ (3, 4, [2, 3, 5]) ] expected = [-1] assert largest_prime_product(T, test_cases) == expected def test_case_four(): T = 1 test_cases = [ (4, 1, [13, 11, 7, 5]) ] expected = [13] assert largest_prime_product(T, test_cases) == expected def test_case_five(): T = 1 test_cases = [ (6, 3, [19, 17, 13, 11, 7, 5]) ] expected = [4199] assert largest_prime_product(T, test_cases) == expected","solution":"def largest_prime_product(T, test_cases): result = [] for case in test_cases: N, K, primes = case if K > N: result.append(-1) continue primes.sort(reverse=True) product = 1 for i in range(K): product *= primes[i] result.append(product) return result"},{"question":"def shortest_subsequence_length(sequence): Find the length of the shortest sub-sequence in the given sequence that includes every unique number exactly once. >>> shortest_subsequence_length([2, 1, 1, 3, 2, 4, 3]) 4 >>> shortest_subsequence_length([1, 2, 4, 2, 1]) 3 def process_test_cases(t, test_cases): For each test case, find the length of the shortest sub-sequence that includes every unique number in the given sequence exactly once. >>> t = 2 >>> test_cases = [ ... (7, [2, 1, 1, 3, 2, 4, 3]), ... (5, [1, 2, 4, 2, 1]) ... ] >>> process_test_cases(t, test_cases) [4, 3]","solution":"def shortest_subsequence_length(sequence): unique_elements = set(sequence) unique_count = len(unique_elements) count_dict = {} left = 0 min_length = float('inf') for right in range(len(sequence)): count_dict[sequence[right]] = count_dict.get(sequence[right], 0) + 1 while len(count_dict) == unique_count: min_length = min(min_length, right - left + 1) count_dict[sequence[left]] -= 1 if count_dict[sequence[left]] == 0: del count_dict[sequence[left]] left += 1 return min_length def process_test_cases(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] sequence = test_cases[i][1] results.append(shortest_subsequence_length(sequence)) return results"},{"question":"class ParkingLot: A class to manage a parking lot system with the following operations: 1. Park a car in a specified space. 2. Remove a car from a specified space. 3. Check if a specified space is occupied or vacant. 4. Find the nearest vacant space from a given starting point (searching either to the left or right). Example usage: >>> lot = ParkingLot() >>> lot.park(10) >>> lot.check(10) 'Occupied' >>> lot.check(30) 'Vacant' >>> lot.remove(10) >>> lot.check(10) 'Vacant' >>> lot.nearest(15, 'R') 16 def __init__(self): self.spaces = [False] * 10000 def park(self, x): pass def remove(self, x): pass def check(self, x): pass def nearest(self, x, d): pass import pytest def test_park_and_check(): lot = ParkingLot() lot.park(10) lot.park(20) assert lot.check(10) == \\"Occupied\\" assert lot.check(20) == \\"Occupied\\" assert lot.check(30) == \\"Vacant\\" def test_remove_and_check(): lot = ParkingLot() lot.park(10) lot.remove(10) assert lot.check(10) == \\"Vacant\\" def test_nearest_right(): lot = ParkingLot() lot.park(15) lot.park(16) assert lot.nearest(10, 'R') == 11 assert lot.nearest(15, 'R') == 17 lot.park(17) assert lot.nearest(15, 'R') == 18 def test_nearest_left(): lot = ParkingLot() lot.park(15) lot.park(14) assert lot.nearest(20, 'L') == 19 assert lot.nearest(15, 'L') == 13 lot.park(13) assert lot.nearest(15, 'L') == 12 @pytest.mark.parametrize(\\"start, direction, expected\\", [ (15, 'R', 16), (9999, 'R', \\"None\\"), (0, 'L', \\"None\\"), ]) def test_edge_cases(start, direction, expected): lot = ParkingLot() lot.park(15) assert lot.nearest(start, direction) == expected","solution":"class ParkingLot: def __init__(self): self.spaces = [False] * 10000 def park(self, x): self.spaces[x] = True def remove(self, x): self.spaces[x] = False def check(self, x): return \\"Occupied\\" if self.spaces[x] else \\"Vacant\\" def nearest(self, x, d): if d == 'L': for i in range(x-1, -1, -1): if not self.spaces[i]: return i elif d == 'R': for i in range(x+1, 10000): if not self.spaces[i]: return i return \\"None\\""},{"question":"def kth_term_sequence(k: int) -> int: Determines the k-th term in the sequence where each term is the smallest positive integer that is coprime with all previous terms. >>> kth_term_sequence(1) 1 >>> kth_term_sequence(7) 7 >>> kth_term_sequence(25) 25","solution":"def kth_term_sequence(k): Returns the k-th term of the sequence where each term is the smallest positive integer that is coprime with all previous terms. return k"},{"question":"def min_walking_distance(n, coordinates): Determines the minimum walking distance needed to collect all shiny objects. Given the number of shiny objects and their coordinates with the shine factor, this function returns the minimum total distance to travel to collect all objects. Examples: >>> min_walking_distance(3, [[0, 0, 3], [0, 2, 1], [2, 2, 2]]) 4 >>> min_walking_distance(1, [[0, 0, 1]]) 0 >>> min_walking_distance(2, [[0, 0, 1], [2, 2, 2]]) 4","solution":"def min_walking_distance(n, coordinates): Determines the minimum walking distance needed to collect all shiny objects. This problem can be thought of as the Travelling Salesman Problem, for simplicity we'll use a naive, yet feasible approach due to the small constraints (n <= 1000). from itertools import permutations # Create a function to calculate the walking distance between two points def distance(p1, p2): return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) # Store just the coordinates of the shiny objects points = [(coord[0], coord[1]) for coord in coordinates] # Calculate the minimal walk distance using brute force permutation approach min_distance = float('inf') for perm in permutations(points): total_dist = sum(distance(perm[i], perm[i+1]) for i in range(n-1)) min_distance = min(min_distance, total_dist) return min_distance"},{"question":"def max_gold_coins(n: int, gold_coins: List[int], m: int, passages: List[Tuple[int, int]], start: int) -> int: Calculate the maximum number of gold coins Zara can collect starting from the given room. >>> n = 4 >>> gold_coins = [6, 9, 5, 7] >>> m = 5 >>> passages = [(1, 2), (2, 3), (3, 1), (3, 4), (4, 2)] >>> start = 1 >>> max_gold_coins(n, gold_coins, m, passages, start) 27","solution":"def max_gold_coins(n, gold_coins, m, passages, start): from collections import defaultdict, deque graph = defaultdict(list) for u, v in passages: graph[u].append(v) max_gold = 0 def dfs(room, collected_gold, visited): nonlocal max_gold visited.add(room) collected_gold += gold_coins[room-1] max_gold = max(max_gold, collected_gold) for next_room in graph[room]: if next_room not in visited: dfs(next_room, collected_gold, visited) visited.remove(room) dfs(start, 0, set()) return max_gold"},{"question":"from typing import List, Tuple def calculate_total_xp(quest_log: List[Tuple[str, int]]) -> int: Calculate total XP earned by the player given the quest log. :param quest_log: List of tuples containing outcome and XP value as (outcome, xp_value) :return: Total XP earned >>> calculate_total_xp([('Success', 50), ('Failure', 30), ('Critical Success', 20)]) == 90 >>> calculate_total_xp([('Success', 100), ('Critical Success', 40)]) == 180 pass def read_quest_logs(input_logs: str) -> List[int]: Read quest logs from the input and calculate the total XP for each dataset. :param input_logs: Multiline string where each dataset contains quest outcome and XP value :return: List of total XP for each dataset >>> input_logs = \\"3nSuccess 50nFailure 30nCritical Success 20nn2nSuccess 100nCritical Success 40nn0n\\" >>> read_quest_logs(input_logs) == [90, 180] pass","solution":"def calculate_total_xp(quest_log): Calculate total XP earned by the player given the quest log. :param quest_log: List of tuples containing outcome and XP value as (outcome, xp_value) :return: Total XP earned total_xp = 0 for outcome, xp in quest_log: if outcome == 'Success': total_xp += xp elif outcome == 'Critical Success': total_xp += 2 * xp # 'Failure' adds 0 XP, so no need to handle it explicitly return total_xp def read_quest_logs(input_logs): Read quest logs from the input and calculate the total XP for each dataset. :param input_logs: Multiline string where each dataset contains quest outcome and XP value :return: List of total XP for each dataset results = [] datasets = input_logs.strip().split(\\"nn\\") for dataset in datasets: lines = dataset.split('n') n = int(lines[0]) if n == 0: continue quest_log = [] for i in range(1, n + 1): outcome, xp = lines[i].rsplit(' ', 1) quest_log.append((outcome, int(xp))) total_xp = calculate_total_xp(quest_log) results.append(total_xp) return results"},{"question":"def smallest_substring_lengths(s: str, queries: List[str]) -> List[int]: Returns a list of the lengths of smallest substrings in 's' that contain the characters in 'queries'. >>> smallest_substring_lengths(\\"abcabc\\", [\\"a\\", \\"b\\", \\"c\\"]) [1, 1, 1] >>> smallest_substring_lengths(\\"hello\\", [\\"h\\", \\"e\\"]) [1, 1] >>> smallest_substring_lengths(\\"abc\\", [\\"d\\"]) [-1] >>> smallest_substring_lengths(\\"example\\", [\\"a\\", \\"a\\"]) [1, 1] def process_test_cases(t: int, test_cases: List[Tuple[str, int, List[str]]]) -> List[int]: Processes multiple test cases to find the lengths of the smallest substrings for each character query. >>> process_test_cases(2, [(\\"abcabc\\", 3, [\\"a\\", \\"b\\", \\"c\\"]), (\\"hello\\", 2, [\\"h\\", \\"e\\"])]) [1, 1, 1, 1, 1] >>> process_test_cases(2, [(\\"abcabc\\", 4, [\\"a\\", \\"b\\", \\"c\\", \\"d\\"]), (\\"hello\\", 3, [\\"h\\", \\"e\\", \\"z\\"])]) [1, 1, 1, -1, 1, 1, -1]","solution":"def smallest_substring_lengths(s, queries): Returns a list of the lengths of smallest substrings in 's' that contain the characters in 'queries'. # Dictionary to store the smallest length for each character char_lengths = {} for char in queries: if char in char_lengths: continue # We look for the given character in the string index = s.find(char) if index == -1: char_lengths[char] = -1 else: char_lengths[char] = 1 # Generate the result list based on queries order result = [char_lengths[char] for char in queries] return result def process_test_cases(t, test_cases): results = [] for i in range(t): s, q, queries = test_cases[i] result = smallest_substring_lengths(s, queries) results.extend(result) return results"},{"question":"import heapq from typing import List def minimum_cost_to_combine_rods(N: int, rods: List[int]) -> int: Returns the minimum cost to combine all the rods into one single rod. :param N: int, the number of rods. :param rods: List[int], the lengths of the rods. :return: int, the minimum cost to combine all the rods. # Your code here # Unit Test def test_example_case(): assert minimum_cost_to_combine_rods(4, [4, 3, 2, 6]) == 29 def test_single_rod(): assert minimum_cost_to_combine_rods(1, [5]) == 0 def test_two_rods(): assert minimum_cost_to_combine_rods(2, [1, 2]) == 3 def test_identical_lengths(): assert minimum_cost_to_combine_rods(3, [1, 1, 1]) == 5 def test_different_lengths(): assert minimum_cost_to_combine_rods(3, [8, 4, 6]) == 28 def test_large_case(): import random rods = [random.randint(1, 10**4) for _ in range(1000)] assert minimum_cost_to_combine_rods(1000, rods) # No exact number to assert, just to ensure it runs","solution":"import heapq def minimum_cost_to_combine_rods(N, rods): Returns the minimum cost to combine all the rods into one single rod. :param N: int, the number of rods. :param rods: List[int], the lengths of the rods. :return: int, the minimum cost to combine all the rods. # Use a min-heap to always combine the two smallest rods first heapq.heapify(rods) total_cost = 0 while len(rods) > 1: # Pop two smallest elements first_min = heapq.heappop(rods) second_min = heapq.heappop(rods) # The cost to combine them is the sum of their lengths combined_length = first_min + second_min total_cost += combined_length # Push the combined rod back into the heap heapq.heappush(rods, combined_length) return total_cost"},{"question":"def min_possible_beauty(n: int, k: int, s: str) -> int: Calculates the minimum possible beauty of any substring from \`s\` with at most \`k\` changes. Parameters: n (int): The length of the string. k (int): The number of allowed changes. s (str): The input string consisting of uppercase letters. Returns: int: The minimum possible beauty of any substring. pass def test_example_1(): assert min_possible_beauty(5, 1, \\"ABABA\\") == 1 def test_example_2(): assert min_possible_beauty(6, 2, \\"AABCCD\\") == 1 def test_example_3(): assert min_possible_beauty(4, 0, \\"ABCD\\") == 1 def test_no_changes_allowed(): assert min_possible_beauty(7, 0, \\"ABCDEFG\\") == 1 def test_all_same_characters(): assert min_possible_beauty(4, 1, \\"AAAA\\") == 1 def test_large_k_value(): assert min_possible_beauty(5, 5, \\"ABCDE\\") == 1 def test_minimal_input(): assert min_possible_beauty(1, 1, \\"A\\") == 1","solution":"def min_possible_beauty(n, k, s): Calculates the minimum possible beauty of any substring from \`s\` with at most \`k\` changes. Parameters: n (int): The length of the string. k (int): The number of allowed changes. s (str): The input string consisting of uppercase letters. Returns: int: The minimum possible beauty of any substring. return 1"},{"question":"def min_abs_difference(N: int, array: List[int]) -> int: Find the minimum absolute difference between the sum of two subsets formed from these integers. If it is not possible to form such subsets, return -1. >>> min_abs_difference(3, [1, 2, 3]) 0 >>> min_abs_difference(4, [1, 2, 3, 9]) 3 >>> min_abs_difference(2, [-7, -3]) 4 >>> min_abs_difference(1, [5]) -1","solution":"def min_abs_difference(N, array): if N == 1: return -1 total_sum = sum(array) subset_sums = set() for i in range(1 << N): # Generate all subset sums using bit masking subset_sum = 0 for j in range(N): if i & (1 << j): # If jth bit in i is set, include array[j] subset_sum += array[j] subset_sums.add(subset_sum) min_diff = float('inf') for subset_sum in subset_sums: min_diff = min(min_diff, abs(total_sum - 2 * subset_sum)) return min_diff"},{"question":"def distinct_count_in_range(arr, queries): Given an array of integers and a list of queries, return the count of distinct integers in the subarray for each query range [l, r]. INPUT arr: List[int] a list of integers representing the array. queries: List[Tuple[int, int]] a list of queries, each represented by a tuple of two integers (l, r), indicating the subarray range. OUTPUT List[int] a list of counts of distinct integers for each query range. >>> distinct_count_in_range([1, 2, 1, 3, 2], [(1, 3), (2, 4), (1, 5)]) [2, 3, 3] >>> distinct_count_in_range([1], [(1, 1)]) [1] >>> distinct_count_in_range([1, 1, 1, 1], [(1, 4), (2, 3)]) [1, 1] >>> distinct_count_in_range([1, 2, 3, 4, 5], []) [] >>> distinct_count_in_range([1, 2, 3, 4, 5], [(1, 2), (3, 4)]) [2, 2]","solution":"def distinct_count_in_range(arr, queries): # array of unique counts generated for each index from collections import defaultdict n = len(arr) last_seen = {} next_occurrence = [n] * n # back to front to quickly lookup the next occurrence of each element for idx in reversed(range(n)): item = arr[idx] if item in last_seen: next_occurrence[idx] = last_seen[item] last_seen[item] = idx # Creating segment tree class SegmentTree: def __init__(self, array): self.n = len(array) self.tree = [0] * (2 * self.n) for i in range(self.n): self.tree[self.n + i] = array[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, pos, value): pos += self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def range_sum(self, left, right): left += self.n right += self.n s = 0 while left < right: if left % 2 == 1: s += self.tree[left] left += 1 if right % 2 == 1: right -= 1 s += self.tree[right] left //= 2 right //= 2 return s st = SegmentTree([0] * n) # Initialize result result = [] # Process each query for l, r in queries: l -= 1 r -= 1 # cover the range l to r for i in range(l, r + 1): if next_occurrence[i] > r: # If the next occurrence is outside the range st.update(i, 1) else: st.update(i, 0) result.append(st.range_sum(l, r + 1)) # Revert back the changes for i in range(l, r + 1): st.update(i, 0) return result # Example usage: arr = [1, 2, 1, 3, 2] queries = [(1, 3), (2, 4), (1, 5)] result = distinct_count_in_range(arr, queries) for res in result: print(res) # Output: 2 3 3"},{"question":"from typing import List def max_path_sum(grid: List[List[int]]) -> int: You are given a grid of size n × m filled with integers. Your task is to find the maximum sum of elements you can obtain by following these rules: 1. You start at any cell in the first row. 2. You can move to the cell directly below or to the cell that is diagonally below on the left or the right. 3. You must always move to the row immediately below the current cell until you reach the last row. Write a function \`max_path_sum(grid: List[List[int]]) -> int\` that computes the maximum sum possible following the above rules. >>> grid = [ ... [2, 1, 3], ... [6, 5, 4], ... [7, 8, 9] ... ] >>> max_path_sum(grid) 17 >>> grid = [ ... [3, 1, 3, 4], ... [8, 7, 4, 2], ... [6, 10, 8, 7], ... ] >>> max_path_sum(grid) 21 pass def test_max_path_sum_small_grid(): grid = [ [2, 1, 3], [6, 5, 4], [7, 8, 9] ] assert max_path_sum(grid) == 17 def test_max_path_sum_single_element(): grid = [ [10] ] assert max_path_sum(grid) == 10 def test_max_path_sum_long_vertical_grid(): grid = [ [1], [2], [3], [4], [5] ] assert max_path_sum(grid) == 15 def test_max_path_sum_long_horizontal_grid(): grid = [ [1, 2, 3, 4, 5] ] assert max_path_sum(grid) == 5 def test_max_path_sum_large_grid(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], ] assert max_path_sum(grid) == 45 def test_max_path_sum_another_case(): grid = [ [3, 1, 3, 4], [8, 7, 4, 2], [6, 10, 8, 7], ] assert max_path_sum(grid) == 21","solution":"from typing import List def max_path_sum(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) # copy the first row to start forming the solution dp = grid[0][:] # iterate over each row starting from the second row for i in range(1, n): new_dp = [0] * m # Create new dp array for the current row for j in range(m): # iterate over each column of the current row # take value from directly above max_sum = dp[j] # take value from the left diagonal, if it exists if j > 0: max_sum = max(max_sum, dp[j - 1]) # take value from the right diagonal, if it exists if j < m - 1: max_sum = max(max_sum, dp[j + 1]) # store the calculated max path sum for this cell new_dp[j] = grid[i][j] + max_sum # update dp to be the new_dp array for the next iteration dp = new_dp # the max path sum will be the maximum value in the last dp array return max(dp)"},{"question":"def is_palindrome(s: str) -> bool: Determine if a given string is a valid palindrome, ignoring non-alphanumeric characters and case differences. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False","solution":"def is_palindrome(s: str) -> bool: Returns True if the given string is a palindrome, ignoring non-alphanumeric characters and case differences. # Filter out non-alphanumeric characters and convert the rest to lowercase cleaned = ''.join(char.lower() for char in s if char.isalnum()) # Check if the cleaned string is the same forwards and backwards return cleaned == cleaned[::-1]"},{"question":"from typing import List def max_product_after_changes(nums: List[int], k: int) -> int: You are given a list of integers and an integer k. You can make at most k changes to the list. In one change, you can select a subarray (contiguous segment) of length at most 2, and reverse it. You need to find the maximum possible value of the product of the elements in the list after making at most k changes. Parameters: nums (List[int]): The list of integers. k (int): The maximum number of allowed changes. Returns: int: The maximum possible value of the product of the elements. Example: >>> max_product_after_changes([1, 2, 3, 4, 5], 2) 120 pass def test_max_product_no_changes(): assert max_product_after_changes([1, 2, 3, 4, 5], 0) == 120 def test_max_product_single_element(): assert max_product_after_changes([100], 2) == 100 def test_max_product_one_change(): assert max_product_after_changes([1, 2, 3, 4, 5], 1) == 120 def test_max_product_two_changes(): assert max_product_after_changes([1, 2, 3, 4, 5], 2) == 120 def test_max_product_mixed_values(): assert max_product_after_changes([1, -2, 3, -4, 5], 2) == 120 def test_max_product_large_k(): assert max_product_after_changes([1, -2, 3, -4, 5], 10) == 120","solution":"def max_product_after_changes(nums, k): Returns the maximum possible product of the list after making at most k changes. n = len(nums) if k == 0: # No changes allowed, return the product of current list. result = 1 for num in nums: result *= num return result if n == 1: # If list contains only one element, the product is the element itself. return nums[0] def product(lst): result = 1 for num in lst: result *= num return result max_product = float('-inf') for i in range(n): for j in range(i, min(i+2, n)): new_list = nums[:i] + nums[i:j+1][::-1] + nums[j+1:] max_product = max(max_product, product(new_list)) return max_product"},{"question":"def beautify_garden(n: int, flower_data: List[str]) -> str: Rearranges flowers in such a way that no two adjacent flowers are of the same type and the arrangement is lexicographically smallest. If it is not possible, returns \\"Not possible\\". Parameters: n (int): The number of flowers. flower_data (List[str]): List of flower types and heights. Returns: str: The rearranged sequence or \\"Not possible\\". Examples: >>> beautify_garden(5, [\\"a\\", \\"3\\", \\"b\\", \\"1\\", \\"a\\", \\"2\\", \\"c\\", \\"1\\", \\"a\\", \\"1\\"]) \\"a 1 b 1 a 3 c 1 a 2\\" >>> beautify_garden(4, [\\"a\\", \\"1\\", \\"a\\", \\"2\\", \\"a\\", \\"3\\", \\"a\\", \\"4\\"]) \\"Not possible\\" # Your code here def test_flower_rearrangement(): assert beautify_garden(5, [\\"a\\", \\"3\\", \\"b\\", \\"1\\", \\"a\\", \\"2\\", \\"c\\", \\"1\\", \\"a\\", \\"1\\"]) in [ \\"a 3 b 1 a 2 c 1 a 1\\", \\"a 2 b 1 a 3 c 1 a 1\\", \\"a 1 b 1 a 3 c 1 a 2\\" ] assert beautify_garden(4, [\\"a\\", \\"1\\", \\"a\\", \\"2\\", \\"a\\", \\"3\\", \\"a\\", \\"4\\"]) == \\"Not possible\\" assert beautify_garden(6, [\\"b\\", \\"2\\", \\"b\\", \\"3\\", \\"b\\", \\"4\\", \\"a\\", \\"1\\", \\"a\\", \\"2\\", \\"a\\", \\"3\\"]) in [ \\"a 1 b 2 a 2 b 3 a 3 b 4\\", ] assert beautify_garden(3, [\\"a\\", \\"1\\", \\"b\\", \\"2\\", \\"a\\", \\"2\\"]) in [ \\"a 1 b 2 a 2\\", ] assert beautify_garden(3, [\\"a\\", \\"1\\", \\"a\\", \\"2\\", \\"c\\", \\"3\\"]) in [ \\"a 1 c 3 a 2\\", \\"a 2 c 3 a 1\\" ]","solution":"from collections import Counter import heapq def rearrange_flowers(n, flowers): # Count frequencies and store flowers information flower_count = Counter(flowers[i][0] for i in range(n)) max_freq = max(flower_count.values()) # If any flower appears more than (n + 1) // 2 times, it's impossible if max_freq > (n + 1) // 2: return \\"Not possible\\" # Create a max heap based on flower counts (-count for max heap in python) max_heap = [] for flower in flower_count: heapq.heappush(max_heap, (-flower_count[flower], flower)) result = [] prev_f, prev_char = 0, '' while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_f < 0: heapq.heappush(max_heap, (prev_f, prev_char)) prev_f, prev_char = freq + 1, char # decrease frequency by 1 return result def beautify_garden(n, flower_data): flowers = [(flower_data[i], int(flower_data[i + 1])) for i in range(0, 2 * n, 2)] flower_types = ''.join(flower_data[i] for i in range(0, 2 * n, 2)) rearranged_types = rearrange_flowers(n, flowers) if rearranged_types == \\"Not possible\\": return \\"Not possible\\" rearranged_flowers = [] flower_data_indices = {char: [] for char in set(flower_types)} for i, (char, height) in enumerate(flowers): flower_data_indices[char].append(i) rearranged = [] for char in rearranged_types: indices = flower_data_indices[char].pop(0) rearranged.append(f\\"{char} {flowers[indices][1]}\\") return \\" \\".join(rearranged) def solve(): n = int(input().strip()) flower_data = input().strip().split() result = beautify_garden(n, flower_data) print(result)"},{"question":"def minimum_spanning_tree(n, edges): Returns the total weight of the Minimum Spanning Tree (MST) of a graph. :param n: The number of nodes in the graph :param edges: A list of tuples representing the edges of the graph (u, v, w) :return: The total weight of the MST >>> minimum_spanning_tree(4, [(1, 2, 3), (1, 3, 1), (4, 2, 2), (4, 3, 4)]) 6 >>> minimum_spanning_tree(1, []) 0 >>> minimum_spanning_tree(2, [(1, 2, 10)]) 10 >>> minimum_spanning_tree(3, [(1, 2, 1), (2, 3, 2), (1, 3, 3)]) 3 >>> minimum_spanning_tree(5, [(1, 2, 4), (1, 3, 3), (2, 4, 2), (3, 4, 5), (3, 5, 1), (4, 5, 7)]) 10 pass","solution":"import heapq def minimum_spanning_tree(n, edges): Returns the total weight of the Minimum Spanning Tree (MST) of a graph. :param n: The number of nodes in the graph :param edges: A list of tuples representing the edges of the graph (u, v, w) :return: The total weight of the MST def prim(start, graph): visited = [False] * (n + 1) min_heap = [(0, start)] # (weight, node) total_weight = 0 edges_in_mst = 0 while min_heap and edges_in_mst < n: weight, u = heapq.heappop(min_heap) if visited[u]: continue visited[u] = True total_weight += weight edges_in_mst += 1 for v, w in graph[u]: if not visited[v]: heapq.heappush(min_heap, (w, v)) return total_weight # Build the graph adjacency list graph = [[] for _ in range(n + 1)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Run Prim's algorithm from node 1 return prim(1, graph)"},{"question":"def simple_calculator(commands): Simulates a simple calculator capable of performing basic arithmetic operations. The program should read a sequence of commands in the format \`OPERATOR OPERAND1 OPERAND2\`, where \`OPERATOR\` is one of the following: add, sub, mul, div. For each command, print the result of the operation. The program should stop processing input when it encounters the command \`end\`. >>> simple_calculator([\\"add 2 3\\", \\"end\\"]) [5] >>> simple_calculator([\\"sub 10 4\\", \\"end\\"]) [6] >>> simple_calculator([\\"mul 3 5\\", \\"end\\"]) [15] >>> simple_calculator([\\"div 8 2\\", \\"end\\"]) [4] >>> simple_calculator([\\"add 2 3\\", \\"sub 10 4\\", \\"mul 3 5\\", \\"div 8 2\\", \\"end\\"]) [5, 6, 15, 4] >>> simple_calculator([\\"unknown 2 3\\", \\"end\\"]) ValueError: \\"Unknown operator\\"","solution":"def simple_calculator(commands): Simulates a simple calculator capable of performing basic arithmetic operations. results = [] for command in commands: parts = command.split() if parts[0] == \\"end\\": break operator, operand1, operand2 = parts[0], float(parts[1]), float(parts[2]) if operator == \\"add\\": results.append(operand1 + operand2) elif operator == \\"sub\\": results.append(operand1 - operand2) elif operator == \\"mul\\": results.append(operand1 * operand2) elif operator == \\"div\\": results.append(operand1 / operand2) else: raise ValueError(\\"Unknown operator\\") return results"},{"question":"def is_prime(n: int) -> bool: Check if a given number is a prime number. >>> is_prime(2) True >>> is_prime(4) False # Your implementation here pass def find_prime_ids(participant_ids: List[int]) -> List[Union[int, str]]: Given a list of participant IDs, return a list of IDs that are prime numbers, or [\\"No prime IDs found\\"] if there are none. >>> find_prime_ids([23, 29, 15, 18, 10]) [23, 29] >>> find_prime_ids([15, 18, 10, 20]) ['No prime IDs found'] # Your implementation here pass # Unit tests def test_is_prime(): assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(17) == True assert is_prime(18) == False assert is_prime(1) == False def test_find_prime_ids(): assert find_prime_ids([23, 29, 15, 18, 10]) == [23, 29] assert find_prime_ids([15, 18, 10, 20]) == [\\"No prime IDs found\\"] assert find_prime_ids([2, 4, 6, 7, 22]) == [2, 7] assert find_prime_ids([5]) == [5] assert find_prime_ids([1]) == [\\"No prime IDs found\\"] assert find_prime_ids([99991, 100000, 99989]) == [99991, 99989]","solution":"def is_prime(n): Helper function to determine if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False max_divisor = int(n**0.5) + 1 for d in range(3, max_divisor, 2): if n % d == 0: return False return True def find_prime_ids(participant_ids): This function takes a list of participant IDs and returns a list of prime IDs. prime_ids = [ID for ID in participant_ids if is_prime(ID)] return prime_ids if prime_ids else [\\"No prime IDs found\\"] # Example usage: # participant_ids = [23, 29, 15, 18, 10] # result = find_prime_ids(participant_ids) # for ID in result: # print(ID)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTree(preorder: List[int], inorder: List[int]) -> TreeNode: Build a binary tree from preorder and inorder traversal arrays. Args: preorder (List[int]): Preorder traversal of the tree. inorder (List[int]): Inorder traversal of the tree. Returns: TreeNode: The root node of the constructed binary tree. Examples: >>> inorder_traversal(buildTree([3,9,20,15,7], [9,3,15,20,7])) [9, 3, 15, 20, 7] >>> inorder_traversal(buildTree([1,2,4,5,3,6,7], [4,2,5,1,6,3,7])) [4, 2, 5, 1, 6, 3, 7] # Your code here def inorder_traversal(root): if root is None: return [] return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) def test_buildTree(): preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] tree = buildTree(preorder, inorder) assert inorder_traversal(tree) == inorder def test_buildTree_with_balanced_tree(): preorder = [1,2,4,5,3,6,7] inorder = [4,2,5,1,6,3,7] tree = buildTree(preorder, inorder) assert inorder_traversal(tree) == inorder def test_buildTree_single_node(): preorder = [1] inorder = [1] tree = buildTree(preorder, inorder) assert inorder_traversal(tree) == inorder def test_buildTree_empty(): preorder = [] inorder = [] tree = buildTree(preorder, inorder) assert tree is None","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTree(preorder, inorder): if not preorder or not inorder: return None root_val = preorder[0] root = TreeNode(root_val) root_idx_inorder = inorder.index(root_val) root.left = buildTree(preorder[1:1+root_idx_inorder], inorder[:root_idx_inorder]) root.right = buildTree(preorder[1+root_idx_inorder:], inorder[root_idx_inorder+1:]) return root"},{"question":"from typing import List, Tuple def process_queries(queries: List[Tuple[int, ...]]) -> List[int]: You are given a list of integers, initially it is empty. Your task is to perform n queries on this list. There are three different types of queries: * 1 x — Add the integer x to the list. * 2 x — Remove one occurrence of the integer x from the list. If x does not exist in the list, do nothing. * 3 — Output the integer that appears the most in the list (most frequent). If there are multiple integers with the same highest frequency, output the smallest one. Input The first line contains one integer number n (1 ≤ n ≤ 105), the number of queries. Next n lines contain either two integers q, x (1 ≤ q ≤ 2, 1 ≤ x ≤ 105) or one integer q (q = 3) — the type of the query and its parameter(s), if applicable. Output Print the result of the third type query after each occurrence. Examples: >>> process_queries([(1, 3), (1, 3), (3,), (2, 3), (3,)]) [3, 3] >>> process_queries([(1, 3), (1, 7), (2, 3), (1, 5), (1, 5), (3,)]) [5]","solution":"from collections import Counter import heapq def process_queries(queries): count = Counter() freq_heap = [] result = [] for query in queries: if query[0] == 1: x = query[1] count[x] += 1 elif query[0] == 2: x = query[1] if count[x] > 0: count[x] -= 1 if count[x] == 0: del count[x] elif query[0] == 3: if count: max_freq = max(count.values()) candidates = [key for key in count.keys() if count[key] == max_freq] result.append(min(candidates)) else: result.append(None) return result"},{"question":"def organize_album(birds: List[str]) -> List[str]: Organizes the birds into groups of the same species maintaining the order of their first appearance in the input list. >>> organize_album(['sparrow', 'robin', 'sparrow', 'eagle', 'robin', 'eagle', 'falcon']) ['sparrow', 'sparrow', 'robin', 'robin', 'eagle', 'eagle', 'falcon'] >>> organize_album(['hawk', 'hawk', 'owl', 'owl', 'owl']) ['hawk', 'hawk', 'owl', 'owl', 'owl'] >>> organize_album(['eagle', 'hawk', 'owl']) ['eagle', 'hawk', 'owl'] >>> organize_album(['parrot', 'parrot', 'parrot']) ['parrot', 'parrot', 'parrot'] >>> organize_album([]) []","solution":"def organize_album(birds): Organizes the birds into groups of the same species maintaining the order of their first appearance in the input list. Parameters: birds (list): A list of strings where each string is the name of the bird species. Returns: list: A new list where the same species are grouped together, maintaining order of their first appearance. from collections import OrderedDict bird_dict = OrderedDict() for bird in birds: if bird in bird_dict: bird_dict[bird].append(bird) else: bird_dict[bird] = [bird] result = [] for group in bird_dict.values(): result.extend(group) return result # Example usage n = 7 birds = ['sparrow', 'robin', 'sparrow', 'eagle', 'robin', 'eagle', 'falcon'] print(' '.join(organize_album(birds)))"},{"question":"from typing import List, Tuple def is_prime(n: int) -> bool: Determine if a number is a prime number. pass def count_primes(arr: List[int]) -> int: Count the number of prime numbers in the list. pass def game_outcome(num_cases: int, cases: List[Tuple[int, List[int]]]) -> List[str]: Determine the winner of the game for each test case. >>> game_outcome(2, [(3, [2, 5, 7]), (4, [4, 6, 8, 9])]) [\\"Alice\\", \\"Bob\\"] >>> game_outcome(1, [(1, [2])]) [\\"Alice\\"] >>> game_outcome(1, [(4, [4, 6, 8, 9])]) [\\"Bob\\"] >>> game_outcome(1, [(3, [2, 5, 7])]) [\\"Alice\\"] >>> game_outcome(1, [(4, [2, 3, 5, 7])]) [\\"Bob\\"] >>> game_outcome(1, [(5, [4, 6, 8, 9, 11])]) [\\"Alice\\"]","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def count_primes(arr): return sum(1 for num in arr if is_prime(num)) def game_outcome(num_cases, cases): results = [] for case in cases: N, arr = case if count_primes(arr) % 2 == 1: results.append(\\"Alice\\") else: results.append(\\"Bob\\") return results"},{"question":"def determine_winner(n, elements): Determine the winner of the game. :param n: Integer, the number of elements in the list :param elements: List of integers, the elements in the list :return: String, \\"Alice\\" if Alice wins, otherwise \\"Bob\\" pass from solution import determine_winner def test_example_case(): assert determine_winner(5, [1, 2, 3, 4, 5]) == 'Alice' def test_single_element(): assert determine_winner(1, [10]) == 'Alice' assert determine_winner(1, [1]) == 'Alice' def test_even_elements(): assert determine_winner(4, [1, 2, 3, 4]) == 'Alice' def test_identical_elements(): assert determine_winner(5, [2, 2, 2, 2, 2]) == 'Alice' def test_high_values(): assert determine_winner(3, [1000000000, 1, 1]) == 'Alice' assert determine_winner(4, [1000000000, 1000000000, 1, 1]) == 'Bob'","solution":"def determine_winner(n, elements): Determine the winner of the game. :param n: Integer, the number of elements in the list :param elements: List of integers, the elements in the list :return: String, \\"Alice\\" if Alice wins, otherwise \\"Bob\\" sorted_elements = sorted(elements, reverse=True) alice_sum = 0 bob_sum = 0 for i in range(n): if i % 2 == 0: alice_sum += sorted_elements[i] else: bob_sum += sorted_elements[i] return \\"Alice\\" if alice_sum > bob_sum else \\"Bob\\""},{"question":"def edit_distance(n: int, m: int, s: str, t: str) -> int: Compute the minimum number of operations required to convert string s into string t. Args: n (int): Length of string s. m (int): Length of string t. s (str): Source string. t (str): Target string. Returns: int: Minimum number of operations required to convert s into t. >>> edit_distance(6, 7, \\"kitten\\", \\"sitting\\") 3 >>> edit_distance(3, 3, \\"abc\\", \\"def\\") 3 >>> edit_distance(0, 0, \\"\\", \\"\\") 0 >>> edit_distance(1, 1, \\"a\\", \\"a\\") 0 >>> edit_distance(1, 1, \\"a\\", \\"b\\") 1 >>> edit_distance(5, 8, \\"spark\\", \\"sharkins\\") 4 def test_edit_distance(): assert edit_distance(6, 7, \\"kitten\\", \\"sitting\\") == 3 assert edit_distance(3, 3, \\"abc\\", \\"def\\") == 3 assert edit_distance(0, 0, \\"\\", \\"\\") == 0 assert edit_distance(1, 1, \\"a\\", \\"a\\") == 0 assert edit_distance(1, 1, \\"a\\", \\"b\\") == 1 assert edit_distance(5, 8, \\"spark\\", \\"sharkins\\") == 4 def test_edit_distance_longer_strings(): s = \\"abcdefghijklmnopqrstuvwxyz\\" t = \\"zyxwvutsrqponmlkjihgfedcba\\" assert edit_distance(26, 26, s, t) == 26 s = \\"abcde\\" * 40 t = \\"edcba\\" * 40 assert edit_distance(200, 200, s, t) == 160 def test_edit_distance_substrings(): s = \\"testing\\" t = \\"test\\" assert edit_distance(7, 4, s, t) == 3 s = \\"test\\" t = \\"testing\\" assert edit_distance(4, 7, s, t) == 3","solution":"def edit_distance(n, m, s, t): Compute the minimum number of operations required to convert string s into string t. # Create a DP table dp = [[0] * (m + 1) for _ in range(n + 1)] # Initialize the table with base cases for i in range(n + 1): for j in range(m + 1): if i == 0: dp[i][j] = j # If s is empty, we need to insert all characters of t elif j == 0: dp[i][j] = i # If t is empty, we need to delete all characters of s elif s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j-1] # If characters are same, no new operation needed else: dp[i][j] = 1 + min(dp[i-1][j], # Deletion dp[i][j-1], # Insertion dp[i-1][j-1]) # Replacement return dp[n][m]"},{"question":"def median_salary(n: int, salaries: List[int]) -> float: Returns the median salary from the list of salaries. >>> median_salary(5, [30000, 50000, 25000, 60000, 70000]) 50000 >>> median_salary(4, [30000, 50000, 25000, 70000]) 40000.00 >>> median_salary(3, [50000, 50000, 50000]) 50000 >>> median_salary(1, [40000]) 40000 >>> median_salary(4, [20000, 40000, 60000, 80000]) 50000.00 >>> median_salary(4, [10000, 20000, 30000, 40000]) 25000.00 >>> median_salary(3, [1000000, 1000000, 1000000]) 1000000","solution":"def median_salary(n, salaries): Returns the median salary from the list of salaries. salaries.sort() mid = n // 2 if n % 2 == 1: return salaries[mid] else: median = (salaries[mid - 1] + salaries[mid]) / 2 return round(median, 2)"},{"question":"def count_arithmetic_slices(nums: List[int]) -> int: Returns the number of arithmetic slices in the given list of integers. >>> count_arithmetic_slices([1, 2, 3, 4, 6]) == 3 >>> count_arithmetic_slices([1, 3, 5, 7, 9, 11]) == 10 >>> count_arithmetic_slices([1, 2, 4]) == 0 >>> count_arithmetic_slices([1, 2, 3]) == 1","solution":"def count_arithmetic_slices(nums): Returns the number of arithmetic slices in the given list of integers. if len(nums) < 3: return 0 total_slices = 0 current = 0 for i in range(2, len(nums)): if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]: current += 1 total_slices += current else: current = 0 return total_slices"},{"question":"def find_three_sum(arr: list, x: int) -> str: Determines if there exist three distinct indices i, j, k such that arr[i] + arr[j] + arr[k] = x. >>> find_three_sum([1, 2, 4, 5, -1], 6) \\"YES\\" >>> find_three_sum([1, 2, 3, 4], 10) \\"NO\\" >>> find_three_sum([0, -1, 2, -3, 1, -2], 0) \\"YES\\"","solution":"def find_three_sum(arr, x): Determines if there exist three distinct indices i, j, k such that arr[i] + arr[j] + arr[k] = x. Parameters: arr (list): List of integers. x (int): The target sum. Returns: str: \\"YES\\" if such indices exist, otherwise \\"NO\\". arr.sort() n = len(arr) for i in range(n-2): left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == x: return \\"YES\\" elif current_sum < x: left += 1 else: right -= 1 return \\"NO\\""},{"question":"def sum_to_single_digit(n: int) -> int: Returns a single digit obtained by repeatedly summing the digits of n. >>> sum_to_single_digit(9875) 2 >>> sum_to_single_digit(49) 4 >>> sum_to_single_digit(7) 7 >>> sum_to_single_digit(10**9) 1 >>> sum_to_single_digit(123456789) 9 >>> sum_to_single_digit(10000) 1","solution":"def sum_to_single_digit(n): Returns a single digit obtained by repeatedly summing the digits of n. while n >= 10: n = sum(int(digit) for digit in str(n)) return n"},{"question":"def elevator_system(max_floors, commands): Calculates the final floor of an elevator after processing a list of commands. :param max_floors: Maximum number of floors in the building. :param commands: List of commands that the elevator needs to execute. :return: The final floor the elevator will be on after executing all commands. >>> elevator_system(15, [\\"UP\\", \\"UP\\", \\"DOWN\\", \\"UP\\", \\"STAY\\", \\"DOWN\\", \\"DOWN\\", \\"UP\\"]) 1 >>> elevator_system(2, [\\"UP\\", \\"UP\\", \\"UP\\"]) 2 >>> elevator_system(10, [\\"DOWN\\", \\"DOWN\\", \\"UP\\", \\"DOWN\\"]) 0 >>> elevator_system(10, [\\"UP\\"]*50000 + [\\"DOWN\\"]*50000) 0 >>> elevator_system(5, [\\"STAY\\", \\"STAY\\", \\"STAY\\"]) 0 >>> elevator_system(10, [\\"UP\\"]*5) 5 >>> elevator_system(10, [\\"DOWN\\"]*5) 0 >>> elevator_system(120, [\\"UP\\"]*100 + [\\"DOWN\\"]*100 + [\\"UP\\", \\"UP\\"]) 2","solution":"def elevator_system(max_floors, commands): Calculates the final floor of an elevator after processing a list of commands. :param max_floors: Maximum number of floors in the building. :param commands: List of commands that the elevator needs to execute. :return: The final floor the elevator will be on after executing all commands. current_floor = 0 for command in commands: if command == \\"UP\\": if current_floor < max_floors: current_floor += 1 elif command == \\"DOWN\\": if current_floor > 0: current_floor -= 1 # No need to check \\"STAY\\" as it does nothing return current_floor"},{"question":"def count_distinct_substrings(n: int, k: int, s: str) -> int: Returns the number of distinct substrings of length k in the string s. >>> count_distinct_substrings(10, 4, \\"abccdabcab\\") == 7 >>> count_distinct_substrings(5, 6, \\"abcde\\") == 0 >>> count_distinct_substrings(5, 1, \\"abcde\\") == 5 >>> count_distinct_substrings(5, 2, \\"abcde\\") == 4 >>> count_distinct_substrings(10, 3, \\"abcabcabca\\") == 3 >>> count_distinct_substrings(5, 3, \\"aaaaa\\") == 1 >>> count_distinct_substrings(6, 2, \\"aaaaaa\\") == 1","solution":"def count_distinct_substrings(n, k, s): Returns the number of distinct substrings of length k in the string s. if k > n: return 0 substrings = set() for i in range(n - k + 1): substr = s[i:i + k] substrings.add(substr) return len(substrings)"},{"question":"def can_make_strictly_increasing(grid): n = len(grid) for i in range(n - 1): for j in range(n - 1): if grid[i][j] > grid[i][j + 1] or grid[i][j] > grid[i + 1][j]: return False return True def solve(t, test_cases): Determine whether it is possible to make all rows and all columns of the grid strictly increasing by performing the given operation any number of times. >>> solve(2, [(2, [[1, 2], [3, 4]]), (3, [[3, 1, 2], [2, 3, 1], [1, 2, 3]])]) [\\"YES\\", \\"NO\\"] >>> solve(1, [(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]])]) [\\"YES\\"] >>> solve(1, [(2, [[1, 3], [2, 4]])]) [\\"YES\\"] >>> solve(1, [(3, [[2, 3, 4], [1, 5, 6], [7, 8, 1]])]) [\\"NO\\"] >>> solve(1, [(4, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])]) [\\"YES\\"]","solution":"def can_make_strictly_increasing(grid): n = len(grid) for i in range(n - 1): for j in range(n - 1): if grid[i][j] > grid[i][j + 1] or grid[i][j] > grid[i + 1][j]: return False return True def solve(t, test_cases): results = [] for case in test_cases: n, grid = case if can_make_strictly_increasing(grid): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def modify_matrix(matrix: List[List[int]]) -> List[List[int]]: Modify the matrix such that if any cell of the matrix is 1, then its entire row and column are set to 1. >>> modify_matrix([[0, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 0]]) [[0, 0, 1, 0], [1, 1, 1, 1], [0, 0, 1, 0]] >>> modify_matrix([[1, 0], [0, 0]]) [[1, 1], [1, 0]] >>> modify_matrix([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) [[0, 1, 0], [1, 1, 1], [0, 1, 0]] >>> modify_matrix([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> modify_matrix([[1, 1], [1, 1]]) [[1, 1], [1, 1]]","solution":"def modify_matrix(matrix): n = len(matrix) m = len(matrix[0]) rows_to_update = set() cols_to_update = set() # First pass to find the rows and columns that need to be updated for i in range(n): for j in range(m): if matrix[i][j] == 1: rows_to_update.add(i) cols_to_update.add(j) # Apply the updates to rows for row in rows_to_update: for j in range(m): matrix[row][j] = 1 # Apply the updates to columns for col in cols_to_update: for i in range(n): matrix[i][col] = 1 return matrix"},{"question":"from typing import List def delivery_truck_route(test_cases: List[List[List[int]]]) -> List[str]: Determine the minimum distance the driver needs to travel to complete the delivery route starting and ending at the specified city. Args: test_cases (List[List[List[int]]]): A list containing test cases, each test case is represented by an NxN matrix with distances between cities. Returns: List[str]: A list of results in the format 'Case T: A' where T is the case number and A is the minimum distance. >>> delivery_truck_route([ ... [ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ] ... ]) ['Case 1: 80'] >>> delivery_truck_route([ ... [ ... [0, 29, 20], ... [29, 0, 15], ... [20, 15, 0] ... ] ... ]) ['Case 1: 64']","solution":"from itertools import permutations def calculate_min_distance(matrix): N = len(matrix) cities = list(range(N)) min_distance = float('inf') for perm in permutations(cities[1:]): # Fix the starting city to 0 current_path = [0] + list(perm) + [0] current_distance = sum(matrix[current_path[i]][current_path[i + 1]] for i in range(len(current_path)-1)) min_distance = min(min_distance, current_distance) return min_distance def delivery_truck_route(test_cases): results = [] for i, matrix in enumerate(test_cases): min_distance = calculate_min_distance(matrix) results.append(f\\"Case {i + 1}: {min_distance}\\") return results"},{"question":"def shortest_palindrome(s: str) -> str: Given a string s, find and return the shortest palindrome you can find by adding characters in front of it. >>> shortest_palindrome(\\"aacecaaa\\") == \\"aaacecaaa\\" >>> shortest_palindrome(\\"abcd\\") == \\"dcbabcd\\"","solution":"def shortest_palindrome(s: str) -> str: Returns the shortest palindrome that can be formed by adding characters in front of the given string. if not s: return s # Reverse the string reversed_s = s[::-1] for i in range(len(s)): if s.startswith(reversed_s[i:]): return reversed_s[:i] + s return \\"\\" # Example usage: # input: \\"aacecaaa\\" # output: \\"aaacecaaa\\" print(shortest_palindrome(\\"aacecaaa\\")) # aaacecaaa # input: \\"abcd\\" # output: \\"dcbabcd\\" print(shortest_palindrome(\\"abcd\\")) # dcbabcd"},{"question":"def check_presence(N: int, M: int, A: List[int], B: List[int], C: List[int]) -> List[str]: You are given two lists of integers, A and B, both of the same length, N. The integers in both lists are in a non-decreasing order. A third list, C, of length M, is also given which is in an arbitrary order. For each integer in C, you need to determine if it is present in either list A or list B. Print \\"Yes\\" if the integer is present in at least one of the lists, otherwise print \\"No\\". >>> check_presence(5, 3, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10], [5, 8, 11]) [\\"Yes\\", \\"Yes\\", \\"No\\"] >>> check_presence(4, 2, [10, 20, 30, 40], [15, 25, 35, 45], [20, 50]) [\\"Yes\\", \\"No\\"]","solution":"def check_presence(N, M, A, B, C): # Create a set with elements from both A and B combined_set = set(A) | set(B) # For each element in C, check its presence in the combined set result = [] for number in C: if number in combined_set: result.append(\\"Yes\\") else: result.append(\\"No\\") return result"},{"question":"def maxProfit(prices: List[int]) -> int: Given an array of integers representing daily stock prices, finds the maximum profit that can be achieved by buying and selling the stock at most twice. >>> maxProfit([3, 3, 5, 0, 0, 3, 1, 4]) 6 >>> maxProfit([1, 2, 3, 4, 5]) 4 >>> maxProfit([7, 6, 4, 3, 1]) 0 >>> maxProfit([1, 2]) 1","solution":"def maxProfit(prices): if not prices: return 0 # Initialize variables to track the maximum profit after the first and second transactions first_buy = float('-inf') first_sell = 0 second_buy = float('-inf') second_sell = 0 for price in prices: # Track the maximum profit after buying the first stock first_buy = max(first_buy, -price) # Track the maximum profit after selling the first stock first_sell = max(first_sell, first_buy + price) # Track the maximum profit after buying the second stock second_buy = max(second_buy, first_sell - price) # Track the maximum profit after selling the second stock second_sell = max(second_sell, second_buy + price) return second_sell"},{"question":"from typing import List, Tuple def compute_fair_scores(n: int, m: int, k: int, scores: List[List[int]]) -> List[int]: Computes the fair scores for each participant by disregarding any score instances that exceed k occurrences. Args: n (int): Number of participants. m (int): Number of problems. k (int): Maximum allowed occurrences for any score. scores (List[List[int]]): The scores received by each participant for each problem. Returns: List[int]: The list of fair total scores for each participant. Example: >>> compute_fair_scores(3, 4, 2, [ ... [5, 5, 5, 5], ... [3, 3, 3, 3], ... [4, 4, 4, 4], ... ]) [10, 6, 8] pass def test_compute_fair_scores_basic(): input_data = (3, 4, 2, [ [5, 5, 5, 5], [3, 3, 3, 3], [4, 4, 4, 4], ]) expected_output = [10, 6, 8] assert compute_fair_scores(*input_data) == expected_output def test_compute_fair_scores_no_limit_exceeded(): input_data = (2, 3, 5, [ [1, 2, 3], [4, 5, 6], ]) expected_output = [6, 15] assert compute_fair_scores(*input_data) == expected_output def test_compute_fair_scores_with_some_duplicates(): input_data = (2, 5, 2, [ [7, 7, 8, 8, 8], [10, 10, 9, 9, 9], ]) expected_output = [30, 38] assert compute_fair_scores(*input_data) == expected_output def test_compute_fair_scores_all_same_scores(): input_data = (1, 4, 1, [ [10, 10, 10, 10], ]) expected_output = [10] assert compute_fair_scores(*input_data) == expected_output def test_compute_fair_scores_single_participant(): input_data = (1, 5, 1, [ [2, 3, 2, 3, 2], ]) expected_output = [5] assert compute_fair_scores(*input_data) == expected_output","solution":"from collections import Counter def compute_fair_scores(n, m, k, scores): fair_scores = [] for i in range(n): score_counts = Counter(scores[i]) total = 0 for score, freq in score_counts.items(): total += score * min(freq, k) fair_scores.append(total) return fair_scores"},{"question":"def flip_bits(n: int) -> int: Returns the integer obtained by flipping the bits of the input integer. >>> flip_bits(0) == 15 >>> flip_bits(10) == 5 >>> flip_bits(20) == 11 >>> flip_bits(1) == 0 >>> flip_bits(255) == 0 >>> flip_bits(8) == 7 >>> flip_bits(1023) == 0 >>> flip_bits(1024) == 1023","solution":"def flip_bits(n): Returns the integer obtained by flipping the bits of the input integer. # Find the number of bits in n if n == 0: # Special case: for input 0, return 15 (binary 1111) return 15 # Determine the number of bits in the binary representation of n num_bits = n.bit_length() # Create a mask with num_bits bits all set to 1 mask = (1 << num_bits) - 1 # XOR n with the mask to flip the bits flipped = n ^ mask return flipped"},{"question":"def valid_planting_schedules(N: int) -> int: Returns the number of valid planting schedules for N days. The garden must not have three consecutive days without planting a tree. >>> valid_planting_schedules(1) 2 >>> valid_planting_schedules(3) 7 >>> valid_planting_schedules(5) 29 def test_valid_planting_schedules(): assert valid_planting_schedules(1) == 2 assert valid_planting_schedules(2) == 4 assert valid_planting_schedules(3) == 7 assert valid_planting_schedules(4) == 13 assert valid_planting_schedules(5) == 24 assert valid_planting_schedules(6) == 44 assert valid_planting_schedules(10) == 504 print(\\"All tests passed.\\") test_valid_planting_schedules()","solution":"def valid_planting_schedules(N): Returns the number of valid planting schedules for N days. if N == 1: return 2 if N == 2: return 4 if N == 3: return 7 dp = [0] * (N + 1) dp[1] = 2 # Only two ways: plant or skip but plant next dp[2] = 4 # 1 plant, 2 plants, [P, P, skip] dp[3] = 7 # 3 plants, [P, P, S], [P, S, P], etc. for i in range(4, N + 1): dp[i] = dp[i-1] + dp[i-2] + dp[i-3] return dp[N]"},{"question":"def find_mth_element(a: int, b: int, m: int) -> int: Returns the m-th element of the sequence starting with a and b, where each element is the sum of its two immediate predecessors. >>> find_mth_element(2, 3, 5) 13 >>> find_mth_element(1, 1, 1) 1 >>> find_mth_element(3, 5, 2) 5 >>> find_mth_element(1, 1, 3) 2 >>> find_mth_element(10**9, 10**9, 3) 2000000000","solution":"def find_mth_element(a, b, m): Returns the m-th element of the sequence starting with a and b, where each element is the sum of its two immediate predecessors. if m == 1: return a elif m == 2: return b sequence = [a, b] for _ in range(2, m): next_element = sequence[-1] + sequence[-2] sequence.append(next_element) return sequence[m-1]"},{"question":"class Sequence: def __init__(self, n: int, elements: List[int]): Initialize the sequence with n elements. def update(self, x: int, y: int): Update the value at position x to y. def range_sum(self, l: int, r: int) -> int: Calculate and return the sum of integers in the given range [l, r]. def process_queries(n: int, elements: List[int], queries: List[List[int]]) -> List[int]: Process a series of q queries on the sequence of n integers. Returns a list of results for the range sum queries. Example: >>> process_queries(5, [1, 2, 3, 4, 5], [[2, 1, 3], [1, 3, 10], [2, 1, 3], [2, 3, 4], [2, 1, 5]]) [6, 13, 14, 22] from typing import List def test_sequence_operations(): seq = Sequence(5, [1, 2, 3, 4, 5]) # Test initial range sum assert seq.range_sum(1, 3) == 6 # Test update operation seq.update(3, 10) assert seq.elements == [1, 2, 10, 4, 5] # Test range sum after update assert seq.range_sum(1, 3) == 13 assert seq.range_sum(3, 4) == 14 assert seq.range_sum(1, 5) == 22 def test_process_queries(): n = 5 elements = [1, 2, 3, 4, 5] queries = [ [2, 1, 3], [1, 3, 10], [2, 1, 3], [2, 3, 4], [2, 1, 5] ] results = process_queries(n, elements, queries) assert results == [6, 13, 14, 22]","solution":"class Sequence: def __init__(self, n, elements): self.n = n self.elements = elements def update(self, x, y): self.elements[x-1] = y def range_sum(self, l, r): return sum(self.elements[l-1:r]) def process_queries(n, elements, queries): seq = Sequence(n, elements) results = [] for query in queries: type_query = query[0] if type_query == 1: x, y = query[1], query[2] seq.update(x, y) elif type_query == 2: l, r = query[1], query[2] results.append(seq.range_sum(l, r)) return results"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Returns the maximum possible sum of a non-empty subarray. Parameters: nums (list of int): List of integers to find the max subarray sum. Returns: int: Maximum sum of any non-empty subarray. >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) 6 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([1, 2, 3, 4]) 10 >>> max_subarray_sum([2, -1, 2, 3, -5]) 6 >>> max_subarray_sum([-2, 5]) 5 >>> max_subarray_sum([5, -2, 5, 0]) 8 >>> max_subarray_sum([100]) 100","solution":"def max_subarray_sum(nums): Returns the maximum possible sum of a non-empty subarray. Parameters: nums (list of int): List of integers to find the max subarray sum. Returns: int: Maximum sum of any non-empty subarray. max_current = max_global = nums[0] for i in range(1, len(nums)): max_current = max(nums[i], max_current + nums[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"def tsp_min_travel_time(n: int, travel_time: List[List[int]]) -> int: Determine the sequence of visiting all cities exactly once starting from city 0, such that the total travel time is minimized. >>> tsp_min_travel_time(4, [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]) 80 >>> tsp_min_travel_time(2, [ [0, 10], [10, 0]]) 20 >>> tsp_min_travel_time(3, [ [0, 1, 1], [1, 0, 1], [1, 1, 0]]) 3 import pytest from typing import List def test_example_case(): n = 4 travel_time = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0], ] assert tsp_min_travel_time(n, travel_time) == 80 def test_case_two_cities(): n = 2 travel_time = [ [0, 10], [10, 0], ] assert tsp_min_travel_time(n, travel_time) == 20 def test_case_all_equal_distances(): n = 3 travel_time = [ [0, 1, 1], [1, 0, 1], [1, 1, 0], ] assert tsp_min_travel_time(n, travel_time) == 3 # 0 -> 1 -> 2 -> 0 def test_case_large_distances(): n = 3 travel_time = [ [0, 999, 999], [999, 0, 999], [999, 999, 0], ] assert tsp_min_travel_time(n, travel_time) == 2997 # 0 -> 1 -> 2 -> 0 def test_case_more_cities(): n = 5 travel_time = [ [0, 2, 9, 10, 1], [1, 0, 6, 4, 2], [15, 7, 0, 8, 3], [6, 3, 12, 0, 20], [8, 4, 8, 5, 0], ] assert tsp_min_travel_time(n, travel_time) == 21 # 0 -> 4 -> 1 -> 3 -> 2 -> 0","solution":"def tsp_min_travel_time(n, travel_time): # memo dict: (tuple, int) -> int memo = {} END_VISITED = (1 << n) - 1 def visit(city, visited): # If all cities have been visited, return distance to start city if visited == END_VISITED: return travel_time[city][0] # If the subproblem is already solved, return its value if (city, visited) in memo: return memo[(city, visited)] # Initialize the min travel as infinite min_travel = float('inf') for next_city in range(n): if not (visited & (1 << next_city)): current_travel = travel_time[city][next_city] + visit(next_city, visited | (1 << next_city)) min_travel = min(min_travel, current_travel) memo[(city, visited)] = min_travel return min_travel return visit(0, 1)"},{"question":"def find_max_subgrid_sum(N: int, grid: List[List[int]]) -> int: A grid of size NxN is filled with integers. You are asked to find the largest sum of integers of any sub-grid. A sub-grid is any contiguous part of the grid that forms a rectangle. >>> find_max_subgrid_sum(2, [[1, -2], [3, 4]]) 7 >>> find_max_subgrid_sum(3, [[1, 2, -1], [-3, 4, 2], [1, 1, -3]]) 7 >>> find_max_subgrid_sum(2, [[-1, -2], [-3, -4]]) -1 >>> find_max_subgrid_sum(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 45 >>> find_max_subgrid_sum(2, [[0, -2], [3, 4]]) 7 >>> find_max_subgrid_sum(1, [[-5]]) -5","solution":"def find_max_subgrid_sum(N, grid): def max_sub_array(arr): max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far max_sum = float('-inf') for left in range(N): temp = [0] * N for right in range(left, N): for i in range(N): temp[i] += grid[i][right] max_sum = max(max_sum, max_sub_array(temp)) return max_sum"},{"question":"def is_properly_nested(seq: str) -> str: Checks if the parentheses in the input string are properly nested. Parameters: seq (str): Input string containing only '(' and ')'. Returns: str: \\"YES\\" if the string is properly nested, otherwise \\"NO\\". pass def process_input(datasets: list[str]) -> list[str]: Processes a list of datasets and returns a list of results. Parameters: datasets (list of str): List containing input strings. Returns: list of str: List of \\"YES\\" or \\"NO\\" corresponding to each input string. pass from solution import is_properly_nested, process_input def test_is_properly_nested_yes(): assert is_properly_nested(\\"(())\\") == \\"YES\\" assert is_properly_nested(\\"()()\\") == \\"YES\\" assert is_properly_nested(\\"((())())\\") == \\"YES\\" assert is_properly_nested(\\"\\") == \\"YES\\" def test_is_properly_nested_no(): assert is_properly_nested(\\"(()\\") == \\"NO\\" assert is_properly_nested(\\"())\\") == \\"NO\\" assert is_properly_nested(\\"(()))\\") == \\"NO\\" assert is_properly_nested(\\")(\\") == \\"NO\\" def test_process_input(): datasets = [\\"(())()\\", \\"(()))\\", \\"((()))\\", \\"END\\"] expected = [\\"YES\\", \\"NO\\", \\"YES\\"] assert process_input(datasets) == expected def test_process_input_no_end(): datasets = [\\"(())\\", \\"()()\\", \\"(())())\\"] expected = [\\"YES\\", \\"YES\\", \\"NO\\"] assert process_input(datasets) == expected def test_process_input_mixed(): datasets = [\\"(((()\\", \\"(()())\\", \\"()(\\", \\"END\\"] expected = [\\"NO\\", \\"YES\\", \\"NO\\"] assert process_input(datasets) == expected","solution":"def is_properly_nested(seq): Checks if the parentheses in the input string are properly nested. Parameters: seq (str): Input string containing only '(' and ')'. Returns: str: \\"YES\\" if the string is properly nested, otherwise \\"NO\\". stack = [] for char in seq: if char == '(': stack.append(char) elif char == ')': if not stack: return \\"NO\\" stack.pop() return \\"YES\\" if not stack else \\"NO\\" def process_input(datasets): Processes a list of datasets and returns a list of results. Parameters: datasets (list of str): List containing input strings. Returns: list of str: List of \\"YES\\" or \\"NO\\" corresponding to each input string. results = [] for dataset in datasets: if dataset == \\"END\\": break results.append(is_properly_nested(dataset)) return results"},{"question":"from typing import List, Tuple def sort_pos_neg(arr: List[int]) -> List[int]: This function takes a list of integers and returns a new list with all positive integers before all negative integers, while preserving the relative order of the integers within their respective categories. pass def rearrange_lists(test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: This function takes a list of test case tuples and returns the rearranged lists as per the conditions. Each tuple contains the size of the list and the list itself. pass # Unit Tests def test_sort_pos_neg(): assert sort_pos_neg([-1, 2, -3, 4, -5, 6]) == [2, 4, 6, -1, -3, -5] assert sort_pos_neg([7, -8, 9, -10]) == [7, 9, -8, -10] assert sort_pos_neg([1, -1, 2, -2]) == [1, 2, -1, -2] assert sort_pos_neg([-1, -2, -3]) == [-1, -2, -3] assert sort_pos_neg([1, 2, 3]) == [1, 2, 3] def test_rearrange_lists(): test_cases = [ (6, [-1, 2, -3, 4, -5, 6]), (4, [7, -8, 9, -10]) ] assert rearrange_lists(test_cases) == [[2, 4, 6, -1, -3, -5], [7, 9, -8, -10]] test_cases = [ (4, [1, -1, 2, -2]), (3, [-1, -2, -3]) ] assert rearrange_lists(test_cases) == [[1, 2, -1, -2], [-1, -2, -3]] test_cases = [ (5, [1, -1, -2, 3, 4]), (6, [-6, -5, 4, 3, 2, 1])] assert rearrange_lists(test_cases) == [[1, 3, 4, -1, -2], [4, 3, 2, 1, -6, -5]]","solution":"def sort_pos_neg(arr): This function takes a list of integers and returns a new list with all positive integers before all negative integers, while preserving the relative order of the integers within their respective categories. positives = [x for x in arr if x >= 0] negatives = [x for x in arr if x < 0] return positives + negatives def rearrange_lists(test_cases): This function takes a list of test case tuples and prints the rearranged lists as per the conditions. Each tuple contains the size of the list and the list itself. results = [] for N, arr in test_cases: rearranged = sort_pos_neg(arr) results.append(rearranged) return results"},{"question":"def two_non_overlapping_subarrays_with_sum(arr: List[int], k: int) -> str: Determine whether there exist two non-overlapping subarrays in the array such that the sum of their elements is equal to k. Args: arr (List[int]): The array of distinct integers. k (int): The target sum. Returns: str: \\"YES\\" if such subarrays exist, otherwise \\"NO\\". >>> two_non_overlapping_subarrays_with_sum([1, 2, 3, 4, 5, 6, 7], 10) \\"YES\\" >>> two_non_overlapping_subarrays_with_sum([5, -3, 2, 7, 9], 8) \\"NO\\" >>> two_non_overlapping_subarrays_with_sum([1], 2) \\"NO\\" >>> two_non_overlapping_subarrays_with_sum([1], 1) \\"NO\\" >>> two_non_overlapping_subarrays_with_sum([10**9, -10**9, 10**9, -10**9, 10**9], 10**18) \\"NO\\" >>> two_non_overlapping_subarrays_with_sum([1, 2, 3, 4, 5], 9) \\"YES\\" >>> two_non_overlapping_subarrays_with_sum([-1, -2, -3, -4, -5], -9) \\"YES\\" >>> two_non_overlapping_subarrays_with_sum([-5, 1, 2, -2, 7, -9, 10], 5) \\"YES\\" >>> two_non_overlapping_subarrays_with_sum([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], 10) \\"YES\\" >>> two_non_overlapping_subarrays_with_sum([1, 2, 1, 3, 1, 4, 1, 5], 100) \\"NO\\"","solution":"def two_non_overlapping_subarrays_with_sum(arr, k): Determine whether there exist two non-overlapping subarrays in the array such that the sum of their elements is equal to k. Args: arr (list of int): The array of distinct integers. k (int): The target sum. Returns: str: \\"YES\\" if such subarrays exist, otherwise \\"NO\\". n = len(arr) # Dictionary to store sums and their ending indices sum_map = {} # Variable to store the prefix sum prefix_sum = 0 for i in range(n): prefix_sum += arr[i] if prefix_sum == k: if i < n-1: return \\"YES\\" if (prefix_sum - k) in sum_map: j = sum_map[prefix_sum - k] if j < i: if i < n-1: return \\"YES\\" sum_map[prefix_sum] = i return \\"NO\\" # Testing with provided examples print(two_non_overlapping_subarrays_with_sum([1, 2, 3, 4, 5, 6, 7], 10)) print(two_non_overlapping_subarrays_with_sum([5, -3, 2, 7, 9], 8))"},{"question":"def minimal_gcd_sequence_sum(n: int) -> int: Returns the sum of the sequence that meets the given conditions and has the smallest sum. The smallest sum for a sequence of length n where each pair of elements are coprime is the sum of the first n positive integers. >>> minimal_gcd_sequence_sum(1) == 1 >>> minimal_gcd_sequence_sum(2) == 3 >>> minimal_gcd_sequence_sum(3) == 6 >>> minimal_gcd_sequence_sum(4) == 10 >>> minimal_gcd_sequence_sum(5) == 15 >>> minimal_gcd_sequence_sum(10) == 55 >>> minimal_gcd_sequence_sum(100000) == 5000050000","solution":"def minimal_gcd_sequence_sum(n): Returns the sum of the sequence that meets the given conditions and has the smallest sum. The smallest sum for a sequence of length n where each pair of elements are coprime is the sum of the first n positive integers. # To generate the smallest sequence with all pairwise gcd equal to 1, # we can simply use the first n natural numbers. # The sum of the first n natural numbers is given by the formula n * (n + 1) / 2. return n * (n + 1) // 2"},{"question":"from typing import List, Tuple def sort_books(books: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Sorts the books first by height in ascending order and then by width in descending order if two books have the same height. Args: books (List[Tuple[int, int]]): A list of tuples representing the books, where each tuple contains two integers: height and width. Returns: List[Tuple[int, int]]: A list of tuples representing the sorted books. Example: >>> sort_books([(10, 5), (8, 7), (8, 5), (12, 3)]) [(8, 7), (8, 5), (10, 5), (12, 3)] pass def test_sort_books_example(): assert sort_books([(10, 5), (8, 7), (8, 5), (12, 3)]) == [(8, 7), (8, 5), (10, 5), (12, 3)] def test_sort_books_all_same_height(): assert sort_books([(8, 5), (8, 7), (8, 3)]) == [(8, 7), (8, 5), (8, 3)] def test_sort_books_all_same_width(): assert sort_books([(10, 5), (8, 5), (12, 5)]) == [(8, 5), (10, 5), (12, 5)] def test_sort_books_already_sorted(): assert sort_books([(8, 7), (8, 5), (10, 5), (12, 3)]) == [(8, 7), (8, 5), (10, 5), (12, 3)] def test_sort_books_unsorted(): assert sort_books([(12, 1), (1, 12), (12, 12), (1, 1)]) == [(1, 12), (1, 1), (12, 12), (12, 1)]","solution":"from typing import List, Tuple def sort_books(books: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Sorts the books first by height in ascending order and then by width in descending order if two books have the same height. # Sort books by height ascending, then by width descending return sorted(books, key=lambda x: (x[0], -x[1]))"},{"question":"def plant_acquisition_dates(n, plant_data, m, queries): Retrieves the acquisition dates for the queried plant species. Parameters: n (int): Number of plants. plant_data (list of str): List of plant species and acquisition dates. m (int): Number of queries. queries (list of str): List of plant species to query. Returns: list of str: Acquisition dates corresponding to the queried plant species. >>> n = 3 >>> plant_data = [\\"rose 2022-04-10\\", \\"lily 2021-03-25\\", \\"tulip 2023-01-01\\"] >>> m = 2 >>> queries = [\\"rose\\", \\"tulip\\"] >>> plant_acquisition_dates(n, plant_data, m, queries) [\\"2022-04-10\\", \\"2023-01-01\\"] >>> n = 1 >>> plant_data = [\\"daisy 2020-09-09\\"] >>> m = 1 >>> queries = [\\"daisy\\"] >>> plant_acquisition_dates(n, plant_data, m, queries) [\\"2020-09-09\\"] >>> n = 5 >>> plant_data = [\\"a 2020-01-01\\", \\"b 2021-02-02\\", \\"c 2022-03-03\\", \\"d 2023-04-04\\", \\"e 2024-05-05\\"] >>> m = 3 >>> queries = [\\"b\\", \\"e\\", \\"c\\"] >>> plant_acquisition_dates(n, plant_data, m, queries) [\\"2021-02-02\\", \\"2024-05-05\\", \\"2022-03-03\\"] >>> n = 3 >>> plant_data = [\\"x 2019-08-08\\", \\"y 2018-07-07\\", \\"z 2017-06-06\\"] >>> m = 3 >>> queries = [\\"x\\", \\"y\\", \\"z\\"] >>> plant_acquisition_dates(n, plant_data, m, queries) [\\"2019-08-08\\", \\"2018-07-07\\", \\"2017-06-06\\"] >>> n = 4 >>> plant_data = [\\"p1 2022-11-11\\", \\"p2 2021-10-10\\", \\"p3 2023-09-09\\", \\"p4 2020-08-08\\"] >>> m = 2 >>> queries = [\\"p3\\", \\"p1\\"] >>> plant_acquisition_dates(n, plant_data, m, queries) [\\"2023-09-09\\", \\"2022-11-11\\"]","solution":"def plant_acquisition_dates(n, plant_data, m, queries): Retrieves the acquisition dates for the queried plant species. Parameters: n (int): Number of plants. plant_data (list of str): List of plant species and acquisition dates. m (int): Number of queries. queries (list of str): List of plant species to query. Returns: list of str: Acquisition dates corresponding to the queried plant species. plant_dict = {} for i in range(n): species, date = plant_data[i].split() plant_dict[species] = date result = [] for j in range(m): query = queries[j] result.append(plant_dict[query]) return result"},{"question":"def count_eligible_instructors(N: int, M: int, T: int, instructor_info: list) -> int: Returns the number of eligible instructors based on the given conditions. Parameters: N (int): Number of instructors. M (int): Minimum number of courses an instructor must create. T (int): Minimum number of students that must be enrolled in at least one of the instructor's courses. instructor_info (list of tuples): List containing instructor details, where each tuple contains (instructor_name, K, [student_counts]) Returns: int: Number of eligible instructors. pass # Test cases to validate the solution def test_example_case(): N, M, T = 3, 2, 30 instructor_info = [ (\\"Alice\\", 3, [15, 30, 5]), (\\"Bob\\", 2, [40, 10]), (\\"Charlie\\", 2, [20, 19]) ] assert count_eligible_instructors(N, M, T, instructor_info) == 2 def test_all_instructors_eligible(): N, M, T = 2, 1, 5 instructor_info = [ (\\"Dave\\", 2, [10, 5]), (\\"Eva\\", 1, [7]) ] assert count_eligible_instructors(N, M, T, instructor_info) == 2 def test_no_instructors_eligible(): N, M, T = 3, 4, 50 instructor_info = [ (\\"Frank\\", 3, [49, 48, 47]), (\\"Grace\\", 2, [10, 5]), (\\"Hank\\", 0, []) ] assert count_eligible_instructors(N, M, T, instructor_info) == 0 def test_minimum_values(): N, M, T = 1, 1, 1 instructor_info = [(\\"Ivy\\", 1, [1])] assert count_eligible_instructors(N, M, T, instructor_info) == 1 def test_maximum_values(): N = 1000 M, T = 10, 500 instructor_info = [(\\"Instructor_\\" + str(i), 15, [500] * 15) for i in range(1000)] assert count_eligible_instructors(N, M, T, instructor_info) == 1000 def test_edge_case_not_enough_courses(): N, M, T = 2, 3, 20 instructor_info = [(\\"John\\", 2, [25, 30]), (\\"Jane\\", 1, [20])] assert count_eligible_instructors(N, M, T, instructor_info) == 0 def test_edge_case_no_students(): N, M, T = 2, 1, 1 instructor_info = [(\\"Kevin\\", 1, [0]), (\\"Laura\\", 1, [1])] assert count_eligible_instructors(N, M, T, instructor_info) == 1","solution":"def count_eligible_instructors(N, M, T, instructor_info): Returns the number of eligible instructors based on the given conditions. Parameters: N (int): Number of instructors. M (int): Minimum number of courses an instructor must create. T (int): Minimum number of students that must be enrolled in at least one of the instructor's courses. instructor_info (list of tuples): List containing instructor details, where each tuple contains (instructor_name, K, [student_counts]) Returns: int: Number of eligible instructors. eligible_count = 0 for info in instructor_info: instructor_name, K, student_counts = info if K >= M and any(students >= T for students in student_counts): eligible_count += 1 return eligible_count"},{"question":"from typing import List, Dict, Tuple def most_popular_posts(posts: List[Dict[str, int]]) -> Tuple[List[int], List[int]]: Analyzes user engagement statistics to identify the most popular posts based on likes and shares. Args: posts (List[Dict[str, int]]): A list of dictionaries where each dictionary contains: - \\"id\\" (int): The unique identifier of the post. - \\"likes\\" (int): The number of likes the post received. - \\"shares\\" (int): The number of times the post was shared. Returns: Tuple[List[int], List[int]]: A tuple containing two lists: - A list of post IDs with the highest number of likes. - A list of post IDs with the highest number of shares. Example: >>> posts = [ ... {\\"id\\": 1, \\"likes\\": 10, \\"shares\\": 5}, ... {\\"id\\": 2, \\"likes\\": 15, \\"shares\\": 7}, ... {\\"id\\": 3, \\"likes\\": 15, \\"shares\\": 2}, ... {\\"id\\": 4, \\"likes\\": 10, \\"shares\\": 7} ... ] >>> most_popular_posts(posts) ([2, 3], [2, 4]) import pytest from solution import most_popular_posts def test_most_popular_posts_example1(): posts = [ {\\"id\\": 1, \\"likes\\": 10, \\"shares\\": 5}, {\\"id\\": 2, \\"likes\\": 15, \\"shares\\": 7}, {\\"id\\": 3, \\"likes\\": 15, \\"shares\\": 2}, {\\"id\\": 4, \\"likes\\": 10, \\"shares\\": 7} ] assert most_popular_posts(posts) == ([2, 3], [2, 4]) def test_most_popular_posts_example2(): posts = [ {\\"id\\": 1, \\"likes\\": 3, \\"shares\\": 4}, {\\"id\\": 2, \\"likes\\": 5, \\"shares\\": 6}, {\\"id\\": 3, \\"likes\\": 5, \\"shares\\": 4}, {\\"id\\": 4, \\"likes\\": 2, \\"shares\\": 10} ] assert most_popular_posts(posts) == ([2, 3], [4]) def test_most_popular_posts_no_posts(): posts = [] assert most_popular_posts(posts) == ([], []) def test_most_popular_posts_single_post(): posts = [ {\\"id\\": 1, \\"likes\\": 1, \\"shares\\": 1} ] assert most_popular_posts(posts) == ([1], [1]) def test_most_popular_posts_all_same_likes_and_shares(): posts = [ {\\"id\\": 1, \\"likes\\": 5, \\"shares\\": 5}, {\\"id\\": 2, \\"likes\\": 5, \\"shares\\": 5}, {\\"id\\": 3, \\"likes\\": 5, \\"shares\\": 5} ] assert most_popular_posts(posts) == ([1, 2, 3], [1, 2, 3]) def test_most_popular_posts_tied_likes_different_shares(): posts = [ {\\"id\\": 1, \\"likes\\": 10, \\"shares\\": 1}, {\\"id\\": 2, \\"likes\\": 10, \\"shares\\": 5}, {\\"id\\": 3, \\"likes\\": 5, \\"shares\\": 5} ] assert most_popular_posts(posts) == ([1, 2], [2, 3])","solution":"from typing import List, Dict, Tuple def most_popular_posts(posts: List[Dict[str, int]]) -> Tuple[List[int], List[int]]: Returns two lists: 1. A list of post IDs with the highest number of likes. 2. A list of post IDs with the highest number of shares. if not posts: return ([], []) # Find the maximum number of likes and shares max_likes = max(post[\\"likes\\"] for post in posts) max_shares = max(post[\\"shares\\"] for post in posts) # Collect all post IDs with the maximum likes and shares most_liked_posts = [post[\\"id\\"] for post in posts if post[\\"likes\\"] == max_likes] most_shared_posts = [post[\\"id\\"] for post in posts if post[\\"shares\\"] == max_shares] return (most_liked_posts, most_shared_posts)"},{"question":"def find_routes_through_midpoint(intersections, roads, routes, midpoint): Determines which routes pass through the given midpoint intersection. Parameters: intersections (list of tuples): List of intersection coordinates. roads (list of tuples): List of roads represented by pairs of intersection indices. routes (list of list of int): List of routes, each route represented by a list of intersection indices. midpoint (tuple): Coordinates of the midpoint intersection to check routes against. Returns: list of int: Indices of routes that pass through the midpoint. If no routes pass through, returns [\\"NONE\\"]. pass from solution import find_routes_through_midpoint def test_find_routes_through_midpoint_one_route_through_midpoint(): intersections = [(0, 0), (2, 0), (4, 0), (2, 2), (4, 2)] roads = [(0, 1), (1, 2), (1, 3), (2, 4)] routes = [ [0, 1, 2], [0, 3, 4], [4, 3, 0] ] midpoint = (2, 0) result = find_routes_through_midpoint(intersections, roads, routes, midpoint) assert result == [0] def test_find_routes_through_midpoint_multiple_routes_through_midpoint(): intersections = [(0, 0), (2, 0), (4, 0), (2, 2), (4, 2)] roads = [(0, 1), (1, 2), (1, 3), (2, 4)] routes = [ [0, 1, 2], [0, 3, 4], [4, 3, 0] ] midpoint = (4, 2) result = find_routes_through_midpoint(intersections, roads, routes, midpoint) assert result == [1, 2] def test_find_routes_through_midpoint_no_routes_through_midpoint(): intersections = [(0, 0), (2, 0), (4, 0), (2, 2), (4, 2)] roads = [(0, 1), (1, 2), (1, 3), (2, 4)] routes = [ [0, 1, 2], [0, 3, 4], [4, 3, 0] ] midpoint = (1, 1) result = find_routes_through_midpoint(intersections, roads, routes, midpoint) assert result == [\\"NONE\\"] def test_find_routes_through_midpoint_no_routes_defined(): intersections = [(0, 0), (2, 0), (4, 0), (2, 2), (4, 2)] roads = [(0, 1), (1, 2), (1, 3), (2, 4)] routes = [] midpoint = (2, 2) result = find_routes_through_midpoint(intersections, roads, routes, midpoint) assert result == [\\"NONE\\"] def test_find_routes_through_midpoint_invalid_midpoint(): intersections = [(0, 0), (2, 0), (4, 0), (2, 2), (4, 2)] roads = [(0, 1), (1, 2), (1, 3), (2, 4)] routes = [ [0, 1, 2], [0, 3, 4], [4, 3, 0] ] midpoint = (5, 5) result = find_routes_through_midpoint(intersections, roads, routes, midpoint) assert result == [\\"NONE\\"]","solution":"def find_routes_through_midpoint(intersections, roads, routes, midpoint): Determines which routes pass through the given midpoint intersection. Parameters: intersections (list of tuples): List of intersection coordinates. roads (list of tuples): List of roads represented by pairs of intersection indices. routes (list of list of int): List of routes, each route represented by a list of intersection indices. midpoint (tuple): Coordinates of the midpoint intersection to check routes against. Returns: list of int: Indices of routes that pass through the midpoint. If no routes pass through, returns [\\"NONE\\"]. mid_x, mid_y = midpoint midpoint_index = None # Find the index of the midpoint intersection for i, (x, y) in enumerate(intersections): if x == mid_x and y == mid_y: midpoint_index = i break if midpoint_index is None: return [\\"NONE\\"] passing_route_indices = [] for i, route in enumerate(routes): if midpoint_index in route: passing_route_indices.append(i) if not passing_route_indices: return [\\"NONE\\"] return passing_route_indices"},{"question":"def can_rearrange_to_palindrome(n: int, k: int, s: str) -> str: Determines if it is possible to rearrange the string \`s\` into a palindrome with at most \`k\` changes. Parameters: n (int): The length of the string and number of types of flowers. k (int): The maximum number of changes allowed. s (str): The current arrangement of flowers. Returns: str: \\"YES\\" if possible to rearrange into a palindrome with at most \`k\` changes, otherwise \\"NO\\". from solution import can_rearrange_to_palindrome def test_case_1(): assert can_rearrange_to_palindrome(5, 1, \\"12321\\") == \\"YES\\" def test_case_2(): assert can_rearrange_to_palindrome(6, 2, \\"123456\\") == \\"NO\\" def test_case_3(): assert can_rearrange_to_palindrome(5, 2, \\"12231\\") == \\"YES\\" def test_case_4(): assert can_rearrange_to_palindrome(4, 0, \\"1221\\") == \\"YES\\" def test_already_palindrome(): assert can_rearrange_to_palindrome(3, 0, \\"121\\") == \\"YES\\" def test_more_changes_than_needed(): assert can_rearrange_to_palindrome(6, 3, \\"123321\\") == \\"YES\\" def test_exact_changes_needed(): assert can_rearrange_to_palindrome(6, 3, \\"123421\\") == \\"YES\\" def test_not_possible_palindrome(): assert can_rearrange_to_palindrome(6, 1, \\"123456\\") == \\"NO\\"","solution":"def can_rearrange_to_palindrome(n, k, s): Determines if it is possible to rearrange the string \`s\` into a palindrome with at most \`k\` changes. Parameters: n (int): The length of the string and number of types of flowers. k (int): The maximum number of changes allowed. s (str): The current arrangement of flowers. Returns: str: \\"YES\\" if possible to rearrange into a palindrome with at most \`k\` changes, otherwise \\"NO\\". changes_needed = 0 for i in range(n // 2): if s[i] != s[n - 1 - i]: changes_needed += 1 if changes_needed <= k: return \\"YES\\" else: return \\"NO\\""},{"question":"def generate_binary_numbers(n): Generate all unique binary numbers of length n that do not have two consecutive 1s. The function should generate binary numbers in lexicographical order and use dynamic programming or backtracking. :param n: int - Length of the binary numbers :return: List[str] - List of valid binary strings >>> generate_binary_numbers(1) ['0', '1'] >>> generate_binary_numbers(2) ['00', '01', '10'] >>> generate_binary_numbers(3) ['000', '001', '010', '100', '101'] pass def test_generate_binary_numbers_length_1(): assert generate_binary_numbers(1) == ['0', '1'] def test_generate_binary_numbers_length_2(): assert generate_binary_numbers(2) == ['00', '01', '10'] def test_generate_binary_numbers_length_3(): assert generate_binary_numbers(3) == ['000', '001', '010', '100', '101'] def test_generate_binary_numbers_length_4(): assert generate_binary_numbers(4) == ['0000', '0001', '0010', '0100', '0101', '1000', '1001', '1010'] def test_generate_binary_numbers_length_5(): assert generate_binary_numbers(5) == ['00000', '00001', '00010', '00100', '00101', '01000', '01001', '01010', '10000', '10001', '10010', '10100', '10101']","solution":"def generate_binary_numbers(n): Generate all unique binary numbers of length n that do not have two consecutive 1s. :param n: int :return: List of valid binary strings def is_valid(num): Check if a binary number contains two consecutive 1s. return '11' not in num def backtrack(path): Use backtracking to generate all binary numbers of length n. if len(path) == n: if is_valid(path): result.append(path) return backtrack(path + '0') backtrack(path + '1') result = [] backtrack('') return result"},{"question":"def kth_smallest_positive_element(N, K, arr): Returns the K-th smallest positive element in the array. If there are fewer than K positive elements, returns -1. >>> kth_smallest_positive_element(5, 2, [3, 1, -1, 4, 0]) == 3 >>> kth_smallest_positive_element(5, 5, [3, 1, 0, 2, 6]) == -1 >>> kth_smallest_positive_element(6, 1, [0, -1, -2, -3, -4, -5]) == -1 >>> kth_smallest_positive_element(1, 1, [5]) == 5 >>> kth_smallest_positive_element(1, 1, [-5]) == -1 >>> kth_smallest_positive_element(4, 2, [-1, -2, -3, -4]) == -1 >>> kth_smallest_positive_element(4, 4, [1, 3, 2, 4]) == 4 >>> kth_smallest_positive_element(6, 3, [5, 1, 4, 3, 2, 6]) == 3","solution":"def kth_smallest_positive_element(N, K, arr): Returns the K-th smallest positive element in the array. If there are fewer than K positive elements, returns -1. # Filter positive elements positive_elements = [x for x in arr if x > 0] # Sort the positive elements positive_elements.sort() # Check if there are at least K positive elements if len(positive_elements) >= K: return positive_elements[K-1] else: return -1"},{"question":"def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two sorted lists into one sorted list without duplicates. Parameters: list1 (list): A list of sorted integers. list2 (list): A list of sorted integers. Returns: list: A sorted list containing all unique elements from both input lists. >>> merge_sorted_lists([1, 3, 5, 7], [2, 3, 6, 8]) [1, 2, 3, 5, 6, 7, 8] >>> merge_sorted_lists([], [1, 2, 3, 4]) [1, 2, 3, 4] >>> merge_sorted_lists([1, 1, 1, 1], [2, 2, 2, 2]) [1, 2] >>> merge_sorted_lists([-3, 0, 3], [-2, 1, 2]) [-3, -2, 0, 1, 2, 3] >>> merge_sorted_lists([], []) []","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into one sorted list without duplicates. Parameters: list1 (list): A list of sorted integers. list2 (list): A list of sorted integers. Returns: list: A sorted list containing all unique elements from both input lists. result = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: if not result or result[-1] != list1[i]: result.append(list1[i]) i += 1 elif list1[i] > list2[j]: if not result or result[-1] != list2[j]: result.append(list2[j]) j += 1 else: if not result or result[-1] != list1[i]: result.append(list1[i]) i += 1 j += 1 while i < len(list1): if not result or result[-1] != list1[i]: result.append(list1[i]) i += 1 while j < len(list2): if not result or result[-1] != list2[j]: result.append(list2[j]) j += 1 return result"},{"question":"from typing import List from math import gcd from functools import reduce def min_possible_max_element(arr: List[int]) -> int: Returns the minimum possible value of the maximum element in the sequence after performing any number of the allowed operations. >>> min_possible_max_element([2, 6, 8, 10]) 2 >>> min_possible_max_element([15, 25, 35]) 5 >>> min_possible_max_element([5, 5, 5]) 5 >>> min_possible_max_element([7, 11, 13]) 1 >>> min_possible_max_element([3, 3, 3, 3]) 3 >>> min_possible_max_element([12, 15, 18]) 3 >>> min_possible_max_element([10, 15]) 5 >>> min_possible_max_element([1000000000, 500000000, 250000000]) 250000000 >>> min_possible_max_element([1000000000, 999999999, 999999998]) 1 pass # Your implementation goes here","solution":"from math import gcd from functools import reduce def min_possible_max_element(arr): Returns the minimum possible value of the maximum element in the sequence after performing any number of the allowed operations. return reduce(gcd, arr) # Example Usage # n = 4 # arr = [2, 6, 8, 10] # result = min_possible_max_element(arr) # print(result) # Output: 2"},{"question":"def unique_clusters(n: int, features: List[Tuple[int, int, int]]) -> int: Returns the number of unique clusters given the list of features of robots. :param n: Number of robots (int) :param features: A list of tuples, where each tuple contains three integers (xi, yi, zi) :return: Number of unique clusters (int) >>> unique_clusters(5, [(1, 2, 3), (4, 5, 6), (1, 2, 3), (7, 8, 9), (4, 5, 6)]) 3 >>> unique_clusters(3, [(10, 20, 30), (10, 20, 30), (10, 20, 30)]) 1 >>> unique_clusters(4, [(1, 2, 3), (4, 5, 6), (7, 8, 9), (10, 11, 12)]) 4 >>> unique_clusters(6, [(1, 1, 1), (2, 2, 2), (1, 1, 1), (2, 2, 2), (3, 3, 3), (4, 4, 4)]) 4 >>> unique_clusters(2, [(50, 50, 50), (50, 50, 50)]) 1","solution":"def unique_clusters(n, features): Returns the number of unique clusters given the list of features of robots. :param n: Number of robots (int) :param features: A list of tuples, where each tuple contains three integers (xi, yi, zi) :return: Number of unique clusters (int) # Use a set to store unique feature combinations unique_combinations = set(features) # The number of unique clusters is the length of the set return len(unique_combinations)"},{"question":"def solve_laborinth(input_text: str) -> str: You are given a labyrinth represented as a grid of cells, where each cell is either free space ('.') or a wall ('#'). Your task is to determine if it's possible to travel from the top-left corner of the grid to the bottom-right corner. You can move up, down, left, or right, but you cannot move through walls or outside the grid. Write a program that reads the labyrinth grid and outputs \\"Yes\\" if there is a path from the top-left corner to the bottom-right corner, and \\"No\\" otherwise. Input The input consists of a series of datasets. Each dataset is provided in the following format: N M row_1 row_2 ... row_N N is the number of rows and M is the number of columns in the grid. The following N lines each contain a string of M characters that represent the layout of the labyrinth. You may assume the following: 2 ≤ N, M ≤ 1000. The input is terminated by N = M = 0. Output For each dataset, output \\"Yes\\" if there is a path, or \\"No\\" otherwise. Examples: >>> input_data = '''4 4 ... .. ... ..#. ... #. ... .... ... 3 3 ... .#. ... ... ... ..# ... 5 5 ... ..... ... .#.#. ... .#.#. ... .#.#. ... ..... ... 0 0''' >>> solve_laborinth(input_data) 'YesnNonYes' >>> input_data = '''3 3 ... ... ... ... ... ... ... 0 0''' >>> solve_laborinth(input_data) 'Yes' >>> input_data = '''2 2 ... ... ... 0 0''' >>> solve_laborinth(input_data) 'No' >>> input_data = '''3 3 ... # ... #.# ... # ... 0 0''' >>> solve_laborinth(input_data) 'No' >>> input_data = '''5 5 ... ..... ... #.# ... #.#.# ... .#... ... # ... 0 0''' >>> solve_laborinth(input_data) 'No'","solution":"def is_path_possible(grid): n, m = len(grid), len(grid[0]) if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 'No' def dfs(x, y, visited): if x == n-1 and y == m-1: return True visited.add((x, y)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and (nx, ny) not in visited: if dfs(nx, ny, visited): return True return False visited = set() if dfs(0, 0, visited): return 'Yes' else: return 'No' def solve_laborinth(input_text): input_lines = input_text.strip().split('n') index = 0 results = [] while index < len(input_lines): line = input_lines[index] n, m = map(int, line.split()) if n == 0 and m == 0: break grid = [] for i in range(n): index += 1 grid.append(input_lines[index]) results.append(is_path_possible(grid)) index += 1 return \\"n\\".join(results)"},{"question":"def can_reorder_array(n, d, array): Determine if it's possible to reorder the array such that the difference between any two adjacent elements is at most d. >>> can_reorder_array(4, 2, [1, 5, 3, 8]) \\"NO\\" >>> can_reorder_array(5, 3, [10, 1, 7, 4, 6]) \\"YES\\" >>> can_reorder_array(3, 1, [3, 3, 3]) \\"YES\\" >>> can_reorder_array(3, 1, [1, 2, 3]) \\"YES\\" >>> can_reorder_array(3, 1, [1, 4, 2]) \\"NO\\" def process_test_cases(T, test_cases): Process multiple test cases to determine if it's possible to reorder each array. >>> T = 3 >>> test_cases = [(4, 2, [1, 5, 3, 8]), (5, 3, [10, 1, 7, 4, 6]), (3, 1, [3, 3, 3])] >>> process_test_cases(T, test_cases) [\\"NO\\", \\"YES\\", \\"YES\\"] >>> T = 2 >>> test_cases = [(3, 2, [1, 3, 2]), (4, 5, [5, 10, 15, 20])] >>> process_test_cases(T, test_cases) [\\"YES\\", \\"YES\\"] >>> T = 1 >>> test_cases = [(4, 1, [1, 2, 3, 5])] >>> process_test_cases(T, test_cases) [\\"NO\\"]","solution":"def can_reorder_array(n, d, array): Determine if it's possible to reorder the array such that the difference between any two adjacent elements is at most d. array.sort() for i in range(1, n): if array[i] - array[i-1] > d: return \\"NO\\" return \\"YES\\" def process_test_cases(T, test_cases): results = [] for i in range(T): n, d, array = test_cases[i] result = can_reorder_array(n, d, array) results.append(result) return results"},{"question":"def max_energy(F: int, Ea: int, Eo: int) -> int: Returns the maximum energy Om Nom can accumulate in one day given the number of fruits he can gather and the energy values of apples and oranges. >>> max_energy(8, 3, 2) == 24 >>> max_energy(8, 3, 5) == 40 >>> max_energy(5, 4, 4) == 20 >>> max_energy(1, 1, 1) == 1 >>> max_energy(1000000000, 999999999, 1000000000) == 1000000000000000000","solution":"def max_energy(F, Ea, Eo): Returns the maximum energy Om Nom can accumulate in one day given the number of fruits he can gather and the energy values of apples and oranges. # Calculate the maximum energy by comparing energies of apples and oranges if Ea > Eo: # Apples provide more energy, so pick only apples return F * Ea else: # Oranges provide more energy, so pick only oranges return F * Eo"},{"question":"def is_prime(num: int) -> bool: Determines if the given number is a prime number. A prime number is greater than 1 and has no divisors other than 1 and itself. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(5) == True >>> is_prime(9) == False >>> is_prime(11) == True >>> is_prime(1) == False >>> is_prime(0) == False >>> is_prime(-5) == False def largest_prime_in_list(lst: List[int]) -> int: Takes a list of integers and returns the largest prime number in it. If there are no primes in the list, returns -1. >>> largest_prime_in_list([15, 3, 8, 6, 12, 9]) == 3 >>> largest_prime_in_list([4, 6, 8, 12]) == -1 >>> largest_prime_in_list([7, 10, 2]) == 7 >>> largest_prime_in_list([19, 23, 17, 90, 86]) == 23 >>> largest_prime_in_list([]) == -1 >>> largest_prime_in_list([13]) == 13 >>> largest_prime_in_list([0, 1, 14, 15]) == -1 >>> largest_prime_in_list([2, 2, 2]) == 2","solution":"def is_prime(num): Determines if the given number is a prime number. A prime number is greater than 1 and has no divisors other than 1 and itself. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def largest_prime_in_list(lst): Takes a list of integers and returns the largest prime number in it. If there are no primes in the list, returns -1. primes = [num for num in lst if is_prime(num)] return max(primes, default=-1)"},{"question":"def can_transform(s: str, t: str) -> str: Determines if string s can be transformed into string t by removing zero or more characters from s. >>> can_transform(\\"abpcplea\\", \\"apple\\") \\"YES\\" >>> can_transform(\\"abpcplea\\", \\"applez\\") \\"NO\\" >>> can_transform(\\"aaa\\", \\"aaaa\\") \\"NO\\" >>> can_transform(\\"aaaa\\", \\"aaa\\") \\"YES\\" >>> can_transform(\\"abc\\", \\"\\") \\"YES\\" >>> can_transform(\\"\\", \\"a\\") \\"NO\\" >>> can_transform(\\"abcdefghijklmnopqrstuvwxyz\\", \\"az\\") \\"YES\\" >>> can_transform(\\"abcdefghijklmnopqrstuvwxyz\\", \\"zy\\") \\"NO\\" >>> can_transform(\\"abcde\\", \\"abcde\\") \\"YES\\" >>> can_transform(\\"abc\\", \\"def\\") \\"NO\\"","solution":"def can_transform(s, t): Determines if string s can be transformed into string t by removing zero or more characters from s. # Use two pointers to check if t is a subsequence of s it = iter(s) # Check if all characters of t can be found in s in order if all(char in it for char in t): return \\"YES\\" else: return \\"NO\\""},{"question":"import heapq from typing import List, Tuple def find_minimum_weight_path(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Find the minimum weight path from node 1 to node n in an undirected graph. Args: n (int): Number of nodes. m (int): Number of edges. edges (List[Tuple[int, int, int]]): List of edges where each edge is represented by a tuple (u, v, w) indicating an edge between nodes u and v with weight w. Returns: int: The minimum weight from node 1 to node n. If there is no path, return -1. Examples: >>> find_minimum_weight_path(5, 6, [(1, 2, 4), (1, 3, 2), (2, 3, 3), (3, 4, 1), (4, 5, 5), (2, 5, 7)]) 8 >>> find_minimum_weight_path(4, 2, [(1, 2, 3), (3, 4, 1)]) -1","solution":"import heapq def find_minimum_weight_path(n, m, edges): graph = {i: [] for i in range(1, n+1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) def dijkstra(source, target): heap = [(0, source)] distances = {i: float('inf') for i in range(1, n+1)} distances[source] = 0 while heap: current_distance, node = heapq.heappop(heap) if node == target: return current_distance if current_distance > distances[node]: continue for neighbor, weight in graph[node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(heap, (distance, neighbor)) return float('inf') result = dijkstra(1, n) return result if result != float('inf') else -1"},{"question":"def rounds_to_meet(P: int, Alice: int, Bob: int) -> int: Returns the smallest number of rounds necessary for Alice to compete against Bob. >>> rounds_to_meet(8, 1, 8) 3 >>> rounds_to_meet(16, 3, 10) 4 pass","solution":"def rounds_to_meet(P, Alice, Bob): Returns the smallest number of rounds necessary for Alice to compete against Bob. rounds = 0 while Alice != Bob: Alice = (Alice + 1) // 2 Bob = (Bob + 1) // 2 rounds += 1 return rounds"},{"question":"def longest_contiguous_subarray_length(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Write a function that takes an array of integers and returns the length of the longest contiguous subarray having the same value for each test case. :param t: Number of test cases. :param test_cases: A list of tuples where each tuple consists of an integer N and a list of N integers. :return: A list of integers representing the length of the longest contiguous subarray with the same value for each test case. >>> longest_contiguous_subarray_length(2, [(8, [1, 2, 2, 2, 3, 3, 4, 4]), (6, [10, 10, 10, 10, 10, 5])]) [3, 5] >>> longest_contiguous_subarray_length(1, [(1, [1])]) [1]","solution":"def longest_contiguous_subarray_length(t, test_cases): Returns the length of the longest contiguous subarray having the same value for each test case. :param t: Number of test cases. :param test_cases: A list containing the test cases. Each test case is a tuple (N, array). :return: A list containing the length of the longest contiguous subarray with the same value for each test case. results = [] for i in range(t): n, arr = test_cases[i] max_len = 1 current_len = 1 for j in range(1, n): if arr[j] == arr[j - 1]: current_len += 1 if current_len > max_len: max_len = current_len else: current_len = 1 results.append(max_len) return results"},{"question":"def card_game_winner(n: int, cards: List[int]) -> str: Determine whether Alex will win, Blake will win, or the game will end in a draw. Args: n (int): Number of cards cards (List[int]): List of card values Returns: str: \\"Alex\\" if Alex wins, \\"Blake\\" if Blake wins, or \\"Draw\\" if it's a draw Examples: >>> card_game_winner(4, [1, 2, 9, 4]) 'Alex' >>> card_game_winner(2, [8, 8]) 'Draw'","solution":"def card_game_winner(n, cards): dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = cards[i] for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 dp[i][j] = max(cards[i] - dp[i + 1][j], cards[j] - dp[i][j - 1]) result = dp[0][n - 1] if result > 0: return \\"Alex\\" elif result < 0: return \\"Blake\\" else: return \\"Draw\\""},{"question":"def evaluate_trend(n: int, results: list) -> str: Evaluates if the drug's effectiveness shows a strictly increasing trend. Parameters: n (int): Number of test results. results (list of floats): List of test results. Returns: str: \\"Consistent Improvement\\" if it shows a strictly increasing trend, otherwise \\"Further Testing Needed\\". Examples: >>> evaluate_trend(5, [0.1, 0.2, 0.3, 0.4, 0.5]) \\"Consistent Improvement\\" >>> evaluate_trend(4, [1.5, 1.5, 1.6, 1.7]) \\"Further Testing Needed\\" >>> evaluate_trend(3, [2.3, 2.2, 2.5]) \\"Further Testing Needed\\" >>> evaluate_trend(2, [1.0, 1.0]) \\"Further Testing Needed\\" >>> evaluate_trend(2, [1.0, 2.0]) \\"Consistent Improvement\\"","solution":"def evaluate_trend(n, results): Evaluates if the drug's effectiveness shows a strictly increasing trend. Parameters: n (int): Number of test results. results (list of floats): List of test results. Returns: str: \\"Consistent Improvement\\" if it shows a strictly increasing trend, otherwise \\"Further Testing Needed\\". for i in range(1, n): if results[i] <= results[i - 1]: return \\"Further Testing Needed\\" return \\"Consistent Improvement\\""},{"question":"from typing import List, Tuple def longest_contiguous_same_parity_sublist(lst: List[int]) -> List[int]: Given a list of integer numbers, identify and return a sublist that forms the longest contiguous subsequence where all elements are of the same parity (either all odd or all even). >>> longest_contiguous_same_parity_sublist([1, 2, 2, 2, 5, 7, 6, 4]) [2, 2, 2] >>> longest_contiguous_same_parity_sublist([10, 12, 14, 1, 3]) [10, 12, 14] >>> longest_contiguous_same_parity_sublist([2, 4, 8, 1, 1, 1, 2, 2]) [2, 4, 8] >>> longest_contiguous_same_parity_sublist([1, 1, 1, 2, 2, 3, 3]) [1, 1, 1] >>> longest_contiguous_same_parity_sublist([10, 10, 10]) [10, 10, 10] def solve(test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: For each test case, print the longest contiguous subsequence that contains elements of the same parity. If there are multiple answers, print the one that appears first. >>> solve([(8, [1, 2, 2, 2, 5, 7, 6, 4]), (5, [10, 12, 14, 1, 3])]) [[2, 2, 2], [10, 12, 14]] def parse_input(input_text: str) -> List[Tuple[int, List[int]]]: Parses the input text. >>> parse_input(\\"2n8n1 2 2 2 5 7 6 4n5n10 12 14 1 3n\\") [(8, [1, 2, 2, 2, 5, 7, 6, 4]), (5, [10, 12, 14, 1, 3])]","solution":"def longest_contiguous_same_parity_sublist(lst): Returns a sublist that forms the longest contiguous subsequence where all elements are of the same parity (either all odd or all even). max_length = 0 current_length = 0 best_start_index = 0 start_index = 0 is_even = lst[0] % 2 == 0 for i in range(len(lst)): if lst[i] % 2 == (0 if is_even else 1): current_length += 1 else: if current_length > max_length: max_length = current_length best_start_index = start_index start_index = i current_length = 1 is_even = lst[i] % 2 == 0 if current_length > max_length: max_length = current_length best_start_index = start_index return lst[best_start_index: best_start_index + max_length] def solve(test_cases): results = [] for t in test_cases: n, lst = t result = longest_contiguous_same_parity_sublist(lst) results.append(result) return results def parse_input(input_text): lines = input_text.split(\\"n\\") t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) lst = list(map(int, lines[index + 1].split())) test_cases.append((n, lst)) index += 2 return test_cases"},{"question":"def chunk_averages(numbers: List[int], k: int) -> List[float]: Given a list of integers and an integer k, returns a list of averages of the integers in chunks of size k. If the last chunk contains fewer than k numbers, the average for that partial chunk is also computed. Each average is rounded to two decimal places. >>> chunk_averages([1, 2, 3, 4, 5, 6, 7], 3) [2.0, 5.0, 7.0] >>> chunk_averages([1, 2, 3, 4, 5, 6, 7, 8], 3) [2.0, 5.0, 7.5] >>> chunk_averages([1, 2, 3, 4, 5], 1) [1.0, 2.0, 3.0, 4.0, 5.0] >>> chunk_averages([1, 2, 3, 4, 5], 5) [3.0] >>> chunk_averages([-3, -2, -1, 1, 2, 3], 2) [-2.5, 0.0, 2.5] >>> chunk_averages([7, 7, 7, 7, 7, 7], 2) [7.0, 7.0, 7.0] >>> chunk_averages([1, 2, 3], 3) [2.0] >>> chunk_averages([1], 1) [1.0]","solution":"def chunk_averages(numbers, k): Returns a list of averages of \`numbers\` in chunks of size \`k\`. Each average is rounded to two decimal places. averages = [] for i in range(0, len(numbers), k): chunk = numbers[i:i+k] avg = round(sum(chunk) / len(chunk), 2) averages.append(avg) return averages"},{"question":"def num_of_distinct_paths(N: int, M: int) -> int: Returns the number of distinct valid paths from the top-left corner to the bottom-right corner of an N x M grid. # <<Your implementation here>> # Unit tests def test_num_of_distinct_paths_3x3(): assert num_of_distinct_paths(3, 3) == 6 def test_num_of_distinct_paths_4x2(): assert num_of_distinct_paths(4, 2) == 4 def test_num_of_distinct_paths_5x5(): assert num_of_distinct_paths(5, 5) == 70 def test_num_of_distinct_paths_2x2(): assert num_of_distinct_paths(2, 2) == 2 def test_num_of_distinct_paths_1x1(): assert num_of_distinct_paths(1, 1) == 1 # Base case def test_num_of_distinct_paths_1x5(): assert num_of_distinct_paths(1, 5) == 1 # Only one way to move in a single row def test_num_of_distinct_paths_5x1(): assert num_of_distinct_paths(5, 1) == 1 # Only one way to move in a single column def test_num_of_distinct_paths_large_grid(): assert num_of_distinct_paths(100, 100) > 0 # Ensure it works for large input sizes","solution":"def num_of_distinct_paths(N, M): Returns the number of distinct valid paths from the top-left corner to the bottom-right corner of an N x M grid. # Using dynamic programming to solve this problem dp = [[0] * M for _ in range(N)] # There is only one way to reach any cell in the first row (all rights) for i in range(M): dp[0][i] = 1 # There is only one way to reach any cell in the first column (all downs) for j in range(N): dp[j][0] = 1 # Fill the DP table for i in range(1, N): for j in range(1, M): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[N-1][M-1] # Read input from standard input if __name__ == \\"__main__\\": import sys input = sys.stdin.read().strip() N, M = map(int, input.split()) print(num_of_distinct_paths(N, M))"},{"question":"def validate_molecular_weights(test_cases, element_weights): Validate the list of molecular weights for each given chemical formula. >>> validate_molecular_weights([('H2O', 18)], {'H': 1, 'He': 4, 'Li': 7, 'Be': 9, 'B': 11, 'C': 12, 'N': 14, 'O': 16, 'F': 19, 'Ne': 20}) [\\"Correct\\"] >>> validate_molecular_weights([('CO2', 44)], {'H': 1, 'He': 4, 'Li': 7, 'Be': 9, 'B': 11, 'C': 12, 'N': 14, 'O': 16, 'F': 19, 'Ne': 20}) [\\"Correct\\"] >>> validate_molecular_weights([('C6H12O6', 180)], {'H': 1, 'He': 4, 'Li': 7, 'Be': 9, 'B': 11, 'C': 12, 'N': 14, 'O': 16, 'F': 19, 'Ne': 20}) [\\"Correct\\"] >>> validate_molecular_weights([('H2O', 19)], {'H': 1, 'He': 4, 'Li': 7, 'Be': 9, 'B': 11, 'C': 12, 'N': 14, 'O': 16, 'F': 19, 'Ne': 20}) [\\"Incorrect\\"] >>> validate_molecular_weights([('CO2', 45)], {'H': 1, 'He': 4, 'Li': 7, 'Be': 9, 'B': 11, 'C': 12, 'N': 14, 'O': 16, 'F': 19, 'Ne': 20}) [\\"Incorrect\\"] pass element_weights = { 'H': 1, 'He': 4, 'Li': 7, 'Be': 9, 'B': 11, 'C': 12, 'N': 14, 'O': 16, 'F': 19, 'Ne': 20 }","solution":"def validate_molecular_weights(test_cases, element_weights): results = [] for formula, expected_weight in test_cases: calculated_weight = 0 i = 0 while i < len(formula): if formula[i].isalpha(): element = formula[i] i += 1 count = 0 while i < len(formula) and formula[i].isdigit(): count = count * 10 + int(formula[i]) i += 1 count = max(count, 1) # Default to 1 if there's no digit after the element symbol calculated_weight += element_weights[element] * count if calculated_weight == expected_weight: results.append(\\"Correct\\") else: results.append(\\"Incorrect\\") return results element_weights = { 'H': 1, 'He': 4, 'Li': 7, 'Be': 9, 'B': 11, 'C': 12, 'N': 14, 'O': 16, 'F': 19, 'Ne': 20 }"},{"question":"def number_of_paths(grid, n, m): Determine the number of distinct paths from the top-left corner to the bottom-right corner of the grid, avoiding obstacles. Args: grid (List[List[str]]): The grid representation, where '.' is a clear path and '#' is an obstacle. n (int): Number of rows in the grid. m (int): Number of columns in the grid. Returns: int: The number of distinct paths to the destination. >>> number_of_paths([['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']], 3, 3) 2 >>> number_of_paths([['.', '#'], ['#', '.']], 2, 2) 0 pass def distinct_paths(test_cases): Process multiple test cases to determine the number of distinct paths for each grid configuration. Args: test_cases (List[Tuple[int, int, List[List[str]]]]): A list of test cases, each containing the grid dimensions and the grid itself. Returns: List[int]: A list of results for each test case. Example: For input: [ (3, 3, [['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]), (2, 2, [['.', '#'], ['#', '.']]) ] The output should be [2, 0] pass # Unit Tests def test_example_cases(): test_cases = [ (3, 3, [ ['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.'] ]), (2, 2, [ ['.', '#'], ['#', '.'] ]) ] results = distinct_paths(test_cases) assert results == [2, 0] def test_no_obstacles(): test_cases = [ (2, 2, [ ['.', '.'], ['.', '.'] ]) ] results = distinct_paths(test_cases) assert results == [2] def test_full_path_blocked(): test_cases = [ (2, 3, [ ['.', '#', '.'], ['#', '#', '.'] ]) ] results = distinct_paths(test_cases) assert results == [0] def test_single_cell_path(): test_cases = [ (1, 1, [ ['.'] ]) ] results = distinct_paths(test_cases) assert results == [1] def test_single_row_or_column(): test_cases = [ (1, 3, [ ['.', '.', '.'] ]), (3, 1, [ ['.'], ['.'], ['.'] ]) ] results = distinct_paths(test_cases) assert results == [1, 1] def test_edges_and_corners_blocked(): test_cases = [ (3, 3, [ ['.','#','.'], ['#','.','#'], ['.','#','.'] ]) ] results = distinct_paths(test_cases) assert results == [0]","solution":"def number_of_paths(grid, n, m): # If the starting or ending point is an obstacle if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 dp = [[0 for _ in range(m)] for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1] def distinct_paths(test_cases): results = [] for case in test_cases: n, m, grid = case result = number_of_paths(grid, n, m) results.append(result) return results"},{"question":"def is_magic_square(matrix: List[List[int]]) -> str: Determine if a given matrix is a magic square. >>> is_magic_square([ ... [2, 7, 6], ... [9, 5, 1], ... [4, 3, 8] ... ]) == \\"YES\\" >>> is_magic_square([ ... [16, 3, 2, 13], ... [5, 10, 11, 8], ... [9, 6, 7, 12], ... [4, 15, 14, 1] ... ]) == \\"YES\\" >>> is_magic_square([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == \\"NO\\" pass def process_input(input_data: str) -> List[str]: Process the input data and output results for magic square checking. >>> input_data = '3n2 7 6n9 5 1n4 3 8n4n16 3 2 13n5 10 11 8n9 6 7 12n4 15 14 1n3n1 2 3n4 5 6n7 8 9n' >>> process_input(input_data) == [\\"YES\\", \\"YES\\", \\"NO\\"] pass import pytest def test_is_magic_square(): assert is_magic_square([ [2, 7, 6], [9, 5, 1], [4, 3, 8] ]) == \\"YES\\" assert is_magic_square([ [16, 3, 2, 13], [5, 10, 11, 8], [9, 6, 7, 12], [4, 15, 14, 1] ]) == \\"YES\\" assert is_magic_square([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == \\"NO\\" assert is_magic_square([ [1, 1], [1, 1] ]) == \\"NO\\" assert is_magic_square([ [1] ]) == \\"YES\\" def test_process_input(): input_data = 3 2 7 6 9 5 1 4 3 8 4 16 3 2 13 5 10 11 8 9 6 7 12 4 15 14 1 3 1 2 3 4 5 6 7 8 9 assert process_input(input_data) == [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def is_magic_square(matrix): Function to check if a given matrix is a magic square. Parameters: matrix (list of list of int): The n x n matrix. Returns: str: \\"YES\\" if the matrix is a magic square, \\"NO\\" otherwise. n = len(matrix) # Get the magic constant using the first row magic_constant = sum(matrix[0]) # Check all rows for row in matrix: if sum(row) != magic_constant: return \\"NO\\" # Check all columns for col in range(n): if sum(matrix[row][col] for row in range(n)) != magic_constant: return \\"NO\\" # Check both diagonals if sum(matrix[i][i] for i in range(n)) != magic_constant: return \\"NO\\" if sum(matrix[i][n - i - 1] for i in range(n)) != magic_constant: return \\"NO\\" # Check for distinct integers elements = set() for row in matrix: for element in row: if element in elements: return \\"NO\\" elements.add(element) return \\"YES\\" def process_input(input_data): Function to process the input data and output results for magic square checking. Parameters: input_data (str): the entire input data as a string Returns: list: List of results, each being \\"YES\\" or \\"NO\\". lines = input_data.strip().split('n') index = 0 results = [] while index < len(lines): n = int(lines[index]) matrix = [] for i in range(n): matrix.append(list(map(int, lines[index + 1 + i].strip().split()))) index += n + 1 results.append(is_magic_square(matrix)) return results # Example usage: input_data = 3 2 7 6 9 5 1 4 3 8 4 16 3 2 13 5 10 11 8 9 6 7 12 4 15 14 1 3 1 2 3 4 5 6 7 8 9 results = process_input(input_data) for result in results: print(result)"},{"question":"from typing import List import math from functools import reduce def canMakeElementsEqual(arr: List[int]) -> bool: Determine if it's possible to make all elements in the array equal using the allowed operations. >>> canMakeElementsEqual([6, 9, 3]) True >>> canMakeElementsEqual([8, 5, 7, 13]) False import pytest def test_single_element_array(): assert canMakeElementsEqual([7]) == True def test_two_elements_with_gcd_1(): assert canMakeElementsEqual([7, 3]) == False def test_two_elements_with_gcd_greater_than_1(): assert canMakeElementsEqual([6, 9]) == True def test_multiple_elements_with_same_gcd(): assert canMakeElementsEqual([12, 15, 9, 18]) == True def test_multiple_elements_with_different_gcd(): assert canMakeElementsEqual([8, 5, 7, 13]) == False def test_multiple_elements_reducible_to_gcd_1(): assert canMakeElementsEqual([6, 10, 15]) == False def test_multiple_elements_reducible_to_same_gcd_greater_than_1(): assert canMakeElementsEqual([6, 12, 18]) == True def test_all_elements_equal(): assert canMakeElementsEqual([7, 7, 7, 7]) == True","solution":"import math from functools import reduce def canMakeElementsEqual(arr): Determine if it's possible to make all elements in the array equal using the allowed operations. if len(arr) == 1: return True # Calculate the GCD of the entire array gcd_value = reduce(math.gcd, arr) # If the GCD is greater than 1, it's possible to make all elements equal return gcd_value > 1"},{"question":"def min_boxes(N: int, M: int, weights: List[int]) -> int: Determines the minimum number of boxes required to pack all items such that the total weight in any box does not exceed M grams. Args: N : int : number of items M : int : maximum allowed weight per box weights : List[int] : weights of items Returns: int : minimum number of boxes required Examples: >>> min_boxes(3, 10, [2, 4, 6]) 2 >>> min_boxes(5, 5, [1, 2, 3, 4, 5]) 3 from solution import min_boxes def test_example_1(): assert min_boxes(3, 10, [2, 4, 6]) == 2 def test_example_2(): assert min_boxes(5, 5, [1, 2, 3, 4, 5]) == 3 def test_all_items_same_weight(): assert min_boxes(5, 10, [2, 2, 2, 2, 2]) == 1 def test_all_items_have_max_weight(): assert min_boxes(3, 10, [10, 10, 10]) == 3 def test_single_item(): assert min_boxes(1, 5, [3]) == 1 def test_large_number_of_items(): assert min_boxes(100000, 1000000000, [1]*100000) == 1 def test_heavy_items(): assert min_boxes(4, 15, [7, 8, 7, 8]) == 2 def test_no_items(): assert min_boxes(0, 10, []) == 0 def test_single_large_box(): assert min_boxes(100, 100000, [1000]*100) == 1","solution":"def min_boxes(N, M, weights): Determines the minimum number of boxes required to pack all items such that the total weight in any box does not exceed M grams. weights.sort(reverse=True) box_count = 0 while weights: box_weight = 0 i = 0 while i < len(weights): if box_weight + weights[i] <= M: box_weight += weights[i] weights.pop(i) else: i += 1 box_count += 1 return box_count"},{"question":"def hamiltonian_path_exists(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determine if there exists a Hamiltonian cycle in the given undirected graph. Args: n (int): Number of nodes in the graph. m (int): Number of edges in the graph. edges (List[Tuple[int, int]]): List of edges represented as tuples (u, v). Returns: str: \\"Yes\\" if a Hamiltonian cycle exists, otherwise \\"No\\". >>> hamiltonian_path_exists(4, 6, [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3), (2, 4)]) 'Yes' >>> hamiltonian_path_exists(4, 4, [(1, 2), (2, 3), (3, 4), (1, 3)]) 'No' >>> hamiltonian_path_exists(3, 0, []) 'No' >>> hamiltonian_path_exists(1, 0, []) 'No' >>> hamiltonian_path_exists(5, 10, [(1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)]) 'Yes' >>> hamiltonian_path_exists(4, 2, [(1, 2), (3, 4)]) 'No' >>> hamiltonian_path_exists(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 'Yes'","solution":"from itertools import permutations def is_hamiltonian_cycle(n, edges): graph = {i: set() for i in range(1, n+1)} for u, v in edges: graph[u].add(v) graph[v].add(u) nodes = list(graph.keys()) for start in nodes: for perm in permutations(nodes): if perm[0] != start: continue is_cycle = True for i in range(n): if perm[i] not in graph[perm[(i+1) % n]]: is_cycle = False break if is_cycle: return \\"Yes\\" return \\"No\\" def hamiltonian_path_exists(n, m, edges): return is_hamiltonian_cycle(n, edges)"},{"question":"def dfs(graph, v, visited, rec_stack): This function performs a Depth First Search (DFS) traversal on a graph starting from vertex v. It uses visited and rec_stack arrays to keep track of visited nodes and nodes in the current recursion stack respectively. visited[v] = True rec_stack[v] = True for neighbor in graph[v]: if not visited[neighbor]: if dfs(graph, neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: return True rec_stack[v] = False return False def has_cycle(graph, n): This function checks if a cycle is present in a directed graph. visited = [False] * n rec_stack = [False] * n for node in range(n): if not visited[node]: if dfs(graph, node, visited, rec_stack): return True return False def detect_cycle(n, m, edges): This function builds the graph from the given edges and determines if there is a cycle. Returns \\"Cycle Detected\\" if there is a cycle, otherwise returns \\"No Cycle Detected\\". Parameters: n (int): Number of vertices. m (int): Number of edges. edges (List[Tuple[int, int]]): List of edges represented as tuples (u, v). Returns: str: \\"Cycle Detected\\" or \\"No Cycle Detected\\" Examples: >>> detect_cycle(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]) 'Cycle Detected' >>> detect_cycle(3, 2, [(1, 2), (2, 3)]) 'No Cycle Detected' graph = [[] for _ in range(n)] for u, v in edges: graph[u-1].append(v-1) if has_cycle(graph, n): return \\"Cycle Detected\\" else: return \\"No Cycle Detected\\" # Unit Tests import pytest def test_detect_cycle_with_cycle(): n = 4 m = 4 edges = [(1, 2), (2, 3), (3, 4), (4, 2)] assert detect_cycle(n, m, edges) == \\"Cycle Detected\\" def test_detect_cycle_no_cycle(): n = 3 m = 2 edges = [(1, 2), (2, 3)] assert detect_cycle(n, m, edges) == \\"No Cycle Detected\\" def test_detect_cycle_single_node_no_edges(): n = 1 m = 0 edges = [] assert detect_cycle(n, m, edges) == \\"No Cycle Detected\\" def test_detect_cycle_two_nodes_no_cycle(): n = 2 m = 1 edges = [(1, 2)] assert detect_cycle(n, m, edges) == \\"No Cycle Detected\\" def test_detect_cycle_two_nodes_with_cycle(): n = 2 m = 2 edges = [(1, 2), (2, 1)] assert detect_cycle(n, m, edges) == \\"Cycle Detected\\" def test_detect_cycle_complex_cycle(): n = 5 m = 6 edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (3, 5)] assert detect_cycle(n, m, edges) == \\"Cycle Detected\\"","solution":"def dfs(graph, v, visited, rec_stack): visited[v] = True rec_stack[v] = True # Recur for all neighbors of v for neighbor in graph[v]: if not visited[neighbor]: if dfs(graph, neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: return True rec_stack[v] = False return False def has_cycle(graph, n): visited = [False] * n rec_stack = [False] * n for node in range(n): if not visited[node]: if dfs(graph, node, visited, rec_stack): return True return False def detect_cycle(n, m, edges): graph = [[] for _ in range(n)] for u, v in edges: graph[u-1].append(v-1) if has_cycle(graph, n): return \\"Cycle Detected\\" else: return \\"No Cycle Detected\\""},{"question":"def is_point_in_rectangle(x1, y1, x2, y2, px, py): Determines if the point (px, py) lies inside the rectangle defined by the opposite corners (x1, y1) and (x2, y2). >>> is_point_in_rectangle(0, 0, 2, 2, 1, 1) 1 >>> is_point_in_rectangle(0, 0, 2, 2, 3, 3) 0 >>> is_point_in_rectangle(-1, -1, 1, 1, 0, 0) 1 ... def process_queries(queries): Processes a list of query strings, determining if each point lies inside its respective rectangle. Args: - queries: List of query strings where each string contains coordinates x1, y1, x2, y2, px, py separated by spaces. Returns: - List of results where each element is \\"1\\" if the point is inside or on the border of the rectangle, and \\"0\\" otherwise. >>> queries = [ ... \\"0 0 2 2 1 1\\", ... \\"0 0 2 2 3 3\\", ... \\"-1 -1 1 1 0 0\\" ... ] >>> process_queries(queries) [1, 0, 1] ...","solution":"def is_point_in_rectangle(x1, y1, x2, y2, px, py): Determines if the point (px, py) lies inside the rectangle defined by the opposite corners (x1, y1) and (x2, y2). # Ensure the lower bound is always x1, y1 and upper bound is x2, y2 lower_x = min(x1, x2) upper_x = max(x1, x2) lower_y = min(y1, y2) upper_y = max(y1, y2) # Check if point is within bounds (including boundaries) if lower_x <= px <= upper_x and lower_y <= py <= upper_y: return 1 else: return 0 def process_queries(queries): results = [] for query in queries: x1, y1, x2, y2, px, py = map(int, query.split()) result = is_point_in_rectangle(x1, y1, x2, y2, px, py) results.append(result) return results"},{"question":"def sequence_beauty(n: int, seq: List[int]) -> int: Computes the beauty of the given sequence :param n: Length of the sequence :param seq: The sequence of integers :return: The beauty of the sequence Examples: >>> sequence_beauty(5, [1, 2, 1, 2, 1]) 15 >>> sequence_beauty(2, [1, 1]) 3 >>> sequence_beauty(7, [1, 2, 3, 4, 2, 1, 2]) 28 >>> sequence_beauty(1, [10]) 1 >>> sequence_beauty(3, [-1, -1, -1]) 6 >>> sequence_beauty(4, [1, 2, 3, 4]) 10","solution":"def sequence_beauty(n, seq): Computes the beauty of the given sequence :param n: Length of the sequence :param seq: The sequence of integers :return: The beauty of the sequence return n * (n + 1) // 2"},{"question":"from typing import List, Tuple def highest_transaction_employee(transactions: List[Tuple[int, int]]) -> int: Compute the employee ID with the highest total transaction amount. If there's a tie, returns the smallest employee ID among them. Args: transactions (list of tuples): A list where each tuple contains an employee ID and transaction amount. Returns: int: The employee ID with the highest total transaction amount. pass def test_single_transaction(): assert highest_transaction_employee([(1, 500)]) == 1 def test_two_employees_different_totals(): assert highest_transaction_employee([(1, 500), (2, 300)]) == 1 def test_multiple_transactions_single_employee(): assert highest_transaction_employee([(1, 500), (1, 300)]) == 1 def test_multiple_employees_same_totals(): assert highest_transaction_employee([(1, 500), (2, 500)]) == 1 assert highest_transaction_employee([(6, 200), (2, 400), (6, 200), (2, 400)]) == 2 def test_case_with_multiple_transactions(): assert highest_transaction_employee([(1, 500), (2, 300), (1, 200), (2, 400), (3, 600)]) == 1 def test_case_with_multiple_ids_and_high_transaction(): assert highest_transaction_employee([(4, 100), (5, 100), (6, 100), (5, 100)]) == 5","solution":"def highest_transaction_employee(transactions): Compute the employee ID with the highest total transaction amount. If there's a tie, returns the smallest employee ID among them. Args: transactions (list of tuples): A list where each tuple contains an employee ID and transaction amount. Returns: int: The employee ID with the highest total transaction amount. from collections import defaultdict # Dictionary to store total transaction amount for each employee ID transaction_totals = defaultdict(int) # Calculate the total transaction amount for each employee ID for emp_id, amount in transactions: transaction_totals[emp_id] += amount # Find the employee ID with the highest total transaction amount max_amount = max(transaction_totals.values()) max_ids = [emp_id for emp_id, amount in transaction_totals.items() if amount == max_amount] # Return the smallest employee ID among those with the highest total return min(max_ids)"},{"question":"def longest_subsequence(arr): Given an array of integers, finds the length of the longest subsequence where each successive element is greater by 1 than the previous one. Parameters: arr (List[int]): A list of integers. Returns: int: Length of the longest subsequence where each successive element is greater by 1 than the previous one. from solution import longest_subsequence def test_longest_subsequence_example1(): assert longest_subsequence([1, 2, 3, 4, 2, 3, 4, 5]) == 4 def test_longest_subsequence_example2(): assert longest_subsequence([10, 9, 8, 7, 6]) == 1 def test_longest_subsequence_single_element(): assert longest_subsequence([5]) == 1 def test_longest_subsequence_no_consecutive(): assert longest_subsequence([1, 3, 5, 7, 9]) == 1 def test_longest_subsequence_all_consecutive(): assert longest_subsequence([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 9 def test_longest_subsequence_multiple_segments(): assert longest_subsequence([1, 2, 1, 2, 3, 1, 2, 3, 4]) == 4 def test_longest_subsequence_negative_numbers(): assert longest_subsequence([-3, -2, -1, 0, 1, 2]) == 6","solution":"def longest_subsequence(arr): Given an array of integers, finds the length of the longest subsequence where each successive element is greater by 1 than the previous one. if not arr: return 0 longest = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] == arr[i - 1] + 1: current_length += 1 else: longest = max(longest, current_length) current_length = 1 longest = max(longest, current_length) return longest"},{"question":"def is_anagram_substring(str1: str, str2: str) -> str: Determines if str2 is an anagram of any substring of str1. Args: str1 (str): The main string. str2 (str): The string to check as an anagram substring. Returns: str: \\"YES\\" if str2 is an anagram of any substring of str1, otherwise \\"NO\\". >>> is_anagram_substring('abcdefg', 'bca') 'YES' >>> is_anagram_substring('hello', 'world') 'NO' from collections import Counter len1 = len(str1) len2 = len(str2) if len2 > len1: return \\"NO\\" counter2 = Counter(str2) for i in range(len1 - len2 + 1): if Counter(str1[i:i+len2]) == counter2: return \\"YES\\" return \\"NO\\" # Test cases def test_example1(): assert is_anagram_substring('abcdefg', 'bca') == \\"YES\\" def test_example2(): assert is_anagram_substring('hello', 'world') == \\"NO\\" def test_substring_is_full_string(): assert is_anagram_substring('abc', 'abc') == \\"YES\\" def test_no_possible_anagram(): assert is_anagram_substring('abcdefg', 'cbaaa') == \\"NO\\" def test_large_input(): long_str1 = 'a' * 100000 long_str2 = 'a' * 99999 + 'b' assert is_anagram_substring(long_str1, long_str2) == \\"NO\\" def test_multiple_anagrams(): assert is_anagram_substring('anagrammargana', 'anagram') == \\"YES\\"","solution":"def is_anagram_substring(str1, str2): Determines if str2 is an anagram of any substring of str1. from collections import Counter len1 = len(str1) len2 = len(str2) if len2 > len1: return \\"NO\\" counter2 = Counter(str2) for i in range(len1 - len2 + 1): if Counter(str1[i:i+len2]) == counter2: return \\"YES\\" return \\"NO\\""},{"question":"def simulate_elevator(n, m, events): Simulates the behavior of an elevator in a building and tracks the floors visited and the number of people in the elevator. Args: n (int): Number of floors. m (int): Maximum capacity of the elevator. events (list of str): List of events describing people entering and exiting the elevator. Returns: tuple: A tuple where the first element is a list of floors to visit and the second element is the current number of people in the elevator. >>> simulate_elevator(10, 15, [\\"IN 5 1\\", \\"IN 10 2\\", \\"OUT 3 5\\", \\"IN 7 8\\", \\"OUT 4 10\\"]) ([1, 2, 5, 8, 10], 15) >>> simulate_elevator(9, 10, [\\"IN 2 3\\", \\"IN 8 4\\", \\"OUT 5 6\\", \\"IN 3 9\\"]) ([3, 4, 6, 9], 8) >>> simulate_elevator(10, 10, [\\"IN 5 1\\", \\"OUT 5 2\\"]) ([1, 2], 0) >>> simulate_elevator(10, 10, []) ([], 0) >>> simulate_elevator(1000, 100, [\\"IN 20 100\\", \\"OUT 5 200\\", \\"IN 30 300\\"]) ([100, 200, 300], 45)","solution":"def simulate_elevator(n, m, events): Simulates the behavior of an elevator in a building and tracks the floors visited and the number of people in the elevator. Args: n (int): Number of floors. m (int): Maximum capacity of the elevator. events (list of str): List of events describing people entering and exiting the elevator. Returns: tuple: A tuple where the first element is a list of floors to visit and the second element is the current number of people in the elevator. people_in_elevator = 0 floors_to_visit = set() for event in events: parts = event.split() action = parts[0] number_of_people = int(parts[1]) floor = int(parts[2]) if action == \\"IN\\": people_in_elevator += number_of_people elif action == \\"OUT\\": people_in_elevator -= number_of_people floors_to_visit.add(floor) # Converting set to sorted list floors_to_visit = sorted(floors_to_visit) return floors_to_visit, people_in_elevator"},{"question":"def get_files_in_folder(operations: List[Tuple[str, int, int]], queries: List[int]) -> List[List[int]]: Retrieve the list of files contained directly within the specified folder IDs. Args: operations: A list of tuples where each tuple represents either a folder or a file. Each tuple is of the form (\\"folder\\", ID, parentID) or (\\"file\\", ID, parentID). queries: A list of folder IDs for which the files are to be retrieved. Returns: A list of lists, where each inner list contains the file IDs sorted in ascending order for the corresponding folder ID in the queries. Example: >>> operations = [(\\"folder\\", 2, 1), (\\"folder\\", 3, 1), (\\"file\\", 4, 2), (\\"file\\", 5, 2), (\\"file\\", 6, 3), (\\"file\\", 7, 3), (\\"folder\\", 8, 1), (\\"file\\", 9, 8)] >>> queries = [2, 1, 8] >>> get_files_in_folder(operations, queries) [[4, 5], [], [9]] >>> operations = [(\\"folder\\", 2, 1), (\\"folder\\", 3, 1)] >>> queries = [1, 2, 3] >>> get_files_in_folder(operations, queries) [[], [], []]","solution":"def get_files_in_folder(operations, queries): # Create a dictionary to store files for each folder folder_contents = {} for operation in operations: op_type, ID, parentID = operation if op_type == \\"file\\": if parentID not in folder_contents: folder_contents[parentID] = [] folder_contents[parentID].append(ID) results = [] for query in queries: if query in folder_contents: results.append(sorted(folder_contents[query])) else: results.append([]) return results"},{"question":"def merge_trees_max_sum(a: List[int], b: List[int]) -> int: Merge two trees (arrays) to maximize their sum maintaining the order of elements. The merge is done by alternately picking elements from a and b. Returns the maximum possible sum of the merged tree. Args: a (List[int]): Array representing the first tree. b (List[int]): Array representing the second tree. Returns: int: Maximum possible sum of the merged tree. Examples: >>> merge_trees_max_sum([1, 3, 2], [4, 6, 5]) 21 >>> merge_trees_max_sum([10, 15], [5, 7, 20]) 57 >>> merge_trees_max_sum([5, 6], []) 11 >>> merge_trees_max_sum([], [7, 8, 9]) 24","solution":"def merge_trees_max_sum(a, b): Merge two trees (arrays) to maximize their sum maintaining the order of elements. The merge is done by alternately picking elements from a and b. Returns the maximum possible sum of the merged tree. i, j = 0, 0 total_sum = 0 while i < len(a) and j < len(b): if a[i] >= b[j]: total_sum += a[i] i += 1 else: total_sum += b[j] j += 1 while i < len(a): total_sum += a[i] i += 1 while j < len(b): total_sum += b[j] j += 1 return total_sum"},{"question":"from typing import List, Tuple def is_path_possible(n: int, m: int, edges: List[Tuple[int, int]], s: int, d: int) -> str: Determine if there is a path between two specific cities using the route map provided as an adjacency list. :param n: Number of cities :param m: Number of direct bus routes :param edges: List of tuples representing direct bus routes between cities :param s: Source city :param d: Destination city :return: \\"YES\\" if there is a path, otherwise \\"NO\\" >>> is_path_possible(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)], 1, 3) \\"YES\\" >>> is_path_possible(4, 4, [(1, 2), (2, 3), (3, 1), (3, 4)], 1, 4) \\"YES\\" >>> is_path_possible(3, 2, [(1, 2), (2, 3)], 1, 3) \\"YES\\" >>> is_path_possible(3, 2, [(1, 2), (2, 3)], 1, 4) \\"NO\\" >>> is_path_possible(4, 0, [], 1, 3) \\"NO\\" pass def route_checker(test_cases: List[Tuple[int, int, List[Tuple[int, int]], int, int]]) -> List[str]: Determines if there is a path for multiple test cases. :param test_cases: List of test cases where each test case is a tuple of (n, m, edges, s, d) :return: List of results for each test case. \\"YES\\" if there is a path, otherwise \\"NO\\" >>> route_checker([(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)], 1, 3), (4, 4, [(1, 2), (2, 3), (3, 1), (3, 4)], 1, 4)]) [\\"YES\\", \\"YES\\"] >>> route_checker([(3, 2, [(1, 2), (2, 3)], 1, 3), (4, 0, [], 1, 3)]) [\\"YES\\", \\"NO\\"] pass","solution":"def is_path_possible(n, m, edges, s, d): from collections import deque, defaultdict # Creating the adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # BFS to find path from s to d visited = set() queue = deque([s]) while queue: current = queue.popleft() if current == d: return \\"YES\\" if current in visited: continue visited.add(current) for neighbor in graph[current]: if neighbor not in visited: queue.append(neighbor) return \\"NO\\" def route_checker(test_cases): results = [] for case in test_cases: n, m, edges, s, d = case results.append(is_path_possible(n, m, edges, s, d)) return results"},{"question":"def can_divide_teams(n: int, m: int, conflicts: List[Tuple[int, int]]) -> str: Determine whether it is possible to split all the developers into two teams where no two conflicting developers are in the same team. >>> can_divide_teams(4, 3, [(1, 2), (2, 3), (1, 3)]) 'NO' >>> can_divide_teams(5, 2, [(1, 2), (3, 4)]) 'YES' >>> can_divide_teams(6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)]) 'YES' from solution import can_divide_teams def test_example1(): assert can_divide_teams(4, 3, [(1, 2), (2, 3), (1, 3)]) == \\"NO\\" def test_example2(): assert can_divide_teams(5, 2, [(1, 2), (3, 4)]) == \\"YES\\" def test_example3(): assert can_divide_teams(6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)]) == \\"YES\\" def test_no_conflict(): assert can_divide_teams(3, 0, []) == \\"YES\\" def test_one_conflict(): assert can_divide_teams(2, 1, [(1, 2)]) == \\"YES\\" def test_multiple_components(): assert can_divide_teams(6, 3, [(1, 2), (3, 4), (5, 6)]) == \\"YES\\" def test_complex_conflict(): assert can_divide_teams(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) == \\"NO\\"","solution":"def can_divide_teams(n, m, conflicts): from collections import defaultdict, deque # Initialize a graph from the list of conflicts graph = defaultdict(list) for a, b in conflicts: graph[a].append(b) graph[b].append(a) # Array to store the team assignment, -1 means unassigned team = [-1] * (n + 1) def bfs(start): queue = deque([start]) team[start] = 0 # Start by assigning the start node to team 0 while queue: current = queue.popleft() current_team = team[current] for neighbor in graph[current]: if team[neighbor] == -1: # If neighbor not assigned any team team[neighbor] = 1 - current_team # Assign to the opposite team queue.append(neighbor) elif team[neighbor] == current_team: # If neighbor already in the same team return False return True # Run BFS for each component for i in range(1, n + 1): if team[i] == -1: # If not yet visited if not bfs(i): return \\"NO\\" return \\"YES\\" # Example usage: # print(can_divide_teams(4, 3, [(1, 2), (2, 3), (1, 3)])) # Should output \\"NO\\" # print(can_divide_teams(5, 2, [(1, 2), (3, 4)])) # Should output \\"YES\\" # print(can_divide_teams(6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)])) # Should output \\"YES\\""},{"question":"def longest_path(grid: List[List[int]]) -> int: Given a grid of size n x m filled with integers, find the length of the longest path in the grid that can be formed based on the rules of movement. From any cell (i, j), you can move to an adjacent cell (i+1, j), (i-1, j), (i, j+1), or (i, j-1) if and only if the value of the destination cell is strictly greater than the value of the current cell. >>> longest_path([ [9, 9, 4, 10], [6, 6, 8, 8], [2, 2, 1, 1], [7, 2, 3, 4] ]) 4 >>> longest_path([ [5] ]) 1 >>> longest_path([ [1, 2, 3, 4] ]) 4 >>> longest_path([ [1], [2], [3], [4] ]) 4 >>> longest_path([ [7, 7], [7, 7] ]) 1 pass","solution":"def longest_path(grid): n = len(grid) m = len(grid[0]) def dfs(i, j, memo): if memo[i][j] != -1: return memo[i][j] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_length = 1 for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] > grid[i][j]: max_length = max(max_length, 1 + dfs(ni, nj, memo)) memo[i][j] = max_length return max_length memo = [[-1] * m for _ in range(n)] max_path_length = 0 for i in range(n): for j in range(m): max_path_length = max(max_path_length, dfs(i, j, memo)) return max_path_length"},{"question":"def count_connected_components(n: int, edges: List[Tuple[int, int]]) -> int: Determine the number of connected components in an undirected graph. Args: n (int): The number of vertices in the graph. edges (List[Tuple[int, int]]): The list of edges where each edge is represented as a tuple (u, v). Returns: int: The number of connected components in the graph. Examples: >>> count_connected_components(6, [(1, 2), (2, 3), (4, 5), (5, 6), (6, 4)]) 2 >>> count_connected_components(4, [(1, 2), (3, 4)]) 2 >>> count_connected_components(5, []) 5 >>> count_connected_components(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) 1 >>> count_connected_components(5, [(1, 2), (3, 4)]) 3","solution":"def count_connected_components(n, edges): def dfs(node, visited, adjacency_list): stack = [node] while stack: current = stack.pop() for neighbor in adjacency_list[current]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) adjacency_list = [[] for _ in range(n+1)] for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) visited = [False] * (n + 1) component_count = 0 for i in range(1, n + 1): if not visited[i]: component_count += 1 visited[i] = True dfs(i, visited, adjacency_list) return component_count"},{"question":"def max_trees(m: int, n: int) -> int: This function computes the maximum number of trees that can be planted in an MxN grid such that no two trees are adjacent horizontally, vertically, or diagonally. Args: m (int): The number of rows in the garden grid. n (int): The number of columns in the garden grid. Returns: int: The maximum number of trees that can be planted in the garden. Examples: >>> max_trees(4, 5) 10 >>> max_trees(1, 1) 1 >>> max_trees(2, 2) 2 >>> max_trees(3, 3) 5 >>> max_trees(0, 0) 0 >>> max_trees(100, 100) 5000 >>> max_trees(7, 11) 39","solution":"def max_trees(m, n): This function computes the maximum number of trees that can be planted in an MxN grid such that no two trees are adjacent horizontally, vertically, or diagonally. if m == 0 or n == 0: return 0 # Calculate the number of cells in the grid total_cells = m * n # The maximum number of trees that can be planted max_trees_possible = (total_cells + 1) // 2 return max_trees_possible"},{"question":"def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Transposes the given square matrix. Parameters: matrix (list of list of int): The square matrix to be transposed Returns: list of list of int: The transposed matrix pass def test_transpose_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] assert transpose_matrix(matrix) == expected matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected = [ [1, 5, 9, 13], [2, 6, 10, 14], [3, 7, 11, 15], [4, 8, 12, 16] ] assert transpose_matrix(matrix) == expected matrix = [ [1] ] expected = [ [1] ] assert transpose_matrix(matrix) == expected matrix = [ [1, 2], [3, 4] ] expected = [ [1, 3], [2, 4] ] assert transpose_matrix(matrix) == expected matrix = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ] expected = [ [1, 6, 11, 16, 21], [2, 7, 12, 17, 22], [3, 8, 13, 18, 23], [4, 9, 14, 19, 24], [5, 10, 15, 20, 25] ] assert transpose_matrix(matrix) == expected","solution":"def transpose_matrix(matrix): Transposes the given square matrix. Parameters: matrix (list of list of int): The square matrix to be transposed Returns: list of list of int: The transposed matrix n = len(matrix) transposed = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): transposed[j][i] = matrix[i][j] return transposed"},{"question":"from typing import List def find_min_gte(arr: List[int], x: int) -> int: Find the smallest integer in the array that is greater than or equal to x. If no such integer exists, returns -1. >>> find_min_gte([1, 2, 3, 4, 5], 3) 3 >>> find_min_gte([1, 2, 3, 4, 5], 6) -1 >>> find_min_gte([-3, -1, 0, 3, 4], -2) -1 >>> find_min_gte([10, 20, 30, 40], 25) 30 import pytest def test_find_min_gte_exact_match(): assert find_min_gte([1, 2, 3, 4, 5], 3) == 3 def test_find_min_gte_no_match(): assert find_min_gte([1, 2, 3, 4, 5], 6) == -1 def test_find_min_gte_negative_case(): assert find_min_gte([-3, -1, 0, 3, 4], -2) == -1 def test_find_min_gte_greater_value(): assert find_min_gte([10, 20, 30, 40], 25) == 30 def test_find_min_gte_single_element(): assert find_min_gte([5], 5) == 5 assert find_min_gte([5], 1) == 5 assert find_min_gte([5], 6) == -1 def test_find_min_gte_empty_array(): assert find_min_gte([], 3) == -1 def test_find_min_gte_large_numbers(): assert find_min_gte([-10**9, -500000, 0, 500000, 10**9], 0) == 0 assert find_min_gte([-10**9, -500000, 0, 500000, 10**9], 500001) == 10**9 def test_find_min_gte_all_elements_less_than_x(): assert find_min_gte([1, 2, 3, 4], -5) == 1 def test_find_min_gte_first_element_gte_x(): assert find_min_gte([1, 2, 3, 4], 1) == 1 def test_find_min_gte_large_array(): arr = list(range(100000)) # array from 0 to 99999 assert find_min_gte(arr, 50000) == 50000 assert find_min_gte(arr, 100000) == -1","solution":"from typing import List def find_min_gte(arr: List[int], x: int) -> int: Finds the smallest integer in the array that is greater than or equal to x. If no such integer exists, returns -1. left, right = 0, len(arr) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if arr[mid] >= x: result = arr[mid] right = mid - 1 else: left = mid + 1 return result if result != -1 else -1"},{"question":"def longest_balanced_substring(s: str) -> int: Function to find the length of the longest balanced substring where the number of 'a's is equal to the number of 'b's. >>> longest_balanced_substring(\\"abba\\") 4 >>> longest_balanced_substring(\\"ababab\\") 6 >>> longest_balanced_substring(\\"aabb\\") 4 >>> longest_balanced_substring(\\"aaabbb\\") 6 >>> longest_balanced_substring(\\"aaabbaa\\") 4 >>> longest_balanced_substring(\\"bbaaabba\\") 8 >>> longest_balanced_substring(\\"a\\") 0 >>> longest_balanced_substring(\\"ab\\") 2 def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Processes multiple test cases for finding the length of the longest balanced substring for each string. >>> process_test_cases(2, [\\"abba\\", \\"ababab\\"]) [4, 6] >>> process_test_cases(3, [\\"aabb\\", \\"aaabbb\\", \\"aaabbaa\\"]) [4, 6, 4] >>> process_test_cases(1, [\\"bbaaabba\\"]) [8]","solution":"def longest_balanced_substring(s): Function to find the length of the longest balanced substring where the number of 'a's is equal to the number of 'b's. max_len = 0 n = len(s) # Dictionary to store the first occurrence index of the balance count balance_map = {0: -1} balance = 0 for i in range(n): if s[i] == 'a': balance += 1 else: balance -= 1 if balance in balance_map: max_len = max(max_len, i - balance_map[balance]) else: balance_map[balance] = i return max_len def process_test_cases(t, test_cases): Processes multiple test cases for finding the length of the longest balanced substring for each string. results = [] for i in range(t): s = test_cases[i] result = longest_balanced_substring(s) results.append(result) return results"},{"question":"def can_form_strictly_increasing_alliances(n, a): Determines whether it is possible to form strictly increasing alliance strengths between adjacent planets. Args: n : int : Number of planets a : list of int : List of maximum allowable strengths between adjacent planets Returns: str : \\"YES\\" if strictly increasing alliance strengths are possible, otherwise \\"NO\\" Examples: >>> can_form_strictly_increasing_alliances(4, [2, 4, 6]) 'YES' >>> can_form_strictly_increasing_alliances(5, [3, 6, 4, 7]) 'NO'","solution":"def can_form_strictly_increasing_alliances(n, a): Determines whether it is possible to form strictly increasing alliance strengths between adjacent planets. Args: n : int : Number of planets a : list of int : List of maximum allowable strengths between adjacent planets Returns: str : \\"YES\\" if strictly increasing alliance strengths are possible, otherwise \\"NO\\" for i in range(1, n - 1): if a[i] <= a[i - 1]: return \\"NO\\" return \\"YES\\""},{"question":"def smallest_x_to_maintain_median(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the smallest non-negative integer height X such that after each grouped consecutive group of three people is changed to the height X, the median height of the entire sequence remains the same. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple contains: - An integer N representing the number of people in the line. - A list of integers A representing the heights of the people in line. Returns: List[int]: List of smallest integer height X for each test case which maintains the median. Examples: >>> smallest_x_to_maintain_median(1, [(3, [1, 5, 3])]) [3] >>> smallest_x_to_maintain_median(1, [(6, [1, 2, 3, 4, 5, 6])]) [3]","solution":"def smallest_x_to_maintain_median(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] heights = test_cases[i][1] median = sorted(heights)[n // 2] if n % 2 == 1 else (sorted(heights)[n // 2 - 1] + sorted(heights)[n // 2]) / 2 results.append(int(median)) return results"},{"question":"def min_boxes(n: int, W: int, weights: List[int]) -> int: Determine the minimum number of boxes required to pack all items with the given weights and box capacity. Args: n (int): The number of items. W (int): The maximum weight capacity of a box. weights (List[int]): A list of integers representing the weights of the items. Returns: int: The minimum number of boxes required. Examples: >>> min_boxes(5, 10, [2, 3, 7, 8, 1]) 3 >>> min_boxes(4, 5, [4, 2, 2, 3]) 3 from solution import min_boxes def test_min_boxes_example_1(): assert min_boxes(5, 10, [2, 3, 7, 8, 1]) == 3 def test_min_boxes_example_2(): assert min_boxes(4, 5, [4, 2, 2, 3]) == 3 def test_min_boxes_all_items_same_weight(): assert min_boxes(5, 5, [5, 5, 5, 5, 5]) == 5 def test_min_boxes_one_item(): assert min_boxes(1, 10, [5]) == 1 def test_min_boxes_large_capacity_small_weights(): assert min_boxes(6, 15, [3, 1, 5, 7, 9, 2]) == 2 def test_min_boxes_mixed_weights(): assert min_boxes(7, 20, [5, 5, 5, 10, 15, 6, 9]) == 3","solution":"def min_boxes(n, W, weights): weights.sort(reverse=True) boxes = 0 while weights: capacity = W i = 0 while i < len(weights): if weights[i] <= capacity: capacity -= weights[i] weights.pop(i) else: i += 1 boxes += 1 return boxes"},{"question":"def sort_parcels(n, parcels): The Berland Post Office has decided to automate the sorting of parcels in their warehouses. Each parcel has a unique identifier and a destination code. Given a starting arrangement of parcels and their respective destinations, the goal is to sort the parcels such that they are grouped by the same destination code in ascending order of their identifiers. :param n: Number of parcels (integer) :param parcels: List of tuples, each containing (identifier, destination code) :return: Sorted list of parcels >>> sort_parcels(5, [(1003, 20), (1001, 10), (1002, 20), (1004, 10), (1000, 30)]) [(1001, 10), (1004, 10), (1002, 20), (1003, 20), (1000, 30)] >>> sort_parcels(1, [(1000, 30)]) [(1000, 30)] >>> sort_parcels(3, [(1000, 10), (1001, 20), (1002, 30)]) [(1000, 10), (1001, 20), (1002, 30)] >>> sort_parcels(4, [(1005, 50), (1002, 30), (1001, 30), (1000, 10)]) [(1000, 10), (1001, 30), (1002, 30), (1005, 50)] >>> sort_parcels(4, [(1003, 20), (1001, 20), (1002, 20), (1000, 20)]) [(1000, 20), (1001, 20), (1002, 20), (1003, 20)] >>> sort_parcels(3, [(1000, 10), (1000, 20), (1000, 30)]) [(1000, 10), (1000, 20), (1000, 30)] # Your code here","solution":"def sort_parcels(n, parcels): Sort parcels by destination code and within each code by identifier. :param n: Number of parcels (integer) :param parcels: List of tuples, each containing (identifier, destination code) :return: Sorted list of parcels return sorted(parcels, key=lambda x: (x[1], x[0]))"},{"question":"from typing import List def can_transform(arr1: List[int], arr2: List[int]) -> str: Determines if arr1 can be transformed into arr2 by performing the specified operation any number of times. Parameters: arr1 (list of int): The initial array. arr2 (list of int): The target array. Returns: str: \\"YES\\" if the transformation is possible, otherwise \\"NO\\". Example: >>> can_transform([4, 3, 2, 1], [1, 2, 3, 4]) \\"YES\\" >>> can_transform([1, 2, 3], [2, 3, 1]) \\"NO\\" def test_can_transform_example_1(): arr1 = [4, 3, 2, 1] arr2 = [1, 2, 3, 4] assert can_transform(arr1, arr2) == \\"YES\\" def test_can_transform_example_2(): arr1 = [1, 2, 3] arr2 = [2, 3, 1] assert can_transform(arr1, arr2) == \\"NO\\" def test_can_transform_example_3(): arr1 = [5, 5, 5, 5, 5] arr2 = [6, 6, 6, 6, 6] assert can_transform(arr1, arr2) == \\"NO\\" def test_can_transform_equal_arrays(): arr1 = [3, 3, 3] arr2 = [3, 3, 3] assert can_transform(arr1, arr2) == \\"YES\\" def test_can_transform_prefix_sum_check(): arr1 = [10, 5, 5] arr2 = [6, 6, 8] assert can_transform(arr1, arr2) == \\"YES\\" def test_can_transform_non_match_prefix_sum(): arr1 = [7, 3, 5] arr2 = [6, 6, 3] assert can_transform(arr1, arr2) == \\"NO\\" def test_can_transform_large_numbers(): arr1 = [10**9] * 4 arr2 = [10**9] * 4 assert can_transform(arr1, arr2) == \\"YES\\" def test_can_transform_large_but_possible(): arr1 = [10**9, 1, 1, 1] arr2 = [1, 1, 1, 10**9] assert can_transform(arr1, arr2) == \\"YES\\"","solution":"def can_transform(arr1, arr2): Determines if arr1 can be transformed into arr2 by performing the specified operation any number of times. Parameters: arr1 (list of int): The initial array. arr2 (list of int): The target array. Returns: str: \\"YES\\" if the transformation is possible, otherwise \\"NO\\". # If the sums of the arrays are not equal, transformation is not possible if sum(arr1) != sum(arr2): return \\"NO\\" # Check if for any prefix sum, arr1 is at least arr2 up to that point prefix_diff = 0 for a, b in zip(arr1, arr2): prefix_diff += a - b if prefix_diff < 0: return \\"NO\\" return \\"YES\\""},{"question":"def min_finish_time(n: int, events: List[Tuple[int, int]]) -> int: Returns the minimum finish time of the latest finishing event. :param n: Integer, number of events :param events: List of tuples where each tuple contains (start time, duration) :return: Integer, minimum finish time of the latest finishing event >>> min_finish_time(4, [(1, 4), (2, 3), (3, 6), (4, 2)]) 9 >>> min_finish_time(3, [(5, 7), (1, 3), (2, 5)]) 12 >>> min_finish_time(2, [(1, 1), (2, 2)]) 4","solution":"def min_finish_time(n, events): Returns the minimum finish time of the latest finishing event. :param n: Integer, number of events :param events: List of tuples where each tuple contains (start time, duration) :return: Integer, minimum finish time of the latest finishing event finish_times = [s + d for s, d in events] return max(finish_times)"},{"question":"def can_be_expressed_as_product(n: int) -> str: Given an integer n, determine if n can be expressed as the product of two positive integers where both are greater than 1. >>> can_be_expressed_as_product(6) \\"Yes\\" >>> can_be_expressed_as_product(13) \\"No\\"","solution":"def can_be_expressed_as_product(n): Determine if n can be expressed as the product of two positive integers where both are greater than 1. for i in range(2, int(n**0.5) + 1): if n % i == 0 and n // i > 1: return \\"Yes\\" return \\"No\\""},{"question":"def min_max_diff(n: int, weights: List[int]) -> int: Function to find the minimum possible maximum difference between the weights of any pair of leaves. :param n: The number of leaves :param weights: A list of integers representing the weights of the leaves :return: An integer representing the minimum possible maximum difference >>> min_max_diff(4, [8, 1, 12, 5]) == 3 >>> min_max_diff(5, [10, 9, 17, 1, 2]) == 1 >>> min_max_diff(1, [5]) == 0 >>> min_max_diff(0, []) == 0 >>> min_max_diff(2, [12, 10]) == 2 pass def test_min_max_diff(): assert min_max_diff(4, [8, 1, 12, 5]) == 3 assert min_max_diff(5, [10, 9, 17, 1, 2]) == 1 assert min_max_diff(1, [5]) == 0 assert min_max_diff(0, []) == 0 assert min_max_diff(2, [12, 10]) == 2 assert min_max_diff(3, [3, 8, 15]) == 5 assert min_max_diff(6, [100, 200, 300, 400, 500, 600]) == 100 assert min_max_diff(7, [1, 1, 1, 1, 1, 1, 1]) == 0 assert min_max_diff(7, [-1, -2, -3, -4, -5, -6, -7]) == 1 assert min_max_diff(3, [4, 3, 2]) == 1","solution":"def min_max_diff(n, weights): Function to find the minimum possible maximum difference between the weights of any pair of leaves. :param n: The number of leaves :param weights: A list of integers representing the weights of the leaves :return: An integer representing the minimum possible maximum difference if n < 2: return 0 # If there's only one leaf or none, no pair can be formed. weights.sort() min_diff = float('inf') for i in range(1, n): diff = weights[i] - weights[i-1] if diff < min_diff: min_diff = diff return min_diff"},{"question":"def max_packages_delivered(n, m, towns, packages): Determine the maximum number of packages that can be successfully delivered without any town exceeding its maximum weight limit. Args: n (int): Number of towns m (int): Number of packages towns (List[Tuple[int, int]]): Town information where each tuple contains (town_id, weight_limit) packages (List[Tuple[int, int, int]]): Package information where each tuple contains (package_id, weight, town_id) Returns: int: The maximum number of packages that can be delivered Examples: >>> max_packages_delivered(3, 5, [(1, 100), (2, 150), (3, 200)], [(1, 50, 1), (2, 60, 1), (3, 70, 2), (4, 80, 3), (5, 90, 3)]) 4 >>> max_packages_delivered(2, 0, [(1, 100), (2, 150)], []) 0 >>> max_packages_delivered(2, 4, [(1, 150), (2, 200)], [(1, 50, 1), (2, 50, 1), (3, 100, 2), (4, 50, 2)]) 4 >>> max_packages_delivered(3, 6, [(1, 100), (2, 150), (3, 200)], [(1, 50, 1), (2, 55, 1), (3, 60, 2), (4, 65, 2), (5, 80, 3), (6, 85, 3)]) 5 >>> max_packages_delivered(2, 4, [(1, 100), (2, 100)], [(1, 101, 1), (2, 102, 1), (3, 103, 2), (4, 104, 2)]) 0","solution":"def max_packages_delivered(n, m, towns, packages): # Town weight limits dictionary town_limits = {ti: li for ti, li in towns} # Dictionary to keep track of current weight per town town_current_weights = {ti: 0 for ti, _ in towns} # List to hold packages and sort by weight in ascending order sorted_packages = sorted(packages, key=lambda x: x[1]) delivered_count = 0 for _, weight, town_id in sorted_packages: if town_current_weights[town_id] + weight <= town_limits[town_id]: town_current_weights[town_id] += weight delivered_count += 1 return delivered_count # Example Usage: n = 3 m = 5 towns = [(1, 100), (2, 150), (3, 200)] packages = [(1, 50, 1), (2, 60, 1), (3, 70, 2), (4, 80, 3), (5, 90, 3)] print(max_packages_delivered(n, m, towns, packages)) # Output should be 4"},{"question":"def max_plants_watered(test_cases): Determine the maximum number of plants Dana can water with a limited volume of water. Args: test_cases: List of tuples, where each tuple contains an integer V (volume of the watering can), an integer P (number of plants), and a list of P integers representing the water requirements of each plant. Returns: List of integers where each integer represents the maximum number of plants Dana can water for each test case. >>> max_plants_watered([(10, 5, [4, 3, 5, 2, 1]), (15, 3, [10, 5, 8])]) [4, 2] >>> max_plants_watered([(20, 4, [5, 5, 5, 5])]) [4] >>> max_plants_watered([(5, 3, [6, 7, 8])]) [0] >>> max_plants_watered([(7, 4, [2, 2, 2, 2])]) [3] pass def parse_input(input_data): Parse the input data into test cases. Args: input_data: String representing the input data. Returns: List of tuples representing the parsed test cases. >>> parse_input(\\"2n10 5n4 3 5 2 1n15 3n10 5 8n\\") [(10, 5, [4, 3, 5, 2, 1]), (15, 3, [10, 5, 8])] pass def main(input_data): Main function to process the input data and return the results. Args: input_data: String representing the input data. Returns: List of integers where each integer represents the maximum number of plants Dana can water for each test case. >>> main(\\"2n10 5n4 3 5 2 1n15 3n10 5 8n\\") [4, 2] pass from main import max_plants_watered, parse_input, main def test_case_1(): input_data = \\"2n10 5n4 3 5 2 1n15 3n10 5 8n\\" expected_output = [4, 2] assert main(input_data) == expected_output def test_case_2(): input_data = \\"1n20 4n5 5 5 5n\\" expected_output = [4] assert main(input_data) == expected_output def test_case_3(): input_data = \\"1n5 3n6 7 8n\\" expected_output = [0] assert main(input_data) == expected_output def test_case_4(): input_data = \\"1n7 4n2 2 2 2n\\" expected_output = [3] assert main(input_data) == expected_output def test_case_5(): input_data = \\"3n6 2n2 4n10 3n5 7 1n8 5n2 2 2 2 2n\\" expected_output = [2, 2, 4] assert main(input_data) == expected_output def test_case_6(): input_data = \\"1n10 6n1 2 3 4 5 6n\\" expected_output = [4] assert main(input_data) == expected_output","solution":"def max_plants_watered(test_cases): results = [] for test_case in test_cases: V, P, water_reqs = test_case water_reqs.sort() watered_count = 0 current_volume = V for requirement in water_reqs: if requirement <= current_volume: watered_count += 1 current_volume -= requirement else: break results.append(watered_count) return results def parse_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): V, P = map(int, lines[index].split()) water_reqs = list(map(int, lines[index + 1].split())) test_cases.append((V, P, water_reqs)) index += 2 return test_cases def main(input_data): test_cases = parse_input(input_data) return max_plants_watered(test_cases)"},{"question":"def satellite_mission(initial_fuel: int, num_stages: int, burns: List[int]) -> Union[int, str]: Determines whether the mission is successful or failed based on the sequence of burn commands. Parameters: initial_fuel (int): The initial amount of fuel available. num_stages (int): The number of stages in the launch sequence. burns (list of int): The amount of fuel to be burned during each stage. Returns: str or int: \\"Failed\\" if mission fails, or remaining fuel amount if mission succeeds. Examples: >>> satellite_mission(100, 3, [30, 30, 30]) 10 >>> satellite_mission(100, 4, [30, 30, 45, 10]) \\"Failed\\"","solution":"def satellite_mission(initial_fuel, num_stages, burns): Determines whether the mission is successful or failed based on the sequence of burn commands. Parameters: initial_fuel (int): The initial amount of fuel available. num_stages (int): The number of stages in the launch sequence. burns (list of int): The amount of fuel to be burned during each stage. Returns: str or int: \\"Failed\\" if mission fails, or remaining fuel amount if mission succeeds. fuel = initial_fuel for burn in burns: if fuel >= burn: fuel -= burn else: return \\"Failed\\" return fuel"},{"question":"def can_form_valid_word(S: str, valid_words: List[str]) -> str: Determines if any valid word can be formed by rearranging the characters in string S. >>> can_form_valid_word(\\"abc\\", [\\"acb\\", \\"bca\\", \\"abd\\"]) \\"YES\\" >>> can_form_valid_word(\\"abc\\", [\\"def\\", \\"ghi\\", \\"jkl\\"]) \\"NO\\" def decode_messages(T: int, test_cases: List[Tuple[str, List[str]]]) -> List[str]: Decodes multiple test cases and determines if any valid word can be formed. Parameters: - T: integer, number of test cases - test_cases: list of tuples containing the string S and list of valid words for each test case Returns: - List of strings, \\"YES\\" or \\"NO\\" for each test case >>> decode_messages(2, [(\\"abc\\", [\\"acb\\", \\"bca\\", \\"abd\\"]), (\\"xyz\\", [\\"zxy\\", \\"yxz\\"])]) [\\"YES\\", \\"YES\\"] >>> decode_messages(3, [(\\"abc\\", [\\"acb\\", \\"bca\\", \\"abd\\"]), (\\"def\\", [\\"ghi\\", \\"jkl\\"]), (\\"xyz\\", [\\"zxy\\", \\"yxz\\"])]) [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def can_form_valid_word(S, valid_words): Determines if any valid word can be formed by rearranging the characters in string S. sorted_S = sorted(S) for word in valid_words: if sorted(word) == sorted_S: return \\"YES\\" return \\"NO\\" def decode_messages(T, test_cases): Decodes multiple test cases and determines if any valid word can be formed. Parameters: - T: integer, number of test cases - test_cases: list of tuples containing the string S and list of valid words for each test case Returns: - List of strings, \\"YES\\" or \\"NO\\" for each test case results = [] for S, valid_words in test_cases: result = can_form_valid_word(S, valid_words) results.append(result) return results"},{"question":"def maximalRectangle(matrix: List[List[int]]) -> int: Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. Example Usage: >>> maximalRectangle([ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ]) 6 pass # Your implementation here # Unit Tests def test_example_case(): matrix = [ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ] assert maximalRectangle(matrix) == 6 def test_small_matrix(): matrix = [ [0, 1], [1, 1] ] assert maximalRectangle(matrix) == 2 def test_no_ones(): matrix = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert maximalRectangle(matrix) == 0 def test_all_ones(): matrix = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert maximalRectangle(matrix) == 9 def test_single_row(): matrix = [ [1, 0, 1, 1, 1, 0, 1] ] assert maximalRectangle(matrix) == 3 def test_single_column(): matrix = [ [0], [1], [1], [0], [1], [1] ] assert maximalRectangle(matrix) == 2","solution":"def maximalRectangle(matrix): Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. if not matrix: return 0 def maximal_histogram_area(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area max_rectangle_area = 0 n = len(matrix[0]) heights = [0] * n for row in matrix: for idx in range(n): if row[idx] == 0: heights[idx] = 0 else: heights[idx] += 1 max_rectangle_area = max(max_rectangle_area, maximal_histogram_area(heights)) return max_rectangle_area # Example Usage: matrix = [ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ] print(maximalRectangle(matrix)) # Output: 6"},{"question":"def calculate_revenue(input_str: str) -> int: Calculate the total revenue generated from selling all the paintings at their highest bids. Args: input_str: str - Input string containing the number of paintings, minimum starting bids, and bids for each painting. Returns: int: Total revenue generated from selling all the paintings. Example: >>> input_str = \\"3n100 200 150n2 130 140n3 210 190 220n1 160n\\" >>> calculate_revenue(input_str) 520 >>> input_str = \\"2n100 200n0n0n\\" >>> calculate_revenue(input_str) 0","solution":"def total_revenue(num_paintings, min_bids, bids_list): total = 0 for i in range(num_paintings): num_bids = bids_list[i][0] if num_bids == 0: continue highest_bid = max(bids_list[i][1:]) if highest_bid > min_bids[i]: total += highest_bid return total def parse_input(input_str): lines = input_str.strip().split('n') num_paintings = int(lines[0]) min_bids = list(map(int, lines[1].split())) bids_list = [list(map(int, line.split())) for line in lines[2:]] return num_paintings, min_bids, bids_list def calculate_revenue(input_str): num_paintings, min_bids, bids_list = parse_input(input_str) return total_revenue(num_paintings, min_bids, bids_list)"},{"question":"def process_operations(n: int, operations: List[str]) -> List[str]: Processes a list of operations on a custom collection of unique numbers. Args: n (int): The number of operations. operations (List[str]): A list of operations in the format \\"operation_type number\\". Returns: List[str]: A list containing results (\\"true\\"/\\"false\\") for \\"check\\" operations. >>> process_operations(6, [\\"add 1\\", \\"check 1\\", \\"add 2\\", \\"check 3\\", \\"remove 1\\", \\"check 1\\"]) [\\"true\\", \\"false\\", \\"false\\"] >>> process_operations(3, [\\"check 1\\", \\"check 2\\", \\"check 3\\"]) [\\"false\\", \\"false\\", \\"false\\"]","solution":"def process_operations(n, operations): Processes a list of operations on a custom collection of unique numbers. Args: n (int): The number of operations. operations (List[str]): A list of operations in the format \\"operation_type number\\". Returns: List[str]: A list containing results (\\"true\\"/\\"false\\") for \\"check\\" operations. collection = set() # Initialize an empty set to store unique numbers results = [] # List to store the results of the check operations for operation in operations: op, num = operation.split() num = int(num) # Convert the number part to an integer if op == \\"add\\": collection.add(num) # Add the number to the collection elif op == \\"remove\\": collection.discard(num) # Remove the number if present elif op == \\"check\\": results.append(\\"true\\" if num in collection else \\"false\\") # Check for presence return results"},{"question":"from math import factorial from typing import List, Tuple def number_of_distinct_paths(T: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Calculate the number of distinct paths in a tree starting from the root node that visit every connected node exactly once. Args: T: Number of test cases. test_cases: A list of tuples, where each tuple contains: - N: Number of nodes in the tree. - A list of edges represented as tuples (u, v). Returns: A list of integers representing the number of distinct paths for each test case. >>> number_of_distinct_paths(3, [(3, [(1, 2), (1, 3)]), (4, [(1, 2), (2, 3), (2, 4)]), (4, [(1, 2), (1, 3), (1, 4)])]) [2, 6, 6] >>> number_of_distinct_paths(1, [(2, [(1, 2)])]) [1] # Implement the function here def test_example_case(): T = 3 test_cases = [ (3, [(1, 2), (1, 3)]), (4, [(1, 2), (2, 3), (2, 4)]), (4, [(1, 2), (1, 3), (1, 4)]) ] expected_output = [2, 6, 6] assert number_of_distinct_paths(T, test_cases) == expected_output def test_single_node(): T = 1 test_cases = [ (1, []) ] expected_output = [1] assert number_of_distinct_paths(T, test_cases) == expected_output def test_minimum_tree(): T = 1 test_cases = [ (2, [(1, 2)]) ] expected_output = [1] # Only one path: 1 -> 2 assert number_of_distinct_paths(T, test_cases) == expected_output def test_large_tree(): T = 1 test_cases = [ (10, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7), (4, 8), (4, 9), (5, 10)]) ] expected_output = [factorial(9)] # (10-1)! paths assert number_of_distinct_paths(T, test_cases) == expected_output","solution":"from math import factorial def number_of_distinct_paths(T, test_cases): results = [] for case in test_cases: N = case[0] if N == 1: results.append(1) continue # Number of distinct paths is just (N-1)! result = factorial(N - 1) results.append(result) return results # Example usage: T = 3 test_cases = [ (3, [(1, 2), (1, 3)]), (4, [(1, 2), (2, 3), (2, 4)]), (4, [(1, 2), (1, 3), (1, 4)]) ] print(number_of_distinct_paths(T, test_cases))"},{"question":"def is_palindrome(S: str) -> bool: Returns True if the string S is a palindrome, otherwise returns False. Ignores case and non-alphanumeric characters. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"Madam, in Eden, I’m Adam\\") True >>> is_palindrome(\\"This is not a palindrome\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True","solution":"def is_palindrome(S): Returns True if the string S is a palindrome, otherwise returns False. Ignores case and non-alphanumeric characters. import re # Remove non-alphanumeric characters and convert to lowercase cleaned_str = re.sub(r'[^A-Za-z0-9]', '', S).lower() # Check if the string reads the same forward and backward return cleaned_str == cleaned_str[::-1]"},{"question":"def min_distinct_diffs(N: int, sequence: List[int]) -> int: Given a sequence of integers of length N, determine if it is possible to reorder the sequence into a strictly increasing sequence such that the number of distinct differences between consecutive elements is minimized. If possible, return the minimum number of distinct differences; otherwise, return -1. :param N: Length of the sequence :param sequence: List of integers :return: Minimum number of distinct differences or -1 if not possible >>> min_distinct_diffs(5, [3, 1, 4, 1, 5]) 2 >>> min_distinct_diffs(3, [2, 2, 3]) 1 >>> min_distinct_diffs(4, [1, 2, 3, 4]) 1 >>> min_distinct_diffs(3, [7, 7, 7]) 1 >>> min_distinct_diffs(4, [5, 4, 3, 2]) -1 pass # Unit tests from solution import min_distinct_diffs def test_example_1(): assert min_distinct_diffs(5, [3, 1, 4, 1, 5]) == 2 def test_example_2(): assert min_distinct_diffs(3, [2, 2, 3]) == 1 def test_example_3(): assert min_distinct_diffs(4, [1, 2, 3, 4]) == 1 def test_example_4(): assert min_distinct_diffs(3, [7, 7, 7]) == 1 def test_example_5(): assert min_distinct_diffs(4, [5, 4, 3, 2]) == -1 def test_single_element(): assert min_distinct_diffs(1, [10]) == 1 def test_all_elements_identical(): assert min_distinct_diffs(5, [8, 8, 8, 8, 8]) == 1 def test_increasing_non_consecutive(): assert min_distinct_diffs(5, [1, 3, 5, 7, 9]) == 1 def test_decreasing_sequence(): assert min_distinct_diffs(5, [9, 7, 5, 3, 1]) == 1 def test_random_order(): assert min_distinct_diffs(6, [1, 3, 3, 7, 8, 9]) == 3 def test_large_values(): assert min_distinct_diffs(5, [10**9, 1, 10**8, 10**9-1, 0]) == 3 def test_duplicates_with_different_diffs(): assert min_distinct_diffs(7, [4, 8, 4, 12, 8, 16, 12]) == 1","solution":"def min_distinct_diffs(N, sequence): Given an integer sequence, determine the minimum number of distinct differences between consecutive elements in the sequence when sorted. :param N: Length of the sequence :param sequence: List of integers :return: Minimum number of distinct differences or -1 if not possible if N == 1: return 1 # Only one element means no differences at all # Sort the sequence sequence.sort() # Track the differences distinct_diffs = set() for i in range(1, N): diff = sequence[i] - sequence[i-1] if diff == 0: continue # Ignore zero differences distinct_diffs.add(diff) return len(distinct_diffs) if len(distinct_diffs) > 0 else 1"},{"question":"def count_book_genres(t, cases): Given number of test cases and the genres of books for each test case, returns the count of genres sorted in lexicographical order. Args: t (int): Number of test cases cases (list): A list containing tuples where each tuple has: - n (int): Number of books - genres (list of str): List of genres of the books Returns: list of list of tuples: For each test case, returns a list of tuples where each tuple contains: - genre (str): The genre name - count (int): The count of books of that genre # Example test cases: # # def test_single_test_case(): # t = 1 # cases = [ # (5, [\\"Fantasy\\", \\"Mystery\\", \\"Thriller\\", \\"Fantasy\\", \\"Romance\\"]) # ] # expected_output = [ # [(\\"Fantasy\\", 2), (\\"Mystery\\", 1), (\\"Romance\\", 1), (\\"Thriller\\", 1)] # ] # assert count_book_genres(t, cases) == expected_output # # def test_multiple_test_cases(): # t = 2 # cases = [ # (4, [\\"Sci-fi\\", \\"Fantasy\\", \\"Fantasy\\", \\"Mystery\\"]), # (3, [\\"Romance\\", \\"Sci-fi\\", \\"Romance\\"]) # ] # expected_output = [ # [(\\"Fantasy\\", 2), (\\"Mystery\\", 1), (\\"Sci-fi\\", 1)], # [(\\"Romance\\", 2), (\\"Sci-fi\\", 1)] # ] # assert count_book_genres(t, cases) == expected_output # # def test_all_same_genre(): # t = 1 # cases = [ # (3, [\\"Mystery\\", \\"Mystery\\", \\"Mystery\\"]) # ] # expected_output = [ # [(\\"Mystery\\", 3)] # ] # assert count_book_genres(t, cases) == expected_output # # def test_empty_generes(): # t = 1 # cases = [ # (0, []) # ] # expected_output = [ # [] # ] # assert count_book_genres(t, cases) == expected_output # # def test_mixed_case_genres(): # t = 1 # cases = [ # (3, [\\"Fantasy\\", \\"fantasy\\", \\"Fantasy\\"]) # ] # expected_output = [ # [(\\"Fantasy\\", 2), (\\"fantasy\\", 1)] # ] # assert count_book_genres(t, cases) == expected_output","solution":"def count_book_genres(t, cases): Given number of test cases and the genres of books for each test case, returns the count of genres sorted in lexicographical order. results = [] for case in cases: n, genres = case genre_count = {} for genre in genres: if genre in genre_count: genre_count[genre] += 1 else: genre_count[genre] = 1 sorted_genres = sorted(genre_count.items()) results.append(sorted_genres) return results"},{"question":"from typing import List, Tuple def simplify_commands(commands: List[Tuple[int, List[int]]]) -> List[Tuple[int, List[int]]]: Simplifies the list of commands by removing consecutive redundant commands. >>> simplify_commands([(1, [2, 3]), (1, [2, 3]), (2, [3, 4]), (1, [2, 3]), (2, [3, 4])]) [(1, [2, 3]), (2, [3, 4]), (1, [2, 3]), (2, [3, 4])] >>> simplify_commands([(0, [1]), (0, [1]), (0, [1]), (2, [4, 5]), (2, [4, 5])]) [(0, [1]), (2, [4, 5])] def test_simplify_commands_no_redundant(): commands = [(1, [2, 3]), (2, [3, 4]), (3, [1, 2]), (4, [5, 6])] assert simplify_commands(commands) == commands def test_simplify_commands_some_redundant(): commands = [(1, [2, 3]), (1, [2, 3]), (2, [3, 4]), (2, [3, 4])] assert simplify_commands(commands) == [(1, [2, 3]), (2, [3, 4])] def test_simplify_commands_all_redundant(): commands = [(1, [2, 3]), (1, [2, 3]), (1, [2, 3]), (1, [2, 3])] assert simplify_commands(commands) == [(1, [2, 3])] def test_simplify_commands_mixed_redundant(): commands = [(1, [2, 3]), (1, [2, 3]), (2, [3, 4]), (1, [2, 3]), (2, [3, 4])] assert simplify_commands(commands) == [(1, [2, 3]), (2, [3, 4]), (1, [2, 3]), (2, [3, 4])] def test_simplify_commands_single_command(): commands = [(1, [2, 3])] assert simplify_commands(commands) == [(1, [2, 3])] def test_simplify_commands_no_commands(): commands = [] assert simplify_commands(commands) == []","solution":"from typing import List, Tuple def simplify_commands(commands: List[Tuple[int, List[int]]]) -> List[Tuple[int, List[int]]]: if not commands: return [] simplified_commands = [commands[0]] for command in commands[1:]: if command != simplified_commands[-1]: simplified_commands.append(command) return simplified_commands"},{"question":"def calculate_ranks(students: List[List[Union[str, int]]]) -> List[Tuple[str, int]]: Calculate the ranks for a list of students based on their total marks and Math marks. Args: students (list): A list of lists where each inner list contains a student's name, Math marks, and Science marks. Returns: list: A list of tuples with each tuple containing a student's name and their rank. >>> calculate_ranks([[\\"Alice\\", 80, 90], [\\"Bob\\", 90, 95], [\\"Charlie\\", 85, 80]]) [(\\"Bob\\", 1), (\\"Alice\\", 2), (\\"Charlie\\", 3)] >>> calculate_ranks([[\\"Alice\\", 70, 75], [\\"Bob\\", 70, 75], [\\"Charlie\\", 80, 85]]) [(\\"Charlie\\", 1), (\\"Alice\\", 2), (\\"Bob\\", 2)] >>> calculate_ranks([[\\"bob\\", 70, 75], [\\"alice\\", 70, 75]]) [(\\"alice\\", 1), (\\"bob\\", 1)] # Test cases from typing import List, Tuple, Union def test_single_student(): students = [[\\"Alice\\", 80, 90]] assert calculate_ranks(students) == [(\\"Alice\\", 1)] def test_all_unique_scores(): students = [ [\\"Alice\\", 80, 90], [\\"Bob\\", 90, 95], [\\"Charlie\\", 85, 80] ] assert calculate_ranks(students) == [ (\\"Bob\\", 1), (\\"Alice\\", 2), (\\"Charlie\\", 3) ] def test_tie_break_math(): students = [ [\\"Alice\\", 80, 90], [\\"Bob\\", 80, 85], [\\"Charlie\\", 90, 95], [\\"David\\", 85, 90], [\\"Eve\\", 75, 80] ] assert calculate_ranks(students) == [ (\\"Charlie\\", 1), (\\"David\\", 2), (\\"Alice\\", 3), (\\"Bob\\", 4), (\\"Eve\\", 5) ] def test_tie_same_rank(): students = [ [\\"Alice\\", 70, 75], [\\"Bob\\", 70, 75], [\\"Charlie\\", 80, 85] ] assert calculate_ranks(students) == [ (\\"Charlie\\", 1), (\\"Alice\\", 2), (\\"Bob\\", 2) ] def test_same_total_different_math(): students = [ [\\"Alice\\", 70, 80], # Total = 150 [\\"Bob\\", 75, 75], # Total = 150 [\\"Charlie\\", 90, 95], # Total = 185 [\\"David\\", 80, 70] # Total = 150 ] assert calculate_ranks(students) == [ (\\"Charlie\\", 1), (\\"David\\", 2), (\\"Bob\\", 3), (\\"Alice\\", 4) ] def test_alphabetical_order_same_rank(): students = [ [\\"bob\\", 70, 75], [\\"alice\\", 70, 75], ] assert calculate_ranks(students) == [ (\\"alice\\", 1), (\\"bob\\", 1) ]","solution":"def calculate_ranks(students): Calculate the ranks for a list of students based on their total marks and Math marks. Args: students (list): A list of tuples where each tuple contains a student's name, Math marks, and Science marks. Returns: list: A list of tuples with each tuple containing a student's name and their rank. # Calculate total marks for each student for student in students: student.append(student[1] + student[2]) # Sort by total marks (desc), Math marks (desc), and name (asc) sorted_students = sorted(students, key=lambda x: (-x[3], -x[1], x[0])) # Determine ranks result = [] rank = 1 for i in range(len(sorted_students)): if i == 0: result.append((sorted_students[i][0], rank)) else: if (sorted_students[i][3] == sorted_students[i-1][3] and sorted_students[i][1] == sorted_students[i-1][1]): result.append((sorted_students[i][0], result[-1][1])) else: rank = i + 1 result.append((sorted_students[i][0], rank)) return result"},{"question":"def max_sum_of_k_consecutive_elements(A: List[int], K: int) -> int: Returns the maximum sum of K consecutive elements in the array A. >>> max_sum_of_k_consecutive_elements([1, 2, 3, 4, 5, 6, 7, 8, 9], 2) == 17 >>> max_sum_of_k_consecutive_elements([-1, -2, -3, -4, -5, -6, -7, -8, -9], 3) == -6","solution":"def max_sum_of_k_consecutive_elements(A, K): Returns the maximum sum of K consecutive elements in the array A. N = len(A) if K > N: return None # Calculate the sum of the first K elements max_sum = curr_sum = sum(A[:K]) # Slide over the array, one element at a time for i in range(K, N): curr_sum += A[i] - A[i - K] if curr_sum > max_sum: max_sum = curr_sum return max_sum"},{"question":"def highest_possible_score(n: int, k: int, scores: List[int]) -> int: Returns the highest possible score for any competitor after losing up to k points. :param n: number of competitors :param k: number of points each competitor can lose :param scores: initial scores of competitors :return: highest possible score after losing up to k points >>> highest_possible_score(5, 3, [10, 20, 30, 25, 40]) == 37 >>> highest_possible_score(6, 10, [15, 10, 35, 40, 20, 25]) == 30 >>> highest_possible_score(4, 0, [8, 12, 15, 10]) == 15","solution":"def highest_possible_score(n, k, scores): Returns the highest possible score for any competitor after losing up to k points. :param n: number of competitors :param k: number of points each competitor can lose :param scores: initial scores of competitors :return: highest possible score after losing up to k points max_score = max(scores) # Find the maximum initial score return max(max_score - k, 0) # Calculate the highest possible score after losing up to k points"},{"question":"def largest_temperature_fluctuation(temperatures: List[int]) -> int: Returns the largest temperature fluctuation observed between two consecutive days. >>> largest_temperature_fluctuation([15, 12, 20, 5, 25]) 20 >>> largest_temperature_fluctuation([10, 10, 10, 10, 10]) 0 >>> largest_temperature_fluctuation([10, 20]) 10 >>> largest_temperature_fluctuation([-10, -20, -30, -10, 0]) 20 >>> largest_temperature_fluctuation([-100, 100]) 200 >>> largest_temperature_fluctuation([10]) 0","solution":"def largest_temperature_fluctuation(temperatures): Returns the largest temperature fluctuation observed between two consecutive days. :param temperatures: List of daily temperatures (list of int) :return: The largest temperature fluctuation between two consecutive days (int) max_fluctuation = 0 for i in range(1, len(temperatures)): fluctuation = abs(temperatures[i] - temperatures[i - 1]) if fluctuation > max_fluctuation: max_fluctuation = fluctuation return max_fluctuation"},{"question":"from typing import List def longest_palindrome_len(s: str) -> int: Returns the length of the longest palindrome that can be formed from string s. >>> longest_palindrome_len(\\"abccccdd\\") 7 >>> longest_palindrome_len(\\"aabb\\") 4 >>> longest_palindrome_len(\\"abc\\") 1 def test_example_case_1(): assert longest_palindrome_len(\\"abccccdd\\") == 7 def test_example_case_2(): assert longest_palindrome_len(\\"aabb\\") == 4 def test_example_case_3(): assert longest_palindrome_len(\\"abc\\") == 1 def test_single_character_string(): assert longest_palindrome_len(\\"a\\") == 1 def test_all_characters_same(): assert longest_palindrome_len(\\"aaaa\\") == 4 def test_odd_characters_occurrence(): assert longest_palindrome_len(\\"aabbccddddd\\") == 11 def test_every_character_different(): assert longest_palindrome_len(\\"abcdefg\\") == 1 def test_mixed_even_odd_counts(): assert longest_palindrome_len(\\"abacaba\\") == 7 def test_large_input(): s = \\"a\\" * 500 + \\"b\\" * 500 assert longest_palindrome_len(s) == 1000","solution":"from collections import Counter def longest_palindrome_len(s): Returns the length of the longest palindrome that can be formed from string s. freq = Counter(s) length = 0 odd_count_found = False # Count pairs and number of odd frequency characters for count in freq.values(): length += (count // 2) * 2 if count % 2 == 1: odd_count_found = True # If there's at least one character with an odd count, we can use one of them as the center character if odd_count_found: length += 1 return length"},{"question":"from collections import defaultdict, deque def find_project_order(n: int, m: int, dependencies: List[Tuple[int, int]]) -> List[int]: Given a list of projects with dependency constraints, determine the order in which the projects should be completed. A project can only be started once all of its dependencies have been completed. If there are multiple valid orders, return any. If it is not possible to complete all projects because of a circular dependency, return an empty list. Args: n : int : the number of projects m : int : the number of dependency constraints dependencies : List[Tuple[int, int]] : the list of dependency constraints where each tuple (u, v) indicates project v is dependent on project u Returns: List[int] : the order in which the projects can be completed, or an empty list if it's not possible to complete all projects Examples: >>> find_project_order(3, 0, []) == [1, 2, 3] >>> find_project_order(4, 3, [(1, 2), (2, 3), (3, 4)]) == [1, 2, 3, 4] >>> result = find_project_order(4, 3, [(1, 2), (1, 3), (3, 4)]) >>> result in [[1, 3, 4, 2], [1, 2, 3, 4], [1, 3, 2, 4]] >>> find_project_order(3, 3, [(1, 2), (2, 3), (3, 1)]) == [] >>> find_project_order(6, 6, [(1, 2), (1, 3), (3, 4), (4, 5), (2, 4), (5, 6)]) in [ [1, 2, 3, 4, 5, 6], [1, 2, 4, 3, 5, 6], [1, 3, 2, 4, 5, 6], [1, 3, 4, 2, 5, 6] ]","solution":"from collections import defaultdict, deque def find_project_order(n, m, dependencies): graph = defaultdict(list) in_degree = [0] * (n + 1) # Building the graph and calculating in-degrees for u, v in dependencies: graph[u].append(v) in_degree[v] += 1 queue = deque() # Start with all projects that have no dependencies for i in range(1, n + 1): if in_degree[i] == 0: queue.append(i) project_order = [] while queue: project = queue.popleft() project_order.append(project) for neighbor in graph[project]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If the length of project_order is not n, it means there's a cycle if len(project_order) != n: return [] return project_order"},{"question":"def max_circular_subarray_sum(nums, n, k): Computes the maximum possible sum of any contiguous subarray of length k, considering that the array wraps around circularly. Parameters: nums (List[int]): list of integers representing the array. n (int): number of elements in the array. k (int): size of the subarray to be considered. Returns: int: the maximum possible sum of any contiguous subarray of size k. Examples: >>> max_circular_subarray_sum([4, -1, 2, 1, 6], 5, 3) 11 >>> max_circular_subarray_sum([-2, 5, -1, 7, -3, 2, 4], 7, 4) 10 >>> max_circular_subarray_sum([1, 2, 3, 4, 5, -1, -2, -3, -4, -5], 10, 2) 9 pass # Unit tests def test_example_1(): result = max_circular_subarray_sum([4, -1, 2, 1, 6], 5, 3) assert result == 11 def test_example_2(): result = max_circular_subarray_sum([-2, 5, -1, 7, -3, 2, 4], 7, 4) assert result == 10 def test_example_3(): result = max_circular_subarray_sum([1, 2, 3, 4, 5, -1, -2, -3, -4, -5], 10, 2) assert result == 9 def test_single_element_array(): result = max_circular_subarray_sum([5], 1, 1) assert result == 5 def test_all_negative_numbers(): result = max_circular_subarray_sum([-3, -2, -1, -5], 4, 2) assert result == -3 def test_array_equals_k(): result = max_circular_subarray_sum([3, 2, 1], 3, 3) assert result == 6 def test_k_equals_1(): result = max_circular_subarray_sum([1, 2, 3, 4, 5], 5, 1) assert result == 5","solution":"def max_circular_subarray_sum(nums, n, k): Computes the maximum possible sum of any contiguous subarray of length k, considering that the array wraps around circularly. if n < k: return 0 # Calculate sum of the first k elements current_sum = sum(nums[:k]) max_sum = current_sum # Create an extended array to handle circular nature extended_nums = nums + nums # Use a sliding window to calculate sum of subarrays of size k for i in range(1, n): current_sum += extended_nums[i + k - 1] - extended_nums[i - 1] max_sum = max(max_sum, current_sum) return max_sum # Example usage: # n = 5, k = 3 # nums = [4, -1, 2, 1, 6] # print(max_circular_subarray_sum(nums, n, k)) # Output should be 11"},{"question":"def top_k_frequent(words: List[str], k: int) -> List[str]: Given an array of strings \`words\` and an integer \`k\`, return the \`k\` most frequent elements. The answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first. >>> top_k_frequent([\\"i\\", \\"love\\", \\"leetcode\\", \\"i\\", \\"love\\", \\"coding\\"], 2) ['i', 'love'] >>> top_k_frequent([\\"the\\", \\"day\\", \\"is\\", \\"sunny\\", \\"the\\", \\"the\\", \\"the\\", \\"sunny\\", \\"is\\", \\"is\\"], 3) ['the', 'is', 'sunny'] >>> top_k_frequent([\\"i\\", \\"love\\", \\"coding\\", \\"and\\", \\"coding\\"], 1) ['coding'] pass def process_input(n: int, k: int, words: str) -> List[str]: Process the input string and returns the top k frequent elements as per the specifications. >>> process_input(6, 2, 'i love leetcode i love coding') ['i', 'love'] >>> process_input(8, 3, 'the day is sunny the the the sunny is is') ['the', 'is', 'sunny'] >>> process_input(5, 1, 'i love coding and coding') ['coding'] words = words.split() return top_k_frequent(words, k)","solution":"from collections import Counter import heapq def top_k_frequent(words, k): # Count the frequency of each word counts = Counter(words) # Use a heap to store the words by frequency heap = [(-freq, word) for word, freq in counts.items()] heapq.heapify(heap) # Extract the top k elements with the highest frequency result = [heapq.heappop(heap)[1] for _ in range(k)] return result def process_input(n, k, words): words = words.split() return top_k_frequent(words, k)"},{"question":"def max_products(t: int, test_cases: List[Tuple[int, int]]) -> List[int]: Determines the maximum number of products that can fit into a box with the given dimensions and the smallest number of expansions for each test case. :param t: Number of test cases :param test_cases: List of tuples representing the dimensions (p rows, q columns) :return: List of integers with the maximum number of products for each test case >>> max_products(3, [(2, 3), (4, 5), (3, 6)]) [6, 20, 18] >>> max_products(2, [(1, 1), (1, 1000)]) [1, 1000] >>> max_products(2, [(1000, 1000), (1000, 1)]) [1000000, 1000]","solution":"def max_products(t, test_cases): Returns a list of maximum products that can fit into the box with the smallest number of expansions for each test case. :param t: int, number of test cases :param test_cases: list of tuples, each containing two integers (p, q) which are the dimensions of the box :return: list of integers, where each integer corresponds to the maximum number of products for each test case results = [] for p, q in test_cases: results.append(p * q) return results"},{"question":"from typing import List, Tuple def calculate_min_fuel(T: int, test_cases: List[Tuple[int, List[Tuple[str, int]]]]) -> List[int]: Returns the minimum total fuel required to deliver packages for each test case. Args: T (int): Number of test cases test_cases (List[Tuple[int, List[Tuple[str, int]]]]): Each test case contains a number of colonies and a list of tuples with each tuple containing a time window (str) and fuel requirement (int) Returns: List[int]: Minimum total fuel required for each test case >>> calculate_min_fuel(1, [(3, [(\\"1-4\\", 500), (\\"3-5\\", 200), (\\"2-6\\", 300)])]) [1000] >>> calculate_min_fuel(2, [(3, [(\\"1-4\\", 500), (\\"3-5\\", 200), (\\"2-6\\", 300)]), (2, [(\\"1-3\\", 100), (\\"2-5\\", 150)])]) [1000, 250]","solution":"def calculate_min_fuel(T, test_cases): Returns the minimum total fuel required to deliver packages for each test case. results = [] for case in test_cases: colonies = case[1] colonies.sort(key=lambda x: (x[0].split('-')[1], x[1])) # Sort by end of time window and then by fuel fuel_needed = sum(fuel for _, fuel in colonies) results.append(fuel_needed) return results"},{"question":"def count_occurrences(n: int, q: int, sequence: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Returns the number of times x appears in the subsequence from l to r inclusive for each query. :param n: Number of elements in the sequence :param q: Number of queries :param sequence: List of integers representing the sequence :param queries: List of tuples representing the queries (l, r, x) :return: List of integers where each integer is the answer to the respective query >>> count_occurrences(5, 3, [1, 2, 3, 2, 1], [(0, 4, 2), (1, 3, 3), (2, 4, 1)]) [2, 1, 1] >>> count_occurrences(5, 2, [1, 2, 3, 4, 5], [(0, 4, 6), (1, 3, 7)]) [0, 0] >>> count_occurrences(4, 2, [5, 5, 5, 5], [(0, 3, 5), (1, 2, 5)]) [4, 2] >>> count_occurrences(1, 1, [1], [(0, 0, 1)]) [1] >>> count_occurrences(5, 2, [-1000000000, 1000000000, -1000000000, 1000000000, -1000000000], [(0, 4, -1000000000), (0, 4, 1000000000)]) [3, 2]","solution":"def count_occurrences(n, q, sequence, queries): Returns the number of times x appears in the subsequence from l to r inclusive for each query. :param n: Number of elements in the sequence :param q: Number of queries :param sequence: List of integers representing the sequence :param queries: List of tuples representing the queries (l, r, x) :return: List of integers where each integer is the answer to the respective query results = [] for l, r, x in queries: count = sum(1 for i in range(l, r + 1) if sequence[i] == x) results.append(count) return results"},{"question":"from typing import List, Tuple def parse_input(input_str: str) -> List[Tuple[int, List[List[str]]]]: Parse the input string into test cases. Args: input_str (str): The input string containing test cases. Returns: List[Tuple[int, List[List[str]]]]: Parsed test cases. pass def minimum_steps_to_collect_parcels(test_cases: List[Tuple[int, List[List[str]]]]) -> List[int]: Determine the minimum steps required for a vehicle to pick up all parcels starting from (0,0). Args: test_cases (List[Tuple[int, List[List[str]]]]): A list of test cases where each test case is represented as a tuple containing an integer N and an NxN grid. Returns: List[int]: A list of integers representing the minimum number of steps for each test case. pass # Unit tests def test_case_1(): input_str = \\"2n3nPEEnEPEnEEPn4nPPPPnEEEEnPEEEnEEEEn\\" test_cases = parse_input(input_str) assert minimum_steps_to_collect_parcels(test_cases) == [4, 3] def test_case_2(): input_str = \\"1n3nEEEnEPEnEEEn\\" test_cases = parse_input(input_str) assert minimum_steps_to_collect_parcels(test_cases) == [2] def test_case_3(): input_str = \\"1n3nEEEnEEEnEEEn\\" test_cases = parse_input(input_str) assert minimum_steps_to_collect_parcels(test_cases) == [-1] def test_case_4(): input_str = \\"1n1nPn\\" test_cases = parse_input(input_str) assert minimum_steps_to_collect_parcels(test_cases) == [0] def test_case_5(): input_str = \\"1n2nPEnEPn\\" test_cases = parse_input(input_str) assert minimum_steps_to_collect_parcels(test_cases) == [2]","solution":"from collections import deque def minimum_steps_to_collect_parcels(test_cases): results = [] def bfs(grid, N): directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] parcels = sum(row.count('P') for row in grid) if parcels == 0: return 0 queue = deque([(0, 0, 0)]) # x, y, steps visited = set() visited.add((0, 0)) parcels_collected = 0 while queue: x, y, steps = queue.popleft() if grid[x][y] == 'P': parcels_collected += 1 if parcels_collected == parcels: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < N and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1 # If we have traversed the entire grid and not collected all parcels for N, grid in test_cases: if grid[0][0] == 'E' and all(cell == 'E' for row in grid for cell in row): results.append(-1) else: results.append(bfs(grid, N)) return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) cases = [] i = 1 for _ in range(T): N = int(lines[i]) grid = [list(lines[i + j + 1]) for j in range(N)] cases.append((N, grid)) i += N + 1 return cases"},{"question":"def largest_pyramid(n: int, cards: List[int]) -> Tuple[int, List[int]]: Determine the largest possible card pyramid Jane can build with n cards and arrange them accordingly. Args: n (int): The number of cards. cards (List[int]): The values of the cards. Returns: Tuple[int, List[int]]: The number of levels in the largest pyramid and the arranged cards. Examples: >>> largest_pyramid(10, [9, 3, 5, 7, 8, 2, 4, 6, 1, 10]) (4, [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) >>> largest_pyramid(6, [5, 4, 6, 3, 2, 1]) (3, [6, 5, 4, 3, 2, 1]) >>> largest_pyramid(3, [7, 4, 2]) (2, [7, 4, 2])","solution":"def largest_pyramid(n, cards): cards.sort(reverse=True) # Finding the largest k such that k * (k + 1) / 2 <= n k = 0 total_cards = 0 while total_cards + (k + 1) <= n: k += 1 total_cards += k pyramid_cards = cards[:total_cards] remaining_cards = cards[total_cards:] return k, pyramid_cards + remaining_cards"},{"question":"class SegmentTree: def __init__(self, data): Initializes the Segment Tree with the given data. self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): Builds the segment tree. # Initialize leaves for i in range(self.n): self.tree[self.n + i] = data[i] # Build the tree in a bottom-up approach for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, index, value): Updates the value at the given index. # Set value at the position \`index\` pos = index + self.n self.tree[pos] = value # Move upward and update parents while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def query(self, left, right): Queries the sum in the range [left, right). result = 0 left += self.n right += self.n while left < right: if left % 2: result += self.tree[left] left += 1 if right % 2: right -= 1 result += self.tree[right] left //= 2 right //= 2 return result def process_operations(n, k, array, operations): Processes a list of operations on an array. Args: n: Length of the array. k: Number of operations. array: List of integers representing the array. operations: List of operations to be performed on the array. Returns: List of results for each query operation. seg_tree = SegmentTree(array) results = [] for operation in operations: op_type = operation[0] if op_type == 1: _, i, x = operation seg_tree.update(i - 1, x) # Convert 1-based index to 0-based elif op_type == 2: _, l, r = operation result = seg_tree.query(l - 1, r) # Convert 1-based index to 0-based, right is exclusive results.append(result) return results def test_example_case(): n = 5 k = 3 array = [1, 2, 3, 4, 5] operations = [ [2, 1, 3], # Query from index 1 to 3 [1, 3, 10], # Update index 3 to 10 [2, 1, 3] # Query from index 1 to 3 ] result = process_operations(n, k, array, operations) assert result == [6, 13] def test_single_element_update_and_query(): n = 1 k = 3 array = [5] operations = [ [2, 1, 1], # Query from index 1 to 1 [1, 1, 10], # Update index 1 to 10 [2, 1, 1] # Query from index 1 to 1 ] result = process_operations(n, k, array, operations) assert result == [5, 10] def test_multiple_updates_and_queries(): n = 4 k = 4 array = [1, 3, 5, 7] operations = [ [2, 1, 4], # Query from index 1 to 4 [1, 2, 4], # Update index 2 to 4 [2, 1, 3], # Query from index 1 to 3 [1, 4, 2] # Update index 4 to 2 ] result = process_operations(n, k, array, operations) assert result == [16, 10] def test_no_operations(): n = 3 k = 0 array = [1, 2, 3] operations = [] result = process_operations(n, k, array, operations) assert result == [] def test_large_values_and_array_length(): n = 100000 k = 100 array = [1000000000] * n operations = [[2, 1, n]] * k # Query the full range k times result = process_operations(n, k, array, operations) assert result == [100000000000000] * k","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = data[i] # Build the tree in a bottom-up approach for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, index, value): # Set value at the position \`index\` pos = index + self.n self.tree[pos] = value # Move upward and update parents while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def query(self, left, right): # Sum on the range [left, right) result = 0 left += self.n right += self.n while left < right: if left % 2: result += self.tree[left] left += 1 if right % 2: right -= 1 result += self.tree[right] left //= 2 right //= 2 return result def process_operations(n, k, array, operations): seg_tree = SegmentTree(array) results = [] for operation in operations: op_type = operation[0] if op_type == 1: _, i, x = operation seg_tree.update(i - 1, x) # Convert 1-based index to 0-based elif op_type == 2: _, l, r = operation result = seg_tree.query(l - 1, r) # Convert 1-based index to 0-based, right is exclusive results.append(result) return results"},{"question":"import bisect class IntegerCollection: A data structure that supports inserting, deleting, and finding the minimum, maximum, and median of a collection of distinct integers. def __init__(self): self.data = [] def insert(self, x: int) -> None: Insert an integer x into the collection. pass def delete(self, x: int) -> None: Delete an integer x from the collection if it exists. pass def find_min(self) -> int: Find and return the minimum integer in the collection. Returns None if the collection is empty. pass def find_max(self) -> int: Find and return the maximum integer in the collection. Returns None if the collection is empty. pass def find_median(self) -> int: Find and return the median integer in the collection. Returns None if the collection is empty. If there is an even number of elements, return the lower median. pass def process_operations(operations: List[str]) -> List[int]: Process a list of operations on the IntegerCollection data structure and return a list of results for 'min', 'max', and 'median' queries. Parameters: operations (List[str]): The list of operations to be performed Returns: List[int]: The list of results for 'min', 'max', and 'median' queries. Example: >>> process_operations([ ... \\"insert 5\\", ... \\"insert 3\\", ... \\"insert 8\\", ... \\"min\\", ... \\"max\\", ... \\"median\\", ... \\"delete 3\\", ... \\"min\\", ... \\"max\\", ... \\"median\\", ... ]) [3, 8, 5, 5, 8, 5] collection = IntegerCollection() results = [] for operation in operations: parts = operation.split() if parts[0] == \\"insert\\": collection.insert(int(parts[1])) elif parts[0] == \\"delete\\": collection.delete(int(parts[1])) elif parts[0] == \\"min\\": results.append(collection.find_min()) elif parts[0] == \\"max\\": results.append(collection.find_max()) elif parts[0] == \\"median\\": results.append(collection.find_median()) return results if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"import bisect class IntegerCollection: def __init__(self): self.data = [] def insert(self, x): bisect.insort(self.data, x) def delete(self, x): index = bisect.bisect_left(self.data, x) if index < len(self.data) and self.data[index] == x: self.data.pop(index) def find_min(self): if not self.data: return None return self.data[0] def find_max(self): if not self.data: return None return self.data[-1] def find_median(self): if not self.data: return None n = len(self.data) if n % 2 == 1: return self.data[n // 2] else: return self.data[(n // 2) - 1] # Function for easier testing def process_operations(operations): collection = IntegerCollection() results = [] for operation in operations: parts = operation.split() if parts[0] == \\"insert\\": collection.insert(int(parts[1])) elif parts[0] == \\"delete\\": collection.delete(int(parts[1])) elif parts[0] == \\"min\\": results.append(collection.find_min()) elif parts[0] == \\"max\\": results.append(collection.find_max()) elif parts[0] == \\"median\\": results.append(collection.find_median()) return results"},{"question":"def can_form_palindrome(s: str) -> str: Determine if the characters of string s can be rearranged to form a palindrome. >>> can_form_palindrome(\\"civic\\") \\"YES\\" >>> can_form_palindrome(\\"ivicc\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\" >>> can_form_palindrome(\\"racecar\\") \\"YES\\" >>> can_form_palindrome(\\"aabbccdd\\") \\"YES\\" def check_palindrome_cases(t: int, test_cases: List[str]) -> List[str]: Determine if the strings in test_cases can be rearranged to form a palindrome. >>> check_palindrome_cases(4, [\\"civic\\", \\"ivicc\\", \\"hello\\", \\"racecar\\"]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] >>> check_palindrome_cases(3, [\\"aabbcc\\", \\"aabbccd\\", \\"abcd\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def can_form_palindrome(s): Determine if the characters of string s can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one character has an odd count. from collections import Counter char_count = Counter(s) odd_count = sum(count % 2 for count in char_count.values()) return \\"YES\\" if odd_count <= 1 else \\"NO\\" def check_palindrome_cases(t, test_cases): results = [] for s in test_cases: results.append(can_form_palindrome(s)) return results"},{"question":"def can_arrange_books(n: int, m: int, shelf_capacities: List[int], books: List[int]) -> str: Determines if all books can be arranged on the shelves without exceeding any shelf's capacity. Parameters: n (int): Number of shelves. m (int): Number of books. shelf_capacities (list): List of capacities for each shelf. books (list): List of number of books in each category. Returns: str: \\"yes\\" if all books can be arranged, otherwise \\"no\\". >>> can_arrange_books(3, 5, [5, 10, 8], [2, 3, 4, 2, 1]) == \\"yes\\" >>> can_arrange_books(2, 4, [3, 7], [6, 5, 1, 2]) == \\"no\\"","solution":"def can_arrange_books(n, m, shelf_capacities, books): Determines if all books can be arranged on the shelves without exceeding any shelf's capacity. Parameters: n (int): Number of shelves. m (int): Number of books. shelf_capacities (list): List of capacities for each shelf. books (list): List of number of books in each category. Returns: str: \\"yes\\" if all books can be arranged, otherwise \\"no\\". total_shelf_capacity = sum(shelf_capacities) total_books = sum(books) if total_books <= total_shelf_capacity: return \\"yes\\" else: return \\"no\\""},{"question":"def process_operations(n: int, q: int, array: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: Process a sequence of operations on an array where you can update an element or query the minimum value in a range. :param n: The number of elements in the initial array. :param q: The number of operations to be performed. :param array: The initial array of integers. :param operations: A list of operations, where each operation is a tuple. The first element of the tuple is the type of operation (1 for update, 2 for query). For update, the following two elements are index (1-based) and new value. For query, the following two elements are index range (1-based). :returns: A list of results for the query operations. import pytest from solution import process_operations def test_example_case(): n = 5 q = 5 array = [1, 3, 2, 4, 5] operations = [(2, 1, 3), (1, 2, 1), (2, 1, 3), (1, 3, 6), (2, 1, 5)] assert process_operations(n, q, array, operations) == [1, 1, 1] def test_single_update_query(): n = 3 q = 2 array = [4, 6, 8] operations = [(2, 1, 3), (1, 2, 3)] assert process_operations(n, q, array, operations) == [4] def test_all_queries(): n = 4 q = 3 array = [2, 2, 2, 2] operations = [(2, 1, 4), (2, 2, 3), (2, 1, 2)] assert process_operations(n, q, array, operations) == [2, 2, 2] def test_edge_case_minimum_values(): n = 3 q = 2 array = [1, 1, 1] operations = [(2, 1, 3), (2, 2, 2)] assert process_operations(n, q, array, operations) == [1, 1]","solution":"class SegmentTree: def __init__(self, array): self.n = len(array) self.tree = [float('inf')] * (2 * self.n) self.build(array) def build(self, array): for i in range(self.n): self.tree[self.n + i] = array[i] for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, index, value): index += self.n self.tree[index] = value while index > 1: index //= 2 self.tree[index] = min(self.tree[2 * index], self.tree[2 * index + 1]) def query(self, left, right): left += self.n right += self.n min_val = float('inf') while left < right: if left % 2 == 1: min_val = min(min_val, self.tree[left]) left += 1 if right % 2 == 1: right -= 1 min_val = min(min_val, self.tree[right]) left //= 2 right //= 2 return min_val def process_operations(n, q, array, operations): seg_tree = SegmentTree(array) result = [] for operation in operations: if operation[0] == 1: _, i, v = operation seg_tree.update(i - 1, v) elif operation[0] == 2: _, l, r = operation result.append(seg_tree.query(l - 1, r)) return result"},{"question":"def find_top_author_by_genre(n: int, book_entries: List[str], genre: str) -> str: Develop a management tool for a library's book inventory to find which author has written the most books in a given genre. Args: n (int): The number of books. book_entries (List[str]): Each book's data is provided in the format: 'book_id; title; author; genre'. genre (str): The genre you are interested in. Returns: str: The name of the author who has written the most books in the given genre, in lowercase. Examples: >>> find_top_author_by_genre(5, [\\"123; The Great Gatsby; F. Scott Fitzgerald; Fiction\\", \\"124; To Kill a Mockingbird; Harper Lee; Fiction\\", \\"125; The Old Man and the Sea; Ernest Hemingway; Fiction\\", \\"126; A Farewell to Arms; Ernest Hemingway; Fiction\\", \\"127; Moby Dick; Herman Melville; Fiction\\"], \\"fiction\\") 'ernest hemingway' >>> find_top_author_by_genre(4, [\\"101; The Double Helix; James Watson; Science\\", \\"102; A Brief History of Time; Stephen Hawking; Science\\", \\"103; The Selfish Gene; Richard Dawkins; Science\\", \\"104; Cosmos; Carl Sagan; Science\\"], \\"science\\") 'carl sagan' >>> find_top_author_by_genre(4, [\\"101; The Double Helix; James Watson; Science\\", \\"102; A Brief History of Time; Stephen Hawking; Science\\", \\"103; The Selfish Gene; Richard Dawkins; Science\\", \\"104; Cosmos; Carl Sagan; Science\\"], \\"SCIENCE\\") 'carl sagan' >>> find_top_author_by_genre(1, [\\"101; The Great Gatsby; F. Scott Fitzgerald; Fiction\\"], \\"fiction\\") 'f. scott fitzgerald' # Implementation here","solution":"def find_top_author_by_genre(n, book_entries, genre): from collections import defaultdict genre = genre.strip().lower() author_count = defaultdict(int) for entry in book_entries: book_id, title, author, book_genre = entry.split(';') book_genre = book_genre.strip().lower() author = author.strip().lower() if book_genre == genre: author_count[author] += 1 # Finding the author with the maximum count and handling ties lexicographically top_author = min((author for author in author_count.keys() if author_count[author] == max(author_count.values())), default='', key=lambda a: (author_count[a],a)) return top_author.lower()"},{"question":"from typing import List def shortest_path_to_bottom_right(n: int, m: int, grid: List[str]) -> int: Finds the length of the shortest path from the top-left to the bottom-right of the grid. If there is no such path, returns -1. :param n: Number of rows in the grid. :param m: Number of columns in the grid. :param grid: List of strings representing the grid with 'L' for land and 'W' for water. :return: Length of the shortest path or -1 if no such path exists. >>> shortest_path_to_bottom_right(3, 3, [\\"LLL\\", \\"LWL\\", \\"LLL\\"]) 4 >>> shortest_path_to_bottom_right(3, 3, [\\"LWL\\", \\"WWW\\", \\"LLL\\"]) -1 >>> shortest_path_to_bottom_right(1, 1, [\\"L\\"]) 0","solution":"from collections import deque def shortest_path_to_bottom_right(n, m, grid): Finds the length of the shortest path from the top-left to the bottom-right of the grid. :param n: Number of rows in the grid. :param m: Number of columns in the grid. :param grid: 2D List representing the grid with 'L' for land and 'W' for water. :return: Length of the shortest path or -1 if no such path exists. def is_valid(x, y): # Check if the cell is within the grid bounds and is 'L' return 0 <= x < n and 0 <= y < m and grid[x][y] == 'L' # Initialize directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # If starting or ending cell is water, return -1 immediately if grid[0][0] == 'W' or grid[n-1][m-1] == 'W': return -1 # Initialize queue for BFS and visited set queue = deque([(0, 0, 0)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() # If we reached the bottom-right cell, return the distance if x == n - 1 and y == m - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) # If no path was found return -1"},{"question":"def find_minimum_time_to_complete_tasks(N, tasks, M, dependencies): Calculate the minimum amount of overall time required to complete all tasks given the constraints. Args: N (int): The number of tasks. tasks (list): A list of tuples, each representing a task with (D, W) where D is the time required and W is the worker. M (int): The number of dependencies. dependencies (list): A list of tuples, each representing a dependency between tasks. Returns: int: The minimum overall time required to complete all tasks. >>> find_minimum_time_to_complete_tasks(3, [(10, 1), (20, 2), (30, 3)], 2, [(1, 2), (2, 3)]) 60 >>> find_minimum_time_to_complete_tasks(4, [(5, 1), (10, 1), (15, 2), (20, 2)], 3, [(1, 2), (1, 3), (2, 4)]) 35 >>> find_minimum_time_to_complete_tasks(5, [(10, 1), (5, 2), (20, 1), (15, 2), (10, 3)], 4, [(1, 2), (1, 3), (3, 4), (4, 5)]) 55 pass def process_input(input_list): Process the input list to compute the results for each dataset. Args: input_list (list): A list of strings representing the input. Returns: list: A list of integers where each integer is the result of find_minimum_time_to_complete_tasks for one dataset. >>> process_input([ ... \\"3\\", \\"10 1\\", \\"20 2\\", \\"30 3\\", \\"2\\", \\"1 2\\", \\"2 3\\", ... \\"4\\", \\"5 1\\", \\"10 1\\", \\"15 2\\", \\"20 2\\", \\"3\\", \\"1 2\\", \\"1 3\\", \\"2 4\\", ... \\"5\\", \\"10 1\\", \\"5 2\\", \\"20 1\\", \\"15 2\\", \\"10 3\\", \\"4\\", \\"1 2\\", \\"1 3\\", \\"3 4\\", \\"4 5\\", \\"0\\" ... ]) [60, 35, 55] pass def main(): import sys input = sys.stdin.read().strip().split('n') results = process_input(input) for result in results: print(result) if __name__ == '__main__': main()","solution":"def find_minimum_time_to_complete_tasks(N, tasks, M, dependencies): from collections import defaultdict, deque # Build adj list and indegree map adj_list = defaultdict(list) indegree = [0] * (N + 1) task_time = [0] * (N + 1) worker_time = defaultdict(int) for i in range(N): Di, Wi = tasks[i] task_time[i + 1] = Di worker_time[i + 1] = 0 for dep in dependencies: A, B = dep adj_list[A].append(B) indegree[B] += 1 # Topological sort using Kahn's algorithm queue = deque() for i in range(1, N + 1): if indegree[i] == 0: queue.append(i) worker_time[i] += task_time[i] while queue: task = queue.popleft() current_end_time = worker_time[task] for neighbor in adj_list[task]: indegree[neighbor] -= 1 worker_time[neighbor] = max(worker_time[neighbor], current_end_time + task_time[neighbor]) if indegree[neighbor] == 0: queue.append(neighbor) # Overall completion time is the maximum finish time for any task return max(worker_time.values()) def process_input(input_list): index = 0 results = [] while index < len(input_list): N = int(input_list[index]) if N == 0: break index += 1 tasks = [] for _ in range(N): tasks.append(tuple(map(int, input_list[index].split()))) index += 1 M = int(input_list[index]) index += 1 dependencies = [] for _ in range(M): dependencies.append(tuple(map(int, input_list[index].split()))) index += 1 result = find_minimum_time_to_complete_tasks(N, tasks, M, dependencies) results.append(result) return results def main(): import sys input = sys.stdin.read().strip().split('n') results = process_input(input) for result in results: print(result) if __name__ == '__main__': main()"},{"question":"from typing import List def find_shortest_balanced_for_cases(t: int, cases: List[str]) -> List[int]: Determine the length of the shortest contiguous balanced substring for multiple test cases. A string is called \\"balanced\\" if the number of occurrences of the characters 'a', 'b', and 'c' are equal. Given a string, determine the length of the shortest contiguous substring of that is balanced. If no such substring exists, return -1. Parameters: t (int): The number of test cases. cases (List[str]): A list of strings to check for balanced substrings. Returns: List[int]: A list of lengths for each test case, or -1 if no balanced substring exists. >>> find_shortest_balanced_for_cases(3, [\\"abc\\", \\"aabbcc\\", \\"aaabbbccc\\"]) [3, 6, 9] >>> find_shortest_balanced_for_cases(1, [\\"abcabcabcabc\\"]) [3] >>> find_shortest_balanced_for_cases(2, [\\"aabb\\", \\"abcabcab\\"]) [-1, 3] >>> find_shortest_balanced_for_cases(1, [\\"a\\"]) [-1] pass","solution":"def shortest_balanced_substring_length(s): from collections import Counter n = len(s) if n < 3: return -1 # Function to check if a substring is balanced def is_balanced(sub): counter = Counter(sub) return counter.get('a', 0) == counter.get('b', 0) == counter.get('c', 0) min_length = float('inf') # Sliding window to find the shortest balanced substring for i in range(n): for j in range(i + 2, n): if is_balanced(s[i:j+1]): min_length = min(min_length, j - i + 1) return min_length if min_length != float('inf') else -1 def find_shortest_balanced_for_cases(t, cases): results = [] for case in cases: results.append(shortest_balanced_substring_length(case)) return results"},{"question":"def find_unique_element(n: int, arr: List[int]) -> int: Function to find the element that appears exactly once in the list. Args: n: An integer representing the number of elements in the list. arr: A list of integers where one element appears exactly once and all other elements appear exactly twice. Returns: An integer that appears exactly once in the list. Examples: >>> find_unique_element(5, [4, 3, 2, 4, 3]) 2 >>> find_unique_element(3, [5, 7, 5]) 7 >>> find_unique_element(7, [10, -10, 10, 99, 99, -10, -3]) -3 >>> find_unique_element(1, [42]) 42 >>> find_unique_element(3, [1000000000, -1000000000, 1000000000]) -1000000000 >>> find_unique_element(5, [0, 1, 0, 1, 2]) 2 >>> find_unique_element(5, [-1, -2, -2, -3, -1]) -3","solution":"def find_unique_element(n, arr): Function to find the element that appears exactly once in the list. unique = 0 for num in arr: unique ^= num return unique"},{"question":"def is_contiguous_subarray_in_matrix(m, n, matrix, x): Check whether x is present as a contiguous subarray in any row of the matrix. >>> is_contiguous_subarray_in_matrix(3, 4, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]], [6, 7]) == \\"YES\\" >>> is_contiguous_subarray_in_matrix(2, 5, [[1, 2, 3, 4, 5], [8, 7, 6, 5, 4]], [7, 4]) == \\"NO\\"","solution":"def is_contiguous_subarray_in_matrix(m, n, matrix, x): x_str = ' '.join(map(str, x)) for row in matrix: row_str = ' '.join(map(str, row)) if x_str in row_str: return \\"YES\\" return \\"NO\\" # Example Usage # matrix = [ # [1, 2, 3, 4], # [5, 6, 7, 8], # [9, 10, 11, 12] # ] # x = [6, 7] # print(is_contiguous_subarray_in_matrix(3, 4, matrix, x)) # Output: \\"YES\\""},{"question":"def min_operations_to_make_same(n: int, s: str) -> int: Determine the minimum number of operations required to transform the given string into a string where all characters are the same. >>> min_operations_to_make_same(5, 'aabbb') 2 >>> min_operations_to_make_same(6, 'abccba') 4 >>> min_operations_to_make_same(1, 'a') 0","solution":"def min_operations_to_make_same(n, s): from collections import Counter # count the frequency of each character in the string frequency = Counter(s) # find the maximum frequency most_frequent_count = max(frequency.values()) # the minimum number of operations required to make all characters same return n - most_frequent_count"},{"question":"from typing import List class BankAccount: Simulates the operation of a simple bank account. def __init__(self, initial_balance=0): Initializes the account with a given balance self.balance = initial_balance def deposit(self, amount: int): Increases the account balance by the specified amount pass def withdraw(self, amount: int): Decreases the account balance by the specified amount if there are sufficient funds pass def get_balance(self) -> int: Returns the current account balance pass def process_transactions(transactions: List[str]) -> List[int]: Processes a list of transactions on a single bank account. >>> process_transactions([\\"deposit 100\\", \\"balance\\", \\"withdraw 50\\", \\"balance\\", \\"withdraw 60\\", \\"balance\\"]) [100, 50, 50] account = BankAccount() results = [] return results # Example transactions for processing transactions = [ \\"deposit 100\\", \\"balance\\", \\"withdraw 50\\", \\"balance\\", \\"withdraw 60\\", \\"balance\\" ] print(process_transactions(transactions)) # Outputs [100, 50, 50]","solution":"class BankAccount: def __init__(self, initial_balance=0): self.balance = initial_balance def deposit(self, amount): if amount > 0: self.balance += amount def withdraw(self, amount): if amount > 0: if amount <= self.balance: self.balance -= amount else: print(\\"Insufficient funds\\") def get_balance(self): return self.balance def process_transactions(transactions): account = BankAccount() results = [] for transaction in transactions: if transaction.startswith(\\"deposit\\"): _, amount = transaction.split() account.deposit(int(amount)) elif transaction.startswith(\\"withdraw\\"): _, amount = transaction.split() account.withdraw(int(amount)) elif transaction == \\"balance\\": results.append(account.get_balance()) return results # Example transactions for processing transactions = [ \\"deposit 100\\", \\"balance\\", \\"withdraw 50\\", \\"balance\\", \\"withdraw 60\\", \\"balance\\" ] print(process_transactions(transactions)) # Outputs [100, 50, 50]"},{"question":"def kth_smallest_element(N: int, M: int, k: int, A: List[List[int]]) -> int: Returns the k-th smallest element in the flattened N x M matrix A. Parameters: N (int): number of rows M (int): number of columns k (int): position of the k-th smallest element A (list of list of int): the N x M matrix Returns: int: the k-th smallest element in the flattened array pass # Unit Tests def test_kth_smallest_element_basic(): N = 3 M = 3 k = 4 A = [ [3, 1, 10], [2, 7, 100], [5, 4, 8] ] assert kth_smallest_element(N, M, k, A) == 4 def test_single_element(): N = 1 M = 1 k = 1 A = [ [42] ] assert kth_smallest_element(N, M, k, A) == 42 def test_large_k(): N = 2 M = 3 k = 6 A = [ [1, 2, 3], [4, 5, 6] ] assert kth_smallest_element(N, M, k, A) == 6 def test_all_same_elements(): N = 2 M = 2 k = 3 A = [ [7, 7], [7, 7] ] assert kth_smallest_element(N, M, k, A) == 7 def test_mixed_elements(): N = 3 M = 3 k = 8 A = [ [9, 8, 7], [6, 5, 4], [3, 2, 1] ] assert kth_smallest_element(N, M, k, A) == 8 def test_ordered_elements(): N = 3 M = 3 k = 9 A = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert kth_smallest_element(N, M, k, A) == 9","solution":"def kth_smallest_element(N, M, k, A): Returns the k-th smallest element in the flattened N x M matrix A. Parameters: N (int): number of rows M (int): number of columns k (int): position of the k-th smallest element A (list of list of int): the N x M matrix Returns: int: the k-th smallest element in the flattened array # Flatten the 2D array into a 1D array flattened_array = [element for row in A for element in row] # Sort the flattened array flattened_array.sort() # Return the k-th smallest element (1-based index, so k-1 for 0-based index) return flattened_array[k - 1] # Example usage: # N, M, k = 3, 3, 4 # A = [ # [3, 1, 10], # [2, 7, 100], # [5, 4, 8] # ] # print(kth_smallest_element(N, M, k, A)) # Output: 4"},{"question":"def longest_substring_two_distinct(s: str) -> int: Determine the length of the longest substring that contains at most two distinct characters. >>> longest_substring_two_distinct(\\"abcba\\") 3 >>> longest_substring_two_distinct(\\"a\\") 1 >>> longest_substring_two_distinct(\\"aabbcc\\") 4 >>> longest_substring_two_distinct(\\"aaaa\\") 4 >>> longest_substring_two_distinct(\\"\\") 0 >>> longest_substring_two_distinct(\\"abaccc\\") 4 >>> longest_substring_two_distinct(\\"abcdef\\") 2 >>> longest_substring_two_distinct(\\"a\\" * 50000 + \\"b\\" * 50000) 100000","solution":"def longest_substring_two_distinct(s: str) -> int: This function finds the length of the longest substring with at most two distinct characters. if not s: return 0 left = 0 max_length = 0 char_map = {} for right in range(len(s)): char = s[right] if char in char_map: char_map[char] += 1 else: char_map[char] = 1 while len(char_map) > 2: left_char = s[left] char_map[left_char] -= 1 if char_map[left_char] == 0: del char_map[left_char] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"from itertools import permutations from typing import List def generate_permutations(s: str) -> List[str]: Generates all distinct permutations of the input string \`s\` in lexicographical order. Args: s (str): Input string. Returns: list: A list of distinct permutations sorted lexicographically. >>> generate_permutations(\\"abc\\") [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] >>> generate_permutations(\\"aab\\") [\\"aab\\", \\"aba\\", \\"baa\\"] >>> generate_permutations(\\"ab\\") [\\"ab\\", \\"ba\\"] >>> generate_permutations(\\"a\\") [\\"a\\"] >>> generate_permutations(\\"aa\\") [\\"aa\\"] >>> generate_permutations(\\"aaa\\") [\\"aaa\\"]","solution":"from itertools import permutations def generate_permutations(s): Generates all distinct permutations of the input string \`s\` in lexicographical order. Args: s (str): Input string. Returns: list: A list of distinct permutations sorted lexicographically. # Use set to remove duplicate permutations and then sort the result perm = sorted(set(''.join(p) for p in permutations(s))) return perm"},{"question":"def removeDuplicateLetters(s: str) -> str: Given a string s consisting of lowercase Latin letters, returns the lexicographically smallest string that can be obtained by removing duplicate characters. >>> removeDuplicateLetters(\\"cbacdcbc\\") \\"acdb\\" >>> removeDuplicateLetters(\\"bcabc\\") \\"abc\\"","solution":"def removeDuplicateLetters(s): Given a string s consisting of lowercase Latin letters, returns the lexicographically smallest string that can be obtained by removing duplicate characters. # Dictionary to keep the count of each character count = { char: 0 for char in s } for char in s: count[char] += 1 result = [] # Stack to store the result characters seen = set() # Set to track characters already in result for char in s: count[char] -= 1 if char in seen: continue # Ensure the result is lexicographically smallest while result and char < result[-1] and count[result[-1]] > 0: seen.discard(result.pop()) result.append(char) seen.add(char) return ''.join(result)"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.children = [] def build_tree(edges, root_val): nodes = {} for u, v in edges: if u not in nodes: nodes[u] = TreeNode(u) if v not in nodes: nodes[v] = TreeNode(v) nodes[u].children.append(nodes[v]) return nodes[root_val] def find_lca(root, x, y): Find the lowest common ancestor (LCA) of two nodes with values x and y in the forest of trees. >>> root = build_tree([(1, 2), (2, 3), (3, 4)], 1) >>> find_lca(root, 2, 4).value 2 pass def is_ancestor(root, x, y): Determine if the node with value x is an ancestor of the node with value y in the forest of trees. >>> root = build_tree([(1, 2), (2, 3), (3, 4)], 1) >>> is_ancestor(root, 2, 4) True >>> is_ancestor(root, 3, 2) False pass def cyclic_shift(nodes, k): Cyclically shift the positions of the children at a specific node by k units. >>> root = build_tree([(1, 2), (1, 3), (1, 4)], 1) >>> root.children = cyclic_shift(root.children, 1) >>> [child.value for child in root.children] [4, 2, 3] >>> root.children = cyclic_shift(root.children, -1) >>> [child.value for child in root.children] [2, 3, 4] pass import sys input = sys.stdin.read def main(): data = input().strip().split() idx = 0 Q = int(data[idx]) idx += 1 T = int(data[idx]) idx += 1 roots = [] value_to_node = {} for _ in range(T): root_val = int(data[idx]) idx += 1 edges = [] while idx < len(data) and data[idx][0] != '1' and data[idx][0] != '2' and data[idx][0] != '3': u = int(data[idx]) v = int(data[idx + 1]) edges.append((u, v)) idx += 2 root = build_tree(edges, root_val) roots.append(root) value_to_node[root_val] = root results = [] for _ in range(Q): query_type = int(data[idx]) idx += 1 if query_type == 1: x = int(data[idx]) y = int(data[idx + 1]) idx += 2 lca_result = None for root in roots: lca_result = find_lca(root, x, y) if lca_result: results.append(str(lca_result.value)) break elif query_type == 2: x = int(data[idx]) y = int(data[idx + 1]) idx += 2 ancestor_result = None for root in roots: ancestor_result = is_ancestor(root, x, y) if ancestor_result: results.append(\\"Yes\\") break if not ancestor_result: results.append(\\"No\\") elif query_type == 3: x = int(data[idx]) k = int(data[idx + 1]) idx += 2 for root in roots: if root.value == x: root.children = cyclic_shift(root.children, k) break else: for child in root.children: if child.value == x: child.children = cyclic_shift(child.children, k) break print(\\"n\\".join(results)) if __name__ == \\"__main__\\": main()","solution":"class TreeNode: def __init__(self, value): self.value = value self.children = [] def build_tree(edges, root_val): nodes = {} for u, v in edges: if u not in nodes: nodes[u] = TreeNode(u) if v not in nodes: nodes[v] = TreeNode(v) nodes[u].children.append(nodes[v]) return nodes[root_val] def find_lca(root, x, y): if root is None or root.value == x or root.value == y: return root count = 0 temp = None for child in root.children: res = find_lca(child, x, y) if res: count += 1 if count == 1: temp = res if count == 2: return root return temp def is_ancestor(root, x, y): if root is None: return False if root.value == x: return search(root, y) for child in root.children: if is_ancestor(child, x, y): return True return False def search(root, val): if root is None: return False if root.value == val: return True for child in root.children: if search(child, val): return True return False def cyclic_shift(nodes, k): k = k % len(nodes) return nodes[-k:] + nodes[:-k] import sys input = sys.stdin.read def main(): data = input().strip().split() idx = 0 Q = int(data[idx]) idx += 1 T = int(data[idx]) idx += 1 roots = [] value_to_node = {} for _ in range(T): root_val = int(data[idx]) idx += 1 edges = [] while idx < len(data) and data[idx][0] != '1' and data[idx][0] != '2' and data[idx][0] != '3': u = int(data[idx]) v = int(data[idx + 1]) edges.append((u, v)) idx += 2 root = build_tree(edges, root_val) roots.append(root) value_to_node[root_val] = root results = [] for _ in range(Q): query_type = int(data[idx]) idx += 1 if query_type == 1: x = int(data[idx]) y = int(data[idx + 1]) idx += 2 lca_result = None for root in roots: lca_result = find_lca(root, x, y) if lca_result: results.append(str(lca_result.value)) break elif query_type == 2: x = int(data[idx]) y = int(data[idx + 1]) idx += 2 ancestor_result = None for root in roots: ancestor_result = is_ancestor(root, x, y) if ancestor_result: results.append(\\"Yes\\") break if not ancestor_result: results.append(\\"No\\") elif query_type == 3: x = int(data[idx]) k = int(data[idx + 1]) idx += 2 for root in roots: if root.value == x: root.children = cyclic_shift(root.children, k) break else: for child in root.children: if child.value == x: child.children = cyclic_shift(child.children, k) break print(\\"n\\".join(results)) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List, Tuple def concentration(C: int, N: int) -> int: Calculate the concentration at time N given the initial concentration C. >>> concentration(2, 5) 36 >>> concentration(3, 4) 43 >>> concentration(1, 0) 1 >>> concentration(1, 1) 3 >>> concentration(2, 2) 10 pass def process_test_cases(test_cases: List[Tuple[int, int]]) -> List[int]: Process a list of test cases, each with an initial concentration C and a time interval N, and return the concentration at time N for each test case. >>> process_test_cases([(2, 5), (3, 4)]) [36, 43] >>> process_test_cases([(1, 0), (1, 1), (2, 2), (3, 3)]) [1, 3, 10, 15] pass","solution":"def concentration(C, N): Calculate the concentration at time N given the initial concentration C. c = C for t in range(1, N + 1): if t % 2 == 0: c = 3 * c - 2 else: c = c + 2 return c def process_test_cases(test_cases): results = [] for C, N in test_cases: results.append(concentration(C, N)) return results"},{"question":"class Block: def __init__(self, vertices): self.vertices = vertices self.x_min = min(v[0] for v in vertices) self.y_min = min(v[1] for v in vertices) self.z_min = min(v[2] for v in vertices) self.x_max = max(v[0] for v in vertices) self.y_max = max(v[1] for v in vertices) self.z_max = max(v[2] for v in vertices) def overlaps_with(self, other): Check for any overlap between this block and another block. def check_blocks_overlap(test_cases, new_block_vertices): Check if the new block overlaps with any of the existing blocks. >>> existing_blocks = [[(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1)], [(2, 2, 2), (2, 2, 3), (2, 3, 2), (2, 3, 3), (3, 2, 2), (3, 2, 3), (3, 3, 2), (3, 3, 3)]] >>> new_block = [(1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 2, 2), (2, 1, 1), (2, 1, 2), (2, 2, 1), (2, 2, 2)] >>> check_blocks_overlap(existing_blocks, new_block) == \\"Overlap\\" def main(input_data): Main function to process the input data and return the results. >>> input_data = '''2 ... 0 0 0 ... 0 0 1 ... 0 1 0 ... 0 1 1 ... 1 0 0 ... 1 0 1 ... 1 1 0 ... 1 1 1 ... 2 2 2 ... 2 2 3 ... 2 3 2 ... 2 3 3 ... 3 2 2 ... 3 2 3 ... 3 3 2 ... 3 3 3 ... 1 1 1 ... 1 1 2 ... 1 2 1 ... 1 2 2 ... 2 1 1 ... 2 1 2 ... 2 2 1 ... 2 2 2 ... 0''' >>> output = main(input_data) >>> output == \\"Overlap\\"","solution":"class Block: def __init__(self, vertices): self.vertices = vertices self.x_min = min(v[0] for v in vertices) self.y_min = min(v[1] for v in vertices) self.z_min = min(v[2] for v in vertices) self.x_max = max(v[0] for v in vertices) self.y_max = max(v[1] for v in vertices) self.z_max = max(v[2] for v in vertices) def overlaps_with(self, other): # Check for any overlap between this block and another block. does_not_overlap = ( self.x_max < other.x_min or self.x_min > other.x_max or self.y_max < other.y_min or self.y_min > other.y_max or self.z_max < other.z_min or self.z_min > other.z_max ) return not does_not_overlap def check_blocks_overlap(test_cases, new_block_vertices): existing_blocks = [Block(vertices) for vertices in test_cases] new_block = Block(new_block_vertices) for block in existing_blocks: if block.overlaps_with(new_block): return \\"Overlap\\" return \\"No Overlap\\" def main(input_data): lines = input_data.strip().splitlines() idx = 0 output = [] while idx < len(lines): n = int(lines[idx]) if n == 0: break idx += 1 test_cases = [] for _ in range(n): block_vertices = [] for _ in range(8): vertex = tuple(map(int, lines[idx].split())) block_vertices.append(vertex) idx += 1 test_cases.append(block_vertices) new_block_vertices = [] for _ in range(8): vertex = tuple(map(int, lines[idx].split())) new_block_vertices.append(vertex) idx += 1 result = check_blocks_overlap(test_cases, new_block_vertices) output.append(result) return \\"n\\".join(output)"},{"question":"def max_subarray_sum_after_swap(n, cards): A group of friends is playing a card game where each player is given a hand of cards, and each card has a value associated with it. The game has a unique rule: a player is allowed to swap exactly two cards in their hand to maximize the total sum of contiguous subarrays of cards. More formally, if a player has a hand of cards \`[a1, a2, a3, ..., an]\`, they are allowed to swap exactly two cards, say the card at position \`i\` with the card at position \`j\`, then compute the maximum possible sum of any contiguous subarray after the swap. Input The first line contains a single integer \`n\` (1 ≤ n ≤ 105) — the number of cards in the hand. The second line contains \`n\` integers a1, a2, ..., an (−104 ≤ ai ≤ 104) — the values of the cards in the initial hand. Output Output a single integer — the maximum possible sum of any contiguous subarray after swapping exactly two cards. Examples: >>> max_subarray_sum_after_swap(5, [1, 2, -3, 4, 5]) 12 >>> max_subarray_sum_after_swap(3, [-1, -2, -3]) -1","solution":"def max_subarray_sum_after_swap(n, cards): def max_subarray_sum(arr): max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far if n == 1: return cards[0] current_max = max_subarray_sum(cards) max_sum = current_max for i in range(n): for j in range(i + 1, n): cards[i], cards[j] = cards[j], cards[i] max_sum = max(max_sum, max_subarray_sum(cards)) cards[i], cards[j] = cards[j], cards[i] return max_sum"},{"question":"def can_build_bridges_without_crossing(n: int, m: int, bridges: List[Tuple[int, int]]) -> Union[str, List[Tuple[int, int]]]: Determines if it's possible to build the bridges such that no two bridges cross each other. If possible, returns a list of bridges in non-crossing order. Otherwise, returns \\"Impossible\\". >>> can_build_bridges_without_crossing(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) [(1, 2), (2, 3), (3, 4), (4, 5)] >>> can_build_bridges_without_crossing(6, 3, [(1, 4), (2, 5), (3, 6)]) 'Impossible'","solution":"def can_build_bridges_without_crossing(n, m, bridges): Determines if it's possible to build the bridges such that no two bridges cross each other. If possible, returns a list of bridges in non-crossing order. Otherwise, returns \\"Impossible\\". # Function to check if two bridges cross each other def do_cross(bridge1, bridge2): a1, b1 = bridge1 a2, b2 = bridge2 # Normalize the endpoints so that a < b if a1 > b1: a1, b1 = b1, a1 if a2 > b2: a2, b2 = b2, a2 return (a1 < a2 < b1 < b2) or (a2 < a1 < b2 < b1) # Check all pairs of bridges to see if any two cross for i in range(m): for j in range(i + 1, m): if do_cross(bridges[i], bridges[j]): return \\"Impossible\\" # If no bridges cross, return the given list of bridges return bridges"},{"question":"def number_of_watchtowers(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Determines the minimum number of watchtowers needed to monitor all roads. Parameters: - n (int): Number of cities - m (int): Number of roads - roads (list of tuples): List of roads, each represented as a tuple (u, v, l) where * u (int): One endpoint of the road * v (int): The other endpoint of the road * l (int): Length of the road (not used in this solution) Returns: - int: Minimum number of watchtowers needed Examples: >>> number_of_watchtowers(4, 4, [(1, 2, 5), (2, 3, 4), (3, 4, 3), (4, 1, 6)]) 4 >>> number_of_watchtowers(5, 0, []) 0 pass import pytest from solution import number_of_watchtowers def test_no_roads(): assert number_of_watchtowers(5, 0, []) == 0 def test_example_case_1(): n = 4 m = 4 roads = [(1, 2, 5), (2, 3, 4), (3, 4, 3), (4, 1, 6)] assert number_of_watchtowers(n, m, roads) == 4 def test_disconnected_graph(): n = 6 m = 3 roads = [(1, 2, 1), (3, 4, 1), (5, 6, 1)] assert number_of_watchtowers(n, m, roads) == 6 def test_fully_connected_graph(): n = 4 m = 6 roads = [(1, 2, 1), (1, 3, 1), (1, 4, 1), (2, 3, 1), (2, 4, 1), (3, 4, 1)] assert number_of_watchtowers(n, m, roads) == 4 def test_single_road(): n = 2 m = 1 roads = [(1, 2, 1)] assert number_of_watchtowers(n, m, roads) == 2 def test_sparsely_connected_graph(): n = 5 m = 2 roads = [(1, 2, 1), (4, 5, 1)] assert number_of_watchtowers(n, m, roads) == 4 if __name__ == \\"__main__\\": pytest.main()","solution":"def number_of_watchtowers(n, m, roads): Determines the minimum number of watchtowers needed to monitor all roads. Parameters: - n (int): Number of cities - m (int): Number of roads - roads (list of tuples): List of roads, each represented as a tuple (u, v, l) where * u (int): One endpoint of the road * v (int): The other endpoint of the road * l (int): Length of the road (not used in this solution) Returns: - int: Minimum number of watchtowers needed if m == 0: # no roads, no watchtowers needed return 0 # We'll use a set to track unique cities connected by roads cities = set() for (u, v, l) in roads: cities.add(u) cities.add(v) # The minimum number of watchtowers needed is equal to the number # of unique cities that have roads connecting them return len(cities)"},{"question":"def count_consecutive_seats(n: int, k: int) -> int: Determine the number of distinct ways to reserve \`k\` consecutive seats in a concert hall with \`n\` seats. >>> count_consecutive_seats(10, 3) 8 >>> count_consecutive_seats(5, 2) 4 >>> count_consecutive_seats(1, 1) 1 >>> count_consecutive_seats(5, 5) 1 >>> count_consecutive_seats(10, 10) 1 >>> count_consecutive_seats(5, 6) 0 >>> count_consecutive_seats(1000000, 1) 1000000 >>> count_consecutive_seats(1000000, 1000000) 1 >>> count_consecutive_seats(1000000, 500000) 500001","solution":"def count_consecutive_seats(n, k): if k > n: return 0 return n - k + 1 # Example usage: # result = count_consecutive_seats(10, 3) # print(result) # Expected output: 8"},{"question":"def process_orders(inventory_input: str, orders_input: str) -> List[str]: Processes orders in an e-commerce system, checking if they can be fulfilled given the inventory levels. Args: inventory_input (str): Multiline string containing the initial inventory items and quantities. orders_input (str): Multiline string containing the list of orders and quantities. Returns: List[str]: List of \\"Yes\\" or \\"No\\" indicating whether each order can be fulfilled. >>> inventory_input = \\"5napple 10nbanana 5norange 8ngrape 15nmango 10n\\" >>> orders_input = \\"3n2napple 3norange 2n3nbanana 2nmango 5ngrape 5n2napple 12nbanana 3n\\" >>> process_orders(inventory_input, orders_input) ['Yes', 'Yes', 'No'] >>> inventory_input = \\"3nitem1 5nitem2 10nitem3 7n\\" >>> orders_input = \\"2n1nitem1 6n2nitem1 2nitem2 3n\\" >>> process_orders(inventory_input, orders_input) ['No', 'Yes'] from typing import List def test_process_orders(): inventory_input = \\"5napple 10nbanana 5norange 8ngrape 15nmango 10n\\" orders_input = \\"3n2napple 3norange 2n3nbanana 2nmango 5ngrape 5n2napple 12nbanana 3n\\" expected_output = [\\"Yes\\", \\"Yes\\", \\"No\\"] assert process_orders(inventory_input, orders_input) == expected_output def test_out_of_stock_order(): inventory_input = \\"3nitem1 5nitem2 10nitem3 7n\\" orders_input = \\"2n1nitem1 6n2nitem1 2nitem2 3n\\" expected_output = [\\"No\\", \\"Yes\\"] assert process_orders(inventory_input, orders_input) == expected_output def test_exact_stock_match(): inventory_input = \\"2nitem1 5nitem2 5n\\" orders_input = \\"2n1nitem1 5n1nitem2 5n\\" expected_output = [\\"Yes\\", \\"Yes\\"] assert process_orders(inventory_input, orders_input) == expected_output def test_no_initial_stock(): inventory_input = \\"3nitem1 0nitem2 0nitem3 0n\\" orders_input = \\"1n1nitem1 1n\\" expected_output = [\\"No\\"] assert process_orders(inventory_input, orders_input) == expected_output def test_multiple_orders(): inventory_input = \\"3nitem1 10nitem2 10nitem3 10n\\" orders_input = \\"3n2nitem1 3nitem2 4n2nitem2 5nitem3 2n1nitem3 1n\\" expected_output = [\\"Yes\\", \\"Yes\\", \\"Yes\\"] assert process_orders(inventory_input, orders_input) == expected_output","solution":"def process_orders(inventory_input, orders_input): from collections import defaultdict inventory_lines = inventory_input.strip().split('n') orders_lines = orders_input.strip().split('n') item_count = int(inventory_lines[0]) inventory = {} # Read the initial inventory index = 1 for _ in range(item_count): item_name, quantity = inventory_lines[index].split() inventory[item_name] = int(quantity) index += 1 order_count = int(orders_lines[0]) orders = [] # Read the orders line_index = 1 for _ in range(order_count): num_items_in_order = int(orders_lines[line_index]) current_order = [] line_index += 1 for _ in range(num_items_in_order): item_name, quantity = orders_lines[line_index].split() current_order.append((item_name, int(quantity))) line_index += 1 orders.append(current_order) # Process each order results = [] for order in orders: can_fulfill = True for item_name, quantity in order: if inventory.get(item_name, 0) < quantity: can_fulfill = False break if can_fulfill: for item_name, quantity in order: inventory[item_name] -= quantity results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def can_make_sum(n, coins, V): Determines if a subset of coins can sum to the value V. >>> can_make_sum(4, [2, 5, 5, 1], 10) \\"YES\\" >>> can_make_sum(3, [1, 2, 3], 6) \\"YES\\" >>> can_make_sum(5, [1, 2, 3, 4, 5], 11) \\"YES\\" >>> can_make_sum(5, [1, 1, 1, 1, 1], 100) \\"NO\\" def solve_collection_problem(T, test_cases): Determines if it is possible to select a subset of coins such that their sum is exactly V for each test case. >>> solve_collection_problem(4, [(4, 10, [2, 5, 5, 1]), (3, 6, [1, 2, 3]), (5, 11, [1, 2, 3, 4, 5]), (5, 100, [1, 1, 1, 1, 1])]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] >>> solve_collection_problem(2, [(1, 5, [5]), (1, 5, [3])]) [\\"YES\\", \\"NO\\"] >>> solve_collection_problem(2, [(3, 9, [3, 3, 3]), (4, 15, [5, 5, 5, 1])]) [\\"YES\\", \\"YES\\"] >>> solve_collection_problem(2, [(2, 1, [1, 1]), (2, 2, [1, 1])]) [\\"YES\\", \\"YES\\"]","solution":"def can_make_sum(n, coins, V): Determines if a subset of coins can sum to the value V. # Create a dp array to store whether a certain sum value can be achieved dp = [False] * (V + 1) dp[0] = True # Loop through each coin in the list for coin in coins: # Update the dp array in reverse order for i in range(V, coin - 1, -1): if dp[i - coin]: dp[i] = True return \\"YES\\" if dp[V] else \\"NO\\" def solve_collection_problem(T, test_cases): results = [] for n, V, coins in test_cases: result = can_make_sum(n, coins, V) results.append(result) return results"},{"question":"from typing import List, Union def process_operations(operations: List[str]) -> List[Union[int, str]]: Perform a series of operations on a list of integers and return results for 'M' operations. The operations consist of: - 'A' followed by a number to add that number to the list - 'R' followed by a number to remove that number if it exists - 'M' to return the maximum number or \\"EMPTY\\" if the list is empty >>> process_operations([\\"A5\\", \\"A3\\", \\"M\\", \\"A10\\", \\"R5\\", \\"M\\", \\"R10\\", \\"M\\", \\"R3\\", \\"M\\"]) [5, 10, 3, \\"EMPTY\\"] >>> process_operations([\\"A5\\", \\"A3\\", \\"A10\\", \\"M\\"]) [10] >>> process_operations([\\"A5\\", \\"A3\\", \\"A10\\", \\"R5\\", \\"R3\\", \\"R10\\", \\"M\\"]) [\\"EMPTY\\"] >>> process_operations([\\"A2\\", \\"A8\\", \\"M\\", \\"A6\\", \\"R8\\", \\"M\\", \\"R2\\", \\"M\\"]) [8, 6, 6] >>> process_operations([\\"M\\", \\"A5\\", \\"M\\", \\"R5\\", \\"M\\"]) [\\"EMPTY\\", 5, \\"EMPTY\\"] >>> process_operations([\\"A1\\", \\"A2\\", \\"A3\\", \\"R1\\", \\"R2\\", \\"R3\\", \\"M\\"]) [\\"EMPTY\\"]","solution":"from typing import List, Union def process_operations(operations: List[str]) -> List[Union[int, str]]: lst = [] results = [] for operation in operations: if operation[0] == 'A': number = int(operation[1:]) lst.append(number) elif operation[0] == 'R': number = int(operation[1:]) if number in lst: lst.remove(number) elif operation[0] == 'M': if lst: results.append(max(lst)) else: results.append(\\"EMPTY\\") return results"},{"question":"def smallest_number(A: int, B: int) -> int: Returns the smallest positive integer not greater than 10^18 that is divisible by A but not divisible by B. If such a number does not exist, returns -1. from math import gcd # Your code here def test_example_1(): assert smallest_number(6, 8) == 6 def test_example_2(): assert smallest_number(10, 5) == -1 def test_A_divisible_by_B(): assert smallest_number(9, 3) == -1 def test_A_not_divisible_by_B(): assert smallest_number(9, 4) == 9 def test_large_input(): assert smallest_number(10**9, 7) == 10**9 def test_edge_case(): assert smallest_number(1, 1) == -1 assert smallest_number(1, 2) == 1 def test_A_eq_B(): assert smallest_number(1000000000, 1000000000) == -1 def test_A_multiplication_with_other(): assert smallest_number(7, 14) == 7","solution":"def smallest_number(A, B): Returns the smallest positive integer not greater than 10^18 that is divisible by A but not divisible by B. If such a number does not exist, returns -1. from math import gcd # If A is already divisible by B, we need to find a number which is not. if A % B == 0: return -1 # As per the requirement, we need to find the smallest value which fits the condition. # Since the number should be divisible by A, we can start with A. # If the result needs to be within 10^18. # We can directly return A as it is the smallest possible starting point which is divisible by A and if it is not divisible by B. return A"},{"question":"def sort_and_merge(test_cases: List[Dict[str, Union[int, List[List[int]], str]]]) -> List[str]: Sort each list of integers and merge them into a single string with a specified delimiter. Parameters: test_cases (List[Dict[str, Union[int, List[List[int]], str]]]): A list of test cases. Each test case is represented as a dictionary containing: - 'm' (int): The number of lists to sort and merge. - 'lists' (List[List[int]]): Lists of integers to be sorted and merged. - 'delimiter' (str): The delimiter to use for merging the sorted lists. Returns: List[str]: A list of merged strings for each test case. Examples: >>> sort_and_merge([{'m': 2, 'lists': [[5, 2, 3], [9, 1, 4, 10]], 'delimiter': ' '}]) ['2,3,5 1,4,9,10'] >>> sort_and_merge([{'m': 1, 'lists': [[3, 1, 2]], 'delimiter': ','}]) ['1,2,3'] from solution import sort_and_merge def test_single_list(): test_cases = [ { 'm': 1, 'lists': [[3, 1, 2]], 'delimiter': ' ' } ] assert sort_and_merge(test_cases) == ['1,2,3'] def test_multiple_lists(): test_cases = [ { 'm': 2, 'lists': [[5, 2, 3], [9, 1, 4, 10]], 'delimiter': ' ' } ] assert sort_and_merge(test_cases) == ['2,3,5 1,4,9,10'] def test_empty_list(): test_cases = [ { 'm': 1, 'lists': [], 'delimiter': ' ' } ] assert sort_and_merge(test_cases) == [''] def test_various_delimiters(): test_cases = [ { 'm': 2, 'lists': [[3], [7]], 'delimiter': ', ' }, { 'm': 1, 'lists': [[1, 2, 3, 4], [4, 2, 8], [3, 1, 4, 1, 5, 9]], 'delimiter': ' ds ' } ] assert sort_and_merge(test_cases) == ['3, 7', '1,2,3,4 ds 2,4,8 ds 1,1,3,4,5,9'] def test_input_with_multiple_cases(): test_cases = [ { 'm': 1, 'lists': [[3]], 'delimiter': ' ' }, { 'm': 1, 'lists': [[5]], 'delimiter': ' ' } ] assert sort_and_merge(test_cases) == ['3', '5']","solution":"def sort_and_merge(test_cases): results = [] for case in test_cases: m = case['m'] lists = case['lists'] delimiter = case['delimiter'] # Sort each list sorted_lists = [sorted(lst) for lst in lists] # Convert each sorted list to a comma-separated string sorted_str_lists = [','.join(map(str, lst)) for lst in sorted_lists] # Join all sorted strings with the delimiter merged_string = delimiter.join(sorted_str_lists) # Add the result to the list results.append(merged_string) return results"},{"question":"class QuestManager: A system to manage and track the completion status of quests. Each quest has several sub-tasks that must be completed in sequence. Initially, all quests are not started. Methods: start_quest(s: int): Start a new quest with \`s\` sub-tasks. mark_next_subtask_completed(k: int): Mark the next sub-task as completed for a specific quest. is_quest_completed(k: int) -> str: Check if the specific quest is completed. Example: >>> qm = QuestManager() >>> qm.start_quest(3) >>> qm.start_quest(5) >>> qm.mark_next_subtask_completed(0) >>> qm.mark_next_subtask_completed(1) >>> qm.is_quest_completed(0) 'In Progress' >>> qm.is_quest_completed(1) 'In Progress' def __init__(self): self.quests = [] def start_quest(self, s): self.quests.append([0, s]) # [completed_sub_tasks, total_sub_tasks] def mark_next_subtask_completed(self, k): completed, total = self.quests[k] if completed < total: self.quests[k][0] += 1 def is_quest_completed(self, k): completed, total = self.quests[k] return \\"Completed\\" if completed == total else \\"In Progress\\" # Unit Test def test_start_quest(): qm = QuestManager() qm.start_quest(3) assert qm.quests == [[0, 3]] qm.start_quest(5) assert qm.quests == [[0, 3], [0, 5]] def test_mark_next_subtask_completed(): qm = QuestManager() qm.start_quest(3) qm.start_quest(5) qm.mark_next_subtask_completed(0) assert qm.quests == [[1, 3], [0, 5]] qm.mark_next_subtask_completed(1) assert qm.quests == [[1, 3], [1, 5]] qm.mark_next_subtask_completed(0) assert qm.quests == [[2, 3], [1, 5]] def test_is_quest_completed(): qm = QuestManager() qm.start_quest(3) qm.start_quest(2) qm.mark_next_subtask_completed(0) assert qm.is_quest_completed(0) == \\"In Progress\\" qm.mark_next_subtask_completed(0) assert qm.is_quest_completed(0) == \\"In Progress\\" qm.mark_next_subtask_completed(0) assert qm.is_quest_completed(0) == \\"Completed\\" qm.mark_next_subtask_completed(1) assert qm.is_quest_completed(1) == \\"In Progress\\" qm.mark_next_subtask_completed(1) assert qm.is_quest_completed(1) == \\"Completed\\"","solution":"class QuestManager: def __init__(self): self.quests = [] def start_quest(self, s): self.quests.append([0, s]) # [completed_sub_tasks, total_sub_tasks] def mark_next_subtask_completed(self, k): completed, total = self.quests[k] if completed < total: self.quests[k][0] += 1 def is_quest_completed(self, k): completed, total = self.quests[k] return \\"Completed\\" if completed == total else \\"In Progress\\""},{"question":"def can_decorate_tree(n: int, m: int, values: List[int], edges: List[Tuple[int, int]]) -> str: Determine if it's possible to decorate Emma's n-ary tree following the decoration rule. Each node’s value must be divisible by the value of its parent node. Parameters: n (int): Maximum number of children each node can have. m (int): Number of nodes in the tree. values (List[int]): The values of the nodes. edges (List[Tuple[int, int]]): The edges representing the parent-child relationships. Returns: str: \\"Possible\\" if the tree can be decorated following the rule, otherwise \\"Impossible\\". Examples: >>> can_decorate_tree(2, 5, [1, 2, 4, 8, 16], [(1, 2), (1, 3), (3, 4), (3, 5)]) \\"Possible\\" >>> can_decorate_tree(3, 4, [2, 4, 6, 13], [(1, 2), (2, 3), (2, 4)]) \\"Impossible\\" from collections import defaultdict, deque tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) values_dict = {i+1: values[i] for i in range(m)} visited = set() def dfs(node): stack = [(node, -1)] visited.add(node) while stack: current, parent = stack.pop() if parent != -1: if values_dict[current] % values_dict[parent] != 0: return \\"Impossible\\" for neighbor in tree[current]: if neighbor not in visited: visited.add(neighbor) stack.append((neighbor, current)) return \\"Possible\\" return dfs(1)","solution":"def can_decorate_tree(n, m, values, edges): from collections import defaultdict, deque tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) values_dict = {i+1: values[i] for i in range(m)} visited = set() def dfs(node): stack = [(node, -1)] visited.add(node) while stack: current, parent = stack.pop() if parent != -1: if values_dict[current] % values_dict[parent] != 0: return \\"Impossible\\" for neighbor in tree[current]: if neighbor not in visited: visited.add(neighbor) stack.append((neighbor, current)) return \\"Possible\\" return dfs(1)"},{"question":"def count_close_buddy_pairs(n: int, d: int, arr: List[int]) -> int: Returns the number of close-buddy pairs in the array such that the absolute value of the difference between two elements is exactly d. >>> count_close_buddy_pairs(5, 3, [1, 4, 2, 6, 9]) == 2 >>> count_close_buddy_pairs(6, 0, [5, 5, 5, 5, 5, 5]) == 15 >>> count_close_buddy_pairs(5, 7, [1, 2, 3, 4, 5]) == 0","solution":"def count_close_buddy_pairs(n, d, arr): Returns the number of close-buddy pairs in the array such that the absolute value of the difference between two elements is exactly d. :param n: number of integers in the array :param d: required difference for two elements to be considered close-buddies :param arr: list of integers representing the array :return: number of close-buddy pairs from collections import Counter counter = Counter(arr) count = 0 if d == 0: for v in counter.values(): count += v * (v - 1) // 2 else: for value in counter: count += counter[value] * counter[value + d] return count"},{"question":"def restock_decision(n: int, k: int, suggestions: List[int]) -> str: Determine whether to restock based on crew's suggestions and the threshold. >>> restock_decision(4, 150, [30, 40, 50, 20]) == \\"RESTOCK\\" >>> restock_decision(3, 90, [30, 30, 40]) == \\"OVERSTOCK\\" >>> restock_decision(2, 60, [30, 30]) == \\"RESTOCK\\" >>> restock_decision(1, 100, [100]) == \\"RESTOCK\\" >>> restock_decision(1, 1, [1]) == \\"RESTOCK\\"","solution":"def restock_decision(n, k, suggestions): Determine whether to restock based on crew's suggestions and the threshold. Parameters: n (int): Number of crew members k (int): Threshold for restocking suggestions (list of int): Quantities suggested by crew members Returns: str: \\"RESTOCK\\" if total suggestions are within the threshold, \\"OVERSTOCK\\" otherwise total_suggestions = sum(suggestions) if total_suggestions <= k: return \\"RESTOCK\\" else: return \\"OVERSTOCK\\""},{"question":"def min_shipments(n, containers, limit): Determine the minimum number of shipments required so that the sum of items in each shipment does not exceed the limit. Parameters: n (int): The number of containers. containers (list of int): The number of items in each container. limit (int): The maximum limit of items per shipment. Returns: int: The minimum number of shipments required. >>> min_shipments(5, [2, 3, 4, 5, 6], 10) 3 >>> min_shipments(4, [1, 2, 3, 4], 6) 2 >>> min_shipments(1, [5], 10) 1 >>> min_shipments(3, [2, 3, 4], 10) 1 >>> min_shipments(5, [10, 10, 10, 10, 10], 10) 5 >>> min_shipments(0, [], 10) 0 >>> min_shipments(3, [3, 3, 3], 6) 2 >>> min_shipments(100000, [1] * 100000, 5) 20000","solution":"def min_shipments(n, containers, limit): Determine the minimum number of shipments required so that the sum of items in each shipment does not exceed the limit. Parameters: n (int): The number of containers. containers (list of int): The number of items in each container. limit (int): The maximum limit of items per shipment. Returns: int: The minimum number of shipments required. current_sum = 0 shipments = 0 for items in containers: if current_sum + items > limit: shipments += 1 current_sum = items else: current_sum += items if current_sum > 0: shipments += 1 return shipments"},{"question":"from typing import List, Tuple def largest_rectangle_area(matrix: List[List[str]]) -> int: Find the largest rectangular area that can be formed entirely by parks in a grid-shaped city. Args: matrix: A 2D list consisting of 'P' for park and 'B' for building. Returns: int: The area of the largest rectangle consisting entirely of parks. >>> largest_rectangle_area([ ... ['P', 'B', 'B', 'P', 'P'], ... ['P', 'P', 'B', 'P', 'P'], ... ['B', 'P', 'P', 'P', 'B'], ... ['B', 'P', 'P', 'P', 'P'] ... ]) 6 >>> largest_rectangle_area([ ... ['B', 'B', 'B'], ... ['B', 'B', 'B'], ... ['B', 'B', 'B'] ... ]) 0 pass def test_largest_rectangle_area(): matrix1 = [ ['P', 'B', 'B', 'P', 'P'], ['P', 'P', 'B', 'P', 'P'], ['B', 'P', 'P', 'P', 'B'], ['B', 'P', 'P', 'P', 'P'] ] assert largest_rectangle_area(matrix1) == 6 matrix2 = [ ['B', 'B', 'B'], ['B', 'B', 'B'], ['B', 'B', 'B'] ] assert largest_rectangle_area(matrix2) == 0 matrix3 = [ ['B', 'B', 'B'], ['B', 'P', 'B'], ['B', 'B', 'B'] ] assert largest_rectangle_area(matrix3) == 1 matrix4 = [ ['P', 'P', 'P', 'P'] ] assert largest_rectangle_area(matrix4) == 4 matrix5 = [ ['P'], ['P'], ['P'], ['P'], ] assert largest_rectangle_area(matrix5) == 4 matrix6 = [] assert largest_rectangle_area(matrix6) == 0","solution":"def largest_rectangle_area(matrix): def max_histogram_area(heights): heights.append(0) stack = [] max_area = 0 for i in range(len(heights)): while stack and heights[stack[-1]] > heights[i]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() return max_area if not matrix: return 0 n, m = len(matrix), len(matrix[0]) height = [0] * m max_area = 0 for i in range(n): for j in range(m): if matrix[i][j] == 'P': height[j] += 1 else: height[j] = 0 max_area = max(max_area, max_histogram_area(height)) return max_area"},{"question":"def query_results(n: int, m: int, array: List[int], queries: List[Tuple[int, int, int]]) -> List[str]: Determine if the integer x appears more than once in the subarray from array[l] to array[r] (inclusive) for each query. Parameters: n (int): the number of elements in the array. m (int): the number of queries. array (list of int): the array of n integers. queries (list of tuple of int): the list of m queries, each query is a tuple (l, r, x). Returns: list of str: a list containing \\"YES\\" or \\"NO\\" for each query. >>> n, m = 5, 3 >>> array = [1, 2, 3, 2, 4] >>> queries = [(1, 3, 2), (2, 5, 2), (3, 5, 3)] >>> query_results(n, m, array, queries) ['NO', 'YES', 'NO'] >>> n, m = 1, 1 >>> array = [1] >>> queries = [(1, 1, 1)] >>> query_results(n, m, array, queries) ['NO'] >>> n, m = 5, 2 >>> array = [1, 2, 3, 4, 5] >>> queries = [(1, 5, 3), (1, 5, 6)] >>> query_results(n, m, array, queries) ['NO', 'NO'] >>> n, m = 4, 1 >>> array = [2, 2, 2, 2] >>> queries = [(1, 4, 2)] >>> query_results(n, m, array, queries) ['YES'] >>> n, m = 6, 3 >>> array = [1, 2, 3, 4, 3, 4] >>> queries = [(1, 6, 3), (2, 4, 4), (3, 6, 4)] >>> query_results(n, m, array, queries) ['YES', 'NO', 'YES']","solution":"def query_results(n, m, array, queries): Determine if the integer x appears more than once in the subarray from array[l] to array[r] (inclusive) for each query. Parameters: n (int): the number of elements in the array. m (int): the number of queries. array (list of int): the array of n integers. queries (list of tuple of int): the list of m queries, each query is a tuple (l, r, x). Returns: list of str: a list containing \\"YES\\" or \\"NO\\" for each query. results = [] for l, r, x in queries: subarray = array[l-1:r] if subarray.count(x) > 1: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def solve(queries: List[str]) -> List[bool]: Given a list of logical formulas consisting of atomic formulas (denoted by uppercase single English letters 'A' to 'Z') and logical operators (AND represented by '&' and OR represented by '|'), evaluate each formula using predefined atomic formula values and return the result. The atomic formulas are evaluated as follows: - 'A' is True, 'B' is False, 'C' is True, 'D' is False, and so on. The operators '&' and '|' are evaluated using standard Boolean logic rules. >>> solve([\\"A & B | C\\"]) [True] >>> solve([\\"A & (B | C)\\"]) [True] >>> solve([\\"(A & B) | (C & D)\\"]) [False]","solution":"def evaluate_formula(formula): # Mapping for atomic formulas atomic_values = {chr(i): (i-65) % 2 == 0 for i in range(65, 91)} # Replace atomic formulas with their boolean values in the formula eval_formula = \\"\\".join(str(atomic_values[char]) if char in atomic_values else char for char in formula) # Evaluate the formula using eval and Python's Boolean logic return eval(eval_formula) def solve(queries): results = [] for query in queries: result = evaluate_formula(query) results.append(result) return results"},{"question":"def maxProfit(prices): Given a list of daily prices for a fruit, return the maximum profit from at most two transactions (a purchase followed by a sale). Args: prices (List[int]): A list where prices[i] is the price of the fruit on day i (0 ≤ i < n). Returns: int: Maximum profit from at most two transactions. If no profit can be made, return 0. Examples: >>> maxProfit([3,3,5,0,0,3,1,4]) 6 >>> maxProfit([1,2,3,4,5]) 4 >>> maxProfit([7, 6, 4, 3, 1]) 0 >>> maxProfit([5]) 0 >>> maxProfit([3,2,6,5,0,3]) 7 >>> maxProfit([]) 0 >>> maxProfit([1, 2, 1, 2, 1]) 2","solution":"def maxProfit(prices): if not prices: return 0 # Initialize variables to track the maximum profit # First buy/sell first_buy = float('-inf') first_sell = 0 # Second buy/sell second_buy = float('-inf') second_sell = 0 for price in prices: # Trying to buy the first stock first_buy = max(first_buy, -price) # Trying to sell the first stock that was bought first_sell = max(first_sell, first_buy + price) # Trying to buy the second stock after selling the first stock second_buy = max(second_buy, first_sell - price) # Trying to sell the second stock that was bought second_sell = max(second_sell, second_buy + price) return second_sell"},{"question":"def max_tasks(task_list, start_time): Returns the maximum number of tasks that can be successfully completed. :param task_list: List of tuples where each tuple is (time_required, deadline) :param start_time: Initial starting time :return: Maximum number of tasks that can be completed >>> max_tasks([(3, 9), (2, 5), (4, 8), (1, 6), (3, 7)], 2) 3 >>> max_tasks([], 1) 0 >>> max_tasks([(5, 5), (6, 6), (7, 7)], 1) 0 >>> max_tasks([(2, 10), (3, 12), (4, 15)], 1) 3 >>> max_tasks([(4, 8), (3, 5), (2, 4), (2, 6)], 1) 2 >>> n = 100000 >>> start_time = 1 >>> task_list = [(1, 1000000) for _ in range(n)] >>> max_tasks(task_list, start_time) 100000","solution":"def max_tasks(task_list, start_time): Returns the maximum number of tasks that can be successfully completed. :param task_list: List of tuples where each tuple is (time_required, deadline) :param start_time: Initial starting time :return: Maximum number of tasks that can be completed # Sort tasks by their deadline (earliest deadline first) task_list.sort(key=lambda task: task[1]) current_time = start_time successful_tasks = 0 # Iterate through the sorted task list for time_required, deadline in task_list: # Check if the task can be completed before its deadline if current_time + time_required <= deadline: current_time += time_required successful_tasks += 1 return successful_tasks # Driver code e.g. can be tested using the following method def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) S = int(data[1]) tasks = [] index = 2 for _ in range(N): time_required = int(data[index]) deadline = int(data[index + 1]) tasks.append((time_required, deadline)) index += 2 print(max_tasks(tasks, S)) # If for instance the module is run directly, it would execute the main process if __name__ == \\"__main__\\": main()"},{"question":"def min_monotonically_increasing_subarrays(nums: List[int]) -> int: Returns the minimum number of monotonically increasing subarrays needed to partition the given array. >>> min_monotonically_increasing_subarrays([4, 2, 3, 1, 5]) 3 >>> min_monotonically_increasing_subarrays([1, 2, 3, 4, 5, 6]) 1 >>> min_monotonically_increasing_subarrays([5, 4, 3, 2, 1]) 5 >>> min_monotonically_increasing_subarrays([1]) 1 >>> min_monotonically_increasing_subarrays([1, 3, 2, 4, 3, 5, 4, 6]) 4 >>> min_monotonically_increasing_subarrays([1, 2, 2, 3, 2, 4]) 2","solution":"def min_monotonically_increasing_subarrays(nums): Returns the minimum number of monotonically increasing subarrays needed to partition the given array. count = 1 for i in range(1, len(nums)): if nums[i] < nums[i-1]: count += 1 return count"},{"question":"import math def is_within_range(houses, stations, d): Given lists of coordinates for houses and stations, and a maximum allowable distance d, determine if every house has at least one station within distance d. Print \\"YES\\" if every house is within the distance, otherwise print \\"NO\\". Parameters: houses (List[Tuple[int, int]]): List of coordinates representing houses. stations (List[Tuple[int, int]]): List of coordinates representing utility stations. d (int): Maximum allowable distance between a house and a station. Returns: str: \\"YES\\" if every house has at least one station within the distance, otherwise \\"NO\\". Examples: >>> is_within_range([(0, 0), (2, 3), (4, 4)], [(1, 1), (5, 5)], 5) 'YES' >>> is_within_range([(0, 0), (1, 1), (2, 2)], [(0, 3)], 2) 'NO' # Unit tests def test_example_1(): houses = [(0, 0), (2, 3), (4, 4)] stations = [(1, 1), (5, 5)] d = 5 assert is_within_range(houses, stations, d) == \\"YES\\" def test_example_2(): houses = [(0, 0), (1, 1), (2, 2)] stations = [(0, 3)] d = 2 assert is_within_range(houses, stations, d) == \\"NO\\" def test_all_within_distance(): houses = [(1, 1), (2, 2), (3, 3)] stations = [(0, 0), (1, 1), (2, 2), (3, 3)] d = 1 assert is_within_range(houses, stations, d) == \\"YES\\" def test_none_within_distance(): houses = [(10, 10), (20, 20)] stations = [(0, 0)] d = 5 assert is_within_range(houses, stations, d) == \\"NO\\" def test_equal_coordinates(): houses = [(0, 0), (1, 1)] stations = [(0, 0), (1, 1), (2, 2)] d = 0 assert is_within_range(houses, stations, d) == \\"YES\\" def test_large_input(): houses = [(i, i) for i in range(1000)] stations = [(i, i+1) for i in range(1000)] d = 2 assert is_within_range(houses, stations, d) == \\"YES\\"","solution":"import math def is_within_range(houses, stations, d): Returns \\"YES\\" if every house has at least one station within distance d. Otherwise, returns \\"NO\\". for hx, hy in houses: found = False for sx, sy in stations: dist = math.sqrt((sx - hx) ** 2 + (sy - hy) ** 2) if dist <= d: found = True break if not found: return \\"NO\\" return \\"YES\\""},{"question":"def longest_palindrome(s: str) -> int: Returns the length of the longest palindrome that can be formed with the characters in the input string. Input: - s: a string containing only lowercase English characters Output: - an integer representing the length of the longest possible palindrome Example: >>> longest_palindrome(\\"abccccdd\\") 7 >>> longest_palindrome(\\"a\\") 1 >>> longest_palindrome(\\"aaaa\\") 4 >>> longest_palindrome(\\"abcdef\\") 1 >>> longest_palindrome(\\"aabbcdeeffg\\") 9 >>> longest_palindrome(\\"aabbccdde\\") 9 >>> longest_palindrome(\\"\\") 0 >>> longest_palindrome(\\"abcde\\") 1","solution":"def longest_palindrome(s): Returns the length of the longest palindrome that can be formed with the characters in the input string. :param s: a string containing only lowercase English characters :return: an integer representing the length of the longest possible palindrome from collections import Counter count = Counter(s) length = 0 odd_found = False for char, char_count in count.items(): if char_count % 2 == 0: length += char_count else: length += char_count - 1 odd_found = True if odd_found: length += 1 return length"},{"question":"def minimize_max_difference(N, M, grid): Find a path from top left to bottom right in the grid such that the maximum absolute difference between any two adjacent cells in the path is minimized. Uses Dijkstra's algorithm to find the shortest path in a weighted graph where weights are the absolute differences between adjacent cells. Parameters: N (int): number of rows M (int): number of columns grid (list of list of int): N x M grid of integers Returns: int: minimized maximum difference >>> minimize_max_difference(3, 3, [[1, 3, 5], [6, 7, 8], [9, 10, 12]]) 3 >>> minimize_max_difference(2, 2, [[1, 100], [101, 1]]) 99 >>> minimize_max_difference(3, 3, [[1, 2, 2], [2, 3, 3], [2, 2, 1]]) 1 >>> minimize_max_difference(2, 3, [[1, 10, 1], [1, 10, 1]]) 9 >>> minimize_max_difference(1, 1, [[1]]) 0","solution":"from heapq import heappop, heappush import itertools def minimize_max_difference(N, M, grid): Find a path from top left to bottom right in the grid such that the maximum absolute difference between any two adjacent cells in the path is minimized. Uses Dijkstra's algorithm to find the shortest path in a weighted graph where weights are the absolute differences between adjacent cells. Parameters: N (int): number of rows M (int): number of columns grid (list of list of int): N x M grid of integers Returns: int: minimized maximum difference # Define the directions for moving right, down, left, and up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Priority queue for Dijkstra's algorithm pq = [(0, 0, 0)] # (max_diff, x, y) # Keeps track of minimum max difference to reach each cell min_diff = [[float('inf')] * M for _ in range(N)] min_diff[0][0] = 0 while pq: max_diff, x, y = heappop(pq) if x == N - 1 and y == M - 1: return max_diff for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M: diff = abs(grid[x][y] - grid[nx][ny]) new_max_diff = max(max_diff, diff) if min_diff[nx][ny] > new_max_diff: min_diff[nx][ny] = new_max_diff heappush(pq, (new_max_diff, nx, ny)) return -1 # In case no path found which should not happen given valid input"},{"question":"def is_communication_possible(N, M, connections, A, B): Determines if there exists a communication path between two specified computers. Parameters: N (int): number of computers. M (int): number of connections. connections (List[Tuple[int, int]]): list of connections where each connection specifies two computer IDs. A (int): ID of the starting computer. B (int): ID of the destination computer. Returns: str: \\"YES\\" if there exists a communication path between computer A and computer B, otherwise \\"NO\\". Example: >>> is_communication_possible(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)], 1, 5) \\"YES\\" >>> is_communication_possible(3, 3, [(1, 2), (2, 3), (4, 5)], 1, 5) \\"NO\\" pass def process_test_cases(test_cases): Processes multiple test cases to check if communication paths exist for each. Parameters: test_cases (List[Tuple[int, int, List[Tuple[int, int]], int, int]]): list of test cases. Returns: List[str]: results for each test case. Example: >>> process_test_cases([(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)], 1, 5), (3, 3, [(1, 2), (2, 3), (4, 5)], 1, 5)]) [\\"YES\\", \\"NO\\"] pass # Unit test def test_is_communication_possible(): assert is_communication_possible(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)], 1, 5) == \\"YES\\" assert is_communication_possible(3, 3, [(1, 2), (2, 3), (4, 5)], 1, 5) == \\"NO\\" assert is_communication_possible(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 6)], 1, 6) == \\"YES\\" assert is_communication_possible(4, 2, [(1, 2), (3, 4)], 1, 3) == \\"NO\\" def test_process_test_cases(): test_cases = [ (5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)], 1, 5), (3, 3, [(1, 2), (2, 3), (4, 5)], 1, 5) ] assert process_test_cases(test_cases) == [\\"YES\\", \\"NO\\"] test_cases = [ (6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 6)], 1, 6), (4, 2, [(1, 2), (3, 4)], 1, 3) ] assert process_test_cases(test_cases) == [\\"YES\\", \\"NO\\"]","solution":"def is_communication_possible(N, M, connections, A, B): from collections import defaultdict, deque adj_list = defaultdict(list) for U, V in connections: adj_list[U].append(V) adj_list[V].append(U) visited = set() queue = deque([A]) while queue: current = queue.popleft() if current == B: return \\"YES\\" for neighbor in adj_list[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return \\"NO\\" def process_test_cases(test_cases): results = [] for N, M, connections, A, B in test_cases: result = is_communication_possible(N, M, connections, A, B) results.append(result) return results"},{"question":"def average_execution_time(test_cases): Given a list of test cases containing the number of execution times and the times themselves, return a list of average times truncated to 6 decimal places. >>> average_execution_time([(5, [10, 20, 30, 40, 50])]) == [\\"30.000000\\"] >>> average_execution_time([(4, [100, 150, 100, 50])]) == [\\"100.000000\\"] >>> average_execution_time([(6, [1, 2, 3, 4, 5, 6])]) == [\\"3.500000\\"] from solution import average_execution_time def test_average_execution_time(): # Test case from the example test_cases = [ (5, [10, 20, 30, 40, 50]), (4, [100, 150, 100, 50]), (6, [1, 2, 3, 4, 5, 6]) ] expected_output = [ \\"30.000000\\", \\"100.000000\\", \\"3.500000\\" ] assert average_execution_time(test_cases) == expected_output def test_single_value(): test_cases = [ (1, [38]), (1, [1000000]) ] expected_output = [ \\"38.000000\\", \\"1000000.000000\\" ] assert average_execution_time(test_cases) == expected_output def test_varying_length(): test_cases = [ (2, [1, 2]), (3, [4, 5, 6]) ] expected_output = [ \\"1.500000\\", \\"5.000000\\" ] assert average_execution_time(test_cases) == expected_output def test_zero_values(): test_cases = [ (5, [0, 0, 0, 0, 0]), ] expected_output = [ \\"0.000000\\" ] assert average_execution_time(test_cases) == expected_output def test_large_values(): test_cases = [ (3, [1000000, 1000000, 1000000]), ] expected_output = [ \\"1000000.000000\\" ] assert average_execution_time(test_cases) == expected_output","solution":"def average_execution_time(test_cases): Given a list of test cases containing the number of execution times and the times themselves, return a list of average times truncated to 6 decimal places. results = [] for case in test_cases: n = case[0] times = case[1] avg_time = sum(times) / n results.append(f\\"{avg_time:.6f}\\") return results"},{"question":"def min_contiguous_cars(n: int, capacities: List[int], T: int) -> int: Determines the minimum number of contiguous cars needed to meet or exceed the threshold T. Parameters: - n (int): The number of cars. - capacities (list of int): The capacities of each car. - T (int): The minimum threshold of total people required to operate the ride. Returns: - int: The minimum number of contiguous cars needed to meet the threshold T or -1 if impossible. >>> min_contiguous_cars(5, [6, 2, 3, 5, 1], 8) 2 >>> min_contiguous_cars(3, [1, 1, 1], 10) -1 from solution import min_contiguous_cars def test_example_1(): assert min_contiguous_cars(5, [6, 2, 3, 5, 1], 8) == 2 def test_example_2(): assert min_contiguous_cars(3, [1, 1, 1], 10) == -1 def test_single_car_meets_threshold(): assert min_contiguous_cars(5, [1, 2, 3, 4, 5], 5) == 1 def test_entire_array_required(): assert min_contiguous_cars(4, [2, 3, 1, 2], 8) == 4 def test_middle_segment(): assert min_contiguous_cars(6, [1, 2, 3, 1, 1, 1], 6) == 3 def test_no_possible_combination(): assert min_contiguous_cars(4, [1, 2, 2, 1], 9) == -1 def test_exact_match(): assert min_contiguous_cars(5, [1, 2, 2, 4, 2], 6) == 2 def test_large_input_small_threshold(): assert min_contiguous_cars(100000, [1] * 100000, 10) == 10","solution":"def min_contiguous_cars(n, capacities, T): Determines the minimum number of contiguous cars needed to meet or exceed the threshold T. Parameters: - n (int): The number of cars. - capacities (list of int): The capacities of each car. - T (int): The minimum threshold of total people required to operate the ride. Returns: - int: The minimum number of contiguous cars needed to meet the threshold T or -1 if impossible. # Initialize the sum of the current window and the result to a high value current_sum = 0 min_length = float('inf') # Two pointers to define the current window start = 0 for end in range(n): current_sum += capacities[end] while current_sum >= T: min_length = min(min_length, end - start + 1) current_sum -= capacities[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def count_distinct_in_subarray(array, queries): For each query, count the distinct integers in the subarray specified. Args: array (List[int]): The array of integers. queries (List[Tuple[int, int]]): List of queries where each query contains two integers l and r. Returns: List[int]: List of counts of distinct integers for each query. Examples: >>> count_distinct_in_subarray([1, 2, 2, 3, 3, 4, 5], [(1, 3), (2, 5), (3, 7)]) [2, 2, 4] >>> count_distinct_in_subarray([3], [(1, 1)]) [1] pass def process_test_cases(test_cases): Processes multiple test cases according to the problem statement. Args: test_cases (List[Dict]): List of test cases, where each test case is a dictionary containing the size of the array 'n', the number of queries 'q', the 'array' itself, and the 'queries'. Returns: List[int]: List of results for all queries across all test cases. Examples: >>> test_cases = [ { 'n': 7, 'q': 3, 'array': [1, 2, 2, 3, 3, 4, 5], 'queries': [(1, 3), (2, 5), (3, 7)] }, { 'n': 1, 'q': 1, 'array': [3], 'queries': [(1, 1)] }, ] >>> process_test_cases(test_cases) [2, 2, 4, 1] pass","solution":"def count_distinct_in_subarray(array, queries): For each query, count the distinct integers in the subarray specified. results = [] for l, r in queries: subarray = array[l-1:r] distinct_count = len(set(subarray)) results.append(distinct_count) return results def process_test_cases(test_cases): Processes multiple test cases according to the problem statement. all_results = [] for case in test_cases: n, q = case['n'], case['q'] array = case['array'] queries = case['queries'] results = count_distinct_in_subarray(array, queries) all_results.extend(results) return all_results"},{"question":"def can_partition_within_difference(n, k, d, array): Determine if the array can be partitioned into k subarrays such that the absolute difference between the sum of any two subarrays is at most d. Args: n (int): The length of the array. k (int): The number of subarrays to partition into. d (int): The maximum allowed absolute difference between sums of subarrays. array (List[int]): The array of integers to be partitioned. Returns: str: \\"YES\\" if it is possible to partition the array, otherwise \\"NO\\". >>> can_partition_within_difference(5, 3, 1, [1, 2, 3, 4, 5]) \\"NO\\" >>> can_partition_within_difference(5, 2, 10, [1, 1, 1, 1, 1]) \\"YES\\" >>> can_partition_within_difference(6, 4, 3, [1, -2, 3, -4, 5, 6]) \\"YES\\" pass # placeholder for actual implementation def solve(t, test_cases): results = [] for case in test_cases: n, k, d, array = case result = can_partition_within_difference(n, k, d, array) results.append(result) return results def test_can_partition_within_difference(): # Define the test cases t = 3 test_cases = [ (5, 3, 1, [1, 2, 3, 4, 5]), (5, 2, 10, [1, 1, 1, 1, 1]), (6, 4, 3, [1, -2, 3, -4, 5, 6]) ] expected_results = [\\"NO\\", \\"YES\\", \\"YES\\"] # Solve the test cases results = solve(t, test_cases) # Assert each solution for i in range(t): assert results[i] == expected_results[i] if __name__ == \\"__main__\\": import pytest pytest.main([__file__])","solution":"def can_partition_within_difference(n, k, d, array): Determine if the array can be partitioned into k subarrays such that the absolute difference between the sum of any two subarrays is at most d. # It is impossible to partition the array if k > n if k > n: return \\"NO\\" # Calculate the prefix sums of the array prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + array[i] # Use a dynamic programming approach to partition the array dp = [[float('inf')] * (k + 1) for _ in range(n + 1)] dp[0][0] = 0 for i in range(1, n + 1): for j in range(1, k + 1): for l in range(0, i): subarray_sum = prefix_sums[i] - prefix_sums[l] if dp[l][j - 1] != float('inf'): dp[i][j] = min(dp[i][j], max(dp[l][j - 1], subarray_sum)) # Check if the difference between the max sum and min sum of any partition is within d min_sum = min(dp[n][j] for j in range(1, k + 1) if dp[n][j] != float('inf')) max_sum = max(dp[n][j] for j in range(1, k + 1) if dp[n][j] != float('inf')) if max_sum - min_sum <= d: return \\"YES\\" else: return \\"NO\\" def solve(t, test_cases): results = [] for case in test_cases: n, k, d, array = case result = can_partition_within_difference(n, k, d, array) results.append(result) return results"},{"question":"def min_changes_to_palindrome(s: str) -> int: Returns the minimum number of character changes needed to transform the string s into a palindrome. >>> min_changes_to_palindrome(\\"abca\\") 1 >>> min_changes_to_palindrome(\\"racecar\\") 0","solution":"def min_changes_to_palindrome(s): Returns the minimum number of character changes needed to transform the string s into a palindrome. n = len(s) changes = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: changes += 1 return changes"},{"question":"def process_transactions(n: int, transactions: List[Tuple[str, str, int]]) -> List[Tuple[str, int]]: Process a series of transactions and output the final count of each item in the warehouse. Args: n (int): Number of transactions. transactions (List[Tuple[str, str, int]]): List of transactions where each transaction is a tuple containing the type of transaction ('add' or 'remove'), the item_id, and the count. Returns: List[Tuple[str, int]]: List of tuples where each tuple contains the item_id and its final count. Example: >>> process_transactions(5, [(\\"add\\", \\"apple\\", 10), (\\"remove\\", \\"apple\\", 5), (\\"add\\", \\"banana\\", 7), (\\"remove\\", \\"apple\\", 6), (\\"add\\", \\"banana\\", 3)]) [('apple', 5), ('banana', 10)] >>> process_transactions(2, [(\\"add\\", \\"apple\\", 10), (\\"remove\\", \\"apple\\", 10)]) [('apple', 0)]","solution":"def process_transactions(n, transactions): inventory = {} for transaction in transactions: action, item_id, count = transaction[0], transaction[1], int(transaction[2]) if action == \\"add\\": if item_id in inventory: inventory[item_id] += count else: inventory[item_id] = count elif action == \\"remove\\": if item_id in inventory: if inventory[item_id] >= count: inventory[item_id] -= count # If removal tries to take more than available, do nothing # If the action has to be ignored, it does nothing sorted_inventory = sorted(inventory.items()) return [(item, count) for item, count in sorted_inventory]"},{"question":"def library_books_analysis(n: int, l: List[int], b: List[int]) -> Tuple[int, int]: Determines the number of unborrowed books that can still be borrowed and the maximum number of times any book has been borrowed. :param n: Number of books (integer) :param l: List of borrowing limits for each book (list of integers) :param b: List of number of times each book has been borrowed (list of integers) :return: A tuple with two elements: - number of books that have not been borrowed at all but can still be borrowed - the maximum number of times any book has been borrowed pass # Example test cases def test_library_books_analysis_example1(): assert library_books_analysis(5, [2, 3, 1, 4, 5], [0, 2, 0, 3, 5]) == (2, 5) def test_library_books_analysis_example2(): assert library_books_analysis(4, [1, 1, 2, 3], [1, 0, 2, 2]) == (1, 2)","solution":"def library_books_analysis(n, l, b): Determines the number of unborrowed books that can still be borrowed and the maximum number of times any book has been borrowed. :param n: Number of books (integer) :param l: List of borrowing limits for each book (list of integers) :param b: List of number of times each book has been borrowed (list of integers) :return: A tuple with two elements: - number of books that have not been borrowed at all but can still be borrowed - the maximum number of times any book has been borrowed unborrowed_books_count = sum(1 for i in range(n) if b[i] == 0 and l[i] > 0) max_borrowed = max(b) return (unborrowed_books_count, max_borrowed)"},{"question":"from typing import List, Tuple def min_roads_to_disconnect(n: int, r: int, roads: List[Tuple[int, int]]) -> int: Determine the minimum number of roads that, if removed, would make the castles disconnected. Args: n (int): The number of castles. r (int): The number of roads. roads (List[Tuple[int, int]]): The list of roads represented by pairs of castles. Returns: int: The minimum number of roads to remove to disconnect the kingdom. Examples: >>> min_roads_to_disconnect(6, 7, [(1, 2), (1, 3), (2, 3), (2, 4), (3, 4), (3, 5), (4, 6)]) 2 >>> min_roads_to_disconnect(5, 0, []) 0 >>> min_roads_to_disconnect(2, 1, [(1, 2)]) 1 >>> min_roads_to_disconnect(6, 6, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 4)]) 0 >>> min_roads_to_disconnect(5, 10, [(1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)]) 0 >>> min_roads_to_disconnect(4, 3, [(1, 2), (2, 3), (3, 4)]) 3","solution":"from collections import defaultdict, deque def find_bridges(n, connections): def dfs(u, parent): nonlocal time visited[u] = True discovery[u] = low[u] = time time += 1 for v in graph[u]: if not visited[v]: dfs(v, u) low[u] = min(low[u], low[v]) if low[v] > discovery[u]: bridges.append((u, v)) elif v != parent: low[u] = min(low[u], discovery[v]) graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) discovery = [0] * (n + 1) low = [0] * (n + 1) bridges = [] time = 0 for i in range(1, n + 1): if not visited[i]: dfs(i, -1) return len(bridges) def min_roads_to_disconnect(n, r, roads): return find_bridges(n, roads)"},{"question":"import random from typing import List, Tuple def quicksort(arr: List[int], p: int) -> Tuple[List[int], int]: Perform quicksort with a pivot chosen as the median of p random unique elements. Parameters: arr (list of int): List of integers to sort. p (int): Number of random unique elements to choose as potential pivots. Returns: tuple: Sorted array and number of comparisons made. >>> quicksort([4, 1, 3, 2, 5], 3) ([1, 2, 3, 4, 5], <number_of_comparisons>) >>> quicksort([1], 1) ([1], 0) >>> quicksort([1, 2, 3, 4, 5], 3) ([1, 2, 3, 4, 5], <number_of_comparisons>) >>> quicksort([5, 4, 3, 2, 1], 3) ([1, 2, 3, 4, 5], <number_of_comparisons>) >>> quicksort([3, 1, 2, 2, 5, 4, 3], 4) ([1, 2, 2, 3, 3, 4, 5], <number_of_comparisons>) >>> quicksort(list(range(1000, 0, -1)), 5) ([1, 2, 3, ..., 1000], <number_of_comparisons>) pass","solution":"import random def quicksort(arr, p): Perform quicksort with a pivot chosen as the median of p random unique elements. Parameters: arr (list of int): List of integers to sort. p (int): Number of random unique elements to choose as potential pivots. Returns: tuple: Sorted array and number of comparisons made. comparisons = 0 def partition(low, high): nonlocal comparisons # Choose p random unique indices from the array indices = random.sample(range(low, high + 1), min(p, high - low + 1)) candidates = [arr[i] for i in indices] pivot_value = sorted(candidates)[len(candidates) // 2] pivot_index = arr.index(pivot_value) arr[pivot_index], arr[high] = arr[high], arr[pivot_index] pivot = arr[high] i = low - 1 for j in range(low, high): comparisons += 1 if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quicksort_helper(low, high): if low < high: pivot_index = partition(low, high) quicksort_helper(low, pivot_index - 1) quicksort_helper(pivot_index + 1, high) quicksort_helper(0, len(arr) - 1) return arr, comparisons # Example usage: # n, p = 5, 3 # arr = [4, 1, 3, 2, 5] # sorted_arr, total_comparisons = quicksort(arr, p) # print(\\" \\".join(map(str, sorted_arr))) # print(total_comparisons)"},{"question":"def decode_message(messages: List[str]) -> List[str]: Decode each message by converting uppercase letters to lowercase and vice versa for each character in the string. >>> decode_message([\\"HelloWorld\\"]) == [\\"hELLOwORLD\\"] >>> decode_message([\\"SherLock\\"]) == [\\"sHERlOCK\\"] >>> decode_message([\\"DecodeMe\\"]) == [\\"dECODEmE\\"] def process_input_and_decode(T: int, inputs: List[str]) -> List[str]: Process input and decode messages. Parameters: T (int): Number of test cases. inputs (list of str): List of input messages. Returns: list of str: List of decoded message strings. from solution import decode_message, process_input_and_decode def test_decode_single_message(): assert decode_message([\\"HelloWorld\\"]) == [\\"hELLOwORLD\\"] assert decode_message([\\"SherLock\\"]) == [\\"sHERlOCK\\"] assert decode_message([\\"DecodeMe\\"]) == [\\"dECODEmE\\"] def test_decode_multiple_messages(): messages = [\\"HelloWorld\\", \\"SherLock\\", \\"DecodeMe\\"] expected = [\\"hELLOwORLD\\", \\"sHERlOCK\\", \\"dECODEmE\\"] assert decode_message(messages) == expected def test_process_input_and_decode(): T = 3 inputs = [\\"HelloWorld\\", \\"SherLock\\", \\"DecodeMe\\"] expected = [\\"hELLOwORLD\\", \\"sHERlOCK\\", \\"dECODEmE\\"] assert process_input_and_decode(T, inputs) == expected def test_edge_case_empty_string(): assert decode_message([\\"\\"]) == [\\"\\"] def test_edge_case_all_uppercase(): assert decode_message([\\"ABC\\"]) == [\\"abc\\"] def test_edge_case_all_lowercase(): assert decode_message([\\"xyz\\"]) == [\\"XYZ\\"]","solution":"def decode_message(messages): Decode each message by converting uppercase letters to lowercase and vice versa for each character in the string. Parameters: messages (list of str): List of message strings to be decoded. Returns: list of str: List of decoded message strings. decoded_messages = [] for message in messages: decoded_message = ''.join( char.lower() if char.isupper() else char.upper() for char in message ) decoded_messages.append(decoded_message) return decoded_messages def process_input_and_decode(T, inputs): Process input and decode messages. Parameters: T (int): Number of test cases. inputs (list of str): List of input messages. Returns: list of str: List of decoded message strings. # Decode messages using the decode_message function return decode_message(inputs)"},{"question":"def transpose_matrix(n: int, matrix: List[List[int]]) -> List[List[int]]: Transposes an n x n matrix. :param n: size of the matrix :param matrix: list of lists representing the matrix :return: transposed matrix (list of lists) Example: >>> transpose_matrix(3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] pass if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def transpose_matrix(n, matrix): Transposes an n x n matrix. :param n: size of the matrix :param matrix: list of lists representing the matrix :return: transposed matrix (list of lists) transposed = [[matrix[j][i] for j in range(n)] for i in range(n)] return transposed"},{"question":"def maximum_spanning_tree(n: int, edges: List[Tuple[int, int, int]]) -> int: Determine the sum of the weights of the edges in a Maximum Spanning Tree (MST) of the graph. If there are multiple MSTs, any of them can be used for the calculation. :param n: The number of vertices in the graph. :param edges: A list of tuples where each tuple contains two vertices and the weight of the edge between them. :return: The sum of the weights of the edges in a Maximum Spanning Tree. >>> maximum_spanning_tree(4, [(1, 2, 3), (1, 3, 4), (2, 3, 2), (2, 4, 1), (3, 4, 5)]) 12 >>> maximum_spanning_tree(1, []) 0 >>> maximum_spanning_tree(2, [(1, 2, 10)]) 10 >>> maximum_spanning_tree(4, [(1, 2, 3), (2, 3, 3), (3, 4, 3), (4, 1, 3)]) 9 >>> maximum_spanning_tree(100, []) 0 >>> maximum_spanning_tree(3, [(1, 2, 4), (2, 3, 6)]) 10","solution":"class DSU: def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n def find(self, u): if u != self.parent[u]: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def maximum_spanning_tree(n, edges): dsu = DSU(n + 1) edges.sort(key=lambda x: x[2], reverse=True) mst_weight = 0 for u, v, w in edges: if dsu.find(u) != dsu.find(v): dsu.union(u, v) mst_weight += w return mst_weight"},{"question":"import math from typing import List, Tuple def calculate_distance(x1: float, y1: float, x2: float, y2: float) -> float: Calculate the distance between two points in a 2D plane. >>> calculate_distance(0, 0, 3, 4) 5.0 >>> calculate_distance(1, 1, 4, 5) 5.0 pass def minimum_range_to_cover_houses(house_coordinates: List[Tuple[float, float]]) -> float: Determine the minimum range needed for the communication tower to cover all houses. >>> abs(minimum_range_to_cover_houses([(0.0, 0.0), (1.0, 1.0), (2.0, 2.0)]) - 1.414214) < 1e-6 True >>> abs(minimum_range_to_cover_houses([(5.0, 5.0), (5.0, 6.0), (6.0, 5.0), (6.0, 6.0)]) - 0.707107) < 1e-6 True pass def parse_input_data(input_data: str) -> List[List[Tuple[float, float]]]: Parse the input data into a list of datasets with house coordinates. >>> input_data = \\"\\"\\"3n0.0 0.0n1.0 1.0n2.0 2.0n4n5.0 5.0n5.0 6.0n6.0 5.0n6.0 6.0n0n\\"\\"\\" >>> parse_input_data(input_data) [[(0.0, 0.0), (1.0, 1.0), (2.0, 2.0)], [(5.0, 5.0), (5.0, 6.0), (6.0, 5.0), (6.0, 6.0)]] pass def process_input_dataset(dataset: List[List[Tuple[float, float]]]) -> List[str]: Process the input dataset to determine the required minimum range for each set of house coordinates. >>> dataset = [[(0.0, 0.0), (1.0, 1.0), (2.0, 2.0)], [(5.0, 5.0), (5.0, 6.0), (6.0, 5.0), (6.0, 6.0)]] >>> process_input_dataset(dataset) ['1.414214', '0.707107'] pass","solution":"import math def calculate_distance(x1, y1, x2, y2): return math.sqrt((x2 - x1)**2 + (y2 - y1)**2) def minimum_range_to_cover_houses(house_coordinates): n = len(house_coordinates) max_distance = 0 for i in range(n): for j in range(i + 1, n): distance = calculate_distance(house_coordinates[i][0], house_coordinates[i][1], house_coordinates[j][0], house_coordinates[j][1]) if distance > max_distance: max_distance = distance return max_distance / 2 def process_input_dataset(dataset): results = [] for houses in dataset: if houses: min_range = minimum_range_to_cover_houses(houses) results.append(f\\"{min_range:.6f}\\") return results def parse_input_data(input_data): dataset = [] houses = [] lines = input_data.strip().split(\\"n\\") for line in lines: tokens = line.strip().split() if len(tokens) == 1: if tokens[0] == \\"0\\": if houses: dataset.append(houses) break elif houses: dataset.append(houses) houses = [] else: x, y = map(float, tokens) houses.append((x, y)) return dataset # Example usage input_data = 3 0.0 0.0 1.0 1.0 2.0 2.0 4 5.0 5.0 5.0 6.0 6.0 5.0 6.0 6.0 0 dataset = parse_input_data(input_data) results = process_input_dataset(dataset) for result in results: print(result)"},{"question":"from typing import List def process_commands(initial_string: str, commands: List[str]) -> str: Execute a series of commands on the initial string to determine the final string. >>> process_commands(\\"abc\\", [\\"D\\", \\"A d\\", \\"D\\"]) \\"abcabcdabcabcd\\" >>> process_commands(\\"xyz\\", [\\"A a\\", \\"D\\", \\"A b\\"]) \\"xyzaxyzab\\" def test_example_1(): initial_string = \\"abc\\" commands = [\\"D\\", \\"A d\\", \\"D\\"] assert process_commands(initial_string, commands) == \\"abcabcdabcabcd\\" def test_example_2(): initial_string = \\"xyz\\" commands = [\\"A a\\", \\"D\\", \\"A b\\"] assert process_commands(initial_string, commands) == \\"xyzaxyzab\\" def test_empty_initial_string(): initial_string = \\"\\" commands = [\\"D\\", \\"A a\\", \\"D\\"] assert process_commands(initial_string, commands) == \\"aa\\" def test_no_commands(): initial_string = \\"abc\\" commands = [] assert process_commands(initial_string, commands) == \\"abc\\" def test_only_doubling(): initial_string = \\"foo\\" commands = [\\"D\\", \\"D\\", \\"D\\"] assert process_commands(initial_string, commands) == \\"foofoofoofoofoofoofoofoo\\" def test_only_appending(): initial_string = \\"bar\\" commands = [\\"A x\\", \\"A y\\", \\"A z\\"] assert process_commands(initial_string, commands) == \\"barxyz\\" def test_mixed_operations(): initial_string = \\"test\\" commands = [\\"A !\\", \\"D\\", \\"A @\\", \\"D\\"] assert process_commands(initial_string, commands) == \\"test!test!@test!test!@\\"","solution":"from typing import List def process_commands(initial_string: str, commands: List[str]) -> str: result_string = initial_string for command in commands: if command == 'D': result_string = result_string + result_string elif command.startswith('A'): _, char = command.split() result_string = result_string + char return result_string"},{"question":"def unique_paths(m: int, n: int) -> int: Returns the number of unique paths from (0, 0) to (M-1, N-1) in a MxN grid. >>> unique_paths(3, 3) 6 >>> unique_paths(2, 2) 2 >>> unique_paths(7, 3) 28 def solve_all_cases(test_cases: List[Tuple[int, int]]) -> List[int]: Solves multiple test cases of the unique paths problem. Args: test_cases: List of tuples, where each tuple contains two integers M and N. Returns: List of integers where each integer is the number of unique paths for corresponding test case. >>> solve_all_cases([(3, 3), (2, 2), (7, 3)]) [6, 2, 28] >>> solve_all_cases([(1, 1)]) [1] >>> solve_all_cases([(1, 50), (50, 1)]) [1, 1] >>> solve_all_cases([(4, 4), (5, 5), (2, 3), (3, 2)]) [20, 70, 3, 3]","solution":"def unique_paths(m, n): Returns the number of unique paths from (0, 0) to (M-1, N-1) in a MxN grid. # Create a 2D list to store the number of ways to reach each cell dp = [[0] * n for _ in range(m)] # Initialize the first row and first column to 1 for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Fill the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1] def solve_all_cases(test_cases): results = [] for (m, n) in test_cases: results.append(unique_paths(m, n)) return results"},{"question":"def max_cakes(M, K, heights): Returns the maximum number of cakes that can be arranged in a line such that the difference in heights between any two adjacent cakes is at least K. Parameters: M (int): Number of cakes K (int): Minimum difference in heights heights (List[int]): List of cake heights Returns: int: Maximum number of cakes that can be included in the line Examples: >>> max_cakes(5, 3, [1, 3, 6, 8, 10]) 3 >>> max_cakes(7, 2, [2, 2, 2, 3, 5, 7, 9]) 4 from solution import max_cakes def test_max_cakes_example1(): assert max_cakes(5, 3, [1, 3, 6, 8, 10]) == 3 def test_max_cakes_example2(): assert max_cakes(7, 2, [2, 2, 2, 3, 5, 7, 9]) == 4 def test_max_cakes_no_cake_meets_requirement(): assert max_cakes(3, 5, [1, 2, 3]) == 1 def test_max_cakes_all_cakes_identical(): assert max_cakes(4, 1, [4, 4, 4, 4]) == 1 def test_max_cakes_large_K(): assert max_cakes(5, 1000, [1, 100, 200, 300, 400]) == 1 def test_max_cakes_minimal_constraints(): assert max_cakes(1, 1, [1]) == 1","solution":"def max_cakes(M, K, heights): Returns the maximum number of cakes that can be arranged in a line such that the difference in heights between any two adjacent cakes is at least K. # Sort the heights heights.sort() # Initialize the count of cakes count = 1 current_height = heights[0] # Iterate through the sorted list and count cakes that meet the requirement for i in range(1, M): if heights[i] - current_height >= K: count += 1 current_height = heights[i] return count # Example usage: Note that in a real scenario, the input would be read from standard input if __name__ == \\"__main__\\": M, K = 5, 3 heights = [1, 3, 6, 8, 10] print(max_cakes(M, K, heights)) # Output: 3"},{"question":"def find_available_point(x: int, y: int) -> int: Returns the available point value for the next participant when two values are already taken. :param x: Integer, one of the taken points (1, 2, or 3) :param y: Integer, the other taken point (1, 2, or 3) :return: Integer, the available point value >>> find_available_point(1, 3) 2 >>> find_available_point(2, 1) 3 >>> find_available_point(2, 3) 1","solution":"def find_available_point(x, y): Returns the available point value for the next participant when two values are already taken. :param x: Integer, one of the taken points (1, 2, or 3) :param y: Integer, the other taken point (1, 2, or 3) :return: Integer, the available point value return 6 - x - y"},{"question":"from typing import List, Tuple def determine_winner(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determine the winner of the game if both players play optimally. Arguments: n -- number of nodes in the graph m -- number of edges in the graph edges -- list of edges represented as tuples (u, v) Returns: \\"Alice\\" if Alice can force a win, otherwise \\"Bob\\". Example: >>> determine_winner(3, 3, [(1, 2), (2, 3), (3, 1)]) \\"Bob\\" >>> determine_winner(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"Alice\\" def find_winners(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Determine the winners for multiple test cases. Arguments: test_cases -- list of test cases, each represented as a tuple (n, m, edges) Returns: A list of strings where each string is either \\"Alice\\" or \\"Bob\\" for each test case. Example: >>> find_winners([(3, 3, [(1, 2), (2, 3), (3, 1)]), (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)])]) [\\"Bob\\", \\"Alice\\"] def parse_input(input_str: str) -> List[Tuple[int, int, List[Tuple[int, int]]]]: Parse the input string into a format suitable for processing. Arguments: input_str -- The input string Returns: A list of test cases, each represented as a tuple (n, m, edges). Example: >>> parse_input(\\"3n3 3n1 2n2 3n3 1n4 4n1 2n2 3n3 4n4 1n4 3n1 2n2 3n3 4\\") [(3, 3, [(1, 2), (2, 3), (3, 1)]), (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), (4, 3, [(1, 2), (2, 3), (3, 4)])]","solution":"def determine_winner(n, m, edges): # The outcome of the game is determined by the parity of the number of edges. if m % 2 == 0: return \\"Alice\\" else: return \\"Bob\\" def find_winners(test_cases): results = [] for test in test_cases: n, m, edges = test results.append(determine_winner(n, m, edges)) return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) idx = 1 test_cases = [] for _ in range(T): n, m = map(int, lines[idx].split()) edges = [] for i in range(m): u, v = map(int, lines[idx + 1 + i].split()) edges.append((u, v)) test_cases.append((n, m, edges)) idx += 1 + m return test_cases"},{"question":"def min_operations_to_equalize(arr): Returns the minimum number of operations to make all integers in the array equal. Parameters: arr (List[int]): The list of integers. Returns: int: The minimum number of operations. pass # Unit Test def test_min_operations_example1(): assert min_operations_to_equalize([1, 2, 3, 4]) == 4 def test_min_operations_example2(): assert min_operations_to_equalize([10, 10, 10]) == 0 def test_min_operations_small_array(): assert min_operations_to_equalize([1, 2]) == 1 def test_min_operations_already_equal(): assert min_operations_to_equalize([5, 5, 5, 5]) == 0 def test_min_operations_large_difference(): assert min_operations_to_equalize([1, 1000000000]) == 999999999 def test_min_operations_mixed_numbers(): assert min_operations_to_equalize([1, -1, 3, 7]) == 10 def test_min_operations_with_negatives(): assert min_operations_to_equalize([-1, -2, -3, -4]) == 4","solution":"def min_operations_to_equalize(arr): Returns the minimum number of operations to make all integers in the array equal. Parameters: arr (List[int]): The list of integers. Returns: int: The minimum number of operations. n = len(arr) median = sorted(arr)[n // 2] return sum(abs(x - median) for x in arr) # Read input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) A = list(map(int, data[1:])) print(min_operations_to_equalize(A))"},{"question":"def total_animals_in_segments(n: int, animals: List[int], queries: List[Tuple[int, int]]) -> List[int]: Computes the total number of animals in the specified segments of the forest. params: - n: int, the number of regions in the forest - animals: List[int], the number of animals in each region - queries: List[Tuple[int, int]], each tuple represents a segment to query return: - List[int], total number of animals in each specified segment Examples: >>> total_animals_in_segments(5, [1, 2, 3, 4, 5], [(1, 3), (2, 5), (1, 5)]) [6, 14, 15] >>> total_animals_in_segments(4, [10, 20, 30, 40], [(1, 2), (3, 4)]) [30, 70]","solution":"def total_animals_in_segments(n, animals, queries): Computes the total number of animals in the specified segments of the forest. params: - n: int, the number of regions in the forest - animals: List[int], the number of animals in each region - queries: List[Tuple[int, int]], each tuple represents a segment to query return: - List[int], total number of animals in each specified segment # Precompute prefix sums to make range sum queries faster prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i+1] = prefix_sums[i] + animals[i] results = [] for l, r in queries: segment_sum = prefix_sums[r] - prefix_sums[l-1] results.append(segment_sum) return results"},{"question":"from typing import List def generate_sublists(arr: List[int], sublist_length: int) -> List[List[int]]: Create a function that takes a list of integers and returns a new list containing all the contiguous sublists (sublists made up of consecutive elements) of a length you specify. Each sublist should be in the same order as in the input list. >>> generate_sublists([1, 2, 3, 4], 3) [[1, 2, 3], [2, 3, 4]] >>> generate_sublists([1, 2, 3], 0) [] >>> generate_sublists([1, 2, 3], 4) [] >>> generate_sublists([1, 2, 3], -1) [] >>> generate_sublists([], 1) []","solution":"from typing import List def generate_sublists(arr: List[int], sublist_length: int) -> List[List[int]]: if sublist_length <= 0 or sublist_length > len(arr): return [] sublists = [] for i in range(len(arr) - sublist_length + 1): sublists.append(arr[i:i + sublist_length]) return sublists"},{"question":"def plant_height(n: int) -> int: Calculate the height of the plant after n days, given its initial height of 1 unit. Parameters: n (int): The number of days. Returns: int: The height of the plant after n days. >>> plant_height(5) 2 >>> plant_height(10) 1 >>> plant_height(999) 2 >>> plant_height(1000) 1","solution":"def plant_height(n): Calculate the height of the plant after n days. Parameters: n (int): number of days Returns: int: height of the plant after n days height = 1 # initial height for day in range(1, n + 1): if day % 2 != 0: height *= 2 else: height *= 0.5 return int(height)"},{"question":"def min_operations(t: int, test_cases: List[str]) -> List[int]: Given the number of test cases and each string, return a list of minimum operations needed for each string to make sure no two adjacent characters are the same. >>> min_operations(3, [\\"aabb\\", \\"aaab\\", \\"ababa\\"]) [2, 2, 0] >>> min_operations(2, [\\"aaaa\\", \\"abababab\\"]) [3, 0] >>> min_operations(1, [\\"abcabcabc\\"]) [0] >>> min_operations(4, [\\"zz\\", \\"xx\\", \\"yy\\", \\"uu\\"]) [1, 1, 1, 1] >>> min_operations(3, [\\"zxzxzx\\", \\"yxyxy\\", \\"xyxyxyx\\"]) [0, 0, 0]","solution":"def min_operations(t, test_cases): Given the number of test cases and each string, return a list of minimum operations needed for each string to make sure no two adjacent characters are the same. results = [] for s in test_cases: count = 0 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 results.append(count) return results"},{"question":"def can_organize_socks(n: int, m: int, sock_patterns: List[int], compartments: List[int]) -> str: Determines if Alex can place each sock in its corresponding compartment without conflicts. :param n: Number of socks :param m: Number of compartments :param sock_patterns: List of sock patterns :param compartments: List of compartment labels :return: \\"YES\\" if each sock can be placed in the compartments without conflicts, \\"NO\\" otherwise from solution import can_organize_socks def test_can_organize_socks_case1(): assert can_organize_socks(3, 5, [1, 2, 3], [3, 4, 2]) == \\"YES\\" def test_can_organize_socks_case2(): assert can_organize_socks(4, 3, [1, 2, 3, 4], [1, 2, 3, 2]) == \\"NO\\" def test_can_organize_socks_case3(): assert can_organize_socks(3, 3, [1, 2, 3], [1, 2, 3]) == \\"YES\\" def test_can_organize_socks_case4(): assert can_organize_socks(5, 6, [1, 2, 3, 4, 5], [1, 3, 5, 2, 4]) == \\"YES\\" def test_can_organize_socks_case5(): assert can_organize_socks(5, 5, [1, 2, 3, 4, 5], [1, 2, 3, 4, 4]) == \\"NO\\"","solution":"def can_organize_socks(n, m, sock_patterns, compartments): Determines if Alex can place each sock in its corresponding compartment without conflicts. :param n: Number of socks :param m: Number of compartments :param sock_patterns: List of sock patterns :param compartments: List of compartment labels :return: \\"YES\\" if each sock can be placed in the compartments without conflicts, \\"NO\\" otherwise occupied_compartments = set() for compartment in compartments: if compartment in occupied_compartments: return \\"NO\\" occupied_compartments.add(compartment) return \\"YES\\""},{"question":"def can_partition(nums: List[int]) -> bool: Determines if the list can be partitioned into two subsets with equal sum. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False","solution":"def can_partition(nums): Determines if the list can be partitioned into two subsets with equal sum. total_sum = sum(nums) # If total sum is odd, it cannot be split into two equal parts if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Create a set to store possible sums possible_sums = {0} for num in nums: # Update possible_sums for the current number new_sums = set() for s in possible_sums: if s + num == target: return True new_sums.add(s + num) possible_sums.update(new_sums) return target in possible_sums"},{"question":"def process_orders(M: int, N: int, X: int, Y: int, orders: List[Tuple[str, int]]) -> int: Determines the number of complete orders that can be fulfilled within the available time. Args: M (int): Total working hours available in a day. N (int): Number of orders for that day. X (int): Time taken to produce one unit of product A. Y (int): Time taken to produce one unit of product B. orders (list of tuples): Each tuple contains product type ('A' or 'B') and the quantity required. Returns: int: Number of complete orders that can be processed in a day. >>> process_orders(8, 3, 2, 3, [('A', 2), ('B', 1), ('A', 3)]) 2 >>> process_orders(10, 2, 4, 5, [('A', 1), ('B', 2)]) 1 >>> process_orders(0, 1, 2, 3, [('A', 1)]) 0 >>> process_orders(100, 20, 1, 2, [('A', 1)] * 10 + [('B', 1)] * 10) 20 pass def parse_input(input_str: str) -> List[int]: Parses the input string to determine the results for each test case. Args: input_str (str): Input string containing multiple test cases. Returns: List[int]: List of results for each test case. >>> input_data = '''8 3 ... 2 3 ... A 2 ... B 1 ... A 3 ... 10 2 ... 4 5 ... A 1 ... B 2 ... 0 0''' >>> parse_input(input_data) [2, 1] >>> input_data = '''0 1 ... 2 3 ... A 1 ... 0 0''' >>> parse_input(input_data) [0] pass from typing import List, Tuple def test_process_orders(): assert process_orders(8, 3, 2, 3, [('A', 2), ('B', 1), ('A', 3)]) == 2 assert process_orders(10, 2, 4, 5, [('A', 1), ('B', 2)]) == 1 assert process_orders(0, 1, 2, 3, [('A', 1)]) == 0 assert process_orders(100, 20, 1, 2, [('A', 1)] * 10 + [('B', 1)] * 10) == 20 def test_parse_input(): input_data = 8 3 2 3 A 2 B 1 A 3 10 2 4 5 A 1 B 2 0 0 expected_output = [2, 1] assert parse_input(input_data) == expected_output input_data = 0 1 2 3 A 1 0 0 expected_output = [0] assert parse_input(input_data) == expected_output","solution":"def process_orders(M, N, X, Y, orders): complete_orders = 0 for order in orders: order_type, quantity = order if order_type == 'A': required_time = X * quantity elif order_type == 'B': required_time = Y * quantity else: continue if required_time <= M: complete_orders += 1 M -= required_time return complete_orders def parse_input(input_str): lines = input_str.strip().split('n') idx = 0 results = [] while idx < len(lines): M, N = map(int, lines[idx].split()) if M == 0 and N == 0: break idx += 1 X, Y = map(int, lines[idx].split()) idx += 1 orders = [] for _ in range(N): order_type, quantity = lines[idx].split() quantity = int(quantity) orders.append((order_type, quantity)) idx += 1 results.append(process_orders(M, N, X, Y, orders)) return results"},{"question":"def can_deliver_package(t: int, test_cases: List[Dict[str, Union[int, Tuple[int, int]]]]) -> List[str]: Determine if the drone can successfully deliver the package to its destination without exhausting its battery. >>> can_deliver_package(3, [ ... {'E': 10, 'start': (0, 0), 'end': (3, 4)}, ... {'E': 5, 'start': (0, 0), 'end': (3, 4)}, ... {'E': 7, 'start': (1, 1), 'end': (4, 5)} ... ]) [\\"yes\\", \\"no\\", \\"yes\\"] >>> can_deliver_package(2, [ ... {'E': 8, 'start': (1, 2), 'end': (3, 5)}, ... {'E': 2, 'start': (0, 0), 'end': (1, 2)} ... ]) [\\"yes\\", \\"no\\"] >>> can_deliver_package(1, [ ... {'E': 4, 'start': (-1, -1), 'end': (1, 1)} ... ]) [\\"yes\\"] >>> can_deliver_package(2, [ ... {'E': 15, 'start': (0, 0), 'end': (10, 5)}, ... {'E': 15, 'start': (0, 0), 'end': (10, 6)} ... ]) [\\"yes\\", \\"no\\"] >>> can_deliver_package(1, [ ... {'E': 1, 'start': (0, 0), 'end': (0, 1)} ... ]) [\\"yes\\"] >>> can_deliver_package(1, [ ... {'E': 0, 'start': (2, 2), 'end': (2, 2)} ... ]) [\\"yes\\"]","solution":"def can_deliver_package(t, test_cases): results = [] for i in range(t): E = test_cases[i]['E'] X1, Y1 = test_cases[i]['start'] X2, Y2 = test_cases[i]['end'] # Calculate the Manhattan distance between start and end coordinates distance = abs(X2 - X1) + abs(Y2 - Y1) if distance <= E: results.append(\\"yes\\") else: results.append(\\"no\\") return results"},{"question":"from typing import List, Tuple, Dict def longest_login_streak(n: int, logins: List[Tuple[str, int]]) -> Dict[str, int]: Function to find the longest streak of consecutive days with at least one login for each user. Args: n (int): The number of login events. logins (list): A list of tuples (user_id, timestamp) representing the login events. Returns: dict: A dictionary where each key is a user_id and each value is the length of the longest streak of consecutive days. Examples: >>> longest_login_streak(10, [('alice', 1609459200), ('alice', 1609545600), ('alice', 1609632000), ('bob', 1609459200), ('bob', 1609545600), ('bob', 1612224000), ('alice', 1612137600), ('alice', 1612224000), ('charlie', 1609459200), ('charlie', 1609545600)]) {'alice': 3, 'bob': 2, 'charlie': 2} >>> longest_login_streak(1, [('alice', 1609459200)]) {'alice': 1} >>> longest_login_streak(4, [('alice', 1609459200), ('alice', 1609545600), ('alice', 1612224000), ('alice', 1612310400)]) {'alice': 2}","solution":"from collections import defaultdict import time def longest_login_streak(n, logins): Function to find the longest streak of consecutive days with at least one login for each user. Args: n (int): The number of login events. logins (list): A list of tuples (user_id, timestamp) representing the login events. Returns: dict: A dictionary where each key is a user_id and each value is the length of the longest streak of consecutive days. log_dates = defaultdict(set) # Convert the timestamps to days since 1970-01-01 and store unique log days per user for user_id, timestamp in logins: log_day = int(time.strftime('%Y-%m-%d', time.gmtime(timestamp)).replace('-', '')) log_dates[user_id].add(log_day) result = {} for user_id, days in log_dates.items(): sorted_days = sorted(days) longest_streak = 1 current_streak = 1 for i in range(1, len(sorted_days)): if sorted_days[i] == sorted_days[i - 1] + 1: current_streak += 1 longest_streak = max(longest_streak, current_streak) else: current_streak = 1 result[user_id] = longest_streak return result"},{"question":"def count_distinct_substrings(s: str, k: int) -> int: Returns the number of distinct substrings of length k in the string s. >>> count_distinct_substrings(\\"abcabc\\", 3) 3 >>> count_distinct_substrings(\\"aaaa\\", 2) 1 >>> count_distinct_substrings(\\"abcdefghijklmnop\\", 1) 16","solution":"def count_distinct_substrings(s, k): Returns the number of distinct substrings of length k in the string s. if k > len(s): return 0 substrings = set() for i in range(len(s) - k + 1): substr = s[i:i+k] substrings.add(substr) return len(substrings)"},{"question":"def process_orders(n: int, orders: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Process the orders in the sequence they arrive and return the completion times. :param n: Number of orders :param orders: List of tuples, where each tuple contains (processing_time, unique_identifier) :return: List of tuples, where each tuple contains (unique_identifier, completion_time) >>> process_orders(3, [(3, 101), (5, 102), (2, 103)]) [(101, 3), (102, 8), (103, 10)] >>> process_orders(1, [(4, 201)]) [(201, 4)] >>> process_orders(3, [(2, 301), (2, 302), (2, 303)]) [(301, 2), (302, 4), (303, 6)] >>> process_orders(3, [(1, 401), (3, 402), (2, 403)]) [(401, 1), (402, 4), (403, 6)] >>> process_orders(2, [(100, 501), (200, 502)]) [(501, 100), (502, 300)] >>> process_orders(1, [(1, 601)]) [(601, 1)] >>> process_orders(1000, [(1, i) for i in range(1, 1001)]) [(i, i) for i in range(1, 1001)]","solution":"def process_orders(n, orders): Process the orders in the sequence they arrive and return the completion times. :param n: Number of orders :param orders: List of tuples, where each tuple contains (processing_time, unique_identifier) :return: List of tuples, where each tuple contains (unique_identifier, completion_time) completion_times = [] current_time = 0 for t_i, p_i in orders: current_time += t_i completion_times.append((p_i, current_time)) return completion_times"},{"question":"def is_balanced_brackets(s: str) -> str: Check if the input string of brackets is balanced. Parameters: s (str): a string consisting of '(', ')', '[', ']', '{', '}' Returns: str: \\"YES\\" if the string is balanced, \\"NO\\" otherwise. >>> is_balanced_brackets(\\"()\\") \\"YES\\" >>> is_balanced_brackets(\\"([]){}([])\\") \\"YES\\" >>> is_balanced_brackets(\\"([)]\\") \\"NO\\" >>> is_balanced_brackets(\\"{[()()]}\\") \\"YES\\" >>> is_balanced_brackets(\\"{[(])}\\") \\"NO\\" >>> is_balanced_brackets(\\"((()))[]{}\\") \\"YES\\" >>> is_balanced_brackets(\\"\\") \\"YES\\" >>> is_balanced_brackets(\\"()\\") \\"YES\\" >>> is_balanced_brackets(\\"[]\\") \\"YES\\" >>> is_balanced_brackets(\\"{}\\") \\"YES\\" >>> is_balanced_brackets(\\"([{}])\\") \\"YES\\" >>> is_balanced_brackets(\\"[({})]\\") \\"YES\\" >>> is_balanced_brackets(\\"{[(())]}\\") \\"YES\\" >>> is_balanced_brackets(\\"({[(())]})\\") \\"YES\\" >>> is_balanced_brackets(\\"(}\\") \\"NO\\" >>> is_balanced_brackets(\\"[{]}\\") \\"NO\\" >>> is_balanced_brackets(\\"{[}]\\") \\"NO\\" >>> is_balanced_brackets(\\"([{})]\\") \\"NO\\"","solution":"def is_balanced_brackets(s): Check if the input string of brackets is balanced. Parameters: s (str): a string consisting of '(', ')', '[', ']', '{', '}' Returns: str: \\"YES\\" if the string is balanced, \\"NO\\" otherwise. stack = [] bracket_map = {')': '(', ']': '[', '}': '{'} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map: if stack and stack[-1] == bracket_map[char]: stack.pop() else: return \\"NO\\" else: return \\"NO\\" return \\"YES\\" if not stack else \\"NO\\""},{"question":"def max_distance(commands: str) -> int: Calculate the maximum possible distance the robotic arm can be from the starting point (0, 0) after exactly changing two commands. >>> max_distance(\\"URDL\\") == 2 >>> max_distance(\\"UUDDLRL\\") == 3","solution":"def max_distance(commands): Calculate the maximum possible distance the robotic arm can be from the starting point (0, 0) after exactly changing two commands. x, y = 0, 0 # Calculate initial position for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 # To maximize distance, we can change two commands to 'U' or 'R'. # This effectively means we can add 2 to our current x or y coordinate. max_distance = abs(x) + abs(y) + 2 return max_distance"},{"question":"def count_common_characters(n: int, gemstones: List[str]) -> int: Returns the number of common characters that appear in every gemstone. >>> count_common_characters(3, [\\"abcdde\\", \\"baccd\\", \\"eeabg\\"]) 2 >>> count_common_characters(4, [\\"abc\\", \\"def\\", \\"ghi\\", \\"jkl\\"]) 0 >>> count_common_characters(3, [\\"aaa\\", \\"aaa\\", \\"aaa\\"]) 1 >>> count_common_characters(3, [\\"abc\\", \\"def\\", \\"ghi\\"]) 0 >>> count_common_characters(1, [\\"abcdefghijklmnop\\"]) 16 >>> count_common_characters(2, [\\"a\\"*100, \\"a\\"*99 + \\"b\\"]) 1","solution":"def count_common_characters(n, gemstones): Returns the number of common characters that appear in every gemstone. # Find the set of characters in the first gemstone common_chars = set(gemstones[0]) # Intersect it with the set of characters in remaining gemstones for i in range(1, n): common_chars &= set(gemstones[i]) # The number of common characters is the size of the intersection set return len(common_chars)"},{"question":"def find_shortest_paths(n: int, m: int, roads: List[Tuple[int, int, int]]) -> List[Union[int, str]]: Calculate the minimum travel time from the central intersection to every other intersection in the city. If an intersection is not reachable, return 'INF' for that intersection. Args: n (int): The number of intersections. m (int): The number of roads. roads (List[Tuple[int, int, int]]): A list of tuples where each tuple (u, v, t) represents a one-way road from intersection u to intersection v with a travel time of t. Returns: List[Union[int, str]]: A list of travel times from the central intersection to intersections 1 through n. Examples: >>> find_shortest_paths(4, 4, [(1, 2, 3), (1, 3, 1), (3, 2, 1), (2, 4, 2)]) [0, 2, 1, 4] >>> find_shortest_paths(5, 6, [(1, 2, 6), (1, 3, 2), (2, 4, 1), (3, 2, 1), (4, 3, 5), (4, 5, 3)]) [0, 3, 2, 4, 7] >>> find_shortest_paths(4, 2, [(1, 2, 5), (2, 3, 3)]) [0, 5, 8, 'INF']","solution":"import heapq def find_shortest_paths(n, m, roads): graph = {i: [] for i in range(1, n + 1)} for u, v, t in roads: graph[u].append((v, t)) # Dijkstra's algorithm to find the shortest paths from the central node (1) def dijkstra(start): distances = {i: float('inf') for i in range(1, n + 1)} distances[start] = 0 priority_queue = [(0, start)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances shortest_paths = dijkstra(1) result = [] for i in range(1, n + 1): if shortest_paths[i] == float('inf'): result.append(\\"INF\\") else: result.append(shortest_paths[i]) return result"},{"question":"import random import string def modify_password(password: str) -> str: Modify a given password to meet complexity requirements: - At least 1 uppercase letter - At least 1 lowercase letter - At least 1 digit - At least 1 special character from the set: !@#%^&*()-+ - Minimum length of 8 characters # Example test cases: # assert modify_password(\\"abcD3\\") == \\"abcD3!@\\" # assert modify_password(\\"1234567!@\\") == \\"A1234567!@\\" # assert modify_password(\\"Abcdefgh\\") == \\"Abcdefgh1!\\" # assert modify_password(\\"abc1!@#\\") == \\"abc1!@#D\\"","solution":"import string import random def modify_password(password): This function takes a password string and modifies it to ensure it meets the specified complexity requirements: - At least 1 uppercase letter - At least 1 lowercase letter - At least 1 digit - At least 1 special character from the set: !@#%^&*()-+ - Minimum length of 8 characters has_upper = any(c.isupper() for c in password) has_lower = any(c.islower() for c in password) has_digit = any(c.isdigit() for c in password) has_special = any(c in '!@#%^&*()-+' for c in password) needed_chars = [] if not has_upper: needed_chars.append(random.choice(string.ascii_uppercase)) if not has_lower: needed_chars.append(random.choice(string.ascii_lowercase)) if not has_digit: needed_chars.append(random.choice(string.digits)) if not has_special: needed_chars.append(random.choice('!@#%^&*()-+')) password += ''.join(needed_chars) if len(password) < 8: extra_chars_needed = 8 - len(password) password += ''.join(random.choices(string.ascii_letters + string.digits + '!@#%^&*()-+', k=extra_chars_needed)) return password"},{"question":"from typing import List, Tuple def find_path_between_stations(n: int, metro_lines: List[List[str]], q: int, queries: List[Tuple[str, str]]) -> List[str]: Determines if there exists a path between two stations located on different lines. Args: n (int): Number of lines in the metro system. metro_lines (List[List[str]]): List of metro lines where each line is a list of stations. q (int): Number of queries. queries (List[Tuple[str, str]]): List of station pairs for which to determine if a path exists. Returns: List[str]: List of \\"YES\\" or \\"NO\\" for each query. Example: n = 4 metro_lines = [ [\\"A1\\", \\"A2\\", \\"A3\\", \\"A4\\"], [\\"B1\\", \\"B2\\", \\"B3\\"], [\\"C1\\", \\"C2\\", \\"C3\\"], [\\"D1\\", \\"D2\\", \\"D3\\"] ] q = 5 queries = [ (\\"A1\\", \\"B1\\"), (\\"A3\\", \\"C3\\"), (\\"B2\\", \\"D2\\"), (\\"C1\\", \\"D3\\"), (\\"A1\\", \\"A4\\"), ] assert find_path_between_stations(n, metro_lines, q, queries) == [\\"NO\\", \\"NO\\", \\"NO\\", \\"NO\\", \\"YES\\"]","solution":"def find_path_between_stations(n, metro_lines, q, queries): from collections import defaultdict, deque # Build an adjacency list for the stations based on metro lines station_to_lines = defaultdict(set) for i, line in enumerate(metro_lines): for station in line: station_to_lines[station].add(i) # Build a graph (adjacency list) for the lines based on station connections line_graph = defaultdict(set) for stations in metro_lines: for i in range(len(stations)): for j in range(i + 1, len(stations)): line_graph[stations[i]].add(stations[j]) line_graph[stations[j]].add(stations[i]) # Function to check if there is a path using BFS def is_path(station1, station2): if station1 == station2: return True visited = set() queue = deque([station1]) while queue: current_station = queue.popleft() if current_station in visited: continue if current_station == station2: return True visited.add(current_station) for neighbor in line_graph[current_station]: if neighbor not in visited: queue.append(neighbor) return False # Processing queries results = [] for s1, s2 in queries: if is_path(s1, s2): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage (without interactive input/output to match requirements): n = 4 metro_lines = [ [\\"A1\\", \\"A2\\", \\"A3\\", \\"A4\\"], [\\"B1\\", \\"B2\\", \\"B3\\"], [\\"C1\\", \\"C2\\", \\"C3\\"], [\\"D1\\", \\"D2\\", \\"D3\\"] ] q = 5 queries = [ (\\"A1\\", \\"B1\\"), (\\"A3\\", \\"C3\\"), (\\"B2\\", \\"D2\\"), (\\"C1\\", \\"D3\\"), (\\"A1\\", \\"A4\\"), ] output = find_path_between_stations(n, metro_lines, q, queries) for result in output: print(result)"},{"question":"def is_possible(books, n, k, max_pages): Helper function to check if it is possible to allocate books such that the maximum number of pages per student is minimized. :param books: List of integers representing the number of pages in each book. :param n: Number of books. :param k: Number of students. :param max_pages: The maximum number of pages a student can read. :return: Boolean indicating whether it is possible to allocate books in such a way. student_count = 1 current_pages = 0 for pages in books: if current_pages + pages > max_pages: student_count += 1 current_pages = pages if student_count > k: return False else: current_pages += pages return True def find_minimum_max_pages(books, n, k): Function to find the minimum possible value for the maximum number of pages assigned to a student. :param books: List of integers representing the number of pages in each book. :param n: Number of books. :param k: Number of students. :return: Minimum possible value for the maximum number of pages a student has to read. if k > n: return -1 low = max(books) high = sum(books) result = high while low <= high: mid = (low + high) // 2 if is_possible(books, n, k, mid): result = mid high = mid - 1 else: low = mid + 1 return result def allocate_books(test_cases): Function to allocate books across multiple test cases. :param test_cases: List of tuples, each containing N (number of books), K (number of students), and a list of N integers (pages in each book). :return: List of integers representing the minimum possible value for the maximum number of pages a student has to read for each test case. from solution import is_possible, find_minimum_max_pages, allocate_books def test_is_possible(): assert is_possible([10, 20, 30, 40], 4, 2, 60) == True assert is_possible([10, 20, 30, 40], 4, 2, 50) == False assert is_possible([10, 20, 30, 40], 4, 3, 40) == True assert is_possible([5, 10, 20, 30, 40], 5, 3, 40) == True def test_find_minimum_max_pages(): assert find_minimum_max_pages([10, 20, 30, 40], 4, 2) == 60 assert find_minimum_max_pages([5, 10, 20, 30, 40], 5, 3) == 40 assert find_minimum_max_pages([10, 20, 30], 3, 2) == 30 assert find_minimum_max_pages([12, 34, 67, 90], 4, 2) == 113 def test_allocate_books(): test_cases = [ (4, 2, [10, 20, 30, 40]), (5, 3, [5, 10, 20, 30, 40]), (3, 2, [10, 20, 30]), (4, 2, [12, 34, 67, 90]) ] expected_results = [60, 40, 30, 113] assert allocate_books(test_cases) == expected_results test_is_possible() test_find_minimum_max_pages() test_allocate_books()","solution":"def is_possible(books, n, k, max_pages): student_count = 1 current_pages = 0 for pages in books: if current_pages + pages > max_pages: student_count += 1 current_pages = pages if student_count > k: return False else: current_pages += pages return True def find_minimum_max_pages(books, n, k): if k > n: return -1 low = max(books) high = sum(books) result = high while low <= high: mid = (low + high) // 2 if is_possible(books, n, k, mid): result = mid high = mid - 1 else: low = mid + 1 return result def allocate_books(test_cases): results = [] for test in test_cases: n, k, books = test result = find_minimum_max_pages(books, n, k) results.append(result) return results"},{"question":"def filter_words(words: List[str], constraints: List[str]) -> List[str]: Implement a function that given a list of words and a set of constraints, filters out words that do not meet the conditions. The function should take two inputs - a list of words, and a dictionary of constraints. The constraints specify certain conditions a word must satisfy to be included in the output list. The constraints may include: - Minimum length - Maximum length - Must contain certain letters (in any order) - Must start with a particular letter - Must end with a particular letter If none of the constraints are provided, the function should return the original list of words. Unit Test: >>> test_no_constraints() >>> test_min_length() >>> test_max_length() >>> test_must_contain() >>> test_start_with() >>> test_end_with() >>> test_multiple_constraints() def test_no_constraints(): words = [\\"apple\\", \\"banana\\", \\"grape\\", \\"kiwi\\", \\"orange\\"] constraints = [] assert filter_words(words, constraints) == [\\"apple\\", \\"banana\\", \\"grape\\", \\"kiwi\\", \\"orange\\"] def test_min_length(): words = [\\"apple\\", \\"banana\\", \\"grape\\", \\"kiwi\\", \\"orange\\"] constraints = [\\"min_length 5\\"] assert filter_words(words, constraints) == [\\"apple\\", \\"banana\\", \\"grape\\", \\"orange\\"] def test_max_length(): words = [\\"apple\\", \\"banana\\", \\"grape\\", \\"kiwi\\", \\"orange\\"] constraints = [\\"max_length 5\\"] assert filter_words(words, constraints) == [\\"apple\\", \\"grape\\", \\"kiwi\\"] def test_must_contain(): words = [\\"apple\\", \\"banana\\", \\"grape\\", \\"kiwi\\", \\"orange\\"] constraints = [\\"must_contain p\\"] assert filter_words(words, constraints) == [\\"apple\\", \\"grape\\"] def test_start_with(): words = [\\"apple\\", \\"banana\\", \\"grape\\", \\"kiwi\\", \\"orange\\"] constraints = [\\"start_with b\\"] assert filter_words(words, constraints) == [\\"banana\\"] def test_end_with(): words = [\\"apple\\", \\"banana\\", \\"grape\\", \\"kiwi\\", \\"orange\\"] constraints = [\\"end_with e\\"] assert filter_words(words, constraints) == [\\"apple\\", \\"grape\\", \\"orange\\"] def test_multiple_constraints(): words = [\\"apple\\", \\"banana\\", \\"grape\\", \\"kiwi\\", \\"orange\\"] constraints = [\\"min_length 5\\", \\"start_with b\\", \\"must_contain a\\"] assert filter_words(words, constraints) == [\\"banana\\"]","solution":"def filter_words(words, constraints): filtered_words = words for constraint in constraints: parts = constraint.split() if parts[0] == \\"min_length\\": min_length = int(parts[1]) filtered_words = [word for word in filtered_words if len(word) >= min_length] elif parts[0] == \\"max_length\\": max_length = int(parts[1]) filtered_words = [word for word in filtered_words if len(word) <= max_length] elif parts[0] == \\"must_contain\\": required_letters = parts[1] filtered_words = [word for word in filtered_words if all(letter in word for letter in required_letters)] elif parts[0] == \\"start_with\\": start_letter = parts[1] filtered_words = [word for word in filtered_words if word.startswith(start_letter)] elif parts[0] == \\"end_with\\": end_letter = parts[1] filtered_words = [word for word in filtered_words if word.endswith(end_letter)] return filtered_words"},{"question":"def min_height_difference(n: int, heights: list) -> int: Calculates the minimum difference between the original total height and the total height after making all towers have equal height. Args: - n: int, number of towers. - heights: list of int, heights of towers. Returns: - int, minimum difference between original and final total height. Examples: >>> min_height_difference(4, [1, 2, 3, 4]) 0 >>> min_height_difference(3, [2, 5, 8]) 6 >>> min_height_difference(5, [10, 1, 10, 1, 10]) 27 # Your code here","solution":"def min_height_difference(n, heights): Calculates the minimum difference between the original total height and the total height after making all towers have equal height. Args: - n: int, number of towers. - heights: list of int, heights of towers. Returns: - int, minimum difference between original and final total height. return 0"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Returns the largest rectangular area in the skyline represented by heights. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3, 1]) 10 >>> largest_rectangle_area([4, 4, 4, 4]) 16 >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12 >>> largest_rectangle_area([1]) 1 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9 >>> largest_rectangle_area([2, 1, 2, 3, 1, 4]) 6 >>> largest_rectangle_area([2, 1, 2, 3, 2, 4]) 8 # Implementation goes here","solution":"def largest_rectangle_area(heights): Returns the largest rectangular area in the skyline represented by heights. n = len(heights) stack = [] # stack to store indices max_area = 0 # Initialize max area index = 0 while index < n: # If this bar is higher than the bar at stack top, push it to the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the smallest (or minimum height) bar 'h' area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max area, if needed max_area = max(max_area, area) # Now pop the remaining bars from stack and calculate area while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def most_frequent_bird(T: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Determines the most frequently sighted bird ID for each test case. If two or more species have the same highest frequency, returns the smallest ID among them. >>> most_frequent_bird(2, [(6, [1, 1, 2, 2, 3, 3]), (5, [2, 2, 1, 1, 3])]) [1, 1] >>> most_frequent_bird(1, [(5, [5, 5, 5, 5, 5])]) [5] >>> most_frequent_bird(1, [(7, [1, 1, 1, 2, 2, 3, 3])]) [1] >>> most_frequent_bird(1, [(1, [1])]) [1] from solution import most_frequent_bird def test_single_case_multiple_birds(): assert most_frequent_bird(1, [(6, [1, 1, 2, 2, 3, 3])]) == [1] def test_single_case_tie(): assert most_frequent_bird(1, [(5, [2, 2, 1, 1, 3])]) == [1] def test_multiple_cases(): assert most_frequent_bird(2, [(6, [1, 1, 2, 2, 3, 3]), (5, [2, 2, 1, 1, 3])]) == [1, 1] def test_single_case_single_bird(): assert most_frequent_bird(1, [(1, [1])]) == [1] def test_single_case_different_frequencies(): assert most_frequent_bird(1, [(7, [1, 1, 1, 2, 2, 3, 3])]) == [1] def test_single_case_all_same(): assert most_frequent_bird(1, [(5, [5, 5, 5, 5, 5])]) == [5]","solution":"def most_frequent_bird(T, cases): Determines the most frequently sighted bird ID. If two or more species have the same highest frequency, returns the smallest ID among them. Parameters: T (int): number of test cases cases (list): list of tuples containing number of bird sightings and list of sightings for each case. Returns: list: a list of most frequent bird ID for each case results = [] for case in cases: N, sightings = case bird_count = {} for bird in sightings: if bird in bird_count: bird_count[bird] += 1 else: bird_count[bird] = 1 # Find the bird with maximum frequency most_frequent = min([k for k, v in bird_count.items() if v == max(bird_count.values())]) results.append(most_frequent) return results"},{"question":"def can_achieve_target_xp(n: int, t: int, xp_list: List[int]) -> str: Determines if there is a contiguous subarray of quests' XP that sums to at least t. Args: n (int): Number of quests. t (int): Target amount of XP. xp_list (list of int): XP gained from completing each quest. Returns: str: \\"YES\\" if there is a contiguous subarray with sum at least t, otherwise \\"NO\\". >>> can_achieve_target_xp(5, 15, [3, 1, 2, 7, 9]) == \\"YES\\" >>> can_achieve_target_xp(4, 20, [3, 5, 2, 9]) == \\"NO\\"","solution":"def can_achieve_target_xp(n, t, xp_list): Determines if there is a contiguous subarray of quests' XP that sums to at least t. Args: n (int): Number of quests. t (int): Target amount of XP. xp_list (list of int): XP gained from completing each quest. Returns: str: \\"YES\\" if there is a contiguous subarray with sum at least t, otherwise \\"NO\\". current_sum = 0 start = 0 for end in range(n): current_sum += xp_list[end] while current_sum >= t: return \\"YES\\" while current_sum > t and start <= end: current_sum -= xp_list[start] start += 1 return \\"NO\\""},{"question":"def update_feed(N: int, initial_likes: List[int], M: int, operations: List[Tuple[int, int]]) -> List[int]: Process a series of like operations and return the final state of the social media feed. Parameters: N (int): Number of posts initial_likes (List[int]): Initial like counts of the posts M (int): Number of operations operations (List[Tuple[int, int]]): List of operations, where each operation is a tuple containing index and number of likes Returns: List[int]: Final like counts after processing all operations Examples: >>> update_feed(3, [5, 3, 7], 2, [(1, 5), (3, 2)]) [10, 3, 9] >>> update_feed(4, [1, 2, 3, 4], 3, [(2, 3), (4, 1), (1, 10)]) [11, 5, 3, 5]","solution":"def update_feed(N, initial_likes, M, operations): for idx, likes in operations: initial_likes[idx - 1] += likes return initial_likes def process_input(): N = int(input()) initial_likes = list(map(int, input().split())) M = int(input()) operations = [tuple(map(int, input().split())) for _ in range(M)] updated_likes = update_feed(N, initial_likes, M, operations) print(' '.join(map(str, updated_likes)))"},{"question":"def total_cost_of_mst(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Find the total cost of the Minimum Spanning Tree (MST) of the village's road network. Arguments: n -- number of houses m -- number of roads roads -- list of tuples representing the roads, where each tuple contains three integers a, b, w: a and b are the houses connected by the road, and w is the cost to travel that road Output: Returns the total cost of the MST. Example: >>> total_cost_of_mst(4, 5, [(1, 2, 3), (1, 3, 1), (2, 3, 3), (2, 4, 6), (3, 4, 2)]) 6 >>> total_cost_of_mst(2, 1, [(1, 2, 10)]) 10 >>> total_cost_of_mst(3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 2)]) 2 >>> total_cost_of_mst(4, 6, [(1, 2, 5), (1, 3, 10), (1, 4, 100), (2, 3, 50), (2, 4, 10), (3, 4, 1)]) 16 >>> total_cost_of_mst(1, 0, []) 0","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def kruskal_mst(n, roads): roads.sort(key=lambda x: x[2]) parent = [i for i in range(n + 1)] rank = [0] * (n + 1) mst_weight = 0 edges_used = 0 for road in roads: u, v, w = road root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: mst_weight += w union(parent, rank, root_u, root_v) edges_used += 1 if edges_used == n - 1: break return mst_weight def total_cost_of_mst(n, m, roads): return kruskal_mst(n, roads)"},{"question":"from typing import List def longest_common_subsequence(A: List[int], B: List[int]) -> int: Given two sorted lists A and B each containing n unique integers, find the length of the longest common subsequence (LCS) between them. >>> longest_common_subsequence([1, 3, 4, 9, 10], [1, 4, 9, 10]) 4 >>> longest_common_subsequence([1, 2, 3], [2, 3, 4]) 2 >>> longest_common_subsequence([10, 20, 30, 40], [15, 20, 35, 40]) 2","solution":"def longest_common_subsequence(A, B): Returns the length of the longest common subsequence between two lists A and B. n = len(A) m = len(B) # Create a dp table with (n+1)x(m+1) dimensions initialized to 0 dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill the dp table for i in range(1, n + 1): for j in range(1, m + 1): if A[i-1] == B[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i][j-1], dp[i-1][j]) # The length of the longest common subsequence will be in dp[n][m] return dp[n][m]"},{"question":"class DataStructure: Design a data structure that supports insertion, removal, and finding pairs of integers. Methods: insert(x: int, y: int) remove(x: int, y: int) find(x: int) -> List[Tuple[int, int]] process_commands(commands: List[str]) -> List[List[Tuple[int, int]]] >>> ds = DataStructure() >>> ds.insert(3, 4) >>> ds.insert(1, 2) >>> ds.insert(3, 5) >>> ds.find(3) [(3, 4), (3, 5)] >>> ds.remove(3, 4) >>> ds.find(3) [(3, 5)] >>> ds.remove(1, 2) >>> ds.find(1) [] >>> commands = [ ... \\"INSERT 3 4\\", ... \\"INSERT 1 2\\", ... \\"INSERT 3 5\\", ... \\"FIND 3\\", ... \\"REMOVE 3 4\\", ... \\"FIND 3\\", ... \\"REMOVE 1 2\\", ... \\"FIND 1\\", ... \\"END\\" ... ] >>> ds.process_commands(commands) [[(3, 4), (3, 5)], [(3, 5)], []] def __init__(self): pass def insert(self, x, y): pass def remove(self, x, y): pass def find(self, x): pass def process_commands(self, commands): pass","solution":"class DataStructure: def __init__(self): self.data = {} def insert(self, x, y): if x in self.data: self.data[x].add(y) else: self.data[x] = {y} def remove(self, x, y): if x in self.data and y in self.data[x]: self.data[x].remove(y) if not self.data[x]: # remove key if set is empty del self.data[x] def find(self, x): if x in self.data: result = [(x, y) for y in sorted(self.data[x])] return result return [] def process_commands(self, commands): results = [] for command in commands: parts = command.split() if parts[0] == \\"INSERT\\": self.insert(int(parts[1]), int(parts[2])) elif parts[0] == \\"REMOVE\\": self.remove(int(parts[1]), int(parts[2])) elif parts[0] == \\"FIND\\": results.append(self.find(int(parts[1]))) elif parts[0] == \\"END\\": break return results"},{"question":"from collections import defaultdict, deque def analyze_comments(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[Tuple[int, int]]: Analyzes user comments to determine the maximum depth of comments and the total number of comments. :param t: The number of test cases. :param test_cases: A list containing tuples for each test case. Each tuple contains an integer n and a list of n tuples representing comments. Each comment tuple contains two integers: id and parent_id. :return: A list of tuples. Each tuple contains two integers: the maximum depth of comments and the total number of comments for each test case. results = [] # Implementation here return results def process_input(input_str: str) -> List[Tuple[int, int]]: Parses the input string and processes it to extract the number of test cases and their respective details. :param input_str: Input string containing all test case details. :return: A list of results from the analyze_comments function. lines = input_str.strip().split(\\"n\\") t = int(lines[0]) index = 1 test_cases = [] # Implementation here return analyze_comments(t, test_cases) def format_output(output: List[Tuple[int, int]]) -> str: Converts the output into the specified format. :param output: List of tuples containing the maximum depth of comments and the total number of comments. :return: Formatted output string. return \\"n\\".join(f\\"{depth} {count}\\" for depth, count in output) def main(input_str: str) -> str: Main function to handle the input and produce the output. :param input_str: Input string containing all test case details. :return: Formatted output string. output = process_input(input_str) return format_output(output) # Unit test def test_analyze_comments(): input_str = \\"2n5n1 0n2 1n3 1n4 2n5 0n3n1 0n2 1n3 2n\\" expected_output = \\"3 5n3 3\\" assert main(input_str).strip() == expected_output input_str = \\"1n4n1 0n2 1n3 2n4 3n\\" expected_output = \\"4 4\\" assert main(input_str).strip() == expected_output input_str = \\"1n1n1 0n\\" expected_output = \\"1 1\\" assert main(input_str).strip() == expected_output input_str = \\"1n6n1 0n2 1n3 1n4 2n5 2n6 3n\\" expected_output = \\"3 6\\" assert main(input_str).strip() == expected_output input_str = \\"2n3n1 0n2 0n3 0n2n1 0n2 1n\\" expected_output = \\"1 3n2 2\\" assert main(input_str).strip() == expected_output","solution":"from collections import defaultdict, deque def analyze_comments(t, test_cases): results = [] for case in test_cases: n, comments = case comment_tree = defaultdict(list) root_comments = [] total_comments = n for comment in comments: id, parent_id = comment if parent_id == 0: root_comments.append(id) else: comment_tree[parent_id].append(id) def get_max_depth(root): queue = deque([(root, 1)]) max_depth = 0 while queue: current, depth = queue.popleft() max_depth = max(max_depth, depth) for child in comment_tree[current]: queue.append((child, depth + 1)) return max_depth max_depth = 0 for root in root_comments: max_depth = max(max_depth, get_max_depth(root)) results.append((max_depth, total_comments)) return results # Function to extract the input and pass it to the analyze_comments function def process_input(input_str): lines = input_str.strip().split(\\"n\\") t = int(lines[0]) index = 1 test_cases = [] for _ in range(t): n = int(lines[index]) comments = [] for i in range(n): id, parent_id = map(int, lines[index + 1 + i].split()) comments.append((id, parent_id)) index += n + 1 test_cases.append((n, comments)) return analyze_comments(t, test_cases) # Function to convert output list into the specified output format def format_output(output): return \\"n\\".join(f\\"{depth} {count}\\" for depth, count in output) # Main function def main(input_str): output = process_input(input_str) return format_output(output)"},{"question":"def count_swaps_to_sort(n: int, a: List[int]) -> int: Returns the number of swaps required to sort the array using the given procedure. >>> count_swaps_to_sort(5, [4, 3, 2, 1, 5]) 6 >>> count_swaps_to_sort(5, [1, 2, 3, 4, 5]) 0 >>> count_swaps_to_sort(4, [4, 3, 2, 1]) 6 >>> count_swaps_to_sort(1, [1]) 0 >>> count_swaps_to_sort(2, [2, 1]) 1 >>> count_swaps_to_sort(5, [1, 2, 3, 5, 4]) 1","solution":"def count_swaps_to_sort(n, a): Returns the number of swaps required to sort the array using the given procedure. swaps = 0 sorted_flag = False while not sorted_flag: sorted_flag = True for i in range(n - 1): if a[i] > a[i + 1]: # Swap the elements a[i], a[i + 1] = a[i + 1], a[i] swaps += 1 sorted_flag = False return swaps"},{"question":"def process_commands(commands: List[str]) -> List[Union[int, str]]: Process a sequence of commands to simulate stack operations. The available commands are: - \\"push x\\": Push the value x onto the stack. - \\"pop\\": Remove the top value from the stack and print it. If the stack is empty, output \\"EMPTY\\". - \\"inc k x\\": Increment the bottom k elements of the stack by x. >>> process_commands([\\"push 4\\", \\"push 3\\", \\"inc 2 1\\", \\"pop\\", \\"pop\\", \\"pop\\"]) [4, 5, \\"EMPTY\\"] >>> process_commands([\\"push 10\\", \\"push 20\\", \\"pop\\", \\"inc 1 5\\", \\"pop\\"]) [20, 15] >>> process_commands([\\"pop\\", \\"pop\\"]) [\\"EMPTY\\", \\"EMPTY\\"] >>> process_commands([\\"push 1\\", \\"pop\\"]) [1] >>> process_commands([\\"push 1\\", \\"push 2\\", \\"push 3\\", \\"inc 5 2\\", \\"pop\\", \\"pop\\", \\"pop\\"]) [5, 4, 3] >>> process_commands([\\"push 1\\", \\"push 2\\", \\"push 3\\", \\"inc 2 1\\", \\"pop\\", \\"pop\\", \\"pop\\"]) [3, 3, 2] pass","solution":"def process_commands(commands): stack = [] result = [] for command in commands: if command.startswith(\\"push\\"): _, x = command.split() stack.append(int(x)) elif command == \\"pop\\": if stack: result.append(stack.pop()) else: result.append(\\"EMPTY\\") elif command.startswith(\\"inc\\"): _, k, x = command.split() k = int(k) x = int(x) for i in range(min(k, len(stack))): stack[i] += x return result"},{"question":"from typing import List def solve_n_queens(n: int) -> List[List[str]]: Given the size of the board (n), this function will find the maximum number of queens that can be placed on the board following the condition that no two queens should be able to attack each other. >>> solve_n_queens(1) [['Q']] >>> solve_n_queens(4) [['.','.','Q','.'], ['Q','.','.','.'], ['.','.','.','Q'], ['.','Q','.','.']] or [['.','Q','.','.'], ['.','.','.','Q'], ['Q','.','.','.'], ['.','.','Q','.']] >>> solve_n_queens(8) List of 8 strings each containing one 'Q' and 7 '.'","solution":"def solve_n_queens(n): def is_safe(board, row, col): # Check this row on left side. for i in range(col): if board[row][i] == 'Q': return False # Check upper diagonal on left side. for i, j in zip(range(row, -1, -1), range(col, -1, -1)): if board[i][j] == 'Q': return False # Check lower diagonal on left side. for i, j in zip(range(row, n, 1), range(col, -1, -1)): if board[i][j] == 'Q': return False return True def solve_n_queens_util(board, col): if col >= n: return True for i in range(n): if is_safe(board, i, col): board[i][col] = 'Q' if solve_n_queens_util(board, col + 1): return True board[i][col] = '.' return False board = [['.' for _ in range(n)] for _ in range(n)] if solve_n_queens_util(board, 0): return board else: return [] def main(n): result = solve_n_queens(n) print(n) for row in result: print(''.join(row)) # Example usage. if __name__ == \\"__main__\\": main(4)"},{"question":"def is_prime_majority(n: int) -> str: Determines if the majority of room numbers from 1 to n are prime numbers. Args: n (int): The total number of rooms. Returns: str: \\"YES\\" if majority of the rooms are prime numbers, otherwise \\"NO\\". Examples: >>> is_prime_majority(10) 'NO' >>> is_prime_majority(20) 'NO'","solution":"def is_prime_majority(n): Determines if the majority of room numbers from 1 to n are prime numbers. Args: n (int): The total number of rooms. Returns: str: \\"YES\\" if majority of the rooms are prime numbers, otherwise \\"NO\\". if n < 2: return \\"NO\\" sieve = [True] * (n + 1) sieve[0] = sieve[1] = False for i in range(2, int(n**0.5) + 1): if sieve[i]: for j in range(i*i, n + 1, i): sieve[j] = False prime_count = sum(sieve) return \\"YES\\" if prime_count > n / 2 else \\"NO\\""},{"question":"def increment_number(digits): Increments the number represented by an array of digits by one. Returns the resulting number as an array of digits. >>> increment_number([1, 2, 3, 4]) [1, 2, 3, 5] >>> increment_number([9, 9, 9]) [1, 0, 0, 0] >>> increment_number([0]) [1] >>> increment_number([1, 0, 0, 8]) [1, 0, 0, 9] >>> increment_number([0, 0, 0, 0, 0]) [0, 0, 0, 0, 1] >>> increment_number([1, 8, 3, 4, 0, 9, 9]) [1, 8, 3, 4, 1, 0, 0]","solution":"def increment_number(digits): Increments the number represented by an array of digits by one. Returns the resulting number as an array of digits. n = len(digits) carry = 1 # We need to add one to the number for i in range(n-1, -1, -1): new_digit = digits[i] + carry if new_digit >= 10: digits[i] = new_digit % 10 carry = 1 else: digits[i] = new_digit carry = 0 break if carry: digits.insert(0, carry) return digits"},{"question":"def sum_even_or_odd(nums: List[int]) -> str: Determines if the sum of the integers in the list is even or odd. >>> sum_even_or_odd([1, 2, 3]) \\"even\\" >>> sum_even_or_odd([2, 5, 1, 10]) \\"even\\" >>> sum_even_or_odd([1, 1, 1, 1, 1]) \\"odd\\"","solution":"def sum_even_or_odd(nums): Determines if the sum of the integers in the list is even or odd. Parameters: nums (list): A list of integers. Returns: str: \\"even\\" if the sum is even, \\"odd\\" if the sum is odd. total_sum = sum(nums) return \\"even\\" if total_sum % 2 == 0 else \\"odd\\""},{"question":"def create_array_with_k_disorders(n, k): Returns an n-length array such that the array consists of integers from 1 to n (inclusive), and exactly k pairs of adjacent elements are not in increasing order. pass def process_input(t, cases): Processes multiple test cases and returns a list of results with each result being an n-length array consisting of integers from 1 to n with exactly k pairs of adjacent elements not in increasing order. pass # Unit Tests def test_create_array_with_k_disorders_no_disorder(): assert create_array_with_k_disorders(4, 0) == [1, 2, 3, 4] def test_create_array_with_k_disorders_one_disorder(): assert create_array_with_k_disorders(4, 1) == [2, 1, 3, 4] def test_create_array_with_k_disorders_multiple_disorders(): result = create_array_with_k_disorders(5, 2) assert result == [2, 1, 4, 3, 5] def test_process_input(): assert process_input(2, [(5, 2), (4, 0)]) == [ [2, 1, 4, 3, 5], [1, 2, 3, 4] ] def test_edge_cases(): assert create_array_with_k_disorders(1, 0) == [1] assert create_array_with_k_disorders(2, 1) == [2, 1] assert create_array_with_k_disorders(2, 0) == [1, 2]","solution":"def create_array_with_k_disorders(n, k): Returns an n-length array such that the array consists of integers from 1 to n (inclusive), and exactly k pairs of adjacent elements are not in increasing order. arr = list(range(1, n + 1)) # To create k pairs of adjacent elements that are not in increasing order for i in range(k): arr[2 * i], arr[2 * i + 1] = arr[2 * i + 1], arr[2 * i] return arr def process_input(t, cases): results = [] for n, k in cases: result = create_array_with_k_disorders(n, k) results.append(result) return results"},{"question":"def shortest_path(N: int, M: int, grid: List[str], start: Tuple[int, int], end: Tuple[int, int]) -> int: Determines the shortest path from start to end in a given N x M grid avoiding restricted cells. :param N: int, number of rows in the grid :param M: int, number of columns in the grid :param grid: list of str, representation of the city grid :param start: tuple of int, (r1, c1) - starting position (1-indexed) :param end: tuple of int, (r2, c2) - ending position (1-indexed) :return: int, length of the shortest path from start to end, or -1 if no such path exists >>> shortest_path(5, 5, [\\".....\\", \\".#.\\", \\".....\\", \\".#.\\", \\".....\\"], (1, 1), (5, 5)) 8 >>> shortest_path(5, 5, [\\".....\\", \\".#.\\", \\".....\\", \\"#\\", \\".....\\"], (1, 1), (5, 5)) -1 >>> shortest_path(5, 5, [\\".....\\", \\".#.\\", \\".....\\", \\".#.\\", \\".....\\"], (1, 1), (1, 1)) 0 >>> shortest_path(5, 5, [\\"..#..\\", \\".#.\\", \\".....\\", \\".#.\\", \\".....\\"], (1, 3), (5, 5)) -1 >>> shortest_path(5, 5, [\\".....\\", \\".#.\\", \\"....#\\", \\".#.\\", \\".....\\"], (1, 1), (3, 5)) -1","solution":"from collections import deque def shortest_path(N, M, grid, start, end): Determines the shortest path from start to end in a given N x M grid avoiding restricted cells. :param N: int, number of rows in the grid :param M: int, number of columns in the grid :param grid: list of str, representation of the city grid :param start: tuple of int, (r1, c1) - starting position (1-indexed) :param end: tuple of int, (r2, c2) - ending position (1-indexed) :return: int, length of the shortest path from start to end, or -1 if no such path exists r1, c1, r2, c2 = start[0]-1, start[1]-1, end[0]-1, end[1]-1 # convert to 0-indexed if grid[r1][c1] == '#' or grid[r2][c2] == '#': return -1 # start or end is in a restricted cell # Directions array for moving in 4 possible directions: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Queue for BFS queue = deque([(r1, c1, 0)]) # (row, col, distance) visited = set() visited.add((r1, c1)) while queue: x, y, dist = queue.popleft() if (x, y) == (r2, c2): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited and grid[nx][ny] == '.': queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1 # no path found"},{"question":"def max_score(n: int, m: int, tasks: List[Tuple[int, int]]) -> int: Determines the maximum score that can be achieved by completing at most m tasks. Parameters: - n: The total number of available tasks (int) - m: The maximum number of tasks a competitor can attempt (int) - tasks: A list of tuples, where each tuple contains two integers: - di: difficulty level of the i-th task (int) - pi: points awarded for completing the i-th task (int) Returns: - The maximum total points (int) >>> max_score(6, 3, [(4, 20), (3, 5), (1, 10), (5, 15), (2, 25), (3, 10)]) 60 >>> max_score(5, 2, [(1, 30), (2, 50), (3, 40), (4, 25), (5, 35)]) 90","solution":"def max_score(n, m, tasks): Determines the maximum score that can be achieved by completing at most m tasks. Parameters: - n: The total number of available tasks (int) - m: The maximum number of tasks a competitor can attempt (int) - tasks: A list of tuples, where each tuple contains two integers: - di: difficulty level of the i-th task (int) - pi: points awarded for completing the i-th task (int) Returns: - The maximum total points (int) # Sort tasks by points in descending order to maximize the score sorted_tasks = sorted(tasks, key=lambda x: x[1], reverse=True) # Select the top m tasks with the highest points max_points = sum(task[1] for task in sorted_tasks[:m]) return max_points"},{"question":"from typing import List, Tuple, Any def update_document(starting_document: str, operations: List[Tuple[str, Any]]) -> str: Applies a series of operations to a starting document and returns the final state of the document. Args: starting_document: str : The initial document string. operations: List[Tuple[str, Any]] : A list of operations to apply to the document. Returns: str: The final state of the document after applying all operations. pass def test_update_document_append(): starting_document = \\"hello\\" operations = [(\\"append\\", \\" world\\")] assert update_document(starting_document, operations) == \\"hello world\\" def test_update_document_delete(): starting_document = \\"hello world\\" operations = [(\\"delete\\", 6)] assert update_document(starting_document, operations) == \\"hello\\" def test_update_document_insert(): starting_document = \\"hello world\\" operations = [(\\"insert\\", 5, \\", bright\\")] assert update_document(starting_document, operations) == \\"hello, bright world\\" def test_update_document_combined_operations(): starting_document = \\"hello world\\" operations = [(\\"append\\", \\"!!!\\"), (\\"delete\\", 6), (\\"insert\\", 5, \\", bright\\")] assert update_document(starting_document, operations) == \\"hello, bright wo\\" def test_update_document_empty_initial(): starting_document = \\"\\" operations = [(\\"append\\", \\"hello\\"), (\\"insert\\", 5, \\" world\\"), (\\"delete\\", 6)] assert update_document(starting_document, operations) == \\"hello\\" def test_update_document_no_operations(): starting_document = \\"hello world\\" operations = [] assert update_document(starting_document, operations) == \\"hello world\\" def test_update_document_delete_more_than_length(): starting_document = \\"hello\\" operations = [(\\"delete\\", 10)] assert update_document(starting_document, operations) == \\"\\"","solution":"def update_document(starting_document, operations): Applies a series of operations to a starting document and returns the final state of the document. Args: starting_document: str : The initial document string. operations: List[Tuple[str, Any]] : A list of operations to apply to the document. Returns: str: The final state of the document after applying all operations. doc = starting_document for operation in operations: op_type = operation[0] if op_type == \\"append\\": doc += operation[1] elif op_type == \\"delete\\": n = operation[1] doc = doc[:-n] if n <= len(doc) else \\"\\" elif op_type == \\"insert\\": index, string_to_insert = operation[1], operation[2] doc = doc[:index] + string_to_insert + doc[index:] return doc"},{"question":"from collections import defaultdict, deque def longest_simple_path(n, edges): Determine the length of the longest simple path in a weighted, undirected tree. Args: n: int - the number of vertices in the tree. edges: List[Tuple[int, int, int]] - the list of edges where each edge is represented as a tuple (u, v, w). Returns: int - the length of the longest simple path in the tree. Example: >>> longest_simple_path(5, [(1, 2, 3), (1, 3, 4), (2, 4, 2), (3, 5, 1)]) 10 >>> longest_simple_path(3, [(1, 2, 2), (2, 3, 3)]) 5 import pytest from solution import longest_simple_path def test_example_1(): n = 5 edges = [(1, 2, 3), (1, 3, 4), (2, 4, 2), (3, 5, 1)] assert longest_simple_path(n, edges) == 10 def test_example_2(): n = 3 edges = [(1, 2, 2), (2, 3, 3)] assert longest_simple_path(n, edges) == 5 def test_linear_tree(): n = 4 edges = [(1, 2, 1), (2, 3, 1), (3, 4, 1)] assert longest_simple_path(n, edges) == 3 def test_small_tree(): n = 2 edges = [(1, 2, 1)] assert longest_simple_path(n, edges) == 1 def test_balanced_tree(): n = 7 edges = [(1, 2, 1), (1, 3, 1), (2, 4, 1), (2, 5, 1), (3, 6, 1), (3, 7, 1)] assert longest_simple_path(n, edges) == 4","solution":"from collections import defaultdict, deque def longest_simple_path(n, edges): def bfs(start_node): queue = deque([(start_node, 0)]) visited = [-1] * n visited[start_node] = 0 max_distance = 0 farthest_node = start_node while queue: current_node, current_distance = queue.popleft() for neighbor, weight in tree[current_node]: if visited[neighbor] == -1: distance = current_distance + weight visited[neighbor] = distance queue.append((neighbor, distance)) if distance > max_distance: max_distance, farthest_node = distance, neighbor return farthest_node, max_distance tree = defaultdict(list) for u, v, w in edges: tree[u-1].append((v-1, w)) tree[v-1].append((u-1, w)) node, _ = bfs(0) _, longest_distance = bfs(node) return longest_distance # Example usage: # edges = [(1, 2, 3), (1, 3, 4), (2, 4, 2), (3, 5, 1)] # n = 5 # print(longest_simple_path(n, edges)) # Output: 10"},{"question":"def rotate_matrix_by_90(matrix: List[List[int]]) -> List[List[int]]: Rotate an NxN matrix clockwise by 90 degrees. >>> rotate_matrix_by_90([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]] >>> rotate_matrix_by_90([[3, 2, 1], [6, 5, 4], [9, 8, 7]]) [[9, 6, 3], [8, 5, 2], [7, 4, 1]] def process_input(data: str) -> List[List[List[int]]]: Process the input to extract datasets and perform rotation. >>> process_input(\\"4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 0\\") [[[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]]] >>> process_input(\\"3 3 2 1 6 5 4 9 8 7 0\\") [[[9, 6, 3], [8, 5, 2], [7, 4, 1]]] def format_output(results: List[List[List[int]]]) -> str: Format the output string from the rotated matrices. >>> format_output([[[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]], [[9, 6, 3], [8, 5, 2], [7, 4, 1]]]) '13 9 5 1n14 10 6 2n15 11 7 3n16 12 8 4nn9 6 3n8 5 2n7 4 1'","solution":"def rotate_matrix_by_90(matrix): N = len(matrix) # This will create a new NxN matrix which is the rotated version of the input matrix rotated_matrix = [[None] * N for _ in range(N)] for i in range(N): for j in range(N): rotated_matrix[j][N-1-i] = matrix[i][j] return rotated_matrix def process_input(data): # Split and convert input data to a list of integers data = list(map(int, data.split())) results = [] index = 0 while index < len(data): N = data[index] if N == 0: break # Extract the NxN matrix index += 1 matrix = [] for _ in range(N): matrix.append(data[index:index + N]) index += N # Rotate the matrix by 90 degrees rotated_matrix = rotate_matrix_by_90(matrix) results.append(rotated_matrix) return results def format_output(results): output_str = \\"\\" for matrix in results: for row in matrix: output_str += \\" \\".join(map(str, row)) + \\"n\\" output_str += \\"n\\" return output_str.strip()"},{"question":"def can_convert_with_one_operation(S: str, T: str) -> str: Determines if string S can be converted into string T by performing exactly one operation. >>> can_convert_with_one_operation(\\"abc\\", \\"abd\\") \\"YES\\" >>> can_convert_with_one_operation(\\"hello\\", \\"hellp\\") \\"YES\\" >>> can_convert_with_one_operation(\\"world\\", \\"words\\") \\"NO\\" >>> can_convert_with_one_operation(\\"coding\\", \\"coding\\") \\"NO\\" def solve(test_cases: List[Tuple[str, str]]) -> List[str]: Processes multiple test cases. >>> solve([(\\"abc\\", \\"abd\\"), (\\"hello\\", \\"hellp\\"), (\\"world\\", \\"words\\"), (\\"coding\\", \\"coding\\")]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\"] >>> solve([(\\"a\\", \\"b\\"), (\\"aaa\\", \\"aab\\"), (\\"test\\", \\"tost\\"), (\\"same\\", \\"same\\")]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def can_convert_with_one_operation(S, T): Determines if string S can be converted into string T by performing exactly one operation. if len(S) != len(T): return \\"NO\\" count_diff = 0 for s, t in zip(S, T): if s != t: count_diff += 1 return \\"YES\\" if count_diff == 1 else \\"NO\\" def solve(test_cases): Processes multiple test cases. results = [] for S, T in test_cases: results.append(can_convert_with_one_operation(S, T)) return results"},{"question":"def collect_tokens(M: int, N: int, grid: List[List[int]], moves: str) -> int: Returns the number of tokens collected based on the sequence of moves. Args: - M: number of rows in the grid. - N: number of columns in the grid. - grid: 2D list representing the grid where 1 represents a token and 0 represents an empty cell. - moves: string consisting of the characters 'U', 'D', 'L', 'R' representing the sequence of moves. Returns: - Integer representing the total number of tokens collected.","solution":"def collect_tokens(M, N, grid, moves): Returns the number of tokens collected based on the sequence of moves. Args: - M: number of rows in the grid. - N: number of columns in the grid. - grid: 2D list representing the grid where 1 represents a token and 0 represents an empty cell. - moves: string consisting of the characters 'U', 'D', 'L', 'R' representing the sequence of moves. Returns: - Integer representing the total number of tokens collected. # Starting position x, y = 0, 0 # Set to keep track of visited cells visited = set() visited.add((x, y)) # Initial tokens count tokens_collected = grid[x][y] # Directions mapping directions = { 'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1) } for move in moves: dx, dy = directions[move] new_x, new_y = x + dx, y + dy # Ensure the new position is within grid bounds if 0 <= new_x < M and 0 <= new_y < N: x, y = new_x, new_y if (x, y) not in visited: tokens_collected += grid[x][y] visited.add((x, y)) return tokens_collected"},{"question":"def find_pairs(n: int, arr: List[int]) -> Union[str, Tuple[int, int, int, int]]: You have an array of n positive integers. You want to find a pair (i, j) and (k, l) (1 ≤ i < j, k < l ≤ n, i ≠ k, j ≠ l) such that the sum of a[i] + a[j] is equal to the sum of a[k] + a[l]. If multiple such pairs exist, return any one pair of pairs. If no such pairs exist, return \\"NO\\". Input: - n: integer, size of the array (4 ≤ n ≤ 1000) - arr: list of n positive integers (1 ≤ ai ≤ 100000) Output: - If such pairs exist, output four integers i, j, k, l (1 ≤ i < j, k < l ≤ n, i ≠ k, j ≠ l). - If no such pairs exist, output \\"NO\\". Examples: >>> find_pairs(5, [1, 2, 3, 4, 5]) (1, 4, 2, 3) >>> find_pairs(4, [2, 2, 2, 2]) (1, 2, 3, 4) pass from solution import find_pairs def test_example_case_1(): assert find_pairs(5, [1, 2, 3, 4, 5]) == (1, 4, 2, 3) or find_pairs(5, [1, 2, 3, 4, 5]) == (2, 3, 1, 4) def test_example_case_2(): assert find_pairs(4, [2, 2, 2, 2]) == (1, 2, 3, 4) or find_pairs(4, [2, 2, 2, 2]) == (1, 3, 2, 4) def test_no_pairs(): assert find_pairs(4, [1, 2, 3, 10]) == \\"NO\\" def test_multiple_pairs(): result = find_pairs(6, [1, 2, 3, 6, 5, 4]) valid_outputs = [ (1, 6, 2, 3), (1, 6, 4, 5), (2, 3, 1, 6), (2, 3, 4, 5), (4, 5, 1, 6), (4, 5, 2, 3) ] assert result in valid_outputs def test_case_with_duplicate_elements(): result = find_pairs(6, [2, 2, 2, 2, 2, 2]) valid_outputs = [ (1, 2, 3, 4), (1, 2, 3, 5), (1, 2, 3, 6), (1, 3, 2, 4), (1, 3, 2, 5), (1, 3, 2, 6), (1, 4, 2, 3), (1, 4, 2, 5), (1, 4, 2, 6), (1, 5, 2, 3), (1, 5, 2, 4), (1, 5, 2, 6), (1, 6, 2, 3), (1, 6, 2, 4), (1, 6, 2, 5) ] assert result in valid_outputs def test_large_case(): n = 1000 arr = list(range(1, 1001)) result = find_pairs(n, arr) assert result is not \\"NO\\"","solution":"def find_pairs(n, arr): sums_dict = {} for i in range(n): for j in range(i + 1, n): pair_sum = arr[i] + arr[j] if pair_sum in sums_dict: prev_i, prev_j = sums_dict[pair_sum] if prev_i != i and prev_i != j and prev_j != i and prev_j != j: return prev_i + 1, prev_j + 1, i + 1, j + 1 else: sums_dict[pair_sum] = (i, j) return \\"NO\\""},{"question":"class DisplayBoard: def __init__(self): self.grid = [[' ' for _ in range(20)] for _ in range(10)] def insert(self, r, c, text): r -= 1 c -= 1 for i in range(min(len(text), 20 - c)): self.grid[r][c + i] = text[i] def delete(self, r, c, length): r -= 1 c -= 1 for i in range(min(length, 20 - c)): self.grid[r][c + i] = ' ' def move(self, sr, sc, dr, dc, length): sr -= 1 sc -= 1 dr -= 1 dc -= 1 temp = [] for i in range(min(length, 20 - sc)): temp.append(self.grid[sr][sc + i]) self.grid[sr][sc + i] = ' ' for i in range(min(len(temp), 20 - dc)): self.grid[dr][dc + i] = temp[i] def print_grid(self): for row in self.grid: print(''.join(row)) def process_commands(commands): Process a list of commands to manipulate a display grid. Args: commands (list): A list of command strings. Example: >>> commands = [\\"INSERT 1 1 HELLO\\", \\"INSERT 2 5 WORLD\\", \\"INSERT 4 8 !\\", \\"DELETE 1 2 3\\", \\"MOVE 2 5 3 10 5\\", \\"PRINT\\", \\"-\\"] >>> process_commands(commands) H L O D D ! board = DisplayBoard() for command in commands: parts = command.split(' ') if parts[0] == 'INSERT': r, c, text = int(parts[1]), int(parts[2]), ' '.join(parts[3:]) board.insert(r, c, text) elif parts[0] == 'DELETE': r, c, length = int(parts[1]), int(parts[2]), int(parts[3]) board.delete(r, c, length) elif parts[0] == 'MOVE': sr, sc, dr, dc, length = map(int, parts[1:6]) board.move(sr, sc, dr, dc, length) elif parts[0] == 'PRINT': board.print_grid() from solution import process_commands def test_example_scenario(): commands = [ \\"INSERT 1 1 HELLO\\", \\"INSERT 2 5 WORLD\\", \\"INSERT 4 8 !\\", \\"DELETE 1 2 3\\", \\"MOVE 2 5 3 10 5\\", \\"PRINT\\", \\"-\\" ] process_commands(commands) def test_insert_beyond_edge(): commands = [ \\"INSERT 1 18 ABCD\\", \\"PRINT\\", \\"-\\" ] process_commands(commands) def test_delete_beyond_edge(): commands = [ \\"INSERT 1 18 ABCD\\", \\"DELETE 1 19 4\\", \\"PRINT\\", \\"-\\" ] process_commands(commands) def test_move_within_limits(): commands = [ \\"INSERT 1 1 EXAMPLE\\", \\"MOVE 1 1 2 5 7\\", \\"PRINT\\", \\"-\\" ] process_commands(commands) def test_move_truncate(): commands = [ \\"INSERT 1 1 TOOLONGTEXTFORGRID\\", \\"MOVE 1 1 3 5 20\\", \\"PRINT\\", \\"-\\" ] process_commands(commands)","solution":"class DisplayBoard: def __init__(self): self.grid = [[' ' for _ in range(20)] for _ in range(10)] def insert(self, r, c, text): r -= 1 c -= 1 for i in range(min(len(text), 20 - c)): self.grid[r][c + i] = text[i] def delete(self, r, c, length): r -= 1 c -= 1 for i in range(min(length, 20 - c)): self.grid[r][c + i] = ' ' def move(self, sr, sc, dr, dc, length): sr -= 1 sc -= 1 dr -= 1 dc -= 1 temp = [] for i in range(min(length, 20 - sc)): temp.append(self.grid[sr][sc + i]) self.grid[sr][sc + i] = ' ' for i in range(min(len(temp), 20 - dc)): self.grid[dr][dc + i] = temp[i] def print_grid(self): for row in self.grid: print(''.join(row)) def process_commands(commands): board = DisplayBoard() for command in commands: parts = command.split(' ') if parts[0] == 'INSERT': r, c, text = int(parts[1]), int(parts[2]), ' '.join(parts[3:]) board.insert(r, c, text) elif parts[0] == 'DELETE': r, c, length = int(parts[1]), int(parts[2]), int(parts[3]) board.delete(r, c, length) elif parts[0] == 'MOVE': sr, sc, dr, dc, length = map(int, parts[1:6]) board.move(sr, sc, dr, dc, length) elif parts[0] == 'PRINT': board.print_grid()"},{"question":"def find_pairs(nums, target): Given a list of distinct integers and a target sum, find all unique pairs of integers in the list that add up to the target. The pairs should be sorted in non-decreasing order and the output should be a list containing all unique pairs sorted lexicographically. Args: nums: List of distinct integers. target: Integer target sum. Returns: A list of tuples representing the unique pairs sorted lexicographically. >>> find_pairs([1, 5, 3, 7, 9], 8) [(1, 7), (3, 5)] >>> find_pairs([2, 4, 6, 3], 10) [(4, 6)] >>> find_pairs([1, 2, 3, 4], 8) []","solution":"def find_pairs(nums, target): Given a list of distinct integers and a target sum, find all unique pairs of integers in the list that add up to the target. Args: nums: List of distinct integers. target: Integer target sum. Returns: A list of tuples representing the unique pairs sorted lexicographically. pairs = [] nums_set = set(nums) for num in nums: complement = target - num if complement in nums_set and complement != num: pair = tuple(sorted((num, complement))) if pair not in pairs: pairs.append(pair) return sorted(pairs)"},{"question":"class BookDatabase: def __init__(self): Initialize the book database self.books = [] def add_book(self, title: str, author: str, genre: str, year: int): Add a new book to the database. - title: Title of the book - author: Author of the book - genre: Genre of the book - year: Year of publication pass def remove_book(self, title: str): Remove a book from the database by its title. - title: Title of the book to be removed pass def list_books(self, attribute: str = None, value: str = None): List all the books that match a given attribute-value filter. - attribute: Attribute to filter on ('title', 'author', 'genre', 'year') - value: Value of the attribute to match pass def process_commands(commands: List[str]) -> List[str]: Process a list of commands to interact with the book database. - commands: List of commands to process Returns a list of strings representing the output of LIST commands. pass from typing import List def test_process_commands(): commands = [ \\"ADD TheGreatGatsby FScottFitzgerald Fiction 1925\\", \\"ADD MobyDick HermanMelville Fiction 1851\\", \\"LIST\\", \\"REMOVE MobyDick\\", \\"ADD ToKillAMockingbird HarperLee Fiction 1960\\", \\"LIST genre Fiction\\", \\"END\\" ] output = process_commands(commands) expected_output = [ \\"TheGreatGatsby FScottFitzgerald Fiction 1925\\", \\"MobyDick HermanMelville Fiction 1851\\", \\"TheGreatGatsby FScottFitzgerald Fiction 1925\\", \\"ToKillAMockingbird HarperLee Fiction 1960\\" ] assert output == expected_output def test_add_book(): db = BookDatabase() db.add_book(\\"TheGreatGatsby\\", \\"FScottFitzgerald\\", \\"Fiction\\", 1925) assert len(db.books) == 1 db.add_book(\\"TheGreatGatsby\\", \\"FScottFitzgerald\\", \\"Fiction\\", 1925) assert len(db.books) == 1 # duplicate title should not be added def test_remove_book(): db = BookDatabase() db.add_book(\\"TheGreatGatsby\\", \\"FScottFitzgerald\\", \\"Fiction\\", 1925) db.remove_book(\\"TheGreatGatsby\\") assert len(db.books) == 0 def test_list_books(): db = BookDatabase() db.add_book(\\"TheGreatGatsby\\", \\"FScottFitzgerald\\", \\"Fiction\\", 1925) db.add_book(\\"MobyDick\\", \\"HermanMelville\\", \\"Fiction\\", 1851) db.add_book(\\"Sapiens\\", \\"YuvalNoahHarari\\", \\"NonFiction\\", 2014) all_books = db.list_books() assert len(all_books) == 3 fiction_books = db.list_books(attribute=\\"genre\\", value=\\"Fiction\\") assert len(fiction_books) == 2 no_book = db.list_books(attribute=\\"year\\", value=\\"2000\\") assert len(no_book) == 0","solution":"class BookDatabase: def __init__(self): self.books = [] def add_book(self, title, author, genre, year): if not any(book['title'] == title for book in self.books): self.books.append({ 'title': title, 'author': author, 'genre': genre, 'year': year }) def remove_book(self, title): self.books = [book for book in self.books if book['title'] != title] def list_books(self, attribute=None, value=None): if not attribute: return self.books return [book for book in self.books if str(book[attribute]) == value] def process_commands(commands): db = BookDatabase() results = [] for command in commands: parts = command.split() if parts[0] == \\"ADD\\": db.add_book(parts[1], parts[2], parts[3], int(parts[4])) elif parts[0] == \\"REMOVE\\": db.remove_book(parts[1]) elif parts[0] == \\"LIST\\": if len(parts) > 1: listed_books = db.list_books(parts[1], parts[2]) else: listed_books = db.list_books() for book in listed_books: results.append(f\\"{book['title']} {book['author']} {book['genre']} {book['year']}\\") return results commands = [ \\"ADD TheGreatGatsby FScottFitzgerald Fiction 1925\\", \\"ADD MobyDick HermanMelville Fiction 1851\\", \\"LIST\\", \\"REMOVE MobyDick\\", \\"ADD ToKillAMockingbird HarperLee Fiction 1960\\", \\"LIST genre Fiction\\", \\"END\\" ] print(\\"n\\".join(process_commands(commands)))"},{"question":"def length_of_lis(arr: List[int]) -> int: Returns the length of the longest strictly increasing subsequence in the array. >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([0, 1, 0, 3, 2, 3]) 4 >>> length_of_lis([7, 7, 7, 7, 7, 7, 7]) 1 pass def test_example1(): assert length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) == 4 def test_example2(): assert length_of_lis([0, 1, 0, 3, 2, 3]) == 4 def test_example3(): assert length_of_lis([7, 7, 7, 7, 7, 7, 7]) == 1 def test_with_negative_numbers(): assert length_of_lis([-1, 0, 1, 2, -1, -2]) == 4 def test_single_element(): assert length_of_lis([10]) == 1 def test_empty_array(): assert length_of_lis([]) == 0 def test_decreasing_sequence(): assert length_of_lis([5, 4, 3, 2, 1]) == 1 def test_constant_sequence(): assert length_of_lis([3, 3, 3, 3, 3]) == 1 def test_long_increasing_sequence(): assert length_of_lis(list(range(1000))) == 1000","solution":"def length_of_lis(arr): Returns the length of the longest strictly increasing subsequence in the array. if not arr: return 0 dp = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"from typing import List def min_moves_to_reach_end(M: int, N: int, grid: List[List[int]]) -> int: Given a rectangular grid and a robot starting at the top-left corner, finds the minimum number of moves required to reach the bottom-right corner or returns -1 if it's not possible. :param M: Number of rows in the grid :param N: Number of columns in the grid :param grid: The grid itself :return: Minimum number of moves or -1 if there is no path >>> min_moves_to_reach_end(3, 4, [[0, 0, 0, 1], [1, 0, 0, 0], [1, 1, 0, 0]]) == 5 >>> min_moves_to_reach_end(4, 4, [[0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0], [1, 0, 0, 0]]) == 6 >>> min_moves_to_reach_end(3, 3, [[0, 1, 0], [1, 1, 1], [0, 0, 0]]) == -1 >>> min_moves_to_reach_end(2, 2, [[0, 1], [0, 0]]) == 2 pass def parse_input(data: str): Parses the input string and returns M, N, and the grid as a list of lists. :param data: Input string :return: Tuple of integers M, N and the grid >>> parse_input(\\"3 4n0 0 0 1n1 0 0 0n1 1 0 0\\") == (3, 4, [[0, 0, 0, 1], [1, 0, 0, 0], [1, 1, 0, 0]]) >>> parse_input(\\"2 2n0 1n0 0\\") == (2, 2, [[0, 1], [0, 0]]) pass def test_min_moves_to_reach_end_basic(): input_data = \\"3 4n0 0 0 1n1 0 0 0n1 1 0 0\\" M, N, grid = parse_input(input_data) assert min_moves_to_reach_end(M, N, grid) == 5 def test_min_moves_to_reach_end_no_path(): input_data = \\"3 3n0 1 0n1 1 1n0 0 0\\" M, N, grid = parse_input(input_data) assert min_moves_to_reach_end(M, N, grid) == -1 def test_min_moves_to_reach_end_complex(): input_data = \\"4 4n0 0 1 0n0 1 0 0n0 0 0 0n1 0 0 0\\" M, N, grid = parse_input(input_data) assert min_moves_to_reach_end(M, N, grid) == 6 def test_min_moves_to_reach_end_edge_case(): input_data = \\"2 2n0 1n0 0\\" M, N, grid = parse_input(input_data) assert min_moves_to_reach_end(M, N, grid) == 2 def test_min_moves_to_reach_end_single_row(): input_data = \\"1 5n0 0 0 1 0\\" M, N, grid = parse_input(input_data) assert min_moves_to_reach_end(M, N, grid) == -1 def test_min_moves_to_reach_end_single_column(): input_data = \\"5 1n0n0n0n1n0\\" M, N, grid = parse_input(input_data) assert min_moves_to_reach_end(M, N, grid) == -1","solution":"from collections import deque def min_moves_to_reach_end(M, N, grid): Given a rectangular grid and a robot starting at the top-left corner, finds the minimum number of moves required to reach the bottom-right corner or returns -1 if it's not possible. :param M: Number of rows in the grid :param N: Number of columns in the grid :param grid: The grid itself :return: Minimum number of moves or -1 if there is no path # Directions to move in the grid directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Check if start or end is blocked if grid[0][0] == 1 or grid[M-1][N-1] == 1: return -1 # Initialize deque for BFS (row, col, distance) queue = deque([(0, 0, 0)]) visited = set([(0, 0)]) # Perform BFS while queue: r, c, dist = queue.popleft() # Check if we reached the destination if r == M-1 and c == N-1: return dist # Explore all possible directions for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < M and 0 <= nc < N and (nr, nc) not in visited and grid[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) # If we exhausted the queue and never reached the end return -1 # Parse the input def parse_input(data): Parses the input string and returns M, N, and the grid as a list of lists. lines = data.strip().split('n') M, N = map(int, lines[0].split()) grid = [list(map(int, line.split())) for line in lines[1:]] return M, N, grid"},{"question":"def minimum_time_to_complete_tasks(test_cases: List[Tuple[int, int, List[Tuple[int, List[int]]]]]) -> List[int]: Determine the minimum total time required to complete all tasks for given test cases. Parameters: - test_cases: A list of tuples where each tuple contains the number of tasks (n), the number of machines (m) and a list of tasks. Each task is described by a tuple containing the time required to complete the task and a list of machines that can process this task. Returns: - A list of integers where each integer is the minimum total time required to complete all tasks for a corresponding test case. >>> test_cases = [ ... (3, 3, [(5, [1, 2]), (3, [1, 2, 3]), (4, [2])]), ... (2, 2, [(2, [1, 2]), (4, [2])]) ... ] >>> minimum_time_to_complete_tasks(test_cases) [5, 4] pass def read_input(input_lines: List[str]) -> List[Tuple[int, int, List[Tuple[int, List[int]]]]]: Read the input and return the test cases in the required format. Parameters: - input_lines: A list of strings representing the input lines. Returns: - A list of tuples where each tuple contains the number of tasks (n), the number of machines (m) and a list of tasks. Each task is described by a tuple containing the time required to complete the task and a list of machines that can process this task. >>> input_lines = [ ... \\"3 3\\", ... \\"5 2 1 2\\", ... \\"3 3 1 2 3\\", ... \\"4 1 2\\", ... \\"2 2\\", ... \\"2 2 1 2\\", ... \\"4 1 2\\", ... \\"0 0\\" ... ] >>> read_input(input_lines) [ (3, 3, [(5, [1, 2]), (3, [1, 2, 3]), (4, [2])]), (2, 2, [(2, [1, 2]), (4, [2])]) ] pass def test_minimum_time_to_complete_tasks(): input_data = 3 3 5 2 1 2 3 3 1 2 3 4 1 2 2 2 2 2 1 2 4 1 2 4 5 7 3 1 3 5 2 2 2 4 5 4 1 2 3 4 9 2 3 5 0 0 input_lines = input_data.strip().split('n') test_cases = read_input(input_lines) result = minimum_time_to_complete_tasks(test_cases) assert result == [5, 4, 9] def test_minimum_time_to_complete_tasks_single_case(): input_data = 2 2 3 1 1 4 1 2 0 0 input_lines = input_data.strip().split('n') test_cases = read_input(input_lines) result = minimum_time_to_complete_tasks(test_cases) assert result == [4] def test_minimum_time_to_complete_tasks_all_machines_can_do_all_tasks(): input_data = 2 2 2 2 1 2 2 2 1 2 0 0 input_lines = input_data.strip().split('n') test_cases = read_input(input_lines) result = minimum_time_to_complete_tasks(test_cases) assert result == [2] def test_minimum_time_to_complete_tasks_edge_case(): input_data = 1 1 100 1 1 0 0 input_lines = input_data.strip().split('n') test_cases = read_input(input_lines) result = minimum_time_to_complete_tasks(test_cases) assert result == [100]","solution":"from itertools import product def minimum_time_to_complete_tasks(test_cases): results = [] for n, m, tasks in test_cases: # Convert machine index to zero-based for easier array handling tasks = [(task[0], [x-1 for x in task[1]]) for task in tasks] def valid_assignment(machine_tasks): load = [0] * m for i, task_machines in enumerate(machine_tasks): if task_machines != -1: load[task_machines] += tasks[i][0] return max(load) # Generate all possible assignments (without duplicates) task_combinations = list(product(*[task[1] for task in tasks])) times = [valid_assignment(assign) for assign in task_combinations] results.append(min(times)) return results def read_input(input_lines): test_cases = [] i = 0 while i < len(input_lines): n, m = map(int, input_lines[i].split()) if n == 0 and m == 0: break i += 1 tasks = [] for _ in range(n): line = list(map(int, input_lines[i].split())) t = line[0] k = line[1] machines = line[2:2 + k] tasks.append((t, machines)) i += 1 test_cases.append((n, m, tasks)) return test_cases input_data = 3 3 5 2 1 2 3 3 1 2 3 4 1 2 2 2 2 2 1 2 4 1 2 4 5 7 3 1 3 5 2 2 2 4 5 4 1 2 3 4 9 2 3 5 0 0 def main(): input_lines = input_data.strip().split('n') test_cases = read_input(input_lines) return minimum_time_to_complete_tasks(test_cases) print(main()) # Output should be: [5, 4, 9]"},{"question":"def distribute_candies(n: int, sequence: List[int]) -> List[int]: Determines the total amount of candies consumed by each employee based on the given sequence. Args: n (int): Number of employees and bags of candies. sequence (list): Picking order of candies. Returns: list: Total amount of candies consumed by each employee.","solution":"def distribute_candies(n, sequence): Determines the total amount of candies consumed by each employee based on the given sequence. Args: n (int): Number of employees and bags of candies. sequence (list): Picking order of candies. Returns: list: Total amount of candies consumed by each employee. result = [0]*n for i in range(n): result[i] = sequence[i % len(sequence)] return result"},{"question":"def minimize_final_element(n: int, a: List[int]) -> int: Returns the minimum possible resultant element by summing all elements. >>> minimize_final_element(3, [3, 1, 2]) 6 >>> minimize_final_element(4, [1, 2, 3, 4]) 10","solution":"def minimize_final_element(n, a): Returns the minimum possible resultant element by summing all elements. Parameters: n (int): The number of elements in the array. a (list of int): The list of integers. Returns: int: The minimum possible final element. return sum(a)"},{"question":"def is_valid_ride(cars: str) -> bool: Determines if the ride setup is valid such that no two adjacent cars face the same direction. A new amusement park ride features a line of cars connected in a straight line, resembling a train. Each car can either be facing forward ('F') or backward ('B'). The ride has a strict requirement that a ride cannot start if there are any adjacent cars facing the same direction, as they can only couple face-to-face. The function should return a Boolean value indicating whether the ride setup is valid according to these rules. Args: cars (str): A string of 'F' (forward) and 'B' (backward) representing the direction of the cars. Returns: bool: True if the ride setup is valid, False otherwise. >>> is_valid_ride(\\"FBFBFB\\") True >>> is_valid_ride(\\"FFBB\\") False >>> is_valid_ride(\\"FB\\") True >>> is_valid_ride(\\"BFFB\\") False # Example Tests: print(is_valid_ride(\\"FBFBFB\\")) # Expected output: True print(is_valid_ride(\\"FFBB\\")) # Expected output: False print(is_valid_ride(\\"FB\\")) # Expected output: True print(is_valid_ride(\\"BFFB\\")) # Expected output: False","solution":"def is_valid_ride(cars: str) -> bool: Determines if the ride setup is valid such that no two adjacent cars face the same direction. Args: cars (str): A string of 'F' (forward) and 'B' (backward) representing the direction of the cars. Returns: bool: True if the ride setup is valid, False otherwise. for i in range(1, len(cars)): if cars[i] == cars[i-1]: return False return True"},{"question":"def longest_even_sum_sublist(n: int, arr: List[int]) -> int: Given a list of integers, find the longest sublist such that the sum of its elements is even. Returns the length of the longest sublist with even sum. If there is no such sublist, it returns 0. >>> longest_even_sum_sublist(5, [1, 2, 3, 4, 5]) 4 >>> longest_even_sum_sublist(3, [1, 1, 1]) 2","solution":"def longest_even_sum_sublist(n, arr): Returns the length of the longest sublist with even sum. If there is no such sublist, it returns 0. # Total sum of the array total_sum = sum(arr) # If the total sum is even, the whole list is the longest even-sum sublist if total_sum % 2 == 0: return n # Check the first and last odd number to minimize the removal to make sum even first_odd_index = -1 last_odd_index = -1 for i in range(n): if arr[i] % 2 != 0: if first_odd_index == -1: first_odd_index = i last_odd_index = i if first_odd_index == -1: # No odd numbers were found, meaning all are even return n # If we remove first or last odd number and the rest sum is even max_length_after_removal = max(n - first_odd_index - 1, last_odd_index) return max_length_after_removal"},{"question":"def check_possible_sequence(n: int, labels: List[int]) -> str: This function determines if the given labels can be rearranged to form a strictly increasing sequence of consecutive integers. Parameters: - n: int, the number of artifact labels. - labels: list of int, the labels of the artifacts. Returns: - str: \\"Possible\\" followed by the sequence or \\"Impossible\\". >>> check_possible_sequence(5, [9, 7, 6, 8, 10]) 'Possiblen6 7 8 9 10' >>> check_possible_sequence(4, [3, 5, 6, 8]) 'Impossible' >>> check_possible_sequence(1, [1000000000]) 'Possiblen1000000000' >>> check_possible_sequence(3, [1, 2, 3]) 'Possiblen1 2 3' >>> check_possible_sequence(3, [3, 2, 1]) 'Possiblen1 2 3' >>> check_possible_sequence(4, [1, 2, 4, 5]) 'Impossible'","solution":"def check_possible_sequence(n, labels): This function determines if the given labels can be rearranged to form a strictly increasing sequence of consecutive integers. Parameters: - n: int, the number of artifact labels. - labels: list of int, the labels of the artifacts. Returns: - str: \\"Possible\\" followed by the sequence or \\"Impossible\\". labels.sort() for i in range(1, n): if labels[i] != labels[i - 1] + 1: return \\"Impossible\\" return \\"Possiblen\\" + \\" \\".join(map(str, labels))"},{"question":"def relative_profit(prices: List[int]) -> List[int]: Computes the relative profit for each day compared to the previous day. :param prices: List[int] - List of stock prices on consecutive days :return: List[int] - List of relative profits for each day >>> relative_profit([7, 1, 5, 3, 6, 4]) [0, -6, 4, -2, 3, -2] >>> relative_profit([1, 2, 3, 4, 5]) [0, 1, 1, 1, 1] >>> relative_profit([5, 4, 3, 2, 1]) [0, -1, -1, -1, -1] >>> relative_profit([10, 10, 10]) [0, 0, 0] >>> relative_profit([]) [] >>> relative_profit([100]) [0] >>> relative_profit([1, 10000]) [0, 9999] >>> relative_profit([10000, 1]) [0, -9999] >>> relative_profit([3, 5, 1, 6]) [0, 2, -4, 5] >>> relative_profit([4, 5, 1, 1, 5]) [0, 1, -4, 0, 4]","solution":"def relative_profit(prices): Computes the relative profit for each day compared to the previous day. :param prices: List[int] - List of stock prices on consecutive days :return: List[int] - List of relative profits for each day n = len(prices) if n == 0: return [] profits = [0] # Initialize the first day's profit as 0 for i in range(1, n): profit = prices[i] - prices[i-1] profits.append(profit) return profits"},{"question":"def closest_point_to_origin(n: int, coordinates: List[Tuple[int, int]]) -> Tuple[int, int]: Returns the coordinates of the point closest to the origin (0, 0). Args: n (int): Number of points. coordinates (list of tuples): List of (x, y) coordinates. Returns: tuple: The coordinates of the point closest to the origin. >>> closest_point_to_origin(4, [(1, 2), (2, 3), (-1, -1), (3, 3)]) (-1, -1) >>> closest_point_to_origin(3, [(1, 1), (-1, -1), (1, 1)]) (1, 1) >>> closest_point_to_origin(1, [(1, 2)]) (1, 2) >>> closest_point_to_origin(5, [(100, 100), (200, 200), (0, 1), (1, 0), (2, 2)]) (0, 1) >>> closest_point_to_origin(3, [(3, 4), (0, 0), (5, 12)]) (0, 0)","solution":"def closest_point_to_origin(n, coordinates): Returns the coordinates of the point closest to the origin. Args: n (int): Number of points. coordinates (list of tuples): List of (x, y) coordinates. Returns: tuple: The coordinates of the point closest to the origin. def distance_squared(point): x, y = point return x**2 + y**2 closest_point = coordinates[0] min_distance = distance_squared(closest_point) for point in coordinates[1:]: dist = distance_squared(point) if dist < min_distance: min_distance = dist closest_point = point return closest_point"},{"question":"def is_unique_subsequence(s: str, queries: List[Tuple[int, int]]) -> List[str]: Determine if the subsequence of s from index l to r is composed of all unique characters for each query. :param s: Input string consisting of lowercase Latin letters. :param queries: List of tuples, where each tuple contains two integers (l, r) representing the starting and ending indices (1-based) of each query. :return: List of strings \\"YES\\" or \\"NO\\" for each query indicating if the subsequence has all unique characters. >>> is_unique_subsequence(\\"abcdef\\", [(1, 3), (2, 5), (1, 6)]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> is_unique_subsequence(\\"aaaaa\\", [(1, 1), (1, 2), (1, 5)]) [\\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def is_unique_subsequence(s, queries): Determine if the subsequence of s from index l to r is composed of all unique characters for each query. :param s: Input string consisting of lowercase Latin letters. :param queries: List of tuples, where each tuple contains two integers (l, r) representing the starting and ending indices (1-based) of each query. :return: List of strings \\"YES\\" or \\"NO\\" for each query indicating if the subsequence has all unique characters. results = [] for l, r in queries: subseq = s[l-1:r] # Convert to 0-based index and slice the string if len(subseq) == len(set(subseq)): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def range_sum_queries(T, test_cases): Calculate the sum of elements in the given range [x, y] (inclusive) for each query. Arguments: - T: int, number of test cases - test_cases: list of dictionaries, each containing: - N: int, number of elements in the array - Q: int, number of queries - array: list of int, containing the elements of the array - queries: list of tuples, each containing two int, x (starting index) and y (ending index) Returns: - list of int, the sum of elements for each query Example: >>> range_sum_queries(1, [{\\"N\\": 5, \\"Q\\": 3, \\"array\\": [1, 2, 3, 4, 5], \\"queries\\": [(0, 2), (1, 3), (2, 4)]}]) [6, 9, 12] >>> range_sum_queries(1, [{\\"N\\": 3, \\"Q\\": 2, \\"array\\": [-1, -2, -3], \\"queries\\": [(0, 1), (1, 2)]}]) [-3, -5] from solution import range_sum_queries def test_single_case(): T = 1 test_cases = [ { \\"N\\": 5, \\"Q\\": 3, \\"array\\": [1, 2, 3, 4, 5], \\"queries\\": [(0, 2), (1, 3), (2, 4)] } ] expected_results = [6, 9, 12] assert range_sum_queries(T, test_cases) == expected_results def test_multi_cases(): T = 2 test_cases = [ { \\"N\\": 5, \\"Q\\": 3, \\"array\\": [1, 2, 3, 4, 5], \\"queries\\": [(0, 2), (1, 3), (2, 4)] }, { \\"N\\": 3, \\"Q\\": 2, \\"array\\": [-1, -2, -3], \\"queries\\": [(0, 1), (1, 2)] } ] expected_results = [6, 9, 12, -3, -5] assert range_sum_queries(T, test_cases) == expected_results def test_zero_sum_case(): T = 1 test_cases = [ { \\"N\\": 4, \\"Q\\": 2, \\"array\\": [0, 0, 0, 0], \\"queries\\": [(0, 3), (1, 2)] } ] expected_results = [0, 0] assert range_sum_queries(T, test_cases) == expected_results def test_large_numbers_case(): T = 1 test_cases = [ { \\"N\\": 3, \\"Q\\": 1, \\"array\\": [10**9, -10**9, 10**9], \\"queries\\": [(0, 2)] } ] expected_results = [10**9] assert range_sum_queries(T, test_cases) == expected_results","solution":"def range_sum_queries(T, test_cases): results = [] for case in test_cases: N, Q = case['N'], case['Q'] array = case['array'] queries = case['queries'] prefix_sum = [0] * (N + 1) for i in range(N): prefix_sum[i + 1] = prefix_sum[i] + array[i] for x, y in queries: sum_range = prefix_sum[y + 1] - prefix_sum[x] results.append(sum_range) return results"},{"question":"def form_teams(n: int) -> Tuple[int, int]: Determine the maximum number of teams that can be formed and the number of employees left without a team when the maximum number of teams is formed. A team consists of exactly 3 employees. Parameters: n (int): the total number of employees (1 ≤ n ≤ 10^9) Returns: Tuple[int, int]: a tuple where the first element is the maximum number of teams and the second element is the number of employees left without a team. Examples: >>> form_teams(7) (2, 1) >>> form_teams(10) (3, 1)","solution":"def form_teams(n): Returns the maximum number of teams that can be formed with n employees and the number of employees left without a team. A team consists of exactly 3 employees. max_teams = n // 3 left_out = n % 3 return (max_teams, left_out)"},{"question":"from typing import List def longest_increasing_subsequence(A: List[int]) -> List[int]: Write a function to find the longest increasing subsequence in a given sequence A. A subsequence is defined as a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) [10, 22, 33, 50, 60, 80] >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) [3, 10, 20]","solution":"from typing import List def longest_increasing_subsequence(A: List[int]) -> List[int]: if not A: return [] n = len(A) # Initialize LIS list to store longest increasing subsequence at each index lis = [[] for _ in range(n)] lis[0].append(A[0]) for i in range(1, n): for j in range(i): if A[i] > A[j] and len(lis[i]) < len(lis[j]): lis[i] = lis[j][:] lis[i].append(A[i]) # Find the entry with the maximal sequence length in the lis longest = max(lis, key=len) return longest"},{"question":"def max_design_value(n, S, values, spaces): Determines the maximum possible value of the sum of design elements that can fit on a t-shirt without exceeding the space limit. Args: n (int): The number of design elements. S (int): The space limit of a t-shirt. values (List[int]): The values of the design elements. spaces (List[int]): The space requirements of the design elements. Returns: int: The maximum possible sum of the values of design elements. Examples: >>> max_design_value(4, 10, [10, 40, 30, 50], [5, 4, 6, 3]) 90 >>> max_design_value(3, 8, [15, 20, 25], [4, 5, 3]) 45","solution":"def max_design_value(n, S, values, spaces): # Create a DP table to store the maximum value for each space limit dp = [0] * (S + 1) for i in range(n): for j in range(S, spaces[i] - 1, -1): dp[j] = max(dp[j], dp[j - spaces[i]] + values[i]) return dp[S] # Example usage # n, S = 4, 10 # values = [10, 40, 30, 50] # spaces = [5, 4, 6, 3] # print(max_design_value(n, S, values, spaces)) # Output: 90"},{"question":"def max_length_substring_with_k_distinct(s: str, k: int) -> int: Determine the maximum length of a substring with at most \`k\` distinct characters. >>> max_length_substring_with_k_distinct(\\"abaccc\\", 2) 4 >>> max_length_substring_with_k_distinct(\\"abcabcabc\\", 1) 1 >>> max_length_substring_with_k_distinct(\\"aaabbb\\", 2) 6 >>> max_length_substring_with_k_distinct(\\"eceba\\", 2) 3 >>> max_length_substring_with_k_distinct(\\"a\\", 1) 1 >>> max_length_substring_with_k_distinct(\\"a\\", 2) 1 >>> max_length_substring_with_k_distinct(\\"abababababab\\", 2) 12 >>> max_length_substring_with_k_distinct(\\"\\", 1) 0","solution":"def max_length_substring_with_k_distinct(s, k): Returns the length of the longest substring with at most k distinct characters. from collections import defaultdict n = len(s) if k == 0 or n == 0: return 0 left = 0 max_length = 0 char_count = defaultdict(int) for right in range(n): char_count[s[right]] += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List, Tuple def find_most_influential_employee(employee_list: List[Tuple[int, int]]) -> int: Find the employee who has the highest number of subordinates directly or indirectly under them. Args: employee_list (List[Tuple[int, int]]): A list of tuples where each tuple consists of two integers, an employee's ID and their manager's ID. Returns: int: The ID of the employee with the most subordinates. Examples: >>> find_most_influential_employee([(1, -1), (2, 1), (3, 1), (4, 2), (5, 2), (6, 3)]) 1 >>> find_most_influential_employee([(1, -1), (2, 1), (3, 1), (4, 1)]) 1 >>> find_most_influential_employee([(1, -1), (2, 1), (3, 2), (4, 2), (5, 3)]) 1 >>> find_most_influential_employee([(1, -1), (2, 1), (3, 1), (4, 2), (5, 2), (6, 4)]) 1 >>> find_most_influential_employee([(1, -1), (2, 1)]) 1","solution":"def find_most_influential_employee(employee_list): from collections import defaultdict # Build an adjacency list to represent the management tree tree = defaultdict(list) root = None for employee_id, manager_id in employee_list: if manager_id == -1: root = employee_id else: tree[manager_id].append(employee_id) # Function to count subordinates for each node def count_subordinates(node): if node not in tree: return 0 count = 0 for child in tree[node]: count += 1 + count_subordinates(child) return count # Determine the employee with the maximum number of subordinates max_subordinates = -1 influential_employee = None for employee, _ in employee_list: sub_count = count_subordinates(employee) if sub_count > max_subordinates: max_subordinates = sub_count influential_employee = employee return influential_employee"},{"question":"def min_trucks_required(n: int, weights: List[int], capacity: int) -> int: Returns the minimum number of trucks required to transport all the packages. Args: n (int): The number of packages. weights (list[int]): The list of package weights. capacity (int): The capacity of each truck. Returns: int: The minimum number of trucks required. Examples: >>> min_trucks_required(5, [2, 3, 4, 5, 6], 10) 2 >>> min_trucks_required(8, [1, 2, 3, 4, 5, 6, 7, 8], 15) 3 >>> min_trucks_required(1, [100], 100) 1 >>> min_trucks_required(4, [10, 20, 30, 40], 100) 1 >>> min_trucks_required(4, [25, 30, 35, 40], 30) 4","solution":"def min_trucks_required(n, weights, capacity): Returns the minimum number of trucks required to transport all the packages. Args: n (int): The number of packages. weights (list[int]): The list of package weights. capacity (int): The capacity of each truck. Returns: int: The minimum number of trucks required. # Sort weights in descending order to prioritize heavier packages first. weights.sort(reverse=True) trucks = [] for weight in weights: # Try to put the package in an existing truck placed = False for truck in trucks: if sum(truck) + weight <= capacity: truck.append(weight) placed = True break # If not possible, create a new truck if not placed: trucks.append([weight]) return len(trucks)"},{"question":"def countCircles(n: int, matrix: List[List[int]]) -> int: Tina is building a new social media application and wants to implement a feature for finding the “circle of friends”. A circle of friends is defined as a group of users where each user is directly or indirectly friends with each other within that group. The friendship is mutual, meaning if user A is friends with user B, then user B is also friends with user A. You are given an adjacency matrix where matrix[i][j] = 1 indicates that user i and user j are friends, and matrix[i][j] = 0 indicates they are not friends. All users are numbered starting from 0. Your task is to find the number of distinct circles of friends within the given matrix. >>> countCircles(4, [[1, 1, 0, 0], [1, 1, 0, 1], [0, 0, 1, 0], [0, 1, 0, 1]]) 2 >>> countCircles(3, [[1, 1, 0], [1, 1, 1], [0, 1, 1]]) 1 >>> countCircles(1, [[1]]) 1 >>> countCircles(3, [[1, 0, 0], [0, 1, 0], [0, 0, 1]]) 3 >>> countCircles(4, [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) 1","solution":"def countCircles(n, matrix): def dfs(node, visited): for friend, is_friend in enumerate(matrix[node]): if is_friend and not visited[friend]: visited[friend] = True dfs(friend, visited) visited = [False] * n circles = 0 for i in range(n): if not visited[i]: circles += 1 visited[i] = True dfs(i, visited) return circles"},{"question":"def min_total_cost(n, minRAM, minCPU, m, laptops): Determine the minimum total cost to purchase exactly one laptop for each employee that meets the specifications. Args: n (int): The number of employees minRAM (int): The minimum RAM required minCPU (float): The minimum CPU speed required m (int): The number of available laptops laptops (List[Tuple[int, float, int]]): A list of tuples, each containing RAM, CPU speed, and price of the laptop Returns: int: The minimum total cost to purchase one laptop for each employee. If it is impossible to meet the requirements for all employees, return -1. >>> min_total_cost(3, 8, 2, 5, [(10, 2.5, 3000), (8, 2, 2500), (16, 3, 4000), (7, 1.8, 1500), (9, 2.2, 3200)]) 8700 >>> min_total_cost(2, 8, 2, 3, [(7, 2, 2200), (8, 1.5, 2100), (9, 1.9, 2300)]) -1","solution":"def min_total_cost(n, minRAM, minCPU, m, laptops): # Filter laptops to find those that meet the minimum RAM and CPU requirements valid_laptops = [laptop for laptop in laptops if laptop[0] >= minRAM and laptop[1] >= minCPU] # If there are not enough valid laptops, return -1 if len(valid_laptops) < n: return -1 # Sort the filtered laptops based on their price in ascending order valid_laptops.sort(key=lambda x: x[2]) # Take the cheapest n laptops that meet the requirements total_cost = sum(laptop[2] for laptop in valid_laptops[:n]) return total_cost"},{"question":"def max_sum_of_removed_buildings(n, heights): This function calculates the maximum sum of heights of buildings after removing exactly one pair of buildings. Parameters: n (int): Number of buildings heights (List[int]): List of heights of the buildings Returns: int: Maximum sum of removed buildings' heights >>> max_sum_of_removed_buildings(5, [1, 2, 3, 4, 5]) 9 >>> max_sum_of_removed_buildings(6, [5, 1, 1, 1, 5, 1]) 10 >>> max_sum_of_removed_buildings(4, [1, 1, 1, 1]) 2 import unittest class TestMaxSumOfRemovedBuildings(unittest.TestCase): def test_basic_cases(self): self.assertEqual(max_sum_of_removed_buildings(5, [1, 2, 3, 4, 5]), 9) self.assertEqual(max_sum_of_removed_buildings(6, [5, 1, 1, 1, 5, 1]), 10) self.assertEqual(max_sum_of_removed_buildings(4, [1, 1, 1, 1]), 2) def test_edge_cases(self): self.assertEqual(max_sum_of_removed_buildings(2, [1, 2]), 3) self.assertEqual(max_sum_of_removed_buildings(2, [1000000000, 1000000000]), 2000000000) def test_varied_height_cases(self): self.assertEqual(max_sum_of_removed_buildings(3, [1, 10, 100]), 110) self.assertEqual(max_sum_of_removed_buildings(4, [1, 5, 9, 100]), 109) def test_same_heights(self): self.assertEqual(max_sum_of_removed_buildings(5, [3, 3, 3, 3, 3]), 6) self.assertEqual(max_sum_of_removed_buildings(6, [7, 7, 7, 7, 7, 7]), 14) if __name__ == \\"__main__\\": unittest.main()","solution":"def max_sum_of_removed_buildings(n, heights): This function calculates the maximum sum of heights of buildings after removing exactly one pair of buildings. Parameters: n (int): Number of buildings heights (List[int]): List of heights of the buildings Returns: int: Maximum sum of removed buildings' heights # Initialize the maximum sum to zero max_sum = 0 # Iterate over the list of heights to find the maximum sum of a pair of buildings for i in range(n - 1): for j in range(i + 1, n): current_sum = heights[i] + heights[j] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def smallest_missing_positive(arr): Find the smallest missing positive integer from a given array of integers. >>> smallest_missing_positive([1, 2, 0, -1, 3]) 4 >>> smallest_missing_positive([3, 4, -1, 1]) 2 >>> smallest_missing_positive([7, 8, 9, 11, 12, 13]) 1 def find_smallest_missing_positive(T, test_cases): Determine the smallest missing positive integer for multiple test cases. >>> find_smallest_missing_positive(3, [(5, [1, 2, 0, -1, 3]), (4, [3, 4, -1, 1]), (6, [7, 8, 9, 11, 12, 13])]) [4, 2, 1] from solution import smallest_missing_positive, find_smallest_missing_positive def test_case_1(): assert smallest_missing_positive([1, 2, 0, -1, 3]) == 4 def test_case_2(): assert smallest_missing_positive([3, 4, -1, 1]) == 2 def test_case_3(): assert smallest_missing_positive([7, 8, 9, 11, 12, 13]) == 1 def test_case_4(): assert smallest_missing_positive([-1, -2, -3, -4]) == 1 def test_case_5(): assert smallest_missing_positive([2, 3, 4, 5, 6]) == 1 def test_large_case(): n = 100000 array = list(range(1, n + 1)) array[n - 1] = -1 # Replace the last element with -1 assert smallest_missing_positive(array) == n def test_multiple_cases(): T = 3 test_cases = [ (5, [1, 2, 0, -1, 3]), (4, [3, 4, -1, 1]), (6, [7, 8, 9, 11, 12, 13]) ] assert find_smallest_missing_positive(T, test_cases) == [4, 2, 1] def test_edge_case_single_element(): assert smallest_missing_positive([1]) == 2 assert smallest_missing_positive([2]) == 1 def test_all_positive_numbers(): assert smallest_missing_positive([5, 6, 7, 8]) == 1 assert smallest_missing_positive([1, 2, 3, 4]) == 5 def test_duplicates(): assert smallest_missing_positive([1, 2, 2, 3, 4]) == 5 assert smallest_missing_positive([1, 2, 3, 3, 3, 5]) == 4","solution":"def smallest_missing_positive(arr): n = len(arr) for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] for i in range(n): if arr[i] != i + 1: return i + 1 return n + 1 def find_smallest_missing_positive(T, test_cases): results = [] for i in range(T): n = test_cases[i][0] array = test_cases[i][1] results.append(smallest_missing_positive(array)) return results"},{"question":"from typing import List def calculate_word_frequency_ranking(n: int, words: List[str]) -> List[str]: Given a list of words, this function calculates the frequency of each word and returns a list of words sorted by frequency in descending order. In case of ties in frequency, words are sorted alphabetically. Parameters: n (int): The number of words in the list. words (List[str]): The list of words. Returns: List[str]: The list of words sorted by frequency and alphabetically in case of ties. Examples: >>> calculate_word_frequency_ranking(6, [\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]) ['apple', 'banana', 'orange'] >>> calculate_word_frequency_ranking(10, [\\"lemon\\", \\"lemon\\", \\"berry\\", \\"berry\\", \\"berry\\", \\"apple\\", \\"kiwi\\", \\"kiwi\\", \\"kiwi\\", \\"banana\\"]) ['berry', 'kiwi', 'lemon', 'apple', 'banana'] def test_case_1(): input_n = 6 input_words = [\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"] expected_output = [\\"apple\\", \\"banana\\", \\"orange\\"] assert calculate_word_frequency_ranking(input_n, input_words) == expected_output def test_case_2(): input_n = 10 input_words = [\\"lemon\\", \\"lemon\\", \\"berry\\", \\"berry\\", \\"berry\\", \\"apple\\", \\"kiwi\\", \\"kiwi\\", \\"kiwi\\", \\"banana\\"] expected_output = [\\"berry\\", \\"kiwi\\", \\"lemon\\", \\"apple\\", \\"banana\\"] assert calculate_word_frequency_ranking(input_n, input_words) == expected_output def test_case_3(): input_n = 5 input_words = [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\", \\"elderberry\\"] expected_output = [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\", \\"elderberry\\"] assert calculate_word_frequency_ranking(input_n, input_words) == expected_output def test_case_4(): input_n = 6 input_words = [\\"a\\", \\"b\\", \\"c\\", \\"b\\", \\"a\\", \\"a\\"] expected_output = [\\"a\\", \\"b\\", \\"c\\"] assert calculate_word_frequency_ranking(input_n, input_words) == expected_output def test_case_5(): input_n = 4 input_words = [\\"zebra\\", \\"monkey\\", \\"aardvark\\", \\"zebra\\"] expected_output = [\\"zebra\\", \\"aardvark\\", \\"monkey\\"] assert calculate_word_frequency_ranking(input_n, input_words) == expected_output","solution":"from collections import Counter def calculate_word_frequency_ranking(n, words): Given a list of words, this function calculates the frequency of each word and returns a list of words sorted by frequency in descending order. In case of ties in frequency, words are sorted alphabetically. word_count = Counter(words) sorted_words = sorted(word_count.items(), key=lambda item: (-item[1], item[0])) return [word for word, count in sorted_words]"},{"question":"def find_min_abs_diff_pair(n: int, arr: List[int]) -> Tuple[int, int]: Finds two numbers a_i and a_j (i ≠ j) such that the absolute difference between them is minimized. If there are multiple pairs with the same minimum difference, any one of them is acceptable. >>> find_min_abs_diff_pair(5, [10, 8, 15, 3, 12]) (8, 10) >>> find_min_abs_diff_pair(4, [1, 9, 13, 6]) (6, 9) pass if __name__ == '__main__': import sys input = sys.stdin.read data = input().split() n = int(data[0]) arr = list(map(int, data[1:])) result = find_min_abs_diff_pair(n, arr) print(result[0], result[1])","solution":"def find_min_abs_diff_pair(n, arr): Finds two numbers a_i and a_j (i ≠ j) such that the absolute difference between them is minimized. If there are multiple pairs with the same minimum difference, any one of them is acceptable. arr.sort() min_diff = float('inf') pair = (arr[0], arr[1]) for i in range(1, n): diff = abs(arr[i] - arr[i - 1]) if diff < min_diff: min_diff = diff pair = (arr[i - 1], arr[i]) return pair if __name__ == '__main__': import sys input = sys.stdin.read data = input().split() n = int(data[0]) arr = list(map(int, data[1:])) result = find_min_abs_diff_pair(n, arr) print(result[0], result[1])"},{"question":"def min_moves_to_make_elements_equal(N: int, A: List[int]) -> int: Given an array of integers A of length N, find the minimum number of moves required to make all the elements of the array equal. Each move can increase or decrease the value of any one element by 1. >>> min_moves_to_make_elements_equal(4, [1, 10, 2, 9]) 16 >>> min_moves_to_make_elements_equal(3, [-1, -1, 1]) 2 >>> min_moves_to_make_elements_equal(5, [1, 2, 3, 4, 5]) 6 from typing import List def test_min_moves_case_1(): assert min_moves_to_make_elements_equal(4, [1, 10, 2, 9]) == 16 def test_min_moves_case_2(): assert min_moves_to_make_elements_equal(3, [-1, -1, 1]) == 2 def test_min_moves_case_3(): assert min_moves_to_make_elements_equal(5, [1, 2, 3, 4, 5]) == 6 def test_min_moves_case_4(): assert min_moves_to_make_elements_equal(2, [-1000000000, 1000000000]) == 2000000000 def test_min_moves_case_5(): assert min_moves_to_make_elements_equal(1, [0]) == 0 def test_min_moves_large_case(): assert min_moves_to_make_elements_equal(6, [1, 3, 3, 3, 6, 7]) == 9","solution":"def min_moves_to_make_elements_equal(N, A): Returns the minimum number of moves required to make all elements of A equal. A.sort() median = A[N // 2] # choosing the median as the target for minimum moves return sum(abs(x - median) for x in A) # reading input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) A = list(map(int, data[1:])) print(min_moves_to_make_elements_equal(N, A))"},{"question":"def count_consecutive_sum_ways(n: int) -> int: Returns the number of unique ways to express n as the sum of two or more consecutive positive integers. >>> count_consecutive_sum_ways(9) == 2 >>> count_consecutive_sum_ways(15) == 3 >>> count_consecutive_sum_ways(1) == 0 >>> count_consecutive_sum_ways(10) == 1 >>> count_consecutive_sum_ways(100) == 2 >>> count_consecutive_sum_ways(45) == 5 def process_input(input_list: List[int]) -> List[int]: Process the input list and returns the results for each n that is not zero. >>> process_input([9, 15, 0]) == [2, 3] >>> process_input([10, 45, 0]) == [1, 5] >>> process_input([100, 1, 0]) == [2, 0] >>> process_input([1, 0, 0]) == [0]","solution":"def count_consecutive_sum_ways(n): Returns the number of unique ways to express n as the sum of two or more consecutive positive integers. count = 0 length = 2 while True: a = (2 * n + length - length ** 2) / (2 * length) if a < 1: break if a.is_integer(): count += 1 length += 1 return count def process_input(input_list): Process the input list and returns the results for each n that is not zero. results = [] for n in input_list: if n == 0: break results.append(count_consecutive_sum_ways(n)) return results"},{"question":"def can_be_constructed_by_repeating_substring(s: str) -> bool: Determine if the string can be constructed by repeating a substring. >>> can_be_constructed_by_repeating_substring(\\"abab\\") True >>> can_be_constructed_by_repeating_substring(\\"aba\\") False >>> can_be_constructed_by_repeating_substring(\\"abcabcabcabc\\") True >>> can_be_constructed_by_repeating_substring(\\"a\\") False >>> can_be_constructed_by_repeating_substring(\\"aa\\") True >>> can_be_constructed_by_repeating_substring(\\"ab\\") False >>> can_be_constructed_by_repeating_substring(\\"xyzxyzxyz\\") True >>> can_be_constructed_by_repeating_substring(\\"xyzxyzxy\\") False >>> can_be_constructed_by_repeating_substring(\\"abcd\\") False","solution":"def can_be_constructed_by_repeating_substring(s): Determine if the string can be constructed by repeating a substring. n = len(s) for i in range(1, n // 2 + 1): if n % i == 0: if s[:i] * (n // i) == s: return True return False"},{"question":"def max_consecutive_days(k: int, study_hours: List[int]) -> int: Returns the maximum number of consecutive days students studied more than k hours. >>> max_consecutive_days(5, [2, 6, 7, 5, 8, 12, 4, 3, 5, 6, 24, 24, 1, 2, 3, 4, 5, 11, 13, 14, 2, 3, 6, 7, 8, 3, 2, 1, 0, 9]) 3 >>> max_consecutive_days(8, [9, 10, 11, 12, 8, 8, 8, 7, 6, 5, 4, 3, 2, 1, 0, 8, 9, 10, 8, 7, 5, 4, 3, 2, 1, 8, 8, 8, 9, 10]) 4","solution":"def max_consecutive_days(k, study_hours): Returns the maximum number of consecutive days students studied more than k hours. max_streak = 0 current_streak = 0 for hours in study_hours: if hours > k: current_streak += 1 max_streak = max(max_streak, current_streak) else: current_streak = 0 return max_streak"},{"question":"def minimum_tiles(n: int, a: int) -> int: Returns the minimum number of tiles required to completely cover a floor of dimensions n by n using tiles of side a. >>> minimum_tiles(6, 4) 4 >>> minimum_tiles(7, 3) 9 >>> minimum_tiles(5, 2) 9","solution":"import math def minimum_tiles(n, a): Returns the minimum number of tiles required to completely cover a floor of dimensions n by n using tiles of side a. # Calculate the number of tiles needed along each dimension tiles_along_side = math.ceil(n / a) # The total number of tiles will be the product of the tiles needed along each dimension total_tiles = tiles_along_side * tiles_along_side return total_tiles"},{"question":"def guess_sequence(t: int, test_cases: List[Tuple[int, int, int]]) -> List[List[int]]: Guess the correct sequence of numbers for the given game. The function takes the number of test cases 't' and a list of test cases where each test case is represented by a tuple (n, m, q): - n: Length of the sequence - m: The range of possible values - q: The maximum number of queries you can make Example: >>> t = 1 >>> test_cases = [(5, 10, 3)] >>> guess_sequence(t, test_cases) [[1, 3, 5, 7, 10]] from io import StringIO from unittest.mock import patch import pytest def test_guess_sequence_case_1(): t = 1 test_cases = [(5, 10, 3)] input_seq = iter([ \\"1\\", \\"3\\", \\"5\\", \\"7\\", \\"10\\", # Responses to the queries \\"Correct\\" ]) expected_output = [[1, 3, 5, 7, 10]] with patch('builtins.input', lambda: next(input_seq)): assert guess_sequence(t, test_cases) == expected_output def test_guess_sequence_case_2(): t = 1 test_cases = [(4, 8, 4)] input_seq = iter([ \\"2\\", \\"4\\", \\"6\\", \\"8\\", # Responses to the queries \\"Correct\\" ]) expected_output = [[2, 4, 6, 8]] with patch('builtins.input', lambda: next(input_seq)): assert guess_sequence(t, test_cases) == expected_output def test_guess_sequence_case_3(): t = 1 test_cases = [(3, 5, 2)] input_seq = iter([ \\"1\\", \\"3\\", \\"5\\", # Responses to the queries \\"Correct\\" ]) expected_output = [[1, 3, 5]] with patch('builtins.input', lambda: next(input_seq)): assert guess_sequence(t, test_cases) == expected_output def test_guess_sequence_incorrect(): t = 1 test_cases = [(3, 5, 2)] input_seq = iter([ \\"1\\", \\"3\\", \\"5\\", # Responses to the queries \\"Incorrect\\" # Immediate termination on incorrect guess ]) expected_output = [] with patch('builtins.input', lambda: next(input_seq)): assert guess_sequence(t, test_cases) == expected_output","solution":"def guess_sequence(t, test_cases): results = [] for test_index in range(t): n, m, q = test_cases[test_index] queries = [] # Query all single positions first for i in range(1, n + 1): print(f\\"? 1 {i}\\") # Read the response max_val = int(input().strip()) queries.append(max_val) # The sequence should be strictly increasing and unique secret_sequence = sorted(queries) print(f\\"! {' '.join(map(str, secret_sequence))}\\") # Read result feedback feedback = input().strip() if feedback != \\"Correct\\": break else: results.append(secret_sequence) return results # Example usage: # t = 1 # test_cases = [(5, 10, 3)] # guess_sequence(t, test_cases)"},{"question":"def rearrange_heights(n: int, heights: List[int]) -> List[int]: Rearranges the list of heights so that the maximum difference between any two adjacent people is minimized. >>> rearrange_heights(5, [4, 1, 3, 9, 7]) [1, 3, 4, 7, 9] >>> rearrange_heights(3, [10, 20, 30]) [10, 20, 30]","solution":"def rearrange_heights(n, heights): Rearranges the list of heights so that the maximum difference between any two adjacent people is minimized. heights.sort() return heights"},{"question":"from typing import List def generate_tournament_configurations(m: int) -> List[List[int]]: Generate all possible unique configurations for tournaments with tasks ranging from 1 to m. Args: m (int): Maximum difficulty of the tasks. Returns: List[List[int]]: A list of configurations with each configuration being a list of integers. pass # Unit Tests def test_generate_tournament_configurations_m_2(): expected = [[1, 2], [2, 1]] assert generate_tournament_configurations(2) == expected def test_generate_tournament_configurations_m_3(): expected = [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] assert generate_tournament_configurations(3) == expected def test_generate_tournament_configurations_m_1(): expected = [[1]] assert generate_tournament_configurations(1) == expected def test_generate_tournament_configurations_m_4(): expected = sorted([ [1, 2, 3, 4], [1, 2, 4, 3], [1, 3, 2, 4], [1, 3, 4, 2], [1, 4, 2, 3], [1, 4, 3, 2], [2, 1, 3, 4], [2, 1, 4, 3], [2, 3, 1, 4], [2, 3, 4, 1], [2, 4, 1, 3], [2, 4, 3, 1], [3, 1, 2, 4], [3, 1, 4, 2], [3, 2, 1, 4], [3, 2, 4, 1], [3, 4, 1, 2], [3, 4, 2, 1], [4, 1, 2, 3], [4, 1, 3, 2], [4, 2, 1, 3], [4, 2, 3, 1], [4, 3, 1, 2], [4, 3, 2, 1] ]) result = sorted(generate_tournament_configurations(4)) assert result == expected def test_generate_tournament_configurations_m_5(): result = generate_tournament_configurations(5) assert len(result) == 120 assert all(sorted(list(item)) == list(range(1, 6)) for item in result)","solution":"from itertools import permutations def generate_tournament_configurations(m): Generate all possible unique configurations for tournaments with tasks ranging from 1 to m. Args: m (int): Maximum difficulty of the tasks. Returns: List[List[int]]: A list of configurations with each configuration being a list of integers. tasks = list(range(1, m + 1)) unique_configs = list(permutations(tasks)) result = [list(config) for config in unique_configs] return result"},{"question":"def find_leaders(T: int, test_cases: List[Tuple[int, List[int]]]) -> Union[List[str], str]: Given an array of integers, find all the leaders in the array. An element is a leader if it is greater than all the elements to its right side. The rightmost element is always a leader. Args: T : int : Number of test cases test_cases : List[Tuple[int, List[int]]] : List of tuples with each tuple containing an integer n and a list of n integers Returns: Union[List[str], str] : List of strings with the leaders for each test case or \\"Invalid Test\\"/\\"Invalid Input\\" >>> find_leaders(2, [(6, [16, 17, 4, 3, 5, 2]), (5, [1, 2, 3, 4, 5])]) ['17 5 2', '5'] >>> find_leaders(11, [(5, [1, 2, 3, 4, 5])]) 'Invalid Test' >>> find_leaders(1, [(101, [10] * 101)]) 'Invalid Input' >>> find_leaders(1, [(3, [7, 6, 8])]) ['8'] >>> find_leaders(1, [(2, [10, 20])]) ['20']","solution":"def find_leaders(T, test_cases): if not (1 <= T <= 10): return \\"Invalid Test\\" results = [] for case in test_cases: n = case[0] array = case[1] if not (1 <= n <= 100): return \\"Invalid Input\\" leaders = [] max_from_right = array[-1] # The rightmost element is always a leader leaders.append(max_from_right) # Traverse the array from right to left for i in range(n - 2, -1, -1): if array[i] > max_from_right: leaders.append(array[i]) max_from_right = array[i] # Since we collected leaders from right to left, reverse the order before appending results.append(\\" \\".join(map(str, reversed(leaders)))) return results"},{"question":"from typing import List, Tuple def solve_maze_problem(input_string: str) -> int: Given a maze represented by a 2D array of size n x m consisting of '.' and '#' characters, find the length of the shortest path from the start (0,0) to the end (n-1,m-1). If no such path exists, return -1. Example: >>> solve_maze_problem(\\"5 5n. . . . #n# # . # #n. . . . .n. # # # .n. . . . .\\") 9 >>> solve_maze_problem(\\"4 4n. . # .n# . # .n# . # #n. . . .\\") 7 >>> solve_maze_problem(\\"3 3n. # .n# # .n. . .\\") -1 >>> solve_maze_problem(\\"1 1n.\\") 1 >>> solve_maze_problem(\\"3 3n# # #n# # #n# # #\\") -1 def shortest_path_in_maze(n: int, m: int, maze: List[List[str]]) -> int: # Function body here def parse_input(input_string: str) -> Tuple[int, int, List[List[str]]]: # Function body here # Main logic here","solution":"from collections import deque def shortest_path_in_maze(n, m, maze): Returns the length of the shortest path from the top-left corner to the bottom-right corner of the maze. If no such path exists, return -1. def is_valid(x, y): return 0 <= x < n and 0 <= y < m and maze[x][y] == '.' # directions for moving in the maze: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # queue for BFS queue = deque([(0, 0, 1)]) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if (x, y) == (n-1, m-1): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 def parse_input(input_string): lines = input_string.strip().split(\\"n\\") n, m = map(int, lines[0].split()) maze = [line.split() for line in lines[1:]] return n, m, maze def solve_maze_problem(input_string): n, m, maze = parse_input(input_string) return shortest_path_in_maze(n, m, maze)"},{"question":"from typing import List def cyclic_permutations(s: str) -> List[str]: Generate all unique cyclic permutations of the string \`s\` in lexicographical order. >>> cyclic_permutations(\\"abcd\\") == [\\"abcd\\", \\"bcda\\", \\"cdab\\", \\"dabc\\"] >>> cyclic_permutations(\\"rotation\\") == [ ... \\"ationrot\\", ... \\"ionrotat\\", ... \\"nrotatio\\", ... \\"onrotati\\", ... \\"otationr\\", ... \\"rotation\\", ... \\"tationro\\", ... \\"tionrota\\", ... ] pass def process_input(inputs: List[str]) -> List[List[str]]: Process a list of input strings and return a list of lists containing the lexicographically ordered unique cyclic permutations for each string. >>> process_input([\\"abcd\\", \\"rotation\\", \\"#\\"]) == [ ... [\\"abcd\\", \\"bcda\\", \\"cdab\\", \\"dabc\\"], ... [ ... \\"ationrot\\", ... \\"ionrotat\\", ... \\"nrotatio\\", ... \\"onrotati\\", ... \\"otationr\\", ... \\"rotation\\", ... \\"tationro\\", ... \\"tionrota\\", ... ] ... ] pass","solution":"def cyclic_permutations(s): Generate all unique cyclic permutations of the string \`s\` in lexicographical order. n = len(s) permutations = set() for i in range(n): rotated_string = s[i:] + s[:i] permutations.add(rotated_string) return sorted(permutations) def process_input(inputs): results = [] for s in inputs: if s == '#': break results.append(cyclic_permutations(s)) return results"},{"question":"def min_transfers_to_even_requests(T: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of transfers needed to make all web hosts handle even number of requests. Args: T : int : The number of test cases cases : List[Tuple[int, List[int]]] : A list where each element is a tuple. The first element of the tuple is an integer N, the number of web hosts. The second element is a list of N integers, representing the number of requests being served by each host. Returns: List[int] : A list of integers where each integer represents the minimum number of transfers required for each test case. Example: >>> min_transfers_to_even_requests(2, [(4, [5, 9, 3, 1]), (3, [2, 3, 4])]) [4, 0] # Here are some example test cases to help you verify your implementation def test_cases(): assert min_transfers_to_even_requests(1, [(3, [2, 4, 6])]) == [0] assert min_transfers_to_even_requests(1, [(3, [1, 3, 5])]) == [2] assert min_transfers_to_even_requests(1, [(3, [2, 3, 4])]) == [0] assert min_transfers_to_even_requests(1, [(4, [5, 9, 3, 1])]) == [4] assert min_transfers_to_even_requests(2, [(4, [5, 9, 3, 1]), (3, [2, 3, 4])]) == [4, 0] assert min_transfers_to_even_requests(1, [(1, [2])]) == [0] assert min_transfers_to_even_requests(1, [(1, [1])]) == [0] test_cases = [(1000, [i for i in range(1, 1001)])] results = min_transfers_to_even_requests(1, test_cases) assert results == [500]","solution":"def min_transfers_to_even_requests(T, cases): results = [] for case in cases: N, requests = case odd_counts = sum(1 for req in requests if req % 2 != 0) # To make all even, the number of odd counts should be even # So, the number of transfers will be odd_counts//2 results.append(odd_counts // 2 * 2) return results"},{"question":"def minimal_color_changes(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determines the minimal number of color changes required to create segments of unique colored flower pots. >>> minimal_color_changes(2, [(5, [1, 2, 2, 3, 4]), (4, [1, 1, 1, 1])]) [1, 3] >>> minimal_color_changes(1, [(5, [1, 2, 3, 4, 5])]) [0]","solution":"def minimal_color_changes(T, test_cases): results = [] for t in range(T): N, pots = test_cases[t] color_set = set(pots) unique_color_count = len(color_set) if unique_color_count == N: results.append(0) else: results.append(N - unique_color_count) return results # Example usage: # T = 2 # test_cases = [(5, [1, 2, 2, 3, 4]), (4, [1, 1, 1, 1])] # print(minimal_color_changes(T, test_cases)) # Output: [1, 3]"},{"question":"def highest_average_score(input_data: str) -> float: Calculate and return the highest average score among all students. Args: input_data (str): Multiline string where the first line contains the number of students. Each subsequent line contains a student ID followed by their scores. Returns: float: The highest average score rounded to two decimal places. Examples: >>> highest_average_score(\\"1n23 88 92\\") 90.00 >>> highest_average_score(\\"3n1 70 80 90n2 85 95n3 60 100 85 70\\") 90.00 >>> highest_average_score(\\"2n101 50 60 70n102 85 90 95 80\\") 87.50","solution":"def highest_average_score(input_data): Calculate and return the highest average score among all students. Args: input_data (str): Multiline string where the first line contains the number of students. Each subsequent line contains a student ID followed by their scores. Returns: float: The highest average score rounded to two decimal places. lines = input_data.strip().split('n') num_students = int(lines[0]) high_avg = 0.0 for i in range(1, num_students + 1): data = list(map(int, lines[i].split())) student_id = data[0] scores = data[1:] avg_score = sum(scores) / len(scores) if avg_score > high_avg: high_avg = avg_score return round(high_avg, 2)"},{"question":"def minimum_minutes_to_turn_on_lamps(q: int, test_cases: List[int]) -> List[int]: Given the number of test cases and the number of round tables in each test case, this function returns the minimum number of minutes required to turn on all the lamps for each test case. >>> minimum_minutes_to_turn_on_lamps(2, [3, 4]) [2, 2] >>> minimum_minutes_to_turn_on_lamps(1, [5]) [3]","solution":"def minimum_minutes_to_turn_on_lamps(q, test_cases): This function returns the minimum number of minutes required to turn on all the lamps for each test case. def minutes_for_m(m): # For an odd number of lamps, (m-1)//2 minutes are needed # For an even number of lamps, (m//2 + 1) minutes are needed if m % 2 == 0: return (m // 2) else: return (m + 1) // 2 results = [] for m in test_cases: results.append(minutes_for_m(m)) return results"},{"question":"def minimal_variance_brightness(N: int, K: int, brightness: list) -> int: This function returns the minimum variance of brightness for K consecutive photos out of a total of N photos. :param N: int, the number of photos :param K: int, the number of consecutive photos to select :param brightness: list of int, the brightness values of the photos :return: int, the minimum variance of brightness pass # Unit Tests def test_minimal_variance_brightness_example(): N, K = 8, 3 brightness = [10, 20, 30, 40, 50, 60, 70, 80] assert minimal_variance_brightness(N, K, brightness) == 20 def test_minimal_variance_brightness_single_photo(): N, K = 5, 1 brightness = [10, 20, 30, 40, 50] assert minimal_variance_brightness(N, K, brightness) == 0 def test_minimal_variance_brightness_all_same_brightness(): N, K = 4, 2 brightness = [30, 30, 30, 30] assert minimal_variance_brightness(N, K, brightness) == 0 def test_minimal_variance_brightness_decreasing_brightness(): N, K = 6, 3 brightness = [60, 50, 40, 30, 20, 10] assert minimal_variance_brightness(N, K, brightness) == 20 def test_minimal_variance_brightness_edge_case(): N, K = 4, 4 brightness = [1, 1000000, 1, 1000000] assert minimal_variance_brightness(N, K, brightness) == 999999","solution":"def minimal_variance_brightness(N, K, brightness): This function returns the minimum variance of brightness for K consecutive photos out of a total of N photos. :param N: int, the number of photos :param K: int, the number of consecutive photos to select :param brightness: list of int, the brightness values of the photos :return: int, the minimum variance of brightness min_variance = float('inf') for i in range(N - K + 1): current_segment = brightness[i:i+K] current_variance = max(current_segment) - min(current_segment) if current_variance < min_variance: min_variance = current_variance return min_variance"},{"question":"def minimum_cost_to_connect_islands(n: int, m: int, bridge_data: List[Tuple[int, int, int, int]], max_energy: int) -> Union[int, str]: Determine the minimum cost needed to keep all islands connected without exceeding the wizard's magical energy capacity. >>> minimum_cost_to_connect_islands(4, 5, [(1, 2, 10, 5), (2, 3, 15, 7), (3, 4, 10, 6), (4, 1, 20, 9), (1, 3, 25, 8)], 15) 35 >>> minimum_cost_to_connect_islands(3, 3, [(1, 2, 10, 5), (2, 3, 15, 3), (3, 1, 30, 10)], 8) 25 >>> minimum_cost_to_connect_islands(3, 3, [(1, 2, 10, 5), (2, 3, 15, 7), (3, 1, 20, 10)], 5) \\"impossible\\" >>> minimum_cost_to_connect_islands(4, 6, [(1, 2, 10, 5), (2, 3, 10, 4), (3, 4, 10, 4), (4, 1, 10, 4), (1, 3, 30, 10), (2, 4, 30, 10)], 10) 30","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal(n, edges): result = [] i = 0 e = 0 edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) while e < n - 1: if i >= len(edges): break u, v, cost, energy = edges[i] i = i + 1 x = find(parent, u) y = find(parent, v) if x != y: e = e + 1 result.append((u, v, cost)) union(parent, rank, x, y) if e != n - 1: return \\"impossible\\" else: return sum([cost for u, v, cost in result]) def minimum_cost_to_connect_islands(n, m, bridge_data, max_energy): edges = [] for u, v, cost, energy in bridge_data: if energy <= max_energy: edges.append((u-1, v-1, cost, energy)) return kruskal(n, edges)"},{"question":"def min_meeting_rooms(tasks: List[Tuple[int, int]]) -> int: Determines the minimum number of meeting rooms required to accommodate all tasks without overlap. Each task is represented by a tuple of integers (start time, end time). If a task ends at time x and another task starts at time x, these two tasks do not overlap. :param tasks: List of tuples representing the start and end times of tasks. :return: Integer representing the minimum number of meeting rooms required. Examples: >>> min_meeting_rooms([(1, 4), (2, 6), (8, 9), (5, 7)]) 2 >>> min_meeting_rooms([(1, 5), (2, 6), (3, 7), (4, 8)]) 4 >>> min_meeting_rooms([(10, 20), (20, 30), (30, 40), (40, 50)]) 1 from solution import min_meeting_rooms def test_no_tasks(): assert min_meeting_rooms([]) == 0 def test_single_task(): assert min_meeting_rooms([(1, 2)]) == 1 def test_non_overlapping_tasks(): assert min_meeting_rooms([(1, 3), (4, 6), (7, 9)]) == 1 def test_overlapping_tasks(): assert min_meeting_rooms([(1, 4), (2, 6), (8, 9), (5, 7)]) == 2 assert min_meeting_rooms([(1, 5), (2, 6), (3, 7), (4, 8)]) == 4 def test_tasks_with_same_start_and_end(): assert min_meeting_rooms([(1, 3), (1, 3), (1, 3)]) == 3 assert min_meeting_rooms([(1, 2), (1, 2), (2, 3), (2, 3)]) == 2 def test_complex_tasks(): assert min_meeting_rooms([(0, 30), (5, 10), (15, 20)]) == 2 assert min_meeting_rooms([(10, 20), (20, 30), (30, 40), (40, 50)]) == 1 assert min_meeting_rooms([(1, 4), (2, 3), (3, 5), (4, 6)]) == 2","solution":"import heapq def min_meeting_rooms(tasks): Determines the minimum number of meeting rooms required to accommodate all tasks. :param tasks: List of tuples representing start and end times of tasks. :return: Integer representing the minimum number of meeting rooms required. if not tasks: return 0 # Sort the tasks by start time tasks.sort(key=lambda x: x[0]) # Use a min heap to keep track of end times of tasks min_heap = [] # Add the end time of the first task to the heap heapq.heappush(min_heap, tasks[0][1]) for i in range(1, len(tasks)): # If the current task's start time is greater than or equal to the min end time in the heap, pop from the heap if tasks[i][0] >= min_heap[0]: heapq.heappop(min_heap) # Add the current task's end time to the heap heapq.heappush(min_heap, tasks[i][1]) # The size of the heap is the number of rooms required return len(min_heap)"},{"question":"import re from typing import List def count_unique_words(sentence: str) -> int: Returns the number of unique words in the given sentence. >>> count_unique_words(\\"Hello, World! Hello Code.\\") 3 >>> count_unique_words(\\"Hello hello HeLLo\\") 1 >>> count_unique_words(\\"Hello World 123\\") 2 >>> count_unique_words(\\"\\") 0 >>> count_unique_words(\\"123, 456!\\") 0 >>> count_unique_words(\\"Hello, World! 12345 Code!\\") 3 >>> count_unique_words(\\"Does it, really? It does!\\") 3","solution":"import re def count_unique_words(sentence): Returns the number of unique words in the given sentence. # Convert to lowercase and use regex to find all words words = re.findall(r'b[a-z]+b', sentence.lower()) # Use a set to find unique words unique_words = set(words) # The number of unique words return len(unique_words)"},{"question":"from typing import List class Matrix: def __init__(self, n: int): Initialize a matrix of size n x n with all zeroes and an array to store row increments. pass def process_query(self, query: str) -> int: Process a single query and return the result for sum queries. pass def process_queries(n: int, queries: List[str]) -> List[int]: Process multiple queries on an n x n matrix. Args: n (int): The size of the matrix. queries (List[str]): List of queries to be processed. Returns: List[int]: Results of sum queries. Example: >>> process_queries(3, [\\"1 1 1 2\\", \\"1 2 2 3\\", \\"2 1 1\\", \\"3 1 1 2 2\\", \\"3 2 2 3 3\\"]) [7, 3] pass # Unit test cases def test_process_queries(): n = 3 queries = [ \\"1 1 1 2\\", \\"1 2 2 3\\", \\"2 1 1\\", \\"3 1 1 2 2\\", \\"3 2 2 3 3\\" ] expected_output = [7, 3] assert process_queries(n, queries) == expected_output def test_all_zeroes(): n = 2 queries = [ \\"3 1 1 2 2\\" ] expected_output = [0] assert process_queries(n, queries) == expected_output def test_single_entry_set_and_sum(): n = 2 queries = [ \\"1 1 1 5\\", \\"3 1 1 1 1\\" ] expected_output = [5] assert process_queries(n, queries) == expected_output def test_row_increment_and_sum(): n = 2 queries = [ \\"1 1 1 3\\", \\"2 1 2\\", \\"3 1 1 2 2\\" ] expected_output = [7] assert process_queries(n, queries) == expected_output def test_submatrix_sum(): n = 3 queries = [ \\"1 1 1 1\\", \\"1 1 2 1\\", \\"1 1 3 1\\", \\"3 1 1 1 3\\" ] expected_output = [3] assert process_queries(n, queries) == expected_output","solution":"class Matrix: def __init__(self, n): self.n = n self.matrix = [[0] * n for _ in range(n)] self.row_adds = [0] * n def process_query(self, query): parts = list(map(int, query.split())) type_query = parts[0] if type_query == 1: _, row, column, value = parts self.matrix[row-1][column-1] = value - self.row_adds[row-1] elif type_query == 2: _, row, increment = parts self.row_adds[row-1] += increment elif type_query == 3: _, row1, column1, row2, column2 = parts sum_value = 0 for r in range(row1-1, row2): for c in range(column1-1, column2): sum_value += self.matrix[r][c] + self.row_adds[r] return sum_value def process_queries(n, queries): matrix = Matrix(n) results = [] for query in queries: result = matrix.process_query(query) if result is not None: results.append(result) return results"},{"question":"def max_bravery_scores(n: int, bravery_scores: List[int], q: int, queries: List[Tuple[int, int]]) -> List[int]: Returns the maximum bravery score for each query range. :param n: number of warriors :param bravery_scores: a list of integers representing bravery scores :param q: number of queries :param queries: a list of tuples, each containing two integers (li, ri) :return: a list of integers representing the maximum bravery scores for each query range >>> max_bravery_scores(5, [3, 6, 1, 5, 9], 3, [(1, 3), (2, 5), (4, 4)]) [6, 9, 5] >>> max_bravery_scores(5, [3, 6, 1, 5, 9], 1, [(3, 3)]) [1] >>> max_bravery_scores(5, [3, 6, 1, 5, 9], 1, [(1, 5)]) [9] >>> max_bravery_scores(5, [2, 2, 2, 2, 2], 2, [(1, 3), (3, 5)]) [2, 2] >>> max_bravery_scores(5, [7, 8, 9, 10, 6], 3, [(1, 1), (5, 5), (4, 4)]) [7, 6, 10]","solution":"def max_bravery_scores(n, bravery_scores, q, queries): Returns the maximum bravery score for each query range. :param n: number of warriors :param bravery_scores: a list of integers representing bravery scores :param q: number of queries :param queries: a list of tuples, each containing two integers (li, ri) :return: a list of integers representing the maximum bravery scores for each query range results = [] for li, ri in queries: results.append(max(bravery_scores[li-1:ri])) return results"},{"question":"def calculate_shipping_cost(weight: int, length: int, width: int, height: int) -> int: Calculate the total shipping cost based on weight and dimensions of the package. >>> calculate_shipping_cost(10, 50, 50, 50) 25 >>> calculate_shipping_cost(20, 200, 50, 30) 55 >>> calculate_shipping_cost(5, 110, 90, 80) 25 >>> calculate_shipping_cost(0, 50, 50, 50) 5 >>> calculate_shipping_cost(0, 105, 50, 50) 15 >>> calculate_shipping_cost(50, 50, 50, 50) 105 >>> calculate_shipping_cost(0, 100, 100, 1) 15 >>> calculate_shipping_cost(50, 101, 50, 50) 115","solution":"def calculate_shipping_cost(weight, length, width, height): Calculate the total shipping cost based on weight and dimensions of the package. base_cost = 5 additional_cost_per_kg = 2 oversized_surcharge = 10 additional_cost = weight * additional_cost_per_kg oversized = length > 100 or width > 100 or height > 100 or (length + width + height) > 200 total_cost = base_cost + additional_cost if oversized: total_cost += oversized_surcharge return total_cost if __name__ == \\"__main__\\": import sys input = sys.stdin.read().strip() weight, length, width, height = map(int, input.split()) print(calculate_shipping_cost(weight, length, width, height))"},{"question":"def smallest_subsegment_with_sum(arr, S): Returns the length of the smallest subsegment with sum greater than or equal to S. If no such subsegment exists, returns -1. >>> smallest_subsegment_with_sum([1, 2, 3, 4, 5, 6, 7, 8], 15) == 2 >>> smallest_subsegment_with_sum([5, 1, 4, 3, 2], 10) == 3 >>> smallest_subsegment_with_sum([1, 2, 3], 10) == -1 >>> smallest_subsegment_with_sum([10, -1, 3, 2, 1], 10) == 1 >>> smallest_subsegment_with_sum([1, 1, 1, 1, 1], 5) == 5 >>> smallest_subsegment_with_sum([-1, -1, 2, 3, 1], 4) == 2 >>> smallest_subsegment_with_sum([10**9, -10**9, 10**9, 10**9], 10**9) == 1","solution":"def smallest_subsegment_with_sum(arr, S): Returns the length of the smallest subsegment with sum greater than or equal to S. If no such subsegment exists, returns -1. n = len(arr) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= S: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def calculate_total_price(n: int, prices: List[int]) -> float: Calculate the total price after applying discounts based on the total purchase amount. Args: n (int): Number of components purchased. prices (list of ints): List of prices of each component. Returns: float: The total price after applying the discount, rounded to 2 decimal places.","solution":"def calculate_total_price(n, prices): Calculate the total price after applying discounts based on the total purchase amount. Args: n (int): Number of components purchased. prices (list of ints): List of prices of each component. Returns: float: The total price after applying the discount, rounded to 2 decimal places. total = sum(prices) if total < 1000: discount = 0 elif 1000 <= total < 5000: discount = 0.10 elif 5000 <= total < 10000: discount = 0.15 else: discount = 0.20 discounted_total = total * (1 - discount) return round(discounted_total, 2)"},{"question":"def highest_sales(N: int, records: List[str], Q: int, queries: List[str]) -> List[int]: Determines the highest number of units sold in a single day for each platform given the sales records and queries. :param N: int, the number of sales records :param records: list of strings, each in the format \\"date platform units_sold\\" :param Q: int, the number of queries :param queries: list of strings, each representing a platform name :return: list of int, the highest number of units sold for each platform requested in the queries pass # Your code here def test_highest_sales(): records = [ \\"2023-01-10 Amazon 100\\", \\"2023-01-15 eBay 150\\", \\"2023-01-15 Amazon 90\\", \\"2023-01-15 Walmart 200\\", \\"2023-01-20 Amazon 300\\" ] queries = [\\"Amazon\\", \\"eBay\\", \\"Walmart\\"] expected_results = [300, 150, 200] assert highest_sales(5, records, 3, queries) == expected_results def test_highest_sales_no_records(): records = [] queries = [\\"Amazon\\", \\"eBay\\", \\"Walmart\\"] expected_results = [-1, -1, -1] assert highest_sales(0, records, 3, queries) == expected_results def test_highest_sales_some_platforms(): records = [ \\"2023-01-10 Amazon 100\\", \\"2023-01-15 eBay 150\\" ] queries = [\\"Amazon\\", \\"eBay\\", \\"Walmart\\"] expected_results = [100, 150, -1] assert highest_sales(2, records, 3, queries) == expected_results def test_highest_sales_multiple_updates(): records = [ \\"2023-01-10 Amazon 100\\", \\"2023-01-12 Amazon 200\\", \\"2023-01-15 Amazon 150\\" ] queries = [\\"Amazon\\"] expected_results = [200] assert highest_sales(3, records, 1, queries) == expected_results def test_highest_sales_different_dates_same_platform(): records = [ \\"2023-01-10 Amazon 100\\", \\"2023-01-10 Amazon 200\\" # Same date, different sale amount ] queries = [\\"Amazon\\"] expected_results = [200] assert highest_sales(2, records, 1, queries) == expected_results","solution":"def highest_sales(N, records, Q, queries): Determines the highest number of units sold in a single day for each platform given the sales records and queries. :param N: int, the number of sales records :param records: list of strings, each in the format \\"date platform units_sold\\" :param Q: int, the number of queries :param queries: list of strings, each representing a platform name :return: list of int, the highest number of units sold for each platform requested in the queries sales_dict = {} # Process each sales record and update the sales dictionary for record in records: date, platform, units_sold = record.split() units_sold = int(units_sold) if platform not in sales_dict: sales_dict[platform] = units_sold else: sales_dict[platform] = max(sales_dict[platform], units_sold) # Answer each query based on the sales dictionary results = [] for query in queries: if query in sales_dict: results.append(sales_dict[query]) else: results.append(-1) return results"},{"question":"from typing import List def find_unique_number(arr: List[int]) -> int: Returns the integer that occurs only once in the list where every other integer occurs twice. >>> find_unique_number([1]) 1 >>> find_unique_number([1, 2, 3, 4, 5, 2, 3, 4, 1]) 5 >>> find_unique_number([10, 5, 3, 10, 3, 11, 11]) 5 >>> large_list = [x for x in range(1, 100001)] * 2 >>> large_list.append(999999) >>> find_unique_number(large_list) 999999 >>> find_unique_number([5, 1, 1, 2, 2, 3, 3, 5, 4, 4, 6, 6, 7, 7, 8, 8, 9, 9, 0]) 0","solution":"def find_unique_number(arr): Returns the integer that occurs only once in the list where every other integer occurs twice. :param arr: List of integers :return: The integer that occurs only once unique_num = 0 for num in arr: unique_num ^= num return unique_num"},{"question":"def is_valid_sequence(sequence: str) -> str: Determine if the sequence of movements is valid, returning 'YES' if valid and 'NO' otherwise. A sequence is considered valid if the movements ultimately return you to the starting point. This means that the number of 'L' movements should be equal to the number of 'R' movements, and the number of 'U' movements should be equal to the number of 'D' movements. Parameters: sequence (str): A string consisting of the characters 'L', 'R', 'U', and 'D'. Returns: str: 'YES' if the sequence is valid, 'NO' otherwise. >>> is_valid_sequence('LR') 'YES' >>> is_valid_sequence('LLRR') 'YES' >>> is_valid_sequence('LURD') 'YES' >>> is_valid_sequence('LLUURR') 'NO'","solution":"def is_valid_sequence(sequence): Determine if the sequence of movements is valid, returning 'YES' if valid and 'NO' otherwise. Parameters: sequence (str): A string consisting of the characters 'L', 'R', 'U', and 'D'. Returns: str: 'YES' if the sequence is valid, 'NO' otherwise. left_count = sequence.count('L') right_count = sequence.count('R') up_count = sequence.count('U') down_count = sequence.count('D') if left_count == right_count and up_count == down_count: return 'YES' else: return 'NO'"},{"question":"def is_almost_palindrome(s: str) -> bool: Determine whether the string can be converted into a palindrome by removing at most one character. >>> is_almost_palindrome(\\"abca\\") True >>> is_almost_palindrome(\\"racecar\\") True >>> is_almost_palindrome(\\"abc\\") False >>> is_almost_palindrome(\\"abcdba\\") True >>> is_almost_palindrome(\\"\\") True >>> is_almost_palindrome(\\"a\\") True >>> is_almost_palindrome(\\"abba\\") True >>> is_almost_palindrome(\\"abccab\\") False pass","solution":"def is_almost_palindrome(s): Determine whether the string can be converted into a palindrome by removing at most one character. def is_palindrome_range(s, left, right): while left < right: if s[left] != s[right]: return False left += 1 right -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return is_palindrome_range(s, left+1, right) or is_palindrome_range(s, left, right-1) left += 1 right -= 1 return True"},{"question":"def num_decodings(s: str) -> int: Calculate the number of ways to decode a given string s using the provided mapping. >>> num_decodings(\\"1\\") 1 >>> num_decodings(\\"9\\") 1 >>> num_decodings(\\"0\\") 0 >>> num_decodings(\\"10\\") 1 >>> num_decodings(\\"12\\") 2 >>> num_decodings(\\"123\\") 3 >>> num_decodings(\\"226\\") 3 >>> num_decodings(\\"2101\\") 1 >>> num_decodings(\\"111\\") 3 >>> num_decodings(\\"1111\\") 5 >>> num_decodings(\\"2611055971756562\\") 4 >>> num_decodings(\\"1010101010\\") 1 >>> num_decodings(\\"1111111111\\") 89","solution":"def num_decodings(s): Calculate the number of ways to decode a given string s using the provided mapping. if not s or s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 # base case: empty string dp[1] = 1 # base case: non-0 single char for i in range(2, n + 1): single_digit = int(s[i-1:i]) double_digit = int(s[i-2:i]) if 1 <= single_digit <= 9: dp[i] += dp[i-1] if 10 <= double_digit <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"def find_longest_path(N, K, edges): Find the length of the longest path in a binary tree with N nodes such that the sum of the values of the nodes in this path is less than or equal to K. Args: N (int): The number of nodes in the tree. K (int): The maximum allowable sum of node values in the path. edges (List[Tuple[int, int]]): The edges of the tree. Returns: int: The length of the longest path with the sum of node values ≤ K. >>> find_longest_path(5, 7, [(1, 2), (1, 3), (2, 4), (2, 5)]) 3 >>> find_longest_path(4, 4, [(1, 2), (1, 3), (3, 4)]) 2 def parse_input(input_list): Parses the input data into the respective variables N, K, and edges. Args: input_list (List[str]): The list of strings representing the input data. Returns: int: The number of nodes N. int: The maximum allowable sum K. List[Tuple[int, int]]: The edges of the tree. >>> parse_input([\\"5 7\\", \\"1 2\\", \\"1 3\\", \\"2 4\\", \\"2 5\\"]) (5, 7, [(1, 2), (1, 3), (2, 4), (2, 5)]) >>> parse_input([\\"4 4\\", \\"1 2\\", \\"1 3\\", \\"3 4\\"]) (4, 4, [(1, 2), (1, 3), (3, 4)]) # Unit Tests def test_example_1(): input_data = [ \\"5 7\\", \\"1 2\\", \\"1 3\\", \\"2 4\\", \\"2 5\\" ] N, K, edges = parse_input(input_data) assert find_longest_path(N, K, edges) == 3 def test_example_2(): input_data = [ \\"4 4\\", \\"1 2\\", \\"1 3\\", \\"3 4\\" ] N, K, edges = parse_input(input_data) assert find_longest_path(N, K, edges) == 2 def test_single_node(): input_data = [\\"1 1\\"] N, K, edges = parse_input(input_data) assert find_longest_path(N, K, edges) == 1 def test_all_paths_too_long(): input_data = [ \\"4 1\\", \\"1 2\\", \\"1 3\\", \\"3 4\\" ] N, K, edges = parse_input(input_data) assert find_longest_path(N, K, edges) == 1","solution":"from collections import defaultdict def find_longest_path(N, K, edges): graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) def dfs(node, parent, current_sum): if current_sum > K: return 0 max_path = 0 for neighbor in graph[node]: if neighbor != parent: max_path = max(max_path, dfs(neighbor, node, current_sum + neighbor)) return 1 + max_path longest_path_length = 0 for i in range(1, N+1): longest_path_length = max(longest_path_length, dfs(i, -1, i)) return longest_path_length # Function to parse input def parse_input(input_list): N, K = map(int, input_list[0].split()) edges = [tuple(map(int, line.split())) for line in input_list[1:]] return N, K, edges"},{"question":"def stable_sort_segments(T: int, test_cases: list) -> list: Sort the list of integers in non-decreasing order while maintaining the constraints. Args: T: int - The number of test cases. test_cases: list - A list of tuples, where each tuple contains an integer N (the number of integers) and a list of integers. Returns: list: A list of strings where each string contains the sorted integers in non-decreasing order while maintaining the original relative order of duplicates. Examples: >>> stable_sort_segments(1, [(5, [4, 3, 2, 1, 0])]) [\\"0 1 2 3 4\\"] >>> stable_sort_segments(1, [(7, [1, 2, 2, 3, 3, 1, 4])]) [\\"1 1 2 2 3 3 4\\"]","solution":"def stable_sort_segments(T, test_cases): results = [] for case_idx in range(T): N = test_cases[case_idx][0] array = test_cases[case_idx][1] # Use stable sorting algorithm (Python's built-in sort is stable) sorted_array = sorted(array) # Append the result in the required format results.append(\\" \\".join(map(str, sorted_array))) return results"},{"question":"def final_coordinates(moves): Calculate the final coordinates after a series of moves. Args: moves (str): A string representing movements, where each character is one of 'N', 'S', 'E', 'W'. Returns: tuple: The final coordinates (x, y) after executing all the moves. pass # Test Cases def test_final_coordinates_example1(): assert final_coordinates('NNEESSWW') == (0, 0) def test_final_coordinates_example2(): assert final_coordinates('NNNWWW') == (-3, 3) def test_final_coordinates_example3(): assert final_coordinates('ESES') == (2, -2) def test_final_coordinates_moves_in_all_directions(): assert final_coordinates('NNSS') == (0, 0) assert final_coordinates('EEWW') == (0, 0) def test_final_coordinates_only_north(): assert final_coordinates('NNN') == (0, 3) def test_final_coordinates_only_south(): assert final_coordinates('SSS') == (0, -3) def test_final_coordinates_only_east(): assert final_coordinates('EEE') == (3, 0) def test_final_coordinates_only_west(): assert final_coordinates('WWW') == (-3, 0)","solution":"def final_coordinates(moves): Calculate the final coordinates after a series of moves. Args: moves (str): A string representing movements, where each character is one of 'N', 'S', 'E', 'W'. Returns: tuple: The final coordinates (x, y) after executing all the moves. x, y = 0, 0 for move in moves: if move == 'N': y += 1 elif move == 'S': y -= 1 elif move == 'E': x += 1 elif move == 'W': x -= 1 return x, y"},{"question":"def process_datasets(input_text: str) -> List[int]: Given an input string representing multiple datasets, each dataset containing the number of hills and their heights, this function returns a list of integers representing the minimum possible difference in height between the tallest hill and the shortest hill after any number of operations for each dataset. Args: input_text (str): A string with datasets. Each dataset starts with an integer N, followed by N integers representing the heights. Returns: List[int]: A list of integers showing the minimum possible height differences for each dataset. Examples: >>> process_datasets(\\"5n1 5 9 2 8n4n4 7 2 9n0n\\") [0, 0] >>> process_datasets(\\"1n10n0n\\") [0] >>> process_datasets(\\"3n6 6 6n0n\\") [0] pass","solution":"def min_height_difference(datasets): Given a list of datasets, each representing the heights of hills, return a list of integers where each integer represents the minimum possible difference in height between the tallest hill and the shortest hill after any number of operations for each dataset. results = [] for data in datasets: heights = data['heights'] min_height = min(heights) max_height = min(heights) # The minimum possible difference is 0 results.append(max_height - min_height) return results def parse_input(input_text): Parses the input text and returns structured data. Parameters: - input_text: A string of the input. Returns: A list of dictionaries with 'n' and 'heights' keys. lines = input_text.strip().split(\\"n\\") datasets = [] i = 0 while i < len(lines): n = int(lines[i]) if n == 0: break heights = list(map(int, lines[i + 1].split())) datasets.append({'n': n, 'heights': heights}) i += 2 return datasets def process_datasets(input_text): datasets = parse_input(input_text) return min_height_difference(datasets)"},{"question":"import heapq from collections import defaultdict from typing import List, Tuple def shortest_travel_time(datasets: List[Tuple[int, int, int, int, int, List[Tuple[int, int, int]], List[Tuple[int, int, int]]]]) -> List[int]: Determine the shortest possible travel time from a given starting junction to a destination junction. considering both the travel times on the edges and the time-saving but energy-consuming instant tunnels. >>> input_str = \\"5 6 2n1 5n1 2 10n2 3 15n3 4 10n4 5 5n1 3 25n3 5 10n1 4 10n2 5 10n0n\\" >>> datasets = parse_input(input_str) >>> shortest_travel_time(datasets) [20] >>> input_str = \\"4 4 1n1 4n1 2 5n2 3 10n3 4 5n1 3 15n1 4 2n0n\\" >>> datasets = parse_input(input_str) >>> shortest_travel_time(datasets) [2] >>> input_str = \\"5 7 0n1 5n1 2 3n1 3 8n2 3 2n2 4 5n3 4 1n4 5 4n1 4 2n0n\\" >>> datasets = parse_input(input_str) >>> shortest_travel_time(datasets) [6] pass def parse_input(input_str: str) -> List[Tuple[int, int, int, int, int, List[Tuple[int, int, int]], List[Tuple[int, int, int]]]]: Parses the input string to extract datasets. >>> input_str = \\"5 6 2n1 5n1 2 10n2 3 15n3 4 10n4 5 5n1 3 25n3 5 10n1 4 10n2 5 10n0n\\" >>> parse_input(input_str) [(5, 6, 2, 1, 5, [(1, 2, 10), (2, 3, 15), (3, 4, 10), (4, 5, 5), (1, 3, 25), (3, 5, 10)], [(1, 4, 10), (2, 5, 10)])] pass def main(input_str: str): datasets = parse_input(input_str) results = shortest_travel_time(datasets) for result in results: print(result) def test_shortest_travel_time(): input_str = \\"5 6 2n1 5n1 2 10n2 3 15n3 4 10n4 5 5n1 3 25n3 5 10n1 4 10n2 5 10n0n\\" expected_output = [20] datasets = parse_input(input_str) result = shortest_travel_time(datasets) assert result == expected_output input_str = \\"4 4 1n1 4n1 2 5n2 3 10n3 4 5n1 3 15n1 4 2n0n\\" expected_output = [2] datasets = parse_input(input_str) result = shortest_travel_time(datasets) assert result == expected_output input_str = \\"5 7 0n1 5n1 2 3n1 3 8n2 3 2n2 4 5n3 4 1n4 5 4n1 4 2n0n\\" expected_output = [6] datasets = parse_input(input_str) result = shortest_travel_time(datasets) assert result == expected_output if __name__ == \\"__main__\\": test_shortest_travel_time()","solution":"import heapq from collections import defaultdict def shortest_travel_time(datasets): results = [] def dijkstra(graph, start, N): dist = [float('inf')] * (N + 1) dist[start] = 0 pq = [(0, start)] # (distance, node) while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > dist[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return dist for dataset in datasets: N, M, Q, s, d, edges, tunnels = dataset graph = defaultdict(list) for u, v, t in edges: graph[u].append((v, t)) dist = dijkstra(graph, s, N) for q, r, e in tunnels: if dist[q] + e < dist[r]: dist[r] = dist[q] + e results.append(dist[d]) return results def parse_input(input_str): lines = input_str.split('n') datasets = [] i = 0 while i < len(lines): line = lines[i].strip() if line == \\"0\\": break if not line: i += 1 continue N, M, Q = map(int, line.split()) i += 1 s, d = map(int, lines[i].strip().split()) i += 1 edges = [] for _ in range(M): u, v, t = map(int, lines[i].strip().split()) edges.append((u, v, t)) i += 1 tunnels = [] for _ in range(Q): q, r, e = map(int, lines[i].strip().split()) tunnels.append((q, r, e)) i += 1 datasets.append((N, M, Q, s, d, edges, tunnels)) return datasets def main(input_str): datasets = parse_input(input_str) results = shortest_travel_time(datasets) for result in results: print(result)"},{"question":"def highest_tax(R: int, C: int, matrix: List[List[int]]) -> int: Given a matrix of resources, returns the highest possible tax paid by a citizen, which is equivalent to the highest value in any contiguous submatrix. >>> highest_tax(2, 3, [ ... [1, 2, 3], ... [4, 5, 6] ... ]) == 6 >>> highest_tax(3, 3, [ ... [1, 3, 2], ... [6, 7, 8], ... [4, 5, 9] ... ]) == 9 >>> highest_tax(1, 4, [ ... [2, 4, 6, 8] ... ]) == 8","solution":"def highest_tax(R, C, matrix): Given a matrix of resources, returns the highest possible tax paid by a citizen, which is equivalent to the highest value in any contiguous submatrix. # Initialize the highest value found highest_value = -1 # Iterate through the entire matrix to find the maximum value for row in matrix: highest_value = max(highest_value, max(row)) return highest_value"},{"question":"from typing import List, Tuple def max_score_difference(test_cases: List[Tuple[int, List[Tuple[int, ...]]]]) -> List[List[int]]: Identify the maximum score difference for each student between any two of their problem attempts. Args: test_cases (List[Tuple[int, List[Tuple[int, ...]]]]): A list of test cases. Each test case consists of an integer n representing the total number of students, followed by n tuples. Each tuple contains an integer k and k integers representing the scores of each problem attempt. Returns: List[List[int]]: For each test case, returns a list where each element is the maximum score difference for the corresponding student. If a student has less than two problem attempts, returns -1 for that student. Example: >>> test_cases = [ (2, [ (3, 10, 20, 15), (2, 5, 5) ]), (3, [ (4, 30, 10, 5, 25), (3, 5, 5, 5), (1, 100) ]) ] >>> max_score_difference(test_cases) [[10, 0], [25, 0, -1]] # Include the following test cases in your test suite to verify the solution # test_example_case_1: # >>> test_cases = [ (2, [(3, 10, 20, 15), (2, 5, 5)]) ] # >>> max_score_difference(test_cases) # [[10, 0]] # test_example_case_2: # >>> test_cases = [ (3, [(4, 30, 10, 5, 25), (3, 5, 5, 5), (1, 100)]) ] # >>> max_score_difference(test_cases) # [[25, 0, -1]] # test_single_student_multiple_attempts: # >>> test_cases = [ (1, [(5, 10, 15, 20, 25, 30)]) ] # >>> max_score_difference(test_cases) # [[20]] # test_multiple_students_one_attempt_each: # >>> test_cases = [ (3, [(1, 10), (1, 20), (1, 30)]) ] # >>> max_score_difference(test_cases) # [[-1, -1, -1]] # test_students_with_varied_scores: # >>> test_cases = [ (2, [(5, 10, 40, 30, 20, 50), (3, 5, 10, 15)]) ] # >>> max_score_difference(test_cases) # [[40, 10]]","solution":"def max_score_difference(test_cases): results = [] for case in test_cases: n, students_data = case case_result = [] for student_data in students_data: k, scores = student_data[0], student_data[1:] if k < 2: case_result.append(-1) else: max_difference = max(scores) - min(scores) case_result.append(max_difference) results.append(case_result) return results"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Determine the length of the longest palindromic subsequence in a given string. >>> longest_palindromic_subsequence(\\"abca\\") 3 >>> longest_palindromic_subsequence(\\"abcba\\") 5 >>> longest_palindromic_subsequence(\\"abcdef\\") 1 def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Process multiple test cases to find the longest palindromic subsequence for each. >>> process_test_cases(3, [\\"abca\\", \\"abcba\\", \\"abcdef\\"]) [3, 5, 1] >>> process_test_cases(2, [\\"a\\", \\"aa\\"]) [1, 2] from typing import List # Unit Tests def test_longest_palindromic_subsequence(): assert longest_palindromic_subsequence(\\"abca\\") == 3 assert longest_palindromic_subsequence(\\"abcba\\") == 5 assert longest_palindromic_subsequence(\\"abcdef\\") == 1 assert longest_palindromic_subsequence(\\"a\\") == 1 assert longest_palindromic_subsequence(\\"aa\\") == 2 assert longest_palindromic_subsequence(\\"ab\\") == 1 assert longest_palindromic_subsequence(\\"abb\\") == 2 assert longest_palindromic_subsequence(\\"aabaa\\") == 5 def test_process_test_cases(): T = 3 test_cases = [\\"abca\\", \\"abcba\\", \\"abcdef\\"] assert process_test_cases(T, test_cases) == [3, 5, 1] T = 2 test_cases = [\\"a\\", \\"aa\\"] assert process_test_cases(T, test_cases) == [1, 2] T = 4 test_cases = [\\"abba\\", \\"racecar\\", \\"abc\\", \\"xyz\\"] assert process_test_cases(T, test_cases) == [4, 7, 1, 1]","solution":"def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] def process_test_cases(T, test_cases): results = [] for s in test_cases: results.append(longest_palindromic_subsequence(s)) return results"},{"question":"def schedule_tasks(num_tasks: int, tasks: List[Tuple[int, int]]) -> List[int]: Determines the order in which to complete the tasks based on their priorities and deadlines. Parameters: num_tasks (int): Number of tasks. tasks (list of tuples): Each tuple contains two integers - priority and deadline of the task. Returns: list: Task indices in the order they should be completed. from typing import List, Tuple def test_schedule_tasks_case_1(): assert schedule_tasks(3, [(2, 5), (1, 2), (2, 1)]) == [3, 1, 2] def test_schedule_tasks_case_2(): assert schedule_tasks(4, [(3, 10), (1, 5), (2, 7), (3, 3)]) == [4, 1, 3, 2] def test_schedule_tasks_equal_priorities(): assert schedule_tasks(3, [(1, 3), (1, 2), (1, 1)]) == [3, 2, 1] def test_schedule_tasks_single_task(): assert schedule_tasks(1, [(5, 10)]) == [1] def test_schedule_tasks_all_equal(): assert schedule_tasks(5, [(3, 3), (3, 3), (3, 3), (3, 3), (3, 3)]) == [1, 2, 3, 4, 5] def test_schedule_tasks_different_priorities(): assert schedule_tasks(3, [(3, 1), (2, 2), (1, 3)]) == [1, 2, 3] def test_schedule_tasks_different_deadlines(): assert schedule_tasks(2, [(2, 2), (2, 1)]) == [2, 1]","solution":"def schedule_tasks(num_tasks, tasks): Determines the order in which to complete the tasks based on their priorities and deadlines. Parameters: num_tasks (int): Number of tasks. tasks (list of tuples): Each tuple contains two integers - priority and deadline of the task. Returns: list: Task indices in the order they should be completed. # Create a list of tasks with their indices to keep track of the original positions indexed_tasks = [(i + 1, tasks[i][0], tasks[i][1]) for i in range(num_tasks)] # Sort the tasks firstly by priority (descending), and if equal, by deadline (ascending) indexed_tasks.sort(key=lambda x: (-x[1], x[2])) # Extract the task indices in the required order ordered_indices = [task[0] for task in indexed_tasks] return ordered_indices"},{"question":"def smallest_lexicographic_permutation(s: str) -> str: Returns the lexicographically smallest permutation of the string. >>> smallest_lexicographic_permutation(\\"baedc\\") \\"abcde\\" >>> smallest_lexicographic_permutation(\\"geeks\\") \\"eegks\\"","solution":"def smallest_lexicographic_permutation(s): Returns the lexicographically smallest permutation of the string. return ''.join(sorted(s))"},{"question":"def min_operations_to_transform(S: str, T: str) -> int: Returns the minimum number of operations required to transform string S into string T. Arguments: S -- the initial string T -- the target string Returns: int -- the minimum number of operations required Example: >>> min_operations_to_transform('abcde', 'abzde') 1 >>> min_operations_to_transform('aaaa', 'bbbb') 4 >>> min_operations_to_transform('xyz', 'xyz') 0 >>> min_operations_to_transform('abcdef', 'fedcba') 6","solution":"def min_operations_to_transform(S, T): Returns the minimum number of operations required to transform string S into string T. if len(S) != len(T): raise ValueError(\\"Strings S and T must be of the same length\\") operations = sum(1 for s, t in zip(S, T) if s != t) return operations"},{"question":"def max_fan_engagement_hours(n: int, schedule: List[List[int]]) -> int: Returns the maximum number of hours Miku can spend on fan engagement sessions over the entire month given the number of days and the schedule of events for each day. >>> max_fan_engagement_hours(4, [[3, 3, 4, 5], [2, 2, 9], [0], [1, 10]]) == 12 + 13 + 24 + 14 >>> max_fan_engagement_hours(3, [[2, 8, 8], [1, 6], [0]]) == 8 + 18 + 24 >>> max_fan_engagement_hours(2, [[3, 6, 6, 6], [0]]) == 6 + 24 >>> max_fan_engagement_hours(1, [[0]]) == 24 >>> max_fan_engagement_hours(1, [[3, 4, 4, 4]]) == 12","solution":"def max_fan_engagement_hours(n, schedule): Returns the maximum number of hours Miku can spend on fan engagement sessions over the entire month given the number of days and the schedule of events for each day. total_hours = 0 for day in schedule: m = day[0] if m == 0: total_hours += 24 else: total_event_hours = sum(day[1:m+1]) total_hours += (24 - total_event_hours) return total_hours"},{"question":"def min_replacements_to_palindrome(s: str) -> int: Returns the minimum number of character replacements needed to convert the given string into a palindrome. >>> min_replacements_to_palindrome(\\"abca\\") 1 >>> min_replacements_to_palindrome(\\"abcde\\") 2 >>> min_replacements_to_palindrome(\\"racecar\\") 0","solution":"def min_replacements_to_palindrome(s): Returns the minimum number of character replacements needed to convert the given string into a palindrome. n = len(s) replacements = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: replacements += 1 return replacements"},{"question":"def total_distance_run(number_of_days: int, distances: List[int]) -> int: Calculates the total distance run over the given period. Parameters: number_of_days (int): The number of days Peter ran. distances (list): A list of integers representing the distance run each day. Returns: int: The total distance run. if __name__ == \\"__main__\\": number_of_days = int(input().strip()) distances = list(map(int, input().strip().split())) print(total_distance_run(number_of_days, distances))","solution":"def total_distance_run(number_of_days, distances): Calculates the total distance run over the given period. Parameters: number_of_days (int): The number of days Peter ran. distances (list): A list of integers representing the distance run each day. Returns: int: The total distance run. return sum(distances) if __name__ == \\"__main__\\": number_of_days = int(input().strip()) distances = list(map(int, input().strip().split())) print(total_distance_run(number_of_days, distances))"},{"question":"class VendingMachine: def __init__(self, n, slots): self.n = n self.slots = slots self.coins_inserted = 0 self.cost_per_item = 50 self.accepted_coins = [1, 5, 10, 25] def insert_coin(self, coin): Accepts a coin. The machine only accepts coins of denomination 1, 5, 10, 25. pass def select_slot(self, slot): Dispenses an item from the given slot if the user has inserted enough coins. If the item is dispensed, the cost of the item is deducted from the total amount of coins inserted. If the slot is empty or there are insufficient coins, the appropriate message is shown. pass def check_amount(self): Displays the total amount of coins inserted so far. pass def cancel(self): Returns all inserted coins to the user and resets the machine. pass def main(commands): Simulates the vending machine operation based on the provided commands. Commands: - INSERT coin - SELECT slot - CHECK amount - CANCEL n = commands[0] slots = [int(x) for x in commands[1:n+1]] vm = VendingMachine(n, slots) for cmd in commands[n+1:]: parts = cmd.split() action = parts[0] if action == \\"INSERT\\": coin = int(parts[1]) vm.insert_coin(coin) elif action == \\"SELECT\\": slot = int(parts[1]) vm.select_slot(slot) elif action == \\"CHECK\\": vm.check_amount() elif action == \\"CANCEL\\": vm.cancel() break # Sample unit tests def test_insert_coin(): vm = VendingMachine(1, [10]) vm.insert_coin(25) assert vm.coins_inserted == 25 vm.insert_coin(10) assert vm.coins_inserted == 35 vm.insert_coin(1) assert vm.coins_inserted == 36 vm.insert_coin(100) assert vm.coins_inserted == 36 # 100 is not an accepted coin def test_select_slot_insufficient_coins(): vm = VendingMachine(1, [10]) vm.insert_coin(25) vm.select_slot(1) assert vm.coins_inserted == 25 assert vm.slots[0] == 10 # no item dispensed def test_select_slot(): vm = VendingMachine(1, [10]) vm.insert_coin(25) vm.insert_coin(25) vm.select_slot(1) assert vm.coins_inserted == 0 assert vm.slots[0] == 9 # item dispensed def test_select_slot_empty(): vm = VendingMachine(1, [0]) vm.insert_coin(25) vm.insert_coin(25) vm.select_slot(1) assert vm.coins_inserted == 50 assert vm.slots[0] == 0 # no item dispensed def test_check_amount(): vm = VendingMachine(1, [10]) vm.insert_coin(10) vm.insert_coin(5) vm.check_amount() def test_cancel(): vm = VendingMachine(1, [10]) vm.insert_coin(25) vm.insert_coin(10) vm.cancel() assert vm.coins_inserted == 0 def test_main_commands(): commands = [ 3, 10, 5, 2, \\"INSERT 25\\", \\"INSERT 25\\", \\"SELECT 1\\", \\"INSERT 10\\", \\"SELECT 2\\", \\"CHECK amount\\", \\"CANCEL\\" ] expected_output = [ \\"1 item dispensed from slot 1\\", # after SELECT 1 \\"Insufficient coins, item not dispensed\\", # after SELECT 2 \\"Total amount: 10\\", # after CHECK amount \\"Coins returned: 10\\" # after CANCEL ] main(commands)","solution":"class VendingMachine: def __init__(self, n, slots): self.n = n self.slots = slots self.coins_inserted = 0 self.cost_per_item = 50 self.accepted_coins = [1, 5, 10, 25] def insert_coin(self, coin): if coin in self.accepted_coins: self.coins_inserted += coin else: print(f\\"Coin {coin} not accepted\\") def select_slot(self, slot): if slot < 1 or slot > self.n: print(f\\"Invalid slot {slot}\\") return if self.coins_inserted >= self.cost_per_item: if self.slots[slot-1] > 0: self.slots[slot-1] -= 1 self.coins_inserted -= self.cost_per_item print(f\\"1 item dispensed from slot {slot}\\") else: print(\\"Slot empty, item not dispensed\\") else: print(\\"Insufficient coins, item not dispensed\\") def check_amount(self): print(f\\"Total amount: {self.coins_inserted}\\") def cancel(self): print(f\\"Coins returned: {self.coins_inserted}\\") self.coins_inserted = 0 def main(commands): n = commands[0] slots = [int(x) for x in commands[1:n+1]] vm = VendingMachine(n, slots) for cmd in commands[n+1:]: parts = cmd.split() action = parts[0] if action == \\"INSERT\\": coin = int(parts[1]) vm.insert_coin(coin) elif action == \\"SELECT\\": slot = int(parts[1]) vm.select_slot(slot) elif action == \\"CHECK\\": vm.check_amount() elif action == \\"CANCEL\\": vm.cancel() break"},{"question":"def plant_state(n: int, k: int, m: int, xi: int, yi: int) -> str: Determine the state of a specific cell after n seconds. :param n: Number of seconds that have passed (0 ≤ n ≤ 100) :param k: Exact number of neighbors needed for a cell to split (1 ≤ k ≤ 4) :param m: Maximum number of neighbors a cell can have before it dies (k ≤ m ≤ 4) :param xi: x coordinate of the query cell (-10^9 ≤ xi ≤ 10^9) :param yi: y coordinate of the query cell (-10^9 ≤ yi ≤ 10^9) :return: \\"ALIVE\\" if the cell (xi, yi) is alive after n seconds, otherwise \\"DEAD\\" >>> plant_state(0, 2, 4, 0, 0) \\"ALIVE\\" >>> plant_state(0, 2, 4, 1, 0) \\"DEAD\\" >>> plant_state(3, 2, 4, 1, 0) \\"ALIVE\\" >>> plant_state(3, 2, 4, 2, 2) \\"DEAD\\" >>> plant_state(3, 2, 4, 4, 0) \\"DEAD\\" >>> plant_state(3, 2, 4, 0, 5) \\"DEAD\\" >>> plant_state(3, 2, 4, 1, 1) \\"DEAD\\" >>> plant_state(4, 2, 4, 1, 1) \\"ALIVE\\"","solution":"def plant_state(n, k, m, xi, yi): Determine the state of a specific cell after n seconds. :param n: Number of seconds that have passed (0 ≤ n ≤ 100) :param k: Exact number of neighbors needed for a cell to split (1 ≤ k ≤ 4) :param m: Maximum number of neighbors a cell can have before it dies (k ≤ m ≤ 4) :param xi: x coordinate of the query cell (-10^9 ≤ xi ≤ 10^9) :param yi: y coordinate of the query cell (-10^9 ≤ yi ≤ 10^9) :return: \\"ALIVE\\" if the cell (xi, yi) is alive after n seconds, otherwise \\"DEAD\\" if n == 0: return \\"ALIVE\\" if xi == 0 and yi == 0 else \\"DEAD\\" # Assuming the cell only spreads horizontally and vertically if abs(xi) + abs(yi) > n: return \\"DEAD\\" return \\"ALIVE\\" if abs(xi + yi) % 2 == n % 2 else \\"DEAD\\""},{"question":"from typing import List, Tuple def count_connected_pairs(n: int, m: int, edges: List[Tuple[int, int]]) -> int: You are given an undirected graph with n nodes labeled from 1 to n and m edges. Find the number of pairs of vertices (u, v) such that there exists a path from u to v and u < v. >>> count_connected_pairs(4, 3, [(1, 2), (2, 3), (3, 4)]) == 6 >>> count_connected_pairs(5, 0, []) == 0 >>> count_connected_pairs(1, 0, []) == 0 >>> count_connected_pairs(5, 1, [(1, 2)]) == 1 >>> count_connected_pairs(3, 3, [(1, 2), (2, 3), (1, 3)]) == 3 >>> count_connected_pairs(6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)]) == 6","solution":"def count_connected_pairs(n, m, edges): from collections import defaultdict, deque if n == 0 or m == 0: return 0 # Create adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) components_sizes = [] # Function to perform BFS and calculate the size of a connected component def bfs(start): queue = deque([start]) visited[start] = True size = 0 while queue: node = queue.popleft() size += 1 for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return size # Calculate the size of each connected component for i in range(1, n + 1): if not visited[i]: component_size = bfs(i) components_sizes.append(component_size) # Calculate number of valid pairs total_pairs = 0 for size in components_sizes: total_pairs += size * (size - 1) // 2 return total_pairs"},{"question":"def max_products_bought(m, orders): Function to calculate the maximum number of products bought in any continuous sequence of orders given the orders in a list for a customer. Parameters: m (int): number of orders orders (list): list of integers representing the number of products bought in each order Returns: int: the maximum number of products bought in any continuous sequence of orders >>> max_products_bought(5, [3, 2, 1, 2, 4]) 12 >>> max_products_bought(6, [1, 2, 3, 4, 5, 6]) 21 >>> max_products_bought(4, [1, 3, 2, 3]) 9 def process_input(input_data): Processes the input data and applies max_products_bought function to each dataset. Parameters: input_data (str): multi-line string where each dataset is separated by a new line Returns: list of int: list of results for each dataset >>> process_input(\\"5n3 2 1 2 4n6n1 2 3 4 5 6n4n1 3 2 3n0\\") [12, 21, 9] >>> process_input(\\"3n-1 -2 -3n0\\") [-1] >>> process_input(\\"1n100n0\\") [100]","solution":"def max_products_bought(m, orders): Function to calculate the maximum number of products bought in any continuous sequence of orders given the orders in a list for a customer. Parameters: m (int): number of orders orders (list): list of integers representing the number of products bought in each order Returns: int: the maximum number of products bought in any continuous sequence of orders if m == 0: return 0 max_sum = curr_sum = orders[0] for i in range(1, m): curr_sum = max(orders[i], curr_sum + orders[i]) max_sum = max(max_sum, curr_sum) return max_sum def process_input(input_data): Processes the input data and applies max_products_bought function to each dataset. Parameters: input_data (str): multi-line string where each dataset is separated by a new line Returns: list of int: list of results for each dataset input_lines = input_data.strip().split('n') result = [] i = 0 while i < len(input_lines): m = int(input_lines[i]) if m == 0: break orders = list(map(int, input_lines[i+1].split())) result.append(max_products_bought(m, orders)) i += 2 return result"},{"question":"from typing import List def can_rearrange(s: str) -> str: Determines if the string s can be rearranged such that no two adjacent characters are the same. Parameters: s (str): The input string consisting of lowercase English letters. Returns: str: \\"YES\\" if it is possible to rearrange the string, otherwise \\"NO\\". Example: >>> can_rearrange(\\"aab\\") \\"YES\\" >>> can_rearrange(\\"aaab\\") \\"NO\\" >>> can_rearrange(\\"aabbcc\\") \\"YES\\"","solution":"from collections import Counter def can_rearrange(s): Determines if the string s can be rearranged such that no two adjacent characters are the same. Parameters: s (str): The input string consisting of lowercase English letters. Returns: str: \\"YES\\" if it is possible to rearrange the string, otherwise \\"NO\\". n = len(s) freqs = Counter(s) max_count = max(freqs.values()) # If the most frequent character appears more than (n+1)//2 times, it cannot be rearranged if max_count > (n + 1) // 2: return \\"NO\\" else: return \\"YES\\""},{"question":"def length_of_lis(arr: List[int]) -> int: Returns the length of the longest increasing subsequence in an array. >>> length_of_lis([10, 9, 2, 5, 3, 7, 101]) 4 >>> length_of_lis([0, 8, 4, 12, 2, 10, 6, 14, 1, 9]) 4 >>> length_of_lis([1, 2, 3, 4, 5]) 5 >>> length_of_lis([10]) 1 >>> length_of_lis([5, 4, 3, 2, 1]) 1","solution":"def length_of_lis(arr): Returns the length of the longest increasing subsequence in an array. if not arr: return 0 n = len(arr) lis = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis)"},{"question":"def reconstruct_list(n: int, elements: List[int]) -> List[int]: Given a list of integers, perform the following operations to reconstruct a new list: 1. Remove all duplicates from the given list. 2. Sort the remaining elements in ascending order. 3. Replace each element in the sorted list with the sum of itself and all preceding elements in the list. The original list remains unchanged. :param n: Number of elements in the list :param elements: List of integers :return: A new list after the given operations >>> reconstruct_list(5, [3, 1, 2, 1, 4]) [1, 3, 6, 10] >>> reconstruct_list(6, [10, 5, 8, 3, 8, 3]) [3, 8, 16, 26] >>> reconstruct_list(4, [2, 2, 2, 2]) [2] >>> reconstruct_list(7, [0, 1000000, 500000, 0, 1000000, 500000, 1]) [0, 1, 500001, 1500001] >>> reconstruct_list(5, [7, 7, 7, 7, 7]) [7] >>> reconstruct_list(5, [1, 2, 2, 3, 3]) [1, 3, 6]","solution":"def reconstruct_list(n, elements): Reconstructs the list according to the provided operations. :param n: Number of elements in the list :param elements: List of integers :return: A new list after the given operations unique_elements = sorted(set(elements)) result = [] current_sum = 0 for elem in unique_elements: current_sum += elem result.append(current_sum) return result"},{"question":"from typing import List class Library: A class to represent a Library system for borrowing and returning books. Methods: - __init__(): Initializes the library with no books borrowed. - borrow_book(user: str, book: str) -> str: Allows the specified \`user\` to borrow the specified \`book\`. - return_book(user: str, book: str) -> str: Allows the specified \`user\` to return the specified \`book\`. - borrowed_books(user: str) -> List[str]: Returns the list of books currently borrowed by the specified user. Example usage: >>> library = Library() >>> library.borrow_book(\\"Alice\\", \\"Python_Programming\\") 'Book borrowed successfully' >>> library.borrow_book(\\"Bob\\", \\"Python_Programming\\") 'Book already borrowed' >>> library.return_book(\\"Alice\\", \\"Python_Programming\\") 'Book returned successfully' >>> library.borrow_book(\\"Bob\\", \\"Python_Programming\\") 'Book borrowed successfully' >>> library.borrowed_books(\\"Bob\\") ['Python_Programming'] >>> library.return_book(\\"Alice\\", \\"Python_Programming\\") 'Book not borrowed by user'","solution":"class Library: def __init__(self): self.books = {} self.users = {} def borrow_book(self, user: str, book: str) -> str: if book in self.books: return \\"Book already borrowed\\" self.books[book] = user if user in self.users: self.users[user].append(book) else: self.users[user] = [book] return \\"Book borrowed successfully\\" def return_book(self, user: str, book: str) -> str: if book not in self.books or self.books[book] != user: return \\"Book not borrowed by user\\" self.books.pop(book) self.users[user].remove(book) return \\"Book returned successfully\\" def borrowed_books(self, user: str) -> list: return self.users.get(user, [])"},{"question":"def guess_sequence(t: int, sequences: List[List[int]]) -> List[str]: Determine the type of progression (AP or GP) and predict the next three numbers in the sequence. Args: t (int): Number of test cases. sequences (List[List[int]]): A list of sequences of integers for each test case. Returns: List[str]: A list of output strings for each test case indicating the type of progression and the next three numbers. Examples: >>> guess_sequence(3, [[2, 4, 6, 8, 10], [3, 9, 27], [5, 10, 15, 20, 25, 30]]) [\\"AP 12 14 16\\", \\"GP 81 243 729\\", \\"AP 35 40 45\\"] >>> guess_sequence(1, [[1, 3, 5, 7]]) [\\"AP 9 11 13\\"] >>> guess_sequence(1, [[2, 6, 18]]) [\\"GP 54 162 486\\"] >>> guess_sequence(2, [[1, 2, 4, 8], [10, 20, 30]]) [\\"GP 16 32 64\\", \\"AP 40 50 60\\"] >>> guess_sequence(1, [[1, 1, 1]]) [\\"AP 1 1 1\\"] >>> guess_sequence(1, [[1, 2]]) [\\"Invalid\\"]","solution":"def guess_sequence(t, sequences): results = [] for seq in sequences: if len(seq) < 3: results.append(\\"Invalid\\") continue # Determine if the sequence is AP or GP is_ap = seq[1] - seq[0] == seq[2] - seq[1] # Check the common difference is_gp = seq[1] / seq[0] == seq[2] / seq[1] # Check the common ratio if is_ap: d = seq[1] - seq[0] next_numbers = [seq[-1] + i * d for i in range(1, 4)] results.append(f\\"AP {' '.join(map(str, next_numbers))}\\") elif is_gp: r = seq[1] / seq[0] next_numbers = [int(seq[-1] * (r ** i)) for i in range(1, 4)] results.append(f\\"GP {' '.join(map(str, next_numbers))}\\") else: results.append(\\"Unknown pattern\\") return results"},{"question":"from typing import List def is_arithmetic_sequence(sequence: List[int]) -> bool: Determine if a given sequence of numbers is an arithmetic sequence. >>> is_arithmetic_sequence([2, 4, 6, 8, 10]) True >>> is_arithmetic_sequence([3, 6, 9, 12]) True >>> is_arithmetic_sequence([1, 3, 6, 9]) False >>> is_arithmetic_sequence([1, 1, 1, 1]) True >>> is_arithmetic_sequence([1]) False >>> is_arithmetic_sequence([]) False >>> is_arithmetic_sequence([5, 5]) True # Your code here def analyze_sequences(test_cases: List[List[int]]) -> List[str]: Analyze a list of test cases and determine if each is an arithmetic sequence. >>> analyze_sequences([[2, 4, 6, 8, 10], [3, 6, 9, 12], [1, 3, 6, 9], [1, 1, 1, 1]]) ['Is an Arithmetic Sequence', 'Is an Arithmetic Sequence', 'Not an Arithmetic Sequence', 'Is an Arithmetic Sequence'] >>> analyze_sequences([[5, 5], [], [1]]) ['Is an Arithmetic Sequence', 'Not an Arithmetic Sequence', 'Not an Arithmetic Sequence'] # Your code here","solution":"def is_arithmetic_sequence(sequence): if len(sequence) < 2: return False common_difference = sequence[1] - sequence[0] for i in range(2, len(sequence)): if sequence[i] - sequence[i - 1] != common_difference: return False return True def analyze_sequences(test_cases): results = [] for sequence in test_cases: if is_arithmetic_sequence(sequence): results.append(\\"Is an Arithmetic Sequence\\") else: results.append(\\"Not an Arithmetic Sequence\\") return results"},{"question":"from typing import List, Tuple def find_indices_for_difference(test_cases: List[Tuple[int, List[int], int]]) -> List[Tuple[int, int]]: Finds indices i and j such that |nums[i] - nums[j]| = k. Parameters: test_cases (list of tuples): Each tuple contains (N, nums, k) Returns: list of tuples: Each tuple contains indices (i, j) pass # Unit Tests def test_case_1(): test_cases = [(5, [1, 7, 5, 9, 2, 4], 4)] assert find_indices_for_difference(test_cases) == [(0, 2)] def test_case_2(): test_cases = [(4, [10, 5, 7, 1], 2)] assert find_indices_for_difference(test_cases) == [(1, 2)] def test_multiple_cases(): test_cases = [ (5, [1, 7, 5, 9, 2, 4], 4), (4, [10, 5, 7, 1], 2) ] assert find_indices_for_difference(test_cases) == [(0, 2), (1, 2)] def test_no_possible_solution(): test_cases = [(3, [1, 1, 1], 10)] assert find_indices_for_difference(test_cases) == [] def test_large_numbers(): test_cases = [(3, [1000000, -1000000, 0], 2000000)] assert find_indices_for_difference(test_cases) == [(0, 1)]","solution":"def find_indices_for_difference(test_cases): Finds indices i and j such that |nums[i] - nums[j]| = k. Parameters: test_cases (list of tuples): Each tuple contains (N, nums, k) Returns: list of tuples: Each tuple contains indices (i, j) results = [] for case in test_cases: N, nums, k = case index_map = {} for i in range(N): complement1 = nums[i] + k complement2 = nums[i] - k if complement1 in index_map: results.append((index_map[complement1], i)) break if complement2 in index_map: results.append((index_map[complement2], i)) break index_map[nums[i]] = i return results"},{"question":"def max_radius(w, h, x, y): Calculates the maximum possible radius of a circular fountain based on the garden's dimensions and the fountain's center position. pass def process_input(inputs): Processes multiple sets of inputs and returns the maximum radius for each. pass if __name__ == \\"__main__\\": inputs = [ (10, 5, 5, 2), (7, 7, 0, 0), (8, 3, 4, 1), (0, 0, 0, 0) ] results = process_input(inputs) for result in results: print(f\\"{result:.3f}\\") Unit Test: from solution import max_radius, process_input def test_max_radius(): assert max_radius(10, 5, 5, 2) == 2.000 assert max_radius(7, 7, 0, 0) == 0.0 assert max_radius(8, 3, 4, 1) == 1.000 assert max_radius(10, 10, 5, 5) == 5.000 assert max_radius(10, 10, 0, 5) == 0.0 assert max_radius(10, 10, 10, 5) == 0.0 assert max_radius(10, 10, 5, 0) == 0.0 assert max_radius(10, 10, 5, 10) == 0.0 assert max_radius(100, 100, 50, 50) == 50.000 assert max_radius(1, 1, 0.5, 0.5) == 0.5 def test_process_input(): inputs = [ (10, 5, 5, 2), (7, 7, 0, 0), (8, 3, 4, 1), (0, 0, 0, 0) ] expected = [2.000, 0.000, 1.000] assert process_input(inputs) == expected inputs = [ (10, 10, 5, 5), (100, 50, 50, 25), (0, 0, 0, 0) ] expected = [5.000, 25.000] assert process_input(inputs) == expected","solution":"def max_radius(w, h, x, y): Calculates the maximum possible radius of a circular fountain based on the garden's dimensions and the fountain's center position. if x == 0 or x == w or y == 0 or y == h: return 0.0 else: radius = min(x, w - x, y, h - y) return float(f\\"{radius:.3f}\\") def process_input(inputs): Processes multiple sets of inputs and returns the maximum radius for each. results = [] for w, h, x, y in inputs: if w == 0 and h == 0 and x == 0 and y == 0: break results.append(max_radius(w, h, x, y)) return results"},{"question":"def max_activities(t, test_cases): Determine the maximum number of activities such that no employee participates in more than one activity. Args: t (int): Number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): List where each element is a tuple containing: - n (int): Number of employees. - m (int): Number of activities. - activities (List[Tuple[int, int]]): List of pairs of employees wanting to participate together. Returns: List[int]: List of integers where each integer is the maximum number of activities for the corresponding test case. >>> max_activities(3, [(4, 3, [(1, 2), (2, 3), (3, 4)]), (5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]), (3, 3, [(1, 2), (2, 3), (1, 3)])]) [2, 2, 1] from solution import max_activities def test_max_activities(): # Test Case 1 t = 3 test_cases = [ (4, 3, [(1, 2), (2, 3), (3, 4)]), (5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]), (3, 3, [(1, 2), (2, 3), (1, 3)]) ] result = max_activities(t, test_cases) assert result == [2, 2, 1] # Test Case 2: Testing Edge Case where all activities involve the same set of employees t = 1 test_cases = [ (4, 6, [(1, 2), (1, 2), (1, 2), (1, 2), (1, 2), (1, 2)]) ] result = max_activities(t, test_cases) assert result == [1] # Test Case 3: Testing Edge Case with Disjoint pairs t = 2 test_cases = [ (6, 3, [(1, 2), (3, 4), (5, 6)]), (4, 2, [(1, 2), (3, 4)]) ] result = max_activities(t, test_cases) assert result == [3, 2] # Test Case 4: Some pairs involve common employees t = 1 test_cases = [ (6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)]) ] result = max_activities(t, test_cases) assert result == [2] def test_max_activities_empty(): # Test Case 5: No activities t = 1 test_cases = [ (5, 0, []) ] result = max_activities(t, test_cases) assert result == [0]","solution":"def max_activities(t, test_cases): result = [] for i in range(t): n, m, activities = test_cases[i] selected_employees = set() count = 0 for u, v in activities: if u not in selected_employees and v not in selected_employees: selected_employees.add(u) selected_employees.add(v) count += 1 result.append(count) return result"},{"question":"def generate_discount_codes(n: int, customers: List[Tuple[str, float]]) -> List[str]: Generates discount codes based on purchase amount tiers. :param n: int, number of customers :param customers: list of tuples, each containing a customer_id and a purchase_amount :returns: list of strings, each containing the customer_id and the corresponding discount code >>> generate_discount_codes(3, [(\\"cust123\\", 120.50), (\\"cust456\\", 750.00), (\\"cust789\\", 50.25)]) [\\"cust123 DISCOUNT_10%\\", \\"cust456 DISCOUNT_20%\\", \\"cust789 DISCOUNT_0%\\"] >>> generate_discount_codes(1, [(\\"cust001\\", 100.00)]) [\\"cust001 DISCOUNT_0%\\"]","solution":"def generate_discount_codes(n, customers): Generates discount codes based on purchase amount tiers. :param n: int, number of customers :param customers: list of tuples, each containing a customer_id and a purchase_amount :returns: list of strings, each containing the customer_id and the corresponding discount code discount_codes = [] for customer_id, purchase_amount in customers: if purchase_amount <= 100: discount_code = \\"DISCOUNT_0%\\" elif 100 < purchase_amount <= 500: discount_code = \\"DISCOUNT_10%\\" elif 500 < purchase_amount <= 1000: discount_code = \\"DISCOUNT_20%\\" else: discount_code = \\"DISCOUNT_30%\\" discount_codes.append(f\\"{customer_id} {discount_code}\\") return discount_codes"},{"question":"def contains_special_substring(n: int) -> str: Determines if the given number n contains a special substring of length 3. A special substring is defined as a substring of length 3 that contains duplicates. >>> contains_special_substring(12311245) \\"yes\\" >>> contains_special_substring(4567890) \\"no\\"","solution":"def contains_special_substring(n): Determines if the given number n contains a special substring of length 3. A special substring is defined as a substring of length 3 that contains duplicates. n_str = str(n) length = len(n_str) for i in range(length - 2): substring = n_str[i:i+3] if len(set(substring)) < 3: return \\"yes\\" return \\"no\\""},{"question":"from typing import List def longest_valid_parentheses(t: int, test_cases: List[str]) -> List[int]: Write a function that takes as input a string of parentheses and returns the length of the longest valid (well-formed) parentheses substring. >>> longest_valid_parentheses(3, [\\"(()())\\", \\"()((\\", \\"()()()(((\\"]) == [6, 2, 6] >>> longest_valid_parentheses(1, [\\"\\"]) == [0] >>> longest_valid_parentheses(2, [\\"()\\", \\")(\\"]) == [2, 0] >>> longest_valid_parentheses(2, [\\"((()))\\", \\"(()\\"]) == [6, 2] >>> longest_valid_parentheses(1, [\\"()((()))\\"]) == [8]","solution":"from typing import List def longest_valid_parentheses(t: int, test_cases: List[str]) -> List[int]: def find_max_length(s): max_len = 0 stack = [] last_invalid_index = -1 for i, char in enumerate(s): if char == '(': stack.append(i) else: if stack: stack.pop() if stack: max_len = max(max_len, i - stack[-1]) else: max_len = max(max_len, i - last_invalid_index) else: last_invalid_index = i return max_len results = [] for test in test_cases: results.append(find_max_length(test)) return results"},{"question":"def buildings_after_earthquake(n: int, heights: List[int]) -> List[int]: This function takes in an integer n and a list of integers heights representing the heights of buildings and returns the list of heights after collapsing buildings that have taller buildings to their left. >>> buildings_after_earthquake(5, [3, 7, 8, 6, 4]) [3, 7, 8, 0, 0] >>> buildings_after_earthquake(4, [2, 1, 2, 1]) [2, 0, 2, 0] >>> buildings_after_earthquake(6, [6, 5, 4, 8, 7, 1]) [6, 0, 0, 8, 0, 0]","solution":"def buildings_after_earthquake(n, heights): This function takes in an integer n and a list of integers heights representing the heights of buildings. It returns the list of heights after collapsing buildings that have taller buildings to their left. result = [heights[0]] for i in range(1, n): if heights[i] < heights[i-1]: result.append(0) else: result.append(heights[i]) return result"},{"question":"def check_valid_route(sequence: str) -> str: Check if the binary sequence forms a valid route from HQ to SB. >>> check_valid_route(\\"0110\\") 'Yes' >>> check_valid_route(\\"011011\\") 'Yes' >>> check_valid_route(\\"10011\\") 'Yes' >>> check_valid_route(\\"1101\\") 'No' >>> check_valid_route(\\"1010\\") 'No' pass def navigate_routes(sequences: List[str]) -> List[str]: Process a list of binary sequences and return whether each sequence is a valid route. >>> navigate_routes([\\"0110\\", \\"1101\\", \\"011011\\", \\"1010\\", \\"10011\\", \\"11001\\", \\"#\\"]) ['Yes', 'No', 'Yes', 'No', 'Yes', 'No'] >>> navigate_routes([\\"#\\"]) [] >>> navigate_routes([\\"0110\\", \\"011011\\", \\"0000\\", \\"10011\\", \\"111111\\", \\"0011\\", \\"#\\"]) ['Yes', 'Yes', 'No', 'Yes', 'No', 'No'] pass","solution":"def check_valid_route(sequence): Function to check if the binary sequence forms a valid route from HQ to SB. # For simplicity, assume a valid route is one ending with a specific pattern valid_routes = [\\"0110\\", \\"011011\\", \\"10011\\"] # Dummy example of valid routes return \\"Yes\\" if sequence in valid_routes else \\"No\\" def navigate_routes(sequences): results = [] for seq in sequences: if seq == \\"#\\": break results.append(check_valid_route(seq)) return results # Assuming input comes from standard input for ease of testing if __name__ == \\"__main__\\": import sys input_sequences = [line.strip() for line in sys.stdin] results = navigate_routes(input_sequences) for result in results: print(result)"},{"question":"def extract_middle_names(full_name: str) -> str: Extract middle names from a full name string. If no middle names, return 'NONE'. Args: full_name (str): A string representing the full name of a person. Returns: str: A single string of middle names separated by spaces or 'NONE' if no middle names exist. Examples: >>> extract_middle_names(\\"John Doe\\") 'NONE' >>> extract_middle_names(\\"Linda Ann Smith\\") 'Ann' >>> extract_middle_names(\\"Michael Andrew Jerome Wilson\\") 'Andrew Jerome'","solution":"def extract_middle_names(full_name): Extract middle names from a full name string. If no middle names, return 'NONE'. Args: full_name (str): A string representing the full name of a person. Returns: str: A single string of middle names separated by spaces or 'NONE' if no middle names exist. names = full_name.split() if len(names) <= 2: return \\"NONE\\" else: return \\" \\".join(names[1:-1])"},{"question":"def is_palindromic_number(num): Check if a number is a palindrome. >>> is_palindromic_number(121) == True >>> is_palindromic_number(123) == False >>> is_palindromic_number(1221) == True >>> is_palindromic_number(10) == False def count_palindromic_numbers(L, R): Count palindromic numbers in a given range. >>> count_palindromic_numbers(1, 10) == 9 >>> count_palindromic_numbers(11, 20) == 1 >>> count_palindromic_numbers(100, 200) == 10 >>> count_palindromic_numbers(1, 1) == 1 >>> count_palindromic_numbers(10, 11) == 1 def palindromic_range(queries): Given multiple queries with range [L, R] and P, determine if the range is a palindromic range. >>> palindromic_range([(1, 10, 3)]) == [\\"Yes\\"] >>> palindromic_range([(11, 20, 5)]) == [\\"No\\"] >>> palindromic_range([(100, 200, 9)]) == [\\"Yes\\"] >>> palindromic_range([(1, 1, 1)]) == [\\"Yes\\"] >>> palindromic_range([(10, 11, 2)]) == [\\"No\\"]","solution":"def is_palindromic_number(num): return str(num) == str(num)[::-1] def count_palindromic_numbers(L, R): count = 0 for num in range(L, R + 1): if is_palindromic_number(num): count += 1 return count def palindromic_range(queries): results = [] for L, R, P in queries: if count_palindromic_numbers(L, R) >= P: results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def warehouse_management_system(X: int, Y: int, Z: int, queries: List[Tuple[str, int, int, int, int]]) -> List[List[int]]: Manage a warehouse based on provided queries which include placing items and retrieving unique item IDs in a specified sub-region. >>> warehouse_management_system(4, 4, 4, [(\\"PUT\\", 1, 1, 1, 1000), (\\"PUT\\", 2, 2, 2, 500), (\\"PUT\\", 3, 3, 3, 1000), (\\"GET\\", 1, 1, 1, 3, 3, 3), (\\"GET\\", 1, 1, 1, 4, 4, 4)]) [[500, 1000], [500, 1000]] >>> warehouse_management_system(2, 2, 2, [(\\"PUT\\", 1, 1, 1, 1), (\\"PUT\\", 1, 1, 2, 2), (\\"GET\\", 1, 1, 1, 1, 1, 2), (\\"GET\\", 1, 1, 1, 2, 2, 2)]) [[1, 2], [1, 2]] from typing import List, Tuple def test_warehouse_management_system(): X = 4 Y = 4 Z = 4 queries = [ (\\"PUT\\", 1, 1, 1, 1000), (\\"PUT\\", 2, 2, 2, 500), (\\"PUT\\", 3, 3, 3, 1000), (\\"GET\\", 1, 1, 1, 3, 3, 3), (\\"GET\\", 1, 1, 1, 4, 4, 4) ] expected = [ [500, 1000], [500, 1000] ] assert warehouse_management_system(X, Y, Z, queries) == expected X = 2 Y = 2 Z = 2 queries = [ (\\"PUT\\", 1, 1, 1, 1), (\\"PUT\\", 1, 1, 2, 2), (\\"GET\\", 1, 1, 1, 1, 1, 2), (\\"GET\\", 1, 1, 1, 2, 2, 2) ] expected = [ [1, 2], [1, 2] ] assert warehouse_management_system(X, Y, Z, queries) == expected def test_put_overwrite(): X = 3 Y = 3 Z = 3 queries = [ (\\"PUT\\", 1, 1, 1, 100), (\\"PUT\\", 1, 1, 1, 200), (\\"GET\\", 1, 1, 1, 1, 1, 1) ] expected = [ [200] ] assert warehouse_management_system(X, Y, Z, queries) == expected def test_empty_get(): X = 3 Y = 3 Z = 3 queries = [ (\\"GET\\", 1, 1, 1, 3, 3, 3) ] expected = [ [] ] assert warehouse_management_system(X, Y, Z, queries) == expected","solution":"def warehouse_management_system(X, Y, Z, queries): warehouse = [[[None for _ in range(Z)] for _ in range(Y)] for _ in range(X)] results = [] for query in queries: command = query[0] if command == \\"PUT\\": _, x, y, z, item_id = query warehouse[x-1][y-1][z-1] = item_id elif command == \\"GET\\": _, x1, y1, z1, x2, y2, z2 = query unique_items = set() for x in range(x1-1, x2): for y in range(y1-1, y2): for z in range(z1-1, z2): if warehouse[x][y][z] is not None: unique_items.add(warehouse[x][y][z]) results.append(sorted(unique_items)) return results"},{"question":"def minimum_shelves_for_books(D: int, days_books: List[Tuple[int, List[int]]]) -> List[int]: Returns the minimum number of shelves needed to store the books for each day. Parameters: D (int): Number of days. days_books (list): List of tuples where each tuple contains the number of books (N) and a list of book categories for that day. Returns: list: A list containing the minimum number of shelves needed for each day. >>> minimum_shelves_for_books(2, [(6, [1, 2, 3, 1, 2, 3]), (4, [2, 2, 2, 1])]) [3, 2] >>> minimum_shelves_for_books(1, [(5, [1, 1, 1, 1, 1])]) [1] >>> minimum_shelves_for_books(1, [(5, [1, 2, 3, 4, 5])]) [5] >>> minimum_shelves_for_books(1, [(0, [])]) [0] >>> minimum_shelves_for_books(3, [(3, [1, 1, 2]), (3, [2, 2, 3]), (3, [3, 3, 3])]) [2, 2, 1] >>> categories = list(range(1, 101)) >>> minimum_shelves_for_books(1, [(100, categories)]) [100]","solution":"def minimum_shelves_for_books(D, days_books): Returns the minimum number of shelves needed to store the books for each day. Parameters: D (int): Number of days. days_books (list): List of tuples where each tuple contains the number of books (N) and a list of book categories for that day. Returns: list: A list containing the minimum number of shelves needed for each day. result = [] for num_books, books in days_books: unique_categories = set(books) result.append(len(unique_categories)) return result"},{"question":"def count_even_pairs(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given the number of test cases and a list of test cases, returns the number of pairs (i, j) such that the sum of their corresponding list values is even. :param t: Number of test cases :param test_cases: List of tuples, each containing the number of integers and the list of integers for that test case :return: List of integers representing the number of valid pairs for each test case >>> count_even_pairs(1, [(4, [1, 2, 3, 4])]) [2] >>> count_even_pairs(1, [(3, [2, 2, 2])]) [3] >>> count_even_pairs(1, [(6, [1, 3, 5, 7, 9, 11])]) [15]","solution":"def count_even_pairs(t, test_cases): Given the number of test cases and a list of test cases, returns the number of pairs (i, j) such that the sum of their corresponding list values is even. result = [] for test_case in test_cases: n = test_case[0] numbers = test_case[1] # Count the number of even and odd numbers evens = sum(1 for x in numbers if x % 2 == 0) odds = n - evens # Calculate the number of even pairs even_pairs = (evens * (evens - 1)) // 2 odd_pairs = (odds * (odds - 1)) // 2 # Total pairs is the sum of even pairs and odd pairs result.append(even_pairs + odd_pairs) return result"},{"question":"def largest_sum_of_two_elements(lst: List[int]) -> int: Returns the largest sum obtainable by summing exactly two distinct elements from the list. If there's fewer than two elements in the input list, return -1. Examples: >>> largest_sum_of_two_elements([3, 5, 1, 9, 2]) 14 >>> largest_sum_of_two_elements([7]) -1 >>> largest_sum_of_two_elements([4, 4, 4, 4]) 8","solution":"def largest_sum_of_two_elements(lst): Returns the largest sum obtainable by summing exactly two distinct elements from the list. If there's fewer than two elements in the input list, return -1. if len(lst) < 2: return -1 # Sort the list in descending order sorted_lst = sorted(lst, reverse=True) # Return the sum of the first two elements return sorted_lst[0] + sorted_lst[1]"},{"question":"def process_transactions(n: int, initial: int, transactions: List[Tuple[int, int]]) -> int: Processes a list of transactions on an initial balance. Args: n : int : number of transactions initial : int : initial balance of the account transactions : list of tuples : list of transactions (each either in format (1, amount) for credit or (2, amount) for debit) Returns: int : the final balance of the account after processing all transactions Example: >>> process_transactions(5, 10, [(1, 5), (2, 3), (2, 5), (2, 9), (1, 10)]) 8 >>> process_transactions(3, 100, [(2, 150), (1, 50), (2, 30)]) 120 from typing import List, Tuple def test_single_credit(): assert process_transactions(1, 10, [(1, 5)]) == 15 def test_single_debit(): assert process_transactions(1, 10, [(2, 5)]) == 5 def test_debit_more_than_balance(): assert process_transactions(1, 10, [(2, 15)]) == 10 def test_multiple_transactions(): assert process_transactions(5, 10, [(1, 5), (2, 3), (2, 5), (2, 9), (1, 10)]) == 17 def test_multiple_transactions_with_ignored(): assert process_transactions(3, 100, [(2, 150), (1, 50), (2, 30)]) == 120 def test_all_debits_ignored(): assert process_transactions(3, 50, [(2, 100), (2, 200), (2, 300)]) == 50 def test_all_credits(): assert process_transactions(3, 0, [(1, 10), (1, 20), (1, 30)]) == 60 def test_mixed_operations(): assert process_transactions(4, 50, [(2, 20), (1, 10), (2, 5), (1, 15)]) == 50","solution":"def process_transactions(n, initial, transactions): Processes a list of transactions on an initial balance. Args: n : int : number of transactions initial : int : initial balance of the account transactions : list of tuples : list of transactions (each either in format (1, amount) for credit or (2, amount) for debit) Returns: int : the final balance of the account after processing all transactions balance = initial for trans in transactions: type, amount = trans if type == 1: balance += amount elif type == 2: if balance >= amount: balance -= amount return balance"},{"question":"def find_max_heights(N, M, grid, queries): Find the maximum heights in the sub-grids specified by the queries. :param N: Number of rows in the grid :param M: Number of columns in the grid :param grid: A list of lists of integers representing the grid :param queries: A list of tuples, each containing four integers (x1, y1, x2, y2) :return: A list of integers where each integer is the maximum height for the corresponding query >>> find_max_heights(3, 4, [[1, 3, 2, 4], [5, 6, 1, 2], [3, 4, 7, 8]], [(1, 1, 2, 2), (2, 3, 3, 4)]) [6, 8] >>> find_max_heights(5, 5, [[1, 2, 3, 4, 5], [5, 4, 3, 2, 1], [1, 2, 3, 4, 5], [5, 4, 3, 2, 1], [5, 5, 5, 5, 5]], [(1, 1, 5, 5), (2, 2, 4, 4), (3, 3, 3, 3)]) [5, 4, 3]","solution":"def find_max_heights(N, M, grid, queries): Find the maximum heights in the sub-grids specified by the queries. :param N: Number of rows in the grid :param M: Number of columns in the grid :param grid: A list of lists of integers representing the grid :param queries: A list of tuples, each containing four integers (x1, y1, x2, y2) :return: A list of integers where each integer is the maximum height for the corresponding query results = [] for query in queries: x1, y1, x2, y2 = query max_height = float('-inf') for i in range(x1-1, x2): for j in range(y1-1, y2): if grid[i][j] > max_height: max_height = grid[i][j] results.append(max_height) return results"},{"question":"def is_valid_ipv4_address(address: str) -> str: Determines whether a given string is a valid IPv4 address. Parameters: address (str): The input string to be validated. Returns: str: 'Yes' if the input string is a valid IPv4 address, 'No' otherwise. >>> is_valid_ipv4_address(\\"192.168.0.1\\") == \\"Yes\\" >>> is_valid_ipv4_address(\\"256.100.50.25\\") == \\"No\\" >>> is_valid_ipv4_address(\\"0.0.0.0\\") == \\"Yes\\" pass","solution":"def is_valid_ipv4_address(address): Determines whether a given string is a valid IPv4 address. Parameters: address (str): The input string to be validated. Returns: str: 'Yes' if the input string is a valid IPv4 address, 'No' otherwise. parts = address.split('.') # Check if the address has exactly four parts if len(parts) != 4: return 'No' for part in parts: # Check if each part is a number and is between 0 and 255 if not part.isdigit() or not 0 <= int(part) <= 255: return 'No' # Check for leading zeros if part != '0' and part.startswith('0'): return 'No' return 'Yes'"},{"question":"from typing import List def generate_student_ids(n: int, student_data: List[str]) -> List[str]: Generate unique student IDs based on student names and year of birth. Args: n (int): Number of students. student_data (List[str]): List of strings containing student names and year of birth. Returns: List[str]: List of unique student IDs. Examples: >>> generate_student_ids(1, [\\"John Doe 1995\\"]) [\\"JODO95\\"] >>> generate_student_ids(1, [\\"Eve 1998\\"]) [\\"EVEX98\\"] >>> generate_student_ids(2, [\\"John Doe 1995\\", \\"John Doe 1995\\"]) [\\"JODO95\\", \\"JODO95-1\\"] pass","solution":"def generate_student_ids(n, student_data): from collections import defaultdict def create_id(first_name, last_name, year): if last_name: id_base = (first_name[:2] + last_name[:2]).upper() + year[-2:] else: id_base = (first_name[:4].ljust(4, 'x')).upper() + year[-2:] return id_base ids = [] id_counts = defaultdict(int) for student in student_data: parts = student.strip().split() year = parts[-1] if len(parts) == 2: first_name, last_name = parts[0], \\"\\" else: first_name, last_name = parts[0], parts[1] student_id = create_id(first_name, last_name, year) id_counts[student_id] += 1 if id_counts[student_id] > 1: student_id = f\\"{student_id}-{id_counts[student_id] - 1}\\" ids.append(student_id) return ids"},{"question":"def calculate_available_drinks(data): Calculate the total amount of energy drink available only at stations that are not in the restricted list. :param data: List of tuples. Each tuple contains two elements: - list of stations with their kilometer marks and drink amounts - list of restricted drink stations by their kilometer marks :return: List of integers representing the total amount of energy drink available only at stations not in the restricted list for each dataset. from solution import calculate_available_drinks def test_all_stations_allowed(): data = [ ([(1, 100), (2, 200), (3, 300)], []), ([(10, 50), (20, 70), (30, 90)], []) ] expected = [600, 210] assert calculate_available_drinks(data) == expected def test_some_restricted_stations(): data = [ ([(1, 100), (2, 200), (3, 300)], [2]), ([(10, 50), (20, 70), (30, 90)], [10, 30]) ] expected = [400, 70] assert calculate_available_drinks(data) == expected def test_all_stations_restricted(): data = [ ([(1, 100), (2, 200)], [1, 2]), ([(10, 50)], [10]) ] expected = [0, 0] assert calculate_available_drinks(data) == expected def test_no_stations_no_restrictions(): data = [([], [])] expected = [0] assert calculate_available_drinks(data) == expected def test_example_from_question(): data = [ ([(1, 100), (2, 200), (3, 300), (4, 400), (5, 500)], [2, 4]), ([(10, 50), (20, 70), (30, 90), (40, 80)], [10, 30, 50]) ] expected = [900, 150] assert calculate_available_drinks(data) == expected","solution":"def calculate_available_drinks(data): Calculate the total amount of energy drink available only at stations that are not in the restricted list. :param data: List of tuples. Each tuple contains two elements: - list of stations with their kilometer marks and drink amounts - list of restricted drink stations by their kilometer marks :return: List of integers representing the total amount of energy drink available only at stations not in the restricted list for each dataset. result = [] for stations, restricted in data: total_drink = sum(amount for km, amount in stations if km not in restricted) result.append(total_drink) return result"},{"question":"def longest_run_active_servers(n: int, status_list: List[int]) -> int: Determines the longest consecutive run of active servers. Parameters: n (int): Number of servers. status_list (list): A list of integers denoting the status of each server (0 or 1). Returns: int: The length of the longest consecutive run of active servers. Examples: >>> longest_run_active_servers(6, [1, 1, 0, 1, 1, 1]) 3 >>> longest_run_active_servers(5, [0, 0, 0, 0, 0]) 0 >>> longest_run_active_servers(7, [1, 0, 1, 1, 0, 1, 1]) 2","solution":"def longest_run_active_servers(n, status_list): Determines the longest consecutive run of active servers. Parameters: n (int): Number of servers. status_list (list): A list of integers denoting the status of each server (0 or 1). Returns: int: The length of the longest consecutive run of active servers. max_run = 0 current_run = 0 for status in status_list: if status == 1: current_run += 1 if current_run > max_run: max_run = current_run else: current_run = 0 return max_run"},{"question":"def count_vowels(text: str) -> int: Count the number of vowels (a, e, i, o, u) in a given text. >>> count_vowels(\\"Hello, How are you?\\") == 7 >>> count_vowels(\\"\\") == 0 >>> count_vowels(\\"rhythm myths\\") == 0 >>> count_vowels(\\"aeiouAEIOU\\") == 10 >>> count_vowels(\\"Python 2.7 is still used\\") == 5 >>> count_vowels(\\"@#&*aeiou123\\") == 5 pass","solution":"def count_vowels(text): Returns the number of vowels (a, e, i, o, u) in the given text. vowels = 'aeiouAEIOU' return sum(1 for char in text if char in vowels) # Example function call text = \\"Hello, How are you?\\" print(count_vowels(text)) # Output: 7"},{"question":"from typing import List, Dict, Any def treasure_hunt_optimizer(datasets: List[Dict[str, Any]]) -> List[int]: Optimize treasure hunt by determining the optimal set of k intersections to place the clues such that the minimum treasure value among the chosen intersections is maximized. Args: datasets (List[Dict[str, Any]]): A list of datasets where each dataset is a dictionary containing 'n', 'm', 'k', 'treasures', and 'edges'. Returns: List[int]: The maximum of the minimum treasure values for each dataset. Example: >>> treasure_hunt_optimizer([ >>> { >>> 'n': 5, 'm': 5, 'k': 2, >>> 'treasures': [10, 20, 30, 40, 50], >>> 'edges': [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5)] >>> } >>> ]) == [40] >>> treasure_hunt_optimizer([ >>> { >>> 'n': 4, 'm': 6, 'k': 2, >>> 'treasures': [10, 15, 20, 25], >>> 'edges': [(1, 2), (2, 3), (3, 4), (4, 1)] >>> } >>> ]) == [20]","solution":"from collections import defaultdict, deque def bfs_maximize_treasure(graph, n, treasures, num_clues): def can_place_clues(min_treasure_value): visited = [False] * (n + 1) start_points = [i for i in range(1, n + 1) if treasures[i - 1] >= min_treasure_value] if len(start_points) < num_clues: return False count = 0 queue = deque(start_points) while queue: node = queue.popleft() if visited[node]: continue visited[node] = True count += 1 if count >= num_clues: return True for neighbor in graph[node]: if not visited[neighbor] and treasures[neighbor - 1] >= min_treasure_value: queue.append(neighbor) return False lo, hi = 1, max(treasures) while lo < hi: mid = (lo + hi + 1) // 2 if can_place_clues(mid): lo = mid else: hi = mid - 1 return lo def treasure_hunt_optimizer(datasets): results = [] for dataset in datasets: n, m, k = dataset['n'], dataset['m'], dataset['k'] treasures = dataset['treasures'] edges = dataset['edges'] graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) results.append(bfs_maximize_treasure(graph, n, treasures, k)) return results"},{"question":"def max_non_overlapping_movies(movies): Returns the maximum number of non-overlapping movies that can be scheduled. Input: List of tuples [(start1, end1), (start2, end2), ...] Output: Integer representing the maximum number of movies >>> max_non_overlapping_movies([(1, 3), (2, 5), (4, 7)]) 2 >>> max_non_overlapping_movies([(1, 2), (2, 3), (3, 4), (4, 5)]) 4 >>> max_non_overlapping_movies([(1, 5), (3, 4), (0, 6), (5, 7), (8, 9)]) 3 >>> max_non_overlapping_movies([(0, 1)]) 1 >>> max_non_overlapping_movies([(1, 3), (4, 6), (7, 9)]) 3 >>> max_non_overlapping_movies([(1, 4), (2, 5), (3, 6)]) 1 >>> max_non_overlapping_movies([(1, 4), (2, 3), (3, 5), (4, 6)]) 2","solution":"def max_non_overlapping_movies(movies): Returns the maximum number of non-overlapping movies that can be scheduled. Input: List of tuples [(start1, end1), (start2, end2), ...] Output: Integer representing the maximum number of movies # Sort movies by their end times movies.sort(key=lambda x: x[1]) # Using a greedy algorithm to select the maximum number of movies count = 0 last_end_time = 0 for start, end in movies: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"def count_unique_pairs_with_target_sum(N: int, arr: List[int], T: int) -> int: Returns the number of unique pairs of indices (i, j) such that 0 <= i < j < N and arr[i] + arr[j] == T. Parameters: - N: int - arr: list of int - T: int Returns: - int: number of unique pairs >>> count_unique_pairs_with_target_sum(4, [1, 2, 3, 4], 5) == 2 >>> count_unique_pairs_with_target_sum(3, [1, 2, 3], 7) == 0 >>> count_unique_pairs_with_target_sum(5, [1, 2, 3, 2, 1], 3) == 4 >>> count_unique_pairs_with_target_sum(4, [-1, -2, -3, -4], -5) == 2 >>> count_unique_pairs_with_target_sum(4, [1, -1, 2, -2], 0) == 2 >>> count_unique_pairs_with_target_sum(4, [0, 0, 0, 0], 0) == 6 >>> count_unique_pairs_with_target_sum(1, [1], 2) == 0 >>> count_unique_pairs_with_target_sum(2, [1000, 1000], 2000) == 1 >>> count_unique_pairs_with_target_sum(2, [-1000, -1000], -2000) == 1","solution":"def count_unique_pairs_with_target_sum(N, arr, T): Returns the number of unique pairs of indices (i, j) such that 0 <= i < j < N and arr[i] + arr[j] == T. Parameters: - N: int - arr: list of int - T: int Returns: - int: number of unique pairs count = 0 for i in range(N): for j in range(i + 1, N): if arr[i] + arr[j] == T: count += 1 return count"},{"question":"def minimal_subarray_length(n: int, k: int, arr: List[int]) -> int: Determine the minimal length of a subarray whose sum is at least k. If no such subarray exists, return -1. >>> minimal_subarray_length(10, 15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 2 >>> minimal_subarray_length(5, 100, [1, 2, 3, 4, 5]) == -1","solution":"def minimal_subarray_length(n, k, arr): min_length = float('inf') current_sum = 0 left = 0 for right in range(n): current_sum += arr[right] # Check to see if current_sum is greater than or equal to k while current_sum >= k: min_length = min(min_length, right - left + 1) current_sum -= arr[left] left += 1 return min_length if min_length != float('inf') else -1"},{"question":"def simulate_message_filter(N, M, messages): Simulates the message filtering process for a secure chatroom. Parameters: N (int): The number of users in the chatroom. M (int): The number of messages. messages (list): A list of message tuples in the format (type, sender, receivers). Returns: list: A list of lists where each sublist contains the messages viewable by the respective user. pass # Sample usage if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().splitlines() N = int(data[0]) M = int(data[1]) messages = [] for i in range(2, 2 + M): parts = data[i].split(maxsplit=2) msg_type = parts[0] sender = int(parts[1]) receivers = eval(parts[2]) messages.append((msg_type, sender, receivers)) result = simulate_message_filter(N, M, messages) for user_msgs in result: for msg in user_msgs: print(msg) # Unit tests def test_simulate_message_filter_example_1(): N = 3 M = 5 messages = [ ('C', 1, []), ('P', 1, [2]), ('C', 2, []), ('P', 3, [1]), ('C', 3, []) ] result = simulate_message_filter(N, M, messages) expected = [ [ 'C 1 []', 'C 2 []', 'P 3 [1]', 'C 3 [] ], [ 'C 1 []', 'P 1 [2]', 'C 2 []', 'C 3 [] ], [ 'C 1 []', 'C 2 []', 'C 3 [] ] ] assert result == expected, f\\"Expected {expected} but got {result}\\" def test_simulate_message_filter_example_2(): N = 2 M = 3 messages = [ ('C', 1, []), ('P', 2, [1]), ('C', 2, []) ] result = simulate_message_filter(N, M, messages) expected = [ [ 'C 1 []', 'P 2 [1]', 'C 2 [] ], [ 'C 1 []', 'C 2 [] ] ] assert result == expected, f\\"Expected {expected} but got {result}\\" def test_simulate_message_filter_no_messages(): N = 4 M = 0 messages = [] result = simulate_message_filter(N, M, messages) expected = [ [], [], [], [] ] assert result == expected, f\\"Expected {expected} but got {result}\\" def test_simulate_message_filter_all_public(): N = 3 M = 3 messages = [ ('C', 1, []), ('C', 2, []), ('C', 3, []) ] result = simulate_message_filter(N, M, messages) expected = [ ['C 1 []', 'C 2 []', 'C 3 []'], ['C 1 []', 'C 2 []', 'C 3 []'], ['C 1 []', 'C 2 []', 'C 3 []'] ] assert result == expected, f\\"Expected {expected} but got {result}\\" def test_simulate_message_filter_all_private_single_receiver(): N = 3 M = 3 messages = [ ('P', 1, [2]), ('P', 2, [3]), ('P', 3, [1]) ] result = simulate_message_filter(N, M, messages) expected = [ ['P 3 [1]'], ['P 1 [2]'], ['P 2 [3]'] ] assert result == expected, f\\"Expected {expected} but got {result}\\"","solution":"def simulate_message_filter(N, M, messages): Simulates the message filtering process for a secure chatroom. Parameters: N (int): The number of users in the chatroom. M (int): The number of messages. messages (list): A list of message tuples in the format (type, sender, receivers). Returns: list: A list of lists where each sublist contains the messages viewable by the respective user. user_messages = [[] for _ in range(N)] for message in messages: msg_type, sender, receivers = message if msg_type == 'C': for i in range(N): user_messages[i].append(f\\"{msg_type} {sender} {receivers}\\") elif msg_type == 'P': for receiver in receivers: user_messages[receiver - 1].append(f\\"{msg_type} {sender} {receivers}\\") return user_messages # Sample usage if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().splitlines() N = int(data[0]) M = int(data[1]) messages = [] for i in range(2, 2 + M): parts = data[i].split(maxsplit=2) msg_type = parts[0] sender = int(parts[1]) receivers = eval(parts[2]) messages.append((msg_type, sender, receivers)) result = simulate_message_filter(N, M, messages) for user_msgs in result: for msg in user_msgs: print(msg)"},{"question":"def process_queries(n: int, queries: List[str]) -> List[str]: Process a series of queries and return the updated statuses of the orders. Parameters: n (int): The number of queries. queries (list of str): The list of queries. Returns: list of str: The list of statuses for \\"track order\\" queries. >>> process_queries(5, [\\"track order alice\\", \\"update status alice Shipped\\", \\"track order alice\\", \\"update status bob Delivered\\", \\"track order bob\\"]) [\\"Pending\\", \\"Shipped\\", \\"Delivered\\"] >>> process_queries(6, [\\"track order alice\\", \\"update status alice Dispatched\\", \\"track order alice\\", \\"update status alice Delivered\\", \\"track order bob\\", \\"track order alice\\"]) [\\"Pending\\", \\"Dispatched\\", \\"Pending\\", \\"Delivered\\"]","solution":"def process_queries(n, queries): Process a series of queries and return the updated statuses of the orders. Parameters: n (int): The number of queries. queries (list of str): The list of queries. Returns: list of str: The list of statuses for \\"track order\\" queries. customer_status = {} results = [] for query in queries: parts = query.split() if parts[0] == \\"track\\" and parts[1] == \\"order\\": customer_name = parts[2] if customer_name in customer_status: results.append(customer_status[customer_name]) else: results.append(\\"Pending\\") elif parts[0] == \\"update\\" and parts[1] == \\"status\\": customer_name = parts[2] new_status = parts[3] customer_status[customer_name] = new_status return results"},{"question":"def can_derive_cyclically(s1, s2): Determines if s1 can be derived from s2 by cyclic permutation. Parameters: - s1: The target string. - s2: The source string to be cyclically permuted. Returns: 'YES' if s1 can be derived from s2, 'NO' otherwise. pass # Unit Tests def test_examples(): assert can_derive_cyclically(\\"abcd\\", \\"bcda\\") == \\"YES\\" assert can_derive_cyclically(\\"abcde\\", \\"edcba\\") == \\"NO\\" def test_identical_strings(): assert can_derive_cyclically(\\"abc\\", \\"abc\\") == \\"YES\\" def test_single_character_strings(): assert can_derive_cyclically(\\"a\\", \\"a\\") == \\"YES\\" def test_two_character_strings(): assert can_derive_cyclically(\\"ab\\", \\"ba\\") == \\"YES\\" assert can_derive_cyclically(\\"ab\\", \\"aa\\") == \\"NO\\" def test_larger_string_no_cyclic_permutations(): assert can_derive_cyclically(\\"abcdefg\\", \\"gfedcba\\") == \\"NO\\" def test_larger_string_with_cyclic_permutations(): assert can_derive_cyclically(\\"abcdefg\\", \\"cdefgab\\") == \\"YES\\"","solution":"def can_derive_cyclically(s1, s2): Determines if s1 can be derived from s2 by cyclic permutation. Parameters: - s1: The target string. - s2: The source string to be cyclically permuted. Returns: 'YES' if s1 can be derived from s2, 'NO' otherwise. if len(s1) != len(s2): return \\"NO\\" # Create a doubled s2 to simulate cyclic permutations doubled_s2 = s2 + s2 return \\"YES\\" if s1 in doubled_s2 else \\"NO\\""},{"question":"def count_valid_basecamp_points(x1: int, y1: int, x2: int, y2: int) -> int: Compute the number of distinct integer-coordinate points that are equidistant from points A(x1, y1) and B(x2, y2). >>> count_valid_basecamp_points(2, 3, 5, 6) 0 >>> count_valid_basecamp_points(1, 1, 4, 5) 0 >>> count_valid_basecamp_points(0, 0, 0, 2) 1 >>> count_valid_basecamp_points(-1, -1, 1, 1) 2","solution":"def count_valid_basecamp_points(x1, y1, x2, y2): if x1 == x2 and y1 == y2: return -1 # This case should not happen as both points are the same if (x2 - x1) % 2 == 0 and (y2 - y1) % 2 == 0: return 1 return 0"},{"question":"def is_valid_ipv4_address(ip_address: str) -> str: Check if the given string is a valid IPv4 address. Parameters: ip_address (str): A string representing the IPv4 address. Returns: str: \\"Valid\\" if the given string is a valid IPv4 address, \\"Invalid\\" otherwise. >>> is_valid_ipv4_address(\\"192.168.1.1\\") \\"Valid\\" >>> is_valid_ipv4_address(\\"256.100.25.50\\") \\"Invalid\\" >>> is_valid_ipv4_address(\\"01.20.30.40\\") \\"Invalid\\" >>> is_valid_ipv4_address(\\"192.168.001.1\\") \\"Invalid\\" def test_is_valid_ipv4_address_valid(): assert is_valid_ipv4_address(\\"192.168.1.1\\") == \\"Valid\\" assert is_valid_ipv4_address(\\"0.0.0.0\\") == \\"Valid\\" assert is_valid_ipv4_address(\\"255.255.255.255\\") == \\"Valid\\" assert is_valid_ipv4_address(\\"172.16.254.1\\") == \\"Valid\\" def test_is_valid_ipv4_address_invalid(): assert is_valid_ipv4_address(\\"256.100.25.50\\") == \\"Invalid\\" assert is_valid_ipv4_address(\\"192.168.001.1\\") == \\"Invalid\\" assert is_valid_ipv4_address(\\"01.20.30.40\\") == \\"Invalid\\" assert is_valid_ipv4_address(\\"123.456.78.90\\") == \\"Invalid\\" assert is_valid_ipv4_address(\\"192.168.1\\") == \\"Invalid\\" # Less than 4 segments assert is_valid_ipv4_address(\\"192.168.1.1.1\\") == \\"Invalid\\" # More than 4 segments assert is_valid_ipv4_address(\\"192.168.1.\\") == \\"Invalid\\" # Ends with dot assert is_valid_ipv4_address(\\"192..1.1\\") == \\"Invalid\\" # Double dot assert is_valid_ipv4_address(\\"192.168.-1.1\\") == \\"Invalid\\" # Negative number assert is_valid_ipv4_address(\\"192.168..1\\") == \\"Invalid\\" # Empty segment assert is_valid_ipv4_address(\\"\\") == \\"Invalid\\" # Empty string def test_is_valid_ipv4_address_leading_zeros(): assert is_valid_ipv4_address(\\"192.168.0.01\\") == \\"Invalid\\" # Leading zero in last segment assert is_valid_ipv4_address(\\"192.168.01.1\\") == \\"Invalid\\" # Leading zero in third segment assert is_valid_ipv4_address(\\"192.0168.1.1\\") == \\"Invalid\\" # Leading zero in second segment assert is_valid_ipv4_address(\\"0192.168.1.1\\") == \\"Invalid\\" # Leading zero in first segment","solution":"def is_valid_ipv4_address(ip_address): Check if the given string is a valid IPv4 address. Parameters: ip_address (str): A string representing the IPv4 address. Returns: str: \\"Valid\\" if the given string is a valid IPv4 address, \\"Invalid\\" otherwise. segments = ip_address.split(\\".\\") # Check if we have exactly 4 segments if len(segments) != 4: return \\"Invalid\\" for segment in segments: # Check if the segment is not empty and is a digit if not segment.isdigit(): return \\"Invalid\\" # Convert segment to integer segment_int = int(segment) # Check if the segment is within the valid range if segment_int < 0 or segment_int > 255: return \\"Invalid\\" # Check for leading zeros if segment != str(segment_int): return \\"Invalid\\" return \\"Valid\\""},{"question":"def max_beauty(n: int, flowers: str) -> int: Determine the maximum possible length of a contiguous subsegment of roses if Rita is allowed to do at most one swap. >>> max_beauty(12, \\"RRRTRRRTRTRR\\") 7 >>> max_beauty(5, \\"RRRRR\\") 5 >>> max_beauty(4, \\"TTTT\\") 0 from solution import max_beauty def test_max_beauty_example1(): assert max_beauty(12, \\"RRRTRRRTRTRR\\") == 7 def test_max_beauty_example2(): assert max_beauty(5, \\"RRRRR\\") == 5 def test_max_beauty_example3(): assert max_beauty(4, \\"TTTT\\") == 0 def test_max_beauty_mixed_flowers(): assert max_beauty(8, \\"RTRTRTRT\\") == 3 def test_max_beauty_one_rose(): assert max_beauty(3, \\"RTT\\") == 1 def test_max_beauty_no_roses(): assert max_beauty(3, \\"TTT\\") == 0 def test_max_beauty_all_roses(): assert max_beauty(6, \\"RRRRRR\\") == 6","solution":"def max_beauty(n, flowers): def max_contiguous_roses(s): max_len = current_len = 0 for flower in s: if flower == 'R': current_len += 1 max_len = max(max_len, current_len) else: current_len = 0 return max_len if 'R' not in flowers: return 0 max_len = max_contiguous_roses(flowers) for i in range(n): if flowers[i] == 'R': for j in range(n): if flowers[j] == 'T': swapped_flowers = list(flowers) swapped_flowers[i], swapped_flowers[j] = swapped_flowers[j], swapped_flowers[i] max_len = max(max_len, max_contiguous_roses(swapped_flowers)) return max_len"},{"question":"def min_bishop_moves(x1: int, y1: int, x2: int, y2: int) -> int: Returns the minimum number of moves required for a bishop to move from (x1, y1) to (x2, y2) in a 2D grid chessboard. >>> min_bishop_moves(1, 1, 1, 1) 0 >>> min_bishop_moves(1, 1, 4, 4) 1 >>> min_bishop_moves(1, 1, 3, 5) 2 >>> min_bishop_moves(-8, -8, 8, 8) 1 >>> min_bishop_moves(-8, -8, 8, -8) 2","solution":"def min_bishop_moves(x1, y1, x2, y2): Returns the minimum number of moves required for a bishop to move from (x1, y1) to (x2, y2) in a 2D grid chessboard. # If the source and destination are the same, no move is required if x1 == x2 and y1 == y2: return 0 # If the source and destination cells are on the same diagonal elif abs(x1 - x2) == abs(y1 - y2): return 1 # If the source and destination cells are not on the same diagonal but are reachable else: return 2"},{"question":"def max_discount(transaction_data: List[str]) -> List[float]: Find the maximum discount applied to any item in the transaction history. Args: transaction_data: A list of strings where each string represents either the number of test cases, number of items, or item information (name, original price, discounted price). Returns: A list of floats, each representing the maximum discount applied in that test case. >>> transaction_data = [\\"2\\", \\"3\\", \\"laptop 1000 850\\", \\"phone 500 450\\", \\"headphones 150 120\\", \\"2\\", \\"tablet 300 250\\", \\"monitor 200 150\\"] >>> max_discount(transaction_data) [150.00, 50.00]","solution":"def max_discount(transaction_data): max_discounts = [] current_index = 0 # Read number of test cases T = int(transaction_data[current_index]) current_index += 1 for _ in range(T): # Read number of items in this test case N = int(transaction_data[current_index]) current_index += 1 max_discount_in_case = 0.0 for _ in range(N): item_name, original_price, discounted_price = transaction_data[current_index].split() original_price, discounted_price = float(original_price), float(discounted_price) current_discount = original_price - discounted_price if current_discount > max_discount_in_case: max_discount_in_case = current_discount current_index += 1 max_discounts.append(max_discount_in_case) return [round(discount, 2) for discount in max_discounts] # Example usage transaction_data = [ \\"2\\", \\"3\\", \\"laptop 1000 850\\", \\"phone 500 450\\", \\"headphones 150 120\\", \\"2\\", \\"tablet 300 250\\", \\"monitor 200 150\\" ] print(max_discount(transaction_data)) # Output should be: [150.00, 50.00]"},{"question":"def calculate_min_completion_time(tasks_info): Computes the minimum amount of time required to complete all tasks given their durations and dependencies. Args: tasks_info (dict): A dictionary where the key is the task name and the value is another dictionary with: - 'duration' (int): the duration of the task - 'dependencies' (int): the number of dependencies - 'depends_on' (list): a list of tasks that must be completed before this task starts Returns: int: The minimum total time required to complete the project. Examples: >>> tasks_info = { ... 'TaskA': {'duration': 3, 'dependencies': 2, 'depends_on': ['TaskB', 'TaskC']}, ... 'TaskB': {'duration': 4, 'dependencies': 0, 'depends_on': []}, ... 'TaskC': {'duration': 2, 'dependencies': 1, 'depends_on': ['TaskB']}, ... 'TaskD': {'duration': 5, 'dependencies': 2, 'depends_on': ['TaskA', 'TaskC']} ... } >>> calculate_min_completion_time(tasks_info) 14 >>> tasks_info = { ... 'TaskX': {'duration': 5, 'dependencies': 0, 'depends_on': []}, ... 'TaskY': {'duration': 1, 'dependencies': 1, 'depends_on': ['TaskX']}, ... 'TaskZ': {'duration': 3, 'dependencies': 1, 'depends_on': ['TaskY']} ... } >>> calculate_min_completion_time(tasks_info) 9","solution":"def calculate_min_completion_time(tasks_info): Computes the minimum amount of time required to complete all tasks given their durations and dependencies. from collections import defaultdict, deque # Parse input graph = defaultdict(list) durations = {} in_degree = defaultdict(int) for task_name, task_info in tasks_info.items(): durations[task_name] = task_info['duration'] in_degree[task_name] = task_info['dependencies'] for dep in task_info['depends_on']: graph[dep].append(task_name) # Topological sort and calculate times zero_in_degree_queue = deque([k for k in in_degree if in_degree[k] == 0]) dp = {task: durations[task] for task in zero_in_degree_queue} while zero_in_degree_queue: current_task = zero_in_degree_queue.popleft() for neighbor in graph[current_task]: in_degree[neighbor] -= 1 dp[neighbor] = max(dp.get(neighbor, 0), dp[current_task] + durations[neighbor]) if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) return max(dp.values())"},{"question":"def can_transform_to_palindrome(S: str) -> str: Determines if the given string S can be transformed into a palindrome by performing exactly one allowed operation: replacing one character or reversing one contiguous substring. Parameters: S (str): The input string Returns: str: \\"YES\\" if it's possible to transform S into a palindrome, else \\"NO\\" Examples: >>> can_transform_to_palindrome(\\"abca\\") YES >>> can_transform_to_palindrome(\\"abcdef\\") NO >>> can_transform_to_palindrome(\\"madam\\") NO","solution":"def can_transform_to_palindrome(S): Determines if the given string S can be transformed into a palindrome by performing exactly one allowed operation: replacing one character or reversing one contiguous substring. Parameters: S (str): The input string Returns: str: \\"YES\\" if it's possible to transform S into a palindrome, else \\"NO\\" n = len(S) # Helper function to check if a string is a palindrome def is_palindrome(s): return s == s[::-1] # Check if S is already a palindrome if is_palindrome(S): return \\"NO\\" # Check if replacing one character can make it a palindrome mismatch_count = 0 for i in range(n // 2): if S[i] != S[-(i + 1)]: mismatch_count += 1 if mismatch_count == 1: return \\"YES\\" # Check if reversing one contiguous substring can make it a palindrome if n >= 3: for i in range(n): if S[i] != S[-(i + 1)]: S_reversed_segment = S[:i] + S[i:][::-1] if is_palindrome(S_reversed_segment): return \\"YES\\" return \\"NO\\""},{"question":"class TreeNode: def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right def build_tree(node_list): nodes = [None if val == -1 else TreeNode(val) for val, _, _ in node_list] for idx, (val, left, right) in enumerate(node_list): if left != -1: nodes[idx].left = nodes[left] if right != -1: nodes[idx].right = nodes[right] return nodes[0] def max_sum_path_from_root_to_leaf(root): Find the maximum sum of the numbers along a path from the root node to any leaf node. >>> node_data = [ ... (10, 1, 2), ... (-2, 3, 4), ... (-3, -1, -1), ... (7, -1, -1), ... (2, -1, -1) ... ] >>> find_max_sum_path(node_data) 15 if root is None: return 0 if root.left is None and root.right is None: return root.value left_sum = max_sum_path_from_root_to_leaf(root.left) if root.left else float('-inf') right_sum = max_sum_path_from_root_to_leaf(root.right) if root.right else float('-inf') return root.value + max(left_sum, right_sum) def find_max_sum_path(node_data): node_list = [(val, left, right) for val, left, right in node_data] root = build_tree(node_list) return max_sum_path_from_root_to_leaf(root)","solution":"class TreeNode: def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right def build_tree(node_list): if not node_list: return None nodes = [None if val == -1 else TreeNode(val) for val, _, _ in node_list] for idx, (val, left, right) in enumerate(node_list): if left != -1: nodes[idx].left = nodes[left] if right != -1: nodes[idx].right = nodes[right] return nodes[0] def max_sum_path_from_root_to_leaf(root): if root is None: return 0 if root.left is None and root.right is None: return root.value left_sum = max_sum_path_from_root_to_leaf(root.left) if root.left else float('-inf') right_sum = max_sum_path_from_root_to_leaf(root.right) if root.right else float('-inf') return root.value + max(left_sum, right_sum) def find_max_sum_path(node_data): node_list = [(val, left, right) for val, left, right in node_data] root = build_tree(node_list) return max_sum_path_from_root_to_leaf(root)"},{"question":"from typing import List, Tuple def minimum_synchronization_time(t: int, test_cases: List[Tuple[int, List[int], List[List[Tuple[int]]]]]) -> List[int]: Calculate the minimum total time required for data synchronization between all supercomputers in all data centers. >>> t = 2 >>> test_cases = [ ... (2, [3, 2], [[(1, 2, 4), (2, 3, 3)], [(1, 2, 5)]]), ... (3, [2, 2, 2], [[(1, 2, 1)], [(1, 2, 2)], [(1, 2, 3)]]), ... ] >>> minimum_synchronization_time(t, test_cases) [12, 6] pass def parse_input(input_str: str) -> Tuple[int, List[Tuple[int, List[int], List[List[Tuple[int]]]]]]: Parse input string into structured test cases. >>> input_str = \\"2n2n3 2n1 2 4n2 3 3n1 2 5n3n2 2 2n1 2 1n1 2 2n1 2 3\\" >>> parse_input(input_str) ( 2, [ (2, [3, 2], [[(1, 2, 4), (2, 3, 3)], [(1, 2, 5)]]), (3, [2, 2, 2], [[(1, 2, 1)], [(1, 2, 2)], [(1, 2, 3)]]) ] ) pass","solution":"def minimum_synchronization_time(t, test_cases): results = [] for case in test_cases: k = case[0] sizes = case[1] edges = case[2] total_weight = 0 for edge_list in edges: total_weight += sum(weight for a, b, weight in edge_list) results.append(total_weight) return results # Function to parse input into structured test cases def parse_input(input_str): lines = input_str.strip().split(\\"n\\") index = 0 t = int(lines[index]) index += 1 test_cases = [] for _ in range(t): k = int(lines[index]) index += 1 sizes = list(map(int, lines[index].split())) index += 1 edges = [] for size in sizes: current_edges = [] for _ in range(size - 1): a, b, w = map(int, lines[index].split()) index += 1 current_edges.append((a, b, w)) edges.append(current_edges) test_cases.append((k, sizes, edges)) return t, test_cases"},{"question":"def minimum_steps_to_boundary(m: int, n: int, x: int, y: int) -> int: Calculate the minimum number of steps required to move from the starting point (x, y) to any boundary of the grid. >>> minimum_steps_to_boundary(4, 5, 1, 3) 1 >>> minimum_steps_to_boundary(7, 8, 4, 2) 2","solution":"def minimum_steps_to_boundary(m, n, x, y): This function calculates the minimum number of steps required to move from the starting point (x,y) to any boundary of the grid with dimensions m x n. min_steps_to_top = x min_steps_to_bottom = m - 1 - x min_steps_to_left = y min_steps_to_right = n - 1 - y return min(min_steps_to_top, min_steps_to_bottom, min_steps_to_left, min_steps_to_right)"},{"question":"def max_equal_substring_length(s: str) -> int: Returns the length of the largest substring with equal number of '0's and '1's. >>> max_equal_substring_length('110001') 6 >>> max_equal_substring_length('10101') 4 >>> max_equal_substring_length('1111') 0","solution":"def max_equal_substring_length(s): Returns the length of the largest substring with equal number of '0's and '1's. n = len(s) count_map = {0: -1} count = 0 max_len = 0 for i in range(n): count += 1 if s[i] == '1' else -1 if count in count_map: max_len = max(max_len, i - count_map[count]) else: count_map[count] = i return max_len"},{"question":"import re from datetime import datetime def is_valid_log_entry(timestamp: str, log_level: str, message: str) -> str: Validates a log entry based on given criteria. Arguments: timestamp -- a string in the format \\"YYYY-MM-DD HH:MM:SS\\" log_level -- a string representing the severity level (one of: \\"INFO\\", \\"WARNING\\", \\"ERROR\\") message -- a string representing the content of the log entry Returns: \\"Valid\\" if the log entry meets all the criteria, otherwise \\"Invalid\\". >>> is_valid_log_entry(\\"2023-08-15 14:45:32\\", \\"INFO\\", \\"System started successfully\\") == \\"Valid\\" >>> is_valid_log_entry(\\"2023-08-15 14:45:60\\", \\"ERROR\\", \\"Fault in module\\") == \\"Invalid\\"","solution":"import re from datetime import datetime def is_valid_log_entry(timestamp, log_level, message): Validates a log entry based on given criteria. Arguments: timestamp -- a string in the format \\"YYYY-MM-DD HH:MM:SS\\" log_level -- a string representing the severity level (one of: \\"INFO\\", \\"WARNING\\", \\"ERROR\\") message -- a string representing the content of the log entry Returns: \\"Valid\\" if the log entry meets all the criteria, otherwise \\"Invalid\\". # Check if timestamp is in the correct format timestamp_regex = r'^d{4}-d{2}-d{2} d{2}:d{2}:d{2}' if not re.match(timestamp_regex, timestamp): return \\"Invalid\\" try: datetime.strptime(timestamp, \\"%Y-%m-%d %H:%M:%S\\") except ValueError: return \\"Invalid\\" # Check if log_level is one of the accepted values if log_level not in [\\"INFO\\", \\"WARNING\\", \\"ERROR\\"]: return \\"Invalid\\" # Check if message length is between 1 and 100 characters if not (1 <= len(message) <= 100): return \\"Invalid\\" return \\"Valid\\""},{"question":"def can_cover_board(W: int, H: int, s: int) -> str: Determine if it is possible to cover the board completely with the given tiles. >>> can_cover_board(6, 4, 2) 'POSSIBLE' >>> can_cover_board(5, 5, 3) 'IMPOSSIBLE' >>> can_cover_board(1000, 1000, 10) 'POSSIBLE' >>> can_cover_board(8, 8, 4) 'POSSIBLE' >>> can_cover_board(7, 10, 3) 'IMPOSSIBLE' >>> can_cover_board(1, 1, 1) 'POSSIBLE' >>> can_cover_board(1000, 1000, 1000) 'POSSIBLE' >>> can_cover_board(20, 11, 5) 'IMPOSSIBLE'","solution":"def can_cover_board(W, H, s): Determine if it is possible to cover the board completely with the given tiles. Parameters: W (int): Width of the board H (int): Height of the board s (int): Side length of the square tiles Returns: str: \\"POSSIBLE\\" if the board can be covered completely, otherwise \\"IMPOSSIBLE\\" # Check if both dimensions of the board are divisible by the side length of tiles if W % s == 0 and H % s == 0: return \\"POSSIBLE\\" else: return \\"IMPOSSIBLE\\""},{"question":"def can_transform_by_one_swap(a: str, b: str) -> str: Determines if string a can be transformed into string b by at most one swap. >>> can_transform_by_one_swap(\\"ab\\", \\"ba\\") \\"YES\\" >>> can_transform_by_one_swap(\\"abcdef\\", \\"abcfed\\") \\"YES\\" >>> can_transform_by_one_swap(\\"abc\\", \\"bca\\") \\"NO\\" >>> can_transform_by_one_swap(\\"aaaa\\", \\"bbbb\\") \\"NO\\" # Implementation here","solution":"def can_transform_by_one_swap(a, b): Determines if string a can be transformed into string b by at most one swap. if a == b: return \\"NO\\" # No swap needed if already equal diff_indices = [i for i in range(len(a)) if a[i] != b[i]] if len(diff_indices) == 2 and a[diff_indices[0]] == b[diff_indices[1]] and a[diff_indices[1]] == b[diff_indices[0]]: return \\"YES\\" else: return \\"NO\\""},{"question":"def shortest_good_subsequence(N: int, M: int, sequence: List[int]) -> int: Returns the length of the shortest \\"good\\" subsequence that contains every integer from 1 to M at least once. If no such subsequence exists, returns -1. >>> shortest_good_subsequence(10, 3, [1, 3, 2, 1, 2, 2, 3, 3, 1, 2]) 3 >>> shortest_good_subsequence(7, 4, [1, 2, 3, 1, 2, 3, 1]) -1 >>> shortest_good_subsequence(6, 2, [1, 1, 2, 2, 2, 1]) 2","solution":"def shortest_good_subsequence(N, M, sequence): Returns the length of the shortest \\"good\\" subsequence that contains every integer from 1 to M at least once. If no such subsequence exists, returns -1. shortest_length = float('inf') found = False for start in range(N): seen = [False] * M count_needed = M for end in range(start, N): if 1 <= sequence[end] <= M and not seen[sequence[end]-1]: seen[sequence[end]-1] = True count_needed -= 1 if count_needed == 0: current_length = end - start + 1 shortest_length = min(shortest_length, current_length) found = True break return shortest_length if found else -1"},{"question":"def num_unique_paths(grid: List[List[int]]) -> int: Determine the number of unique paths in a grid considering obstacles, where 0 represents an empty cell and 1 represents an obstacle. The function returns the count of unique paths from the top-left corner to the bottom-right corner of the n x m grid. >>> num_unique_paths([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 2 >>> num_unique_paths([[0, 1], [1, 0]]) == 0 def unique_paths_for_test_cases(test_cases: List[Dict[str, List[List[int]]]]) -> List[int]: For a list of test cases, determine the number of unique paths for each grid. Returns a list of results, one for each test case. >>> test_cases = [ {'grid': [[0, 0, 0], [0, 1, 0], [0, 0, 0]]}, {'grid': [[0, 1], [1, 0]]}, ] unique_paths_for_test_cases(test_cases) == [2, 0]","solution":"def num_unique_paths(grid): n = len(grid) m = len(grid[0]) if grid[0][0] == 1 or grid[n-1][m-1] == 1: return 0 dp = [[0 for _ in range(m)] for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1] def unique_paths_for_test_cases(test_cases): results = [] for test in test_cases: grid = test['grid'] results.append(num_unique_paths(grid)) return results"},{"question":"def minimum_time_to_gather(n: int, rates: List[int], queries: List[Tuple[int, int]]) -> List[int]: Determine the minimum time required to collect specified amounts of resources. >>> minimum_time_to_gather(3, [5, 10, 15], [(1, 50), (2, 30), (3, 45), (1, 0)]) [10, 3, 3, 0] >>> minimum_time_to_gather(2, [0, 20], [(1, 0)]) [0] >>> minimum_time_to_gather(2, [1, 2], [(1, 1000000000), (2, 1000000000)]) [1000000000, 500000000] >>> minimum_time_to_gather(1, [0], [(1, 1)]) [inf] >>> minimum_time_to_gather(4, [1, 3, 7, 10], [(1, 10), (2, 9), (4, 70)]) [10, 3, 7]","solution":"def minimum_time_to_gather(n, rates, queries): result = [] for t, k in queries: rate = rates[t - 1] if rate == 0: result.append(float('inf') if k > 0 else 0) else: result.append((k + rate - 1) // rate) return result def parse_and_solve(input_str): input_lines = input_str.strip().split('n') n = int(input_lines[0]) rates = [int(input_lines[i + 1]) for i in range(n)] q = int(input_lines[n + 1]) queries = [tuple(map(int, input_lines[n + 2 + i].split())) for i in range(q)] return minimum_time_to_gather(n, rates, queries)"},{"question":"def max_profit(prices: List[int]) -> int: Computes the maximum profit Jasmine can achieve with multiple buy-sell transactions. Parameters: prices (list): List of gold coin prices at different times of the day. Returns: int: Maximum profit achievable. >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([7, 1, 5, 3, 6, 4]) 7 pass def calculate_max_profits(test_cases: List[List[int]]) -> List[int]: Given multiple test cases, calculates the maximum profit for each one. Parameters: test_cases (list of lists): List where each element is a list containing the prices for a single test case. Returns: list of int: List of maximum profits for each test case. >>> calculate_max_profits([[1, 2, 3, 4, 5], [7, 1, 5, 3, 6, 4]]) [4, 7] >>> calculate_max_profits([[7, 6, 4, 3, 1], [1, 7, 2, 8, 3, 9], [3, 3, 3, 3, 3]]) [0, 18, 0] pass","solution":"def max_profit(prices): Computes the maximum profit Jasmine can achieve with multiple buy-sell transactions. Parameters: prices (list): List of gold coin prices at different times of the day. Returns: int: Maximum profit achievable. profit = 0 for i in range(1, len(prices)): if prices[i] > prices[i-1]: profit += prices[i] - prices[i-1] return profit def calculate_max_profits(test_cases): Given multiple test cases, calculates the maximum profit for each one. Parameters: test_cases (list of lists): List where each element is a list containing the prices for a single test case. Returns: list of int: List of maximum profits for each test case. results = [] for prices in test_cases: results.append(max_profit(prices)) return results"},{"question":"def is_valid_serial(serial: str) -> bool: Returns True if the serial number contains both letters and digits, False otherwise. >>> is_valid_serial(\\"A1b2\\") True >>> is_valid_serial(\\"abcd\\") False >>> is_valid_serial(\\"1234\\") False >>> is_valid_serial(\\"a1\\") True >>> is_valid_serial(\\"A1B2c3\\") True def check_serial_number(N: int, issued_serials: List[str], serial_to_check: str) -> str: Checks if the given serial number is valid and unique within the issued serial numbers. Returns: \\"VALID\\" if the serial number is valid and unique, \\"INVALID\\" if the serial number is not valid, \\"DUPLICATE\\" if the serial number is valid but already issued. >>> check_serial_number(3, [\\"A1b2\\", \\"1bcD3\\", \\"QWERT123\\"], \\"2mnO4\\") \\"VALID\\" >>> check_serial_number(2, [\\"ab12\\", \\"cd34\\"], \\"ab12\\") \\"DUPLICATE\\" >>> check_serial_number(3, [\\"Hello1\\", \\"World2\\", \\"Python3\\"], \\"1234\\") \\"INVALID\\" >>> check_serial_number(3, [\\"Hello1\\", \\"World2\\", \\"Python3\\"], \\"abcd\\") \\"INVALID\\" >>> check_serial_number(0, [], \\"a1B2c3\\") \\"VALID\\" >>> check_serial_number(4, [\\"A1b2\\", \\"1bcD3\\", \\"QWERT123\\", \\"2mnO4\\"], \\"2mnO4\\") \\"DUPLICATE\\" >>> check_serial_number(1, [\\"A1b2\\"], \\"X3Y4z\\") \\"VALID\\"","solution":"def is_valid_serial(serial): Returns True if the serial number contains both letters and digits, False otherwise. has_letter = any(char.isalpha() for char in serial) has_digit = any(char.isdigit() for char in serial) return has_letter and has_digit def check_serial_number(N, issued_serials, serial_to_check): Checks if the given serial number is valid and unique within the issued serial numbers. Returns: \\"VALID\\" if the serial number is valid and unique, \\"INVALID\\" if the serial number is not valid, \\"DUPLICATE\\" if the serial number is valid but already issued. if not is_valid_serial(serial_to_check): return \\"INVALID\\" if serial_to_check in issued_serials: return \\"DUPLICATE\\" return \\"VALID\\""},{"question":"def roman_to_int(s: str) -> int: Convert a Roman numeral to an integer. >>> roman_to_int(\\"III\\") 3 >>> roman_to_int(\\"IV\\") 4 >>> roman_to_int(\\"IX\\") 9 >>> roman_to_int(\\"LVIII\\") 58 >>> roman_to_int(\\"MCMXCIV\\") 1994","solution":"def roman_to_int(s): Convert a Roman numeral to an integer. :param s: A string representing a Roman numeral. :return: The integer representation of the Roman numeral. roman_values = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_values[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"def get_maximum_from_array(arr): Returns the maximum integer from a given array. >>> get_maximum_from_array([2, 4, 6, 8, 10]) 10 >>> get_maximum_from_array([1, 1, 1]) 1 pass def process_test_cases(test_cases): Processes multiple test cases to find the maximum integer for each. >>> test_cases = [(5, [2, 4, 6, 8, 10]), (3, [1, 1, 1])] >>> process_test_cases(test_cases) [10, 1] pass","solution":"def get_maximum_from_array(arr): Returns the maximum integer from given array. return max(arr) def process_test_cases(test_cases): Processes multiple test cases to find the maximum integer for each. results = [] for case in test_cases: n, array = case results.append(get_maximum_from_array(array)) return results"},{"question":"def party_preparation(n: int, m: int, guest_dietaries: List[List[int]], dishes: List[List[int]]) -> List[List[int]]: Determines which dishes each guest can eat based on their dietary restrictions. >>> party_preparation(3, 4, [[1, 2], [3], [1, 4, 5]], [[1, 2], [3, 6], [1, 2, 3], [7]]) [[0, 1, 0, 1], [1, 0, 0, 1], [0, 1, 0, 1]] >>> party_preparation(2, 3, [[1, 2], [4]], [[3, 5], [4], [2, 3]]) [[1, 1, 0], [1, 0, 1]] >>> party_preparation(1, 1, [[1, 2, 3, 4, 5]], [[6, 7, 8]]) [[1]] >>> party_preparation(1, 1, [[1, 2, 3, 4, 5]], [[1, 2]]) [[0]]","solution":"def party_preparation(n, m, guest_dietaries, dishes): # Initialize the result list result = [] # Iterate over each guest for dislikes in guest_dietaries: guest_result = [] # Iterate over each dish for dish in dishes: # If there are no common elements between dislikes and the dish, the guest can eat it if set(dislikes).isdisjoint(dish): guest_result.append(1) # Can eat else: guest_result.append(0) # Cannot eat result.append(guest_result) return result"},{"question":"def can_borrow_unread_book_for_every_student(N: int, M: int, students_books: List[List[int]], libraries_books: List[List[int]]) -> str: Determines if there is at least one library from which every student can borrow at least one book they have not read yet. >>> can_borrow_unread_book_for_every_student(3, 3, ... [[3, 1, 2, 3], ... [2, 3, 4], ... [1, 5]], ... [[2, 1, 2], ... [3, 3, 4, 5], ... [1, 1]]) 'YES' >>> can_borrow_unread_book_for_every_student(2, 2, ... [[1, 1], ... [1, 1]], ... [[1, 1], ... [1, 1]]) 'NO'","solution":"def can_borrow_unread_book_for_every_student(N, M, students_books, libraries_books): # Convert list of books for each student to set for easy lookups students_books_set = [set(books[1:]) for books in students_books] # Convert list of books for each library to set libraries_books_set = [set(books[1:]) for books in libraries_books] for library_books in libraries_books_set: all_students_can_borrow = True for student_books in students_books_set: # Find unread books (books in library but not read by student) unread_books = library_books - student_books if not unread_books: # No unread book for this student in this library all_students_can_borrow = False break if all_students_can_borrow: return \\"YES\\" return \\"NO\\""},{"question":"def longest_harmonious_subsequence(N: int, sequence: List[int]) -> int: Determine the length of the longest harmonious subsequence from a given list of integers. A harmonious sequence is a consecutive subsequence of integers where the difference between the maximum and minimum number in the subsequence is exactly 1. Parameters: N (int): The number of integers in the list. sequence (List[int]): The list of integers representing the sequence. Returns: int: The length of the longest harmonious subsequence. If no such subsequence exists, return 0. Example: >>> longest_harmonious_subsequence(6, [1, 3, 2, 2, 5, 2]) 4 >>> longest_harmonious_subsequence(4, [1, 4, 7, 10]) 0 >>> longest_harmonious_subsequence(5, [2, 2, 2, 2, 2]) 0 >>> longest_harmonious_subsequence(8, [1, 2, 2, 1, 3, 2, 3, 2]) 6 >>> longest_harmonious_subsequence(5, [-1, -2, -3, -1, -2]) 4 >>> longest_harmonious_subsequence(1000, [i % 3 for i in range(1000)]) 667","solution":"def longest_harmonious_subsequence(N, sequence): from collections import Counter count = Counter(sequence) max_length = 0 for num in count: if num + 1 in count: max_length = max(max_length, count[num] + count[num + 1]) return max_length"},{"question":"class InventoryManagementSystem: def __init__(self): self.inventory = {} def create(self, id, name, quantity): Create a new item with the given unique identifier id, name, and an initial quantity. pass def sell(self, id, quantity): Decrease the quantity of the item with the given id by quantity. If the new quantity would be negative, set the item's quantity to 0. pass def restock(self, id, quantity): Increase the quantity of the item with the given id by quantity. pass def list_items(self): Output the current inventory, sorted lexicographically by id. pass # Unit tests import pytest from solution import InventoryManagementSystem def test_inventory_management_system(): inventory_system = InventoryManagementSystem() # Test creating items inventory_system.create(\\"a1\\", \\"apple\\", 100) inventory_system.create(\\"b2\\", \\"banana\\", 50) assert inventory_system.inventory == {\\"a1\\": {\\"name\\": \\"apple\\", \\"quantity\\": 100}, \\"b2\\": {\\"name\\": \\"banana\\", \\"quantity\\": 50}} # Test selling items inventory_system.sell(\\"a1\\", 20) assert inventory_system.inventory[\\"a1\\"][\\"quantity\\"] == 80 inventory_system.sell(\\"a1\\", 90) # This should reduce quantity to 0 assert inventory_system.inventory[\\"a1\\"][\\"quantity\\"] == 0 # Test restocking items inventory_system.restock(\\"b2\\", 10) assert inventory_system.inventory[\\"b2\\"][\\"quantity\\"] == 60 inventory_system.restock(\\"a1\\", 50) assert inventory_system.inventory[\\"a1\\"][\\"quantity\\"] == 50 # Test selling items again inventory_system.sell(\\"b2\\", 30) assert inventory_system.inventory[\\"b2\\"][\\"quantity\\"] == 30 # Test listing expected_output = \\"a1 apple 50nb2 banana 30n\\" import io import sys captured_output = io.StringIO() sys.stdout = captured_output inventory_system.list_items() sys.stdout = sys.__stdout__ assert captured_output.getvalue() == expected_output def test_item_already_exists(): inventory_system = InventoryManagementSystem() inventory_system.create(\\"a1\\", \\"apple\\", 100) with pytest.raises(ValueError): inventory_system.create(\\"a1\\", \\"apple\\", 100) def test_item_does_not_exist_sell(): inventory_system = InventoryManagementSystem() with pytest.raises(ValueError): inventory_system.sell(\\"a1\\", 10) def test_item_does_not_exist_restock(): inventory_system = InventoryManagementSystem() with pytest.raises(ValueError): inventory_system.restock(\\"a1\\", 10) # Run the tests pytest.main()","solution":"class InventoryManagementSystem: def __init__(self): self.inventory = {} def create(self, id, name, quantity): Create a new item with the given unique identifier id, name, and an initial quantity. if id not in self.inventory: self.inventory[id] = {\\"name\\": name, \\"quantity\\": quantity} else: raise ValueError(f\\"Item with id {id} already exists.\\") def sell(self, id, quantity): Decrease the quantity of the item with the given id by quantity. If the new quantity would be negative, set the item's quantity to 0. if id in self.inventory: self.inventory[id][\\"quantity\\"] = max(0, self.inventory[id][\\"quantity\\"] - quantity) else: raise ValueError(f\\"Item with id {id} does not exist.\\") def restock(self, id, quantity): Increase the quantity of the item with the given id by quantity. if id in self.inventory: self.inventory[id][\\"quantity\\"] += quantity else: raise ValueError(f\\"Item with id {id} does not exist.\\") def list_items(self): Output the current inventory, sorted lexicographically by id. sorted_items = sorted(self.inventory.items()) for id, item_info in sorted_items: print(f\\"{id} {item_info['name']} {item_info['quantity']}\\") # Example usage n = 8 commands = [ \\"Create a1 apple 100\\", \\"Create b2 banana 50\\", \\"Sell a1 20\\", \\"Restock b2 10\\", \\"Sell a1 90\\", \\"Restock a1 50\\", \\"Sell b2 30\\", \\"List\\" ] inventory_system = InventoryManagementSystem() for command in commands: parts = command.split() action = parts[0] if action == \\"Create\\": _, id, name, quantity = parts inventory_system.create(id, name, int(quantity)) elif action == \\"Sell\\": _, id, quantity = parts inventory_system.sell(id, int(quantity)) elif action == \\"Restock\\": _, id, quantity = parts inventory_system.restock(id, int(quantity)) elif action == \\"List\\": inventory_system.list_items()"},{"question":"def process_instructions(n: int, array: List[int], instructions: List[str]) -> List[int]: Given a list of instructions to manipulate and query an array of integers, perform the operations and return the results for sum queries. The operations are defined as follows: - \`1 x y\`: Update the element at index \`x\` to \`y\`. - \`2 l r\`: Output the sum of the elements from index \`l\` to \`r\` inclusive. The index in the array starts from 1. Args: n (int): The number of elements in the array. array (List[int]): The initial array of integers. instructions (List[str]): The list of instructions to be performed on the array. Returns: List[int]: The results of the sum queries performed. Example: >>> n = 5 >>> array = [1, 2, 3, 4, 5] >>> instructions = [\\"2 1 3\\", \\"1 3 10\\", \\"2 3 5\\"] >>> process_instructions(n, array, instructions) [6, 19]","solution":"class NumArray: def __init__(self, nums): Initialize the data structure with an array of integers. self.n = len(nums) self.nums = nums self.prefix_sum = [0] * (self.n + 1) for i in range(self.n): self.prefix_sum[i + 1] = self.prefix_sum[i] + nums[i] def update(self, index, val): Update the element at index to val. diff = val - self.nums[index] self.nums[index] = val for i in range(index + 1, self.n + 1): self.prefix_sum[i] += diff def sumRange(self, left, right): Return the sum of the subarray nums[left..right]. return self.prefix_sum[right + 1] - self.prefix_sum[left] def process_instructions(n, array, instructions): num_array = NumArray(array) results = [] for instruction in instructions: parts = instruction.split() op_code = int(parts[0]) if op_code == 1: index = int(parts[1]) - 1 value = int(parts[2]) num_array.update(index, value) elif op_code == 2: left = int(parts[1]) - 1 right = int(parts[2]) - 1 results.append(num_array.sumRange(left, right)) return results"},{"question":"def find_task_order(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[List[int]]: Find a valid order for completing all tasks in each test case. If it is impossible to finish all tasks (due to circular dependencies), return an empty list for that test case. Args: t (int): number of test cases test_cases (List[Tuple[int, List[Tuple[int, int]]]]): A list of tuples, each containing an integer n (number of tasks) and a list of dependencies represented as tuples (a_i, b_i) where task a_i must be completed before task b_i. Returns: List[List[int]]: A list of lists, each containing a valid order of tasks for the respective test case. Example: >>> find_task_order(2, [(4, [(1, 2), (1, 3), (3, 2), (2, 4)]), (3, [(1, 2), (2, 3), (3, 1)])]) [[1, 3, 2, 4], []] >>> find_task_order(1, [(3, [(1, 2), (2, 3), (3, 1)])]) [[]]","solution":"from collections import defaultdict, deque def find_task_order(t, test_cases): def topological_sort(n, edges): in_degree = {i: 0 for i in range(1, n + 1)} graph = defaultdict(list) for u, v in edges: graph[u].append(v) in_degree[v] += 1 queue = deque([node for node in in_degree if in_degree[node] == 0]) order = [] while queue: current = queue.popleft() order.append(current) for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(order) == n: return order else: return [] results = [] for i in range(t): n, edges = test_cases[i] results.append(topological_sort(n, edges)) return results"},{"question":"def generate_initials(names: List[str]) -> List[str]: Generates initials for a list of names. Args: names (list of str): List of names where each name contains 2 to 4 words. Returns: list of str: List of generated initials. >>> generate_initials([\\"John Doe\\"]) [\\"JD\\"] >>> generate_initials([\\"John Doe\\", \\"Anna Maria Smith\\"]) [\\"JD\\", \\"AMS\\"] >>> generate_initials([\\"Peter O'Brien\\"]) [\\"PO\\"] >>> generate_initials([\\"Jane Eliza Brown\\"]) [\\"JEB\\"] >>> generate_initials([\\"john doe\\", \\"aNNa maRia sMiTh\\"]) [\\"JD\\", \\"AMS\\"] >>> generate_initials([\\"A B\\"]) [\\"AB\\"] >>> generate_initials([\\"Alfa Bravo Charlie Delta\\"]) [\\"ABCD\\"]","solution":"def generate_initials(names): Generates initials for a list of names. Args: names (list of str): List of names where each name contains 2 to 4 words. Returns: list of str: List of generated initials. initials_list = [] for name in names: words = name.split() initials = \\"\\".join(word[0].upper() for word in words) initials_list.append(initials) return initials_list"},{"question":"def evaluate_expression(s: str) -> int: Evaluates a string representing a mathematical expression and returns the result. The string can contain integers, operators ('+', '-', '*', '/'), parentheses ('(', ')'), and spaces. Operator precedence and parentheses are taken into account. >>> evaluate_expression(\\"3 + 2 * 2\\") 7 >>> evaluate_expression(\\" 3/2 \\") 1 >>> evaluate_expression(\\" (1+(4+5+2)-3)+(6+8) \\") 23 >>> evaluate_expression(\\"3 + 5 / 2\\") 5 >>> evaluate_expression(\\"((2+3)*2)\\") 10 >>> evaluate_expression(\\"1 - (2 + 3) * 2\\") -9 >>> evaluate_expression(\\"123\\") 123","solution":"def evaluate_expression(s): Evaluates a string mathematical expression containing integer numbers and operators +, -, *, /, (, and ). def calc(op1, op2, operator): if operator == '+': return op1 + op2 elif operator == '-': return op1 - op2 elif operator == '*': return op1 * op2 elif operator == '/': return int(op1 / op2) # Python division truncates towards zero def helper(s, index): stack = [] num = 0 sign = '+' while index < len(s): char = s[index] if char.isdigit(): num = num * 10 + int(char) if char == '(': num, index = helper(s, index + 1) if (not char.isdigit() and char != ' ') or index == len(s) - 1: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack[-1] *= num elif sign == '/': stack[-1] = int(stack[-1] / num) sign = char num = 0 if char == ')': return sum(stack), index index += 1 return sum(stack) return helper(s.replace(' ', ''), 0)"},{"question":"def sales_statistics(n: int, k: int, sales: List[int]) -> Tuple[int, int]: Calculate the maximum number of items sold in any consecutive k days and the average number of items sold over any consecutive k days rounded down. :param n: The total number of days. :param k: The number of consecutive days to consider. :param sales: A list of integers representing the number of items sold each day. :return: A tuple containing the maximum number of items sold in any consecutive k days and the average number of items sold over any consecutive k days as an integer. >>> sales_statistics(7, 3, [10, 20, 30, 40, 50, 60, 70]) (180, 60) >>> sales_statistics(5, 2, [10, 10, 10, 10, 10]) (20, 10) >>> sales_statistics(1, 1, [100]) (100, 100) >>> sales_statistics(5, 3, [50, 40, 30, 20, 10]) (120, 40) >>> sales_statistics(8, 4, [1, 3, 5, 7, 9, 11, 13, 15]) (48, 12)","solution":"def sales_statistics(n, k, sales): Returns the maximum number of items sold in any consecutive k days and the average number of items sold over any consecutive k days rounded down. max_sales = 0 sum_sales = sum(sales[:k]) max_sales = sum_sales for i in range(n-k): sum_sales = sum_sales - sales[i] + sales[i+k] if sum_sales > max_sales: max_sales = sum_sales avg_sales = max_sales // k return (max_sales, avg_sales)"},{"question":"def shift_string(s: str, k: int) -> str: Returns a new string where each character in s is shifted k positions to the right. >>> shift_string('abcdef', 2) 'efabcd' >>> shift_string('hello', 13) 'llohe' pass def test_shift_string_no_shift(): assert shift_string(\\"abcdef\\", 0) == \\"abcdef\\" def test_shift_string_small_shift(): assert shift_string(\\"abcdef\\", 2) == \\"efabcd\\" def test_shift_string_shift_equal_length(): assert shift_string(\\"abcdef\\", 6) == \\"abcdef\\" def test_shift_string_large_shift(): assert shift_string(\\"hello\\", 13) == \\"llohe\\" # 13 % 5 = 3, 'hello' shifted by 3 to the right def test_shift_string_large_shift_multiple_of_length(): assert shift_string(\\"abcdef\\", 12) == \\"abcdef\\" # 12 % 6 = 0 def test_shift_string_single_character(): assert shift_string(\\"a\\", 1) == \\"a\\" assert shift_string(\\"a\\", 1000) == \\"a\\" def test_shift_string_long_string(): assert shift_string(\\"abcdefghijklmnopqrstuvwxyz\\", 26) == \\"abcdefghijklmnopqrstuvwxyz\\" assert shift_string(\\"abcdefghijklmnopqrstuvwxyz\\", 27) == \\"zabcdefghijklmnopqrstuvwxy\\" assert shift_string(\\"abcdefghijklmnopqrstuvwxyz\\", 1) == \\"zabcdefghijklmnopqrstuvwxy\\"","solution":"def shift_string(s, k): Returns a new string where each character in s is shifted k positions to the right. n = len(s) k = k % n # Reduce k to be within the bounds of 0 and n-1 return s[-k:] + s[:-k] if k else s"},{"question":"def modified_fibonacci(a0, a1, n): Compute the nth term in a modified Fibonacci sequence starting with a0 and a1. >>> modified_fibonacci(0, 1, 5) 5 >>> modified_fibonacci(2, 3, 4) 13 >>> modified_fibonacci(10, 20, 0) 10 >>> modified_fibonacci(10, 20, 1) 20 >>> modified_fibonacci(1000, 1000, 2) 2000 >>> modified_fibonacci(1, 1, 5) 8 >>> modified_fibonacci(0, 1, 10) 55","solution":"def modified_fibonacci(a0, a1, n): Returns the nth term of the modified Fibonacci sequence starting with a0 and a1. if n == 0: return a0 elif n == 1: return a1 for _ in range(2, n+1): a0, a1 = a1, a0 + a1 return a1"},{"question":"def countRegions(m: int, n: int, grid: List[List[str]]) -> int: Determine the number of distinct free space regions in the town. Parameters: m (int): The number of rows in the grid. n (int): The number of columns in the grid. grid (List[List[str]]): The m x n grid represented as a list of strings, where '0' represents free spaces and '1' represents buildings. Returns: int: The number of distinct free space regions. Example: >>> countRegions(4, 5, [[\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\", \\"1\\", \\"1\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"]]) 3 >>> countRegions(3, 3, [[\\"1\\", \\"1\\", \\"1\\"], [\\"1\\", \\"0\\", \\"1\\"], [\\"1\\", \\"1\\", \\"1\\"]]) 1","solution":"def countRegions(m, n, grid): def dfs(x, y): stack = [(x, y)] while stack: cx, cy = stack.pop() if 0 <= cx < m and 0 <= cy < n and grid[cx][cy] == '0': grid[cx][cy] = '2' # Mark this cell as visited for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: stack.append((cx + dx, cy + dy)) region_count = 0 for i in range(m): for j in range(n): if grid[i][j] == '0': dfs(i, j) region_count += 1 return region_count"},{"question":"def min_moves(t: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[int]: Determine the minimum number of moves required to deliver food to all houses in the grid. >>> min_moves(1, [(3, [ [1, 0, 0], [0, 1, 0], [0, 0, 1], ])]) == [2] >>> min_moves(1, [(4, [ [1, 1, 0, 0], [0, 1, 0, 0], [0, 1, 1, 0], [0, 0, 0, 1], ])]) == [3] >>> min_moves(1, [(2, [ [1, 0], [0, 1], ])]) == [1] >>> min_moves(1, [(2, [ [0, 0], [0, 0], ])]) == [0] >>> min_moves(1, [(1, [ [1], ])]) == [0] >>> min_moves(1, [(3, [ [1, 1, 1], [1, 1, 1], [1, 1, 1], ])]) == [2] >>> min_moves(1, [(5, [ [1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], ])]) == [4]","solution":"def min_moves(t, test_cases): results = [] for case in test_cases: n, grid = case # Find the coordinates of all houses houses = [(i, j) for i in range(n) for j in range(n) if grid[i][j] == 1] # We need to reach the farthest house in terms of grid's layout max_row = max(h[0] for h in houses) if houses else 0 max_col = max(h[1] for h in houses) if houses else 0 # The minimum number of moves required to deliver food to all houses # is the largest row index or the largest column index, whichever is larger moves = max(max_row, max_col) results.append(moves) return results if __name__ == \\"__main__\\": t = int(input().strip()) test_cases = [] for _ in range(t): n = int(input().strip()) grid = [] for _ in range(n): grid.append(list(map(int, input().strip().split()))) test_cases.append((n, grid)) results = min_moves(t, test_cases) for result in results: print(result)"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring with at most 2 distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"ccc\\") 3 >>> length_of_longest_substring_two_distinct(\\"abaccc\\") 4 >>> length_of_longest_substring_two_distinct(\\"a\\") 1 >>> length_of_longest_substring_two_distinct(\\"ab\\") 2 >>> length_of_longest_substring_two_distinct(\\"abcabcabc\\") 2 >>> length_of_longest_substring_two_distinct(\\"\\") 0 >>> length_of_longest_substring_two_distinct(\\"aa\\") 2 >>> length_of_longest_substring_two_distinct(\\"abac\\") 3 pass def solve_test_cases(test_cases_list: List[str]) -> List[int]: Solves multiple test cases for the length_of_longest_substring_two_distinct function. >>> solve_test_cases([\\"eceba\\", \\"ccc\\", \\"abaccc\\"]) [3, 3, 4] >>> solve_test_cases([\\"a\\", \\"ab\\", \\"abcabcabc\\"]) [1, 2, 2] >>> solve_test_cases([\\"aabbcc\\", \\"aabbccc\\", \\"abcde\\"]) [4, 5, 2] pass","solution":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring with at most 2 distinct characters. if len(s) < 2: return len(s) left, right = 0, 0 char_count = {} max_length = 0 while right < len(s): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > 2: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length def solve_test_cases(test_cases_list): results = [] for s in test_cases_list: results.append(length_of_longest_substring_two_distinct(s)) return results"},{"question":"def replace_question_marks(s: str) -> str: Replace question marks in the given string with lowercase letters such that no three consecutive characters are the same. Returns the modified string or 'Impossible' if no valid string exists. >>> replace_question_marks('a?b') == 'acb' # One possible correct output >>> replace_question_marks('????') not in ('Impossible', 'aaa?', 'aaab', 'aaac') >>> replace_question_marks('aa?aa') == 'aabaa'","solution":"def replace_question_marks(s): Replaces question marks in the given string with lowercase letters so that no three consecutive characters are the same. Returns the modified string or 'Impossible' if no valid string exists. n = len(s) if n == 1: return 'a' if s == '?' else s s = list(s) # Convert string to list for mutability for i in range(n): if s[i] == '?': for char in 'abcdefghijklmnopqrstuvwxyz': if (i > 0 and s[i - 1] == char) or (i < n - 1 and s[i + 1] == char): continue s[i] = char break for i in range(n - 2): if s[i] == s[i + 1] == s[i + 2]: return 'Impossible' return ''.join(s)"},{"question":"def max_rides(n: int, m: int, waiting_times: List[int], thrill_levels: List[int], people: List[Tuple[int, int]]) -> List[int]: Determine the maximum number of rides each person can enjoy without exceeding their available time and while ensuring each ride chosen meets their thrill threshold. >>> max_rides(5, 3, [30, 15, 45, 35, 25], [80, 60, 40, 100, 50], [(50, 60), (90, 120), (30, 90)]) [2, 1, 3] >>> max_rides(1, 1, [5], [10], [(10, 5)]) [1] >>> max_rides(3, 1, [10, 20, 30], [10, 20, 30], [(10, 5)]) [0]","solution":"def max_rides(n, m, waiting_times, thrill_levels, people): results = [] for thrill_threshold, available_time in people: filtered_rides = [ waiting_time for waiting_time, thrill_level in zip(waiting_times, thrill_levels) if thrill_level >= thrill_threshold ] filtered_rides.sort() count = 0 total_time = 0 for ride_time in filtered_rides: if total_time + ride_time <= available_time: total_time += ride_time count += 1 else: break results.append(count) return results"},{"question":"def minimum_moves_to_equalize_height(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine the minimum number of moves required to make the tallest tower equal to the shortest tower in the chosen range of towers. Parameters: T - number of test cases test_cases - a list of tuples where each tuple contains two elements: 1. a tuple with two integers N and K 2. a list of N integers representing the heights of the towers Returns: A list of integers where each integer represents the minimum number of moves for the respective test case. Example: >>> minimum_moves_to_equalize_height(2, [((5, 3), [5, 3, 8, 1, 9]), ((6, 4), [4, 7, 2, 4, 6, 3])]) [15, 8] >>> minimum_moves_to_equalize_height(1, [((3, 2), [1, 2, 3])]) [2]","solution":"def minimum_moves_to_equalize_height(T, test_cases): results = [] for test_case in test_cases: N, K = test_case[0] heights = test_case[1] max_height = max(heights) min_height = min(heights) total_moves = 0 for height in heights: if height > K: total_moves += (height - K) elif height < K: total_moves += (K - height) results.append(total_moves) return results"},{"question":"def largest_sum_subgrid(N: int, M: int, grid: List[List[int]]) -> int: Find the largest sum of values in any contiguous rectangular subgrid. >>> largest_sum_subgrid(3, 3, [[1, 2, -1], [-3, 4, 5], [-2, 3, -4]]) 10 >>> largest_sum_subgrid(2, 4, [[-1, -2, -3, -4], [-5, -6, -7, -8]]) -1","solution":"def largest_sum_subgrid(N, M, grid): def max_subarray_sum(arr): max_sum = current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum max_sum = float('-inf') for left in range(M): temp = [0] * N for right in range(left, M): for i in range(N): temp[i] += grid[i][right] current_max_sum = max_subarray_sum(temp) max_sum = max(max_sum, current_max_sum) return max_sum # Example usage: N = 3 M = 3 grid = [ [1, 2, -1], [-3, 4, 5], [-2, 3, -4] ] print(largest_sum_subgrid(N, M, grid)) # Output should be 10"},{"question":"from typing import List def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: Merges two sorted arrays into a single sorted array. Args: arr1: List[int] - First sorted array arr2: List[int] - Second sorted array Returns: List[int] - Merged and sorted array >>> merge_sorted_arrays([1, 3, 5, 7], [2, 4, 6, 8, 10]) [1, 2, 3, 4, 5, 6, 7, 8, 10] >>> merge_sorted_arrays([1, 2, 3], [2, 5, 6, 7]) [1, 2, 2, 3, 5, 6, 7] >>> merge_sorted_arrays([1, 2, 3], [1, 2, 3]) [1, 1, 2, 2, 3, 3] >>> merge_sorted_arrays([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_arrays([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_arrays([], []) [] >>> merge_sorted_arrays([1, 4, 6, 8, 10], [2, 3, 5, 7, 9]) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array. Args: arr1: List[int] - First sorted array arr2: List[int] - Second sorted array Returns: List[int] - Merged and sorted array merged_array = [] i, j = 0, 0 # Traverse through both arrays while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # Append remaining elements of arr1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 # Append remaining elements of arr2 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"def min_water_stations(d: int, n: int, checkpoints: List[int], m: int) -> Tuple[int, List[int]]: Determine the minimum number of water stations and their positions Parameters: d (int): Length of the marathon route n (int): Number of checkpoints checkpoints (list[int]): List of positions of checkpoints m (int): Maximum distance a runner should be from a water station Returns: tuple[int, list[int]]: Minimum number of water stations and their positions Examples: >>> min_water_stations(20, 5, [2, 5, 8, 12, 17], 4) (6, [0, 4, 8, 12, 16, 20]) >>> min_water_stations(15, 0, [], 5) (4, [0, 5, 10, 15])","solution":"def min_water_stations(d, n, checkpoints, m): Determine the minimum number of water stations and their positions Parameters: d (int): Length of the marathon route n (int): Number of checkpoints checkpoints (list[int]): List of positions of checkpoints m (int): Maximum distance a runner should be from a water station Returns: tuple[int, list[int]]: Minimum number of water stations and their positions positions = [] # Place water stations at regular intervals of \`m\` along the route for i in range(0, d + m, m): if i <= d: positions.append(i) else: break return len(positions), positions"},{"question":"from datetime import datetime, timedelta from typing import List def check_overdue(checkout_dates: List[str], reference_date: str) -> List[bool]: Returns a list of booleans indicating whether each book is overdue based on the reference date. >>> check_overdue([\\"2023-09-01\\", \\"2023-08-28\\"], \\"2023-09-20\\") [True, True] >>> check_overdue([\\"2023-09-10\\", \\"2023-09-12\\"], \\"2023-09-20\\") [False, False] >>> check_overdue([\\"2023-09-01\\", \\"2023-09-14\\", \\"2023-09-15\\"], \\"2023-09-20\\") [True, False, False] >>> check_overdue([\\"2023-09-01\\"], \\"2023-09-16\\") [True] >>> check_overdue([\\"2023-09-01\\"], \\"2023-09-15\\") [False]","solution":"from datetime import datetime, timedelta def check_overdue(checkout_dates, reference_date): Returns a list of booleans indicating whether each book is overdue based on the reference date. ref_date = datetime.strptime(reference_date, \\"%Y-%m-%d\\") overdue_status = [] for checkout in checkout_dates: checkout_date = datetime.strptime(checkout, \\"%Y-%m-%d\\") if ref_date - checkout_date > timedelta(days=14): overdue_status.append(True) else: overdue_status.append(False) return overdue_status"},{"question":"def wall_operations(H: int, W: int, P: int, operations: List[List[int]]) -> List[int]: Apply paint and check operations on a wall of height H and width W with P possible colors. Args: - H (int): Height of the wall. - W (int): Width of the wall. - P (int): Number of different colors. - operations (List[List[int]]): List of operations to be performed on the wall. Returns: - List[int]: Result of each check operation. >>> wall_operations(5, 5, 3, [ [1, 1, 1, 2], [1, 2, 2, 3], [2, 1, 1], [2, 2, 1], [1, 3, 4, 1], [2, 2, 2] ]) [2, 0, 3] >>> wall_operations(3, 3, 3, [ [1, 1, 1, 1], [1, 1, 2, 2], [1, 1, 3, 3], [2, 1, 1], [2, 1, 2], [2, 1, 3] ]) [1, 2, 3]","solution":"def wall_operations(H, W, P, operations): # Initialize the wall with 0 (unpainted) wall = [[0] * W for _ in range(H)] # Store results for check operations results = [] # Process each operation for operation in operations: if operation[0] == 1: # Paint operation: 1 i j k _, i, j, k = operation wall[i-1][j-1] = k elif operation[0] == 2: # Check operation: 2 i j _, i, j = operation results.append(wall[i-1][j-1]) return results"},{"question":"def encode_data(n: int, A: List[int], P: List[int], C: List[int], k: int) -> List[int]: Encode the given data array. Parameters: - n (int): Length of the arrays - A (list of int): Original array - P (list of int): Permutation array - C (list of int): Cipher array - k (int): Modulo value Returns: - list of int: Encoded array pass from typing import List def test_example_case(): n = 4 A = [3, 1, 4, 2] P = [2, 0, 1, 3] C = [6, 5, 4, 3] k = 10 assert encode_data(n, A, P, C, k) == [0, 9, 5, 5] def test_large_k(): n = 3 A = [100, 200, 300] P = [2, 0, 1] C = [50, 50, 50] k = 1000000000 assert encode_data(n, A, P, C, k) == [350, 150, 250] def test_non_trivial_permutation(): n = 5 A = [10, 20, 30, 40, 50] P = [4, 2, 0, 3, 1] C = [5, 15, 25, 35, 45] k = 100 assert encode_data(n, A, P, C, k) == [55, 45, 35, 75, 65] def test_single_element(): n = 1 A = [7] P = [0] C = [2] k = 10 assert encode_data(n, A, P, C, k) == [9] def test_no_modulo_effect(): n = 3 A = [9, 8, 7] P = [0, 1, 2] C = [1, 1, 1] k = 20 assert encode_data(n, A, P, C, k) == [10, 9, 8]","solution":"def encode_data(n, A, P, C, k): Encode the given data array. Parameters: - n (int): Length of the arrays - A (list of int): Original array - P (list of int): Permutation array - C (list of int): Cipher array - k (int): Modulo value Returns: - list of int: Encoded array # Step 1: Permute the array A using P permuted_data = [A[P[i]] for i in range(n)] # Step 2: Add the cipher array C and take modulo k encoded_data = [(permuted_data[i] + C[i]) % k for i in range(n)] return encoded_data"},{"question":"def is_valid_phone_number(phone_number: str) -> bool: Checks if the given phone number matches the pattern (XXX)-XXX-XXXX. Args: phone_number (str): The phone number to check. Returns: bool: True if the phone number matches the pattern, False otherwise. Examples: >>> is_valid_phone_number(\\"(123)-456-7890\\") True >>> is_valid_phone_number(\\"123-456-7890\\") False >>> is_valid_phone_number(\\"(123)-45-67890\\") False >>> is_valid_phone_number(\\"(123)-456-789O\\") False","solution":"import re def is_valid_phone_number(phone_number): Checks if the given phone number matches the pattern (XXX)-XXX-XXXX. Args: phone_number (str): The phone number to check. Returns: bool: True if the phone number matches the pattern, False otherwise. pattern = r\\"(d{3})-d{3}-d{4}\\" return bool(re.fullmatch(pattern, phone_number))"},{"question":"def can_reduce_to_empty_string(s: str) -> str: Given a string s consisting of lowercase English letters, returns \\"YES\\" if it is possible to reduce the string to an empty string by removing any two adjacent identical characters any number of times, otherwise returns \\"NO\\". Examples: >>> can_reduce_to_empty_string(\\"abccba\\") \\"YES\\" >>> can_reduce_to_empty_string(\\"abccab\\") \\"NO\\" >>> can_reduce_to_empty_string(\\"aa\\") \\"YES\\" >>> can_reduce_to_empty_string(\\"abc\\") \\"NO\\"","solution":"def can_reduce_to_empty_string(s): Given a string s consisting of lowercase English letters, returns \\"YES\\" if it is possible to reduce the string to an empty string by removing any two adjacent identical characters any number of times, otherwise returns \\"NO\\". stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \\"YES\\" if not stack else \\"NO\\""},{"question":"def can_schedule_classes(n: int, class_counts: List[int]) -> str: Determines if classes can be scheduled without consecutive time slots. Parameters: n (int): Number of days. class_counts (list): List of integers representing the number of classes per day. Returns: str: \\"YES\\" if scheduling without consecutive slots is possible, otherwise \\"NO\\". >>> can_schedule_classes(3, [5, 4, 3]) \\"YES\\" >>> can_schedule_classes(2, [4, 6]) \\"NO\\" >>> can_schedule_classes(4, [2, 2, 1, 0]) \\"YES\\" from typing import List def test_can_schedule_classes(): assert can_schedule_classes(3, [5, 4, 3]) == \\"YES\\" assert can_schedule_classes(2, [4, 6]) == \\"NO\\" assert can_schedule_classes(4, [2, 2, 1, 0]) == \\"YES\\" assert can_schedule_classes(1, [6]) == \\"NO\\" assert can_schedule_classes(7, [1, 1, 2, 1, 1, 2, 2]) == \\"YES\\" assert can_schedule_classes(5, [5, 5, 5, 5, 5]) == \\"YES\\" assert can_schedule_classes(3, [3, 3, 6]) == \\"NO\\"","solution":"def can_schedule_classes(n, class_counts): Determines if classes can be scheduled without consecutive time slots. Parameters: n (int): Number of days. class_counts (list): List of integers representing the number of classes per day. Returns: str: \\"YES\\" if scheduling without consecutive slots is possible, otherwise \\"NO\\". for classes in class_counts: if classes > 5: # maximum non-consecutive slots in a day is 5 (slots 0, 2, 4, 6, 8) return \\"NO\\" return \\"YES\\""},{"question":"def is_room_available(availability: List[bool], start_day: int, end_day: int) -> str: Checks if the room is available for the entire requested period. :param availability: List of boolean values representing the room's availability. :param start_day: Integer representing the starting day of the booking request (inclusive). :param end_day: Integer representing the ending day of the booking request (inclusive). :return: \\"Accepted\\" if the room is available for the requested period, otherwise \\"Rejected\\". # Unit Tests from solution import is_room_available def test_room_fully_available_period(): assert is_room_available([True, True, True, True, True, True], 0, 5) == \\"Accepted\\" def test_room_partially_available_period(): assert is_room_available([True, True, False, True, True, True, False], 0, 2) == \\"Rejected\\" def test_room_availability_edge_case_end_day(): assert is_room_available([True, True, True, True, False], 1, 4) == \\"Rejected\\" def test_room_availability_edge_case_start_day(): assert is_room_available([False, True, True, True, True], 0, 2) == \\"Rejected\\" def test_room_available_for_single_day(): assert is_room_available([True, False, True, True], 2, 2) == \\"Accepted\\" def test_room_unavailable_for_single_day(): assert is_room_available([True, False, True, True], 1, 1) == \\"Rejected\\"","solution":"from typing import List def is_room_available(availability: List[bool], start_day: int, end_day: int) -> str: Checks if the room is available for the entire requested period. :param availability: List of boolean values representing the room's availability. :param start_day: Integer representing the starting day of the booking request (inclusive). :param end_day: Integer representing the ending day of the booking request (inclusive). :return: \\"Accepted\\" if the room is available for the requested period, otherwise \\"Rejected\\". for day in range(start_day, end_day + 1): if not availability[day]: return \\"Rejected\\" return \\"Accepted\\""},{"question":"def hourglass_sum(matrix: List[List[int]]) -> int: Calculate the maximum hourglass sum in a 6x6 matrix. Parameters: matrix (list of list of int): A 6x6 matrix of integers. Returns: int: The maximum hourglass sum. >>> hourglass_sum([ [1, 1, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0], [0, 0, 2, 4, 4, 0], [0, 0, 0, 2, 0, 0], [0, 0, 1, 2, 4, 0] ]) 19 >>> hourglass_sum([ [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1] ]) -7 >>> hourglass_sum([ [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0] ]) 0 >>> hourglass_sum([ [-9, -9, -9, 1, 1, 1], [0, -9, 0, 4, 3, 2], [-9, -9, -9, 1, 2, 3], [0, 0, 8, 6, 6, 0], [0, 0, 0, -2, 0, 0], [0, 0, 1, 2, 4, 0] ]) 28","solution":"def hourglass_sum(matrix): Calculate the maximum hourglass sum in a 6x6 matrix. Parameters: matrix (list of list of int): A 6x6 matrix of integers. Returns: int: The maximum hourglass sum. max_sum = float('-inf') for i in range(4): for j in range(4): top = matrix[i][j] + matrix[i][j + 1] + matrix[i][j + 2] middle = matrix[i + 1][j + 1] bottom = matrix[i + 2][j] + matrix[i + 2][j + 1] + matrix[i + 2][j + 2] hourglass_sum = top + middle + bottom if hourglass_sum > max_sum: max_sum = hourglass_sum return max_sum"},{"question":"def can_have_three_distinct_characters(s: str) -> str: Check if it's possible to modify exactly one character in the string \`s\` so that the resulting string contains at least three distinct characters. >>> can_have_three_distinct_characters(\\"aabc\\") \\"Yes\\" >>> can_have_three_distinct_characters(\\"aaa\\") \\"No\\" >>> can_have_three_distinct_characters(\\"abcdef\\") \\"Yes\\" >>> can_have_three_distinct_characters(\\"zzzzy\\") \\"Yes\\" >>> can_have_three_distinct_characters(\\"xyy\\") \\"No\\" def process_test_cases(t: int, test_cases: List[Tuple[int, str]]) -> List[str]: Process multiple test cases to determine if each string can be modified to have at least three distinct characters. >>> process_test_cases(5, [(4, \\"aabc\\"), (3, \\"aaa\\"), (6, \\"abcdef\\"), (5, \\"zzzzy\\"), (3, \\"xyy\\")]) [\\"Yes\\", \\"No\\", \\"Yes\\", \\"Yes\\", \\"No\\"] >>> process_test_cases(2, [(3, \\"abc\\"), (3, \\"aaa\\")]) [\\"Yes\\", \\"No\\"] >>> process_test_cases(1, [(5, \\"abcde\\")]) [\\"Yes\\"] from typing import List, Tuple def test_can_have_three_distinct_characters(): assert can_have_three_distinct_characters(\\"aabc\\") == \\"Yes\\" assert can_have_three_distinct_characters(\\"aaa\\") == \\"No\\" assert can_have_three_distinct_characters(\\"abcdef\\") == \\"Yes\\" assert can_have_three_distinct_characters(\\"zzzzy\\") == \\"Yes\\" assert can_have_three_distinct_characters(\\"xyy\\") == \\"No\\" def test_process_test_cases(): assert process_test_cases(5, [(4, \\"aabc\\"), (3, \\"aaa\\"), (6, \\"abcdef\\"), (5, \\"zzzzy\\"), (3, \\"xyy\\")]) == [\\"Yes\\", \\"No\\", \\"Yes\\", \\"Yes\\", \\"No\\"] assert process_test_cases(2, [(3, \\"abc\\"), (3, \\"aaa\\")]) == [\\"Yes\\", \\"No\\"] assert process_test_cases(1, [(5, \\"abcde\\")]) == [\\"Yes\\"]","solution":"def can_have_three_distinct_characters(s): Check if it's possible to modify exactly one character in the string \`s\` so that the resulting string contains at least three distinct characters. distinct_chars = set(s) if len(distinct_chars) >= 3: return \\"Yes\\" elif len(distinct_chars) == 2 and len(s) >= 4: return \\"Yes\\" elif len(distinct_chars) == 1 and len(s) >= 3: return \\"No\\" return \\"No\\" def process_test_cases(t, test_cases): results = [] for i in range(t): n, s = test_cases[i] results.append(can_have_three_distinct_characters(s)) return results"},{"question":"from collections import deque from typing import List, Tuple def is_valid(cell: Tuple[int, int], grid: List[List[int]], rows: int, cols: int, visited: List[List[bool]]) -> bool: Check if the cell is within bounds, not an obstacle, and not yet visited. >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> rows, cols = 3, 3 >>> visited = [[False] * cols for _ in range(rows)] >>> is_valid((0, 0), grid, rows, cols, visited) True >>> is_valid((3, 3), grid, rows, cols, visited) False pass def bfs_shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Perform BFS to find the shortest path from start to end in the grid. >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> bfs_shortest_path(grid, (0, 0), (2, 2)) 4 >>> grid = [ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> bfs_shortest_path(grid, (0, 0), (2, 2)) 4 >>> grid = [ ... [0, 1, 0], ... [1, 1, 0], ... [0, 0, 0] ... ] >>> bfs_shortest_path(grid, (0, 0), (2, 2)) -1 pass def process_test_cases(): Process multiple test cases from input and output the shortest distance or -1 if unreachable. >>> # Sample test case >>> process_test_cases() 5 5 1 1 5 5 3 3 3 2 2 5 1 4 4 0 6 7 1 1 6 7 1 3 4 0 8 9 pass","solution":"from collections import deque def is_valid(cell, grid, rows, cols, visited): x, y = cell return 0 <= x < rows and 0 <= y < cols and grid[x][y] == 0 and not visited[x][y] def bfs_shortest_path(grid, start, end): rows, cols = len(grid), len(grid[0]) queue = deque([(start, 0)]) visited = [[False]*cols for _ in range(rows)] visited[start[0]][start[1]] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: (x, y), dist = queue.popleft() if (x, y) == end: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid((nx, ny), grid, rows, cols, visited): visited[nx][ny] = True queue.append(((nx, ny), dist + 1)) return -1 def process_test_cases(): results = [] while True: m, n = map(int, input().split()) if m == 0 and n == 0: break x1, y1, x2, y2 = map(int, input().split()) k = int(input()) obstacles = [tuple(map(int, input().split())) for _ in range(k)] grid = [[0] * n for _ in range(m)] for ox, oy in obstacles: grid[ox - 1][oy - 1] = 1 x1 -= 1 y1 -= 1 x2 -= 1 y2 -= 1 result = bfs_shortest_path(grid, (x1, y1), (x2, y2)) results.append(result) for res in results: print(res) # Uncomment below line to run the function # process_test_cases()"},{"question":"from typing import List def findMaxAverage(nums: List[int], k: int) -> float: Returns the maximum average value of any subarray of length k. >>> findMaxAverage([1, 12, -5, -6, 50, 3], 4) 12.75 >>> findMaxAverage([5], 1) 5.0 >>> findMaxAverage([-5], 1) -5.0 >>> findMaxAverage([1, 2, 3, 4, 5], 2) 4.5 >>> findMaxAverage([-1, -2, -3, -4, -5], 2) -1.5 >>> findMaxAverage([3, -1, 2, -1, 4, -1], 3) 1.6666666666666667 >>> findMaxAverage([i for i in range(100000)], 1000) 99499.5 >>> findMaxAverage([1, 2, 3, 4, 5], 5) 3.0","solution":"def findMaxAverage(nums, k): Returns the maximum average value of any subarray of length k. current_sum = sum(nums[:k]) max_sum = current_sum for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum / k"},{"question":"def trap_water(n: int, heights: List[int]) -> int: Determine the amount of water that remains trapped between the blocks after it rains. >>> trap_water(12, [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_water(0, []) 0 >>> trap_water(3, [3, 3, 3]) 0 >>> trap_water(1, [1]) 0","solution":"def trap_water(n, heights): if n == 0: return 0 left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"def maximalRectangle(matrix: List[List[int]]) -> int: Given a 2D array containing 0's and 1's, return the area of the largest rectangle containing only 1's >>> maximalRectangle([ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]) 6 >>> maximalRectangle([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> maximalRectangle([ ... [1, 1], ... [1, 1] ... ]) 4","solution":"def maximalRectangle(matrix): if not matrix: return 0 max_area = 0 dp = [0] * len(matrix[0]) for row in matrix: for j in range(len(row)): dp[j] = dp[j] + 1 if row[j] == 1 else 0 max_area = max(max_area, largestRectangleArea(dp)) return max_area def largestRectangleArea(heights): stack = [-1] max_area = 0 for i in range(len(heights)): while stack[-1] != -1 and heights[stack[-1]] >= heights[i]: height = heights[stack.pop()] width = i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) while stack[-1] != -1: height = heights[stack.pop()] width = len(heights) - stack[-1] - 1 max_area = max(max_area, height * width) return max_area"},{"question":"from typing import List, Tuple def sum_of_nodes_at_max_depth(n: int, edges: List[Tuple[int, int]], values: List[Tuple[int, int]]) -> int: Given a binary tree with N nodes, where each node has a value associated with it. Find the sum of all the values of nodes that are at the maximum depth of the tree. >>> sum_of_nodes_at_max_depth(5, [(1, 2), (1, 3), (3, 4), (3, 5)], [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50)]) 90 >>> sum_of_nodes_at_max_depth(3, [(1, 2), (1, 3)], [(1, 10), (2, 20), (3, 30)]) 50 >>> sum_of_nodes_at_max_depth(1, [], [(1, 10)]) 10 >>> sum_of_nodes_at_max_depth(4, [(1, 2), (1, 3), (3, 4)], [(1, 10), (2, 20), (3, 30), (4, 40)]) 40 >>> sum_of_nodes_at_max_depth(7, [(1, 2), (1, 3), (2, 4), (3, 5), (3, 6), (5, 7)], [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60), (7, 70)]) 70","solution":"from collections import defaultdict, deque def sum_of_nodes_at_max_depth(n, edges, values): # Construct the tree from edges tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Store the values for each node node_values = dict(values) # BFS to find maximum depth and sum at that depth visited = set() queue = deque([(1, 0)]) # Start BFS from node 1 with depth 0 max_depth = 0 sum_at_max_depth = 0 while queue: node, depth = queue.popleft() if depth > max_depth: max_depth = depth sum_at_max_depth = node_values[node] elif depth == max_depth: sum_at_max_depth += node_values[node] visited.add(node) for neighbor in tree[node]: if neighbor not in visited: queue.append((neighbor, depth + 1)) visited.add(neighbor) return sum_at_max_depth"},{"question":"def find_min_abs_difference(n, arr): Find the minimum absolute difference between any two elements in the list and print all pairs with that minimum absolute difference in ascending order. >>> find_min_abs_difference(5, [1, 3, 4, 7, 9]) 1 3 4 >>> find_min_abs_difference(7, [10, 12, 15, 20, 9, 13, 25]) 1 9 10 12 13 pass def test_example_1(capsys): input_data = (5, [1, 3, 4, 7, 9]) find_min_abs_difference(*input_data) captured = capsys.readouterr() assert captured.out == \\"1n3 4n\\" def test_example_2(capsys): input_data = (7, [10, 12, 15, 20, 9, 13, 25]) find_min_abs_difference(*input_data) captured = capsys.readouterr() assert captured.out == \\"1n9 10n12 13n\\" def test_all_pairs_with_min_difference(capsys): input_data = (6, [1, 2, 3, 4, 5, 6]) find_min_abs_difference(*input_data) captured = capsys.readouterr() assert captured.out == \\"1n1 2n2 3n3 4n4 5n5 6n\\" def test_large_numbers(capsys): input_data = (3, [1000000000, 999999999, 1000000001]) find_min_abs_difference(*input_data) captured = capsys.readouterr() assert captured.out == \\"1n999999999 1000000000n1000000000 1000000001n\\" def test_two_elements(capsys): input_data = (2, [5, 10]) find_min_abs_difference(*input_data) captured = capsys.readouterr() assert captured.out == \\"5n5 10n\\" def test_negative_numbers(capsys): input_data = (5, [-10, -5, 0, 5, 10]) find_min_abs_difference(*input_data) captured = capsys.readouterr() assert captured.out == \\"5n-10 -5n-5 0n0 5n5 10n\\" if __name__ == '__main__': import pytest pytest.main()","solution":"def find_min_abs_difference(n, arr): arr.sort() min_diff = float('inf') result_pairs = [] # Find minimum absolute difference for i in range(1, n): diff = arr[i] - arr[i - 1] if diff < min_diff: min_diff = diff result_pairs = [(arr[i - 1], arr[i])] elif diff == min_diff: result_pairs.append((arr[i - 1], arr[i])) # Output the result print(min_diff) for pair in result_pairs: print(pair[0], pair[1])"},{"question":"def can_rearrange_to_increasing_sequence(N: int, k: int, sequence: List[int]) -> str: Determines if it's possible to rearrange the sequence into a strictly increasing sequence by reversing exactly k cards. Parameters: N (int): The number of cards. 1 ≤ N ≤ 100 k (int): The number of cards to reverse. 1 ≤ k ≤ N sequence (list): The sequence of N distinct integers. Returns: str: \\"YES\\" or \\"NO\\" Examples: >>> can_rearrange_to_increasing_sequence(5, 2, [1, 3, 2, 4, 5]) 'YES' >>> can_rearrange_to_increasing_sequence(6, 3, [4, 3, 2, 6, 5, 1]) 'NO' >>> can_rearrange_to_increasing_sequence(4, 2, [1, 2, 3, 4]) 'YES'","solution":"def can_rearrange_to_increasing_sequence(N, k, sequence): Determines if it's possible to rearrange the sequence into a strictly increasing sequence by reversing exactly k cards. Parameters: N (int): The number of cards. k (int): The number of cards to reverse. sequence (list): The sequence of cards. Returns: str: \\"YES\\" or \\"NO\\" # If the sequence is already sorted, return \\"YES\\" if sequence == sorted(sequence): return \\"YES\\" # Try to reverse any k consecutive cards and check the result for i in range(N - k + 1): temp_seq = sequence[:i] + sequence[i:i+k][::-1] + sequence[i+k:] if temp_seq == sorted(sequence): return \\"YES\\" return \\"NO\\""},{"question":"def garden_border_flowers(n: int, m: int) -> int: Determines the number of flowers needed to form the border of an n by m garden. :param n: Number of rows in the garden :param m: Number of columns in the garden :return: Number of flowers needed for the border >>> garden_border_flowers(3, 4) 10 >>> garden_border_flowers(1, 5) 5 >>> garden_border_flowers(6, 1) 6 >>> garden_border_flowers(4, 4) 12 >>> garden_border_flowers(1, 1) 1 >>> garden_border_flowers(100, 1) 100 >>> garden_border_flowers(1, 100) 100 >>> garden_border_flowers(10, 10) 36 >>> garden_border_flowers(99, 100) 394","solution":"def garden_border_flowers(n, m): Determines the number of flowers needed to form the border of an n by m garden. :param n: Number of rows in the garden :param m: Number of columns in the garden :return: Number of flowers needed for the border # Special case where the garden is 1 row or 1 column or 1x1 if n == 1 or m == 1: return n * m # Calculate the perimeter minus the 4 corners which are added twice return 2 * (n + m - 2)"},{"question":"def three_sum(nums, target): Determines if there are three distinct indices i, j, k in nums such that the sum at these indexes equals target. >>> three_sum([2, 7, 4, 8, 3], 15) 'YES' >>> three_sum([1, 2, 3, 4], 10) 'NO' >>> three_sum([1, 5, 5, 6], 16) 'YES' >>> three_sum([1000000000, 1000000000, 1000000000, 2], 3000000000) 'YES' >>> three_sum([0, 1, 2, 3, 4, 5], 10) 'YES' >>> three_sum([1, 1, 1, 1], 4) 'NO'","solution":"def three_sum(nums, target): Determines if there are three distinct indices i, j, k in nums such that the sum at these indexes equals target. nums.sort() n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: summation = nums[i] + nums[left] + nums[right] if summation == target: return \\"YES\\" elif summation < target: left += 1 else: right -= 1 return \\"NO\\""},{"question":"def calculate_total_cost_by_day(days_info): Calculate the total cost and quantity of a list of fruits bought over various days. :param days_info: A list where each element is a dictionary containing 'vendors' and 'shopping_list'. :type days_info: List[Dict[str, Dict[str, Union[int, float]]]] :return: A list of total costs for each day. :rtype: List[float] ... def parse_input(data): Parse the input data into structured information about days, vendors, and shopping lists. :param data: A list of strings containing the input data. :type data: List[str] :return: A list where each element is a dictionary containing 'vendors' and 'shopping_list'. :rtype: List[Dict[str, Dict[str, Union[int, float]]]] ... # Example usage and test cases def test_calculate_total_cost_by_day(): data = [ '2', '3', 'Apple 100', 'Banana 50', 'Orange 70', '2', 'Apple 2', 'Banana 3', '4', 'Strawberry 200', 'Apple 150', 'Banana 110', 'Orange 90', '3', 'Strawberry 1', 'Apple 2', 'Orange 3', '0' ] days_info = parse_input(data) result = calculate_total_cost_by_day(days_info) assert result == [350, 770], f\\"Expected [350, 770], but got {result}\\" def test_parse_input_single_case(): data = [ '1', '1', 'Mango 120', '1', 'Mango 2', '0' ] days_info = parse_input(data) expected = [ { 'vendors': {'Mango': 120}, 'shopping_list': {'Mango': 2} } ] assert days_info == expected, f\\"Expected {expected}, but got {days_info}\\" def test_parse_input_multiple_cases(): data = [ '2', '3', 'Apple 90', 'Banana 60', 'Grape 130', '2', 'Apple 1', 'Banana 2', '3', 'Apple 50', 'Banana 40', 'Grape 30', '1', 'Banana 3', '0' ] days_info = parse_input(data) expected = [ { 'vendors': {'Apple': 90, 'Banana': 60, 'Grape': 130}, 'shopping_list': {'Apple': 1, 'Banana': 2} }, { 'vendors': {'Apple': 50, 'Banana': 40, 'Grape': 30}, 'shopping_list': {'Banana': 3} } ] assert days_info == expected, f\\"Expected {expected}, but got {days_info}\\" if __name__ == \\"__main__\\": test_calculate_total_cost_by_day() test_parse_input_single_case() test_parse_input_multiple_cases() print(\\"All tests passed!\\")","solution":"def calculate_total_cost_by_day(days_info): results = [] for day in days_info: vendors = day['vendors'] shopping_list = day['shopping_list'] total_cost = 0 for fruit, qty in shopping_list.items(): if fruit in vendors: total_cost += vendors[fruit] * qty results.append(total_cost) return results def parse_input(data): index = 0 days_info = [] while index < len(data): if data[index] == '0': break d = int(data[index]) index += 1 for _ in range(d): v = int(data[index]) index += 1 vendors = {} for _ in range(v): fruit, price = data[index].split() vendors[fruit] = int(price) index += 1 f = int(data[index]) index += 1 shopping_list = {} for _ in range(f): fruit, qty = data[index].split() shopping_list[fruit] = int(qty) index += 1 day_info = { 'vendors': vendors, 'shopping_list': shopping_list } days_info.append(day_info) return days_info data = [ '2', '3', 'Apple 100', 'Banana 50', 'Orange 70', '2', 'Apple 2', 'Banana 3', '4', 'Strawberry 200', 'Apple 150', 'Banana 110', 'Orange 90', '3', 'Strawberry 1', 'Apple 2', 'Orange 3', '0' ] days_info = parse_input(data) print(calculate_total_cost_by_day(days_info))"},{"question":"def find_median(arr): Returns the median of the list \`arr\`. >>> find_median([1, 2, 3]) 2 >>> find_median([1, 2, 3, 4]) 2.5 pass def process_test_cases(t, test_cases): Processes multiple test cases and finds the median for each test case list. >>> test_cases = [(5, [5, 3, 8, 4, 2]), (4, [7, 9, 1, 5])] >>> process_test_cases(2, test_cases) [4, 6.0] >>> test_cases_one_case = [(3, [3, 1, 2])] >>> process_test_cases(1, test_cases_one_case) [2] pass","solution":"def find_median(arr): Returns the median of the list \`arr\`. arr.sort() n = len(arr) mid = n // 2 if n % 2 == 1: return arr[mid] else: return (arr[mid - 1] + arr[mid]) / 2 def process_test_cases(t, test_cases): Processes multiple test cases and finds the median for each test case list. results = [] for i in range(t): N = test_cases[i][0] arr = test_cases[i][1] median = find_median(arr) results.append(median) return results"},{"question":"def split_string(s: str, k: int) -> List[str]: Takes a string 's' and an integer 'k' as inputs and splits the string 's' into substrings of length 'k'. If the length of 's' is not a multiple of 'k', the last substring may be shorter than 'k'. >>> split_string(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\", 5) [\\"ABCDE\\", \\"FGHIJ\\", \\"KLMNO\\", \\"PQRST\\", \\"UVWXY\\", \\"Z\\"] >>> split_string(\\"HELLOWORLD\\", 3) [\\"HEL\\", \\"LOW\\", \\"ORL\\", \\"D\\"]","solution":"def split_string(s, k): Splits the string 's' into substrings of length 'k'. return [s[i:i+k] for i in range(0, len(s), k)]"},{"question":"def is_prime(num: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(5) True def longest_prime_subsequence_length(n: int, sequence: List[int]) -> int: Find the length of the longest contiguous subsequence where all integers are prime. >>> longest_prime_subsequence_length(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 2 >>> longest_prime_subsequence_length(5, [11, 13, 17, 19, 23]) 5","solution":"def is_prime(num): if num <= 1: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def longest_prime_subsequence_length(n, sequence): max_len = 0 current_len = 0 for num in sequence: if is_prime(num): current_len += 1 if current_len > max_len: max_len = current_len else: current_len = 0 return max_len"},{"question":"def can_irrigate_plants(n: int, m: int, k: int, w: List[int]) -> bool: Determines if the irrigation system can supply enough water to each plant daily for k consecutive days. >>> can_irrigate_plants(3, 10, 5, [2, 3, 1]) True >>> can_irrigate_plants(3, 5, 2, [2, 3, 6]) False","solution":"from typing import List def can_irrigate_plants(n: int, m: int, k: int, w: List[int]) -> bool: total_daily_requirement = sum(w) return total_daily_requirement <= m"},{"question":"def can_cover_garden(m: int, n: int, s: int) -> str: Determines if a garden of size m x n can be completely covered with square flower beds of side length s. Arguments: m -- the length of the garden n -- the width of the garden s -- the side length of the square flower bed Returns: 'YES' if the garden can be completely covered, 'NO' otherwise. Examples: >>> can_cover_garden(8, 6, 2) 'YES' >>> can_cover_garden(9, 7, 3) 'NO' >>> can_cover_garden(5, 5, 5) 'YES' from solution import can_cover_garden def test_can_cover_garden_example1(): assert can_cover_garden(8, 6, 2) == 'YES' def test_can_cover_garden_example2(): assert can_cover_garden(9, 7, 3) == 'NO' def test_can_cover_garden_example3(): assert can_cover_garden(5, 5, 5) == 'YES' def test_can_cover_garden_partial_overlap(): assert can_cover_garden(6, 4, 3) == 'NO' def test_can_cover_garden_perfect_fit(): assert can_cover_garden(10, 10, 1) == 'YES' def test_can_cover_garden_one_side_mismatch(): assert can_cover_garden(10, 8, 2) == 'YES' def test_can_cover_garden_large_garden_small_bed(): assert can_cover_garden(100, 100, 100) == 'YES' def test_can_cover_garden_null_case(): assert can_cover_garden(7, 5, 2) == 'NO'","solution":"def can_cover_garden(m, n, s): Determines if a garden of size m x n can be completely covered with square flower beds of side length s. Arguments: m -- the length of the garden n -- the width of the garden s -- the side length of the square flower bed Returns: 'YES' if the garden can be completely covered, 'NO' otherwise. if m % s == 0 and n % s == 0: return 'YES' else: return 'NO'"},{"question":"def merge_alternately(word1: str, word2: str) -> str: Merges two strings alternately. If one string is shorter, append the remaining characters of the longer string. >>> merge_alternately(\\"abc\\", \\"pqr\\") \\"apbqcr\\" >>> merge_alternately(\\"ab\\", \\"pqrs\\") \\"apbqrs\\" >>> merge_alternately(\\"abcd\\", \\"pq\\") \\"apbqcd\\" >>> merge_alternately(\\"\\", \\"\\") \\"\\" >>> merge_alternately(\\"abc\\", \\"\\") \\"abc\\" >>> merge_alternately(\\"\\", \\"xyz\\") \\"xyz\\" >>> merge_alternately(\\"a\\", \\"z\\") \\"az\\" >>> merge_alternately(\\"a\\", \\"\\") \\"a\\"","solution":"def merge_alternately(word1, word2): Merges two strings alternately. If one string is shorter, append the remaining characters of the longer string. Args: word1 (str): First input string. word2 (str): Second input string. Returns: str: Merged result of the two strings. merged = [] len1, len2 = len(word1), len(word2) for i in range(max(len1, len2)): if i < len1: merged.append(word1[i]) if i < len2: merged.append(word2[i]) return ''.join(merged)"},{"question":"def maximum_sum_of_length_3_subarray(n: int, a: List[int]) -> int: Returns the maximum sum of any subarray of length exactly 3 from array a. >>> maximum_sum_of_length_3_subarray(5, [1, 2, 3, 4, 5]) 12 >>> maximum_sum_of_length_3_subarray(4, [9, 1, 7, 3]) 17 >>> maximum_sum_of_length_3_subarray(6, [1, 3, 5, 7, 9, 11]) 27 >>> maximum_sum_of_length_3_subarray(7, [10, 10, 10, 10, 10, 10, 10]) 30 >>> maximum_sum_of_length_3_subarray(3, [1, 1, 1]) 3 >>> maximum_sum_of_length_3_subarray(5, [100, 99, 98, 97, 96]) 297","solution":"def maximum_sum_of_length_3_subarray(n, a): Returns the maximum sum of any subarray of length exactly 3 from array a. :param n: int, length of the array :param a: list of int, elements of the array :return: int, maximum sum of any subarray of length exactly 3 max_sum = 0 for i in range(n - 2): current_sum = a[i] + a[i+1] + a[i+2] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def min_operations_to_equal_elements(n: int, array: List[int]) -> int: Returns the minimum number of operations required to make all elements of the array equal. >>> min_operations_to_equal_elements(4, [1, 2, 3, 4]) 3 >>> min_operations_to_equal_elements(5, [5, 5, 5, 5, 5]) 0 >>> min_operations_to_equal_elements(3, [1, 100, 1000]) 2","solution":"def min_operations_to_equal_elements(n, array): Returns the minimum number of operations required to make all elements of the array equal. if len(set(array)) == 1: return 0 return n - 1"},{"question":"import re def evaluate_expression(expression, variables): try: result = eval(expression, {}, variables) return int(result) except NameError: return 'UNDEFINED' except ZeroDivisionError: return 'UNDEFINED' def parse_and_evaluate(input_lines): Evaluates a sequence of lines in a simple language with basic arithmetic operations and assignments. Args: input_lines (List[str]): A list of lines containing variable initializations, expressions, and assignments. Returns: List[Union[int, str]]: A list of results for each evaluated expression or assignment. >>> parse_and_evaluate([ ... \\"x 10\\", \\"y 20\\", \\"END OF INITIALIZATION\\", ... \\"z = x + y\\", \\"a = z * 2\\", \\"a / 5\\", ... \\"b = a - 30\\", \\"c = (a - (b * 2))\\", ... \\"w = (d + y)\\", \\"END OF EXPRESSIONS\\" ... ]) [30, 60, 12, 30, 0, \\"UNDEFINED\\"] >>> parse_and_evaluate([ ... \\"x 10\\", \\"END OF INITIALIZATION\\", ... \\"a = y + 2\\", \\"END OF EXPRESSIONS\\" ... ]) [\\"UNDEFINED\\"] >>> parse_and_evaluate([ ... \\"x 10\\", \\"END OF INITIALIZATION\\", ... \\"a = x / 0\\", \\"END OF EXPRESSIONS\\" ... ]) [\\"UNDEFINED\\"] >>> parse_and_evaluate([ ... \\"x 5\\", \\"y 3\\", \\"END OF INITIALIZATION\\", ... \\"z = x + y\\", \\"END OF EXPRESSIONS\\" ... ]) [8] >>> parse_and_evaluate([ ... \\"x 10\\", \\"y 5\\", \\"END OF INITIALIZATION\\", ... \\"z = x * (2 + y)\\", \\"END OF EXPRESSIONS\\" ... ]) [70]","solution":"import re def evaluate_expression(expression, variables): try: result = eval(expression, {}, variables) return int(result) except NameError: return 'UNDEFINED' except ZeroDivisionError: return 'UNDEFINED' def parse_and_evaluate(input_lines): variables = {} output = [] initialization_phase = True for line in input_lines: line = line.strip() if line == \\"\\": continue if line == \\"END OF INITIALIZATION\\": initialization_phase = False continue if line == \\"END OF EXPRESSIONS\\": break if initialization_phase: var, value = line.split() variables[var] = int(value) else: if \\"=\\" in line: var, expr = line.split(\\"=\\") var = var.strip() expr = expr.strip() result = evaluate_expression(expr, variables) if result != 'UNDEFINED': variables[var] = result output.append(result) else: result = evaluate_expression(line, variables) output.append(result) return output # Example usage: input_lines = [ \\"x 10\\", \\"y 20\\", \\"END OF INITIALIZATION\\", \\"z = x + y\\", \\"a = z * 2\\", \\"a / 5\\", \\"b = a - 30\\", \\"c = (a - (b * 2))\\", \\"w = (d + y)\\", \\"END OF EXPRESSIONS\\" ] print(parse_and_evaluate(input_lines)) # Expected Output: [30, 60, 12, 30, 0, 'UNDEFINED']"},{"question":"def can_cover_exactly(m: int, sections: List[int]) -> List[str]: Determine if Jane can cover exactly y sections of the wall using small and large art pieces. >>> can_cover_exactly(3, [8, 17, 10]) ['YES', 'YES', 'NO'] >>> can_cover_exactly(2, [4, 9]) ['YES', 'YES']","solution":"def can_cover_exactly(m, sections): results = [] for y in sections: found = False for small in range((y // 4) + 1): if (y - 4 * small) % 9 == 0: found = True break if found: results.append('YES') else: results.append('NO') return results"},{"question":"def second_largest(input_list: List[int]) -> int: Returns the second largest number in the list. >>> second_largest([2, 3, 6, 6, 5]) 5 >>> second_largest([10, 5, 10]) 5 >>> second_largest([1, 1, 1, 1]) None >>> second_largest([10, 9, 8, 7, 6, 5]) 9 >>> second_largest([1, 2, 3, 4, 5, 6]) 5 >>> second_largest([-1, -2, -3, -4, -5]) -2 >>> second_largest([-10, 100, 50, 50, -500, 1000, -1000]) 100 >>> second_largest([7, 14]) 7 >>> second_largest([10, 20, 20, 30]) 20","solution":"def second_largest(input_list): Returns the second largest number in the list. unique_numbers = list(set(input_list)) unique_numbers.sort() if len(unique_numbers) < 2: return None return unique_numbers[-2] # Function to handle the input as per the problem statement def find_second_largest(n, numbers): return second_largest(numbers)"},{"question":"def can_collect_all_treasures(n: int, m: int, grid: List[List[int]]) -> str: Determines if it's possible to collect all treasures while respecting the movement constraints of moving only through adjacent cells. :param n: Number of rows in the grid :param m: Number of columns in the grid :param grid: 2D list representing the grid with treasures :return: \\"YES\\" if it's possible to collect all treasures, otherwise \\"NO\\" >>> can_collect_all_treasures(3, 3, [ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ]) == \\"NO\\" >>> can_collect_all_treasures(3, 3, [ ... [1, 1, 0], ... [0, 1, 1], ... [0, 0, 0] ... ]) == \\"YES\\"","solution":"def can_collect_all_treasures(n, m, grid): Determines if it's possible to collect all treasures while respecting the movement constraints of moving only through adjacent cells. :param n: Number of rows in the grid :param m: Number of columns in the grid :param grid: 2D list representing the grid with treasures :return: \\"YES\\" if it's possible to collect all treasures, otherwise \\"NO\\" def dfs(x, y, visited): # Set the current cell as visited visited[x][y] = True # Possible movements: right, left, down, up movements = [(0, 1), (0, -1), (1, 0), (-1, 0)] for movement in movements: nx, ny = x + movement[0], y + movement[1] # If the new position is within bounds and has treasures and is not visited if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] != 0 and not visited[nx][ny]: dfs(nx, ny, visited) # Create a visited matrix initialized to False visited = [[False for _ in range(m)] for _ in range(n)] # Find the first cell with treasures to start the DFS start_x, start_y = -1, -1 for i in range(n): for j in range(m): if grid[i][j] != 0: start_x, start_y = i, j break if start_x != -1: break # If there are no treasures at all in the grid if start_x == -1: return \\"YES\\" # Perform DFS to visit all connected cells with treasures dfs(start_x, start_y, visited) # Check if all cells with treasures have been visited for i in range(n): for j in range(m): if grid[i][j] != 0 and not visited[i][j]: return \\"NO\\" return \\"YES\\""},{"question":"def num_of_ways(N: int, M: int) -> int: Returns the number of valid ways to plant the crops in an N x M field. >>> num_of_ways(2, 2) 2 >>> num_of_ways(3, 4) 4 >>> num_of_ways(5, 5) 4 >>> num_of_ways(2, 3) 4 >>> num_of_ways(1000, 1000) 4 def valid_planting_configs(test_cases: List[Tuple[int, int]]) -> List[int]: Given a list of test cases, each containing two integers N and M, returns a list of integers where each integer represents the number of valid planting configurations for the corresponding test case.","solution":"def num_of_ways(N, M): Returns the number of valid ways to plant the crops. # For a 2x2 grid, there are exactly 2 ways to alternate planting crops # For all other rectangular grids larger than 2x2, there are 4 ways as # the optimal tiling can still be done in 4 patterns. if N == 2 and M == 2: return 2 else: return 4 def valid_planting_configs(test_cases): results = [] for N, M in test_cases: if N == 0 and M == 0: break results.append(num_of_ways(N, M)) return results"},{"question":"def top_k_frequent_words(document: str, K: int) -> List[str]: Returns the top K most frequent words in the document, in descending order of frequency. If two words have the same frequency, they are sorted lexicographically. :param document: str, the preprocessed document containing words separated by spaces. :param K: int, the number of top frequent words to return. :return: list of str, the top K most frequent words. >>> top_k_frequent_words(\\"to be or not to be that is the question\\", 3) [\\"be\\", \\"to\\", \\"is\\"] >>> top_k_frequent_words(\\"a a a b b b c c d\\", 2) [\\"a\\", \\"b\\"]","solution":"from collections import Counter def top_k_frequent_words(document, K): Returns the top K most frequent words in the document, in descending order of frequency. If two words have the same frequency, they are sorted lexicographically. :param document: str, the preprocessed document containing words separated by spaces. :param K: int, the number of top frequent words to return. :return: list of str, the top K most frequent words. # Split the document into words words = document.split() # Count the frequency of each word word_count = Counter(words) # Create a list of words sorted by frequency and then alphabetically sorted_words = sorted(word_count.items(), key=lambda x: (-x[1], x[0])) # Extract the top K words top_k_words = [word for word, count in sorted_words[:K]] return top_k_words"},{"question":"def min_partitions(t: int, test_cases: List[str]) -> List[int]: Partition the strings into as few distinct substrings as possible such that each character appears in at most one substring. The substrings do not need to be continuous and can be in any order. >>> min_partitions(3, [\\"abacbc\\", \\"abcdef\\", \\"aabbcc\\"]) [3, 6, 3] >>> min_partitions(2, [\\"aa\\", \\"bb\\"]) [1, 1] >>> min_partitions(1, [\\"abcabcabc\\"]) [3] >>> min_partitions(4, [\\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\"]) [4, 4, 4, 4] >>> min_partitions(1, [\\"zyxwvutsrqponmlkjihgfedcba\\"]) [26]","solution":"def min_partitions(t, test_cases): results = [] for s in test_cases: # Using a set to store distinct characters distinct_chars = set(s) # The number of partitions required is exactly the number of distinct characters results.append(len(distinct_chars)) return results"},{"question":"from typing import List, Tuple def min_moves_to_target(m: int, n: int, grid: List[List[str]], o: int, changes: List[Tuple[int, int]]) -> int: Determine the minimum number of moves required to reach the target cell (m-1, n-1) from (0, 0). If it is not possible to reach the target cell, return -1. Args: m: int : The number of rows in the grid. n: int : The number of columns in the grid. grid: List[List[str]] : The grid containing open spaces (\`.\`) and walls (\`#\`). o: int : The number of changes in the grid. changes: List[Tuple[int, int]] : List of tuples representing the changes in the grid. Returns: int : The minimum number of moves to reach the target cell or -1 if not possible. # Example usage: m, n = 3, 3 grid = [ ['.', '#', '.'], ['.', '#', '.'], ['.', '.', '.'] ] o = 2 changes = [(1, 4), (2, 6)] print(min_moves_to_target(m, n, grid, o, changes)) # Example output: 4","solution":"from collections import deque def min_moves_to_target(m, n, grid, o, changes): dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)] def bfs(start, end, grid): queue = deque([(start, 0)]) visited = set([start]) while queue: (x, y), moves = queue.popleft() if (x, y) == end: return moves for dx, dy in dirs: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append(((nx, ny), moves + 1)) return -1 def update_grid(grid, change): i = change[1] - 1 x, y = i // n, i % n grid[x][y] = '.' if grid[x][y] == '#' else '#' start = (0, 0) end = (m-1, n-1) if grid[end[0]][end[1]] == '#': return -1 for minute in range(o + 1): if minute > 0: update_grid(grid, changes[minute - 1]) result = bfs(start, end, grid) if result != -1: return result return -1 # Example usage: m, n = 3, 3 grid = [ ['.', '#', '.'], ['.', '#', '.'], ['.', '.', '.'] ] o = 2 changes = [(1, 4), (2, 6)] print(min_moves_to_target(m, n, grid, o, changes)) # Output: 4"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Finds two distinct integers in the array that add up to the target integer and returns their indices. Parameters: nums (list): List of integers target (int): Target integer Returns: list: List containing the indices of the two numbers that add up to the target, or an empty list if no such pair exists. Example: >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([1, 2, 3, 4, 5], 10) [] from typing import List def test_two_sum_found(): assert two_sum([2, 7, 11, 15], 9) == [0, 1] assert two_sum([3, 2, 4], 6) == [1, 2] assert two_sum([3, 3], 6) == [0, 1] def test_two_sum_not_found(): assert two_sum([1, 2, 3, 4, 5], 10) == [] assert two_sum([], 0) == [] assert two_sum([1], 2) == [] def test_two_sum_with_negatives(): assert two_sum([-1, -2, -3, -4, -5], -8) == [2, 4] assert two_sum([1, -1, 2, -2], 0) == [0, 1] def test_two_sum_large_numbers(): assert two_sum([1000000, 500000, -1500000], -1000000) == [1, 2]","solution":"def two_sum(nums, target): Finds two distinct integers in the array that add up to the target integer and returns their indices. Parameters: nums (list): List of integers target (int): Target integer Returns: list: List containing the indices of the two numbers that add up to the target, or an empty list if no such pair exists. index_map = {} for i, num in enumerate(nums): complement = target - num if complement in index_map: return [index_map[complement], i] index_map[num] = i return []"},{"question":"def trap_rainwater(heights: List[int]) -> int: Calculates the amount of rainwater that can be trapped given the heights of bars. Args: heights (List[int]): List of non-negative integers representing the elevation map. Returns: int: Total units of trapped rainwater. from solution import trap_rainwater def test_trap_rainwater_sample_1(): assert trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 def test_trap_rainwater_sample_2(): assert trap_rainwater([4, 2, 0, 3, 2, 5]) == 9 def test_trap_rainwater_empty(): assert trap_rainwater([]) == 0 def test_trap_rainwater_single_element(): assert trap_rainwater([5]) == 0 def test_trap_rainwater_no_trapping(): assert trap_rainwater([1, 2, 3, 4, 5]) == 0 assert trap_rainwater([5, 4, 3, 2, 1]) == 0 def test_trap_rainwater_various_cases(): assert trap_rainwater([2, 0, 2]) == 2 assert trap_rainwater([3, 0, 2, 0, 4]) == 7 assert trap_rainwater([0, 0, 0, 1, 0, 0]) == 0","solution":"def trap_rainwater(heights): Calculates the amount of rainwater that can be trapped given the heights of bars. Args: heights (List[int]): List of non-negative integers representing the elevation map. Returns: int: Total units of trapped rainwater. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n trapped_water = 0 # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate trapped water for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water # Example Usage # sample_input = list(map(int, \\"0 1 0 2 1 0 1 3 2 1 2 1\\".split())) # print(trap_rainwater(sample_input)) # Output should be 6"},{"question":"def minimize_max_diff(nums: List[int]) -> List[int]: Reorders the list of integers such that the maximum difference between adjacent integers in the reordered list is minimized. :param nums: List[int] - List of unique integers :return: List[int] - Reordered list >>> minimize_max_diff([10, 1, 9, 3, 6]) [1, 3, 6, 9, 10] >>> minimize_max_diff([4, 8, 1, 3]) [1, 3, 4, 8]","solution":"def minimize_max_diff(nums): Reorders the list of integers such that the maximum difference between adjacent integers in the reordered list is minimized. :param nums: List[int] - List of unique integers :return: List[int] - Reordered list nums.sort() return nums"},{"question":"def sum_elements_greater_than_k(matrix, k): Returns the sum of all elements in the matrix that are greater than k. total_sum = 0 for row in matrix: for element in row: if element > k: total_sum += element return total_sum def create_matrix_and_calculate_sum(m, n, matrix_elements, k): Wrapper function to create a matrix from provided elements list and calculate the sum of all elements in the matrix that are greater than k. >>> create_matrix_and_calculate_sum(3, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9], 5) 30 >>> create_matrix_and_calculate_sum(2, 2, [1, 2, 3, 4], 5) 0 from solution import create_matrix_and_calculate_sum def test_example_case(): m = 3 n = 3 matrix_elements = [1, 2, 3, 4, 5, 6, 7, 8, 9] k = 5 assert create_matrix_and_calculate_sum(m, n, matrix_elements, k) == 30 def test_all_elements_less_than_k(): m = 2 n = 2 matrix_elements = [1, 2, 3, 4] k = 5 assert create_matrix_and_calculate_sum(m, n, matrix_elements, k) == 0 def test_no_elements_greater_than_k(): m = 2 n = 2 matrix_elements = [5, 5, 5, 5] k = 5 assert create_matrix_and_calculate_sum(m, n, matrix_elements, k) == 0 def test_all_elements_greater_than_k(): m = 2 n = 3 matrix_elements = [6, 7, 8, 9, 10, 11] k = 5 assert create_matrix_and_calculate_sum(m, n, matrix_elements, k) == 51 def test_single_row(): m = 1 n = 5 matrix_elements = [1, 6, 7, 8, 2] k = 5 assert create_matrix_and_calculate_sum(m, n, matrix_elements, k) == 21 def test_single_column(): m = 4 n = 1 matrix_elements = [2, 4, 6, 8] k = 5 assert create_matrix_and_calculate_sum(m, n, matrix_elements, k) == 14 def test_various_elements(): m = 3 n = 3 matrix_elements = [1000, 999, 100, 900, 800, 700, 600, 500, 300] k = 500 assert create_matrix_and_calculate_sum(m, n, matrix_elements, k) == 4999","solution":"def sum_elements_greater_than_k(matrix, k): Returns the sum of all elements in the matrix that are greater than k. total_sum = 0 for row in matrix: for element in row: if element > k: total_sum += element return total_sum def create_matrix_and_calculate_sum(m, n, matrix_elements, k): Wrapper function to create a matrix from provided elements list and calculate the sum of all elements in the matrix that are greater than k. matrix = [] for i in range(m): row = matrix_elements[i * n:(i + 1) * n] matrix.append(row) return sum_elements_greater_than_k(matrix, k)"},{"question":"def find_smallest_missing_positive_integer(arr): Find the smallest positive integer that does not appear in the array. >>> find_smallest_missing_positive_integer([1, 3, 6, 4, 1, 2]) 5 >>> find_smallest_missing_positive_integer([1, 2, 3]) 4 >>> find_smallest_missing_positive_integer([]) 1 def process_test_cases(test_cases): Processes multiple test cases for finding the smallest missing positive integer in each array. >>> process_test_cases([(6, [1, 3, 6, 4, 1, 2]), (3, [1, 2, 3]), (0, [])]) [5, 4, 1] >>> process_test_cases([(5, [2, 3, 4, 5, 10]), (4, [1, 1, 1, 1])]) [1, 2]","solution":"def find_smallest_missing_positive_integer(arr): Finds the smallest positive integer that does not appear in the array. if not arr: return 1 # Use a set for O(1) lookups number_set = set(arr) # Start checking from 1 upwards smallest_missing = 1 while smallest_missing in number_set: smallest_missing += 1 return smallest_missing def process_test_cases(test_cases): Processes multiple test cases for finding the smallest missing positive integer in each array. results = [] for case in test_cases: _, arr = case results.append(find_smallest_missing_positive_integer(arr)) return results"},{"question":"def min_changes_to_ensure_no_adjacent_same(N: int, beads: List[int]) -> int: Returns the minimum number of beads that need to be changed to ensure no two adjacent beads have the same ID. >>> min_changes_to_ensure_no_adjacent_same(5, [1, 2, 2, 3, 3]) 2 >>> min_changes_to_ensure_no_adjacent_same(4, [1, 1, 1, 1]) 2 pass def solve_beads_problem(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: For each test case, calculate the minimum number of beads to change to ensure no two adjacent beads have the same ID. >>> solve_beads_problem(2, [(5, [1, 2, 2, 3, 3]), (4, [1, 1, 1, 1])]) [2, 2] >>> solve_beads_problem(1, [(6, [1, 2, 3, 4, 5, 6])]) [0] pass","solution":"def min_changes_to_ensure_no_adjacent_same(N, beads): Returns the minimum number of beads that need to be changed to ensure no two adjacent beads have the same ID. if N == 1: return 0 changes = 0 for i in range(1, N): if beads[i] == beads[i - 1]: changes += 1 # Change current bead to any other ID between 1 and 50 (inclusive) not used in its neighbors for new_id in range(1, 51): if (i == N-1 or new_id != beads[i + 1]) and new_id != beads[i - 1]: beads[i] = new_id break return changes def solve_beads_problem(T, test_cases): results = [] for N, beads in test_cases: results.append(min_changes_to_ensure_no_adjacent_same(N, beads)) return results"},{"question":"def is_armstrong_number(n: int) -> bool: Determines if a given integer N is an Armstrong number. An Armstrong number for a given number of digits is an integer such that the sum of its digits each raised to the power of the number of digits equals the number itself. >>> is_armstrong_number(153) # True >>> is_armstrong_number(947) # False >>> is_armstrong_number(9474) # True >>> is_armstrong_number(10) # False >>> is_armstrong_number(7) # True # Your code here","solution":"def is_armstrong_number(n): Determines if a given number n is an Armstrong number. num_str = str(n) num_digits = len(num_str) num_sum = sum(int(digit) ** num_digits for digit in num_str) return num_sum == n"},{"question":"def longest_substring_with_two_distinct_chars(s: str) -> int: Find the length of the longest contiguous substring that contains at most two distinct characters. >>> longest_substring_with_two_distinct_chars(\\"eceba\\") 3 >>> longest_substring_with_two_distinct_chars(\\"ccaabbb\\") 5 >>> longest_substring_with_two_distinct_chars(\\"abaccc\\") 4 def solve(t: int, test_cases: List[str]) -> List[int]: Solve the problem for multiple test cases >>> solve(3, [\\"eceba\\", \\"ccaabbb\\", \\"abaccc\\"]) [3, 5, 4]","solution":"def longest_substring_with_two_distinct_chars(s): distinct_count = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in distinct_count: distinct_count[s[right]] += 1 else: distinct_count[s[right]] = 1 while len(distinct_count) > 2: distinct_count[s[left]] -= 1 if distinct_count[s[left]] == 0: del distinct_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length def solve(t, test_cases): results = [] for s in test_cases: results.append(longest_substring_with_two_distinct_chars(s)) return results"},{"question":"def can_form_k_unique_subsequences(N: int, K: int) -> str: Determines if it's possible to form exactly K unique subsequences from N spells. Args: N (int): The number of spells. K (int): The required number of unique subsequences. Returns: str: \\"YES\\" if it is possible to form the required number of unique subsequences, \\"NO\\" otherwise. >>> can_form_k_unique_subsequences(5, 3) \\"YES\\" >>> can_form_k_unique_subsequences(7, 7) \\"YES\\" >>> can_form_k_unique_subsequences(4, 5) \\"NO\\" def magic_tournament(T: int, test_cases: List[Tuple[int, int]]) -> List[str]: Processes multiple test cases to determine if the required unique subsequences can be formed. Args: T (int): Number of test cases. test_cases (List[Tuple[int, int]]): List of (N, K) tuples representing each test case. Returns: List[str]: List of results for each test case. >>> magic_tournament(3, [(5, 3), (7, 7), (4, 2)]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> magic_tournament(3, [(5, 1), (7, 8), (4, 4)]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> magic_tournament(2, [(1, 1), (6, 5)]) [\\"YES\\", \\"YES\\"]","solution":"def can_form_k_unique_subsequences(N, K): Determines if it's possible to form exactly K unique subsequences from N spells. Args: N (int): The number of spells. K (int): The required number of unique subsequences. Returns: str: \\"YES\\" if it is possible to form the required number of unique subsequences, \\"NO\\" otherwise. if K <= N: return \\"YES\\" return \\"NO\\" def magic_tournament(T, test_cases): Processes multiple test cases to determine if the required unique subsequences can be formed. Args: T (int): Number of test cases. test_cases (list of tuples): List of (N, K) tuples representing each test case. Returns: list: List of results for each test case. results = [] for i in range(T): N, K = test_cases[i] result = can_form_k_unique_subsequences(N, K) results.append(result) return results"},{"question":"def largest_connected_component(R: int, C: int, grid: List[str]) -> int: Returns the size of the largest connected component of passable cells ('.') in the grid. >>> largest_connected_component(3, 4, [ ... \\".#..\\", ... \\"..#.\\", ... \\".#..\\"]) == 5 >>> largest_connected_component(2, 2, [ ... \\"\\", ... \\"\\"]) == 0 >>> largest_connected_component(5, 5, [ ... \\"..#..\\", ... \\"..#..\\", ... \\"#\\", ... \\"..#..\\", ... \\"..#..\\"]) == 4","solution":"def largest_connected_component(R, C, grid): Returns the size of the largest connected component of passable cells ('.') in the grid. def dfs(x, y): # If the current cell is outside the grid or already visited or an obstacle if x < 0 or y < 0 or x >= R or y >= C or grid[x][y] == '#' or visited[x][y]: return 0 # Mark the current cell as visited visited[x][y] = True # Initialize the size of the component with the current cell itself size = 1 # Move in all four possible directions (right, left, down, up) size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size visited = [[False for _ in range(C)] for __ in range(R)] max_size = 0 for i in range(R): for j in range(C): if grid[i][j] == '.' and not visited[i][j]: # Calculate the size of the connected component component_size = dfs(i, j) max_size = max(max_size, component_size) return max_size"},{"question":"def minimum_adjacent_swaps(rows: List[List[int]]) -> List[int]: Returns the minimum number of adjacent swaps needed to sort each row of plants. Args: rows (list of list): A list where each element is a list of integers representing plant heights. Returns: list: A list of integers where each element represents the minimum number of adjacent swaps for that row. >>> minimum_adjacent_swaps([[3, 1, 2]]) == [2] >>> minimum_adjacent_swaps([[4, 5, 6]]) == [0] >>> minimum_adjacent_swaps([[1, 5, 3, 4]]) == [2] >>> minimum_adjacent_swaps([[1, 2, 3, 4, 5]]) == [0] >>> minimum_adjacent_swaps([[5, 4, 3, 2, 1]]) == [10] >>> minimum_adjacent_swaps([[], [3, 2, 1]]) == [0, 3] # Your code here def test_minimum_adjacent_swaps(): assert minimum_adjacent_swaps([[3, 1, 2]]) == [2] assert minimum_adjacent_swaps([[4, 5, 6]]) == [0] assert minimum_adjacent_swaps([[1, 5, 3, 4]]) == [2] assert minimum_adjacent_swaps([[1, 2, 3, 4, 5]]) == [0] assert minimum_adjacent_swaps([[5, 4, 3, 2, 1]]) == [10] assert minimum_adjacent_swaps([[], [3, 2, 1]]) == [0, 3] def test_multiple_rows(): input_rows = [ [3, 1, 2], [4, 5, 6], [1, 5, 3, 4], [10, 9, 8, 7] ] expected_output = [2, 0, 2, 6] assert minimum_adjacent_swaps(input_rows) == expected_output def test_edge_cases(): assert minimum_adjacent_swaps([[]]) == [0] assert minimum_adjacent_swaps([[1]]) == [0] assert minimum_adjacent_swaps([[2, 1]]) == [1] assert minimum_adjacent_swaps([[1, 2]]) == [0]","solution":"def merge_sort_and_count(arr): Helper function that uses merge sort and counts inversions. Args: arr (list): List of integers representing plant heights. Returns: tuple: A sorted list of integers and the count of adjacent swaps (inversions). if len(arr) <= 1: return arr, 0 mid = len(arr) // 2 left, left_inv = merge_sort_and_count(arr[:mid]) right, right_inv = merge_sort_and_count(arr[mid:]) merged, merge_inv = merge_and_count(left, right) return merged, left_inv + right_inv + merge_inv def merge_and_count(left, right): Helper function that merges two sorted lists and counts inversions. Args: left (list): Left half of the list. right (list): Right half of the list. Returns: tuple: A merged sorted list and the count of adjacent swaps (inversions). merged = [] i = j = swaps = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 swaps += len(left) - i merged.extend(left[i:]) merged.extend(right[j:]) return merged, swaps def minimum_adjacent_swaps(rows): Returns the minimum number of adjacent swaps needed to sort each row of plants. Args: rows (list of list): A list where each element is a list of integers representing plant heights. Returns: list: A list of integers where each element represents the minimum number of adjacent swaps for that row. results = [] for row in rows: _, count = merge_sort_and_count(row) results.append(count) return results"},{"question":"def count_pairs(s: str) -> int: Returns the number of pairs (i, j) such that s[i] is not equal to s[j] for the given string s. >>> count_pairs(\\"abc\\") 3 >>> count_pairs(\\"aaa\\") 0","solution":"def count_pairs(s): Returns the number of pairs (i, j) such that s[i] is not equal to s[j] for the given string s. n = len(s) char_count = {} # Count the occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Number of pairs (i, j) such that 1 ≤ i < j ≤ |s| total_pairs = n * (n - 1) // 2 # Subtract the pairs where characters are the same for count in char_count.values(): total_pairs -= count * (count - 1) // 2 return total_pairs"},{"question":"def cycle_detector(n: int, matrix: List[List[int]]) -> str: Determine if there is a cycle in the directed graph represented by the adjacency matrix. Args: n (int): the number of vertices in the graph matrix (List[List[int]]): adjacency matrix of size n x n representing the graph Returns: str: \\"YES\\" if there is a cycle in the graph, otherwise \\"NO\\" Examples: >>> cycle_detector(3, [[0, 1, 0], [0, 0, 1], [1, 0, 0]]) \\"YES\\" >>> cycle_detector(3, [[0, 1, 0], [0, 0, 1], [0, 0, 0]]) \\"NO\\" >>> cycle_detector(4, [[0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4], [0, 0, 0, 0]]) \\"NO\\"","solution":"def has_cycle(n, graph): def dfs(v, visited, rec_stack): visited[v] = True rec_stack[v] = True for neighbour in range(n): if graph[v][neighbour] != 0: # there is an edge if not visited[neighbour]: if dfs(neighbour, visited, rec_stack): return True elif rec_stack[neighbour]: return True rec_stack[v] = False return False visited = [False] * n rec_stack = [False] * n for node in range(n): if not visited[node]: if dfs(node, visited, rec_stack): return True return False def cycle_detector(n, matrix): if has_cycle(n, matrix): return \\"YES\\" else: return \\"NO\\""},{"question":"def can_convert_to_target(n: int, arr: List[int], target: List[int]) -> str: Determines if it is possible to convert 'arr' to 'target' by reversing any subarray. Parameters: n (int): The length of the arrays. arr (List[int]): The original array. target (List[int]): The target array. Returns: str: \\"YES\\" if it's possible to convert \`arr\` to \`target\`, otherwise \\"NO\\". Examples: >>> can_convert_to_target(5, [3, 1, 2, 5, 4], [1, 2, 3, 4, 5]) YES >>> can_convert_to_target(4, [4, 3, 2, 1], [1, 2, 3, 5]) NO","solution":"def can_convert_to_target(n, arr, target): Determines if it is possible to convert 'arr' to 'target' by reversing any subarray. sorted_arr = sorted(arr) return \\"YES\\" if sorted_arr == target else \\"NO\\""},{"question":"def max_stock_shoe_type(n: int, branches: List[str]) -> str: Determines the shoe type that has the maximum stock across all branches combined. Args: n: An integer representing the number of branches. branches: A list of strings where each string corresponds to the stock in a branch. Return: A string containing the shoe type with the maximum stock and its count. >>> max_stock_shoe_type(3, [\\"AADBC\\", \\"DABA\\", \\"CBAA\\"]) \\"A 6\\" >>> max_stock_shoe_type(4, [\\"CCCC\\", \\"BBBB\\", \\"AAAA\\", \\"DDDD\\"]) \\"A 4\\"","solution":"def max_stock_shoe_type(n, branches): Determines the shoe type that has the maximum stock across all branches combined. Args: n: An integer representing the number of branches. branches: A list of strings where each string corresponds to the stock in a branch. Returns: A string containing the shoe type with the maximum stock and its count. from collections import Counter # Combine all the stocks into one string combined_stock = ''.join(branches) # Count occurrences of each shoe type stock_counter = Counter(combined_stock) # Find the shoe type with maximum stock (lexicographically smallest in case of a tie) max_shoe_type = min(stock_counter.items(), key=lambda x: (-x[1], x[0])) return f\\"{max_shoe_type[0]} {max_shoe_type[1]}\\""},{"question":"from typing import List, Tuple def longest_even_sum_subsequence(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the length of the longest subsequence with an even sum for each test case. Args: test_cases (List[Tuple[int, List[int]]]): A list of test cases, where each test case is a tuple containing an integer n, the number of elements in the sequence, followed by a list of integers that represent the sequence elements. Returns: List[int]: A list of integers representing the length of the longest subsequence with an even sum for each test case. Example: >>> longest_even_sum_subsequence([(4, [1, 2, 3, 4]), (3, [1, 3, 5])]) [4, 2] >>> longest_even_sum_subsequence([(5, [2, 4, 6, 8, 10]), (1, [3])]) [5, 0]","solution":"def longest_even_sum_subsequence(test_cases): results = [] for case in test_cases: n, seq = case[0], case[1:] seq_sum = sum(seq) if seq_sum % 2 == 0: results.append(n) else: # If there is any odd number in the sequence odd_present = any(x % 2 != 0 for x in seq) if odd_present: results.append(n - 1) else: # If there's no odd number, we can't make the sum even results.append(0) return results"},{"question":"def has_pair_with_sum(arr, target): Determine if there are two distinct elements in \`arr\` that sum up to \`target\`. Parameters: arr (list): List of positive integers. target (int): Target sum. Returns: bool: True if there exists a pair of distinct elements that sum up to \`target\`. False otherwise. >>> has_pair_with_sum([1, 2, 3, 9, 7], 8) True >>> has_pair_with_sum([1, 2, 4, 4], 8) True >>> has_pair_with_sum([3, 5, 6], 10) False def process_test_cases(T, test_cases): Process multiple test cases to check for pairs summing to a target value. Parameters: T (int): Number of test cases test_cases (list of tuples): Each tuple consists of (n, arr, target) Returns: list of bool: List of results for each test case. >>> T = 3 >>> test_cases = [ ... (5, [1, 2, 3, 9, 7], 8), ... (4, [1, 2, 4, 4], 8), ... (3, [3, 5, 6], 10) ... ] >>> process_test_cases(T, test_cases) [True, True, False]","solution":"def has_pair_with_sum(arr, target): Determine if there are two distinct elements in \`arr\` that sum up to \`target\`. Parameters: arr (list): List of positive integers. target (int): Target sum. Returns: bool: True if there exists a pair of distinct elements that sum up to \`target\`. False otherwise. seen = set() for num in arr: if target - num in seen: return True seen.add(num) return False def process_test_cases(T, test_cases): Process multiple test cases to check for pairs summing to a target value. Parameters: T (int): Number of test cases test_cases (list of tuples): Each tuple consists of (n, arr, target) Returns: list of bool: List of results for each test case. results = [] for n, arr, target in test_cases: results.append(has_pair_with_sum(arr, target)) return results"},{"question":"def is_oid(n: int, array: List[int], x: int) -> str: Determines if x is in the array. Parameters: n (int): the number of elements in the array array (list): the list of n distinct integers x (int): the integer to be checked Returns: str: \\"YES\\" if x is in the array, otherwise \\"NO\\" Examples: >>> is_oid(5, [3, 1, 4, 2, 5], 1) 'YES' >>> is_oid(5, [3, 1, 4, 2, 5], 6) 'NO' from solution import is_oid def test_is_oid_found_in_array(): assert is_oid(5, [3, 1, 4, 2, 5], 1) == \\"YES\\" assert is_oid(5, [3, 1, 4, 2, 5], 5) == \\"YES\\" assert is_oid(1, [999], 999) == \\"YES\\" def test_is_oid_not_found_in_array(): assert is_oid(5, [3, 1, 4, 2, 5], 6) == \\"NO\\" assert is_oid(3, [10, 20, 30], 15) == \\"NO\\" assert is_oid(2, [1000000000, 999999999], 1000000001) == \\"NO\\" def test_is_oid_varied_cases(): assert is_oid(2, [1, 1000000000], 1) == \\"YES\\" assert is_oid(2, [1, 1000000000], 1000000000) == \\"YES\\" assert is_oid(2, [1, 1000000000], 500000000) == \\"NO\\"","solution":"def is_oid(n, array, x): Determines if x is in the array. Parameters: n (int): the number of elements in the array array (list): the list of n distinct integers x (int): the integer to be checked Returns: str: \\"YES\\" if x is in the array, otherwise \\"NO\\" return \\"YES\\" if x in array else \\"NO\\""},{"question":"def next_state_of_grid(m: int, n: int, grid: List[List[int]]) -> List[List[int]]: Returns the next state of the grid based on the given rules. Args: m (int): number of rows in the grid. n (int): number of columns in the grid. grid (List[List[int]]): 2D list representing the current state of the grid. Returns: List[List[int]]: The next state of the grid. Examples: >>> m, n = 4, 3 >>> grid = [ ... [0, 1, 0], ... [1, 1, 1], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> next_state_of_grid(m, n, grid) [[1, 1, 1], [1, 0, 1], [1, 1, 1], [0, 0, 0]] >>> m, n = 4, 4 >>> grid = [ ... [0, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 0] ... ] >>> next_state_of_grid(m, n, grid) [[0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]","solution":"def next_state_of_grid(m, n, grid): Returns the next state of the grid based on the given rules. def count_live_neighbors(x, y): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] live_neighbors = 0 for dx, dy in directions: if 0 <= x + dx < m and 0 <= y + dy < n: live_neighbors += grid[x + dx][y + dy] return live_neighbors next_grid = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): live_neighbors = count_live_neighbors(i, j) if grid[i][j] == 1: if live_neighbors < 2 or live_neighbors > 3: next_grid[i][j] = 0 else: next_grid[i][j] = 1 else: if live_neighbors == 3: next_grid[i][j] = 1 return next_grid # Example Usage: m = 4 n = 3 grid = [ [0, 1, 0], [1, 1, 1], [0, 1, 0], [0, 0, 0], ] print(next_state_of_grid(m, n, grid))"},{"question":"class TreeNode: def __init__(self, value): Initialize a TreeNode with a given value. self.value = value self.left = None self.right = None def find_levels(T: int, test_cases: List[Dict[str, Any]]) -> List[int]: For each test case, find the level of the node with value \`Q\` in the BitTree formed by inserting given node values. Args: T: An integer denoting the number of test cases. test_cases: A list of dictionaries, each containing: - \`NQ\`: A tuple of two integers (N, Q) - \`values\`: A list of N distinct integers representing node values Returns: A list of integers representing the level of the node with value \`Q\`. If the value \`Q\` is not present in the tree, return -1. Example: >>> T = 2 >>> test_cases = [ ... {\\"NQ\\": (5, 3), \\"values\\": [10, 5, 3, 7, 15]}, ... {\\"NQ\\": (3, 10), \\"values\\": [5, 15, 20]} ... ] >>> find_levels(T, test_cases) [3, -1]","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def insert(root, value): if root is None: return TreeNode(value) if value < root.value: root.left = insert(root.left, value) else: root.right = insert(root.right, value) return root def find_level(root, value, level=1): if root is None: return -1 if root.value == value: return level if value < root.value: return find_level(root.left, value, level + 1) else: return find_level(root.right, value, level + 1) def find_levels(T, test_cases): results = [] for i in range(T): N, Q = test_cases[i]['NQ'] values = test_cases[i]['values'] root = None for value in values: root = insert(root, value) level = find_level(root, Q) results.append(level) return results"},{"question":"from typing import List def minimum_non_zero_and_subseq_sum(n: int, arr: List[int]) -> int: Given an array of n integers, find the minimum sum of a non-empty subsequence that has the property that the bitwise AND of all its elements is non-zero. If no such subsequence exists, return -1. >>> minimum_non_zero_and_subseq_sum(5, [5, 3, 12, 6, 7]) 3 >>> minimum_non_zero_and_subseq_sum(4, [0, 0, 0, 0]) -1 >>> minimum_non_zero_and_subseq_sum(4, [10, 10, 10, 10]) 10 >>> minimum_non_zero_and_subseq_sum(3, [4, 2, 6]) 2","solution":"def minimum_non_zero_and_subseq_sum(n, arr): min_sum = float('inf') for value in arr: if value != 0: min_sum = min(min_sum, value) return min_sum if min_sum != float('inf') else -1"},{"question":"def longest_subarray_length(n: int, k: int, nums: List[int]) -> int: Returns the length of the longest subarray where the product of its elements is strictly less than k. >>> longest_subarray_length(5, 100, [1, 2, 3, 4, 5]) 4 >>> longest_subarray_length(7, 10, [10, 5, 2, 6, 3, 1, 2]) 3","solution":"def longest_subarray_length(n, k, nums): Returns the length of the longest subarray where the product of its elements is strictly less than k. start = 0 product = 1 max_length = 0 for end in range(n): product *= nums[end] while start <= end and product >= k: product //= nums[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def rearrange_sequence(N: int, sequence: List[int]) -> str: Determines if it's possible to rearrange the sequence such that the absolute difference between any two consecutive integers is exactly one. Args: N: int - the number of elements in the sequence. sequence: list of int - the sequence of integers. Returns: str: rearranged sequence as a string if possible, else \\"Not Possible\\". >>> rearrange_sequence(4, [3, 2, 4, 1]) '1 2 3 4' >>> rearrange_sequence(3, [1, 4, 3]) 'Not Possible' >>> rearrange_sequence(5, [-1, 0, 1, 2, 3]) '-1 0 1 2 3'","solution":"def rearrange_sequence(N, sequence): Determines if it's possible to rearrange the sequence such that the absolute difference between any two consecutive integers is exactly one. Args: N: int - the number of elements in the sequence. sequence: list of int - the sequence of integers. Returns: str: rearranged sequence as a string if possible, else \\"Not Possible\\". sequence.sort() for i in range(1, N): if abs(sequence[i] - sequence[i-1]) != 1: return \\"Not Possible\\" return \\" \\".join(map(str, sequence)) # Function to parse input and call corresponding function def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) sequence = list(map(int, data[1:])) return rearrange_sequence(N, sequence)"},{"question":"def process_queries(n: int, q: int, array: List[int], queries: List[str]) -> List[int]: Processes 'max' and 'set' queries on the given array. >>> process_queries(5, 4, [1, 3, 2, 5, 4], [\\"max 2 4\\", \\"set 3 5 0\\", \\"max 1 3\\", \\"max 4 5\\"]) [5, 3, 0] >>> process_queries(6, 3, [1, 1, 1, 1, 1, 1], [\\"set 1 3 2\\", \\"max 1 6\\", \\"set 4 6 3\\"]) [2] >>> process_queries(3, 2, [5, 3, 4], [\\"max 1 2\\", \\"max 3 3\\"]) [5, 4] >>> process_queries(4, 0, [2, 4, 1, 6], []) [] >>> process_queries(1, 1, [100], [\\"set 1 1 5\\"]) [] >>> process_queries(5, 3, [9, 8, 7, 6, 10], [\\"max 1 5\\", \\"max 1 5\\", \\"max 1 5\\"]) [10, 10, 10] >>> process_queries(4, 3, [5, 10, 15, 20], [\\"set 2 3 25\\", \\"max 1 4\\", \\"max 3 4\\"]) [25, 25] >>> process_queries(6, 2, [100, 100, 100, 100, 100, 100], [\\"set 1 6 0\\", \\"max 1 6\\"]) [0] pass","solution":"def process_queries(n, q, array, queries): Processes 'max' and 'set' queries on the given array. Parameters: n (int): Number of elements in the array. q (int): Number of queries. array (list): List of n integers representing the array. queries (list): List of q queries in the format \\"max l r\\" or \\"set l r x\\". Returns: list: List of results for each 'max' query. results = [] for query in queries: parts = query.split() if parts[0] == \\"max\\": l = int(parts[1]) - 1 r = int(parts[2]) - 1 results.append(max(array[l:r+1])) elif parts[0] == \\"set\\": l = int(parts[1]) - 1 r = int(parts[2]) - 1 x = int(parts[3]) for i in range(l, r+1): array[i] = x return results"},{"question":"def can_form_palindrome(s: str) -> str: Determines if any permutation of the string can be a palindrome. >>> can_form_palindrome(\\"civic\\") == \\"YES\\" >>> can_form_palindrome(\\"ivicc\\") == \\"YES\\" >>> can_form_palindrome(\\"hello\\") == \\"NO\\" def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Processes multiple test cases for checking palindrome permutations. >>> process_test_cases(3, [\\"civic\\", \\"ivicc\\", \\"hello\\"]) == [\\"YES\\", \\"YES\\", \\"NO\\"] >>> process_test_cases(2, [\\"aabb\\", \\"racecar\\"]) == [\\"YES\\", \\"YES\\"]","solution":"def can_form_palindrome(s): Determines if any permutation of the string can be a palindrome. from collections import Counter count = Counter(s) odd_count = sum(1 for x in count.values() if x % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\" def process_test_cases(T, test_cases): results = [] for case in test_cases: results.append(can_form_palindrome(case)) return results # Sample usage: # T = 3 # test_cases = [\\"civic\\", \\"ivicc\\", \\"hello\\"] # print(process_test_cases(T, test_cases)) # Output: ['YES', 'YES', 'NO']"},{"question":"from collections import deque, defaultdict from typing import List, Tuple def longest_path_in_tree(N: int, edges: List[Tuple[int, int]]) -> int: Implement a function to find the longest path in a tree. The length of a path is measured by the number of edges in the path. The input tree is represented as an undirected graph, and is given in the form of an adjacency list. Arguments: N (int): The number of nodes in the tree. edges (List[Tuple[int, int]]): The edges in the tree. Returns: int: The length of the longest path in the tree. Example: >>> longest_path_in_tree(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) 3 >>> longest_path_in_tree(4, [(1, 2), (2, 3), (3, 4)]) 3","solution":"from collections import deque, defaultdict def longest_path_in_tree(N, edges): def bfs(start): visited = [-1] * (N + 1) queue = deque([start]) visited[start] = 0 farthest_node = start max_distance = 0 while queue: node = queue.popleft() current_distance = visited[node] for neighbor in adj_list[node]: if visited[neighbor] == -1: visited[neighbor] = current_distance + 1 queue.append(neighbor) if visited[neighbor] > max_distance: max_distance = visited[neighbor] farthest_node = neighbor return farthest_node, max_distance adj_list = defaultdict(list) for a, b in edges: adj_list[a].append(b) adj_list[b].append(a) # Step 1: Find farthest node from an arbitrary node, say 1 farthest_node, _ = bfs(1) # Step 2: Find the diameter by starting BFS from the farthest node _, diameter = bfs(farthest_node) return diameter"},{"question":"from typing import List, Tuple def estimate_bakery_needs(n: int, orders: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Given the number of orders and a list of orders specifying the day of the week and the quantity of a particular baked good ordered on that day, determine the minimum quantity the bakery should prepare for each day of the week. Args: n (int): The number of orders. orders (List[Tuple[str, int]]): A list of tuples where each tuple contains a string representing the day of the week and an integer representing the quantity of the particular baked good ordered. Returns: List[Tuple[str, int]]: A list of tuples where each tuple contains a string representing the day of the week and an integer representing the minimum quantity of that particular baked good the bakery should prepare for that day. >>> estimate_bakery_needs(5, [(\\"Monday\\", 15), (\\"Tuesday\\", 10), (\\"Monday\\", 20), (\\"Wednesday\\", 25), (\\"Tuesday\\", 5)]) [('Monday', 20), ('Tuesday', 10), ('Wednesday', 25), ('Thursday', 0), ('Friday', 0), ('Saturday', 0), ('Sunday', 0)] >>> estimate_bakery_needs(1, [(\\"Monday\\", 15)]) [('Monday', 15), ('Tuesday', 0), ('Wednesday', 0), ('Thursday', 0), ('Friday', 0), ('Saturday', 0), ('Sunday', 0)] pass # Your implementation goes here","solution":"def estimate_bakery_needs(n, orders): days_of_week = [\\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\", \\"Saturday\\", \\"Sunday\\"] daily_needs = {day: 0 for day in days_of_week} for order in orders: day, quantity = order daily_needs[day] = max(daily_needs[day], quantity) return [(day, daily_needs[day]) for day in days_of_week] # Example usage: # orders = [ # (\\"Monday\\", 15), # (\\"Tuesday\\", 10), # (\\"Monday\\", 20), # (\\"Wednesday\\", 25), # (\\"Tuesday\\", 5) # ] # print(estimate_bakery_needs(5, orders)) # Output should be: # [('Monday', 20), ('Tuesday', 10), ('Wednesday', 25), # ('Thursday', 0), ('Friday', 0), ('Saturday', 0), ('Sunday', 0)]"},{"question":"class ParkingGarage: A parking garage class to manage the capacity of compact and regular cars. Methods: - __init__(self, compactLimit: int, regularLimit: int): Initializes the parking garage. - park(self, carType: str) -> bool: Parks a car of the given type if there is capacity. - leave(self, carType: str) -> bool: Removes a car of the given type if there is any parked. Example: >>> garage = ParkingGarage(2, 2) >>> garage.park(\\"compact\\") True >>> garage.park(\\"regular\\") True >>> garage.park(\\"compact\\") True >>> garage.park(\\"compact\\") False >>> garage.leave(\\"compact\\") True >>> garage.park(\\"compact\\") True >>> garage.leave(\\"compact\\") True >>> garage.leave(\\"compact\\") True >>> garage.leave(\\"compact\\") False def __init__(self, compactLimit: int, regularLimit: int): pass def park(self, carType: str) -> bool: pass def leave(self, carType: str) -> bool: pass # Unit Tests def test_park_compact(): garage = ParkingGarage(2, 2) assert garage.park(\\"compact\\") == True assert garage.park(\\"compact\\") == True assert garage.park(\\"compact\\") == False def test_park_regular(): garage = ParkingGarage(2, 2) assert garage.park(\\"regular\\") == True assert garage.park(\\"regular\\") == True assert garage.park(\\"regular\\") == False def test_leave_compact(): garage = ParkingGarage(2, 2) garage.park(\\"compact\\") garage.park(\\"compact\\") assert garage.leave(\\"compact\\") == True assert garage.leave(\\"compact\\") == True assert garage.leave(\\"compact\\") == False def test_leave_regular(): garage = ParkingGarage(2, 2) garage.park(\\"regular\\") garage.park(\\"regular\\") assert garage.leave(\\"regular\\") == True assert garage.leave(\\"regular\\") == True assert garage.leave(\\"regular\\") == False def test_mixed(): garage = ParkingGarage(1, 1) assert garage.park(\\"compact\\") == True assert garage.park(\\"regular\\") == True assert garage.park(\\"compact\\") == False assert garage.park(\\"regular\\") == False assert garage.leave(\\"compact\\") == True assert garage.leave(\\"compact\\") == False assert garage.leave(\\"regular\\") == True assert garage.leave(\\"regular\\") == False","solution":"class ParkingGarage: def __init__(self, compactLimit: int, regularLimit: int): self.compactLimit = compactLimit self.regularLimit = regularLimit self.compactCount = 0 self.regularCount = 0 def park(self, carType: str) -> bool: if carType == \\"compact\\": if self.compactCount < self.compactLimit: self.compactCount += 1 return True else: return False elif carType == \\"regular\\": if self.regularCount < self.regularLimit: self.regularCount += 1 return True else: return False else: return False def leave(self, carType: str) -> bool: if carType == \\"compact\\": if self.compactCount > 0: self.compactCount -= 1 return True else: return False elif carType == \\"regular\\": if self.regularCount > 0: self.regularCount -= 1 return True else: return False else: return False"},{"question":"def min_trees_to_cut(trees: List[int]) -> int: Given an array of integers where each element represents the height of a tree, find the minimum number of trees that need to be cut down so that the remaining trees have a strictly increasing height from left to right. >>> min_trees_to_cut([3, 2, 1, 4, 5]) 2 >>> min_trees_to_cut([1, 3, 2, 4]) 1 >>> min_trees_to_cut([5, 4, 3]) 2 >>> min_trees_to_cut([1, 2, 3, 4, 5]) 0 >>> min_trees_to_cut([2, 2, 2, 2, 2]) 4 >>> min_trees_to_cut([1, 3, 2, 4, 3, 5]) 2 >>> min_trees_to_cut([1]) 0 >>> min_trees_to_cut([1, 2]) 0 >>> min_trees_to_cut([2, 1]) 1","solution":"def min_trees_to_cut(trees): Returns the minimum number of trees that need to be cut down to get a strictly increasing height of trees from left to right. n = len(trees) if n <= 1: return 0 # dp array to store the length of the longest increasing subsequence ending at i dp = [1] * n for i in range(1, n): for j in range(i): if trees[i] > trees[j]: dp[i] = max(dp[i], dp[j] + 1) max_increasing_length = max(dp) return n - max_increasing_length"},{"question":"def min_operations_to_palindrome(n: int, s: str) -> int: Calculates the minimum number of operations required to transform the string s into a palindrome. Parameters: n (int): Length of the string s (str): The input string consisting of lowercase Latin letters Returns: int: The minimum number of operations required Examples: >>> min_operations_to_palindrome(5, \\"abcar\\") 2 >>> min_operations_to_palindrome(4, \\"abcd\\") 2 >>> min_operations_to_palindrome(7, \\"racecar\\") 0","solution":"def min_operations_to_palindrome(n, s): This function calculates the minimum number of operations required to transform the string s into a palindrome. Parameters: n (int): Length of the string s (str): The input string Returns: int: The minimum number of operations required operations = 0 # Checking each character with its corresponding character from the end for i in range(n // 2): if s[i] != s[n - i - 1]: operations += 1 return operations"},{"question":"def multiply_digits_until_single(n: int) -> int: Repeatedly multiplies the digits of 'n' until a single-digit value is obtained. >>> multiply_digits_until_single(39) 4 >>> multiply_digits_until_single(77) 8 >>> multiply_digits_until_single(10) 0 def process_test_cases(test_cases: List[int]) -> List[int]: Processes a list of test cases, where each case is an integer. Returns a list of results where each result is the final single-digit value obtained from the sequence of operations for the corresponding test case. >>> process_test_cases([39, 77, 10]) [4, 8, 0] >>> process_test_cases([99, 56]) [8, 0] >>> process_test_cases([3, 7]) [3, 7]","solution":"def multiply_digits_until_single(n): Repeatedly multiplies the digits of 'n' until a single-digit value is obtained. while n > 9: product = 1 while n > 0: product *= (n % 10) n //= 10 n = product return n def process_test_cases(test_cases): Processes a list of test cases, where each case is an integer. Returns a list of results where each result is the final single-digit value obtained from the sequence of operations for the corresponding test case. results = [] for number in test_cases: results.append(multiply_digits_until_single(number)) return results"},{"question":"def calculate_subtree_sums(n, values, edges): Determine the sum of vertex values in the subtree rooted at each vertex in an undirected tree. Args: n (int): The number of vertices in the tree. values (List[int]): A list of integers representing the values of the vertices. edges (List[Tuple[int, int]]): A list of tuples representing the edges between the vertices. Returns: List[int]: A list containing the sum of vertex values in the subtree rooted at each vertex. Example: >>> calculate_subtree_sums(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (2, 4), (2, 5)]) [15, 11, 3, 4, 5] def test_example_case(): n = 5 values = [1, 2, 3, 4, 5] edges = [(1, 2), (1, 3), (2, 4), (2, 5)] result = calculate_subtree_sums(n, values, edges) assert result == [15, 11, 3, 4, 5] def test_single_node(): n = 1 values = [10] edges = [] result = calculate_subtree_sums(n, values, edges) assert result == [10] def test_two_nodes(): n = 2 values = [5, 6] edges = [(1, 2)] result = calculate_subtree_sums(n, values, edges) assert result == [11, 6] def test_three_nodes_linear(): n = 3 values = [1, 3, 2] edges = [(1, 2), (2, 3)] result = calculate_subtree_sums(n, values, edges) assert result == [6, 5, 2] def test_four_nodes(): n = 4 values = [1, 1, 1, 1] edges = [(1, 2), (1, 3), (3, 4)] result = calculate_subtree_sums(n, values, edges) assert result == [4, 1, 2, 1]","solution":"def calculate_subtree_sums(n, values, edges): from collections import defaultdict, deque # Create an adjacency list for representing the tree tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Initialize the sums array subtree_sum = [0] * (n + 1) # Function to perform DFS and calculate subtree sums def dfs(node, parent): total = values[node - 1] for neighbor in tree[node]: if neighbor != parent: total += dfs(neighbor, node) subtree_sum[node] = total return total # Perform DFS from the root node which is 1 in this example dfs(1, -1) return subtree_sum[1:] # Example usage: # n = 5 # values = [1, 2, 3, 4, 5] # edges = [(1, 2), (1, 3), (2, 4), (2, 5)] # print(calculate_subtree_sums(n, values, edges)) # Output: [15, 11, 3, 4, 5]"},{"question":"def can_form_target(n: int, str_list: List[str], target: str) -> str: Returns \\"Yes\\" if the target string can be formed by concatenating any combination of strings from the list (repetitions allowed). Otherwise returns \\"No\\". >>> can_form_target(3, [\\"ab\\", \\"ba\\", \\"a\\"], \\"aba\\") \\"Yes\\" >>> can_form_target(2, [\\"abc\\", \\"def\\"], \\"abcdefg\\") \\"No\\"","solution":"def can_form_target(n, str_list, target): Returns \\"Yes\\" if the target string can be formed by concatenating any combination of strings from the list (repetitions allowed). Otherwise returns \\"No\\". dp = [False] * (len(target) + 1) dp[0] = True for i in range(1, len(target) + 1): for string in str_list: if len(string) <= i and dp[i - len(string)] and target[i-len(string):i] == string: dp[i] = True break return \\"Yes\\" if dp[len(target)] else \\"No\\""},{"question":"def max_difference(n: int, values: List[int], edges: List[Tuple[int, int]]) -> int: Returns the maximum difference between the values of any two nodes in the tree. >>> max_difference(3, [1, 3, 2], [(1, 2), (1, 3)]) == 2 >>> max_difference(4, [10, 5, 3, 12], [(1, 2), (1, 3), (2, 4)]) == 9 def parse_input(data: str) -> Tuple[int, List[int], List[Tuple[int, int]]]: Parses the input data and returns the number of nodes, the values of the nodes, and the list of edges. >>> parse_input('''3n1 3 2n1 2n1 3''') (3, [1, 3, 2], [(1, 2), (1, 3)]) >>> parse_input('''4n10 5 3 12n1 2n1 3n2 4''') (4, [10, 5, 3, 12], [(1, 2), (1, 3), (2, 4)])","solution":"def max_difference(n, values, edges): Returns the maximum difference between the values of any two nodes in the tree. return max(values) - min(values) def parse_input(data): lines = data.strip().split('n') n = int(lines[0]) values = list(map(int, lines[1].split())) edges = [tuple(map(int, line.split())) for line in lines[2:]] return n, values, edges"},{"question":"def min_swaps_to_bring_ones_together(n, arr): Find the minimum number of swaps required to bring all the 1s in a given binary array together. Args: n (int): the length of the array. arr (List[int]): the binary array. Returns: int: the minimum number of swaps required. Example: >>> min_swaps_to_bring_ones_together(7, [1, 0, 1, 0, 1, 0, 1]) 2 >>> min_swaps_to_bring_ones_together(8, [1, 0, 0, 1, 0, 1, 0, 1]) 2 pass def min_swaps_for_all_cases(test_cases): Process multiple test cases for bringing all 1s together with minimum swaps. Args: test_cases (List[Tuple[int, List[int]]]): a list of tuples, where each tuple contains the length of the array and the binary array. Returns: List[int]: a list of integers where each integer is the result for each test case. Example: >>> test_cases = [(7, [1, 0, 1, 0, 1, 0, 1]), (8, [1, 0, 0, 1, 0, 1, 0, 1])] >>> min_swaps_for_all_cases(test_cases) [2, 2] pass from solution import min_swaps_for_all_cases def test_single_case_all_ones(): test_cases = [(5, [1, 1, 1, 1, 1])] expected = [0] assert min_swaps_for_all_cases(test_cases) == expected def test_single_case_already_together(): test_cases = [(7, [1, 1, 1, 0, 0, 0, 0])] expected = [0] assert min_swaps_for_all_cases(test_cases) == expected def test_single_case_example(): test_cases = [(7, [1, 0, 1, 0, 1, 0, 1])] expected = [2] assert min_swaps_for_all_cases(test_cases) == expected def test_multiple_cases(): test_cases = [(7, [1, 0, 1, 0, 1, 0, 1]), (8, [1, 0, 0, 1, 0, 1, 0, 1])] expected = [2, 2] assert min_swaps_for_all_cases(test_cases) == expected def test_case_no_ones(): test_cases = [(5, [0, 0, 0, 0, 0])] expected = [0] assert min_swaps_for_all_cases(test_cases) == expected def test_case_one_element(): test_cases = [(1, [1]), (1, [0])] expected = [0, 0] assert min_swaps_for_all_cases(test_cases) == expected","solution":"def min_swaps_to_bring_ones_together(n, arr): num_ones = sum(arr) if num_ones == 0 or num_ones == n: return 0 max_ones_in_window = 0 current_ones_count = 0 for i in range(num_ones): current_ones_count += arr[i] max_ones_in_window = current_ones_count for i in range(num_ones, n): current_ones_count += arr[i] - arr[i - num_ones] max_ones_in_window = max(max_ones_in_window, current_ones_count) return num_ones - max_ones_in_window def min_swaps_for_all_cases(test_cases): results = [] for n, arr in test_cases: results.append(min_swaps_to_bring_ones_together(n, arr)) return results"},{"question":"def can_ensure_max_travel_time(n: int, m: int, k: int, roads: List[Tuple[int, int, int]]) -> Tuple[str, List[Tuple[int, int, int]]]: Determines if it's possible to ensure the travel time between any two cities does not exceed k minutes. Returns a tuple (\\"YES\\", modified_roads) or (\\"NO\\", []). Args: n (int): Number of cities. m (int): Number of roads. k (int): Maximum allowable travel time between any pair of cities. roads (List[Tuple[int, int, int]]): List containing tuples with the roads and their travel times. Returns: Tuple[str, List[Tuple[int, int, int]]]: \\"YES\\" and the list of modified roads or \\"NO\\". >>> can_ensure_max_travel_time(4, 4, 10, [(1, 2, 8), (2, 3, 12), (3, 4, 15), (4, 1, 20)]) ('YES', [(1, 2, 8), (2, 3, 10), (3, 4, 10), (4, 1, 10)]) >>> can_ensure_max_travel_time(3, 3, 5, [(1, 2, 6), (2, 3, 7), (3, 1, 8)]) ('NO', [])","solution":"def can_ensure_max_travel_time(n, m, k, roads): Determines if it's possible to ensure the travel time between any two cities does not exceed k minutes. Returns a tuple (\\"YES\\", modified_roads) or (\\"NO\\", []). modified_roads = [] for u, v, t in roads: if t <= k: modified_roads.append((u, v, t)) else: modified_roads.append((u, v, k)) # It's always possible to set road times <= k since we are allowed to reduce any t > k to k return \\"YES\\", modified_roads"},{"question":"def max_subarray_sum(arr): Finds the maximum sum of any contiguous subarray within the sequence. >>> max_subarray_sum([2, 3, 1, 5]) == 11 >>> max_subarray_sum([-3, -4, -1, -2]) == -1 >>> max_subarray_sum([-2, 1, -3, 4, -1]) == 4 >>> max_subarray_sum([]) == float('-inf') >>> max_subarray_sum([4]) == 4 >>> max_subarray_sum([-4]) == -4 >>> max_subarray_sum([-1, -2, -3, -4, -5]) == -1","solution":"def max_subarray_sum(arr): Finds the maximum sum of any contiguous subarray within the sequence. :param arr: List of integers. :return: Integer, the maximum sum of any contiguous subarray. max_so_far = float('-inf') max_ending_here = 0 for num in arr: max_ending_here += num if max_so_far < max_ending_here: max_so_far = max_ending_here if max_ending_here < 0: max_ending_here = 0 return max_so_far # Example of using the function (for testing purposes) n = 5 arr = [-2, 1, -3, 4, -1] print(max_subarray_sum(arr)) # Output: 4"},{"question":"def can_rearrange_students(n: int, heights: List[int]) -> str: Determines if students can be rearranged in such a way that every student is taller than the preceding one. Parameters: n (int): Number of students. heights (list of int): List of student heights. Returns: str: \\"YES\\" if students can be rearranged to meet the requirements, otherwise \\"NO\\". Examples: >>> can_rearrange_students(5, [1, 3, 2, 4, 5]) 'YES' >>> can_rearrange_students(3, [5, 3, 5]) 'NO'","solution":"def can_rearrange_students(n, heights): Determines if students can be rearranged in such a way that every student is taller than the preceding one. Parameters: n (int): Number of students. heights (list of int): List of student heights. Returns: str: \\"YES\\" if students can be rearranged to meet the requirements, otherwise \\"NO\\". # Convert the list to a set to remove duplicates unique_heights = set(heights) # If the length of the set is not equal to the length of the original list, # it means there were duplicates. if len(unique_heights) != len(heights): return \\"NO\\" return \\"YES\\""},{"question":"def is_palindrome(s: str) -> bool: Checks if the given string s is a palindrome, ignoring spaces, punctuation, and capitalization. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") == True >>> is_palindrome(\\"hello\\") == False def check_palindromes(n: int, strings: List[str]) -> List[str]: For each string in strings, checks if it is a palindrome and prints \\"YES\\" or \\"NO\\". >>> check_palindromes(4, [\\"A man, a plan, a canal, Panama\\", \\"racecar\\", \\"hello\\", \\"Madam In Eden, I’m Adam\\"]) == [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] >>> check_palindromes(4, [\\"\\", \\"Noon\\", \\"Able was I ere I saw Elba\\", \\"Not a palindrome\\"]) == [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def is_palindrome(s): Checks if the given string s is a palindrome, ignoring spaces, punctuation, and capitalization. cleaned_s = ''.join(char.lower() for char in s if char.isalnum()) return cleaned_s == cleaned_s[::-1] def check_palindromes(n, strings): For each string in strings, checks if it is a palindrome and prints \\"YES\\" or \\"NO\\". results = [] for s in strings: if is_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def rank_scores(n, scores): Given the number of participants and their scores, return the rank of each score in the original list. Args: n: an integer denoting the number of participants scores: a list of integers representing the scores Returns: A list of integers representing the rank of each score in the original list order. Examples: >>> rank_scores(5, [300, 500, 200, 600, 100]) [3, 2, 4, 1, 5] >>> rank_scores(3, [450, 350, 550]) [2, 3, 1] >>> rank_scores(1, [500]) [1] >>> rank_scores(4, [700, 800, 600, 900]) [3, 2, 4, 1] >>> rank_scores(3, [1000, 100, 500]) [1, 3, 2] >>> rank_scores(4, [1000, 900, 800, 700]) [1, 2, 3, 4] >>> rank_scores(4, [700, 800, 900, 1000]) [4, 3, 2, 1]","solution":"def rank_scores(n, scores): Given the number of participants and their scores, return the rank of each score in the original list. Args: n: an integer denoting the number of participants scores: a list of integers representing the scores Returns: A list of integers representing the rank of each score in the original list order. # Sort the scores and determine ranks sorted_scores = sorted(scores, reverse=True) score_to_rank = {score: rank + 1 for rank, score in enumerate(sorted_scores)} # Assign ranks based on original score list ranks = [score_to_rank[score] for score in scores] return ranks"},{"question":"from typing import List, Tuple def suggest_friends(n: int, m: int, friendships: List[Tuple[int, int]], u: int) -> List[int]: Suggest potential friends for a user based on two-hop friends in the social network. n: int - the number of users m: int - the number of friendships friendships: List[Tuple[int, int]] - each tuple represents a friendship (a, b) u: int - the user ID for which to find suggested friends Returns: List[int] - user IDs of the suggested friends in increasing order or [-1] if no suggestions Example: >>> suggest_friends(6, 5, [(1, 2), (2, 3), (2, 4), (3, 5), (4, 6)], 2) [5, 6] >>> suggest_friends(4, 2, [(1, 2), (3, 4)], 1) [-1] # Placeholder for the implementation","solution":"def suggest_friends(n, m, friendships, u): from collections import defaultdict # Create an adjacency list to represent the social network graph adj_list = defaultdict(set) for a, b in friendships: adj_list[a].add(b) adj_list[b].add(a) # Get direct friends of u direct_friends = adj_list[u] # To store the suggested friends suggested_friends = set() # Traverse the friends of u's friends (two-hop friends) for friend in direct_friends: for friend_of_friend in adj_list[friend]: # Add to suggested friends if not u and not a direct friend of u if friend_of_friend != u and friend_of_friend not in direct_friends: suggested_friends.add(friend_of_friend) # Convert to list and return in sorted order or -1 if no suggested friends suggested_friends = sorted(suggested_friends) if not suggested_friends: return [-1] return suggested_friends"},{"question":"def is_latin_square_possible(grid): Check if the grid can be transformed into a Latin square by swapping rows or columns. >>> is_latin_square_possible([[1, 2, 3], [3, 1, 2], [2, 3, 1]]) 'YES' >>> is_latin_square_possible([[1, 2, 3], [1, 3, 2], [3, 1, 2]]) 'NO' def solve(t, test_cases): Solve the problem for multiple test cases. >>> solve(1, [(3, [[1, 2, 3], [3, 1, 2], [2, 3, 1]])]) ['YES'] >>> solve(2, [(3, [[1, 2, 3], [3, 1, 2], [2, 3, 1]]), (4, [[1, 2, 3, 4], [2, 3, 4, 1], [3, 4, 1, 2], [4, 1, 2, 3]])]) ['YES', 'YES']","solution":"def is_latin_square_possible(grid): n = len(grid) # Check all rows and columns have values between 1 and n for i in range(n): row = set(grid[i]) col = set(grid[j][i] for j in range(n)) if row != set(range(1, n+1)) or col != set(range(1, n+1)): return \\"NO\\" return \\"YES\\" def solve(t, test_cases): results = [] for case in test_cases: n, grid = case result = is_latin_square_possible(grid) results.append(result) return results"},{"question":"def can_form_palindrome(s: str) -> str: Determines if a string can be rearranged to form a palindrome. Parameters: s (str): The input string. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\". >>> can_form_palindrome(\\"civic\\") \\"YES\\" >>> can_form_palindrome(\\"ivicc\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\" >>> can_form_palindrome(\\"aabbcc\\") \\"YES\\"","solution":"def can_form_palindrome(s): Determines if a string can be rearranged to form a palindrome. Parameters: s (str): The input string. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\". from collections import Counter # Count frequency of each character freq = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in freq.values() if count % 2 == 1) # A string can form a palindrome if there is at most one character with an odd frequency return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def replace_digits_with_words(s: str) -> str: Transform the string such that every numeric digit (0-9) is replaced by its corresponding English word. >>> replace_digits_with_words(\\"a1b2\\") 'aonebtwo' >>> replace_digits_with_words(\\"123hello456\\") 'onetwothreehellofourfivesix' >>> replace_digits_with_words(\\"n0m9\\") 'nzeromnine'","solution":"def replace_digits_with_words(s: str) -> str: digit_to_word = { '0': 'zero', '1': 'one', '2': 'two', '3': 'three', '4': 'four', '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine' } result = [] for char in s: if char.isdigit(): result.append(digit_to_word[char]) else: result.append(char) return ''.join(result)"},{"question":"def count_magic_strings(test_cases): Count how many strings are magic strings in each test case. A magic string is defined as a string that either starts with the character 'A' and ends with the character 'Z' or starts with the character 'Z' and ends with the character 'A'. >>> count_magic_strings([(3, [\\"AZ\\", \\"ZZ\\", \\"ZA\\"])]) [2] >>> count_magic_strings([(4, [\\"AA\\", \\"AZ\\", \\"ZA\\", \\"ZZZZZZ\\"])]) [2] def parse_input(input_string): Parse the input data and return test cases in the required format. >>> parse_input(\\"2n3nAZnZZnZAn4nAAnAZnZAnZZZZZZn\\") [(3, [\\"AZ\\", \\"ZZ\\", \\"ZA\\"]), (4, [\\"AA\\", \\"AZ\\", \\"ZA\\", \\"ZZZZZZ\\"])] def test_count_magic_strings_single_test_case(): input_data = \\"1n3nAZnZZnZAn\\" test_cases = parse_input(input_data) result = count_magic_strings(test_cases) assert result == [2] def test_count_magic_strings_multiple_test_cases(): input_data = \\"2n3nAZnZZnZAn4nAAnAZnZAnZZZZZZn\\" test_cases = parse_input(input_data) result = count_magic_strings(test_cases) assert result == [2, 2] def test_count_magic_strings_no_magic_strings(): input_data = \\"1n4nAAnBBnCCnDDn\\" test_cases = parse_input(input_data) result = count_magic_strings(test_cases) assert result == [0] def test_count_magic_strings_all_magic_strings(): input_data = \\"1n4nAZnZAnAZnZAn\\" test_cases = parse_input(input_data) result = count_magic_strings(test_cases) assert result == [4] def test_count_magic_strings_empty_string(): input_data = \\"1n1nn\\" test_cases = parse_input(input_data) result = count_magic_strings(test_cases) assert result == [0] def test_parse_input(): input_data = 2 3 AZ ZZ ZA 4 AA AZ ZA ZZZZZZ expected_output = [ (3, [\\"AZ\\", \\"ZZ\\", \\"ZA\\"]), (4, [\\"AA\\", \\"AZ\\", \\"ZA\\", \\"ZZZZZZ\\"]) ] assert parse_input(input_data) == expected_output","solution":"def count_magic_strings(test_cases): results = [] for case in test_cases: N, strings = case magic_count = sum(1 for s in strings if (s.startswith('A') and s.endswith('Z')) or (s.startswith('Z') and s.endswith('A'))) results.append(magic_count) return results def parse_input(input_string): lines = input_string.strip().split(\\"n\\") T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) strings = lines[index + 1: index + 1 + N] test_cases.append((N, strings)) index += N + 1 return test_cases"},{"question":"MOD = 10**9 + 7 def catalan_number(n): Calculate the nth Catalan number modulo 10^9 + 7. pass def count_balanced_strings(n): Calculate the number of balanced strings of length n. A balanced string has an equal number of 'A's and 'B's, and for any prefix of the string, the number of 'A's is never less than the number of 'B's. Args: - n: The length of the strings (1 ≤ n ≤ 10^5). Returns: - The number of different balanced strings of length n modulo 10^9 + 7. >>> count_balanced_strings(4) 2 >>> count_balanced_strings(6) 5 >>> count_balanced_strings(3) 0 pass","solution":"MOD = 10**9 + 7 def catalan_number(n): if n == 0: return 1 c = [0]* (n + 1) c[0] = 1 for i in range(1, n + 1): c[i] = (2 * (2 * i - 1) * c[i - 1]) // (i + 1) c[i] %= MOD return c[n] def count_balanced_strings(n): if n % 2 != 0: return 0 n //= 2 return catalan_number(n)"},{"question":"def is_vault_locked(events: List[Tuple[int, str]]) -> str: Determines if the vault will be locked at the end of the day given a list of events. Each event is a tuple (timestamp, event_type) where event_type is either 'open' or 'close'. >>> is_vault_locked([(1, 'open'), (2, 'close'), (3, 'open'), (4, 'close'), (5, 'open')]) 'NO' >>> is_vault_locked([(1, 'open'), (2, 'close'), (3, 'open'), (4, 'close'), (5, 'open'), (6, 'close')]) 'YES' >>> is_vault_locked([(1, 'open'), (2, 'close'), (3, 'open')]) 'NO' pass def process_test_cases(test_cases: List[List[Tuple[int, str]]]) -> List[str]: Processes multiple test cases to determine if the vault will be locked at the end of each day. >>> process_test_cases([[(1, 'open'), (2, 'close'), (3, 'open'), (4, 'close'), (5, 'open')], [(1, 'open'), (2, 'close'), (3, 'open'), (4, 'close'), (5, 'open'), (6, 'close')]]) ['NO', 'YES'] pass def main(input_data: str) -> None: Main function to read input, process test cases and print results. >>> input_data = '3n5n1 openn2 closen3 openn4 closen5 openn6n1 openn2 closen3 openn4 closen5 openn6 closen3n1 openn2 closen3 openn' >>> main(input_data) NO YES NO pass if __name__ == \\"__main__\\": import sys input_data = sys.stdin.read() main(input_data)","solution":"def is_vault_locked(events): Determines if the vault will be locked at the end of the day given a list of events. Each event is a tuple (timestamp, event_type) where event_type is either 'open' or 'close'. open_count = 0 close_count = 0 for _, event in events: if event == 'open': open_count += 1 elif event == 'close': close_count += 1 return 'YES' if open_count == close_count else 'NO' def process_test_cases(test_cases): results = [] for events in test_cases: results.append(is_vault_locked(events)) return results def main(input_data): lines = input_data.split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): E = int(lines[index]) events = [] for i in range(1, E + 1): timestamp, event_type = lines[index + i].split() events.append((int(timestamp), event_type)) test_cases.append(events) index += E + 1 results = process_test_cases(test_cases) for result in results: print(result)"},{"question":"def min_boxes_needed(n: int, k: int, box_sizes: List[int]) -> int: Returns the minimum number of boxes needed to package k cookies given n different box sizes. If it is not possible to package the exact number of cookies using the given box sizes, return -1. >>> min_boxes_needed(3, 9, [2, 3, 5]) 3 >>> min_boxes_needed(2, 8, [3, 5]) 2 >>> min_boxes_needed(3, 11, [2, 4, 6]) -1 >>> min_boxes_needed(1, 10, [10]) 1 >>> min_boxes_needed(1, 9, [10]) -1 >>> min_boxes_needed(3, 15, [1, 5, 10]) 2 >>> min_boxes_needed(2, 7, [2, 4]) -1 >>> min_boxes_needed(3, 10000, [1, 2, 5]) 2000 >>> min_boxes_needed(4, 11, [1, 2, 3, 4]) 3","solution":"def min_boxes_needed(n, k, box_sizes): Returns the minimum number of boxes needed to package k cookies given n different box sizes. If it is not possible to package the exact number of cookies using the given box sizes, returns -1. from math import inf # Dynamic Programming table to store minimum boxes required for every amount of cookies from 0 to k dp = [inf] * (k + 1) dp[0] = 0 # No cookies need 0 boxes # Update the DP table for each box size for size in box_sizes: for j in range(size, k + 1): dp[j] = min(dp[j], dp[j - size] + 1) return -1 if dp[k] == inf else dp[k]"},{"question":"from collections import deque, defaultdict def min_hospitals(n, m, d, roads): Determine the minimum number of hospitals needed to ensure that every city has access to a hospital within the specified distance D. Parameters: n (int): Number of cities m (int): Number of roads d (int): Maximum distance within which each city should have access to a hospital roads (List[Tuple[int, int, int]]): List of roads where each road is represented by a tuple (u, v, w) indicating a road between city u and city v with distance w Returns: int: Minimum number of hospitals required Example: >>> min_hospitals(6, 7, 3, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (5, 6, 1), (1, 3, 3), (3, 6, 2)]) 2 >>> min_hospitals(4, 2, 1, [(1, 2, 1), (3, 4, 1)]) 2 pass def test_min_hospitals(): n = 6 m = 7 d = 3 roads = [ (1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (5, 6, 1), (1, 3, 3), (3, 6, 2) ] assert min_hospitals(n, m, d, roads) == 2 def test_disconnected_graph(): n = 4 m = 2 d = 1 roads = [ (1, 2, 1), (3, 4, 1), ] assert min_hospitals(n, m, d, roads) == 2 def test_large_distance(): n = 3 m = 2 d = 10 roads = [ (1, 2, 5), (2, 3, 5), ] assert min_hospitals(n, m, d, roads) == 1 def test_no_roads(): n = 4 m = 0 d = 1 roads = [] assert min_hospitals(n, m, d, roads) == 4 def test_multiple_hospitals_needed(): n = 5 m = 4 d = 2 roads = [ (1, 2, 2), (2, 3, 2), (3, 4, 2), (4, 5, 2), ] assert min_hospitals(n, m, d, roads) == 3","solution":"from collections import deque, defaultdict def min_hospitals(n, m, d, roads): graph = defaultdict(list) for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) def bfs(start): visited = [False] * (n + 1) queue = deque([(start, 0)]) neighborhoods = [] while queue: current, dist = queue.popleft() if dist > d: continue for neighbor, weight in graph[current]: if not visited[neighbor] and dist + weight <= d: visited[neighbor] = True queue.append((neighbor, dist + weight)) return [i for i in range(1, n + 1) if visited[i]] uncovered = set(range(1, n + 1)) hospitals = 0 while uncovered: city = uncovered.pop() neighborhoods = bfs(city) uncovered -= set(neighborhoods) hospitals += 1 return hospitals"},{"question":"def min_cost_climbing_stairs(cost): Calculate the minimum cost to climb stairs with given costs. >>> min_cost_climbing_stairs([10, 15, 20]) 15 >>> min_cost_climbing_stairs([1, 100, 1, 1, 1]) 3 def process_input(input_str): Process input and output the result for multiple test cases. >>> input_str = \\"3n3n10 15 20n5n1 100 1 1 1n4n1 2 3 4n\\" >>> process_input(input_str) [15, 3, 4]","solution":"def min_cost_climbing_stairs(cost): Function to calculate the minimum cost to climb stairs. n = len(cost) if n == 0: return 0 elif n == 1: return cost[0] dp = [0] * n dp[0] = cost[0] dp[1] = cost[1] for i in range(2, n): dp[i] = cost[i] + min(dp[i - 1], dp[i - 2]) return min(dp[n - 1], dp[n - 2]) def process_input(input_str): Function to process input and output the result for multiple test cases. input_lines = input_str.strip().split(\\"n\\") T = int(input_lines[0]) results = [] index = 1 for _ in range(T): N = int(input_lines[index]) costs = list(map(int, input_lines[index + 1].split())) index += 2 results.append(min_cost_climbing_stairs(costs)) return results"},{"question":"def battle_simulation(t: int, robot_data: List[Tuple[int, List[int]]]) -> List[str]: Process the battle results of several robots based on their initial shield strength and a series of attacks. >>> battle_simulation(3, [ ... (50, [10, 20, 5, 10]), ... (100, [30, 40, 20]), ... (20, [5, 10, 5, 5, 10])]) [\\"Shield intact with strength 5\\", \\"Shield intact with strength 10\\", \\"Robot took 15 hit points of damage\\"] >>> battle_simulation(2, [ ... (10, [5, 10, 3]), ... (50, [50, 60])]) [\\"Robot took 8 hit points of damage\\", \\"Robot took 60 hit points of damage\\"] >>> battle_simulation(1, [(30, [10, 10, 5])]) [\\"Shield intact with strength 5\\"] >>> battle_simulation(1, [(5, [1, 2, 3, 4, 5])]) [\\"Robot took 10 hit points of damage\\"] >>> battle_simulation(1, [(0, [1, 2, 3])]) [\\"Robot took 6 hit points of damage\\"] >>> battle_simulation(1, [(1000000, [10, 20, 30, 40, 50])]) [\\"Shield intact with strength 999850\\"]","solution":"def battle_simulation(t, robot_data): results = [] for data in robot_data: initial_shield, attacks = data remaining_shield = initial_shield damage_taken = 0 for attack in attacks: if remaining_shield > 0: if attack <= remaining_shield: remaining_shield -= attack else: damage_taken += (attack - remaining_shield) remaining_shield = 0 else: damage_taken += attack if remaining_shield > 0: results.append(f\\"Shield intact with strength {remaining_shield}\\") else: results.append(f\\"Robot took {damage_taken} hit points of damage\\") return results"},{"question":"def largest_square_plot(L: int, W: int) -> (int, int): Determines the side length of the largest possible square plot that can be cut from the rectangular field, and the maximum number of such square plots that can be cut from the field. Args: L (int): The length of the rectangular field. W (int): The width of the rectangular field. Returns: (int, int): A tuple containing two integers. The first integer is the side length of the largest possible square plot, and the second integer is the maximum number of such square plots. Examples: >>> largest_square_plot(12, 10) (2, 30) >>> largest_square_plot(5, 5) (5, 1)","solution":"def largest_square_plot(L, W): Returns the side length of the largest square plot and maximum number of such plots that can be cut from the rectangle of length L and width W. def gcd(a, b): while b: a, b = b, a % b return a side = gcd(L, W) count = (L // side) * (W // side) return side, count"},{"question":"def minimum_possible_total_effort(n: int, participants: List[List[int]]) -> int: Determine the minimum possible total effort that would be equal for all participants after adjustments. >>> minimum_possible_total_effort(3, [ ... [1, 2, 3], ... [2, 3, 4], ... [1, 5] ... ]) 29 >>> minimum_possible_total_effort(2, [ ... [5, 6], ... [3, 2, 1] ... ]) 61 from typing import List def test_minimum_possible_total_effort(): assert minimum_possible_total_effort(3, [ [1, 2, 3], [2, 3, 4], [1, 5] ]) == 29 assert minimum_possible_total_effort(2, [ [5, 6], [3, 2, 1] ]) == 61 assert minimum_possible_total_effort(1, [ [1, 1] ]) == 2 assert minimum_possible_total_effort(3, [ [1, 1, 1], [2, 2, 2], [3, 3, 3] ]) == 27 assert minimum_possible_total_effort(4, [ [4, 3, 2, 1], [1, 2, 3, 4], [2, 2, 2, 2], [1, 1, 1, 1] ]) == 30","solution":"def minimum_possible_total_effort(n, participants): # Function to calculate sum of squares def sum_of_squares(arr): return sum(x * x for x in arr) # Calculate the current efforts for all participants current_efforts = [sum_of_squares(p) for p in participants] # Calculate the maximum of the current efforts, which would be the minimum level Antonia must achieve for all target_effort = max(current_efforts) return target_effort # Example usage: # n = 3 # participants = [ # [1, 2, 3], # [2, 3, 4], # [1, 5] # ] # print(minimum_possible_total_effort(n, participants)) # Output: 29"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string s, determine the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"abc!@#abc!@#\\") 6 >>> length_of_longest_substring(\\" \\") 1 >>> length_of_longest_substring(\\"dvdf\\") 3 >>> length_of_longest_substring(\\"abcdefghijklmnopqrstuvwxyz\\") 26 >>> length_of_longest_substring(\\"a\\" * 10000) 1 >>> length_of_longest_substring(\\"12345!@#%123\\") 10","solution":"def length_of_longest_substring(s): This function returns the length of the longest substring without repeating characters. last_seen = {} start = 0 max_length = 0 for index, char in enumerate(s): if char in last_seen and last_seen[char] >= start: start = last_seen[char] + 1 last_seen[char] = index max_length = max(max_length, index - start + 1) return max_length"},{"question":"def largest_square_zeros(grid: List[List[str]]) -> int: Find the side length of the largest square subgrid completely filled with 'O' characters. Args: grid (List[List[str]]): 2D grid consisting of 'O's and 'X's Returns: int: The side length of the largest square subgrid filled with 'O' characters. Examples: >>> grid = [ >>> ['O', 'O', 'O'], >>> ['O', 'O', 'O'], >>> ['O', 'O', 'O'] >>> ] >>> largest_square_zeros(grid) 3 >>> grid = [ >>> ['X', 'X', 'X'], >>> ['X', 'O', 'X'], >>> ['X', 'X', 'X'] >>> ] >>> largest_square_zeros(grid) 1 >>> grid = [ >>> ['O', 'O', 'X', 'O'], >>> ['O', 'O', 'X', 'X'], >>> ['X', 'X', 'O', 'O'], >>> ['O', 'O', 'O', 'O'], >>> ['X', 'O', 'O', 'O'] >>> ] >>> largest_square_zeros(grid) 2 >>> grid = [ >>> ['O', 'O', 'O', 'X'], >>> ['O', 'X', 'O', 'O'], >>> ['O', 'O', 'O', 'O'], >>> ['X', 'O', 'O', 'O'], >>> ['O', 'O', 'O', 'O'] >>> ] >>> largest_square_zeros(grid) 3 >>> grid = [ >>> ['X', 'X', 'X'], >>> ['X', 'X', 'X'], >>> ['X', 'X', 'X'] >>> ] >>> largest_square_zeros(grid) 0 >>> grid = [] >>> largest_square_zeros(grid) 0 >>> grid = [['O']*500 for _ in range(500)] >>> largest_square_zeros(grid) 500","solution":"def largest_square_zeros(grid): Returns the largest square subgrid size filled with 'O' characters. if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) dp = [[0] * m for _ in range(n)] max_side_length = 0 for i in range(n): for j in range(m): if grid[i][j] == 'O': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side_length = max(max_side_length, dp[i][j]) return max_side_length"},{"question":"def has_fibonacci_like_subarray(n: int, arr: List[int]) -> str: Determines if a contiguous subarray exists within the given array where each element is the sum of the two preceding ones. Parameters: n (int): Number of elements in the array arr (list): List of integers Returns: str: \\"YES\\" if such a subarray exists, otherwise \\"NO\\" Examples: >>> has_fibonacci_like_subarray(8, [1, 2, 3, 2, 4, 6, 8, 14]) \\"YES\\" >>> has_fibonacci_like_subarray(5, [5, 7, 9, -4, 11]) \\"NO\\"","solution":"def has_fibonacci_like_subarray(n, arr): Determines if a contiguous subarray exists within the given array where each element is the sum of the two preceding ones. Parameters: n (int): Number of elements in the array arr (list): List of integers Returns: str: \\"YES\\" if such a subarray exists, otherwise \\"NO\\" for i in range(n - 2): if arr[i] + arr[i+1] == arr[i+2]: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple def count_inversions(arr: List[int]) -> Tuple[int, int]: Given an integer array a, count the number of local and global inversions. A local inversion is a pair of indices (i, j) where i < j and a[i] > a[j] and j = i + 1. A global inversion is a pair of indices (i, j) where i < j and a[i] > a[j]. >>> count_inversions([1, 3, 2, 4, 5]) (1, 1) >>> count_inversions([3, 2, 1]) (2, 3) # Implement function here def test_example_1(): assert count_inversions([1, 3, 2, 4, 5]) == (1, 1) def test_example_2(): assert count_inversions([3, 2, 1]) == (2, 3) def test_no_inversions(): assert count_inversions([1, 2, 3, 4, 5]) == (0, 0) def test_all_inversions(): assert count_inversions([5, 4, 3, 2, 1]) == (4, 10) def test_single_element(): assert count_inversions([1]) == (0, 0) def test_alternating_inversions(): assert count_inversions([2, 1, 4, 3, 6, 5]) == (3, 3)","solution":"def count_inversions(arr): n = len(arr) local_inversions = 0 global_inversions = 0 # Count local inversions for i in range(n - 1): if arr[i] > arr[i + 1]: local_inversions += 1 # Count global inversions using merge sort def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted array inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid - i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count temp_arr = [0]*n global_inversions = merge_sort_and_count(arr, temp_arr, 0, n-1) return local_inversions, global_inversions"},{"question":"from typing import List def can_reach_key(maze: List[str]) -> str: Determines if there is at least one way to reach the key 'K' from any open cell in the maze. >>> can_reach_key([ ... \\"....\\", ... \\"..#K\\", ... \\"....\\", ... \\"....\\" ... ]) \\"YES\\" >>> can_reach_key([ ... \\"#\\", ... \\"#K#\\", ... \\"#\\" ... ]) \\"NO\\"","solution":"def can_reach_key(maze): N, M = len(maze), len(maze[0]) def find_key(): for i in range(N): for j in range(M): if maze[i][j] == 'K': return i, j return None def bfs(start_row, start_col): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = [(start_row, start_col)] visited = set() visited.add((start_row, start_col)) while queue: row, col = queue.pop(0) for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < N and 0 <= c < M and (r, c) not in visited: if maze[r][c] == 'K': return True if maze[r][c] == '.': visited.add((r, c)) queue.append((r, c)) return False key_row, key_col = find_key() if key_row is None: return \\"NO\\" for i in range(N): for j in range(M): if maze[i][j] == '.': if bfs(i, j): return \\"YES\\" return \\"NO\\" # Input N, M = 4, 4 maze = [ \\"....\\", \\"..#K\\", \\"....\\", \\"....\\" ] print(can_reach_key(maze)) # Expects: YES"},{"question":"def minimum_number_of_points(intervals): This function takes a list of intervals and returns the minimum number of points such that each interval in the list has at least one point. >>> minimum_number_of_points([[1, 4], [2, 5], [6, 8]]) 2 >>> minimum_number_of_points([[1, 2], [2, 3], [3, 4], [4, 5]]) 2 def test_no_intervals(): assert minimum_number_of_points([]) == 0 def test_single_interval(): assert minimum_number_of_points([[1, 4]]) == 1 def test_non_overlapping_intervals(): assert minimum_number_of_points([[1, 2], [3, 4], [5, 6]]) == 3 def test_overlapping_intervals(): assert minimum_number_of_points([[1, 4], [2, 5], [6, 8]]) == 2 assert minimum_number_of_points([[1, 2], [2, 3], [3, 4], [4, 5]]) == 2 def test_mixed_intervals(): assert minimum_number_of_points([[1, 4], [1, 2], [3, 7], [7, 8]]) == 2 assert minimum_number_of_points([[1, 3], [2, 6], [8, 10], [15, 18]]) == 3 # Run the tests using pytest approach def test_minimum_number_of_points(): test_no_intervals() test_single_interval() test_non_overlapping_intervals() test_overlapping_intervals() test_mixed_intervals() test_minimum_number_of_points()","solution":"def minimum_number_of_points(intervals): This function takes a list of intervals and returns the minimum number of points such that each interval in the list has at least one point. if not intervals: return 0 # Sort intervals by their end points intervals.sort(key=lambda x: x[1]) # Initialize the number of points needed and the position of the last added point points_needed = 0 last_point = float('-inf') for interval in intervals: if interval[0] > last_point: # Add a point at the end of the current interval last_point = interval[1] points_needed += 1 return points_needed"},{"question":"def can_earn_exactly_m_points(M: int) -> bool: Determine if there is a way to earn exactly M points by collecting any combination of apples, bananas, and cherries. Apples are worth 2 points each, bananas are worth 3 points each, and cherries are worth 5 points each. Players must collect at least one type of fruit. :param M: int - The target points to be earned :return: bool - True if exactly M points can be earned, otherwise False >>> can_earn_exactly_m_points(14) True >>> can_earn_exactly_m_points(9) True >>> can_earn_exactly_m_points(1) False def print_result(M: int): Print \\"Yes\\" if exact M points can be earned, else print \\"No\\". :param M: Target points >>> print_result(14) Yes >>> print_result(9) Yes >>> print_result(1) No","solution":"def can_earn_exactly_m_points(M): Determine if it's possible to earn exactly M points by collecting apples, bananas, and cherries. Apples: 2 points each Bananas: 3 points each Cherries: 5 points each :param M: int - The target points to be earned :return: bool - True if exactly M points can be earned, otherwise False for apples in range(M // 2 + 1): for bananas in range(M // 3 + 1): # Calculate the remaining points needed after using apples and bananas remaining = M - 2 * apples - 3 * bananas # Check if the remaining points can be achieved by using cherries if remaining >= 0 and remaining % 5 == 0: return True return False def print_result(M): Print \\"Yes\\" if exact M points can be earned, else print \\"No\\". :param M: Target points if can_earn_exactly_m_points(M): print(\\"Yes\\") else: print(\\"No\\")"},{"question":"def find_min_time_worker(w: int, t: int, task_durations: List[List[int]]) -> int: Finds the worker with the minimum total time spent on tasks. :param w: The number of workers :param t: The number of tasks for each worker :param task_durations: A list of lists, each containing the task durations for a worker :return: The 1-based index of the worker with the minimum total time pass # Example test cases def test_example_case(): assert find_min_time_worker(3, 4, [ [1, 2, 3, 4], [2, 2, 2, 2], [4, 3, 2, 1] ]) == 2 def test_single_worker_single_task(): assert find_min_time_worker(1, 1, [ [5] ]) == 1 def test_multiple_workers_equal_time(): assert find_min_time_worker(3, 3, [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) == 1 def test_last_worker_minimum_time(): assert find_min_time_worker(4, 3, [ [2, 3, 2], [3, 2, 3], [4, 2, 4], [1, 1, 1] ]) == 4 def test_all_zero_durations(): assert find_min_time_worker(3, 4, [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ]) == 1 def test_worker_identifier_with_minimum_index(): assert find_min_time_worker(3, 3, [ [1, 3, 4], [2, 2, 4], [1, 1, 7] ]) == 1","solution":"def find_min_time_worker(w, t, task_durations): Finds the worker with the minimum total time spent on tasks. :param w: The number of workers :param t: The number of tasks for each worker :param task_durations: A list of lists, each containing the task durations for a worker :return: The 1-based index of the worker with the minimum total time min_time = float('inf') min_worker = -1 for i in range(w): total_time = sum(task_durations[i]) if total_time < min_time: min_time = total_time min_worker = i + 1 return min_worker # Example usage w = 3 t = 4 task_durations = [ [1, 2, 3, 4], [2, 2, 2, 2], [4, 3, 2, 1] ] print(find_min_time_worker(w, t, task_durations)) # Output: 2"},{"question":"def calculate_final_price(n, items, discount_percentage, threshold): Returns the final price after applying discount if applicable. :param n: Number of items :param items: List of tuples, each containing item name and its price :param discount_percentage: The discount percentage to be applied :param threshold: The threshold total price to apply the discount :return: The final price rounded to two decimal places >>> items = [('Laptop', 999.99), ('Mouse', 49.50), ('Keyboard', 79.99)] >>> calculate_final_price(3, items, 10, 2000.00) 1129.48 >>> items = [('Laptop', 999.99), ('Mouse', 49.50), ('Keyboard', 79.99)] >>> calculate_final_price(3, items, 10, 1000.00) 1016.53 >>> items = [('Item1', 500.00), ('Item2', 500.00)] >>> calculate_final_price(2, items, 20, 1000.00) 800.00 >>> items = [('Item1', 400.00), ('Item2', 500.00)] >>> calculate_final_price(2, items, 20, 1000.00) 900.00 >>> items = [] >>> calculate_final_price(0, items, 50, 0.00) 0.00 from typing import List, Tuple def test_no_discount(): items = [('Laptop', 999.99), ('Mouse', 49.50), ('Keyboard', 79.99)] assert calculate_final_price(3, items, 10, 2000.00) == 1129.48 def test_discount_applied(): items = [('Laptop', 999.99), ('Mouse', 49.50), ('Keyboard', 79.99)] assert calculate_final_price(3, items, 10, 1000.00) == 1016.53 def test_exact_threshold(): items = [('Item1', 500.00), ('Item2', 500.00)] assert calculate_final_price(2, items, 20, 1000.00) == 800.00 def test_below_threshold(): items = [('Item1', 400.00), ('Item2', 500.00)] assert calculate_final_price(2, items, 20, 1000.00) == 900.00 def test_no_items(): items = [] assert calculate_final_price(0, items, 50, 0.00) == 0.00","solution":"def calculate_final_price(n, items, discount_percentage, threshold): Returns the final price after applying discount if applicable. :param n: Number of items :param items: List of tuples, each containing item name and its price :param discount_percentage: The discount percentage to be applied :param threshold: The threshold total price to apply the discount :return: The final price rounded to two decimal places # Calculate the total original price total_price = sum(price for item, price in items) # Apply discount if the total price exceeds the threshold if total_price >= threshold: final_price = total_price * (1 - discount_percentage / 100) else: final_price = total_price # Return the final price rounded to two decimal places return round(final_price, 2)"},{"question":"def process_queries(n: int, q: int, array: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Process queries to find the number of elements in subarray a[l...r] that are greater than or equal to k. Parameters: n (int): number of elements in the array q (int): number of queries array (List[int]): list of n integers queries (List[Tuple[int, int, int]]): list of queries, each query is a tuple (l, r, k) Returns: List[int]: list of results for each query >>> process_queries(5, 3, [1, 2, 3, 4, 5], [(1, 3, 2), (2, 4, 5), (1, 5, 3)]) [2, 0, 3] >>> process_queries(6, 2, [10, 20, 10, 10, 20, 10], [(1, 6, 15), (2, 5, 20)]) [2, 2] >>> process_queries(4, 4, [5, 5, 5, 5], [(1, 4, 5), (1, 3, 4), (2, 3, 4), (3, 4, 5)]) [4, 3, 2, 2]","solution":"def process_queries(n, q, array, queries): Process queries to find the number of elements in subarray a[l...r] that are greater than or equal to k. Parameters: n : int : number of elements in the array q : int : number of queries array : list : list of n integers queries : list : list of queries, each query is a tuple (l, r, k) Returns: list : list of results for each query results = [] for l, r, k in queries: count = 0 for i in range(l-1, r): if array[i] >= k: count += 1 results.append(count) return results # Example usage: # n, q = 5, 3 # array = [1, 2, 3, 4, 5] # queries = [(1, 3, 2), (2, 4, 5), (1, 5, 3)] # results = process_queries(n, q, array, queries) # print(results) # Output: [2, 0, 3]"},{"question":"def min_popularity_score_difference(n: int, popularity: List[int]) -> int: Determine the minimum possible difference between the highest and the lowest stack popularity scores when books are split into two stacks. Args: n : int : number of books popularity : List[int] : list of popularity scores for each book Returns: int : the minimum possible difference between the highest and the lowest stack popularity scores Examples: >>> min_popularity_score_difference(4, [1, 2, 3, 4]) 0 >>> min_popularity_score_difference(5, [10, 20, 15, 5, 25]) 5 >>> min_popularity_score_difference(1, [10]) 10 >>> min_popularity_score_difference(4, [10, 10, 10, 10]) 0 >>> min_popularity_score_difference(3, [1, 1000, 1000]) 1 >>> min_popularity_score_difference(4, [1, 2, 5, 7]) 1","solution":"def min_popularity_score_difference(n, popularity): total_popularity = sum(popularity) half_total_popularity = total_popularity // 2 dp = [[False] * (half_total_popularity + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(half_total_popularity + 1): dp[i][j] = dp[i-1][j] if j >= popularity[i-1]: dp[i][j] = dp[i][j] or dp[i-1][j-popularity[i-1]] for j in range(half_total_popularity, -1, -1): if dp[n][j]: return total_popularity - 2 * j"},{"question":"def find_indices_with_closest_sum_to_zero(n: int, arr: List[int]) -> Tuple[int, int]: Finds two indices i and j (1-based indexing) such that the sum of the elements at these indices is closest to zero. Example: >>> find_indices_with_closest_sum_to_zero(5, [-2, 4, 1, -3, 2]) (1, 5) >>> find_indices_with_closest_sum_to_zero(3, [-1, 1, 3]) (1, 2)","solution":"def find_indices_with_closest_sum_to_zero(n, arr): Finds two indices i and j (1-based indexing) such that the sum of the elements at these indices is closest to zero. closest_sum = float('inf') closest_pair = (0, 0) for i in range(n): for j in range(i + 1, n): current_sum = arr[i] + arr[j] if abs(current_sum) < abs(closest_sum) or (abs(current_sum) == abs(closest_sum) and (i + 1 < closest_pair[0] or (i + 1 == closest_pair[0] and j + 1 < closest_pair[1]))): closest_sum = current_sum closest_pair = (i + 1, j + 1) return closest_pair"},{"question":"def find_busiest_hour(logs: List[str]) -> str: Find the hour with the maximum number of events given a list of event timestamps. Args: logs (List[str]): A list of event timestamps as strings in the format \\"YYYY-MM-DD HH:MM:SS\\". Returns: str: The hour with the maximum number of events in the format \\"YYYY-MM-DD HH\\". >>> find_busiest_hour([\\"2023-07-15 13:45:20\\", \\"2023-07-15 13:50:01\\", \\"2023-07-15 14:00:00\\", \\"2023-07-15 14:30:10\\", \\"2023-07-15 13:59:59\\"]) '2023-07-15 13' >>> find_busiest_hour([\\"2023-07-15 10:00:00\\", \\"2023-07-15 11:00:00\\", \\"2023-07-15 11:05:00\\"]) '2023-07-15 11'","solution":"def find_busiest_hour(logs): from collections import defaultdict hour_count = defaultdict(int) for log in logs: hour = log[:13] # Extracting \\"YYYY-MM-DD HH\\" hour_count[hour] += 1 busiest_hour, max_count = \\"\\", 0 for hour, count in hour_count.items(): if count > max_count or (count == max_count and hour < busiest_hour): busiest_hour = hour max_count = count return busiest_hour def main(): import sys input = sys.stdin.read data = input().splitlines() N = int(data[0]) logs = data[1:] print(find_busiest_hour(logs)) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List def max_noodle_pieces(arr: List[int]) -> int: Given a list of noodle lengths, this function determines the maximum number of pieces such that any three can form a triangle. >>> max_noodle_pieces([4, 2, 9, 5, 7, 3]) 6 >>> max_noodle_pieces([1, 2, 3]) 0 pass","solution":"def max_noodle_pieces(arr): Given a list of noodles' lengths, this function determines the maximum number of pieces such that any three can form a triangle. n = len(arr) # First, sort the array arr.sort() # Find maximum number of pieces such that any three can form a triangle for i in range(n - 2): if arr[i] + arr[i + 1] > arr[i + 2]: return n # If no three pieces form a triangle, return 0 return 0"},{"question":"def smallest_non_negative_integer(matrix, x, y): Returns the smallest non-negative integer that does not appear in the row, column, or diagonals (if applicable) of the position (x, y) in the given matrix. Examples: >>> smallest_non_negative_integer([ ... [1, 2, 3, 4], ... [2, 3, -1, 1], ... [3, 4, 1, 2], ... [4, 1, 2, 3]], 2, 2) 0 >>> smallest_non_negative_integer([ ... [0, 1, 2], ... [1, -1, 0], ... [2, 0, 1]], 1, 1) 3","solution":"def smallest_non_negative_integer(matrix, x, y): Returns the smallest non-negative integer that does not appear in the row, column, or diagonals (if applicable) of the position (x, y) in the given matrix. n = len(matrix) row_elements = set(matrix[x]) col_elements = set(matrix[i][y] for i in range(n)) primary_diagonal_elements = set(matrix[i][i] for i in range(n) if i != x and i != y) secondary_diagonal_elements = set(matrix[i][n-1-i] for i in range(n) if i != x and n-1-i != y) all_elements = row_elements | col_elements | primary_diagonal_elements | secondary_diagonal_elements result = 0 while result in all_elements: result += 1 return result # Example usage: # matrix = [ # [1, 2, 3, 4], # [2, 3, -1, 1], # [3, 4, 1, 2], # [4, 1, 2, 3] # ] # x, y = 2, 2 # print(smallest_non_negative_integer(matrix, x, y)) # Output: 0"},{"question":"def reduce_string(s: str) -> str: You are given a string \`s\` containing only characters \`a\` and \`b\`. In one operation, you can select any two adjacent characters in the string and replace them with a single character \`c\` according to the following rules: - If the two characters are \`a\` and \`a\`, replace them with a single \`a\`. - If the two characters are \`b\` and \`b\`, replace them with a single \`b\`. - If the two characters are \`a\` and \`b\`, replace them with a single \`a\`. - If the two characters are \`b\` and \`a\`, replace them with a single \`b\`. Your task is to determine the resulting character after a series of operations is applied to the entire string until only one character remains. Examples: >>> reduce_string('ab') 'a' >>> reduce_string('ba') 'b' >>> reduce_string('aa') 'a' >>> reduce_string('bbab') 'b'","solution":"def reduce_string(s): Reduces the string based on the given rules until one character remains. while len(s) > 1: new_s = [] i = 0 while i < len(s): if i < len(s) - 1: if s[i] == s[i + 1]: new_s.append(s[i]) else: new_s.append('a' if s[i] == 'a' else 'b') i += 2 else: new_s.append(s[i]) i += 1 s = ''.join(new_s) return s"},{"question":"from typing import List def find_unique(int_list: List[int]) -> List[int]: Given an unsorted list of integers, returns a new list containing only the unique elements from the original list in the order they first appeared. >>> find_unique([4, 5, 6, 4, 2, 2, 6, 3]) [4, 5, 6, 2, 3] >>> find_unique([1, 1, 1, 1]) [1] >>> find_unique([3, 3, 3, 2, 4, 4, 5, 6]) [3, 2, 4, 5, 6] def test_find_unique_mixed_integers(): assert find_unique([4, 5, 6, 4, 2, 2, 6, 3]) == [4, 5, 6, 2, 3] def test_find_unique_all_same(): assert find_unique([1, 1, 1, 1]) == [1] def test_find_unique_no_duplicates(): assert find_unique([1, 2, 3, 4]) == [1, 2, 3, 4] def test_find_unique_mixed_duplicates(): assert find_unique([3, 3, 3, 2, 4, 4, 5, 6]) == [3, 2, 4, 5, 6] def test_find_unique_empty_list(): assert find_unique([]) == [] def test_find_unique_single_element(): assert find_unique([10]) == [10] def test_find_unique_large_input(): assert find_unique([i for i in range(10000)] + [5000, 9999]) == [i for i in range(10000)]","solution":"from typing import List def find_unique(int_list: List[int]) -> List[int]: Returns a list of unique elements from the original list in the order they first appeared. seen = set() unique_list = [] for num in int_list: if num not in seen: seen.add(num) unique_list.append(num) return unique_list"},{"question":"def max_strength_after_duels(strengths: List[int]) -> int: Calculate the maximum possible strength of the strongest warrior after all possible duels. >>> max_strength_after_duels([2, 7, 4]) 13 >>> max_strength_after_duels([10]) 10 >>> max_strength_after_duels([2, 2, 2, 2]) 8 >>> max_strength_after_duels([3, 5]) 8 pass","solution":"def max_strength_after_duels(strengths): while len(strengths) > 1: # Sort strengths in descending order strengths.sort(reverse=True) # The strongest warrior absorbs the strength of the second strongest strengths[0] += strengths[1] # Remove the second strongest from the list strengths.pop(1) return strengths[0]"},{"question":"def max_product_of_three(n: int, arr: List[int]) -> int: Write a program that, for a given list of integers, finds and returns the maximum product of any three distinct integers in the list. :param n: Int, the number of integers in the list :param arr: List of integers :return: Int, the maximum product of any three distinct integers >>> max_product_of_three(5, [-10, -10, 5, 2, 3]) 500 >>> max_product_of_three(5, [1, 2, 3, 4, 5]) 60 >>> max_product_of_three(5, [-1, -2, -3, -4, -5]) -6 >>> max_product_of_three(6, [-10, -10, 2, 3, 5, 9]) 900 >>> max_product_of_three(4, [1000, 1000, -1000, -1000]) 1000000000 >>> max_product_of_three(5, [-1, 0, 3, 1000, 2]) 6000","solution":"def max_product_of_three(n, arr): Returns the maximum product of any three distinct integers in the list. :param n: Int, the number of integers in the list :param arr: List of integers :return: Int, the maximum product of any three distinct integers arr.sort() return max(arr[0] * arr[1] * arr[-1], arr[-1] * arr[-2] * arr[-3])"},{"question":"from typing import List def modify_array(arr: List[int], k: int) -> List[int]: Modifies the array such that elements which are multiples of 10 are increased by k. Args: arr: List of integers representing the input array. k: Integer value to add to multiples of 10. Returns: List of integers representing the modified array. Examples: >>> modify_array([20, 15, 30, 40, 9], 3) [23, 15, 33, 43, 9] >>> modify_array([11, 15, 23, 47], 5) [11, 15, 23, 47] >>> modify_array([10, 20, 30, 40], 2) [12, 22, 32, 42] >>> modify_array([0, 10, 20, 0], 1) [1, 11, 21, 1] >>> modify_array([999990, 1000000, 5000000], 100000) [1099990, 1100000, 5100000] >>> modify_array([], 5) [] >>> modify_array([10], 5) [15] >>> modify_array([11], 5) [11]","solution":"from typing import List def modify_array(arr: List[int], k: int) -> List[int]: Modifies the array such that elements which are multiples of 10 are increased by k. Args: arr: List of integers representing the input array. k: Integer value to add to multiples of 10. Returns: List of integers representing the modified array. for i in range(len(arr)): if arr[i] % 10 == 0: arr[i] += k return arr"},{"question":"def longest_consecutive_subsequence(s: str) -> int: Finds the length of the longest subsequence of consecutive letters of the alphabet. >>> longest_consecutive_subsequence(\\"abcpqabcde\\") 5 >>> longest_consecutive_subsequence(\\"zxybac\\") 2","solution":"def longest_consecutive_subsequence(s): Finds the length of the longest subsequence of consecutive letters of the alphabet. n = len(s) max_len = 0 for i in range(n): current_len = 1 prev_char = s[i] for j in range(i+1, n): if ord(s[j]) == ord(prev_char) + 1: current_len += 1 prev_char = s[j] max_len = max(max_len, current_len) return max_len"},{"question":"def next_palindrome(n: str) -> str: Find the smallest palindrome larger than the given number. >>> next_palindrome(\\"123\\") \\"131\\" >>> next_palindrome(\\"4\\") \\"5\\" >>> next_palindrome(\\"999\\") \\"1001\\" def smallest_palindrome_bigger_than_n(test_cases: list) -> list: For each test case, find the smallest palindrome larger than the given number. >>> smallest_palindrome_bigger_than_n([\\"123\\", \\"4\\", \\"999\\"]) [\\"131\\", \\"5\\", \\"1001\\"] >>> smallest_palindrome_bigger_than_n([\\"1\\", \\"88\\"]) [\\"2\\", \\"99\\"]","solution":"def next_palindrome(n): # Convert the string number to an integer n = int(n) # Increment n to start checking the next numbers n += 1 # Convert the number back to string to check if it's a palindrome while True: if str(n) == str(n)[::-1]: return str(n) n += 1 def smallest_palindrome_bigger_than_n(test_cases): results = [] for n in test_cases: results.append(next_palindrome(n)) return results"},{"question":"def max_water_pressure(test_cases): Compute the maximum water pressure at any given point in time based on the pump activation intervals. Parameters: test_cases (List[List[Tuple[int, int]]]): List of test cases, each test case is a list of tuples where each tuple represents the start (Ti) and end (Tj) time of a pump. Returns: List[int]: List of maximum water pressures for each test case. Example: >>> max_water_pressure([[(1, 5), (3, 7), (4, 6)]]) [3] >>> max_water_pressure([[(5, 10), (1, 3), (2, 6), (8, 9)]]) [2] from solution import max_water_pressure def test_case_1(): test_cases = [ [(1, 5), (3, 7), (4, 6)] ] assert max_water_pressure(test_cases) == [3] def test_case_2(): test_cases = [ [(5, 10), (1, 3), (2, 6), (8, 9)] ] assert max_water_pressure(test_cases) == [2] def test_case_3(): test_cases = [ [(1, 2), (3, 4), (5, 6)] ] assert max_water_pressure(test_cases) == [1] def test_case_4(): test_cases = [ [(1, 5), (1, 5), (1, 5)] ] assert max_water_pressure(test_cases) == [3] def test_case_5(): test_cases = [ [(1, 10), (2, 5), (3, 4)] ] assert max_water_pressure(test_cases) == [3] def test_multiple_cases(): test_cases = [ [(1, 5), (3, 7), (4, 6)], [(5, 10), (1, 3), (2, 6), (8, 9)] ] assert max_water_pressure(test_cases) == [3, 2] def test_large_interval(): test_cases = [ [(1, 10**9), (1, 10**9)] ] assert max_water_pressure(test_cases) == [2]","solution":"def max_water_pressure(test_cases): results = [] for case in test_cases: intervals = case events = [] for start, end in intervals: events.append((start, 1)) events.append((end, -1)) events.sort() current_pressure = 0 max_pressure = 0 for time, change in events: current_pressure += change if current_pressure > max_pressure: max_pressure = current_pressure results.append(max_pressure) return results"},{"question":"def floyd_warshall(n: int, edges: List[Tuple[int, int, int]]) -> List[List[int]]: Determine the shortest possible total latency needed to establish communication between any two computers in the network. Args: n: Number of computers. edges: List of communication links where each link is a tuple (u, v, w) signifying a link from computer u to computer v with latency w. Returns: A 2D list where the j-th integer in the i-th line represents the latency of the shortest communication path from computer i to computer j. If there is no path, output -1 instead of the latency. >>> floyd_warshall(4, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 1, 6)]) [[0, 3, 7, 12], [-1, 0, 4, 9], [-1, -1, 0, 5], [6, 9, 13, 0]] >>> floyd_warshall(3, [(1, 2, 4), (2, 3, 1), (3, 1, 2)]) [[0, 4, 5], [3, 0, 1], [2, 6, 0]]","solution":"def floyd_warshall(n, edges): # Initialize the distance matrix with \\"infinity\\" and 0s on the diagonal dist = [[float('inf')] * n for _ in range(n)] for i in range(n): dist[i][i] = 0 # Populate initial distances with the direct edge costs for u, v, w in edges: dist[u-1][v-1] = w # Apply Floyd-Warshall algorithm for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] # Replace 'inf' with -1 for no path available for i in range(n): for j in range(n): if dist[i][j] == float('inf'): dist[i][j] = -1 return dist"},{"question":"def can_divide_equal_weight(n: int, weights: List[int]) -> str: Determine if flora can divide her apples into two groups with the same total weight. Args: n (int): The number of apples. weights (List[int]): The weights of the apples. Returns: str: \\"YES\\" if it is possible to divide the apples into 2 groups with equal weight, otherwise \\"NO\\". Examples: >>> can_divide_equal_weight(4, [1, 5, 7, 1]) \\"YES\\" >>> can_divide_equal_weight(3, [1, 3, 5]) \\"NO\\"","solution":"def can_divide_equal_weight(n, weights): total_weight = sum(weights) # If the total weight is odd, it can't be divided into two equal parts if total_weight % 2 != 0: return \\"NO\\" target = total_weight // 2 dp = [False] * (target + 1) dp[0] = True for weight in weights: for j in range(target, weight - 1, -1): dp[j] = dp[j] or dp[j - weight] return \\"YES\\" if dp[target] else \\"NO\\""},{"question":"def find_course_order(n: int, m: int, prerequisites: List[Tuple[int, int]]) -> Union[List[int], str]: Determines a valid order of course completion given the prerequisites. If it's not possible to complete all courses, return 'Impossible'. >>> find_course_order(4, 4, [(2, 1), (3, 2), (4, 3), (3, 1)]) [1, 2, 3, 4] >>> find_course_order(2, 2, [(1, 2), (2, 1)]) 'Impossible'","solution":"from collections import defaultdict, deque def find_course_order(n, m, prerequisites): Determines a valid order of course completion given the prerequisites. Returns 'Impossible' if it's not possible to complete all courses. # Create graph and in-degree array graph = defaultdict(list) in_degree = [0] * (n + 1) for course, prereq in prerequisites: graph[prereq].append(course) in_degree[course] += 1 # Use a queue to perform a topological sort queue = deque([i for i in range(1, n + 1) if in_degree[i] == 0]) course_order = [] while queue: prereq = queue.popleft() course_order.append(prereq) for course in graph[prereq]: in_degree[course] -= 1 if in_degree[course] == 0: queue.append(course) if len(course_order) == n: return course_order else: return \\"Impossible\\""},{"question":"from typing import List def closest_subset_sum(costs: List[int], B: int) -> int: Returns the maximum sum of a subset of sneaker costs that is as close as possible to the budget B without exceeding it. If no such subset exists, returns -1. >>> closest_subset_sum([2, 7, 3, 10, 5], 14) 14 >>> closest_subset_sum([6, 4, 8, 2, 3, 7], 5) 5 >>> closest_subset_sum([10, 20, 30], 5) -1 >>> closest_subset_sum([1, 2, 3, 4, 5], 3) 3 >>> closest_subset_sum([1, 2, 2, 3], 4) 4 >>> closest_subset_sum([1, 2, 3], 6) 6 >>> closest_subset_sum([], 10) -1 >>> closest_subset_sum([1, 2, 3, 4, 5], 100) 15","solution":"from itertools import combinations def closest_subset_sum(costs, B): Returns the maximum sum of a subset of sneaker costs that is as close as possible to the budget B without exceeding it. If no such subset exists, returns -1. n = len(costs) closest_sum = -1 for r in range(1, n+1): for subset in combinations(costs, r): current_sum = sum(subset) if current_sum <= B and current_sum > closest_sum: closest_sum = current_sum return closest_sum"},{"question":"def spiralOrder(matrix: List[List[str]]) -> str: Returns the characters in the matrix in spiral order as a single string. >>> spiralOrder([['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']]) 'abcfihgde' >>> spiralOrder([['a']]) 'a' >>> spiralOrder([['a', 'b'], ['c', 'd']]) 'abdc' pass def decode_message(test_cases: List[List[List[str]]]) -> List[str]: Decodes a list of NxN matrices of characters into their spiral order representations. >>> decode_message([[['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']]]) ['abcfihgde'] >>> decode_message([[['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']], [['a', 'b'], ['c', 'd']]]) ['abcfihgde', 'abdc'] >>> decode_message([]) [] pass","solution":"def spiralOrder(matrix): Returns the characters in the matrix in spiral order as a single string. result = [] while matrix: # right result += matrix.pop(0) if matrix and matrix[0]: # down for row in matrix: result.append(row.pop()) if matrix: # left result += matrix.pop()[::-1] if matrix and matrix[0]: # up for row in matrix[::-1]: result.append(row.pop(0)) return ''.join(result) def decode_message(test_cases): results = [] for matrix in test_cases: results.append(spiralOrder(matrix)) return results"},{"question":"def is_valid_identifier(identifier: str) -> bool: Check whether a string is a valid identifier in a programming language. A valid identifier must adhere to the following rules: 1. The first character must be a letter (a-z, A-Z) or an underscore (_). 2. Subsequent characters may also include digits (0-9). 3. The identifier must not be a reserved keyword in the programming language. The reserved keywords are: 'if', 'else', 'while', 'for', 'return', 'True', 'False', 'None', 'in', 'not', 'and', 'or', 'is', 'def', 'class'. >>> is_valid_identifier(\\"_myVar\\") True >>> is_valid_identifier(\\"2ndValue\\") False >>> is_valid_identifier(\\"True\\") False >>> is_valid_identifier(\\"valid_123\\") True >>> is_valid_identifier(\\"def_function\\") False","solution":"def is_valid_identifier(identifier: str) -> bool: reserved_keywords = { 'if', 'else', 'while', 'for', 'return', 'True', 'False', 'None', 'in', 'not', 'and', 'or', 'is', 'def', 'class' } if not identifier: return False if identifier in reserved_keywords: return False if not (identifier[0].isalpha() or identifier[0] == '_'): return False for char in identifier[1:]: if not (char.isalnum() or char == '_'): return False return True"},{"question":"class Inventory: Simulates a simple inventory management system for a store. The Inventory class should support the following operations: - Add a new item to the inventory. If the item already exists, update its quantity. - Remove an item from the inventory by its ID. - Retrieve information about an item by its ID. - Print the entire inventory in a sorted order based on item names. >>> inventory = Inventory() >>> inventory.add(1, \\"apple\\", 10) >>> inventory.add(2, \\"banana\\", 5) >>> inventory.get(1) '1 apple 10' >>> inventory.remove(1) >>> inventory.get(1) 'Item not found' >>> inventory.add(3, \\"cherry\\", 7) >>> inventory.print_inventory() '2 banana 5n3 cherry 7' def __init__(self): pass def add(self, id: int, name: str, quantity: int): pass def remove(self, id: int): pass def get(self, id: int) -> str: pass def print_inventory(self) -> str: pass # Unit Tests def test_add_and_get(): inventory = Inventory() inventory.add(1, \\"apple\\", 10) assert inventory.get(1) == \\"1 apple 10\\" def test_remove(): inventory = Inventory() inventory.add(1, \\"apple\\", 10) inventory.remove(1) assert inventory.get(1) == \\"Item not found\\" def test_get_nonexistent_item(): inventory = Inventory() assert inventory.get(99) == \\"Item not found\\" def test_print_inventory(): inventory = Inventory() inventory.add(1, \\"apple\\", 10) inventory.add(2, \\"banana\\", 5) inventory.add(3, \\"cherry\\", 7) expected_output = \\"2 banana 5n3 cherry 7\\" assert inventory.print_inventory() == expected_output def test_add_update_quantity(): inventory = Inventory() inventory.add(1, \\"apple\\", 10) inventory.add(1, \\"apple\\", 15) assert inventory.get(1) == \\"1 apple 15\\" def test_remove_and_add(): inventory = Inventory() inventory.add(1, \\"apple\\", 10) inventory.remove(1) inventory.add(1, \\"apple\\", 5) assert inventory.get(1) == \\"1 apple 5\\"","solution":"class Inventory: def __init__(self): self.items = {} def add(self, id, name, quantity): self.items[id] = {'name': name, 'quantity': quantity} def remove(self, id): if id in self.items: del self.items[id] def get(self, id): item = self.items.get(id) if item: return f\\"{id} {item['name']} {item['quantity']}\\" else: return \\"Item not found\\" def print_inventory(self): sorted_items = sorted(self.items.items(), key=lambda x: x[1]['name']) result = [f\\"{id} {item['name']} {item['quantity']}\\" for id, item in sorted_items] return \\"n\\".join(result)"},{"question":"def searchable_dictionary(dictionary, queries): Returns a list of definitions for the given queries based on the dictionary. Parameters: dictionary (dict): A dictionary containing words and their definitions. queries (list): A list of words to be searched. Returns: list: A list of results where each result is either the definition of the queried word if it is found in the dictionary or \\"Word not found\\" if it is not. >>> searchable_dictionary( ... {\\"apple\\": \\"A fruit that grows on trees.\\", \\"banana\\": \\"A long, curved fruit with a yellow skin.\\"}, ... [\\"apple\\", \\"orange\\"] ... ) [\\"A fruit that grows on trees.\\", \\"Word not found\\"] >>> searchable_dictionary( ... {\\"cat\\": \\"A small domesticated carnivorous mammal with soft fur.\\", \\"dog\\": \\"A domesticated carnivorous mammal that typically has a long snout.\\"}, ... [\\"rabbit\\", \\"dog\\"] ... ) [\\"Word not found\\", \\"A domesticated carnivorous mammal that typically has a long snout.\\"]","solution":"def searchable_dictionary(dictionary, queries): Returns a list of definitions for the given queries based on the dictionary. Parameters: dictionary (dict): A dictionary containing words and their definitions. queries (list): A list of words to be searched. Returns: list: A list of results where each result is either the definition of the queried word if it is found in the dictionary or \\"Word not found\\" if it is not. results = [] for query in queries: results.append(dictionary.get(query, \\"Word not found\\")) return results"},{"question":"class MessageManager: MessageManager is a class to manage a list of messages. It provides functionalities to append, edit, delete and retrieve messages efficiently. def append_message(self, message: str) -> None: Appends a message to the list of messages. Args: message (str): The message to be added. def edit_message(self, index: int, new_message: str) -> None: Edits a message at a specific index in the list of messages. Args: index (int): The index of the message to be edited. new_message (str): The new message content. def delete_message(self, index: int) -> None: Deletes a message at a specific index in the list of messages. Args: index (int): The index of the message to be deleted. def retrieve_messages(self, start: int, end: int) -> list: Retrieves a range of messages from the list. Args: start (int): The starting index of the range. end (int): The ending index of the range. Returns: list: The list of messages in the specified range, or \\"Invalid range\\" if the range is invalid. >>> manager = MessageManager() >>> manager.append_message(\\"Hello\\") >>> manager.append_message(\\"World\\") >>> manager.retrieve_messages(0, 1) ['Hello', 'World'] >>> manager.edit_message(1, \\"Everyone\\") >>> manager.retrieve_messages(0, 1) ['Hello', 'Everyone'] >>> manager.delete_message(0) >>> manager.retrieve_messages(0, 1) ['Everyone'] >>> manager.retrieve_messages(1, 0) 'Invalid range'","solution":"class MessageManager: def __init__(self): self.messages = [] def append_message(self, message): self.messages.append(message) def edit_message(self, index, new_message): if 0 <= index < len(self.messages): self.messages[index] = new_message def delete_message(self, index): if 0 <= index < len(self.messages): del self.messages[index] def retrieve_messages(self, start, end): if 0 <= start <= end < len(self.messages): return self.messages[start:end + 1] else: return \\"Invalid range\\""},{"question":"def is_balanced(s: str) -> bool: Checks if the parentheses in the input string are balanced. >>> is_balanced(\\"{[()]}\\") True >>> is_balanced(\\"{[(])}\\") False >>> is_balanced(\\"{{[[(())]]}}\\") True >>> is_balanced(\\"{[a+b]*[x/y]}\\") True","solution":"def is_balanced(s: str) -> bool: Checks if the parentheses in the input string are balanced. stack = [] parentheses = {\\"(\\": \\")\\", \\"{\\": \\"}\\", \\"[\\": \\"]\\"} for char in s: if char in parentheses: stack.append(char) elif char in parentheses.values(): if not stack or parentheses[stack.pop()] != char: return False return not stack"},{"question":"def count_special_strings(t: int, test_cases: List[Tuple[int, List[str]]]) -> List[int]: Count the number of special strings in each test case collection. A special string is a string that is a substring of at least one other string in the collection but is not a prefix of any string, including itself. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, List[str]]]): List of test cases, where each test case is represented by a tuple containing the number of strings (n) and the list of n strings. Returns: List[int]: A list of integers, each representing the number of special strings for the corresponding test case. Example: >>> count_special_strings(2, [(3, [\\"abc\\", \\"bc\\", \\"abcd\\"]), (4, [\\"hello\\", \\"hell\\", \\"ell\\", \\"ohell\\"])]) [1, 2]","solution":"def count_special_strings(t, test_cases): results = [] for case in test_cases: n = case[0] strings = case[1] special_count = 0 for i in range(n): is_special = False for j in range(n): if i != j and strings[i] in strings[j] and not strings[j].startswith(strings[i]): is_special = True break if is_special: special_count += 1 results.append(special_count) return results"},{"question":"def max_points(n: int, k: int, points: List[int]) -> int: Returns the maximum points that can be collected by completing exactly k consecutive stages. >>> max_points(5, 3, [1, 2, 3, 4, 5]) 12 >>> max_points(4, 2, [10, 20, 10, 5]) 30 >>> max_points(7, 4, [1, 2, 3, 4, 5, 6, 7]) 22","solution":"def max_points(n, k, points): Returns the maximum points that can be collected by completing exactly k consecutive stages. :param n: int: the number of stages :param k: int: the number of consecutive stages Nina must complete :param points: list[int]: the points from each stage :return: int: the maximum points # Initial sum of the first k stages current_sum = sum(points[:k]) max_sum = current_sum # Slide the window of k stages across the stages for i in range(k, n): current_sum += points[i] - points[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def max_ones(n: int, m: int) -> int: Determine the maximum number of 1s that can be placed in an n x m grid such that each row and each column contains at most one 1. >>> max_ones(3, 3) == 3 >>> max_ones(4, 2) == 2 >>> max_ones(5, 5) == 5 >>> max_ones(10, 1) == 1 >>> max_ones(1, 100) == 1","solution":"def max_ones(n, m): Returns the maximum number of 1s that can be placed in an n x m grid such that each row and each column contains at most one 1. return min(n, m)"},{"question":"from typing import List, Tuple def min_travel_cost(n: int, m: int, k: int, special_cities: List[int], roads: List[Tuple[int, int, int]]) -> int: Compute the minimum travel cost from one special city to all other special cities. Args: n (int): The number of cities. m (int): The number of roads. k (int): The number of special cities. special_cities (List[int]): List of special cities. roads (List[Tuple[int, int, int]]): List of roads represented by tuples (u, v, w). Returns: int: The minimum travel cost, or -1 if it's impossible to travel between all special cities. >>> min_travel_cost(6, 7, 3, [2, 3, 4], [(1, 2, 5), (1, 3, 10), (3, 4, 1), (4, 5, 3), (2, 5, 2), (2, 3, 1), (5, 6, 2)]) 2 >>> min_travel_cost(4, 2, 2, [1, 4], [(1, 2, 5), (3, 4, 10)]) -1 >>> min_travel_cost(1, 0, 1, [1], []) 0 >>> min_travel_cost(4, 4, 3, [1, 2, 3], [(1, 2, 1), (2, 3, 1), (3, 1, 1), (4, 1, 10)]) 2 >>> isinstance(min_travel_cost(100000, 200000, 10, list(range(1, 11)), [(i, i + 1, 5) for i in range(1, 100000)] + [(i, 100000 - i + 1, 3) for i in range(1, 50000)]), int) True","solution":"import heapq import sys def min_travel_cost(n, m, k, special_cities, roads): INF = sys.maxsize # Adjacency list to store the graph graph = [[] for _ in range(n + 1)] for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) # Function to perform Dijkstra's algorithm def dijkstra(start): dist = [INF] * (n + 1) dist[start] = 0 pq = [(0, start)] while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for v, weight in graph[u]: if dist[u] + weight < dist[v]: dist[v] = dist[u] + weight heapq.heappush(pq, (dist[v], v)) return dist min_cost = INF for city in special_cities: dist = dijkstra(city) total_cost = sum(dist[sp_city] for sp_city in special_cities) min_cost = min(min_cost, total_cost) return min_cost if min_cost < INF else -1 # Example usage if __name__ == \\"__main__\\": n = 6 m = 7 k = 3 special_cities = [2, 3, 4] roads = [ (1, 2, 5), (1, 3, 10), (3, 4, 1), (4, 5, 3), (2, 5, 2), (2, 3, 1), (5, 6, 2) ] print(min_travel_cost(n, m, k, special_cities, roads)) # Output: 2"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathSum(root: TreeNode) -> int: Returns the maximum path sum in the binary tree. >>> root = TreeNode(1) ... root.left = TreeNode(2) ... root.right = TreeNode(3) ... maxPathSum(root) 6 >>> root = TreeNode(-10) ... root.left = TreeNode(9) ... root.right = TreeNode(20) ... root.right.left = TreeNode(15) ... root.right.right = TreeNode(7) ... maxPathSum(root) 42","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathSum(root): Returns the maximum path sum in the binary tree. def helper(node): nonlocal max_sum if not node: return 0 # Recursively get the maximum path sum for the left and right subtrees left_max = max(helper(node.left), 0) right_max = max(helper(node.right), 0) # Update the global maximum path sum if the path through the current # node surpasses the known maximum current_max = node.val + left_max + right_max max_sum = max(max_sum, current_max) # Return the maximum sum of paths that include the current node and # one of its subtrees return node.val + max(left_max, right_max) max_sum = float('-inf') helper(root) return max_sum"},{"question":"def reorder_array(n: int, arr: List[int]) -> List[int]: Reorders the array such that it alternates between the smallest and largest elements. >>> reorder_array(6, [11, 2, 9, 7, 6, 3]) [2, 11, 3, 9, 6, 7] >>> reorder_array(1, [5]) [5] >>> reorder_array(4, [1, 4, 2, 3]) [1, 4, 2, 3] >>> reorder_array(5, [10, 9, 8, 7, 6]) [6, 10, 7, 9, 8] >>> reorder_array(4, [100, 1, 50, 25]) [1, 100, 25, 50] >>> reorder_array(6, [9, 7, 5, 3, 2, 1]) [1, 9, 2, 7, 3, 5] >>> reorder_array(6, [11, 2, 11, 7, 6, 3]) [2, 11, 3, 11, 6, 7]","solution":"def reorder_array(n, arr): Reorders the array such that it alternates between the smallest and largest elements. arr.sort() left = 0 right = n - 1 result = [] while left <= right: if left <= right: result.append(arr[left]) left += 1 if left <= right: result.append(arr[right]) right -= 1 return result"},{"question":"def highest_temperature_days(n: int, entries: List[Tuple[str, int]]) -> Dict[str, Tuple[int, int]]: Identify the day on which a particular city recorded the highest temperature, and the temperature itself. >>> highest_temperature_days(8, [(\\"Tokyo\\", 16), (\\"London\\", 20), (\\"NewYork\\", 23), (\\"Tokyo\\", 20), (\\"London\\", 15), (\\"NewYork\\", 25), (\\"Tokyo\\", 23), (\\"London\\", 22)]) {\\"Tokyo\\": (7, 23), \\"London\\": (8, 22), \\"NewYork\\": (6, 25)} >>> highest_temperature_days(4, [(\\"LosAngeles\\", 30), (\\"LosAngeles\\", 35), (\\"LosAngeles\\", 33), (\\"LosAngeles\\", 34)]) {\\"LosAngeles\\": (2, 35)} >>> highest_temperature_days(3, [(\\"Paris\\", 10), (\\"Paris\\", 10), (\\"Paris\\", 10)]) {\\"Paris\\": (1, 10)} >>> highest_temperature_days(5, [(\\"Berlin\\", 15), (\\"Berlin\\", 12), (\\"Berlin\\", 15), (\\"Berlin\\", 14), (\\"Berlin\\", 10)]) {\\"Berlin\\": (1, 15)} >>> highest_temperature_days(6, [(\\"Rome\\", 5), (\\"Rome\\", 12), (\\"Rome\\", 8), (\\"Rome\\", 12), (\\"Rome\\", 3), (\\"Rome\\", 12)]) {\\"Rome\\": (2, 12)}","solution":"def highest_temperature_days(n, entries): city_temperatures = {} for i in range(n): city, temp = entries[i] temp = int(temp) if city not in city_temperatures: city_temperatures[city] = (i + 1, temp) else: if temp > city_temperatures[city][1]: city_temperatures[city] = (i + 1, temp) return city_temperatures"},{"question":"def min_distance(s1: str, s2: str) -> int: Compute the minimum number of operations required to transform s1 into s2 using Insert, Delete, and Replace operations. >>> min_distance(\\"kitten\\", \\"sitting\\") 3 >>> min_distance(\\"abc\\", \\"yabd\\") 2 >>> min_distance(\\"book\\", \\"book\\") 0 >>> min_distance(\\"short\\", \\"ports\\") 3 >>> min_distance(\\"\\", \\"\\") 0 >>> min_distance(\\"\\", \\"abcdef\\") 6 >>> min_distance(\\"abcdef\\", \\"\\") 6 >>> min_distance(\\"intention\\", \\"execution\\") 5","solution":"def min_distance(s1, s2): Compute the minimum number of operations required to transform s1 into s2 using Insert, Delete, and Replace operations. m, n = len(s1), len(s2) # Create a table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp[][] in bottom up manner for i in range(m + 1): for j in range(n + 1): # If first string is empty, only option is to insert all characters of second string if i == 0: dp[i][j] = j # Min. operations = j # If second string is empty, only option is to remove all characters of first string elif j == 0: dp[i][j] = i # Min. operations = i # If last characters are the same, ignore last character and recur for remaining string elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If the last character is different, consider all possibilities and find the minimum else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1])# Replace return dp[m][n] # Example of usage: # min_distance(\\"kitten\\", \\"sitting\\") should return 3 # min_distance(\\"abc\\", \\"yabd\\") should return 2"},{"question":"class DairyFarm: def __init__(self, N, M, production): Initialize the farm with N sectors, M days, and initial production values. def update_production(self, sector, day, value): Update the amount of milk produced in a specific sector on a specific day. def total_production_day(self, day): Calculate the total amount of milk produced across all sectors on a specific day. def total_production_sector(self, sector, start_day, end_day): Find the total milk production in a specific sector over a range of days. def process_queries(N, M, production, queries): Process a list of queries on the DairyFarm and return the results for each query of type 'D' or 'S'. farm = DairyFarm(N, M, production) results = [] for query in queries: parts = query.split() if parts[0] == 'U': sector, day, value = int(parts[1]), int(parts[2]), int(parts[3]) farm.update_production(sector, day, value) elif parts[0] == 'D': day = int(parts[1]) results.append(farm.total_production_day(day)) elif parts[0] == 'S': sector, start_day, end_day = int(parts[1]), int(parts[2]), int(parts[3]) results.append(farm.total_production_sector(sector, start_day, end_day)) return results # Unit Tests def test_dairy_farm_update_production(): N, M = 3, 3 production = [ [10, 20, 30], [40, 50, 60], [70, 80, 90] ] farm = DairyFarm(N, M, production) farm.update_production(1, 2, 100) assert farm.production[0][1] == 100 def test_dairy_farm_total_production_day(): N, M = 3, 3 production = [ [10, 20, 30], [40, 50, 60], [70, 80, 90] ] farm = DairyFarm(N, M, production) assert farm.total_production_day(2) == 150 def test_dairy_farm_total_production_sector(): N, M = 3, 3 production = [ [10, 20, 30], [40, 50, 60], [70, 80, 90] ] farm = DairyFarm(N, M, production) assert farm.total_production_sector(2, 1, 3) == 150 def test_process_queries(): N, M = 3, 3 production = [ [10, 20, 30], [40, 50, 60], [70, 80, 90] ] queries = [ 'D 2', 'U 1 2 100', 'S 2 1 3' ] results = process_queries(N, M, production, queries) assert results == [150, 150] if __name__ == \\"__main__\\": test_dairy_farm_update_production() test_dairy_farm_total_production_day() test_dairy_farm_total_production_sector() test_process_queries() print(\\"All tests passed.\\")","solution":"class DairyFarm: def __init__(self, N, M, production): Initialize the farm with N sectors, M days, and initial production values. self.N = N self.M = M self.production = production def update_production(self, sector, day, value): Update the amount of milk produced in a specific sector on a specific day. self.production[sector - 1][day - 1] = value def total_production_day(self, day): Calculate the total amount of milk produced across all sectors on a specific day. return sum(sector[day - 1] for sector in self.production) def total_production_sector(self, sector, start_day, end_day): Find the total milk production in a specific sector over a range of days. return sum(self.production[sector - 1][start_day - 1:end_day]) # Taking sample inputs and processing queries def process_queries(N, M, production, queries): farm = DairyFarm(N, M, production) results = [] for query in queries: parts = query.split() if parts[0] == 'U': sector, day, value = int(parts[1]), int(parts[2]), int(parts[3]) farm.update_production(sector, day, value) elif parts[0] == 'D': day = int(parts[1]) results.append(farm.total_production_day(day)) elif parts[0] == 'S': sector, start_day, end_day = int(parts[1]), int(parts[2]), int(parts[3]) results.append(farm.total_production_sector(sector, start_day, end_day)) return results # Example usage if __name__ == \\"__main__\\": N, M = 3, 3 production = [ [10, 20, 30], [40, 50, 60], [70, 80, 90] ] queries = [ 'D 2', 'U 1 2 100', 'S 2 1 3' ] print(process_queries(N, M, production, queries))"},{"question":"def is_match(input_string: str, pattern: str) -> str: Determine if the pattern matches the entire input string where '*' matches zero or more of any character. >>> is_match(\\"abc123xyz\\", \\"a*b*c*xyz\\") \\"YES\\" >>> is_match(\\"abcdefg\\", \\"a*e*h*\\") \\"NO\\"","solution":"def is_match(input_string, pattern): Determines if the input_string matches the pattern where '*' matches zero or more characters. s_len = len(input_string) p_len = len(pattern) # Create a dp table where dp[i][j] indicates if input_string[0:i] matches pattern[0:j] dp = [[False] * (p_len + 1) for _ in range(s_len + 1)] # Empty pattern matches empty string dp[0][0] = True # Dealing with patterns like a*, a*b* etc. for j in range(1, p_len + 1): if pattern[j - 1] == '*': dp[0][j] = dp[0][j - 1] for i in range(1, s_len + 1): for j in range(1, p_len + 1): if pattern[j - 1] == '*': dp[i][j] = dp[i - 1][j] or dp[i][j - 1] else: dp[i][j] = dp[i - 1][j - 1] and input_string[i - 1] == pattern[j - 1] return \\"YES\\" if dp[s_len][p_len] else \\"NO\\""},{"question":"def calculate_total_playlist_duration(test_cases): Calculate the total playtime of a user's playlist in hours, minutes, and seconds. >>> calculate_total_playlist_duration([['3:45', '4:30', '5:15'], ['10:15', '12:20']]) ['0:13:30', '0:22:35'] >>> calculate_total_playlist_duration([['0:59']]) ['0:00:59'] >>> calculate_total_playlist_duration([['60:00', '60:00', '60:00']]) ['3:00:00'] >>> calculate_total_playlist_duration([['999:59']]) ['16:39:59'] pass def parse_input(input_str): Parse the input string to extract test cases. >>> parse_input(\\"3n3:45n4:30n5:15n2n10:15n12:20n0\\") [['3:45', '4:30', '5:15'], ['10:15', '12:20']] >>> parse_input(\\"1n0:59n0\\") [['0:59']] >>> parse_input(\\"3n60:00n60:00n60:00n0\\") [['60:00', '60:00', '60:00']] >>> parse_input(\\"1n999:59n0\\") [['999:59']] pass def main(input_str): Main function to calculate total playlist duration from an input string. >>> main(\\"3n3:45n4:30n5:15n2n10:15n12:20n0\\") ['0:13:30', '0:22:35'] >>> main(\\"1n0:59n0\\") ['0:00:59'] >>> main(\\"3n60:00n60:00n60:00n0\\") ['3:00:00'] >>> main(\\"1n999:59n0\\") ['16:39:59'] pass","solution":"def calculate_total_playlist_duration(test_cases): results = [] for case in test_cases: total_seconds = 0 for duration in case: minutes, seconds = map(int, duration.split(':')) total_seconds += minutes * 60 + seconds hours = total_seconds // 3600 total_seconds %= 3600 minutes = total_seconds // 60 seconds = total_seconds % 60 results.append(f\\"{hours}:{minutes:02}:{seconds:02}\\") return results def parse_input(input_str): lines = input_str.strip().split('n') test_cases = [] current_case = [] for line in lines: if line == '0': if current_case: test_cases.append(current_case) break elif line.isdigit(): if current_case: test_cases.append(current_case) current_case = [] else: current_case.append(line) return test_cases def main(input_str): test_cases = parse_input(input_str) return calculate_total_playlist_duration(test_cases)"},{"question":"from typing import List, Tuple def count_distinct_in_range(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Counts the number of distinct integers in the specified range for each query. Parameters: arr (List[int]): The list of integers. queries (List[Tuple[int, int]]): The list of range queries. Returns: List[int]: The list of results for each query. Example: >>> count_distinct_in_range([1, 2, 1, 3, 2], [(1, 3), (2, 4), (1, 5)]) [2, 3, 3] >>> count_distinct_in_range([1], [(1, 1)]) [1]","solution":"def count_distinct_in_range(arr, queries): Counts the number of distinct integers in the specified range for each query. Parameters: arr (List[int]): The list of integers. queries (List[Tuple[int, int]]): The list of range queries. Returns: List[int]: The list of results for each query. results = [] for l, r in queries: distinct_count = len(set(arr[l-1:r])) results.append(distinct_count) return results"},{"question":"def can_arrange_stamps(n: int, beauties: List[int]) -> str: Determine if Bobby can arrange the stamps such that no adjacent stamps have the same beauty value. >>> can_arrange_stamps(5, [1, 2, 2, 3, 4]) 'POSSIBLE' >>> can_arrange_stamps(3, [5, 5, 5]) 'IMPOSSIBLE'","solution":"def can_arrange_stamps(n, beauties): from collections import Counter beauty_counts = Counter(beauties) max_count = max(beauty_counts.values()) if max_count > (n + 1) // 2: return \\"IMPOSSIBLE\\" else: return \\"POSSIBLE\\""},{"question":"def max_total_cost(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Returns the maximum total cost of the items you can buy using the special sale offer optimally. >>> max_total_cost(1, [(5, [3, 1, 2, 4, 5])]) [9] >>> max_total_cost(1, [(3, [10, 20, 30])]) [50] >>> max_total_cost(1, [(7, [5, 5, 5, 5, 5, 5, 5])]) [10]","solution":"def max_total_cost(t, test_cases): Returns the maximum total cost of the items you can buy using the special sale offer optimally. results = [] for i in range(t): n, prices = test_cases[i] prices.sort(reverse=True) results.append(prices[0] + prices[1]) return results"},{"question":"def num_islands(grid): Find the number of distinct islands in the given grid. >>> num_islands([ ... \\"11000\\", ... \\"11000\\", ... \\"00100\\", ... \\"00011\\" ...]) == 3 >>> num_islands([ ... \\"110\\", ... \\"010\\", ... \\"011\\" ...]) == 1","solution":"def num_islands(grid): if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) visited = [[False] * m for _ in range(n)] def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] == '0' or visited[x][y]: return visited[x][y] = True dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) island_count = 0 for i in range(n): for j in range(m): if grid[i][j] == '1' and not visited[i][j]: dfs(i, j) island_count += 1 return island_count"},{"question":"def shortest_path_to_drop_zone(n: int, sx: int, sy: int, walls: List[Tuple[int, int]], drop_zones: List[Tuple[int, int]]) -> int: Calculate the shortest Manhattan distance from the starting point to the nearest drop zone, avoiding walls. Args: - n: int, size of the grid (n x n) - sx: int, starting x-coordinate - sy: int, starting y-coordinate - walls: list of tuples, each representing the coordinates of walls - drop_zones: list of tuples, each representing the coordinates of drop zones Returns: - int, shortest distance to the nearest drop zone, or -1 if no path exists >>> shortest_path_to_drop_zone(5, 1, 1, [(2, 2), (3, 3)], [(1, 3), (5, 5)]) 4 >>> shortest_path_to_drop_zone(5, 1, 1, [], [(1, 3), (5, 5)]) 2 >>> shortest_path_to_drop_zone(5, 1, 1, [(1, 2), (2, 1)], [(5, 5)]) -1 >>> shortest_path_to_drop_zone(5, 1, 1, [], [(1, 1)]) 0 >>> shortest_path_to_drop_zone(5, 1, 1, [(2, 2), (3, 3), (4, 4)], [(1, 3), (4, 5)]) 2","solution":"from collections import deque def shortest_path_to_drop_zone(n, sx, sy, walls, drop_zones): Calculate the shortest path in Manhattan distance from the starting point to the nearest drop zone considering walls as obstacles. Args: - n: int, size of the grid (n x n) - sx: int, starting x-coordinate - sy: int, starting y-coordinate - walls: list of tuples, each representing the coordinates of walls - drop_zones: list of tuples, each representing the coordinates of drop zones Returns: - int, shortest distance to the nearest drop zone, or -1 if no path exists # Directions for moving in the grid (right, left, up, down) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Initialize the queue with the starting point queue = deque([(sx, sy, 0)]) # (x, y, distance) # Convert walls and drop_zones lists into sets for faster lookup wall_set = set(walls) drop_zone_set = set(drop_zones) # Visited set to keep track of visited cells visited = set() visited.add((sx, sy)) while queue: x, y, dist = queue.popleft() # If the current position is a drop zone, return the distance if (x, y) in drop_zone_set: return dist # Generate all possible moves for dx, dy in directions: nx, ny = x + dx, y + dy # Ensure the new position is within the grid and not a wall and not visited if 1 <= nx <= n and 1 <= ny <= n and (nx, ny) not in wall_set and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) # If the queue is exhausted and no drop zone was found return -1"},{"question":"def longest_subarray_with_sum_at_most(arr: List[int], S: int) -> int: Determine the length of the longest contiguous subarray whose sum is less than or equal to S. Parameters: - arr: List[int] - List of integers representing the array - S: int - The maximum sum for the subarray Returns: - int - Length of the longest contiguous subarray with sum <= S Examples: >>> longest_subarray_with_sum_at_most([1, 2, 3, 4, 5], 12) 4 >>> longest_subarray_with_sum_at_most([1, 2, 3, 4, 5, 6, 7], 15) 5 >>> longest_subarray_with_sum_at_most([1, 2, 3, 4, 5], 0) 0 >>> longest_subarray_with_sum_at_most([2, 2, 2, 2, 2], 8) 4 >>> longest_subarray_with_sum_at_most([10, 2, 3, 1, 5], 7) 3 def process_test_cases(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Process multiple test cases and return their results. Parameters: - T: int - Number of test cases - test_cases: List[Tuple[int, int, List[int]]] - List containing the test cases where each test case is represented as a tuple (N, S, arr) Returns: - List[int] - List of results for each test case Examples: >>> process_test_cases(2, [(5, 12, [1, 2, 3, 4, 5]), (7, 15, [1, 2, 3, 4, 5, 6, 7])]) [4, 5]","solution":"def longest_subarray_with_sum_at_most(arr, S): Determine the length of the longest contiguous subarray whose sum is less than or equal to S. Parameters: - arr: List[int] - List of integers representing the array - S: int - The maximum sum for the subarray Returns: - int - Length of the longest contiguous subarray with sum <= S max_length = 0 current_sum = 0 start = 0 for end, value in enumerate(arr): current_sum += value while current_sum > S and start <= end: current_sum -= arr[start] start += 1 max_length = max(max_length, end - start + 1) return max_length def process_test_cases(T, test_cases): Process multiple test cases and return their results. Parameters: - T: int - Number of test cases - test_cases: List[Tuple(int, int, List[int])] - List containing the test cases where each test case is represented as a tuple (N, S, arr) Returns: - List[int] - List of results for each test case results = [] for N, S, arr in test_cases: results.append(longest_subarray_with_sum_at_most(arr, S)) return results"},{"question":"from typing import List def count_good_pairs(arr: List[int]) -> int: Returns the number of good pairs in the given array which form a perfect square when multiplied. >>> count_good_pairs([2, 4, 6, 8, 16]) == 2 >>> count_good_pairs([1, 2, 3, 5, 7, 11]) == 0 from math import isqrt def test_example_1(): arr = [2, 4, 6, 8, 16] assert count_good_pairs(arr) == 2 def test_example_2(): arr = [1, 2, 3, 5, 7, 11] assert count_good_pairs(arr) == 0 def test_single_element(): arr = [1, 1] assert count_good_pairs(arr) == 1 def test_no_good_pairs(): arr = [3, 5, 7, 11, 13] assert count_good_pairs(arr) == 0 def test_all_good_pairs(): arr = [1, 4, 16, 256, 65536] assert count_good_pairs(arr) == 10 def test_mixed_numbers(): arr = [1, 3, 9, 27, 81] assert count_good_pairs(arr) == 4 def test_large_numbers(): arr = [1000000, 1000000, 1000000, 1000000] assert count_good_pairs(arr) == 6 def test_no_elements(): arr = [] assert count_good_pairs(arr) == 0 def test_two_elements_no_good_pairs(): arr = [2, 3] assert count_good_pairs(arr) == 0 def test_two_elements_one_good_pair(): arr = [2, 8] assert count_good_pairs(arr) == 1","solution":"import math def count_good_pairs(arr): Returns the number of good pairs in the given array which form a perfect square when multiplied. def is_perfect_square(x): root = int(math.isqrt(x)) return root * root == x n = len(arr) good_pairs = 0 # Compare each pair of distinct elements for i in range(n): for j in range(i + 1, n): product = arr[i] * arr[j] if is_perfect_square(product): good_pairs += 1 return good_pairs"},{"question":"def update_scores(n: int, matches: List[Tuple[str, str, str]]) -> None: Updates and prints the scores of players after each match. Parameters: n (int): Number of matches matches (list): List of tuples, each containing (player1, player2, result) Example: >>> update_scores(1, [(\\"Alice\\", \\"Bob\\", \\"win\\")]) Alice 3 Bob 0 >>> update_scores(4, [(\\"Alice\\", \\"Bob\\", \\"win\\"), (\\"Bob\\", \\"Charlie\\", \\"lose\\"), (\\"Alice\\", \\"Charlie\\", \\"draw\\"), (\\"Charlie\\", \\"Bob\\", \\"draw\\")]) Alice 3 Bob 0 Charlie 0 Alice 3 Bob 0 Charlie 3 Alice 4 Bob 0 Charlie 4 Alice 4 Bob 1 Charlie 5 from solution import update_scores def test_update_scores_single_game(): output = [] def mock_print(*args): output.append(\\" \\".join(map(str, args))) import builtins original_print = builtins.print builtins.print = mock_print update_scores(1, [(\\"Alice\\", \\"Bob\\", \\"win\\")]) builtins.print = original_print assert output == [\\"Alice 3\\", \\"Bob 0\\"] def test_update_scores_multiple_games(): output = [] def mock_print(*args): output.append(\\" \\".join(map(str, args))) import builtins original_print = builtins.print builtins.print = mock_print update_scores(4, [(\\"Alice\\", \\"Bob\\", \\"win\\"), (\\"Bob\\", \\"Charlie\\", \\"lose\\"), (\\"Alice\\", \\"Charlie\\", \\"draw\\"), (\\"Charlie\\", \\"Bob\\", \\"draw\\")]) builtins.print = original_print expected_output = [ \\"Alice 3\\", \\"Bob 0\\", \\"Alice 3\\", \\"Bob 0\\", \\"Charlie 3\\", \\"Alice 4\\", \\"Bob 0\\", \\"Charlie 4\\", \\"Alice 4\\", \\"Bob 1\\", \\"Charlie 5\\" ] assert output == expected_output def test_update_scores_draw_game(): output = [] def mock_print(*args): output.append(\\" \\".join(map(str, args))) import builtins original_print = builtins.print builtins.print = mock_print update_scores(1, [(\\"Alice\\", \\"Bob\\", \\"draw\\")]) builtins.print = original_print assert output == [\\"Alice 1\\", \\"Bob 1\\"]","solution":"def update_scores(n, matches): Updates and prints the scores of players after each match. Parameters: n (int): Number of matches matches (list): List of tuples, each containing (player1, player2, result) scores = {} for match in matches: player1, player2, result = match if player1 not in scores: scores[player1] = 0 if player2 not in scores: scores[player2] = 0 if result == 'win': scores[player1] += 3 elif result == 'lose': scores[player2] += 3 elif result == 'draw': scores[player1] += 1 scores[player2] += 1 for player in sorted(scores.keys()): print(f\\"{player} {scores[player]}\\")"},{"question":"from typing import List def shortest_path_in_city_map(n: int, m: int, grid: List[str]) -> int: Find the shortest path from the top-left corner (0, 0) to the bottom-right corner (n-1, m-1) in a city map grid represented by roads ('.') and buildings ('#'). If no such path exists, return -1. >>> shortest_path_in_city_map(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 4 >>> shortest_path_in_city_map(3, 3, [\\"#\\", \\".#.\\", \\"...\\"]) -1 >>> shortest_path_in_city_map(5, 5, [\\".....\\", \\".#.\\", \\"..#..\\", \\".#...\\", \\".....\\"]) 8 def test_shortest_path_no_obstacles(): grid = [ \\"...\\" ] n = 3 m = 3 assert shortest_path_in_city_map(n, m, grid) == 4 def test_shortest_path_with_obstacles(): grid = [ \\"#\\", \\".#.\\", \\"...\\" ] n = 3 m = 3 assert shortest_path_in_city_map(n, m, grid) == -1 def test_shortest_path_complex_grid(): grid = [ \\".....\\", \\".#.\\", \\"..#..\\", \\".#...\\", \\".....\\" ] n = 5 m = 5 assert shortest_path_in_city_map(n, m, grid) == 8 def test_shortest_path_no_start_end_path(): grid = [ \\"#..\\", \\"...\\", \\"...\\" ] n = 3 m = 3 assert shortest_path_in_city_map(n, m, grid) == -1 def test_shortest_path_single_cell(): grid = [ \\".\\" ] n = 1 m = 1 assert shortest_path_in_city_map(n, m, grid) == 0 def test_shortest_path_with_isolated_start(): grid = [ \\".#.\\", \\"#\\", \\"...\\" ] n = 3 m = 3 assert shortest_path_in_city_map(n, m, grid) == -1","solution":"from collections import deque def shortest_path_in_city_map(n, m, grid): if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] visited = [[False] * m for _ in range(n)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited[0][0] = True while queue: r, c, dist = queue.popleft() if r == n-1 and c == m-1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and not visited[nr][nc] and grid[nr][nc] == '.': visited[nr][nc] = True queue.append((nr, nc, dist + 1)) return -1"},{"question":"def sequence_operations(n, q, arr, operations): Perform a sequence of operations to manipulate a list of integers. :param n: number of elements in the list :param q: number of operations :param arr: list of integers :param operations: list of operations to perform :return: list of results for query operations >>> sequence_operations(5, 5, [1, 2, 3, 4, 5], [(2, 1, 3), (1, 2, 10), (2, 1, 3), (1, 5, 2), (2, 4, 5)]) [6, 16, 11] >>> sequence_operations(3, 3, [1, 1, 1], [(1, 1, 2), (1, 2, 3), (1, 3, 4)]) [] >>> sequence_operations(3, 2, [1, 2, 3], [(2, 1, 1), (2, 1, 3)]) [1, 6] >>> sequence_operations(4, 6, [1, 2, 3, 4], [(2, 1, 2), (1, 1, 5), (2, 1, 4), (1, 4, 1), (2, 3, 4), (2, 1, 1)]) [3, 15, 8, 6] >>> sequence_operations(2, 3, [100000, 100000], [(2, 1, 2), (1, 2, 2), (2, 1, 2)]) [200000, 200002]","solution":"def sequence_operations(n, q, arr, operations): result = [] for operation in operations: op_type, x, y = operation if op_type == 1: arr[x-1] += y elif op_type == 2: result.append(sum(arr[x-1:y])) return result"},{"question":"from typing import List def canScheduleContest(startDay: str, duration: int, holidays: List[str]) -> str: Determine if the contest can be scheduled without any clashes with national holidays. Parameters: startDay (str): The starting day of the week for the contest. duration (int): The number of days the contest will last. holidays (List[str]): List of national holidays within the week. Returns: str: \\"YES\\" if the contest can be scheduled without any clashes with the holidays, otherwise \\"NO\\". >>> canScheduleContest('MON', 5, ['WED', 'THU']) \\"NO\\" >>> canScheduleContest('TUE', 3, ['FRI']) \\"YES\\" >>> canScheduleContest('SAT', 2, ['SUN', 'MON']) \\"NO\\" >>> canScheduleContest('FRI', 1, ['TUE']) \\"YES\\" # Test cases assert canScheduleContest('MON', 5, ['WED', 'THU']) == \\"NO\\" assert canScheduleContest('TUE', 3, ['FRI']) == \\"YES\\" assert canScheduleContest('SAT', 2, ['SUN', 'MON']) == \\"NO\\" assert canScheduleContest('FRI', 1, ['TUE']) == \\"YES\\" assert canScheduleContest('SUN', 3, ['SUN', 'MON', 'TUE']) == \\"NO\\" assert canScheduleContest('MON', 7, ['SUN']) == \\"NO\\" assert canScheduleContest('WED', 2, []) == \\"YES\\" assert canScheduleContest('WED', 1, ['MON', 'TUE']) == \\"YES\\" assert canScheduleContest('WED', 1, ['WED']) == \\"NO\\"","solution":"def canScheduleContest(startDay, duration, holidays): # List of days in a week in order week = ['MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN'] # Find the starting index of the start day in the week start_index = week.index(startDay) # Generate the list of contest days contest_days = [week[(start_index + i) % 7] for i in range(duration)] # Check if any contest days overlap with holidays for day in contest_days: if day in holidays: return \\"NO\\" return \\"YES\\""},{"question":"def remove_duplicates(participant_ids): Removes duplicate participant IDs, preserving the order of their first occurrence. >>> remove_duplicates(['A1', 'B2', 'C3', 'D4', 'E5', 'F6']) == ['A1', 'B2', 'C3', 'D4', 'E5', 'F6'] >>> remove_duplicates(['X123', 'Y456', 'X123', 'Z789', 'Y456']) == ['X123', 'Y456', 'Z789'] >>> remove_duplicates(['P001', 'Q002', 'P001', 'P001', 'R003']) == ['P001', 'Q002', 'R003'] pass def process_input(input_str): Processes the input string to return the space-separated unique participant IDs. >>> process_input(\\"A1 B2 C3 D4 E5 F6\\") == 'A1 B2 C3 D4 E5 F6' >>> process_input(\\"X123 Y456 X123 Z789 Y456\\") == 'X123 Y456 Z789' >>> process_input(\\"P001 Q002 P001 P001 R003\\") == 'P001 Q002 R003' >>> process_input(\\"\\") == \\"\\" pass","solution":"def remove_duplicates(participant_ids): Removes duplicate participant IDs, preserving the order of their first occurrence. seen = set() unique_ids = [] for pid in participant_ids: if pid not in seen: unique_ids.append(pid) seen.add(pid) return unique_ids def process_input(input_str): Processes the input string to return the space-separated unique participant IDs. participant_ids = input_str.split() unique_ids = remove_duplicates(participant_ids) return \\" \\".join(unique_ids)"},{"question":"def max_overlapping_intervals(intervals): Determines the maximum number of overlapping intervals at any given time from a list of time intervals. intervals: List of [(start_time, end_time)] Each interval is given as a tuple with \\"HH:MM\\" strings representing the start and end times. Returns: int: Maximum number of overlapping intervals >>> max_overlapping_intervals([(\\"09:00\\", \\"10:30\\")]) 1 >>> max_overlapping_intervals([(\\"09:00\\", \\"10:00\\"), (\\"09:30\\", \\"10:30\\")]) 2 >>> max_overlapping_intervals([(\\"09:00\\", \\"11:00\\"), (\\"10:00\\", \\"12:00\\")]) 2 >>> max_overlapping_intervals([(\\"09:00\\", \\"10:30\\"), (\\"10:00\\", \\"11:00\\"), (\\"11:30\\", \\"12:00\\"), (\\"10:15\\", \\"11:45\\")]) 3 >>> max_overlapping_intervals([(\\"08:00\\", \\"08:30\\"), (\\"08:15\\", \\"09:00\\"),(\\"08:45\\", \\"09:15\\"), (\\"09:10\\", \\"09:50\\")]) 2","solution":"def max_overlapping_intervals(intervals): Determines the maximum number of overlapping intervals at any given time from a list of time intervals. intervals: List of [(start_time, end_time)] Each interval is given as a tuple with \\"HH:MM\\" strings representing the start and end times. Returns: int: Maximum number of overlapping intervals events = [] # Convert intervals to events where (+1) is start and (-1) is end for start, end in intervals: events.append((start, 1)) events.append((end, -1)) # Sort events based on time, breaking ties by giving preference to end events events.sort(key=lambda x: (x[0], x[1])) max_overlap = 0 current_overlap = 0 # Traverse events to find max overlaps for event in events: current_overlap += event[1] max_overlap = max(max_overlap, current_overlap) return max_overlap def read_datasets(): import sys input = sys.stdin.read data = input().strip().split('n') result = [] i = 0 while i < len(data): n = int(data[i]) if n == 0: break intervals = [(data[i + j + 1].split()[0], data[i + j + 1].split()[1]) for j in range(n)] result.append(max_overlapping_intervals(intervals)) i += n + 1 for res in result: print(res)"},{"question":"def all_books_available(bookshelf: List[str], interested_books: List[str]) -> bool: Checks whether all books in the interested_books list are available on the bookshelf. Parameters: bookshelf (list): A list containing the titles of books on the bookshelf. interested_books (list): A list containing the titles of books you're interested in. Returns: bool: True if all interested books are on the bookshelf, False otherwise. >>> bookshelf = [\\"The Art of Computer Programming\\", \\"The Pragmatic Programmer\\", \\"Structure and Interpretation of Computer Programs\\"] >>> interested_books = [\\"The Pragmatic Programmer\\", \\"The Art of Computer Programming\\"] >>> all_books_available(bookshelf, interested_books) True >>> bookshelf = [\\"Game of Thrones\\", \\"Harry Potter and the Philosopher's Stone\\", \\"To Kill a Mockingbird\\"] >>> interested_books = [\\"The Pragmatic Programmer\\", \\"The Art of Computer Programming\\"] >>> all_books_available(bookshelf, interested_books) False >>> bookshelf = [\\"The Art of Computer Programming\\", \\"The Pragmatic Programmer\\", \\"Structure and Interpretation of Computer Programs\\"] >>> interested_books = [\\"The Pragmatic Programmer\\", \\"Clean Code\\"] >>> all_books_available(bookshelf, interested_books) False >>> bookshelf = [\\"The Art of Computer Programming\\", \\"The Pragmatic Programmer\\", \\"Structure and Interpretation of Computer Programs\\"] >>> interested_books = [] >>> all_books_available(bookshelf, interested_books) True >>> bookshelf = [] >>> interested_books = [\\"The Pragmatic Programmer\\", \\"The Art of Computer Programming\\"] >>> all_books_available(bookshelf, interested_books) False >>> bookshelf = [\\"The Art of Computer Programming\\", \\"The Pragmatic Programmer\\"] >>> interested_books = [\\"The Art of Computer Programming\\", \\"The Pragmatic Programmer\\"] >>> all_books_available(bookshelf, interested_books) True","solution":"def all_books_available(bookshelf, interested_books): Checks whether all books in the interested_books list are available on the bookshelf. Parameters: bookshelf (list): A list containing the titles of books on the bookshelf. interested_books (list): A list containing the titles of books you're interested in. Returns: bool: True if all interested books are on the bookshelf, False otherwise. bookshelf_set = set(bookshelf) for book in interested_books: if book not in bookshelf_set: return False return True"},{"question":"def unique_paths(n: int, m: int) -> int: Returns the number of unique paths from top-left corner to bottom-right corner in a grid. >>> unique_paths(3, 7) 28 >>> unique_paths(4, 4) 20","solution":"def unique_paths(n, m): Returns the number of unique paths from top-left corner to bottom-right corner in a grid. # Create a 2D dp array with all elements initially set to 1 dp = [[1] * m for _ in range(n)] # Fill the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner of the dp array contains the number of unique paths return dp[n-1][m-1]"},{"question":"from typing import List def max_distinct_subarray(N: int, A: List[int], K: int) -> int: Determine the maximum number of distinct elements in any subarray of length K. >>> max_distinct_subarray(7, [1, 2, 1, 3, 4, 2, 3], 4) == 4 >>> max_distinct_subarray(5, [1, 2, 3, 4, 5], 3) == 3 >>> max_distinct_subarray(5, [1, 2, 2, 2, 3], 2) == 2 >>> max_distinct_subarray(5, [1, 2, 2, 2, 3], 5) == 3 >>> max_distinct_subarray(1, [1], 1) == 1 >>> max_distinct_subarray(10, [1, 9, 8, 2, 4, 6, 8, 2, 1, 7], 5) == 5","solution":"def max_distinct_subarray(N: int, A: list[int], K: int) -> int: from collections import defaultdict if K > N: return 0 # If K is greater than N, no subarray of length K can exist max_distinct_count = 0 current_count = 0 freq_map = defaultdict(int) # Initialize the first window for i in range(K): if freq_map[A[i]] == 0: current_count += 1 freq_map[A[i]] += 1 max_distinct_count = current_count # Slide the window for i in range(K, N): # Remove the element going out of the window if freq_map[A[i - K]] == 1: current_count -= 1 freq_map[A[i - K]] -= 1 # Add the new element coming into the window if freq_map[A[i]] == 0: current_count += 1 freq_map[A[i]] += 1 if current_count > max_distinct_count: max_distinct_count = current_count return max_distinct_count"},{"question":"class SimpleTextEditor: A simple text editor that supports append, delete, print, and undo operations. Methods: append(w) -- Appends the string w to the end of the current text. delete(k) -- Deletes the last k characters from the current text. print(k) -- Outputs the kth character of the current text. undo() -- Undoes the last append or delete operation. from solution import SimpleTextEditor def test_simple_text_editor(): editor = SimpleTextEditor() # Test initial state assert editor.text == \\"\\" # Test append operation editor.append(\\"abc\\") assert editor.text == \\"abc\\" # Test print operation assert editor.text[2] == 'c' # Equivalent to print 3 # Test delete operation editor.delete(3) assert editor.text == \\"\\" # Test append operation editor.append(\\"xy\\") assert editor.text == \\"xy\\" # Test print operation assert editor.text[1] == 'y' # Equivalent to print 2 # Test undo operation editor.undo() assert editor.text == \\"\\" # Test print operation after undo editor.append(\\"abc\\") editor.append(\\"xy\\") editor.undo() assert editor.text == \\"abc\\" # Test undo operation editor.undo() assert editor.text == \\"\\"","solution":"class SimpleTextEditor: def __init__(self): self.text = \\"\\" self.history = [] def append(self, w): self.history.append((self.text,)) self.text += w def delete(self, k): self.history.append((self.text,)) self.text = self.text[:-k] def print_char(self, k): print(self.text[k - 1]) def undo(self): if self.history: self.text = self.history.pop()[0]"},{"question":"def max_resources(n: int, m: int, grid: List[List[int]]) -> int: Determine the maximum resources Brimstone can collect if he starts his expedition from any cell on the grid, moves to adjacent cells, and uses his teleportation ability once. >>> max_resources(2, 2, [[1, 2], [3, 4]]) 10 >>> max_resources(3, 3, [[0, 0, 0], [0, 100, 0], [0, 0, 0]]) 100 from typing import List def test_example1(): grid = [ [1, 2], [3, 4] ] assert max_resources(2, 2, grid) == 10 def test_example2(): grid = [ [0, 0, 0], [0, 100, 0], [0, 0, 0] ] assert max_resources(3, 3, grid) == 100 def test_single_element(): grid = [ [-10] ] assert max_resources(1, 1, grid) == -10 def test_large_negative_values(): grid = [ [-1000000000, -1000000000], [-1000000000, -1000000000] ] assert max_resources(2, 2, grid) == -4000000000 def test_mixed_values(): grid = [ [1, -2, 3], [-4, 5, -6], [7, -8, 9] ] assert max_resources(3, 3, grid) == 5","solution":"def max_resources(n, m, grid): max_resource = -float('inf') for i in range(n): for j in range(m): current_resources = sum([grid[x][y] for x in range(n) for y in range(m)]) max_resource = max(max_resource, current_resources) return max_resource"},{"question":"def smallest_sequence_length(n: int, sequence: List[int]) -> int: You are given a sequence of n integers a1, a2, ..., an. You can perform the following operation on the sequence: choose any two distinct integers ai and aj (1 ≤ i, j ≤ n) and remove them from the sequence. You can repeat this operation as many times as you want, or you can stop at any point. Your goal is to make the remaining sequence as small as possible. Input - The first line contains an integer n (1 ≤ n ≤ 1000), the number of elements in the sequence. - The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 100,000). Output - Print a single integer representing the length of the smallest sequence you can achieve. Examples: >>> smallest_sequence_length(6, [1, 1, 2, 2, 3, 3]) 0 >>> smallest_sequence_length(7, [1, 2, 2, 3, 3, 4, 4]) 1","solution":"def smallest_sequence_length(n, sequence): from collections import Counter # Count the occurrences of each element counts = Counter(sequence) # Find the total number of pairs that can be made pairs = sum(count // 2 for count in counts.values()) # Remaining elements after forming pairs remaining = n - 2 * pairs return remaining"},{"question":"def max_parks(M: int, N: int) -> int: Returns the maximum number of parks that can be placed in an MxN grid such that no two parks are on neighboring blocks. >>> max_parks(3, 3) 5 >>> max_parks(2, 2) 2","solution":"def max_parks(M, N): Returns the maximum number of parks that can be placed in an MxN grid such that no two parks are on neighboring blocks. # The maximum number of parks is achieved by filling every alternate cell # in a checkerboard pattern. Therefore, it can be calculated using: max_parks = ((M + 1) // 2) * ((N + 1) // 2) + (M // 2) * (N // 2) return max_parks"},{"question":"from typing import List, Tuple def communication_network_cost(n: int, m: int, connections: List[Tuple[int, int]]) -> int: Determines if the network is robust and returns the cost if it is, otherwise returns -1. >>> communication_network_cost(5, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (2, 4)]) == 6 >>> communication_network_cost(4, 2, [(1, 2), (3, 4)]) == -1 >>> communication_network_cost(2, 1, [(1, 2)]) == 1 >>> communication_network_cost(3, 3, [(1, 2), (2, 3), (3, 1)]) == 3 >>> communication_network_cost(1, 0, []) == -1","solution":"from collections import defaultdict, deque def is_robust_network(n, m, cables): Determines if the network is robust and returns the cost if it is, otherwise returns -1. :param n: Number of nodes :param m: Number of cables :param cables: List of tuples representing undirected cables between nodes :return: Cost of the network if robust, otherwise -1 if n <= 1: return -1 # Build adjacency list adj_list = defaultdict(list) for u, v in cables: adj_list[u].append(v) adj_list[v].append(u) # Function to check if the graph is connected def is_connected(excluded_node): visited = [False] * (n + 1) start_node = next(node for node in range(1, n + 1) if node != excluded_node) queue = deque([start_node]) visited[start_node] = True connected_count = 1 while queue: node = queue.popleft() for neighbor in adj_list[node]: if not visited[neighbor] and neighbor != excluded_node: visited[neighbor] = True queue.append(neighbor) connected_count += 1 return connected_count == n - 1 # Check if all nodes except excluded one are visited # Check robustness by testing connectivity after excluding each node one by one for node in range(1, n + 1): if not is_connected(node): return -1 return m def communication_network_cost(n, m, connections): return is_robust_network(n, m, connections)"},{"question":"from typing import List def min_moves_with_magic_wand(grid: List[str]) -> int: Determine the minimum number of moves required to reach the bottom-right corner from the top-left corner in a grid with the possibility of using a magic wand once to remove an obstacle. Args: grid (List[str]): a list of strings where '.' represents an open space and '#' represents an obstacle. Returns: int: the minimum number of moves to reach the bottom-right corner or -1 if it's not possible. Examples: >>> min_moves_with_magic_wand([ ... \\"....\\", ... \\"....\\", ... \\"....\\", ... \\"....\\" ...]) 6 >>> min_moves_with_magic_wand([ ... \\"..#\\", ... \\".#.\\", ... \\"..#\\" ...]) 4 if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"from collections import deque def min_moves_with_magic_wand(grid): N = len(grid) if N == 0: return -1 def in_bounds(x, y): return 0 <= x < N and 0 <= y < N def bfs(start_x, start_y, can_use_wand): directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(start_x, start_y, 0, can_use_wand)]) visited = set((start_x, start_y, can_use_wand)) while queue: x, y, dist, wand_left = queue.popleft() if (x, y) == (N-1, N-1): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if in_bounds(nx, ny): next_pos = (nx, ny, wand_left) if wand_left and grid[nx][ny] == '#': next_pos_with_wand = (nx, ny, False) if next_pos_with_wand not in visited: visited.add(next_pos_with_wand) queue.append((nx, ny, dist + 1, False)) if grid[nx][ny] == '.' and next_pos not in visited: visited.add(next_pos) queue.append((nx, ny, dist + 1, wand_left)) return -1 # No path found return bfs(0, 0, True) # Example usage # grid = [ # \\"..#\\", # \\".#.\\", # \\"..#\\" # ] # print(min_moves_with_magic_wand(grid)) # Output: 4"},{"question":"def max_trees_standing(heights: List[int]) -> int: Returns the maximum number of trees that can be left standing after removal such that the heights of the remaining trees form a strictly increasing sequence. >>> max_trees_standing([3, 1, 4, 1, 5]) 3 >>> max_trees_standing([7, 7, 7, 7]) 1 >>> max_trees_standing([10]) 1 >>> max_trees_standing([1, 2, 3, 4, 5]) 5 >>> max_trees_standing([5, 4, 3, 2, 1]) 1 >>> max_trees_standing([10, 1, 2, 10, 4, 5]) 4 >>> max_trees_standing([1000000, 1, 999999, 2, 500000]) 3 >>> max_trees_standing([2, 2, 2, 3, 3, 1]) 2","solution":"def max_trees_standing(heights): Returns the maximum number of trees that can be left standing after removal such that the heights of the remaining trees form a strictly increasing sequence. import bisect if not heights: return 0 # This will store the end elements of potential increasing subsequences subseq_ends = [] for height in heights: # Find the position to replace or append the current height pos = bisect.bisect_left(subseq_ends, height) if pos < len(subseq_ends): subseq_ends[pos] = height else: subseq_ends.append(height) return len(subseq_ends)"},{"question":"def find_fastest_runner(n, m, k, updates): Determine the runner who completes the marathon the fastest based on given updates. Args: n (int): Number of checkpoints. m (int): Number of runners. k (int): Number of updates. updates (List[Tuple[int, int, int, int]]): Each update contains four integers (runner_i, l_i, r_i, t_i). Returns: int: The index of the runner who reaches the final checkpoint n the earliest. Example: >>> n, m, k = 5, 3, 6 >>> updates = [ ... (1, 1, 2, 5), ... (2, 1, 3, 4), ... (1, 3, 5, 7), ... (3, 1, 4, 3), ... (2, 4, 5, 6), ... (3, 5, 5, 8) ... ] >>> find_fastest_runner(n, m, k, updates) 2 from typing import List, Tuple def test_example_case(): n, m, k = 5, 3, 6 updates = [ (1, 1, 2, 5), (2, 1, 3, 4), (1, 3, 5, 7), (3, 1, 4, 3), (2, 4, 5, 6), (3, 5, 5, 8) ] assert find_fastest_runner(n, m, k, updates) == 2 def test_earliest_at_final_checkpoint(): n, m, k = 5, 2, 4 updates = [ (1, 1, 5, 10), (2, 4, 5, 5), (1, 3, 5, 9), (2, 1, 3, 2) ] assert find_fastest_runner(n, m, k, updates) == 2 def test_single_runner(): n, m, k = 5, 1, 1 updates = [ (1, 1, 5, 7) ] assert find_fastest_runner(n, m, k, updates) == 1 def test_multiple_updates(): n, m, k = 6, 2, 6 updates = [ (1, 1, 3, 5), (2, 3, 6, 15), (1, 4, 6, 10), (2, 1, 2, 7), (1, 2, 4, 8), (2, 5, 6, 12) ] assert find_fastest_runner(n, m, k, updates) == 1 def test_multiple_runners_same_time(): n, m, k = 10, 3, 3 updates = [ (1, 1, 10, 20), (2, 1, 10, 20), (3, 1, 10, 20) ] assert find_fastest_runner(n, m, k, updates) == 1","solution":"def find_fastest_runner(n, m, k, updates): # Initialize an array to track the earliest time each runner reaches the final checkpoint n final_times = [float('inf')] * (m + 1) # Process each update for update in updates: runner, l, r, t = update # If the range includes the final checkpoint n if l <= n <= r: # Update the time if this is the first time or a faster time the runner reaches checkpoint n final_times[runner] = min(final_times[runner], t) # Determine the runner with the smallest index who reached the final checkpoint the earliest fastest_runner = None earliest_time = float('inf') for runner in range(1, m + 1): if final_times[runner] < earliest_time: earliest_time = final_times[runner] fastest_runner = runner return fastest_runner"},{"question":"from typing import List def minimum_trips(n: int, X: int, weights: List[int]) -> int: Determine the minimum number of trips the drone needs to transport all the packages >>> minimum_trips(5, 10, [1, 2, 3, 4, 5]) 3 >>> minimum_trips(3, 15, [7, 8, 8]) 2 >>> minimum_trips(1, 10, [5]) 1 >>> minimum_trips(4, 5, [5, 5, 5, 5]) 4 >>> minimum_trips(4, 10, [3, 7, 2, 8]) 2 >>> minimum_trips(2, 1000000000, [1000000000, 999999999]) 2","solution":"def minimum_trips(n, X, weights): weights.sort(reverse=True) # Sort weights in descending order for optimization trips = 0 left, right = 0, n - 1 while left <= right: # If the heaviest (left) and lightest (right) package can be carried together if weights[left] + weights[right] <= X: right -= 1 left += 1 trips += 1 return trips # Example usage: # n, X = 5, 10 # weights = [1, 2, 3, 4, 5] # print(minimum_trips(n, X, weights)) # Output: 3"},{"question":"def min_insertions_to_palindrome(s: str) -> int: Returns the minimum number of insertions needed to make the string 's' a palindrome. >>> min_insertions_to_palindrome(\\"abac\\") 1 >>> min_insertions_to_palindrome(\\"google\\") 2 >>> min_insertions_to_palindrome(\\"aab\\") 1","solution":"def min_insertions_to_palindrome(s): Returns the minimum number of insertions needed to make the string 's' a palindrome. def lcs(s1, s2): Helper function to calculate the longest common subsequence length between two strings n = len(s1) dp = [[0] * (n + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][n] # To form a palindrome, we can find the longest palindromic subsequence of \`s\` # and subtract its length from \`s\`'s length longest_palindromic_subseq_len = lcs(s, s[::-1]) return len(s) - longest_palindromic_subseq_len"},{"question":"from typing import List def is_isogram(s: str) -> bool: Determines if the string is an isogram. Args: s: A string consisting of lowercase English letters. Returns: True if the string is an isogram, False otherwise. >>> is_isogram(\\"machine\\") True >>> is_isogram(\\"hello\\") False def isogram_checker(t: int, test_cases: List[str]) -> List[str]: Checks multiple strings if they are isograms. Args: t: Number of test cases (integer). test_cases: List of string test cases. Returns: List of results for each test case (\\"YES\\" or \\"NO\\"). >>> isogram_checker(3, [\\"machine\\", \\"isogram\\", \\"hello\\"]) ['YES', 'YES', 'NO'] >>> isogram_checker(2, [\\"abcd\\", \\"aabc\\"]) ['YES', 'NO']","solution":"def is_isogram(s): Determines if the string is an isogram. return len(s) == len(set(s)) def isogram_checker(t, test_cases): Checks multiple strings if they are isograms. Args: t: Number of test cases (integer). test_cases: List of string test cases. Returns: List of results for each test case (\\"YES\\" or \\"NO\\"). results = [] for s in test_cases: if is_isogram(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def rotate_list_right(arr, k): Rotates the list 'arr' to the right by 'k' steps. Args: arr (List[int]): List of integers to rotate. k (int): Number of steps to rotate the list. Returns: List[int]: The rotated list. >>> rotate_list_right([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list_right([10, 22, 13, 44, 15, 36, 27], 3) [15, 36, 27, 10, 22, 13, 44] >>> rotate_list_right([2, 4, 6, 8], 4) [2, 4, 6, 8] pass def process_input(input_lines): Processes the input and returns the list of rotated arrays for each test case. Args: input_lines (List[str]): The list of input lines. Returns: List[List[int]]: List of rotated arrays for each test case. >>> input_lines = [ ... \\"3\\", ... \\"5 2\\", \\"1 2 3 4 5\\", ... \\"7 3\\", \\"10 22 13 44 15 36 27\\", ... \\"4 4\\", \\"2 4 6 8\\" ... ] >>> process_input(input_lines) [[4, 5, 1, 2, 3], [15, 36, 27, 10, 22, 13, 44], [2, 4, 6, 8]] pass # Unit Tests def test_rotate_list_right(): assert rotate_list_right([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert rotate_list_right([10, 22, 13, 44, 15, 36, 27], 3) == [15, 36, 27, 10, 22, 13, 44] assert rotate_list_right([2, 4, 6, 8], 4) == [2, 4, 6, 8] def test_process_input(): input_lines = [ \\"3\\", \\"5 2\\", \\"1 2 3 4 5\\", \\"7 3\\", \\"10 22 13 44 15 36 27\\", \\"4 4\\", \\"2 4 6 8\\" ] expected_output = [ [4, 5, 1, 2, 3], [15, 36, 27, 10, 22, 13, 44], [2, 4, 6, 8] ] assert process_input(input_lines) == expected_output def test_single_element(): assert rotate_list_right([1], 10) == [1] def test_no_rotation(): assert rotate_list_right([1, 2, 3], 0) == [1, 2, 3] def test_rotation_more_than_length(): assert rotate_list_right([1, 2, 3], 3) == [1, 2, 3] assert rotate_list_right([1, 2, 3], 4) == [3, 1, 2]","solution":"def rotate_list_right(arr, k): Rotates the list 'arr' to the right by 'k' steps. n = len(arr) k = k % n # To handle cases where k > n return arr[-k:] + arr[:-k] def process_input(input_lines): Processes the input and returns the list of rotated arrays for each test case. index = 0 T = int(input_lines[index]) index += 1 results = [] for _ in range(T): N, K = map(int, input_lines[index].split()) index += 1 array = list(map(int, input_lines[index].split())) index += 1 rotated_array = rotate_list_right(array, K) results.append(rotated_array) return results # Example usage input_lines = [ \\"3\\", \\"5 2\\", \\"1 2 3 4 5\\", \\"7 3\\", \\"10 22 13 44 15 36 27\\", \\"4 4\\", \\"2 4 6 8\\" ] results = process_input(input_lines) for result in results: print(' '.join(map(str, result))) # For output"},{"question":"def minimum_vehicles_required(m: int, weights: List[int], k: int, capacities: List[int]) -> int: Determines the minimum number of vehicles required to deliver all products without exceeding their capacity. Parameters: m (int): The number of products. weights (list of int): The weights of the products. k (int): The number of available vehicles. capacities (list of int): The capacities of the vehicles. Returns: int: The minimum number of vehicles required, or -1 if it is not possible to deliver all products. >>> minimum_vehicles_required(5, [2, 3, 4, 5, 6], 3, [8, 7, 9]) 3 >>> minimum_vehicles_required(4, [4, 1, 6, 5], 2, [7, 10]) 2 >>> minimum_vehicles_required(3, [10, 15, 25], 2, [8, 12]) -1 pass # Example Unit Tests def test_example1(): assert minimum_vehicles_required(5, [2, 3, 4, 5, 6], 3, [8, 7, 9]) == 3 def test_example2(): assert minimum_vehicles_required(4, [4, 1, 6, 5], 2, [7, 10]) == 2 def test_example3(): assert minimum_vehicles_required(3, [10, 15, 25], 2, [8, 12]) == -1 def test_no_products(): assert minimum_vehicles_required(0, [], 2, [7, 10]) == 0 def test_over_max_capacity(): assert minimum_vehicles_required(1, [2000], 2, [1000, 1000]) == -1 def test_all_single_vehicle(): assert minimum_vehicles_required(3, [2, 2, 2], 1, [10]) == 1 def test_perfect_distribution(): assert minimum_vehicles_required(3, [1, 2, 3], 3, [1, 2, 3]) == 3 def test_multiple_vehicles_same_capacity(): assert minimum_vehicles_required(6, [2, 4, 4, 2, 2, 1], 3, [8, 8, 8]) == 2 def test_larger_capacity_than_needed(): assert minimum_vehicles_required(3, [1, 1, 1], 4, [10, 10, 10, 10]) == 1","solution":"def minimum_vehicles_required(m, weights, k, capacities): Determines the minimum number of vehicles required to deliver all products without exceeding their capacity. Parameters: m (int): The number of products. weights (list of int): The weights of the products. k (int): The number of available vehicles. capacities (list of int): The capacities of the vehicles. Returns: int: The minimum number of vehicles required, or -1 if it is not possible to deliver all products. # Sort the weights of products in descending order weights.sort(reverse=True) # Sort the capacities of vehicles in descending order capacities.sort(reverse=True) # Initialize vehicle usage tracker vehicle_used = [0] * k for weight in weights: for i in range(k): if vehicle_used[i] + weight <= capacities[i]: vehicle_used[i] += weight break else: # If no vehicle can accommodate this product, return -1 return -1 # Count how many vehicles were actually used used_vehicle_count = sum(1 for usage in vehicle_used if usage > 0) return used_vehicle_count"},{"question":"def calculate_reward(points: list[int]) -> int: Calculates the total reward points for the week based on daily performance points. Parameters: points (list of int): A list containing 7 integers representing daily performance. Returns: int: The total reward points for the week. Examples: >>> calculate_reward([3, 1, -1, 0, 2, -3, 4]) 6 >>> calculate_reward([5, 2, 0, -7, 3, 1, -4]) 0 >>> calculate_reward([-1, -1, -1, -1, -1, -1, -1]) 0 >>> calculate_reward([1, 2, 3, 4, 5, 6, 7]) 28 >>> calculate_reward([0, 0, 0, 0, 0, 0, 0]) 0 >>> calculate_reward([-1, -2, -3, -4, -5, -6, -7]) 0 >>> calculate_reward([50, -25, 30, -20, 40, -10, 60]) 125 from solution import calculate_reward def test_calculate_reward_standard_cases(): assert calculate_reward([3, 1, -1, 0, 2, -3, 4]) == 6 assert calculate_reward([5, 2, 0, -7, 3, 1, -4]) == 0 assert calculate_reward([-1, -1, -1, -1, -1, -1, -1]) == 0 def test_calculate_reward_all_positive_values(): assert calculate_reward([1, 2, 3, 4, 5, 6, 7]) == 28 def test_calculate_reward_all_zero_values(): assert calculate_reward([0, 0, 0, 0, 0, 0, 0]) == 0 def test_calculate_reward_all_negative_values(): assert calculate_reward([-1, -2, -3, -4, -5, -6, -7]) == 0 def test_calculate_reward_mixed_large_values(): assert calculate_reward([50, -25, 30, -20, 40, -10, 60]) == 125","solution":"def calculate_reward(points): Calculates the total reward points for the week based on daily performance points. Parameters: points (list of int): A list containing 7 integers representing daily performance. Returns: int: The total reward points for the week. total_reward = 0 for point in points: if point > 0: total_reward += point else: total_reward -= abs(point) if total_reward < 0: total_reward = 0 return total_reward"},{"question":"def max_wish_points(n: int, wish_points: List[int]) -> int: Determine the maximum possible wish points that can be achieved for all branches. >>> max_wish_points(3, [1, 2, 3]) 9 >>> max_wish_points(5, [3, 0, 1, 4, 2]) 20 >>> max_wish_points(1, [5]) 5 >>> max_wish_points(4, [2, 2, 2, 2]) 8 >>> max_wish_points(10, [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]) 900 >>> max_wish_points(3, [0, 0, 0]) 0","solution":"def max_wish_points(n, wish_points): Returns the maximum possible wish points that can be achieved for all branches. max_wish_point = max(wish_points) total_wish_points = max_wish_point * n return total_wish_points"},{"question":"def find_word_occurrences(m: int, n: int, grid: List[str]) -> Union[str, List[Tuple[int, int, int, int]]]: Find all occurrences of the word \\"level\\" vertically or horizontally in the grid. >>> find_word_occurrences(4, 5, [\\"level\\", \\"xlevl\\", \\"opevl\\", \\"level\\"]) [(0, 0, 0, 4), (3, 0, 3, 4)] >>> find_word_occurrences(5, 5, [\\"lxxxx\\", \\"exxxx\\", \\"vxxxx\\", \\"exxxx\\", \\"lxxxx\\"]) [(0, 0, 4, 0)] >>> find_word_occurrences(5, 5, [\\"level\\", \\"exxel\\", \\"vxxxl\\", \\"exxel\\", \\"lxxxx\\"]) [(0, 0, 0, 4), (0, 0, 4, 0)] >>> find_word_occurrences(4, 5, [\\"abcde\\", \\"fghij\\", \\"klmno\\", \\"pqrst\\"]) \\"No occurrences found\\"","solution":"def find_word_occurrences(m, n, grid): target_word = \\"level\\" word_len = len(target_word) occurrences = [] # Check horizontally for r in range(m): for c in range(n - word_len + 1): if grid[r][c:c + word_len] == target_word: occurrences.append((r, c, r, c + word_len - 1)) # Check vertically for c in range(n): for r in range(m - word_len + 1): if \\"\\".join(grid[r + i][c] for i in range(word_len)) == target_word: occurrences.append((r, c, r + word_len - 1, c)) if not occurrences: return \\"No occurrences found\\" return occurrences"},{"question":"def can_form_palindrome(s: str, k: int) -> bool: Determines if the given string can be transformed into a palindrome within at most k operations. :param s: The input string that needs to be checked. :param k: The maximum number of character changes allowed. :return: True if it is possible to form a palindrome within the given number of operations, False otherwise. >>> can_form_palindrome(\\"abca\\", 1) True >>> can_form_palindrome(\\"abcd\\", 1) False pass def process_tests(t: int, test_cases: list) -> list: Processes multiple test cases and returns a list with results for each test case. :param t: The number of test cases. :param test_cases: A list of tuples, each containing a string and an integer. :return: A list of strings \\"YES\\" or \\"NO\\" for each test case result. >>> process_tests(3, [(\\"abca\\", 1), (\\"abcde\\", 2), (\\"abcd\\", 1)]) ['YES', 'YES', 'NO'] >>> process_tests(2, [(\\"aab\\", 1), (\\"racecar\\", 0)]) ['YES', 'YES'] pass","solution":"def can_form_palindrome(s, k): Determines if the given string can be transformed into a palindrome within at most k operations. mismatches = 0 length = len(s) for i in range(length // 2): if s[i] != s[length - i - 1]: mismatches += 1 return mismatches <= k def process_tests(t, test_cases): Processes multiple test cases. results = [] for case in test_cases: s, k = case k = int(k) if can_form_palindrome(s, k): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def manage_tasks(commands: List[str]) -> List[List[str]]: Manage a list of tasks based on the given commands. Args: commands (list of str): List of commands to manage tasks. Returns: list of lists: Each sub-list contains the tasks after a LIST command in the commands list. Examples: >>> manage_tasks([\\"ADD Buy milk\\", \\"ADD Do homework\\", \\"LIST\\", \\"COMPLETE Buy milk\\", \\"ADD Read book\\", \\"REMOVE Do homework\\", \\"LIST\\"]) [[\\"Buy milk\\", \\"Do homework\\"], [\\"Buy milk (completed)\\", \\"Read book\\"]] >>> manage_tasks([\\"ADD Task1\\", \\"ADD Task2\\", \\"REMOVE Task1\\", \\"LIST\\", \\"REMOVE Task2\\"]) [[\\"Task2\\"]] from typing import List import unittest class TestTaskManager(unittest.TestCase): def test_manage_tasks_scenario1(self): commands = [ \\"7\\", \\"ADD Buy milk\\", \\"ADD Do homework\\", \\"LIST\\", \\"COMPLETE Buy milk\\", \\"ADD Read book\\", \\"REMOVE Do homework\\", \\"LIST\\" ] expected = [ [\\"Buy milk\\", \\"Do homework\\"], [\\"Buy milk (completed)\\", \\"Read book\\"] ] self.assertEqual(manage_tasks(commands[1:]), expected) def test_manage_tasks_add_remove(self): commands = [ \\"5\\", \\"ADD Task1\\", \\"ADD Task2\\", \\"REMOVE Task1\\", \\"LIST\\", \\"REMOVE Task2\\" ] expected = [ [\\"Task2\\"] ] self.assertEqual(manage_tasks(commands[1:]), expected) def test_manage_tasks_complete_and_list(self): commands = [ \\"5\\", \\"ADD Write report\\", \\"ADD Send emails\\", \\"COMPLETE Write report\\", \\"COMPLETE Send emails\\", \\"LIST\\" ] expected = [ [\\"Write report (completed)\\", \\"Send emails (completed)\\"] ] self.assertEqual(manage_tasks(commands[1:]), expected) def test_manage_tasks_multiple_lists(self): commands = [ \\"6\\", \\"ADD Plan meeting\\", \\"LIST\\", \\"ADD Prepare presentation\\", \\"LIST\\", \\"COMPLETE Plan meeting\\", \\"LIST\\", ] expected = [ [\\"Plan meeting\\"], [\\"Plan meeting\\", \\"Prepare presentation\\"], [\\"Prepare presentation\\", \\"Plan meeting (completed)\\"] ] self.assertEqual(manage_tasks(commands[1:]), expected) def test_manage_tasks_only_add_and_list(self): commands = [ \\"3\\", \\"ADD Task A\\", \\"ADD Task B\\", \\"LIST\\" ] expected = [ [\\"Task A\\", \\"Task B\\"] ] self.assertEqual(manage_tasks(commands[1:]), expected)","solution":"def manage_tasks(commands): Manage a list of tasks based on the given commands. Args: commands (list of str): List of commands to manage tasks. Returns: list of lists: Each sub-list contains the tasks after a LIST command in the commands list. tasks = [] completed_tasks = set() output = [] for command in commands: if command.startswith(\\"ADD \\"): task = command[4:] tasks.append(task) elif command.startswith(\\"REMOVE \\"): task = command[7:] if task in tasks: tasks.remove(task) if task in completed_tasks: completed_tasks.remove(task) elif command.startswith(\\"COMPLETE \\"): task = command[9:] if task in tasks and task not in completed_tasks: tasks.remove(task) tasks.append(task) completed_tasks.add(task) elif command == \\"LIST\\": current_list = [] for task in tasks: if task in completed_tasks: current_list.append(f\\"{task} (completed)\\") else: current_list.append(task) output.append(current_list) return output"},{"question":"from typing import List def min_moves_to_reach_destination(N: int, M: int, grid: List[List[str]]) -> int: Determine the minimum number of moves required to reach the bottom-right corner of the grid from the top-left corner. >>> min_moves_to_reach_destination(5, 6, [['.', '.', '.', '#', '.', '.'], ... ['.', '#', '.', '.', '#', '.'], ... ['.', '#', '#', '.', '.', '.'], ... ['.', '.', '.', '#', '.', '#'], ... ['#', '.', '.', '.', '.', '.']]) 9 >>> min_moves_to_reach_destination(3, 3, [['.', '#', '.'], ... ['#', '#', '.'], ... ['.', '.', '.']]) -1 >>> min_moves_to_reach_destination(1, 1, [['.']]) 0 >>> min_moves_to_reach_destination(1, 1, [['#']]) -1 >>> min_moves_to_reach_destination(2, 2, [['.', '#'], ... ['#', '.']]) -1 >>> min_moves_to_reach_destination(2, 2, [['.', '.'], ... ['.', '.']]) 2","solution":"from collections import deque def min_moves_to_reach_destination(N, M, grid): if grid[0][0] == '#' or grid[N-1][M-1] == '#': return -1 # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: r, c, steps = queue.popleft() if r == N-1 and c == M-1: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < N and 0 <= nc < M and grid[nr][nc] == '.' and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return -1"},{"question":"def knapsack(n, W, items): Determine the maximum value of items that can be carried in the magic bag. :param n: Number of items :param W: Maximum weight capacity of the bag :param items: List of tuples with each tuple containing weight and value of an item :return: Maximum value of items that can be carried in the magic bag pass def test_knapsack_example_1(): items = [(2, 3), (3, 4), (4, 5), (5, 6)] n, W = 4, 8 assert knapsack(n, W, items) == 10 def test_knapsack_example_2(): items = [(10, 60), (20, 100), (30, 120)] n, W = 3, 50 assert knapsack(n, W, items) == 220 def test_knapsack_single_item(): items = [(10, 100)] n, W = 1, 10 assert knapsack(n, W, items) == 100 def test_knapsack_no_items(): items = [] n, W = 0, 50 assert knapsack(n, W, items) == 0 def test_knapsack_zero_capacity(): items = [(10, 60), (20, 100), (30, 120)] n, W = 3, 0 assert knapsack(n, W, items) == 0 def test_knapsack_all_items_too_heavy(): items = [(10, 60), (20, 100), (30, 120)] n, W = 3, 5 assert knapsack(n, W, items) == 0","solution":"def knapsack(n, W, items): Determine the maximum value of items that can be carried in the magic bag. :param n: Number of items :param W: Maximum weight capacity of the bag :param items: List of tuples with each tuple containing weight and value of an item :return: Maximum value of items that can be carried in the magic bag dp = [[0] * (W + 1) for _ in range(n + 1)] for i in range(1, n + 1): wi, vi = items[i - 1] for w in range(W + 1): if wi <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - wi] + vi) else: dp[i][w] = dp[i - 1][w] return dp[n][W]"},{"question":"def generate_triangle(n: int) -> str: Generates a right-angled triangle pattern of height n using '*' characters. >>> generate_triangle(1) '*' >>> generate_triangle(3) '*n**n***' >>> generate_triangle(5) '*n**n***n****n*****' >>> generate_triangle(10) '*n**n***n****n*****n******n*******n********n*********n**********' >>> generate_triangle(1000) expected = \\"n\\".join(\\"*\\" * i for i in range(1, 1001)) expected","solution":"def generate_triangle(n): Generates a right-angled triangle pattern of height n using '*' characters. triangle = \\"n\\".join(\\"*\\" * i for i in range(1, n + 1)) return triangle"},{"question":"def minimum_trucks(n: int, w: int, weights: List[int]) -> int: Determine the minimum number of trucks required to deliver all the packages. >>> minimum_trucks(5, 10, [2, 5, 4, 7, 1]) == 3 >>> minimum_trucks(4, 15, [10, 7, 5, 4]) == 2","solution":"def minimum_trucks(n, w, weights): # Sort the weights of the packages in decreasing order weights.sort(reverse=True) trucks = 0 i = 0 j = n - 1 while i <= j: if weights[i] + weights[j] <= w: j -= 1 i += 1 trucks += 1 return trucks"},{"question":"def min_energy_to_visit_waypoints(n: int, waypoints: List[Tuple[int, int]]) -> int: Calculate the minimum energy required to visit all waypoints. :param n: int, number of waypoints :param waypoints: list of tuples, each tuple contains two integers (x, y) for the coordinates of a waypoint :return: int, minimum amount of energy required >>> min_energy_to_visit_waypoints(3, [(0, 0), (1, 1), (1, 2)]) 2 >>> min_energy_to_visit_waypoints(4, [(1, 1), (3, 3), (6, 6), (6, 8)]) 7","solution":"def min_energy_to_visit_waypoints(n, waypoints): Calculate the minimum energy required to visit all waypoints. :param n: int, number of waypoints :param waypoints: list of tuples, each tuple contains two integers (x, y) for the coordinates of a waypoint :return: int, minimum amount of energy required total_energy = 0 for i in range(1, n): x1, y1 = waypoints[i-1] x2, y2 = waypoints[i] dx = abs(x2 - x1) dy = abs(y2 - y1) # Add the maximum of dx and dy to total energy total_energy += max(dx, dy) return total_energy"},{"question":"def library_operations(n, m: int, operations: List[Tuple[int, int]]) -> List[str]: Function to perform a series of library operations and output the query results. :param n: The number of books :param m: The number of operations :param operations: List of tuples representing the operations :return: List of results for the queries pass # Unit tests def test_example_case(): assert library_operations(5, 7, [(1, 3), (1, 5), (2, 3), (4, 3), (3, 3), (4, 3), (4, 5)]) == [\\"Borrowed\\", \\"Available\\", \\"Available\\"] def test_all_books_operations(): assert library_operations(3, 6, [(1, 1), (2, 1), (4, 1), (3, 1), (4, 1), (4, 2)]) == [\\"Borrowed\\", \\"Available\\", \\"Available\\"] def test_multiple_queries(): assert library_operations(2, 5, [(1, 1), (1, 2), (2, 1), (4, 1), (4, 2)]) == [\\"Borrowed\\", \\"Available\\"] def test_only_add_and_query(): assert library_operations(3, 6, [(1, 1), (1, 2), (4, 1), (4, 2), (1, 3), (4, 3)]) == [\\"Available\\", \\"Available\\", \\"Available\\"] def test_borrow_return_query(): assert library_operations(4, 8, [(1, 1), (1, 2), (1, 3), (1, 4), (2, 3), (4, 3), (3, 3), (4, 3)]) == [\\"Borrowed\\", \\"Available\\"]","solution":"def library_operations(n, m, operations): Function to perform a series of library operations and output the query results. :param n: The number of books :param m: The number of operations :param operations: List of tuples representing the operations :return: List of results for the queries book_status = {i: \\"Available\\" for i in range(1, n+1)} result = [] for operation in operations: t, id = operation if t == 1: book_status[id] = \\"Available\\" elif t == 2: book_status[id] = \\"Borrowed\\" elif t == 3: book_status[id] = \\"Available\\" elif t == 4: result.append(book_status[id]) return result"},{"question":"from typing import List, Tuple def count_unique_paths(n: int, m: int, roads: List[Tuple[int, int]], start: int, end: int) -> int: Returns the number of unique paths from start to end. n : int : number of cities m : int : number of one-way roads roads : List[Tuple[int, int]] : list of one-way roads represented as tuples (a, b) start : int : starting city end : int : destination city >>> count_unique_paths(6, 7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 5), (4, 6), (5, 6)], 1, 6) 3 >>> count_unique_paths(3, 2, [(1, 2), (2, 3)], 1, 3) 1 >>> count_unique_paths(4, 2, [(1, 2), (3, 4)], 1, 4) 0 >>> count_unique_paths(4, 5, [(1, 2), (2, 3), (3, 1), (2, 4), (3, 4)], 1, 4) 2 >>> count_unique_paths(7, 9, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (2, 5), (1, 6), (6, 7), (7, 5)], 1, 5) 4","solution":"from collections import defaultdict, deque def count_unique_paths(n, m, roads, start, end): Returns the number of unique paths from start to end. n : int : number of cities m : int : number of one-way roads roads : List[Tuple[int, int]] : list of one-way roads represented as tuples (a, b) start : int : starting city end : int : destination city graph = defaultdict(list) for a, b in roads: graph[a].append(b) def count_paths(graph, start, end): queue = deque([(start, set())]) unique_paths_count = 0 while queue: current_city, visited_roads = queue.popleft() if current_city == end: unique_paths_count += 1 continue for next_city in graph[current_city]: if (current_city, next_city) not in visited_roads: new_visited_roads = visited_roads | {(current_city, next_city)} queue.append((next_city, new_visited_roads)) return unique_paths_count return count_paths(graph, start, end)"},{"question":"def highest_unique_char_blip(blips: List[str]) -> str: Returns the blip with the highest number of unique characters, or the first occurring one in case of a tie. >>> highest_unique_char_blip([\\"social\\", \\"networking\\", \\"interest\\", \\"content\\"]) 'networking' >>> highest_unique_char_blip([\\"abc\\", \\"bca\\", \\"cab\\"]) 'abc' >>> highest_unique_char_blip([\\"test\\"]) 'test' >>> highest_unique_char_blip([\\"aaaa\\", \\"bbbb\\", \\"cccc\\"]) 'aaaa' >>> highest_unique_char_blip([\\"short\\", \\"a longer blip\\", \\"medium\\"]) 'a longer blip' pass","solution":"def highest_unique_char_blip(blips): Returns the blip with the highest number of unique characters, or the first occurring one in case of a tie. max_unique_chars = 0 result_blip = \\"\\" for blip in blips: unique_chars = len(set(blip)) if unique_chars > max_unique_chars: max_unique_chars = unique_chars result_blip = blip elif unique_chars == max_unique_chars and result_blip == \\"\\": result_blip = blip return result_blip"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Returns the length of the longest palindromic subsequence in string s. >>> longest_palindromic_subsequence(\\"bbbab\\") 4 >>> longest_palindromic_subsequence(\\"cbbd\\") 2 from solution import longest_palindromic_subsequence def test_example_case_1(): assert longest_palindromic_subsequence(\\"bbbab\\") == 4 def test_example_case_2(): assert longest_palindromic_subsequence(\\"cbbd\\") == 2 def test_single_character(): assert longest_palindromic_subsequence(\\"a\\") == 1 def test_two_different_characters(): assert longest_palindromic_subsequence(\\"ab\\") == 1 def test_palindrome_string(): assert longest_palindromic_subsequence(\\"aba\\") == 3 def test_mixed_characters(): assert longest_palindromic_subsequence(\\"character\\") == 5 def test_longer_string(): assert longest_palindromic_subsequence(\\"xabacxdey\\") == 5","solution":"def longest_palindromic_subsequence(s): Returns the length of the longest palindromic subsequence in string s. n = len(s) dp = [[0] * n for _ in range(n)] # Every single character is a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Build the table. The outer loop is for substrings of length from 2 to n for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1]"},{"question":"import math from functools import reduce def gcd_multiple(numbers): return reduce(math.gcd, numbers) def max_students(N: int, A: List[int]) -> int: Calculate the maximum number of students that can receive sweets without having any leftovers. Args: N (int): The number of different types of sweet packets. A (List[int]): The list of integers representing the number of sweets in each packet. Returns: int: The maximum number of students that can receive sweets without any leftovers. Example: >>> max_students(5, [4, 6, 8, 12, 16]) 2 >>> max_students(3, [2, 4, 8]) 2 >>> max_students(4, [1, 1, 1, 1]) 1 >>> max_students(2, [5, 10]) 5 >>> max_students(6, [7, 14, 21, 28, 35, 42]) 7 >>> max_students(5, [1, 1, 1, 1, 1]) 1 >>> max_students(5, [2, 3, 5, 7, 11]) 1 >>> max_students(4, [100, 50, 25, 75]) 25","solution":"import math from functools import reduce def gcd_multiple(numbers): return reduce(math.gcd, numbers) def max_students(N, A): return gcd_multiple(A)"},{"question":"def min_cut_time(n, heights): Calculate the minimum cut time required to satisfy the given heights. :param n: Number of required heights :param heights: List of integer heights required :return: Minimum cut time pass def process_input(input_data): Processes multiple sets of input and returns results for each set. :param input_data: List of strings representing multiple datasets :return: List of results for each dataset pass # Unit Tests def test_min_cut_time_single_height(): assert min_cut_time(3, [5, 5, 5]) == 1 def test_min_cut_time_multiple_heights(): assert min_cut_time(4, [3, 3, 3, 4]) == 2 def test_min_cut_time_single_repeated_height(): assert min_cut_time(5, [6, 6, 6, 6, 6]) == 1 def test_min_cut_time_mixed_heights(): assert min_cut_time(4, [1, 2, 3, 4]) == 4 def test_process_input_multiple_datasets(): input_data = [ '3', '5 5 5', '4', '3 3 3 4', '5', '6 6 6 6 6', '0' ] assert process_input(input_data) == [1, 2, 1] def test_process_input_single_dataset(): input_data = ['3', '5 5 5', '0'] assert process_input(input_data) == [1] def test_process_input_varied_heights(): input_data = ['5', '1 2 1 2 1', '0'] assert process_input(input_data) == [2]","solution":"def min_cut_time(n, heights): Calculate the minimum cut time required to satisfy the given heights. :param n: Number of required heights :param heights: List of integer heights required :return: Minimum cut time if n == 0: return 0 unique_heights = len(set(heights)) return unique_heights def process_input(input_data): Processes multiple sets of input and returns results for each set. :param input_data: List of strings representing multiple datasets :return: List of results for each dataset results = [] index = 0 while index < len(input_data): n = int(input_data[index]) if n == 0: break heights = list(map(int, input_data[index+1].split())) results.append(min_cut_time(n, heights)) index += 2 return results"},{"question":"def multiply_sparse_polynomials(poly1, poly2): Multiply two sparse polynomials represented as lists of tuples, where each tuple contains the coefficient and exponent of a non-zero term. Args: poly1 (List[Tuple[int, int]]): List of tuples representing the first polynomial. poly2 (List[Tuple[int, int]]): List of tuples representing the second polynomial. Returns: List[Tuple[int, int]]: Resulting polynomial in sparse form. Examples: >>> multiply_sparse_polynomials([(1, 1), (2, 2), (3, 3)], [(1, 0), (4, 1)]) [(1, 1), (6, 2), (11, 3), (12, 4)] >>> multiply_sparse_polynomials([(3, 0), (2, 1)], [(1, 0), (1, 1)]) [(3, 0), (5, 1), (2, 2)] >>> multiply_sparse_polynomials([(0, 0)], [(0, 0)]) [(0, 0)]","solution":"def multiply_sparse_polynomials(poly1, poly2): result_terms = {} for c1, k1 in poly1: for c2, k2 in poly2: product_coeff = c1 * c2 product_exp = k1 + k2 if product_exp in result_terms: result_terms[product_exp] += product_coeff else: result_terms[product_exp] = product_coeff # Remove zero coefficient terms and sort by exponent result = [(coeff, exp) for exp, coeff in sorted(result_terms.items()) if coeff != 0] if not result: return [(0, 0)] return result"},{"question":"def influence_score(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]], int]]) -> List[int]: Compute the influence score for given users based on follower relationships. >>> influence_score(1, [(5, 4, [(1, 2), (1, 3), (2, 4), (3, 5)], 1)]) [4] >>> influence_score(1, [(3, 0, [], 1)]) [0] >>> influence_score(1, [(6, 5, [(1, 3), (1, 4), (2, 3), (4, 5), (3, 6)], 1)]) [4] >>> influence_score(2, [(5, 4, [(1, 2), (1, 3), (2, 4), (3, 5)], 1), (4, 3, [(1, 2), (2, 3), (3, 4)], 2)]) [4, 2]","solution":"from collections import defaultdict, deque def influence_score(t, test_cases): results = [] for test_case in test_cases: n, m, relationships, u = test_case followers = defaultdict(set) followed_by = defaultdict(set) for a, b in relationships: followers[a].add(b) followed_by[b].add(a) direct_followers = followers[u] influence_count = len(direct_followers) indirect_followers_set = set() for follower in direct_followers: for indirect_follower in followers[follower]: if indirect_follower != u: # avoid counting self indirect_followers_set.add(indirect_follower) influence_count += len(indirect_followers_set) results.append(influence_count) return results"},{"question":"def smallest_window(s: str, t: str) -> str: Write a function smallest_window that takes two strings \`s\` and \`t\`, and finds the smallest contiguous substring of \`s\` that contains all the characters in \`t\` exactly once. If there are multiple such substrings, return the one that appears first in \`s\`. If no such substring exists, return an empty string. >>> smallest_window(\\"adobecodebanc\\", \\"abc\\") \\"banc\\" >>> smallest_window(\\"thisisateststring\\", \\"tist\\") \\"tstri\\" >>> smallest_window(\\"a\\", \\"b\\") \\"\\" def test_smallest_window_example1(): s = \\"adobecodebanc\\" t = \\"abc\\" assert smallest_window(s, t) == \\"banc\\" def test_smallest_window_example2(): s = \\"thisisateststring\\" t = \\"tist\\" assert smallest_window(s, t) == \\"tstri\\" def test_smallest_window_example3(): s = \\"a\\" t = \\"b\\" assert smallest_window(s, t) == \\"\\" def test_smallest_window_exact_match(): s = \\"abcdef\\" t = \\"abcdef\\" assert smallest_window(s, t) == \\"abcdef\\" def test_smallest_window_no_match(): s = \\"abcdef\\" t = \\"gh\\" assert smallest_window(s, t) == \\"\\" def test_smallest_window_contains_repeated(): s = \\"aaabbbccc\\" t = \\"abc\\" assert smallest_window(s, t) == \\"abbbc\\" def test_smallest_window_multiple_minimal_substrings(): s = \\"abcabcab\\" t = \\"abc\\" assert smallest_window(s, t) == \\"abc\\" def test_smallest_window_single_char(): s = \\"a\\" t = \\"a\\" assert smallest_window(s, t) == \\"a\\"","solution":"def smallest_window(s: str, t: str) -> str: from collections import Counter if not s or not t: return \\"\\" # Count characters in t t_count = Counter(t) required = len(t_count) # Initialize the sliding window l, r = 0, 0 formed = 0 window_counts = {} # Result variables ans = float(\\"inf\\"), None, None while r < len(s): char = s[r] window_counts[char] = window_counts.get(char, 0) + 1 if char in t_count and window_counts[char] == t_count[char]: formed += 1 while l <= r and formed == required: char = s[l] if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) window_counts[char] -= 1 if char in t_count and window_counts[char] < t_count[char]: formed -= 1 l += 1 r += 1 return \\"\\" if ans[0] == float(\\"inf\\") else s[ans[1]:ans[2]+1]"},{"question":"def alternate_even_odd(n: int, nums: List[int]) -> List[int]: Arrange the integers in the list to alternate between even and odd numbers starting with the smallest possible number. If not possible, return an empty list. Parameters: n (int): number of integers in the list. nums (List[int]): list of integers. Returns: List[int]: list of integers arranged to alternate between even and odd numbers or an empty list if not possible. Examples: >>> alternate_even_odd(6, [8, 3, 5, 2, 7, 6]) [2, 3, 6, 5, 8, 7] >>> alternate_even_odd(5, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> alternate_even_odd(4, [2, 4, 6, 8]) []","solution":"def alternate_even_odd(n, nums): Arrange the integers in the list to alternate between even and odd numbers starting with the smallest possible number. If not possible, return an empty list. even_nums = sorted([num for num in nums if num % 2 == 0]) odd_nums = sorted([num for num in nums if num % 2 != 0]) # If the number difference between even and odd numbers is more than 1, return [] if abs(len(even_nums) - len(odd_nums)) > 1: return [] result = [] start_with_even = (even_nums and (not odd_nums or even_nums[0] < odd_nums[0])) # Create the sequence starting with the smallest possible number while even_nums or odd_nums: if start_with_even and even_nums: result.append(even_nums.pop(0)) start_with_even = False elif not start_with_even and odd_nums: result.append(odd_nums.pop(0)) start_with_even = True else: return [] return result"},{"question":"def find_words_with_prefix(words, prefix): Returns a list of words from the input list that start with the given prefix. If no words are found with the given prefix, returns \\"No words found\\". >>> find_words_with_prefix([\\"apple\\", \\"appetizer\\", \\"application\\", \\"banana\\", \\"apply\\"], \\"app\\") [\\"apple\\", \\"appetizer\\", \\"application\\", \\"apply\\"] >>> find_words_with_prefix([\\"hello\\", \\"world\\", \\"help\\"], \\"wo\\") [\\"world\\"] >>> find_words_with_prefix([\\"dog\\", \\"deer\\", \\"deal\\", \\"dance\\", \\"cat\\"], \\"car\\") [\\"No words found\\"] >>> find_words_with_prefix([\\"back\\", \\"bake\\", \\"base\\", \\"basket\\", \\"bat\\"], \\"back\\") [\\"back\\"] >>> find_words_with_prefix([\\"jump\\", \\"joy\\", \\"joke\\", \\"jar\\", \\"jug\\"], \\"\\") [\\"jump\\", \\"joy\\", \\"joke\\", \\"jar\\", \\"jug\\"] >>> find_words_with_prefix([], \\"test\\") [\\"No words found\\"]","solution":"def find_words_with_prefix(words, prefix): Returns a list of words from the input list that start with the given prefix. If no words are found with the given prefix, returns \\"No words found\\". result = [word for word in words if word.startswith(prefix)] return result if result else [\\"No words found\\"]"},{"question":"def min_operations_to_zero(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Returns the minimum number of operations required to make all elements of the array in each test case equal to zero. Parameters: t (int): Number of test cases. test_cases (list): List of tuples where each tuple contains an integer n and a list of n integers. Returns: list: List of integers where each integer represents the minimum number of operations for the corresponding test case. from typing import List, Tuple # Unit Tests def test_basic_cases(): t = 4 test_cases = [ (3, [3, 2, 3]), (4, [4, 4, 4, 4]), (5, [1, 2, 1, 2, 1]), (1, [7]) ] assert min_operations_to_zero(t, test_cases) == [3, 4, 2, 7] def test_single_element_cases(): t = 3 test_cases = [ (1, [1]), (1, [1000]), (1, [500]) ] assert min_operations_to_zero(t, test_cases) == [1, 1000, 500] def test_edge_cases(): t = 2 test_cases = [ (1000, [1] * 1000), (1000, [1000] * 1000) ] assert min_operations_to_zero(t, test_cases) == [1, 1000] def test_varied_cases(): t = 2 test_cases = [ (5, [2, 3, 1, 2, 3]), (7, [5, 1, 4, 2, 4, 3, 6]) ] assert min_operations_to_zero(t, test_cases) == [3, 6]","solution":"def min_operations_to_zero(t, test_cases): Returns the minimum number of operations required to make all elements of the array in each test case equal to zero. Parameters: t (int): Number of test cases. test_cases (list): List of tuples where each tuple contains an integer n and a list of n integers. Returns: list: List of integers where each integer represents the minimum number of operations for the corresponding test case. results = [] for n, array in test_cases: results.append(max(array)) return results"},{"question":"def tallest_stack(n: int, heights: List[int]) -> Tuple[int, List[int]]: Determines the maximum height of the stack that can be achieved and the sequence of blocks in the stack. :param n: int, the number of blocks. :param heights: list of int, heights of the blocks. :return: tuple, maximum possible height of the stack and the sequence of block heights. >>> tallest_stack(5, [4, 5, 3, 2, 4]) (18, [5, 4, 4, 3, 2]) >>> tallest_stack(7, [10, 9, 10, 8, 7, 6, 5]) (55, [10, 10, 9, 8, 7, 6, 5]) >>> tallest_stack(4, [3, 3, 4, 4]) (14, [4, 4, 3, 3])","solution":"def tallest_stack(n, heights): Determines the maximum height of the stack that can be achieved and the sequence of blocks in the stack. :param n: int, the number of blocks. :param heights: list of int, heights of the blocks. :return: tuple, maximum possible height of the stack and the sequence of block heights. # Sort the heights in non-increasing order heights_sorted = sorted(heights, reverse=True) # Return as the maximum height and the sorted sequence return sum(heights_sorted), heights_sorted"},{"question":"def first_non_repeating_character(s: str) -> int: Returns the 0-indexed position of the first non-repeating character in s, or -1 if there is no such character. >>> first_non_repeating_character(\\"leetcode\\") 0 >>> first_non_repeating_character(\\"loveleetcode\\") 2 >>> first_non_repeating_character(\\"aabb\\") -1 >>> first_non_repeating_character(\\"x\\") 0 >>> first_non_repeating_character(\\"aaaa\\") -1 >>> first_non_repeating_character(\\"abcdef\\") 0 >>> first_non_repeating_character(\\"aabbccd\\") 6 >>> first_non_repeating_character(\\"abcabcdef\\") 6","solution":"def first_non_repeating_character(s): Returns the 0-indexed position of the first non-repeating character in s, or -1 if there is no such character. # Dictionary to store the frequency of each character frequency = {} # Populate the frequency dictionary for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 # Find the first character with frequency 1 for i, char in enumerate(s): if frequency[char] == 1: return i # If no non-repeating character is found return -1"},{"question":"def min_moves_to_destination(x, y, a, b): Returns the minimum number of moves to reach destination (x, y) from (0, 0) using steps of (a, 0), (0, b), and (a, b). If reaching (x, y) is impossible, returns -1. >>> min_moves_to_destination(8, 6, 2, 3) 4 >>> min_moves_to_destination(10, 15, 2, 3) 5 >>> min_moves_to_destination(5, 11, 3, 4) -1 >>> min_moves_to_destination(7, 5, 2, 3) -1 >>> min_moves_to_destination(6, 9, 2, 3) 3 >>> min_moves_to_destination(10**9, 10**9, 1, 1) 10**9 >>> min_moves_to_destination(0, 0, 1, 1) 0","solution":"def min_moves_to_destination(x, y, a, b): Returns the minimum number of moves to reach destination (x, y) from (0, 0) using steps of (a, 0), (0, b), and (a, b). If reaching (x, y) is impossible, returns -1. # If it works only when x and y have the same differences of multiple a and b if x % a == 0 and y % b == 0: # Number of diagonal steps that can be taken diagonal_steps = min(x // a, y // b) x -= diagonal_steps * a y -= diagonal_steps * b # Now we need to check if we can do move by exactly a and b steps if x % a == 0 and y % b == 0: horizontal_steps = x // a vertical_steps = y // b return diagonal_steps + horizontal_steps + vertical_steps return -1"},{"question":"def find_missing_temperature(n: int, readings: List[int]) -> int: Given a list of n-1 unique integers representing temperature readings, find the missing temperature in the range from the smallest recorded temperature to the largest recorded temperature (inclusive). Args: n (int): The number of sensors (sections in the factory). readings (list): A list of n-1 unique integer temperature readings. Returns: int: The missing temperature reading. >>> find_missing_temperature(5, [1, 2, 4, 5]) 3 >>> find_missing_temperature(6, [10, 12, 15, 11, 14]) 13 >>> find_missing_temperature(3, [-1, 1]) 0 from solution import find_missing_temperature def test_example_1(): assert find_missing_temperature(5, [1, 2, 4, 5]) == 3 def test_example_2(): assert find_missing_temperature(6, [10, 12, 15, 11, 14]) == 13 def test_example_3(): assert find_missing_temperature(3, [-1, 1]) == 0 def test_consecutive_numbers(): assert find_missing_temperature(4, [1, 2, 4]) == 3 def test_single_missing_middle(): assert find_missing_temperature(5, [1, 3, 4, 5]) == 2 def test_with_negative_numbers(): assert find_missing_temperature(5, [-2, -1, 1, 2]) == 0 def test_large_gap(): assert find_missing_temperature(4, [100, 102, 103]) == 101 def test_minimal_case(): assert find_missing_temperature(2, [1]) == 0","solution":"def find_missing_temperature(n, readings): Given a list of n-1 unique integers representing temperature readings, find the missing temperature in the range from the smallest recorded temperature to the largest recorded temperature (inclusive). Args: n (int): The number of sensors (sections in the factory). readings (list): A list of n-1 unique integer temperature readings. Returns: int: The missing temperature reading. expected_sum = sum(range(min(readings), max(readings) + 1)) actual_sum = sum(readings) return expected_sum - actual_sum"},{"question":"def longest_alphabetic_subsequence(s: str) -> str: Given a string of text, find the longest subsequence where each character appears exactly once and the characters are in alphabetical order. :param s: The input string :return: The longest subsequence in alphabetical order where each character appears exactly once Examples: >>> longest_alphabetic_subsequence(\\"abracadabra\\") \\"abr\\" >>> longest_alphabetic_subsequence(\\"abcxyzacb\\") \\"abcxyz\\" >>> longest_alphabetic_subsequence(\\"zxvutsrqponmlkjihgfedcba\\") \\"z\\"","solution":"def longest_alphabetic_subsequence(s): Finds the longest subsequence in which each character appears exactly once and is in alphabetical order. result = [] last_char = '' for char in s: if char > last_char: result.append(char) last_char = char return ''.join(result)"},{"question":"def decode_message_count(n: int, message: str) -> int: Returns the number of unique strings that can be generated by decoding the message. >>> decode_message_count(1, \\"1\\") 1 >>> decode_message_count(1, \\"*\\") 9 >>> decode_message_count(3, \\"123\\") 1 >>> decode_message_count(3, \\"1*3\\") 9 >>> decode_message_count(4, \\"1**3\\") 81 >>> decode_message_count(5, \\"*1*3*\\") 729 >>> decode_message_count(1000, \\"1\\" * 1000) 1 >>> decode_message_count(5, \\"*****\\") 59049","solution":"def decode_message_count(n, message): Returns the number of unique strings that can be generated by decoding the message. # Each '*' can be replaced with any of 'A' to 'I' which is 9 possibilities count_wildcards = message.count('*') # Number of unique strings is 9^count_wildcards return 9 ** count_wildcards"},{"question":"def is_palindrome(num: int) -> bool: Check if a number is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(12321) True >>> is_palindrome(123) False def largest_palindromic_product(n: int) -> int: Find the largest palindromic number that can be obtained by multiplying two n-digit numbers. If no such number exists, return -1. >>> largest_palindromic_product(1) 9 >>> largest_palindromic_product(2) 9009 >>> largest_palindromic_product(3) 906609 >>> largest_palindromic_product(0) -1 >>> largest_palindromic_product(7) -1","solution":"def is_palindrome(num): return str(num) == str(num)[::-1] def largest_palindromic_product(n): if n < 1 or n > 6: return -1 max_num = 10**n - 1 min_num = 10**(n-1) max_palindrome = -1 for i in range(max_num, min_num - 1, -1): for j in range(i, min_num - 1, -1): product = i * j if product <= max_palindrome: break if is_palindrome(product): max_palindrome = product return max_palindrome"},{"question":"def month_with_highest_sightings(records: List[str]) -> int: Determines the month with the highest Jabberwocky sightings. Parameters: records (list of str): List of strings where each string is formatted as \\"Month Count\\". Returns: int: The month with the highest number of Jabberwocky sightings. >>> month_with_highest_sightings([\\"1 50\\", \\"2 80\\", \\"3 80\\"]) 2 >>> month_with_highest_sightings([\\"1 100\\", \\"2 200\\", \\"3 150\\", \\"4 50\\", \\"5 0\\"]) 2 >>> month_with_highest_sightings([\\"3 75\\", \\"6 150\\", \\"9 150\\", \\"12 50\\"]) 6","solution":"def month_with_highest_sightings(records): Determines the month with the highest Jabberwocky sightings. Parameters: records (list of str): List of strings where each string is formatted as \\"Month Count\\". Returns: int: The month with the highest number of Jabberwocky sightings. max_count = -1 max_month = -1 for record in records: month, count = map(int, record.split()) if count > max_count: max_count = count max_month = month return max_month"},{"question":"def max_rectangles_covering_point(n: int, rectangles: List[Tuple[int, int, int, int]], p1: int, p2: int) -> int: Determine the maximum number of rectangles that can cover a specific point (p1, p2) at the same time. Parameters: n (int): Number of rectangles. rectangles (list of tuples): List of rectangles where each is defined by (xi, yi, xi', yi'). p1, p2 (int): Coordinates of the specific point. Returns: int: The maximum number of rectangles covering the point (p1, p2) # Unit Tests def test_example1(): rectangles = [(1, 1, 4, 4), (2, 2, 5, 5), (3, 3, 6, 6)] p1, p2 = 3, 3 assert max_rectangles_covering_point(3, rectangles, p1, p2) == 3 def test_example2(): rectangles = [(1, 1, 3, 3), (2, 2, 4, 4)] p1, p2 = 0, 0 assert max_rectangles_covering_point(2, rectangles, p1, p2) == 0 def test_no_coverage(): rectangles = [(1, 1, 2, 2)] p1, p2 = 3, 3 assert max_rectangles_covering_point(1, rectangles, p1, p2) == 0 def test_all_covering(): rectangles = [(0, 0, 10, 10), (1, 1, 9, 9), (2, 2, 8, 8), (3, 3, 7, 7)] p1, p2 = 5, 5 assert max_rectangles_covering_point(4, rectangles, p1, p2) == 4 def test_partial_coverage(): rectangles = [(1, 1, 4, 4), (2, 2, 5, 5), (5, 5, 10, 10)] p1, p2 = 3, 3 assert max_rectangles_covering_point(3, rectangles, p1, p2) == 2 def test_point_on_edge(): rectangles = [(1, 1, 4, 4), (2, 2, 5, 5), (3, 3, 6, 6)] p1, p2 = 1, 1 assert max_rectangles_covering_point(3, rectangles, p1, p2) == 1","solution":"def max_rectangles_covering_point(n, rectangles, p1, p2): Determine the maximum number of rectangles that can cover a specific point (p1, p2) at the same time. Parameters: n (int): Number of rectangles. rectangles (list of tuples): List of rectangles where each is defined by (xi, yi, xi', yi'). p1, p2 (int): Coordinates of the specific point. Returns: int: The maximum number of rectangles covering the point (p1, p2) count = 0 for rect in rectangles: xi, yi, xi_prime, yi_prime = rect if xi <= p1 <= xi_prime and yi <= p2 <= yi_prime: count += 1 return count # Example usage: # n = 3 # rectangles = [(1, 1, 4, 4), (2, 2, 5, 5), (3, 3, 6, 6)] # p1, p2 = 3, 3 # print(max_rectangles_covering_point(n, rectangles, p1, p2)) # Output: 3"},{"question":"def prime_factors(n: int) -> List[int]: Returns a list of prime factors of the given number n. def convert_list_to_prime_factors(lst: List[int]) -> List[int]: Converts a list of non-negative integers to a list of their prime factors. >>> convert_list_to_prime_factors([10, 15, 23, 50]) [2, 5, 3, 5, 23, 2, 5, 5] >>> convert_list_to_prime_factors([4, 17, 8]) [2, 2, 17, 2, 2, 2]","solution":"def prime_factors(n): Returns a list of prime factors of the given number n. factors = [] # factor out 2s while n % 2 == 0: factors.append(2) n //= 2 # factor out all odd numbers for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: factors.append(i) n //= i # if n is still a prime number greater than 2 if n > 2: factors.append(n) return factors def convert_list_to_prime_factors(lst): Converts a list of non-negative integers to a list of their prime factors. result = [] for num in lst: if num == 0 or num == 1: result.append(num) else: result.extend(prime_factors(num)) return result # Example usage: n = 4 input_list = [10, 15, 23, 50] output_list = convert_list_to_prime_factors(input_list) print(output_list) # Output: [2, 5, 3, 5, 23, 2, 5, 5]"},{"question":"def find_words_in_grid(n: int, m: int, grid: List[str], k: int, words: List[str]) -> int: Find the number of distinct valid words from the dictionary that can be formed in the grid. Parameters: - n: Number of rows in the grid (int) - m: Number of columns in the grid (int) - grid: List of strings representing the grid (list of str) - k: Number of words in the dictionary (int) - words: List of words in the dictionary (list of str) Returns: - Number of distinct valid words from the dictionary that can be formed in the grid (int) >>> find_words_in_grid(3, 3, [\\"abc\\", \\"def\\", \\"ghi\\"], 5, [\\"abcf\\", \\"abc\\", \\"dehi\\", \\"aef\\", \\"ghi\\"]) 4 >>> find_words_in_grid(2, 4, [\\"abcd\\", \\"efgh\\"], 3, [\\"abcd\\", \\"aebc\\", \\"efgh\\"]) 2 def test_find_words_in_grid_case_1(): n = 3 m = 3 grid = [\\"abc\\", \\"def\\", \\"ghi\\"] k = 5 words = [\\"abcf\\", \\"abc\\", \\"dehi\\", \\"aef\\", \\"ghi\\"] assert find_words_in_grid(n, m, grid, k, words) == 4 def test_find_words_in_grid_case_2(): n = 2 m = 4 grid = [\\"abcd\\", \\"efgh\\"] k = 3 words = [\\"abcd\\", \\"aebc\\", \\"efgh\\"] assert find_words_in_grid(n, m, grid, k, words) == 2 def test_find_words_in_grid_no_valid_words(): n = 3 m = 3 grid = [\\"abc\\", \\"def\\", \\"ghi\\"] k = 2 words = [\\"xyz\\", \\"mnop\\"] assert find_words_in_grid(n, m, grid, k, words) == 0 def test_find_words_in_grid_all_words_valid(): n = 2 m = 3 grid = [\\"abc\\", \\"def\\"] k = 3 words = [\\"abc\\", \\"def\\", \\"ab\\"] assert find_words_in_grid(n, m, grid, k, words) == 3 def test_find_words_in_grid_duplicate_words_in_list(): n = 3 m = 3 grid = [\\"abc\\", \\"def\\", \\"ghi\\"] k = 5 words = [\\"abc\\", \\"abc\\", \\"ghi\\", \\"ghi\\", \\"def\\"] assert find_words_in_grid(n, m, grid, k, words) == 3","solution":"def find_words_in_grid(n, m, grid, k, words): Find the number of distinct valid words from the dictionary that can be formed in the grid. Parameters: - n: Number of rows in the grid (int) - m: Number of columns in the grid (int) - grid: List of strings representing the grid (list of str) - k: Number of words in the dictionary (int) - words: List of words in the dictionary (list of str) Returns: - Number of distinct valid words from the dictionary that can be formed in the grid (int) # Helper function for DFS search def dfs(x, y, word, index): if index == len(word): return True if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] != word[index] or visited[x][y]: return False visited[x][y] = True result = ( dfs(x + 1, y, word, index + 1) or # down dfs(x - 1, y, word, index + 1) or # up dfs(x, y + 1, word, index + 1) or # right dfs(x, y - 1, word, index + 1) # left ) visited[x][y] = False return result # Find each word in the grid found_words = set() for word in words: if word in found_words: continue found = False for i in range(n): for j in range(m): visited = [[False] * m for _ in range(n)] if dfs(i, j, word, 0): found = True break if found: found_words.add(word) break return len(found_words)"},{"question":"def can_divide_grid(n: int, m: int, grid: List[List[int]]) -> str: Determine if it's possible to divide the grid into two contiguous subgrids with equal total fertility score. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[List[int]]): The fertility scores of the cells in the grid. Returns: str: \\"YES\\" if it's possible to divide the grid into two contiguous subgrids with equal total fertility score, otherwise \\"NO\\". >>> can_divide_grid(3, 3, [[1, 3, 2], [5, 4, 2], [2, 1, 3]]) NO >>> can_divide_grid(2, 4, [[1, 1, 1, 1], [1, 1, 1, 1]]) YES","solution":"def can_divide_grid(n, m, grid): from collections import deque total_fertility = sum(sum(row) for row in grid) if total_fertility % 2 != 0: return \\"NO\\" target_fertility = total_fertility // 2 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def bfs(start, target_fertility): queue = deque([start]) visited = set([start]) current_sum = grid[start[0]][start[1]] while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) current_sum += grid[nx][ny] if current_sum == target_fertility: return True elif current_sum > target_fertility: return False return False for i in range(n): for j in range(m): if grid[i][j] <= target_fertility: if bfs((i, j), target_fertility): return \\"YES\\" return \\"NO\\""},{"question":"def reverse_in_groups(arr, k): Reverse an array in groups of size k. If k > length of the array, reverse the whole array. >>> reverse_in_groups([1, 2, 3, 4, 5], 2) [2, 1, 4, 3, 5] >>> reverse_in_groups([1, 2, 3, 4], 3) [3, 2, 1, 4] >>> reverse_in_groups([1, 2, 3, 4, 5, 6, 7], 8) [7, 6, 5, 4, 3, 2, 1] >>> reverse_in_groups([1], 1) [1] >>> reverse_in_groups([10, 20, 30, 40], 4) [40, 30, 20, 10] pass def process_test_cases(t, test_cases): Process multiple test cases to reverse arrays in groups of size k. >>> process_test_cases(3, [(5, [1, 2, 3, 4, 5], 2), (4, [1, 2, 3, 4], 3), (7, [1, 2, 3, 4, 5, 6, 7], 8)]) [[2, 1, 4, 3, 5], [3, 2, 1, 4], [7, 6, 5, 4, 3, 2, 1]] pass","solution":"def reverse_in_groups(arr, k): Reverse an array in groups of size k. If k > length of the array, reverse the whole array. n = len(arr) if k > n: return arr[::-1] for i in range(0, n, k): left = i right = min(i + k - 1, n - 1) while left < right: arr[left], arr[right] = arr[right], arr[left] left += 1 right -= 1 return arr def process_test_cases(t, test_cases): results = [] for case in test_cases: n, arr, k = case results.append(reverse_in_groups(arr, k)) return results"},{"question":"def find_first_max_memory_index(n: int, memory_usages: List[int]) -> int: Returns the 1-based index of the operation where the maximum memory usage first occurred. :param n: Int - the number of operations. :param memory_usages: List[Int] - the memory usages after each operation. :return: Int - 1-based index of the operation where the maximum memory usage first occurred. >>> find_first_max_memory_index(5, [10, 20, 30, 20, 30]) 3 >>> find_first_max_memory_index(7, [5, 4, 8, 3, 8, 9, 2]) 6 >>> find_first_max_memory_index(4, [12, 7, 12, 6]) 1 >>> find_first_max_memory_index(1, [0]) 1 >>> find_first_max_memory_index(3, [1, 2, 3]) 3 >>> find_first_max_memory_index(3, [3, 2, 1]) 1 >>> find_first_max_memory_index(6, [1, 1, 1, 2, 2, 2]) 4 >>> find_first_max_memory_index(6, [1, 3, 2, 1, 3, 2]) 2","solution":"def find_first_max_memory_index(n, memory_usages): Returns the 1-based index of the operation where the maximum memory usage first occurred. :param n: Int - the number of operations. :param memory_usages: List[Int] - the memory usages after each operation. :return: Int - 1-based index of the operation where the maximum memory usage first occurred. max_memory = -1 max_index = -1 for i in range(n): if memory_usages[i] > max_memory: max_memory = memory_usages[i] max_index = i return max_index + 1"},{"question":"def closest_product_pair(n: int, m: int, numbers: List[int]) -> Tuple[int, int]: Returns the pair of integers from the list whose product is closest to the given integer m. If multiple pairs exist with the same closest product, return the pair which appears first. >>> closest_product_pair(5, 15, [3, 2, 1, 6, 5]) (3, 5) >>> closest_product_pair(5, 18, [3, 2, 1, 6, 5]) (3, 6) >>> closest_product_pair(4, -8, [-2, 4, -4, 1]) (-2, 4) >>> closest_product_pair(6, 20, [4, 5, -5, -4, 1, 4]) (4, 5) >>> closest_product_pair(10, 50, [1, 1, 10, 5, 4, 3, 3, 2, 2, 5]) (10, 5) >>> closest_product_pair(3, 6, [2, 3, 1]) (2, 3)","solution":"def closest_product_pair(n, m, numbers): Returns the pair of integers from the list whose product is closest to the given integer m. If multiple pairs exist with the same closest product, return the pair which appears first. closest_pair = None closest_diff = float('inf') for i in range(n): for j in range(i + 1, n): product = numbers[i] * numbers[j] diff = abs(product - m) if diff < closest_diff: closest_diff = diff closest_pair = (numbers[i], numbers[j]) return closest_pair # Example usage: n = 5 m = 15 numbers = [3, 2, 1, 6, 5] result = closest_product_pair(n, m, numbers) print(result) # Output: (3, 5)"},{"question":"def longest_equal_subarray(arr): Given an array of integers, find the size of the longest continuous subarray such that each element in the subarray is equal. >>> longest_equal_subarray([1, 1, 2, 2, 2]) == 3 >>> longest_equal_subarray([3, 3, 3, 1, 1, 3]) == 3 >>> longest_equal_subarray([7]) == 1 >>> longest_equal_subarray([1, 1, 1, 1, 1]) == 5 >>> longest_equal_subarray([1, 2, 3, 4, 5, 6]) == 1 >>> longest_equal_subarray([2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4]) == 4 >>> longest_equal_subarray([]) == 0 >>> longest_equal_subarray([5, 5, 5, 6, 6, 6, 6, 7, 7]) == 4 >>> longest_equal_subarray([9, 9, 8, 8, 8, 9, 9, 9, 9]) == 4 >>> longest_equal_subarray([10]) == 1","solution":"def longest_equal_subarray(arr): Given an array of integers, find the size of the longest continuous subarray such that each element in the subarray is equal. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] == arr[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"from typing import List, Tuple def max_subarray_sum(n: int, array: List[int]) -> int: Returns the sum of the longest contiguous subarray within an array of integers that has the largest sum. >>> max_subarray_sum(5, [-2, 1, -3, 4, -1]) 4 >>> max_subarray_sum(4, [1, 2, 3, 4]) 10 def find_max_subarrays(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a list of test cases, where each test case contains an integer n, the number of elements in the array, followed by n integers representing the elements of the array, return a list of the sum of the longest contiguous subarray that has the largest sum for each test case. >>> find_max_subarrays([(5, [-2, 1, -3, 4, -1]), (4, [1, 2, 3, 4])]) [4, 10] def test_single_element_array(): assert max_subarray_sum(1, [5]) == 5 assert max_subarray_sum(1, [-5]) == -5 def test_multiple_elements(): assert max_subarray_sum(5, [-2, 1, -3, 4, -1]) == 4 assert max_subarray_sum(4, [1, 2, 3, 4]) == 10 def test_large_array(): assert max_subarray_sum(3, [-1, -2, -3]) == -1 assert max_subarray_sum(3, [1, -3, 2]) == 2 def test_find_max_subarrays(): test_cases = [ (5, [-2, 1, -3, 4, -1]), (4, [1, 2, 3, 4]) ] assert find_max_subarrays(test_cases) == [4, 10] test_cases = [ (3, [2, -1, 2]), (5, [-1, -2, -3, -4, -5]) ] assert find_max_subarrays(test_cases) == [3, -1] def test_mixed_positive_negative(): assert max_subarray_sum(6, [2, -3, 1, -1, 3, -1]) == 3 def test_all_positive(): assert max_subarray_sum(5, [1, 2, 3, 4, 5]) == 15 def test_all_negative(): assert max_subarray_sum(5, [-1, -2, -3, -4, -5]) == -1","solution":"def max_subarray_sum(n, array): Returns the sum of the longest contiguous subarray that has the largest sum. Uses Kadane's algorithm to find the maximum sum. max_current = max_global = array[0] for i in range(1, n): max_current = max(array[i], max_current + array[i]) if max_current > max_global: max_global = max_current return max_global def find_max_subarrays(test_cases): results = [] for n, array in test_cases: results.append(max_subarray_sum(n, array)) return results # Example usage (uncomment for testing): # t = 2 # test_cases = [ # (5, [-2, 1, -3, 4, -1]), # (4, [1, 2, 3, 4]) # ] # print(find_max_subarrays(test_cases)) # Outputs: [4, 10]"},{"question":"import re from typing import List def validate_urls(n: int, urls: List[str]) -> List[str]: Validates a list of URLs based on specified rules. Parameters: n (int): Number of URLs. urls (List[str]): List of URLs. Returns: List[str]: \\"VALID\\" or \\"INVALID\\" indicating the validity of each URL. results = [] pattern = re.compile(r\\"^(http|https)://([a-zA-Z0-9-]+(.[a-zA-Z0-9-]+)*.[a-zA-Z]{2,6})(/[^s]{0,128})?\\") for url in urls: if pattern.match(url): results.append(\\"VALID\\") else: results.append(\\"INVALID\\") return results # Unit Tests def test_valid_urls(): urls = [ \\"https://www.example.com\\", \\"http://valid-site.org/path/to/resource\\", \\"https://example.co\\", \\"http://example-definition.com\\" ] expected = [\\"VALID\\", \\"VALID\\", \\"VALID\\", \\"VALID\\"] assert validate_urls(4, urls) == expected def test_invalid_urls(): urls = [ \\"ftp://invalid-scheme.com\\", \\"http://Invalid_Authority\\", \\"https://in valid.com\\", \\"http:///missinghost.com\\", \\"http:site.com\\", \\"https://site.notvalidtoolongdomain\\" ] expected = [\\"INVALID\\", \\"INVALID\\", \\"INVALID\\", \\"INVALID\\", \\"INVALID\\", \\"INVALID\\"] assert validate_urls(6, urls) == expected def test_edge_case_urls(): urls = [ \\"http://a.b\\", \\"https://a.com\\", \\"http://test-test-test-test-test-test-test-test-test-test-test-test.org/path\\", \\"https://example-comp.net/a\\" * 64 ] expected = [\\"INVALID\\", \\"VALID\\", \\"VALID\\", \\"INVALID\\"] assert validate_urls(4, urls) == expected","solution":"import re def validate_urls(n, urls): Validates a list of URLs based on specified rules. Parameters: n (int): Number of URLs. urls (list of str): List of URLs. Returns: list of str: \\"VALID\\" or \\"INVALID\\" indicating the validity of each URL. results = [] pattern = re.compile(r\\"^(http|https)://([a-zA-Z0-9-]+(.[a-zA-Z0-9-]+)*.[a-zA-Z]{2,6})(/[^s]{0,128})?\\") for url in urls: if pattern.match(url): results.append(\\"VALID\\") else: results.append(\\"INVALID\\") return results"},{"question":"def can_knight_reach_in_n_moves(n: int, start: tuple, target: tuple) -> str: Determines if the knight can reach the target cell from the starting cell in exactly n moves. Parameters: n (int): Number of moves (0 <= n <= 20) start (tuple): Starting position of the knight (r1, c1) target (tuple): Target position of the knight (r2, c2) Returns: str: \\"YES\\" if the knight can reach the target in exactly n moves, else \\"NO\\" Examples: >>> can_knight_reach_in_n_moves(3, (4, 4), (6, 5)) \\"YES\\" >>> can_knight_reach_in_n_moves(1, (1, 1), (2, 3)) \\"YES\\" >>> can_knight_reach_in_n_moves(2, (3, 3), (7, 7)) \\"NO\\"","solution":"def can_knight_reach_in_n_moves(n, start, target): Determines if the knight can reach the target cell from the starting cell in exactly n moves. Parameters: n (int): Number of moves (0 <= n <= 20) start (tuple): Starting position of the knight (r1, c1) target (tuple): Target position of the knight (r2, c2) Returns: str: \\"YES\\" if the knight can reach the target in exactly n moves, else \\"NO\\" from collections import deque # Knight's possible movements moves = [(-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1)] r1, c1 = start r2, c2 = target queue = deque([(r1, c1, 0)]) # (current_row, current_col, current_move_count) visited = set([(r1, c1, 0)]) while queue: cr, cc, cm = queue.popleft() # If we have made exactly n moves if cm == n: if (cr, cc) == (r2, c2): return \\"YES\\" continue # Generate all possible moves next for dr, dc in moves: nr, nc = cr + dr, cc + dc if 1 <= nr <= 8 and 1 <= nc <= 8 and (nr, nc, cm + 1) not in visited: visited.add((nr, nc, cm + 1)) queue.append((nr, nc, cm + 1)) return \\"NO\\""},{"question":"def can_form_unique_word(string: str) -> str: Determine if a word with no repeating characters can be formed from the given string. Parameters: string (str): The input string consisting of only lowercase letters. Returns: str: \\"YES\\" if it's possible to form a word with no repeating characters, otherwise \\"NO\\". >>> can_form_unique_word(\\"apple\\") \\"NO\\" >>> can_form_unique_word(\\"orange\\") \\"YES\\" pass def determine_unique_words(test_cases: List[str]) -> List[str]: For each test case, determine if a word with no repeating characters can be formed. Parameters: test_cases (List[str]): A list of strings for each test case. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each test case. >>> determine_unique_words([\\"apple\\",\\"orange\\",\\"balloon\\"]) [\\"NO\\", \\"YES\\", \\"NO\\"] pass # Unit Tests def test_can_form_unique_word(): assert can_form_unique_word(\\"apple\\") == \\"NO\\" assert can_form_unique_word(\\"orange\\") == \\"YES\\" assert can_form_unique_word(\\"balloon\\") == \\"NO\\" assert can_form_unique_word(\\"abcdef\\") == \\"YES\\" assert can_form_unique_word(\\"aabbcc\\") == \\"NO\\" def test_determine_unique_words(): test_cases = [\\"apple\\", \\"orange\\", \\"balloon\\"] results = determine_unique_words(test_cases) expected = [\\"NO\\", \\"YES\\", \\"NO\\"] assert results == expected test_cases = [\\"abcdef\\", \\"aabbcc\\", \\"xyz\\", \\"abbcde\\", \\"mnop\\"] results = determine_unique_words(test_cases) expected = [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\", \\"YES\\"] assert results == expected","solution":"def can_form_unique_word(string): Determine if a word with no repeating characters can be formed from the given string. return \\"YES\\" if len(set(string)) == len(string) else \\"NO\\" def determine_unique_words(test_cases): For each test case, determine if a word with no repeating characters can be formed. return [can_form_unique_word(string) for string in test_cases]"},{"question":"def find_three_numbers_sum(arr: List[int], target: int) -> List[int]: Finds three distinct numbers in the array that sum up to the target sum. Returns these numbers as a list. If no such combination exists, returns an empty list. Args: arr : List[int] : the list of integers target : int : the target sum Returns: List[int] : a list containing three integers that sum up to the target, or an empty list if no such combination exists Examples: >>> find_three_numbers_sum([1, 2, 3, 4, 5, 6], 10) [1, 3, 6] >>> find_three_numbers_sum([1, 2, 3, 4, 5, 6], 20) [] >>> find_three_numbers_sum([-1, 2, 1, -4, 3, 0], 2) [-1, 1, 2] >>> find_three_numbers_sum([10**9, -10**9, 0, 2, -2, 3], 1) [-2, 0, 3] >>> find_three_numbers_sum([1, 1, 1, 1, 1, 1], 3) [1, 1, 1]","solution":"def find_three_numbers_sum(arr, target): Finds three distinct numbers in the array that sum up to the target sum. Returns these numbers as a list. If no such combination exists, returns an empty list. arr.sort() n = len(arr) for i in range(n - 2): # We use two pointers: one starting just after the current element, and one at the end of the array left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return [arr[i], arr[left], arr[right]] elif current_sum < target: left += 1 else: right -= 1 return []"},{"question":"def is_valid_schedule(n: int, surgeries: List[Tuple[int, int, int]]) -> str: Verifies whether a given schedule is valid. A schedule is valid if no two surgeries overlap in the same room. Arguments: n : int -- the number of surgeries surgeries : list of tuples -- each tuple contains (Si, Ei, Ri) representing the start time, end time, and room number Returns: str -- \\"Valid\\" if no conflicts, \\"Invalid\\" if there's at least one conflict. Examples: >>> is_valid_schedule(2, [(60, 120, 1), (130, 180, 1)]) 'Valid' >>> is_valid_schedule(3, [(30, 150, 1), (540, 600, 1), (145, 160, 1)]) 'Invalid'","solution":"def is_valid_schedule(n, surgeries): Verifies whether a given schedule is valid. A schedule is valid if no two surgeries overlap in the same room. Arguments: n : int -- the number of surgeries surgeries : list of tuples -- each tuple contains (Si, Ei, Ri) representing the start time, end time, and room number Returns: str -- \\"Valid\\" if no conflicts, \\"Invalid\\" if there's at least one conflict. from collections import defaultdict room_schedules = defaultdict(list) for surgery in surgeries: start, end, room = surgery room_schedules[room].append((start, end)) for room, times in room_schedules.items(): times.sort() end_time = -1 for start, end in times: if start < end_time: return \\"Invalid\\" end_time = end return \\"Valid\\""},{"question":"def is_happy_number(x: int) -> str: Determines if the square sum sequence starting from x eventually reaches 1. Args: x (int): The starting integer for the sequence. Returns: str: \\"Happy\\" if the sequence reaches 1, otherwise \\"Unhappy\\". def test_happy_path(): assert is_happy_number(19) == \\"Happy\\" assert is_happy_number(1) == \\"Happy\\" def test_unhappy_path(): assert is_happy_number(4) == \\"Unhappy\\" assert is_happy_number(2) == \\"Unhappy\\" def test_edge_cases(): assert is_happy_number(10) == \\"Happy\\" # 10 -> 1 -> Happy assert is_happy_number(7) == \\"Happy\\" # 7 -> 49 -> 97 -> 130 -> 10 -> 1 -> Happy def test_large_numbers(): assert is_happy_number(987654321) == \\"Unhappy\\" assert is_happy_number(1000000000) == \\"Happy\\"","solution":"def is_happy_number(x): Determines if the square sum sequence starting from x eventually reaches 1. Args: x (int): The starting integer for the sequence. Returns: str: \\"Happy\\" if the sequence reaches 1, otherwise \\"Unhappy\\". def get_next_number(n): return sum(int(digit) ** 2 for digit in str(n)) seen_numbers = set() while x != 1 and x not in seen_numbers: seen_numbers.add(x) x = get_next_number(x) return \\"Happy\\" if x == 1 else \\"Unhappy\\""},{"question":"def shift_letters(s: str) -> str: Convert the string into a new string where each character is replaced by the character that follows it in the alphabetical order. The last character 'z' should be replaced by 'a'. Parameters: s (str): The input string consisting of lowercase English letters. Returns: str: The converted string. Examples: >>> shift_letters(\\"abcxyz\\") \\"bcdyza\\" >>> shift_letters(\\"a\\") \\"b\\" >>> shift_letters(\\"z\\") \\"a\\" >>> shift_letters(\\"zzzz\\") \\"aaaa\\" >>> shift_letters(\\"helloz\\") \\"ifmmpa\\" >>> shift_letters(\\"abcdefghijklmnopqrstuvwxyz\\") \\"bcdefghijklmnopqrstuvwxyza\\" from solution import shift_letters def test_shift_letters_normal_case(): assert shift_letters(\\"abcxyz\\") == \\"bcdyza\\" def test_shift_letters_single_char(): assert shift_letters(\\"a\\") == \\"b\\" assert shift_letters(\\"z\\") == \\"a\\" def test_shift_letters_all_z(): assert shift_letters(\\"zzzz\\") == \\"aaaa\\" def test_shift_letters_mixed_case(): assert shift_letters(\\"helloz\\") == \\"ifmmpa\\" def test_shift_letters_entire_alphabet(): assert shift_letters(\\"abcdefghijklmnopqrstuvwxyz\\") == \\"bcdefghijklmnopqrstuvwxyza\\"","solution":"def shift_letters(s): Returns a new string where each character is replaced by the character that follows it in the alphabetical order. The last character 'z' is replaced by 'a'. return ''.join(chr(((ord(char) - ord('a') + 1) % 26) + ord('a')) for char in s)"},{"question":"def max_sum_of_chips(chips: List[Tuple[int, str, str]]) -> int: Returns the maximum sum of values by choosing one chip of each color. Args: chips (List[Tuple[int, str, str]]): List of tuples where each tuple contains the value, color, and unique identifier of a chip. Returns: int: Maximum sum of values by choosing one chip of each color. Examples: >>> max_sum_of_chips([(10, 'red', 'a1'), (20, 'blue', 'b2'), (30, 'blue', 'b3'), (25, 'red', 'a2'), (15, 'green', 'c1'), (40, 'green', 'c2')]) 95 >>> max_sum_of_chips([(5, 'orange', 'd3'), (15, 'yellow', 'e5'), (12, 'orange', 'd4'), (7, 'yellow', 'e6'), (20, 'purple', 'f1')]) 47 >>> max_sum_of_chips([(10, 'red', 'a1')]) 10 >>> max_sum_of_chips([(10, 'red', 'a1'), (20, 'red', 'a2')]) 20 >>> max_sum_of_chips([(10, 'red', 'a1'), (20, 'blue', 'b1'), (15, 'green', 'c1')]) 45 # Your code here.","solution":"def max_sum_of_chips(chips): Returns the maximum sum of values by choosing one chip of each color. color_max_values = {} for chip in chips: value, color, _ = chip if color in color_max_values: color_max_values[color] = max(color_max_values[color], value) else: color_max_values[color] = value return sum(color_max_values.values()) # Sample usage n = 6 chips_description = [ (10, 'red', 'a1'), (20, 'blue', 'b2'), (30, 'blue', 'b3'), (25, 'red', 'a2'), (15, 'green', 'c1'), (40, 'green', 'c2') ] result = max_sum_of_chips(chips_description) print(result) # Expected output: 95"},{"question":"def can_schedule_presentations(test_cases: List[Tuple[int, int, List[int], List[int]]]) -> List[str]: Determine if it is possible to schedule all presentations within the time slots without exceeding the duration limits. Each test case contains the number of presentations, number of time slots, list of presentation durations, and list of time slot limits. Returns a list of \\"YES\\" or \\"NO\\" for each test case. pass def input_parser(input_lines: List[str]) -> List[Tuple[int, int, List[int], List[int]]]: Parses the input lines into a suitable structure for the function. pass def process_input_output(input_str: str) -> str: Takes input in string format and returns output in string format. pass # example unit test def test_can_schedule_presentations(): input_str = '3n3 3n2 3 5n6 5 4n4 2n3 1 2 4n5 3n5 5n4 4 4 4 4n5 5 5 5 1n' expected_output = 'YESnNOnNO' assert process_input_output(input_str) == expected_output def test_single_case_yes(): input_str = '1n1 2n3n5 4n' expected_output = 'YES' assert process_input_output(input_str) == expected_output def test_single_case_no(): input_str = '1n2 1n5 6n4n' expected_output = 'NO' assert process_input_output(input_str) == expected_output def test_impossible_case(): input_str = '1n3 2n7 8 9n5 6n' expected_output = 'NO' assert process_input_output(input_str) == expected_output def test_possible_exact_case(): input_str = '1n3 3n5 4 3n3 4 5n' expected_output = 'YES' assert process_input_output(input_str) == expected_output import pytest if __name__ == \\"__main__\\": pytest.main()","solution":"def can_schedule_presentations(test_cases): results = [] for case in test_cases: n, m, durations, limits = case if n > m: results.append(\\"NO\\") continue durations.sort() limits.sort() possible = True for duration, limit in zip(durations, limits): if duration > limit: possible = False break results.append(\\"YES\\" if possible else \\"NO\\") return results # Parsing the input format into a suitable structure for the function def input_parser(input_lines): idx = 0 t = int(input_lines[idx].strip()) idx += 1 test_cases = [] for _ in range(t): n, m = map(int, input_lines[idx].strip().split()) idx += 1 durations = list(map(int, input_lines[idx].strip().split())) idx += 1 limits = list(map(int, input_lines[idx].strip().split())) idx += 1 test_cases.append((n, m, durations, limits)) return test_cases # Function to take input in string format and return output in string format def process_input_output(input_str): input_lines = input_str.strip().split('n') test_cases = input_parser(input_lines) results = can_schedule_presentations(test_cases) return 'n'.join(results)"},{"question":"from typing import List, Tuple def solve(n: int, values: List[int], edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: You are given a tree with \`n\` nodes numbered from 1 to \`n\`. Each node has a value. You have to answer \`q\` queries. Each query consists of two integers, \`u\` and \`v\` and asks for the maximum value of the nodes in the path from \`u\` to \`v\`. :param n: Number of nodes :param values: List of values of the nodes :param edges: List of edges where each edge is represented by a tuple of two integers :param queries: List of queries where each query is a tuple of two integers :return: List of answers for each query where the answer is the maximum value of the nodes in the path from \`u\` to \`v\` Example: >>> solve(5, [1, 5, 2, 4, 3], [(1, 2), (1, 3), (3, 4), (3, 5)], [(2, 3), (4, 1), (4, 5)]) [5, 4, 4] >>> solve(2, [1, 2], [(1, 2)], [(1, 2)]) [2] pass","solution":"from collections import defaultdict, deque import sys sys.setrecursionlimit(200000) def preprocess_tree(n, values, edges): LOG = 17 adj = defaultdict(list) for a, b in edges: adj[a].append(b) adj[b].append(a) up = [[-1] * (LOG + 1) for _ in range(n + 1)] max_on_path = [[-1] * (LOG + 1) for _ in range(n + 1)] depth = [-1] * (n + 1) def dfs(v, parent): depth[v] = depth[parent] + 1 if parent != -1 else 0 up[v][0] = parent max_on_path[v][0] = values[v-1] for i in range(1, LOG + 1): if up[v][i-1] != -1: up[v][i] = up[up[v][i-1]][i-1] max_on_path[v][i] = max(max_on_path[v][i-1], max_on_path[up[v][i-1]][i-1]) for u in adj[v]: if u != parent: dfs(u, v) root = 1 dfs(root, -1) def lca(u, v): if depth[u] < depth[v]: u, v = v, u max_value = -1 diff = depth[u] - depth[v] for i in range(LOG + 1): if (diff >> i) & 1: max_value = max(max_value, max_on_path[u][i]) u = up[u][i] if u == v: return max(max_value, values[u-1]) for i in range(LOG, -1, -1): if up[u][i] != up[v][i]: max_value = max(max_value, max_on_path[u][i], max_on_path[v][i]) u = up[u][i] v = up[v][i] return max(max_value, max_on_path[u][0], max_on_path[v][0], values[up[u][0]-1]) return lca def solve(n, values, edges, queries): lca = preprocess_tree(n, values, edges) results = [] for u, v in queries: results.append(lca(u, v)) return results"},{"question":"from typing import List def max_non_adjacent_sum(nums: List[int]) -> int: Find the maximum sum of non-adjacent numbers in the list. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([3, 2, 7, 10]) 13","solution":"def max_non_adjacent_sum(nums): Returns the maximum sum of non-adjacent numbers in the list. if not nums: return 0 n = len(nums) if n == 1: return nums[0] # Initialize an array to store the maximum sum up to each index dp = [0] * n # Base cases dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) # Fill the dp array for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[n-1] # Example usage if __name__ == \\"__main__\\": import sys input_line = sys.stdin.read().strip() nums = list(map(int, input_line.split())) print(max_non_adjacent_sum(nums))"},{"question":"def generate_jewel_pairs(test_cases: List[Tuple[int, List[int]]]) -> List[List[Tuple[int, int]]]: Given a list of test cases, each containing an integer N and a list of N jewel indexes, generate all unique pairs of jewels for each test case. Parameters: - test_cases: List of tuples, where each tuple contains an integer N and a list of N integers representing jewel indexes. Returns: - List of lists containing tuples of unique pairs of jewels. Example: >>> generate_jewel_pairs([(4, [8, 3, 1, 2])]) [[(1, 2), (1, 3), (1, 8), (2, 3), (2, 8), (3, 8)]] pass def parse_input(input_string: str) -> Tuple[int, List[Tuple[int, List[int]]]]: Parse the input string to extract the number of test cases and the respective jewel indexes for each test case. Parameters: - input_string: A single string containing the number of test cases (T), followed by T times a number N and a list of N jewel indexes. Returns: - A tuple containing an integer (T) and a list of tuples where each tuple contains an integer (N) and a list of N integers. Example: >>> parse_input(\\"2n4n8 3 1 2n3n9 7 5n\\") (2, [(4, [8, 3, 1, 2]), (3, [9, 7, 5])]) pass def format_output(pairs_list: List[List[Tuple[int, int]]]) -> str: Format the list of pairs into a string for output. Parameters: - pairs_list: List of lists containing tuples of unique pairs of jewels. Returns: - A formatted string where each pair is on a new line in the format \\"(a, b)\\". Example: >>> format_output([[(1, 2), (1, 3), (1, 8), (2, 3), (2, 8), (3, 8)]]) \\"(1, 2)n(1, 3)n(1, 8)n(2, 3)n(2, 8)n(3, 8)\\" pass def process_jewel_pairs(input_string: str) -> str: Process the input string to generate all unique pairs of jewels and format the output. Parameters: - input_string: A single string containing the number of test cases (T), followed by T times a number N and a list of N jewel indexes. Returns: - A formatted string where each pair of jewels is on a new line in the format \\"(a, b)\\". Example: >>> process_jewel_pairs(\\"2n4n8 3 1 2n3n9 7 5n\\") \\"(1, 2)n(1, 3)n(1, 8)n(2, 3)n(2, 8)n(3, 8)n(5, 7)n(5, 9)n(7, 9)\\" pass def test_generate_jewel_pairs_single_test(): test_cases = [(4, [8, 3, 1, 2])] expected_output = [ [(1, 2), (1, 3), (1, 8), (2, 3), (2, 8), (3, 8)] ] assert generate_jewel_pairs(test_cases) == expected_output def test_generate_jewel_pairs_multiple_tests(): test_cases = [ (4, [8, 3, 1, 2]), (3, [9, 7, 5]) ] expected_output = [ [(1, 2), (1, 3), (1, 8), (2, 3), (2, 8), (3, 8)], [(5, 7), (5, 9), (7, 9)] ] assert generate_jewel_pairs(test_cases) == expected_output def test_parse_input(): input_string = \\"2n4n8 3 1 2n3n9 7 5n\\" expected_output = ( 2, [ (4, [8, 3, 1, 2]), (3, [9, 7, 5]) ] ) assert parse_input(input_string) == expected_output def test_format_output(): pairs_list = [ [(1, 2), (1, 3), (1, 8), (2, 3), (2, 8), (3, 8)], [(5, 7), (5, 9), (7, 9)] ] expected_output = \\"(1, 2)n(1, 3)n(1, 8)n(2, 3)n(2, 8)n(3, 8)n(5, 7)n(5, 9)n(7, 9)\\" assert format_output(pairs_list) == expected_output def test_process_jewel_pairs(): input_string = \\"2n4n8 3 1 2n3n9 7 5n\\" expected_output = \\"(1, 2)n(1, 3)n(1, 8)n(2, 3)n(2, 8)n(3, 8)n(5, 7)n(5, 9)n(7, 9)\\" assert process_jewel_pairs(input_string) == expected_output","solution":"def generate_jewel_pairs(test_cases): result = [] for case in test_cases: N, jewels = case pairs = [] jewels.sort() for i in range(N): for j in range(i + 1, N): pairs.append((jewels[i], jewels[j])) result.append(pairs) return result def parse_input(input_string): input_lines = input_string.strip().split('n') T = int(input_lines[0]) test_cases = [] idx = 1 for _ in range(T): N = int(input_lines[idx]) jewels = list(map(int, input_lines[idx + 1].split())) test_cases.append((N, jewels)) idx += 2 return T, test_cases def format_output(pairs_list): output = [] for pairs in pairs_list: for pair in pairs: output.append(f\\"({pair[0]}, {pair[1]})\\") return 'n'.join(output) def process_jewel_pairs(input_string): T, test_cases = parse_input(input_string) pairs_list = generate_jewel_pairs(test_cases) return format_output(pairs_list)"},{"question":"def can_accommodate(n, table_sizes, m, reservations): Determine if all reservations can be accommodated by assigning each reservation to a suitable table. Each table can be used only once. Args: n (int): The number of available tables. table_sizes (List[int]): A list of integers representing the number of seats at each table. m (int): The number of reservations. reservations (List[int]): A list of integers representing the number of people for each reservation. Returns: bool: True if all reservations can be accommodated, otherwise False. Examples: >>> can_accommodate(5, [2, 4, 4, 6, 8], 5, [2, 4, 6, 8, 2]) True >>> can_accommodate(3, [2, 4, 6], 4, [2, 2, 3, 6]) False","solution":"def can_accommodate(n, table_sizes, m, reservations): table_sizes.sort() reservations.sort() i, j = 0, 0 while i < n and j < m: if table_sizes[i] >= reservations[j]: j += 1 # move to the next reservation i += 1 # move to the next table return j == m"},{"question":"from typing import List def bst_inorder_traversal(arr: List[int]) -> List[int]: Given a sequence of integers, arrange them into a binary search tree and return the in-order traversal sequence. >>> bst_inorder_traversal([10, 5, 1, 7, 40, 50]) [1, 5, 7, 10, 40, 50] >>> bst_inorder_traversal([3, 1, 4, 2]) [1, 2, 3, 4] >>> bst_inorder_traversal([1]) [1] >>> bst_inorder_traversal([2, 1, 3]) [1, 2, 3] >>> bst_inorder_traversal([5, 3, 7, 2, 4, 6, 8]) [2, 3, 4, 5, 6, 7, 8] >>> bst_inorder_traversal([3, 9, 20, 15, 7]) [3, 7, 9, 15, 20]","solution":"from typing import List class TreeNode: def __init__(self, value): self.left = None self.right = None self.value = value class BinarySearchTree: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert_recursive(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert_recursive(node.right, value) def inorder_traversal(self): result = [] self._inorder_recursive(self.root, result) return result def _inorder_recursive(self, node, result): if node is not None: self._inorder_recursive(node.left, result) result.append(node.value) self._inorder_recursive(node.right, result) def bst_inorder_traversal(arr: List[int]) -> List[int]: bst = BinarySearchTree() for value in arr: bst.insert(value) return bst.inorder_traversal()"},{"question":"def balance_packages(n: int, weights: List[int]) -> Tuple[List[int], List[int]]: Balance packages between two new conveyor belts such that the absolute difference in the total weights of the packages on each belt is minimized. :param n: Integer, the number of packages. :param weights: List of integers, the weights of the packages. :returns: Two lists of integers, the weights of the packages assigned to the first and second conveyor belts. >>> balance_packages(6, [10, 20, 30, 40, 50, 60]) ([10, 40, 60], [20, 30, 50]) >>> balance_packages(4, [1, 2, 3, 4]) ([1, 4], [2, 3]) from solution import balance_packages def test_even_number_of_packages(): weights = [10, 20, 30, 40, 50, 60] belt1, belt2 = balance_packages(6, weights) assert sum(belt1) == 110 and sum(belt2) == 100 def test_odd_number_of_packages(): weights = [10, 20, 30, 35, 40, 50, 60] belt1, belt2 = balance_packages(7, weights) assert abs(sum(belt1) - sum(belt2)) <= 25 def test_four_packages(): weights = [1, 2, 3, 4] belt1, belt2 = balance_packages(4, weights) assert set(belt1) == {1, 4} and set(belt2) == {2, 3} def test_single_package(): weights = [100] belt1, belt2 = balance_packages(1, weights) assert set(belt1) == {100} and set(belt2) == set() def test_two_packages(): weights = [100, 200] belt1, belt2 = balance_packages(2, weights) assert (set(belt1) == {200} and set(belt2) == {100}) or (set(belt1) == {100} and set(belt2) == {200})","solution":"def balance_packages(n, weights): weights.sort(reverse=True) belt1, belt2 = [], [] sum1, sum2 = 0, 0 for weight in weights: if sum1 <= sum2: belt1.append(weight) sum1 += weight else: belt2.append(weight) sum2 += weight return belt1, belt2"},{"question":"def is_palindrome(s: str) -> str: Returns 'YES' if the string s is a palindrome, 'NO' otherwise. >>> is_palindrome(\\"level\\") 'YES' >>> is_palindrome(\\"deed\\") 'YES' >>> is_palindrome(\\"Palindrome\\") 'NO' >>> is_palindrome(\\"12321\\") 'YES' >>> is_palindrome(\\"A man a plan a canal Panama\\") 'YES' >>> is_palindrome(\\"No lemon, no melon\\") 'YES' >>> is_palindrome(\\"\\") 'YES' >>> is_palindrome(\\"a\\") 'YES' pass def check_palindromes(t: int, strings: List[str]) -> List[str]: Checks a list of strings to determine if each one is a palindrome. Args: t: int, number of test cases. strings: list of str, each string to be checked. Returns: list of str: 'YES' or 'NO' for each string in the input list. >>> check_palindromes(4, [\\"level\\", \\"deed\\", \\"Palindrome\\", \\"12321\\"]) ['YES', 'YES', 'NO', 'YES'] >>> check_palindromes(3, [\\"A man a plan a canal Panama\\", \\"No lemon, no melon\\", \\"\\"]) ['YES', 'YES', 'YES'] pass","solution":"def is_palindrome(s): Returns 'YES' if the string s is a palindrome, 'NO' otherwise. # Normalize the string by removing non-alphanumeric characters and converting to lowercase s_filtered = ''.join(char.lower() for char in s if char.isalnum()) return 'YES' if s_filtered == s_filtered[::-1] else 'NO' def check_palindromes(t, strings): Checks a list of strings to determine if each one is a palindrome. Args: t: int, number of test cases. strings: list of str, each string to be checked. Returns: list of str: 'YES' or 'NO' for each string in the input list. results = [] for string in strings: results.append(is_palindrome(string)) return results"},{"question":"def min_operations_to_group_cows(n: int, cows: str) -> int: Returns the minimum number of operations required to group all cows of the same breed together. >>> min_operations_to_group_cows(6, \\"AABACA\\") 2 >>> min_operations_to_group_cows(5, \\"BBBAA\\") 1 >>> min_operations_to_group_cows(1, \\"A\\") 0 >>> min_operations_to_group_cows(4, \\"AAAA\\") 0 >>> min_operations_to_group_cows(3, \\"BBB\\") 0 >>> min_operations_to_group_cows(5, \\"AABBB\\") 1 >>> min_operations_to_group_cows(4, \\"ABAB\\") 1 pass","solution":"def min_operations_to_group_cows(n, cows): Returns the minimum number of operations required to group all cows of the same breed together. Parameters: n (int): Number of cows cows (str): String representing the breeds of cows Returns: int: Minimum number of operations if n <= 1: return 0 count_breed = {} for breed in cows: if breed in count_breed: count_breed[breed] += 1 else: count_breed[breed] = 1 max_breed_count = max(count_breed.values()) return len(count_breed) - 1"},{"question":"import heapq from typing import List, Union class MedianFinder: def __init__(self): self.low = [] # max_heap self.high = [] # min_heap def add_num(self, num: int) -> None: Adds a number to the data structure Args: num: integer to be added to the stream # implementation details def find_median(self) -> Union[int, float]: Finds the median of the current numbers Returns: The median of the stream as an integer or float # implementation details def find_medians(stream: List[int]) -> List[Union[int, float]]: Finds the medians of the stream at each insertion Args: stream: List of integers representing the stream Returns: List of medians after each insertion >>> find_medians([5, 15, 1, 3, 8, 7]) [5, 10, 5, 4, 5, 6] >>> find_medians([2, 4, 6, 8]) [2, 3, 4, 5] # implementation details # Test cases def test_case_1(): stream = [5, 15, 1, 3, 8, 7] expected_output = [5, 10, 5, 4, 5, 6] assert find_medians(stream) == expected_output def test_case_2(): stream = [2, 4, 6, 8] expected_output = [2, 3, 4, 5] assert find_medians(stream) == expected_output def test_case_3(): stream = [1] expected_output = [1] assert find_medians(stream) == expected_output def test_case_4(): stream = [-1, -2, -3, -4, -5, -6] expected_output = [-1, -1.5, -2, -2.5, -3, -3.5] assert find_medians(stream) == expected_output def test_case_5(): stream = [5, 5, 5, 5, 5] expected_output = [5, 5, 5, 5, 5] assert find_medians(stream) == expected_output","solution":"import heapq class MedianFinder: def __init__(self): self.low = [] # max_heap self.high = [] # min_heap def add_num(self, num): heapq.heappush(self.low, -num) # Ensure every element in low is less than or equal to every element in high if self.low and self.high and (-self.low[0] > self.high[0]): value_to_move = -heapq.heappop(self.low) heapq.heappush(self.high, value_to_move) if len(self.low) > len(self.high) + 1: value_to_move = -heapq.heappop(self.low) heapq.heappush(self.high, value_to_move) if len(self.high) > len(self.low): value_to_move = heapq.heappop(self.high) heapq.heappush(self.low, -value_to_move) def find_median(self): if len(self.low) > len(self.high): return -self.low[0] return (-self.low[0] + self.high[0]) / 2.0 def find_medians(stream): median_finder = MedianFinder() medians = [] for num in stream: median_finder.add_num(num) medians.append(median_finder.find_median()) return medians"},{"question":"def can_make_divisible(N: int, X: int, A: List[int]) -> str: Determines if all elements of the sequence can be made divisible by X using the described operations. :param N: Number of elements in the sequence. :param X: The integer by which we want each element to be divisible. :param A: The list of integers in the sequence. :return: \\"Yes\\" if we can make each element divisible by X, otherwise \\"No\\". >>> can_make_divisible(3, 5, [5, 10, 15]) \\"Yes\\" >>> can_make_divisible(3, 2, [1, 2, 3]) \\"No\\" >>> can_make_divisible(4, 3, [1, 2, 3, 8]) \\"No\\" >>> can_make_divisible(4, 1, [0, 0, 0, 0]) \\"Yes\\" >>> can_make_divisible(1, 5, [5]) \\"Yes\\" >>> can_make_divisible(1, 5, [4]) \\"No\\" >>> can_make_divisible(3, 1000000000, [1000000000, 2000000000, 3000000000]) \\"Yes\\"","solution":"def can_make_divisible(N, X, A): Determines if all elements of the sequence can be made divisible by X using the described operations. :param N: Number of elements in the sequence. :param X: The integer by which we want each element to be divisible. :param A: The list of integers in the sequence. :return: \\"Yes\\" if we can make each element divisible by X, otherwise \\"No\\". for num in A: if num % X != 0: return \\"No\\" return \\"Yes\\""},{"question":"from collections import deque from typing import List, Tuple def minimum_max_distance(n: int, roads: List[Tuple[int, int]]) -> int: Return the minimum possible maximum distance from an optimally placed headquarters. n : int : number of villages roads : List[Tuple[int, int]] : list of roads connecting the villages >>> minimum_max_distance(4, [(1, 2), (2, 3), (3, 4)]) 2 >>> minimum_max_distance(6, [(1, 2), (1, 3), (3, 4), (3, 5), (4, 6)]) 2 pass def test_case_1(): n = 4 roads = [(1, 2), (2, 3), (3, 4)] assert minimum_max_distance(n, roads) == 2 def test_case_2(): n = 6 roads = [(1, 2), (1, 3), (3, 4), (3, 5), (4, 6)] assert minimum_max_distance(n, roads) == 2 def test_case_3(): n = 3 roads = [(1, 2), (1, 3)] assert minimum_max_distance(n, roads) == 1 def test_case_4(): n = 2 roads = [(1, 2)] assert minimum_max_distance(n, roads) == 1 def test_case_5(): n = 7 roads = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)] assert minimum_max_distance(n, roads) == 3","solution":"from collections import deque def find_furthest_node(n, graph, start): Perform BFS to find the furthest node from the start node. Returns the node and its distance from the start. visited = [False] * (n + 1) queue = deque([(start, 0)]) # (current_node, current_distance) visited[start] = True furthest_node = start max_distance = 0 while queue: node, distance = queue.popleft() if distance > max_distance: max_distance = distance furthest_node = node for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append((neighbor, distance + 1)) return furthest_node, max_distance def minimum_max_distance(n, roads): Returns the minimum possible maximum distance from an optimally placed headquarters. # Build the graph using adjacency list graph = [[] for _ in range(n + 1)] for u, v in roads: graph[u].append(v) graph[v].append(u) # Perform BFS from an arbitrary node to find one endpoint of the longest path arbitrary_start = 1 furthest_from_start, _ = find_furthest_node(n, graph, arbitrary_start) # Perform BFS from the furthest node found to find the actual longest path in the tree furthest_from_furthest, max_distance = find_furthest_node(n, graph, furthest_from_start) # The minimum possible maximum distance from an optimally placed headquarters # is half of the longest path (rounded up) return (max_distance + 1) // 2"},{"question":"from typing import List def maximizeDifference(heights: List[int]) -> int: Returns the maximum difference between the heights of any two consecutive towers in the rearranged sequence. >>> maximizeDifference([1, 5, 9, 16]) 15 >>> maximizeDifference([4, 2, 7, 1]) 6 >>> maximizeDifference([100, 80, 90, 110]) 30","solution":"from typing import List def maximizeDifference(heights: List[int]) -> int: Returns the maximum difference between the heights of any two consecutive towers in the rearranged sequence. # Sort the heights in ascending order heights.sort() # Create a new sequence starting with the smallest element and then the largest remaining element new_order = [] left, right = 0, len(heights) - 1 while left <= right: if left == right: new_order.append(heights[left]) else: new_order.append(heights[left]) new_order.append(heights[right]) left += 1 right -= 1 # Compute the maximum difference between any two consecutive elements in the new sequence max_diff = 0 for i in range(1, len(new_order)): max_diff = max(max_diff, abs(new_order[i] - new_order[i - 1])) return max_diff"},{"question":"def process_strings(strings): Returns a list where each input string results in 'crossierostum non recte'. Example: >>> process_strings([\\"hello\\", \\"world\\"]) [\\"crossierostum non recte\\", \\"crossierostum non recte\\"] >>> process_strings([\\"algorithm\\"]) [\\"crossierostum non recte\\"] >> process_strings([]) []","solution":"def process_strings(strings): Returns 'crossierostum non recte' for each input string. return [\\"crossierostum non recte\\" for _ in strings]"},{"question":"import math from typing import List, Tuple def euclidean_distance(x1: int, y1: int, x2: int, y2: int) -> str: Returns the Euclidean distance between two points (x1, y1) and (x2, y2) rounded to two decimal places. If the points are the same, return \\"Same Point\\". >>> euclidean_distance(1, 2, 4, 6) == \\"5.00\\" >>> euclidean_distance(-2, 3, -2, 3) == \\"Same Point\\" >>> euclidean_distance(0, 0, 3, 4) == \\"5.00\\" >>> euclidean_distance(1, 1, 1, 1) == \\"Same Point\\" >>> euclidean_distance(2, -3, 6, -7) == \\"5.66\\" pass def process_input(t: int, coordinates: List[Tuple[int, int, int, int]]) -> List[str]: Processes a list of coordinate pairs and returns a list of distances or \\"Same Point\\" strings for each pair. >>> process_input(3, [(1, 2, 4, 6), (-2, 3, -2, 3), (0, 0, 3, 4)]) == [\\"5.00\\", \\"Same Point\\", \\"5.00\\"] >>> process_input(2, [(1, 1, 1, 1), (2, -3, 6, -7)]) == [\\"Same Point\\", \\"5.66\\"] pass","solution":"import math def euclidean_distance(x1, y1, x2, y2): Returns the Euclidean distance between two points (x1, y1) and (x2, y2) rounded to two decimal places. If the points are the same, return \\"Same Point\\". if x1 == x2 and y1 == y2: return \\"Same Point\\" distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2) return f\\"{distance:.2f}\\" def process_input(t, coordinates): Processes a list of coordinate pairs and returns a list of distances or \\"Same Point\\" strings for each pair. results = [] for i in range(t): x1, y1, x2, y2 = coordinates[i] results.append(euclidean_distance(x1, y1, x2, y2)) return results"},{"question":"def has_pair_with_sum(arr, k): Determines if there are two distinct indices i and j in the array such that the sum of the elements at those indices equals k. Parameters: arr (list): List of integers. k (int): Target sum. Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". >>> has_pair_with_sum([1, 2, 3, 4], 7) \\"YES\\" >>> has_pair_with_sum([2, 5, 1], 5) \\"NO\\" def process_test_cases(test_cases): Processes multiple test cases to determine if each has a pair with sum k. Parameters: test_cases (list): List of tuples where each tuple contains the number of elements in the array (n), the target sum (k), and the array (arr). Returns: list: List of results for each test case, either \\"YES\\" or \\"NO\\". >>> process_test_cases([(4, 7, [1, 2, 3, 4]), (3, 5, [2, 5, 1])]) [\\"YES\\", \\"NO\\"]","solution":"def has_pair_with_sum(arr, k): Determines if there are two distinct indices i and j in the array such that the sum of the elements at those indices equals k. Parameters: arr (list): List of integers. k (int): Target sum. Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". seen = set() for number in arr: if k - number in seen: return \\"YES\\" seen.add(number) return \\"NO\\" def process_test_cases(test_cases): Processes multiple test cases to determine if each has a pair with sum k. Parameters: test_cases (list): List of tuples where each tuple contains the number of elements in the array (n), the target sum (k), and the array (arr). Returns: list: List of results for each test case, either \\"YES\\" or \\"NO\\". results = [] for n, k, arr in test_cases: results.append(has_pair_with_sum(arr, k)) return results"},{"question":"from collections import deque from typing import List def shortest_path(N: int, M: int, grid: List[str]) -> int: In a distant kingdom, there is a popular game among its citizens. The game is played on a rectangular grid of size N x M. Some of the cells in the grid are blocked and cannot be accessed. The player's objective is to find the shortest path from the top-left corner (0, 0) to the bottom-right corner (N-1, M-1). Each step in the game can be made to one of the four neighboring cells (left, right, up, down). Given the grid configuration, determine the minimum number of steps required to reach the bottom-right corner from the top-left corner. If there is no possible way to reach the bottom-right corner, return -1. Args: N (int): The number of rows in the grid. M (int): The number of columns in the grid. grid (List[str]): The grid configuration, where '.' represents an empty cell and '#' represents a blocked cell. Returns: int: The minimum number of steps required to reach the bottom-right corner, or -1 if it is impossible. Example: >>> shortest_path(5, 5, [\\".....\\", \\".#.\\", \\"..#..\\", \\"#..\\", \\".....\\"]) 8 >>> shortest_path(5, 5, [\\".....\\", \\"#\\", \\".....\\", \\"#\\", \\".....\\"]) -1","solution":"from collections import deque def shortest_path(N, M, grid): Returns the minimum number of steps required to reach the bottom-right corner from the top-left corner on a grid, or -1 if it is impossible. if grid[0][0] == '#' or grid[N-1][M-1] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0)]) visited = set((0, 0)) steps = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() if (x, y) == (N-1, M-1): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny)) steps += 1 return -1"},{"question":"def max_subsequences_after_k_operations(N: int, M: int, K: int, A: str, B: str) -> int: Given three integers N, M, and K and two strings A and B, find the maximum number of distinct subsequences of A that can be found in the transformed version of B using at most K operations. An operation is defined as changing a single character in string B to any other lower-case English letter. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Arguments: N -- Length of string A M -- Length of string B K -- Maximum number of operations allowed A -- String A B -- String B Returns: Integer representing the maximum number of distinct subsequences of A in the transformed version of B. >>> max_subsequences_after_k_operations(3, 5, 2, \\"abc\\", \\"axeyd\\") 3 >>> max_subsequences_after_k_operations(3, 5, 1, \\"abc\\", \\"axeyd\\") 2 >>> max_subsequences_after_k_operations(3, 3, 0, \\"abc\\", \\"xyz\\") 0 >>> max_subsequences_after_k_operations(5, 5, 5, \\"abcde\\", \\"fghij\\") 5 >>> max_subsequences_after_k_operations(1, 3, 2, \\"a\\", \\"xyz\\") 1 >>> max_subsequences_after_k_operations(4, 4, 0, \\"abcd\\", \\"abcd\\") 4 >>> max_subsequences_after_k_operations(3, 3, 0, \\"aaa\\", \\"aaa\\") 1","solution":"def max_subsequences_after_k_operations(N, M, K, A, B): Returns the maximum number of distinct subsequences of A that can be found in the transformed version of B. from collections import Counter # Count the frequency of characters in A a_count = Counter(A) # We will greedily try to match B as closely as possible to A by counting changes needed and tallying distinct matches changes_needed = 0 distinct_subsequences = 0 for char in set(A): if a_count[char] > B.count(char): additional_needed = a_count[char] - B.count(char) changes_needed += additional_needed if changes_needed <= K: distinct_subsequences += 1 else: break else: distinct_subsequences += 1 return distinct_subsequences"},{"question":"def find_max_participants(webinars): Returns the maximum number of participants and the indices of webinars with the maximum number of participants. >>> find_max_participants([]) (0, []) >>> find_max_participants([100]) (100, [0]) >>> find_max_participants([10, 20, 20, 5, 30, 30, 10]) (30, [4, 5]) >>> find_max_participants([10, 10, 10, 10]) (10, [0, 1, 2, 3]) >>> find_max_participants([5, 3, 9, 12, 7]) (12, [3]) >>> find_max_participants([12, 0, 12, 3, 12, 1]) (12, [0, 2, 4])","solution":"def find_max_participants(webinars): Returns the maximum number of participants and the indices of webinars with the maximum number of participants. if not webinars: return (0, []) max_participants = max(webinars) max_indices = [i for i, participants in enumerate(webinars) if participants == max_participants] return (max_participants, max_indices)"},{"question":"def factorial(n: int) -> int: Calculate the factorial of a given number n. >>> factorial(0) == 1 >>> factorial(1) => 1 >>> factorial(2) => 2 >>> factorial(3) => 6 >> factorial(4) => 24 >>> factorial(5) => 120 def unique_paths(N: int, M: int) -> int: Calculate the number of unique paths in a grid from top-left to bottom-right. >>> unique_paths(2, 2) => 2 >>> unique_paths(3, 3) => 6 >>> unique_paths(3, 7) => 28 >>> unique_paths(1, 1) => 1 >>> unique_paths(10, 10) => 48620 def process_test_cases(test_cases: List[Tuple[int, int]]) -> List[int]: Process multiple test cases to calculate the number of unique paths for each. >>> process_test_cases([(2, 2), (3, 3), (3, 7)]) => [2, 6, 28] # Driver function for the input-output format def main(): Main function to read input and output results. import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) M = int(data[index + 1]) test_cases.append((N, M)) index += 2 results = process_test_cases(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()","solution":"def factorial(n): if n == 0 or n == 1: return 1 result = 1 for i in range(2, n + 1): result *= i return result def unique_paths(N, M): # The number of unique paths is given by the binomial coefficient (N+M-2) choose (M-1) return factorial(N + M - 2) // (factorial(N - 1) * factorial(M - 1)) def process_test_cases(test_cases): results = [] for N, M in test_cases: results.append(unique_paths(N, M)) return results # Driver function for the input-output format def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) M = int(data[index + 1]) test_cases.append((N, M)) index += 2 results = process_test_cases(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def update_inventory(inventory: List[Tuple[str, int]], shipments: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Updates the inventory based on the shipment details. :param inventory: List of tuples, where each tuple contains a product ID and a quantity. :param shipments: List of tuples, where each tuple contains a product ID and a quantity. :return: List of tuples representing the updated inventory. >>> update_inventory([(\\"apple\\", 50), (\\"banana\\", 20), (\\"orange\\", 30)], [(\\"banana\\", 10), (\\"grape\\", 15)]) [(\\"apple\\", 50), (\\"banana\\", 30), (\\"orange\\", 30), (\\"grape\\", 15)] >>> update_inventory([(\\"shoes\\", 15), (\\"hat\\", 25)], [(\\"shirt\\", 10), (\\"belt\\", 12)]) [(\\"shoes\\", 15), (\\"hat\\", 25), (\\"shirt\\", 10), (\\"belt\\", 12)] >>> update_inventory([(\\"shoes\\", 15), (\\"hat\\", 25)], [(\\"hat\\", 5)]) [(\\"shoes\\", 15), (\\"hat\\", 30)] >>> update_inventory([], [(\\"hat\\", 5)]) [(\\"hat\\", 5)] >>> update_inventory([(\\"shoes\\", 15), (\\"hat\\", 25)], []) [(\\"shoes\\", 15), (\\"hat\\", 25)] # Your code here","solution":"def update_inventory(inventory, shipments): Updates the inventory based on the shipment details. :param inventory: List of tuples, where each tuple contains a product ID (str) and a quantity (int). :param shipments: List of tuples, where each tuple contains a product ID (str) and a quantity (int). :return: List of tuples representing the updated inventory. inventory_dict = {product: quantity for product, quantity in inventory} for product, quantity in shipments: if product in inventory_dict: inventory_dict[product] += quantity else: inventory_dict[product] = quantity updated_inventory = [] # Maintain the order of initial inventory for product, quantity in inventory: updated_inventory.append((product, inventory_dict[product])) # Add new products from shipments for product, quantity in shipments: if product not in dict(inventory): updated_inventory.append((product, quantity)) return updated_inventory"},{"question":"def longest_subsequence_as_substring(a: str, b: str) -> int: Determine the length of the longest subsequence in string a that is also a substring of string b. Input: - a: string consisting of lowercase Latin letters. - b: string consisting of lowercase Latin letters. Output: - Integer: the length of the longest subsequence in a that is also a substring in b. Examples: >>> longest_subsequence_as_substring(\\"abcde\\", \\"ace\\") 3 >>> longest_subsequence_as_substring(\\"abacaba\\", \\"aba\\") 3 >>> longest_subsequence_as_substring(\\"abc\\", \\"def\\") 0 from solution import longest_subsequence_as_substring def test_longest_subsequence_as_substring_1(): assert longest_subsequence_as_substring(\\"abcde\\", \\"ace\\") == 3 def test_longest_subsequence_as_substring_2(): assert longest_subsequence_as_substring(\\"abacaba\\", \\"aba\\") == 3 def test_longest_subsequence_as_substring_3(): assert longest_subsequence_as_substring(\\"abc\\", \\"def\\") == 0 def test_longest_subsequence_as_substring_4(): assert longest_subsequence_as_substring(\\"xyz\\", \\"xyz\\") == 3 def test_longest_subsequence_as_substring_5(): assert longest_subsequence_as_substring(\\"abcdefgh\\", \\"aabbccddeeffgghh\\") == 8 def test_longest_subsequence_as_substring_6(): assert longest_subsequence_as_substring(\\"a\\", \\"a\\") == 1 def test_longest_subsequence_as_substring_7(): assert longest_subsequence_as_substring(\\"abcd\\", \\"abcd\\") == 4 def test_longest_subsequence_as_substring_8(): assert longest_subsequence_as_substring(\\"abcd\\", \\"abdc\\") == 3 def test_longest_subsequence_as_substring_9(): assert longest_subsequence_as_substring(\\"abbcd\\", \\"bd\\") == 2 def test_longest_subsequence_as_substring_10(): assert longest_subsequence_as_substring(\\"aaaaaaaa\\", \\"aa\\") == 2","solution":"def longest_subsequence_as_substring(a, b): Function to find the length of the longest subsequence in 'a' which is also a substring in 'b'. m, n = len(a), len(b) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if a[i - 1] == b[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[-1][-1]"},{"question":"from typing import List def change_element(lst: List[int], i: int, v: int) -> None: Change the element at index i to v. Parameters: lst (List[int]): The list of integers i (int): The index (1-based) of the element to change v (int): The new value of the element >>> lst = [5, 3, 8, 6] >>> change_element(lst, 1, 3) >>> lst [3, 3, 8, 6] pass def query_sum(lst: List[int], l: int, r: int) -> int: Query the sum of elements from index l to index r (inclusive). Parameters: lst (List[int]): The list of integers l (int): The starting index (1-based) of the range r (int): The ending index (1-based) of the range >>> lst = [5, 3, 8, 6] >>> query_sum(lst, 1, 4) 22 pass def check_segment_same(lst: List[int], l: int, r: int, v: int) -> bool: Check if all elements from index l to index r are equal to v. Parameters: lst (List[int]): The list of integers l (int): The starting index (1-based) of the range r (int): The ending index (1-based) of the range v (int): The value to check against the elements in range >>> lst = [3, 3, 3, 3] >>> check_segment_same(lst, 1, 4, 3) True >>> lst = [3, 3, 8, 3] >>> check_segment_same(lst, 1, 4, 3) False pass","solution":"def change_element(lst, i, v): Change the element at index i to v. lst[i-1] = v def query_sum(lst, l, r): Query the sum of elements from index l to index r (inclusive). return sum(lst[l-1:r]) def check_segment_same(lst, l, r, v): Check if all elements from index l to index r are equal to v. for index in range(l-1, r): if lst[index] != v: return False return True # Example to demonstrate the function after implementing tests if __name__ == \\"__main__\\": lst = [5, 3, 8, 6] change_element(lst, 1, 3) # lst becomes [3, 3, 8, 6] print(query_sum(lst, 2, 5)) # Output: 23 print(check_segment_same(lst, 1, 4, 3)) # Output: True"},{"question":"def min_sort_energy_cost(n: int, weights: List[int]) -> int: This function returns the minimum total energy cost required to sort the widgets in non-decreasing order of their weights. Parameters: n (int): The number of widgets weights (list of int): The weights of the widgets Returns: int: The minimum total energy cost to sort the widgets from typing import List # Unit tests def test_example_1(): assert min_sort_energy_cost(3, [2, 3, 1]) == 2 def test_example_2(): assert min_sort_energy_cost(4, [4, 2, 3, 1]) == 5 def test_example_3(): assert min_sort_energy_cost(5, [10, 20, 30, 40, 50]) == 0 def test_single_element(): assert min_sort_energy_cost(1, [100]) == 0 def test_all_same_elements(): assert min_sort_energy_cost(5, [2, 2, 2, 2, 2]) == 0 def test_reverse_order(): assert min_sort_energy_cost(4, [4, 3, 2, 1]) == 6 def test_large_gap_weights(): assert min_sort_energy_cost(3, [1, 1000000000, 500000000]) == 999999999 def test_already_sorted(): assert min_sort_energy_cost(3, [1, 2, 3]) == 0","solution":"def min_sort_energy_cost(n, weights): This function returns the minimum total energy cost required to sort the widgets in non-decreasing order of their weights. Parameters: n (int): The number of widgets weights (list of int): The weights of the widgets Returns: int: The minimum total energy cost to sort the widgets # Create a copy of original weights original_weights = weights[:] # Sort the weights to get the target positions sorted_weights = sorted(weights) # Create a map from weight to original index weight_to_index = {weight: i for i, weight in enumerate(weights)} visited = [False] * n cost = 0 for i in range(n): if visited[i] or sorted_weights[i] == original_weights[i]: continue j = i cycle_size = 0 cycle_cost = 0 while not visited[j]: visited[j] = True next_index = weight_to_index[sorted_weights[j]] cycle_cost += abs(original_weights[j] - original_weights[next_index]) j = next_index cycle_size += 1 if cycle_size > 1: cost += cycle_cost - (cycle_size - 1) return cost"},{"question":"from typing import List class FleetManagementSystem: def __init__(self): self.vehicles = {} def update_vehicle(self, vehicle_id: int, x1: int, y1: int, x2: int, y2: int): Updates the area for the vehicle with the given vehicle_id. The area is defined by two opposite corners (x1, y1) and (x2, y2). pass def query_vehicle(self, vehicle_id: int, x: int, y: int) -> str: Checks if the vehicle can deliver to the location (x, y). Returns \\"YES\\" if it can and \\"NO\\" otherwise. pass def manage_fleet(operations: List[str]) -> List[str]: Manages the fleet of vehicles and processes the operations. Args: operations: List of operations to perform on the fleet. Returns: List of results from the QUERY operations. pass # Example Usage operations = [ \\"UPDATE 1 0 0 10 10\\", \\"UPDATE 2 -10 -10 -1 -1\\", \\"QUERY 1 5 5\\", \\"QUERY 2 0 0\\", \\"QUERY 2 -5 -5\\", \\"QUERY 3 10 10\\" ] result = manage_fleet(operations) print(result) # Output: [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"]","solution":"class FleetManagementSystem: def __init__(self): self.vehicles = {} def update_vehicle(self, vehicle_id, x1, y1, x2, y2): # Ensure the coordinates are ordered in the canonical form min_x, max_x = min(x1, x2), max(x1, x2) min_y, max_y = min(y1, y2), max(y1, y2) self.vehicles[vehicle_id] = (min_x, min_y, max_x, max_y) def query_vehicle(self, vehicle_id, x, y): if vehicle_id not in self.vehicles: return \\"NO\\" min_x, min_y, max_x, max_y = self.vehicles[vehicle_id] if min_x <= x <= max_x and min_y <= y <= max_y: return \\"YES\\" return \\"NO\\" def manage_fleet(operations): system = FleetManagementSystem() result = [] for operation in operations: parts = operation.split() if parts[0] == \\"UPDATE\\": vehicle_id = int(parts[1]) x1, y1, x2, y2 = int(parts[2]), int(parts[3]), int(parts[4]), int(parts[5]) system.update_vehicle(vehicle_id, x1, y1, x2, y2) elif parts[0] == \\"QUERY\\": vehicle_id = int(parts[1]) x, y = int(parts[2]), int(parts[3]) result.append(system.query_vehicle(vehicle_id, x, y)) return result"},{"question":"def sum_of_even_numbers_in_subarray(nums, queries): This function returns the sum of even numbers for each query given on the nums array. Parameters: nums (list of int): The list of integers. queries (list of tuple): The list of queries where each query is a tuple (li, ri). Returns: list of int: A list containing the results for each query. >>> sum_of_even_numbers_in_subarray([2, 1, 4, 5, 6, 3], [(2, 5)]) [10] >>> sum_of_even_numbers_in_subarray([2, 1, 4, 5, 6, 3], [(2, 5), (1, 3)]) [10, 6] >>> sum_of_even_numbers_in_subarray([2, 1, 4, 5, 6, 3], [(4, 5)]) [6] >>> sum_of_even_numbers_in_subarray([2, 4, 6, 8, 10], [(1, 5), (2, 4)]) [30, 18] >>> sum_of_even_numbers_in_subarray([1, 3, 5, 7, 9], [(1, 5), (2, 4)]) [0, 0] >>> sum_of_even_numbers_in_subarray([2, 1, 4, 5, 6, 3], [(1, 6), (1, 1), (6, 6)]) [12, 2, 0]","solution":"def sum_of_even_numbers_in_subarray(nums, queries): This function returns the sum of even numbers for each query given on the nums array. Parameters: nums (list of int): The list of integers. queries (list of tuple): The list of queries where each query is a tuple (li, ri). Returns: list of int: A list containing the results for each query. results = [] for li, ri in queries: subarray = nums[li-1:ri] even_sum = sum(num for num in subarray if num % 2 == 0) results.append(even_sum) return results"},{"question":"def max_teams(n: int, k: int, skill_levels: List[int]) -> int: Finds the maximum number of teams that can be formed where the difference in skill levels between the strongest and the weakest knight in each team does not exceed k. Parameters: n (int): The number of knights k (int): The maximum allowed difference in skill levels within a team skill_levels (List[int]): List of skill levels of the knights Returns: int: The maximum number of teams # Test Cases def test_example1(): assert max_teams(5, 3, [1, 5, 3, 8, 4]) == 2 def test_example2(): assert max_teams(6, 0, [1, 2, 3, 4, 5, 6]) == 6 def test_no_difference_allowed(): assert max_teams(4, 0, [10, 20, 30, 40]) == 4 def test_all_same_skill(): assert max_teams(5, 10, [10, 10, 10, 10, 10]) == 1 def test_one_knight(): assert max_teams(1, 10, [10]) == 1 def test_larger_difference(): assert max_teams(5, 10, [1, 5, 3, 8, 4]) == 1 def test_skill_zero(): assert max_teams(4, 3, [0, 0, 0, 0]) == 1","solution":"def max_teams(n, k, skill_levels): Finds the maximum number of teams that can be formed where the difference in skill levels between the strongest and the weakest knight in each team does not exceed k. Parameters: n (int): The number of knights k (int): The maximum allowed difference in skill levels within a team skill_levels (List[int]): List of skill levels of the knights Returns: int: The maximum number of teams # Sort the skill levels skill_levels.sort() teams = 0 i = 0 while i < n: # Find the max skill in the current team max_skill = skill_levels[i] + k # Find the range of skills that can be included in the current team while i < n and skill_levels[i] <= max_skill: i += 1 # A new team is formed teams += 1 return teams"},{"question":"def max_sum_divisible_by_k(n: int, k: int, arr: List[int]) -> int: Returns the maximum possible sum of selected integers such that it is divisible by k. Args: n (int): the number of integers in the list k (int): the divisor arr (List[int]): list of integers Returns: int: the maximum sum possible which is divisible by k Examples: >>> max_sum_divisible_by_k(5, 4, [3, 1, 4, 2, 8]) 16 >>> max_sum_divisible_by_k(1, 3, [4]) 0 >>> max_sum_divisible_by_k(1, 3, [3]) 3 >>> max_sum_divisible_by_k(4, 2, [2, 4, 6, 8]) 20 >>> max_sum_divisible_by_k(3, 5, [1, 2, 3]) 5 >>> max_sum_divisible_by_k(3, 10, [100, 200, 300]) 600 from solution import max_sum_divisible_by_k def test_example_case(): n = 5 k = 4 arr = [3, 1, 4, 2, 8] assert max_sum_divisible_by_k(n, k, arr) == 16 def test_single_element_not_divisible(): n = 1 k = 3 arr = [4] assert max_sum_divisible_by_k(n, k, arr) == 0 def test_single_element_divisible(): n = 1 k = 3 arr = [3] assert max_sum_divisible_by_k(n, k, arr) == 3 def test_multiple_elements_all_divisible(): n = 4 k = 2 arr = [2, 4, 6, 8] assert max_sum_divisible_by_k(n, k, arr) == 20 def test_no_elements_divisible(): n = 3 k = 5 arr = [1, 2, 3] assert max_sum_divisible_by_k(n, k, arr) == 5 def test_large_numbers(): n = 3 k = 10 arr = [100, 200, 300] assert max_sum_divisible_by_k(n, k, arr) == 600","solution":"def max_sum_divisible_by_k(n, k, arr): Returns the maximum possible sum of selected integers such that it is divisible by k. n: int - the number of integers in the list k: int - the divisor arr: list of int - list of integers dp = [0] * k # dp[i] will be the max sum % k == i for num in arr: # We need to iterate over a copy of dp to not update dp during the iteration new_dp = dp[:] for i in range(k): new_sum = dp[i] + num new_dp[new_sum % k] = max(new_dp[new_sum % k], new_sum) dp = new_dp # update the dp array return dp[0] # Test code"},{"question":"def max_in_range(arr, queries): Returns the maximum integer in the specified subsegment for each query. Parameters: arr (list): The array of integers. queries (list): A list of tuples, each containing two integers representing the range (l, r) (1-based index). Returns: list: A list of integers, each corresponding to the maximum integer in the specified subsegment for each query. pass from solution import max_in_range def test_single_query(): arr = [1, 5, 3, 2, 4] queries = [(2, 4)] assert max_in_range(arr, queries) == [5] def test_multiple_queries(): arr = [1, 3, -2, 7, 4] queries = [(1, 3), (2, 4), (1, 5)] assert max_in_range(arr, queries) == [3, 7, 7] def test_entire_range_query(): arr = [2, 6, 1, -3] queries = [(1, 4)] assert max_in_range(arr, queries) == [6] def test_single_element_ranges(): arr = [10, 20, 30, 40, 50] queries = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] assert max_in_range(arr, queries) == [10, 20, 30, 40, 50] def test_overlapping_ranges(): arr = [8, -2, 4, 5, 9, 1] queries = [(1, 3), (3, 5), (2, 6)] assert max_in_range(arr, queries) == [8, 9, 9]","solution":"def max_in_range(arr, queries): Returns the maximum integer in the specified subsegment for each query. Parameters: arr (list): The array of integers. queries (list): A list of tuples, each containing two integers representing the range (l, r) (1-based index). Returns: list: A list of integers, each corresponding to the maximum integer in the specified subsegment for each query. results = [] for (l, r) in queries: # Find the maximum in the subsegment l-1 to r-1 (0-based indexing) max_value = max(arr[l-1:r]) results.append(max_value) return results"},{"question":"from typing import List def determine_winner(n: int, array: List[int]) -> str: Alice and Bob are playing a game with an array of integers. The game involves taking turns to change elements in the array by adding or subtracting a value of 1 from any element. The objective of the game is to make all elements of the array equal. Alice always starts first, and they play optimally. Parameters: n (int): The number of elements in the array. array (list of int): The array of integers. Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins. >>> determine_winner(3, [1, 2, 3]) \\"Alice\\" >>> determine_winner(4, [4, 4, 4, 4]) \\"Bob\\" >>> determine_winner(5, [1, 1, 2, 3, 3]) \\"Alice\\" >>> determine_winner(2, [1, 1]) \\"Bob\\" >>> determine_winner(6, [1, 2, 2, 1, 1, 2]) \\"Alice\\" >>> determine_winner(1, [1]) \\"Bob\\" # Only one element >>> determine_winner(2, [1, 2]) \\"Alice\\" # Simple two element array >>> determine_winner(3, [3, 3, 3]) \\"Bob\\" # All elements are the same >>> determine_winner(3, [3, 1, 1]) \\"Alice\\" # One element different","solution":"def determine_winner(n, array): Determines the winner of the game between Alice and Bob based on the given rules. Parameters: n (int): The number of elements in the array. array (list of int): The array of integers. Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins. distinct_elements = len(set(array)) # If all elements are already equal, Bob wins if distinct_elements == 1: return \\"Bob\\" # Otherwise, Alice wins as she can always make the first optimal move else: return \\"Alice\\""},{"question":"def fibonacci(n): Returns the nth term of the Fibonacci sequence. >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(5) 5 >>> fibonacci(10) 55 def get_fibonacci_sequence(test_cases): Processes multiple test cases and returns the Nth Fibonacci term for each case. >>> get_fibonacci_sequence([5, 10, 15]) [5, 55, 610] >>> get_fibonacci_sequence([1, 2, 3, 4, 5]) [1, 1, 2, 3, 5] >>> get_fibonacci_sequence([20, 25, 30]) [6765, 75025, 832040]","solution":"def fibonacci(n): Returns the nth term of the Fibonacci sequence. if n == 1 or n == 2: return 1 a, b = 1, 1 for _ in range(3, n + 1): a, b = b, a + b return b def get_fibonacci_sequence(test_cases): Processes multiple test cases and returns the Nth Fibonacci term for each case. results = [] for n in test_cases: results.append(fibonacci(n)) return results"},{"question":"def count_special_pairs(arr): This function counts the number of special pairs in the array where a pair (x, y) is special if x + y is even. even_count = sum(1 for x in arr if x % 2 == 0) odd_count = len(arr) - even_count # Special pairs within evens and within odds return even_count * (even_count - 1) // 2 + odd_count * (odd_count - 1) // 2 def max_special_pairs(n, k, arr): This function returns the maximum number of special pairs possible after at most k swaps. Args: n (int): the number of elements in the array. k (int): the number of swaps allowed. arr (List[int]): the array of integers. Returns: int: the maximum number of special pairs after at most k swaps. >>> max_special_pairs(6, 1, [1, 3, 5, 7, 2, 8]) 15 >>> max_special_pairs(4, 0, [2, 4, 6, 8]) 6 >>> max_special_pairs(5, 2, [3, 6, 9, 12, 15]) 10 # Initial count of special pairs initial_special_pairs = count_special_pairs(arr) if k == 0: return initial_special_pairs # Maximum possible pairs in worst case swapping scenario return n * (n - 1) // 2","solution":"def count_special_pairs(arr): This function counts the number of special pairs in the array where a pair (x, y) is special if x + y is even. even_count = sum(1 for x in arr if x % 2 == 0) odd_count = len(arr) - even_count # Special pairs within evens and within odds return even_count * (even_count - 1) // 2 + odd_count * (odd_count - 1) // 2 def max_special_pairs(n, k, arr): This function returns the maximum number of special pairs possible after at most k swaps. # Initial count of special pairs initial_special_pairs = count_special_pairs(arr) if k == 0: return initial_special_pairs # Maximum possible pairs in worst case swapping scenario return n * (n - 1) // 2 # Example usage # print(max_special_pairs(6, 1, [1, 3, 5, 7, 2, 8])) # Output: 9 # print(max_special_pairs(4, 0, [2, 4, 6, 8])) # Output: 6 # print(max_special_pairs(5, 2, [3, 6, 9, 12, 15])) # Output: 6"},{"question":"def generate_parenthesis(n: int) -> List[str]: Generates all possible balanced parenthesis sequences of length 2n. >>> generate_parenthesis(1) [\\"()\\"] >>> generate_parenthesis(2) [\\"(())\\", \\"()()\\"] >>> generate_parenthesis(3) [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] def generate_parenthesis_lexicographic(n: int): Generates and prints all possible balanced parenthesis sequences of length 2n in lexicographic order. >>> generate_parenthesis_lexicographic(1) () >>> generate_parenthesis_lexicographic(2) (()) ()() >>> generate_parenthesis_lexicographic(3) ((())) (()()) (())() ()(()) ()()()","solution":"def generate_parenthesis(n): Generates all possible balanced parenthesis sequences of length 2n. result = [] def backtrack(s='', left=0, right=0): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s + '(', left + 1, right) if right < left: backtrack(s + ')', left, right + 1) backtrack() return result def generate_parenthesis_lexicographic(n): Generates and prints all possible balanced parenthesis sequences of length 2n in lexicographic order. res = generate_parenthesis(n) for seq in sorted(res): print(seq)"},{"question":"def magical_energy(matrix: List[List[int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: Given a matrix representing the magical energy in the forest and a list of queries, return the total amount of magical energy in each specified rectangular subarea. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> queries = [ ... (1, 1, 2, 2), ... (0, 0, 2, 2) ... ] >>> magical_energy(matrix, queries) [28, 45]","solution":"def magical_energy(matrix, queries): Given a matrix representing the magical energy in the forest and a list of queries, return the total amount of magical energy in each specified rectangular subarea. results = [] for r1, c1, r2, c2 in queries: total_energy = 0 for r in range(r1, r2+1): for c in range(c1, c2+1): total_energy += matrix[r][c] results.append(total_energy) return results"},{"question":"def main(input_string: str) -> str: Given a 9×9 Sudoku puzzle where some of the cells are already filled with digits ranging from 1 to 9, determine whether it is possible to completely fill the grid following the Sudoku rules: - Each row must contain all digits from 1 to 9 without repetition. - Each column must contain all digits from 1 to 9 without repetition. - Each of the nine 3×3 subgrids must contain all digits from 1 to 9 without repetition. Your task is to write a program that reads the initial state of the Sudoku grid and outputs \\"Yes\\" if the puzzle is solvable according to the rules, otherwise output \\"No\\". >>> input_puzzle = \\"53..7....n6..195...n.98....6.n8...6...3n4..8.3..1n7...2...6n.6....28.n...419..5n....8..79n0\\" >>> main(input_puzzle) 'Yes' >>> input_puzzle = \\"53..7....n65.195...n.98....6.n8...6...3n4..8.3..1n7...2...6n.6....28.n...419..5n....8..79n0\\" >>> main(input_puzzle) 'No' >>> input_puzzle = \\"53..7....n6..195...n.98....6.n8...6...3n4..8.3..1n7...2...6n.6....28.n...419..5n....8..79n53..7....n6..195...n.98....6.n8...6...3n4..8.3..1n7...2...6n.6....28.n...419..5n....8..79n0\\" >>> main(input_puzzle) 'YesnYes' >>> input_puzzle = \\"53..7....n6..195...n.98....6.n8...6...3n4..8.3..1n7...2...6n.6....28.n...419..5n....8..75n0\\" >>> main(input_puzzle) 'No'","solution":"def is_valid_sudoku(board): rows, cols, squares = {}, {}, {} for r in range(9): for c in range(9): val = board[r][c] if val != '.': if r not in rows: rows[r] = set() if c not in cols: cols[c] = set() square = (r // 3, c // 3) if square not in squares: squares[square] = set() if val in rows[r] or val in cols[c] or val in squares[square]: return False rows[r].add(val) cols[c].add(val) squares[square].add(val) return True def solve_sudoku(board): empty = find_empty_location(board) if not empty: return is_valid_sudoku(board) row, col = empty for num in range(1, 10): if is_safe(board, row, col, str(num)): board[row][col] = str(num) if solve_sudoku(board): return True board[row][col] = '.' return False def find_empty_location(board): for r in range(9): for c in range(9): if board[r][c] == '.': return (r, c) return None def is_safe(board, row, col, num): for i in range(9): if board[row][i] == num or board[i][col] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num: return False return True def process_input(input_string): puzzles = input_string.strip().split(\\"n\\") results = [] puzzle = [] for line in puzzles: if line == \\"0\\": if puzzle: results.append(\\"Yes\\" if solve_sudoku(puzzle) else \\"No\\") break elif len(line) == 9: puzzle.append(list(line)) if len(puzzle) == 9: results.append(\\"Yes\\" if solve_sudoku(puzzle) else \\"No\\") puzzle = [] return results def main(input_string): return \\"n\\".join(process_input(input_string))"},{"question":"def assign_tasks(n: int, m: int, k: int, tasks: List[int]) -> Union[str, Tuple[str, List[int]]]: Determine whether it is possible to distribute n tasks among m participants such that no participant is assigned more than k tasks. :param n: Number of tasks :param m: Number of participants :param k: Maximum tasks per participant :param tasks: List of task difficulties (not relevant for the solution) :return: \\"YES\\" and the task assignment or \\"NO\\" >>> assign_tasks(6, 3, 2, [3, 5, 2, 8, 6, 4]) (\\"YES\\", [1, 2, 3, 1, 2, 3]) >>> assign_tasks(8, 2, 3, [3, 5, 1, 7, 4, 6, 8, 2]) \\"NO\\" # Implementation","solution":"def assign_tasks(n, m, k, tasks): Determine whether it is possible to distribute n tasks among m participants such that no participant is assigned more than k tasks. :param n: Number of tasks :param m: Number of participants :param k: Maximum tasks per participant :param tasks: List of task difficulties (not relevant for the solution) :return: \\"YES\\" and the task assignment or \\"NO\\" # Check if we have a feasible solution if n > m * k: return \\"NO\\" # Create the task assignment list assignment = [0] * n # Implementing a round-robin distribution participant = 1 for i in range(n): assignment[i] = participant participant += 1 if participant > m: participant = 1 return \\"YES\\", assignment"},{"question":"def is_prime(num: int) -> bool: Helper function to check if a number is prime. >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(3) True >>> is_prime(5) True >>> is_prime(9) False >>> is_prime(23) True pass def sum_of_primes(arr: List[int]) -> int: Returns the sum of prime numbers in the array. >>> sum_of_primes([2, 4, 6, 7, 11, 13]) 33 >>> sum_of_primes([0, 1, 4, 6, 8, 10]) 0 >>> sum_of_primes([2, 3, 5, 7, 11, 13]) 41 >>> sum_of_primes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 17 >>> sum_of_primes([]) 0 >>> sum_of_primes([1]) 0 >>> sum_of_primes([2]) 2 >>> sum_of_primes([1,1,1,1]) 0 pass def main(): n = int(input()) arr = list(map(int, input().split())) print(sum_of_primes(arr)) if __name__ == \\"__main__\\": main()","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num == 2: return True # 2 is the only even prime number if num % 2 == 0: return False # No other even number can be prime sq_root = int(num**0.5) + 1 for i in range(3, sq_root, 2): if num % i == 0: return False return True def sum_of_primes(arr): Returns the sum of prime numbers in the array. prime_sum = 0 for num in arr: if is_prime(num): prime_sum += num return prime_sum def main(): n = int(input()) arr = list(map(int, input().split())) print(sum_of_primes(arr)) if __name__ == \\"__main__\\": main()"},{"question":"def cyclic_shift(series: str, positions: int) -> str: Shifts the digits in the series cyclically to the right by the specified number of positions. Args: series (str): The series of numeric digits as a string. positions (int): The number of positions to shift the digits. Returns: str: The encrypted series of numbers after shifting the digits cyclically to the right. Examples: >>> cyclic_shift(\\"12345\\", 2) \\"45123\\" >>> cyclic_shift(\\"9876543210\\", 4) \\"3210987654\\" >>> cyclic_shift(\\"5\\", 0) \\"5\\"","solution":"def cyclic_shift(series, positions): Shifts the digits in the series cyclically to the right by the specified number of positions. if len(series) == 0: return series n = len(series) positions = positions % n return series[-positions:] + series[:-positions]"},{"question":"from typing import List, Tuple def count_postal_offices(n: int, roads: List[Tuple[int, int]]) -> int: Returns the minimum number of postal offices needed to serve all cities. Parameters: n (int): The number of cities. roads (list of tuples): Each tuple represents a bidirectional road between two cities. Returns: int: Minimum number of postal offices needed. pass # Unit Tests def test_no_roads_multiple_cities(): assert count_postal_offices(5, []) == 5 def test_single_city(): assert count_postal_offices(1, []) == 1 def test_two_components(): assert count_postal_offices(4, [(1, 2), (3, 4)]) == 2 def test_fully_connected(): assert count_postal_offices(3, [(1, 2), (2, 3), (1, 3)]) == 1 def test_line_graph(): assert count_postal_offices(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) == 1 def test_disconnected_graph(): assert count_postal_offices(6, [(1, 2), (2, 3), (4, 5)]) == 3 def test_complex_graph(): assert count_postal_offices(6, [(1, 2), (1, 3), (2, 3), (4, 5), (4, 6), (5, 6)]) == 2","solution":"def count_postal_offices(n, roads): Returns the minimum number of postal offices needed to serve all cities. Parameters: n (int): The number of cities. roads (list of tuples): Each tuple represents a bidirectional road between two cities. Returns: int: Minimum number of postal offices needed. from collections import defaultdict, deque # Create an adjacency list adjacency_list = defaultdict(list) for u, v in roads: adjacency_list[u].append(v) adjacency_list[v].append(u) visited = set() connected_components = 0 def bfs(node): queue = deque([node]) while queue: current = queue.popleft() for neighbor in adjacency_list[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) for city in range(1, n + 1): if city not in visited: visited.add(city) bfs(city) connected_components += 1 return connected_components # Example usage: # print(count_postal_offices(4, [(1, 2), (3, 4)])) # Output: 2 # print(count_postal_offices(5, [(1, 2), (2, 3), (3, 4), (4, 5)])) # Output: 1"},{"question":"def generate_sequence(n, k, m, starting_integers): Generates a sequence of integers of length n based on the given parameters. Parameters: - n (int): The total length of the desired sequence. - k (int): The number of initial integers in the sequence. - m (int): The number of immediate predecessors to sum for generating the next integer. - starting_integers (list): The starting k integers of the sequence. Returns: - list: The generated sequence of length n. pass def process_test_cases(test_cases): Processes multiple test cases and generates the sequences for each. Parameters: - test_cases (list): A list of tuples where each tuple contains (n, k, m, starting_integers). Returns: - list: A list of generated sequences for each test case. pass from solution import generate_sequence, process_test_cases def test_generate_sequence(): assert generate_sequence(10, 3, 2, [1, 1, 2]) == [1, 1, 2, 3, 5, 8, 13, 21, 34, 55] assert generate_sequence(7, 4, 3, [2, 2, 2, 2]) == [2, 2, 2, 2, 6, 10, 18] assert generate_sequence(5, 2, 1, [1, 1]) == [1, 1, 1, 1, 1] assert generate_sequence(6, 3, 3, [0, 0, 1]) == [0, 0, 1, 1, 2, 4] def test_process_test_cases(): test_cases = [ (10, 3, 2, [1, 1, 2]), (7, 4, 3, [2, 2, 2, 2]) ] expected = [ [1, 1, 2, 3, 5, 8, 13, 21, 34, 55], [2, 2, 2, 2, 6, 10, 18] ] assert process_test_cases(test_cases) == expected","solution":"def generate_sequence(n, k, m, starting_integers): Generates a sequence of integers of length n based on the given parameters. Parameters: - n (int): The total length of the desired sequence. - k (int): The number of initial integers in the sequence. - m (int): The number of immediate predecessors to sum for generating the next integer. - starting_integers (list): The starting k integers of the sequence. Returns: - list: The generated sequence of length n. sequence = starting_integers[:] while len(sequence) < n: next_value = sum(sequence[-m:]) sequence.append(next_value) return sequence def process_test_cases(test_cases): Processes multiple test cases and generates the sequences for each. Parameters: - test_cases (list): A list of tuples where each tuple contains (n, k, m, starting_integers). Returns: - list: A list of generated sequences for each test case. results = [] for n, k, m, starting_integers in test_cases: results.append(generate_sequence(n, k, m, starting_integers)) return results"},{"question":"def can_be_palindrome_by_replacing_one_char(S: str) -> str: Given a string S, determine whether it is possible to make S a palindrome by replacing exactly one character. If it is possible, return 'Yes'; if it is not possible, return 'No'. A palindrome is a word that reads the same backward as forward. Constraints: * 1 <= |S| <= 100 * S consists of lowercase English letters. Example: >>> can_be_palindrome_by_replacing_one_char(\\"abccba\\") 'No' >>> can_be_palindrome_by_replacing_one_char(\\"abccaa\\") 'Yes' >>> can_be_palindrome_by_replacing_one_char(\\"abcda\\") 'Yes' def test_example_1(): assert can_be_palindrome_by_replacing_one_char(\\"abccba\\") == 'No' def test_example_2(): assert can_be_palindrome_by_replacing_one_char(\\"abccaa\\") == 'Yes' def test_example_3(): assert can_be_palindrome_by_replacing_one_char(\\"abcda\\") == 'Yes' def test_single_char(): assert can_be_palindrome_by_replacing_one_char(\\"a\\") == 'No' def test_two_chars_no(): assert can_be_palindrome_by_replacing_one_char(\\"aa\\") == 'No' def test_two_chars_yes(): assert can_be_palindrome_by_replacing_one_char(\\"ab\\") == 'Yes' def test_already_palindrome(): assert can_be_palindrome_by_replacing_one_char(\\"racecar\\") == 'No' def test_needs_multiple_changes(): assert can_be_palindrome_by_replacing_one_char(\\"abcdef\\") == 'No' def test_odd_length_needs_one_change(): assert can_be_palindrome_by_replacing_one_char(\\"abcba\\") == 'No' # Middle char different def test_even_length_needs_one_change(): assert can_be_palindrome_by_replacing_one_char(\\"abccbx\\") == 'Yes' def test_edge_case_empty(): assert can_be_palindrome_by_replacing_one_char(\\"\\") == 'No'","solution":"def can_be_palindrome_by_replacing_one_char(S): Return 'Yes' if it is possible to make S a palindrome by replacing exactly one character, otherwise return 'No'. n = len(S) mismatch_count = 0 for i in range(n // 2): if S[i] != S[n - i - 1]: mismatch_count += 1 if mismatch_count > 1: return 'No' return 'Yes' if mismatch_count == 1 else 'No'"},{"question":"def max_employees(n: int, teams: List[List[int]]) -> int: Find the maximum number of employees that can be chosen such that they are from different teams and their skill levels form a strictly increasing sequence. >>> max_employees(3, [[1, 3, 5], [2, 4, 6], [4, 7, 8]]) 3 >>> max_employees(2, [[5, 7], [3, 9]]) 2 >>> max_employees(1, [[5, 3, 7, 2]]) 1 >>> max_employees(3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 3 >>> max_employees(200000, [[i] for i in range(200000)]) 200000","solution":"def max_employees(n, teams): # Extract the minimum skills from each team min_skills = [min(team) for team in teams] # Sort the min skills to create a potential strictly increasing list min_skills_sorted = sorted(min_skills) # We can select each of these skills as they come from different teams return len(min_skills_sorted)"},{"question":"def max_problems_solved(M: int, L: int, times: List[int]) -> int: Determines the maximum number of problems Diana can solve within the time limit L. Parameters: M (int): Number of problems L (int): Time limit times (List[int]): Time required to solve each problem Returns: int: Maximum number of problems that can be solved within the time limit Examples: >>> max_problems_solved(5, 10, [2, 3, 1, 4, 5]) 4 >>> max_problems_solved(3, 7, [4, 5, 6]) 1 >>> max_problems_solved(4, 11, [8, 2, 3, 4]) 3","solution":"def max_problems_solved(M, L, times): Determines the maximum number of problems Diana can solve within the time limit L. Parameters: M (int): Number of problems L (int): Time limit times (List[int]): Time required to solve each problem Returns: int: Maximum number of problems that can be solved within the time limit # Sort the problem times to solve the easiest problems first times.sort() total_time = 0 problem_count = 0 for time in times: if total_time + time <= L: total_time += time problem_count += 1 else: break return problem_count"},{"question":"from typing import List def shortest_path(M: int, N: int, grid: List[List[str]], sx: int, sy: int, ex: int, ey: int) -> int: Finds the shortest path in a grid from (sx, sy) to (ex, ey), avoiding buildings. :param M: int, number of rows :param N: int, number of columns :param grid: list of lists, representing the city layout ('.' for road, '#' for building) :param sx: int, start x-coordinate :param sy: int, start y-coordinate :param ex: int, end x-coordinate :param ey: int, end y-coordinate :return: int, shortest path length or -1 if no valid path exists pass # Test cases to verify the solution def test_shortest_path_basic(): grid = [ ['.', '.', '.', '#', '.'], ['#', '#', '.', '#', '.'], ['.', '.', '.', '.', '#'], ['.', '#', '#', '.', '#'], ['.', '.', '.', '.', '.'] ] assert shortest_path(5, 5, grid, 0, 0, 4, 4) == 8 def test_shortest_path_no_path(): grid = [ ['.', '.', '.', '#', '.'], ['.', '#', '#', '#', '.'], ['.', '#', '.', '.', '.'], ['#', '#', '#', '.', '.'], ['.', '.', '.', '.', '.'] ] assert shortest_path(5, 5, grid, 0, 0, 4, 4) == -1 def test_shortest_path_start_is_end(): grid = [ ['.', '.', '.', '#', '.'], ['#', '#', '.', '#', '.'], ['.', '.', '.', '.', '#'], ['.', '#', '#', '.', '#'], ['.', '.', '.', '.', '.'] ] assert shortest_path(5, 5, grid, 0, 0, 0, 0) == 0 def test_shortest_path_multiple_roads(): grid = [ ['.', '.', '.', '#', '.'], ['#', '#', '.', '#', '.'], ['.', '.', '.', '.', '.'], ['.', '#', '#', '.', '#'], ['.', '.', '.', '.', '.'] ] assert shortest_path(5, 5, grid, 0, 0, 2, 4) == 6 def test_shortest_path_no_buildings(): grid = [ ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'] ] assert shortest_path(5, 5, grid, 0, 0, 4, 4) == 8 def test_shortest_path_completely_blocked(): grid = [ ['#'], ] assert shortest_path(1, 1, grid, 0, 0, 0, 0) == -1","solution":"from collections import deque def shortest_path(M, N, grid, sx, sy, ex, ey): Finds the shortest path in a grid from (sx, sy) to (ex, ey), avoiding buildings. :param M: int, number of rows :param N: int, number of columns :param grid: list of lists, representing the city layout :param sx: int, start x-coordinate :param sy: int, start y-coordinate :param ex: int, end x-coordinate :param ey: int, end y-coordinate :return: int, shortest path length or -1 if no valid path exists if grid[sx][sy] == '#' or grid[ex][ey] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(sx, sy)]) visited = [[False] * N for _ in range(M)] visited[sx][sy] = True distance = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() if x == ex and y == ey: return distance for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny)) distance += 1 return -1"},{"question":"def process_commands(n: int, command_lines: List[str]) -> str: Process a list of text editor commands and return the final state of the text. >>> process_commands(5, [\\"1 a\\", \\"1 b\\", \\"2\\", \\"3\\", \\"1 c\\"]) \\"abc\\" >>> process_commands(7, [\\"1 x\\", \\"1 y\\", \\"1 z\\", \\"2\\", \\"2\\", \\"3\\", \\"3\\"]) \\"xyz\\"","solution":"def text_editor(commands): current_text = [] undo_stack = [] redo_stack = [] for command in commands: if command.startswith(\\"1\\"): _, char = command.split() current_text.append(char) undo_stack.append(char) redo_stack.clear() # Clear redo stack as new operations break the redo chain elif command == \\"2\\": if current_text: redo_stack.append(current_text.pop()) elif command == \\"3\\": if redo_stack: char = redo_stack.pop() current_text.append(char) undo_stack.append(char) return ''.join(current_text) def process_commands(n, command_lines): return text_editor(command_lines)"},{"question":"def sequence_modulo(N: int, K: int, A: List[int]) -> List[int]: This function takes the length of the sequence N, the exponent K, and the sequence of integers A, then calculates A_i raised to the power of K modulo 1000 for each element in the sequence A. >>> sequence_modulo(5, 2, [123, 456, 789, 1011, 1213]) [129, 936, 521, 121, 369] >>> sequence_modulo(3, 4, [1, 2, 3]) [1, 16, 81] import unittest class TestSequenceModulo(unittest.TestCase): def test_sequence_modulo_example_1(self): N = 5 K = 2 A = [123, 456, 789, 1011, 1213] self.assertEqual(sequence_modulo(N, K, A), [129, 936, 521, 121, 369]) def test_sequence_modulo_example_2(self): N = 3 K = 4 A = [1, 2, 3] self.assertEqual(sequence_modulo(N, K, A), [1, 16, 81]) def test_sequence_modulo_single_element(self): N = 1 K = 1 A = [999] self.assertEqual(sequence_modulo(N, K, A), [999]) def test_sequence_modulo_large_k(self): N = 3 K = 100000 A = [2, 5, 10] self.assertEqual(sequence_modulo(N, K, A), [(2 ** 100000) % 1000, (5 ** 100000) % 1000, (10 ** 100000) % 1000]) def test_sequence_modulo_large_a(self): N = 2 K = 2 A = [99999, 100000] self.assertEqual(sequence_modulo(N, K, A), [(99999 ** 2) % 1000, (100000 ** 2) % 1000]) def test_sequence_modulo_zero_k(self): N = 3 K = 0 A = [1, 2, 3] self.assertEqual(sequence_modulo(N, K, A), [1, 1, 1]) # Any number raised to power 0 is 1 if __name__ == \\"__main__\\": unittest.main()","solution":"def sequence_modulo(N, K, A): This function takes the length of the sequence N, the exponent K, and the sequence of integers A, then calculates A_i raised to the power of K modulo 1000 for each element in the sequence A. mod = 1000 B = [(a ** K) % mod for a in A] return B"},{"question":"def replace_shortcuts(n, shortcuts, text): Replaces shortcuts in the provided text with their corresponding full variable names. Args: n (int): number of shortcut definitions. shortcuts (List[Tuple[str, str]]): A list of tuples where each tuple contains a shortcut and its full variable name. text (str): The text in which shortcuts need to be replaced. Returns: str: The processed text with shortcuts replaced by their corresponding full variable names. Example: >>> replace_shortcuts(3, [(\\"brb\\", \\"be right back\\"), (\\"gtg\\", \\"got to go\\"), (\\"idk\\", \\"I don't know\\")], \\"I need to leave now gtg. brb.\\") I need to leave now got to go. be right back.","solution":"def replace_shortcuts(n, shortcuts, text): Replaces shortcuts in the provided text with their corresponding full variable names. Args: n (int): number of shortcut definitions. shortcuts (List[Tuple[str, str]]): A list of tuples where each tuple contains a shortcut and its full variable name. text (str): The text in which shortcuts need to be replaced. Returns: str: The processed text with shortcuts replaced by their corresponding full variable names. for shortcut, full_name in shortcuts: text = text.replace(shortcut, full_name) return text # Example usage: # n = 3 # shortcuts = [(\\"brb\\", \\"be right back\\"), (\\"gtg\\", \\"got to go\\"), (\\"idk\\", \\"I don't know\\")] # text = \\"I need to leave now gtg. brb.\\" # print(replace_shortcuts(n, shortcuts, text))"},{"question":"def largest_sum_increasing_subsequence(n: int, sequence: List[int]) -> int: Find the largest sum of an increasing subsequence in the sequence. Args: n (int): The number of elements in the sequence. sequence (List[int]): The sequence of integers. Returns: int: The largest sum of an increasing subsequence. Example: >>> largest_sum_increasing_subsequence(5, [1, 101, 2, 3, 100]) 106 >>> largest_sum_increasing_subsequence(3, [3, 4, 5]) 12 >>> largest_sum_increasing_subsequence(6, [10, 5, 4, 3, 2, 1]) 10","solution":"def largest_sum_increasing_subsequence(n, sequence): if n == 0: return 0 # Initialize a list to store the maximum sum of increasing subsequences ending at each index max_sum = sequence[:] # Iterate over the sequence to fill the \`max_sum\` list for i in range(1, n): for j in range(i): if sequence[i] > sequence[j]: max_sum[i] = max(max_sum[i], max_sum[j] + sequence[i]) # Return the maximum value from the \`max_sum\` list return max(max_sum) # Example usage: # n = 5 # sequence = [1, 101, 2, 3, 100] # print(largest_sum_increasing_subsequence(n, sequence)) # Output: 106"},{"question":"def can_form_word(word: str, letters: List[str]) -> bool: Check if a word can be formed with the given list of letters exactly once. >>> can_form_word(\\"dog\\", [\\"d\\", \\"o\\", \\"g\\"]) == True >>> can_form_word(\\"cat\\", [\\"c\\", \\"a\\", \\"t\\"]) == True >>> can_form_word(\\"bat\\", [\\"b\\", \\"a\\", \\"t\\", \\"x\\"]) == True >>> can_form_word(\\"bat\\", [\\"b\\", \\"a\\", \\"x\\"]) == False def words_from_letters(words_list: str, letters_list: str) -> str: Returns the list of words that can be formed using the given letters exactly once. >>> words_from_letters(\\"dog cat mouse\\", \\"d o g c a t m o u s e\\") == \\"dog cat mouse\\" >>> words_from_letters(\\"apple orange banana\\", \\"a p p l e o r a n g e b a n a n a\\") == \\"apple orange banana\\" >>> words_from_letters(\\"blue red green\\", \\"b l u e r e d g r e e n\\") == \\"blue red green\\" >>> words_from_letters(\\"boat car plane\\", \\"b o a t c a r\\") == \\"boat car\\"","solution":"def can_form_word(word, letters): Check if a word can be formed with the given list of letters exactly once. letter_count = {} for letter in letters: if letter in letter_count: letter_count[letter] += 1 else: letter_count[letter] = 1 for char in word: if char not in letter_count or letter_count[char] == 0: return False letter_count[char] -= 1 return True def words_from_letters(words_list, letters_list): Returns the list of words that can be formed using the given letters exactly once. result = [] letters = letters_list.split() for word in words_list.split(): if can_form_word(word, letters): result.append(word) for char in word: letters.remove(char) return ' '.join(result)"},{"question":"def is_palindrome(s: str) -> str: Determines if a given string is a palindrome, ignoring spaces, punctuation, and case differences. Args: s (str): The input string. Returns: str: \\"YES\\" if the input string is a palindrome, otherwise \\"NO\\". Example: >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") == \\"YES\\" >>> is_palindrome(\\"Hello, World!\\") == \\"NO\\"","solution":"def is_palindrome(s): Determines if a given string is a palindrome, ignoring spaces, punctuation, and case differences. Args: s (str): The input string. Returns: str: \\"YES\\" if the input string is a palindrome, otherwise \\"NO\\". # Using list comprehension to filter out non-alphanumeric characters and convert to lower case filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered list of characters is equal to its reverse if filtered_chars == filtered_chars[::-1]: return \\"YES\\" else: return \\"NO\\""},{"question":"def shortest_palindrome(s: str) -> str: Returns the shortest palindrome by adding characters at the start of the string. >>> shortest_palindrome(\\"aacecaaa\\") 'aaacecaaa' >>> shortest_palindrome(\\"abcd\\") 'dcbabcd'","solution":"def shortest_palindrome(s): Returns the shortest palindrome by adding characters at the start of the string. n = len(s) if n == 0: return \\"\\" # Create the string for checking palindrome by reverse prefix rev_s = s[::-1] new_s = s + \\"#\\" + rev_s lps = [0] * len(new_s) # Longest prefix suffix array # Compute the LPS array for i in range(1, len(new_s)): length = lps[i - 1] while length > 0 and new_s[i] != new_s[length]: length = lps[length - 1] if new_s[i] == new_s[length]: lps[i] = length + 1 else: lps[i] = 0 # The number of characters to be added is derived from the LPS array to_add_count = n - lps[-1] # Form the shortest palindrome return rev_s[:to_add_count] + s"},{"question":"def count_unique_participants(d: int, participants: List[int]) -> int: Returns the total number of unique participants who attended the workshop over the days. Since there's no further information, we assume all participants each day are unique. Args: d (int): The number of days the workshop runs. participants (list of int): List containing the number of participants for each day. Returns: int: The total number of unique participants. >>> count_unique_participants(5, [10, 20, 10, 10, 5]) 55 >>> count_unique_participants(3, [100, 200, 300]) 600 >>> count_unique_participants(4, [10, 0, 20, 10]) 40 >>> count_unique_participants(2, [50, 50]) 100","solution":"def count_unique_participants(d, participants): Returns the total number of unique participants who attended the workshop over the days. Since there's no further information, we assume all participants each day are unique. Args: d (int): The number of days the workshop runs. participants (list of int): List containing the number of participants for each day. Returns: int: The total number of unique participants. return sum(participants) # Input reading is assumed to be done by the calling function or environment"},{"question":"def minimum_additional_roads(n, m, roads): Determine the minimum number of additional roads required to make the entire road network connected. :param n: int - the number of cities :param m: int - the number of existing roads :param roads: List of tuples - each tuple contains two integers representing a road between two cities :return: int - the minimum number of additional roads required to connect all cities def test_minimum_additional_roads(): assert minimum_additional_roads(4, 2, [(1, 2), (3, 4)]) == 1 assert minimum_additional_roads(5, 3, [(1, 2), (2, 3), (4, 5)]) == 1 assert minimum_additional_roads(3, 3, [(1, 2), (2, 3), (1, 3)]) == 0 assert minimum_additional_roads(6, 0, []) == 5 assert minimum_additional_roads(1, 0, []) == 0 # Single city, no roads needed assert minimum_additional_roads(2, 0, []) == 1 # Two cities, no roads assert minimum_additional_roads(2, 1, [(1, 2)]) == 0 # Two cities, one road assert minimum_additional_roads(4, 3, [(1, 2), (2, 3), (3, 4)]) == 0 # Linear connection assert minimum_additional_roads(4, 1, [(2, 3)]) == 2 # One connection, need two more","solution":"def minimum_additional_roads(n, m, roads): Determine the minimum number of additional roads required to make the entire road network connected. :param n: int - the number of cities :param m: int - the number of existing roads :param roads: List of tuples - each tuple contains two integers representing a road between two cities :return: int - the minimum number of additional roads required to connect all cities if n == 1: return 0 from collections import defaultdict, deque def bfs(node, visited, graph): queue = deque([node]) visited[node] = True while queue: current = queue.popleft() for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) visited = [False] * (n+1) components = 0 for city in range(1, n+1): if not visited[city]: bfs(city, visited, graph) components += 1 return components - 1"},{"question":"def max_beauty_within_time_limit(m: int, t: int, spots: List[Tuple[int, int]]) -> int: Find the maximum beauty score from any picnic spot where the preparation time does not exceed the allowed limit. >>> max_beauty_within_time_limit(3, 10, [(7, 5), (4, 8), (9, 12)]) 7 >>> max_beauty_within_time_limit(2, 5, [(6, 7), (3, 4)]) 3 >>> max_beauty_within_time_limit(1, 3, [(5, 4)]) -1","solution":"def max_beauty_within_time_limit(m, t, spots): max_beauty = -1 for beauty, time in spots: if time <= t: if beauty > max_beauty: max_beauty = beauty return max_beauty"},{"question":"def minimum_hike_time(n: int, m: int, trails: List[str], s: int) -> int: Determine the minimum time Samantha needs to visit all landmarks and return to her starting point. The function takes in: - n: number of landmarks - m: number of undirected trails - trails: a list of strings representing the trails where each string is of the form 'a b t' indicating a trail between landmarks a and b with traversal time t - s: the starting landmark for Samantha and returns the minimum time in minutes. >>> minimum_hike_time(4, 5, [\\"1 2 4\\", \\"2 3 3\\", \\"3 4 5\\", \\"4 1 2\\", \\"1 3 6\\"], 1) 14 >>> minimum_hike_time(3, 3, [\\"1 2 2\\", \\"2 3 2\\", \\"3 1 3\\"], 2) 7","solution":"def tsp(n, m, edges, s): import itertools # Initializing adjacency matrix with a large value for non-adjacent nodes inf = float('inf') dist = [[inf] * n for _ in range(n)] for a, b, t in edges: dist[a-1][b-1] = min(dist[a-1][b-1], t) dist[b-1][a-1] = min(dist[b-1][a-1], t) # DP Table to store the minimum distance to achieve each state dp = [[inf] * n for _ in range(1 << n)] dp[1 << (s - 1)][s - 1] = 0 # Starting point for mask in range(1 << n): for u in range(n): if mask & (1 << u): for v in range(n): if mask & (1 << v) == 0 and dist[u][v] != inf: dp[mask | (1 << v)][v] = min(dp[mask | (1 << v)][v], dp[mask][u] + dist[u][v]) res = inf full_mask = (1 << n) - 1 for u in range(n): if u != (s - 1): res = min(res, dp[full_mask][u] + dist[u][s-1]) return res # Reading input def minimum_hike_time(n, m, trails, s): edges = [tuple(map(int, trail.split())) for trail in trails] return tsp(n, m, edges, s)"},{"question":"from typing import List, Tuple def max_subarray_sum(T: int, test_cases: List[Tuple[int, List[int], int]]) -> List[int]: Find the maximum sum of a subarray such that no two adjacent elements of this subarray differ by more than the given target value. Args: T: The number of test cases. test_cases: A list of tuples, each containing: - An integer n, the length of the array. - A list of n integers, the elements of the array. - An integer k, the target value. Returns: A list of integers, where each integer is the result for the corresponding test case.","solution":"def max_subarray_sum(T, test_cases): results = [] for case in test_cases: n, array, k = case max_sum = float('-inf') current_sum = 0 for i in range(n): if i == 0 or abs(array[i] - array[i-1]) <= k: current_sum += array[i] else: current_sum = array[i] max_sum = max(max_sum, current_sum) results.append(max_sum) return results"},{"question":"def min_operations_to_level_grid(n: int, m: int, grid: List[List[int]]) -> int: Returns the minimum number of operations required to level the entire grid such that all buildings have the same height. >>> min_operations_to_level_grid(2, 2, [[4, 4], [2, 2]]) 4 >>> min_operations_to_level_grid(3, 1, [[3], [2], [1]]) 3","solution":"def min_operations_to_level_grid(n, m, grid): Returns the minimum number of operations required to level the entire grid such that all buildings have the same height. min_height = min(min(row) for row in grid) total_operations = sum(sum(height - min_height for height in row) for row in grid) return total_operations"},{"question":"def maximize_sum_after_xor(n: int, arr: List[int]) -> int: Alice has a sequence of n integers, and she likes to experiment with the properties of the sequence. For her latest experiment, she wants to perform the following operation exactly once: Select a contiguous subsequence of the array and perform an XOR operation on every element of that subsequence. She wants to maximize the sum of the elements in the updated array after this operation. Help Alice find the maximum possible sum of the elements in the array after performing the described operation. >>> maximize_sum_after_xor(5, [1, 2, 3, 4, 5]) == 15 >>> maximize_sum_after_xor(3, [-1, -2, -3]) == -6 >>> maximize_sum_after_xor(1, [10]) == 10 >>> maximize_sum_after_xor(4, [-1, -2, -3, -4]) == -10 >>> maximize_sum_after_xor(5, [-1, 2, 3, -4, 5]) == 5","solution":"def maximize_sum_after_xor(n, arr): # The maximum sum possible after performing the XOR operation is the initial sum of the array. current_sum = sum(arr) return current_sum"},{"question":"def check_mirror_palindrome(s: str) -> str: Returns \\"YES\\" if the string s is a mirror palindrome, otherwise returns \\"NO\\". >>> check_mirror_palindrome(\\"AHA\\") 'YES' >>> check_mirror_palindrome(\\"CAT\\") 'NO' >>> check_mirror_palindrome(\\"WOW\\") 'YES' >>> check_mirror_palindrome(\\"OTTO\\") 'YES' >>> check_mirror_palindrome(\\"HELLO\\") 'NO'","solution":"def is_mirror_palindrome(s): mirror_letters = {'A', 'H', 'I', 'M', 'O', 'T', 'U', 'V', 'W', 'X', 'Y'} # Check if all characters in the string are mirror letters if all(char in mirror_letters for char in s): return s == s[::-1] return False def check_mirror_palindrome(s): Returns \\"YES\\" if the string s is a mirror palindrome, otherwise returns \\"NO\\" if is_mirror_palindrome(s): return \\"YES\\" else: return \\"NO\\""},{"question":"def min_possible_final_number(n: int, arr: List[int]) -> int: Determine the minimum possible final number after repeatedly removing the larger of each adjacent pair. >>> min_possible_final_number(5, [5, 3, 2, 9, 6]) 2 >>> min_possible_final_number(1, [42]) 42 >>> min_possible_final_number(4, [7, 7, 7, 7]) 7 >>> min_possible_final_number(5, [10, 8, 6, 4, 2]) 2 >>> min_possible_final_number(5, [1, 2, 3, 4, 5]) 1 >>> min_possible_final_number(3, [999999999, 1000000000, 999999998]) 999999998","solution":"def min_possible_final_number(n, arr): Returns the minimum possible final number from the array after repeatedly removing the larger of each adjacent pair. # The minimum number in the array is the smallest possible final number return min(arr)"},{"question":"def shortest_path(matrix): Find the length of the shortest path with minimal sum from the top-left to the bottom-right cell of the matrix. >>> matrix = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> shortest_path(matrix) 5 >>> matrix = [[0]] >>> shortest_path(matrix) 1 >>> matrix = [ ... [1, 2], ... [1, 1] ... ] >>> shortest_path(matrix) 3 >>> matrix = [ ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1] ... ] >>> shortest_path(matrix) 7 >>> matrix = [ ... [100, 100], ... [100, 100] ... ] >>> shortest_path(matrix) 3","solution":"def shortest_path(matrix): from heapq import heappop, heappush import sys N = len(matrix) M = len(matrix[0]) # Create a min-heap to store (cost, path_length, (i, j)) heap = [(matrix[0][0], 1, (0, 0))] # Record the minimal sum to reach each cell min_sum = [[sys.maxsize] * M for _ in range(N)] min_sum[0][0] = matrix[0][0] # Directions for moving right and down directions = [(0, 1), (1, 0)] while heap: current_sum, path_length, (i, j) = heappop(heap) # If we reach the bottom-right corner if (i, j) == (N-1, M-1): return path_length for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < N and 0 <= nj < M: new_sum = current_sum + matrix[ni][nj] if new_sum < min_sum[ni][nj]: min_sum[ni][nj] = new_sum heappush(heap, (new_sum, path_length + 1, (ni, nj))) return -1 # This line should not be reached"},{"question":"def number_of_vigilant_testers(t: int, b: int, bug_reports: List[Tuple[int, int]]) -> int: Determine the number of vigilant testers. A vigilant tester is defined as one who has found at least one bug with a severity level of 7 or higher. Parameters: t (int): Number of testers b (int): Number of bugs bug_reports (List[Tuple[int, int]]): List of bug reports where each bug report is a tuple containing (tester_id, severity) Returns: int: Number of vigilant testers Examples: >>> number_of_vigilant_testers(3, 6, [(1, 5), (2, 8), (2, 4), (3, 7), (1, 10), (3, 2)]) 3 >>> number_of_vigilant_testers(4, 5, [(1, 3), (2, 10), (2, 6), (4, 5), (4, 7)]) 2","solution":"def number_of_vigilant_testers(t, b, bug_reports): high_severity_threshold = 7 vigilant_testers = set() for tester_id, severity in bug_reports: if severity >= high_severity_threshold: vigilant_testers.add(tester_id) return len(vigilant_testers)"},{"question":"def distinct_states_sum(n: int, days: List[int], q: int, queries: List[Tuple[int, int]]) -> List[int]: Computes the sum of distinct states for each query range in days. :param n: Number of days in the period (integer) :param days: List of integers representing the state of each day :param q: Number of queries (integer) :param queries: List of tuples where each tuple represents a (l, r) range (1-based index) :return: List of integers representing the sum of distinct states for each query >>> distinct_states_sum(7, [1, 2, 1, 3, 2, 1, 2], 3, [(1, 4), (2, 5), (3, 7)]) [6, 6, 6] >>> distinct_states_sum(1, [1], 1, [(1, 1)]) [1]","solution":"def distinct_states_sum(n, days, q, queries): Computes the sum of distinct states for each query range in days. :param n: Number of days in the period (integer) :param days: List of integers representing the state of each day :param q: Number of queries (integer) :param queries: List of tuples where each tuple represents a (l, r) range (1-based index) :return: List of integers representing the sum of distinct states for each query results = [] for l, r in queries: # Convert 1-based indexing to 0-based indexing subperiod = days[l-1:r] distinct_sum = sum(set(subperiod)) results.append(distinct_sum) return results"},{"question":"def process_deforestation_events(n, m, events): Process a series of deforestation events and queries on an n x m grid representing a forest. Parameters: n (int): number of rows in the grid m (int): number of columns in the grid events (list of str): list of events, where each event is either a deforestation event in the form 'D x1 y1 x2 y2' or a query in the form 'Q x y' Returns: list of str: responses to the queries, each being \\"Deforested\\" or \\"Forest\\" pass","solution":"def process_deforestation_events(n, m, events): Process a series of deforestation events and queries on an n x m grid representing a forest. Parameters: n (int): number of rows in the grid m (int): number of columns in the grid events (list of str): list of events, where each event is either a deforestation event in the form 'D x1 y1 x2 y2' or a query in the form 'Q x y' Returns: list of str: responses to the queries, each being \\"Deforested\\" or \\"Forest\\" forest = [[True for _ in range(m)] for _ in range(n)] results = [] for event in events: parts = event.split() if parts[0] == 'D': x1, y1, x2, y2 = map(int, parts[1:]) for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): forest[i][j] = False elif parts[0] == 'Q': x, y = map(int, parts[1:]) results.append(\\"Deforested\\" if not forest[x - 1][y - 1] else \\"Forest\\") return results"},{"question":"def determine_winner(test_cases): Given a list of test cases, determine the winner of the game for each case. Each test case contains a number of elements in the array and the array itself. Both players play optimally with Riya moving first. Args: test_cases: List of tuples where each tuple contains: - an integer n: number of elements in the array (2 <= n <= 100) - a list of integers representing the array (-10^3 <= ai <= 10^3) Returns: List of strings where each string is either \\"Riya\\" or \\"Sam\\" indicating the winner. >>> determine_winner([(4, [1, 2, 3, 4]), (2, [-1, -2]), (6, [10, 20, 30, 40, 50, 60])]) ['Sam', 'Sam', 'Sam'] >>> determine_winner([(3, [1, 2, 3]), (5, [10, 20, 30, 40, 50]), (7, [-1, -2, -3, -4, -5, -6, -7])]) ['Riya', 'Riya', 'Riya'] >>> determine_winner([(4, [1, 2, 3, 4]), (3, [10, 20, 30]), (5, [1, 2, 3, 4, 5]), (2, [10, 20])]) ['Sam', 'Riya', 'Riya', 'Sam'] >>> determine_winner([(3, [5, 6, 7])]) ['Riya'] >>> determine_winner([(2, [5, 6])]) ['Sam'] results = [] for n, array in test_cases: # Determine winner based on the number of elements return results","solution":"def determine_winner(test_cases): results = [] for n, array in test_cases: # If the number of elements is even, Sam wins (Riya goes first) # If the number of elements is odd, Riya wins (Riya goes first) if n % 2 == 0: results.append(\\"Sam\\") else: results.append(\\"Riya\\") return results"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Returns the length of the longest palindromic subsequence in the given string s. >>> longest_palindromic_subsequence(\\"bbbab\\") 4 >>> longest_palindromic_subsequence(\\"cbbd\\") 2 >>> longest_palindromic_subsequence(\\"a\\") 1 >>> longest_palindromic_subsequence(\\"abcdef\\") 1 >>> longest_palindromic_subsequence(\\"aaaa\\") 4 >>> longest_palindromic_subsequence(\\"abccba\\") 6 >>> longest_palindromic_subsequence(\\"character\\") 5 >>> longest_palindromic_subsequence(\\"\\") 0 >>> longest_palindromic_subsequence(\\"a\\" * 1000) 1000","solution":"def longest_palindromic_subsequence(s): Returns the length of the longest palindromic subsequence in the given string s. n = len(s) if n == 0: return 0 # Create a 2D array to store the length of longest palindromic subsequence dp = [[0] * n for _ in range(n)] # Every single character is a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Build the dp array for length in range(2, n + 1): # length of the substring for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: if length == 2: dp[i][j] = 2 else: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1] # Example usage: # s = input().strip() # print(longest_palindromic_subsequence(s))"},{"question":"def ninja_mission(N: int, sensors: List[Tuple[int, int, int]], Ax: int, Ay: int, Bx: int, By: int) -> str: Determine if Sakura can reach from the starting point (Ax, Ay) to the destination point (Bx, By) without entering the detection range of any sensor. Args: N : int : The number of sensors. sensors : List[Tuple[int, int, int]] : A list of tuples, where each tuple contains three integers xi, yi, and ri, which describe the coordinates of the center and the radius of the i-th sensor. Ax : int : x-coordinate of the starting point. Ay : int : y-coordinate of the starting point. Bx : int : x-coordinate of the destination point. By : int : y-coordinate of the destination point. Returns: str : \\"YES\\" if Sakura can reach the destination without being detected by any sensor, otherwise \\"NO\\". Examples: >>> ninja_mission(3, [(0, 0, 5), (10, 10, 3), (-5, -5, 2)], -20, -20, 20, 20) \\"NO\\" >>> ninja_mission(2, [(0, 0, 5), (10, 10, 3)], -20, -20, -10, -10) \\"YES\\"","solution":"import math def is_detected(xi, yi, ri, Ax, Ay, Bx, By): Check if the line segment from (Ax, Ay) to (Bx, By) intersects with the circle centered at (xi, yi) with radius ri. # Vector AB ABx = Bx - Ax ABy = By - Ay # Vector AP APx = xi - Ax APy = yi - Ay # Project vector AP onto AB to find the point D on line segment AB closest to the circle center (xi, yi) t = (APx * ABx + APy * ABy) / (ABx * ABx + ABy * ABy) # Limit t to be within the segment [0, 1] t = max(0, min(1, t)) # Coordinates of D Dx = Ax + t * ABx Dy = Ay + t * ABy # Distance from D to the circle center distSq = (xi - Dx) ** 2 + (yi - Dy) ** 2 return distSq <= ri ** 2 def can_reach_destination(N, sensors, Ax, Ay, Bx, By): for x, y, r in sensors: if is_detected(x, y, r, Ax, Ay, Bx, By): return \\"NO\\" return \\"YES\\" def ninja_mission(N, sensors, Ax, Ay, Bx, By): return can_reach_destination(N, sensors, Ax, Ay, Bx, By)"},{"question":"from typing import List def max_product(nums: List[int]) -> int: Finds the maximum product of any two integers in the list. Parameters: nums (List[int]): List of integers Returns: int: Maximum product of any two integers in the list >>> max_product([3, 4, 5, 2]) == 20 >>> max_product([-10, -20, 5, 1]) == 200 >>> max_product([-3, -4, -5, -2]) == 20 >>> max_product([10000, -10000, 5, 9999]) == 99990000 >>> max_product([1, 2]) == 2 >>> max_product([-1, -2]) == 2 >>> max_product([0, -3, 5, -1000]) == 3000","solution":"from typing import List def max_product(nums: List[int]) -> int: Finds the maximum product of any two integers in the list. Parameters: nums (List[int]): List of integers Returns: int: Maximum product of any two integers in the list if len(nums) < 2: raise ValueError(\\"List must contain at least two elements\\") max1 = max2 = float('-inf') min1 = min2 = float('inf') for num in nums: # Update maximum values if num > max1: max2 = max1 max1 = num elif num > max2: max2 = num # Update minimum values if num < min1: min2 = min1 min1 = num elif num < min2: min2 = num return max(max1 * max2, min1 * min2)"},{"question":"def max_contiguous_subarray_length(array: List[int]) -> int: Determine the maximum length of any contiguous subarray where the difference between the maximum and minimum values does not exceed 1. >>> max_contiguous_subarray_length([4, 4, 5, 3, 3]) 3 >>> max_contiguous_subarray_length([1, 2, 2, 2, 3, 1]) 4 >>> max_contiguous_subarray_length([1]) 1 >>> max_contiguous_subarray_length([1, 1, 1, 1, 1, 1, 1]) 7 >>> max_contiguous_subarray_length([1, 2, 3, 4, 5, 6]) 2 >>> max_contiguous_subarray_length([]) 0","solution":"def max_contiguous_subarray_length(array): if not array: return 0 n = len(array) max_length = 1 left = 0 while left < n: max_val = min_val = array[left] right = left while right < n and max(max_val, array[right]) - min(min_val, array[right]) <= 1: max_val = max(max_val, array[right]) min_val = min(min_val, array[right]) right += 1 max_length = max(max_length, right - left) left += 1 return max_length"},{"question":"def max_non_adjacent_sum(arr: List[int]) -> int: Given an integer array 'arr' of length 'n', find the maximum sum of a subarray with the constraint that no two elements in the subarray should be adjacent in the original array. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([4, 1, 1, 4]) 8 >>> max_non_adjacent_sum([5]) 5 >>> max_non_adjacent_sum([5, 3]) 5 >>> max_non_adjacent_sum([10000, -10000, 10000, -10000, 10000]) 30000 >>> max_non_adjacent_sum([-3, -2, -5, -10, -7]) -2 >>> max_non_adjacent_sum([-3, 2, -3, 2, -3, 2]) 6","solution":"def max_non_adjacent_sum(arr): n = len(arr) if n == 0: return 0 if n == 1: return arr[0] # Initialize dp array dp = [0] * n dp[0] = arr[0] dp[1] = max(arr[0], arr[1]) for i in range(2, n): dp[i] = max(dp[i-1], arr[i] + dp[i-2]) return dp[n-1] # Example usage print(max_non_adjacent_sum([3, 2, 5, 10, 7])) # Output: 15 print(max_non_adjacent_sum([4, 1, 1, 4])) # Output: 8"},{"question":"from typing import List def largest_park_area(grid: List[List[str]]) -> int: Returns the size of the largest contiguous area of park cells ('*') in the given grid. pass def parse_input(input_str: str) -> List[List[str]]: Parses the input string into the grid representation. pass if __name__ == \\"__main__\\": import sys input_str = sys.stdin.read().strip() grid = parse_input(input_str) print(largest_park_area(grid))","solution":"def largest_park_area(grid): Returns the size of the largest contiguous area of park cells ('*') in the given grid. n = len(grid) m = len(grid[0]) def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] != '*': return 0 # Mark this cell as visited grid[x][y] = '#' area = 1 # Visit all four adjacent cells area += dfs(x - 1, y) area += dfs(x + 1, y) area += dfs(x, y - 1) area += dfs(x, y + 1) return area max_area = 0 for i in range(n): for j in range(m): if grid[i][j] == '*': max_area = max(max_area, dfs(i, j)) return max_area def parse_input(input_str): lines = input_str.split('n') n, m = map(int, lines[0].split()) grid = [list(line) for line in lines[1:n+1]] return grid"},{"question":"def verify_revenue_calculations(n: int, sales_data: List[Tuple[int, int, int]]) -> List[str]: Determines if the recorded revenue for each item is correct. Parameters: n (int): The number of items sold. sales_data (list of tuples): Each tuple contains three integers P (price per unit), U (units sold), and R (recorded revenue). Returns: list of str: Each string is either \\"CORRECT\\" or \\"INCORRECT\\" for corresponding sales data. >>> verify_revenue_calculations(4, [(10, 5, 50), (20, 3, 60), (15, 7, 105), (30, 2, 70)]) ['CORRECT', 'CORRECT', 'CORRECT', 'INCORRECT'] >>> verify_revenue_calculations(3, [(10, 5, 50), (20, 2, 40), (8, 12, 96)]) ['CORRECT', 'CORRECT', 'CORRECT']","solution":"def verify_revenue_calculations(n, sales_data): Determines if the recorded revenue for each item is correct. Parameters: n (int): The number of items sold. sales_data (list of tuples): Each tuple contains three integers P (price per unit), U (units sold), and R (recorded revenue). Returns: list of str: Each string is either \\"CORRECT\\" or \\"INCORRECT\\" for corresponding sales data. results = [] for data in sales_data: P, U, R = data if P * U == R: results.append(\\"CORRECT\\") else: results.append(\\"INCORRECT\\") return results # Example usage: n = 4 sales_data = [ (10, 5, 50), (20, 3, 60), (15, 7, 105), (30, 2, 70) ] print(verify_revenue_calculations(n, sales_data))"},{"question":"import math def num_paths(patterns): This function takes a list of patterns with 'R' and 'U', and returns the number of distinct paths for each pattern. def solve(input_data): This function reads the input data, processes each test case, and prints the results. # Test cases import io from contextlib import redirect_stdout def test_num_paths(): assert num_paths(['RRU']) == [3] assert num_paths(['RUURR', 'RURU']) == [10, 6] assert num_paths(['R', 'U', 'RRUU', 'UUUURRRR']) == [1, 1, 6, 70] def test_solve(): input_data = 3 RRU RUURR RURU expected_output = \\"3n10n6n\\" f = io.StringIO() with redirect_stdout(f): solve(input_data) out = f.getvalue() assert out == expected_output def test_edge_cases(): assert num_paths(['']) == [1] assert num_paths(['R', 'U']) == [1, 1] assert num_paths(['RRUUUUU']) == [21] input_data = 3 R U RRUUUUU expected_output = \\"1n1n21n\\" f = io.StringIO() with redirect_stdout(f): solve(input_data) out = f.getvalue() assert out == expected_output","solution":"import math def num_paths(patterns): This function takes a list of patterns with 'R' and 'U', and returns the number of distinct paths for each pattern. results = [] for pattern in patterns: r_count = pattern.count('R') u_count = pattern.count('U') # Compute the binomial coefficient (r_count + u_count) choose (r_count or u_count) paths = math.comb(r_count + u_count, r_count) results.append(paths) return results def solve(input_data): This function reads the input data, processes each test case, and prints the results. lines = input_data.strip().splitlines() t = int(lines[0]) patterns = [lines[i] for i in range(1, t + 1)] results = num_paths(patterns) for result in results: print(result)"},{"question":"def update_inventory(n, m, quantities, operations): Apply a series of operations to update inventory quantities. Args: n (int): Number of items in the inventory. m (int): Number of operations. quantities (List[int]): Initial quantities of the items. operations (List[Tuple[int, int, int, int]]): List of operations to be applied. Returns: List[int]: The final quantities of the items after all operations are applied. Operations can be of two types: 1. Update: For a range of items, update each item's quantity by a specified amount. 2. Set: For a range of items, set each item's quantity to a specified amount. Example: >>> n, m = 5, 4 >>> quantities = [10, 20, 30, 40, 50] >>> operations = [(1, 1, 3, 5), (2, 2, 4, 15), (1, 3, 5, 10), (2, 1, 5, 25)] >>> update_inventory(n, m, quantities, operations) [25, 25, 25, 25, 25] pass def main(n, m, quantities, operations): updated_quantities = update_inventory(n, m, quantities, operations) return \\" \\".join(map(str, updated_quantities)) # Example usage: # n, m = 5, 4 # quantities = [10, 20, 30, 40, 50] # operations = [(1, 1, 3, 5), (2, 2, 4, 15), (1, 3, 5, 10), (2, 1, 5, 25)] # print(main(n, m, quantities, operations)) # Output: 25 25 25 25 25 # Unit Test def test_example_1(): n, m = 5, 4 quantities = [10, 20, 30, 40, 50] operations = [(1, 1, 3, 5), (2, 2, 4, 15), (1, 3, 5, 10), (2, 1, 5, 25)] assert main(n, m, quantities, operations) == \\"25 25 25 25 25\\" def test_example_2(): n, m = 3, 2 quantities = [5, 10, 15] operations = [(1, 1, 2, 7), (2, 1, 3, 10)] assert main(n, m, quantities, operations) == \\"10 10 10\\" def test_single_update(): n, m = 3, 1 quantities = [1, 2, 3] operations = [(1, 1, 3, 2)] assert main(n, m, quantities, operations) == \\"3 4 5\\" def test_single_set(): n, m = 4, 1 quantities = [1, 2, 3, 4] operations = [(2, 2, 4, 5)] assert main(n, m, quantities, operations) == \\"1 5 5 5\\" def test_mixed_operations(): n, m = 3, 4 quantities = [0, 0, 0] operations = [(2, 1, 1, 10), (1, 2, 3, 5), (2, 3, 3, 20), (1, 2, 3, 2)] assert main(n, m, quantities, operations) == \\"10 7 22\\"","solution":"def update_inventory(n, m, quantities, operations): # Apply the operations in the order given for operation in operations: op_type, li, ri, value = operation li -= 1 ri -= 1 if op_type == 1: for i in range(li, ri + 1): quantities[i] += value elif op_type == 2: for i in range(li, ri + 1): quantities[i] = value return quantities def main(n, m, quantities, operations): updated_quantities = update_inventory(n, m, quantities, operations) return \\" \\".join(map(str, updated_quantities)) # Example usage: # n, m = 5, 4 # quantities = [10, 20, 30, 40, 50] # operations = [(1, 1, 3, 5), (2, 2, 4, 15), (1, 3, 5, 10), (2, 1, 5, 25)] # print(main(n, m, quantities, operations)) # Output: 25 25 25 25 25"},{"question":"def min_delivery_time(n: int, c: int, packages: List[int]) -> int: Minimize the total delivery time required to deliver all packages. >>> min_delivery_time(3, 3, [3, 3, 3]) 6 >>> min_delivery_time(1, 5, [5]) 2 >>> min_delivery_time(1, 5, [3]) 2 >>> min_delivery_time(1, 3, [7]) 6 >>> min_delivery_time(4, 2, [2, 2, 4, 5]) 14 >>> min_delivery_time(3, 3, [0, 0, 0]) 0 >>> min_delivery_time(100000, 1000, [10000] * 100000) 2000000","solution":"def min_delivery_time(n, c, packages): total_deliveries = 0 for i in range(n): deliveries_for_warehouse = (packages[i] + c - 1) // c # Ceil value of packages[i] / c total_deliveries += deliveries_for_warehouse # Count each trip as one unit return total_deliveries * 2 # Each delivery is a round trip from the main hub"},{"question":"def modify_string(s: str) -> str: Modify the string so that no two adjacent characters are the same by replacing some (possibly none) characters with any lowercase English letter. :param s: Input string consisting of lowercase English letters only. :type s: str :return: Modified string with no two adjacent characters being the same. :rtype: str Examples: >>> modify_string(\\"aaabbb\\") 'ababab' >>> modify_string(\\"aaaa\\") 'abab' >>> modify_string(\\"a\\") 'a'","solution":"def modify_string(s): Modifies the string such that no two adjacent characters are the same. If there are multiple possible answers, any of them can be returned. :param s: str - Input string composed of lowercase English letters. :return: str - Modified string with no two adjacent characters being the same. n = len(s) if n == 1: return s s_list = list(s) for i in range(n): if i > 0 and s_list[i] == s_list[i - 1]: for char in 'abcdefghijklmnopqrstuvwxyz': if (i == n - 1 or char != s_list[i + 1]) and char != s_list[i - 1]: s_list[i] = char break return ''.join(s_list)"},{"question":"from typing import List, Tuple def spread_rumor(m: int, n: int, k: int, initial_positions: List[Tuple[int, int]]) -> int: Determine the number of days it will take for the rumor to spread to every house in the town. >>> spread_rumor(3, 3, 1, [(0, 0)]) == 4 >>> spread_rumor(2, 2, 2, [(0, 0), (1, 1)]) == 1 >>> spread_rumor(2, 3, 1, [(0, 1)]) == 2 >>> spread_rumor(2, 2, 4, [(0, 0), (0, 1), (1, 0), (1, 1)]) == 0 >>> spread_rumor(3, 3, 1, [(1, 1)]) == 2 >>> spread_rumor(1, 1, 1, [(0, 0)]) == 0 >>> spread_rumor(1, 5, 1, [(0, 0)]) == 4 >>> spread_rumor(5, 1, 1, [(0, 0)]) == 4 >>> spread_rumor(10, 10, 1, [(0, 0)]) == 18","solution":"from collections import deque def spread_rumor(m, n, k, initial_positions): grid = [[-1] * n for _ in range(m)] queue = deque() for r, c in initial_positions: grid[r][c] = 0 queue.append((r, c)) # Directions for movement: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_days = 0 while queue: x, y = queue.popleft() for dx, dy in directions: new_x, new_y = x + dx, y + dy if 0 <= new_x < m and 0 <= new_y < n and grid[new_x][new_y] == -1: grid[new_x][new_y] = grid[x][y] + 1 max_days = max(max_days, grid[new_x][new_y]) queue.append((new_x, new_y)) for row in grid: if -1 in row: return -1 return max_days"},{"question":"def minimize_max_workload(n:int, k:int, tasks:List[int]) -> int: Determine the best way to distribute tasks to employees such that the maximum time any single employee spends on their assigned tasks is minimized. >>> minimize_max_workload(5, 2, [4, 3, 7, 8, 9]) 17 >>> minimize_max_workload(3, 3, [2, 15, 10]) 15 >>> minimize_max_workload(6, 3, [1, 2, 3, 4, 5, 6]) 9","solution":"def is_possible(tasks, k, max_load): current_sum = 0 required_workers = 1 for task in tasks: if current_sum + task > max_load: required_workers += 1 current_sum = task if required_workers > k: return False else: current_sum += task return True def minimize_max_workload(n, k, tasks): left = max(tasks) right = sum(tasks) while left < right: mid = (left + right) // 2 if is_possible(tasks, k, mid): right = mid else: left = mid + 1 return left"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Returns the length of the longest palindromic substring in the input string s. A palindrome is a sequence of characters that reads the same backward as forward. Examples: >>> longest_palindromic_substring_length(\\"babad\\") 3 >>> longest_palindromic_substring_length(\\"cbbd\\") 2 >>> longest_palindromic_substring_length(\\"aabcdcb\\") 5","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring in the input string s. n = len(s) if n == 0: return 0 # Create a 2D array to store whether s[i:j+1] is a palindrome dp = [[False] * n for _ in range(n)] max_length = 1 # At least every single character is a palindrome for i in range(n): dp[i][i] = True start = 0 # Starting index of the longest palindrome found for length in range(2, n+1): # Current length of the substring for i in range(n - length + 1): j = i + length - 1 if length == 2: dp[i][j] = (s[i] == s[j]) else: dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1] # Update the maximum length if a longer palindrome is found if dp[i][j] and length > max_length: max_length = length start = i return max_length"},{"question":"import math from typing import List def is_prime(n: int) -> bool: Determine if a number is a prime number. >>> is_prime(2) True >>> is_prime(4) False if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def prime_sum(sequence: List[int]) -> int: Calculate the prime sum of a sequence of non-negative integers. >>> prime_sum([3, 4, 7, 6, 5, 11]) 26 >>> prime_sum([1, 2, 3, 4, 5]) 10 >>> prime_sum([6, 8, 10]) 0 return sum(x for x in sequence if is_prime(x))","solution":"import math def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def prime_sum(sequence): return sum(x for x in sequence if is_prime(x))"},{"question":"from itertools import permutations from typing import List def is_palindrome(s: str) -> bool: return s == s[::-1] def palindrome_permutations(s: str) -> List[str]: Returns all distinct palindromic permutations of the input string. If no such permutations exist, returns [\\"None\\"]. >>> palindrome_permutations(\\"aabb\\") ['abba', 'baab'] >>> palindrome_permutations(\\"abc\\") ['None']","solution":"from itertools import permutations def is_palindrome(s): return s == s[::-1] def palindrome_permutations(s): Returns all distinct palindromic permutations of the input string. If no such permutations exist, returns [\\"None\\"]. unique_permutations = set(permutations(s)) palindromes = set(''.join(p) for p in unique_permutations if is_palindrome(p)) if not palindromes: return [\\"None\\"] return sorted(list(palindromes))"},{"question":"from typing import List def min_cost_path(grid: List[List[int]]) -> int: Calculate the minimum cost path from the top-left corner to the bottom-right corner of a grid. >>> grid = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> min_cost_path(grid) 7 >>> grid = [ ... [1, 2], ... [4, 5] ... ] >>> min_cost_path(grid) 8 pass def process_grid_input(input_lines: List[str]) -> List[int]: Process multiple test case inputs for the grid cost problem. >>> input_lines = [ ... \\"3 3\\", ... \\"1 3 1\\", ... \\"1 5 1\\", ... \\"4 2 1\\", ... \\"2 2\\", ... \\"1 2\\", ... \\"4 5\\", ... \\"0 0\\" ... ] >>> process_grid_input(input_lines) [7, 8] pass","solution":"import heapq def min_cost_path(grid): M = len(grid) N = len(grid[0]) # Dijkstra's algorithm using a min-heap priority queue directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] pq = [(grid[0][0], 0, 0)] visited = [[False] * N for _ in range(M)] visited[0][0] = True while pq: cost, x, y = heapq.heappop(pq) if x == M-1 and y == N-1: return cost for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and not visited[nx][ny]: visited[nx][ny] = True heapq.heappush(pq, (cost + grid[nx][ny], nx, ny)) return float('inf') def process_grid_input(input_lines): index = 0 results = [] while index < len(input_lines): M, N = map(int, input_lines[index].split()) if M == 0 and N == 0: break grid = [] for i in range(M): index += 1 grid.append(list(map(int, input_lines[index].split()))) index += 1 results.append(min_cost_path(grid)) return results"},{"question":"from typing import List, Tuple def tsp(adj_matrix: List[List[int]]) -> int: Calculate the minimum delivery cost to cover all points starting from the first node. :param adj_matrix: A list of lists representing the adjacency matrix of costs. :return: The minimum cost to visit all nodes starting from the first node. Example: >>> tsp([ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ]) 80 >>> tsp([ ... [0, 29, 20], ... [29, 0, 15], ... [20, 15, 0] ... ]) 64 def parse_input(input_data: str) -> List[Tuple[int, List[List[int]]]]: Parse the input data into a list of problems, where each problem is a tuple containing the number of nodes and the adjacency matrix. :param input_data: A string representing the input data. :return: A list of tuples, each containing an integer and a list of lists. Example: >>> parse_input(''' ... 4 ... 0 10 15 20 ... 10 0 35 25 ... 15 35 0 30 ... 20 25 30 0 ... 3 ... 0 29 20 ... 29 0 15 ... 20 15 0 ... 0 ... ''') [(4, [ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ]), ... (3, [ ... [0, 29, 20], ... [29, 0, 15], ... [20, 15, 0] ... ])] def solve_tsp(problems: List[Tuple[int, List[List[int]]]]) -> List[int]: Solve the TSP problem for each problem in the list. :param problems: A list of problems where each problem is a tuple containing the number of nodes and the adjacency matrix. :return: A list of integers representing the minimum costs for each problem. Example: >>> solve_tsp([(4, [ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ]), ... (3, [ ... [0, 29, 20], ... [29, 0, 15], ... [20, 15, 0] ... ])]) [80, 64] def main(input_data: str) -> None: problems = parse_input(input_data) results = solve_tsp(problems) for result in results: print(result) # Unit Tests def test_tsp(): adj_matrix_1 = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] assert tsp(adj_matrix_1) == 80 adj_matrix_2 = [ [0, 29, 20], [29, 0, 15], [20, 15, 0] ] assert tsp(adj_matrix_2) == 64 def test_parse_input(): input_data = '''4 0 10 15 20 10 0 35 25 15 35 0 30 20 25 30 0 3 0 29 20 29 0 15 20 15 0 0 ''' expected_output = [ (4, [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ]), (3, [ [0, 29, 20], [29, 0, 15], [20, 15, 0] ]) ] assert parse_input(input_data) == expected_output def test_solve_tsp(): problems = [ (4, [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ]), (3, [ [0, 29, 20], [29, 0, 15], [20, 15, 0] ]) ] assert solve_tsp(problems) == [80, 64] if __name__ == \\"__main__\\": test_tsp() test_parse_input() test_solve_tsp()","solution":"from itertools import permutations def tsp(adj_matrix): n = len(adj_matrix) nodes = list(range(n)) min_cost = float('inf') # Create all permutations of nodes except the starting node 0 for perm in permutations(nodes[1:]): current_cost = adj_matrix[0][perm[0]] for i in range(len(perm) - 1): current_cost += adj_matrix[perm[i]][perm[i+1]] current_cost += adj_matrix[perm[-1]][0] if current_cost < min_cost: min_cost = current_cost return min_cost def solve_tsp(problems): results = [] for problem in problems: n = problem[0] if n == 0: break adj_matrix = problem[1] results.append(tsp(adj_matrix)) return results def parse_input(input_data): split_data = input_data.strip().split('n') index = 0 problems = [] while index < len(split_data): n = int(split_data[index]) if n == 0: break adj_matrix = [] for i in range(n): index += 1 row = list(map(int, split_data[index].split())) adj_matrix.append(row) problems.append((n, adj_matrix)) index += 1 return problems def main(input_data): problems = parse_input(input_data) results = solve_tsp(problems) for result in results: print(result)"},{"question":"def endurance_marathon_winner(n: int, energy_requirements: List[int], E_Alicia: int, E_Bob: int) -> str: Determine whether Alicia or Bob will win the endurance marathon if both participants follow the optimal strategy for energy allocation. Args: n (int): Number of tasks. energy_requirements (List[int]): List of energy requirements for each task. E_Alicia (int): Total energy available to Alicia. E_Bob (int): Total energy available to Bob. Returns: str: \\"Alicia\\" if Alicia wins, \\"Bob\\" if Bob wins, and \\"Tie\\" if it's a tie. >>> endurance_marathon_winner(5, [1, 2, 3, 4, 5], 10, 12) 'Bob' >>> endurance_marathon_winner(3, [2, 2, 2], 6, 6) 'Tie' >>> endurance_marathon_winner(3, [2, 2, 2], 20, 5) 'Alicia' >>> endurance_marathon_winner(3, [2, 2, 2], 5, 20) 'Bob' from solution import endurance_marathon_winner def test_basic_scenario(): assert endurance_marathon_winner(5, [1, 2, 3, 4, 5], 10, 12) == \\"Bob\\" def test_case_tie_with_more_remaining_energy_alicia(): assert endurance_marathon_winner(3, [2, 2, 2], 6, 6) == \\"Tie\\" def test_case_tie_with_more_remaining_energy_bob(): assert endurance_marathon_winner(3, [2, 2, 2], 7, 7) == \\"Tie\\" def test_different_tasks_numbers(): assert endurance_marathon_winner(4, [1, 2, 3, 10], 11, 12) == \\"Bob\\" def test_alicia_wins_outright(): assert endurance_marathon_winner(3, [2, 2, 2], 20, 5) == \\"Alicia\\" def test_bob_wins_outright(): assert endurance_marathon_winner(3, [2, 2, 2], 5, 20) == \\"Bob\\"","solution":"def endurance_marathon_winner(n, energy_requirements, E_Alicia, E_Bob): energy_requirements.sort() def max_tasks_and_remaining_energy(E_total): tasks_completed = 0 remaining_energy = E_total for energy in energy_requirements: if remaining_energy >= energy: tasks_completed += 1 remaining_energy -= energy else: break return tasks_completed, remaining_energy alicia_tasks, alicia_energy_left = max_tasks_and_remaining_energy(E_Alicia) bob_tasks, bob_energy_left = max_tasks_and_remaining_energy(E_Bob) if alicia_tasks > bob_tasks: return \\"Alicia\\" elif bob_tasks > alicia_tasks: return \\"Bob\\" else: if alicia_energy_left > bob_energy_left: return \\"Alicia\\" elif bob_energy_left > alicia_energy_left: return \\"Bob\\" else: return \\"Tie\\""},{"question":"def max_consecutive_non_decreasing_days(temperatures: List[int]) -> int: Returns the maximum number of consecutive days with non-decreasing temperatures. :param temperatures: List of integers representing temperatures recorded daily. :return: Integer representing the maximum number of consecutive non-decreasing days. >>> max_consecutive_non_decreasing_days([2, 3, 3, -1, 0, 1, 2]) 4 >>> max_consecutive_non_decreasing_days([5, 4, 3, 2, 1]) 1","solution":"def max_consecutive_non_decreasing_days(temperatures): Returns the maximum number of consecutive days with non-decreasing temperatures. :param temperatures: List of integers representing temperatures recorded daily. :return: Integer representing the maximum number of consecutive non-decreasing days. max_count = 1 current_count = 1 for i in range(1, len(temperatures)): if temperatures[i] >= temperatures[i - 1]: current_count += 1 max_count = max(max_count, current_count) else: current_count = 1 return max_count"},{"question":"def tribonacci(n: int) -> int: Given an integer n, find the n-th Tribonacci number Tn. The Tribonacci numbers are defined as follows: - T0 = 0 - T1 = 1 - T2 = 1 - Tn = Tn-1 + Tn-2 + Tn-3 for n >= 3 >>> tribonacci(0) 0 >>> tribonacci(1) 1 >>> tribonacci(2) 1 >>> tribonacci(4) 4 >>> tribonacci(10) 149","solution":"def tribonacci(n): Returns the n-th Tribonacci number. if n == 0: return 0 elif n == 1 or n == 2: return 1 t0, t1, t2 = 0, 1, 1 for i in range(3, n + 1): t3 = t0 + t1 + t2 t0, t1, t2 = t1, t2, t3 return t3"},{"question":"def palindrome_game_winner(t: int, test_cases: List[str]) -> List[str]: Determine the winner of the Palindrome Substring Game for each test case. >>> palindrome_game_winner(1, [\\"aba\\"]) [\\"Alice\\"] >>> palindrome_game_winner(1, [\\"aa\\"]) [\\"Bob\\"] >>> palindrome_game_winner(3, [\\"ababa\\", \\"abacdcaba\\", \\"aa\\"]) [\\"Alice\\", \\"Alice\\", \\"Bob\\"]","solution":"def palindrome_game_winner(t, test_cases): results = [] def is_palindrome(s): return s == s[::-1] for s in test_cases: if is_palindrome(s): if len(s) % 2 == 1: results.append(\\"Alice\\") else: results.append(\\"Bob\\") else: results.append(\\"Alice\\") return results"},{"question":"def third_largest_unique_number(nums: List[int]) -> int: Returns the third largest unique number in the list. If the list contains fewer than three unique numbers, return the largest number. >>> third_largest_unique_number([5, 3, 9, 5, 3, 9, 1, 7]) == 5 >>> third_largest_unique_number([1, 2, 2]) == 2 >>> third_largest_unique_number([10]) == 10 >>> third_largest_unique_number([1, 1, 1, 2, 2, 2]) == 2 >>> third_largest_unique_number([4, 6, 4, 7, 6, 7, 5]) == 5 >>> third_largest_unique_number([-1, -2, -3, -1, -2, -3]) == -3 >>> third_largest_unique_number(list(range(-100, 101))) == 98 >>> third_largest_unique_number([3, 3, 3, 3, 3]) == 3","solution":"def third_largest_unique_number(nums): Returns the third largest unique number in the list. If the list contains fewer than three unique numbers, return the largest number. unique_nums = list(set(nums)) # Remove duplicates unique_nums.sort(reverse=True) # Sort in descending order if len(unique_nums) < 3: return unique_nums[0] return unique_nums[2]"},{"question":"def tickets_available(tickets: List[int], requests: List[Tuple[int, int]]) -> List[str]: Determines if there is at least one ticket in the available tickets list that falls within the specified range for each purchase request. Parameters: tickets (list): A list of available ticket IDs. requests (list): A list of tuples, each containing two integers (low, high) representing the inclusive range for a purchase request. Returns: list: A list of strings \\"YES\\" or \\"NO\\" for each request. results = [] ticket_set = set(tickets) for low, high in requests: found = \\"NO\\" for ticket in ticket_set: if low <= ticket <= high: found = \\"YES\\" break results.append(found) return results def test_tickets_available(): assert tickets_available([1, 3, 5, 7, 9], [(0, 2), (4, 6), (8, 10)]) == [\\"YES\\", \\"YES\\", \\"YES\\"] assert tickets_available([2, 4, 6, 8], [(1, 3), (5, 7), (9, 11)]) == [\\"YES\\", \\"YES\\", \\"NO\\"] assert tickets_available([100], [(0, 99), (100, 100), (101, 200)]) == [\\"NO\\", \\"YES\\", \\"NO\\"] assert tickets_available([1000000000], [(999999999, 1000000000)]) == [\\"YES\\"] assert tickets_available([1, 2, 3], [(1, 1), (2, 2), (3, 3), (0, 0)]) == [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] def test_empty_requests(): assert tickets_available([1, 3, 5], []) == [] def test_no_available_tickets(): assert tickets_available([], [(0, 10), (5, 5), (1000, 2000)]) == [\\"NO\\", \\"NO\\", \\"NO\\"]","solution":"def tickets_available(tickets, requests): Determines if there is at least one ticket in the available tickets list that falls within the specified range for each purchase request. Parameters: tickets (list): A list of available ticket IDs. requests (list): A list of tuples, each containing two integers (low, high) representing the inclusive range for a purchase request. Returns: list: A list of strings \\"YES\\" or \\"NO\\" for each request. results = [] ticket_set = set(tickets) for low, high in requests: found = \\"NO\\" for ticket in ticket_set: if low <= ticket <= high: found = \\"YES\\" break results.append(found) return results # Example usage tickets = [1, 3, 5, 7, 9] requests = [(0, 2), (4, 6), (8, 10)] print(tickets_available(tickets, requests)) # Outputs: ['YES', 'YES', 'YES']"},{"question":"from typing import List, Tuple def min_difficulty_level(tasks: List[int], K: int) -> int: Returns the minimum difficulty level a task needs to have so that Chef has to complete at least K different tasks from the list. If it's impossible, returns -1. >>> min_difficulty_level([1, 2, 3, 4, 5], 3) 3 >>> min_difficulty_level([6, 7, 8, 9], 5) -1 >>> min_difficulty_level([5, 1, 3, 4, 2], 2) 2 >>> min_difficulty_level([10, 9, 8, 7, 6], 1) 6 >>> min_difficulty_level([10, 9, 8, 7, 6], 5) 10 pass def solve_task_list(T: int, task_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Solves the given task for the list of test cases. >>> cases = [ ... (5, 3, [1, 2, 3, 4, 5]), ... (4, 5, [6, 7, 8, 9]), ... (5, 1, [7, 10, 4, 3, 2]), ... (2, 2, [1, 2]), ... (3, 3, [5, 5, 5]), ... ] >>> expected_results = [3, -1, 2, 2, 5] >>> solve_task_list(5, cases) [3, -1, 2, 2, 5] pass","solution":"def min_difficulty_level(tasks, K): Returns the minimum difficulty level a task needs to have so that Chef has to complete at least K different tasks from the list. If it's impossible, returns -1. tasks.sort() if len(tasks) < K: return -1 return tasks[K-1] def solve_task_list(T, task_cases): results = [] for case in task_cases: N, K, tasks = case result = min_difficulty_level(tasks, K) results.append(result) return results"},{"question":"def unique_paths(n: int, m: int, k: int, obstacles: List[Tuple[int, int]]) -> int: Calculate the number of unique paths from the bottom-left to the top-right corner of the grid. Parameters: n (int): number of rows in the grid. m (int): number of columns in the grid. k (int): number of obstacles. obstacles (List[Tuple[int, int]]): list of coordinates representing the position of obstacles. Returns: int: the number of unique paths from (1,1) to (n,m). Examples: >>> unique_paths(3, 3, 0, []) 6 >>> unique_paths(3, 3, 1, [(2, 2)]) 2 >>> unique_paths(3, 3, 2, [(2, 2), (1, 3)]) 1 >>> unique_paths(3, 3, 1, [(1, 1)]) 0 >>> unique_paths(1, 1, 0, []) 1 >>> unique_paths(2, 2, 4, [(1, 1), (1, 2), (2, 1), (2, 2)]) 0","solution":"def unique_paths(n, m, k, obstacles): # Initialize the grid with -1 where obstacles are placed grid = [[0] * (m + 1) for _ in range(n + 1)] for x, y in obstacles: grid[x][y] = -1 # DP table to store number of paths to each cell dp = [[0] * (m + 1) for _ in range(n + 1)] dp[1][1] = 1 if grid[1][1] == 0 else 0 for i in range(1, n + 1): for j in range(1, m + 1): if grid[i][j] == -1: dp[i][j] = 0 else: if i > 1 and grid[i-1][j] != -1: dp[i][j] += dp[i-1][j] if j > 1 and grid[i][j-1] != -1: dp[i][j] += dp[i][j-1] return dp[n][m] # Example usage (you can remove this when testing): # n = 3 # m = 3 # k = 1 # obstacles = [(2, 2)] # print(unique_paths(n, m, k, obstacles))"},{"question":"def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths from the top-left corner to the bottom-right corner of an M x N grid. You can only move either down or right at any point in time. >>> unique_paths(3, 2) 3 >>> unique_paths(7, 3) 28 >>> unique_paths(1, 1) 1 >>> unique_paths(2, 2) 2 >>> unique_paths(10, 10) 48620","solution":"def unique_paths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. # Create a 2D list (m x n) filled with 1s. This represents the number of ways to reach each cell. dp = [[1]*n for _ in range(m)] # Iterate over the grid starting from (1,1) since the first row and first column are all 1s for i in range(1, m): for j in range(1, n): # Number of ways to reach (i, j) is the sum of ways to reach (i-1, j) and (i, j-1) dp[i][j] = dp[i-1][j] + dp[i][j-1] # Return the number of ways to reach the bottom-right corner return dp[m-1][n-1]"},{"question":"from typing import List, Tuple def solve(n: int, m: int, q: int, grid: List[str], queries: List[Tuple[int, int]]) -> List[int]: Compute the size of the regions containing specific cells in a grid, where regions are defined as connected cells containing the same character. Args: n (int): The number of rows in the grid. m (int): The number of columns in the grid. q (int): The number of queries. grid (List[str]): The grid represented as a list of strings. queries (List[Tuple[int, int]]): The list of queries represented as tuples of (x, y) coordinates. Returns: List[int]: The list of sizes of regions for each query. Examples: >>> solve(4, 4, 3, [\\"abab\\", \\"baba\\", \\"abab\\", \\"baba\\"], [(1, 1), (2, 2), (4, 2)]) [1, 1, 1] >>> solve(3, 3, 3, [\\"aaa\\", \\"aba\\", \\"aaa\\"], [(1, 1), (2, 2), (3, 3)]) [8, 1, 8] pass def test_case_1(): n, m, q = 4, 4, 3 grid = [ \\"abab\\", \\"baba\\", \\"abab\\", \\"baba\\" ] queries = [(1, 1), (2, 2), (4, 2)] assert solve(n, m, q, grid, queries) == [1, 1, 1] def test_case_2(): n, m, q = 3, 3, 3 grid = [ \\"aaa\\", \\"aba\\", \\"aaa\\" ] queries = [(1, 1), (2, 2), (3, 3)] assert solve(n, m, q, grid, queries) == [8, 1, 8] def test_case_3(): n, m, q = 5, 5, 5 grid = [ \\"abcde\\", \\"fghij\\", \\"klmno\\", \\"pqrst\\", \\"uvwxy\\" ] queries = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] assert solve(n, m, q, grid, queries) == [1, 1, 1, 1, 1] def test_case_4(): n, m, q = 2, 2, 1 grid = [ \\"aa\\", \\"aa\\" ] queries = [(1, 1)] assert solve(n, m, q, grid, queries) == [4] def test_case_5(): n, m, q = 1, 1, 1 grid = [\\"a\\"] queries = [(1, 1)] assert solve(n, m, q, grid, queries) == [1]","solution":"def find_region_size(grid, x, y, n, m, visited): # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] stack = [(x, y)] start_char = grid[x][y] size = 0 while stack: cx, cy = stack.pop() if visited[cx][cy]: continue visited[cx][cy] = True size += 1 for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == start_char: stack.append((nx, ny)) return size def solve(n, m, q, grid, queries): visited = [[False] * m for _ in range(n)] region_sizes = [[0] * m for _ in range(n)] # Find all region sizes for i in range(n): for j in range(m): if not visited[i][j]: size = find_region_size(grid, i, j, n, m, visited) fill_region_sizes(grid, i, j, n, m, region_sizes, size) results = [] for x, y in queries: results.append(region_sizes[x-1][y-1]) return results def fill_region_sizes(grid, x, y, n, m, region_sizes, size): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] stack = [(x, y)] start_char = grid[x][y] visited = set() while stack: cx, cy = stack.pop() if (cx, cy) in visited: continue visited.add((cx, cy)) region_sizes[cx][cy] = size for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == start_char: stack.append((nx, ny)) # Example usage: n, m, q = 4, 4, 3 grid = [ \\"abab\\", \\"baba\\", \\"abab\\", \\"baba\\" ] queries = [(1, 1), (2, 2), (4, 2)] print(solve(n, m, q, grid, queries)) # Output: [1, 1, 1]"},{"question":"def process_queries(N, Q, queries): Processes a series of queries on an N x N grid and returns the number of distinct values in the grid after all queries are applied. Parameters: N (int): Size of the grid (NxN) Q (int): Number of queries queries (list of tuples): Each tuple contains three integers (x, y, v) Returns: int: Number of distinct values in the grid pass # Unit Test def test_single_query(): assert process_queries(3, 1, [(1, 1, 5)]) == 2 # grid: 5 0 0; 0 0 0; 0 0 0 (distinct values: 0, 5) def test_multiple_queries_same_value(): assert process_queries(3, 4, [(1, 1, 5), (2, 2, 5), (3, 3, 5), (2, 1, 5)]) == 2 # grid: 5 0 0; 5 5 0; 0 0 5 (distinct values: 0, 5) def test_multiple_queries_different_values(): assert process_queries(3, 4, [(1, 1, 5), (2, 2, 5), (3, 3, 1), (2, 2, 0)]) == 3 # grid: 5 0 0; 0 0 0; 0 0 1 (distinct values: 0, 1, 5) def test_no_queries(): assert process_queries(3, 0, []) == 1 # grid: 0 0 0; 0 0 0; 0 0 0 (distinct values: 0 only) def test_all_cells_same_value(): assert process_queries(2, 4, [(1, 1, 2), (1, 2, 2), (2, 1, 2), (2, 2, 2)]) == 2 # grid: 2 2; 2 2 (distinct values: 0, 2) def test_all_cells_different_value(): assert process_queries(2, 4, [(1, 1, 1), (1, 2, 2), (2, 1, 3), (2, 2, 4)]) == 5 # grid: 1 2; 3 4 (distinct values: 0, 1, 2, 3, 4)","solution":"def process_queries(N, Q, queries): Processes a series of queries on an N x N grid and returns the number of distinct values in the grid after all queries are applied. Parameters: N (int): Size of the grid (NxN) Q (int): Number of queries queries (list of tuples): Each tuple contains three integers (x, y, v) Returns: int: Number of distinct values in the grid grid = [[0] * N for _ in range(N)] # Initialize the grid with 0s values_set = set([0]) for x, y, v in queries: grid[x-1][y-1] = v # Apply the query values_set.add(v) # Add the value to the set # Return the number of distinct values return len(values_set)"},{"question":"from typing import List, Union class SegmentTree: A segment tree for efficient range sum query and point update. def __init__(self, data): n = len(data) self.n = n self.tree = [0] * (2 * n) self._build(data) def _build(self, data): # Initialize the tree with the original data for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, pos, value): # Update value at position pos and propagate changes pos += self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def range_sum(self, l, r): # Query sum in the range [l, r) l += self.n r += self.n + 1 sum_ = 0 while l < r: if l % 2 == 1: sum_ += self.tree[l] l += 1 if r % 2 == 1: r -= 1 sum_ += self.tree[r] l //= 2 r //= 2 return sum_ def process_queries(n: int, q: int, L: List[int], queries: List[Union[List[Union[str, int]]]]) -> List[int]: Process the list of range sum and update queries on an integer list. Parameters: n (int): The length of the list. q (int): The number of queries. L (List[int]): The initial list of integers. queries (List[Union[List[Union[str, int]]]]): The list of queries. Returns: List[int]: The results of the range sum queries. >>> process_queries(5, 3, [1, 2, 3, 4, 5], [['S', 1, 3], ['U', 2, 10], ['S', 1, 3]]) [9, 16] >>> process_queries(8, 4, [2, 4, 5, 3, 1, 6, 2, 8], [['S', 0, 4], ['U', 3, 10], ['S', 2, 6], ['S', 1, 7]]) [15, 24, 36]","solution":"class SegmentTree: A segment tree for efficient range sum query and point update. def __init__(self, data): n = len(data) self.n = n self.tree = [0] * (2 * n) self._build(data) def _build(self, data): # Initialize the tree with the original data for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, pos, value): # Update value at position pos and propagate changes pos += self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def range_sum(self, l, r): # Query sum in the range [l, r) l += self.n r += self.n + 1 sum_ = 0 while l < r: if l % 2 == 1: sum_ += self.tree[l] l += 1 if r % 2 == 1: r -= 1 sum_ += self.tree[r] l //= 2 r //= 2 return sum_ def process_queries(n, q, L, queries): st = SegmentTree(L) results = [] for query in queries: if query[0] == 'U': _, i, v = query st.update(i, v) elif query[0] == 'S': _, i, j = query results.append(st.range_sum(i, j)) return results"},{"question":"def evaluate_expression(expression: str) -> int: Create a function that takes a string representing a mathematical expression and returns the result of evaluating that expression. The expression can contain: 1. Non-negative integers. 2. The arithmetic operators: +, -, *, / (integer division). 3. Parentheses for grouping. The expression is guaranteed to be valid and will not contain any spaces. Implement the function to correctly follow the order of operations (parentheses, multiplication and division, addition and subtraction). >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") 23 >>> evaluate_expression(\\"2-1+2\\") 3 # Your code here","solution":"def evaluate_expression(expression: str) -> int: def compute(operators, operands): right = operands.pop() left = operands.pop() operator = operators.pop() if operator == '+': operands.append(left + right) elif operator == '-': operands.append(left - right) elif operator == '*': operands.append(left * right) elif operator == '/': operands.append(int(left / right)) # Truncate towards zero operators = [] operands = [] i = 0 while i < len(expression): char = expression[i] if char.isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 operands.append(num) i -= 1 elif char in \\"+-*/\\": while (operators and operators[-1] in \\"+-*/\\" and ((char in \\"+-\\" and operators[-1] in \\"+-*/\\") or (char in \\"*/\\" and operators[-1] in \\"*/\\"))): compute(operators, operands) operators.append(char) elif char == '(': operators.append(char) elif char == ')': while operators and operators[-1] != '(': compute(operators, operands) operators.pop() # pop '(' i += 1 while operators: compute(operators, operands) return operands[0]"},{"question":"from typing import List def uniquePathsWithObstacles(obstacleGrid: List[List[int]]) -> int: Calculate the number of unique paths from the top-left corner to the bottom-right corner of the grid considering obstacles. The grid is represented as a list of lists where: 0 - represents an empty space 1 - represents an obstacle Parameters: obstacleGrid (List[List[int]]): A m x n grid containing 0s and 1s. Returns: int: The number of unique paths from the top-left corner to the bottom-right corner. Example: >>> uniquePathsWithObstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 def test_unique_paths_no_obstacles(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert uniquePathsWithObstacles(grid) == 6 def test_unique_paths_with_obstacles(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert uniquePathsWithObstacles(grid) == 2 def test_unique_paths_with_border_obstacles(): grid = [ [0, 1], [0, 0] ] assert uniquePathsWithObstacles(grid) == 1 def test_unique_paths_single_row_obstacle(): grid = [ [0, 1] ] assert uniquePathsWithObstacles(grid) == 0 def test_unique_paths_start_obstacle(): grid = [ [1, 0], [0, 0] ] assert uniquePathsWithObstacles(grid) == 0 def test_unique_paths_end_obstacle(): grid = [ [0, 0], [0, 1] ] assert uniquePathsWithObstacles(grid) == 0","solution":"def uniquePathsWithObstacles(obstacleGrid): This function calculates the number of unique paths from the top-left corner to the bottom-right corner of the grid considering obstacles. if not obstacleGrid or obstacleGrid[0][0] == 1: return 0 m, n = len(obstacleGrid), len(obstacleGrid[0]) # Create a dp grid initialized to 0 dp = [[0] * n for _ in range(m)] # Start position dp[0][0] = 1 # Fill first column for i in range(1, m): dp[i][0] = dp[i-1][0] if obstacleGrid[i][0] == 0 else 0 # Fill first row for j in range(1, n): dp[0][j] = dp[0][j-1] if obstacleGrid[0][j] == 0 else 0 # Fill the rest of the dp grid for i in range(1, m): for j in range(1, n): if obstacleGrid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] else: dp[i][j] = 0 return dp[m-1][n-1]"},{"question":"def find_triplets(arr: List[int], target: int) -> List[List[int]]: Finds all unique triplets in the array that add up to the target sum. Each triplet should be sorted in ascending order, and the list of triplets should be sorted in lexicographical order. Returns an empty list if no such triplets exist. >>> find_triplets([-1, 0, 1, 2, -1, -4], 0) [[-1, -1, 2], [-1, 0, 1]] >>> find_triplets([1, 2, 3, 4, 5], 9) [[1, 3, 5], [2, 3, 4]] >>> find_triplets([1, 2, 3], 10) [] >>> find_triplets([], 0) [] >>> find_triplets([1], 1) [] >>> find_triplets([1, 2], 3) [] >>> find_triplets([0, 0, 0, 0], 0) [[0, 0, 0]] >>> find_triplets([1000000, -1000000, 0, 1000000, -1000000, 0], 0) [[-1000000, 0, 1000000]]","solution":"def find_triplets(arr, target): Finds all unique triplets in \`arr\` that sum up to \`target\`. Each triplet is sorted in ascending order and the list of triplets is sorted lexicographically. Parameters: arr (list): List of integers. target (int): Target sum for the triplets. Returns: list: List of lists containing the triplets. arr.sort() n = len(arr) triplets = set() for i in range(n): left, right = i + 1, n - 1 while left < right: s = arr[i] + arr[left] + arr[right] if s == target: triplets.add((arr[i], arr[left], arr[right])) left += 1 right -= 1 elif s < target: left += 1 else: right -= 1 # Convert to sorted list of lists result = [list(triplet) for triplet in sorted(triplets)] return result"},{"question":"def max_workshops(starts, ends): Determines the maximum number of non-overlapping workshops that can be attended. Parameters: starts (list of int): Start days of the workshops. ends (list of int): End days of the workshops. Returns: int: Maximum number of non-overlapping workshops. Example: >>> max_workshops([1, 3, 2, 5], [4, 5, 3, 8]) 2 >>> max_workshops([1, 4, 6, 8], [3, 5, 7, 9]) 4 >>> max_workshops([1, 1, 1, 1], [2, 2, 2, 2]) 1 >>> max_workshops([1, 3, 5, 7], [2, 4, 8, 9]) 3 >>> max_workshops([1, 10, 20, 30, 40], [15, 25, 35, 45, 50]) 3 >>> max_workshops([3], [4]) 1 >>> max_workshops([1, 2], [4, 3]) 1","solution":"def max_workshops(starts, ends): Determines the maximum number of non-overlapping workshops that can be attended. Parameters: starts (list of int): Start days of the workshops. ends (list of int): End days of the workshops. Returns: int: Maximum number of non-overlapping workshops. intervals = sorted(zip(ends, starts)) # Initialize the end time of the last selected workshop last_end = intervals[0][0] count = 1 # At least one workshop can be attended for end, start in intervals[1:]: if start > last_end: count += 1 last_end = end return count # Example usage: # n = 4 # starts = [1, 3, 2, 5] # ends = [4, 5, 3, 8] # print(max_workshops(starts, ends)) # Output should be 2"},{"question":"def single_number(arr: List[int]) -> int: Find the single number that appears exactly once in an array where every other number appears three times. pass import pytest def test_single_number_case1(): assert single_number([3, 3, 2, 3, 4, 4, 4]) == 2 def test_single_number_case2(): assert single_number([-1, -1, -1, 5, 5, 5, 7, 7, 7, 11]) == 11 def test_single_number_case3(): assert single_number([0, 0, 0, 1]) == 1 def test_single_number_case4(): assert single_number([10, 10, 10, -20]) == -20 def test_single_number_case5(): assert single_number([1, 2, 1, 2, 1, 2, 3]) == 3","solution":"def single_number(arr): Find the single number that appears exactly once in an array where every other number appears three times. ones, twos = 0, 0 for num in arr: # \`twos\` holds the bits which appear twice twos |= ones & num # \`ones\` holds the bits which appear once ones ^= num # \`common_bit_mask\` contains the common bits in \`ones\` and \`twos\` # which means the bits which appear three times common_bit_mask = ~(ones & twos) # Removing bits that appear three times from \`ones\` ones &= common_bit_mask # Removing bits that appear three times from \`twos\` twos &= common_bit_mask return ones"},{"question":"from typing import List, Tuple def find_most_active_user(activities: List[Tuple[int, str]], start: int, end: int) -> str: Identify the user with the most activities within a given timestamp range. >>> find_most_active_user([(1, \\"user1\\"), (2, \\"user2\\"), (3, \\"user1\\"), (4, \\"user1\\"), (5, \\"user3\\"), (6, \\"user2\\")], 2, 4) 'user1' >>> find_most_active_user([(1, \\"userA\\"), (2, \\"userB\\"), (3, \\"userA\\"), (4, \\"userB\\"), (5, \\"userB\\"), (6, \\"userC\\")], 1, 6) 'userB' >>> find_most_active_user([(1, \\"user1\\"), (2, \\"user2\\")], 3, 4) '' >>> find_most_active_user([(3, \\"user1\\")], 3, 3) 'user1' >>> find_most_active_user([(3, \\"userA\\"), (4, \\"userB\\"), (5, \\"userA\\"), (6, \\"userB\\")], 3, 6) 'userA' >>> find_most_active_user([(i, f\\"user{i % 3}\\") for i in range(100000)], 0, 99999) 'user0'","solution":"from collections import defaultdict from typing import List, Tuple def find_most_active_user(activities: List[Tuple[int, str]], start: int, end: int) -> str: user_activity_count = defaultdict(int) for timestamp, user_id in activities: if start <= timestamp <= end: user_activity_count[user_id] += 1 most_activities = max(user_activity_count.values(), default=0) most_active_users = [user for user, count in user_activity_count.items() if count == most_activities] return min(most_active_users, default=\\"\\") # Return the lexicographically smallest user ID"},{"question":"def last_stone_weight(n: int, stones: List[int]) -> int: Returns the weight of the last remaining stone after smashing them according to the given rules. If there are no stones left, return 0. Parameters: n (int): The number of stones. stones (List[int]): The weights of the stones. Returns: int: The weight of the last remaining stone, or 0 if no stones are left. Examples: >>> last_stone_weight(6, [2, 7, 4, 1, 8, 1]) 1 >>> last_stone_weight(4, [2, 2, 3, 1]) 0","solution":"def last_stone_weight(n, stones): Returns the weight of the last remaining stone after smashing them according to the given rules. If there are no stones left, return 0. import heapq # Turn all stones to negative values to use a min-heap as max-heap stones = [-stone for stone in stones] heapq.heapify(stones) while len(stones) > 1: # Extract two heaviest stones (smallest in negative form) first = -heapq.heappop(stones) second = -heapq.heappop(stones) if first != second: # The new stone weight after smashing new_stone = first - second # Insert back the negative of new stone's weight heapq.heappush(stones, -new_stone) # If there are no stones left, return 0, else return the weight of the remaining stone (turning it back positive) return -stones[0] if stones else 0"},{"question":"def is_subsequence(seq1: list[int], seq2: list[int]) -> str: Determine whether seq1 is a subsequence of seq2. Parameters: seq1 (list): The first sequence of integers. seq2 (list): The second sequence of integers. Returns: str: \\"YES\\" if seq1 is a subsequence of seq2, otherwise \\"NO\\". >>> is_subsequence([1, 3, 5], [1, 2, 3, 4, 5]) \\"YES\\" >>> is_subsequence([1, 4, 6], [1, 2, 3, 5, 7]) \\"NO\\" >>> is_subsequence([1], [1, 2, 3]) \\"YES\\" >>> is_subsequence([], [1, 2, 3, 5, 7]) \\"YES\\" >>> is_subsequence([1, 2, 3], [3, 2, 1]) \\"NO\\" >>> is_subsequence([1, 3, 4], [1, 2, 3, 4]) \\"YES\\" >>> is_subsequence([6, 7], [1, 2, 3, 4, 5]) \\"NO\\" >>> is_subsequence([], []) \\"YES\\" >>> is_subsequence([1, 2, 3], []) \\"NO\\"","solution":"def is_subsequence(seq1, seq2): Determine whether seq1 is a subsequence of seq2. Parameters: seq1 (list): The first sequence of integers. seq2 (list): The second sequence of integers. Returns: str: \\"YES\\" if seq1 is a subsequence of seq2, otherwise \\"NO\\". iter_seq2 = iter(seq2) return \\"YES\\" if all(elem in iter_seq2 for elem in seq1) else \\"NO\\""},{"question":"def max_visible_buildings(buildings: List[int]) -> int: Determines the maximum number of buildings that can be seen from the left side. A building is visible if it is taller than all the buildings before it. >>> max_visible_buildings([2, 6, 4, 5, 8]) 3 >>> max_visible_buildings([1, 2, 2, 3]) 3 >>> max_visible_buildings([5]) 1 >>> max_visible_buildings([4, 4, 4, 4]) 1 >>> max_visible_buildings([5, 4, 3, 2, 1]) 1 >>> max_visible_buildings([1, 2, 3, 4, 5]) 5 >>> max_visible_buildings([]) 0","solution":"def max_visible_buildings(buildings): Determines the maximum number of buildings that can be seen from the left side. A building is visible if it is taller than all the buildings before it. if not buildings: return 0 max_height = float('-inf') visible_buildings = 0 for building in buildings: if building > max_height: visible_buildings += 1 max_height = building return visible_buildings"},{"question":"def city_with_highest_avg_temp(data): Determines the city with the highest average temperature. :param data: List of strings, with the first element as the number of cities followed by each city's temperature readings in a specific format. :return: The name of the city with the highest average temperature. Examples: >>> city_with_highest_avg_temp([\\"3\\", \\"CityA:30,32,31,29\\", \\"CityB:29,28,30,32\\", \\"CityC:40,41,42,40\\"]) \\"CityC\\" >>> city_with_highest_avg_temp([\\"2\\", \\"CityX:25,25,25\\", \\"CityY:24,24,24\\"]) \\"CityX\\" >>> city_with_highest_avg_temp([\\"1\\", \\"SoloCity:10,20,30\\"]) \\"SoloCity\\" >>> city_with_highest_avg_temp([\\"4\\", \\"Alpha:20,30,40\\", \\"Bravo:25,35,45\\", \\"Charlie:30,30,30\\", \\"Delta:5,5,5\\"]) \\"Bravo\\" >>> city_with_highest_avg_temp([\\"2\\", \\"CityA:10,20,30\\", \\"CityB:15,25,35\\"]) \\"CityB\\"","solution":"def city_with_highest_avg_temp(data): Determines the city with the highest average temperature. :param data: List of strings, with the first element as the number of cities followed by each city's temperature readings in a specific format. :return: The name of the city with the highest average temperature. num_cities = int(data[0]) max_avg_temp = float('-inf') city_with_max_avg_temp = None for i in range(1, num_cities + 1): city_data = data[i] city_name, temperatures_str = city_data.split(\\":\\") temperatures = list(map(int, temperatures_str.split(','))) avg_temp = sum(temperatures) / len(temperatures) if avg_temp > max_avg_temp: max_avg_temp = avg_temp city_with_max_avg_temp = city_name return city_with_max_avg_temp"},{"question":"def is_magic_square(square: List[List[int]]) -> str: Verify if a given n x n square grid is a magic square. >>> is_magic_square([ ... [8, 1, 6], ... [3, 5, 7], ... [4, 9, 2] ... ]) \\"YES\\" >>> is_magic_square([ ... [8, 1, 6], ... [3, 5, 8], ... [4, 9, 2] ... ]) \\"NO\\"","solution":"def is_magic_square(square): n = len(square) # Calculate the sum of the first row to use as reference expected_sum = sum(square[0]) # Check sums of all rows for row in square: if sum(row) != expected_sum: return \\"NO\\" # Check sums of all columns for col in range(n): if sum(square[row][col] for row in range(n)) != expected_sum: return \\"NO\\" # Check the sum of the main diagonal if sum(square[i][i] for i in range(n)) != expected_sum: return \\"NO\\" # Check the sum of the anti-diagonal if sum(square[i][n-1-i] for i in range(n)) != expected_sum: return \\"NO\\" return \\"YES\\""},{"question":"def common_divisor_sum(K: int, C: List[int]) -> int: Returns the sum of all positive integers less than or equal to K that are divisible by any of the integers in the provided list C. >>> common_divisor_sum(10, [2, 3]) 42 >>> common_divisor_sum(5, [1]) 15","solution":"def common_divisor_sum(K, C): Returns the sum of all positive integers less than or equal to K that are divisible by any of the integers in the provided list C. divisible_set = set() for c in C: for multiple in range(c, K + 1, c): divisible_set.add(multiple) return sum(divisible_set)"},{"question":"def encrypted_score(s: str) -> int: Returns the encrypted score of the string s modulo 1,000,000,007. Input: - s: A string consisting of lowercase English letters. Output: - The encrypted score of the string modulo 1,000,000,007. Example: >>> encrypted_score(\\"abc\\") 6 >>> encrypted_score(\\"xyz\\") 15600","solution":"def encrypted_score(s): Returns the encrypted score of the string s modulo 1,000,000,007. modulo = 1_000_000_007 score = 1 for char in s: base_value = ord(char) - ord('a') + 1 score = (score * base_value) % modulo return score"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing positive and negative integers, and the +, -, *, / operators, as well as parentheses to denote order of operations. Parameters: expression (str): A string representation of the mathematical expression. Returns: int: The result of the evaluated expression. >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") 23 pass from solution import evaluate_expression def test_simple_addition(): assert evaluate_expression(\\"3+2\\") == 5 def test_simple_subtraction(): assert evaluate_expression(\\"10-5\\") == 5 def test_simple_multiplication(): assert evaluate_expression(\\"4*5\\") == 20 def test_simple_division(): assert evaluate_expression(\\"20/4\\") == 5 def test_combined_operations(): assert evaluate_expression(\\"3+2*2\\") == 7 assert evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") == 23 def test_with_negative_numbers(): assert evaluate_expression(\\"3+-2\\") == 1 def test_with_multiple_digit_numbers(): assert evaluate_expression(\\"12+34\\") == 46 assert evaluate_expression(\\"50-25\\") == 25 def test_parentheses_with_precedence(): assert evaluate_expression(\\"2*(5+5*2)/3+(6/2+8)\\") == 21 def test_complex_expression(): assert evaluate_expression(\\"(7 - (3 + 2) * (8 - 6 + 1)) / (2 * (3 + 3) / 2)\\") == -1","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing positive and negative integers, and the +, -, *, / operators, as well as parentheses to denote order of operations. Parameters: expression (str): A string representation of the mathematical expression. Returns: int: The result of the evaluated expression. from collections import deque def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(int(left / right)) # use int() to ensure integer division def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 def calculate(expression): operators = deque() values = deque() i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue if expression[i] == '(': operators.append(expression[i]) elif expression[i].isdigit() or (expression[i] == '-' and (i == 0 or expression[i-1] in \\"(+-*/\\")): # Check for segment that might form a number with multiple digits including negative signs start = i if expression[i] == '-': i += 1 while i < len(expression) and expression[i].isdigit(): i += 1 values.append(int(expression[start:i])) continue elif expression[i] == ')': while operators and operators[-1] != '(': apply_operator(operators, values) operators.pop() # pop '(' else: while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operator(operators, values) return values[0] return calculate(expression)"},{"question":"def generate_checkerboard(n: int, m: int) -> list: Generates an n x m checkerboard pattern with characters 'A' and 'B'. Parameters: n (int): Number of rows of the checkerboard. m (int): Number of columns of the checkerboard. Returns: list: A list of strings representing the checkerboard pattern. >>> generate_checkerboard(3, 4) ['ABAB', 'BABA', 'ABAB'] >>> generate_checkerboard(2, 2) ['AB', 'BA']","solution":"def generate_checkerboard(n, m): Generates an n x m checkerboard pattern with characters 'A' and 'B'. Parameters: n (int): Number of rows of the checkerboard. m (int): Number of columns of the checkerboard. Returns: list: A list of strings representing the checkerboard pattern. checkerboard = [] for i in range(n): row = \\"\\" for j in range(m): if (i + j) % 2 == 0: row += 'A' else: row += 'B' checkerboard.append(row) return checkerboard"},{"question":"def character_frequencies(s: str) -> List[str]: Determine the frequency of characters in a string. The output is a list of strings in the format 'character+frequency' in the order of first appearance. Constraints: * The string will have at most 1000 characters. * The string will contain only lowercase English letters (a-z). Example: >>> character_frequencies(\\"programming\\") == ['p1', 'r2', 'o1', 'g2', 'a1', 'm2', 'i1', 'n1'] >>> character_frequencies(\\"aabc\\") == ['a2', 'b1', 'c1'] Test cases: >>> character_frequencies(\\"abcabc\\") == ['a2', 'b2', 'c2'] >>> character_frequencies(\\"aaa\\") == ['a3'] >>> character_frequencies(\\"abcdef\\") == ['a1', 'b1', 'c1', 'd1', 'e1', 'f1'] >>> character_frequencies(\\"\\") == [] >>> character_frequencies(\\"a\\") == ['a1'] >>> character_frequencies(\\"z\\") == ['z1'] >>> character_frequencies(\\"zzzzz\\") == ['z5']","solution":"def character_frequencies(s): Returns the frequencies of characters in the string s. The output is a list of tuples (character, frequency) in the order of first appearance. frequency_dict = {} result = [] for character in s: if character in frequency_dict: frequency_dict[character] += 1 else: frequency_dict[character] = 1 seen = set() for character in s: if character not in seen: result.append(f\\"{character}{frequency_dict[character]}\\") seen.add(character) return result"},{"question":"def can_place_garlands(n, m, k): Determines if it is possible to place m garlands on a circular table with n seats such that no two garlands overlap any seat. Args: n (int): Number of seats. m (int): Number of garlands. k (int): Number of seats each garland covers. Returns: str: \\"Yes\\" if it is possible to place all garlands without overlapping, otherwise \\"No\\". >>> can_place_garlands(10, 2, 3) \\"Yes\\" >>> can_place_garlands(5, 3, 2) \\"No\\" def test_example_cases(): assert can_place_garlands(10, 2, 3) == \\"Yes\\" assert can_place_garlands(5, 3, 2) == \\"No\\" def test_edge_cases(): # minimum values assert can_place_garlands(3, 1, 2) == \\"Yes\\" assert can_place_garlands(3, 1, 3) == \\"Yes\\" assert can_place_garlands(3, 2, 2) == \\"No\\" # maximum value of n assert can_place_garlands(100000, 1, 50000) == \\"Yes\\" assert can_place_garlands(100000, 2, 50000) == \\"Yes\\" assert can_place_garlands(100000, 2, 50001) == \\"No\\" def test_general_cases(): assert can_place_garlands(12, 4, 3) == \\"Yes\\" assert can_place_garlands(12, 4, 4) == \\"No\\" assert can_place_garlands(15, 5, 3) == \\"Yes\\" assert can_place_garlands(15, 5, 4) == \\"No\\"","solution":"def can_place_garlands(n, m, k): Determines if it is possible to place m garlands on a circular table with n seats such that no two garlands overlap any seat. Args: n (int): Number of seats. m (int): Number of garlands. k (int): Number of seats each garland covers. Returns: str: \\"Yes\\" if it is possible to place all garlands without overlapping, otherwise \\"No\\". if m * k <= n: return \\"Yes\\" return \\"No\\""},{"question":"def count_distinct_substrings(s: str) -> int: Returns the number of distinct substrings in the given string s. >>> count_distinct_substrings(\\"abc\\") 6 >>> count_distinct_substrings(\\"aaa\\") 3 >>> count_distinct_substrings(\\"abac\\") 9 def process_queries(n: int, queries: list) -> list: Processes multiple queries to count the number of distinct substrings for each query string. >>> process_queries(3, [\\"abc\\", \\"aaa\\", \\"abac\\"]) [6, 3, 9] >>> process_queries(2, [\\"abab\\", \\"abcd\\"]) [7, 10] from solution import count_distinct_substrings, process_queries def test_count_distinct_substrings(): assert count_distinct_substrings(\\"abc\\") == 6 assert count_distinct_substrings(\\"aaa\\") == 3 assert count_distinct_substrings(\\"abac\\") == 9 assert count_distinct_substrings(\\"abcd\\") == 10 assert count_distinct_substrings(\\"a\\") == 1 assert count_distinct_substrings(\\"abab\\") == 7 def test_process_queries(): assert process_queries(3, [\\"abc\\", \\"aaa\\", \\"abac\\"]) == [6, 3, 9] assert process_queries(2, [\\"abab\\", \\"abcd\\"]) == [7, 10] def test_edge_cases(): assert count_distinct_substrings(\\"\\") == 0 assert count_distinct_substrings(\\"a\\") == 1 assert count_distinct_substrings(\\"aa\\") == 2 def test_large_inputs(): long_string = \\"a\\" * 100 assert count_distinct_substrings(long_string) == 100","solution":"def count_distinct_substrings(s: str) -> int: Returns the number of distinct substrings in the given string s. substrings = set() for i in range(len(s)): for j in range(i + 1, len(s) + 1): substrings.add(s[i:j]) return len(substrings) def process_queries(n: int, queries: list) -> list: Processes multiple queries to count the number of distinct substrings for each query string. results = [] for query in queries: results.append(count_distinct_substrings(query)) return results"},{"question":"def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Write a function to determine the number of unique paths in a grid from the top-left corner to the bottom-right corner. The grid has obstacles and empty spaces. The robot can only move either down or right at any point in time. An obstacle and empty space are marked as 1 and 0 respectively in the grid. >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> unique_paths_with_obstacles([ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 1 >>> unique_paths_with_obstacles([ ... [1] ... ]) 0 >>> unique_paths_with_obstacles([ ... [0] ... ]) 1 def process_input(input_data: str) -> List[int]: Process input string to determine the number of unique paths for multiple test cases. >>> input_data = \\"2n3 3n0 0 0n0 1 0n0 0 0n3 3n0 1 0n0 1 0n0 0 0n\\" >>> process_input(input_data) [2, 1]","solution":"def unique_paths_with_obstacles(grid): m, n = len(grid), len(grid[0]) # If the starting cell has an obstacle, then directly return 0 if grid[0][0] == 1: return 0 # Initialize the dp array with 0 values dp = [[0] * n for _ in range(m)] # Starting position dp[0][0] = 1 # Fill the dp array for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1] def process_input(input_data): lines = input_data.strip().split(\\"n\\") results = [] num_cases = int(lines[0]) line_index = 1 for _ in range(num_cases): m, n = map(int, lines[line_index].split()) grid = [] for i in range(m): grid.append(list(map(int, lines[line_index + 1 + i].split()))) line_index += m + 1 results.append(unique_paths_with_obstacles(grid)) return results # Example usage input_data = 2 3 3 0 0 0 0 1 0 0 0 0 3 3 0 1 0 0 1 0 0 0 0 print(process_input(input_data)) # Output should be [2, 1]"},{"question":"def is_palindrome(s: str) -> str: Checks if the given string is a palindrome, ignoring case, spaces, and punctuation. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") \\"Yes\\" >>> is_palindrome(\\"race a car\\") \\"No\\" >>> is_palindrome(\\"\\") \\"Yes\\" >>> is_palindrome(\\"a\\") \\"Yes\\" >>> is_palindrome(\\"Z\\") \\"Yes\\" >>> is_palindrome(\\"123321\\") \\"Yes\\" >>> is_palindrome(\\"12321\\") \\"Yes\\" >>> is_palindrome(\\"12345\\") \\"No\\" >>> is_palindrome(\\"No 'x' in Nixon\\") \\"Yes\\" >>> is_palindrome(\\"Able was I, ere I saw Elba\\") \\"Yes\\" >>> is_palindrome(\\"%^Madam, In Eden, I’m Adam...\\") \\"Yes\\" >>> is_palindrome(\\"Was it a car or a cat I saw?\\") \\"Yes\\" >>> is_palindrome(\\"This is definitely not a palindrome\\") \\"No\\" >>> is_palindrome(\\"Hello, World!\\") \\"No\\"","solution":"import re def is_palindrome(s): Checks if the given string is a palindrome, ignoring case, spaces, and punctuation. # Remove non-alphanumeric characters and convert to lowercase cleaned = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Check if cleaned string is equal to its reverse return \\"Yes\\" if cleaned == cleaned[::-1] else \\"No\\""},{"question":"def correct_time(time_str: str) -> str: Given a time string in HH:MM format, corrects it to the nearest valid time. >>> correct_time(\\"25:61\\") \\"00:00\\" >>> correct_time(\\"19:75\\") \\"19:00\\"","solution":"def correct_time(time_str): Given a time string in HH:MM format, corrects it to the nearest valid time. # Split the input into different components hours, minutes = time_str.split(':') hours = int(hours) minutes = int(minutes) # Correct the hours if they are out of valid range if hours > 23: hours = 0 # Correct the minutes if they are out of valid range if minutes > 59: minutes = 0 # Convert hours and minutes back to string with leading zeros if necessary corrected_hours = f\\"{hours:02d}\\" corrected_minutes = f\\"{minutes:02d}\\" # Combine them back into HH:MM format corrected_time = f\\"{corrected_hours}:{corrected_minutes}\\" return corrected_time"},{"question":"def max_non_overlapping_meetings(n: int, meetings: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping meetings that can be scheduled. Parameters: - n: int, the number of meetings - meetings: list of tuples, each tuple contains two integers (start and end) representing start and end times of a meeting Returns: - int, the maximum number of non-overlapping meetings Example: >>> max_non_overlapping_meetings(3, [(1, 3), (2, 4), (3, 5)]) 2 >>> max_non_overlapping_meetings(4, [(1, 2), (2, 3), (3, 4), (1, 3)]) 3","solution":"def max_non_overlapping_meetings(n, meetings): Returns the maximum number of non-overlapping meetings that can be scheduled. Parameters: - n: int, the number of meetings - meetings: list of tuples, each tuple contains two integers (start and end) representing start and end times of a meeting Returns: - int, the maximum number of non-overlapping meetings # Sort the meetings by their end times meetings.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in meetings: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"def construct_list(n: int) -> List[int]: Constructs a list of n integers such that the sum of the elements is n and each integer in the list is either 1, 2, or 3. Args: n (int): The total number of elements in the list. Returns: list: A list of integers satisfying the condition. >>> construct_list(5) [1, 1, 1, 1, 1] >>> construct_list(10) [2, 2, 2, 2, 2]","solution":"def construct_list(n): Constructs a list of n integers such that the sum of the elements is n and each integer in the list is either 1, 2, or 3. Args: n (int): The total number of elements in the list. Returns: list: A list of integers satisfying the condition. result = [] while n > 0: if n >= 3: result.append(3) n -= 3 elif n == 2: result.append(2) break else: result.append(1) break return result"},{"question":"from typing import List, Tuple def check_crossing_lines(test_cases: List[Tuple[int, List[Tuple[int, int, int, int]]]]) -> List[str]: Determine if any two tram lines cross each other. Args: test_cases (List[Tuple[int, List[Tuple[int, int, int, int]]]]): A list of test cases where each test case consists of an integer M (number of tram lines) and a list of tram lines described by their start and end coordinates. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" strings indicating whether any pair of tram lines cross for each test case. Example: >>> check_crossing_lines(parse_input(\\"2n3n1 1 1 5n2 2 2 6n1 3 2 3n2n0 0 2 0n1 -1 1 1n\\")) [\\"YES\\", \\"YES\\"] >>> check_crossing_lines(parse_input(\\"1n2n0 0 0 5n1 0 1 5n\\")) [\\"NO\\"] # Implement the function here def parse_input(input_string: str) -> List[Tuple[int, List[Tuple[int, int, int, int]]]]: Parse the input string to extract the test cases. Args: input_string (str): The input string representing multiple test cases. Returns: List[Tuple[int, List[Tuple[int, int, int, int]]]]: A list of test cases where each test case consists of an integer M (number of tram lines) and a list of tram lines described by their start and end coordinates. Example: >>> parse_input(\\"2n3n1 1 1 5n2 2 2 6n1 3 2 3n2n0 0 2 0n1 -1 1 1n\\") [(3, [(1, 1, 1, 5), (2, 2, 2, 6), (1, 3, 2, 3)]), (2, [(0, 0, 2, 0), (1, -1, 1, 1)])] # Implement the function here","solution":"def check_crossing_lines(test_cases): results = [] for lines in test_cases: M, tram_lines = lines vertical_lines = [] horizontal_lines = [] for x1, y1, x2, y2 in tram_lines: if x1 == x2: vertical_lines.append((x1, min(y1, y2), max(y1, y2))) elif y1 == y2: horizontal_lines.append((y1, min(x1, x2), max(x1, x2))) crossing_found = False for vx, vy1, vy2 in vertical_lines: for hy, hx1, hx2 in horizontal_lines: if hx1 <= vx <= hx2 and vy1 <= hy <= vy2: crossing_found = True break if crossing_found: break results.append(\\"YES\\" if crossing_found else \\"NO\\") return results def parse_input(input_string): lines = input_string.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): M = int(lines[index]) tram_lines = [] for i in range(M): x1, y1, x2, y2 = map(int, lines[index + 1 + i].split()) tram_lines.append((x1, y1, x2, y2)) test_cases.append((M, tram_lines)) index += M + 1 return test_cases"},{"question":"from collections import defaultdict def find_cycle(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Detects if there is a cycle in an undirected graph represented by n nodes and m edges. Parameters: n (int): Number of nodes. m (int): Number of edges. edges (list of tuples): Edge list where each tuple represents an edge between two nodes. Returns: str: \\"Cycle Found\\" if there is at least one cycle, otherwise \\"No Cycle\\" graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) def is_cyclic(v: int, parent: int) -> bool: visited[v] = True for neighbour in graph[v]: if not visited[neighbour]: if is_cyclic(neighbour, v): return True elif neighbour != parent: return True return False for i in range(1, n + 1): if not visited[i]: if is_cyclic(i, -1): return \\"Cycle Found\\" return \\"No Cycle\\" def test_find_cycle(): assert find_cycle(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 2)]) == \\"Cycle Found\\" assert find_cycle(4, 3, [(1, 2), (2, 3), (3, 4)]) == \\"No Cycle\\" assert find_cycle(3, 2, [(1, 2), (2, 3)]) == \\"No Cycle\\" assert find_cycle(6, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)]) == \\"Cycle Found\\" assert find_cycle(4, 5, [(1, 2), (1, 3), (1, 4), (2, 3), (3, 4)]) == \\"Cycle Found\\" def test_find_cycle_single_node(): assert find_cycle(1, 0, []) == \\"No Cycle\\" def test_find_cycle_disconnected_graph(): assert find_cycle(6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)]) == \\"No Cycle\\" assert find_cycle(6, 5, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6)]) == \\"Cycle Found\\"","solution":"from collections import defaultdict def find_cycle(n, m, edges): Detects if there is a cycle in an undirected graph represented by n nodes and m edges. Parameters: n (int): Number of nodes. m (int): Number of edges. edges (list of tuples): Edge list where each tuple represents an edge between two nodes. Returns: str: \\"Cycle Found\\" if there is at least one cycle, otherwise \\"No Cycle\\" graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) def is_cyclic(v, parent): visited[v] = True for neighbour in graph[v]: if not visited[neighbour]: if is_cyclic(neighbour, v): return True elif neighbour != parent: return True return False for i in range(1, n + 1): if not visited[i]: if is_cyclic(i, -1): return \\"Cycle Found\\" return \\"No Cycle\\""},{"question":"from typing import List def dailyTemperatures(temperatures: List[int]) -> List[int]: Given an array of integers representing daily temperature readings, determine how many days it takes for each day to have a warmer temperature than the current day. If there is no future day with a warmer temperature, return 0 for that day. >>> dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> dailyTemperatures([30, 40, 50, 60]) [1, 1, 1, 0] >>> dailyTemperatures([40, 30, 20, 10]) [0, 0, 0, 0]","solution":"from typing import List def dailyTemperatures(temperatures: List[int]) -> List[int]: n = len(temperatures) result = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: j = stack.pop() result[j] = i - j stack.append(i) return result"},{"question":"def min_increments_to_make_array_strictly_increasing(n: int, arr: List[int]) -> int: Determine the minimum number of increments required to make the array strictly increasing. >>> min_increments_to_make_array_strictly_increasing(5, [1, 2, 2, 4, 3]) == 3 >>> min_increments_to_make_array_strictly_increasing(3, [3, 3, 3]) == 3 >>> min_increments_to_make_array_strictly_increasing(4, [1, 1, 1, 1]) == 6 >>> min_increments_to_make_array_strictly_increasing(5, [1, 2, 3, 4, 5]) == 0 >>> min_increments_to_make_array_strictly_increasing(3, [5, 6, 7]) == 0 >>> min_increments_to_make_array_strictly_increasing(1, [100]) == 0 >>> min_increments_to_make_array_strictly_increasing(2, [1000000000, 1000000000]) == 1","solution":"def min_increments_to_make_array_strictly_increasing(n, arr): increments = 0 for i in range(1, n): if arr[i] <= arr[i-1]: diff = arr[i-1] - arr[i] + 1 increments += diff arr[i] += diff return increments"},{"question":"def min_swaps_to_transform(a: str, b: str) -> int: Determine the minimum number of swaps required to transform string \`a\` into string \`b\`. Return -1 if it is not possible to transform string \`a\` into string \`b\`. >>> min_swaps_to_transform(\\"ab\\", \\"ba\\") == 1 >>> min_swaps_to_transform(\\"abcdefgh\\", \\"hgfedcba\\") == 4 >>> min_swaps_to_transform(\\"abcd\\", \\"abdc\\") == 1 >>> min_swaps_to_transform(\\"abcd\\", \\"abdd\\") == -1","solution":"def min_swaps_to_transform(a, b): Determine the minimum number of swaps required to transform string \`a\` into string \`b\`. Return -1 if it is not possible to transform string \`a\` into string \`b\`. if sorted(a) != sorted(b): return -1 n = len(a) swaps = 0 a = list(a) for i in range(n): if a[i] != b[i]: swap_index = i for j in range(i + 1, n): if a[j] == b[i]: swap_index = j break a[i], a[swap_index] = a[swap_index], a[i] swaps += 1 return swaps"},{"question":"def min_length_subarray(arr: List[int], s: int) -> int: You are given an array of integers and a target integer s. Your goal is to find the length of the shortest subarray whose sum is equal to or greater than the target integer s. If no such subarray exists, return -1. >>> min_length_subarray([1, 2, 3, 4, 5, 6], 15) 3 >>> min_length_subarray([1, 1, 1, 1, 1], 10) -1","solution":"def min_length_subarray(arr, s): n = len(arr) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= s: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def max_sum_after_operations(n: int, sequence: List[int]) -> int: Calculate the maximum possible sum of the sequence by inverting the sign of any subsegment any number of times. :param n: int - number of integers in the sequence :param sequence: list of int - the sequence of integers :return: int - the maximum possible sum of the sequence >>> max_sum_after_operations(5, [1, -2, 3, 4, -5]) 15 >>> max_sum_after_operations(3, [-1, -2, -3]) 6 >>> max_sum_after_operations(6, [2, -4, 6, -8, 10, -12]) 42","solution":"def max_sum_after_operations(n, sequence): Function to calculate the maximum possible sum of the sequence by inverting the sign of any subsegment any number of times. :param n: int - number of integers in the sequence :param sequence: list of int - the sequence of integers :return: int - the maximum possible sum of the sequence # Initialize the maximum sum with the sum of absolute values of all elements max_sum = sum(abs(x) for x in sequence) return max_sum"},{"question":"def ShippingFeeCalculator(weight): Calculates the total shipping fee based on the weight of the shipment. :param weight: int or float representing the weight of the shipment in kilograms :return: Total shipping fee as an integer >>> ShippingFeeCalculator(3) 5 >>> ShippingFeeCalculator(5) 5 >>> ShippingFeeCalculator(6) 7 >>> ShippingFeeCalculator(7) 9 >>> ShippingFeeCalculator(10) 15 >>> ShippingFeeCalculator(8.5) 11 >>> ShippingFeeCalculator(100) 195","solution":"def ShippingFeeCalculator(weight): Calculates the total shipping fee based on the weight of the shipment. :param weight: int or float representing the weight of the shipment in kilograms :return: Total shipping fee as an integer base_fee = 5 if weight > 5: additional_fee = (int(weight - 1) - 4) * 2 # Subtracts 1 kg and rounds down, then accounts for every kg above 5 return base_fee + additional_fee return base_fee"},{"question":"def can_alice_win(n: int, m: int, alice_points: List[int], bob_points: List[int]) -> str: Determines if there exists a non-empty subset of Alice's points where the total points is strictly greater than any subset of Bob's points. Parameters: n (int): Total rounds for Alice. m (int): Total rounds for Bob. alice_points (list): List containing points Alice scored in each round. bob_points (list): List containing points Bob scored in each round. Returns: str: \\"YES\\" if there exists such a subset, otherwise \\"NO\\". pass # Unit Tests def test_case_1(): assert can_alice_win(3, 4, [3, 5, 7], [2, 3, 4, 6]) == \\"YES\\" def test_case_2(): assert can_alice_win(2, 2, [1, 2], [2, 2]) == \\"NO\\" def test_case_3(): assert can_alice_win(1, 1, [100], [99]) == \\"YES\\" def test_case_4(): assert can_alice_win(3, 3, [1, 1, 1], [1, 1, 1]) == \\"NO\\" def test_case_5(): assert can_alice_win(5, 5, [5, 10, 15, 20, 25], [30, 35, 40, 45, 50]) == \\"NO\\" def test_case_6(): assert can_alice_win(3, 3, [10, 20, 30], [10, 20, 29]) == \\"YES\\"","solution":"def can_alice_win(n, m, alice_points, bob_points): Determines if there exists a non-empty subset of Alice's points where the total points is strictly greater than any subset of Bob's points. Parameters: n (int): Total rounds for Alice. m (int): Total rounds for Bob. alice_points (list): List containing points Alice scored in each round. bob_points (list): List containing points Bob scored in each round. Returns: str: \\"YES\\" if there exists such a subset, otherwise \\"NO\\". max_alice = max(alice_points) max_bob = max(bob_points) if max_alice > max_bob: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple def minimum_vertex_cover(n: int, edges: List[Tuple[int, int]]) -> int: Determine the minimum number of cities with communication equipment to cover the network. Args: n: An integer, the number of cities edges: A list of tuples, where each tuple represents a road between two cities Returns: An integer, the minimum number of cities with communication equipment. >>> minimum_vertex_cover(5, [(1, 2), (1, 3), (4, 5), (3, 4)]) 2 >>> minimum_vertex_cover(3, [(1, 2), (1, 3), (2, 3)]) 1 def solve_communication_issue(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Solve the communication issue for multiple test cases. Args: test_cases: A list of tuples, where each tuple represents a test case. Each test case contains an integer n (number of cities), an integer m (number of roads), and a list of tuples representing the roads. Returns: A list of integers, each representing the minimum number of cities with communication equipment for the corresponding test case. >>> test_cases = [ ... (5, 4, [(1, 2), (1, 3), (4, 5), (3, 4)]), ... (3, 3, [(1, 2), (1, 3), (2, 3)]) ... ] >>> solve_communication_issue(test_cases) [2, 1]","solution":"def minimum_vertex_cover(n, edges): from collections import defaultdict if n == 0: return 0 # Create a graph representation graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # To keep track of visited nodes visited = [False] * (n + 1) # Function to count vertex cover def vertex_cover(graph, visited): cover_count = 0 for u in range(1, n + 1): if not visited[u]: for v in graph[u]: if not visited[v]: visited[u] = True visited[v] = True cover_count += 1 break return cover_count return vertex_cover(graph, visited) def solve_communication_issue(test_cases): results = [] for n, m, edges in test_cases: results.append(minimum_vertex_cover(n, edges)) return results"},{"question":"def sum_submatrix(matrix, a, b, c, d): Returns the sum of elements in the submatrix defined by the coordinates (a, b) and (c, d). Coordinates are 1-based inclusive. pass def parse_input(input_list): Parses the input list to extract the matrix and the coordinates pass # Unit tests def test_sum_submatrix_example(): input_list = [ \\"4 4\\", \\"1 2 3 4\\", \\"5 6 7 8\\", \\"9 10 11 12\\", \\"13 14 15 16\\", \\"2 2 3 3\\" ] matrix, a, b, c, d = parse_input(input_list) assert sum_submatrix(matrix, a, b, c, d) == 34 def test_sum_submatrix_single_element(): input_list = [ \\"4 4\\", \\"1 2 3 4\\", \\"5 6 7 8\\", \\"9 10 11 12\\", \\"13 14 15 16\\", \\"1 1 1 1\\" ] matrix, a, b, c, d = parse_input(input_list) assert sum_submatrix(matrix, a, b, c, d) == 1 def test_sum_submatrix_entire_matrix(): input_list = [ \\"2 2\\", \\"1 2\\", \\"3 4\\", \\"1 1 2 2\\" ] matrix, a, b, c, d = parse_input(input_list) assert sum_submatrix(matrix, a, b, c, d) == 10 def test_sum_submatrix_large_values(): input_list = [ \\"3 3\\", \\"1000000 1000000 1000000\\", \\"1000000 1000000 1000000\\", \\"1000000 1000000 1000000\\", \\"1 1 3 3\\" ] matrix, a, b, c, d = parse_input(input_list) assert sum_submatrix(matrix, a, b, c, d) == 9000000","solution":"def sum_submatrix(matrix, a, b, c, d): Returns the sum of elements in the submatrix defined by the coordinates (a, b) and (c, d). Coordinates are 1-based inclusive. # Convert to 0-based indices for ease of iteration a, b, c, d = a - 1, b - 1, c - 1, d - 1 submatrix_sum = 0 for i in range(a, c + 1): for j in range(b, d + 1): submatrix_sum += matrix[i][j] return submatrix_sum def parse_input(input_list): Parses the input list to extract the matrix and the coordinates n, m = map(int, input_list[0].split()) matrix = [] for i in range(1, n + 1): row = list(map(int, input_list[i].split())) matrix.append(row) a, b, c, d = map(int, input_list[n + 1].split()) return matrix, a, b, c, d"},{"question":"from collections import defaultdict, deque from typing import List, Tuple class TreeDiameter: def __init__(self, n): self.n = n self.edges = defaultdict(list) def add_edge(self, p, q, d): self.edges[p].append((q, d)) self.edges[q].append((p, d)) def bfs(self, start): longest_distance = -1 furthest_node = start queue = deque([(start, 0)]) visited = set() while queue: node, dist = queue.popleft() if dist > longest_distance: longest_distance = dist furthest_node = node visited.add(node) for neighbor, length in self.edges[node]: if neighbor not in visited: queue.append((neighbor, dist + length)) return furthest_node, longest_distance def find_diameter(self): # Find the farthest node from any starting node, say node 1 leaf, _ = self.bfs(1) # Find the farthest node from the leaf found in the previous BFS _, diameter = self.bfs(leaf) return diameter def tree_diameter(n: int, edges: List[Tuple[int, int, int]]) -> int: Calculate the diameter of a binary tree given its edges. Args: n (int): The number of nodes in the tree. edges (List[Tuple[int, int, int]]): The edges of the tree represented as tuples (p, q, d). Returns: int: The diameter of the tree. >>> tree_diameter(5, [(1, 2, 3), (1, 3, 4), (2, 4, 2), (3, 5, 5)]) 14 >>> tree_diameter(2, [(1, 2, 1)]) 1 tree = TreeDiameter(n) for p, q, d in edges: tree.add_edge(p, q, d) return tree.find_diameter()","solution":"from collections import defaultdict, deque class TreeDiameter: def __init__(self, n): self.n = n self.edges = defaultdict(list) def add_edge(self, p, q, d): self.edges[p].append((q, d)) self.edges[q].append((p, d)) def bfs(self, start): longest_distance = -1 furthest_node = start queue = deque([(start, 0)]) visited = set() while queue: node, dist = queue.popleft() if dist > longest_distance: longest_distance = dist furthest_node = node visited.add(node) for neighbor, length in self.edges[node]: if neighbor not in visited: queue.append((neighbor, dist + length)) return furthest_node, longest_distance def find_diameter(self): # Find the farthest node from any starting node, say node 1 leaf, _ = self.bfs(1) # Find the farthest node from the leaf found in the previous BFS _, diameter = self.bfs(leaf) return diameter def tree_diameter(n, edges): tree = TreeDiameter(n) for p, q, d in edges: tree.add_edge(p, q, d) return tree.find_diameter()"},{"question":"def can_form_even_sum_components(n: int, values: List[int], edges: List[Tuple[int, int]]) -> str: Determine if there exists a subset of edges such that if you remove them, the resulting connected components of the tree each have an even sum of vertex values. >>> can_form_even_sum_components(6, [2, 4, 6, 8, 10, 12], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)]) \\"YES\\" >>> can_form_even_sum_components(4, [1, 3, 5, 7], [(1, 2), (2, 3), (2, 4)]) \\"NO\\"","solution":"def can_form_even_sum_components(n, values, edges): from collections import defaultdict def dfs(node, parent): subtree_sum = values[node - 1] for neighbor in graph[node]: if neighbor == parent: continue result_subtree = dfs(neighbor, node) if result_subtree % 2 == 0: even_sum_candidate.append(neighbor) subtree_sum += result_subtree return subtree_sum if sum(values) % 2 != 0: return \\"NO\\" graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) even_sum_candidate = [] dfs(1, -1) return \\"YES\\" if even_sum_candidate else \\"NO\\""},{"question":"def sum_of_absolute_differences(arr): Returns the sum of the absolute differences between consecutive elements in the list. :param arr: List of integers. :return: Integer sum of absolute differences. >>> sum_of_absolute_differences([1, -4, 7, 2, 5]) 24 >>> sum_of_absolute_differences([1, 2, 3, 4, 5]) 4 >>> sum_of_absolute_differences([-1, -2, -3, -4, -5]) 4 >>> sum_of_absolute_differences([-1, 1, -1, 1, -1]) 8 >>> sum_of_absolute_differences([5, 5, 5, 5, 5]) 0 >>> sum_of_absolute_differences([10, -10]) 20 >>> sum_of_absolute_differences([-1000, 1000]) 2000","solution":"def sum_of_absolute_differences(arr): Returns the sum of the absolute differences between consecutive elements in the list. :param arr: List of integers. :return: Integer sum of absolute differences. total_sum = 0 for i in range(1, len(arr)): total_sum += abs(arr[i] - arr[i-1]) return total_sum"},{"question":"def lexicographically_smallest_character(n: int, s: str) -> str: Given a string S composed of only uppercase English letters, find the lexicographically smallest string that can be obtained after performing the operations any number of times. The input consists of - an integer n (1 ≤ n ≤ 300000), the length of the string S. - a string S. The output should be the lexicographically smallest string that can be obtained. Examples >>> lexicographically_smallest_character(4, \\"BCDA\\") \\"A\\" >>> lexicographically_smallest_character(5, \\"EDCBA\\") \\"A\\"","solution":"def lexicographically_smallest_character(n, s): Returns the lexicographically smallest character in the string s. return min(s)"},{"question":"def length_of_LIS(sequence: List[int]) -> int: Returns the length of the longest strictly increasing sub-sequence in the given sequence. >>> length_of_LIS([5, 1, 5, 3, 4]) 3 >>> length_of_LIS([10, 20, 10, 30, 10, 40]) 4 >>> length_of_LIS([5]) 1 >>> length_of_LIS([1, 2, 3, 4, 5]) 5 >>> length_of_LIS([5, 4, 3, 2, 1]) 1 >>> length_of_LIS([3, 10, 2, 1, 20]) 3 >>> length_of_LIS([5, 5, 5, 5, 5]) 1 >>> length_of_LIS([2, 9, 3, 6, 5, 1, 7]) 4 pass","solution":"def length_of_LIS(sequence): Returns the length of the longest strictly increasing sub-sequence in the given sequence. if not sequence: return 0 from bisect import bisect_left # dp array that will store the smallest ending value of increasing subsequence of each length. dp = [] for num in sequence: pos = bisect_left(dp, num) if pos == len(dp): dp.append(num) else: dp[pos] = num return len(dp)"},{"question":"def longest_increasing_contiguous_subsequence(pots): Returns the length of the longest strictly increasing contiguous subsequence in the given pot arrangement. >>> longest_increasing_contiguous_subsequence([2, 2, 3, 4, 1, 5]) 3 >>> longest_increasing_contiguous_subsequence([5, 4, 3, 2, 1]) 1 pass # Utility function to convert given input into proper format. def process_input(input_str): Processes the input string and returns the list of pot flower counts. >>> process_input(\\"6n2 2 3 4 1 5n\\") [2, 2, 3, 4, 1, 5] >>> process_input(\\"5n5 4 3 2 1n\\") [5, 4, 3, 2, 1] pass from solution import longest_increasing_contiguous_subsequence, process_input def test_longest_increasing_subsequence_example1(): pots = process_input(\\"6n2 2 3 4 1 5n\\") assert longest_increasing_contiguous_subsequence(pots) == 3 def test_longest_increasing_subsequence_example2(): pots = process_input(\\"5n5 4 3 2 1n\\") assert longest_increasing_contiguous_subsequence(pots) == 1 def test_longest_increasing_subsequence_single_element(): pots = process_input(\\"1n7n\\") assert longest_increasing_contiguous_subsequence(pots) == 1 def test_longest_increasing_subsequence_all_increase(): pots = process_input(\\"5n1 2 3 4 5n\\") assert longest_increasing_contiguous_subsequence(pots) == 5 def test_longest_increasing_subsequence_all_decrease(): pots = process_input(\\"5n9 8 7 6 5n\\") assert longest_increasing_contiguous_subsequence(pots) == 1 def test_longest_increasing_subsequence_mixed(): pots = process_input(\\"7n10 9 2 3 2 4 5n\\") assert longest_increasing_contiguous_subsequence(pots) == 3","solution":"def longest_increasing_contiguous_subsequence(pots): Returns the length of the longest strictly increasing contiguous subsequence in the given pot arrangement. n = len(pots) if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if pots[i] > pots[i - 1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 return max(max_length, current_length) # Utility function to convert given input into proper format. def process_input(input_str): lines = input_str.strip().split(\\"n\\") n = int(lines[0].strip()) pots = list(map(int, lines[1].strip().split())) return pots"},{"question":"def has_triplet_with_sum(arr, target): Given an array of integers, detect if there exists a triplet (i, j, k) such that i < j < k, and the sum of the elements at these indices is a specific target value. :param arr: List of integers :param target: Target sum for the triplet :return: \\"Yes\\" if such triplet exists, otherwise \\"No\\" pass # Example test cases to validate your solution assert has_triplet_with_sum([1, 2, 3, 4, 5], 9) == \\"Yes\\" assert has_triplet_with_sum([1, 2, 3, 4], 10) == \\"No\\"","solution":"def has_triplet_with_sum(arr, target): Given an array of integers, detect if there exists a triplet (i, j, k) such that i < j < k, and the sum of the elements at these indices is a specific target value. :param arr: List of integers :param target: Target sum for the triplet :return: \\"Yes\\" if such triplet exists, otherwise \\"No\\" n = len(arr) arr.sort() for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return \\"Yes\\" elif current_sum < target: left += 1 else: right -= 1 return \\"No\\""},{"question":"def rearrange_books(n: int, widths: List[int]) -> List[int]: Returns the final arrangement of books after no more shifts are possible. Parameters: n (int): The number of books. widths (list of int): List of widths of the books. Returns: list of int: The final arrangement of book widths. >>> rearrange_books(5, [2, 4, 6, 3, 8]) [2, 3, 4, 6, 8] >>> rearrange_books(5, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> rearrange_books(5, [5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> rearrange_books(6, [4, 1, 3, 5, 2, 6]) [1, 2, 3, 4, 5, 6] >>> rearrange_books(1, [10]) [10]","solution":"def rearrange_books(n, widths): Returns the final arrangement of books after no more shifts are possible. Parameters: n (int): The number of books. widths (list of int): List of widths of the books. Returns: list of int: The final arrangement of book widths. while True: changed = False for i in range(n - 1): if widths[i] > widths[i + 1]: widths[i], widths[i + 1] = widths[i + 1], widths[i] changed = True if not changed: break return widths"},{"question":"def word_with_highest_distinct_vowels(words): Write a function that takes a list of words and returns the word with the highest number of distinct vowels (a, e, i, o, u). If multiple words have the same number of distinct vowels, return the one which appears first in the list. >>> word_with_highest_distinct_vowels([\\"hello\\", \\"programming\\", \\"education\\", \\"algorithm\\", \\"universe\\"]) \\"education\\" >>> word_with_highest_distinct_vowels([\\"hello\\", \\"education\\", \\"umbrella\\"]) \\"education\\" from solution import word_with_highest_distinct_vowels def test_single_word(): assert word_with_highest_distinct_vowels([\\"hello\\"]) == \\"hello\\" def test_multiple_words(): assert word_with_highest_distinct_vowels([\\"hello\\", \\"programming\\", \\"education\\", \\"algorithm\\", \\"universe\\"]) == \\"education\\" def test_tie_break(): assert word_with_highest_distinct_vowels([\\"hello\\", \\"education\\", \\"umbrella\\"]) == \\"education\\" def test_all_vowels(): assert word_with_highest_distinct_vowels([\\"aeiou\\", \\"communication\\"]) == \\"aeiou\\" def test_no_vowels(): assert word_with_highest_distinct_vowels([\\"rhythm\\", \\"brr\\", \\"pssst\\"]) == \\"rhythm\\"","solution":"def word_with_highest_distinct_vowels(words): vowels = set(\\"aeiou\\") def count_distinct_vowels(word): return len(set(word) & vowels) max_vowels = 0 result_word = \\"\\" for word in words: distinct_vowels = count_distinct_vowels(word) if distinct_vowels > max_vowels or (distinct_vowels == max_vowels and result_word == \\"\\"): max_vowels = distinct_vowels result_word = word return result_word"},{"question":"def can_enroll(m, prerequisites, n, completed_courses, target_course): Determine if the student can enroll in a specified course based on completed courses and the prerequisite structure. Args: m : int : number of courses with prerequisites prerequisites : List[str] : list containing prerequisite relationships for courses n : int : number of courses the student has completed completed_courses : List[str] : list of courses the student has completed target_course : str : course the student wishes to enroll in Returns: str : \\"Yes\\" if the student can enroll in the target_course, otherwise \\"No\\" Example: >>> can_enroll(3, [\\"CS201 CS101\\", \\"CS301 CS201\\", \\"CS401 CS301\\"], 2, [\\"CS101\\", \\"CS201\\"], \\"CS301\\") \\"Yes\\" >>> can_enroll(2, [\\"ENG301 ENG101\\", \\"ENG401 ENG301\\"], 1, [\\"ENG101\\"], \\"ENG401\\") \\"No\\" pass def process_input(input_data): Process input data and determine enrollment eligibility for each data set. Args: input_data : List[str] : input data representing multiple data sets of course prerequisites and completed courses Returns: List[str] : list of results for each data set, either \\"Yes\\" or \\"No\\" Example: >>> process_input([ \\"3\\", \\"CS201 CS101\\", \\"CS301 CS201\\", \\"CS401 CS301\\", \\"2\\", \\"CS101\\", \\"CS201\\", \\"CS301\\", \\"2\\", \\"ENG301 ENG101\\", \\"ENG401 ENG301\\", \\"1\\", \\"ENG101\\", \\"ENG401\\", \\"0\\" ]) [\\"Yes\\", \\"No\\"] pass","solution":"def can_enroll(m, prerequisites, n, completed_courses, target_course): prereq_map = {} for course in prerequisites: parts = course.split() prereq_map[parts[0]] = parts[1:] completed_courses_set = set(completed_courses) def has_completed_prerequisites(course): if course in completed_courses_set: return True if course not in prereq_map: return False for prereq in prereq_map[course]: if prereq not in completed_courses_set: return False return True return \\"Yes\\" if has_completed_prerequisites(target_course) else \\"No\\" def process_input(input_data): results = [] idx = 0 while idx < len(input_data): m = int(input_data[idx]) if m == 0: break idx += 1 prerequisites = input_data[idx:idx + m] idx += m n = int(input_data[idx]) idx += 1 completed_courses = input_data[idx:idx + n] idx += n target_course = input_data[idx] idx += 1 results.append(can_enroll(m, prerequisites, n, completed_courses, target_course)) return results # Example usage with the initial example provided if __name__ == \\"__main__\\": input_data = [ \\"3\\", \\"CS201 CS101\\", \\"CS301 CS201\\", \\"CS401 CS301\\", \\"2\\", \\"CS101\\", \\"CS201\\", \\"CS301\\", \\"2\\", \\"ENG301 ENG101\\", \\"ENG401 ENG301\\", \\"1\\", \\"ENG101\\", \\"ENG401\\", \\"0\\" ] output = process_input(input_data) for result in output: print(result)"},{"question":"def find_single_number(nums: List[int]) -> int: Returns the single integer in the list where every other integer appears twice. >>> find_single_number([4, 3, 2, 4, 1, 3, 2]) 1 >>> find_single_number([7, 3, 5, 3, 5]) 7 >>> find_single_number([1, 1, 2, 2, 3, 3, 4]) 4 >>> find_single_number([10, 20, 10, 30, 20, 40, 30, 40, 50]) 50 >>> find_single_number([99]) 99","solution":"def find_single_number(nums): Returns the single integer in the list where every other integer appears twice. Utilizes XOR operation to achieve O(n) runtime complexity and O(1) space complexity. single_number = 0 for num in nums: single_number ^= num return single_number"},{"question":"def is_balanced(arr: List[int]) -> str: Determine if the array is balanced. Parameters: arr (list): A list of integers representing the heights of the buildings. Returns: str: \\"YES\\" if the array is balanced, \\"NO\\" otherwise. >>> is_balanced([5]) == \\"YES\\" >>> is_balanced([3, 4, 3, 4, 3]) == \\"YES\\" >>> is_balanced([7, 5, 6]) == \\"NO\\" >>> is_balanced([1, 1, 1, 1]) == \\"YES\\" >>> is_balanced([1, 3]) == \\"NO\\" >>> is_balanced([1, 2, 1, 2, 1, 0]) == \\"YES\\" >>> is_balanced([-10**9, -10**9+1, -10**9]) == \\"YES\\" >>> is_balanced([-10**9, 10**9]) == \\"NO\\"","solution":"def is_balanced(arr): Determine if the array is balanced. Parameters: arr (list): A list of integers representing the heights of the buildings. Returns: str: \\"YES\\" if the array is balanced, \\"NO\\" otherwise. n = len(arr) if n == 1: return \\"YES\\" for i in range(1, n): if abs(arr[i] - arr[i-1]) > 1: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List def minimum_steps(n: int, m: int, grid: List[str]) -> int: Determine the minimum number of steps for the robot to reach the bottom-right corner. Returns -1 if there is no possible path. >>> minimum_steps(4, 4, [\\"....\\", \\"..#.\\", \\"..#.\\", \\"....\\"]) 6 >>> minimum_steps(3, 3, [\\".#.\\", \\".#.\\", \\".#.\\"]) -1 # Your code here # Unit Tests import pytest def test_minimum_steps_basic(): assert minimum_steps(4, 4, [ \\"....\\", \\"..#.\\", \\"..#.\\", \\"....\\" ]) == 6 def test_minimum_steps_no_path(): assert minimum_steps(3, 3, [ \\".#.\\", \\".#.\\", \\".#.\\" ]) == -1 def test_minimum_steps_complex(): assert minimum_steps(5, 5, [ \\".....\\", \\".\\", \\".#...\\", \\"...\\", \\".....\\" ]) == 8 def test_minimum_steps_single_row(): assert minimum_steps(1, 5, [ \\".....\\" ]) == 4 def test_minimum_steps_single_column(): assert minimum_steps(5, 1, [ \\".\\", \\".\\", \\".\\", \\".\\", \\".\\" ]) == 4 def test_minimum_steps_obstacle_start(): assert minimum_steps(2, 2, [ \\"#.\\", \\"..\\" ]) == -1 def test_minimum_steps_obstacle_end(): assert minimum_steps(2, 2, [ \\"..\\", \\".#\\" ]) == -1","solution":"from collections import deque def minimum_steps(n, m, grid): Determine the minimum number of steps for the robot to reach the bottom-right corner. Returns -1 if there is no possible path. if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] visited = [[False] * m for _ in range(n)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited[0][0] = True while queue: x, y, steps = queue.popleft() if x == n - 1 and y == m - 1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, steps + 1)) return -1"},{"question":"def check_serial_numbers(n: int, serial_numbers: List[str]) -> str: Verifies the ordering of serial numbers and identifies the first misplaced serial number if any exists. :param n: Number of serial numbers :param serial_numbers: List of serial numbers :return: \\"Sorted\\" if all serial numbers are sorted, otherwise \\"Misplaced\\" followed by the index and the serial number. for i in range(n - 1): if serial_numbers[i] > serial_numbers[i + 1]: return f\\"Misplaced {i + 1} {serial_numbers[i]}\\" return \\"Sorted\\" # Example usage: # n = 4 # serial_numbers = [\\"alpha\\", \\"delta\\", \\"bravo\\", \\"echo\\"] # print(check_serial_numbers(n, serial_numbers)) # Output: \\"Misplaced 2 delta\\"","solution":"def check_serial_numbers(n, serial_numbers): Verifies the ordering of serial numbers and identifies the first misplaced serial number if any exists. :param n: Number of serial numbers :param serial_numbers: List of serial numbers :return: \\"Sorted\\" if all serial numbers are sorted, otherwise \\"Misplaced\\" followed by the index and the serial number. for i in range(n - 1): if serial_numbers[i] > serial_numbers[i + 1]: return f\\"Misplaced {i + 1} {serial_numbers[i]}\\" return \\"Sorted\\" # Example usage: # n = 4 # serial_numbers = [\\"alpha\\", \\"delta\\", \\"bravo\\", \\"echo\\"] # print(check_serial_numbers(n, serial_numbers)) # Output: \\"Misplaced 2 delta\\""},{"question":"def max_path_sum(n: int, values: List[int], edges: List[Tuple[int, int]]) -> int: Determine the maximum sum of values from the root to any leaf in the tree. >>> max_path_sum(5, [3, 2, 1, 10, 1], [(1, 2), (1, 3), (2, 4), (2, 5)]) 15 >>> max_path_sum(3, [1, 2, 3], [(1, 2), (2, 3)]) 6 >>> max_path_sum(1, [5], []) 5 >>> max_path_sum(2, [1, 2], [(1, 2)]) 3 >>> max_path_sum(3, [5, 3, 4], [(1, 2), (1, 3)]) 9 >>> max_path_sum(7, [1, 2, 3, 4, 5, 6, 7], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) 11 >>> max_path_sum(5, [1, 1, 1, 1, 100], [(1, 2), (2, 3), (3, 4), (4, 5)]) 104","solution":"def max_path_sum(n, values, edges): from collections import defaultdict, deque # Create an adjacency list for the tree tree = defaultdict(list) for a, b in edges: tree[a].append(b) tree[b].append(a) # Use a DFS approach to find the maximum path sum def dfs(node, parent): max_sum = 0 for child in tree[node]: if child != parent: max_sum = max(max_sum, dfs(child, node)) return values[node-1] + max_sum return dfs(1, -1) # Example usage: # n = 5 # values = [3, 2, 1, 10, 1] # edges = [(1, 2), (1, 3), (2, 4), (2, 5)] # print(max_path_sum(n, values, edges)) # Output: 15"},{"question":"def analyze_page_visits(n: int, p: int, paths: List[List[int]]) -> Tuple[int, int]: Analyzes the page visits from paths and identifies the highest visit count and the number of pages with this visit count. :param n: Total number of pages :param p: Number of paths :param paths: List of paths, where each path is a list of page IDs :return: A tuple containing the highest visit count and the number of pages with that count >>> analyze_page_visits(4, 3, [[1, 2, 3], [2, 3, 4], [3, 4]]) (3, 1) >>> analyze_page_visits(5, 4, [[1, 2], [2, 3], [4, 5], [5]]) (2, 2)","solution":"def analyze_page_visits(n, p, paths): Analyzes the page visits from paths and identifies the highest visit count and the number of pages with this visit count. :param n: Total number of pages :param p: Number of paths :param paths: List of paths, where each path is a list of page IDs :return: A tuple containing the highest visit count and the number of pages with that count visit_counts = [0] * (n + 1) for path in paths: for page in path: visit_counts[page] += 1 max_visits = max(visit_counts) max_visits_count = visit_counts.count(max_visits) return max_visits, max_visits_count # Example usage n, p = 4, 3 paths = [[1, 2, 3], [2, 3, 4], [3, 4]] print(analyze_page_visits(n, p, paths)) # Output: (3, 1)"},{"question":"def prime_numbers_in_range(L: int, R: int) -> List[int]: Finds all the prime numbers in the inclusive range [L, R]. >>> prime_numbers_in_range(5, 15) [5, 7, 11, 13] >>> prime_numbers_in_range(10, 20) [11, 13, 17, 19] >>> prime_numbers_in_range(1, 10) [2, 3, 5, 7] >>> prime_numbers_in_range(14, 16) [] >>> prime_numbers_in_range(1, 100) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] >>> prime_numbers_in_range(2, 2) [2] >>> prime_numbers_in_range(1, 1) [] >>> prime_numbers_in_range(0, 1) [] >>> prime_numbers_in_range(10**5 - 1, 10**5) []","solution":"def prime_numbers_in_range(L, R): Returns a list of prime numbers in the inclusive range [L, R]. def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True primes = [] for num in range(L, R + 1): if is_prime(num): primes.append(num) return primes"},{"question":"def can_reach_bottom_right(n, m, obstacles): Determines if there's a path from (1,1) to (n,n) in an n x n grid with obstacles. Args: n (int): The dimension of the grid. m (int): The number of obstacles. obstacles (list of tuples): A list of (x, y) coordinates indicating obstacle positions. Returns: str: \\"YES\\" if there's a path, otherwise \\"NO\\".","solution":"def can_reach_bottom_right(n, m, obstacles): Determines if there's a path from (1,1) to (n,n) in an n x n grid with obstacles. Args: n (int): The dimension of the grid. m (int): The number of obstacles. obstacles (list of tuples): A list of (x, y) coordinates indicating obstacle positions. Returns: str: \\"YES\\" if there's a path, otherwise \\"NO\\". from collections import deque # Create the grid and mark obstacles grid = [[0] * n for _ in range(n)] for (x, y) in obstacles: grid[x-1][y-1] = 1 # mark obstacle (convert 1-based to 0-based index) # If start or end is an obstacle, return \\"NO\\" if grid[0][0] == 1 or grid[n-1][n-1] == 1: return \\"NO\\" # Breadth-First Search (BFS) to find path directions = [(0, 1), (1, 0)] # right, down queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (n-1, n-1): return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) return \\"NO\\""},{"question":"def sort_distinct_and_repeated(n: int, elements: List[int]) -> List[int]: Sort a list of integers such that all distinct elements come first in ascending order, followed by all repeated elements in ascending order. >>> sort_distinct_and_repeated(6, [4, 3, 2, 4, 5, 2]) [3, 5, 2, 2, 4, 4] >>> sort_distinct_and_repeated(5, [1, 3, 3, 1, 2]) [2, 1, 1, 3, 3] >>> sort_distinct_and_repeated(4, [7, -1, -5, 7]) [-5, -1, 7, 7] >>> sort_distinct_and_repeated(1, [0]) [0] >>> sort_distinct_and_repeated(8, [-1, -2, -3, -1, -4, -2, -5, -3]) [-5, -4, -3, -3, -2, -2, -1, -1]","solution":"def sort_distinct_and_repeated(n, elements): from collections import Counter # Taking the count of each element element_counter = Counter(elements) # Separate the elements to distinct and repeated lists distinct_elements = [] repeated_elements = [] for element, count in element_counter.items(): if count == 1: distinct_elements.append(element) else: repeated_elements += [element] * count # Sort both lists distinct_elements.sort() repeated_elements.sort() # Concatenate the lists and return sorted_elements = distinct_elements + repeated_elements return sorted_elements"},{"question":"from typing import List, Tuple def longest_path(n: int, nodes: List[Tuple[int, int, int]]) -> int: Compute the longest path between any two nodes in a graph where each node can have at most 2 outgoing edges. >>> longest_path(4, [(1, 2, 2, 3), (2, 1, 3), (3, 1, 4), (4, 0)]) 3 >>> longest_path(4, [(1, 2, 2, 3), (2, 1, 3), (3, 1, 2), (4, 0)]) -1 >>> longest_path(1, [(1, 0)]) 0 >>> longest_path(3, [(1, 1, 2), (2, 0), (3, 0)]) 1 >>> longest_path(4, [(1, 1, 2), (2, 0), (3, 1, 4), (4, 0)]) 1","solution":"def longest_path(n, nodes): from collections import defaultdict, deque # Build graph from the list of nodes graph = defaultdict(list) in_degree = {i: 0 for i in range(1, n + 1)} for node in nodes: node_id, count, *edges = node for edge in edges: graph[node_id].append(edge) in_degree[edge] += 1 # Detect cycles using Kahn's algorithm (Topological Sort) queue = deque([node for node in in_degree if in_degree[node] == 0]) topo_order = [] while queue: node = queue.popleft() topo_order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(topo_order) != n: # Cycle detected return -1 # Initialize distances distances = {i: float('-inf') for i in range(1, n + 1)} for node in topo_order: distances[node] = 0 # Compute the longest path max_distance = 0 for node in topo_order: for neighbor in graph[node]: if distances[neighbor] < distances[node] + 1: distances[neighbor] = distances[node] + 1 max_distance = max(max_distance, distances[neighbor]) return max_distance"},{"question":"def find_max_profit(prices, fee): Returns the maximum profit that can be achieved with the given prices and fee. >>> find_max_profit([1, 3, 2, 8, 4, 9], 2) == 8 >>> find_max_profit([1, 3, 7, 5, 10], 1) == 9 >>> find_max_profit([1, 7, 5], 0) == 6 >>> find_max_profit([1, 1, 1, 1, 1], 2) == 0 >>> find_max_profit([1, 10, 20, 30, 40], 50) == 0 pass def max_profits(t, test_cases): Given the number of test cases and the test case details, it returns the maximum profits for each test case. >>> max_profits(3, [((6, 2), [1, 3, 2, 8, 4, 9]), ((5, 1), [1, 3, 7, 5, 10]), ((3, 0), [1, 7, 5])]) == [8, 9, 6] pass","solution":"def find_max_profit(prices, fee): Returns the maximum profit that can be achieved with the given prices and fee. n = len(prices) if n == 0: return 0 # Initialize the previous hold and cash states hold = -prices[0] cash = 0 for price in prices[1:]: cash = max(cash, hold + price - fee) hold = max(hold, cash - price) return cash def max_profits(t, test_cases): results = [] for case in test_cases: n, fee = case[0] prices = case[1] results.append(find_max_profit(prices, fee)) return results # Example usage: # t = 3 # test_cases = [((6, 2), [1, 3, 2, 8, 4, 9]), ((5, 1), [1, 3, 7, 5, 10]), ((3, 0), [1, 7, 5])] # print(max_profits(t, test_cases)) # Outputs: [8, 9, 6]"},{"question":"from typing import List, Union def generate_pin_codes(n: int) -> Union[str, List[str]]: Generate unique 4-digit pin codes for 'n' rooms, ensuring no two digits are the same and the pin code is not a palindrome. >>> generate_pin_codes(1) [\\"1032\\"] >>> generate_pin_codes(5) [\\"1032\\", \\"2043\\", \\"3052\\", \\"4061\\", \\"5074\\"] >>> generate_pin_codes(5041) \\"Impossible\\"","solution":"from typing import List, Union def is_valid_pin(pin: str) -> bool: # Checks if pin is a 4-digit number with all unique digits and not a palindrome if len(pin) != 4 or len(set(pin)) != 4: return False return pin != pin[::-1] def generate_pin_codes(n: int) -> Union[str, List[str]]: if n > 5040: return \\"Impossible\\" pin_codes = [] digits = '0123456789' from itertools import permutations perm = permutations(digits, 4) for p in perm: pin = ''.join(p) if is_valid_pin(pin): pin_codes.append(pin) if len(pin_codes) == n: break return pin_codes if len(pin_codes) == n else \\"Impossible\\""},{"question":"from typing import List def threeSum(nums: List[int]) -> List[List[int]]: Find all unique triplets in the array which gives the sum of zero. :param nums: List of integers :return: List of lists containing unique triplets that sum to zero >>> sorted(threeSum([-1, 0, 1, 2, -1, -4])) [[-1, -1, 2], [-1, 0, 1]] >>> threeSum([]) [] >>> threeSum([0]) [] pass","solution":"from typing import List def threeSum(nums: List[int]) -> List[List[int]]: Find all unique triplets in the array which gives the sum of zero. :param nums: List of integers :return: List of lists containing unique triplets that sum to zero nums.sort() n = len(nums) result = [] for i in range(n): if i > 0 and nums[i] == nums[i - 1]: # Skip duplicate elements continue left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return result"},{"question":"def process_reports(t, reports): Process a list of daily reports and return the number of valid and invalid items for each report. :param t: Integer, number of daily reports. :param reports: List of tuples, where each tuple contains: - an integer n: the number of items in the daily report - a list of strings: the item identifiers for that day :returns: List of tuples, where each tuple contains: - the first integer is the number of valid items - the second integer is the number of invalid items >>> process_reports(1, [(5, ['I1234', 'I5678', 'I0000', 'I1234', 'I9999'])]) [(4, 1)] >>> process_reports(1, [(3, ['I2345', 'I234', 'I1236'])]) [(2, 1)] >>> process_reports(2, [(5, ['I1234', 'I5678', 'I0000', 'I1234', 'I9999']), (3, ['I2345', 'I234', 'I1236'])]) [(4, 1), (2, 1)] >>> process_reports(1, [(4, ['12345', 'I123', 'II123', 'I12AB'])]) [(0, 4)] >>> process_reports(1, [(0, [])]) [(0, 0)]","solution":"def process_reports(t, reports): def is_valid_identifier(identifier, seen): # Check format if len(identifier) == 5 and identifier[0] == 'I' and identifier[1:].isdigit(): if identifier not in seen: return True return False results = [] for report in reports: n = report[0] identifiers = report[1] valid_count = 0 invalid_count = 0 seen = set() for identifier in identifiers: if is_valid_identifier(identifier, seen): valid_count += 1 seen.add(identifier) else: invalid_count += 1 results.append((valid_count, invalid_count)) return results"},{"question":"def max_unique_snowmen(n: int, heights: List[int]) -> int: Returns the maximum number of unique snowmen that can be created from the given array of heights. Args: n (int): The number of snowballs. heights (List[int]): The heights of the snowballs. Returns: int: The maximum number of unique snowmen. >>> max_unique_snowmen(7, [1, 2, 3, 3, 4, 5, 5]) == 5 >>> max_unique_snowmen(4, [10, 20, 10, 20]) == 2 >>> max_unique_snowmen(5, [1, 2, 3, 4, 5]) == 5 >>> max_unique_snowmen(4, [7, 7, 7, 7]) == 1 >>> max_unique_snowmen(6, [1, 1, 2, 2, 3, 3]) == 3","solution":"def max_unique_snowmen(n, heights): Returns the maximum number of unique snowmen that can be created from the given array of heights. unique_heights = set(heights) # Remove duplicates by converting the list to a set return len(unique_heights)"},{"question":"def max_completed_projects(n: int, m: int, employee_skills: List[str], project_requirements: List[str]) -> int: Determine the maximum number of projects that can be completed given the skills of the employees and the skill requirements for each project. Args: n (int): Number of employees m (int): Number of projects employee_skills (list of str): List of skills for each employee project_requirements (list of str): List of skill requirements for each project Returns: int: Maximum number of projects that can be completed # Write your code here return 0 # Change this return statement appropriately # Test Cases def test_example_case(): n = 4 m = 3 employee_skills = [\\"abc\\", \\"a\\", \\"bc\\", \\"ab\\"] project_requirements = [\\"ab\\", \\"c\\", \\"abc\\"] assert max_completed_projects(n, m, employee_skills, project_requirements) == 3 def test_no_projects_possible(): n = 2 m = 2 employee_skills = [\\"a\\", \\"b\\"] project_requirements = [\\"c\\", \\"d\\"] assert max_completed_projects(n, m, employee_skills, project_requirements) == 0 def test_all_employees_identical_skill(): n = 3 m = 3 employee_skills = [\\"abc\\", \\"abc\\", \\"abc\\"] project_requirements = [\\"a\\", \\"b\\", \\"c\\"] assert max_completed_projects(n, m, employee_skills, project_requirements) == 3 def test_various_skill_levels(): n = 4 m = 4 employee_skills = [\\"a\\", \\"bc\\", \\"abc\\", \\"de\\"] project_requirements = [\\"a\\", \\"b\\", \\"c\\", \\"def\\"] assert max_completed_projects(n, m, employee_skills, project_requirements) == 3 def test_large_input_size(): n = 1000 m = 1000 employee_skills = [\\"a\\"*50 for _ in range(n)] project_requirements = [\\"a\\"*50 for _ in range(m)] assert max_completed_projects(n, m, employee_skills, project_requirements) == 1000","solution":"def max_completed_projects(n, m, employee_skills, project_requirements): Determine the maximum number of projects that can be completed given the skills of the employees and the skill requirements for each project. Args: n (int): Number of employees m (int): Number of projects employee_skills (list of str): List of skills for each employee project_requirements (list of str): List of skill requirements for each project Returns: int: Maximum number of projects that can be completed # Convert list of employee skills and project requirements to sets for easy comparison employee_sets = [set(skills) for skills in employee_skills] project_sets = [set(requirements) for requirements in project_requirements] max_projects = 0 for project in project_sets: for employee in employee_sets: if project.issubset(employee): max_projects += 1 break return max_projects"},{"question":"from collections import deque def conveyor_belt(operations): Execute operations on a conveyor belt and return the final state. >>> conveyor_belt([\\"insert_back 4\\", \\"insert_front 3\\", \\"remove_back\\", \\"insert_front 5\\", \\"insert_back 7\\"]) \\"5 3 7\\" >>> conveyor_belt([\\"insert_front 2\\", \\"remove_front\\", \\"remove_front\\"]) \\"empty\\"","solution":"from collections import deque def conveyor_belt(operations): belt = deque() for operation in operations: op = operation.split() if op[0] == \\"insert_front\\": belt.appendleft(int(op[1])) elif op[0] == \\"insert_back\\": belt.append(int(op[1])) elif op[0] == \\"remove_front\\": if belt: belt.popleft() elif op[0] == \\"remove_back\\": if belt: belt.pop() if belt: return \\" \\".join(map(str, belt)) else: return \\"empty\\""},{"question":"def canMakeIdentical(n: int, a: List[int], b: List[int]) -> str: Determines if arrays a and b can be made identical by incrementing or decrementing both arrays by the same amount at each index. Parameters: n: int - the size of the arrays a: list of int - the first array b: list of int - the second array Returns: str: \\"YES\\" if the arrays can be made identical, \\"NO\\" otherwise >>> canMakeIdentical(5, [1, 2, 3, 4, 5], [2, 3, 4, 5, 6]) 'YES' >>> canMakeIdentical(4, [1, 3, 5, 7], [9, 11, 13, 15]) 'YES' >>> canMakeIdentical(3, [1, 2, 3], [4, 5, 7]) 'NO' Test Cases: def test_can_make_identical(): assert canMakeIdentical(5, [1, 2, 3, 4, 5], [2, 3, 4, 5, 6]) == \\"YES\\" assert canMakeIdentical(4, [1, 3, 5, 7], [9, 11, 13, 15]) == \\"YES\\" assert canMakeIdentical(3, [1, 2, 3], [4, 5, 7]) == \\"NO\\" assert canMakeIdentical(1, [1], [1]) == \\"YES\\" assert canMakeIdentical(2, [1, 2], [3, 4]) == \\"YES\\" assert canMakeIdentical(3, [1, 2, 3], [1, 2, 5]) == \\"NO\\" assert canMakeIdentical(4, [0, 0, 0, 0], [0, 0, 0, 0]) == \\"YES\\" a_max = [i for i in range(1, 101)] b_max = [i + 3 for i in range(1, 101)] assert canMakeIdentical(100, a_max, b_max) == \\"YES\\"","solution":"def canMakeIdentical(n, a, b): Determines if arrays a and b can be made identical by incrementing or decrementing both arrays by the same amount at each index. Parameters: n: int - the size of the arrays a: list of int - the first array b: list of int - the second array Returns: str: \\"YES\\" if the arrays can be made identical, \\"NO\\" otherwise differences = {b[i] - a[i] for i in range(n)} return \\"YES\\" if len(differences) == 1 else \\"NO\\""},{"question":"def filter_messages_by_sender(messages, sender_name): Filters messages by the specified sender's name. Parameters: messages (list of tuples): List of messages where each message is represented as a tuple (message_id, sender, content). sender_name (str): The name of the sender whose messages need to be filtered. Returns: list: A list of message contents sent by the specified sender. pass # Example usage: # messages = [(1, \\"Alice\\", \\"Hello there!\\"), (2, \\"Bob\\", \\"Hi, Alice!\\"), (3, \\"Alice\\", \\"How are you?\\"), # (4, \\"Charlie\\", \\"Hey everyone!\\"), (5, \\"Alice\\", \\"I'm doing great, thanks!\\")] # sender_name = \\"Alice\\" # print(filter_messages_by_sender(messages, sender_name)) # Output: [\\"Hello there!\\", \\"How are you?\\", \\"I'm doing great, thanks!\\"] from solution import filter_messages_by_sender def test_filter_messages_by_sender_multiple_matches(): messages = [ (1, \\"Alice\\", \\"Hello there!\\"), (2, \\"Bob\\", \\"Hi, Alice!\\"), (3, \\"Alice\\", \\"How are you?\\"), (4, \\"Charlie\\", \\"Hey everyone!\\"), (5, \\"Alice\\", \\"I'm doing great, thanks!\\") ] sender_name = \\"Alice\\" expected = [\\"Hello there!\\", \\"How are you?\\", \\"I'm doing great, thanks!\\"] assert filter_messages_by_sender(messages, sender_name) == expected def test_filter_messages_by_sender_single_match(): messages = [ (1, \\"Alice\\", \\"Hello there!\\"), (2, \\"Bob\\", \\"Hi, Alice!\\"), (3, \\"Charlie\\", \\"How are you?\\"), (4, \\"David\\", \\"Hey everyone!\\"), (5, \\"Eve\\", \\"I'm doing great, thanks!\\") ] sender_name = \\"David\\" expected = [\\"Hey everyone!\\"] assert filter_messages_by_sender(messages, sender_name) == expected def test_filter_messages_by_sender_no_matches(): messages = [ (1, \\"Alice\\", \\"Hello there!\\"), (2, \\"Bob\\", \\"Hi, Alice!\\"), (3, \\"Charlie\\", \\"How are you?\\"), (4, \\"David\\", \\"Hey everyone!\\"), (5, \\"Eve\\", \\"I'm doing great, thanks!\\") ] sender_name = \\"Frank\\" expected = [] assert filter_messages_by_sender(messages, sender_name) == expected def test_filter_messages_by_sender_all_matches(): messages = [ (1, \\"Frank\\", \\"Hello there!\\"), (2, \\"Frank\\", \\"How are you?\\"), (3, \\"Frank\\", \\"Hey everyone!\\"), (4, \\"Frank\\", \\"I'm doing great, thanks!\\") ] sender_name = \\"Frank\\" expected = [\\"Hello there!\\", \\"How are you?\\", \\"Hey everyone!\\", \\"I'm doing great, thanks!\\"] assert filter_messages_by_sender(messages, sender_name) == expected def test_filter_messages_by_sender_empty_list(): messages = [] sender_name = \\"Alice\\" expected = [] assert filter_messages_by_sender(messages, sender_name) == expected","solution":"def filter_messages_by_sender(messages, sender_name): Filters messages by the specified sender's name. Parameters: messages (list of tuples): List of messages where each message is represented as a tuple (message_id, sender, content). sender_name (str): The name of the sender whose messages need to be filtered. Returns: list: A list of message contents sent by the specified sender. return [content for _, sender, content in messages if sender == sender_name] # Example usage: # messages = [(1, \\"Alice\\", \\"Hello there!\\"), (2, \\"Bob\\", \\"Hi, Alice!\\"), (3, \\"Alice\\", \\"How are you?\\"), # (4, \\"Charlie\\", \\"Hey everyone!\\"), (5, \\"Alice\\", \\"I'm doing great, thanks!\\")] # sender_name = \\"Alice\\" # print(filter_messages_by_sender(messages, sender_name)) # Output: [\\"Hello there!\\", \\"How are you?\\", \\"I'm doing great, thanks!\\"]"},{"question":"def are_anagrams(string1: str, string2: str) -> str: Determines if the two provided strings are anagrams of each other. Args: string1 (str): The first string. string2 (str): The second string. Returns: str: \\"YES\\" if the strings are anagrams, otherwise \\"NO\\". Examples: >>> are_anagrams(\\"listen\\", \\"silent\\") \\"YES\\" >>> are_anagrams(\\"hello\\", \\"billion\\") \\"NO\\"","solution":"def are_anagrams(string1, string2): Determines if the two provided strings are anagrams of each other. Args: string1 (str): The first string. string2 (str): The second string. Returns: str: \\"YES\\" if the strings are anagrams, otherwise \\"NO\\". if sorted(string1) == sorted(string2): return \\"YES\\" else: return \\"NO\\""},{"question":"def longest_subsequence_length(n: int, array: List[int], m: int, allowed_differences: List[int]) -> int: Find the length of the longest subsequence such that the difference between any two successive elements is in a given set of allowed differences. Example: >>> longest_subsequence_length(7, [2, 4, 3, 5, 7, 6, 8], 2, [1, 2]) 5 >>> longest_subsequence_length(4, [1, 2, 3, 4], 1, [1]) 4 >>> longest_subsequence_length(6, [10, 20, 10, 30, 10, 40], 3, [10, 20, 30]) 4 pass","solution":"def longest_subsequence_length(n, array, m, allowed_differences): dp = [1] * n for i in range(n): for j in range(i): if array[i] - array[j] in allowed_differences: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def max_sum_subarray(n, m, array): Determines the maximum sum of a contiguous subarray of length exactly m. Parameters: n (int): The number of integers in the array. m (int): The exact length of the subarray. array (list of int): The elements of the array. Returns: int: The maximum sum of the subarray of length m, or -1 if not possible.","solution":"def max_sum_subarray(n, m, array): Determines the maximum sum of a contiguous subarray of length exactly m. Parameters: n (int): The number of integers in the array. m (int): The exact length of the subarray. array (list of int): The elements of the array. Returns: int: The maximum sum of the subarray of length m, or -1 if not possible. if m > n: return -1 # Initial sum of the first subarray of length m max_sum = sum(array[:m]) current_sum = max_sum # Iterate through the array to find the maximum sum for i in range(m, n): current_sum += array[i] - array[i - m] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def minimize_absolute_differences(N: int, A: List[int], B: List[int]) -> List[int]: Rearranges elements of array A to minimize the sum of absolute differences between corresponding elements of A and B. A.sort() B.sort() return A # Here are some test cases to check the function: # >>> minimize_absolute_differences(4, [4, 1, 8, 7], [2, 3, 6, 5]) # [1, 4, 7, 8] # >>> minimize_absolute_differences(1, [3], [4]) # [3] # >>> minimize_absolute_differences(3, [0, 0, 0], [0, 0, 0]) # [0, 0, 0] # >>> minimize_absolute_differences(3, [-1, -2, -3], [-4, -5, -6]) # [-3, -2, -1] # >>> minimize_absolute_differences(4, [1, -1, 2, -2], [2, -2, 1, -1]) # [-2, -1, 1, 2]","solution":"def minimize_absolute_differences(N, A, B): Rearranges elements of array A to minimize the sum of absolute differences between corresponding elements of A and B. A.sort() B.sort() return A"},{"question":"def minimum_sum_of_distances(n: int, positions: List[int]) -> int: Returns the minimum possible sum of distances between every pair of neighboring cities after constructing a railway line. Parameters: n (int): Number of cities positions (List[int]): Positions of the cities along the horizontal line Returns: int: Minimum possible sum of distances Examples: >>> minimum_sum_of_distances(4, [1, 3, 8, 10]) 9 >>> minimum_sum_of_distances(5, [5, 7, 9, 1, 4]) 8 >>> minimum_sum_of_distances(3, [-3, 0, 3]) 6","solution":"def minimum_sum_of_distances(n, positions): Returns the minimum possible sum of distances between every pair of neighboring cities after constructing a railway line. Parameters: n (int): Number of cities positions (List[int]): Positions of the cities along the horizontal line Returns: int: Minimum possible sum of distances # Sort the positions to minimize the distances between neighboring cities positions.sort() # Calculate the sum of distances between consecutive cities min_sum = sum(abs(positions[i] - positions[i - 1]) for i in range(1, n)) return min_sum"},{"question":"from typing import List def merge_strips(M: int, S: int, strips: List[List[int]]) -> List[int]: Merges M strips into a single non-decreasing sequence truncated to size S. Parameters: - M (int): Number of strips. - S (int): Maximum length of the merged sequence. - strips (List[List[int]]): List of M integer strips, each representing a non-decreasing sequence of positive integers. Returns: - List[int]: The merged and truncated sequence. Examples: >>> merge_strips(3, 5, [[1, 4, 7], [2, 3], [5, 6, 8, 9]]) [1, 2, 3, 4, 5] >>> merge_strips(2, 4, [[1, 3, 5], [2, 4, 6, 7]]) [1, 2, 3, 4]","solution":"import heapq def merge_strips(M, S, strips): Merges M strips into a single non-decreasing sequence truncated to size S. # Initialize a min-heap heap = [] # Insert the first element of each strip into the heap along with the strip index and element index for i in range(M): if len(strips[i]) > 0: heapq.heappush(heap, (strips[i][0], i, 0)) merged_sequence = [] # Extract the minimum element from the heap while heap and len(merged_sequence) < S: value, strip_index, element_index = heapq.heappop(heap) merged_sequence.append(value) # If there's more elements in the same strip, add the next element to the heap if element_index + 1 < len(strips[strip_index]): heapq.heappush(heap, (strips[strip_index][element_index + 1], strip_index, element_index + 1)) return merged_sequence # Sample input for manual testing M = 3 S = 5 strips = [ [1, 4, 7], [2, 3], [5, 6, 8, 9] ] print(merge_strips(M, S, strips)) # Output: [1, 2, 3, 4, 5]"},{"question":"def all_in_first_quadrant(pairs): Returns \\"Yes\\" if all pairs are in the first quadrant (both coordinates are positive), otherwise returns \\"No\\". Parameters: pairs (list of tuples): A list of 7 tuples, each containing two integers x and y. Returns: str: \\"Yes\\" if all pairs are in the first quadrant, \\"No\\" otherwise.","solution":"def all_in_first_quadrant(pairs): Returns \\"Yes\\" if all pairs are in the first quadrant (both coordinates are positive), otherwise returns \\"No\\". Parameters: pairs (list of tuples): A list of 7 tuples, each containing two integers x and y. Returns: str: \\"Yes\\" if all pairs are in the first quadrant, \\"No\\" otherwise. for x, y in pairs: if x <= 0 or y <= 0: return \\"No\\" return \\"Yes\\""},{"question":"def create_playlist(songs): Create a playlist following Danny's rules. Each song must be represented by a tuple (title, artist, timestamp). No two songs by the same artist can be played consecutively, and Danny prefers songs that he hasn't listened to recently. Args: songs (List[Tuple[str, str, int]]): List of songs (title, artist, timestamp). Returns: str: A space-separated sequence of song titles, or \\"Not possible\\" if a valid sequence can't be formed. >>> create_playlist([('Song1', 'Artist1', 10), ('Song2', 'Artist1', 12), ('Song3', 'Artist2', 15), ('Song4', 'Artist3', 20), ('Song5', 'Artist1', 25)]) 'Song3 Song1 Song4 Song2 Song5' >>> create_playlist([('Song1', 'Artist1', 10), ('Song2', 'Artist1', 11), ('Song3', 'Artist1', 12)]) 'Not possible.' pass def process_input(data): Convert input data to list of songs. Args: data (List[str]): Input data lines. Returns: List[Tuple[str, str, int]]: Processed list of songs. >>> process_input([\\"5\\", \\"Song1 Artist1 10\\", \\"Song2 Artist1 12\\", \\"Song3 Artist2 15\\", \\"Song4 Artist3 20\\", \\"Song5 Artist1 25\\"]) [('Song1', 'Artist1', 10), ('Song2', 'Artist1', 12), ('Song3', 'Artist2', 15), ('Song4', 'Artist3', 20), ('Song5', 'Artist1', 25)] >>> process_input([\\"3\\", \\"Song1 Artist1 10\\", \\"Song2 Artist1 11\\", \\"Song3 Artist1 12\\"]) [('Song1', 'Artist1', 10), ('Song2', 'Artist1', 11), ('Song3', 'Artist1', 12)] pass # Unit Tests def test_create_playlist_success_case(): data = [ \\"5\\", \\"Song1 Artist1 10\\", \\"Song2 Artist1 12\\", \\"Song3 Artist2 15\\", \\"Song4 Artist3 20\\", \\"Song5 Artist1 25\\" ] songs = process_input(data) result = create_playlist(songs) assert result == \\"Song1 Song3 Song2 Song4 Song5\\" or result == \\"Song1 Song3 Song4 Song2 Song5\\" or result == \\"Song3 Song1 Song4 Song2 Song5\\" or result == \\"Song3 Song1 Song2 Song4 Song5\\" def test_create_playlist_not_possible_case(): data = [ \\"3\\", \\"Song1 Artist1 10\\", \\"Song2 Artist1 11\\", \\"Song3 Artist1 12\\" ] songs = process_input(data) result = create_playlist(songs) assert result == \\"Not possible.\\" def test_create_playlist_another_success_case(): data = [ \\"6\\", \\"Song1 Artist1 1\\", \\"Song2 Artist2 2\\", \\"Song3 Artist1 3\\", \\"Song4 Artist3 4\\", \\"Song5 Artist2 5\\", \\"Song6 Artist4 6\\" ] songs = process_input(data) result = create_playlist(songs) assert result == \\"Song1 Song2 Song3 Song4 Song5 Song6\\" or result == \\"Song1 Song2 Song5 Song3 Song4 Song6\\" def test_create_playlist_single_song(): data = [ \\"1\\", \\"Song1 Artist1 1\\" ] songs = process_input(data) result = create_playlist(songs) assert result == \\"Song1\\"","solution":"def create_playlist(songs): songs.sort(key=lambda x: x[2]) playlist = [] last_artist = None while songs: for i, song in enumerate(songs): if song[1] != last_artist: playlist.append(song[0]) last_artist = song[1] songs.pop(i) break else: # If no valid song is found, it means it's not possible to create the playlist return \\"Not possible.\\" return \\" \\".join(playlist) def process_input(data): n = int(data[0]) songs = [tuple(data[i].split()) for i in range(1, n + 1)] for i in range(n): songs[i] = (songs[i][0], songs[i][1], int(songs[i][2])) return songs"},{"question":"def is_palindromic_permutation(t: int, test_cases: list) -> list: Determine if there exists a palindrome arrangement of book titles for each test case. Args: t (int): The number of test cases. test_cases (list): A list of tuples, each containing an integer n and a list of n book titles. Returns: list: A list of \\"YES\\" or \\"NO\\" for each test case, indicating whether it's possible to arrange the titles into a palindrome sequence. Example: >>> is_palindromic_permutation(2, [(3, [\\"able\\", \\"blea\\", \\"elba\\"]), (4, [\\"abc\\", \\"cba\\", \\"def\\", \\"fed\\"])]) [\\"YES\\", \\"YES\\"] >>> is_palindromic_permutation(2, [(3, [\\"abc\\", \\"def\\", \\"ghi\\"]), (4, [\\"a\\", \\"b\\", \\"c\\", \\"d\\"])]) [\\"NO\\", \\"NO\\"]","solution":"def is_palindromic_permutation(t: int, test_cases: list) -> list: results = [] for case in test_cases: n, titles = case title_count = {} for title in titles: sorted_title = ''.join(sorted(title)) if sorted_title in title_count: title_count[sorted_title] += 1 else: title_count[sorted_title] = 1 odd_count = 0 for count in title_count.values(): if count % 2 != 0: odd_count += 1 if odd_count > 1: results.append(\\"NO\\") else: results.append(\\"YES\\") return results"},{"question":"class TaskManager: def __init__(self): self.tasks = {'High': [], 'Medium': [], 'Low': []} self.completed = set() def add_task(self, task_id, priority): Adds a new task with a given id and priority level to the task list. Args: task_id: A string representing a unique id of the task. priority: A string representing the priority level (\\"High\\", \\"Medium\\", \\"Low\\"). pass def complete_task(self, task_id): Marks the task with a given id as completed. Args: task_id: A string representing the unique id of the task. pass def retrieve_tasks(self, priority): Retrieves tasks with a given priority level that are not completed. Args: priority: A string representing the priority level (\\"High\\", \\"Medium\\", \\"Low\\"). Returns: A string of task ids separated by spaces, or \\"No tasks\\" if no tasks are available. pass def handle_operations(operations): Processes a list of operations to manage tasks. Args: operations: A list of strings, where each string is an operation to perform. Returns: A list of results corresponding to each \\"RETRIEVE\\" operation. task_manager = TaskManager() results = [] for operation in operations: params = operation.split() if params[0] == \\"ADD\\": task_id, priority = params[1], params[2] task_manager.add_task(task_id, priority) elif params[0] == \\"COMPLETE\\": task_id = params[1] task_manager.complete_task(task_id) elif params[0] == \\"RETRIEVE\\": priority = params[1] results.append(task_manager.retrieve_tasks(priority)) return results import pytest def test_add_retrieve_complete_tasks(): operations = [ \\"ADD 101 High\\", \\"ADD 102 Medium\\", \\"RETRIEVE High\\", \\"COMPLETE 101\\", \\"RETRIEVE High\\", \\"RETRIEVE Medium\\" ] assert handle_operations(operations) == [\\"101\\", \\"No tasks\\", \\"102\\"] def test_add_complete_before_retrieve(): operations = [ \\"ADD 201 Low\\", \\"ADD 202 High\\", \\"COMPLETE 202\\", \\"RETRIEVE High\\" ] assert handle_operations(operations) == [\\"No tasks\\"] def test_empty_retrieve(): operations = [ \\"ADD 301 Low\\", \\"COMPLETE 301\\", \\"RETRIEVE Low\\" ] assert handle_operations(operations) == [\\"No tasks\\"] def test_retrieve_with_multiple_priorities(): operations = [ \\"ADD 401 Medium\\", \\"ADD 402 Medium\\", \\"ADD 403 High\\", \\"COMPLETE 403\\", \\"RETRIEVE Medium\\", \\"RETRIEVE High\\" ] assert handle_operations(operations) == [\\"401 402\\", \\"No tasks\\"] def test_retrieve_in_added_order(): operations = [ \\"ADD 501 High\\", \\"ADD 502 High\\", \\"COMPLETE 501\\", \\"RETRIEVE High\\" ] assert handle_operations(operations) == [\\"502\\"]","solution":"class TaskManager: def __init__(self): self.tasks = {'High': [], 'Medium': [], 'Low': []} self.completed = set() def add_task(self, task_id, priority): if priority in self.tasks: self.tasks[priority].append(task_id) def complete_task(self, task_id): self.completed.add(task_id) def retrieve_tasks(self, priority): if priority in self.tasks: active_tasks = [task_id for task_id in self.tasks[priority] if task_id not in self.completed] if active_tasks: return ' '.join(active_tasks) else: return \\"No tasks\\" def handle_operations(operations): task_manager = TaskManager() results = [] for operation in operations: params = operation.split() if params[0] == \\"ADD\\": task_id, priority = params[1], params[2] task_manager.add_task(task_id, priority) elif params[0] == \\"COMPLETE\\": task_id = params[1] task_manager.complete_task(task_id) elif params[0] == \\"RETRIEVE\\": priority = params[1] results.append(task_manager.retrieve_tasks(priority)) return results"},{"question":"def longest_increasing_subsequence_modulo(arr: List[int], p: int) -> int: Returns the length of the longest monotonically increasing subsequence of an array, modulo a prime number P. Args: arr: List[int] - A list of integers p: int - A prime number for modulo operation Returns: int - The length of the longest monotonically increasing subsequence modulo P Examples: >>> longest_increasing_subsequence_modulo([10, 20, 10, 30, 20], 1000000007) 3 >>> longest_increasing_subsequence_modulo([5, 1, 6, 2, 3, 4], 998244353) 4 >>> longest_increasing_subsequence_modulo([1, 2, 3, 0], 999999937) 3 from solution import longest_increasing_subsequence_modulo def test_lis_example_cases(): assert longest_increasing_subsequence_modulo([10, 20, 10, 30, 20], 1000000007) == 3 assert longest_increasing_subsequence_modulo([5, 1, 6, 2, 3, 4], 998244353) == 4 assert longest_increasing_subsequence_modulo([1, 2, 3, 0], 999999937) == 3 def test_lis_small_cases(): assert longest_increasing_subsequence_modulo([1], 999999937) == 1 assert longest_increasing_subsequence_modulo([2, 1], 999999937) == 1 assert longest_increasing_subsequence_modulo([1, 2], 999999937) == 2 assert longest_increasing_subsequence_modulo([3, 10, 2, 1, 20], 999999937) == 3 def test_lis_repeated_numbers(): assert longest_increasing_subsequence_modulo([2, 2, 2, 2, 2, 2], 999999937) == 1 assert longest_increasing_subsequence_modulo([1, 1, 1, 2, 2, 2], 999999937) == 2 def test_lis_large_numbers(): arr = list(range(1, 2001)) assert longest_increasing_subsequence_modulo(arr, 998244353) == 2000 assert longest_increasing_subsequence_modulo(arr[::-1], 998244353) == 1","solution":"def longest_increasing_subsequence_modulo(arr, p): Returns the length of the longest monotonically increasing subsequence of an array, modulo a prime number P. if not arr: return 0 n = len(arr) lis = [1] * n for i in range(1, n): for j in range(0, i): if arr[i] > arr[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis) % p"},{"question":"def min_checkpoints_sum(t: int, test_cases: List[Tuple[int, List[int], int, List[Tuple[int, int]]]]) -> List[int]: Determines the minimum possible sum of checkpoints for each given query within a path in the Kingdom Resort. Args: t (int): Number of test cases. test_cases (List[Tuple[int, List[int], int, List[Tuple[int, int]]]]): Description of each test case including: - Number of stations (int) - List of checkpoints at each station (List[int]) - Number of queries (int) - List of queries where each query is a tuple of x and y (List[Tuple[int, int]]) Returns: List[int]: List of minimum possible sums of checkpoints for each query. Example: >>> min_checkpoints_sum(2, [(5, [1, 3, 5, 7, 9], 3, [(1, 3), (2, 4), (1, 5)]), (6, [2, 7, 1, 8, 2, 3], 4, [(3, 5), (1, 3), (4, 6), (2, 6)])]) [9, 15, 25, 11, 10, 13, 21]","solution":"def min_checkpoints_sum(t, test_cases): results = [] for i in range(t): n, c, q, queries = test_cases[i] for x, y in queries: # Sum the checkpoints in the inclusive range from x to y results.append(sum(c[x-1:y])) return results"},{"question":"def is_zero_sum_subarray(arr): Returns 'Yes' if there exists a contiguous subarray that sums to zero, otherwise returns 'No'. >>> is_zero_sum_subarray([4, 2, -3, 1, 6]) == \\"Yes\\" >>> is_zero_sum_subarray([4, 2, 0, 1, 6]) == \\"Yes\\" >>> is_zero_sum_subarray([-3, 2, 3, 1, 6]) == \\"No\\" >>> is_zero_sum_subarray([0]) == \\"Yes\\" >>> is_zero_sum_subarray([1, 2, 3, 4, 5]) == \\"No\\" >>> is_zero_sum_subarray([1, 2, -3, 3, -2, 3, -3]) == \\"Yes\\" >>> is_zero_sum_subarray([-1]) == \\"No\\"","solution":"def is_zero_sum_subarray(arr): Returns 'Yes' if there exists a contiguous subarray that sums to zero, otherwise returns 'No'. prefix_sum = 0 prefix_sum_set = set() for num in arr: prefix_sum += num if prefix_sum == 0 or prefix_sum in prefix_sum_set: return \\"Yes\\" prefix_sum_set.add(prefix_sum) return \\"No\\""},{"question":"from typing import List, Tuple def min_trucks_needed(n: int, delivery_points: List[Tuple[int, int]]) -> int: Returns the minimum number of trucks needed to deliver all packages without any conflicts at delivery points. >>> min_trucks_needed(3, [(1, 2), (2, 3), (1, 2)]) 2 >>> min_trucks_needed(4, [(0, 1), (1, 0), (1, 1), (2, 2)]) 1 >>> min_trucks_needed(5, [(-1, -1), (-2, -2), (-1, -1), (1, 1), (2, 2)]) 2 def parse_input(input_data: str) -> Tuple[int, List[Tuple[int, int]]]: Parses the input data to use in the solution. >>> input_data = \\"3n1 2n2 3n1 2n\\" >>> parse_input(input_data) (3, [(1, 2), (2, 3), (1, 2)]) >>> input_data = \\"4n0 1n1 0n1 1n2 2n\\" >>> parse_input(input_data) (4, [(0, 1), (1, 0), (1, 1), (2, 2)])","solution":"from collections import Counter def min_trucks_needed(n, delivery_points): Returns the minimum number of trucks needed to deliver all packages without any conflicts at delivery points. # Count the number of packages to be delivered at each point point_count = Counter(delivery_points) # The minimum number of trucks needed is the maximum count of a single point return max(point_count.values()) def parse_input(input_data): Parses the input data to use in the solution. lines = input_data.strip().split(\\"n\\") n = int(lines[0]) delivery_points = [tuple(map(int, line.split())) for line in lines[1:]] return n, delivery_points"},{"question":"def min_subarray_sum(nums): Function to find the smallest sum of any contiguous subarray. >>> min_subarray_sum([3, -4, 2, -3, -1, 7, -5, 2, 3]) -6 >>> min_subarray_sum([1, 2, 3, 4, 5]) 1 >>> min_subarray_sum([-1, -2, -3, -4, -5]) -15 >>> min_subarray_sum([4]) 4 >>> min_subarray_sum([-4]) -4 >>> min_subarray_sum([1, -1, 0]) -1","solution":"def min_subarray_sum(nums): Function to find the smallest sum of any contiguous subarray. # Initialize our variables min_ending_here = nums[0] min_so_far = nums[0] # Traverse the array for i in range(1, len(nums)): min_ending_here = min(nums[i], min_ending_here + nums[i]) min_so_far = min(min_so_far, min_ending_here) return min_so_far"},{"question":"def sum_after_replacement(values: List[int], indexes: List[int]) -> int: Replace the values at the specified indexes in the first list with zero, and then sum the remaining values after the replacements. Args: values (list of int): List of integers to be processed. indexes (list of int): List of indexes at which values should be replaced with zero. Returns: int: Sum of the values after replacements. >>> sum_after_replacement([5, 7, 2, 4, 9, 6, 3], [1, 2, 3]) 23 >>> sum_after_replacement([10, 20, 30, 40, 50], [0, 4]) 90 >>> sum_after_replacement([5, 7, 2, 4, 9, 6, 3], []) 36 >>> sum_after_replacement([10, 20, 30, 40, 50], [0, 1, 2, 3, 4]) 0 >>> sum_after_replacement([1, 2, 3, 4, 5], [2, 2, 2]) 12 >>> sum_after_replacement([100], [0]) 0 >>> sum_after_replacement([10000, 20000, 30000, 40000, 50000], [1, 3]) 90000","solution":"def sum_after_replacement(values, indexes): Replaces values at specified indexes in the list with zero and returns the sum of the list. Args: values (list of int): List of integers to be processed. indexes (list of int): List of indexes at which values should be replaced with zero. Returns: int: Sum of the values after replacements. for index in indexes: values[index] = 0 return sum(values)"},{"question":"def min_insertions_to_good_string(s: str) -> int: Determine the minimum number of insertions required to convert the given string into a good string. Args: - s: A string consisting of lowercase English letters (1 ≤ length of s ≤ 1000). Returns: - An integer representing the minimum number of insertions required. Examples: >>> min_insertions_to_good_string(\\"aaab\\") 2 >>> min_insertions_to_good_string(\\"ab\\") 0 >>> min_insertions_to_good_string(\\"aabb\\") 2","solution":"def min_insertions_to_good_string(s): Returns the minimum number of insertions required to convert the given string into a good string. insertions = 0 for i in range(1, len(s)): if s[i] == s[i-1]: insertions += 1 return insertions"},{"question":"def minimum_spanning_tree(N: int, M: int, roads: List[Tuple[int, int, int]]) -> Union[int, str]: Returns the minimum total distance to connect all the cities or \\"IMPOSSIBLE\\" if not all cities can be connected using the given roads. Example: >>> minimum_spanning_tree(4, 5, [(1, 2, 3), (1, 3, 10), (2, 3, 4), (2, 4, 2), (3, 4, 7)]) 9 >>> minimum_spanning_tree(3, 1, [(1, 2, 5)]) \\"IMPOSSIBLE\\" >>> minimum_spanning_tree(1, 0, []) 0 >>> minimum_spanning_tree(4, 0, []) \\"IMPOSSIBLE\\"","solution":"def minimum_spanning_tree(N, M, roads): Returns the minimum total distance to connect all the cities or \\"IMPOSSIBLE\\" if not all cities can be connected using the given roads. from heapq import heappop, heappush import itertools if N == 1: return 0 # Only one city, no need to connect anything # Create an adjacency list adj = {i: [] for i in range(1, N+1)} for u, v, w in roads: adj[u].append((w, v)) adj[v].append((w, u)) # Prim's algorithm to find the minimum spanning tree visited = [False] * (N + 1) min_heap = [(0, 1)] # (cost, node), starting with node 1 total_cost = 0 nodes_used = 0 while min_heap and nodes_used < N: cost, node = heappop(min_heap) if visited[node]: continue visited[node] = True total_cost += cost nodes_used += 1 for edge_cost, neighbor in adj[node]: if not visited[neighbor]: heappush(min_heap, (edge_cost, neighbor)) if nodes_used == N: return total_cost else: return \\"IMPOSSIBLE\\""},{"question":"from typing import List def max_possible_value(arr: List[int]) -> int: Returns the maximum possible value achievable in the array by performing the given operation any number of times. >>> max_possible_value([6, 9, 12, 15, 18]) 3 >>> max_possible_value([8, 5, 7, 10]) 1","solution":"def max_possible_value(arr): Returns the maximum possible value achievable in the array by performing the given operation any number of times. from math import gcd from functools import reduce # Reduce array to GCD of all elements return reduce(gcd, arr)"},{"question":"def minDeletionsToPalindrome(s: str) -> int: Returns the minimum number of deletions required to transform the given string into a palindrome. >>> minDeletionsToPalindrome(\\"abcba\\") 0 >>> minDeletionsToPalindrome(\\"abcdef\\") 5","solution":"def minDeletionsToPalindrome(s: str) -> int: Returns the minimum number of deletions required to transform the given string into a palindrome. def longest_palindromic_subsequence(s: str) -> int: n = len(s) # Creating a 2D DP array to store lengths of longest palindromic subsequence dp = [[0] * n for _ in range(n)] # Strings of length 1 are palindrome of length 1 for i in range(n): dp[i][i] = 1 # Build the table. The bottom-up approach for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j]: if cl == 2: dp[i][j] = 2 else: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) # Length of the longest palindromic subsequence return dp[0][n - 1] # The minimum number of deletions required is the difference between # the length of the string and the length of the longest palindromic subsequence lps_length = longest_palindromic_subsequence(s) return len(s) - lps_length"},{"question":"from typing import List, Tuple def max_non_overlapping_events(events: List[Tuple[str, int, int]]) -> int: Finds the maximum number of non-overlapping events that can be attended. Args: events (list of tuples): List of events where each event is represented as a tuple (title, start_time, end_time). Returns: int: Maximum number of non-overlapping events. >>> max_non_overlapping_events([('Meeting', 1, 2), ('Workout', 2, 3), ('Lunch', 3, 4), ('Conference', 1, 5), ('Study', 5, 6)]) 4 >>> max_non_overlapping_events([('Meeting', 1, 4), ('Lunch', 2, 3), ('Dinner', 5, 6)]) 2 def parse_input(input_text: str) -> List[Tuple[str, int, int]]: Parses the input text into a list of events. Args: input_text (str): The input text representing event descriptions. Returns: list of tuples: A list where each tuple contains the title, start_time, and end_time of an event. >>> parse_input(\\"3nMeeting 1 4nLunch 2 3nDinner 5 6\\") [('Meeting', 1, 4), ('Lunch', 2, 3), ('Dinner', 5, 6)]","solution":"def max_non_overlapping_events(events): Finds the maximum number of non-overlapping events that can be attended. Args: events (list of tuples): List of events where each event is represented as a tuple (title, start_time, end_time). Returns: int: Maximum number of non-overlapping events. # Sort events by their end time first sorted_events = sorted(events, key=lambda x: x[2]) count = 0 last_end_time = -1 for event in sorted_events: if event[1] >= last_end_time: count += 1 last_end_time = event[2] return count # Helper function to parse input def parse_input(input_text): lines = input_text.strip().split('n') n = int(lines[0]) events = [] for i in range(1, n+1): parts = lines[i].split() title = ' '.join(parts[:-2]) start_time, end_time = int(parts[-2]), int(parts[-1]) events.append((title, start_time, end_time)) return events"},{"question":"def min_sublists_for_increasing_segments(t, test_cases): You are given a list of integers. Your task is to divide the list into the minimum number of contiguous sublists (subarrays) such that each sublist is strictly increasing. >>> min_sublists_for_increasing_segments(3, [(5, [1, 2, 3, 2, 1]), (4, [1, 3, 2, 4]), (3, [5, 6, 7])]) [3, 2, 1] >>> min_sublists_for_increasing_segments(1, [(6, [1, 1, 1, 1, 1, 1])]) [6] >>> min_sublists_for_increasing_segments(2, [(4, [4, 1, 2, 3]), (4, [4, 3, 2, 1])]) [2, 4] >>> min_sublists_for_increasing_segments(1, [(1, [1])]) [1] >>> min_sublists_for_increasing_segments(2, [(3, [1, 3, 2]), (5, [10, 9, 8, 7, 6])]) [2, 5]","solution":"def min_sublists_for_increasing_segments(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] arr = test_cases[i][1] sublists_count = 1 for j in range(1, n): if arr[j] <= arr[j-1]: sublists_count += 1 results.append(sublists_count) return results # Example usage: # t = 3 # test_cases = [(5, [1, 2, 3, 2, 1]), (4, [1, 3, 2, 4]), (3, [5, 6, 7])] # print(min_sublists_for_increasing_segments(t, test_cases)) # Output: [3, 2, 1]"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_symmetric_tree(n, values, children): Determine whether the given binary tree is symmetric. >>> n = 3 >>> values = [1, 2, 2] >>> children = [[1, 2], [-1, -1], [-1, -1]] >>> is_symmetric_tree(n, values, children) \\"Yes\\" >>> n = 5 >>> values = [1, 2, 2, 3, 3] >>> children = [[1, 2], [3, 4], [-1, -1], [-1, -1], [-1, -1]] >>> is_symmetric_tree(n, values, children) \\"No\\" >>> n = 0 >>> values = [] >>> children = [] >>> is_symmetric_tree(n, values, children) \\"Yes\\" >>> n = 1 >>> values = [1] >>> children = [[-1, -1]] >>> is_symmetric_tree(n, values, children) \\"Yes\\" >>> n = 7 >>> values = [1, 2, 2, 3, 4, 4, 3] >>> children = [[1, 2], [3, 4], [5, 6], [-1, -1], [-1, -1], [-1, -1], [-1, -1]] >>> is_symmetric_tree(n, values, children) \\"Yes\\" >>> n = 7 >>> values = [1, 2, 2, -1, 3, -1, 3] >>> children = [[1, 2], [3, 4], [5, 6], [-1, -1], [-1, -1], [-1, -1], [-1, -1]] >>> is_symmetric_tree(n, values, children) \\"No\\"","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_symmetric_tree(n, values, children): if n == 0: return \\"Yes\\" def build_tree(idx): if idx == -1 or idx >= n: return None node = TreeNode(values[idx]) if idx < len(children): node.left = build_tree(children[idx][0]) node.right = build_tree(children[idx][1]) return node root = build_tree(0) def is_mirror(left, right): if not left and not right: return True if not left or not right: return False return (left.val == right.val) and is_mirror(left.right, right.left) and is_mirror(left.left, right.right) return \\"Yes\\" if is_mirror(root.left, root.right) else \\"No\\""},{"question":"def maxValue(cards: List[int]) -> int: Determine the maximum total value a player can accumulate without collecting cards with consecutive values. >>> maxValue([3, 2, 5, 10, 7]) 15 >>> maxValue([4, 1, 1, 9, 1]) 13 >>> maxValue([1, 2, 3, 4, 5]) 9","solution":"def maxValue(cards): if not cards: return 0 incl = 0 # Maximum value including the previous card excl = 0 # Maximum value excluding the previous card for card in cards: new_excl = max(incl, excl) incl = excl + card excl = new_excl return max(incl, excl)"},{"question":"def max_packages_in_subgrid(n, k, destinations): Returns the maximum number of packages that can be grouped within a k x k subgrid. Parameters: n (int): The size of the city grid. k (int): The size of the square subgrid. destinations (list of tuples): List of package destinations as (x, y) coordinates. Returns: int: Maximum number of packages that can fit within any k x k subgrid. Example: >>> max_packages_in_subgrid(5, 2, [ ... (1, 1), (1, 2), (1, 3), ... (2, 2), (2, 3), (2, 4), ... (3, 3), (3, 4), (3, 5), ... (4, 4), (4, 5), ... (5, 5) ... ]) == 4 >>> max_packages_in_subgrid(5, 2, []) == 0 >>> max_packages_in_subgrid(5, 2, [(2, 2)]) == 1","solution":"def max_packages_in_subgrid(n, k, destinations): Returns the maximum number of packages that can be grouped within a k x k subgrid. Parameters: n (int): The size of the city grid. k (int): The size of the square subgrid. destinations (list of tuples): List of package destinations as (x, y) coordinates. Returns: int: Maximum number of packages that can fit within any k x k subgrid. # Initialize an empty grid with 0s grid = [[0] * (n + 1) for _ in range(n + 1)] # Populate grid with package destinations for x, y in destinations: grid[x][y] += 1 # Build prefix sum array to count packages within subgrids efficiently prefix_sum = [[0] * (n + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, n + 1): prefix_sum[i][j] = ( grid[i][j] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1] ) max_packages = 0 # Slide a k x k window over the grid for i in range(k, n + 1): for j in range(k, n + 1): current_packages = ( prefix_sum[i][j] - prefix_sum[i - k][j] - prefix_sum[i][j - k] + prefix_sum[i - k][j - k] ) max_packages = max(max_packages, current_packages) return max_packages"},{"question":"def decode_message(k: int, s: str) -> str: Decodes the message ID to the original message. Args: k: int - number of words in the original message s: str - encoded message ID Returns: str - original message with words separated by spaces >>> decode_message(2, \\"hiddenmessage\\") \\"hidden message\\" >>> decode_message(3, \\"codedinaday\\") \\"code din aday\\" def process_input(t: int, test_cases: List[Tuple[int, str]]) -> List[str]: Processes the input and returns the decoded messages for each test case. Args: t: int - number of test cases test_cases: List[Tuple[int, str]] - list of test cases with number of words and encoded message ID Returns: List[str] - list of decoded messages >>> process_input(2, [(2, \\"hiddenmessage\\"), (3, \\"codedinaday\\")]) [\\"hidden message\\", \\"code din aday\\"] import pytest from solution import process_input, decode_message, prepare_master_word_list def setup_function(): Setup function to initialize the master word list before each test. prepare_master_word_list() def test_process_input(): setup_function() t = 2 test_cases = [ (2, 'hiddenmessage'), (3, 'codedinaday') ] expected_output = [ 'hidden message', 'code din aday' ] assert process_input(t, test_cases) == expected_output def test_decode_message(): setup_function() assert decode_message(2, 'hiddenmessage') == 'hidden message' assert decode_message(3, 'codedinaday') == 'code din aday' # Required global variable to maintain word dictionary master_word_list = [] def prepare_master_word_list(): Initializes the global word list used to decode message IDs. global master_word_list # Given possible words from the example, this list can be extended as needed master_word_list = ['hidden', 'message', 'code', 'din', 'aday']","solution":"def decode_message(k, s): Decodes the message IDs to the original message. # Initialize variables words = [] start = 0 length = len(s) # Iterate through the length of the string and extract words while start < length: for i in range(start, length + 1): if s[start:i] in master_word_list and s[start:i] not in words: words.append(s[start:i]) start = i break return ' '.join(words) def process_input(t, test_cases): Processes the input and returns the decoded messages. # Result container results = [] # Iterate over each test case for index in range(t): k, s = test_cases[index] results.append(decode_message(k, s)) return results # Required global variable to maintain word dictionary master_word_list = [] def prepare_master_word_list(): Initializes the global word list used to decode message IDs. global master_word_list # Given possible words from the example, this list can be extended as needed master_word_list = ['hidden', 'message', 'code', 'din', 'aday'] # Initialize the master word list prepare_master_word_list()"},{"question":"def can_form_string(S, T): Determines if string T can be formed using characters from string S. from collections import Counter def process_queries(queries): Process multiple queries to determine if T can be formed from S for each query. # Unit Test def test_example_cases(): queries = [ (\\"ababcd\\", \\"abcd\\"), (\\"hello\\", \\"world\\") ] results = process_queries(queries) assert results == [\\"YES\\", \\"NO\\"] def test_edge_cases(): # T is empty, should always be \\"YES\\" queries = [ (\\"\\", \\"\\"), (\\"a\\", \\"\\"), (\\"abc\\", \\"\\") ] results = process_queries(queries) assert results == [\\"YES\\", \\"YES\\", \\"YES\\"] def test_identical_strings(): queries = [ (\\"abc\\", \\"abc\\"), (\\"aaa\\", \\"aaa\\") ] results = process_queries(queries) assert results == [\\"YES\\", \\"YES\\"] def test_insufficient_characters(): queries = [ (\\"a\\", \\"aa\\"), (\\"abc\\", \\"abcd\\"), (\\"xyz\\", \\"xyzz\\") ] results = process_queries(queries) assert results == [\\"NO\\", \\"NO\\", \\"NO\\"] def test_extra_characters_in_S(): queries = [ (\\"aabbcc\\", \\"abc\\"), (\\"hello\\", \\"hell\\"), ] results = process_queries(queries) assert results == [\\"YES\\", \\"YES\\"] def test_complex_scenarios(): queries = [ (\\"aacbbcc\\", \\"cab\\"), (\\"mississippi\\", \\"imps\\") ] results = process_queries(queries) assert results == [\\"YES\\", \\"YES\\"]","solution":"def can_form_string(S, T): Determines if string T can be formed using characters from string S. from collections import Counter counter_S = Counter(S) counter_T = Counter(T) for char in counter_T: if counter_T[char] > counter_S.get(char, 0): return \\"NO\\" return \\"YES\\" def process_queries(queries): Process multiple queries to determine if T can be formed from S for each query. results = [] for S, T in queries: result = can_form_string(S, T) results.append(result) return results"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates an arithmetic expression and returns the result rounded to 3 decimal places. The expression can contain non-negative integers, +, -, *, /, and parentheses (). >>> evaluate_expression(\\"3 + 2 * 2\\") 7.000 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") 23.000 >>> evaluate_expression(\\"2*(5+5*2)/3+(6/2+8)\\") 21.000 >>> evaluate_expression(\\"42\\") 42.000 >>> evaluate_expression(\\" 3 + 2 * 2 \\") 7.000 >>> evaluate_expression(\\" ( 1 + ( 4 + 5 + 2 ) - 3 ) + ( 6 + 8 ) \\") 23.000 >>> evaluate_expression(\\"6 / 2\\") 3.000 >>> evaluate_expression(\\"10 + 2 * 6\\") 22.000 >>> evaluate_expression(\\"100 * 2 + 12\\") 212.000 >>> evaluate_expression(\\"100 * ( 2 + 12 )\\") 1400.000 >>> evaluate_expression(\\"100 * ( 2 + 12 ) / 14\\") 100.000","solution":"import re def evaluate_expression(expression): Evaluates an arithmetic expression and returns the result rounded to 3 decimal places. The expression can contain non-negative integers, +, -, *, /, and parentheses (). def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(left / right) def precedence(op): if op in {'+', '-'}: return 1 if op in {'*', '/'}: return 2 return 0 def parse_expression(expression): tokens = re.findall(r'd+|[-+*/()]', expression) return tokens values = [] operators = [] tokens = parse_expression(expression) i = 0 while i < len(tokens): if tokens[i] == ' ': i += 1 continue if tokens[i] == '(': operators.append(tokens[i]) elif tokens[i].isdigit(): values.append(int(tokens[i])) elif tokens[i] == ')': while operators and operators[-1] != '(': apply_operator(operators, values) operators.pop() else: while (operators and precedence(operators[-1]) >= precedence(tokens[i])): apply_operator(operators, values) operators.append(tokens[i]) i += 1 while operators: apply_operator(operators, values) return round(values[-1], 3)"},{"question":"def sum_of_digits(strings: List[str]) -> List[int]: Returns a list of sums of all digits present in each string. :param strings: List of strings :return: List of integers representing the sum of digits of each string >>> sum_of_digits([\\"a1b2c3\\"]) [6] >>> sum_of_digits([\\"abcdef\\"]) [0] >>> sum_of_digits([\\"123abc456\\"]) [21]","solution":"def sum_of_digits(strings): Returns a list of sums of all digits present in each string. :param strings: List of strings :return: List of integers representing the sum of digits of each string results = [] for s in strings: total = sum(int(char) for char in s if char.isdigit()) results.append(total) return results"},{"question":"def range_sum(n: int, m: int, array: List[int], operations: List[Tuple[int, int]]) -> List[int]: Compute the sum of elements in the list within the given range for each operation. >>> range_sum(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (3, 5)]) [6, 9, 12] >>> range_sum(6, 2, [2, 4, 6, 8, 10, 12], [(1, 5), (2, 6)]) [30, 40]","solution":"def range_sum(n, m, array, operations): # Precompute prefix sums prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + array[i] # Compute the sums for each operation result = [] for l, r in operations: result.append(prefix_sum[r] - prefix_sum[l - 1]) return result"},{"question":"def can_assign_packages(n: int, m: int, capacities: List[int], packages: List[int]) -> str: Determine if it's possible to assign all packages to vehicles without exceeding the capacity of any vehicle. :param n: Number of vehicles :param m: Number of packages :param capacities: List of integers representing the carrying capacity of each vehicle :param packages: List of integers representing the weights of each package :return: 'YES' if it's possible to assign all packages without exceeding any vehicle's capacity, otherwise 'NO' Example: >>> can_assign_packages(3, 4, [10, 15, 20], [5, 10, 10, 5]) \\"YES\\" >>> can_assign_packages(2, 3, [5, 5], [6, 4, 3]) \\"NO\\"","solution":"def can_assign_packages(n, m, capacities, packages): Determine if it's possible to assign all packages to vehicles without exceeding the capacity of any vehicle. :param n: Number of vehicles :param m: Number of packages :param capacities: List of integers representing the carrying capacity of each vehicle :param packages: List of integers representing the weights of each package :return: 'YES' if it's possible to assign all packages without exceeding any vehicle's capacity, otherwise 'NO' capacities.sort(reverse=True) packages.sort(reverse=True) for p in packages: placed = False for i in range(n): if p <= capacities[i]: capacities[i] -= p placed = True break if not placed: return \\"NO\\" return \\"YES\\""},{"question":"def find_minimum_roads(N, M, roads, S, E, W): Determine if there is a possible route from a start intersection S to an end intersection E that can support a truck with weight W. If such a route exists, return the minimum number of roads required to travel from S to E. If no such route exists, return -1. Args: N: int - number of intersections M: int - number of roads roads: List[Tuple[int, int, int]] - list of roads represented as tuples (Ui, Vi, Ci) S: int - start intersection E: int - end intersection W: int - weight of the truck Returns: int - minimum number of roads required or -1 if no route exists Examples: >>> find_minimum_roads(5, 7, [ (1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 5, 10), (2, 4, 5), (2, 5, 2), (3, 1, 4), ], 1, 5, 5) 3 >>> find_minimum_roads(4, 6, [ (1, 2, 15), (2, 3, 15), (3, 4, 15), (4, 2, 10), (2, 1, 15), (5, 2, 12), ], 1, 4, 15) -1","solution":"def find_minimum_roads(N, M, roads, S, E, W): from heapq import heappop, heappush import sys from collections import defaultdict, deque # Create adjacency list for graph graph = defaultdict(list) for u, v, c in roads: if c >= W: graph[u].append((v, c)) # Use BFS to find the shortest path in terms of road count queue = deque([(S, 0)]) # (current node, number of roads taken) visited = set() while queue: current, road_count = queue.popleft() if current == E: return road_count if current in visited: continue visited.add(current) for neighbor, _ in graph[current]: if neighbor not in visited: queue.append((neighbor, road_count + 1)) return -1"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, returns a new list where each element at index i is the product of all the elements in the original list except the one at i. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([5, 3, 4, 2, 6]) [144, 240, 180, 360, 120] >>> product_except_self([10]) [1] >>> product_except_self([3, 7]) [7, 3] >>> product_except_self([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [3628800, 1814400, 1209600, 907200, 725760, 604800, 518400, 453600, 403200, 362880] >>> product_except_self([1000000000, 1000000000]) [1000000000, 1000000000]","solution":"def product_except_self(nums): Given a list of integers, returns a new list where each element at index i is the product of all the elements in the original list except the one at i. n = len(nums) if n == 0: return [] # Initialize arrays for left and right products left_products = [1] * n right_products = [1] * n # Fill left_products left_product = 1 for i in range(n): left_products[i] = left_product left_product *= nums[i] # Fill right_products right_product = 1 for i in range(n - 1, -1, -1): right_products[i] = right_product right_product *= nums[i] # Generate the result by multiplying left and right products result = [1] * n for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"def generate_seating_arrangement(r, c): Generate the seating arrangement in a spiral order for an examination hall. :param r: number of rows :param c: number of columns :return: a 2D list representing the seating arrangement Example: >>> generate_seating_arrangement(3, 3) [[9, 8, 7], [2, 1, 6], [3, 4, 5]] >>> generate_seating_arrangement(4, 4) [[16, 15, 14, 13], [5, 4, 3, 12], [6, 1, 2, 11], [7, 8, 9, 10]] def print_seating_arrangement(r, c): Print the seating arrangement in a spiral order for an examination hall. :param r: number of rows :param c: number of columns Example: >>> print_seating_arrangement(3, 3) 9 8 7 2 1 6 3 4 5 >>> print_seating_arrangement(4, 4) 16 15 14 13 5 4 3 12 6 1 2 11 7 8 9 10","solution":"def generate_seating_arrangement(r, c): mtrx = [[0] * c for _ in range(r)] num = r * c left, right, top, bottom = 0, c - 1, 0, r - 1 while left <= right and top <= bottom: for i in range(left, right + 1): # left to right mtrx[top][i] = num num -= 1 top += 1 for i in range(top, bottom + 1): # top to bottom mtrx[i][right] = num num -= 1 right -= 1 if top <= bottom: for i in range(right, left - 1, -1): # right to left mtrx[bottom][i] = num num -= 1 bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): # bottom to top mtrx[i][left] = num num -= 1 left += 1 return mtrx def print_seating_arrangement(r, c): mtrx = generate_seating_arrangement(r, c) for row in mtrx: print(' '.join(map(str, row)))"},{"question":"def is_connected(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determine if the galaxy is connected, given planets and trade routes. Arguments: n -- the number of planets (nodes) m -- the number of trade routes (edges) edges -- a list of tuples, each containing two integers representing trade routes between planets Returns: \\"YES\\" if the galaxy is connected, \\"NO\\" otherwise Examples: >>> is_connected(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"YES\\" >>> is_connected(4, 3, [(1, 2), (2, 3), (3, 4)]) \\"YES\\" >>> is_connected(4, 2, [(1, 2), (3, 4)]) \\"NO\\"","solution":"def is_connected(n, m, edges): from collections import defaultdict, deque def bfs(start): visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return visited if n == 1: return \\"YES\\" graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = bfs(1) if len(visited) == n: return \\"YES\\" else: return \\"NO\\""},{"question":"def minimum_removal_cost(n: int, k: int, arr: List[int]) -> int: Calculate the minimum total cost to remove all elements from the array according to the rules described. >>> minimum_removal_cost(5, 2, [1, 3, 5, 2, 4]) 15 >>> minimum_removal_cost(6, 3, [2, -1, 2, 3, 4, -5]) 5 >>> minimum_removal_cost(1, 1, [10]) 10 >>> minimum_removal_cost(3, 2, [-1, -2, -3]) -6 >>> minimum_removal_cost(4, 2, [1, -2, 3, -4]) -2 >>> minimum_removal_cost(5, 5, [1, 2, 3, 4, 5]) 15 >>> minimum_removal_cost(10, 2, [1, -1] * 5) 0","solution":"def minimum_removal_cost(n, k, arr): dp = [float('inf')] * (n + 1) dp[0] = 0 # No cost to remove zero elements for i in range(1, n + 1): for j in range(1, k + 1): if i - j >= 0: dp[i] = min(dp[i], dp[i - j] + sum(arr[i - j: i])) return dp[n] # Example usage: # print(minimum_removal_cost(5, 2, [1, 3, 5, 2, 4])) # should return 15 # print(minimum_removal_cost(6, 3, [2, -1, 2, 3, 4, -5])) # should return 5"},{"question":"def min_operations_to_transform(s: str, t: str) -> int: Determine the minimum number of operations required to transform \`s\` into \`t\`. :param s: string s consisting of lowercase English alphabets. :param t: string t consisting of lowercase English alphabets. :return: an integer representing the minimum number of operations required. Examples: >>> min_operations_to_transform(\\"abc\\", \\"def\\") 3 >>> min_operations_to_transform(\\"abcde\\", \\"abfde\\") 1 >>> min_operations_to_transform(\\"abcd\\", \\"abcd\\") 0 >>> min_operations_to_transform(\\"abcd\\", \\"abc\\") -1 >>> min_operations_to_transform(\\"same\\", \\"sane\\") 1 >>> min_operations_to_transform(\\"a\\"*100, \\"b\\"*100) 100 >>> min_operations_to_transform(\\"a\\"*1000, \\"b\\"*1000) 1000 >>> min_operations_to_transform(\\"abcdefghijklmnopqrstuvwxyz\\", \\"zyxwvutsrqponmlkjihgfedcba\\") 26 >>> min_operations_to_transform(\\"kitten\\", \\"sitting\\") -1 def test_min_operations_to_transform(): assert min_operations_to_transform(\\"abc\\", \\"def\\") == 3 assert min_operations_to_transform(\\"abcde\\", \\"abfde\\") == 1 assert min_operations_to_transform(\\"abcd\\", \\"abcd\\") == 0 assert min_operations_to_transform(\\"abcd\\", \\"abc\\") == -1 assert min_operations_to_transform(\\"same\\", \\"sane\\") == 1 assert min_operations_to_transform(\\"a\\"*100, \\"b\\"*100) == 100 assert min_operations_to_transform(\\"a\\"*1000, \\"b\\"*1000) == 1000 assert min_operations_to_transform(\\"abcdefghijklmnopqrstuvwxyz\\", \\"zyxwvutsrqponmlkjihgfedcba\\") == 26 assert min_operations_to_transform(\\"kitten\\", \\"sitting\\") == -1 if __name__ == \\"__main__\\": test_min_operations_to_transform()","solution":"def min_operations_to_transform(s, t): Returns the minimum number of operations required to transform s into t. # Check if lengths are different, transforming each character if len(s) != len(t): return -1 # Not possible if lengths are different # Counting number of different characters between the same position of s and t operations = sum(1 for sc, tc in zip(s, t) if sc != tc) return operations"},{"question":"def determine_winner(s: str) -> str: Determines the winner of the game given the initial string s. Anna wins if the length of the string is even. Bob wins if the length of the string is odd. :param s: str - initial string :return: str - \\"Anna\\" or \\"Bob\\" >>> determine_winner(\\"abc\\") == \\"Bob\\" >>> determine_winner(\\"aaaa\\") == \\"Anna\\" >>> determine_winner(\\"ababa\\") == \\"Anna\\"","solution":"def determine_winner(s): Determines the winner of the game given the initial string s. Anna wins if the length of the string is even. Bob wins if the length of the string is odd. :param s: str - initial string :return: str - \\"Anna\\" or \\"Bob\\" if len(s) % 2 == 0: return \\"Anna\\" else: return \\"Bob\\""},{"question":"def validate_events(test_cases): Determine if a given event is valid based on the tribe's calendar system. Args: test_cases (List[Tuple[int, int, int, List[Tuple[int, int]]]]): A list of test cases where: - Each test case is a tuple containing: - X (int): Number of months. - Y (int): Number of days in each month. - E (int): Number of events. - events (List[Tuple[int, int]]): A list of events, each represented by a tuple (M, D). Returns: List[List[str]]: A list of results for each test case, where each result is a list of \\"valid\\" or \\"invalid\\" strings indicating the validity of the events. >>> validate_events([(12, 30, 3, [(1, 15), (13, 1), (6, 31)])]) [['valid', 'invalid', 'invalid']] >>> validate_events([(10, 20, 2, [(10, 5), (11, 20)])]) [['valid', 'invalid']] # Unit tests def test_validate_events(): test_cases = [ (12, 30, 3, [(1, 15), (13, 1), (6, 31)]), (10, 20, 2, [(10, 5), (11, 20)]), (5, 10, 4, [(1, 1), (5, 10), (3, 15), (6, 5)]), (1, 1, 1, [(1, 1)]) ] expected_results = [ [\\"valid\\", \\"invalid\\", \\"invalid\\"], [\\"valid\\", \\"invalid\\"], [\\"valid\\", \\"valid\\", \\"invalid\\", \\"invalid\\"], [\\"valid\\"] ] results = validate_events(test_cases) for result, expected in zip(results, expected_results): assert result == expected def test_large_input(): test_cases = [ (50, 50, 1000, [(50, 50) for _ in range(1000)]), (30, 30, 1000, [(30, 30) for _ in range(1000)]), ] expected_results = [ [\\"valid\\"] * 1000, [\\"valid\\"] * 1000 ] results = validate_events(test_cases) for result, expected in zip(results, expected_results): assert result == expected def test_invalid_days_and_months(): test_cases = [ (10, 10, 5, [(11, 1), (1, 11), (0, 5), (5, 0), (11, 11)]), ] expected_results = [ [\\"invalid\\", \\"invalid\\", \\"invalid\\", \\"invalid\\", \\"invalid\\"] ] results = validate_events(test_cases) for result, expected in zip(results, expected_results): assert result == expected","solution":"def validate_events(test_cases): results = [] for case in test_cases: X, Y, E, events = case case_result = [] for event in events: M, D = event if 1 <= M <= X and 1 <= D <= Y: case_result.append(\\"valid\\") else: case_result.append(\\"invalid\\") results.append(case_result) return results"},{"question":"from typing import List MOD = 1_000_000_007 def update(arr: List[int], index: int, value: int): Update the value at arr[index-1] to value. pass def retrieve(arr: List[int], L: int, R: int) -> int: Retrieve the product of the elements in the subarray from index L to index R, inclusive, and return the product modulo 1,000,000,007. pass def process_operations(N: int, M: int, arr: List[int], operations: List[str]) -> List[int]: Process M update and retrieve operations on an array of N integers. >>> N = 5 >>> M = 3 >>> arr = [2, 3, 7, 5, 6] >>> operations = [\\"2 2 4\\", \\"1 3 4\\", \\"2 2 4\\"] >>> process_operations(N, M, arr, operations) [105, 60] pass","solution":"MOD = 1_000_000_007 def update(arr, index, value): arr[index - 1] = value def retrieve(arr, L, R): result = 1 for i in range(L-1, R): result = (result * arr[i]) % MOD return result def process_operations(N, M, arr, operations): result = [] for op in operations: parts = op.split() if parts[0] == '1': _, x, v = map(int, parts) update(arr, x, v) elif parts[0] == '2': _, L, R = map(int, parts) result.append(retrieve(arr, L, R)) return result"},{"question":"def minimum_moves_to_match_pairs(h: int, w: int, board: List[List[int]]) -> int: Calculate the minimum number of moves required to match all pairs on the memory puzzle board. >>> minimum_moves_to_match_pairs(4, 4, [ [3, 1, 2, 4], [4, 3, 1, 2], [5, 6, 7, 8], [7, 6, 8, 5] ]) 8 >>> minimum_moves_to_match_pairs(1, 4, [[1, 2, 1, 2]]) 2 >>> minimum_moves_to_match_pairs(4, 1, [[1], [2], [1], [2]]) 2 >>> minimum_moves_to_match_pairs(4, 4, [ [1, 1, 2, 2], [3, 3, 4, 4], [5, 5, 6, 6], [7, 7, 8, 8] ]) 8 >>> minimum_moves_to_match_pairs(50, 50, [[1, 2] * 25, [1, 2] * 25] * 25) 2","solution":"def minimum_moves_to_match_pairs(h, w, board): from collections import defaultdict # Dictionary to store the positions of each card number card_positions = defaultdict(list) # Collect all positions for each card number for i in range(h): for j in range(w): card_positions[board[i][j]].append((i, j)) # Each number has exactly two positions, count of unique pairs is enough return len(card_positions)"},{"question":"from collections import deque, defaultdict def tree_height(n: int, edges: list) -> int: Calculate the height of a tree given its number of nodes and edges. Args: n : int : Number of nodes in the tree. edges: list : A list of tuples representing the edges of the tree. Returns: int : The height of the tree. Example: >>> tree_height(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) 2 >>> tree_height(1, []) 0 pass # Implement the function here","solution":"from collections import deque, defaultdict def tree_height(n, edges): if n == 1: return 0 adjacency_list = defaultdict(list) for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) def bfs(start_node): max_depth = 0 queue = deque([(start_node, 0)]) visited = set([start_node]) while queue: current_node, depth = queue.popleft() max_depth = max(max_depth, depth) for neighbor in adjacency_list[current_node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, depth + 1)) return max_depth return bfs(1) # Sample Usage n = 5 edges = [(1, 2), (1, 3), (3, 4), (3, 5)] print(tree_height(n, edges)) # Output: 2"},{"question":"def max_sum_non_adjacent(arr): Returns the maximum sum of a subsequence with no two adjacent elements. >>> max_sum_non_adjacent([3, 2, 5, 10, 7]) 15 >>> max_sum_non_adjacent([-2, 1, 3, -4, 5]) 8 >>> max_sum_non_adjacent([1, 2, 9, 4, 5, 0, 4, 11, 6]) 26 >>> max_sum_non_adjacent([-1, -2, -9, -4, -5, -0, -4, -11, -6]) 0 >>> max_sum_non_adjacent([]) 0","solution":"def max_sum_non_adjacent(arr): Returns the maximum sum of a subsequence with no two adjacent elements. if not arr: return 0 n = len(arr) if n == 1: return arr[0] # Initialize variables to store the maximum sum of non-adjacent elements incl = arr[0] # Sum including the current element excl = 0 # Sum excluding the current element for i in range(1, n): # Current maximum sum excluding i new_excl = max(incl, excl) # Current maximum sum including i incl = excl + arr[i] excl = new_excl return max(incl, excl)"},{"question":"from typing import List def calculate_bonus(rating: int) -> int: Calculate the bonus amount based on the given rating. >>> calculate_bonus(3) 100 >>> calculate_bonus(5) 500 >>> calculate_bonus(8) 1000 # Your code here def process_ratings(ratings: List[int]) -> List[int]: Takes a list of ratings and returns a list of corresponding bonus amounts. >>> process_ratings([3, 5, 8, 10]) [100, 500, 1000, 1000] # Your code here","solution":"def calculate_bonus(rating): Returns the bonus amount based on the given rating if 1 <= rating <= 4: return 100 elif 5 <= rating <= 7: return 500 elif 8 <= rating <= 10: return 1000 else: raise ValueError(\\"Rating should be between 1 and 10\\") def process_ratings(ratings): Takes a list of ratings and returns list of corresponding bonus amounts return [calculate_bonus(rating) for rating in ratings]"},{"question":"def count_deletions(t: int, test_cases: List[str]) -> List[int]: Determines the number of deletions required so that no two adjacent characters are the same for each test case. Args: t (int): The number of test cases. test_cases (list of str): List of strings for the test cases. Returns: list of int: List of counts of deletions required for each test case. pass # Test cases to validate the solution def test_single_case_no_deletions(): assert count_deletions(1, ['ababab']) == [0] def test_single_case_all_same(): assert count_deletions(1, ['aaaa']) == [3] def test_single_case_no_adjacent_same(): assert count_deletions(1, ['abcabc']) == [0] def test_multiple_cases(): test_cases = ['ababab', 'aaaa', 'abcabc'] expected = [0, 3, 0] assert count_deletions(3, test_cases) == expected def test_single_character_strings(): assert count_deletions(1, ['a']) == [0] def test_single_case_with_some_adjacent_same(): assert count_deletions(1, ['aabbcc']) == [3] def test_edge_case_long_string_no_deletions(): s = 'ab' * 50000 assert count_deletions(1, [s]) == [0] def test_edge_case_long_string_all_same(): s = 'a' * 100000 assert count_deletions(1, [s]) == [99999]","solution":"def count_deletions(t, test_cases): Determines the number of deletions required so that no two adjacent characters are the same for each test case. Args: t (int): The number of test cases. test_cases (list of str): List of strings for the test cases. Returns: list of int: List of counts of deletions required for each test case. results = [] for s in test_cases: deletions = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: deletions += 1 results.append(deletions) return results"},{"question":"def can_form_palindrome(S: str) -> str: Returns 'YES' if the string can be rearranged to form a palindrome, otherwise returns 'NO'. >>> can_form_palindrome(\\"carrace\\") 'YES' >>> can_form_palindrome(\\"apple\\") 'NO' >>> can_form_palindrome(\\"aabbcc\\") 'YES' >>> can_form_palindrome(\\"abc\\") 'NO'","solution":"def can_form_palindrome(S): Returns 'YES' if the string can be rearranged to form a palindrome, otherwise 'NO'. from collections import Counter # Count the frequency of each character in the string char_count = Counter(S) # Count how many characters have an odd frequency odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # A string can be rearranged to form a palindrome if there is at most one character with an odd frequency if odd_count > 1: return 'NO' else: return 'YES'"},{"question":"def nth_desired_sequence_number(n: int) -> int: Find the N-th number in the Desired Sequence. >>> nth_desired_sequence_number(1) 1 >>> nth_desired_sequence_number(2) 2 >>> nth_desired_sequence_number(3) 4 >>> nth_desired_sequence_number(4) 8 >>> nth_desired_sequence_number(5) 16 def process_test_cases(t: int, cases: List[int]) -> List[int]: Process multiple test cases for finding the N-th number in the Desired Sequence. >>> process_test_cases(3, [1, 2, 5]) [1, 2, 16] >>> process_test_cases(2, [3, 4]) [4, 8] >>> process_test_cases(1, [10]) [512]","solution":"def nth_desired_sequence_number(n): sequence = [1] current_number = 2 while len(sequence) < n: # A set to collect all possible subset sums subset_sums = {0} # Calculate all subset sums from the current sequence for num in sequence: new_sums = {num + x for x in subset_sums} subset_sums.update(new_sums) # Find the next smallest positive number not in subset_sums while current_number in subset_sums: current_number += 1 sequence.append(current_number) current_number += 1 return sequence[n-1] def process_test_cases(t, cases): results = [] for n in cases: results.append(nth_desired_sequence_number(n)) return results"},{"question":"def quickselect(arr, low, high, k): Recursive QuickSelect algorithm to find the k-th smallest element. >>> quickselect([7, 10, 4, 3, 20, 15], 0, 5, 1) 4 >>> quickselect([7, 10, 4, 3, 20], 0, 4, 4) 20 def partition(arr, low, high): Partition the array for QuickSelect. >>> partition([7, 10, 4, 3, 20, 15], 0, 5) # This function modifies the array in-place. def find_kth_smallest(arr, n, k): Find and return the k-th smallest element in the array using QuickSelect. >>> find_kth_smallest([7, 10, 4, 3, 20, 15], 6, 2) 4 >>> find_kth_smallest([7, 10, 4, 3, 20], 5, 5) 20 import pytest from solution import find_kth_smallest def test_find_kth_smallest(): data = [ ([7, 10, 4, 3, 20, 15], 6, 2, 4), ([7, 10, 4, 3, 20], 5, 5, 20), ([1], 1, 1, 1), ([2, 1], 2, 1, 1), ([3, 2, 1], 3, 3, 3), ([10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 10, 7, 7), ([7, 10, 4, 3, 20, 15, 2], 7, 4, 7) ] for arr, n, k, expected in data: assert find_kth_smallest(arr, n, k) == expected","solution":"def quickselect(arr, low, high, k): if low == high: # If the list contains only one element return arr[low] pivot_index = partition(arr, low, high) if pivot_index == k: return arr[pivot_index] elif pivot_index < k: return quickselect(arr, pivot_index + 1, high, k) else: return quickselect(arr, low, pivot_index - 1, k) def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i+1], arr[high] = arr[high], arr[i+1] return i + 1 def find_kth_smallest(arr, n, k): return quickselect(arr, 0, n-1, k-1)"},{"question":"def longest_subarray_with_two_distinct(arr: List[int]) -> int: Find the length of the longest contiguous subarray which contains at most two distinct integers in the array \`arr\`. Args: arr (List[int]): A list of integers. Returns: int: The length of the longest contiguous subarray containing at most two distinct integers. Examples: >>> longest_subarray_with_two_distinct([1, 2, 1, 2, 1, 3, 4]) 5 >>> longest_subarray_with_two_distinct([4, 4, 4, 4, 4]) 5 >>> longest_subarray_with_two_distinct([1, 2, 3, 4, 5, 6]) 2 >>> longest_subarray_with_two_distinct([1, 1, 1, 1, 1]) 5 >>> longest_subarray_with_two_distinct([1, 2, 3, 1, 2, 2, 1]) 4 >>> longest_subarray_with_two_distinct([1]) 1 >>> longest_subarray_with_two_distinct([1, 1]) 2 >>> longest_subarray_with_two_distinct([1, 2]) 2","solution":"def longest_subarray_with_two_distinct(arr): if len(arr) <= 2: return len(arr) start = 0 max_length = 0 frequency_map = {} for end in range(len(arr)): if arr[end] in frequency_map: frequency_map[arr[end]] += 1 else: frequency_map[arr[end]] = 1 while len(frequency_map) > 2: frequency_map[arr[start]] -= 1 if frequency_map[arr[start]] == 0: del frequency_map[arr[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def closest_prime(diameters: List[int]) -> List[int]: Given an array of integers representing the diameters of cakes, replace each diameter with the closest prime number and return the updated list of diameters. >>> closest_prime([10, 14, 20, 35, 2]) [11, 13, 19, 37, 2] >>> closest_prime([8, 15, 16]) [7, 13, 17] >>> closest_prime([7]) [7] >>> closest_prime([14, 23, 10]) [13, 23, 11] >>> closest_prime([2, 200]) [2, 199] >>> closest_prime([199, 98, 103, 105]) [199, 97, 103, 103]","solution":"import sympy def closest_prime(diameters): def find_closest_prime(n): if sympy.isprime(n): return n lower = n - 1 upper = n + 1 while True: if sympy.isprime(lower): return lower if sympy.isprime(upper): return upper lower -= 1 upper += 1 result = [] for diameter in diameters: result.append(find_closest_prime(diameter)) return result # Example usage # n = 5 # diameters = [10, 14, 20, 35, 2] # print(closest_prime(diameters)) # Output: [11, 13, 19, 37, 2]"},{"question":"from typing import List, Tuple def unique_tree_species(N: int, M: int, forest: List[int], queries: List[Tuple[int, int]]) -> List[int]: Returns the number of unique tree species in specified intervals. Parameters: N (int): The number of distinct tree species. M (int): The number of queries. forest (list of int): The list representing the forest. queries (list of tuple of int): Each tuple (L, R) representing the interval of the query. Returns: list of int: Number of unique tree species in each specified interval. >>> unique_tree_species(5, 3, [1, 2, 3, 2, 1], [(1, 3), (2, 5), (1, 5)]) [3, 3, 3] >>> unique_tree_species(4, 2, [4, 4, 4, 4], [(1, 2), (3, 4)]) [1, 1]","solution":"def unique_tree_species(N, M, forest, queries): Returns the number of unique tree species in specified intervals. Parameters: N (int): The number of distinct tree species. M (int): The number of queries. forest (list of int): The list representing the forest. queries (list of tuple of int): Each tuple (L, R) representing the interval of the query. Returns: list of int: Number of unique tree species in each specified interval. results = [] for L, R in queries: interval_species = set(forest[L-1:R]) results.append(len(interval_species)) return results"},{"question":"import math from typing import List, Tuple def max_square_side(n: int, m: int) -> int: Given dimensions n and m of Alex's garden, returns the maximum possible dimension of the side of the largest square that can fit completely into any of the symmetric sections to ensure symmetry. pass def solve(test_cases: List[Tuple[int, int]]) -> List[int]: results = [] for n, m in test_cases: results.append(max_square_side(n, m)) return results if __name__ == \\"__main__\\": k = int(input()) test_cases = [tuple(map(int, input().split())) for _ in range(k)] results = solve(test_cases) for result in results: print(result)","solution":"import math def max_square_side(n, m): Given dimensions n and m of Alex's garden, returns the maximum possible dimension of the side of the largest square that can fit completely into any of the symmetric sections to ensure symmetry. return math.gcd(n, m) def solve(test_cases): results = [] for n, m in test_cases: results.append(max_square_side(n, m)) return results"},{"question":"def is_path_exist(m: int, n: int, park: List[str]) -> str: Determine if Alice can find a path from the top-left corner to the bottom-right corner running only on grass cells. >>> is_path_exist(4, 4, [\\"GGGG\\", \\"GWGG\\", \\"GGGW\\", \\"GGGG\\"]) \\"Yes\\" >>> is_path_exist(3, 3, [\\"GGW\\", \\"GWG\\", \\"WGG\\"]) \\"No\\"","solution":"def is_path_exist(m, n, park): def dfs(x, y, visited): # Check if we are out of bounds or hit water or already visited cell if x < 0 or y < 0 or x >= m or y >= n or park[x][y] == 'W' or visited[x][y]: return False # Check if we have reached the bottom-right corner if x == m-1 and y == n-1: return True # Mark cell as visited visited[x][y] = True # Explore the four possible directions if (dfs(x+1, y, visited) or dfs(x-1, y, visited) or dfs(x, y+1, visited) or dfs(x, y-1, visited)): return True # Unmark the visited cell (backtracking) visited[x][y] = False return False # Initialize visited matrix visited = [[False for _ in range(n)] for _ in range(m)] # Start DFS from the top-left corner return \\"Yes\\" if dfs(0, 0, visited) else \\"No\\""},{"question":"def find_largest_square(n: int, m: int, grid: List[str]) -> int: Find the maximum size of a square subgrid consisting only of 1s. >>> find_largest_square(5, 6, [ \\"101001\\", \\"111111\\", \\"111111\\", \\"011111\\", \\"011111\\" ]) 4 >>> find_largest_square(3, 3, [ \\"000\\", \\"000\\", \\"000\\" ]) 0 >>> find_largest_square(3, 3, [ \\"111\\", \\"111\\", \\"111\\" ]) 3 >>> find_largest_square(4, 5, [ \\"01100\\", \\"11011\\", \\"11111\\", \\"11001\\" ]) 2 >>> find_largest_square(1, 1, [ \\"1\\" ]) 1 >>> find_largest_square(1, 1, [ \\"0\\" ]) 0","solution":"def largest_square_subgrid(grid, n, m): if n == 0 or m == 0: return 0 # Create a DP table to store the size of the largest square subgrid ending at (i, j) dp = [[0] * m for _ in range(n)] max_side_length = 0 for i in range(n): for j in range(m): if grid[i][j] == '1': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side_length = max(max_side_length, dp[i][j]) return max_side_length # Function to parse input and call the main logic def find_largest_square(n, m, input_grid): grid = [list(row) for row in input_grid] return largest_square_subgrid(grid, n, m)"},{"question":"def smallest_subsequence(n: int, k: int, arr: List[int]) -> int: Finds the length of the smallest subsequence of the given sequence of integers such that the sum of its elements is greater than or equal to k. If no such subsequence exists, returns -1. Args: n (int): Size of the array. k (int): Target sum. arr (list): List of integers. Returns: int: Length of the smallest subsequence, or -1 if no such subsequence exists. Examples: >>> smallest_subsequence(5, 11, [3, 1, 4, 2, 8]) 2 >>> smallest_subsequence(5, 20, [1, 1, 1, 1, 1]) -1","solution":"def smallest_subsequence(n, k, arr): Finds the length of the smallest subsequence of the given sequence of integers such that the sum of its elements is greater than or equal to k. If no such subsequence exists, returns -1. Args: n (int): Size of the array. k (int): Target sum. arr (list): List of integers. Returns: int: Length of the smallest subsequence, or -1 if no such subsequence exists. arr.sort(reverse=True) total_sum = 0 subseq_length = 0 for num in arr: total_sum += num subseq_length += 1 if total_sum >= k: return subseq_length return -1"},{"question":"def min_operations_to_equal_heights(arr: List[int]) -> int: Given an array of N integers representing the heights of trees in a row, determine the minimum number of operations needed to make all tree heights equal. Each operation consists of cutting any number of adjacent trees to the same height, which must be less than or equal to the minimum height among the selected trees. :param arr: List[int] - a list of integers representing the heights of trees :return: int - the minimum number of operations needed to make all tree heights equal >>> min_operations_to_equal_heights([3, 5, 3, 4, 3]) 3 >>> min_operations_to_equal_heights([5, 5, 5, 5, 5, 5]) 1 >>> min_operations_to_equal_heights([1, 2, 3, 4, 5]) 5 >>> min_operations_to_equal_heights([8, 8, 8, 8, 8]) 1 >>> min_operations_to_equal_heights([9, 6, 3, 6, 9]) 3 >>> min_operations_to_equal_heights([1, 2]) 2 >>> min_operations_to_equal_heights([7]) 1 >>> min_operations_to_equal_heights([10**6, 10**6, 10**6-1]) 2","solution":"def min_operations_to_equal_heights(arr): Given an array of integers representing the heights of trees, returns the minimum number of operations needed to make all tree heights equal. # Convert the list of heights to a set to find unique heights unique_heights = set(arr) return len(unique_heights) if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) heights = list(map(int, data[1:])) print(min_operations_to_equal_heights(heights))"},{"question":"def min_total_road_length(n: int, cities: List[Tuple[int, int]]) -> int: Connect all cities with roads such that: 1. All cities are connected in one network (directly or indirectly). 2. The total length of all roads is minimized. The length of a road segment running between cities at coordinates (x1, y1) and (x2, y2) is calculated as |x1 - x2| + |y1 - y2| (the Manhattan distance). Args: n (int): Number of cities. cities (List[Tuple[int, int]]): List of tuples representing the coordinates of each city. Returns: int: The total length of the roads required to connect all cities in one network. >>> min_total_road_length(4, [(0, 0), (2, 2), (2, 0), (4, 0)]) 6 >>> min_total_road_length(2, [(1, 1), (4, 1)]) 3 >>> min_total_road_length(4, [(0, 0), (2, 0), (4, 0), (6, 0)]) 6 >>> min_total_road_length(4, [(0, 0), (3, 0), (0, 3), (3, 3)]) 9 >>> min_total_road_length(2, [(100000, 100000), (-100000, -100000)]) 400000 >>> min_total_road_length(4, [(0, 0), (1000, 1000), (2000, 2000), (3000, 3000)]) 6000","solution":"def min_total_road_length(n, cities): def manhattan_distance(city1, city2): return abs(city1[0] - city2[0]) + abs(city1[1] - city2[1]) # Kruskal's helpers parent = list(range(n)) rank = [0] * n def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 # Create all edges edges = [] for i in range(n): for j in range(i + 1, n): dist = manhattan_distance(cities[i], cities[j]) edges.append((dist, i, j)) # Sort edges by weight (distance) edges.sort() minimum_total_distance = 0 num_edges_used = 0 # Kruskal's algorithm to form MST for dist, u, v in edges: if find(u) != find(v): union(u, v) minimum_total_distance += dist num_edges_used += 1 if num_edges_used == n - 1: # MST will have exactly n-1 edges break return minimum_total_distance"},{"question":"class DynamicArray: A class implementing a dynamic array with the following functionalities: * append(x): Add the element x to the end of the array. * removeAtIndex(i): Remove the element at index i if the index is valid (0 ≤ i < current length of the array). * reverse(): Reverse the order of elements in the array. * query(i): Return the element at index i if the index is valid (0 ≤ i < current length of the array), otherwise return -1. Example: >>> da = DynamicArray() >>> da.append(1) >>> da.append(2) >>> da.append(3) >>> da.query(1) 2 >>> da.removeAtIndex(1) >>> da.query(1) 3 >>> da.append(4) >>> da.reverse() >>> da.query(0) 4 >>> da.query(2) 1 def __init__(self): Initialize an empty dynamic array. self.arr = [] def append(self, x: int) -> None: Add the element x to the end of the array. pass def removeAtIndex(self, i: int) -> None: Remove the element at index i if the index is valid (0 ≤ i < current length of the array). pass def reverse(self) -> None: Reverse the order of elements in the array. pass def query(self, i: int) -> int: Return the element at index i if the index is valid (0 ≤ i < current length of the array), otherwise return -1. pass def test_append(): da = DynamicArray() da.append(1) da.append(2) assert da.arr == [1, 2] def test_removeAtIndex(): da = DynamicArray() da.append(1) da.append(2) da.append(3) da.removeAtIndex(1) assert da.arr == [1, 3] da.removeAtIndex(5) # Invalid index, array shouldn't change assert da.arr == [1, 3] def test_reverse(): da = DynamicArray() da.append(1) da.append(2) da.append(3) da.reverse() assert da.arr == [3, 2, 1] def test_query(): da = DynamicArray() da.append(1) da.append(2) da.append(3) assert da.query(1) == 2 assert da.query(4) == -1 def test_complex(): da = DynamicArray() da.append(1) da.append(2) da.append(3) assert da.query(1) == 2 da.removeAtIndex(1) assert da.query(1) == 3 da.append(4) da.reverse() assert da.query(0) == 4 assert da.query(2) == 1","solution":"class DynamicArray: def __init__(self): self.arr = [] def append(self, x): self.arr.append(x) def removeAtIndex(self, i): if 0 <= i < len(self.arr): self.arr.pop(i) def reverse(self): self.arr.reverse() def query(self, i): if 0 <= i < len(self.arr): return self.arr[i] return -1"},{"question":"def find_winner(n: int) -> str: Determines the winner of the game between Alice and Bob if both play optimally. Parameters: n (int): The largest integer from 1 to n included in the game. Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins. >>> find_winner(1) \\"Alice\\" >>> find_winner(2) \\"Bob\\" >>> find_winner(3) \\"Alice\\" >>> find_winner(10) \\"Bob\\" >>> find_winner(999999999) \\"Alice\\" >>> find_winner(1000000000) \\"Bob\\"","solution":"def find_winner(n): Determines the winner of the game between Alice and Bob if both play optimally. Parameters: n (int): The largest integer from 1 to n included in the game. Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins. return \\"Alice\\" if n % 2 == 1 else \\"Bob\\""},{"question":"def subset_sum_exists(N: int, S: int, array: List[int]) -> str: Check if there exists a subset of the given array that sums up to S. >>> subset_sum_exists(5, 9, [1, 2, 3, 4, 5]) == \\"YES\\" >>> subset_sum_exists(4, -10, [-1, -2, -3, -4]) == \\"YES\\" >>> subset_sum_exists(3, 0, [1, -1, 3]) == \\"YES\\" >>> subset_sum_exists(3, 8, [1, 4, 5]) == \\"NO\\" >>> subset_sum_exists(1, 10, [-10]) == \\"NO\\" from solution import subset_sum_exists def test_subset_sum_exists_case1(): assert subset_sum_exists(5, 9, [1, 2, 3, 4, 5]) == \\"YES\\" def test_subset_sum_exists_case2(): assert subset_sum_exists(4, -10, [-1, -2, -3, -4]) == \\"YES\\" def test_subset_sum_exists_case3(): assert subset_sum_exists(3, 0, [1, -1, 3]) == \\"YES\\" def test_subset_sum_exists_case4(): assert subset_sum_exists(3, 8, [1, 4, 5]) == \\"NO\\" def test_subset_sum_exists_case5(): assert subset_sum_exists(1, 10, [-10]) == \\"NO\\" def test_subset_sum_exists_with_zero_sum(): assert subset_sum_exists(3, 0, [0, 0, 0]) == \\"YES\\" def test_subset_sum_exists_with_all_negative_numbers(): assert subset_sum_exists(4, -6, [-1, -2, -3, -4]) == \\"YES\\" def test_subset_sum_exists_with_mixed_sign_numbers(): assert subset_sum_exists(5, 3, [2, 1, -2, -1, 5]) == \\"YES\\" def test_subset_sum_exists_with_single_element_true(): assert subset_sum_exists(1, 5, [5]) == \\"YES\\" def test_subset_sum_exists_with_single_element_false(): assert subset_sum_exists(1, 7, [5]) == \\"NO\\"","solution":"def subset_sum_exists(N, S, array): Check if there exists a subset of the given array that sums up to S. :param N: int - Number of elements in the array :param S: int - Target sum :param array: List[int] - List of integers :return: str - \\"YES\\" if there exists a subset that sums to S, otherwise \\"NO\\" def subset_sum_recursive(index, current_sum): if current_sum == S: return True if index >= N: return False return (subset_sum_recursive(index + 1, current_sum + array[index]) or subset_sum_recursive(index + 1, current_sum)) return \\"YES\\" if subset_sum_recursive(0, 0) else \\"NO\\""},{"question":"from typing import List def can_form_currency(N: int) -> str: Determine if the amount N can be formed by the sum of non-negative multiples of 3, 5, and 7. >>> can_form_currency(10) 'YES' >>> can_form_currency(14) 'YES' >>> can_form_currency(23) 'YES' >>> can_form_currency(30) 'YES' >>> can_form_currency(50) 'YES' >>> can_form_currency(1) 'NO' >>> can_form_currency(2) 'NO' def process_datasets(datasets: List[int]) -> List[str]: Process multiple datasets and determine if each can form a custom currency based on rules, stopping at a dataset with value 0. >>> process_datasets([10, 14, 23, 30, 50, 0]) ['YES', 'YES', 'YES', 'YES', 'YES'] >>> process_datasets([1, 2, 3, 0]) ['NO', 'NO', 'YES'] >>> process_datasets([0]) []","solution":"def can_form_currency(N): Determine if the amount N can be formed by the sum of non-negative multiples of 3, 5, and 7. # Iterating multiples of 3 for x in range(0, N + 1, 3): # Iterating multiples of 5 for y in range(0, N + 1 - x, 5): # Calculating the remaining value needed remaining = N - x - y # Check if the remaining value is a multiple of 7 if remaining % 7 == 0: return \\"YES\\" return \\"NO\\" def process_datasets(datasets): results = [] for N in datasets: if N == 0: break results.append(can_form_currency(N)) return results"},{"question":"def is_subsequence_sum(arr: List[int], k: int) -> str: Determines if there exists a subsequence of the given array 'arr' such that the sum of the subsequence is equal to k. >>> is_subsequence_sum([1, 2, 3, 4, 5], 9) 'YES' >>> is_subsequence_sum([2, 3, 5, 7], 11) 'NO'","solution":"def is_subsequence_sum(arr, k): Determines if there exists a subsequence of the given array 'arr' such that the sum of the subsequence is equal to k. n = len(arr) dp = [False] * (k + 1) dp[0] = True for num in arr: for j in range(k, num-1, -1): if dp[j - num]: dp[j] = True return \\"YES\\" if dp[k] else \\"NO\\""},{"question":"def singleNumber(nums: List[int]) -> int: Returns the element that appears exactly once in the given list of integers. >>> singleNumber([2, 2, 1]) 1 >>> singleNumber([1, 2, 3, 4, 5, 1, 2, 3, 4]) 5 >>> singleNumber([10**6, 1, 2, 1, 2, 10**6, 999]) 999 >>> singleNumber([42]) 42 >>> singleNumber([10, -1, -1, 10, -5]) -5","solution":"def singleNumber(nums): Returns the element that appears exactly once in the given list of integers. result = 0 for num in nums: result ^= num return result"},{"question":"def calculate_average_scores(t: int, test_cases: List[Dict[str, Any]]) -> List[str]: Determine the average score each participant gives across all their trial runs. Args: t : int - Number of test cases test_cases : List of dictionaries, where each dictionary contains: 'n' : int - Number of participants 'participants' : List of lists, where each inner list contains: - A string with participant name - A list of integers representing scores of the participant Returns: A list of strings, where each string is in the format \\"ParticipantName AverageScore\\" >>> test_cases = [ ... {'n': 3, 'participants': [['Alice', [8, 7, 9]], ['Bob', [1, 6, 5]], ['Charlie', [2, 4, 5]]]}, ... {'n': 2, 'participants': [['Dave', [5, 6]], ['Eve', []]]} ... ] >>> calculate_average_scores(2, test_cases) ['Alice 8.00', 'Bob 4.00', 'Charlie 3.67', 'Dave 5.50', 'Eve 0.00'] import pytest from solution import calculate_average_scores def test_example_case(): t = 2 test_cases = [ { 'n': 3, 'participants': [ ['Alice', [8, 7, 9]], ['Bob', [1, 6, 5]], ['Charlie', [2, 4, 5]] ] }, { 'n': 2, 'participants': [ ['Dave', [5, 6]], ['Eve', []] ] } ] assert calculate_average_scores(t, test_cases) == [ 'Alice 8.00', 'Bob 4.00', 'Charlie 3.67', 'Dave 5.50', 'Eve 0.00' ] def test_single_participant(): t = 1 test_cases = [ { 'n': 1, 'participants': [ ['Alex', [10, 9, 8]] ] } ] assert calculate_average_scores(t, test_cases) == [ 'Alex 9.00' ] def test_no_scores(): t = 1 test_cases = [ { 'n': 2, 'participants': [ ['Mia', []], ['Liam', []] ] } ] assert calculate_average_scores(t, test_cases) == [ 'Mia 0.00', 'Liam 0.00' ] def test_varied_scores(): t = 1 test_cases = [ { 'n': 2, 'participants': [ ['Anna', [2, 4, 6, 8]], ['Ella', [5, 5, 5]] ] } ] assert calculate_average_scores(t, test_cases) == [ 'Anna 5.00', 'Ella 5.00' ] if __name__ == \\"__main__\\": pytest.main()","solution":"def calculate_average_scores(t, test_cases): results = [] for i in range(t): n = test_cases[i]['n'] participants = test_cases[i]['participants'] participant_scores = [] for j in range(n): data = participants[j] name = data[0] scores = data[1] if scores: average_score = sum(scores) / len(scores) else: average_score = 0.0 participant_scores.append(f\\"{name} {average_score:.2f}\\") results.extend(participant_scores) return results"},{"question":"def max_brightness(n: int, lanterns: List[int]) -> int: Calculate the maximum sum of non-adjacent brightness values. Parameters: n (int): Number of lanterns. lanterns (List[int]): List of brightness values of lanterns. Returns: int: Maximum possible brightness sum under the constraints. pass # Test cases def test_example_case_1(): assert max_brightness(5, [4, 1, 3, 5, 7]) == 14 def test_example_case_2(): assert max_brightness(8, [2, 4, 6, 2, 5, 8, 4, 3]) == 19 def test_single_lantern(): assert max_brightness(1, [5]) == 5 def test_no_lantern(): assert max_brightness(0, []) == 0 def test_two_lanterns(): assert max_brightness(2, [5, 10]) == 10 assert max_brightness(2, [10, 5]) == 10 def test_large_input(): n = 100000 brightness = [1] * n assert max_brightness(n, brightness) == (n + 1) // 2","solution":"def max_brightness(n, lanterns): Calculate the maximum sum of non-adjacent brightness values. Parameters: n (int): Number of lanterns. lanterns (List[int]): List of brightness values of lanterns. Returns: int: Maximum possible brightness sum under the constraints. # Edge case for no lanterns or single lantern if n == 0: return 0 if n == 1: return lanterns[0] dp = [0] * n # Base cases dp[0] = lanterns[0] dp[1] = max(lanterns[0], lanterns[1]) # Fill the dp array for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + lanterns[i]) return dp[-1]"},{"question":"def findUniqueElement(arr: List[int]) -> int: Find the element that appears only once in the array where every element appears twice except for one. >>> findUniqueElement([2, 3, 2, 4, 3]) 4 >>> findUniqueElement([0, 1, 2, 1, 2]) 0 >>> findUniqueElement([1000000000, 1, 1000000000, 2, 1]) 2 >>> findUniqueElement([-1, -2, -1, -3, -2]) -3 >>> findUniqueElement([1, -1, 2, -1, 1]) 2","solution":"def findUniqueElement(arr): Function to find the element that appears only once in the array. Args: arr (list): The list of integers in which every element appears twice except for one. Returns: int: The element that appears only once. unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"def is_prime(num: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(29) True >>> is_prime(28) False def smallest_prime_greater_than(n: int) -> int: Returns the smallest prime number greater than n. >>> smallest_prime_greater_than(12) 13 >>> smallest_prime_greater_than(29) 31 >>> smallest_prime_greater_than(1) 2 >>> smallest_prime_greater_than(20) 23 >>> smallest_prime_greater_than(10**6) 1000003","solution":"def is_prime(num): Check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def smallest_prime_greater_than(n): Returns the smallest prime number greater than n. # Start checking with the next number after n candidate = n + 1 while not is_prime(candidate): candidate += 1 return candidate"},{"question":"def min_traffic_signals(m, n): Determines the minimum number of traffic signals required for a grid with m rows and n columns such that all intersections are controlled. Parameters: m (int): number of rows n (int): number of columns Returns: int: minimum number of traffic signals required Examples: >>> min_traffic_signals(3, 4) 3 >>> min_traffic_signals(5, 3) 3","solution":"def min_traffic_signals(m, n): Determines the minimum number of traffic signals required for a grid with m rows and n columns such that all intersections are controlled. Parameters: m (int): number of rows n (int): number of columns Returns: int: minimum number of traffic signals required return min(m, n)"},{"question":"def move_zeroes(nums): Move all zeros to the end of the array while maintaining the relative order of the non-zero elements. This is done in-place and in linear time. Args: nums (List[int]): The input list of integers. Returns: List[int]: The list after moving zeros to the end. Examples: >>> move_zeroes([0, 1, 0, 3, 12]) [1, 3, 12, 0, 0] >>> move_zeroes([0, 0, 1, 2]) [1, 2, 0, 0]","solution":"def move_zeroes(nums): Move all zeros to the end of the array while maintaining the relative order of the non-zero elements. This is done in-place and in linear time. Args: nums (List[int]): The input list of integers. Returns: List[int]: The list after moving zeros to the end. n = len(nums) last_non_zero_found_at = 0 # Pointer for the position to place the next non-zero element. # Move all non-zero elements to the front. for i in range(n): if nums[i] != 0: nums[last_non_zero_found_at] = nums[i] last_non_zero_found_at += 1 # Fill remaining positions with zeros. for i in range(last_non_zero_found_at, n): nums[i] = 0 return nums # Sample input # n = int(input()) # nums = list(map(int, input().split())) # Solution # nums = move_zeroes(nums) # print(\\" \\".join(map(str, nums)))"},{"question":"def count_char_occurrences(s: str, queries: List[Tuple[int, int, str]]) -> List[int]: Returns the number of occurrences of a given character in specified ranges of the string. Parameters: s (str): The input string. queries (list of tuples): Each tuple contains (l, r, c) where l and r are indices (1-indexed) and c is the target character. Returns: list of int: List containing results for each query. >>> s = \\"abcaaa\\" >>> queries = [(1, 3, 'a'), (2, 5, 'a'), (1, 6, 'b')] >>> count_char_occurrences(s, queries) [1, 2, 1] >>> s = \\"aaaaaa\\" >>> queries = [(1, 3, 'a'), (1, 6, 'a'), (2, 4, 'a')] >>> count_char_occurrences(s, queries) [3, 6, 3] >>> s = \\"abcdef\\" >>> queries = [(1, 3, 'x'), (2, 5, 'z'), (4, 6, 'y')] >>> count_char_occurrences(s, queries) [0, 0, 0] >>> s = \\"abcdef\\" >>> queries = [(1, 6, 'a'), (1, 6, 'f'), (1, 6, 'd')] >>> count_char_occurrences(s, queries) [1, 1, 1] >>> s = \\"a\\" * 100000 >>> queries = [(1, 100000, 'a'), (1, 50000, 'b'), (50001, 100000, 'a')] >>> count_char_occurrences(s, queries) [100000, 0, 50000]","solution":"def count_char_occurrences(s, queries): Returns the number of occurrences of a given character in specified ranges of the string. Parameters: s (str): The input string. queries (list of tuples): Each tuple contains (l, r, c) where l and r are indices (1-indexed) and c is the target character. Returns: list of int: List containing results for each query. results = [] for l, r, c in queries: # Convert 1-indexed to 0-indexed l -= 1 r -= 1 substring = s[l:r+1] count = substring.count(c) results.append(count) return results"},{"question":"def largest_unique_submatrix(matrix: List[List[int]]) -> int: Determine the area of the largest submatrix with all unique elements. Args: matrix: List of lists, representing the 2D matrix of integers. Returns: An integer representing the area of the largest submatrix with all unique elements. >>> largest_unique_submatrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 9 >>> largest_unique_submatrix([ ... [1, 2, 3, 4], ... [2, 3, 4, 5], ... [3, 4, 5, 6] ... ]) == 6","solution":"def largest_unique_submatrix(matrix): n = len(matrix) m = len(matrix[0]) max_area = 0 for x1 in range(n): for y1 in range(m): seen = set() for x2 in range(x1, n): for y2 in range(y1, m): if matrix[x2][y2] in seen: break seen.add(matrix[x2][y2]) max_area = max(max_area, (x2 - x1 + 1) * (y2 - y1 + 1)) return max_area"},{"question":"def longest_beautiful_gear_system(n: int, sizes: list[int]) -> int: Polycarpus has a collection of gears. Find the length of the longest \\"beautiful gear system\\" such that: - The sizes of the gears are all distinct. - The difference between the sizes of any two consecutive gears is at least 2. >>> longest_beautiful_gear_system(6, [8, 1, 4, 7, 2, 6]) 4 >>> longest_beautiful_gear_system(3, [10, 20, 30]) 3 >>> longest_beautiful_gear_system(5, [1, 1, 1, 1, 1]) 1 from solution import longest_beautiful_gear_system def test_example_cases(): assert longest_beautiful_gear_system(6, [8, 1, 4, 7, 2, 6]) == 4 assert longest_beautiful_gear_system(3, [10, 20, 30]) == 3 assert longest_beautiful_gear_system(5, [1, 1, 1, 1, 1]) == 1 def test_all_same_size(): assert longest_beautiful_gear_system(4, [5, 5, 5, 5]) == 1 def test_consecutive_and_non_consecutive_sizes(): assert longest_beautiful_gear_system(5, [1, 2, 3, 4, 5]) == 3 assert longest_beautiful_gear_system(5, [1, 3, 5, 7, 9]) == 5 def test_large_gap(): assert longest_beautiful_gear_system(6, [1, 10, 20, 30, 40, 50]) == 6 def test_large_input(): sizes = [i for i in range(1, 100001)] assert longest_beautiful_gear_system(100000, sizes) == 50000","solution":"def longest_beautiful_gear_system(n, sizes): # Sort the sizes to easily pick gears with at least a difference of 2 sizes.sort() # Start with the first gear longest_system_length = 1 last_used_gear = sizes[0] for i in range(1, n): if sizes[i] - last_used_gear >= 2: longest_system_length += 1 last_used_gear = sizes[i] return longest_system_length"},{"question":"import sys import heapq from typing import List, Tuple def find_minimum_distances(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]], int, List[Tuple[int, int]]]]) -> List[int]: Calculates the minimum distance to travel between pairs of locations in a city. Args: - T: int, number of test cases. - test_cases: List of tuples where each tuple contains: - int, number of locations N - int, number of roads M - List of tuples, where each tuple contains three integers u, v, d indicating a road between locations u and v with distance d - int, number of queries Q - List of tuples, where each tuple contains two integers u and v, the locations between which the minimum distance is queried Returns: - List of integers where each integer is the minimum distance for the corresponding query. pass # Test Cases def test_case_1(): T = 1 test_cases = [ ( 4, 4, [ (1, 2, 5), (2, 3, 6), (3, 4, 2), (1, 4, 9) ], 3, [ (1, 3), (2, 4), (1, 4) ] ) ] expected = [11, 8, 9] result = find_minimum_distances(T, test_cases) assert result == expected def test_case_2(): T = 1 test_cases = [ ( 3, 3, [ (1, 2, 4), (2, 3, 3), (1, 3, 10) ], 2, [ (1,3), (3,1) ] ) ] expected = [7, 7] result = find_minimum_distances(T, test_cases) assert result == expected def test_case_with_no_path(): T = 1 test_cases = [ ( 3, 1, [ (1, 2, 2) ], 1, [ (1, 3) ] ) ] expected = [-1] result = find_minimum_distances(T, test_cases) assert result == expected def test_case_with_multiple_test_cases(): T = 2 test_cases = [ ( 4, 4, [ (1, 2, 5), (2, 3, 6), (3, 4, 2), (1, 4, 9) ], 2, [ (1, 3), (2, 4) ] ), ( 3, 3, [ (1, 2, 4), (2, 3, 3), (1, 3, 10) ], 2, [ (1, 3), (3, 1) ] ) ] expected = [11, 8, 7, 7] result = find_minimum_distances(T, test_cases) assert result == expected","solution":"import sys import heapq def floyd_warshall(n, graph): dist = [[float('inf')] * n for _ in range(n)] for u in range(n): for v in range(n): dist[u][v] = graph[u][v] for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist def find_minimum_distances(T, test_cases): results = [] for case in test_cases: N, M, roads, Q, queries = case graph = [[float('inf')] * N for _ in range(N)] for i in range(N): graph[i][i] = 0 for u, v, d in roads: graph[u-1][v-1] = d graph[v-1][u-1] = d dist = floyd_warshall(N, graph) for u, v in queries: distance = dist[u-1][v-1] results.append(distance if distance != float('inf') else -1) return results"},{"question":"def max_sum_permutation(arr): Rearranges the elements of the array to maximize the sum of absolute differences between consecutive elements. Parameters: arr (list): A list of integers. Returns: list: The rearranged list to achieve the maximum possible sum. def max_sum_value(arr): Returns the maximum possible value of the sum of absolute differences between consecutive elements after rearranging the array. Parameters: arr (list): A list of integers. Returns: int: The maximum possible value of the sum.","solution":"def max_sum_permutation(arr): Rearranges the elements of the array to maximize the sum of absolute differences between consecutive elements. Parameters: arr (list): A list of integers. Returns: list: The rearranged list to achieve the maximum possible sum. # Sort the array to start with arr.sort() result = [] left = 0 right = len(arr) - 1 # Use a two-pointer technique to maximize the differences while left <= right: if left == right: result.append(arr[left]) else: result.append(arr[right]) result.append(arr[left]) left += 1 right -= 1 # Optional, just to ensure the order follows the input rules strictly (if needed) # result.sort(key=lambda x: -x) return result def max_sum_value(arr): rearranged = max_sum_permutation(arr) max_sum = sum(abs(rearranged[i] - rearranged[i + 1]) for i in range(len(rearranged) - 1)) return max_sum"},{"question":"from typing import List def dice_game_score(dice: List[int]) -> int: Compute the highest-scoring \\"hand\\" based on given rules of a unique dice game. - Five of a Kind (all dice have the same value) - 50 points - Four of a Kind (four dice have the same value) - 25 points - Full House (three of one value and two of another) - 15 points - Straight (five consecutive values, 1-2-3-4-5 or 2-3-4-5-6) - 20 points - Three of a Kind (three dice have the same value) - 10 points - Two Pair (two dice have one value and two another value) - 5 points - One Pair (two dice have the same value) - 2 points - Chance (any other combination) - sum of the dice values >>> dice_game_score([6, 6, 6, 6, 6]) 50 >>> dice_game_score([4, 4, 4, 4, 3]) 25 >>> dice_game_score([3, 3, 3, 6, 6]) 15 >>> dice_game_score([1, 2, 3, 4, 5]) 20 >>> dice_game_score([2, 3, 4, 5, 6]) 20 >>> dice_game_score([2, 2, 2, 4, 5]) 10 >>> dice_game_score([1, 1, 2, 2, 3]) 5 >>> dice_game_score([1, 1, 3, 4, 5]) 2 >>> dice_game_score([1, 2, 3, 4, 6]) 16","solution":"def dice_game_score(dice): from collections import Counter counts = Counter(dice) values = counts.values() keys = counts.keys() if 5 in values: return 50 # Five of a Kind elif 4 in values: return 25 # Four of a Kind elif sorted(values) == [2, 3]: return 15 # Full House elif sorted(dice) in [[1, 2, 3, 4, 5], [2, 3, 4, 5, 6]]: return 20 # Straight elif 3 in values: return 10 # Three of a Kind elif list(values).count(2) == 2: return 5 # Two Pair elif 2 in values: return 2 # One Pair else: return sum(dice) # Chance"},{"question":"from typing import List, Tuple def max_profit(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the maximum possible profit for each test case given stock prices. :param t: int, the number of test cases :param test_cases: list of tuples, where each tuple contains the integer n (number of days) and a list representing the stock prices over n days. :return: list of integers, the maximum profit for each test case. pass def test_max_profit(): # Test input and expected output t = 3 test_cases = [ (6, [7, 1, 5, 3, 6, 4]), (5, [7, 6, 4, 3, 1]), (4, [3, 2, 6, 8]), ] expected_output = [5, 0, 6] # Call the function and assert the result assert max_profit(t, test_cases) == expected_output def test_single_price_day(): t = 2 test_cases = [ (1, [10]), (1, [5]) ] expected_output = [0, 0] assert max_profit(t, test_cases) == expected_output def test_no_profit(): t = 1 test_cases = [ (3, [5, 4, 3]), ] expected_output = [0] assert max_profit(t, test_cases) == expected_output def test_all_days_same_price(): t = 1 test_cases = [ (4, [5, 5, 5, 5]), ] expected_output = [0] assert max_profit(t, test_cases) == expected_output def test_large_input(): t = 1 n = 100000 test_cases = [ (n, [i for i in range(1, n+1)]), # increasing prices ] expected_output = [(n-1)] # biggest difference assert max_profit(t, test_cases) == expected_output def test_decreasing_prices(): t = 1 n = 5 test_cases = [ (n, [5, 4, 3, 2, 1]) ] expected_output = [0] assert max_profit(t, test_cases) == expected_output","solution":"def max_profit(t, test_cases): Calculate the maximum possible profit for each test case given stock prices. :param t: int, the number of test cases :param test_cases: list of tuples, where each tuple contains the integer n (number of days) and a list representing the stock prices over n days. :return: list of integers, the maximum profit for each test case. results = [] for i in range(t): n, prices = test_cases[i] if n == 1: results.append(0) continue min_price = prices[0] max_profit = 0 for price in prices: if price < min_price: min_price = price else: potential_profit = price - min_price if potential_profit > max_profit: max_profit = potential_profit results.append(max_profit) return results"},{"question":"from typing import List, Tuple def can_make_strict(seq: List[int]) -> str: This function checks if exactly one element can be removed from the sequence to make it strictly increasing or decreasing. >>> can_make_strict([1, 2, 3, 4]) \\"NO\\" >>> can_make_strict([4, 3, 2, 1]) \\"NO\\" >>> can_make_strict([1, 2, 3, 5, 4]) \\"YES\\" >>> can_make_strict([3, 4, 5, 6, 5, 7]) \\"YES\\" pass def process_test_cases(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: This function processes multiple test cases and outputs the result for each case. >>> process_test_cases(4, [(4, [1, 2, 3, 4]), (4, [4, 3, 2, 1]), (5, [1, 2, 3, 5, 4]), (6, [3, 4, 5, 6, 5, 7])]) [\\"NO\\", \\"NO\\", \\"YES\\", \\"YES\\"] pass","solution":"def can_make_strict(seq): This function checks if exactly one element can be removed from the sequence to make it strictly increasing or decreasing. def is_strictly_increasing(arr): return all(arr[i] < arr[i+1] for i in range(len(arr)-1)) def is_strictly_decreasing(arr): return all(arr[i] > arr[i+1] for i in range(len(arr)-1)) if is_strictly_increasing(seq) or is_strictly_decreasing(seq): return \\"NO\\" for i in range(len(seq)): new_seq = seq[:i] + seq[i+1:] if is_strictly_increasing(new_seq) or is_strictly_decreasing(new_seq): return \\"YES\\" return \\"NO\\" def process_test_cases(t, test_cases): results = [] for n, buildings in test_cases: results.append(can_make_strict(buildings)) return results"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def construct_tree(nodes): Construct a binary tree from a list of nodes. tree_nodes = [TreeNode(value) for value, _, _ in nodes] for idx, (value, left, right) in enumerate(nodes): if left != -1: tree_nodes[idx].left = tree_nodes[left] if right != -1: tree_nodes[idx].right = tree_nodes[right] return tree_nodes[0] def find_maximum_sum_path(root): Find a path from the root to a leaf such that the sum of the values of the nodes in the path is maximized. >>> root = construct_tree([(3, 1, 2), (1, -1, -1), (-1, 3, 4), (2, -1, -1), (2, -1, -1)]) >>> find_maximum_sum_path(root) ([3, -1, 2], 4) if not root: return ([], 0) if not root.left and not root.right: return ([root.value], root.value) left_path, left_sum = [], float('-inf') right_path, right_sum = [], float('-inf') if root.left: left_path, left_sum = find_maximum_sum_path(root.left) if root.right: right_path, right_sum = find_maximum_sum_path(root.right) if left_sum > right_sum or (left_sum == right_sum and left_path < right_path): return ([root.value] + left_path, root.value + left_sum) else: return ([root.value] + right_path, root.value + right_sum) def max_sum_path_for_test_cases(test_cases): Process multiple test cases. >>> test_cases = [[(3, 1, 2), (1, -1, -1), (-1, 3, 4), (2, -1, -1), (2, -1, -1)], [(10, 1, 2), (5, 3, -1), (-3, -1, 4), (7, -1, -1), (-2, -1, -1)]] >>> max_sum_path_for_test_cases(test_cases) [[3, -1, 2], [10, 5, 7]] results = [] for nodes in test_cases: root = construct_tree(nodes) path, _ = find_maximum_sum_path(root) results.append(path) return results # Sample test cases def test_single_node(): nodes = [(3, -1, -1)] root = construct_tree(nodes) assert find_maximum_sum_path(root) == ([3], 3) def test_example_case_1(): nodes = [ (3, 1, 2), (1, -1, -1), (-1, 3, 4), (2, -1, -1), (2, -1, -1) ] root = construct_tree(nodes) assert find_maximum_sum_path(root) == ([3, -1, 2], 4) def test_example_case_2(): nodes = [ (10, 1, 2), (5, 3, -1), (-3, -1, 4), (7, -1, -1), (-2, -1, -1) ] root = construct_tree(nodes) assert find_maximum_sum_path(root) == ([10, 5, 7], 22) def test_multiple_cases(): test_cases = [ [ (3, 1, 2), (1, -1, -1), (-1, 3, 4), (2, -1, -1), (2, -1, -1) ], [ (10, 1, 2), (5, 3, -1), (-3, -1, 4), (7, -1, -1), (-2, -1, -1) ] ] expected = [ [3, -1, 2], # From first test case [10, 5, 7] # From second test case ] assert max_sum_path_for_test_cases(test_cases) == expected","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def construct_tree(nodes): tree_nodes = [TreeNode(value) for value, _, _ in nodes] for idx, (value, left, right) in enumerate(nodes): if left != -1: tree_nodes[idx].left = tree_nodes[left] if right != -1: tree_nodes[idx].right = tree_nodes[right] return tree_nodes[0] def find_maximum_sum_path(root): if not root: return ([], 0) if not root.left and not root.right: return ([root.value], root.value) left_path, left_sum = [], float('-inf') right_path, right_sum = [], float('-inf') if root.left: left_path, left_sum = find_maximum_sum_path(root.left) if root.right: right_path, right_sum = find_maximum_sum_path(root.right) if left_sum > right_sum or (left_sum == right_sum and left_path < right_path): return ([root.value] + left_path, root.value + left_sum) else: return ([root.value] + right_path, root.value + right_sum) def max_sum_path_for_test_cases(test_cases): results = [] for nodes in test_cases: root = construct_tree(nodes) path, _ = find_maximum_sum_path(root) results.append(path) return results"},{"question":"def min_rooms_for_tasks(test_cases): Find the minimum number of rooms required to execute all tasks without any overlaps within a single room. test_cases: List[List[Tuple[int, int]]]: A list of test cases, each containing a list of (start, end) tasks. >>> min_rooms_for_tasks([ ... [(1, 4), (2, 5), (6, 9)], ... [(1, 2), (2, 3), (3, 4), (4, 5)], ... [(5, 10), (10, 15), (15, 20), (5, 12), (1, 30)] ... ]) [2, 1, 3] def test_min_rooms_for_tasks(): test_cases = [ [ # First test case (1, 4), (2, 5), (6, 9) ], [ # Second test case (1, 2), (2, 3), (3, 4), (4, 5) ], [ # Third test case (5, 10), (10, 15), (15, 20), (5, 12), (1, 30) ] ] expected = [2, 1, 3] result = min_rooms_for_tasks(test_cases) assert result == expected, f\\"Expected {expected} but got {result}\\" def test_all_tasks_same_time(): test_cases = [ [ # All tasks start and end at the same time (1, 3), (1, 3), (1, 3) ] ] expected = [3] result = min_rooms_for_tasks(test_cases) assert result == expected, f\\"Expected {expected} but got {result}\\" def test_tasks_with_gaps(): test_cases = [ [ # Tasks do not overlap at all (1, 2), (3, 4), (5, 6) ] ] expected = [1] result = min_rooms_for_tasks(test_cases) assert result == expected, f\\"Expected {expected} but got {result}\\" def test_increasing_complexity(): test_cases = [ [ # Increasing complexity with overlap (1, 4), (2, 6), (8, 9), (5, 8), (3, 5), (7, 10) ] ] expected = [3] result = min_rooms_for_tasks(test_cases) assert result == expected, f\\"Expected {expected} but got {result}\\"","solution":"def min_rooms_for_tasks(test_cases): results = [] for tasks in test_cases: intervals = [] for start, end in tasks: intervals.append((start, 1)) # 1 means task starts intervals.append((end, -1)) # -1 means task ends intervals.sort() # Sort by time, if times are the same, task ending comes first current_rooms = 0 max_rooms = 0 for time, event in intervals: current_rooms += event max_rooms = max(max_rooms, current_rooms) results.append(max_rooms) return results"},{"question":"def calculate_trace(matrix): Calculate the trace of a square matrix. The trace is the sum of the elements on the main diagonal. :param matrix: List of lists, where each list represents a row of the square matrix :return: Integer, the trace of the matrix >>> calculate_trace([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 15 >>> calculate_trace([[10, 20], [30, 40]]) 50 >>> calculate_trace([[100]]) 100 >>> calculate_trace([[100000, 2], [3, 100000]]) 200000 >>> calculate_trace([[1, 100000, 3], [4, 5, 100000], [7, 8, 9]]) 15 import pytest from solution import calculate_trace def test_calculate_trace_example1(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert calculate_trace(matrix) == 15 def test_calculate_trace_example2(): matrix = [ [10, 20], [30, 40] ] assert calculate_trace(matrix) == 50 def test_calculate_trace_single_element(): matrix = [ [100] ] assert calculate_trace(matrix) == 100 def test_calculate_trace_large_elements(): matrix = [ [100000, 2], [3, 100000] ] assert calculate_trace(matrix) == 200000 def test_calculate_trace_mixed_elements(): matrix = [ [1, 100000, 3], [4, 5, 100000], [7, 8, 9] ] assert calculate_trace(matrix) == 15 # 1 + 5 + 9 def test_calculate_trace_large_matrix(): matrix = [[i for i in range(1000)] for j in range(1000)] expected_trace = sum(i for i in range(1000)) assert calculate_trace(matrix) == expected_trace def test_calculate_trace_random_elements(): matrix = [ [5, 9, 1], [6, 7, 2], [3, 8, 7] ] assert calculate_trace(matrix) == 19 # 5 + 7 + 7","solution":"def calculate_trace(matrix): This function calculates the trace of a square matrix. The trace is the sum of the elements on the main diagonal. :param matrix: List of lists, where each list represents a row of the square matrix :return: Integer, the trace of the matrix n = len(matrix) trace = 0 for i in range(n): trace += matrix[i][i] return trace"},{"question":"def follows_pattern(s: str, sub1: str, sub2: str) -> bool: Determine if a given input string follows a specified pattern of two substrings. The function takes three parameters: - s: The main string to analyze. - sub1: The first substring pattern. - sub2: The second substring pattern. Return True if sub1 is followed by sub2 in the string s without overlapping, otherwise False. >>> follows_pattern(\\"abcde\\", \\"ab\\", \\"de\\") True >>> follows_pattern(\\"helloworld\\", \\"hello\\", \\"world\\") True >>> follows_pattern(\\"hellohelloworld\\", \\"hello\\", \\"world\\") True >>> follows_pattern(\\"abcdef\\", \\"fg\\", \\"hi\\") False >>> follows_pattern(\\"abac\\", \\"ab\\", \\"ba\\") False","solution":"def follows_pattern(s: str, sub1: str, sub2: str) -> bool: Returns True if sub1 is followed by sub2 in the string s without overlapping, otherwise False. # Find the first occurrence of sub1 first_index = s.find(sub1) if first_index == -1: return False # Find the first occurrence of sub2 after sub1 second_index = s.find(sub2, first_index + len(sub1)) if second_index == -1: return False return True"},{"question":"from typing import List def longest_path_from_input(n: int, m: int, grid: List[str]) -> int: Determine the length of the longest path of consecutive empty cells from the top-left to the bottom-right corner. >>> longest_path_from_input(3, 3, [\\"..#\\", \\".#.\\", \\"...\\"]) 4 >>> longest_path_from_input(4, 4, [\\"....\\", \\"..\\", \\"..#.\\", \\"..\\"]) -1 >>> longest_path_from_input(1, 1, [\\".\\"]) 0 >>> longest_path_from_input(2, 2, [\\"..\\", \\"..\\"]) 2 >>> longest_path_from_input(3, 3, [\\"..#\\", \\"#..\\", \\"...\\"]) 4","solution":"from collections import deque def longest_path(grid): n = len(grid) m = len(grid[0]) if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 queue = deque([(0, 0, 0)]) visited = set((0, 0)) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 def longest_path_from_input(n, m, matrix): return longest_path(matrix)"},{"question":"def arrange_books(n: int, m: int, k: int, categories: List[int]) -> List[int]: Arrange k books out of n such that no two adjacent books are from the same category. Args: n (int): Total number of books. m (int): Number of categories. k (int): Number of books to be placed on the shelf. categories (List[int]): Categories of the books. Returns: List[int]: Indices of the books in the desired arrangement, or [-1] if no valid arrangement exists. Examples: >>> arrange_books(8, 3, 6, [1, 1, 2, 2, 3, 3, 1, 2]) [1, 3, 5, 2, 4, 6] >>> arrange_books(5, 2, 5, [1, 2, 1, 2, 1]) [1, 2, 3, 4, 5] >>> arrange_books(4, 2, 6, [1, 1, 2, 2]) [-1]","solution":"def arrange_books(n, m, k, categories): from itertools import permutations # Helper function to check if the arrangement is valid def is_valid(arrangement): for i in range(1, len(arrangement)): if arrangement[i][1] == arrangement[i-1][1]: return False return True books = [(i + 1, categories[i]) for i in range(n)] possible_books = permutations(books, k) for p in possible_books: if is_valid(p): return [x[0] for x in p] return [-1]"},{"question":"def count_subsequences(s: str, t: str) -> int: Calculate the number of distinct subsequences of s which are equal to t. The result should be returned modulo 1000000007 (10^9 + 7). Args: s (str): The string from which subsequences are derived. t (str): The target pattern subsequence. Returns: int: The number of distinct subsequences of s equal to t modulo 1000000007. >>> count_subsequences(\\"abab\\", \\"ab\\") 3 >>> count_subsequences(\\"abc\\", \\"abc\\") 1 >>> count_subsequences(\\"aaaa\\", \\"aa\\") 6 >>> count_subsequences(\\"abc\\", \\"d\\") 0 >>> count_subsequences(\\"abc\\", \\"\\") 1 >>> count_subsequences(\\"\\", \\"a\\") 0 >>> count_subsequences(\\"\\", \\"\\") 1 pass","solution":"MOD = 1000000007 def count_subsequences(s, t): n = len(s) m = len(t) # Create a 2D dp array initialized to 0 dp = [[0] * (m + 1) for _ in range(n + 1)] # Base case: an empty string is a subsequence of any string for i in range(n + 1): dp[i][0] = 1 # Fill the dp array for i in range(1, n + 1): for j in range(1, m + 1): if s[i - 1] == t[j - 1]: dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % MOD else: dp[i][j] = dp[i - 1][j] return dp[n][m]"},{"question":"def are_participants_unique(n, participants): Determines if all participants in the list are unique. Args: n (int): Number of participants. participants (list of tuples): Each tuple contains name and email of a participant. Returns: str: \\"YES\\" if all participants are unique, \\"NO\\" otherwise. pass # Test Cases def test_all_unique(): assert are_participants_unique(4, [(\\"Alice\\", \\"alice@example.com\\"), (\\"Bob\\", \\"bob@example.com\\"), (\\"Charlie\\", \\"charlie@example.com\\"), (\\"Alice\\", \\"alice.b@example.com\\")]) == \\"YES\\" def test_not_unique_same_email(): assert are_participants_unique(3, [(\\"Alice\\", \\"alice@example.com\\"), (\\"Bob\\", \\"bob@example.com\\"), (\\"Alice\\", \\"alice@example.com\\")]) == \\"NO\\" def test_not_unique_same_name(): assert are_participants_unique(3, [(\\"Alice\\", \\"alice@example.com\\"), (\\"Alice\\", \\"alice@example.com\\"), (\\"Alice\\", \\"alice@example.com\\")]) == \\"NO\\" def test_single_participant(): assert are_participants_unique(1, [(\\"Alice\\", \\"alice@example.com\\")]) == \\"YES\\" def test_unique_with_similar_names(): assert are_participants_unique(2, [(\\"Alice\\", \\"alice@example.com\\"), (\\"Alice\\", \\"alice.b@example.com\\")]) == \\"YES\\"","solution":"def are_participants_unique(n, participants): Determines if all participants in the list are unique. Args: n (int): Number of participants. participants (list of tuples): Each tuple contains name and email of a participant. Returns: str: \\"YES\\" if all participants are unique, \\"NO\\" otherwise. seen = set() for name, email in participants: participant = (name, email) if participant in seen: return \\"NO\\" seen.add(participant) return \\"YES\\""}]`),S={name:"App",components:{PoemCard:A},data(){return{searchQuery:"",visibleCount:4,poemsData:R,isLoading:!1}},computed:{filteredPoems(){const n=this.searchQuery.trim().toLowerCase();return n?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(n)||e.solution&&e.solution.toLowerCase().includes(n)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(n=>setTimeout(n,1e3)),this.visibleCount+=4,this.isLoading=!1}}},j={class:"search-container"},D={class:"card-container"},I={key:0,class:"empty-state"},C=["disabled"],P={key:0},O={key:1};function Y(n,e,u,c,r,a){const f=h("PoemCard");return s(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",j,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")}," ✕ ")):l("",!0)]),t("div",D,[(s(!0),i(x,null,y(a.displayedPoems,(o,p)=>(s(),v(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),i("div",I,' No results found for "'+d(r.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),i("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),i("span",O,"Loading...")):(s(),i("span",P,"See more"))],8,C)):l("",!0)])}const M=m(S,[["render",Y],["__scopeId","data-v-57991565"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/16.md","filePath":"guide/16.md"}'),z={name:"guide/16.md"},U=Object.assign(z,{setup(n){return(e,u)=>(s(),i("div",null,[w(M)]))}});export{B as __pageData,U as default};
