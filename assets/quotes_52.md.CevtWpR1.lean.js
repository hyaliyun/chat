import{_ as h,o as n,c as i,a as t,m as c,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},A={class:"review-content"};function I(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",A,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const C=h(k,[["render",I],["__scopeId","data-v-615c5563"]]),S=JSON.parse('[{"question":"# Evaluate Reverse Polish Notation Context: In computer science, Reverse Polish Notation (RPN) is a mathematical notation in which every operator follows all of its operands. It is also known as postfix notation. For instance, the expression `4 + 5` would be represented as `4 5 +` in RPN. Evaluating RPN expressions requires the use of a stack data structure to handle the operators and operands efficiently. Problem: Write a function to evaluate the value of an arithmetic expression in Reverse Polish Notation. Function Signature: ```python def eval_rpn(tokens: list[str]) -> int: ``` Input: * `tokens`: A list of strings, where each string is either an operand, represented as a number, or an operator (+, -, *, /). Output: * An integer representing the result of evaluating the expression. Constraints: * The input list will contain between 1 and 10,000 elements. * Each element in the list will be a valid operand (integer) or a valid operator. * Division between two integers should truncate toward zero (same behavior as Python\'s `//` operator). Examples: ```python # Example 1 eval_rpn([\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]) # Expected Output: 9 # Explanation: ((2 + 1) * 3) = 9 # Example 2 eval_rpn([\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"]) # Expected Output: 6 # Explanation: (4 + (13 / 5)) = 6 # Example 3 eval_rpn([\\"10\\", \\"6\\", \\"9\\", \\"3\\", \\"+\\", \\"-11\\", \\"*\\", \\"/\\", \\"*\\", \\"17\\", \\"+\\", \\"5\\", \\"+\\"]) # Expected Output: 22 # Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = 22 ``` Performance Consideration: Ensure the implementation handles large input efficiently by using an appropriate data structure and adhering to optimal algorithmic solutions. The operations should be handled in constant time. Note: Your solution must be implemented in pure Python and should not rely on external libraries. Use comments and docstrings to clarify your approach and outline the logic where necessary.","solution":"def eval_rpn(tokens: list[str]) -> int: Evaluate the value of an arithmetic expression in Reverse Polish Notation. Args: tokens (list of str): The RPN expression in the form of a list of tokens. Returns: int: The result of evaluating the expression. stack = [] operators = {\'+\', \'-\', \'*\', \'/\'} for token in tokens: if token in operators: b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': stack.append(int(a / b)) # Truncate towards zero else: stack.append(int(token)) return stack[0]"},{"question":"# Question: Optimizing Financial Transactions Context: Financial transactions are a critical aspect of modern life, spanning investments, loans, and other monetary exchanges. Efficient management and processing of these transactions are crucial for both individuals and institutions. In this exercise, you will create a system that optimizes a sequence of financial transactions to maximize the total benefit based on given constraints. Task: Design and implement a Python class `TransactionManager` to assist with the management and optimization of financial transactions. This class should include methods to add transactions, compute the net balance, and optimize the sequence of transactions based on specific criteria. Requirements: 1. **Add Transaction**: Implement a method `add_transaction(amount: float, category: str, date: str)` to add a new transaction. - `amount` represents the transaction amount (positive for deposits/credits, negative for withdrawals/debits). - `category` is a string denoting the type of transaction (e.g., \\"investment\\", \\"loan\\", \\"expense\\"). - `date` should be in the format `YYYY-MM-DD`. 2. **Net Balance**: Implement a method `net_balance(start_date: str, end_date: str) -> float` to compute the net balance of all transactions between the specified dates. - `start_date` and `end_date` should be in the format `YYYY-MM-DD`. 3. **Optimize Investments**: Implement a method `optimize_investments() -> list` to return a sequence of investment and loan transactions that maximizes returns while minimizing interest within the provided transactions. - Assume that a positive investment transaction adds to profits, while a negative transaction (loan repayment) subtracts from profits. - The transactions should be sequenced in a way to optimize the net benefit. Implementations: - Create the `TransactionManager` class and implement the required methods. - Ensure to handle edge cases, such as incorrect date formats or invalid amounts. - Provide a clear and concise user interface to interact with the transaction system. - Include appropriate unit tests to validate the functionality of each method. Constraints: - Dates will be in the Gregorian calendar and valid. - Each transaction date will be unique. - Optimize the transactions\' sequence for maximum net benefit based on the provided data. Here is the starter skeleton for your implementation: ```python from datetime import datetime from typing import List, Tuple class TransactionManager: def __init__(self): self.transactions = [] def add_transaction(self, amount: float, category: str, date: str): Add a new transaction to the manager. Args: amount: The transaction amount. category: The transaction category. date: The transaction date in YYYY-MM-DD format. Example: >>> manager = TransactionManager() >>> manager.add_transaction(1000, \\"investment\\", \\"2023-09-01\\") >>> manager.add_transaction(-500, \\"loan\\", \\"2023-10-01\\") try: date_obj = datetime.strptime(date, \'%Y-%m-%d\') self.transactions.append((amount, category, date_obj)) except ValueError as ve: raise ValueError(\\"Date must be in YYYY-MM-DD format\\") from ve def net_balance(self, start_date: str, end_date: str) -> float: Calculate net balance between two dates. Args: start_date: The start date in YYYY-MM-DD format. end_date: The end date in YYYY-MM-DD format. Returns: The net balance as a float. Example: >>> manager = TransactionManager() >>> manager.add_transaction(1000, \\"investment\\", \\"2023-09-01\\") >>> manager.add_transaction(-500, \\"loan\\", \\"2023-10-01\\") >>> manager.net_balance(\\"2023-09-01\\", \\"2023-10-01\\") 500.0 try: start = datetime.strptime(start_date, \'%Y-%m-%d\') end = datetime.strptime(end_date, \'%Y-%m-%d\') if start > end: raise ValueError(\\"Start date must be before end date\\") net = sum(amount for amount, _, date in self.transactions if start <= date <= end) return net except ValueError as ve: raise ValueError(\\"Dates must be in YYYY-MM-DD format\\") from ve def optimize_investments(self) -> List[Tuple[float, str, datetime]]: Optimize sequence of investments and loans to maximize net benefit. Returns: A list of transactions maximizing the net benefit. Example: >>> manager = TransactionManager() >>> manager.add_transaction(1000, \\"investment\\", \\"2023-09-01\\") >>> manager.add_transaction(-500, \\"loan\\", \\"2023-10-01\\") >>> manager.optimize_investments() [(1000, \'investment\', datetime.datetime(2023, 9, 1, 0, 0))] # Placeholder logic for optimization, to be implemented investments = [trans for trans in self.transactions if trans[1] == \'investment\'] loans = [trans for trans in self.transactions if trans[1] == \'loan\'] # Implement logic to maximize net benefit return investments # Change according to optimization logic ``` Input and Output Format: - `add_transaction` takes three parameters: float for amount, string for category, and string for date. - `net_balance` takes two string parameters for start and end dates and returns a float. - `optimize_investments` returns a list of tuples containing the transaction amount, category, and date in datetime format. Constraints: - Transaction amounts will be realistic financial values. - All methods must handle invalid inputs and edge cases gracefully. - Ensure computational efficiency while optimizing the transactions. Good luck!","solution":"from datetime import datetime from typing import List, Tuple class TransactionManager: def __init__(self): self.transactions = [] def add_transaction(self, amount: float, category: str, date: str): Add a new transaction to the manager. Args: amount: The transaction amount. category: The transaction category. date: The transaction date in YYYY-MM-DD format. try: date_obj = datetime.strptime(date, \'%Y-%m-%d\') self.transactions.append((amount, category, date_obj)) except ValueError as ve: raise ValueError(\\"Date must be in YYYY-MM-DD format\\") from ve def net_balance(self, start_date: str, end_date: str) -> float: Calculate net balance between two dates. Args: start_date: The start date in YYYY-MM-DD format. end_date: The end date in YYYY-MM-DD format. Returns: The net balance as a float. try: start = datetime.strptime(start_date, \'%Y-%m-%d\') end = datetime.strptime(end_date, \'%Y-%m-%d\') if start > end: raise ValueError(\\"Start date must be before end date\\") net = sum(amount for amount, _, date in self.transactions if start <= date <= end) return net except ValueError as ve: raise ValueError(\\"Dates must be in YYYY-MM-DD format\\") from ve def optimize_investments(self) -> List[Tuple[float, str, datetime]]: Optimize sequence of investments and loans to maximize net benefit. Returns: A list of transactions maximizing the net benefit. # Separate investments and loans investments = sorted((trans for trans in self.transactions if trans[1] == \'investment\'), key=lambda x: x[2]) loans = sorted((trans for trans in self.transactions if trans[1] == \'loan\'), key=lambda x: x[2]) net_profit = 0 optimized_transactions = [] for inv in investments: optimized_transactions.append(inv) net_profit += inv[0] for loan in loans: optimized_transactions.append(loan) net_profit -= loan[0] return optimized_transactions"},{"question":"# Count Unique Characters Problem Context: You are given a list of strings. Your task is to write a function that calculates the number of unique characters present in each string and return the result as a dictionary where the keys are the original strings and the values are the counts of their unique characters. Function Signature: ```python def count_unique_characters(strings: list) -> dict: ``` Input: * **strings (list)**: A list of strings containing only lowercase alphabets. Output: * **dict**: A dictionary where each key is a string from the input list and its value is the count of unique characters in that string. Constraints: 1. Strings will contain only lowercase alphabetic characters (a-z). 2. The list will have at least one string and at most 100 strings. 3. Each string will have a length between 1 and 100 characters (inclusive). Example: ```python >>> count_unique_characters([\'apple\', \'banana\', \'cherry\']) {\'apple\': 4, \'banana\': 3, \'cherry\': 5} >>> count_unique_characters([\'abc\', \'abc\', \'ab\', \'bcd\']) {\'abc\': 3, \'abc\': 3, \'ab\': 2, \'bcd\': 3} ``` Errors: 1. Raise `ValueError` with an appropriate message if the input list is empty. 2. Raise `TypeError` with an appropriate message if any of the elements in the list are not strings. Implementation Instructions: 1. Verify input constraints and raise errors accordingly. 2. Use appropriate data structures to count unique characters in each string. 3. Construct and return the dictionary with strings as keys and their unique character counts as values.","solution":"def count_unique_characters(strings: list) -> dict: if not strings: raise ValueError(\\"Input list cannot be empty\\") if not all(isinstance(s, str) for s in strings): raise TypeError(\\"All elements in the input list must be strings\\") unique_counts = {} for s in strings: unique_chars = set(s) unique_counts[s] = len(unique_chars) return unique_counts"},{"question":"Problem Statement You are given a list of integers and a target sum. Your task is to write a function `find_triplet_sum` that finds if there exists a triplet (three elements) in the list whose sum equals the given target sum. If such a triplet exists, return a sorted tuple containing these three elements. If multiple such triplets exist, return any one of them. If no such triplet exists, return an empty tuple. # Input * `arr` (list of integers): The list of integers. Constraints: (0 leq text{len(arr)} leq 10^5). * `target` (integer): The target sum. # Output * A sorted tuple of three integers whose sum is equal to the target sum, or an empty tuple if no such triplet exists. # Examples ```python find_triplet_sum([1, 2, 3, 4, 5, 6], 12) # Expected output: (1, 4, 7) find_triplet_sum([12, 3, 4, 1, 6, 9], 24) # Expected output: (3, 9, 12) find_triplet_sum([-1, 0, 1, 2, -1, -4], 0) # Expected output: (-1, -1, 2) find_triplet_sum([1, 1, 1, 1], 10) # Expected output: () find_triplet_sum([], 5) # Expected output: () ``` # Constraints * Ensure the function handles cases where the list is either empty or has fewer than three elements by returning an empty tuple. # Additional Notes * The returned tuple should have digits sorted in ascending order, e.g., (1, 2, 3). * The function should aim for a time complexity better than (O(n^3)), where (n) is the length of the list.","solution":"def find_triplet_sum(arr, target): Finds a triplet in the list whose sum is equal to the target sum. If such a triplet exists, returns a sorted tuple of those three elements. If no such triplet exists, returns an empty tuple. arr.sort() n = len(arr) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return (arr[i], arr[left], arr[right]) elif current_sum < target: left += 1 else: right -= 1 return ()"},{"question":"# Flatten Nested List **Context**: Working with nested data structures is a common problem in software development. A particularly interesting challenge arises when dealing with nested lists where the depth of nesting is not fixed. The task is to flatten a nested list, i.e., convert it into a single list containing all the elements from the nested lists in the same order. **Objective**: Implement the `flatten` function and a comprehensive test suite to verify its correctness. The function should take a nested list of arbitrary depth and return a flat list containing all the elements. **Function Signature**: ```python def flatten(nested_list: list) -> list: pass ``` **Expected Input and Output**: * Input: A single nested list (`list`), which can contain elements of any type and other nested lists. * Output: A flat list (`list`) containing all the elements in the same order. **Performance Requirements**: * The function should handle deeply nested structures efficiently. * It should be capable of managing structures with varying nesting levels. **Constraints**: * Ensure the function raises a `TypeError` if the input is not a list. **Example Cases**: * Nested List: * Input: `[1, [2, [3, 4], 5], 6]` * Output: `[1, 2, 3, 4, 5, 6]` * Empty List: * Input: `[]` * Output: `[]` * No Nested List: * Input: `[1, 2, 3]` * Output: `[1, 2, 3]` **Test Cases**: Provide a complete set of tests ensuring that the function handles all typical and edge cases, including: * Lists with multiple nested levels. * Lists containing different types of elements (e.g., integers, strings). * Handling invalid inputs that are not lists. **Implementation Example**: ```python def flatten(nested_list: list) -> list: if not isinstance(nested_list, list): raise TypeError(\\"Input must be a list\\") flat_list = [] for element in nested_list: if isinstance(element, list): flat_list.extend(flatten(element)) else: flat_list.append(element) return flat_list def test_flatten() -> None: assert flatten([1, [2, [3, 4], 5], 6]) == [1, 2, 3, 4, 5, 6] assert flatten([]) == [] assert flatten([1, 2, 3]) == [1, 2, 3] assert flatten([1, \\"string\\", [2, [3.5, [4, \\"nested\\"]], 5], 6]) == [1, \\"string\\", 2, 3.5, 4, \\"nested\\", 5, 6] assert flatten([[1, 2], [3, 4], [5]]) == [1, 2, 3, 4, 5] assert flatten([[\\"a\\", [\\"b\\", [\\"c\\"]]], \\"d\\"]) == [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] if __name__ == \\"__main__\\": print(flatten([1, [2, [3, 4], 5], 6])) # Expected output: [1, 2, 3, 4, 5, 6] print(flatten([1, \\"string\\", [2, [3.5, [4, \\"nested\\"]], 5], 6])) # Expected output: [1, \\"string\\", 2, 3.5, 4, \\"nested\\", 5, 6] print(flatten([[1, 2], [3, 4], [5]])) # Expected output: [1, 2, 3, 4, 5] ```","solution":"def flatten(nested_list: list) -> list: Flattens a nested list of arbitrary depth into a single list containing all the elements. Parameters: nested_list (list): A nested list of arbitrary depth. Returns: list: A flat list containing all the elements. Raises: TypeError: If the input is not a list. if not isinstance(nested_list, list): raise TypeError(\\"Input must be a list\\") flat_list = [] for element in nested_list: if isinstance(element, list): flat_list.extend(flatten(element)) else: flat_list.append(element) return flat_list"},{"question":"# Problem Statement You are tasked with developing a program that determines whether a given Sudoku puzzle is valid. A Sudoku puzzle is valid if it follows these rules: 1. Each row must contain the digits 1-9 without repetition. 2. Each column must contain the digits 1-9 without repetition. 3. Each of the nine 3x3 subgrids must contain the digits 1-9 without repetition. # Specific Requirements 1. **Input**: - A list of lists (a 2D list) where each inner list represents a row in the Sudoku grid, containing either an integer from 1 to 9 or the period character \'.\' denoting an empty cell. 2. **Output**: - A boolean value: `True` if the Sudoku is valid, `False` otherwise. # Example For the following Sudoku grid: ``` [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] ``` The output would be `True`. # Constraints - The input grid is always a 9x9 grid. - The grid may contain digits and the character \'.\' only. # Function Implementation You are required to implement the function `is_valid_sudoku(board: List[List[str]]) -> bool` that validates the Sudoku grid. # Additional Guidance Ensure to handle edge cases such as: - The grid having subgrid violations. - Proper checking for each row, column, and 3x3 grid. # Example Implementation ```python from typing import List def is_valid_sudoku(board: List[List[str]]) -> bool: def is_valid_unit(unit: List[str]) -> bool: unit = [i for i in unit if i != \'.\'] return len(unit) == len(set(unit)) for i in range(9): # Check row if not is_valid_unit(board[i]): return False # Check column if not is_valid_unit([board[j][i] for j in range(9)]): return False for box_row in range(3): for box_col in range(3): if not is_valid_unit( [board[r][c] for r in range(box_row*3, (box_row+1)*3) for c in range(box_col*3, (box_col+1)*3)] ): return False return True if __name__ == \\"__main__\\": board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] print(is_valid_sudoku(board)) # Output should be True ```","solution":"from typing import List def is_valid_sudoku(board: List[List[str]]) -> bool: def is_valid_unit(unit: List[str]) -> bool: unit = [i for i in unit if i != \'.\'] return len(unit) == len(set(unit)) for i in range(9): # Check row if not is_valid_unit(board[i]): return False # Check column if not is_valid_unit([board[j][i] for j in range(9)]): return False for box_row in range(3): for box_col in range(3): if not is_valid_unit( [board[r][c] for r in range(box_row*3, (box_row+1)*3) for c in range(box_col*3, (box_col+1)*3)] ): return False return True"},{"question":"# Fibonacci Index Locator Task Write a function `fibonacci_index(n: int) -> int` that finds the index `i` of the first Fibonacci number in the Fibonacci sequence that has at least `n` digits. The Fibonacci sequence is defined as follows: ( F_0 = 0 ), ( F_1 = 1 ), and ( F_{i} = F_{i-1} + F_{i-2} ) for ( i geq 2 ). Specifications - **Input**: A single integer `n` where `1 <= n <= 100`. - **Output**: The index of the first Fibonacci number whose number of digits is greater than or equal to `n`. - **Constraints**: - Your solution should handle the upper constraints efficiently, ensuring the program runs within a reasonable time frame. Example ```python def fibonacci_index(n: int) -> int: # (Implement your solution here) pass print(fibonacci_index(1)) # Output should be 1 (F1 = 1 has 1 digit) print(fibonacci_index(2)) # Output should be 7 (F7 = 13 has 2 digits) print(fibonacci_index(3)) # Output should be 12 (F12 = 144 has 3 digits) print(fibonacci_index(10)) # Output should be 45 (F45 has 10 digits) ``` Hints: 1. Utilize memoization to store previously computed Fibonacci numbers to enhance performance. 2. Consider the mathematical properties of Fibonacci numbers and digit count to avoid unnecessary computations. 3. Python handles arbitrarily large integers natively, but being mindful of performance when dealing with large sequences is crucial.","solution":"def fibonacci_index(n: int) -> int: Finds the index of the first Fibonacci number in the sequence that has at least n digits. if n < 1: raise ValueError(\\"n must be at least 1\\") a, b = 0, 1 index = 1 while len(str(b)) < n: a, b = b, a + b index += 1 return index"},{"question":"# Sort the List: Iterative vs Recursive You are given two algorithms to sort a list of numbers: an iterative approach using bubble sort and a recursive approach using merge sort. Your task is to implement a function that leverages these algorithms to sort the provided list of numbers in ascending order. Requirements: 1. **Iterative Approach**: Implement the bubble sort algorithm to sort the list. 2. **Recursive Approach**: Implement the merge sort algorithm to sort the list. # Function Signatures: ```python def bubble_sort_iterative(nums: list[int | float]) -> list[int | float]: pass def merge_sort_recursive(nums: list[int | float]) -> list[int | float]: pass ``` # Input: - A list `nums` of integers or floating-point numbers. The list may be empty. # Output: - A new list sorted in ascending order. # Constraints: - Handle empty lists by returning an empty list. - Be mindful of edge cases, such as lists with negative values, zeroes, floating-point numbers, and duplicate values. # Sample Usage: ```python # Test cases for the iterative approach (bubble sort) assert bubble_sort_iterative([3, 2, 1]) == [1, 2, 3] assert bubble_sort_iterative([-3, -2, -1]) == [-3, -2, -1] assert bubble_sort_iterative([3, -3, 0]) == [-3, 0, 3] assert bubble_sort_iterative([3.0, 3.1, 2.9]) == [2.9, 3.0, 3.1] # Test cases for the recursive approach (merge sort) assert merge_sort_recursive([3, 2, 1]) == [1, 2, 3] assert merge_sort_recursive([-3, -2, -1]) == [-3, -2, -1] assert merge_sort_recursive([3, -3, 0]) == [-3, 0, 3] assert merge_sort_recursive([3.0, 3.1, 2.9]) == [2.9, 3.0, 3.1] # Edge case: empty list assert bubble_sort_iterative([]) == [] assert merge_sort_recursive([]) == [] ``` Implement these functions ensuring efficiency and correctness, and handle edge cases appropriately.","solution":"def bubble_sort_iterative(nums: list[int | float]) -> list[int | float]: Sorts a list using iterative bubble sort algorithm. n = len(nums) for i in range(n): for j in range(0, n-i-1): if nums[j] > nums[j+1]: nums[j], nums[j+1] = nums[j+1], nums[j] return nums def merge_sort_recursive(nums: list[int | float]) -> list[int | float]: Sorts a list using recursive merge sort algorithm. if len(nums) <= 1: return nums mid = len(nums) // 2 left_half = merge_sort_recursive(nums[:mid]) right_half = merge_sort_recursive(nums[mid:]) return merge(left_half, right_half) def merge(left: list[int | float], right: list[int | float]) -> list[int | float]: Merges two sorted lists into one sorted list. sorted_list = [] while left and right: if left[0] <= right[0]: sorted_list.append(left.pop(0)) else: sorted_list.append(right.pop(0)) if left: sorted_list.extend(left) if right: sorted_list.extend(right) return sorted_list"},{"question":"# Prime Groupings Write a function that takes a list of integers and returns a dictionary grouping the integers based on whether they are prime or non-prime. Requirements: 1. Implement the `group_by_prime` function which accepts a list of integers. 2. The function should return a dictionary with two keys: * `\'prime\'`: a list of all prime numbers from the input list. * `\'non_prime\'`: a list of all non-prime numbers from the input list. 3. Use a helper function to determine if a number is prime. 4. Ensure the order of numbers in the result lists matches their order in the input list. Input: * A list of integers. Output: * A dictionary with keys `\'prime\'` and `\'non_prime\'` mapping to lists of integers. Example: Input: ```python numbers = [2, 3, 4, 5, 8, 11, 14, 17] ``` Output: ```python { \\"prime\\": [2, 3, 5, 11, 17], \\"non_prime\\": [4, 8, 14] } ``` # Implementation Implement the following function: ```python def is_prime(n: int) -> bool: Determine if the given integer is a prime number. Parameters: n (int): The integer to check for primality. Returns: bool: True if n is a prime number, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def group_by_prime(numbers: list[int]) -> dict[str, list[int]]: Group a list of integers into prime and non-prime categories. Parameters: numbers (list[int]): A list of integers to be grouped. Returns: dict[str, list[int]]: A dictionary with keys \'prime\' and \'non_prime\' mapping to lists containing primes and non-primes respectively. grouped = {\\"prime\\": [], \\"non_prime\\": []} for number in numbers: if is_prime(number): grouped[\\"prime\\"].append(number) else: grouped[\\"non_prime\\"].append(number) return grouped ```","solution":"def is_prime(n: int) -> bool: Determine if the given integer is a prime number. Parameters: n (int): The integer to check for primality. Returns: bool: True if n is a prime number, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def group_by_prime(numbers: list[int]) -> dict[str, list[int]]: Group a list of integers into prime and non-prime categories. Parameters: numbers (list[int]): A list of integers to be grouped. Returns: dict[str, list[int]]: A dictionary with keys \'prime\' and \'non_prime\' mapping to lists containing primes and non-primes respectively. grouped = {\\"prime\\": [], \\"non_prime\\": []} for number in numbers: if is_prime(number): grouped[\\"prime\\"].append(number) else: grouped[\\"non_prime\\"].append(number) return grouped"},{"question":"# Scenario You are developing a library for handling various data manipulation tasks. One of the required functions is to calculate the Median of a given list of numbers. The Median is the value separating the higher half from the lower half of a data sample; if the list length is even, it is the average of the two middle numbers. # Problem Statement Implement a Python function called `calculate_median` that computes the Median for a given list of numbers. # Function Signature ```python def calculate_median(nums: list[int | float]) -> float: ``` # Inputs * `nums`: A list of integers or floating-point numbers. The list can be empty or consists of any numeric values. # Outputs * A floating-point number representing the median of the input list. # Constraints * The function must raise a `ValueError` with the message \\"List is empty\\" if the input list is empty. * The list could contain negative numbers, zero, or positive numbers. * The function should effectively handle both integer and floating-point numbers. # Performance Requirements * The solution should have a time complexity of O(n log n) due to sorting and a space complexity of O(1). # Example ```python assert calculate_median([4, 1, 3, 2]) == 2.5 assert calculate_median([2, 70, 6, 50, 20, 8, 4, 0]) == 6.0 assert calculate_median([-20, 0, 30, 15]) == 7.5 assert calculate_median([10]) == 10.0 try: calculate_median([]) except ValueError as e: assert str(e) == \\"List is empty\\" ``` Implement the `calculate_median` function to meet the given requirements and optimize for performance. Ensure to handle edge cases appropriately and write clear, maintainable code.","solution":"def calculate_median(nums: list[int | float]) -> float: Calculate the median of a list of numbers. If the list length is even, it returns the average of the two middle numbers. If the list is empty, raises a ValueError. if not nums: raise ValueError(\\"List is empty\\") nums.sort() n = len(nums) mid = n // 2 if n % 2 == 0: median = (nums[mid - 1] + nums[mid]) / 2 else: median = nums[mid] return float(median)"},{"question":"# Problem Statement You are tasked with simulating a basic elevator system in a building. The elevator can move up and down between floors, pick up passengers, and drop them off at their requested floors. # Function Signature ```python def simulate_elevator(requests: List[Tuple[int, int]], total_floors: int) -> List[str]: Simulates an elevator journey based on the given requests and total number of floors. Parameters: requests (List[Tuple[int, int]]): A list of tuples representing the pickup requests where each tuple contains the start floor and the destination floor. total_floors (int): The total number of floors in the building (floors start from 1). Returns: List[str]: A list of strings showing the sequence of the elevator\'s moves. Example: [\\"Pick up at floor 3\\", \\"Drop off at floor 5\\", \\"Pick up at floor 2\\", ...] Raises: ValueError: If any floor in the requests is out of range (not between 1 and total_floors). ``` # Requirements - The elevator can only move one floor up or down at a time. - Ensure that the start and destination floors in each request are within the valid range of floors. - The elevator should fulfill the requests in the order they appear in the list. - Upon each move, the function should log either a \\"Pick up at floor X\\" or \\"Drop off at floor Y\\" message. # Example ```python requests = [(3, 5), (2, 7)] total_floors = 10 print(simulate_elevator(requests, total_floors)) # Expected output: # [ # \\"Pick up at floor 3\\", # \\"Move up to floor 5\\", # \\"Drop off at floor 5\\", # \\"Move down to floor 2\\", # \\"Pick up at floor 2\\", # \\"Move up to floor 7\\", # \\"Drop off at floor 7\\" # ] invalid_requests = [(0, 5), (2, 11)] print(simulate_elevator(invalid_requests, total_floors)) # Raises ValueError ``` # Constraints - Ensure that the function handles up to 1000 requests efficiently. - The floors in the requests will satisfy 1 <= start_floor, destination_floor <= total_floors. - The total number of floors will satisfy 1 <= total_floors <= 10^5. # Hints - Iteratively move the elevator one floor at a time until it reaches the desired floor. - Log the appropriate messages as you pick up and drop off passengers.","solution":"from typing import List, Tuple def simulate_elevator(requests: List[Tuple[int, int]], total_floors: int) -> List[str]: result = [] current_floor = 1 for start_floor, dest_floor in requests: if not (1 <= start_floor <= total_floors) or not (1 <= dest_floor <= total_floors): raise ValueError(\\"Invalid floor in request: start_floor or dest_floor out of range.\\") # Move to start floor while current_floor < start_floor: current_floor += 1 result.append(f\\"Move up to floor {current_floor}\\") while current_floor > start_floor: current_floor -= 1 result.append(f\\"Move down to floor {current_floor}\\") result.append(f\\"Pick up at floor {start_floor}\\") # Move to destination floor while current_floor < dest_floor: current_floor += 1 result.append(f\\"Move up to floor {current_floor}\\") while current_floor > dest_floor: current_floor -= 1 result.append(f\\"Move down to floor {current_floor}\\") result.append(f\\"Drop off at floor {dest_floor}\\") return result"},{"question":"# Longest Subsequence with Limited Sum You are tasked with developing a function that finds the longest subsequence of a given list of integers such that the sum of the subsequence does not exceed a specified limit. Your goal is to return the longest possible subsequence without exceeding the sum constraint. Requirements: 1. The function should accept a list of integers and a limit value. 2. The function should find the longest subsequence where the total sum of the elements in the subsequence is less than or equal to the given limit. 3. If there are multiple subsequences with the same length, return any one of them. Input: * `arr` (list of int): A list of integers. * `limit` (int): The maximum allowed sum of the subsequence. Output: * A list of integers representing the longest subsequence that satisfies the sum constraint. Function Signature: ```python def longest_subsequence_with_limit(arr: list, limit: int) -> list: pass ``` Example: ```python # Example usage: assert longest_subsequence_with_limit([4, 2, 3, 1, 7, 5], 10) in [[4, 3, 1, 2], [2, 3, 1, 4]] # detailed possibility as output could vary assert longest_subsequence_with_limit([1, 2, 3, 4, 5], 15) == [1, 2, 3, 4, 5] assert longest_subsequence_with_limit([5, 6, 1, 99, 2, 8, 7], 10) in [[1, 8, 1], [5, 1, 2, 1], ...] ``` Constraints: * The length of the list `arr` will not exceed `10^4`. * Each integer in the list `arr` will be between `1` and `10^6`, inclusive. * The `limit` will be a positive integer and will not exceed `10^9`. Implement a function `longest_subsequence_with_limit` that meets the above criteria.","solution":"def longest_subsequence_with_limit(arr: list, limit: int) -> list: Find the longest subsequence such that the sum of the subsequence does not exceed the given limit. arr.sort() current_sum = 0 subsequence = [] for num in arr: if current_sum + num <= limit: subsequence.append(num) current_sum += num else: break return subsequence"},{"question":"# Question: (Climbing Stairs Variation) Consider the problem of climbing a staircase, where at each step, you can either climb 1, 2, or 3 steps. You are tasked with finding the number of distinct ways to reach the top if the staircase has `n` steps. Implement a function that calculates this number using a dynamic programming approach. **Function Signature:** ```python def climb_stairs(n: int) -> int: ``` **Input:** * An integer `n` (1 ≤ n ≤ 1000), representing the number of steps in the staircase. **Output:** * An integer representing the number of distinct ways to climb a staircase of `n` steps. **Example:** ```python >>> climb_stairs(4) 7 ``` **Explanation:** For `n = 4`, there are 7 distinct ways to climb to the top: 1. 1 step + 1 step + 1 step + 1 step 2. 1 step + 1 step + 2 steps 3. 1 step + 2 steps + 1 step 4. 2 steps + 1 step + 1 step 5. 2 steps + 2 steps 6. 1 step + 3 steps 7. 3 steps + 1 step **Constraints:** * You may assume the input will always be a positive integer within the given range. **Guidelines:** * Use a dynamic programming approach to efficiently calculate the number of ways. * Ensure to handle edge cases like very small stair lengths effectively. * Optimize your solution to run within the given constraints. **Scenario:** As part of a fitness tracking application, you are developing a feature where users can input the number of steps they need to climb, and the app will display the number of different ways they can reach their daily step goals using various combinations of step strides.","solution":"def climb_stairs(n: int) -> int: Calculate the number of distinct ways to climb a staircase of n steps, where at each step, you can either climb 1, 2, or 3 steps. if n == 1: return 1 elif n == 2: return 2 elif n == 3: return 4 # Create a dp array to store the number of ways to reach each step dp = [0] * (n + 1) # Base cases dp[1] = 1 dp[2] = 2 dp[3] = 4 # Fill the dp array for steps from 4 to n for i in range(4, n + 1): dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] return dp[n]"},{"question":"# Mountain Array Analysis You are tasked with writing a function to determine the peak index in a mountain array. A mountain array is an array of integers where: 1. The length of the array is three or greater. 2. There exists some index `i` (`0 < i < len(arr) - 1`) such that: - `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]` - `arr[i] > arr[i + 1] > ... > arr[len(arr) - 1]` Write a function `find_peak_index` that returns the peak index `i` of an input mountain array. Function Signature: ```python def find_peak_index(arr: List[int]) -> int: pass ``` # Requirements: - **Input**: A list of integers `arr` representing the mountain array. - **Output**: The peak index `i` where the maximum element of the mountain array occurs. # Constraints: - The array length will be at least 3. - The array follows the mountain property as specified above. # Example Usage: ```python print(find_peak_index([0, 2, 3, 4, 5, 3, 1])) # Expected: 4 print(find_peak_index([1, 3, 5, 7, 6, 4, 2])) # Expected: 3 print(find_peak_index([0, 10, 5, 2])) # Expected: 1 ``` # Detailed Explanation of Concepts: - **Binary Search Approach**: Utilize a binary search method to efficiently find the peak index in logarithmic time complexity. The binary search is ideal for this task since the array is unimodal (strictly increasing and then strictly decreasing). - **Mountain Array Property**: Ensure the function relies on the properties of the mountain array to guarantee that there is always a single peak. - **Edge Case Handling**: Consider cases where the peak might be close to the beginning or the end of the array. Focus on writing clean, efficient, and well-documented code while considering edge cases and optimizing for performance. # Sample Implementation: ```python from typing import List def find_peak_index(arr: List[int]) -> int: left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] < arr[mid + 1]: left = mid + 1 else: right = mid return left ```","solution":"from typing import List def find_peak_index(arr: List[int]) -> int: left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] < arr[mid + 1]: left = mid + 1 else: right = mid return left"},{"question":"**Binary Tree Nodes at a Given Depth** You are given the root node of a binary tree and an integer `depth`. Write a function that returns the list of node values at the given depth in the binary tree. Function Definition: - **`binary_tree_nodes_at_depth(root: TreeNode, depth: int) -> list[int]`** - **Input**: `root`: TreeNode, `depth`: int - **Output**: list of integers representing the node values at the given depth in the tree. Constraints: - The number of nodes in the binary tree is in the range `[0, 1000]`. - Each node has a unique integer value. - The `depth` is a non-negative integer. Example: Given the binary tree: ``` 3 / 9 20 / 15 7 ``` 1. **Depth 0**: [3] 2. **Depth 1**: [9, 20] 3. **Depth 2**: [15, 7] TreeNode Class: Use the provided `TreeNode` class for tree construction: ```python from __future__ import annotations from typing import Optional class TreeNode: def __init__(self, val: int = 0, left: Optional[TreeNode] = None, right: Optional[TreeNode] = None): self.val = val self.left = left self.right = right ``` Implement the given function considering edge cases and optimizing for the constraints provided.","solution":"from __future__ import annotations from typing import Optional class TreeNode: def __init__(self, val: int = 0, left: Optional[TreeNode] = None, right: Optional[TreeNode] = None): self.val = val self.left = left self.right = right def binary_tree_nodes_at_depth(root: TreeNode, depth: int) -> list[int]: Returns the list of node values at the given depth in the binary tree. If no nodes exist at that depth, returns an empty list. if not root: return [] current_level = [root] current_depth = 0 while current_level: if current_depth == depth: return [node.val for node in current_level] next_level = [] for node in current_level: if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) current_level = next_level current_depth += 1 return []"},{"question":"# Scenario You are tasked with writing a utility function to assist in the management of an inventory system in a retail company. The system should be able to determine the most valuable item in stock based on certain criteria. # Task You are required to write a function called `most_valuable_item` that receives a list of dictionaries representing the inventory items and returns the name of the most valuable item. Each item dictionary contains the `name` of the item, its `price`, and the `quantity` in stock. # Requirements * **Input**: - A list of dictionaries representing the inventory items, where each dictionary has: - `name`: A string representing the name of the item. - `price`: A float representing the price of the item. - `quantity`: An integer representing the quantity of the item in stock. For example, `[{\\"name\\": \\"laptop\\", \\"price\\": 999.99, \\"quantity\\": 10}, {\\"name\\": \\"mouse\\", \\"price\\": 25.00, \\"quantity\\": 150}]`. * **Output**: - A string representing the name of the most valuable item in stock based on the total value (`price * quantity`) of each item. For example, `\\"laptop\\"`. * **Constraints**: - If multiple items have the same value, return the name of the item that appears first in the list. - The list will contain at least one item. Here\'s the function signature: ```python def most_valuable_item(inventory): pass ``` # Example ```python >>> most_valuable_item([ {\\"name\\": \\"laptop\\", \\"price\\": 999.99, \\"quantity\\": 10}, {\\"name\\": \\"mouse\\", \\"price\\": 25.00, \\"quantity\\": 150}, {\\"name\\": \\"keyboard\\", \\"price\\": 49.99, \\"quantity\\": 50} ]) \'laptop\' ``` # Notes 1. Consider edge cases, such as having only one item in the inventory. 2. Ensure the function handles varying item quantities and prices correctly. 3. Emphasize on the modularity and readability of your solution by breaking down the logic into smaller helper functions if needed. 4. Provide inline documentation and comments explaining your logic and approach.","solution":"def most_valuable_item(inventory): Returns the name of the most valuable item in stock based on total value (price * quantity) of each item. Args: inventory (list of dict): List of dictionaries where each dictionary represents an item with `name`, `price`, and `quantity` keys. Returns: str: The name of the most valuable item. if not inventory: return None # Calculate the total value for each item max_item = max(inventory, key=lambda item: item[\'price\'] * item[\'quantity\']) return max_item[\'name\']"},{"question":"**Perfect Number Finder** Problem Statement: A perfect number is a positive integer that is equal to the sum of its proper divisors (excluding the number itself). For example, 28 is a perfect number because its proper divisors are 1, 2, 4, 7, and 14, and their sum is 28. Your task is to write a function that identifies all perfect numbers within a given range and returns their sum. Requirements: - Implement a function `is_perfect_number` to check whether a given number is perfect. - Implement a function `perfect_numbers_sum` to find all perfect numbers within the range [2, 10000] and return their sum. Input: - None (The range 2 to 10000 is fixed). Output: - `int`: Sum of all perfect numbers within the given range. Constraints: - The solution should be efficient within the provided range. - Functions should be adequately tested for correctness. # Function Signatures: ```python def is_perfect_number(number: int) -> bool: # Checks if a given number is a perfect number. pass def perfect_numbers_sum() -> int: # Finds and returns the sum of all perfect numbers in the range 2 to 10000. pass ``` Example: ```python assert is_perfect_number(28) == True assert is_perfect_number(27) == False assert perfect_numbers_sum() == 8128 # Example results from the given range. ``` # Explanation: - **is_perfect_number** function determines if a number is perfect by checking if the sum of its proper divisors equals the number. - **perfect_numbers_sum** finds all perfect numbers within the range 2 to 10000 and returns their sum.","solution":"def is_perfect_number(number: int) -> bool: Check if the given number is a perfect number. if number < 2: return False proper_divisors_sum = sum(i for i in range(1, number // 2 + 1) if number % i == 0) return proper_divisors_sum == number def perfect_numbers_sum() -> int: Find all perfect numbers within the range 2 to 10000 and return their sum. return sum(number for number in range(2, 10001) if is_perfect_number(number))"},{"question":"# Coding Problem: Identifying Palindromic Primes Background A palindromic number is a number that remains the same when its digits are reversed. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. A palindromic prime is a number that is both a palindrome and a prime, such as 2, 3, 5, 7, 11, 101, etc. Task You need to write a function that takes an integer `n` and returns the first `n` palindromic primes in increasing order. Requirements Write a function that: 1. Accepts an integer `n`. 2. Finds the first `n` numbers that are both palindromes and primes. The function should be designed as follows: **Function Signature:** ```python def find_palindromic_primes(n: int) -> list: pass ``` Input: - `n` (int): The number of palindromic primes to find. Output: - Returns a list of the first `n` palindromic primes (list of ints). Constraints: - The input integer `n` will be in the range 1 to 100. Example Here\'s an example to help solidify the problem requirements. Given an integer `n`: - If `n = 5`, the function should return `[2, 3, 5, 7, 11]`. - If `n = 10`, the function should return `[2, 3, 5, 7, 11, 101, 131, 151, 181, 191]`. Note: Ensure the function is optimized for performance and readability. Properly handle edge cases where `n` is out of the specified range.","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def is_palindrome(num): return str(num) == str(num)[::-1] def find_palindromic_primes(n: int) -> list: palindromic_primes = [] current_num = 2 while len(palindromic_primes) < n: if is_palindrome(current_num) and is_prime(current_num): palindromic_primes.append(current_num) current_num += 1 return palindromic_primes"},{"question":"**Context**: You are designing a system to manage sensor data streams in real-time. Each sensor emits a series of readings, which are captured and need to be processed for monitoring purposes. These readings include a timestamp and a value. **Task**: Implement a `SensorDataStream` class that maintains a window of the most recent `k` readings from multiple sensors using a sliding window technique. Your implementation should support insertion of new readings, retrieval of the current window for a sensor, and calculation of the moving average for a sensor\'s readings in the window. # Function Signature ```python class SensorDataStream: def __init__(self, k: int): pass def add_reading(self, sensor_id: int, timestamp: int, value: float) -> None: pass def get_current_window(self, sensor_id: int) -> [(int, float)]: pass def get_moving_average(self, sensor_id: int) -> float: pass ``` # Requirements 1. **Constructor**: Initialize the sensor data stream manager with a given window size `k`. 2. **Add Reading Function**: Add a new reading for a specific sensor. Each reading is composed of a `sensor_id`, a `timestamp`, and a `value`. 3. **Get Current Window Function**: Retrieve the list of readings in the current window for a specified sensor. Each reading should include the `timestamp` and `value`. 4. **Get Moving Average Function**: Calculate and return the moving average of the readings within the current window for a specified sensor. # Constraints - Multiple sensors can send readings to the system. - A sensor\'s timestamp is an integer representing the number of seconds since the epoch. - A sensor\'s value is a floating-point number. - Input sensor IDs, timestamps, and values are within the range of realistic values, typically integers within `1` to `10^6` and floats for values. # Example ```python # Create a sensor data stream manager with window size 3 manager = SensorDataStream(3) # Add readings for sensor 1 manager.add_reading(1, 1617709952, 10.5) manager.add_reading(1, 1617709953, 12.0) manager.add_reading(1, 1617709954, 11.0) # Get current window for sensor 1 assert manager.get_current_window(1) == [(1617709952, 10.5), (1617709953, 12.0), (1617709954, 11.0)] # Calculate moving average for sensor 1 assert manager.get_moving_average(1) == 11.16 # Add another reading causing the oldest to be removed from the window manager.add_reading(1, 1617709955, 13.0) # Get updated window for sensor 1 assert manager.get_current_window(1) == [(1617709953, 12.0), (1617709954, 11.0), (1617709955, 13.0)] # Calculate updated moving average for sensor 1 assert manager.get_moving_average(1) == 12.0 ``` **Note**: Ensure your implementation efficiently handles the sliding window and performs updates smoothly when new readings are added. Handle edge cases where sensors have fewer than `k` readings initially.","solution":"from collections import defaultdict, deque from typing import List, Tuple class SensorDataStream: def __init__(self, k: int): Initializes the sensor data stream manager with a given window size k. self.k = k self.data = defaultdict(deque) def add_reading(self, sensor_id: int, timestamp: int, value: float) -> None: Adds a new reading for a specific sensor. if sensor_id not in self.data: self.data[sensor_id] = deque() sensor_window = self.data[sensor_id] if len(sensor_window) == self.k: sensor_window.popleft() sensor_window.append((timestamp, value)) def get_current_window(self, sensor_id: int) -> List[Tuple[int, float]]: Retrieves the list of readings in the current window for a specified sensor. if sensor_id in self.data: return list(self.data[sensor_id]) else: return [] def get_moving_average(self, sensor_id: int) -> float: Calculates and returns the moving average of the readings within the current window for a specified sensor. if sensor_id not in self.data or not self.data[sensor_id]: return 0.0 sensor_window = self.data[sensor_id] total = sum(value for timestamp, value in sensor_window) return total / len(sensor_window)"},{"question":"# Question You are given a linked list where each node contains an integer value. Your task is to implement a function to reverse the linked list. Use the guidelines below to implement your solution. Function Signature ```python def reverse_linked_list(head: \'ListNode\') -> \'ListNode\': pass ``` Input * head: the head of a singly linked list, which is either None (if the list is empty) or a reference to the first node in the list. Output * The new head of the reversed linked list. Constraints * You cannot use extra memory for another linked list. * Revert the linked list in-place. * Each node in the linked list has the following structure: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Example ```python # Example 1: # Input: 1 -> 2 -> 3 -> None # Output: 3 -> 2 -> 1 -> None node3 = ListNode(3) node2 = ListNode(2, node3) node1 = ListNode(1, node2) assert reverse_linked_list(node1).val == 3 # Example 2: # Input: None # Output: None assert reverse_linked_list(None) == None # Example 3: # Input: 1 -> None # Output: 1 -> None node1 = ListNode(1) assert reverse_linked_list(node1).val == 1 ``` Explanation In this task, your goal is to reverse the given singly linked list. The function should traverse the list once, reversing the pointers of each node to point to the previous node. Handle edge cases like an empty linked list or a list with only one node correctly. At the end, return the new head of the reversed linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: Reverses the linked list in-place. :param head: The head node of the linked list. :return: The new head of the reversed linked list. prev = None current = head while current is not None: next_node = current.next # store the next node current.next = prev # reverse the link prev = current # move prev one step forward current = next_node # move current one step forward return prev # prev will be the new head of the reversed list"},{"question":"# Data Analysis with Pandas You are given a CSV file that contains yearly sales data for various products. Your task is to write a function that reads this CSV file and processes the data to answer specific questions. Specifically, you need to: 1. Load the CSV file into a Pandas DataFrame. 2. Compute the following summary statistics: - Total sales for each product. - Average sales per year for each product. - Year with the maximum sales for each product. Input - A string `file_path` representing the path to the CSV file containing sales data. Output - An instance of `SalesSummary`, a NamedTuple with fields: - `total_sales`: a dictionary with product names as keys and their total sales as values. - `average_sales`: a dictionary with product names as keys and their average yearly sales as values. - `max_sales_year`: a dictionary with product names as keys and the year with their highest sales as values. Constraints - You must use `pandas` library for data processing. - Handle cases where the CSV file might not exist or may be corrupted. Performance Requirements - Your function should efficiently handle large CSV files with millions of rows. - Implement necessary error handling for file-related issues and data integrity problems. Example ```python import pandas as pd from typing import NamedTuple, Dict class SalesSummary(NamedTuple): total_sales: Dict[str, float] average_sales: Dict[str, float] max_sales_year: Dict[str, int] def analyze_sales_data(file_path: str) -> SalesSummary: try: df = pd.read_csv(file_path) # Ensure the required columns are present if not all(column in df.columns for column in [\'Year\', \'Product\', \'Sales\']): raise ValueError(\\"Missing required columns\\") total_sales = df.groupby(\'Product\')[\'Sales\'].sum().to_dict() average_sales = df.groupby(\'Product\')[\'Sales\'].mean().to_dict() max_sales_year = df.groupby(\'Product\').apply( lambda x: x.loc[x[\'Sales\'].idxmax()][\'Year\'] ).to_dict() return SalesSummary(total_sales, average_sales, max_sales_year) except FileNotFoundError: print(\\"The CSV file was not found\\") except pd.errors.EmptyDataError: print(\\"The CSV file is empty or corrupted\\") except Exception as e: print(f\\"An error occurred: {e}\\") # Example usage file_path = \\"sales_data.csv\\" summary = analyze_sales_data(file_path) print(summary) ``` Note Design your function to ensure it is robust to missing or additional data columns. For example, consider edge cases where the CSV file might contain unexpected or incorrect data types.","solution":"import pandas as pd from typing import NamedTuple, Dict class SalesSummary(NamedTuple): total_sales: Dict[str, float] average_sales: Dict[str, float] max_sales_year: Dict[str, int] def analyze_sales_data(file_path: str) -> SalesSummary: try: df = pd.read_csv(file_path) # Ensure the required columns are present if not all(column in df.columns for column in [\'Year\', \'Product\', \'Sales\']): raise ValueError(\\"Missing required columns\\") # Convert columns to appropriate data types df[\'Year\'] = df[\'Year\'].astype(int) df[\'Sales\'] = df[\'Sales\'].astype(float) total_sales = df.groupby(\'Product\')[\'Sales\'].sum().to_dict() average_sales = df.groupby(\'Product\')[\'Sales\'].mean().to_dict() max_sales_year = df.groupby(\'Product\')[\'Sales\'].idxmax() max_sales_year = df.loc[max_sales_year, [\'Product\', \'Year\']].set_index(\'Product\')[\'Year\'].to_dict() return SalesSummary(total_sales, average_sales, max_sales_year) except FileNotFoundError: raise FileNotFoundError(\\"The CSV file was not found\\") except pd.errors.EmptyDataError: raise ValueError(\\"The CSV file is empty or corrupted\\") except ValueError as ve: raise ve except Exception as e: raise Exception(f\\"An unexpected error occurred: {e}\\")"},{"question":"# Problem Statement The provided function `shift_left(arr: list, shifts: int) -> list` shifts the elements of an input list `arr` to the left by a specified number of positions `shifts`. Input - A list `arr` of integers where each integer is in the range -10^9 to 10^9. - An integer `shifts` (0 ≤ `shifts` ≤ 10^9) representing the number of positions to shift. Output - The resultant list after performing the left shift operation. # Task Implement the function `shift_left(arr: list, shifts: int) -> list` to produce the described left shift transformation. Follow the example structure provided below: ```python def shift_left(arr: list, shifts: int) -> list: # Your implementation here ``` Examples 1. **Input**: `shift_left([1, 2, 3, 4, 5], 2)` - **Output**: `[3, 4, 5, 1, 2]` 2. **Input**: `shift_left([1, 2, 3, 4, 5], 0)` - **Output**: `[1, 2, 3, 4, 5]` 3. **Input**: `shift_left([1, 2, 3, 4, 5], 5)` - **Output**: `[1, 2, 3, 4, 5]` Constraints - List `arr` can contain up to 10^5 integers. - The integer `shifts` might be greater than the length of `arr`. # Notes - Consider optimizing your solution to handle large values of `shifts` efficiently. - You may use slicing or other list manipulation techniques as long as your solution handles edge cases appropriately.","solution":"def shift_left(arr: list, shifts: int) -> list: Shifts the elements of `arr` to the left by `shifts` positions. Parameters: arr (list): The list of integers to be shifted. shifts (int): The number of positions to shift the list. Returns: list: The list after being shifted to the left. n = len(arr) if n == 0: return arr shifts = shifts % n # Simplify shifts if greater than the length of the list return arr[shifts:] + arr[:shifts]"},{"question":"**Problem Statement**: You are given an array of integers representing temperatures on different days. The task is to compute how many days you would have to wait until a warmer temperature for each day. If there is no future day for which this is possible, store 0 for that day. You need to write a function that implements this logic efficiently. **Function Signature**: ```python def daily_temperatures(temperatures: tuple[int, ...]) -> list[int]: ``` **Inputs**: - `temperatures`: A tuple of integers, each representing the temperature on a given day. The length of the tuple is between 1 and 10^5. - The temperature is given in degrees and can range from -100 to 150. **Outputs**: - Return a list of integers where each element is the number of days you need to wait until a warmer temperature. If there is no such day, the element should be 0. **Constraints**: - Ensure all input temperatures are within the valid range. - Aim for an O(n) time complexity with an efficient space complexity. **Scenario**: Imagine you are an analyst working for a meteorological agency. Your task is to determine, for each day in a dataset of temperatures, how long it will take for the weather to become warmer. **Examples**: ```python >>> daily_temperatures((73, 74, 75, 71, 69, 72, 76, 73)) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures((30, 40, 50, 60)) [1, 1, 1, 0] >>> daily_temperatures((-10, 0, 10, -10, 20)) [1, 1, 2, 1, 0] ``` **Requirements**: - Handle possible negative and high temperatures within the provided range. - Optimize for both time and space complexity wherever possible.","solution":"def daily_temperatures(temperatures): Returns a list of integers representing the number of days one would have to wait until a warmer temperature. If there is no future day for which this is possible, store 0 for that day. Args: temperatures (tuple[int, ...]): Tuple of integers representing daily temperatures. Returns: list[int]: A list of integers indicating the wait time for a warmer temperature. n = len(temperatures) answer = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: idx = stack.pop() answer[idx] = i - idx stack.append(i) return answer"},{"question":"# Question: Convert a List of Dictionaries into a Pandas DataFrame and Perform Analysis Given a list of dictionaries representing data with potentially missing fields, your task is to write a function that converts it into a Pandas DataFrame. The function should also perform some basic data analysis by filling in missing values, computing the mean of each numerical column, and adding a new column indicating whether a certain value is present in any of the dictionary entries. # Function Signature ```python def analyze_data(dict_list: List[Dict[str, Any]], fill_value: Any, check_field: str, check_value: Any) -> pd.DataFrame: pass ``` # Input - `dict_list` (List[Dict[str, Any]]): A list of dictionaries containing the data. - `fill_value` (Any): The value to use to fill in missing data. - `check_field` (str): The field to check for the presence of `check_value`. - `check_value` (Any): The value to check for within `check_field`. # Output - Returns a Pandas DataFrame after performing the following: - Converting the list of dictionaries to a DataFrame. - Filling missing values. - Computing and printing the mean of each numerical column. - Adding a new column named `check_column` that indicates (True/False) whether `check_value` is present in `check_field` for each row. # Constraints - The dictionaries may have different keys. - Handle missing data gracefully. - Use Pandas for the data conversions. # Performance - Ensure the solution works efficiently with typical DataFrame operations, considering the variability and potential size of the input data. # Example ```python import pandas as pd data = [ {\'name\': \'Alice\', \'age\': 25, \'city\': \'New York\', \'score\': 85}, {\'name\': \'Bob\', \'age\': 30, \'city\': \'Los Angeles\'}, {\'name\': \'Charlie\', \'city\': \'Chicago\', \'score\': 70}, {\'name\': \'David\', \'age\': 35, \'score\': 92} ] fill_value = 0 check_field = \'city\' check_value = \'Chicago\' print(analyze_data(data, fill_value, check_field, check_value)) # Output: # name age city score check_column # 0 Alice 25 New York 85 False # 1 Bob 30 Los Angeles 0 False # 2 Charlie 0 Chicago 70 True # 3 David 35 0 92 False # Mean of columns: # age: 22.5 # score: 61.75 ``` # Notes - Ensure your implementation accounts for a variety of data structures and missing values scenarios. - Perform thorough testing with different cases to ensure robustness.","solution":"import pandas as pd from typing import List, Dict, Any def analyze_data(dict_list: List[Dict[str, Any]], fill_value: Any, check_field: str, check_value: Any) -> pd.DataFrame: # Convert list of dictionaries to DataFrame df = pd.DataFrame(dict_list) # Fill in missing values df.fillna(fill_value, inplace=True) # Compute and print mean of each numerical column means = df.mean(numeric_only=True) print(\\"Mean of columns:\\") for column, mean in means.items(): print(f\\"{column}: {mean}\\") # Add new column indicating whether check_value is present in check_field df[\'check_column\'] = df[check_field] == check_value return df"},{"question":"**Context**: You have been given a large set of data points representing the daily temperatures recorded over several years. Your task is to identify the longest consecutive sequence of days where the daily temperature was strictly increasing. # Task: Implement a function `longest_increasing_temperature_sequence(temperatures: List[int]) -> int` that identifies the length of the longest consecutive sequence of days with strictly increasing temperatures. # Detailed Steps: 1. Parse the input list of integers representing daily temperatures. 2. Traverse the list to find sequences where each temperature is greater than the previous day\'s temperature. 3. Keep track of the longest sequence found. # Input: * `temperatures`: A list of integers representing the daily temperatures. # Output: * Returns an integer representing the length of the longest consecutive sequence of strictly increasing temperatures. # Constraints: * 1 <= len(temperatures) <= 10^5 * -100 <= temperatures[i] <= 100 # Example: ```python def longest_increasing_temperature_sequence(temperatures: List[int]) -> int: # Your implementation here # Usage result = longest_increasing_temperature_sequence([73, 74, 75, 71, 69, 72, 76, 73]) print(result) # Expected output: 3 (sequence: 73, 74, 75) ``` # Performance Requirements: * Your solution should handle input lists up to 100,000 elements efficiently, ensuring the algorithm completes within feasible runtime and space complexity. # Notes: * Ensure to handle edge cases, such as no increasing sequence in the input or all elements being the same.","solution":"from typing import List def longest_increasing_temperature_sequence(temperatures: List[int]) -> int: Identify the length of the longest consecutive sequence of days where the daily temperature was strictly increasing. if not temperatures: return 0 max_length = 1 current_length = 1 for i in range(1, len(temperatures)): if temperatures[i] > temperatures[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"# Problem Statement: You are tasked with writing a function that analyzes a given text file and determines the length of the longest substring without repeating characters. This is a common problem in string manipulation and algorithm optimization. # Detailed Instructions: 1. **Reading the File**: The function should read the content from a file called `input.txt` located in the working directory. 2. **Finding the Longest Substring**: Process the text to find the length of the longest substring that does not contain any repeating characters. 3. **Output**: The function should return the length of this longest substring. # Input and Output: - **Input**: No direct input parameters. The function should read from `input.txt`, a file with plain text content. - **Output**: An integer representing the length of the longest substring without repeating characters. # Constraints: - The file `input.txt` contains a single line of plain text. - The text in the file is case-sensitive, meaning \'A\' and \'a\' are considered different characters. - The text may consist of letters, digits, and punctuations. # Function Signature: ```python def longest_unique_substring_length() -> int: pass ``` # Performance Requirements: Your solution should efficiently handle long strings, ensuring minimal processing time and memory usage. # Example: Given the content of `input.txt` as: ``` abcabcbb ``` The function call: ```python >>> longest_unique_substring_length() 3 ``` Explanation: The answer is \\"abc\\", with the length of 3. Given the content of `input.txt` as: ``` bbbbb ``` The function call: ```python >>> longest_unique_substring_length() 1 ``` Explanation: The answer is \\"b\\", with the length of 1. # Notes: - Ensure the file `input.txt` is present in the working directory. - Consider edge cases such as empty files or files with no characters. # Hint: Utilize a sliding window approach to minimize time complexity and optimize the solution.","solution":"def longest_unique_substring_length() -> int: Reads the content from \'input.txt\' and returns the length of the longest substring without repeating characters. with open(\'input.txt\', \'r\') as file: s = file.readline().strip() char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map: left = max(left, char_map[s[right]] + 1) char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"# String Compression Algorithm Implementation You are tasked with implementing a simple lossless string compression algorithm that takes a string and encodes it using the Run-Length Encoding (RLE) technique. The RLE algorithm compresses repetitive sequences of characters by storing the character followed by the count of repetitions. Run-Length Encoding Overview: Run-Length Encoding (RLE) is a very simple form of lossless data compression in which runs of data (i.e., sequences in which the same data value occurs in many consecutive data elements) are stored as a single data value and count, rather than as the original run. # Task: 1. Implement the `rle_compress` function that compresses a string using the RLE algorithm. 2. The function should ensure correct handling of all edge cases. 3. The function should return the compressed string. # Function Signature: ```python def rle_compress(s: str) -> str: ``` # Input: * `s` (String): The string to be compressed. # Output: * A compressed string using RLE. If the compressed string is not shorter than the original string, return the original string. # Constraints: * The input string will only contain uppercase English letters (A-Z). * The length of the input string will be between 0 and 10^6. # Example: ```python >>> rle_compress(\\"AAAABBBCCDAA\\") \\"A4B3C2D1A2\\" >>> rle_compress(\\"ABABABABAB\\") \\"ABABABABAB\\" >>> rle_compress(\\"CCCCCCCCCCCC\\") \\"C12\\" >>> rle_compress(\\"\\") \\"\\" >>> rle_compress(\\"A\\") \\"A\\" ``` # Requirements: 1. Your implementation should be efficient and handle large input sizes within a reasonable time frame. 2. Ensure your approach addresses all possible edge cases correctly.","solution":"def rle_compress(s: str) -> str: if not s: return \\"\\" compressed_string = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed_string.append(f\\"{s[i - 1]}{count}\\") count = 1 compressed_string.append(f\\"{s[-1]}{count}\\") compressed_result = \'\'.join(compressed_string) return compressed_result if len(compressed_result) < len(s) else s"},{"question":"# Question: You are given a singly linked list with the head node `head`. Write a function `detect_cycle(head: Node) -> Optional[Node]` to detect a cycle in the linked list. If there is a cycle, return the node where the cycle begins. If there is no cycle, return `None`. In a cycle, some node\'s next point back to one of the previous nodes in the list. This creates a loop in the linked list. # Input and Output: * **Input**: `head`: the head node of the linked list. * **Output**: `Optional[Node]`: returns the node where the cycle begins if there is a cycle, otherwise `None`. # Constraints: * The number of nodes in the list is in the range [0, 10^4]. * Node values are integers in the range [-10^6, 10^6]. # Edge cases to consider: * The list contains only one node, with or without a cycle. * The list does not contain any cycles. * The list is empty (head is `None`). # Function Signature: ```python from typing import Optional class Node: def __init__(self, data: int, next: Optional[Node] = None): self.data = data self.next = next def detect_cycle(head: Optional[Node]) -> Optional[Node]: pass ``` # Example: ```python # Example 1: head = Node(3, Node(2, Node(0, Node(-4)))) head.next.next.next.next = head.next # Creating a cycle print(detect_cycle(head).data) # Output: 2 # Example 2: head = Node(1, Node(2)) head.next.next = head # Creating a cycle print(detect_cycle(head).data) # Output: 1 # Example 3: head = Node(1) print(detect_cycle(head)) # Output: None # Example 4: head = None print(detect_cycle(head)) # Output: None ```","solution":"from typing import Optional class Node: def __init__(self, data: int, next: Optional[\'Node\'] = None): self.data = data self.next = next def detect_cycle(head: Optional[Node]) -> Optional[Node]: if not head or not head.next: return None # Using Floyd\'s Cycle Detection Algorithm (Tortoise and Hare) slow, fast = head, head # First step: determine if there is a cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: return None # Second step: find the node where the cycle begins slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"# Prime Number Generator Context: You are tasked with creating a function that generates a list of prime numbers up to a given integer. Prime number generation is frequently used in encryption algorithms, random number generation, and numeric computations. Problem Statement: Write a function `generate_primes(n: int) -> List[int]` that returns a list of all prime numbers less than or equal to `n`. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Input: - An integer `n` which is greater than or equal to 2. Output: - A list of integers representing all prime numbers less than or equal to `n`. Constraints: - The function should be optimized for efficiency. - Use the Sieve of Eratosthenes algorithm to achieve the best possible time complexity. - Assume that `n` will not exceed 10^6. Examples: ``` >>> generate_primes(10) [2, 3, 5, 7] >>> generate_primes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> generate_primes(2) [2] >>> generate_primes(30) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] ``` Performance Requirements: - Ensure the solution runs efficiently with a time complexity of O(n log log n) and a space complexity of O(n). Implementation Challenge: Implement the function `generate_primes` considering the large value of `n`, and efficiently marking non-prime numbers to optimize for both time and space complexities.","solution":"from typing import List def generate_primes(n: int) -> List[int]: Generates a list of all prime numbers less than or equal to n using the Sieve of Eratosthenes algorithm. if n < 2: return [] is_prime = [True] * (n + 1) p = 2 while p * p <= n: if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 primes = [p for p in range(2, n + 1) if is_prime[p]] return primes"},{"question":"# Question You are to implement a function that checks whether a given list of strings can be constructed by concatenating elements of another list of strings, where each string can be used any number of times. Your task is to implement the function `can_construct` which takes two lists of strings, `words` and `target`. Function Signature ```python def can_construct(words: list[str], target: list[str]) -> bool: pass ``` # Input - `words` (list of `str`): A list of non-empty strings that can be used to construct the target. - `target` (list of `str`): A list of non-empty strings representing the desired target sequence. # Output - The function should return a `bool`: `True` if the target list can be constructed using the strings from the words list, otherwise `False`. # Constraints - `1 <= len(words) <= 1000` - `1 <= len(target) <= 100` - Each string in `words` and `target` has a length of `1` to `10` characters. # Process Requirements - The solution should have an efficient time complexity, ideally O(n * m) where n is the length of `target` and m is the combined length of strings in `words`. # Example ```python can_construct([\'a\', \'b\', \'ab\'], [\'ab\', \'ab\']) # Expected output: True can_construct([\'a\', \'b\', \'c\'], [\'abc\', \'a\']) # Expected output: True can_construct([\'a\', \'b\'], [\'ab\', \'c\']) # Expected output: False can_construct([\'abc\'], [\'ab\', \'c\']) # Expected output: False ``` # Additional Context - To solve this problem, you need to check if it is possible to construct each string in `target` by concatenating any combination of strings from `words`. - There are no restrictions on reusing the strings in `words`. Develop the necessary checks and logic to efficiently determine if the concatenation condition can be met with the provided words to construct the target. Thoroughly test your implementation with various edge cases and valid inputs.","solution":"def can_construct(words, target): def can_form(word, memo): if word in memo: return memo[word] if word == \\"\\": return True for prefix in words: if word.startswith(prefix): if can_form(word[len(prefix):], memo): memo[word] = True return True memo[word] = False return False memo = {} for t in target: if not can_form(t, memo): return False return True"},{"question":"# Problem Statement Reverse Engineering a File System Overview You are tasked with developing a file system in Python that mimics a simplified version of common file systems. This file system will support basic operations such as creating files, reading files, writing to files, and listing directory contents. Task Implement a `FileSystem` class that allows for the creation, reading, writing, and listing of files and directories. The file system should be hierarchical, meaning directories can contain both files and other directories. Requirements 1. **File and Directory Creation**: Implement methods to create files and directories. 2. **File Writing and Reading**: Implement methods to write to and read from files. 3. **Directory Listing**: Implement a method to list the contents of a directory. 4. **Error Handling**: Handle common errors such as trying to read a non-existent file or creating a directory/file that already exists. Input - **Initialization Parameters**: ```python FileSystem() ``` - **Methods**: - `create_file(path: str)` - `create_directory(path: str)` - `write_file(path: str, content: str)` - `read_file(path: str) -> str` - `list_directory(path: str) -> list` Output - The class should be able to: 1. Create a file at a specified path. 2. Create a directory at a specified path. 3. Write content to a file. 4. Read content from a file. 5. List contents of a directory. Constraints - The file system operations must follow the hierarchical directory structure. - Paths provided will always be valid and will use \\"/\\" as the separator regardless of the operating system. - Directories can contain both files and other directories with unique names within the same directory. Example ```python # Create an instance of the FileSystem fs = FileSystem() # Create a directory and a file fs.create_directory(\\"/documents\\") fs.create_file(\\"/documents/todo.txt\\") # Write to the file fs.write_file(\\"/documents/todo.txt\\", \\"1. Buy Groceriesn2. Check Emails\\") # Read from the file content = fs.read_file(\\"/documents/todo.txt\\") print(content) # Expected output: \\"1. Buy Groceriesn2. Check Emails\\" # List directory contents directory_contents = fs.list_directory(\\"/documents\\") print(directory_contents) # Expected output: [\\"todo.txt\\"] ``` **Note**: Your solution should ensure the hierarchical structure is maintained and that the file system operations (creation, writing, reading, listing) work correctly. Handle any exceptions or errors appropriately.","solution":"class FileSystem: def __init__(self): self.file_system = {} def create_file(self, path: str): directories = path.strip(\'/\').split(\'/\') filename = directories.pop() current_dir = self.file_system for directory in directories: if directory not in current_dir or isinstance(current_dir[directory], str): current_dir[directory] = {} current_dir = current_dir[directory] if filename in current_dir: raise FileExistsError(f\\"File \'{filename}\' already exists.\\") current_dir[filename] = \\"\\" def create_directory(self, path: str): directories = path.strip(\'/\').split(\'/\') current_dir = self.file_system for directory in directories: if directory not in current_dir or isinstance(current_dir[directory], str): current_dir[directory] = {} current_dir = current_dir[directory] def write_file(self, path: str, content: str): directories = path.strip(\'/\').split(\'/\') filename = directories.pop() current_dir = self.file_system for directory in directories: if directory not in current_dir: raise FileNotFoundError(f\\"Directory \'{directory}\' does not exist.\\") current_dir = current_dir[directory] if filename not in current_dir or isinstance(current_dir[filename], dict): raise FileNotFoundError(f\\"File \'{filename}\' does not exist.\\") current_dir[filename] = content def read_file(self, path: str) -> str: directories = path.strip(\'/\').split(\'/\') filename = directories.pop() current_dir = self.file_system for directory in directories: if directory not in current_dir: raise FileNotFoundError(f\\"Directory \'{directory}\' does not exist.\\") current_dir = current_dir[directory] if filename not in current_dir or isinstance(current_dir[filename], dict): raise FileNotFoundError(f\\"File \'{filename}\' does not exist.\\") return current_dir[filename] def list_directory(self, path: str) -> list: directories = path.strip(\'/\').split(\'/\') current_dir = self.file_system for directory in directories: if directory not in current_dir: raise FileNotFoundError(f\\"Directory \'{directory}\' does not exist.\\") current_dir = current_dir[directory] return list(current_dir.keys())"},{"question":"# Coding Assessment Question Problem Description: You are working on a system that processes video streams from security cameras. Each stream captures a sequence of events, where each event is represented by a unique integer. Your task is to remove any duplicate events from the stream, preserving their original order of appearance. Write a function `remove_duplicate_events` that takes an input list of integers representing the events captured by the security cameras and returns a list of integers with duplicates removed, preserving the first occurrence of each event. Function Signature ```python def remove_duplicate_events(events: list[int]) -> list[int]: pass ``` Input: * `events`: A list of integers, where each integer represents an event captured by a security camera. The length of the list is `n` where `0 <= n <= 10^6`. Output: * A list of integers representing the original sequence of events with duplicates removed. Examples: ```python >>> remove_duplicate_events([1, 2, 3, 2, 1, 5, 6, 2, 8, 5]) [1, 2, 3, 5, 6, 8] >>> remove_duplicate_events([1, 1, 1, 1, 1, 1]) [1] >>> remove_duplicate_events([4, 5, 6, 7, 8, 9]) [4, 5, 6, 7, 8, 9] >>> remove_duplicate_events([]) [] >>> remove_duplicate_events([10, 20, 30, 20, 10, 40, 50, 10]) [10, 20, 30, 40, 50] ``` Constraints: * The function should handle up to `10^6` elements efficiently. * All elements in the input list are non-negative integers. Requirements: * Define the function `remove_duplicate_events(events: list[int]) -> list[int]`. * Ensure the function is optimized for large input sizes. * Consider edge cases like an empty list or lists with only one unique element. Use the given example to test your implementation after writing the function.","solution":"def remove_duplicate_events(events: list[int]) -> list[int]: Removes duplicate events from the list while preserving the order of the first occurrence of each event. Args: events (list[int]): A list of integers representing captured events. Returns: list[int]: A list of integers with duplicates removed, preserving the first occurrence of each event. seen = set() unique_events = [] for event in events: if event not in seen: seen.add(event) unique_events.append(event) return unique_events"},{"question":"**Scenario**: As a software developer, you have been assigned to create a utility for checking the validity of email addresses based on specific criteria. This utility will help to ensure that email addresses adhere to standard formatting and domain conventions. **Task**: Implement a class named `EmailValidator` that includes the following methods: 1. `is_valid_email(email: str) -> bool` The method should: - Take a string `email` as input. - Return `True` if the email address is valid, otherwise `False`. # Constraints 1. The input string `email` will have a maximum length of 320 characters. 2. The email address should meet the following criteria: - It must contain exactly one \\"@\\" symbol. - The local part (before the \\"@\\") should only consist of alphanumeric characters, dots, underscores, and hyphens. - The local part should not start or end with a dot and should not have two consecutive dots. - The domain part (after the \\"@\\") should only consist of alphanumeric characters and dots. - The domain must have at least one dot, and the last part of the domain should be between 2 and 6 characters long (e.g., \\"com\\" or \\"co.uk\\"). # Requirements 1. Ensure the implementation handles edge cases, such as empty strings and outrageous lengths. 2. Provide error handling for input that does not meet basic email structure. # Expected Input and Output Format * **is_valid_email(email: str) -> bool** - **Input**: `email = \\"user.name@example.com\\"` - **Output**: `True` - **Input**: `email = \\"username@.com\\"` - **Output**: `False` # Performance 1. The solution should be efficient, running in linear time relative to the length of the input string. As a backend developer, you are working on a feature that requires optimizing the retrieval of unique strings from a list. The goal is to implement a utility that removes duplicates while maintaining the order of their first occurrence. **Task**: Write a function named `get_unique_elements` that takes a list of strings as input and returns another list containing only the unique strings in their original order of occurrence. # Constraints 1. The input list will have a maximum length of 10000 elements. 2. Each string in the input list will have a maximum length of 100 characters. # Requirements 1. Ensure the implementation handles edge cases, such as empty lists and lists with all unique elements. 2. Use data structures that optimize for both time and space complexity. # Expected Input and Output Format * **get_unique_elements(elements: List[str]) -> List[str]** - **Input**: `elements = [\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"grape\\"]` - **Output**: `[\\"apple\\", \\"banana\\", \\"orange\\", \\"grape\\"]` - **Input**: `elements = [\\"cat\\", \\"dog\\", \\"fish\\", \\"cat\\", \\"bird\\"]` - **Output**: `[\\"cat\\", \\"dog\\", \\"fish\\", \\"bird\\"]` # Performance 1. The solution should be efficient, ideally with a linear time complexity regarding the number of elements in the input list.","solution":"import re class EmailValidator: def is_valid_email(self, email: str) -> bool: Check if the given email is valid based on the specified criteria. :param email: The email address to check. :return: True if the email is valid, False otherwise. if len(email) > 320: return False # Define the regex pattern for the whole email email_regex = re.compile( r\'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,6}\' ) # Check the whole pattern if not email_regex.match(email): return False # Split email into local part and domain part local_part, domain_part = email.split(\'@\') # Check if local part starts or ends with a dot or has consecutive dots if local_part.startswith(\'.\') or local_part.endswith(\'.\') or \'..\' in local_part: return False return True def get_unique_elements(elements): Takes a list of strings and returns a list of unique strings maintaining the first occurrence order. :param elements: List of strings. :return: List of unique strings in the order of their first occurrence. seen = set() unique_elements = [] for element in elements: if element not in seen: seen.add(element) unique_elements.append(element) return unique_elements"},{"question":"# Question: Implementing Selection Sort Algorithm Goal Write a function `selection_sort` that sorts a list of integers using the Selection Sort algorithm. Function Signature: ```python def selection_sort(arr: list) -> list: ``` Input * `arr` - A list of integers to be sorted. Output * The function should return a new list containing the sorted integers. Constraints * The list can have at most (10^4) elements. * All elements are integers in the range (-10^6) to (10^6). Examples ```python >>> selection_sort([64, 25, 12, 22, 11]) [11, 12, 22, 25, 64] >>> selection_sort([4, 3, 2, 1]) [1, 2, 3, 4] >>> selection_sort([1]) [1] >>> selection_sort([]) [] >>> selection_sort([5, 5, 5, 5]) [5, 5, 5, 5] ``` Additional Guidelines * Avoid using any built-in sorting functions. * The function should implement the Selection Sort algorithm. * Ensure the function works within the provided constraints.","solution":"def selection_sort(arr: list) -> list: Sorts a list of integers using the Selection Sort algorithm. Args: arr (list): A list of integers to be sorted. Returns: list: A new list containing the sorted integers. n = len(arr) sorted_arr = arr.copy() for i in range(n): # Find the minimum element in the remaining unsorted array min_idx = i for j in range(i+1, n): if sorted_arr[j] < sorted_arr[min_idx]: min_idx = j # Swap the found minimum element with the first element sorted_arr[i], sorted_arr[min_idx] = sorted_arr[min_idx], sorted_arr[i] return sorted_arr"},{"question":"# Problem Statement You are tasked with creating a function to perform matrix multiplication. Your implementation should handle large matrices efficiently and meet the following specifications: # Function Signature ```python def matrix_multiply(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: Perform matrix multiplication on two matrices. Args: matrix1 - A 2D list representing the first matrix. matrix2 - A 2D list representing the second matrix. Returns: A 2D list representing the product of the two matrices. Raises: ValueError - If the matrices cannot be multiplied due to shape mismatch. pass ``` # Input - `matrix1`: A 2D list of integers representing the first matrix. - `matrix2`: A 2D list of integers representing the second matrix. # Output - A 2D list of integers representing the result of matrix multiplication. # Constraints - The number of columns in `matrix1` should be equal to the number of rows in `matrix2` to allow matrix multiplication. - Matrices can be as large as 300x300 in dimension. - Integer values in the matrices will be within the range of [-10^4, 10^4]. # Performance Requirements - The solution should handle the multiplication efficiently, ideally with a time complexity of O(n^3) for matrices of size `n x n`. # Examples Given the input matrices: ```python matrix1 = [ [1, 2, 3], [4, 5, 6] ] matrix2 = [ [7, 8], [9, 10], [11, 12] ] ``` The output should be: ```python [ [58, 64], [139, 154] ] ``` # Edge Cases - Matrices with only one row or one column should still produce the correct result. - If the input matrices cannot be multiplied due to dimension mismatch, the function should raise a ValueError. Make sure your implementation accounts for various sizes and configurations of the input matrices. You should write your own tests to validate the correctness and efficiency of your solution.","solution":"from typing import List def matrix_multiply(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: Perform matrix multiplication on two matrices. Args: matrix1 - A 2D list representing the first matrix. matrix2 - A 2D list representing the second matrix. Returns: A 2D list representing the product of the two matrices. Raises: ValueError - If the matrices cannot be multiplied due to shape mismatch. # Check if the number of columns in matrix1 is equal to the number of rows in matrix2 if len(matrix1[0]) != len(matrix2): raise ValueError(\\"The number of columns in the first matrix must be equal to the number of rows in the second matrix.\\") # matrix1 dimensions: m x n # matrix2 dimensions: n x p # Resultant matrix dimensions: m x p m = len(matrix1) n = len(matrix1[0]) p = len(matrix2[0]) # Initialize the resulting matrix with zeros result = [[0 for _ in range(p)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += matrix1[i][k] * matrix2[k][j] return result"},{"question":"# Problem Statement: You are required to implement a **Circular Buffer (or Ring Buffer)**. This data structure should allow efficient insertion and removal of elements in a circular manner. Your implementation should support various operations to interact with the buffer efficiently. Function Signatures: 1. `__init__(self, size: int) -> None`: Initialize the Circular Buffer with the given size. 2. `enqueue(self, value: int) -> bool`: Insert an element into the circular buffer. Return `True` if the operation is successful, and `False` if the buffer is full. 3. `dequeue(self) -> int`: Remove and return the front element from the circular buffer. If the buffer is empty, return `-1`. 4. `front(self) -> int`: Return the front element of the circular buffer without removing it. If the buffer is empty, return `-1`. 5. `is_full(self) -> bool`: Check if the circular buffer is full. 6. `is_empty(self) -> bool`: Check if the circular buffer is empty. Constraints: - The size of the circular buffer `N` will be between `1` and `10^5`. - The value of each element `value` will be between `-10^9` and `10^9`. - The operations `enqueue`, `dequeue`, `front`, `is_full`, and `is_empty` should all run in constant time `O(1)`. Example: ```python >>> cb = CircularBuffer(3) >>> cb.enqueue(10) True >>> cb.enqueue(20) True >>> cb.enqueue(30) True >>> cb.enqueue(40) False >>> cb.front() 10 >>> cb.dequeue() 10 >>> cb.front() 20 >>> cb.enqueue(40) True >>> cb.is_full() True >>> cb.dequeue() 20 >>> cb.dequeue() 30 >>> cb.dequeue() 40 >>> cb.dequeue() -1 >>> cb.is_empty() True ``` # Implementation: You are required to implement the `CircularBuffer` class to meet the given specifications. Pay special attention to handling edge cases and ensuring the efficiency of your implementation.","solution":"class CircularBuffer: def __init__(self, size: int) -> None: self.size = size self.buffer = [0] * size self.front_index = -1 self.rear_index = -1 self.count = 0 def enqueue(self, value: int) -> bool: if self.is_full(): return False if self.is_empty(): self.front_index = 0 self.rear_index = (self.rear_index + 1) % self.size self.buffer[self.rear_index] = value self.count += 1 return True def dequeue(self) -> int: if self.is_empty(): return -1 value = self.buffer[self.front_index] if self.front_index == self.rear_index: self.front_index = -1 self.rear_index = -1 else: self.front_index = (self.front_index + 1) % self.size self.count -= 1 return value def front(self) -> int: if self.is_empty(): return -1 return self.buffer[self.front_index] def is_full(self) -> bool: return self.count == self.size def is_empty(self) -> bool: return self.count == 0"},{"question":"# Coding Assessment Question You are given an array of integers and a target integer. Your task is to determine if there exists a contiguous subarray within the array whose sum is equal to the target integer. Write a function `has_contiguous_subarray(arr: List[int], target: int) -> bool` that returns `True` if such a subarray exists, otherwise, return `False`. Input - `arr` (1 <= |arr| <= 10^5): An array of integers. - `target`: An integer. Output - Return `True` if there exists a contiguous subarray whose sum is equal to `target`, otherwise return `False`. Constraints - The array contains both positive and negative numbers. - The function should have a time complexity of O(n). Example ```python from typing import List def has_contiguous_subarray(arr: List[int], target: int) -> bool: current_sum = 0 sum_dict = {} for index, value in enumerate(arr): current_sum += value if current_sum == target: return True if current_sum - target in sum_dict: return True sum_dict[current_sum] = index return False # Examples print(has_contiguous_subarray([1, 2, 3, 7, 5], 12)) # Output: True print(has_contiguous_subarray([1, 2, 3, 4, 5], 9)) # Output: True print(has_contiguous_subarray([1, 2, 3, 4, 5], 20)) # Output: False print(has_contiguous_subarray([10, 2, -2, -20, 10], -10)) # Output: True print(has_contiguous_subarray([-1, -1, 1, -1, -1, 1], 0)) # Output: True ```","solution":"from typing import List def has_contiguous_subarray(arr: List[int], target: int) -> bool: Determines if there exists a contiguous subarray within the array whose sum is equal to the target integer. current_sum = 0 sum_dict = {} for index, value in enumerate(arr): current_sum += value if current_sum == target: return True if current_sum - target in sum_dict: return True sum_dict[current_sum] = index return False"},{"question":"# Longest Increasing Subsequence You are provided with an array-like data structure `A[1..n]`. The task is to find the length of the longest increasing subsequence (LIS) in the array. A subsequence is a sequence that can be derived from the array by deleting some or none of the elements without changing the order of the remaining elements. Your task is to implement two functions to find the length of the longest increasing subsequence in the array: 1. `find_lis_dp(arr)`: A method using dynamic programming. 2. `find_lis_binary_search(arr)`: An optimized method utilizing binary search with patience sorting technique. Function Signature ```python def find_lis_dp(arr: List[int]) -> int: pass def find_lis_binary_search(arr: List[int]) -> int: pass ``` # Input Format - `arr`: A list of integers, where `1 <= len(arr) <= 10^5`. # Output Format For both functions: - Return a single integer, the length of the longest increasing subsequence. # Constraints - The elements of `A` must be comparable. - Both functions should handle empty lists correctly. - The dynamic programming method should use (O(n^2)) time complexity. - The binary search method should be optimized for performance using (O(n log n)) time complexity. Example ```python # Example 1 arr = [10, 9, 2, 5, 3, 7, 101, 18] assert find_lis_dp(arr) == 4 assert find_lis_binary_search(arr) == 4 # Example 2 arr = [0, 1, 0, 3, 2, 3] assert find_lis_dp(arr) == 4 assert find_lis_binary_search(arr) == 4 # Example 3 arr = [] assert find_lis_dp(arr) == 0 assert find_lis_binary_search(arr) == 0 # Example 4 arr = [7, 7, 7, 7, 7, 7, 7] assert find_lis_dp(arr) == 1 assert find_lis_binary_search(arr) == 1 ``` Implement the two functions such that they adhere to the specifications and handle the given examples correctly.","solution":"from typing import List import bisect def find_lis_dp(arr: List[int]) -> int: if not arr: return 0 n = len(arr) dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def find_lis_binary_search(arr: List[int]) -> int: if not arr: return 0 lis = [] for num in arr: pos = bisect.bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis)"},{"question":"# Problem Statement You are tasked with designing a file handling utility that amalgamates data from multiple CSV files into a single CSV file. Each input CSV file contains data with the same structure. Your utility should concatenate the contents of these files into a single output file, preserving the header row from the first file and discarding duplicate headers from subsequent files. # Task Write a function `merge_csv_files` that takes in a list of file paths and an output file path. Your function should read the content of these CSV files, merge their content into one, and write the result to the specified output file path. # Input * `file_paths` (list of str): A list of file paths to the input CSV files. * `output_file_path` (str): The file path for the output CSV file. # Output * Creates or overwrites the output file at `output_file_path` with the merged data from the input files. # Constraints * Each input file is a valid CSV file with the same columns and headers. * The list `file_paths` will have at least one file path and at most 100 file paths. * The structure and order of columns in all CSV files are identical. * Handle file reading/writing errors gracefully. # Example Function Signature ```python import csv def merge_csv_files(file_paths: list, output_file_path: str) -> None: first_file = True with open(output_file_path, mode=\'w\', newline=\'\') as outfile: writer = csv.writer(outfile) for file_path in file_paths: try: with open(file_path, mode=\'r\') as infile: reader = csv.reader(infile) if first_file: # Write the header from the first file writer.writerow(next(reader)) first_file = False else: # Skip the header in subsequent files next(reader) # Write the data rows for row in reader: writer.writerow(row) except Exception as e: print(f\\"Error processing {file_path}: {e}\\") ``` # Example Usage ```python file_paths = [\'data1.csv\', \'data2.csv\', \'data3.csv\'] output_file_path = \'merged_data.csv\' merge_csv_files(file_paths, output_file_path) ``` In this new question, you are required to handle file manipulation and ensure that CSV data is merged correctly across multiple files while managing headers appropriately. This involves reading from multiple files, processing their contents, and writing to an output file, thereby testing file handling and error management skills in Python.","solution":"import csv def merge_csv_files(file_paths: list, output_file_path: str) -> None: Merges data from multiple CSV files into a single CSV file, preserving only the header from the first file and discarding headers from subsequent files. :param file_paths: List of paths to the input CSV files. :param output_file_path: Path to the output CSV file. first_file = True with open(output_file_path, mode=\'w\', newline=\'\') as outfile: writer = csv.writer(outfile) for file_path in file_paths: try: with open(file_path, mode=\'r\', newline=\'\') as infile: reader = csv.reader(infile) if first_file: # Write the header from the first file writer.writerow(next(reader)) first_file = False else: # Skip the header in subsequent files next(reader) # Write the data rows for row in reader: writer.writerow(row) except Exception as e: print(f\\"Error processing {file_path}: {e}\\")"},{"question":"# Sorting Algorithms - Challenge You are tasked with implementing a classic sorting algorithm: Merge Sort. Merge Sort is a divide-and-conquer algorithm that works by recursively dividing the array into halves until each half contains a single element, and then merging these halves back together in sorted order. Function to Implement: 1. `merge_sort(arr: List[int]) -> List[int]` - **Input**: - `arr` (List[int]): A list of integers that needs to be sorted. - **Output**: A new list of integers in ascending order. Additional Details: * Merge Sort follows the principle of dividing the list into two halves, sorting each half, and then merging the sorted halves back together. * The base case for the recursion is when the size of the list is less than or equal to one, which is already sorted. * Make sure to implement the merge function as a helper to merge two sorted lists into a single sorted list. Performance Requirements: * The time complexity should be O(n log n), where n is the number of elements in the list. * The space complexity should be O(n) due to the additional arrays used during the merge process. Examples: ```python assert merge_sort([4, 3, 1, 5, 6]) == [1, 3, 4, 5, 6] assert merge_sort([10, -1, 2, 5, 0, 6, 4, -5]) == [-5, -1, 0, 2, 4, 5, 6, 10] assert merge_sort([3]) == [3] assert merge_sort([]) == [] assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] ``` Implement the `merge_sort` function to handle the given constraints and requirements, ensuring that it follows the divide-and-conquer strategy efficiently.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Sorts a list of integers in ascending order using the merge sort algorithm. if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left: List[int], right: List[int]) -> List[int]: Merges two sorted lists into a single sorted list. sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 # Append remaining elements of left while i < len(left): sorted_list.append(left[i]) i += 1 # Append remaining elements of right while j < len(right): sorted_list.append(right[j]) j += 1 return sorted_list"},{"question":"# Finding the Longest Path in a Directed Acyclic Graph (DAG) Context You are given a directed acyclic graph (DAG) represented as an adjacency list. Your task is to implement a function that finds the longest path from any vertex in the graph. The longest path is defined as the path that has the maximum number of edges. Function Signature ```python def find_longest_path(graph: dict[str, list[str]]) -> list[str]: Find the longest path in the given directed acyclic graph (DAG). Args: graph (dict[str, list[str]]): The adjacency list of the DAG where the keys are vertices and the values are lists of vertices that the key has directed edges to. Returns: list[str]: A list of vertices representing the longest path in the DAG. ``` Input Format * `graph`: Dictionary representing an adjacency list of the DAG. Output Format * A list of vertices representing the longest path in the DAG. Constraints * The graph contains between 1 and 1000 vertices. * The input graph is a directed acyclic graph. * The graph consists of only uppercase English letters (A-Z) as vertex labels. Example ```python graph = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"D\\"], \\"C\\": [\\"D\\", \\"E\\"], \\"D\\": [\\"E\\"], \\"E\\": [] } print(find_longest_path(graph)) # Output: [\'A\', \'C\', \'D\', \'E\'] ``` Notes * Ensure to clearly identify all the vertices in the longest path. * Topological sorting can be used to facilitate finding the longest path in a DAG. * If there are multiple longest paths, return any one of them.","solution":"def find_longest_path(graph): def topological_sort(vertex, visited, stack): visited[vertex] = True if vertex in graph: for neighbor in graph[vertex]: if not visited[neighbor]: topological_sort(neighbor, visited, stack) stack.append(vertex) def longest_path_from(source): distances = {vertex: float(\'-inf\') for vertex in graph} distances[source] = 0 topo_sort_stack = stack[::-1] for node in topo_sort_stack: if node in graph: for neighbor in graph[node]: if distances[neighbor] < distances[node] + 1: distances[neighbor] = distances[node] + 1 predecessors[neighbor] = node max_distance = float(\'-inf\') furthest_node = None for vertex in graph: if distances[vertex] > max_distance: max_distance = distances[vertex] furthest_node = vertex path = [] current_node = furthest_node while current_node is not None: path.append(current_node) current_node = predecessors.get(current_node, None) return path[::-1] visited = {vertex: False for vertex in graph} stack = [] for vertex in graph: if not visited[vertex]: topological_sort(vertex, visited, stack) longest_path = [] for vertex in graph: predecessors = {} current_path = longest_path_from(vertex) if len(current_path) > len(longest_path): longest_path = current_path return longest_path"},{"question":"# Question: Cyclic Rotation of List **Objective**: Write a function to rotate a given list by a specified number of positions. **Function Signature**: ```python def rotate_list(lst: List[int], k: int) -> List[int]: Given a list of integers `lst` and a positive integer `k`, return a new list that represents `lst` rotated to the right by `k` positions. ``` # Input - `lst` (List[int]): A list of integers (1 <= len(lst) <= 10^5). - `k` (int): The number of positions to rotate the list by (1 <= k <= 10^5). # Output - A new list of integers that has been rotated to the right by `k` positions. # Constraints - Aim for an efficient solution to handle large inputs. - Rotations should be cyclic; after the last element, the rotation continues from the first element. # Example ```python assert rotate_list([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert rotate_list([1, 2, 3], 1) == [3, 1, 2] assert rotate_list([10, 20, 30, 40], 3) == [20, 30, 40, 10] ``` **Notes**: - The elements of the list should retain their relative order after rotation. - Handle the cases efficiently where `k` is larger than the length of the list.","solution":"from typing import List def rotate_list(lst: List[int], k: int) -> List[int]: Given a list of integers `lst` and a positive integer `k`, return a new list that represents `lst` rotated to the right by `k` positions. n = len(lst) k = k % n # To handle cases where k is larger than the length of the list return lst[-k:] + lst[:-k]"},{"question":"You are required to implement an enhanced version of the `merge_sorted_lists` function. The new function should retain the original functionality but address additional requirements for efficiency and error handling. Specifically, implement the following enhancements: 1. **Error Handling**: - Raise an appropriate error if any of the lists contain non-integer values. - Handle cases where input lists are already partially merged or contain duplicate elements. 2. **Performance**: - Optimize the function to operate in O(n) time complexity, where n is the total number of elements across all input lists. - Utilize in-place merging techniques where possible to conserve memory. 3. **Data Integrity**: - Ensure that the final merged list maintains non-decreasing order without duplicates. - Provide an option to either include or exclude duplicates in the final output. Write the function `merge_sorted_lists_v2` with the following signature: ```python from typing import List, Union def merge_sorted_lists_v2(lists: List[List[int]], include_duplicates: bool = True) -> List[int]: # Your implementation here ``` # Input: - `lists` (list of list of int): A list of sorted lists to be merged. - `include_duplicates` (bool, optional): Flag to determine whether duplicates should be included in the merged list. Defaults to True. # Output: - Returns a single sorted list containing all elements from the input lists, maintaining the specified duplicate policy. # Examples: ```python # Example 1 result = merge_sorted_lists_v2([[1, 3, 5], [2, 4, 6]], include_duplicates=True) print(result) # Expected Output: [1, 2, 3, 4, 5, 6] # Example 2 result = merge_sorted_lists_v2([[1, 3, 3, 5], [2, 4, 6]], include_duplicates=False) print(result) # Expected Output: [1, 2, 3, 4, 5, 6] ``` # Constraints: - You may assume that each list within `lists` is already sorted. - Ensure the function handles large inputs efficiently. - The number of input lists and the total number of elements should be reasonable, e.g., up to 10^5 elements. By implementing this function, you should efficiently merge multiple sorted lists into one while addressing potential errors and maintaining flexibility in handling duplicates.","solution":"from typing import List def merge_sorted_lists_v2(lists: List[List[int]], include_duplicates: bool = True) -> List[int]: import heapq # Error handling for non-integer values in lists for lst in lists: if not all(isinstance(x, int) for x in lst): raise ValueError(\\"All elements in the lists must be integers.\\") # Merging all lists using a heap to maintain order merged_list = [] heap = [] # Initialize the heap for i, lst in enumerate(lists): if lst: heapq.heappush(heap, (lst[0], i, 0)) # Cluster merge operation prev = None while heap: val, list_index, element_index = heapq.heappop(heap) if include_duplicates or val != prev: merged_list.append(val) prev = val # If there are more elements in the current list, push the next element to the heap. if element_index + 1 < len(lists[list_index]): next_tuple = (lists[list_index][element_index + 1], list_index, element_index + 1) heapq.heappush(heap, next_tuple) return merged_list"},{"question":"# Coding Assessment Question Context You are tasked to create an optimized file processing function that reads a large text file and identifies the longest word that is a palindrome. Requirements Develop the `find_longest_palindrome` function to: 1. Read and process the content of a text file line by line to handle large files efficiently. 2. Identify the longest word in the file that is a palindrome. 3. If there are multiple words of the same longest length, return the first one encountered. 4. Handle edge cases where the file might be empty or contain no palindromes gracefully. Constraints * Assume words are delimited by whitespace and/or punctuation marks. * The file path provided will be valid. * Words can contain alphabetic characters only. Input & Output # Input * `file_path`: str — The path to the text file. # Output * Returns a string — The longest word that is a palindrome. If no palindromes are found, return an empty string. Example Assuming `example.txt` contains: ``` Madam Arora teaches malayalam ``` ```python >>> longest_palindrome = find_longest_palindrome(\'example.txt\') >>> print(longest_palindrome) malayalam ``` Function Signature ```python def find_longest_palindrome( file_path: str ) -> str: pass ```","solution":"import re def is_palindrome(word): return word == word[::-1] def find_longest_palindrome(file_path): longest_palindrome = \\"\\" with open(file_path, \'r\') as file: for line in file: words = re.findall(r\'bw+b\', line.lower()) for word in words: if is_palindrome(word) and len(word) > len(longest_palindrome): longest_palindrome = word return longest_palindrome"},{"question":"# Problem Statement: You are developing a navigation system that finds the shortest path in a grid-based city map with obstacles. Given a grid where each cell represents a city block, write a function that calculates the length of the shortest path from the top-left corner to the bottom-right corner. You can only move up, down, left, or right, and you cannot pass through obstacles. Write a function `shortest_path` that finds the shortest path in a 2D grid. Function Signature ```python def shortest_path(grid: List[List[int]]) -> int: ``` Input * `grid` (List[List[int]]): A 2D grid representing the map, where each cell is either `0` (empty block) or `1` (obstacle). (1 <= len(grid), len(grid[0]) <= 100) Output * `path_length` (int): The length of the shortest path from the top-left to the bottom-right corner, or `-1` if no such path exists. Constraints * The grid is guaranteed to have at least one row and one column. * The top-left and bottom-right corners of the grid will always be empty blocks (`0`). Example ```python assert shortest_path([[0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]) == 8 assert shortest_path([[0, 1, 1], [1, 1, 0], [1, 0, 0]]) == -1 assert shortest_path([[0]]) == 0 ``` # Evaluation Criteria * **Correctness**: The function should correctly find the shortest path or determine if no path exists for various test cases. * **Performance**: The function should complete in a reasonable time frame for inputs up to the specified constraints. * **Code Quality**: Code should be well-documented, readable, and follow best practices. # Hints 1. Use a breadth-first search (BFS) algorithm to explore the shortest path in the grid. 2. Keep track of visited cells to avoid infinite loops. 3. Consider edge cases such as grids with all obstacles or single-element grids.","solution":"from typing import List from collections import deque def shortest_path(grid: List[List[int]]) -> int: if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() if r == rows - 1 and c == cols - 1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and grid[nr][nc] == 0: queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) return -1"},{"question":"# Question: Implement and Test Enhanced File Parsing System Context: You are tasked with developing a software component that reads and processes large log files. The existing solution processes one file at a time, which makes it slow, especially when dealing with multiple log files. Requirements: 1. **Batch File Processing**: Implement functionality to read and process multiple log files concurrently. 2. **Concurrency**: Use multiprocessing or asynchronous techniques to handle multiple files efficiently. 3. **Enhanced Reporting**: Generate a summary report that includes the number of lines processed for each file and any errors encountered during the process. Main Function Specification: ```python def process_log_files(file_paths: List[str]) -> Dict[str, Union[int, str]]: Given a list of file paths to log files, return a summary report. Parameters: file_paths (List[str]): List of log file paths to process. Returns: Dict[str, Union[int, str]]: A dictionary where the keys are the file paths and the values are the number of lines processed or an error message. pass ``` * **Input**: A list of file paths to the log files. * **Output**: A dictionary with file paths as keys and the number of lines processed or an error message as values. Constraints: - The function should handle up to 50 log files in one call efficiently. - Handle any file reading errors gracefully and return corresponding error messages for files that failed to process. - Each log file should be processed concurrently to minimize total execution time. * **Example**: ```python input_files = [\\"/path/to/log1.txt\\", \\"/path/to/log2.txt\\"] expected_output = { \\"/path/to/log1.txt\\": 1500, \\"/path/to/log2.txt\\": 2000 } assert process_log_files(input_files) == expected_output ``` Performance Requirements: - Ensure the function can process the maximum number of log files within a reasonable time limit (e.g., < 10 seconds for 50 files with an average size of 1MB each). Note: Provide a well-documented and tested solution showcasing your understanding of concurrency, file handling, and error management in Python.","solution":"import os from typing import List, Dict, Union from concurrent.futures import ThreadPoolExecutor, as_completed def count_lines_in_file(file_path: str) -> Union[int, str]: Helper function to count the number of lines in a file. Handles file read errors and returns an error message if the file cannot be read. Parameters: file_path (str): The path of the file to process. Returns: Union[int, str]: The number of lines in the file or an error message. try: with open(file_path, \'r\') as file: return sum(1 for _ in file) except Exception as e: return f\\"Error: {str(e)}\\" def process_log_files(file_paths: List[str]) -> Dict[str, Union[int, str]]: Given a list of file paths to log files, return a summary report. Parameters: file_paths (List[str]): List of log file paths to process. Returns: Dict[str, Union[int, str]]: A dictionary where the keys are the file paths and the values are the number of lines processed or an error message. result = {} with ThreadPoolExecutor() as executor: future_to_file = {executor.submit(count_lines_in_file, file_path): file_path for file_path in file_paths} for future in as_completed(future_to_file): file_path = future_to_file[future] result[file_path] = future.result() return result"},{"question":"# Coding Assessment Question: You are given a list of integers where you need to return a new list containing only the even numbers from the original list. Your task is to implement a function `filter_evens` that performs this filtering. # Function Signature: ```python def filter_evens(numbers: list[int]) -> list[int]: pass ``` # Input: * A list of integers `numbers`. * Constraints: The length of the list numbers is 0 <= len(numbers) <= 10^5. # Output: * Returns a new list containing only the even integers from `numbers`. # Examples: ```python >>> filter_evens([1, 2, 3, 4, 5, 6]) [2, 4, 6] >>> filter_evens([10, 21, 32, 43, 54]) [10, 32, 54] >>> filter_evens([1, 3, 5, 7]) [] >>> filter_evens([]) [] ``` # Performance Requirements: * The solution must have a time complexity of O(n) and a space complexity of O(n), where n is the length of the input list.","solution":"def filter_evens(numbers: list[int]) -> list[int]: Returns a list containing only the even numbers from the original list. return [num for num in numbers if num % 2 == 0]"},{"question":"# Question You are developing an online retail platform that features an interactive shopping cart system. As a part of this initiative, you need to create functionality that allows users to generate and apply discount codes. Write a function `apply_discount(cart: List[Tuple[str, float]], discount_code: str) -> float` that calculates the final price after discount for the items in the cart. The `cart` is a list of tuples where each tuple consists of a product name (string) and its price (float). The `discount_code` is a string representing the discount to be applied. The discount codes are defined as follows: - `SAVE10`: Reduces the total price by 10%. - `SAVE20`: Reduces the total price by 20%. - `SAVE30`: Reduces the total price by 30%. - `NONE`: No discount applied. If an invalid discount code is provided, the function should raise a `ValueError` with an appropriate error message. Example Usage: ```python >>> apply_discount([(\\"item1\\", 100), (\\"item2\\", 200)], \\"SAVE10\\") 270.0 >>> apply_discount([(\\"item1\\", 50), (\\"item2\\", 50), (\\"item3\\", 100)], \\"SAVE20\\") 160.0 >>> apply_discount([(\\"item1\\", 15), (\\"item2\\", 25)], \\"NONE\\") 40.0 >>> apply_discount([(\\"item1\\", 80)], \\"SAVE30\\") 56.0 >>> apply_discount([(\\"item1\\", 80)], \\"INVALID\\") Traceback (most recent call last): ... ValueError: Invalid discount code: \'INVALID\'. Supported values are: SAVE10, SAVE20, SAVE30, NONE ``` Constraints: - Each item price in `cart` will be a non-negative float. - The `discount_code` will be a case-sensitive string. Use the following discount percentages: ```python DISCOUNTS = { \\"SAVE10\\": 0.10, \\"SAVE20\\": 0.20, \\"SAVE30\\": 0.30, \\"NONE\\": 0.00, } ``` # Instructions: 1. Refer to the `DISCOUNTS` dictionary to implement the discount logic. 2. Ensure to handle invalid discount codes by raising an appropriate error. 3. Utilize the provided example usage sections for guidance on expected output.","solution":"from typing import List, Tuple DISCOUNTS = { \\"SAVE10\\": 0.10, \\"SAVE20\\": 0.20, \\"SAVE30\\": 0.30, \\"NONE\\": 0.00, } def apply_discount(cart: List[Tuple[str, float]], discount_code: str) -> float: Calculate the final price after applying a discount code to the shopping cart. Args: cart (List[Tuple[str, float]]): A list of tuples where each tuple consists of a product name and its price. discount_code (str): A string representing the discount to be applied. Returns: float: The final price after applying the discount. Raises: ValueError: If the discount code is invalid. if discount_code not in DISCOUNTS: raise ValueError(f\\"Invalid discount code: \'{discount_code}\'. Supported values are: SAVE10, SAVE20, SAVE30, NONE\\") total_price = sum(price for _, price in cart) discount = DISCOUNTS[discount_code] final_price = total_price * (1 - discount) return final_price"},{"question":"# Problem Statement Given a list of integers, your task is to determine if the integers can form a sequence such that each number is exactly 1 greater than the previous number. Write a Python function to check this property. Your task is to implement the function `is_consecutive_sequence(nums: list[int]) -> bool`, where `nums` is a list of integers. # Input - `nums`: A list of integers. # Output - A boolean value: `True` if the integers in the list can form a consecutive sequence, and `False` otherwise. # Constraints - The list may contain duplicates. - The list can be empty, in which case the function should return `True`. # Performance Requirements - The function should have a time complexity of O(n), where n is the number of integers in the list. # Example ```python >>> is_consecutive_sequence([3, 2, 4, 6, 5]) True >>> is_consecutive_sequence([1, 2, 3, 4, 6, 7]) False >>> is_consecutive_sequence([]) True >>> is_consecutive_sequence([1, 2, 2, 3, 4]) True ``` # Implementation Implement the function `is_consecutive_sequence` as described.","solution":"def is_consecutive_sequence(nums: list[int]) -> bool: Determines if the integers in the list can form a sequence such that each number is exactly 1 greater than the previous number. if not nums: return True nums = list(set(nums)) nums.sort() for i in range(1, len(nums)): if nums[i] - nums[i - 1] != 1: return False return True"},{"question":"# Sum of Squares of Even Numbers You are tasked with writing a function that calculates the sum of squares of all even numbers within a given range. The function should take two integers representing the start and end of the range and return the sum of squares of all even numbers within that range, inclusive. If the start number is greater than the end number, the function should return `0`. Implement the function `sum_of_squares_even(start: int, end: int) -> int` that: * Takes two integers as inputs, `start` and `end`. * Returns the sum of squares of all even numbers between and including `start` and `end`. * Returns `0` if the range is invalid (i.e., `start` is greater than `end`). Function Signature ```python def sum_of_squares_even(start: int, end: int) -> int: pass ``` # Input * `start`: An integer representing the start of the range. * `end`: An integer representing the end of the range. # Output * Returns an integer which is the sum of squares of all even numbers in the range [start, end]. * Returns `0` if `start` is greater than `end`. # Examples Here are some sample test cases for your implementation: ```python assert sum_of_squares_even(1, 10) == 220 # 2^2 + 4^2 + 6^2 + 8^2 + 10^2 = 220 assert sum_of_squares_even(3, 7) == 52 # 4^2 + 6^2 = 52 assert sum_of_squares_even(10, 10) == 100 # 10^2 = 100 assert sum_of_squares_even(6, 2) == 0 # Invalid range, returns 0 assert sum_of_squares_even(1, 1) == 0 # No even number in range, returns 0 assert sum_of_squares_even(2, 2) == 4 # 2^2 = 4 ```","solution":"def sum_of_squares_even(start: int, end: int) -> int: Calculate the sum of squares of all even numbers within the given range [start, end]. Parameters: start (int): The start of the range. end (int): The end of the range. Returns: int: Sum of squares of all even numbers in the range, or 0 if the range is invalid. if start > end: return 0 sum_squares = 0 for num in range(start, end + 1): if num % 2 == 0: sum_squares += num ** 2 return sum_squares"},{"question":"# Coding Assessment Question **Problem Statement**: In a given non-negative integer array, you can perform the following operation any number of times: pick any two elements of the array and subtract the smaller element from the larger element. Your goal is to minimize the maximum element in the array by performing the above operation multiple times. Write a function that calculates the minimum possible value of the maximum element in the array after any number of operations. **Function Signature**: ```python def minimize_array(nums: list) -> int: pass ``` **Input**: - `nums` (list of int): A list of non-negative integers. **Output**: - (int): The minimum possible value of the maximum element in the array. **Constraints**: - 1 <= len(nums) <= 1000 - 0 <= nums[i] <= 10^6 **Examples**: ```python >>> minimize_array([5, 3, 2]) 2 >>> minimize_array([10, 7, 5]) 1 >>> minimize_array([8, 4, 2, 2]) 2 ``` **Guidelines**: - Implement the helper function `gcd(a: int, b: int) -> int` to find the greatest common divisor (GCD) of two numbers. - Utilize the concept that the GCD of the entire array will determine the smallest possible maximum element. - Ensure your implementation is efficient within the provided constraints and handles edge cases robustly. - Test your function with various input arrays to ensure correctness.","solution":"from math import gcd from functools import reduce def minimize_array(nums: list) -> int: Returns the minimum possible value of the maximum element in the array after any number of allowed operations. :param nums: List of non-negative integers. :return: Integer representing the minimum possible maximum element. def find_gcd_of_array(arr): return reduce(gcd, arr) if not nums: return 0 return find_gcd_of_array(nums)"},{"question":"# Reverse Words in a String You are developing a text processing feature that helps users manipulate sentences. A common operation is reversing the order of words in a given string. Write the `reverse_words` function that takes a single string parameter `sentence` and returns a new string where the words appear in reverse order. The words are defined as sequences of non-space characters. The function should handle multiple spaces gracefully and ensure that the reversed sentence has words separated by a single space. # Implementation Details: - **Input**: - `sentence` (string): A string containing the sentence to be reversed. - **Output**: - `string`: A new string with the words in reverse order. - **Constraints**: - The string can contain letters, numbers, and punctuation. - Multiple spaces should be trimmed in the final output. # Examples ```python >>> reverse_words(\\"The quick brown fox\\") \\"fox brown quick The\\" >>> reverse_words(\\" Hello world! \\") \\"world! Hello\\" >>> reverse_words(\\"Coding is fun\\") \\"fun is Coding\\" ``` # Implementation Hints 1. Split the input string by spaces to get the list of words. 2. Remove any leading or trailing spaces or empty elements from the list. 3. Reverse the list of words. 4. Join the reversed list of words with a single space delimiter to form the final string.","solution":"def reverse_words(sentence): Reverses the order of words in a given sentence. Args: sentence (str): A string containing the sentence to be reversed. Returns: str: A new string with the words in reverse order. # Split the sentence into words, stripping out extra spaces words = sentence.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words into a new sentence with single spaces return \' \'.join(reversed_words)"},{"question":"# Coding Assessment Question **Context:** Data streams are commonplace in many real-world applications, and efficiently processing a continuous flow of data entries is a valuable skill. One of the fundamental tasks in handling data streams is identifying unique elements in the stream. **Problem Statement:** Write a function `first_unique_char(s: str) -> str` that takes in a string `s` which represents a stream of characters (only lowercase alphabets) and returns the first unique character in the stream. If there is no unique character, return an empty string. **Input:** - A string `s` where `1 ≤ len(s) ≤ 10^5`. **Output:** - A single character representing the first unique character, or an empty string if none exists. **Constraints:** - The input string will consist only of lowercase alphabets. - The function should run efficiently to handle a large number of characters in `s`. # Function Signature ```python def first_unique_char(s: str) -> str: pass ``` # Examples ```python # Example 1: print(first_unique_char(\\"leetcode\\")) # Output: \\"l\\" # Example 2: print(first_unique_char(\\"loveleetcode\\")) # Output: \\"v\\" # Example 3: print(first_unique_char(\\"aabb\\")) # Output: \\"\\" ```","solution":"def first_unique_char(s: str) -> str: Returns the first unique character in the given string. If no unique character exists, returns an empty string. # Create a dictionary to store frequency of each character char_frequency = {} for char in s: if char in char_frequency: char_frequency[char] += 1 else: char_frequency[char] = 1 # Find the first character with a frequency of 1 for char in s: if char_frequency[char] == 1: return char return \\"\\""},{"question":"# Coding Assessment Question **Context:** Binary trees are a fundamental structure in computer science, often used for organizing data in a way that enables efficient insert, delete, and search operations. One common task when working with binary trees is determining whether they are balanced. A binary tree is balanced if the depth of the two subtrees of every node never differ by more than 1. **Task:** Write a function named `is_balanced` in Python to determine if a given binary tree is height-balanced. A binary tree is height-balanced if, for every node in the tree, the height difference between the left and right subtree is not more than one. **Function Signature:** ```python def is_balanced(root: TreeNode) -> bool: ``` **Input:** - `root`: A `TreeNode` object representing the root of the binary tree. **Output:** - A boolean value `True` if the tree is balanced; otherwise, `False`. **TreeNode Definition:** ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` **Constraints:** - The number of nodes in the tree is in the range [0, 5000]. - The values of the nodes are integers within the range [-10^4, 10^4]. **Example:** ```python # Example 1 root1 = TreeNode(1) root1.left = TreeNode(2) root1.right = TreeNode(3) >>> is_balanced(root1) True # Example 2 root2 = TreeNode(1) root2.left = TreeNode(2) root2.right = TreeNode(3) root2.left.left = TreeNode(4) root2.left.left.left = TreeNode(5) >>> is_balanced(root2) False # Example 3 root3 = None >>> is_balanced(root3) True ``` **Note:** - For an empty tree, the function should return `True`. - You may define helper functions as needed to keep the main function concise. - Ensure your solution is efficient and can handle the maximum input size within a reasonable time frame.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: def check_height(node: TreeNode) -> int: if not node: return 0 left_height = check_height(node.left) right_height = check_height(node.right) if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1: return -1 return max(left_height, right_height) + 1 return check_height(root) != -1"},{"question":"# Coding Assessment Question **Scenario**: You are tasked with developing a text processing tool for an online eBook platform. The goal is to parse the given novel text, identify the most frequently occurring words, and produce a summary report. Specifically, you need to find the top N most frequent words while excluding common stopwords. **Objective**: Modify the function `get_top_frequent_words` to: 1. Exclude a list of common stopwords from the word count. 2. Return the top N most frequent words along with their counts. **Function Signature**: ```python def get_top_frequent_words(novel_text: str, stopwords: list[str], top_n: int) -> list[tuple[str, int]]: Identify the top N most frequent words in a given novel text excluding common stopwords. Args: - novel_text (str): The text of the novel to be processed. - stopwords (list[str]): A list of common stopwords to exclude from the count. - top_n (int): The number of top frequent words to return. Returns: - list[tuple[str, int]]: A list of tuples, each containing a word and its count. ``` **Constraints**: - **Input**: - `novel_text`: A non-empty string representing the full text of a novel. - `stopwords`: A non-empty list of strings representing common stopwords to exclude. - `top_n`: A positive integer indicating the number of top frequent words to return. - **Output**: - A list of tuples, each tuple containing a string (the word) and an integer (its count). The list should be sorted in descending order of word frequency. **Example**: ```python novel_text = \\"It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness.\\" stopwords = [\\"was\\", \\"the\\", \\"of\\", \\"it\\"] top_n = 3 result = get_top_frequent_words(novel_text, stopwords, top_n) Expected Output (example): [(\\"times\\", 2), (\\"best\\", 1), (\\"worst\\", 1)] ``` **Guidelines for Implementation**: 1. **Text Processing**: Efficiently process the text to count word frequencies while excluding stopwords. 2. **Handling Punctuation**: Consider punctuation marks and ensure words are properly tokenized. 3. **Case Sensitivity**: Treat words in a case-insensitive manner (e.g., \\"the\\" and \\"The\\" should be considered the same). 4. **Sorting**: Ensure that the returned list is sorted by word frequency in descending order. 5. **Edge Cases**: Consider scenarios with no words excluding stopwords or when `top_n` is greater than the number of unique words.","solution":"import re from collections import Counter from typing import List, Tuple def get_top_frequent_words(novel_text: str, stopwords: List[str], top_n: int) -> List[Tuple[str, int]]: Identify the top N most frequent words in a given novel text excluding common stopwords. Args: - novel_text (str): The text of the novel to be processed. - stopwords (list[str]): A list of common stopwords to exclude from the count. - top_n (int): The number of top frequent words to return. Returns: - list[tuple[str, int]]: A list of tuples, each containing a word and its count. # Convert to lowercase novel_text = novel_text.lower() # Remove punctuation and tokenize the text into words words = re.findall(r\'bw+b\', novel_text) # Filter out stopwords filtered_words = [word for word in words if word not in stopwords] # Count the frequency of each word word_counts = Counter(filtered_words) # Get the top N most common words top_frequent_words = word_counts.most_common(top_n) return top_frequent_words"},{"question":"# Problem Statement You are tasked with implementing two functions that will help encode and decode strings using the Run-Length Encoding (RLE) algorithm. Run-Length Encoding is a simple form of lossless data compression where consecutive data elements are replaced by just one data value and a count. Function Definitions 1. **Encode Function (`run_length_encode`)**: - **Input**: A string `s` containing only uppercase alphabets. - **Output**: A string representing the run-length encoded version of `s`. 2. **Decode Function (`run_length_decode`)**: - **Input**: A string `encoded_s` representing the run-length encoded data. - **Output**: The original string before encoding. Example: ```python def run_length_encode(s: str) -> str: pass # Your implementation here. def run_length_decode(encoded_s: str) -> str: pass # Your implementation here. ``` Requirements - Both functions should raise a `ValueError` if the input string contains any character other than uppercase alphabets (for the `run_length_encode` function) or if the encoded string format is invalid (for the `run_length_decode` function). - Input constraints: The length of the input string for encoding will be between 1 and (10^5). The length of the encoded string for decoding will also be within the same range. Example Scenarios - **Run-Length Encode**: - `run_length_encode(\\"AAABBCCDDD\\")` should return `\\"A3B2C2D3\\"`. - `run_length_encode(\\"WWWWWWWWWWWW\\")` should return `\\"W12\\"`. - **Run-Length Decode**: - `run_length_decode(\\"A3B2C2D3\\")` should return `\\"AAABBCCDDD\\"`. - `run_length_decode(\\"W12\\")` should return `\\"WWWWWWWWWWWW\\"`. Constraints & Performance - Your solution should handle large inputs efficiently. - Ensure that the encoding and decoding processes are correct and do not lose any information. - Consider edge cases such as the presence of single characters or maximum repetition counts.","solution":"def run_length_encode(s: str) -> str: if not s.isalpha() or not s.isupper(): raise ValueError(\\"Input string must contain only uppercase alphabets\\") encoded_str = [] i = 0 while i < len(s): count = 1 while i + 1 < len(s) and s[i] == s[i + 1]: i += 1 count += 1 encoded_str.append(s[i]) encoded_str.append(str(count)) i += 1 return \'\'.join(encoded_str) def run_length_decode(encoded_s: str) -> str: if not encoded_s or not encoded_s[0].isalpha() or not encoded_s[0].isupper(): raise ValueError(\\"Encoded string must start with an uppercase alphabet character\\") decoded_str = [] i = 0 while i < len(encoded_s): if not encoded_s[i].isalpha() or not encoded_s[i].isupper(): raise ValueError(\\"Encoded string must contain only uppercase alphabets and digits\\") char = encoded_s[i] i += 1 count_str = [] while i < len(encoded_s) and encoded_s[i].isdigit(): count_str.append(encoded_s[i]) i += 1 if not count_str: raise ValueError(\\"Encoded string format is invalid\\") count = int(\'\'.join(count_str)) decoded_str.append(char * count) return \'\'.join(decoded_str)"},{"question":"# Coding Assessment Question Question: You are tasked with finding the first unique character in a given string. A unique character is a character that appears exactly once in the string. If there are no unique characters, the function should return an empty string. Write a function `find_first_unique_character(s: str) -> str` that returns the first unique character in the given string `s`. If no unique character exists, return an empty string. Your function should handle both uppercase and lowercase letters and include error handling for invalid inputs. Function Signature: ```python def find_first_unique_character(s: str) -> str: pass ``` Input: - `s` (str): A string containing the characters to be examined. If `s` is not a string, your function should raise a `TypeError` with the message \\"Invalid input\\". Output: - `str`: A single character string representing the first unique character in `s`. If no unique character exists, return an empty string. Constraints: - The input string can have a maximum length of 10^5 characters. - The input string can contain both uppercase and lowercase English letters. Example: ```python >>> find_first_unique_character(\\"abcdabc\\") \'d\' >>> find_first_unique_character(\\"aabbcc\\") \'\' >>> find_first_unique_character(\\"a\\") \'a\' >>> find_first_unique_character(123) Traceback (most recent call last): ... TypeError: Invalid input >>> find_first_unique_character(\\"\\") \'\' ``` # Additional Information: 1. You may find the use of a dictionary helpful to count character occurrences efficiently. 2. Ensure to perform input validation as per the given constraints.","solution":"def find_first_unique_character(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"Invalid input\\") # Dictionary to count character occurrences char_count = {} # Counting each character in the string for char in s: char_count[char] = char_count.get(char, 0) + 1 # Finding the first character with a count of 1 for char in s: if char_count[char] == 1: return char # If no unique character found, return empty string return \\"\\""},{"question":"# Problem Statement You are tasked with implementing a simplified version of the Merge Sort algorithm, suitable for an introductory level coding assessment. Your goal is to sort a list of integers using the merge sort technique while adhering to performance constraints and ensuring proper error handling. Implementation Details Implement the function `simple_merge_sort(sequence: list) -> list` that takes a list of integers and returns a sorted list of those integers. Constraints 1. The input list contains only integers. 2. Raise a `TypeError` if any element is not an integer. 3. Aim for an optimal merge sort operation. 4. Avoid unnecessary space usage. Input and Output Formats *Input*: * `sequence`: A list of integers. *Output*: * A sorted list of integers in ascending order. Example ```python >>> simple_merge_sort([34, 7, 23, 32, 5, 62]) [5, 7, 23, 32, 34, 62] >>> simple_merge_sort([-3, 0, 2, -1, -4, 3, 1]) [-4, -3, -1, 0, 1, 2, 3] >>> simple_merge_sort([3, 1, 2]) [1, 2, 3] >>> simple_merge_sort([10]) [10] >>> simple_merge_sort([3, \'a\', 2]) Traceback (most recent call last): ... TypeError: Sequence must be a list of integers ``` Performance Requirements 1. Time Complexity should be O(n log n), where n is the number of elements in the list. 2. Maintain an optimal Space Complexity, especially considering the nature of merge sorting which typically requires additional space for merging.","solution":"def simple_merge_sort(sequence): Function to sort a list of integers using merge sort technique. Args: sequence (list): The list of integers to be sorted. Returns: list: The sorted list of integers. Raises: TypeError: If any element in sequence is not an integer. if not all(isinstance(x, int) for x in sequence): raise TypeError(\'Sequence must be a list of integers\') if len(sequence) <= 1: return sequence def merge(left, right): result = [] i = j = 0 # Merge the two halves while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 # Append the remaining elements result.extend(left[i:]) result.extend(right[j:]) return result def merge_sort(seq): if len(seq) <= 1: return seq mid = len(seq) // 2 left = merge_sort(seq[:mid]) right = merge_sort(seq[mid:]) return merge(left, right) return merge_sort(sequence)"},{"question":"# Problem Statement You are required to write a function `process_log_file` that processes a server log file and outputs a summary of various statistics. The log file contains HTTP request logs in the common log format. Your task is to: 1. Count the number of requests received per distinct client IP. 2. Identify the most frequently requested URL. 3. Calculate the total size of all responses in bytes. 4. Create a summary of requests made per HTTP status code. # Function Signature ```python def process_log_file(log_file_path: str) -> dict: Process a server log file and output a summary of various statistics. Parameters: - log_file_path (str): The file path of the server log file. Returns: - dict: A dictionary containing the summary statistics. ``` # Input/Output Examples Input (log file content) ``` 127.0.0.1 - - [10/Oct/2023:13:55:36 -0700] \\"GET /index.html HTTP/1.0\\" 200 1234 192.168.0.1 - - [10/Oct/2023:13:55:50 -0700] \\"POST /submit HTTP/1.1\\" 404 567 127.0.0.1 - - [10/Oct/2023:13:56:01 -0700] \\"GET /index.html HTTP/1.0\\" 200 1234 ``` ```python process_log_file(\\"logs/server.log\\") ``` Output ```python { \\"requests_per_ip\\": { \\"127.0.0.1\\": 2, \\"192.168.0.1\\": 1 }, \\"most_frequent_url\\": \\"/index.html\\", \\"total_response_size\\": 3035, \\"status_code_summary\\": { \\"200\\": 2, \\"404\\": 1 } } ``` # Constraints and Requirements 1. Assume the log files adhere to the common log format closely. 2. The function should handle large files efficiently, managing memory usage appropriately. 3. Ensure the function can handle missing fields gracefully, skipping improperly formatted lines. 4. If multiple URLs have the same highest request count, return any one of them. 5. The summary statistics should be returned as a dictionary with the specified keys. # Performance Requirements 1. The function should be able to process logs with potentially millions of entries efficiently. 2. Use efficient data structures to manage counting and tracking for large datasets. # Context This function can be used for server administration tasks, monitoring and analyzing traffic, and extracting meaningful insights from server logs for performance optimization and troubleshooting.","solution":"import re from collections import defaultdict, Counter def process_log_file(log_file_path: str) -> dict: log_pattern = re.compile(r\'(d+.d+.d+.d+) - - [.*] \\"w+ (/S+)? HTTP/S+\\" (d+) (d+)\') requests_per_ip = defaultdict(int) url_counter = Counter() total_response_size = 0 status_code_summary = defaultdict(int) with open(log_file_path, \'r\') as file: for line in file: match = log_pattern.match(line) if match: ip, url, status_code, response_size = match.groups() requests_per_ip[ip] += 1 url_counter[url] += 1 total_response_size += int(response_size) status_code_summary[status_code] += 1 most_frequent_url = url_counter.most_common(1)[0][0] if url_counter else None return { \\"requests_per_ip\\": dict(requests_per_ip), \\"most_frequent_url\\": most_frequent_url, \\"total_response_size\\": total_response_size, \\"status_code_summary\\": dict(status_code_summary) }"},{"question":"# Pattern Matching Challenge Scenario In computer science, string pattern matching is a crucial process where we search for occurrences of a substring (pattern) within a main string (text). Your task is to implement a function that finds all starting indices of the pattern in the text using the Knuth-Morris-Pratt (KMP) algorithm. Function Signature ```python def kmp_search(pattern: str, text: str) -> list: Given a pattern and a text, returns a list of starting indices where the pattern is found in the text using the KMP algorithm. Raises a ValueError if the pattern is empty. Parameters: pattern (str): The substring to search for within the text. text (str): The main string in which to search for the pattern. Returns: list: A list of integers indicating the starting positions where the pattern is found in the text. Example: >>> kmp_search(\\"abc\\", \\"ababcabcab\\") [2, 5] Constraints: * The pattern and the text consist of lowercase English letters only. * Ensure your solution is efficient and handles edge cases such as empty text or no matches found. ``` Requirements 1. The function should validate that the pattern is not empty. Raise a `ValueError` with the message \\"Pattern must not be empty\\" if this condition is not met. 2. The implementation should follow the KMP algorithm to achieve an efficient search. 3. The solution must work efficiently even for large texts with lengths up to (10^5) and pattern lengths up to (10^4). Constraints * You must not use any built-in string search functions. * The function should handle and return correct results for edge cases like empty text, text shorter than the pattern, or no occurrences of the pattern in the text. * The solution should gracefully handle edge cases such as an empty text string.","solution":"def kmp_search(pattern: str, text: str) -> list: Given a pattern and a text, returns a list of starting indices where the pattern is found in the text using the KMP algorithm. Raises a ValueError if the pattern is empty. Parameters: pattern (str): The substring to search for within the text. text (str): The main string in which to search for the pattern. Returns: list: A list of integers indicating the starting positions where the pattern is found in the text. if not pattern: raise ValueError(\\"Pattern must not be empty\\") def compute_lps_array(pattern): Compute the Longest Prefix Suffix (LPS) array used in KMP algorithm. lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = compute_lps_array(pattern) result = [] i = 0 # index for text j = 0 # index for pattern while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"# Unique String Permutations You are contributing to a module that generates unique permutations for a given string. This can be useful for a variety of applications, such as solving puzzles, creating test cases, or organizing data in a unique way. Objective: Implement a function that generates all unique permutations of a given string. The function should return a list of permutations in lexicographic order. Requirements: 1. Implement the function `unique_permutations` that takes a single string and returns a list of its unique permutations. 2. Ensure that the function handles strings with repeated characters efficiently. 3. The function should return the permutations in lexicographic order. 4. Include comprehensive test cases showing the functionality, especially focusing on scenarios with repeated characters and edge cases. Input: * A single string `str`. Output: * A list of strings representing all unique permutations in lexicographic order. Constraints: * `0 <= len(str) <= 8` * The string contains only ASCII characters Example: ```python print(unique_permutations(\\"abc\\")) # Output: [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] print(unique_permutations(\\"aab\\")) # Output: [\'aab\', \'aba\', \'baa\'] print(unique_permutations(\\"a\\")) # Output: [\'a\'] print(unique_permutations(\\"abca\\")) # Output: [\'aabc\', \'aacb\', \'abac\', \'abca\', \'acab\', \'acba\', \'baac\', \'baca\', \'bcaa\', \'caab\', \'caba\', \'cbaa\'] ``` Note: * Your implementation should avoid generating duplicate permutations. * Ordering should be achieved by considering lexicographical sorting of the permutations. * Provide clear comments explaining key parts of your solution. * Consider using an efficient algorithm to deal with permutation generation, such as backtracking with set-based uniqueness checks.","solution":"from itertools import permutations def unique_permutations(s): Returns all unique permutations of the input string in lexicographic order. # Use a set to avoid generating duplicate permutations perm_set = set(permutations(s)) # Convert the set to a sorted list of strings sorted_permutations = sorted([\'\'.join(p) for p in perm_set]) return sorted_permutations"},{"question":"# Frequency of Letters Context You have been asked to develop a system to analyze the frequency of each letter in a string. This system will be used to determine the most common letters in strings taken from various texts. Your solution should handle upper and lower cases sensitively and work efficiently for large inputs. Task Implement a function `frequency_analysis(input_string: str) -> dict[str, int]` that takes an input string and returns a dictionary with the frequency counts of each letter. The function should treat lowercase and uppercase letters as distinct characters and only count alphabetical letters (ignoring spaces, punctuation, and digits). Input * `input_string`: The text to analyze, as a string. Output * A dictionary where the keys are the alphabetical characters from the string and the values are their corresponding frequency counts. Constraints * `0 <= len(input_string) <= 10^5` * The input can include any character, but only alphabetical letters should be considered for the frequency count. Function Signature ```python def frequency_analysis(input_string: str) -> dict[str, int]: pass ``` Example Scenarios 1. Basic frequency analysis: * Input: `\\"Hello World!\\"` * Output: `{\\"H\\": 1, \\"e\\": 1, \\"l\\": 3, \\"o\\": 2, \\"W\\": 1, \\"r\\": 1, \\"d\\": 1}` 2. Mixed case and non-alphabetic characters: * Input: `\\"Goodbye, Earth! 123\\"` * Output: `{\\"G\\": 1, \\"o\\": 2, \\"d\\": 1, \\"b\\": 1, \\"y\\": 1, \\"e\\": 1, \\"E\\": 1, \\"a\\": 1, \\"r\\": 1, \\"t\\": 1, \\"h\\": 1}` Ensure your solution is efficient and handles large inputs smoothly. The function should be tested against edge cases and include minimal unnecessary computations.","solution":"def frequency_analysis(input_string: str) -> dict[str, int]: Analyzes the frequency of each letter in the input string. Args: input_string (str): The text to analyze. Returns: dict[str, int]: A dictionary with the frequency counts of each letter. frequency = {} for char in input_string: if char.isalpha(): # Only consider alphabetical characters. if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"# Problem Statement Implement a program to simulate the card game War. The program needs to shuffle and deal the cards, simulate the rounds of play, and determine the winner. # Requirements 1. **Class Definition:** `WarGame` 2. **Methods:** - `__init__(self) -> None`: Initializes a new game. - `shuffle_deck(self) -> None`: Shuffles the deck of cards. - `deal_cards(self) -> None`: Deals the shuffled deck to two players. - `play_round(self) -> str`: Plays a single round and returns the result of that round (\'Player 1 wins\', \'Player 2 wins\', or \'War\'). - `determine_winner(self) -> str`: Plays until one player wins all the cards and returns \'Player 1 wins the game\' or \'Player 2 wins the game\'. 3. **Card Definitions:** - Use a standard 52-card deck. - Cards are divided equally between two players. 4. **Gameplay:** - Each round, players play the top card of their deck. - The player with the higher card wins the round and takes both cards, placing them at the bottom of their deck. - If the cards are of equal rank, it’s a War: - Each player places the next three cards face down and the fourth card face up. - The higher fourth card wins all the cards. - If those cards are equal, repeat the process until a winner is determined. - If a player cannot finish the war due to not having enough cards, they lose the game. 5. **Performance Expectations:** - Handle the game fairly within a reasonable timeframe. # Example Usage ```python class WarGame: def __init__(self) -> None: pass def shuffle_deck(self) -> None: pass def deal_cards(self) -> None: pass def play_round(self) -> str: pass def determine_winner(self) -> str: pass if __name__ == \\"__main__\\": game = WarGame() game.shuffle_deck() game.deal_cards() result = game.determine_winner() print(result) ``` # Constraints - Ensure the card deck is correctly shuffled and divided equally between two players. - Simulate the gameplay accurately reflecting the rules of War. - Handle edge cases where players run out of cards during a War situation. # Edge Cases to Consider - One or both players running out of cards during a War. - Correctly handling shuffled and unshuffled states of the deck.","solution":"import random class WarGame: def __init__(self) -> None: self.deck = [f\\"{rank}{suit}\\" for suit in \\"HDSC\\" for rank in \\"23456789TJQKA\\"] self.player1 = [] self.player2 = [] def shuffle_deck(self) -> None: random.shuffle(self.deck) def deal_cards(self) -> None: self.player1 = self.deck[:26] self.player2 = self.deck[26:] def card_value(self, card: str) -> int: rank = card[0] if rank in \\"23456789\\": return int(rank) elif rank == \\"T\\": return 10 elif rank == \\"J\\": return 11 elif rank == \\"Q\\": return 12 elif rank == \\"K\\": return 13 elif rank == \\"A\\": return 14 def play_round(self) -> str: if not self.player1 or not self.player2: return \\"No more cards to play\\" card1 = self.player1.pop(0) card2 = self.player2.pop(0) v1 = self.card_value(card1) v2 = self.card_value(card2) if v1 > v2: self.player1.extend([card1, card2]) return \\"Player 1 wins\\" elif v2 > v1: self.player2.extend([card1, card2]) return \\"Player 2 wins\\" else: return self.war(card1, card2) def war(self, card1: str, card2: str) -> str: war_pile = [card1, card2] while True: if len(self.player1) < 4: self.player2.extend(self.player1 + war_pile) self.player1 = [] return \\"Player 2 wins\\" elif len(self.player2) < 4: self.player1.extend(self.player2 + war_pile) self.player2 = [] return \\"Player 1 wins\\" war_pile.extend(self.player1[:4] + self.player2[:4]) self.player1 = self.player1[4:] self.player2 = self.player2[4:] card1 = war_pile[-2] card2 = war_pile[-1] v1 = self.card_value(card1) v2 = self.card_value(card2) if v1 > v2: self.player1.extend(war_pile) return \\"Player 1 wins\\" elif v2 > v1: self.player2.extend(war_pile) return \\"Player 2 wins\\" def determine_winner(self) -> str: while self.player1 and self.player2: self.play_round() return \\"Player 1 wins the game\\" if self.player1 else \\"Player 2 wins the game\\" if __name__ == \\"__main__\\": game = WarGame() game.shuffle_deck() game.deal_cards() result = game.determine_winner() print(result)"},{"question":"# Coding Assessment Question Scenario You are helping a bookstore with their inventory management system. They need a function to process the sales data and restock the books that are sold out. They store their inventory in a list of dictionaries, where each dictionary represents a book with its details - title, author, genre, stock count, and price. The sales data is provided as a list of lists, where each sublist contains the title of the book sold. Task Write a function `update_inventory(inventory, sales)` that takes two inputs: 1. `inventory`: A list of dictionaries where each dictionary contains: - `title` (string): The title of the book. - `author` (string): The author of the book. - `genre` (string): The genre of the book. - `stock` (int): The current stock count of the book. - `price` (float): The price per unit of the book. 2. `sales`: A list of lists, where each sublist contains the title of a book that was sold. The function should return the updated inventory list after processing the sales data by decrementing the stock count of each sold book. If the stock count of a book reaches zero, a key `\'sold_out\'` with the value `True` should be added to that book\'s dictionary. Input * `inventory`: A list of dictionaries representing the existing inventory. * `sales`: A list of lists representing the sold books. Output * A list of dictionaries representing the updated inventory. Constraints * Each title in the sales data will be present in the inventory data. * The inventory will contain at least one book. * The stock values in the inventory will be non-negative integers. * The sales list will only contain valid titles that exist in the inventory. Example Input ```python inventory = [ {\\"title\\": \\"Book A\\", \\"author\\": \\"Author A\\", \\"genre\\": \\"Fiction\\", \\"stock\\": 5, \\"price\\": 10.99}, {\\"title\\": \\"Book B\\", \\"author\\": \\"Author B\\", \\"genre\\": \\"Non-Fiction\\", \\"stock\\": 2, \\"price\\": 15.50}, {\\"title\\": \\"Book C\\", \\"author\\": \\"Author C\\", \\"genre\\": \\"Mystery\\", \\"stock\\": 1, \\"price\\": 12.75}, ] sales = [ [\\"Book A\\"], [\\"Book B\\"], [\\"Book C\\"], [\\"Book A\\"], [\\"Book C\\"], ] ``` Example Output ```python [ {\\"title\\": \\"Book A\\", \\"author\\": \\"Author A\\", \\"genre\\": \\"Fiction\\", \\"stock\\": 3, \\"price\\": 10.99}, {\\"title\\": \\"Book B\\", \\"author\\": \\"Author B\\", \\"genre\\": \\"Non-Fiction\\", \\"stock\\": 1, \\"price\\": 15.50}, {\\"title\\": \\"Book C\\", \\"author\\": \\"Author C\\", \\"genre\\": \\"Mystery\\", \\"stock\\": 0, \\"price\\": 12.75, \\"sold_out\\": True}, ] ``` In this example, the stock of \\"Book A\\" was decremented by 2, \\"Book B\\" by 1, and \\"Book C\\" by 2 which resulted in it being sold out and tagged accordingly.","solution":"def update_inventory(inventory, sales): Updates the inventory based on the sales data. Parameters: inventory (list of dicts): List of dictionaries representing the inventory. sales (list of lists): List of lists representing the sold books. Returns: list of dicts: The updated inventory. # Convert sales list of lists to a flat list sales_flat = [item for sublist in sales for item in sublist] # Update inventory based on sales for book in inventory: if book[\'title\'] in sales_flat: sales_count = sales_flat.count(book[\'title\']) book[\'stock\'] -= sales_count if book[\'stock\'] <= 0: book[\'stock\'] = 0 book[\'sold_out\'] = True return inventory"},{"question":"# Palindrome Partitioning Objective Implement a class `PalindromePartition` that includes methods to: 1. Partition a given string into all possible sets of palindromic substrings. 2. Count the minimum number of cuts required to partition the string into palindromic substrings. Background A string is a palindrome if it reads the same forwards and backwards. Partitioning involves breaking the string into substrings such that all the substrings are palindromes. The task is to find all such partitions and also determine the minimum cuts needed for such a partition. Task 1. Implement the class `PalindromePartition`. 2. Implement methods to: - Generate all possible partitions where each substring is a palindrome. - Compute the minimum number of cuts needed to partition the string such that every substring is a palindrome. Implementation Requirements 1. **Class Definition**: - `class PalindromePartition:` 2. **Methods to Implement**: - `def all_partitions(self, text: str) -> List[List[str]]`: Returns lists of all possible palindromic partitions. - `def min_cuts(self, text: str) -> int`: Returns the minimum number of cuts needed for palindromic partitions. Function Signatures ```python from typing import List class PalindromePartition: def all_partitions(self, text: str) -> List[List[str]]: pass def min_cuts(self, text: str) -> int: pass ``` Constraints 1. The input text will be a non-empty string consisting of lowercase alphabets. 2. The length of the input text will not exceed 1000 characters. Example ```python palindrome_partition = PalindromePartition() # Text: \\"aab\\" # All Partitions: [[\\"a\\", \\"a\\", \\"b\\"], [\\"aa\\", \\"b\\"]] all_partitions = palindrome_partition.all_partitions(\\"aab\\") # Minimum Cuts: 1 min_cuts = palindrome_partition.min_cuts(\\"aab\\") # Text: \\"abba\\" # All Partitions: [[\\"a\\", \\"b\\", \\"b\\", \\"a\\"], [\\"a\\", \\"bb\\", \\"a\\"], [\\"abba\\"]] all_partitions = palindrome_partition.all_partitions(\\"abba\\") # Minimum Cuts: 0 min_cuts = palindrome_partition.min_cuts(\\"abba\\") ```","solution":"from typing import List class PalindromePartition: def all_partitions(self, text: str) -> List[List[str]]: res = [] self._partition_helper(text, 0, [], res) return res def _partition_helper(self, text: str, start: int, path: List[str], res: List[List[str]]): if start == len(text): res.append(path) return for end in range(start + 1, len(text) + 1): if self._is_palindrome(text, start, end - 1): # end is non-inclusive so end - 1 is inclusive self._partition_helper(text, end, path + [text[start:end]], res) def _is_palindrome(self, text: str, left: int, right: int) -> bool: while left < right: if text[left] != text[right]: return False left += 1 right -= 1 return True def min_cuts(self, text: str) -> int: n = len(text) dp = [0] * n pal = [[False] * n for _ in range(n)] for i in range(n): min_cut = i for j in range(i + 1): if text[j] == text[i] and (i - j <= 1 or pal[j + 1][i - 1]): pal[j][i] = True min_cut = 0 if j == 0 else min(min_cut, dp[j - 1] + 1) dp[i] = min_cut return dp[-1]"},{"question":"# Coding Assessment Question Context You are working on a project involving efficient search algorithms in sorted integer arrays. One common task is to find the minimum element in a sorted and rotated array, which is a typical problem in understanding search techniques and algorithms. Problem Statement You are given an array of `n` integers that has been sorted in ascending order and then possibly rotated. You need to find the minimum element in this array using an efficient logarithmic time algorithm. Write the function to achieve the following: 1. **Find Minimum in Rotated Sorted Array**: * Implement a function that takes a rotated sorted array and returns the minimum element using binary search. Function Signature ```python def find_min_in_rotated_sorted_array(nums: list[int]) -> int: Finds the minimum element in a rotated sorted array using binary search. pass ``` Example ```python print(find_min_in_rotated_sorted_array([3, 4, 5, 1, 2])) # Output: 1 print(find_min_in_rotated_sorted_array([4, 5, 6, 7, 0, 1, 2])) # Output: 0 print(find_min_in_rotated_sorted_array([11, 13, 15, 17])) # Output: 11 print(find_min_in_rotated_sorted_array([1])) # Output: 1 print(find_min_in_rotated_sorted_array([2, 1])) # Output: 1 ``` Constraints * Number of elements (`n`): 1 ≤ n ≤ 10^6 * The array may contain duplicates. * An empty array is not provided. * All elements are integers and within the range of standard integer limits. Your solution will be evaluated on the correctness, efficiency (both time and space), and proper handling of edge cases.","solution":"def find_min_in_rotated_sorted_array(nums: list[int]) -> int: Finds the minimum element in a rotated sorted array using binary search. :param nums: List of integers representing the rotated sorted array. :return: The minimum element in the array. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[right]: left = mid + 1 elif nums[mid] < nums[right]: right = mid else: right -= 1 # handle duplicates return nums[left] # Example usage (uncomment and run): # print(find_min_in_rotated_sorted_array([3, 4, 5, 1, 2])) # Output: 1 # print(find_min_in_rotated_sorted_array([4, 5, 6, 7, 0, 1, 2])) # Output: 0 # print(find_min_in_rotated_sorted_array([11, 13, 15, 17])) # Output: 11 # print(find_min_in_rotated_sorted_array([1])) # Output: 1 # print(find_min_in_rotated_sorted_array([2, 1])) # Output: 1"},{"question":"# Implement a Priority Queue Using a Max-Heap **Context**: Priority queues are fundamental data structures in computer science, commonly used within algorithms like Dijkstra\'s shortest path, Huffman coding, and in scenarios requiring dynamic ordering such as scheduling tasks or managing resources. **Problem Statement**: Your task is to implement a priority queue using a max-heap data structure. The provided `PriorityQueue` class should support the core operations of inserting an element with a given priority, removing the element with the highest priority, and peeking at the element with the highest priority without removing it. Additionally, you must ensure that the max-heap property is maintained after each operation. Requirements: * Implement the `insert`, `remove_max`, and `max` methods in the `PriorityQueue` class. * The `insert` method should add an element with a given priority to the heap. * The `remove_max` method should remove and return the element with the highest priority. * The `max` method should return the element with the highest priority without removing it. * Handle edge cases where the priority queue might be empty. # Function Signature ```python class PriorityQueue: def __init__(self): self._data = [] def insert(self, element, priority): pass def remove_max(self): pass def max(self): pass def _sift_up(self, idx): pass def _sift_down(self, idx): pass ``` # Input & Output * The `insert` method takes an element and a priority (`insert(self, element, priority)`). * The `remove_max` method returns the element with the highest priority (`remove_max(self)`). * The `max` method returns the element with the highest priority without removing it (`max(self)`). # Example ```python >>> pq = PriorityQueue() >>> pq.insert(\'task1\', 5) >>> pq.insert(\'task2\', 9) >>> pq.insert(\'task3\', 3) >>> pq.max() \'task2\' >>> pq.remove_max() \'task2\' >>> pq.max() \'task1\' ``` # Constraints * Ensure the heap property is maintained after each insertion and removal. * Handle edge cases such as removing from an empty priority queue gracefully.","solution":"class PriorityQueue: def __init__(self): self._data = [] def insert(self, element, priority): self._data.append((priority, element)) self._sift_up(len(self._data) - 1) def remove_max(self): if len(self._data) == 0: raise IndexError(\\"remove_max from empty priority queue\\") self._swap(0, len(self._data) - 1) max_element = self._data.pop() self._sift_down(0) return max_element[1] def max(self): if len(self._data) == 0: raise IndexError(\\"max from empty priority queue\\") return self._data[0][1] def _sift_up(self, idx): parent_idx = (idx - 1) // 2 if idx > 0 and self._data[idx][0] > self._data[parent_idx][0]: self._swap(idx, parent_idx) self._sift_up(parent_idx) def _sift_down(self, idx): left_child_idx = 2 * idx + 1 right_child_idx = 2 * idx + 2 max_idx = idx if left_child_idx < len(self._data) and self._data[left_child_idx][0] > self._data[max_idx][0]: max_idx = left_child_idx if right_child_idx < len(self._data) and self._data[right_child_idx][0] > self._data[max_idx][0]: max_idx = right_child_idx if max_idx != idx: self._swap(idx, max_idx) self._sift_down(max_idx) def _swap(self, i, j): self._data[i], self._data[j] = self._data[j], self._data[i]"},{"question":"# Problem Statement You are developing an application where you need to simulate and analyze the movement of objects in a 2D grid that has both walkable and non-walkable cells. The shortest path between two points on this grid should avoid non-walkable cells and is measured in terms of Manhattan distance (sum of the absolute differences of the Cartesian coordinates). Write a function `shortest_path_in_grid` that computes the shortest path from the top-left corner to the bottom-right corner of the grid, only passing through walkable cells. If there is no possible path, the function should return -1. # Function Signature ```python def shortest_path_in_grid(grid: list[list[int]]) -> int: pass ``` # Input - `grid`: a list of lists of integers, where `grid[i][j]` is `0` if the cell is walkable or `1` if the cell is not walkable. # Output - Returns the length of the shortest path from the top-left corner to the bottom-right corner moving only through walkable cells, or `-1` if no such path exists. # Constraints - The dimensions of `grid` will be between 1 and (500 times 500). - Each cell in the grid is either 0 (walkable) or 1 (non-walkable). # Example ```python >>> grid = [ ... [0, 0, 1], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> shortest_path_in_grid(grid) 4 >>> grid = [ ... [0, 1], ... [1, 0] ... ] >>> shortest_path_in_grid(grid) -1 ``` # Notes - Only horizontal and vertical movements to adjacent walkable cells are allowed. - Optimize for performance, considering the constraints. - Top-left corner is considered cell (0, 0) and bottom-right corner is (rows-1, columns-1).","solution":"from collections import deque def shortest_path_in_grid(grid: list[list[int]]) -> int: rows = len(grid) cols = len(grid[0]) if grid[0][0] == 1 or grid[rows-1][cols-1] == 1: return -1 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0, 0)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == rows-1 and y == cols-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0 and (nx, ny) not in visited: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"# Reverse Words in a String Scenario: You are tasked with developing a utility function for a text processing application. One of the features required is the ability to reverse the words in a given sentence, while maintaining the order of word lengths. # Task Write a Python function that takes a string as input and returns a new string where the words are reversed, but their lengths remain in the same order. Function Signature ```python def reverse_words_with_length_maintained(sentence: str) -> str: pass ``` Input * `sentence` (str): A string containing words separated by single spaces. The string will consist of only alphabetic characters and spaces, and it will not be empty. Output * Returns a new string where each word is reversed, but the word lengths follow the original order. Examples ```python >>> reverse_words_with_length_maintained(\\"hello world\\") \\"olleh dlrow\\" >>> reverse_words_with_length_maintained(\\"python programming\\") \\"nohtyp gnimmargorp\\" >>> reverse_words_with_length_maintained(\\"data structures and algorithms\\") \\"atad serutcurts dna smhtirogla\\" ``` Validation and Error Handling Your function should ensure that: * The input string is not empty. * The input string contains only alphabetic characters and spaces. If these conditions are not met, the function should raise appropriate exceptions: * If the input string is empty, raise `Exception: Input sentence must not be empty` * If the input string contains non-alphabetic characters (excluding spaces), raise `Exception: Input sentence must contain only alphabetic characters and spaces`","solution":"def reverse_words_with_length_maintained(sentence: str) -> str: This function takes a string as input and returns a new string where the words are reversed, but their lengths remain in the same order. :param sentence: str - The input sentence with words separated by single spaces. :return: str - New sentence with words reversed maintaining the order of word lengths. if not sentence: raise Exception(\\"Input sentence must not be empty\\") if not all(c.isalpha() or c.isspace() for c in sentence): raise Exception(\\"Input sentence must contain only alphabetic characters and spaces\\") words = sentence.split() reversed_words = [\'\'.join(reversed(word)) for word in words] return \' \'.join(reversed_words)"},{"question":"# Processing Payment Transactions You are hired to develop a financial application that processes payments and calculates total sales. Each payment transaction includes information about the amount, payment method, and status. The objective is to implement functionality to add new transactions and compute the total sales for the day. # Task: Implement the class `TransactionProcessor` with the following specifications: 1. **Class `TransactionProcessor`:** * **Methods**: 1. `add_transaction(self, amount: float, payment_method: str, status: str) -> None` * **Input**: * `amount`: A float representing the amount of the transaction. * `payment_method`: A string, one of \\"credit\\", \\"debit\\", or \\"cash\\". * `status`: A string, one of \\"completed\\", \\"pending\\", or \\"failed\\". * **Constraints**: * Raise an exception if the `amount` is negative. * Raise an exception if the `payment_method` is not one of \\"credit\\", \\"debit\\", or \\"cash\\". * Raise an exception if the `status` is not one of \\"completed\\", \\"pending\\", or \\"failed\\". 2. `total_sales(self) -> float` * **Output**: * Returns the total amount of all transactions with the status \\"completed\\". # Examples: ```python # Example usage: processor = TransactionProcessor() processor.add_transaction(100.0, \\"credit\\", \\"completed\\") processor.add_transaction(200.0, \\"debit\\", \\"pending\\") processor.add_transaction(50.0, \\"cash\\", \\"completed\\") processor.add_transaction(25.0, \\"credit\\", \\"failed\\") print(processor.total_sales()) # Output: 150.0 ``` # Additional Information: Ensure your methods handle edge cases and raise appropriate exceptions when invalid input values are provided. The class should maintain a record of all transactions added.","solution":"class TransactionProcessor: def __init__(self): self.transactions = [] def add_transaction(self, amount: float, payment_method: str, status: str) -> None: if amount < 0: raise ValueError(\\"Transaction amount cannot be negative\\") if payment_method not in [\\"credit\\", \\"debit\\", \\"cash\\"]: raise ValueError(\\"Invalid payment method\\") if status not in [\\"completed\\", \\"pending\\", \\"failed\\"]: raise ValueError(\\"Invalid transaction status\\") self.transactions.append({\\"amount\\": amount, \\"payment_method\\": payment_method, \\"status\\": status}) def total_sales(self) -> float: return sum(transaction[\\"amount\\"] for transaction in self.transactions if transaction[\\"status\\"] == \\"completed\\")"},{"question":"# Coding Assessment: Matrix Rotation Problem Statement You are asked to implement an algorithm that rotates a given square matrix (2D list) by 90 degrees in a clockwise direction. The rotation should be done in-place, meaning no additional matrix or list should be created during the process. Your implementation should be able to handle matrices of various sizes, including edge cases such as a 1x1 matrix or an empty matrix. Task Implement the following function in Python: 1. **rotate_matrix(matrix)**: Rotates the given square matrix by 90 degrees clockwise in-place. ```python def rotate_matrix(matrix): Rotates the given square matrix by 90 degrees clockwise in-place. Parameters: matrix (list): A 2D list representing the square matrix to rotate. Returns: None: The matrix is modified in-place. Example Usage: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> print(matrix) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] n = len(matrix) if n == 0 or n != len(matrix[0]): return for layer in range(n // 2): first = layer last = n - 1 - layer for i in range(first, last): offset = i - first # save top top = matrix[first][i] # left -> top matrix[first][i] = matrix[last - offset][first] # bottom -> left matrix[last - offset][first] = matrix[last][last - offset] # right -> bottom matrix[last][last - offset] = matrix[i][last] # top -> right matrix[i][last] = top # Driver code for testing if __name__ == \\"__main__\\": import doctest doctest.testmod() matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(\\"Original matrix:\\") for row in matrix: print(row) rotate_matrix(matrix) print(\\"nRotated matrix:\\") for row in matrix: print(row) ``` Constraints - Your function should handle empty matrices and 1x1 matrices correctly. - The matrix will always be square (i.e., same number of rows and columns). - Ensure that your implementation is efficient and makes no extraneous matrix or list allocations. Evaluation Your solution will be evaluated based on: 1. **Correctness**: Properly rotating the matrix as per the given instructions. 2. **Efficiency**: Avoiding unnecessary space complexity and working in-place. 3. **Robustness**: Handling edge cases gracefully. 4. **Readability**: Well-commented, clear, and easily understandable code. 5. **Testing**: Comprehensiveness of test cases written.","solution":"def rotate_matrix(matrix): Rotates the given square matrix by 90 degrees clockwise in-place. Parameters: matrix (list): A 2D list representing the square matrix to rotate. Returns: None: The matrix is modified in-place. Example Usage: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> print(matrix) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] n = len(matrix) if n == 0 or n != len(matrix[0]): return for layer in range(n // 2): first = layer last = n - 1 - layer for i in range(first, last): offset = i - first # Save the top element top = matrix[first][i] # Move left element to top matrix[first][i] = matrix[last - offset][first] # Move bottom element to left matrix[last - offset][first] = matrix[last][last - offset] # Move right element to bottom matrix[last][last - offset] = matrix[i][last] # Assign top element to right matrix[i][last] = top"},{"question":"# Sum of Unique Elements Overview Given an array of integers, implement a function that returns the sum of the unique elements in the array. Unique elements are those that appear exactly once in the array. Requirements * **Function Name**: `sum_of_unique` * **Input**: - `nums`: List of integers. * **Output**: Integer representing the sum of all unique elements in the array. * **Constraints**: - The input list can have duplicate numbers. - The input list can be of varying lengths, including empty. - Your solution should efficiently handle large input sizes. Implementation You should write a function to solve the problem based on the above input and output specifications. Example ```python def sum_of_unique(nums: list[int]) -> int: >>> sum_of_unique([1, 2, 3, 2]) 4 >>> sum_of_unique([1, 2, 2, 3, 4, 3, 5]) 10 >>> sum_of_unique([1]) 1 >>> sum_of_unique([1, 1, 1, 1]) 0 >>> sum_of_unique([]) 0 # Example cases print(sum_of_unique([1, 2, 3, 2])) # Output: 4 print(sum_of_unique([1, 2, 2, 3, 4, 3, 5])) # Output: 10 print(sum_of_unique([1])) # Output: 1 print(sum_of_unique([1, 1, 1, 1])) # Output: 0 print(sum_of_unique([])) # Output: 0 ``` Additional Test Cases ```python # No unique elements print(sum_of_unique([4, 4, 4, 4])) # Output: 0 # Large input size with all unique elements print(sum_of_unique(list(range(1, 10001)))) # Output: 50005000 # Mix of duplicates and unique elements print(sum_of_unique([10, 20, 30, 20, 10, 40, 50])) # Output: 120 ``` Implement the function `sum_of_unique` as specified above and ensure it passes the given test cases.","solution":"def sum_of_unique(nums): Returns the sum of unique elements in the given list of integers. from collections import Counter count = Counter(nums) unique_sum = sum(num for num, cnt in count.items() if cnt == 1) return unique_sum"},{"question":"# Question: Implement Byte Array Manipulation and Conversion Context You are developing a data serialization library that needs to handle byte arrays and their conversions efficiently. Specifically, you need to write functions to convert a list of integers to a byte array and vice versa. Each integer should fit into one byte (i.e., in the range 0-255). Requirements 1. **Function 1: Integers to Byte Array** ```python def integers_to_byte_array(numbers: list) -> bytearray: Takes a list of integers and converts it to a byte array. Each integer in the list must be in the range 0 to 255. Return the byte array representation of the list. Example: >>> integers_to_byte_array([1, 2, 3, 255]) bytearray(b\'x01x02x03xff\') ``` 2. **Function 2: Byte Array to Integers** ```python def byte_array_to_integers(b_array: bytearray) -> list: Takes a byte array and converts it back to a list of integers. Return the list of integers representation of the byte array. Example: >>> byte_array_to_integers(bytearray(b\'x01x02x03xff\')) [1, 2, 3, 255] ``` Constraints - The input list for `integers_to_byte_array` must contain integers only. - The list elements must be in the range of 0 to 255, inclusive. - The byte array for `byte_array_to_integers` must be a valid bytearray object. Performance Requirements - Aim for efficient implementations that handle large lists or byte arrays within reasonable time and space limits. Edge Cases - Handle empty lists and empty byte arrays. - Ensure that any invalid input (e.g., integers out of the valid range, non-integer elements) raises appropriate exceptions. Write code that performs these conversions, verifying through provided examples.","solution":"def integers_to_byte_array(numbers: list) -> bytearray: Takes a list of integers and converts it to a byte array. Each integer in the list must be in the range 0 to 255. Return the byte array representation of the list. if not all(isinstance(num, int) and 0 <= num <= 255 for num in numbers): raise ValueError(\\"All elements must be integers in the range 0 to 255.\\") return bytearray(numbers) def byte_array_to_integers(b_array: bytearray) -> list: Takes a byte array and converts it back to a list of integers. Return the list of integers representation of the byte array. return list(b_array)"},{"question":"**Context**: You are developing a file synchronization system that ensures files in two directories remain identical. Each directory is represented as a tree structure with nodes as directories and leaf nodes as files. Each file has a unique identifier. **Task**: Implement the `is_synchronized` function which checks if two directory trees are synchronized, meaning they contain the same files with the same structure. **Function Signature**: ```python def is_synchronized(dir1: dict, dir2: dict) -> bool: Check if two directory trees are synchronized. :param dir1: dict, a tree representation of the first directory :param dir2: dict, a tree representation of the second directory :return: bool, True if directories are synchronized, False otherwise ``` # Input: - `dir1` (dict): A dictionary representing the first directory. - `dir2` (dict): A dictionary representing the second directory. # Output: - A boolean indicating whether the two directories are synchronized (True) or not (False). # Constraints: - Each file in the directories has a unique identifier string. - The directory tree can be nested several levels deep. - The names of the directories and files are case-sensitive. # Example: ```python dir1 = { \\"root\\": { \\"subdir1\\": { \\"file1\\": \\"id1\\", \\"file2\\": \\"id2\\", }, \\"subdir2\\": { \\"file3\\": \\"id3\\", } } } dir2 = { \\"root\\": { \\"subdir1\\": { \\"file1\\": \\"id1\\", \\"file2\\": \\"id2\\", }, \\"subdir2\\": { \\"file4\\": \\"id4\\", } } } assert is_synchronized(dir1, dir2) == False dir3 = { \\"root\\": { \\"subdir1\\": { \\"file1\\": \\"id1\\", \\"file2\\": \\"id2\\", }, \\"subdir2\\": { \\"file3\\": \\"id3\\", } } } assert is_synchronized(dir1, dir3) == True ``` # Note: - Consider edge cases such as empty directories or directories with different structures but no files. - Ensure the function handles deep nested directories efficiently. **Your implementation will be evaluated on correctness, efficiency, and handling of edge cases.**","solution":"def is_synchronized(dir1: dict, dir2: dict) -> bool: Check if two directory trees are synchronized. :param dir1: dict, a tree representation of the first directory :param dir2: dict, a tree representation of the second directory :return: bool, True if directories are synchronized, False otherwise def _compare_dirs(d1, d2): if d1.keys() != d2.keys(): return False for key in d1: if isinstance(d1[key], dict) and isinstance(d2[key], dict): if not _compare_dirs(d1[key], d2[key]): return False elif d1[key] != d2[key]: return False return True return _compare_dirs(dir1, dir2)"},{"question":"# Problem: Validate Subsequence in Array Given two arrays, determine if the second array is a subsequence of the first array. A subsequence of an array is a set of numbers that appear in the same order as they do in the original array, but they do not have to be consecutive. Implement a function `is_subsequence(array: List[int], subsequence: List[int]) -> bool` that checks if the provided subsequence is indeed a valid subsequence of the array. # Function Signature ```python def is_subsequence(array: List[int], subsequence: List[int]) -> bool: pass ``` # Input - `array`: A list of integers `array` (1 <= len(array) <= 10^5, -10^9 <= array[i] <= 10^9) - `subsequence`: A list of integers `subsequence` (0 <= len(subsequence) <= 10^5, -10^9 <= subsequence[i] <= 10^9) # Output - Returns `True` if `subsequence` is a subsequence of `array`, and `False` otherwise. # Constraints - The function should operate within reasonable time complexity to handle large arrays efficiently. - Both input arrays may contain negative numbers, zeros, and positive numbers. # Example ```python print(is_subsequence([1, 2, 3, 4, 5], [1, 3, 5])) # Output: True print(is_subsequence([5, 1, 22, 25, 6, -1, 8, 10], [1, 6, -1, 10])) # Output: True print(is_subsequence([5, 1, 22, 25, 6, -1, 8, 10], [1, 6, 10])) # Output: False ``` # Additional Information - The function must iterate through both arrays without requiring nested loops to ensure performant checking. - Think about using two-pointer technique or similar approaches to achieve the goal in an efficient manner. Implement the function `is_subsequence` to determine if the given subsequence is valid.","solution":"from typing import List def is_subsequence(array: List[int], subsequence: List[int]) -> bool: Determines if subsequence is a valid subsequence of array. :param array: List[int] - The array where we are verifying the subsequence :param subsequence: List[int] - The subsequence to verify :return: bool - True if subsequence is a subsequence of array, False otherwise # Pointers for array and subsequence arr_index = 0 sub_index = 0 # Traverse both arrays while arr_index < len(array) and sub_index < len(subsequence): if array[arr_index] == subsequence[sub_index]: sub_index += 1 arr_index += 1 # If sub_index reaches the length of the subsequence, it is a valid subsequence return sub_index == len(subsequence)"},{"question":"# Coding Assessment Question Scenario You are tasked with evaluating the stability of a string arrangement. Given a string consisting of only curly braces `{` and `}`, you need to determine if the string is balanced. A balanced string has every opening brace `{` properly matched with a closing brace `}` in the correct order. Objective Implement the function `is_balanced_braces(s: str) -> bool`. Your function should return `True` if the string is balanced and `False` otherwise. Input * `s` (str): A string containing only the characters `{` and `}`, with a length between 1 and 10^6. Output * `bool`: Returns `True` if the string is balanced, otherwise `False`. Constraints * The length of the string, `len(s)`, is between 1 and 10^6. Example ```python is_balanced_braces(\\"{}}{\\") # Output: False is_balanced_braces(\\"{{}}\\") # Output: True is_balanced_braces(\\"{}{}{}\\") # Output: True is_balanced_braces(\\"{{}{\\") # Output: False is_balanced_braces(\\"\\") # Output: True ``` Performance Requirement * The function should run efficiently with a linear time complexity, approximately O(n), where n is the length of the input string.","solution":"def is_balanced_braces(s: str) -> bool: Determine if a given string of curly braces is balanced. Args: s (str): A string containing only the characters `{` and `}`. Returns: bool: Returns `True` if the string is balanced, otherwise `False`. balance = 0 for char in s: if char == \'{\': balance += 1 elif char == \'}\': balance -= 1 if balance < 0: return False # More closing than opening braces return balance == 0"},{"question":"# Coding Assessment Question You are tasked to write a function that processes a list of transactions and categorizes them based on their type. The goal is to create a summary report that provides a count and total amount for each transaction type. Scenario Write a function `summarize_transactions` that takes a list of transaction dictionaries and returns a summary report as a dictionary. Implementation Details **Function: summarize_transactions(transactions: list) -> dict** * **Inputs**: - `transactions` (list): A list of dictionaries, each representing a transaction with keys `type` (str) and `amount` (float). * **Outputs**: - A dictionary where keys are transaction types and values are dictionaries containing `count` and `total_amount` for each type. Example: ```python def summarize_transactions(transactions: list) -> dict: summary = {} for transaction in transactions: transaction_type = transaction[\'type\'] amount = transaction[\'amount\'] if transaction_type not in summary: summary[transaction_type] = {\'count\': 0, \'total_amount\': 0.0} summary[transaction_type][\'count\'] += 1 summary[transaction_type][\'total_amount\'] += amount return summary # Example Usage transactions = [ {\'type\': \'income\', \'amount\': 100.0}, {\'type\': \'expense\', \'amount\': 50.0}, {\'type\': \'income\', \'amount\': 200.0} ] print(summarize_transactions(transactions)) # Expected Output: # {\'income\': {\'count\': 2, \'total_amount\': 300.0}, \'expense\': {\'count\': 1, \'total_amount\': 50.0}} ``` Testing Write unit tests to ensure the correctness of `summarize_transactions` function. Cover edge cases such as an empty transaction list and transactions with negative amounts. Example Tests: ```python def test_summarize_transactions(): # Simple test case transactions = [ {\'type\': \'income\', \'amount\': 100.0}, {\'type\': \'expense\', \'amount\': 50.0}, {\'type\': \'income\', \'amount\': 200.0} ] result = summarize_transactions(transactions) assert result == { \'income\': {\'count\': 2, \'total_amount\': 300.0}, \'expense\': {\'count\': 1, \'total_amount\': 50.0} } # Test with empty list transactions = [] result = summarize_transactions(transactions) assert result == {} # Test with negative amounts transactions = [ {\'type\': \'income\', \'amount\': -100.0}, {\'type\': \'expense\', \'amount\': -50.0} ] result = summarize_transactions(transactions) assert result == { \'income\': {\'count\': 1, \'total_amount\': -100.0}, \'expense\': {\'count\': 1, \'total_amount\': -50.0} } ``` **Constraints**: * Assume each transaction dictionary is always well-formed. * Handle the cases where transaction amounts can be negative, zero, or very large. * Ensure the function performs efficiently even with large lists of transactions.","solution":"def summarize_transactions(transactions): Summarizes transactions by their type and calculates total count and amount for each type. Args: transactions (list): A list of transaction dictionaries with keys \'type\' and \'amount\'. Returns: dict: A dictionary summarizing the count and total amount of each transaction type. summary = {} for transaction in transactions: transaction_type = transaction[\'type\'] amount = transaction[\'amount\'] if transaction_type not in summary: summary[transaction_type] = {\'count\': 0, \'total_amount\': 0.0} summary[transaction_type][\'count\'] += 1 summary[transaction_type][\'total_amount\'] += amount return summary"},{"question":"# Coding Assessment Question: Matrix Transposition Context You have been provided with a matrix class that supports various matrix operations such as addition, subtraction, multiplication, and others. However, the functionality to transpose the matrix, which involves flipping the matrix over its diagonal, switching the row and column indices of each element, is missing. Transposing a matrix is a fundamental operation in linear algebra, often used in conjunction with other matrix operations in various fields including computer graphics, machine learning, and more. Task Implement a method within the given `Matrix` class to transpose the matrix. Function Signature ```python def transpose(self) -> \'Matrix\': Returns the transpose of the matrix. Returns: Matrix: The transposed matrix. ``` Input - The matrix is already initialized using the provided `Matrix` class. - No additional inputs are required. Output - The function should return a new matrix that is the transpose of the original matrix. Constraints - You must use the existing `Matrix` class and its methods where applicable. - Ensure the function handles edge cases such as empty matrices, single-row or single-column matrices. Example ```python # Example 1 matrix1 = Matrix([ [1, 2, 3], [4, 5, 6] ]) print(matrix1.transpose().data) # Expected output: # [ # [1, 4], # [2, 5], # [3, 6] # ] # Example 2 matrix2 = Matrix([ [1, 2], [3, 4], [5, 6] ]) print(matrix2.transpose().data) # Expected output: # [ # [1, 3, 5], # [2, 4, 6] # ] # Example 3 matrix3 = Matrix([ [7] ]) print(matrix3.transpose().data) # Expected output: # [ # [7] # ] ``` Additional Notes - You may assume that the matrix data is stored in a 2D list. - Ensure that your implementation is efficient and works for matrices of different dimensions. This new question fits seamlessly with the existing set by addressing another essential matrix operation while maintaining the same level of complexity and technical challenge.","solution":"class Matrix: def __init__(self, data): self.data = data def transpose(self): Returns the transpose of the matrix. Returns: Matrix: The transposed matrix. transposed_data = list(map(list, zip(*self.data))) return Matrix(transposed_data)"},{"question":"# Problem Statement You are given a list of unique integer elements and your task is to generate all possible subsets of the list without using recursion. Order of the elements within each subset does not matter and the order of the subsets themselves does not matter either. # Function Signature ```python def generate_subsets(nums: List[int]) -> List[List[int]]: ``` # Input - `nums` (List[int]): A list of unique integers where (1 leq nums.length leq 10) and each integer is in the range ([-10, 10]). # Output - Return a list of lists, where each list is a subset of the original list `nums`. # Example ```python nums = [1, 2, 3] print(generate_subsets(nums)) # Expected output: [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] ``` # Requirements 1. Implement the function `generate_subsets(nums: List[int]) -> List[List[int]]` that computes all possible subsets of the given list of integers. 2. Ensure your implementation effectively generates all subsets without using recursion. # Tips - Consider using iterative approaches like bit manipulation or breadth-first search (BFS) to generate all subsets. - Pay attention to the constraints in performance and avoid redundant computations.","solution":"from typing import List def generate_subsets(nums: List[int]) -> List[List[int]]: Generate all possible subsets of given list `nums` without using recursion. result = [[]] for num in nums: result += [current + [num] for current in result] return result"},{"question":"# Coding Assessment: Validate and Process User Data Objective You are required to write Python functions to validate and process user data efficiently. Your solution should be robust to handle various validation rules and should process the data by converting it into a specific format. Requirements 1. **Function 1: `validate_user_data(user_data: dict) -> bool`** - Input: - A dictionary representing user data with keys: `username`, `email`, `birthdate`, and `phone`. - Output: - A boolean indicating whether the user data is valid (`True`) or invalid (`False`). - Constraints: - `username`: Should be a non-empty string containing only alphanumeric characters and underscores, and must be between 3 to 20 characters. - `email`: Should be a valid email address format. - `birthdate`: Should be a string in `\\"YYYY-MM-DD\\"` format representing a valid date. - `phone`: Should be a string containing exactly 10 digits. 2. **Function 2: `process_user_data(user_data: dict) -> dict`** - Input: - A dictionary representing user data which has been validated. - Output: - A dictionary containing processed user data formatted as: - `Username`: Capitalized username. - `Email`: Lowercase email address. - `Age`: Age of the user calculated from the birthdate. - `Phone`: Phone number formatted as `\\"(xxx) xxx-xxxx\\"`. Performance Requirements - Your solution should efficiently validate and process the user data. - Consider handling invalid data gracefully and ensure the program flow is smooth. Example ```python >>> user_data = { ... \\"username\\": \\"john_doe\\", ... \\"email\\": \\"John.Doe@example.com\\", ... \\"birthdate\\": \\"1990-01-15\\", ... \\"phone\\": \\"1234567890\\" ... } >>> is_valid = validate_user_data(user_data) >>> if is_valid: ... processed_data = process_user_data(user_data) ... print(processed_data) { \\"Username\\": \\"John_doe\\", \\"Email\\": \\"john.doe@example.com\\", \\"Age\\": 33, \\"Phone\\": \\"(123) 456-7890\\" } ``` Notes 1. Pay attention to the format of each field and ensure the validation rules are strictly followed. 2. Make sure to handle any potential errors gracefully and provide clear feedback. Constraints - Ensure the `username` contains no special characters other than underscores and is of valid length. - Validate the `email` using a proper regular expression. - Ensure the `birthdate` is in the correct format and represents a valid date. - The `phone` number should strictly be a 10-digit string without any other characters.","solution":"import re from datetime import datetime def validate_user_data(user_data): # Validate username: non-empty string, alphanumeric + underscores, 3-20 characters username_pattern = re.compile(r\'^[a-zA-Z0-9_]{3,20}\') if not username_pattern.match(user_data.get(\'username\', \'\')): return False # Validate email email_pattern = re.compile(r\'^S+@S+.S+\') if not email_pattern.match(user_data.get(\'email\', \'\')): return False # Validate birthdate: should be in \\"YYYY-MM-DD\\" format and a valid date try: birthdate = datetime.strptime(user_data.get(\'birthdate\', \'\'), \'%Y-%m-%d\') except ValueError: return False # Validate phone: should be exactly 10 digits phone_pattern = re.compile(r\'^d{10}\') if not phone_pattern.match(user_data.get(\'phone\', \'\')): return False return True def process_user_data(user_data): processed_data = {} # Process username: capitalize processed_data[\'Username\'] = user_data[\'username\'].capitalize() # Process email: lowercase processed_data[\'Email\'] = user_data[\'email\'].lower() # Process Age: calculate from birthdate birthdate = datetime.strptime(user_data[\'birthdate\'], \'%Y-%m-%d\') today = datetime.today() age = today.year - birthdate.year - ((today.month, today.day) < (birthdate.month, birthdate.day)) processed_data[\'Age\'] = age # Process phone: format as \\"(xxx) xxx-xxxx\\" phone = user_data[\'phone\'] formatted_phone = f\\"({phone[:3]}) {phone[3:6]}-{phone[6:]}\\" processed_data[\'Phone\'] = formatted_phone return processed_data"},{"question":"# Problem Statement Given an encoded string, implement a function `decode_the_string(encoded: str) -> str` that decodes the input string according to the following rules: 1. The string can contain digits, letters, and square brackets. 2. Digits represent the number of times the substring enclosed in square brackets should be repeated. 3. The encoded format is always valid and properly nested. # Function Signature ```python def decode_the_string(encoded: str) -> str: pass ``` # Input - `encoded`: A string following the encoding rules described. The length of the string `n` will be 0 ≤ n ≤ 1000. The encoded string will not have any unnecessary spaces, and format is guaranteed to be valid. # Output - Return the decoded string. # Example ```python assert decode_the_string(\\"3[a2[c]]\\") == \\"accaccacc\\" assert decode_the_string(\\"3[a]2[bc]\\") == \\"aaabcbc\\" assert decode_the_string(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\" assert decode_the_string(\\"abc3[cd]xyz\\") == \\"abccdcdcdxyz\\" assert decode_the_string(\\"10[a]\\") == \\"aaaaaaaaaa\\" assert decode_the_string(\\"\\") == \\"\\" ``` # Notes - Pay attention to the nesting level of the brackets to correctly decode the string. - Ensure the solution efficiently handles the decoding process and produces correct results for all test cases. - An iterative or recursive approach can be used to solve this problem.","solution":"def decode_the_string(encoded: str) -> str: stack = [] current_num = 0 current_str = \'\' for char in encoded: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_str, current_num)) current_str = \'\' current_num = 0 elif char == \']\': prev_str, num = stack.pop() current_str = prev_str + num * current_str else: current_str += char return current_str"},{"question":"# Coding Assessment Question AVL Tree Insertion and Balancing Given an initial AVL tree implementation, your task is to extend the functionalities by adding a method for inserting a new value into the tree while maintaining its balanced property. Function Signature: ```python class AVLNode: def __init__(self, key): self.left = None self.right = None self.key = key self.height = 1 class AVLTree: def insert(self, root: AVLNode, key: int) -> AVLNode: pass ``` Input: - `root`: The root node of the AVL tree. - `key`: An integer value to be inserted into the tree. Output: - Return the new root of the AVL tree after insertion. Constraints: - The tree must remain balanced after each insertion. - Perform rebalancing using rotations (left rotation, right rotation, left-right rotation, and right-left rotation). Example: ```python # Utility function to create a new AVL tree node def new_node(key): node = AVLNode(key) node.left = None node.right = None node.height = 1 return node # Initial tree setup root = new_node(10) avl_tree = AVLTree() root = avl_tree.insert(root, 20) root = avl_tree.insert(root, 30) print(root.key) # Output should show the root key after balancing, expected to be 20 ``` Requirements: - Implement the balancing logic in the `insert` method. - Ensure the height of each node is updated accurately during the insertion process. - Handle edge cases such as inserting duplicate keys (optionally ignored or handled as per your design). Hints: - Use helper functions to get the height of a node and to perform rotations. - A node’s balance factor can be calculated as the difference in heights of its left and right subtrees. - Ensure to check and update the balance factor after each insertion and apply the appropriate rotation if required. Good luck!","solution":"class AVLNode: def __init__(self, key): self.left = None self.right = None self.key = key self.height = 1 class AVLTree: # Function to insert a node def insert(self, root: AVLNode, key: int) -> AVLNode: # Helper function to get the height of a node def get_height(node): if not node: return 0 return node.height # Helper function to get the balance factor of a node def get_balance(node): if not node: return 0 return get_height(node.left) - get_height(node.right) # Helper function to perform a right rotation def right_rotate(z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = max(get_height(z.left), get_height(z.right)) + 1 y.height = max(get_height(y.left), get_height(y.right)) + 1 return y # Helper function to perform a left rotation def left_rotate(z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = max(get_height(z.left), get_height(z.right)) + 1 y.height = max(get_height(y.left), get_height(y.right)) + 1 return y # Step 1: Perform the normal BST insertion if not root: return AVLNode(key) elif key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) # Step 2: Update the height of this ancestor node root.height = max(get_height(root.left), get_height(root.right)) + 1 # Step 3: Get the balance factor of this ancestor node balance = get_balance(root) # Step 4: If the node is unbalanced, then there are 4 cases # Left Left Case if balance > 1 and key < root.left.key: return right_rotate(root) # Right Right Case if balance < -1 and key > root.right.key: return left_rotate(root) # Left Right Case if balance > 1 and key > root.left.key: root.left = left_rotate(root.left) return right_rotate(root) # Right Left Case if balance < -1 and key < root.right.key: root.right = right_rotate(root.right) return left_rotate(root) return root"},{"question":"# Bracket Sequence Validation **Scenario**: You are enhancing a text editor\'s syntax validation feature, and you need to implement a function that checks for valid bracket sequences in the code. The function must handle multiple types of brackets: `()`, `{}`, and `[]`. **Problem**: Design a function `is_valid_bracket_sequence` that validates a given string containing multiple types of brackets. A bracket sequence is considered valid if every opening bracket has a corresponding closing bracket in the correct order. **Input/Output**: - **Input**: A single string containing only the characters `()`, `{}`, `[]` - **Output**: Boolean value indicating whether the bracket sequence is valid. **Constraints**: - The length of the string will be between 0 and 1000 characters. - The string will only contain the characters `(`, `)`, `{`, `}`, `[`, `]`. **Function Signature**: ```python def is_valid_bracket_sequence(s: str) -> bool: pass ``` **Example**: ```python assert is_valid_bracket_sequence(\\"()\\") == True assert is_valid_bracket_sequence(\\"()[]{}\\") == True assert is_valid_bracket_sequence(\\"(]\\") == False assert is_valid_bracket_sequence(\\"([)]\\") == False assert is_valid_bracket_sequence(\\"{[]}\\") == True assert is_valid_bracket_sequence(\\"\\") == True assert is_valid_bracket_sequence(\\"({[)]\\") == False assert is_valid_bracket_sequence(\\"([{}])\\") == True assert is_valid_bracket_sequence(\\"{{{{}}}}\\") == True assert is_valid_bracket_sequence(\\"[(({})])\\") == False ``` You are expected to handle various edge cases and ensure the solution is efficient as per the constraints provided.","solution":"def is_valid_bracket_sequence(s: str) -> bool: Checks if the given string is a valid bracket sequence. stack = [] bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map: if not stack or stack.pop() != bracket_map[char]: return False return not stack"},{"question":"# Scenario Given an unweighted, undirected graph represented as an adjacency list, the task is to determine the shortest path from a given starting node to a target node. If the target node is not reachable from the start node, return -1. # Task Write a function `shortest_path(graph: Dict[int, List[int]], start: int, target: int) -> int` that takes a graph represented as an adjacency list, a starting node, and a target node, and returns the length of the shortest path between the start and target nodes. If no such path exists, return -1. Function Signature ```python def shortest_path(graph: Dict[int, List[int]], start: int, target: int) -> int: ``` # Input - `graph`: A dictionary where keys are integers representing nodes, and values are lists of integers representing the adjacency list of connected nodes. - `start`: An integer representing the starting node. - `target`: An integer representing the target node. # Output - An integer representing the length of the shortest path from the starting node to the target node. If the target node is not reachable, return -1. # Constraints - The graph contains at least 1 and at most 1000 nodes. - Each node can have between 0 and 1000 edges. - Node values are unique and are integers. - All nodes listed in the adjacency list and the start and target nodes are guaranteed to be part of the graph. # Example ```python graph = { 0: [1, 2], 1: [0, 3, 4], 2: [0, 5], 3: [1], 4: [1, 5], 5: [2, 4] } start = 0 target = 5 assert shortest_path(graph, start, target) == 2 ``` In this example, the shortest path from node 0 to node 5 is [0, 2, 5] or [0, 1, 4, 5], both having a length of 2. # Implementation Details - Use Breadth-First Search (BFS) to ensure the shortest path in an unweighted graph. - Handle any typical edge cases (e.g., no path exists, start and target are the same). - Assume valid input within the provided constraints.","solution":"from collections import deque def shortest_path(graph, start, target): if start == target: return 0 # Use BFS to find the shortest path queue = deque([(start, 0)]) visited = set() while queue: node, distance = queue.popleft() if node in visited: continue visited.add(node) for neighbor in graph[node]: if neighbor == target: return distance + 1 queue.append((neighbor, distance + 1)) return -1"},{"question":"# Coding Question Problem Statement Implement an algorithm that finds the `k` most frequent strings in a given list of strings. If multiple strings have the same frequency, return them in lexicographical order. You are required to implement both an efficient version using appropriate data structures and a straightforward version leveraging basic lists and iterative methods. Requirements 1. **Efficient Version**: - Input: A list of strings `words` and an integer `k`. - Output: A list of `k` most frequent strings sorted by frequency in descending order. If frequencies are equal, sort them lexicographically. 2. **Straightforward Version**: - Input: A list of strings `words` and an integer `k`. - Output: A list of `k` most frequent strings sorted by frequency in descending order. If frequencies are equal, sort them lexicographically. 3. **Constraints**: - The list `words` can have a length of up to `10^5`. - Each string can have a length of up to `100`. - The integer `k` is always a positive integer and `1 <= k <= len(words)`. 4. **Performance**: - The efficient version should aim to handle the input size within reasonable time limits. - The straightforward version should demonstrate a clear and correct approach, even if not optimal in performance. Example ```python # Efficient Version assert most_frequent_strings_efficient([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"banana\\"], 2) == [\\"banana\\", \\"apple\\"] assert most_frequent_strings_efficient([\\"apple\\", \\"apple\\", \\"banana\\", \\"banana\\", \\"orange\\"], 3) == [\\"apple\\", \\"banana\\", \\"orange\\"] # Straightforward Version assert most_frequent_strings_straightforward([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"banana\\"], 2) == [\\"banana\\", \\"apple\\"] assert most_frequent_strings_straightforward([\\"apple\\", \\"apple\\", \\"banana\\", \\"banana\\", \\"orange\\"], 3) == [\\"apple\\", \\"banana\\", \\"orange\\"] ``` Implementation Details Please implement the following two functions: ```python from typing import List def most_frequent_strings_efficient(words: List[str], k: int) -> List[str]: Find the k most frequent strings in the list efficiently. Parameters: words (list): List of strings. k (int): Number of most frequent strings to return. Returns: list: List of k most frequent strings sorted by frequency and lexicographically. # Your code here def most_frequent_strings_straightforward(words: List[str], k: int) -> List[str]: Find the k most frequent strings in the list using a straightforward method. Parameters: words (list): List of strings. k (int): Number of most frequent strings to return. Returns: list: List of k most frequent strings sorted by frequency and lexicographically. # Your code here ```","solution":"from typing import List from collections import Counter def most_frequent_strings_efficient(words: List[str], k: int) -> List[str]: Find the k most frequent strings in the list efficiently. Parameters: words (list): List of strings. k (int): Number of most frequent strings to return. Returns: list: List of k most frequent strings sorted by frequency and lexicographically. # Count the frequency of each word count = Counter(words) # Create a list of (word, frequency) tuples and sort it by # frequency (in descending order), then lexicographically (in ascending order) sorted_words = sorted(count.items(), key=lambda x: (-x[1], x[0])) # Extract the first k elements\' words return [word for word, _ in sorted_words[:k]] def most_frequent_strings_straightforward(words: List[str], k: int) -> List[str]: Find the k most frequent strings in the list using a straightforward method. Parameters: words (list): List of strings. k (int): Number of most frequent strings to return. Returns: list: List of k most frequent strings sorted by frequency and lexicographically. # Count the frequency of each word count = Counter(words) # Convert Counter dictionary to list of tuples freq_list = [(word, freq) for word, freq in count.items()] # Sort the list by frequency (in descending order), then lexicographically (in ascending order) freq_list.sort(key=lambda x: (-x[1], x[0])) # Extract the first k elements\' words return [word for word, _ in freq_list[:k]]"},{"question":"# Shortest Path in a Graph You are given a directed graph represented as an adjacency matrix, where the value at `graph[i][j]` represents the weight of the edge from node `i` to node `j`. If there is no edge between `i` and `j`, the weight is set to infinity (`float(\'inf\')`). Your task is to find the shortest path from a given source node to a destination node. # Problem Statement **Input:** - A 2D list `graph` of size `n x n` representing the adjacency matrix of the graph. - An integer `source`, which is the starting node. - An integer `destination`, which is the ending node. **Output:** - Returns the minimum distance from the source node to the destination node. If the destination node is unreachable from the source node, return `-1`. # Function Signature ```python def shortest_path(graph: List[List[float]], source: int, destination: int) -> int: ``` # Constraints: - 1 <= n <= 100 - 0 <= source, destination < n - 1 <= graph[i][j] <= 1000 or graph[i][j] = float(\'inf\') # Example: ```python >>> graph = [ ... [0, 3, float(\'inf\'), 7], ... [8, 0, 2, float(\'inf\')], ... [5, float(\'inf\'), 0, 1], ... [2, float(\'inf\'), float(\'inf\'), 0] ... ] >>> shortest_path(graph, 0, 3) 7 ``` # Explanation: - The given adjacency matrix represents the following graph: ``` 3 (0)----->(1) | ^ | | 7 2 | | (3)----->(2) 1 ``` - The shortest path from node `0` to node `3` has a total weight of `7`. # Additional Notes: - Ensure your implementation handles cases where the destination is unreachable by appropriately returning `-1`. - Consider using Dijkstra\'s algorithm or the Floyd-Warshall algorithm to find the shortest path. Choose the method that best fits the constraints and requirements of the problem. - The input graph will not contain any negative weight cycles.","solution":"from typing import List import heapq def shortest_path(graph: List[List[float]], source: int, destination: int) -> int: Returns the minimum distance from the source node to the destination node. If the destination node is unreachable from the source node, return -1. n = len(graph) # Initialize distances array with infinity distances = [float(\'inf\')] * n distances[source] = 0 # Min-heap priority queue pq = [(0, source)] # (distance, node) while pq: current_distance, current_node = heapq.heappop(pq) # If we reach the destination node if current_node == destination: return current_distance # Ignore nodes with outdated distances if current_distance > distances[current_node]: continue for neighbor in range(n): edge_weight = graph[current_node][neighbor] if edge_weight != float(\'inf\'): # There\'s an edge distance = current_distance + edge_weight # If found a shorter path to neighbor if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) # If the destination is unreachable return -1 if distances[destination] == float(\'inf\') else distances[destination]"},{"question":"# Unique Substring Count in Sliding Window Objective: You are required to implement a function that determines the number of unique substrings of a given length from a given string using a sliding window approach. Input: - A string `s` consisting of lowercase English alphabets. - An integer `k` representing the length of substrings to consider. Output: - An integer representing the number of unique substrings of length `k` in the string `s`. Constraints: - `1 <= k <= len(s)` (the length of the substrings will be positive and less than or equal to the length of the string) - The string `s` consists only of lowercase English alphabets. Example Scenarios: ```python def count_unique_substrings(s: str, k: int) -> int: >>> count_unique_substrings(\\"abcabc\\", 3) 3 >>> count_unique_substrings(\\"aaaaa\\", 2) 1 >>> count_unique_substrings(\\"abcd\\", 1) 4 >>> count_unique_substrings(\\"abcd\\", 4) 1 if k > len(s): return 0 # If k is greater than string length, no substrings of length k. unique_substrings = set() for i in range(len(s) - k + 1): substring = s[i:i+k] unique_substrings.add(substring) return len(unique_substrings) ``` Explanation: To solve this problem: 1. Use a set `unique_substrings` to store unique substrings of length `k`. 2. Iterate over the string `s` with a sliding window of length `k`. 3. Extract each substring of length `k` and add it to the set. 4. The final result is the size of the set, representing the count of unique substrings. Implement the `count_unique_substrings` function in Python and verify its correctness using the provided examples in the docstring.","solution":"def count_unique_substrings(s: str, k: int) -> int: Counts the number of unique substrings of length k in the string s. Parameters: s (str): The input string consisting of lowercase English alphabets. k (int): The length of the substrings to consider. Returns: int: The number of unique substrings of length k. if k > len(s): return 0 # If k is greater than string length, no substrings of length k. unique_substrings = set() for i in range(len(s) - k + 1): substring = s[i:i+k] unique_substrings.add(substring) return len(unique_substrings)"},{"question":"# Question: Evaluate Polynomial Sum You are given a polynomial represented by its coefficients in an integer list `coefficients`, where each element at index `i` signifies the coefficient of `x^i`. Additionally, you are provided an integer `n` which represents the value at which the polynomial must be evaluated. Write a function to calculate and return the value of the polynomial evaluated at `n`. # Input * A list of integers `coefficients` where each `coefficients[i]` is the coefficient of `x^i`. * An integer `n` representing the value at which the polynomial is evaluated (1 ≤ n ≤ 100). # Output * Return an integer representing the value of the polynomial evaluated at `n`. # Constraints * The length of `coefficients` will be between 1 and 100. * Each coefficient in the list can be between -100 and 100. * The result will always fit within a 32-bit signed integer range. # Example Input ```python coefficients = [1, 0, 2, 3] n = 2 ``` Output ```python 29 ``` Explanation For the polynomial 1 + 0*x + 2*x² + 3*x³, evaluated at x = 2: 1 + 0*2 + 2*(2^2) + 3*(2^3) = 1 + 0 + 8 + 24 = 33 # Function Signature ```python def evaluate_polynomial(coefficients: List[int], n: int) -> int: pass ```","solution":"from typing import List def evaluate_polynomial(coefficients: List[int], n: int) -> int: Returns the value of the polynomial evaluated at n. Parameters: coefficients (list): A list of integers representing the polynomial coefficients. n (int): The value at which the polynomial is evaluated. Returns: int: The result of the polynomial evaluation. result = 0 for power, coefficient in enumerate(coefficients): result += coefficient * (n ** power) return result"},{"question":"Coding Assessment Question: Design and implement a MinHeap data structure that supports the following operations: insert, find_min, extract_min, and decrease_key. The implementation needs to maintain the properties of a MinHeap and ensure that all operations perform efficiently. **Requirements**: - Your implementation must ensure that the heap property (where the parent node is less than or equal to its children) is maintained. - The insert, find_min, and decrease_key operations should function with (O(log n)) time complexity, where (n) is the number of elements in the heap. - The extract_min operation must have an (O(log n)) time complexity. - Support dynamic key updates using the decrease_key method. **Function Specifications**: - **insert(item: int) -> None**: Inserts an element into the heap. - **find_min() -> int | None**: Returns the smallest element in the heap without removing it. Returns `None` if the heap is empty. - **extract_min() -> int**: Removes and returns the smallest element in the heap. Raises an `IndexError` if the heap is empty. - **decrease_key(index: int, new_value: int) -> None**: Decreases the value of the element at the provided index to the new_value. Raises a `ValueError` if the new_value is greater than the current value at the specified index. **Constraints**: - The maximum number of elements in the heap will not exceed (10^5). - Operations should handle edge scenarios gracefully (e.g., find_min or extract_min on an empty heap). **Example**: ```python >>> min_heap = MinHeap() >>> min_heap.insert(5) >>> min_heap.insert(3) >>> min_heap.insert(8) >>> min_heap.find_min() 3 >>> min_heap.extract_min() 3 >>> min_heap.find_min() 5 >>> min_heap.insert(2) >>> min_heap.decrease_key(1, 1) >>> min_heap.find_min() 1 >>> min_heap.extract_min() 1 >>> min_heap.extract_min() 2 >>> min_heap.extract_min() 8 >>> min_heap.find_min() is None True >>> min_heap.extract_min() Traceback (most recent call last): ... IndexError: extract_min from an empty heap ``` Implement the MinHeap data structure ensuring efficiency and correctness of all operations.","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, item): self.heap.append(item) self._sift_up(len(self.heap) - 1) def find_min(self): if not self.heap: return None return self.heap[0] def extract_min(self): if not self.heap: raise IndexError(\\"extract_min from an empty heap\\") min_item = self.heap[0] last_item = self.heap.pop() if self.heap: self.heap[0] = last_item self._sift_down(0) return min_item def decrease_key(self, index, new_value): if new_value > self.heap[index]: raise ValueError(\\"new_value is greater than current value\\") self.heap[index] = new_value self._sift_up(index) def _sift_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._sift_up(parent_index) def _sift_down(self, index): smallest = index left_child = 2 * index + 1 right_child = 2 * index + 2 if left_child < len(self.heap) and self.heap[left_child] < self.heap[smallest]: smallest = left_child if right_child < len(self.heap) and self.heap[right_child] < self.heap[smallest]: smallest = right_child if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._sift_down(smallest)"},{"question":"# Depth-First Search to Find All Words in a Character Grid **Problem Statement**: Given a `m x n` grid of characters and a list of words, find all words that can be formed by characters in the grid. Each word must be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell cannot be used more than once for any word. # Function Signature ```python def find_words(grid: list[list[str]], words: list[str]) -> list[str]: pass ``` # Input - A grid of size `m x n` where each element is a lowercase English letter. - A list of words containing lowercase English letters. # Output - Return a list of words that can be formed by the grid\'s characters. # Constraints - `1 <= m, n <= 10` - `1 <= len(words) <= 100` - `1 <= len(words[i]) <= 10` # Example ```python grid = [ [\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\'] ] words = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] assert sorted(find_words(grid, words)) == sorted([\\"oath\\", \\"eat\\"]) grid = [ [\'a\',\'b\'], [\'c\',\'d\'] ] words = [\\"abcb\\"] assert find_words(grid, words) == [] ``` # Detailed Explanation: 1. Implement the function `find_words` which will take the grid and the list of words as input and returns a list of found words. 2. Use Depth-First Search (DFS) algorithm to traverse the grid, exploring all possible paths for each word in the list. 3. Ensure that a cell is not reused within the same word path by marking the cell as visited. 4. Check and validate against provided test cases to ensure the algorithm correctly finds all words according to the problem constraints.","solution":"def find_words(grid, words): def dfs(x, y, word, index): if index == len(word): return True if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != word[index]: return False temp = grid[x][y] grid[x][y] = \'\' found = (dfs(x + 1, y, word, index + 1) or dfs(x - 1, y, word, index + 1) or dfs(x, y + 1, word, index + 1) or dfs(x, y - 1, word, index + 1)) grid[x][y] = temp return found found_words = [] for word in words: for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == word[0] and dfs(i, j, word, 0): found_words.append(word) break return found_words"},{"question":"# Context You are developing an application that processes strings for cryptographic purposes. Part of the application needs to check for the unique arrangement of characters in a string. One of the specific requirements is to determine whether a given string is a permutation of a palindrome. # Task Implement the function `is_palindrome_permutation(s: str) -> bool` to determine if the input string is a permutation of a palindrome. # Input and Output * **Input**: * `s` (str): A string that may contain any of the 128 ASCII characters. * **Output**: * A boolean, `True` if the string is a permutation of a palindrome, `False` otherwise. # Constraints * The string may contain spaces and is case-insensitive. * You should ignore spaces and treat uppercase and lowercase letters as the same character. # Example ```python print(is_palindrome_permutation(\\"Tact Coa\\")) # Expected Output: True # Explanation: \\"Tact Coa\\" can be rearranged to \\"tacocat\\" which is a palindrome. print(is_palindrome_permutation(\\"hello\\")) # Expected Output: False # Explanation: \\"hello\\" cannot be rearranged to form any palindrome. ``` # Performance Requirements The function should run in O(n) time complexity, where `n` is the length of the string. The function should be designed to handle strings up to 10,000 characters efficiently. # Note You do not need to handle input validation. Assume all input provided will be valid according to the constraints.","solution":"def is_palindrome_permutation(s: str) -> bool: Determine if the input string is a permutation of a palindrome. :param s: Input string that may contain spaces and different cases :return: True if the string can be rearranged to form a palindrome, False otherwise # Normalize the string: convert to lowercase and remove non-alphanumeric characters (spaces) s = s.lower() s = [char for char in s if char.isalnum()] # Count the frequency of each character char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Check the number of characters with odd counts odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # A string can be rearranged to form a palindrome if at most one character has an odd count return odd_count <= 1"},{"question":"# Coding Assessment Question You are given two functions implemented using the NumPy library: 1. **is_symmetric(matrix: np.ndarray) -> bool**: This function checks if a given matrix is symmetric. 2. **frobenius_norm(matrix: np.ndarray) -> float**: This function calculates the Frobenius norm of a given matrix. Your task is to extend the given functionality in the following ways: 1. Implement a function `closest_symmetric(matrix: np.ndarray) -> np.ndarray` that takes a non-symmetric matrix and returns the closest symmetric matrix to it in terms of the Frobenius norm. The closest symmetric matrix (A_s) to a given matrix (A) can be found as follows: [ A_s = frac{A + A^T}{2} ] 2. Ensure your function handles edge cases, such as non-square matrices, raising an appropriate error if the input matrix is not square. 3. Provide adequate tests for your solution. Function Signature: ```python def closest_symmetric(matrix: np.ndarray) -> np.ndarray: pass ``` # Input: * `matrix`: A square matrix (n times n) (NumPy array) which may not be symmetric. # Output: * Returns the closest symmetric matrix (A_s) (NumPy array). # Constraints: * The input matrix is guaranteed to be square. # Example: ```python import numpy as np A = np.array([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) sym_matrix = closest_symmetric(A) print(\\"Closest Symmetric Matrix:n\\", sym_matrix) ``` # Expected Output: ```python Closest Symmetric Matrix: [[1. 3. 5.] [3. 5. 7.] [5. 7. 9.]] ``` Ensure to test your solution thoroughly and consider edge cases.","solution":"import numpy as np def closest_symmetric(matrix: np.ndarray) -> np.ndarray: Returns the closest symmetric matrix to the given matrix in terms of the Frobenius norm. # Ensure the matrix is square if matrix.shape[0] != matrix.shape[1]: raise ValueError(\\"Input matrix must be square\\") # Calculate the closest symmetric matrix symmetric_matrix = (matrix + matrix.T) / 2.0 return symmetric_matrix"},{"question":"# Question: Optimization of Array Operations **Scenario**: You are part of the development team for a large e-commerce platform. To optimize various array operations, your team has decided to implement a class that can handle the following set of operations efficiently: **Your Task:** Design a class, `ArrayOps`, that supports the following methods: 1. **initialize(arr)**: Accepts an initial list of integers, `arr`. 2. **update(index, value)**: Update the element at `index` to `value`. 3. **get_sum(start, end)**: Return the sum of elements from `start` to `end` (inclusive). 4. **get_max(start, end)**: Return the maximum element from `start` to `end` (inclusive). 5. **multiplication(start, end)**: Return the product of elements from `start` to `end` (inclusive). **Input and Output Format:** - `initialize(arr)` accepts a list of integers. - `update(index, value)` has no return value. - `get_sum(start, end)` returns an integer. - `get_max(start, end)` returns an integer. - `multiplication(start, end)` returns an integer. **Constraints:** - The length of `arr` will be at most 10^5. - The value of each element in `arr` and `value` can be up to 10^9. - 0 <= index < length of `arr` - 0 <= start <= end < length of `arr` **Example:** ```python ops = ArrayOps() ops.initialize([1, 3, 5, 7, 9, 11]) print(ops.get_sum(1, 3)) # Output: 15 (i.e., 3 + 5 + 7) print(ops.get_max(0, 5)) # Output: 11 ops.update(2, 6) print(ops.multiplication(1, 3)) # Output: 126 (i.e., 3 * 6 * 7) ``` **Requirements:** - Implement the `ArrayOps` class with methods that efficiently perform the specified operations, considering the constraints and potential size of the data. - Ensure that updates, queries, and range operations are optimized for performance.","solution":"class ArrayOps: def initialize(self, arr): self.arr = arr def update(self, index, value): if 0 <= index < len(self.arr): self.arr[index] = value def get_sum(self, start, end): if 0 <= start <= end < len(self.arr): return sum(self.arr[start:end + 1]) def get_max(self, start, end): if 0 <= start <= end < len(self.arr): return max(self.arr[start:end + 1]) def multiplication(self, start, end): if 0 <= start <= end < len(self.arr): product = 1 for num in self.arr[start:end + 1]: product *= num return product"},{"question":"# Problem Statement You are tasked with implementing a function to determine if a given integer `n` is a prime number. The major constraint is that your solution should have a time complexity of O(sqrt(n)). # Input and Output * **Input**: A single integer `n` (2 <= n <= 1,000,000), which is the number you need to check for primality. * **Output**: A boolean value, `True` if `n` is a prime number, otherwise `False`. # Function Signature ```python def is_prime(n: int) -> bool: pass ``` # Example ```python assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(29) == True assert is_prime(1000000) == False ``` # Constraints 1. The function should raise a `ValueError` for input values less than 2. # Hints 1. Recall that a number is prime if it has no divisors other than 1 and itself. 2. To optimize, check divisors up to the square root of `n`.","solution":"import math def is_prime(n: int) -> bool: Determines if a given integer n is a prime number. Parameters: n (int): The number to check for primality Returns: bool: True if n is a prime number, False otherwise Raises: ValueError: If n is less than 2 if n < 2: raise ValueError(\\"Input number must be greater than or equal to 2\\") if n == 2: return True if n % 2 == 0: return False for i in range(3, int(math.isqrt(n)) + 1, 2): if n % i == 0: return False return True"},{"question":"# Question: Find First Non-Repeated Character You are asked to implement a function that finds the first character in a given string that does not repeat. The function should be case sensitive and handle edge cases such as an empty string or a string where all characters are repeated. Input: - A single string `s`. Output: - A string containing the first non-repeated character. - If all characters are repeated or the string is empty, return an empty string. Constraints: - The input string will contain only printable ASCII characters. Examples: ```python def first_non_repeated_char(s: str) -> str: Find the first non-repeated character in a given string. :param s: str: The input string. :return: str: The first non-repeated character or an empty string if none exist. Examples: >>> first_non_repeated_char(\\"swiss\\") \'w\' >>> first_non_repeated_char(\\"repetition\\") \'r\' >>> first_non_repeated_char(\\"aabbcc\\") \'\' >>> first_non_repeated_char(\\"\\") \'\' >>> first_non_repeated_char(\\"aAaBbCc\\") \'A\' from collections import OrderedDict frequency = OrderedDict() for char in s: frequency[char] = frequency.get(char, 0) + 1 for char, count in frequency.items(): if count == 1: return char return \\"\\" if __name__ == \\"__main__\\": from doctest import testmod testmod() ``` Your task is to implement the `first_non_repeated_char` function following the specifications above.","solution":"def first_non_repeated_char(s: str) -> str: Find the first non-repeated character in a given string. :param s: str: The input string. :return: str: The first non-repeated character or an empty string if none exist. from collections import OrderedDict # Use an OrderedDict to store the frequency of each character frequency = OrderedDict() # Traverse the string and count the frequency of each character for char in s: frequency[char] = frequency.get(char, 0) + 1 # Traverse the OrderedDict and return the first character that has a count of 1 for char, count in frequency.items(): if count == 1: return char # If no non-repeated character found, return an empty string return \\"\\""},{"question":"# Coding Assessment Question Context A robotics company is developing a warehouse navigation system for their robots. Each robot is given a sequence of commands to follow in order to reach their destinations within the warehouse. Commands comprise movements in the cardinal directions (N, E, S, W) and can be repeated multiple times. The company needs a function that interprets these commands and determines the final position of the robot. Objective Write a function `final_robot_position(commands: list[str]) -> tuple[int, int]` that evaluates a series of movement commands and returns the final position of the robot starting from (0, 0). Each command is a string that includes a direction and an integer indicating the number of steps in that direction. Input and Output - **Input**: A list of commands where each command is a string formatted as \\"DIRECTION STEPS\\". `DIRECTION` is one of \\"N\\", \\"E\\", \\"S\\", \\"W\\" and `STEPS` is a positive integer. - **Output**: A tuple `(x, y)` representing the final coordinates of the robot after executing all commands. Constraints - The length of the `commands` list will be between 0 and 1000 inclusive. - Each `STEPS` value will be between 1 and 100 inclusive. - Valid `DIRECTION` values are \\"N\\", \\"E\\", \\"S\\", \\"W\\". Example ```python def final_robot_position(commands: list[str]) -> tuple[int, int]: Calculate the final position of a robot given a list of movement commands. Args: - commands (list[str]): List of movement commands. Returns: - tuple[int, int]: Final coordinates of the robot. pass # Your implementation goes here # Example Usage commands = [\\"N 3\\", \\"E 2\\", \\"S 1\\", \\"W 4\\", \\"E 1\\"] print(final_robot_position(commands)) # Output: (-1, 2) commands = [\\"E 10\\", \\"N 5\\", \\"W 20\\"] print(final_robot_position(commands)) # Output: (-10, 5) ``` Notes - Assume the initial position of the robot is (0, 0). - Movements should be cumulative. - Ensure the function handles an empty list of commands gracefully by returning the origin (0, 0).","solution":"def final_robot_position(commands: list[str]) -> tuple[int, int]: Calculate the final position of a robot given a list of movement commands. Args: - commands (list[str]): List of movement commands. Returns: - tuple[int, int]: Final coordinates of the robot. x, y = 0, 0 for command in commands: direction, steps = command.split() steps = int(steps) if direction == \\"N\\": y += steps elif direction == \\"E\\": x += steps elif direction == \\"S\\": y -= steps elif direction == \\"W\\": x -= steps return (x, y)"},{"question":"# Scenario You are working on a system that processes and modifies data sets represented by arrays. One of the functionalities involves the transformation of an array based on certain rules, creating a new array from the original one. Specifically, you need to implement a function that constructs a new array where each element at index `i` is the product of all elements in the original array except the one at `i`. # Task You need to write a function, `construct_array`, which takes in an array of integers and produces a new array based on the described transformation. # Details 1. **construct_array(arr: List[int]) -> List[int]**: * Takes an array of integers and returns a new array where each element at index `i` is the product of all elements in the original array except the one at `i`. # Input and Output * **Input Format**: * The input consists of a list of integers `arr`. * `arr` can contain positive, negative, and zero values. * **Output Format**: * The function should return the transformed list of integers. # Constraints * The array will have at least two elements and at most 10^4 elements. * The product of all elements except the one at `i` should be computed without using division. # Examples * Example 1: ```python construct_array([1, 2, 3, 4]) # [24, 12, 8, 6] ``` * Example 2: ```python construct_array([0, 1, 2, 3]) # [6, 0, 0, 0] ``` # Additional Considerations 1. Ensure your solution handles edge cases correctly, such as arrays containing zeros, negative numbers, or very large or very small values. 2. Strive to implement the function efficiently to accommodate the upper limits of the constraints without significant performance degradation.","solution":"def construct_array(arr): Returns a new array where each element at index `i` is the product of all elements in the original array except the one at `i`. n = len(arr) # Initialize the result array with ones result = [1] * n # Compute the prefix products prefix_product = 1 for i in range(n): result[i] = prefix_product prefix_product *= arr[i] # Compute the suffix products and combine with prefix products suffix_product = 1 for i in range(n-1, -1, -1): result[i] *= suffix_product suffix_product *= arr[i] return result"},{"question":"# Scenario: You\'re a software engineer working on an application that helps users manage their reading habits. One of the features allows users to track their progress in different books. Each book can be marked with the pages the user has already read. Your task is to write a function that helps users find the first unread page in a book, given the pages they\'ve read and the total number of pages in the book. # Task: Write a function named `first_unread_page` that determines the first unread page in a book. # Function Definition: **first_unread_page(read_pages: list, total_pages: int) -> int** # Input and Output Format: - **Input**: - `read_pages` (list): A list of integers representing the pages the user has read (1-based). - `total_pages` (int): An integer representing the total number of pages in the book. - **Output**: - Returns the page number of the first unread page as an integer. - If all pages have been read, return `-1`. # Constraints: 1. `read_pages` will contain integers in the range [1, `total_pages`]. 2. The length of `read_pages` will be between 0 and `total_pages`. 3. `total_pages` will be a positive integer. 4. Each page number in `read_pages` will be unique. # Examples: - **Example 1**: ```python first_unread_page([1, 2, 4, 5], 6) # Output: 3 ``` - **Example 2**: ```python first_unread_page([1, 2, 3, 4, 5, 6], 6) # Output: -1 ```","solution":"def first_unread_page(read_pages, total_pages): Determines the first unread page in a book. # Create a set of read pages for quick lookup read_pages_set = set(read_pages) # Iterate through the range of pages 1 to total_pages for page in range(1, total_pages + 1): if page not in read_pages_set: return page # If all pages are read, return -1 return -1"},{"question":"Matrix Transformation You are tasked with implementing a matrix transformation function that flips a given square matrix diagonally. In other words, the function should swap the matrix\'s elements on the primary diagonal with the corresponding elements on the secondary diagonal. # Function Specification **Function**: `diagonal_flip(matrix: List[List[int]]) -> List[List[int]]` Input - `matrix` (List[List[int]]): A 2D list representing an `n x n` square matrix of integers. Output - `List[List[int]]`: A 2D list of the same dimensions as the input, where the primary diagonal elements are swapped with the secondary diagonal elements. Constraints - The input `matrix` will always be a square matrix with dimensions `n x n` where `2 <= n <= 100`. # Example ```python # Input matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Output # Result after flipping diagonals output = diagonal_flip(matrix) print(output) # Expected: [ # [3, 2, 1], # [4, 5, 6], # [9, 8, 7] # ] ``` Explanation In the example above: - The primary diagonal elements (1, 5, 9) are swapped with the secondary diagonal elements (3, 5, 7). # Notes: - The primary diagonal of a matrix consists of elements where the row index is equal to the column index. - The secondary diagonal of a matrix consists of elements where the sum of the row index and column index is `n-1`. - Ensure that the implementation handles all edge cases, including non-square matrices and matrices with minimum and maximum dimensions.","solution":"from typing import List def diagonal_flip(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) for i in range(n): # Swap primary diagonal element and secondary diagonal element matrix[i][i], matrix[i][n - i - 1] = matrix[i][n - i - 1], matrix[i][i] return matrix"},{"question":"# Dynamic Programming: Subset Sum Problem Your task is to implement a solution to determine if there exists a subset of a given set of positive integers that sums up to a target value. The problem involves using dynamic programming to efficiently find the solution. Function Signature: ```python def subset_sum(nums: list[int], target: int) -> bool: ``` - **Input**: - `nums`: A list of positive integers representing the set. - `target`: An integer representing the target sum value. - **Output**: - `True` if there exists a subset of `nums` that sums up to `target`. - `False` otherwise. Constraints: - The length of the list `nums` must not exceed 100. - Each number in the list must be a positive integer and must not exceed 1000. - The value of `target` must be a non-negative integer and must not exceed the sum of the list `nums`. Example: ```python nums = [2, 3, 7, 8, 10] target = 11 result = subset_sum(nums, target) print(result) # Output should be True because 3 + 8 = 11 ``` Example: ```python nums = [1, 2, 3, 4, 5] target = 10 result = subset_sum(nums, target) print(result) # Output should be True because 1 + 2 + 3 + 4 = 10 ``` Notes: - Solve the problem using dynamic programming to ensure efficiency. - Pay attention to edge cases where the list may be empty or where the target is zero. - Consider the time complexity and ensure the solution runs in a reasonable time frame for all allowable inputs.","solution":"def subset_sum(nums: list[int], target: int) -> bool: # Initialize a list to keep track of possible sums up to the target value. dp = [False] * (target + 1) dp[0] = True # There\'s always a subset with sum 0, the empty subset. # Iterate over each number in the list. for num in nums: # Update the dp array in reverse to ensure we do not reuse the same element. for t in range(target, num - 1, -1): dp[t] = dp[t] or dp[t - num] return dp[target]"},{"question":"# Ticket Booking System for a Movie Theater **Context**: You are to design and implement a ticket booking system for a small movie theater. The theater has a limited number of seats organized in rows and aisles. Customers can book, cancel, or check if specific seats are available. Task Implement a class `Theater` with methods to manage seat bookings. The class should support initializing the theater\'s seating arrangement, booking seats, canceling bookings, and checking seat availability. Class Signature ```python class Theater: def __init__(self, rows: int, columns: int): pass def book_seat(self, row: int, col: int) -> str: pass def cancel_booking(self, row: int, col: int) -> str: pass def check_seat(self, row: int, col: int) -> bool: pass ``` Method Descriptions 1. **`__init__(self, rows: int, columns: int)`**: - This constructor initializes the seating arrangement with the specified number of rows and columns. All seats are initially available. 2. **`book_seat(self, row: int, col: int) -> str`**: - Books the seat at the specified row and column if available, and returns a confirmation message. - If the seat is already booked or the coordinates are out of range, return an appropriate error message. 3. **`cancel_booking(self, row: int, col: int) -> str`**: - Cancels the booking for the seat at the specified row and column if it was previously booked, and returns a cancellation message. - If the seat was not booked or the coordinates are out of range, return an appropriate error message. 4. **`check_seat(self, row: int, col: int) -> bool`**: - Returns `True` if the specified seat is available, otherwise returns `False`. Input Parameters * `rows`: Integer, the number of rows in the theater. * `columns`: Integer, the number of columns in the theater. - For methods `book_seat`, `cancel_booking`, and `check_seat`: * `row`: Integer, the row number of the seat (1-indexed). * `col`: Integer, the column number of the seat (1-indexed). Output Format * The `book_seat` method should return one of the following messages: - \\"Seat (row, col) booked successfully.\\" - \\"Seat (row, col) is already booked.\\" - \\"Invalid seat coordinates.\\" * The `cancel_booking` method should return one of the following messages: - \\"Booking for seat (row, col) canceled.\\" - \\"Seat (row, col) is not booked.\\" - \\"Invalid seat coordinates.\\" * The `check_seat` method should return: - `True` if the seat is available. - `False` if the seat is booked or the coordinates are out of range. Constraints * Ensure methods handle invalid coordinates gracefully. * Optimize for seat look-up operations since these will be frequent. Example ```python theater = Theater(3, 3) print(theater.book_seat(1, 1)) # Expected output: \\"Seat (1, 1) booked successfully.\\" print(theater.book_seat(1, 1)) # Expected output: \\"Seat (1, 1) is already booked.\\" print(theater.check_seat(1, 1)) # Expected output: False print(theater.check_seat(2, 2)) # Expected output: True print(theater.cancel_booking(1, 1)) # Expected output: \\"Booking for seat (1, 1) canceled.\\" print(theater.cancel_booking(1, 1)) # Expected output: \\"Seat (1, 1) is not booked.\\" ``` --- Implementation Notes 1. **Initialization**: - Construct the theater with a 2D array representing rows and columns of seats. - Mark all seats as available initially. 2. **Booking**: - Check if the seat is within valid range and then verify availability before booking. 3. **Cancellation**: - Check booking status of the seat and ensure valid cancellation. 4. **Check Seat**: - Provide immediate feedback on seat availability, ensuring edges cases are handled gracefully.","solution":"class Theater: def __init__(self, rows: int, columns: int): # Initialize a 2D array with all seats marked as available (True) self.seats = [[True for _ in range(columns)] for _ in range(rows)] self.rows = rows self.columns = columns def is_valid_seat(self, row: int, col: int) -> bool: # Check if the seat coordinates are within the valid range return 0 <= row < self.rows and 0 <= col < self.columns def book_seat(self, row: int, col: int) -> str: if not self.is_valid_seat(row-1, col-1): return \\"Invalid seat coordinates.\\" if self.seats[row-1][col-1]: self.seats[row-1][col-1] = False return f\\"Seat ({row}, {col}) booked successfully.\\" return f\\"Seat ({row}, {col}) is already booked.\\" def cancel_booking(self, row: int, col: int) -> str: if not self.is_valid_seat(row-1, col-1): return \\"Invalid seat coordinates.\\" if not self.seats[row-1][col-1]: self.seats[row-1][col-1] = True return f\\"Booking for seat ({row}, {col}) canceled.\\" return f\\"Seat ({row}, {col}) is not booked.\\" def check_seat(self, row: int, col: int) -> bool: if not self.is_valid_seat(row-1, col-1): return False return self.seats[row-1][col-1]"},{"question":"# Coding Assessment Question As a software engineer at a data analytics firm, you are tasked with building a utility to parse and analyze a dataset of sales transactions to extract meaningful insights for the business. The dataset is provided as a CSV file, with each row representing a sale transaction. Your task is to: 1. Write a function to read and parse the CSV file into a list of dictionaries, ensuring robust handling of different data anomalies. 2. Implement a function that can summarize the total sales for each unique product in the dataset. 3. Include brief documentation for your functions. Expected Input and Output **Function 1**: `def read_csv(file_path: str) -> list[dict[str, str]]`: Read and parse the CSV file into a list of dictionaries. - **Input**: A file path (str) to the CSV file. - **Output**: A list of dictionaries representing each row in the CSV file. **Function 2**: `def summarize_sales(transactions: list[dict[str, str]]) -> dict[str, float]`: Summarize the total sales for each unique product. - **Input**: A list of dictionaries where each dictionary represents a transaction. - **Output**: A dictionary with product names as keys and total sales as values. # Constraints - Ensure your CSV parser can handle missing values, extra commas, and incorrect data formats gracefully. - Handle large files efficiently, avoiding excessive memory usage. - Assume the CSV file has a header row with column names. - Example columns in the CSV file: \\"Product Name\\", \\"Quantity Sold\\", \\"Price Per Unit\\", \\"Date of Sale\\". - Ensure the correct conversion of data types (e.g., \\"Quantity Sold\\" to int, \\"Price Per Unit\\" to float, etc.). - Include proper error handling for file not found, read errors, and invalid data. Example Usage ```python # CSV file content: # Product Name,Quantity Sold,Price Per Unit,Date of Sale # Widget A,10,2.99,2023-01-15 # Gadget B,5,5.49,2023-01-16 # Widget A,7,2.99,2023-01-17 # ... # Function Call 1: transactions = read_csv(\'sales_data.csv\') # Function Call 2: sales_summary = summarize_sales(transactions) # Expected Output: {\'Widget A\': 50.83, \'Gadget B\': 27.45} print(sales_summary) ``` - Ensure all possible edge cases are considered, including empty datasets and invalid data format. - Optimize the functions to handle real-time updates on sales data promptly.","solution":"import csv def read_csv(file_path: str) -> list[dict[str, str]]: Reads and parses a CSV file into a list of dictionaries. Args: - file_path (str): Path to the CSV file. Returns: - list[dict[str, str]]: A list of dictionaries where each dictionary represents a row in the CSV file. transactions = [] try: with open(file_path, mode=\'r\', newline=\'\', encoding=\'utf-8\') as file: csv_reader = csv.DictReader(file) for row in csv_reader: transactions.append(row) except FileNotFoundError: print(f\\"The file {file_path} does not exist.\\") except csv.Error as e: print(f\\"Error reading CSV file at line {csv_reader.line_num}: {e}\\") return transactions def summarize_sales(transactions: list[dict[str, str]]) -> dict[str, float]: Summarizes the total sales for each unique product. Args: - transactions (list[dict[str, str]]): A list of dictionaries where each dictionary represents a transaction. Returns: - dict[str, float]: A dictionary with product names as keys and total sales as values. sales_summary = {} for transaction in transactions: try: product_name = transaction[\\"Product Name\\"] quantity_sold = int(transaction[\\"Quantity Sold\\"]) # Assume this is a required field and always valid. price_per_unit = float(transaction[\\"Price Per Unit\\"]) # Assume this is a required field and always valid. total_sale = quantity_sold * price_per_unit if product_name in sales_summary: sales_summary[product_name] += total_sale else: sales_summary[product_name] = total_sale except (ValueError, KeyError) as e: print(f\\"Error processing transaction: {transaction}. Error: {e}\\") return sales_summary"},{"question":"# Question: You are given a list of integers. Your task is to determine the smallest positive integer (greater than 0) that cannot be represented as the sum of any subset of the given list. Write a Python function `smallest_unrepresentable_sum` that takes a list of integers, `nums`, as input and returns the smallest positive integer that cannot be represented as a sum of any subset of `nums`. Input Format: - A list of integers `nums` (1 ≤ len(nums) ≤ 1000, 1 ≤ nums[i] ≤ 1000). Output Format: - An integer representing the smallest positive integer that cannot be represented as a sum of any subset of the given list. Constraints: - The function should handle small and large lists efficiently. - The integers in the list are all positive. - You should consider sums of subsets, including the empty subset. Example: ```python def smallest_unrepresentable_sum(nums: list) -> int: pass assert smallest_unrepresentable_sum([1, 2, 3]) == 7 assert smallest_unrepresentable_sum([1, 2, 5]) == 4 assert smallest_unrepresentable_sum([1, 2, 3, 7]) == 14 assert smallest_unrepresentable_sum([1, 1, 3, 4]) == 10 assert smallest_unrepresentable_sum([1, 6, 9, 10]) == 2 ``` Provide your implementation of the `smallest_unrepresentable_sum` function below: ```python def smallest_unrepresentable_sum(nums: list) -> int: nums.sort() smallest_sum = 1 for num in nums: if num > smallest_sum: break smallest_sum += num return smallest_sum # Test cases for validation print(smallest_unrepresentable_sum([1, 2, 3])) # Expected: 7 print(smallest_unrepresentable_sum([1, 2, 5])) # Expected: 4 print(smallest_unrepresentable_sum([1, 2, 3, 7])) # Expected: 14 print(smallest_unrepresentable_sum([1, 1, 3, 4])) # Expected: 10 print(smallest_unrepresentable_sum([1, 6, 9, 10])) # Expected: 2 ``` Ensure your function handles edge cases and optimizes for performance and memory utilization.","solution":"def smallest_unrepresentable_sum(nums: list) -> int: Given a list of integers, determine the smallest positive integer that cannot be represented as the sum of any subset of the list. nums.sort() smallest_sum = 1 for num in nums: if num > smallest_sum: break smallest_sum += num return smallest_sum"},{"question":"# Problem Statement You are developing a task scheduler that organizes tasks with dependencies. Each task is represented by a unique integer, and its dependencies are given as a list of pairs where each pair `[a, b]` indicates that task `a` must be completed before task `b`. Write a function `can_finish_tasks(num_tasks: int, dependencies: List[Tuple[int, int]]) -> bool` that determines if it\'s possible to complete all tasks given the dependencies. **Constraints**: 1. The input integer `num_tasks` is greater than or equal to 1. 2. Dependencies do not form direct cycles. **Input**: - `num_tasks`: An integer representing the total number of tasks. - `dependencies`: A list of tuples where each tuple contains two integers representing a dependency between tasks. **Output**: - A boolean value `True` if it\'s possible to complete all tasks, `False` otherwise. **Example**: ```python # Example 1 num_tasks = 4 dependencies = [(1, 0), (2, 1), (3, 2)] assert can_finish_tasks(num_tasks, dependencies) == True # Example 2 num_tasks = 2 dependencies = [(1, 0), (0, 1)] assert can_finish_tasks(num_tasks, dependencies) == False ``` **Explanation**: - In the first example, the tasks can be completed in the order [0, 1, 2, 3]. - In the second example, there is a cyclic dependency between tasks 0 and 1, making it impossible to complete all tasks.","solution":"from typing import List, Tuple from collections import defaultdict, deque def can_finish_tasks(num_tasks: int, dependencies: List[Tuple[int, int]]) -> bool: Determines if it is possible to finish all tasks given the dependencies. # Create a graph from the dependencies graph = defaultdict(list) indegree = [0] * num_tasks for a, b in dependencies: graph[a].append(b) indegree[b] += 1 # Find all nodes with no incoming edges queue = deque([i for i in range(num_tasks) if indegree[i] == 0]) visited = 0 while queue: node = queue.popleft() visited += 1 for neighbor in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If we visited all nodes, return True return visited == num_tasks"},{"question":"# Problem Statement: Hamming Distance Calculation Write a function `hamming_distance(x: int, y: int) -> int` that calculates the Hamming distance between two integers. The Hamming distance is defined as the number of positions at which the corresponding bits are different in the binary representation of the given integers. Function Signature ```python def hamming_distance(x: int, y: int) -> int: ``` Input - `x` and `y`: non-negative integers representing the two numbers to compare. Output - Returns the Hamming distance as an integer. Constraints - The integers `x` and `y` will be non-negative and fit within the limits of a standard 32-bit integer (0 <= x, y < 2^31). Example ```python assert hamming_distance(1, 4) == 2 # 1 is 0001 and 4 is 0100 in binary assert hamming_distance(3, 1) == 1 # 3 is 0011 and 1 is 0001 in binary assert hamming_distance(7, 10) == 3 # 7 is 0111 and 10 is 1010 in binary assert hamming_distance(0, 0) == 0 # both are 0000 in binary assert hamming_distance(255, 0) == 8 # 255 is 11111111 and 0 is 00000000 in binary ``` Note - Efficiently handle the comparison of binary representations. - Ensure your implementation considers all possible edge cases and optimizes for performance. - This problem deals with bitwise operations, so familiarity with bitwise logic is useful.","solution":"def hamming_distance(x: int, y: int) -> int: Computes the Hamming distance between two integers. Hamming distance is defined as the number of positions at which the corresponding bits are different. :param x: First integer :param y: Second integer :return: Hamming distance as an integer xor_result = x ^ y return bin(xor_result).count(\'1\')"},{"question":"# Coding Assessment Question **Finding Minimum Spanning Tree using Kruskal\'s Algorithm** You are to write a program that finds the minimum spanning tree (MST) of a connected, undirected graph using Kruskal\'s algorithm. Function Signature ```python def kruskal_mst(n: int, edges: List[Tuple[int, int, int]]) -> int: Returns the total weight of the minimum spanning tree. :param n: An integer representing the number of vertices in the graph. :param edges: A list of tuples, where each tuple represents an edge in the format (u, v, weight). :return: An integer representing the total weight of the MST. ``` Input * `n` - an integer `2 <= n <= 1000` representing the number of vertices. * `edges` - a list of tuples, each containing three integers `(u, v, weight)` representing an edge connecting vertices `u` and `v` with a given weight. - Each vertex is indexed from `1` to `n`. - Each edge will have a positive weight. Output * The function should return a single integer, the total weight of the MST. Example ```python print(kruskal_mst(4, [(1, 2, 1), (1, 3, 5), (2, 3, 2), (2, 4, 3), (3, 4, 4)])) # Output: 6 print(kruskal_mst(5, [(1, 2, 3), (2, 3, 1), (3, 4, 6), (4, 5, 2), (1, 5, 10)])) # Output: 12 print(kruskal_mst(3, [(1, 2, 1), (2, 3, 2), (1, 3, 3)])) # Output: 3 ``` Constraints * Take care of edge cases such as graphs with the minimum number of edges. * Ensure that the function can efficiently handle the upper limits of constraints. Performance Requirements * The implementation should be able to handle up to `1000` vertices and `1000000` edges. Context A minimum spanning tree (MST) of a graph is a subset of the edges that forms a tree that includes every vertex, where the total weight of all the edges in the tree is minimized. Kruskal\'s algorithm is a classic method for finding such a tree efficiently using a greedy approach and the union-find data structure for cycle detection.","solution":"from typing import List, Tuple def kruskal_mst(n: int, edges: List[Tuple[int, int, int]]) -> int: Returns the total weight of the minimum spanning tree. :param n: An integer representing the number of vertices in the graph. :param edges: A list of tuples, where each tuple represents an edge in the format (u, v, weight). :return: An integer representing the total weight of the MST. # Helper function to find the root of a vertex u def find(parent, u): if parent[u] == u: return u parent[u] = find(parent, parent[u]) return parent[u] # Helper function to union two sets def union(parent, rank, u, v): root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: if rank[root_u] > rank[root_v]: parent[root_v] = root_u elif rank[root_u] < rank[root_v]: parent[root_u] = root_v else: parent[root_v] = root_u rank[root_u] += 1 # Sort the edges based on weight edges.sort(key=lambda x: x[2]) parent = [i for i in range(n + 1)] rank = [0] * (n + 1) mst_weight = 0 for u, v, weight in edges: if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_weight += weight return mst_weight"},{"question":"# Scenario You are part of a team building a search engine backend, which requires an implementation of autocomplete functionality. When a user starts typing a query, the engine should provide a list of suggested complete words based on an input prefix. # Task Implement a function to construct the autocomplete mechanism using a Trie (prefix tree) and retrieve suggestions based on the given prefix. # Function Signature ```python def build_trie(words: List[str]) -> TrieNode: def autocomplete(trie: TrieNode, prefix: str) -> List[str]: ``` # Input - `words`: A list of strings representing the dictionary of available words. - `prefix`: A string representing the prefix to autocomplete from. # Output - `build_trie(words)`: This function should return the root node of the constructed Trie. - `autocomplete(trie, prefix)`: This function should return a list of all words in the Trie that start with the given prefix, sorted in lexicographical order. # Constraints - Each word in `words` contains only lowercase English letters. - The length of any word does not exceed 100 characters. - The total number of words `n` is between `1` and `10^4` (inclusive). # Example ```python words = [\\"apple\\", \\"apricot\\", \\"banana\\", \\"bamboo\\", \\"ball\\", \\"cat\\", \\"cap\\", \\"cape\\"] trie = build_trie(words) prefix = \\"ba\\" autocomplete(trie, prefix) ``` Expected Output ``` [\'ball\', \'bamboo\', \'banana\'] ``` **Note**: Ensure your functions utilize the Trie data structure efficiently to handle the constraints. Focus on correctly building the Trie and fetching the suggestions to minimize search time.","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False def build_trie(words: List[str]) -> TrieNode: root = TrieNode() for word in words: current = root for letter in word: if letter not in current.children: current.children[letter] = TrieNode() current = current.children[letter] current.is_end_of_word = True return root def autocomplete(trie: TrieNode, prefix: str) -> List[str]: current = trie for letter in prefix: if letter in current.children: current = current.children[letter] else: return [] results = [] _find_words_with_prefix(current, prefix, results) return sorted(results) def _find_words_with_prefix(node: TrieNode, prefix: str, results: List[str]): if node.is_end_of_word: results.append(prefix) for letter, child_node in node.children.items(): _find_words_with_prefix(child_node, prefix + letter, results)"},{"question":"# Problem Statement: You are developing a text editor and need a feature to count the frequency of each word in a given text. Accurate word frequency computation is essential for features like word cloud generation and frequency analysis. # Requirements: Implement a function `word_frequency_counter(text: str) -> dict` that calculates the frequency of each word in a given text string. The function should: 1. Consider words to be separated by spaces, punctuation marks (.,!?;:) or newline characters. 2. Ignore case (i.e., \'Word\' and \'word\' should be counted as the same word). 3. Return a dictionary where keys are words and values are their respective frequency counts. # Input: * A single string representing the text to analyze. # Output: * A dictionary where keys are words and values are their respective frequency counts. # Constraints: * The input text length will be in the range [1, 10^6] characters. # Example: Example 1: ```python def word_frequency_counter(text: str) -> dict: pass # Example Usage: result = word_frequency_counter(\\"How much wood would a woodchuck chuck if a woodchuck could chuck wood?\\") print(result) # Output: { # \'how\': 1, \'much\': 1, \'wood\': 2, \'would\': 1, # \'a\': 2, \'woodchuck\': 2, \'chuck\': 2, \'if\': 1, \'could\': 1 # } result = word_frequency_counter(\\"Hello, World! Hello World.\\") print(result) # Output: { # \'hello\': 2, \'world\': 2 # } ``` # Note: * Ensure punctuation marks are properly handled as word separators. * Focus on maintaining accuracy while counting word frequencies. * You may use the `re` module for regular expression operations to help with word tokenization. # Explanation: In the first example, \\"wood\\" occurs 2 times, \\"woodchuck\\" occurs 2 times, and \\"chuck\\" occurs 2 times, while other words occur only once. Words are also considered case-insensitive, as \\"How\\" and \\"how\\" are both treated as \\"how\\".","solution":"import re from collections import Counter def word_frequency_counter(text: str) -> dict: Calculates the frequency of each word in a given text string. :param text: A string representing the text to analyze :return: A dictionary where keys are words and values are their respective frequency counts # Convert text to lowercase text = text.lower() # Use regular expression to split the text into words, considering punctuation and whitespace words = re.findall(r\'bw+b\', text) # Count frequency of each word using Counter word_counts = Counter(words) return dict(word_counts) # Example Usage: # result = word_frequency_counter(\\"How much wood would a woodchuck chuck if a woodchuck could chuck wood?\\") # print(result) # result = word_frequency_counter(\\"Hello, World! Hello World.\\") # print(result)"},{"question":"Find Loop in Linked List # Context You are given a singly linked list. Your task is to determine if a cycle (loop) exists in the linked list. If a cycle is present, return the node where the cycle begins. If there is no cycle, return `None`. # Input 1. An instance of `LinkedList`. # Output 1. The node where the cycle begins, or `None` if no cycle exists. # Constraints 1. The elements of the linked list are integers. 2. You cannot modify the linked list. 3. The solution should not use additional data structures. # Performance Requirements 1. The time complexity should be linear, i.e., O(n) where n is the number of nodes in the linked list. 2. The space complexity should be O(1). # Function Definition ```python def find_cycle(head: Node) -> Optional[Node]: pass ``` # Example ```python # Example Case 1 # Input: # A linked list with nodes: 3 -> 2 -> 0 -> -4 -> 2 (cycle) head = Node(3) head.next = Node(2) head.next.next = Node(0) head.next.next.next = Node(-4) head.next.next.next.next = head.next # Output: cycle_node = find_cycle(head) # cycle_node should represent the node with the value 2 # Example Case 2 # Input: # A linked list with nodes: 1 -> 2 -> 3 -> None (no cycle) head = Node(1) head.next = Node(2) head.next.next = Node(3) # Output: cycle_node = find_cycle(head) # cycle_node should be None ``` # Notes 1. The function `Node` is defined with properties `val` and `next`. 2. Your solution should correctly handle the detection and return the start of the cycle node or `None` if no cycle is present. 3. Remember, using additional data structures like sets or lists for keeping track of visited nodes is not allowed.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def find_cycle(head: Node): Returns the node where the cycle begins, or `None` if no cycle exists. Uses Floyd\'s Cycle detection algorithm. if not head or not head.next: return None slow, fast = head, head # First step: determine whether a cycle exists while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: return None # No cycle # Second step: find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"# Coding Challenge: String Permutations with Constraints You have been tasked with generating all distinct permutations of a given string that do not contain any palindrome as substrings. Your function should ensure it handles the permutations and palindrome checks efficiently. **Function Signature**: ```python def no_palindrome_permutations(s: str) -> List[str]: ``` **Input**: - A string `s` containing lower case characters (\'a\'-\'z\'). (`1 <= len(s) <= 10`) **Output**: - A list of strings representing all distinct permutations of `s` where none contain any palindrome substrings. **Constraints**: - The function must handle strings of length up to 10. - The output list must contain unique permutations only. - Ensure optimal performance when generating permutations and checking for palindromes. **Example**: ```python >>> no_palindrome_permutations(\\"abc\\") [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] >>> no_palindrome_permutations(\\"aab\\") [] >>> no_palindrome_permutations(\\"aabb\\") [] >>> no_palindrome_permutations(\\"xyz\\") [\'xyz\', \'xzy\', \'yxz\', \'yzx\', \'zxy\', \'zyx\'] >>> no_palindrome_permutations(\\"aa\\") [] ``` **Instructions**: 1. Implement the function `no_palindrome_permutations` to generate permutations and filter out those containing palindrome substrings. 2. Ensure none of the resulting permutations contain substrings that are palindromes. For instance, in the example of `aab`, both possible permutations `aab` and `aba` contain `aa` and `aba` respectively as palindromic substrings, thus the output is `[]`. 3. Optimize your solution for handling the generation of permutations and checking substrings effectively.","solution":"from itertools import permutations from typing import List def is_palindrome(s: str) -> bool: Check if a given string is a palindrome. return s == s[::-1] def contains_palindrome_substring(s: str) -> bool: Check if a given string contains any palindromic substrings. length = len(s) for i in range(length): for j in range(i + 2, length + 1): # substrings of at least 2 characters if is_palindrome(s[i:j]): return True return False def no_palindrome_permutations(s: str) -> List[str]: Generates distinct permutations of a string that do not contain any palindromic substrings. all_permutations = set(permutations(s)) valid_permutations = [ \'\'.join(p) for p in all_permutations if not contains_palindrome_substring(\'\'.join(p)) ] return valid_permutations"},{"question":"# Prime Palindromes Your task is to implement a function that generates a list of prime palindromes less than or equal to a given positive integer `n`. A palindrome is a number that reads the same forwards and backwards (e.g., 121, 131), and a prime number is a number greater than 1 that has no positive divisors other than 1 and itself. To assist individuals in identifying special numbers with both prime and palindromic properties, this function will generate all such numbers up to the specified limit. Function Signature ```python def prime_palindromes(n: int) -> list[int]: Generates a list of prime palindromes less than or equal to n. :param n: A positive integer up to which to find prime palindromes. :return: A list of integers that are both prime and palindromes. :raises ValueError: If the input is not a positive integer. ``` Input & Output **Input**: - An integer `n`. **Output**: - A list of integers that are prime and also palindromes, each of which is less than or equal to `n`. Constraints: - The function should raise a `ValueError` for a non-integer input or if `n` is less than 1. - The output list should be sorted in ascending order. Example ```python assert prime_palindromes(100) == [2, 3, 5, 7, 11, 101] assert prime_palindromes(200) == [2, 3, 5, 7, 11, 101, 131, 151, 181, 191] assert prime_palindromes(10) == [2, 3, 5, 7] try: prime_palindromes(-10) except ValueError as e: assert str(e) == \\"Input must be a positive integer\\" try: prime_palindromes(2.5) except ValueError as e: assert str(e) == \\"Input must be an integer\\" ``` Implement the `prime_palindromes` function based on the provided requirements, ensuring optimal performance and proper error handling for edge cases.","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while (i * i) <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def is_palindrome(num): return str(num) == str(num)[::-1] def prime_palindromes(n): if not isinstance(n, int): raise ValueError(\\"Input must be an integer\\") if n < 1: raise ValueError(\\"Input must be a positive integer\\") result = [] for num in range(1, n + 1): if is_prime(num) and is_palindrome(num): result.append(num) return result"},{"question":"**Objective**: Write a function to detect if there is a cycle in an undirected graph represented using an adjacency list. **Function Signature**: `def has_cycle(graph: Dict[int, List[int]]) -> bool` **Input**: - `graph`: A dictionary where keys are node identifiers (integers) and values are lists of integers representing the adjacent nodes. **Output**: - A boolean value indicating whether the graph contains a cycle. **Constraints**: - The graph will be undirected and can be disconnected. - The graph will have at most 1000 vertices. **Performance Requirements**: - The algorithm should run in O(V + E) time complexity, where V is the number of vertices and E is the number of edges. - The space complexity should be O(V). **Example**: ```python graph1 = { 0: [1, 2], 1: [0, 2], 2: [0, 1, 3], 3: [2, 4], 4: [3] } print(has_cycle(graph1)) # Expected Output: True graph2 = { 0: [1], 1: [0, 2], 2: [1, 3], 3: [2, 4], 4: [3] } print(has_cycle(graph2)) # Expected Output: False ``` **Scenario**: In a social network, people are represented as nodes and friendships as edges. A cycle in this network might indicate a group of friends who all know each other. Your task is to determine whether any such groups exist. **Clarifications**: - Ensure that the algorithm handles both connected and disconnected graphs. - Consider edge cases with no edges or a single node.","solution":"from typing import Dict, List def has_cycle(graph: Dict[int, List[int]]) -> bool: def dfs(node, parent): visited.add(node) for neighbor in graph[node]: if neighbor not in visited: if dfs(neighbor, node): return True elif parent != neighbor: return True return False visited = set() for node in graph: if node not in visited: if dfs(node, -1): return True return False"},{"question":"# Question: Count Distinct Subsequences Given two strings `S` and `T`, write a function `num_distinct(s: str, t: str) -> int` that computes the number of distinct subsequences of `S` which equals `T`. A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. Constraints: - `S` and `T` are strings of alphanumeric characters. - The lengths of `S` and `T` are in the range `[0, 1000]`. Input: - `s` (string): The string from which subsequences are formed. - `t` (string): The target string for which we are counting subsequences. Output: - An integer representing the number of distinct subsequences of `S` that equals `T`. Performance Requirements: - Time Complexity should be O(m*n), where `m` is the length of `S` and `n` is the length of `T`. - Space Complexity should be O(m*n). Example: - `num_distinct(\\"rabbbit\\", \\"rabbit\\")` should return `3`. - `num_distinct(\\"babgbag\\", \\"bag\\")` should return `5`. Edge Cases: - `num_distinct(\\"\\", \\"a\\")` should return `0`. - `num_distinct(\\"a\\", \\"\\")` should return `1` as the empty string is a subsequence of any string. - `num_distinct(\\"\\", \\"\\")` should return `1`. Your implementation should handle edge cases gracefully and should efficiently compute the result using dynamic programming. **Function Signature:** ```python def num_distinct(s: str, t: str) -> int: pass ``` You can use a dynamic programming approach to optimize your solution for large inputs.","solution":"def num_distinct(s: str, t: str) -> int: Returns the number of distinct subsequences of S which equals T. m, n = len(s), len(t) # dp[i][j] will store the number of distinct subsequences of s[0:i] which equals t[0:j] dp = [[0] * (n + 1) for _ in range(m + 1)] # An empty string t is a subsequence of any prefix of s. for i in range(m + 1): dp[i][0] = 1 # Fill the dp table for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: # If the characters match, we can either take it or not take it. dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] else: # If they don\'t match, we can\'t take this character from s. dp[i][j] = dp[i - 1][j] return dp[m][n]"},{"question":"**Scenario**: You are given a list of words and a string `s` which consists of alphanumeric characters and spaces. Your task is to find and return the longest word in `s` that is present in the given list of words. If there are multiple words with the same length, return the lexicographically smallest one. If `s` contains no words from the list, return an empty string. **Instructions**: - Implement the `WordFinder` class as described. - The `find_longest_word` method should identify the longest word from the list that appears in `s`. - The `add_word` method should add a word to the list of known words. **Function Signature**: The function signatures should be as follows: ```python class WordFinder: def __init__(self): # Initialization code goes here def add_word(self, word: str): # Code to add a word to the list goes here def find_longest_word(self, s: str) -> str: # Code to find the longest matching word goes here ``` # Expected Input and Output **Input**: - `s` (str): A string including alphanumeric characters and spaces. - `words` (List[str]): A list of words to be considered. **Output**: - The `find_longest_word` method should return the longest word from the list that is found in `s`. # Sample Input: ```python words = [\\"cat\\", \\"banana\\", \\"dog\\", \\"nana\\", \\"walk\\", \\"walker\\", \\"dogwalker\\"] finder = WordFinder() for word in words: finder.add_word(word) s = \\"walker dogwalker cat banana dog\\" print(finder.find_longest_word(s)) # Output should be \\"dogwalker\\" s2 = \\"the quick brown fox\\" print(finder.find_longest_word(s2)) # Output should be \\"\\" ``` **Constraints**: - Length of `s` within the range `1 <= len(s) <= 10^3` - Number of words in the list `1 <= len(words) <= 10^3` - Length of each word within the range `1 <= len(word) <= 100` **Performance Requirements**: The solution should work efficiently within the given constraints while prioritizing lexicographical order in case of ties.","solution":"class WordFinder: def __init__(self): self.words = set() def add_word(self, word: str): self.words.add(word) def find_longest_word(self, s: str) -> str: s_words = s.split() longest_word = \\"\\" for word in s_words: if word in self.words: if len(word) > len(longest_word) or (len(word) == len(longest_word) and word < longest_word): longest_word = word return longest_word"},{"question":"# Combinatorial Selection Write a function that calculates the total number of unique selections of `k` items from a set of `n` items. This is a classic problem of combinatorics, often referred to as \\"n choose k\\" or binomial coefficient, calculated as: [ C(n, k) = frac{n!}{k!(n-k)!} ] However, for this problem, you should implement the calculation without using direct factorial functions to avoid potential overflow issues with large values of `n`. Instead, use an iterative approach to keep the calculation manageable. Implement the following functions: 1. `combinatorial_selection(n: int, k: int) -> int`: Calculate the number of unique selections. 2. `print_combinatorial_selection(n: int, k: int) -> None`: Print the calculated result in a formatted manner as shown in the examples. Input and Output Formats **`combinatorial_selection` function:** * Input: `n` (int) - The number of items in the set. * Input: `k` (int) - The number of items to select. * Output: The number of unique selections (int). **`print_combinatorial_selection` function:** * Input: `n` (int) - The number of items in the set. * Input: `k` (int) - The number of items to select. * Output: None. The function should print the result to the console in the format: \\"Total selections: {result}\\". Constraints * 0 ≤ k ≤ n. * The input values `n` and `k` should be non-negative integers. Examples ```python >>> combinatorial_selection(5, 3) 10 # Explanation: C(5, 3) = 5! / (3! * (5-3)!) = 10 >>> combinatorial_selection(6, 2) 15 # Explanation: C(6, 2) = 6! / (2! * (6-2)!) = 15 >>> print_combinatorial_selection(5, 3) Total selections: 10 >>> combinatorial_selection(0, 0) 1 # Explanation: C(0, 0) = 1 by definition >>> combinatorial_selection(10, 0) 1 # Explanation: C(10, 0) = 1 by definition >>> combinatorial_selection(10, 10) 1 # Explanation: C(10, 10) = 1 by definition ``` You need to handle invalid inputs by raising appropriate exceptions similar to the original implementation.","solution":"def combinatorial_selection(n, k): if k > n or n < 0 or k < 0: raise ValueError(\\"Invalid input: n and k must be such that 0 ≤ k ≤ n and both are non-negative integers.\\") if k == 0 or k == n: return 1 k = min(k, n - k) # Take advantage of symmetry C(n, k) == C(n, n-k) result = 1 for i in range(k): result *= (n - i) result //= (i + 1) return result def print_combinatorial_selection(n, k): result = combinatorial_selection(n, k) print(f\\"Total selections: {result}\\")"},{"question":"# Coding Assessment: Maximum XOR of Two Numbers in an Array Context Given an array of integers, you are to determine the maximum value obtainable by XORing any two numbers from the array. This problem tests your understanding of bitwise operations and efficient algorithm design using concepts such as Trie or Hash Sets. Problem Statement You will be given an array of integers. Your task is to write a function `find_maximum_xor(nums: list[int]) -> int` that finds the maximum XOR value of any two integers in the array `nums`. Function Signature ```python def find_maximum_xor(nums: list[int]) -> int: ``` Inputs - `nums`: A list of integers (length >= 2, and each integer is a non-negative integer). Outputs - Return the maximum XOR value as an integer. Constraints - The list `nums` will have at least two integers. - Each integer in the list will be a non-negative integer (0 ≤ nums[i] < 2^31). Performance Requirements - The solution should have an average time complexity better than O(n^2). - The solution should handle the upper limits efficiently, i.e., length of `nums` approaching 10^5. Example ```python nums = [3, 10, 5, 25, 2, 8] print(find_maximum_xor(nums)) # Output should be 28 nums = [0, 1, 2, 3, 4] print(find_maximum_xor(nums)) # Output should be 7 nums = [14, 70, 53, 83, 49, 91, 36, 80, 92, 51, 66, 70] print(find_maximum_xor(nums)) # Output should be 127 ``` Hint - Consider using Trie (prefix tree) data structures to minimize the number of operations when determining the potential maximum XOR for each number in the array. - Another approach involves maintaining a hash set of prefixes and iteratively finding pairs that can produce the maximum XOR. Notes - XOR is a bitwise operation that outputs true or 1 only when the input bits are unequal, effective for toggling bits. - Pay close attention to the highest differing bit when computing maximum potential XOR values.","solution":"def find_maximum_xor(nums): Finds the maximum XOR of any two numbers in the given list. if not nums: return 0 # Initialize variables max_xor = 0 mask = 0 # Iterate over the bit positions from 31 to 0 for i in range(31, -1, -1): # Add the current bit to the mask mask |= (1 << i) # Store the prefixes of all the numbers with the current mask prefixes = {num & mask for num in nums} # Get the new maximum XOR with the current bit set to 1 new_max_xor = max_xor | (1 << i) # Check if there is a pair of prefixes that gives the new maximum XOR has_new_max_xor = any((new_max_xor ^ prefix) in prefixes for prefix in prefixes) if has_new_max_xor: max_xor = new_max_xor return max_xor"},{"question":"# Binary Search Tree (BST) Operations and Enhancements As a programming task, you need to enhance the provided Binary Search Tree (BST) implementation by adding specific functionalities and optimizing existing methods. 1. **Find Kth Smallest Element**: Implement a method to find the Kth smallest element in the BST. This requires an in-order traversal to access elements in sorted order. 2. **Calculate Tree Height**: Enhance the current BST structure to compute the height of the tree. The height of a tree is the number of edges on the longest path from the root node to a leaf. 3. **Balance Check**: Implement a method to check if the tree is balanced. A tree is considered balanced if the heights of the two child subtrees of any node differ by no more than one. # Input and Output Format * Implement three distinct methods in the BST class: * `find_kth_smallest(k: int) -> int`: Returns the Kth smallest element in the BST. * `calculate_height() -> int`: Returns the height of the BST. * `is_balanced() -> bool`: Checks if the BST is balanced and returns a boolean accordingly. # Constraints * Tree operations will only involve integers. * Assume that the BST does not contain duplicate elements. * Kth smallest element queries will always have a valid K (i.e., 1 ≤ K ≤ number of nodes in BST). # Examples ```python # Example usage: bst = BinarySearchTree() # Insert elements into the BST bst.insert(50) bst.insert(30) bst.insert(70) bst.insert(20) bst.insert(40) bst.insert(60) bst.insert(80) # Find Kth smallest element print(bst.find_kth_smallest(3)) # Should return 40 # Calculate tree height print(bst.calculate_height()) # Should return 2 (height of the above tree) # Check if the tree is balanced print(bst.is_balanced()) # Should return True # Insert more elements to unbalance the tree bst.insert(10) bst.insert(5) # Checking balance again print(bst.is_balanced()) # Should return False if the tree becomes unbalanced ``` Implement the enhanced `BinarySearchTree` class based on the above requirements and guidelines.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.value = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.value: if node.left is None: node.left = TreeNode(key) else: self._insert(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert(node.right, key) def find_kth_smallest(self, k): self.k = k self.result = None self._in_order_traversal(self.root) return self.result def _in_order_traversal(self, node): if node is not None: self._in_order_traversal(node.left) self.k -= 1 if self.k == 0: self.result = node.value return self._in_order_traversal(node.right) def calculate_height(self): return self._calculate_height(self.root) def _calculate_height(self, node): if node is None: return -1 left_height = self._calculate_height(node.left) right_height = self._calculate_height(node.right) return 1 + max(left_height, right_height) def is_balanced(self): return self._is_balanced(self.root) def _is_balanced(self, node): if node is None: return True left_height = self._calculate_height(node.left) right_height = self._calculate_height(node.right) if abs(left_height - right_height) > 1: return False return self._is_balanced(node.left) and self._is_balanced(node.right)"},{"question":"# Coding Assessment Question Scenario You are tasked to implement a simplified artificial neural network (ANN) for binary classification purposes. The network consists of a single neuron with a sigmoid activation function. You need to construct and train this neuron to classify data points accurately. Task 1. **Function Implementation**: Implement a function `train_neuron` which performs the training of a single neuron on a given dataset using the gradient descent algorithm. 2. **Detailed Steps**: - Define the function `train_neuron(X: List[List[float]], y: List[int], learning_rate: float, epochs: int) -> Tuple[List[float], float]`. - Initialize the weights and bias to random values. - For each epoch, update the weights and bias using the gradient descent algorithm. - Use the sigmoid function as the activation function for the neuron. 3. **Requirements**: * The list `X` contains the feature vectors (list of floats) of the dataset. * The list `y` contains the binary labels (0 or 1) corresponding to each feature vector in `X`. * The `learning_rate` is a float indicating the step size for the gradient descent updates. * The `epochs` is an integer representing the number of iterations to train the neuron. 4. **Example**: ```python >>> X = [[0.1, 0.5], [0.2, 0.6], [0.3, 0.7], [0.4, 0.8], [0.5, 0.9]] >>> y = [0, 0, 1, 1, 1] >>> learning_rate = 0.1 >>> epochs = 1000 >>> weights, bias = train_neuron(X, y, learning_rate, epochs) >>> print(weights, bias) [1.2, -0.8] 0.5 ``` Constraints * **Input**: - The feature vectors in `X` will all have the same number of features. - Labels in `y` will be either 0 or 1. - The `learning_rate` will be a small positive float, and `epochs` will be a positive integer. * **Expected Output**: - The final weights and bias after training. Performance Requirements * The function should efficiently update weights and bias using gradient descent. * The time complexity should be O(m * n * epochs), where m is the number of feature vectors and n is the number of features. * The space complexity should not exceed O(n), where n is the number of features due to storing weights and gradients. Tips - To implement the sigmoid function: `sigmoid(z) = 1 / (1 + exp(-z))` - The update rule for weights and bias in gradient descent is: - `weight[i] += learning_rate * (y_hat - y) * X[i]` - `bias += learning_rate * (y_hat - y)`","solution":"import random import math from typing import List, Tuple def sigmoid(z: float) -> float: Calculate the sigmoid of z. return 1 / (1 + math.exp(-z)) def train_neuron(X: List[List[float]], y: List[int], learning_rate: float, epochs: int) -> Tuple[List[float], float]: Train a single neuron using gradient descent. Args: X (List[List[float]]): The feature vectors. y (List[int]): The binary labels. learning_rate (float): The step size for gradient descent updates. epochs (int): The number of iterations to train. Returns: Tuple[List[float], float]: The final weights and bias. # Initialize weights and bias to random values num_features = len(X[0]) weights = [random.random() for _ in range(num_features)] bias = random.random() # Gradient descent for each epoch for _ in range(epochs): for i in range(len(X)): # Calculate the linear combination of inputs and weights z = sum(w * x for w, x in zip(weights, X[i])) + bias # Calculate the output of the neuron y_hat = sigmoid(z) # Calculate the error error = y_hat - y[i] # Update weights and bias for j in range(num_features): weights[j] -= learning_rate * error * X[i][j] bias -= learning_rate * error return weights, bias"},{"question":"# Problem Statement A software company is developing a scheduling tool that helps teams manage their work week. One essential feature is to determine the minimum number of meeting rooms required to accommodate all scheduled meetings. Each meeting has a start and end time, and meetings may overlap, necessitating multiple rooms. Write a function `min_meeting_rooms(meetings: list[tuple[int, int]]) -> int` that takes a list of meetings represented as tuples of start and end times and returns the minimum number of meeting rooms required to accommodate all meetings. # Input * `meetings`: A list of tuples where each tuple contains two integers representing the start and end time of a meeting. Start and end times are given in a 24-hour format (e.g., 9, 13 for a meeting from 9:00 to 13:00). # Output * An integer representing the minimum number of meeting rooms required. # Constraints * If the input list is empty, the output should be `0`. * If the input contains invalid tuples (not exactly two integers), raise a `ValueError` with the message \\"meetings must be a list of tuples with two integers\\". # Example Usage ```python # Example 1 print(min_meeting_rooms([(9, 10), (11, 12), (10, 11)])) # Output: 1 # Example 2 print(min_meeting_rooms([(9, 10), (9, 10), (9, 10)])) # Output: 3 # Example 3 print(min_meeting_rooms([(9, 11), (10, 12), (11, 13), (12, 14)])) # Output: 2 # Example 4 print(min_meeting_rooms([])) # Output: 0 # Example 5 print(min_meeting_rooms(None)) # Raises ValueError: \\"meetings must be a list of tuples with two integers\\" # Example 6 print(min_meeting_rooms([(9, 10), (10, 11, 12)])) # Raises ValueError: \\"meetings must be a list of tuples with two integers\\" # Example 7 print(min_meeting_rooms([(9, 10), (10, \\"12:00\\")])) # Raises ValueError: \\"meetings must be a list of tuples with two integers\\" ``` # Performance Requirement * The solution should run in O(n log n) time complexity, where n is the number of meetings. This is due to sorting the meeting times. * The space complexity should be O(n) due to the additional data structures used in the solution. Your task is to ensure the function handles all edge cases efficiently and returns the correct result as specified.","solution":"def min_meeting_rooms(meetings): Returns the minimum number of meeting rooms required to accommodate all meetings. if not isinstance(meetings, list): raise ValueError(\\"meetings must be a list of tuples with two integers\\") for meeting in meetings: if not isinstance(meeting, tuple) or len(meeting) != 2: raise ValueError(\\"meetings must be a list of tuples with two integers\\") if not all(isinstance(time, int) for time in meeting): raise ValueError(\\"meetings must be a list of tuples with two integers\\") if not meetings: return 0 # Sort the meetings by start time start_times = sorted([meeting[0] for meeting in meetings]) end_times = sorted([meeting[1] for meeting in meetings]) start_ptr = 0 end_ptr = 0 rooms_needed = 0 max_rooms = 0 # Iterate through the time slots while start_ptr < len(meetings): if start_times[start_ptr] < end_times[end_ptr]: rooms_needed += 1 start_ptr += 1 else: rooms_needed -= 1 end_ptr += 1 max_rooms = max(max_rooms, rooms_needed) return max_rooms"},{"question":"# Problem Statement You are given an array of integers representing the heights of a series of buildings. Your goal is to determine the maximum area of a rectangle that can be formed by any two buildings and the horizontal ground between them. You must ensure that the heights of these two buildings form the boundaries of the rectangle. # Function Signature ```python def max_rectangle_area(heights: list[int]) -> int: Returns the maximum area of the rectangle that can be formed between two heights in the given array. ``` # Input * `heights` (1 <= len(heights) <= 10^5): A list of integers where each integer represents the height of a building. All heights are non-negative integers and do not exceed 10^6. # Output * An integer representing the maximum possible area of the rectangle. # Example ```python assert max_rectangle_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) == 49 assert max_rectangle_area([1, 1]) == 1 assert max_rectangle_area([4, 3, 2, 1, 4]) == 16 assert max_rectangle_area([1, 2, 1]) == 2 assert max_rectangle_area([0, 2]) == 0 ``` # Constraints * The function should have a time complexity of O(n) to efficiently handle large inputs. * The algorithm should handle buildings of varying heights and should return 0 if the array contains fewer than two building heights.","solution":"def max_rectangle_area(heights: list[int]) -> int: Returns the maximum area of the rectangle that can be formed between two heights in the given array. left, right = 0, len(heights) - 1 max_area = 0 while left < right: height = min(heights[left], heights[right]) width = right - left max_area = max(max_area, height * width) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"# Array Manipulation: Maximum Sum of Non-Adjacent Elements Context Sam is working on optimizing his financial investments to maximize returns. He wants to determine the maximum sum of non-adjacent elements in a list of potential daily profit values. This problem is significant as it can be applied to find solutions in dynamic programming, game theory, and other optimization problems. Task Implement a function `max_non_adjacent_sum(nums: List[int]) -> int` that efficiently calculates the maximum sum of non-adjacent elements from a list of integers `nums`. Input Format - A single list of integers `nums` where `1 <= len(nums) <= 10^5` and `-10^4 <= nums[i] <= 10^4`. Output Format - Return an integer representing the maximum sum of non-adjacent elements. Constraints - Elements are non-adjacent if there is at least one index between them. - The function should run efficiently within the given input constraints. Examples ```python assert max_non_adjacent_sum([3, 2, 5, 10, 7]) == 15 # (3 + 10 + 2) assert max_non_adjacent_sum([3, 2, 7, 10]) == 13 # (3 + 10) assert max_non_adjacent_sum([5, 5, 10, 100, 10, 5]) == 110 # (5 + 100 + 5) assert max_non_adjacent_sum([-2, 1, 3, -4, 5]) == 8 # (3 + 5) assert max_non_adjacent_sum([5, 1, 1, 5]) == 10 # (5 + 5) ``` Requirements 1. Implement the `max_non_adjacent_sum` function to meet the above specifications. 2. Ensure the function handles large inputs effectively and adheres to the constraints.","solution":"from typing import List def max_non_adjacent_sum(nums: List[int]) -> int: if not nums: return 0 if len(nums) == 1: return max(0, nums[0]) inclusive = 0 exclusive = 0 for num in nums: new_exclusive = max(inclusive, exclusive) inclusive = exclusive + num exclusive = new_exclusive return max(inclusive, exclusive)"},{"question":"# Context You have been tasked with solving a problem involving prime numbers. The challenge requires you to efficiently generate prime numbers and compute the sum of all prime numbers up to a given integer `n`. This tests your understanding of prime number algorithms and your ability to optimize for performance. # Problem Statement Write a Python function called `sum_primes_up_to` that takes an integer `n` as input and returns the sum of all prime numbers that are less than or equal to `n`. # Input - An integer `n` where `2 <= n <= 10^6`. # Output - An integer representing the sum of all prime numbers up to the given limit. # Function Signature ```python def sum_primes_up_to(n: int) -> int: pass ``` # Constraints - The value of `n` can be as large as 1 million, so your solution should be optimized for performance. - You should handle edge cases where the limit `n` is very small (e.g., 2, 3). # Example ```python assert sum_primes_up_to(10) == 17 # (2, 3, 5, 7) assert sum_primes_up_to(30) == 129 # (2, 3, 5, 7, 11, 13, 17, 19, 23, 29) assert sum_primes_up_to(2) == 2 # (2) assert sum_primes_up_to(29) == 129 # (2, 3, 5, 7, 11, 13, 17, 19, 23, 29) assert sum_primes_up_to(1000000) == 37550402023 # Efficient handling of large input ``` # Guidelines 1. Use the Sieve of Eratosthenes or an efficient algorithm to generate all prime numbers up to `n`. 2. Iterate through the list of generated prime numbers and compute their sum. 3. Return the accumulated sum of prime numbers as the output. Your function will be tested on various input values, including edge cases and large values, so ensure your implementation is both correct and efficient.","solution":"def sum_primes_up_to(n: int) -> int: Returns the sum of all prime numbers less than or equal to n. if n < 2: return 0 sieve = [True] * (n + 1) sieve[0] = sieve[1] = False for start in range(2, int(n ** 0.5) + 1): if sieve[start]: for multiple in range(start * start, n + 1, start): sieve[multiple] = False prime_sum = sum(index for index, is_prime in enumerate(sieve) if is_prime) return prime_sum"},{"question":"# Coding Question Detect Cycles in a Graph **Context** Graphs are fundamental data structures used to represent networks, dependencies, and many other relationships. Detecting cycles in a graph is a critical task in various applications, such as dependency resolution and deadlock detection. **Problem Statement** Write a function `has_cycle(graph: dict) -> bool` that determines whether the given directed graph has any cycles. The graph is represented as an adjacency list where the keys are nodes and the values are lists of nodes to which there is a directed edge. **Function Signature** ```python def has_cycle(graph: dict) -> bool: pass ``` **Input** - `graph` (1 <= len(graph) <= 10^3): A dictionary representing a directed graph, which may be sparse or dense. **Output** - A boolean value: `True` if the graph contains at least one cycle, `False` otherwise. **Example** ```python >>> graph = { ... \\"A\\": [\\"B\\"], ... \\"B\\": [\\"C\\"], ... \\"C\\": [\\"A\\"], ... \\"D\\": [\\"E\\"], ... \\"E\\": [] ... } >>> has_cycle(graph) True >>> graph = { ... \\"A\\": [\\"B\\"], ... \\"B\\": [\\"C\\"], ... \\"C\\": [\\"D\\"], ... \\"D\\": [] ... } >>> has_cycle(graph) False ``` **Constraints** - The implementation should efficiently handle graphs with varying densities. - The solution should run within a time complexity of (O(V + E)), where (V) is the number of vertices and (E) is the number of edges. - Only directed graphs are to be considered for this problem. **Edge Cases to Consider** 1. Disconnected graphs: Ensure the function correctly identifies cycles in all components. 2. Single node graphs: Handle graphs with one node without edges. 3. Empty graph: Consider situations where the graph has no nodes (`graph = {}`). This question integrates seamlessly with the existing set, maintaining a consistent tone and complexity, while exploring the domain of graph algorithms.","solution":"def has_cycle(graph: dict) -> bool: Determines if the given directed graph has a cycle. The graph is represented as an adjacency list. param graph: A dictionary representation of the graph return: Returns True if there is a cycle in the graph, otherwise False def visit(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph.get(node, []): if visit(neighbor): return True visiting.remove(node) visited.add(node) return False visited = set() visiting = set() for node in graph: if visit(node): return True return False"},{"question":"# Matrix Transposition Challenge Problem Statement: You are required to implement a function that computes the transpose of a given matrix. The function should take as input a matrix and return its transpose. A transpose of a matrix is achieved by swapping its rows and columns. For instance, if the original matrix is: [ A = begin{pmatrix} 1 & 2 & 3 4 & 5 & 6 end{pmatrix} ] The transposed matrix will be: [ A^T = begin{pmatrix} 1 & 4 2 & 5 3 & 6 end{pmatrix} ] Function Signature: ```python def transpose(matrix: list[list[int]]) -> list[list[int]]: pass ``` Input: * `matrix`: A list of lists of integers representing the original matrix. Output: * A list of lists of integers representing the transposed matrix. # Constraints: * The input matrix will have a size (m times n) where (1 leq m, n leq 1000). # Examples: ```python print(transpose([[1, 2, 3], [4, 5, 6]])) # Expected output: [[1, 4], [2, 5], [3, 6]] print(transpose([[1]])) # Expected output: [[1]] print(transpose([[1, 2], [3, 4], [5, 6]])) # Expected output: [[1, 3, 5], [2, 4, 6]] print(transpose([[1, 2, 3, 4], [5, 6, 7, 8]])) # Expected output: [[1, 5], [2, 6], [3, 7], [4, 8]] ``` Edge Cases: * Validate and handle matrices with only one element. * Handle empty matrices by returning an empty matrix, i.e., `[] -> []`. Performance Requirements: * The function should handle the maximum constraint efficiently. Implementation Notes: * Consider using list comprehensions for a more concise and readable solution. * Ensure the function can handle and correctly transpose non-square matrices.","solution":"def transpose(matrix): Transpose a given 2D matrix. Args: matrix (list[list[int]]): A matrix represented as a list of lists. Returns: list[list[int]]: The transposed matrix. if not matrix: return [] m, n = len(matrix), len(matrix[0]) return [[matrix[row][col] for row in range(m)] for col in range(n)]"},{"question":"# Programming Question: Implement Radix Sort for Strings You are tasked with implementing the Radix Sort algorithm to efficiently sort arrays of strings. The Radix Sort algorithm sorts elements by processing individual digits or characters one at a time and is particularly effective for fixed-length strings. Your implementation must handle arrays of strings assuming they all are of equal length. **Function Signature:** ```python def radix_sort_strings(array: list, string_length: int) -> list: Sorts an array of fixed-length strings using the Radix Sort algorithm. :param array: The list of strings to be sorted. :param string_length: The fixed length of every string in the array. :return: The sorted list of strings in ascending order. ``` # Constraints * `0 <= len(array) <= 10^5` * All strings in the array have a fixed length specified by `string_length`. * `0 <= string_length <= 100` * Strings consist of lowercase English letters (a-z) only. # Requirements * Your implementation should be stable, ensuring that strings with identical prefixes retain their original relative order. * Handle edge cases appropriately (e.g., empty arrays, single-string arrays). * Efficient handling of large input sizes is required. # Input & Output Examples 1. **Example 1:** ```python array = [\\"bca\\", \\"acb\\", \\"cba\\", \\"aaa\\", \\"abc\\"] string_length = 3 radix_sort_strings(array, string_length) # Output: [\'aaa\', \'abc\', \'acb\', \'bca\', \'cba\'] ``` 2. **Example 2:** ```python array = [\\"ddd\\", \\"ddb\\", \\"ddc\\", \\"daa\\", \\"dab\\"] string_length = 3 radix_sort_strings(array, string_length) # Output: [\'daa\', \'dab\', \'ddb\', \'ddc\', \'ddd\'] ``` 3. **Example 3:** ```python array = [\\"abc\\", \\"xyz\\", \\"ghi\\", \\"def\\"] string_length = 3 radix_sort_strings(array, string_length) # Output: [\'abc\', \'def\', \'ghi\', \'xyz\'] ``` 4. **Example 4:** ```python array = [\\"zaz\\", \\"yby\\", \\"xqx\\", \\"wbw\\"] string_length = 3 radix_sort_strings(array, string_length) # Output: [\'wbw\', \'xqx\', \'yby\', \'zaz\'] ``` # Additional Notes * Ensure that your implementation is thoroughly tested and covers all edge cases. * Consider performance implications of sorting strings with large lengths and large numbers of strings.","solution":"def radix_sort_strings(array, string_length): Sorts an array of fixed-length strings using the Radix Sort algorithm. :param array: The list of strings to be sorted. :param string_length: The fixed length of every string in the array. :return: The sorted list of strings in ascending order. # Function to perform counting sort on the strings based on a specific character position def counting_sort(array, position): # There are 26 lowercase English letters counts = [0] * 26 output = [\\"\\" for _ in array] # Calculate the count of each character at the given position for string in array: index = ord(string[position]) - ord(\'a\') counts[index] += 1 # Calculate cumulative counts for i in range(1, 26): counts[i] += counts[i - 1] # Place the strings in the output array in sorted order for string in reversed(array): index = ord(string[position]) - ord(\'a\') output[counts[index] - 1] = string counts[index] -= 1 return output # Perform counting sort for each character position from right to left for pos in range(string_length - 1, -1, -1): array = counting_sort(array, pos) return array"},{"question":"# Scenario You\'re developing a feature for a budgeting app that helps users track their monthly expenses. One of the tasks is to calculate the total amount spent and the remaining balance for a given month. Users input their monthly expenses as a list of integers and their total monthly budget as an integer. Your goal is to compute how much they have spent and how much they have left from their budget. # Task Implement a function `calculate_budget(expenses: List[int], budget: int) -> Tuple[int, int]` that computes: 1. The total amount spent, defined as the sum of all elements in the `expenses` list. 2. The remaining balance, defined as the difference between the budget and the total amount spent. # Function Signature ```python from typing import List, Tuple def calculate_budget(expenses: List[int], budget: int) -> Tuple[int, int]: pass ``` # Input * `expenses`: A list of integers representing the user\'s monthly expenses. (0 ≤ |expenses| ≤ 10^5, 0 ≤ expenses[i] ≤ 10^4) * `budget`: An integer representing the user\'s total monthly budget. (0 ≤ budget ≤ 10^7) # Output * Returns a tuple of two integers: - Total amount spent. - Remaining balance. # Examples ```python >>> calculate_budget([100, 200, 300], 1000) (600, 400) >>> calculate_budget([1500, 1200, 550, 780], 5000) (4030, 970) >>> calculate_budget([], 700) (0, 700) >>> calculate_budget([1000, 2000, 3000], 5000) (6000, -1000) >>> calculate_budget([500, 500, 500], 1500) (1500, 0) ``` # Constraints * Ensure the function performs efficiently for large input sizes. * The function should handle edge cases such as an empty `expenses` list or zero budget.","solution":"from typing import List, Tuple def calculate_budget(expenses: List[int], budget: int) -> Tuple[int, int]: Computes the total amount spent and the remaining balance from the given expenses and budget. Parameters: expenses (List[int]): A list of integers representing the user\'s monthly expenses. budget (int): An integer representing the user\'s total monthly budget. Returns: Tuple[int, int]: A tuple containing the total amount spent and the remaining balance. total_spent = sum(expenses) remaining_balance = budget - total_spent return total_spent, remaining_balance"},{"question":"# Problem Context In software engineering, algorithms for sorting data are fundamental, often forming the basis of more complex functionalities in various applications. However, certain optimizations can be made based on the characteristics of the data being sorted. One such optimization involves improved handling of nearly sorted or partially sorted data segments to boost overall algorithm performance. # Task You are given the current implementation of a sorting algorithm that uses the QuickSort approach. Optimize this implementation to better handle nearly sorted or partially sorted data by incorporating enhancements that address its worst-case scenarios. # Requirements 1. **Optimize** the QuickSort function: * Modify the pivot selection strategy to improve performance with nearly sorted or reverse sorted lists. * Apply the insertion sort for small subarrays to minimize overhead. 2. **Ensure Robustness**: The outputs should still maintain the correct order as standard sorting algorithms such as Python\'s built-in `sorted()` function. # Input and Output Format 1. `optimized_quick_sort` function: * **Input**: `arr (list of int)`. * **Output**: Sorted list of integers. # Constraints * The input list `arr` can be empty or contain up to (10^6) integers. * Each integer in the list fits within the standard 32-bit integer range. # Edge Cases * Empty list input. * List with all equal elements. * List with large number of small subarrays. # Performance Expectations * Ensure the average-case time complexity remains (O(n log n)) while improving performance for specific cases. * Minimize memory usage and recursive depth where possible. # Example Implement the optimized function and validate its correctness with test cases. **Sample Test** ```python def optimized_quick_sort(arr): if len(arr) <= 1: return arr else: pivot = median_of_three(arr[0], arr[len(arr) // 2], arr[-1]) less = [x for x in arr if x < pivot] equal = [x for x in arr if x == pivot] greater = [x for x in arr if x > pivot] return optimized_quick_sort(less) + equal + optimized_quick_sort(greater) def median_of_three(a, b, c): return sorted([a, b, c])[1] # Assuming the optimized_quick_sort and related helper functions are implemented correctly: from random import shuffle, randint sample_list = list(range(100)) shuffle(sample_list) sorted_sample = optimized_quick_sort(sample_list) assert sorted_sample == sorted(sample_list), \\"The list was not sorted correctly.\\" nearly_sorted_list = sorted(sample_list)[:50] + sorted(sample_list)[50:] sorted_nearly_sorted = optimized_quick_sort(nearly_sorted_list) assert sorted_nearly_sorted == sorted(nearly_sorted_list), \\"The nearly sorted list was not sorted correctly.\\" reversed_list = list(range(100, 0, -1)) sorted_reversed = optimized_quick_sort(reversed_list) assert sorted_reversed == sorted(reversed_list), \\"The reversed list was not sorted correctly.\\" random_list = [randint(1, 1000) for _ in range(100)] sorted_random = optimized_quick_sort(random_list) assert sorted_random == sorted(random_list), \\"The random list was not sorted correctly.\\" print(\\"All tests passed!\\") ```","solution":"def optimized_quick_sort(arr): def insertion_sort(arr, left, right): for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def median_of_three(a, b, c): return sorted([a, b, c])[1] def partition(arr, left, right): mid = left + (right - left) // 2 pivot = median_of_three(arr[left], arr[mid], arr[right]) while left <= right: while arr[left] < pivot: left += 1 while arr[right] > pivot: right -= 1 if left <= right: arr[left], arr[right] = arr[right], arr[left] left += 1 right -= 1 return left def quick_sort(arr, left, right): if left >= right: return elif right - left < 10: insertion_sort(arr, left, right) else: pivot_index = partition(arr, left, right) quick_sort(arr, left, pivot_index - 1) quick_sort(arr, pivot_index, right) quick_sort(arr, 0, len(arr) - 1) return arr"},{"question":"# Problem Statement You are given a binary search tree (BST) and a node N within this tree. Your task is to implement a function that finds the in-order successor of the given node N. The in-order successor of a node in a BST is the node that would appear immediately after the given node in an in-order traversal of the tree. If the given node has no in-order successor, the function should return `None`. # Function Signature ```python class TreeNode: def __init__(self, key: int): self.key = key self.left = None self.right = None self.parent = None def insert(root: TreeNode, key: int) -> TreeNode: pass def find_inorder_successor(root: TreeNode, node: TreeNode) -> TreeNode: pass ``` **Input Format**: - `root` (TreeNode): The root node of the binary search tree. - `node` (TreeNode): The node within the BST whose in-order successor needs to be determined. **Output Format**: - The function `find_inorder_successor` should return the in-order successor node, or `None` if there is no in-order successor. **Constraints**: - The number of nodes n in the BST is in the range [1, 10^3]. - Each key in the BST is a unique integer. - The `insert` function must appropriately insert nodes into the BST maintaining the BST properties. # Example Usage ```python # Create root node and insert other nodes root = TreeNode(20) keys = [10, 30, 5, 15, 25, 35] for key in keys: insert(root, key) # Finding the in-order successor of different nodes node = root.left # Node with key 10 successor = find_inorder_successor(root, node) print(successor.key if successor else None) # Expected output: 15 node = root.right.right # Node with key 35 successor = find_inorder_successor(root, node) print(successor.key if successor else None) # Expected output: None ``` # Evaluation Criteria 1. Correctness: The solution should correctly find and return the in-order successor for various nodes within BST. 2. Efficiency: The solution should perform efficiently even for the upper limit of input size. 3. Edge Handling: Solutions should appropriately handle nodes with no in-order successor, and nodes with complex subtrees. 4. Code Quality: The implementation should be clean, well-documented, and easy to understand.","solution":"class TreeNode: def __init__(self, key: int): self.key = key self.left = None self.right = None self.parent = None def insert(root: TreeNode, key: int) -> TreeNode: if root is None: return TreeNode(key) if key < root.key: if root.left is None: root.left = TreeNode(key) root.left.parent = root else: insert(root.left, key) else: if root.right is None: root.right = TreeNode(key) root.right.parent = root else: insert(root.right, key) return root def find_inorder_successor(root: TreeNode, node: TreeNode) -> TreeNode: # Helper function to find the minimum value node in a tree def find_min(node: TreeNode) -> TreeNode: current = node while current.left is not None: current = current.left return current # If the node has a right subtree, the successor is the minimum node in that subtree if node.right is not None: return find_min(node.right) # Otherwise, traverse up using the parent pointers until # we find a node which is the left child of its parent p = node.parent while p is not None and node == p.right: node = p p = p.parent return p"},{"question":"# Problem Statement You are working on an image processing application that involves manipulating pixel data. Your task is to implement a `rotate_image` function that rotates a given NxN matrix representing an image by 90 degrees clockwise. Function Signature ```python def rotate_image(matrix: list[list[int]]) -> list[list[int]]: pass ``` # Input * **matrix**: A 2D list of integers representing the pixel values of an NxN image. # Output * **Return a new 2D list of integers representing the pixel values of the rotated image**. # Constraints * The size of the matrix (N) will be at least 1 and no more than 1,000. # Example ```python # Input matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Output [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` # Performance Requirements Your solution should run in O(N^2) time complexity, where N is the number of rows (or columns) of the matrix. # Context Rotating images is a common operation in graphic design, photo editing, and computer vision applications. Efficiently implementing this operation is essential for maintaining performance in real-time processing systems.","solution":"def rotate_image(matrix: list[list[int]]) -> list[list[int]]: Rotates a given NxN matrix (2D list) by 90 degrees clockwise. :param matrix: List of list of integers representing pixel values. :return: A new NxN matrix rotated 90 degrees clockwise. N = len(matrix) # Initialize the rotated matrix with the same dimensions rotated_matrix = [[0]*N for _ in range(N)] for i in range(N): for j in range(N): rotated_matrix[j][N-1-i] = matrix[i][j] return rotated_matrix"},{"question":"# Question You are designing a software application for a library to catalog and manage its collection of books. The application should have a function that identifies all books written by a particular author from the library\'s catalog and returns them in a sorted manner based on their publication dates. Your task is to implement the function `find_books_by_author` which: 1. Takes in a list of book details and an author\'s name. 2. Filters out the books written by the specified author. 3. Sorts the filtered books by their publication date in ascending order. 4. Returns the sorted list of book titles. **Function Signature:** ```python def find_books_by_author(books: list[dict], author: str) -> list[str]: pass ``` # Input: - `books`: A list of dictionaries, where each dictionary contains: - `\\"title\\"`: a string representing the book\'s title. - `\\"author\\"`: a string representing the author\'s name. - `\\"publication_date\\"`: a string in the format `\\"YYYY-MM-DD\\"` representing the publication date. - `author`: A string indicating the name of the author to search for. # Output: - Returns a list of book titles sorted by their publication date. # Constraints: - The function must handle cases where the author has no books in the library. - The function should raise a `ValueError` if any book entry does not contain the required keys. # Example: Given the following list of books: ```python books = [ {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"publication_date\\": \\"1925-04-10\\"}, {\\"title\\": \\"This Side of Paradise\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"publication_date\\": \\"1920-03-26\\"}, {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"publication_date\\": \\"1949-06-08\\"}, {\\"title\\": \\"Animal Farm\\", \\"author\\": \\"George Orwell\\", \\"publication_date\\": \\"1945-08-17\\"} ] ``` **Example Usage**: ```python result = find_books_by_author(books, \\"F. Scott Fitzgerald\\") print(result) # Output: [\\"This Side of Paradise\\", \\"The Great Gatsby\\"] ```","solution":"def find_books_by_author(books, author): Identifies all books written by a particular author and returns them in a sorted manner based on their publication dates. Parameters: books (list[dict]): A list of dictionaries containing book details. author (str): The author\'s name to filter by. Returns: list[str]: A list of sorted book titles written by the specified author. required_keys = {\\"title\\", \\"author\\", \\"publication_date\\"} for book in books: if not required_keys <= book.keys(): raise ValueError(\\"Each book entry must contain \'title\', \'author\', and \'publication_date\'\\") # Filter books by the given author filtered_books = [book for book in books if book[\'author\'] == author] # Sort filtered books by publication date sorted_books = sorted(filtered_books, key=lambda x: x[\'publication_date\']) # Extract titles from the sorted books titles = [book[\'title\'] for book in sorted_books] return titles"},{"question":"# Longest Substring Without Repeating Characters Scenario You are developing a text processing tool that helps in analyzing unique character patterns in strings. One of the features is to identify the longest substring without repeating characters. Task Implement the `longest_unique_substring` function provided below, which finds the longest substring without repeating characters in a given input string. Function Signature ```python def longest_unique_substring(s: str) -> str: ``` Input * `s`: A string of `n` lowercase and/or uppercase Latin letters where (1 leq n leq 10^5). Output * A string representing the longest substring without repeating characters. - If there are multiple results with the same length, return the substring which appears first. Constraints * The input string will contain only alphabets (both uppercase and lowercase). Example Consider the following input and output scenarios: ```python # Example 1 s = \\"abcabcbb\\" # Expected Output # Longest Unique Substring: \\"abc\\" # Example 2 s = \\"bbbbb\\" # Expected Output # Longest Unique Substring: \\"b\\" # Example 3 s = \\"pwwkew\\" # Expected Output # Longest Unique Substring: \\"wke\\" # Example 4 s = \\"abcdedcba\\" # Expected Output # Longest Unique Substring: \\"abcde\\" ``` Performance Requirements Ensure the algorithm efficiently handles strings with up to (10^5) characters, providing a quick response suitable for large text analysis in real-time applications.","solution":"def longest_unique_substring(s: str) -> str: Finds the longest substring without repeating characters in a given string. char_index_map = {} start = 0 max_length = 0 max_substring = \\"\\" for end in range(len(s)): if s[end] in char_index_map and char_index_map[s[end]] >= start: start = char_index_map[s[end]] + 1 char_index_map[s[end]] = end current_length = end - start + 1 if current_length > max_length: max_length = current_length max_substring = s[start:end + 1] return max_substring"},{"question":"Context: You\'re implementing a simplified event-driven system that manages a series of tasks. Each task has a priority level and is triggered by specific events. This problem will test your understanding of priority queues, event handling, and the efficient management of task executions. # Task: 1. Implement a `Task` class with the following attributes and methods: - `__init__(self, name: str, priority: int)` that initializes a task with a given name and priority. - `__lt__(self, other: Any) -> bool` that allows comparison between tasks based on their priority (higher priority tasks should come first). 2. Implement an `EventManager` class with the following features: - A method `add_task(self, task: Task) -> None` that adds a task to the event manager. - A method `trigger_event(self, event_name: str) -> List[str]` that returns a list of task names that should be executed for the given event, in order of their priority. # Function Signatures: ```python class Task: def __init__(self, name: str, priority: int): Initializes a task with a specified name and priority. def __lt__(self, other: Any) -> bool: Compares two tasks based on priority. class EventManager: def add_task(self, task: Task) -> None: Adds a task to the event manager. def trigger_event(self, event_name: str) -> List[str]: Triggers an event and returns a list of task names to execute in order of priority. ``` # Input & Output Formats: - The `__init__` method of `Task` takes a string `name` and an integer `priority`. - The `__lt__` method of `Task` takes another task object for comparison. - The `add_task` method of `EventManager` takes a `Task` object and returns `None`. - The `trigger_event` method of `EventManager` takes a string `event_name` and returns a list of strings representing the names of the tasks to be executed. # Constraints: - The system must handle multiple tasks and events efficiently. - Tasks with the same priority should be executed in the order they were added. - The solution should handle edge cases such as triggering events with no associated tasks. # Performance Requirements: - Adding a task should perform in O(log n) due to the use of a priority queue. - Triggering an event should perform in O(m log n), where m is the number of tasks to be executed and n is the total number of tasks. # Example: ```python # Initialize event manager em = EventManager() # Add tasks to event manager em.add_task(Task(\\"Task1\\", 2)) em.add_task(Task(\\"Task2\\", 1)) em.add_task(Task(\\"Task3\\", 3)) # Trigger an event print(em.trigger_event(\\"Event1\\")) # Expected Output: [\\"Task3\\", \\"Task1\\", \\"Task2\\"] # Add more tasks em.add_task(Task(\\"Task4\\", 2)) em.add_task(Task(\\"Task5\\", 3)) # Trigger another event print(em.trigger_event(\\"Event2\\")) # Expected Output: [\\"Task5\\", \\"Task3\\", \\"Task4\\", \\"Task1\\", \\"Task2\\"] ```","solution":"from typing import List, Any import heapq class Task: def __init__(self, name: str, priority: int): Initializes a task with a specified name and priority. self.name = name self.priority = priority def __lt__(self, other: Any) -> bool: Compares two tasks based on priority. return self.priority > other.priority class EventManager: def __init__(self): Initialize an empty event manager with a priority queue. self.tasks = [] def add_task(self, task: Task) -> None: Adds a task to the event manager. heapq.heappush(self.tasks, task) def trigger_event(self, event_name: str) -> List[str]: Triggers an event and returns a list of task names to execute in order of priority. tasks_to_execute = [heapq.heappop(self.tasks).name for _ in range(len(self.tasks))] return tasks_to_execute"},{"question":"# Problem Statement You are to develop a function that processes a list of transactions and identifies any fraudulent activities. Each transaction contains details such as the transaction ID, user ID, amount, and timestamp. Transactions are considered fraudulent if the same user makes transactions with equal amounts for three consecutive times within a 10-minute window. # Function Signature ```python def detect_fraudulent_transactions(transactions: list[dict]) -> list[str]: Given a list of transactions, identify any transactions considered fraudulent based on specific criteria. Parameters: transactions: A list of dictionaries where each dictionary represents a transaction with keys \'id\', \'user_id\', \'amount\', and \'timestamp\'. Returns: A list of transaction IDs that are considered fraudulent. pass ``` # Requirements 1. **Input**: A list of transactions, each represented as a dictionary (e.g., `transactions = [{\\"id\\": \\"txn1\\", \\"user_id\\": \\"user1\\", \\"amount\\": 100, \\"timestamp\\": \\"2023-01-01T00:00:00Z\\"}, ...]`). 2. **Output**: A list of transaction IDs that are considered fraudulent. 3. **Constraints**: - The timestamp is in ISO 8601 format (e.g., \\"2023-01-01T00:00:00Z\\"). - Transactions are provided in chronological order. - You should consider all potential edge cases (e.g., insufficient transactions for fraud detection, varying transaction amounts). - Avoid using global variables. # Performance Requirements Your implementation should: 1. Be able to handle at least 1,000 transactions within a reasonable time frame. 2. Optimize for both time and space where possible. # Example ```python transactions = [ {\\"id\\": \\"txn1\\", \\"user_id\\": \\"user1\\", \\"amount\\": 100, \\"timestamp\\": \\"2023-01-01T00:00:00Z\\"}, {\\"id\\": \\"txn2\\", \\"user_id\\": \\"user1\\", \\"amount\\": 100, \\"timestamp\\": \\"2023-01-01T00:05:00Z\\"}, {\\"id\\": \\"txn3\\", \\"user_id\\": \\"user1\\", \\"amount\\": 100, \\"timestamp\\": \\"2023-01-01T00:10:00Z\\"}, {\\"id\\": \\"txn4\\", \\"user_id\\": \\"user2\\", \\"amount\\": 200, \\"timestamp\\": \\"2023-01-01T00:15:00Z\\"}, {\\"id\\": \\"txn5\\", \\"user_id\\": \\"user1\\", \\"amount\\": 300, \\"timestamp\\": \\"2023-01-01T00:20:00Z\\"} ] result = detect_fraudulent_transactions(transactions) # Example \'result\': # [\\"txn1\\", \\"txn2\\", \\"txn3\\"] ``` # Evaluation Criteria 1. **Correctness**: Correctly identify fraudulent transactions based on the given criteria. 2. **Efficiency**: The function should process the transactions promptly without excessive delay. 3. **Robustness**: Effectively handle edge cases and potential errors.","solution":"from datetime import datetime, timedelta def detect_fraudulent_transactions(transactions): Given a list of transactions, identify any transactions considered fraudulent based on specific criteria. Parameters: transactions: A list of dictionaries where each dictionary represents a transaction with keys \'id\', \'user_id\', \'amount\', and \'timestamp\'. Returns: A list of transaction IDs that are considered fraudulent. fraudulent_ids = [] user_transactions = {} for txn in transactions: user_id = txn[\'user_id\'] amount = txn[\'amount\'] txn_id = txn[\'id\'] timestamp = datetime.fromisoformat(txn[\'timestamp\'].replace(\\"Z\\", \\"+00:00\\")) if user_id not in user_transactions: user_transactions[user_id] = [] user_transactions[user_id].append((amount, timestamp, txn_id)) # Only check for fraud if we have at least 3 transactions if len(user_transactions[user_id]) >= 3: # Extract the last three transactions for the user last_three = user_transactions[user_id][-3:] if last_three[0][0] == last_three[1][0] == last_three[2][0]: if last_three[2][1] - last_three[0][1] <= timedelta(minutes=10): # Add all three transaction IDs as fraudulent fraudulent_ids.extend([last_three[0][2], last_three[1][2], last_three[2][2]]) return list(set(fraudulent_ids))"},{"question":"# Problem Statement You are tasked with finding the smallest positive integer `x` such that the product of its digits is equal to a given integer `d`. For example, if `d = 36`, the smallest `x` would be `49` because `4 * 9 = 36` and there is no smaller positive integer whose digits multiply to 36. Write a function that calculates this smallest integer `x` for a given integer `d`. If no such integer exists, the function should return `-1`. # Function Signature ```python def smallest_integer_product(d: int) -> int: ``` # Input * `d` (int): An integer where `1 ≤ d ≤ 10^9`. # Output * An integer which is the smallest positive integer `x` such that the product of its digits equals `d`, or `-1` if no such integer exists. # Constraints - `1 ≤ d ≤ 10^9` # Example ```python assert smallest_integer_product(36) == 49 assert smallest_integer_product(10) == 25 assert smallest_integer_product(15) == 35 assert smallest_integer_product(1) == 1 assert smallest_integer_product(0) == -1 ``` # Hints 1. Consider the digits from 9 to 1 and try to build the number from the largest possible digits. 2. Ensure that the combination of digits forms the smallest possible number by appropriately sorting or arranging the digits. 3. Handle edge cases such as when `d` is 1, which directly maps to `1`, and `0` which does not have a valid representation.","solution":"def smallest_integer_product(d: int) -> int: if d == 1: return 1 if d == 0: return -1 factors = [] # Decompose d into its prime factors from 9 to 2 for i in range(9, 1, -1): while d % i == 0: factors.append(i) d //= i # If d is not 1 after factorization, then it\'s not possible if d != 1: return -1 # Sort factors to create the smallest possible number factors.sort() # Combine these factors to form the smallest possible number result = int(\'\'.join(map(str, factors))) return result"},{"question":"# Alien Dictionary Sort Order You have intercepted a transmission from alien creatures on another planet that uses a different alphabet order than ours. Based on the data, you need to determine if the given alien words follow their specified order. The alien dictionary is provided in the form of an ordered string (alien_order), where each character represents a letter in the alien alphabet in its respective order from left to right. Your task is to write a function that checks if the provided list of words is sorted according to the alien alphabet order. **Function Signature**: ```python def is_alien_sorted(words: List[str], alien_order: str) -> bool: pass ``` **Parameters**: - **words**: A list of strings representing the words in the alien language. - **alien_order**: A string representing the order of characters in the alien alphabet. **Returns**: - `True` if the words are sorted based on the alien_order, otherwise `False`. # Example ```python words = [\\"hello\\", \\"leetcode\\"] alien_order = \\"hlabcdefgijkmnopqrstuvwxyz\\" print(is_alien_sorted(words, alien_order)) # Output: True words = [\\"word\\", \\"world\\", \\"row\\"] alien_order = \\"worldabcefghijkmnpqstuvxyz\\" print(is_alien_sorted(words, alien_order)) # Output: False ``` # Constraints - All characters in the words and the alien_order string are lowercase English letters. - The length of `alien_order` is exactly 26. - The number of words will not exceed 100. - The length of each word will not exceed 20. # Notes: - You need to map the given alien alphabet order to our known English alphabet for comparison. - Edge cases include words being prefixes of others or having the same prefix.","solution":"def is_alien_sorted(words, alien_order): Returns True if the words are sorted according to the given alien_order, otherwise returns False. # Create a dictionary to map each character to its rank in the alien order order_index = {char: idx for idx, char in enumerate(alien_order)} # Function to compare two words def compare_words(word1, word2): for char1, char2 in zip(word1, word2): if order_index[char1] < order_index[char2]: return True if order_index[char1] > order_index[char2]: return False return len(word1) <= len(word2) # Compare each adjacent word pair in the list for i in range(len(words) - 1): if not compare_words(words[i], words[i + 1]): return False return True"},{"question":"# Question: Log File Analyzer You are tasked with developing a log file analyzer for a web server. Logs are typically used for monitoring, measuring performance, and debugging purposes. Your tool should be able to parse a log file and extract useful information. Requirements: 1. Write a function `analyze_log` which accepts a file path to a web server log file and returns a summary report. 2. The summary report should include: - Total number of requests. - Number of successful requests (status code 200). - Number of client errors (status code 4xx). - Number of server errors (status code 5xx). 3. Assume the log format follows the Common Log Format (CLF): ``` 127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] \\"GET /apache_pb.gif HTTP/1.0\\" 200 2326 ``` 4. Handle the scenario where the log file might be very large and cannot be read into memory all at once. Function Signature: ```python def analyze_log(file_path: str) -> dict: pass ``` # Constraints: - You must use standard Python libraries for file handling. - Optimize for performance, particularly for handling large files. Input: - `file_path` (str): The path to the log file to be analyzed. Output: - `dict`: A dictionary containing the summary report with keys `total_requests`, `successful_requests`, `client_errors`, and `server_errors`. Example: ```python report = analyze_log(\\"server.log\\") print(report) ``` Expected output if the log summary is as follows: ```plaintext { \\"total_requests\\": 10000, \\"successful_requests\\": 8000, \\"client_errors\\": 1500, \\"server_errors\\": 500, } ``` # Performance Requirements: - Ensure the function executes efficiently, especially with large log files. - Avoid loading the entire file into memory; consider reading the file line by line. Additional Notes: - Ensure your implementation processes each line of the log file correctly and handles any edge cases, such as malformed lines. - Provide clear documentation and comments within your code to enhance readability and maintainability.","solution":"def analyze_log(file_path: str) -> dict: Analyzes a web server log file and returns a summary report. Args: file_path (str): The path to the log file to be analyzed. Returns: dict: A dictionary containing the summary report with keys: \'total_requests\', \'successful_requests\', \'client_errors\', \'server_errors\'. # Initialize counters total_requests = 0 successful_requests = 0 client_errors = 0 server_errors = 0 # Read the file line by line with open(file_path, \'r\') as file: for line in file: total_requests += 1 parts = line.split() if len(parts) > 8: status_code = parts[8] if status_code.isdigit(): status_code = int(status_code) if 200 <= status_code < 300: successful_requests += 1 elif 400 <= status_code < 500: client_errors += 1 elif 500 <= status_code < 600: server_errors += 1 # Return the summary report return { \\"total_requests\\": total_requests, \\"successful_requests\\": successful_requests, \\"client_errors\\": client_errors, \\"server_errors\\": server_errors, }"},{"question":"# Coding Assessment Question Problem Statement You are tasked with enhancing a Community Detection algorithm based on the Louvain method to identify communities within a network graph. The Louvain method is a heuristic method that attempts to optimize the modularity of a partition of the network. It begins with each node in its own community and iteratively improves community structures for better modularity. You need to implement the function `enhanced_community_detection` which detects communities in a graph with an optimized version of the Louvain method. Your implementation should precompute necessary data structures and apply an efficient update mechanism. Function Signature ```python def enhanced_community_detection( graph: dict[int, list[tuple[int, int]]], max_passes: int, min_modularity_gain: float ) -> dict[int, int]: pass ``` Input - `graph (dict[int, list[tuple[int, int]]])`: A dictionary representing the graph where keys are node identifiers, and values are lists of tuples representing the adjacent nodes and their respective edge weights. - `max_passes (int)`: The maximum number of passes during optimization. - `min_modularity_gain (float)`: The minimum modularity gain needed to continue optimization in each pass. Output - Returns a dictionary: - The keys are node identifiers. - The values are community identifiers. Constraints - All node and edge values will be valid and positive. - The number of nodes will be at least 2 and up to 10^5. - The number of edges will be at most 5*10^5. Requirements - **Performance Optimization**: Utilize precomputed data structures, such as lookup tables and cumulative sums, to efficiently compute modularity changes. - **Efficient Update Mechanism**: Implement an efficient mechanism to update community assignments and modularity changes. Example ```python graph = { 0: [(1, 1), (2, 1)], 1: [(0, 1), (2, 1)], 2: [(0, 1), (1, 1), (3, 1)], 3: [(2, 1), (4, 1)], 4: [(3, 1)] } result = enhanced_community_detection( graph=graph, max_passes=10, min_modularity_gain=0.0001 ) print(f\\"Community Assignments: {result}\\") ``` Expected Output: ``` Community Assignments: {0: 1, 1: 1, 2: 1, 3: 2, 4: 2} ``` --- Notes 1. Ensure to handle cases where the input `graph` dictionary is empty or contains only a few nodes or edges. 2. Precompute necessary data structures to avoid redundant computations during community updates. 3. Use an efficient method to update community assignments and calculate modularity changes, such as incremental updates based on node movements. ---","solution":"def enhanced_community_detection( graph: dict[int, list[tuple[int, int]]], max_passes: int, min_modularity_gain: float ) -> dict[int, int]: from collections import defaultdict import math def modularity_gain(graph, communities, node, new_comm, total_weight): # calculates modularity gain of moving node to new_comm current_comm = communities[node] node_weight = sum([weight for _, weight in graph[node]]) community_weight = sum([sum([weight for _, weight in graph[n]]) for n in communities if communities[n] == new_comm]) inner_links = sum([weight for neighbor, weight in graph[node] if communities[neighbor] == new_comm]) if current_comm == new_comm: return 0 delta_q = (inner_links / total_weight) - (node_weight / (2 * total_weight)) * (community_weight / (2 * total_weight)) return delta_q def total_modularity(graph, communities, total_weight): # calculates total modularity q = 0 for node in graph: for neighbor, weight in graph[node]: if communities[node] == communities[neighbor]: q += weight return q / (2 * total_weight) # Initialization communities = {node: node for node in graph} # initially each node is its own community total_weight = sum([weight for neighbors in graph.values() for _, weight in neighbors]) / 2 for _ in range(max_passes): improved = False for node in graph: best_comm = communities[node] best_gain = 0 # Remove node from its community original_comm = communities[node] communities[node] = None for neighbor, _ in graph[node]: new_comm = communities[neighbor] gain = modularity_gain(graph, communities, node, new_comm, total_weight) if gain > best_gain: best_gain = gain best_comm = new_comm if best_gain > min_modularity_gain: communities[node] = best_comm improved = True else: communities[node] = original_comm if not improved: break # Re-index communities to be sequential comm_index = {} counter = 0 for node in communities: if communities[node] not in comm_index: comm_index[communities[node]] = counter counter += 1 communities[node] = comm_index[communities[node]] return communities"},{"question":"# Median of Two Sorted Arrays You\'re tasked with creating a component of a financial analysis tool that can merge datasets efficiently. One specific task involves finding the median of two sorted arrays, which represent daily stock prices from two different sources. Task: Write a function `find_median_sorted_arrays` that finds the median of two sorted arrays of stock prices. ```python def find_median_sorted_arrays(arr1: List[float], arr2: List[float]) -> float: # Implement the function pass ``` Parameters: * **arr1** (List[float]): A list representing the first sorted array of stock prices. * **arr2** (List[float]): A list representing the second sorted array of stock prices. Returns: * **float**: The median of the combined sorted arrays. Details: - The median is the middle value in an ordered list of numbers. If the combined list has an odd number of elements, the median is the middle element. If it has an even number of elements, the median is the average of the two middle elements. - You must not use any built-in sort functions or libraries that perform sorting. - The overall run-time complexity should be O(log(min(n, m))), where n and m are the lengths of the two arrays. Examples: ```python >>> find_median_sorted_arrays([1, 3], [2]) 2.0 >>> find_median_sorted_arrays([1, 2], [3, 4]) 2.5 >>> find_median_sorted_arrays([0, 0], [0, 0]) 0.0 >>> find_median_sorted_arrays([], [1]) 1.0 >>> find_median_sorted_arrays([2], []) 2.0 ``` Constraints: * The arrays will either not be empty at the same time (i.e., at least one array is non-empty). * Arrays will contain floating-point numbers ranging between (-10^6) and (10^6). Notes: * Handle edge cases where one of the arrays might be empty. * Ensure your solution is optimized to handle large inputs efficiently.","solution":"def find_median_sorted_arrays(arr1, arr2): Finds the median of two sorted arrays. # Ensure arr1 is the smaller array if len(arr1) > len(arr2): arr1, arr2 = arr2, arr1 n, m = len(arr1), len(arr2) imin, imax, half_len = 0, n, (n + m + 1) // 2 while imin <= imax: i = (imin + imax) // 2 j = half_len - i if i < n and arr1[i] < arr2[j - 1]: imin = i + 1 elif i > 0 and arr1[i - 1] > arr2[j]: imax = i - 1 else: if i == 0: max_of_left = arr2[j - 1] elif j == 0: max_of_left = arr1[i - 1] else: max_of_left = max(arr1[i - 1], arr2[j - 1]) if (n + m) % 2 == 1: return max_of_left if i == n: min_of_right = arr2[j] elif j == m: min_of_right = arr1[i] else: min_of_right = min(arr1[i], arr2[j]) return (max_of_left + min_of_right) / 2.0"},{"question":"# Coding Challenge: Dynamic String Search and Replace # Question: You are tasked with writing a function that searches for all occurrences of a specific word in a given text and replaces each occurrence with an alternate word. The replacement should be case-sensitive and should only match whole words. Additionally, the function should be able to handle various punctuation marks around the words. **Function Signature**: ```python def string_search_replace(text: str, target_word: str, replacement_word: str) -> str: pass ``` **Parameters**: - `text` (str): The input text where the search and replace operation will be performed. - `target_word` (str): The word to search for in the text. - `replacement_word` (str): The word to replace each occurrence of the target_word with. **Returns**: - `str`: The modified text after replacing all occurrences of the target_word with the replacement_word. **Constraints**: - Ensure that the target_word matches whole words only. For example, if `target_word` is \\"cat\\", it should not match \\"catholic\\" or \\"scatter\\". - Handle punctuation marks appropriately around the words. - The function should be case-sensitive. For example, \\"Cat\\" and \\"cat\\" are treated as distinct words. - Assume that the input text will be a non-empty string. **Performance Requirements**: - Ensure efficient execution even with large input texts. **Example**: ```python text = \\"The cat sat on the mat. The cat was happy.\\" target_word = \\"cat\\" replacement_word = \\"dog\\" # Expected output: \\"The dog sat on the mat. The dog was happy.\\" print(string_search_replace(text, target_word, replacement_word)) text = \\"She said \'Hello, World!\' and the world responded.\\" target_word = \\"world\\" replacement_word = \\"universe\\" # Expected output: \\"She said \'Hello, World!\' and the universe responded.\\" print(string_search_replace(text, target_word, replacement_word)) ``` **Hint**: You may want to use regular expressions to handle the identification of whole words and manage surrounding punctuation properly.","solution":"import re def string_search_replace(text: str, target_word: str, replacement_word: str) -> str: Searches for all occurrences of target_word in text and replaces each occurrence with replacement_word. The replacement is case-sensitive and only matches whole words. :param text: The input text where the search and replace operation will be performed. :param target_word: The word to search for in the text. :param replacement_word: The word to replace each occurrence of the target_word with. :return: The modified text after replacing all occurrences of the target_word. # Use regular expressions to match whole words only pattern = rf\'b{re.escape(target_word)}b\' return re.sub(pattern, replacement_word, text)"},{"question":"# Problem Statement: You are tasked with implementing a class that performs basic banking operations. The `BankAccount` class should allow users to create an account, deposit and withdraw money, and check the balance. Additionally, the class should maintain a transaction log that records all deposit and withdrawal operations. Your task is to implement the `BankAccount` class and ensure it correctly handles various edge cases and constraints. # Requirements: 1. **Implement the `BankAccount` class** with the following methods: - `__init__(self, initial_balance: float = 0.0)`: Initializes the account with an initial balance. - `deposit(self, amount: float) -> None`: Adds the specified amount to the account balance. - `withdraw(self, amount: float) -> bool`: Subtracts the specified amount from the account balance if sufficient funds are available. Returns `True` if the withdrawal is successful, otherwise `False`. - `get_balance(self) -> float`: Returns the current account balance. - `get_transaction_log(self) -> list`: Returns a list of tuples representing the transaction log. Each tuple should contain the transaction type (\'DEPOSIT\' or \'WITHDRAW\') and the amount. 2. **Handle edge cases** such as: - Depositing or withdrawing negative amounts (should not be allowed). - Withdrawing amounts greater than the current balance. - Ensuring the balance never becomes a negative value. # Class Definition: ```python class BankAccount: def __init__(self, initial_balance: float = 0.0): def deposit(self, amount: float) -> None: def withdraw(self, amount: float) -> bool: def get_balance(self) -> float: def get_transaction_log(self) -> list: ``` # Input: - **Initial Balance**: A float representing the initial balance when creating the account. - **Amount**: A float representing the amount to deposit or withdraw. # Output: - Returns the balance as a float. - Returns a boolean indicating a successful or failed withdrawal. - Returns a list of transaction logs with the specified format. # Examples: ```python # Create a new bank account with an initial balance of 100.00 account = BankAccount(100.0) # Deposit 50.00 account.deposit(50.0) assert account.get_balance() == 150.0 # Withdraw 30.00 assert account.withdraw(30.0) == True assert account.get_balance() == 120.0 # Attempt to withdraw 200.00 (should fail) assert account.withdraw(200.0) == False assert account.get_balance() == 120.0 # Check transaction log assert account.get_transaction_log() == [(\'DEPOSIT\', 50.0), (\'WITHDRAW\', 30.0), (\'WITHDRAW\', 200.0)] ``` # Notes: - Ensure your `BankAccount` class is robust and handles edge cases properly. - Do not alter the class/method signatures. - You may add helper functions if needed but ensure they follow the required logic and constraints. # Constraints: - All amounts will be non-negative floats. - The initial balance will not exceed 10,000.0.","solution":"class BankAccount: def __init__(self, initial_balance: float = 0.0): self.balance = initial_balance self.transaction_log = [] def deposit(self, amount: float) -> None: if amount <= 0: raise ValueError(\\"Cannot deposit a non-positive amount.\\") self.balance += amount self.transaction_log.append((\'DEPOSIT\', amount)) def withdraw(self, amount: float) -> bool: if amount <= 0: raise ValueError(\\"Cannot withdraw a non-positive amount.\\") if amount > self.balance: return False self.balance -= amount self.transaction_log.append((\'WITHDRAW\', amount)) return True def get_balance(self) -> float: return self.balance def get_transaction_log(self) -> list: return self.transaction_log"},{"question":"# Coding Assessment Question **Context**: The city transport department of `MetroCity` wants to implement a bus fare calculator that provides the fare based on the distance traveled. Buses in the city have a fixed fare rate per kilometer, but there are different categories of buses (e.g., regular, express, night) that have different base fares and additional charges. # Task Write a function `calculate_bus_fare` that takes in the type of bus, distance traveled, and whether it is a peak hour or not, and returns the total fare for the journey. # Function Signature ```python def calculate_bus_fare(bus_type: str, distance: float, peak_hour: bool) -> float: ``` # Input - `bus_type` (str): A string representing the type of bus (\'regular\', \'express\', \'night\'). - `distance` (float): A float representing the distance traveled in kilometers. - `peak_hour` (bool): A boolean indicating whether it is peak hour (True) or not (False). # Output - Returns a float representing the calculated total fare for the journey. # Constraints - `bus_type` should be one of \'regular\', \'express\', \'night\'. - `distance` should be a positive float representing the distance traveled. - The fare must be calculated according to the following rules: - Regular Bus: Base fare 2.00 + 1.50 per kilometer - Express Bus: Base fare 3.00 + 2.00 per kilometer - Night Bus: Base fare 2.50 + 1.75 per kilometer - Peak hour (7-9 AM and 5-7 PM): An additional 20% surcharge on the total fare # Example Given the input parameters: ```python print(calculate_bus_fare(\'express\', 10.0, True)) ``` Expected Output: ``` 26.4 ``` Explanation: - Base fare for express bus = 3.00 - Distance fare for 10 km = 10 * 2.00 = 20.00 - Total fare before peak hour surcharge = 3.00 + 20.00 = 23.00 - Adding peak hour surcharge of 20% = 23.00 + 4.60 = 27.60","solution":"def calculate_bus_fare(bus_type: str, distance: float, peak_hour: bool) -> float: base_fares = { \'regular\': 2.00, \'express\': 3.00, \'night\': 2.50, } fare_per_km = { \'regular\': 1.50, \'express\': 2.00, \'night\': 1.75, } if bus_type not in base_fares or distance < 0: raise ValueError(\'Invalid bus type or distance\') base_fare = base_fares[bus_type] per_km_fare = fare_per_km[bus_type] * distance total_fare = base_fare + per_km_fare if peak_hour: total_fare *= 1.2 return round(total_fare, 2)"},{"question":"**Context:** In many applications, data often needs to be condensed or extracted based on specific criteria. For example, in signal processing or time series analysis, it is common to work with moving averages to understand trends over time. **Question:** Write a function `moving_average(nums: List[int], k: int) -> List[float]` to calculate the moving average of a list of integers `nums` with a window size `k`. The moving average at each position is defined as the average of the current element and the preceding `k-1` elements. If there are fewer than `k` elements before the current position, average all the elements available. **Expected Input and Output:** * **Input:** A list of integers `nums` and an integer `k`. For example `[1, 3, 5, 7, 9]` and `3`. * **Output:** A list of float numbers representing the moving average. For instance, if the input is `[1, 3, 5, 7, 9]` and `k=3`, the output should be `[1.0, 2.0, 3.0, 5.0, 7.0]`. **Function Signature:** ```python from typing import List def moving_average(nums: List[int], k: int) -> List[float]: pass ``` **Constraints:** - The list `nums` may contain up to (10^5) elements. - `1 <= k <= len(nums)`. **Additional Notes:** - You should use a sliding window technique to ensure the function runs efficiently. - The result should be rounded to one decimal place for uniformity.","solution":"from typing import List def moving_average(nums: List[int], k: int) -> List[float]: result = [] window_sum = 0 window = [] for i in range(len(nums)): window.append(nums[i]) window_sum += nums[i] if len(window) > k: window_sum -= window.pop(0) result.append(round(window_sum / min(k, i + 1), 1)) return result"},{"question":"# Question: Implement a Basic RSA Encryption and Decryption Problem Statement: You are tasked with implementing a basic RSA encryption and decryption system. RSA is a widely used public-key cryptosystem that relies on the difficulty of factoring large integers. Your job is to write functions to generate public and private keys, encrypt and decrypt messages. Requirements: 1. Write a function `is_prime(n: int) -> bool` that checks whether a given number n is a prime number. 2. Write a function `gcd(a: int, b: int) -> int` that computes the greatest common divisor (GCD) of two numbers. 3. Write a function `modinv(a: int, m: int) -> int` that computes the modular multiplicative inverse of a modulo m using the Extended Euclidean Algorithm. 4. Write a function `generate_keys(p: int, q: int) -> (tuple, tuple)` that generates the RSA public and private keys given two distinct prime numbers p and q. 5. Write a function `encrypt(public_key: tuple, plaintext: str) -> list` that encrypts a string message using the given public key. 6. Write a function `decrypt(private_key: tuple, ciphertext: list) -> str` that decrypts a list of integers (encrypted message) using the given private key. Input Format: * Two distinct primes `p` and `q` for key generation. * A string `plaintext` for encryption. * An encrypted message `ciphertext` (list of integers) for decryption. Output Format: * The generated public and private keys should be printed on the same line as: * `Public Key = (<e>, <n>), Private Key = (<d>, <n>)`. * The encrypted message should be displayed as: `Encrypted Message = <ciphertext>`. * The decrypted message should be displayed as: `Decrypted Message = <plaintext>`. Constraints: * (2 leq p, q leq 100) * (p neq q) * The plaintext should only contain alphabetical characters and spaces. Example: Input: ``` Enter prime number p: 11 Enter prime number q: 13 Enter plaintext message: HELLO ``` Output: ``` Public Key = (7, 143), Private Key = (103, 143) Encrypted Message = [121, 40, 38, 38, 121] Decrypted Message = HELLO ``` Implementation: ```python def is_prime(n: int) -> bool: if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n ** 0.5) + 1, 2): if n % i == 0: return False return True def gcd(a: int, b: int) -> int: while b: a, b = b, a % b return a def modinv(a: int, m: int) -> int: m0, x0, x1 = m, 0, 1 if m == 1: return 0 while a > 1: q = a // m m, a = a % m, m x0, x1 = x1 - q * x0, x0 if x1 < 0: x1 += m0 return x1 def generate_keys(p: int, q: int) -> (tuple, tuple): if not (is_prime(p) and is_prime(q)): raise ValueError(\\"Both numbers must be prime.\\") if p == q: raise ValueError(\\"p and q cannot be the same.\\") n = p * q phi = (p - 1) * (q - 1) e = 2 while gcd(e, phi) != 1: e += 1 d = modinv(e, phi) return (e, n), (d, n) def encrypt(public_key: tuple, plaintext: str) -> list: e, n = public_key plaintext_integers = [ord(char) for char in plaintext] ciphertext = [pow(m, e, n) for m in plaintext_integers] return ciphertext def decrypt(private_key: tuple, ciphertext: list) -> str: d, n = private_key plaintext_integers = [pow(c, d, n) for c in ciphertext] plaintext = \'\'.join(chr(m) for m in plaintext_integers) return plaintext if __name__ == \\"__main__\\": p = int(input(\\"Enter prime number p: \\")) q = int(input(\\"Enter prime number q: \\")) public_key, private_key = generate_keys(p, q) print(f\\"Public Key = {public_key}, Private Key = {private_key}\\") plaintext = input(\\"Enter plaintext message: \\") ciphertext = encrypt(public_key, plaintext) print(f\\"Encrypted Message = {ciphertext}\\") decrypted_message = decrypt(private_key, ciphertext) print(f\\"Decrypted Message = {decrypted_message}\\") ```","solution":"def is_prime(n: int) -> bool: if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n ** 0.5) + 1, 2): if n % i == 0: return False return True def gcd(a: int, b: int) -> int: while b: a, b = b, a % b return a def modinv(a: int, m: int) -> int: m0, x0, x1 = m, 0, 1 if m == 1: return 0 while a > 1: q = a // m m, a = a % m, m x0, x1 = x1 - q * x0, x0 if x1 < 0: x1 += m0 return x1 def generate_keys(p: int, q: int) -> (tuple, tuple): if not (is_prime(p) and is_prime(q)): raise ValueError(\\"Both numbers must be prime.\\") if p == q: raise ValueError(\\"p and q cannot be the same.\\") n = p * q phi = (p - 1) * (q - 1) e = 2 while gcd(e, phi) != 1: e += 1 d = modinv(e, phi) return (e, n), (d, n) def encrypt(public_key: tuple, plaintext: str) -> list: e, n = public_key plaintext_integers = [ord(char) for char in plaintext] ciphertext = [pow(m, e, n) for m in plaintext_integers] return ciphertext def decrypt(private_key: tuple, ciphertext: list) -> str: d, n = private_key plaintext_integers = [pow(c, d, n) for c in ciphertext] plaintext = \'\'.join(chr(m) for m in plaintext_integers) return plaintext if __name__ == \\"__main__\\": p = int(input(\\"Enter prime number p: \\")) q = int(input(\\"Enter prime number q: \\")) public_key, private_key = generate_keys(p, q) print(f\\"Public Key = {public_key}, Private Key = {private_key}\\") plaintext = input(\\"Enter plaintext message: \\") ciphertext = encrypt(public_key, plaintext) print(f\\"Encrypted Message = {ciphertext}\\") decrypted_message = decrypt(private_key, ciphertext) print(f\\"Decrypted Message = {decrypted_message}\\")"},{"question":"# Question: Matrix Transposition You are tasked with implementing a function that transposes a given matrix. The function should handle both square and rectangular matrices, including edge cases and input validation appropriately. Transposing a matrix involves swapping its rows with its columns. For instance: - The transpose of (begin{bmatrix}1 & 2 3 & 4end{bmatrix}) is (begin{bmatrix}1 & 3 2 & 4end{bmatrix}) - The transpose of (begin{bmatrix}1 & 2 & 3 4 & 5 & 6end{bmatrix}) is (begin{bmatrix}1 & 4 2 & 5 3 & 6end{bmatrix}) Your function should raise an appropriate error for invalid inputs. **Function Signature**: ```python def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: pass ``` # Input - `matrix` (list of list of integers): A list of lists where each sublist represents a row in the matrix. # Output - Returns the transposed matrix as a list of lists. # Constraints - The function should check if the matrix is empty and handle it appropriately. - The function should validate that all rows are of the same length. - Use appropriate error messages mentioned in the given snippets. - The function should raise a `ValueError` if the input is not a valid matrix. - Consider edge cases such as single row or single column matrices. # Examples ```python assert transpose_matrix([[1, 2], [3, 4]]) == [[1, 3], [2, 4]] assert transpose_matrix([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]] assert transpose_matrix([[1]]) == [[1]] assert transpose_matrix([[1, 2, 3]]) == [[1], [2], [3]] assert transpose_matrix([[1], [2], [3]]) == [[1, 2, 3]] try: transpose_matrix([[], []]) except ValueError as e: assert str(e) == \\"transpose_matrix() received an invalid matrix: empty rows\\" try: transpose_matrix([[1, 2], [3, 4, 5]]) except ValueError as e: assert str(e) == \\"transpose_matrix() received an invalid matrix: ragged array\\" try: transpose_matrix(5) except ValueError as e: assert str(e) == \\"transpose_matrix() received an invalid input: not a matrix\\" try: transpose_matrix(\\"not a matrix\\") except ValueError as e: assert str(e) == \\"transpose_matrix() received an invalid input: not a matrix\\" ```","solution":"def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: Returns the transpose of the given matrix. Parameters: matrix (list[list[int]]): A list of lists where each sublist represents a row in the matrix. Returns: list[list[int]]: The transposed matrix as a list of lists. Raises: ValueError: If the input is not a valid matrix. if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): raise ValueError(\\"transpose_matrix() received an invalid input: not a matrix\\") if len(matrix) == 0 or any(len(row) == 0 for row in matrix): raise ValueError(\\"transpose_matrix() received an invalid matrix: empty rows\\") row_length = len(matrix[0]) if not all(len(row) == row_length for row in matrix): raise ValueError(\\"transpose_matrix() received an invalid matrix: ragged array\\") return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]"},{"question":"# Advanced Coding Assessment Question Context You are developing an algorithm to manage and manipulate sequences of numbers. One of the critical operations is ensuring that all elements in a sequence adhere to a certain order. Your task involves implementing a validator and sorter for a sequence based on custom rules. Problem Statement Create a class `SequenceManager` that integrates functionalities for validating and sorting sequences of integers. The class should support the following operations: 1. Validate if a sequence is non-decreasing or non-increasing. 2. Sort the sequence in either ascending or descending order based on custom flags provided during sorting operations. Constraints * The sequence can consist of up to 10^6 integers. * The sequence may have repeated elements. * The input for validation and sorting will be provided as lists of integers. Function Signatures * `class SequenceManager` - `__init__(self, sequence: list[int]) -> None` - `is_non_decreasing(self) -> bool` - `is_non_increasing(self) -> bool` - `custom_sort(self, ascending: bool = True) -> list[int]` Input and Output * `SequenceManager.__init__(sequence: list[int])` - **Input**: A list of integers. - **Initialization**: Stores the sequence. * `SequenceManager.is_non_decreasing()` - **Output**: A boolean indicating if the sequence is non-decreasing (True) or not (False). * `SequenceManager.is_non_increasing()` - **Output**: A boolean indicating if the sequence is non-increasing (True) or not (False). * `SequenceManager.custom_sort(ascending: bool = True)` - **Input**: A boolean flag `ascending` indicating whether to sort in ascending (True) or descending (False) order. - **Output**: A list of integers representing the sorted sequence. Example Usage ```python # Create a sequence manager with a given sequence seq_manager = SequenceManager([3, 1, 2, 4, 5]) # Check if the sequence is non-decreasing or non-increasing print(seq_manager.is_non_decreasing()) # Outputs: False print(seq_manager.is_non_increasing()) # Outputs: False # Sort the sequence in ascending order sorted_sequence = seq_manager.custom_sort(True) print(sorted_sequence) # Outputs: [1, 2, 3, 4, 5] # Sort the sequence in descending order sorted_sequence_desc = seq_manager.custom_sort(False) print(sorted_sequence_desc) # Outputs: [5, 4, 3, 2, 1] # Create a sequence manager with a non-decreasing sequence seq_manager_sorted = SequenceManager([1, 2, 2, 3, 4]) print(seq_manager_sorted.is_non_decreasing()) # Outputs: True print(seq_manager_sorted.is_non_increasing()) # Outputs: False # Create a sequence manager with a non-increasing sequence seq_manager_desc_sorted = SequenceManager([5, 4, 3, 3, 1]) print(seq_manager_desc_sorted.is_non_decreasing()) # Outputs: False print(seq_manager_desc_sorted.is_non_increasing()) # Outputs: True ```","solution":"class SequenceManager: def __init__(self, sequence: list[int]) -> None: self.sequence = sequence def is_non_decreasing(self) -> bool: for i in range(1, len(self.sequence)): if self.sequence[i] < self.sequence[i - 1]: return False return True def is_non_increasing(self) -> bool: for i in range(1, len(self.sequence)): if self.sequence[i] > self.sequence[i - 1]: return False return True def custom_sort(self, ascending: bool = True) -> list[int]: return sorted(self.sequence, reverse=not ascending)"},{"question":"Create a function to parse and evaluate a mathematical expression given in string format. The function should support basic arithmetic operations (addition, subtraction, multiplication, and division) and handle parentheses to enforce the correct order of operations. **Requirements**: - Implement a function `evaluate(expression: str) -> float` that takes a string `expression` and returns the evaluation result as a float. - The function must handle nested parentheses and respect the order of operations (PEMDAS/BODMAS rules). - Include error handling for invalid expressions (unbalanced parentheses, invalid characters, etc.). **Input/Output**: - `evaluate(expression: str) -> float` **Constraints**: - The input string will contain only digits, \'+\', \'-\', \'*\', \'/\', \'(\', \')\', and whitespace. - The input expression will not exceed a length of 300 characters. **Examples**: ```python print(evaluate(\\"3 + 5\\")) # returns 8.0 print(evaluate(\\"10 + 2 * 6\\")) # returns 22.0 print(evaluate(\\"100 * 2 + 12\\")) # returns 212.0 print(evaluate(\\"100 * ( 2 + 12 )\\")) # returns 1400.0 print(evaluate(\\"100 * ( 2 + 12 ) / 14\\")) # returns 100.0 print(evaluate(\\"( 15 - 3 ) * 2\\")) # returns 24.0 print(evaluate(\\"3 * (2 + 5 - (3 / 3))\\")) # returns 18.0 print(evaluate(\\"5 / 0\\")) # handle division by zero exception ``` **Challenge**: Implement the `evaluate` function with efficient parsing and evaluation to correctly handle all given constraints and edge cases.","solution":"def evaluate(expression: str) -> float: Evaluates a mathematical expression in string format and returns the result as a float. Supports \'+\', \'-\', \'*\', \'/\', \'(\', \')\', and respects the order of operations. import re def parse_expression(expression): tokens = re.findall(r\'d+.?d*|[+-*/()]\', expression) return tokens def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 def apply_op(a, b, op): if op == \'+\': return a + b if op == \'-\': return a - b if op == \'*\': return a * b if op == \'/\': if b == 0: raise ValueError(\\"Division by zero\\") return a / b raise ValueError(\\"Invalid operator\\") def evaluate_tokens(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i] == \' \': i += 1 continue elif tokens[i] == \'(\': ops.append(tokens[i]) elif re.match(r\'d+.?d*\', tokens[i]): values.append(float(tokens[i])) elif tokens[i] == \')\': while ops and ops[-1] != \'(\': val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.pop() else: while ops and precedence(ops[-1]) >= precedence(tokens[i]): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.append(tokens[i]) i += 1 while ops: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) return values[-1] tokens = parse_expression(expression) result = evaluate_tokens(tokens) return result"},{"question":"# Coding Assessment Question **Problem Statement:** You are given the implementation of a Linked List class which includes methods to insert and delete nodes. Your task is to write a function `process_linked_list_operations` to manage a series of operations on a linked list. **Objective:** Write a function `process_linked_list_operations` that takes a list of operations and executes them on a linked list, returning the final state of the linked list as a Python list. **Function Signature:** ```python def process_linked_list_operations(operations: List[Tuple[str, int]]) -> List[int]: ``` **Input:** * `operations`: A list of tuples where each tuple contains: - A string indicating the operation type: `\\"insert\\"` or `\\"delete\\"`. - An integer which is either the value to insert or the value to delete. **Output:** * A list of integers representing the final state of the linked list after performing all operations. **Constraints:** * The linked list can initially be considered empty. * The operations will be valid and no operation will be repeated for the same value consecutively. **Example:** ```python operations = [(\\"insert\\", 1), (\\"insert\\", 3), (\\"insert\\", 2), (\\"delete\\", 3), (\\"insert\\", 4)] result = process_linked_list_operations(operations) print(result) # Output: [1, 2, 4] ``` **Requirements:** 1. Implement the function `process_linked_list_operations` by using the `LinkedList` class methods. 2. Correct handling of insertion and deletion as specified. 3. Thoroughly test the function with various inputs representing different edge cases. Here is a basic implementation of a `LinkedList` class for reference. You may assume this class is already provided: ```python class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, data): new_node = Node(data) if not self.head: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def delete(self, data): temp = self.head if temp is not None: if temp.data == data: self.head = temp.next temp = None return while temp is not None: if temp.data == data: break prev = temp temp = temp.next if temp == None: return prev.next = temp.next temp = None def to_list(self): elements = [] current = self.head while current: elements.append(current.data) current = current.next return elements ``` **Function Implementation:** ```python from typing import List, Tuple def process_linked_list_operations(operations: List[Tuple[str, int]]) -> List[int]: linked_list = LinkedList() for operation, value in operations: if operation == \\"insert\\": linked_list.insert(value) elif operation == \\"delete\\": linked_list.delete(value) return linked_list.to_list() ```","solution":"from typing import List, Tuple class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, data): new_node = Node(data) if not self.head: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def delete(self, data): temp = self.head if temp is not None: if temp.data == data: self.head = temp.next temp = None return while temp is not None: if temp.data == data: break prev = temp temp = temp.next if temp == None: return prev.next = temp.next temp = None def to_list(self): elements = [] current = self.head while current: elements.append(current.data) current = current.next return elements def process_linked_list_operations(operations: List[Tuple[str, int]]) -> List[int]: linked_list = LinkedList() for operation, value in operations: if operation == \\"insert\\": linked_list.insert(value) elif operation == \\"delete\\": linked_list.delete(value) return linked_list.to_list()"},{"question":"# Scenario You are developing a software that requires manipulating and analyzing strings containing mathematical expressions. To get started, you decide to implement a function that can compute the sum of all numbers present in a given string. # Problem Statement Write a Python function `sum_of_numbers_in_string(s)` that takes a single input string `s`, extracts all the numbers (both integers and decimal numbers), and returns their sum. Function Signature ```python def sum_of_numbers_in_string(s: str) -> float: pass ``` Input - `s` (str): A string containing various characters, including digits, letters, and punctuation. Output - `float`: The sum of all numbers found in the input string. The result should be returned as a float. Constraints - The input string `s` can have a maximum length of 1000 characters. - The numbers in the string can be positive or negative. - The numbers can be integers or decimal numbers. # Examples ```python # Example 1 assert sum_of_numbers_in_string(\\"The cost is 45.67 and the discount is 5.5.\\") == 51.17 # Example 2 assert sum_of_numbers_in_string(\\"Find the sum: -2, 3.14, and 4.\\") == 5.14 # Example 3 assert sum_of_numbers_in_string(\\"No numbers here!\\") == 0.0 ``` # Notes - Consider edge cases where the string might contain no numbers or consecutive numbers without delimiters. - Your implementation should correctly handle a mix of negative and positive numbers as well as integers and decimals. Ensure the solution is efficient and handles edge cases gracefully.","solution":"import re def sum_of_numbers_in_string(s: str) -> float: Extracts all numbers from the string `s` and returns their sum as a float. Parameters: s (str): The input string containing numbers. Returns: float: The sum of all extracted numbers. # Regular expression to extract numbers (including negative and decimal numbers) numbers = re.findall(r\'-?d+.?d*\', s) # Convert extracted numbers to float and calculate the sum total_sum = sum(map(float, numbers)) return total_sum"},{"question":"# Coding Assessment Question Scenario You are working as a software engineer for a logistics company, and your team needs to implement a system to manage and analyze delivery times. One common metric is the median delivery time. Given a dynamic list of delivery times reported throughout the day, your task is to create a component that can efficiently maintain and provide the median delivery time as new times are added. Task Implement a class `MedianFinder` that maintains a list of delivery times and provides the current median after each insertion. The median is the middle number in a sorted, ascending, or descending list of numbers. If the size of the list is even, the median is the average of the two middle numbers. Class Signature ```python class MedianFinder: def __init__(self): pass def add_time(self, time: float) -> None: pass def find_median(self) -> float: pass ``` Input * `add_time(time: float)`: A floating-point number representing the new delivery time to be added. * `find_median()`: No input; simply returns the current median. Output * `add_time(time: float)`: No return value. The function should update the internal state of the object. * `find_median()`: Returns a floating-point number representing the current median delivery time. Example ```python >>> mf = MedianFinder() >>> mf.add_time(33.0) >>> mf.add_time(29.5) >>> mf.add_time(41.2) >>> mf.find_median() 33.0 >>> mf.add_time(25.1) >>> mf.find_median() 31.25 ``` Constraints * The number of delivery times added can be assumed to fit in memory. * Aim for (O(log n)) time complexity for adding a new time and (O(1)) for finding the median. Edge Cases * Verify behavior when no times have been added (calling `find_median` should raise an appropriate exception). * Handle large numbers of deliveries efficiently. Additional Challenge Try maintaining the data structure such that all operations (add and find median) run in (O(log n)) time complexity. # Solution Notes To maintain an efficient way to find the median, consider using two heaps: a max-heap to store the lower half of the numbers and a min-heap to store the upper half. This allows for efficient balancing and median calculation.","solution":"import heapq class MedianFinder: def __init__(self): Initialize two heaps: - max_heap to store the lower half of the numbers - min_heap to store the upper half of the numbers self.max_heap = [] self.min_heap = [] def add_time(self, time: float) -> None: Add a new delivery time to the data structure. # Always push to max_heap first heapq.heappush(self.max_heap, -time) # Move the largest of max_heap to min_heap to maintain order heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) # Balance the heaps if necessary if len(self.max_heap) < len(self.min_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def find_median(self) -> float: Find the current median delivery time. if len(self.max_heap) == 0: raise ValueError(\\"No delivery times have been added.\\") if len(self.max_heap) > len(self.min_heap): return -self.max_heap[0] else: return (-self.max_heap[0] + self.min_heap[0]) / 2.0"},{"question":"# Question **Context**: You are a software developer at a logistics company. Your team is working on optimizing the delivery routes for your drivers. Each delivery route should be planned such that the total distance traveled is minimized while visiting all required delivery locations. For simplicity, all locations are represented as points on a 2D plane. **Task**: Implement the function `find_shortest_route` which uses a greedy approach to plan a delivery route by starting at the first location and always moving to the nearest unvisited location until all locations are visited. **Function Signature**: ```python def find_shortest_route(locations: list[tuple[int, int]]) -> list[tuple[int, int]]: Args: - locations: A list of tuples, where each tuple represents the (x, y) coordinates of a delivery location. Returns: - A list of tuples representing the order of locations visited in the planned route that tries to minimize the total distance traveled. ``` **Requirements**: 1. Implement the function `find_shortest_route` that takes in: * `locations`: A list of tuples, where each tuple consists of two integers representing the (x, y) coordinates of a location. 2. The function should return a list of tuples representing the order in which the locations should be visited to minimize travel distance. The first tuple in the returned list should be the starting location. 3. Use a greedy approach to plan the route by always moving to the nearest unvisited location from the current location. **Examples**: ```python >>> locations = [(0, 0), (2, 2), (3, 4), (8, 1)] >>> find_shortest_route(locations) [(0, 0), (2, 2), (3, 4), (8, 1)] >>> locations = [(1, 1), (4, 4), (6, 6), (2, 2)] >>> find_shortest_route(locations) [(1, 1), (2, 2), (4, 4), (6, 6)] ``` **Constraints**: * The list `locations` will contain at least 1 and at most (10^3) locations. * Each location is represented as a tuple of two integers (x, y) representing coordinates on a 2D plane. * The distance between locations is computed using the Euclidean distance formula. Good luck, and happy coding!","solution":"from math import sqrt def euclidean_distance(p1, p2): return sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) def find_shortest_route(locations): if not locations: return [] # Start at the first location current_location = locations[0] route = [current_location] unvisited = set(locations[1:]) while unvisited: next_location = min(unvisited, key=lambda loc: euclidean_distance(current_location, loc)) route.append(next_location) unvisited.remove(next_location) current_location = next_location return route"},{"question":"# Problem Description You are provided with a binary search tree (BST) implementation in Python. Your task is to enhance the existing code to support an additional feature: **Find Kth Smallest Element**. The function should find and return the k-th smallest element in the BST. This can be useful for various instances where derived metrics or specific data points are required from ordered datasets. # Objective Implement a method in the `BSTNode` class called `find_kth_smallest` that takes an integer `k` and returns the k-th smallest element in the BST (1-indexed). # Input * A `BSTNode` instance representing the root of the BST. * An integer `k`, which indicates the position of the smallest element to find (1-indexed). # Output * An integer representing the k-th smallest element in the BST. # Constraints * The BST will contain unique integer values only. * The number of nodes in the BST will be at most 1000. * `1 <= k <= number of nodes in the BST`. # Example Given the BST built with the values [5, 3, 7, 2, 4, 6, 8]: ```python root = BSTNode() for value in [5, 3, 7, 2, 4, 6, 8]: root.insert(value) ``` Calling `root.find_kth_smallest(3)` should return 4. # Implementation Notes 1. Perform an in-order traversal of the BST to collect elements in sorted order. 2. Retrieve the k-th element from the sorted list. # Code Template ```python class BSTNode: def __init__(self, value=None): self.value = value self.left = None self.right = None def insert(self, value): if not self.value: self.value = value elif value < self.value: if self.left is None: self.left = BSTNode(value) else: self.left.insert(value) else: if self.right is None: self.right = BSTNode(value) else: self.right.insert(value) # ... (existing methods) def find_kth_smallest(self, k: int) -> int: Find the k-th smallest element in the BST. Args: k (int): the position of the smallest element to find. Returns: int: the k-th smallest element. # Your implementation here. pass # Example usage root = BSTNode() for value in [5, 3, 7, 2, 4, 6, 8]: root.insert(value) print(root.find_kth_smallest(3)) # Output should be 4 ``` # Requirements * Ensure the function operates efficiently with the given constraints. * Handle edge cases appropriately, such as `k` being 1 or `k` being the number of nodes in the BST.","solution":"class BSTNode: def __init__(self, value=None): self.value = value self.left = None self.right = None def insert(self, value): if not self.value: self.value = value elif value < self.value: if self.left is None: self.left = BSTNode(value) else: self.left.insert(value) else: if self.right is None: self.right = BSTNode(value) else: self.right.insert(value) def _in_order(self, node, result): if node: self._in_order(node.left, result) result.append(node.value) self._in_order(node.right, result) def find_kth_smallest(self, k: int) -> int: Find the k-th smallest element in the BST. Args: k (int): the position of the smallest element to find. Returns: int: the k-th smallest element. result = [] self._in_order(self, result) return result[k - 1] # Example usage root = BSTNode() for value in [5, 3, 7, 2, 4, 6, 8]: root.insert(value) print(root.find_kth_smallest(3)) # Output should be 4"},{"question":"# Question: Validate Palindrome Permutation Context: A palindrome is a word, phrase, number, or other sequence of characters which reads the same backward or forward (ignoring spaces, punctuation, and capitalization). A permutation is a rearrangement of a sequence. You need to determine whether any permutation of the input string can form a palindrome. Instructions 1. Implement the function `can_form_palindrome(input_str: str) -> bool` that returns `True` if any permutation of the string can be rearranged to form a palindrome, otherwise `False`. 2. Optimize for both time and space complexity. 3. Handle various edge cases such as empty strings and strings with non-alphabetic characters. Input: * A single string `input_str` (1 <= len(input_str) <= 10^5) Output: * Boolean value: `True` if any permutation of the input string can form a palindrome, otherwise `False`. Example: ``` can_form_palindrome(\\"Tact Coa\\") > True # Permutation \\"taco cat\\" forms a palindrome. can_form_palindrome(\\"Hello\\") > False # No permutation of the string forms a palindrome. ``` Constraints: * The input string may contain spaces, punctuations, and numbers. * Your implementation needs to be case insensitive. Performance Requirements: * Time Complexity: O(n), where n is the length of input string. * Space Complexity: O(1).","solution":"from collections import Counter def can_form_palindrome(input_str: str) -> bool: Determine if any permutation of the input string can form a palindrome. Parameters: input_str: str - The input string Returns: bool - True if any permutation can form a palindrome, otherwise False # convert to lower case and remove non-alphabetic characters filtered_str = \'\'.join(filter(str.isalpha, input_str.lower())) # count frequency of each character char_counter = Counter(filtered_str) # check number of odd frequency counts odd_count = sum(freq % 2 for freq in char_counter.values()) # at most one character can have an odd frequency for a palindrome permutation return odd_count <= 1"},{"question":"**Context**: You are developing a system to manage a library\'s book inventory. The system needs a function to add new books and to check the availability of specific titles. Each book has a title and a unique ISBN number. The function should enable adding new books to the inventory and searching for a book by its title. **Task**: Implement the class `Library` that has the following methods: - `add_book(title: str, isbn: str) -> None`: Adds a new book to the library with the given title and ISBN. - `is_book_available(title: str) -> bool`: Checks if a book with the specified title is available in the library. # Input * `title`: A string representing the title of the book (1 <= len(title) <= 100). * `isbn`: A string representing the ISBN of the book (10 or 13 characters). # Output - The method `add_book` does not return anything. - The method `is_book_available` returns `True` if a book with the given title is available in the library, otherwise `False`. # Constraints * Each book has a unique ISBN. * Multiple books can have the same title. * The search for the title should be case-sensitive. * The length of the library inventory is not limited. # Example Example 1 ```python library = Library() library.add_book(\\"The Catcher in the Rye\\", \\"9780316769488\\") library.add_book(\\"To Kill a Mockingbird\\", \\"9780061120084\\") library.add_book(\\"1984\\", \\"9780451524935\\") assert library.is_book_available(\\"The Catcher in the Rye\\") == True assert library.is_book_available(\\"The Great Gatsby\\") == False ``` Example 2 ```python library = Library() library.add_book(\\"The Hobbit\\", \\"9780547928227\\") library.add_book(\\"The Hobbit\\", \\"9780547928241\\") assert library.is_book_available(\\"The Hobbit\\") == True ```","solution":"class Library: def __init__(self): self.inventory = [] def add_book(self, title: str, isbn: str) -> None: self.inventory.append({\\"title\\": title, \\"isbn\\": isbn}) def is_book_available(self, title: str) -> bool: for book in self.inventory: if book[\\"title\\"] == title: return True return False # Usage examples: # library = Library() # library.add_book(\\"The Catcher in the Rye\\", \\"9780316769488\\") # library.add_book(\\"To Kill a Mockingbird\\", \\"9780061120084\\") # library.add_book(\\"1984\\", \\"9780451524935\\") # print(library.is_book_available(\\"The Catcher in the Rye\\")) # Should return True # print(library.is_book_available(\\"The Great Gatsby\\")) # Should return False"},{"question":"# Binary Search Tree (BST) Operations You are provided with a partial implementation of a Binary Search Tree (BST) in Python. Your task is to complete the implementation of the BST class to include insertion, deletion, and finding the successor and predecessor of a given node. 1. **Implement the `insert` function** to add a new node to the BST maintaining the tree properties. 2. **Implement the `delete` function** to remove a node from the BST maintaining the tree properties. 3. **Implement the `find_successor` function** to find the in-order successor of a node. 4. **Implement the `find_predecessor` function** to find the in-order predecessor of a node. # Input * For the `insert` function: A value to be added to the BST. * For the `delete` function: A value to be removed from the BST. * For the `find_successor` function: A value for which you need to find the in-order successor. * For the `find_predecessor` function: A value for which you need to find the in-order predecessor. # Output * For the `insert` function: No output (it should just update the BST). * For the `delete` function: No output (it should just update the BST). * For the `find_successor` function: The successor value of the given node. * For the `find_predecessor` function: The predecessor value of the given node. # Example ```python # Initialize BST bst = BST() # Insert elements bst.insert(20) bst.insert(10) bst.insert(30) bst.insert(5) bst.insert(15) # Delete element bst.delete(10) # Find successor successor = bst.find_successor(15) print(successor) # Expected output: 20 # Find predecessor predecessor = bst.find_predecessor(15) print(predecessor) # Expected output: 5 ``` # Notes * Ensure your implementation maintains the properties of the BST after each operation. * Handle edge cases where the tree might be empty or the node might not exist. * Consider cases where the node to be deleted has no children, one child, or two children.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.val: if node.left is None: node.left = Node(key) else: self._insert(node.left, key) else: if node.right is None: node.right = Node(key) else: self._insert(node.right, key) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if node is None: return node if key < node.val: node.left = self._delete(node.left, key) elif key > node.val: node.right = self._delete(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._min_value_node(node.right) node.val = temp.val node.right = self._delete(node.right, temp.val) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def find_successor(self, key): node = self._find(self.root, key) if node and node.right: return self._min_value_node(node.right).val successor = None ancestor = self.root while ancestor != node: if node.val < ancestor.val: successor = ancestor ancestor = ancestor.left else: ancestor = ancestor.right return successor.val if successor else None def find_predecessor(self, key): node = self._find(self.root, key) if node and node.left: return self._max_value_node(node.left).val predecessor = None ancestor = self.root while ancestor != node: if node.val > ancestor.val: predecessor = ancestor ancestor = ancestor.right else: ancestor = ancestor.left return predecessor.val if predecessor else None def _find(self, node, key): if node is None or node.val == key: return node if key < node.val: return self._find(node.left, key) else: return self._find(node.right, key) def _max_value_node(self, node): current = node while current.right is not None: current = current.right return current"},{"question":"**Context:** In a scenario where a restaurant needs to manage table reservations efficiently, you are required to develop a reservation system. The system should handle the addition of reservations, cancellation of reservations, and listing of all active reservations. This system needs to deal with potentially multiple bookings for the same table and cancellation of specific reservations. # Task: Implement a reservations management system as a class with the following functionalities: - `add_reservation(table_id, customer_name)`: Adds a reservation for the specified table ID under the customer\'s name. - `cancel_reservation(table_id, customer_name)`: Cancels the reservation for the specified table ID under the customer\'s name. - `list_reservations()`: Returns a list of all active reservations in the format `[(table_id, customer_name)]`, sorted by table_id then customer_name. # Specifications: 1. `add_reservation` should add a new reservation if the table and customer pair don\'t already exist. 2. `cancel_reservation` should remove an existing reservation that matches the table and customer pair. 3. `list_reservations` should return a sorted list of all reservations. # Input and Output: Your methods must match the following signatures: - `add_reservation(table_id: int, customer_name: str) -> None` - `cancel_reservation(table_id: int, customer_name: str) -> None` - `list_reservations() -> list[tuple[int, str]]` # Constraints: - Assume `table_id` is a positive integer. - Assume `customer_name` is a non-empty string with a maximum length of 100 characters. - Maximum number of unique reservations: 10^5. - Operations should handle edge cases such as trying to cancel a non-existent reservation. **Example:** ```python r = ReservationSystem() r.add_reservation(1, \\"Alice\\") r.add_reservation(2, \\"Bob\\") r.add_reservation(1, \\"Charlie\\") assert r.list_reservations() == [(1, \\"Alice\\"), (1, \\"Charlie\\"), (2, \\"Bob\\")] r.cancel_reservation(1, \\"Alice\\") assert r.list_reservations() == [(1, \\"Charlie\\"), (2, \\"Bob\\")] r.cancel_reservation(3, \\"David\\") # No error, even if the reservation does not exist ```","solution":"class ReservationSystem: def __init__(self): self.reservations = set() def add_reservation(self, table_id: int, customer_name: str) -> None: Adds a reservation for the specified table ID under the customer\'s name. self.reservations.add((table_id, customer_name)) def cancel_reservation(self, table_id: int, customer_name: str) -> None: Cancels the reservation for the specified table ID under the customer\'s name. self.reservations.discard((table_id, customer_name)) def list_reservations(self) -> list: Returns a list of all active reservations in the format [(table_id, customer_name)], sorted by table_id then customer_name. return sorted(self.reservations)"},{"question":"# Coding Assessment Question Context: Heap Sort is a comparison-based sorting algorithm that uses a binary heap data structure. It is similar to selection sort, where we first find the maximum element and place the maximum element at the end. We repeat the same process for the remaining elements. Problem Statement: Implement the Heap Sort algorithm in Python. Your function should take a list of integers as input and return the list sorted in ascending order. You should use a max-heap to achieve this. Function Signature: ```python def heap_sort(arr: List[int]) -> List[int]: pass ``` Input: - A list of integers `arr` (0 <= len(arr) <= 10^5, -10^9 <= arr[i] <= 10^9 for all 0 <= i < len(arr)). Output: - A list of integers sorted in ascending order. Constraints: - Your implementation should use the heap sort strategy to sort the array. - Ensure your solution is efficient and operates within O(n log n) time complexity for most cases. Examples: ```python assert heap_sort([3, 2, 1, 5, 6, 4]) == [1, 2, 3, 4, 5, 6] assert heap_sort([]) == [] assert heap_sort([5, 7, 2, 1, 9, 4]) == [1, 2, 4, 5, 7, 9] assert heap_sort([1]) == [1] assert heap_sort([2, 1]) == [1, 2] assert heap_sort([-1, -5, -3, -4, -2]) == [-5, -4, -3, -2, -1] ``` Performance Requirements: - The implemented algorithm should leverage a max-heap and have an expected time complexity of O(n log n) for the majority of inputs.","solution":"from typing import List def heapify(arr: List[int], n: int, i: int) -> None: Converts a subtree rooted with node i into a max heap, assuming the subtrees are already heaps. largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[i] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest) def heap_sort(arr: List[int]) -> List[int]: n = len(arr) for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0) return arr"},{"question":"# Question You are given a string containing a mix of uppercase and lowercase letters. Write a Python function `reverse_only_letters(s: str) -> str` that reverses the order of the letters in the string but keeps the positions of non-letter characters unchanged. Function Signature ```python def reverse_only_letters(s: str) -> str: ``` Inputs * `s`: A string composed of letters and other possible characters (symbols, digits, etc.). Outputs * The function should return a new string where the letters are reversed, but the other characters remain in their original positions. # Constraints 1. The input string will have a length of at most 10^5. 2. The string will contain only printable ASCII characters. # Example ```python reverse_only_letters(\\"a-bC-dEf-ghIj\\") == \\"j-Ih-gfE-dCba\\" reverse_only_letters(\\"Test1ng-Leet=code-Q!\\") == \\"Qedo1ct-eeLg=ntse-T!\\" ``` # Notes * Ensure your implementation correctly handles strings containing various characters and letter cases. * Maintain an optimal time complexity. The entire function should ideally traverse the string only once.","solution":"def reverse_only_letters(s: str) -> str: letters = [c for c in s if c.isalpha()] result = [] for c in s: if c.isalpha(): result.append(letters.pop()) else: result.append(c) return \'\'.join(result)"},{"question":"# Question: Validate and Sum Toeplitz Matrix Rows Write a function that checks if a given matrix is a Toeplitz matrix and, if so, computes the sum of each row in the matrix. A Toeplitz matrix is one where each descending diagonal from left to right is constant. # Function Signature ```python def validate_and_sum_toeplitz(matrix: np.ndarray) -> np.ndarray: pass ``` # Input - `matrix` (numpy.ndarray): A 2D array of integers. # Output - If the matrix is Toeplitz, return a 1D numpy array containing the sum of each row. - If the matrix is not Toeplitz, raise a `ValueError` with a message: `\\"The given matrix is not Toeplitz.\\"` # Constraints - Matrix dimensions: `matrix` is of size `m x n` where `1 ≤ m, n ≤ 1000`. # Requirements - The function should first verify whether the matrix is Toeplitz. - If the matrix is not Toeplitz, raise a `ValueError` with the specified message. - If the matrix is Toeplitz, compute and return the sum of each row as a numpy array. - No external libraries other than numpy are allowed. # Example ```python import numpy as np matrix = np.array([ [1, 2, 3, 4], [5, 1, 2, 3], [6, 5, 1, 2] ]) print(validate_and_sum_toeplitz(matrix)) # Output: array([10, 11, 14]) ``` # Note - Ensure you test your function with various valid and invalid Toeplitz matrices to cover edge cases and different sizes.","solution":"import numpy as np def validate_and_sum_toeplitz(matrix: np.ndarray) -> np.ndarray: Checks if the given matrix is a Toeplitz matrix, and returns the sum of each row if yes. Else, raises a ValueError. Parameters: matrix (numpy.ndarray): A 2D array of integers. Returns: numpy.ndarray: A 1D array containing the sum of each row if the matrix is Toeplitz. Raises: ValueError: If the matrix is not a Toeplitz matrix. # Check if the matrix is Toeplitz rows, cols = matrix.shape for r in range(1, rows): for c in range(1, cols): if matrix[r, c] != matrix[r - 1, c - 1]: raise ValueError(\\"The given matrix is not Toeplitz.\\") # Calculate the sum of each row return np.sum(matrix, axis=1)"},{"question":"# Employee Hierarchy Problem Context You are working on an organizational management software where one of the tasks is to implement a data structure to represent the hierarchy of employees in a company. Each employee can have multiple subordinates but exactly one direct superior. Your task is to model this hierarchy and provide functionality to add employees, get subordinates of an employee, find the superior of an employee, find the lowest common superior of two employees, and return the entire hierarchical structure in a readable format. Task Implement a class `EmployeeHierarchy` in Python that supports the following operations: 1. Initialization of the hierarchy with a root employee. 2. Adding a new employee under a specific superior. 3. Getting the list of subordinates of a specific employee. 4. Finding the superior of a specific employee. 5. Finding the lowest common superior of two employees. 6. String representation of the hierarchy in a human-readable form. Requirements 1. **Initialization**: - The constructor should initialize the hierarchy with a root employee\'s name. ```python def __init__(self, root_employee: str) -> None: ``` 2. **Add Employee**: ```python def add_employee(self, employee: str, superior: str) -> None: ``` 3. **Get Subordinates**: ```python def get_subordinates(self, employee: str) -> List[str]: ``` 4. **Find Superior**: ```python def find_superior(self, employee: str) -> Optional[str]: ``` 5. **Find Lowest Common Superior**: ```python def find_lowest_common_superior(self, employee1: str, employee2: str) -> Optional[str]: ``` 6. **String Representation**: ```python def __str__(self) -> str: ``` Input and Output Formats: - **Initialization**: `EmployeeHierarchy(\\"CEO\\")` initializes a hierarchy with \'CEO\' as the root. - **Add Employee**: `add_employee(\\"Alice\\", \\"CEO\\")` adds \'Alice\' under \'CEO\'. - **Get Subordinates**: `get_subordinates(\\"CEO\\")` should return `[\\"Alice\\"]`. - **Find Superior**: `find_superior(\\"Alice\\")` should return `\\"CEO\\"`. - **Find Lowest Common Superior**: `find_lowest_common_superior(\\"Alice\\", \\"Bob\\")`, assuming both \'Alice\' and \'Bob\' report directly or indirectly to \'CEO\', should return `\\"CEO\\"`. - **String Representation**: Assuming \'Alice\' and \'Bob\' are under \'CEO\', `str()` should return `CEO -> [\'Alice\', \'Bob\']`. Example: ```python hierarchy = EmployeeHierarchy(\\"CEO\\") hierarchy.add_employee(\\"Alice\\", \\"CEO\\") hierarchy.add_employee(\\"Bob\\", \\"CEO\\") hierarchy.add_employee(\\"Charlie\\", \\"Alice\\") hierarchy.add_employee(\\"David\\", \\"Alice\\") print(hierarchy.get_subordinates(\\"CEO\\")) # Should display [\'Alice\', \'Bob\'] print(hierarchy.find_superior(\\"Charlie\\")) # Should return \'Alice\' print(hierarchy.find_lowest_common_superior(\\"Charlie\\", \\"David\\")) # Should return \'Alice\' print(hierarchy.find_lowest_common_superior(\\"Charlie\\", \\"Bob\\")) # Should return \'CEO\' print(hierarchy) # Should display the hierarchy in a readable format ``` Constraints: - The employee names are unique. - Ensure your implementation is efficient and can handle hierarchies with a large number of employees. - Handle exceptions appropriately, such as adding an employee or searching for a superior in a non-existent department. Additional Notes: - You may use a dictionary or any other data structure to maintain the hierarchy. - Consider edge cases such as an employee with no subordinates or requesting the superior of the root employee.","solution":"class EmployeeHierarchy: def __init__(self, root_employee: str) -> None: self.hierarchy = {root_employee: []} self.superiors = {root_employee: None} self.root = root_employee def add_employee(self, employee: str, superior: str) -> None: if superior not in self.hierarchy: raise ValueError(f\\"Superior {superior} does not exist in the hierarchy\\") if employee in self.hierarchy: raise ValueError(f\\"Employee {employee} already exists in the hierarchy\\") self.hierarchy[employee] = [] self.superiors[employee] = superior self.hierarchy[superior].append(employee) def get_subordinates(self, employee: str) -> list: if employee not in self.hierarchy: raise ValueError(f\\"Employee {employee} does not exist in the hierarchy\\") return self.hierarchy[employee] def find_superior(self, employee: str) -> str: if employee not in self.superiors: raise ValueError(f\\"Employee {employee} does not exist in the hierarchy\\") return self.superiors[employee] def find_lowest_common_superior(self, employee1: str, employee2: str) -> str: if employee1 not in self.superiors or employee2 not in self.superiors: raise ValueError(\\"One or both employees do not exist in the hierarchy\\") path1 = self._get_path_to_root(employee1) path2 = self._get_path_to_root(employee2) i, j = len(path1) - 1, len(path2) - 1 lcs = None while i >= 0 and j >= 0 and path1[i] == path2[j]: lcs = path1[i] i -= 1 j -= 1 return lcs def _get_path_to_root(self, employee: str) -> list: path = [] while employee is not None: path.append(employee) employee = self.superiors[employee] return path def __str__(self) -> str: result = [] self._print_hierarchy(self.root, 0, result) return \\"n\\".join(result) def _print_hierarchy(self, employee: str, level: int, result: list) -> None: result.append(\\" \\" * level + f\\"{employee}\\") for subordinate in self.hierarchy[employee]: self._print_hierarchy(subordinate, level + 1, result)"},{"question":"# Question: Distance Converter Problem Statement: You are required to implement a Python function that converts a given distance from kilometers to miles. The conversion formula is based on the fact that 1 kilometer is approximately equal to 0.621371 miles. Function Signature: ```python def kilometers_to_miles(kilometers: float) -> float: ``` Input: - **kilometers** (float): The distance in kilometers (km). (0 ≤ kilometers ≤ 10^6) Output: - Returns the distance in miles (float). Constraints: - If the distance in kilometers is negative, raise a `ValueError` with the message: \\"Distance cannot be negative\\". Examples: ```python >>> kilometers_to_miles(0) 0.0 >>> kilometers_to_miles(1) 0.621371 >>> kilometers_to_miles(5) 3.106855 >>> kilometers_to_miles(10) 6.21371 >>> kilometers_to_miles(0.5) 0.3106855 ``` Implementation: Use Python to implement the function, ensuring accurate conversion based on the given conversion factor. Test for edge cases such as zero distance and negative inputs. **Note**: Ensure your function passes all edge cases and correctly handles distances that result in decimal mile values.","solution":"def kilometers_to_miles(kilometers: float) -> float: Converts distance in kilometers to miles. if kilometers < 0: raise ValueError(\\"Distance cannot be negative\\") return kilometers * 0.621371"},{"question":"# Coding Question Context In geometric transformations, rotation of a point around the origin is a fundamental concept. It involves using the point\'s coordinates ((x, y)) and rotating them by a certain angle (theta) using the following formulas: [ x\' = x cdot cos(theta) - y cdot sin(theta) ] [ y\' = x cdot sin(theta) + y cdot cos(theta) ] Here, ( (x\', y\') ) are the coordinates of the point after rotation. Assume the angle (theta) is given in degrees. Tasks 1. Implement a function `rotate_point` to calculate the new coordinates of a point after rotating it around the origin by a given angle. # Function Signature ```python def rotate_point(x: float, y: float, angle: float) -> tuple: # your code here ``` # Requirements - The function should convert the input angle from degrees to radians before performing calculations. - The function should ensure precision in floating-point arithmetic to avoid significant rounding errors. - If the input angle is not within the usual domain for degrees (0 to 360 degrees), normalize it to fall within this range. - The function should handle and correctly rotate negative coordinates. # Example Usage ```python # Test case for rotating a point (1, 0) by 90 degrees rotate_point(1, 0, 90) # should return (0.0, 1.0) # Test case for rotating a point (0, 1) by 45 degrees rotate_point(0, 1, 45) # should return (-0.70710678, 0.70710678) # Test case for rotating a point (-1, -1) by 180 degrees rotate_point(-1, -1, 180) # should return (1.0, 1.0) ``` Ensure your function accounts for precision in floating-point arithmetic, normalizes the angle, and correctly handles edge cases such as negative coordinates.","solution":"import math def rotate_point(x: float, y: float, angle: float) -> tuple: Rotates a point (x, y) around the origin by the given angle in degrees. Parameters: x (float): x-coordinate of the point. y (float): y-coordinate of the point. angle (float): rotation angle in degrees. Returns: tuple: New coordinates of the point after rotation. # Normalize the angle to the range [0, 360) angle = angle % 360 # Convert angle from degrees to radians angle_rad = math.radians(angle) # Calculate new coordinates using the rotation formulas x_new = x * math.cos(angle_rad) - y * math.sin(angle_rad) y_new = x * math.sin(angle_rad) + y * math.cos(angle_rad) return (round(x_new, 8), round(y_new, 8))"},{"question":"# Problem Statement Given a list of strings `words` and a string `pattern`, return a list of all strings in `words` that match the `pattern`. A string matches the `pattern` if there is a bijective mapping between the characters in the string and the characters in the `pattern`. In other words, for a string to match the pattern, each unique character in the pattern must uniquely map to a unique character in the string and vice versa. # Function Signature ```python def find_and_replace_pattern(words: List[str], pattern: str) -> List[str]: Given a list of strings `words` and a string `pattern`, return a list of all strings in `words` that match the `pattern`. ``` # Input - A list of strings `words` where 1 <= len(words) <= 50 and 1 <= len(words[i]) <= 20. - A string `pattern` where 1 <= len(pattern) <= 20. # Output - A list of strings that match the `pattern`. # Example Usage ```python assert find_and_replace_pattern([\\"abc\\", \\"deq\\", \\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"], \\"abb\\") == [\\"mee\\", \\"aqq\\"] assert find_and_replace_pattern([\\"a\\", \\"b\\", \\"c\\"], \\"a\\") == [\\"a\\", \\"b\\", \\"c\\"] assert find_and_replace_pattern([\\"mlk\\", \\"aaa\\", \\"xyz\\"], \\"mno\\") == [\\"mlk\\", \\"xyz\\"] ``` # Constraints - Each character in `pattern` and each string in `words` consist only of lowercase English letters. # Explanation We need to check if each word from the list of words matches the given pattern using a bijective mapping of characters. If a word matches, it should be included in the result. Example 1: - \\"mee\\" matches \\"abb\\" because \\"m\\" can map to \\"a\\" and \\"e\\" can map to \\"b\\". - \\"aqq\\" matches \\"abb\\" because \\"a\\" can map to \\"a\\" and \\"q\\" can map to \\"b\\". Example 2: - Each word \\"a\\", \\"b\\", \\"c\\" matches the pattern \\"a\\" for a direct single character mapping. Considering these example cases will guide the implementation of the function to find and replace the pattern.","solution":"def find_and_replace_pattern(words, pattern): def matches(word): m1, m2 = {}, {} for w, p in zip(word, pattern): if w not in m1: m1[w] = p if p not in m2: m2[p] = w if (m1[w], m2[p]) != (p, w): return False return True return [word for word in words if matches(word)]"},{"question":"# Coding Assessment Question Context In number theory, a perfect number is a positive integer that is equal to the sum of its proper divisors (excluding itself). For example, 6 is a perfect number because its proper divisors are 1, 2, and 3, and 1 + 2 + 3 = 6. Given an integer (n), your task is to implement a function to determine all perfect numbers less than (n). Task Write a function `find_perfect_numbers(n: int) -> List[int]` that returns a list of all perfect numbers less than (n). Input * An integer (n) where (1 leq n leq 100000). Output * A list of integers representing the perfect numbers less than (n). The list should be sorted in ascending order. Constraints * The function should be designed to handle the upper limit efficiently. * Consider edge cases such as when (n) is very small (e.g., (n = 1) or (n = 2)). Example ```python def find_perfect_numbers(n: int) -> List[int]: # Implementation here pass # Example Usage print(find_perfect_numbers(10000)) # Output: [6, 28, 496, 8128] print(find_perfect_numbers(1000)) # Output: [6, 28, 496] ``` # Requirements * Implement a helper function to compute the sum of proper divisors. * Use this helper function to identify perfect numbers. * Return a list of perfect numbers sorted in ascending order.","solution":"from typing import List def sum_of_proper_divisors(num: int) -> int: Returns the sum of proper divisors of num (excluding itself). if num < 2: return 0 divisors_sum = 1 # 1 is a proper divisor for any number > 1 sqrt_num = int(num ** 0.5) for i in range(2, sqrt_num + 1): if num % i == 0: divisors_sum += i if i != num // i: # Ensure we do not add the square root twice divisors_sum += num // i return divisors_sum def find_perfect_numbers(n: int) -> List[int]: Returns a list of all perfect numbers less than n. perfect_numbers = [] for num in range(2, n): if sum_of_proper_divisors(num) == num: perfect_numbers.append(num) return perfect_numbers"},{"question":"# Common Elements in Sorted Lists Assessment Question You are working on a data processing application that often needs to find common elements between multiple lists. Each list is pre-sorted in ascending order. Your task is to implement a function that finds all the common elements present in all lists. Task: Write a function `common_elements(sorted_lists: List[List[int]]) -> List[int]` that takes a single argument as input: - `sorted_lists` (List[List[int]]): A list of lists, where each sub-list is sorted in ascending order. The function should return a list of integers that are common to all input lists. The returned list should be sorted in ascending order. Input: - It is guaranteed that the number of lists will be at most 100. - Each list will contain at most 1000 integers. - All integers will be in the range from -10^6 to 10^6. Output: - Return a list of integers that are common to all input lists. Examples: ```python >>> common_elements([[1, 2, 3], [2, 3, 4], [2, 5]]) [2] >>> common_elements([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [] >>> common_elements([[-10, -5, 0, 5, 10], [-5, 5, 15], [-5, 0, 5]]) [-5, 5] >>> common_elements([[1]]) [1] >>> common_elements([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]]) [3, 4] ``` Constraints: - The function should handle edge cases such as lists with no common elements gracefully. - Performance should be optimized for the maximum possible input sizes.","solution":"from typing import List def common_elements(sorted_lists: List[List[int]]) -> List[int]: if not sorted_lists: return [] # Initialize the common elements with the first list common = set(sorted_lists[0]) # Intersect with each subsequent list for lst in sorted_lists[1:]: common.intersection_update(lst) return sorted(common)"},{"question":"# Coding Assessment Question **Context**: You are tasked with developing a utility function for a text processing library. This function will help developers efficiently manage text formatting, specifically in cases where certain patterns need to be replaced. **Problem Statement**: Implement a function to perform text substitution based on a given list of patterns and their respective replacements. The function should substitute all occurrences of each pattern in the text with its corresponding replacement, but it should be case-insensitive in its matching of patterns. # Function Signature: ```python def case_insensitive_substitution(text: str, patterns: dict[str, str]) -> str: pass ``` # Input: 1. **text (str)**: The input text where the patterns are to be substituted. 2. **patterns (dict[str, str])**: A dictionary where keys are the patterns to be replaced and values are the replacements. # Output: Returns a string where all occurrences of each pattern in the text, regardless of their case, are replaced with the corresponding replacement. # Constraints: 1. The input `text` can have a length of up to (10^6) characters. 2. The keys and values in `patterns` dictionary can have lengths up to (10^3) characters. 3. Patterns and replacement strings consist only of printable ASCII characters. 4. Each pattern in the dictionary is unique. # Example: ```python assert case_insensitive_substitution(\\"Hello World, hello Universe!\\", {\\"hello\\": \\"hi\\", \\"WORLD\\": \\"earth\\"}) == \\"hi earth, hi Universe!\\" assert case_insensitive_substitution(\\"banana BANANA Banana\\", {\\"banana\\": \\"fruit\\"}) == \\"fruit fruit fruit\\" ``` # Explanation: For the given example inputs: 1. Each occurrence of \\"hello\\" (case-insensitive) is replaced by \\"hi\\", and \\"world\\" (case-insensitive) is replaced by \\"earth\\". 2. Each occurrence of \\"banana\\" (case-insensitive) is replaced by \\"fruit\\". # Notes: - Consider using regular expressions for efficient pattern matching and replacement. - Ensure that the substitutions do not interfere with each other. - Maintain the original case of parts of the text that do not match any pattern.","solution":"import re def case_insensitive_substitution(text: str, patterns: dict[str, str]) -> str: Substitute occurrences of patterns in the text with their corresponding replacements in a case-insensitive manner. :param text: The input text where the patterns should be substituted. :param patterns: A dictionary where keys are the patterns to be replaced and values are the replacements. :return: A string with the substitutions applied. for pattern, replacement in patterns.items(): # Use re.IGNORECASE for case-insensitive matching text = re.sub(re.escape(pattern), replacement, text, flags=re.IGNORECASE) return text"},{"question":"**Context**: You are designing a software system that requires efficiently searching for an element within a part of a collection. A common scenario is dynamically querying a range within a sorted list. This problem can be efficiently solved using binary search. **Task**: Write a function `range_search` that takes a sorted list and a range defined by two integers (lower and upper bounds inclusive). The function should return the indices of the first and last occurrences of elements within that range. # Function Signature ```python def range_search(arr: List[int], lower: int, upper: int) -> Tuple[int, int]: pass ``` # Input * `arr`: A sorted list of integers. * `lower`: An integer representing the lower bound of the range. * `upper`: An integer representing the upper bound of the range. # Output * Returns a tuple with two integers representing the indices of the first and last occurrences of elements within the given range. If no elements are found within the range, return `(-1, -1)`. # Constraints * 0 ≤ len(arr) ≤ 10^6 * ( -10^9 leq text{{lower}}, text{{upper}}, text{{arr[i]}} leq 10^9 ) * The list `arr` is sorted in non-decreasing order. # Performance Requirement * The implementation should have a time complexity of (O(log{n})). # Example ```python assert range_search([1, 3, 3, 5, 7, 8], 3, 5) == (1, 3) assert range_search([1, 2, 4, 5, 5, 5, 6, 8, 9], 5, 5) == (3, 5) assert range_search([10, 20, 30, 40, 50], 15, 25) == (1, 1) assert range_search([1, 2, 3, 4, 5], 6, 10) == (-1, -1) assert range_search([], 1, 10) == (-1, -1) ``` Implement the `range_search` function to efficiently find the indices of the first and last occurrences within the range `[lower, upper]` in the sorted list `arr` using binary search.","solution":"from typing import List, Tuple def range_search(arr: List[int], lower: int, upper: int) -> Tuple[int, int]: Returns the indices of the first and last occurrences of elements within the given range [lower, upper]. If no elements are found within the range, returns (-1, -1). def find_first_occurrence(arr, low, high, target): while low <= high: mid = (low + high) // 2 if arr[mid] >= target: high = mid - 1 else: low = mid + 1 return low def find_last_occurrence(arr, low, high, target): while low <= high: mid = (low + high) // 2 if arr[mid] <= target: low = mid + 1 else: high = mid - 1 return high n = len(arr) if n == 0: return (-1, -1) first_index = find_first_occurrence(arr, 0, n - 1, lower) last_index = find_last_occurrence(arr, 0, n - 1, upper) if first_index <= last_index and 0 <= first_index < n and 0 <= last_index < n and arr[first_index] >= lower and arr[last_index] <= upper: return (first_index, last_index) else: return (-1, -1)"},{"question":"# AVL Tree Rebalancing Objective You are given an incomplete implementation of an AVL Tree that supports insertion and basic rotations. Your task is to complete the implementation by adding the `delete` operation and handling rebalancing after deletion. Problem Statement An AVL Tree is a self-balancing binary search tree where the difference in heights of left and right subtrees cannot be more than one for all nodes. You need to implement the following method: 1. **`delete(self, val: int)`** * **Description**: This method deletes the node with the given value `val` from the AVL Tree and rebalances the tree if necessary. * **Input**: - `val`: an integer value that specifies the node to be deleted. * **Output**: None Constraints: 1. The `val` to be deleted is guaranteed to be present in the AVL Tree. 2. The tree contains integer values only. Performance Requirements: The deletion operation, along with necessary rebalancing, should take (O(log n)) time complexity. Below is the scaffold of the `AVLTree` class. You need to complete the `delete` method and ensure the tree remains balanced. ```python class Node: def __init__(self, value: int): self.value = value self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def insert(self, val: int): # Implementation of insertion and necessary rotations ... def delete(self, val: int): self.root = self._delete(self.root, val) def _delete(self, node: Node, val: int) -> Node: if not node: return node # Perform standard BST delete if val < node.value: node.left = self._delete(node.left, val) elif val > node.value: node.right = self._delete(node.right, val) else: if node.left is None: temp = node.right node = None return temp elif node.right is None: temp = node.left node = None return temp temp = self._get_min_value_node(node.right) node.value = temp.value node.right = self._delete(node.right, temp.value) if not node: return node # Update height and rebalance the node node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) # Left Left Case if balance > 1 and self._get_balance(node.left) >= 0: return self._right_rotate(node) # Left Right Case if balance > 1 and self._get_balance(node.left) < 0: node.left = self._left_rotate(node.left) return self._right_rotate(node) # Right Right Case if balance < -1 and self._get_balance(node.right) <= 0: return self._left_rotate(node) # Right Left Case if balance < -1 and self._get_balance(node.right) > 0: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _get_min_value_node(self, node: Node) -> Node: if node is None or node.left is None: return node return self._get_min_value_node(node.left) def _get_height(self, node: Node) -> int: if not node: return 0 return node.height def _get_balance(self, node: Node) -> int: if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _left_rotate(self, z: Node) -> Node: y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z: Node) -> Node: y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y ``` # Example Usage ```python # Create an AVL Tree and insert values avl = AVLTree() avl.insert(10) avl.insert(20) avl.insert(30) avl.insert(40) avl.insert(50) avl.insert(25) print(\\"Preorder Traversal of AVL Tree:\\") avl.preorder_traversal() # Assume this function is implemented to print tree # Delete value from AVL Tree avl.delete(25) print(\\"Preorder Traversal after deleting 25:\\") avl.preorder_traversal() # Node 25 should be deleted and tree rebalanced ```","solution":"class Node: def __init__(self, value: int): self.value = value self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def insert(self, val: int): self.root = self._insert(self.root, val) def _insert(self, node: Node, val: int) -> Node: if not node: return Node(val) if val < node.value: node.left = self._insert(node.left, val) else: node.right = self._insert(node.right, val) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and val < node.left.value: return self._right_rotate(node) if balance < -1 and val > node.right.value: return self._left_rotate(node) if balance > 1 and val > node.left.value: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and val < node.right.value: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def delete(self, val: int): self.root = self._delete(self.root, val) def _delete(self, node: Node, val: int) -> Node: if not node: return node if val < node.value: node.left = self._delete(node.left, val) elif val > node.value: node.right = self._delete(node.right, val) else: if node.left is None: temp = node.right node = None return temp elif node.right is None: temp = node.left node = None return temp temp = self._get_min_value_node(node.right) node.value = temp.value node.right = self._delete(node.right, temp.value) if not node: return node node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and self._get_balance(node.left) >= 0: return self._right_rotate(node) if balance > 1 and self._get_balance(node.left) < 0: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and self._get_balance(node.right) <= 0: return self._left_rotate(node) if balance < -1 and self._get_balance(node.right) > 0: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _get_min_value_node(self, node: Node) -> Node: if node is None or node.left is None: return node return self._get_min_value_node(node.left) def _get_height(self, node: Node) -> int: if not node: return 0 return node.height def _get_balance(self, node: Node) -> int: if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _left_rotate(self, z: Node) -> Node: y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z: Node) -> Node: y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def preorder_traversal(self): result = [] def _preorder(node): if node is None: return result.append(node.value) _preorder(node.left) _preorder(node.right) _preorder(self.root) return result"},{"question":"# Coding Question **Context**: John is working on a text analysis project and needs to calculate the frequency of each word in a given text. He also wants the ability to exclude common stop words (like \\"the\\", \\"and\\", etc.) and save the frequency count in a specific format. **Task**: Write a Python function `word_frequency_counter` that: 1. Calculates the frequency of each word in the given string `text`. 2. Excludes common stop words if the `exclude_stop_words` parameter is set to `True` (you can hardcode a small list of stop words for this purpose). 3. Supports saving the frequency count to a file in JSON format or returning it as a dictionary based on the input parameters. **Function Signature**: ```python def word_frequency_counter(text: str, exclude_stop_words: bool=False, file_path: str=None) -> dict: Calculates the frequency of each word in the given text. If exclude_stop_words is True, excludes common stop words. If file_path is provided, saves the frequency count in JSON format to the file. Otherwise, returns the frequency count as a dictionary. :param text: str - the input text to analyze :param exclude_stop_words: bool - whether to exclude common stop words :param file_path: str - optional, the path to the file where the frequency count should be saved :return: dict - a dictionary with words as keys and their frequency count as values if file_path is not provided pass ``` **Constraints**: * Words should be case-insensitive (e.g., \\"The\\" and \\"the\\" should be treated as the same word). * Handle punctuations by ignoring them (for example, \\"word,\\" and \\"word\\" should be counted as the same word). * Stop words can be hardcoded as: [\\"the\\", \\"and\\", \\"of\\", \\"to\\", \\"a\\", \\"in\\", \\"that\\", \\"is\\", \\"it\\", \\"with\\", \\"for\\", \\"as\\", \\"on\\", \\"was\\"] **Example**: When calling `word_frequency_counter(\\"Hello world! Hello everyone.\\", exclude_stop_words=False)` without `file_path`: ```python { \\"hello\\": 2, \\"world\\": 1, \\"everyone\\": 1 } ``` When calling `word_frequency_counter(\\"The quick brown fox jumps over the lazy dog. The dog was not amused.\\", exclude_stop_words=True, file_path=\\"frequency_count.json\\")`, the content of `frequency_count.json` should be: ```json { \\"quick\\": 1, \\"brown\\": 1, \\"fox\\": 1, \\"jumps\\": 1, \\"over\\": 1, \\"lazy\\": 1, \\"dog\\": 2, \\"not\\": 1, \\"amused\\": 1 } ``` Additionally, ensure your implementation handles large text input efficiently and manages edge cases appropriately.","solution":"import re import json from collections import Counter def word_frequency_counter(text: str, exclude_stop_words: bool=False, file_path: str=None) -> dict: Calculates the frequency of each word in the given text. If exclude_stop_words is True, excludes common stop words. If file_path is provided, saves the frequency count in JSON format to the file. Otherwise, returns the frequency count as a dictionary. :param text: str - the input text to analyze :param exclude_stop_words: bool - whether to exclude common stop words :param file_path: str - optional, the path to the file where the frequency count should be saved :return: dict - a dictionary with words as keys and their frequency count as values if file_path is not provided # Hardcoded list of common stop words stop_words = {\\"the\\", \\"and\\", \\"of\\", \\"to\\", \\"a\\", \\"in\\", \\"that\\", \\"is\\", \\"it\\", \\"with\\", \\"for\\", \\"as\\", \\"on\\", \\"was\\"} # Convert text to lower case and remove punctuation text = re.sub(r\'[^ws]\', \'\', text.lower()) # Split the text into words words = text.split() # Exclude stop words if required if exclude_stop_words: words = [word for word in words if word not in stop_words] # Count the frequency of each word word_count = Counter(words) # If file_path is provided, save the frequency count in JSON format to the file; otherwise, return as dictionary if file_path: with open(file_path, \'w\') as file: json.dump(word_count, file) else: return dict(word_count)"},{"question":"# Problem Statement: You are given two sorted arrays of integers. Write a function to find the elements that are common in both arrays. The output should be a list of common elements, sorted in ascending order, without duplicates. Input: * Two sorted arrays of integers, `arr1` and `arr2`. Output: * A list of integers representing the common elements in both arrays, sorted in ascending order and without duplicates. # Constraints: * The length of each array does not exceed (10^5). * Each element in the arrays is an integer where (-10^9 leq text{element} leq 10^9). # Example: ```python arr1 = [1, 2, 3, 4, 5] arr2 = [3, 4, 5, 6, 7] expected_output = [3, 4, 5] ``` Implement the function `find_common_elements(arr1, arr2)` to return the above output for the given input arrays. Function Signature: ```python def find_common_elements(arr1: List[int], arr2: List[int]) -> List[int]: ... ```","solution":"def find_common_elements(arr1, arr2): Returns the list of common elements between two sorted arrays. set1 = set(arr1) set2 = set(arr2) common_elements = sorted(set1 & set2) return common_elements"},{"question":"# Problem Statement You are given a list of words and a list of candidate letters. Write a function that finds the longest word in the list that can be constructed by the candidate letters. Each candidate letter can be used only once per word. If there are multiple words with the same maximum length, return the lexicographically smallest one. If no valid word can be formed, return an empty string. # Function Signature ```python def longest_constructable_word(words: list[str], letters: list[str]) -> str: Finds the longest word that can be constructed using the given candidate letters. Args: words (list[str]): A list of words. letters (list[str]): A list of candidate letters. Returns: str: The longest word that can be constructed, or the lexicographically smallest word if there are ties in length, or an empty string if no word can be constructed. pass ``` # Example Usage ```python words = [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"] letters = [\'a\', \'p\', \'l\', \'e\', \'c\', \'h\', \'r\', \'r\', \'y\'] assert longest_constructable_word(words, letters) == \\"cherry\\" # No valid word can be formed words = [\\"grape\\", \\"kiwi\\", \\"lemon\\"] letters = [\'a\', \'b\', \'c\'] assert longest_constructable_word(words, letters) == \\"\\" # Multiple words with same length, return lexicographically smallest one words = [\\"bat\\", \\"tab\\", \\"cat\\"] letters = [\'b\', \'a\', \'t\', \'a\', \'c\'] assert longest_constructable_word(words, letters) == \\"bat\\" ``` # Constraints * The number of words in the list is >= 1 and <= 1000. * Each word length is >= 1 and <= 100. * The number of candidate letters is >= 1 and <= 1000. * All words consist only of lowercase English letters. # Additional Information Consider edge cases, such as when: * No words can be constructed from the candidate letters. * Some words share common letters, and the function should pick the longest word. * Multiple words have the same length but different lexicographic order. * Case-sensitivity should not be handled as all words and letters are in lowercase.","solution":"def longest_constructable_word(words: list[str], letters: list[str]) -> str: from collections import Counter # Creating a counter for the letters letter_count = Counter(letters) def can_construct(word, letter_count): word_count = Counter(word) for char in word_count: if word_count[char] > letter_count.get(char, 0): return False return True valid_words = [word for word in words if can_construct(word, letter_count)] if not valid_words: return \\"\\" # Find the longest (or lexicographically smallest if tie) valid word valid_words.sort() # Sort words to handle lexicographical longest_word = \\"\\" for word in valid_words: if len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"# Problem: Distinct Powers in Range **Description:** You are given two non-negative integers `x` and `y`. Your task is to implement a function `distinct_powers_in_range` that returns the number of distinct integers of the form (a^b) where (2 leq a leq x) and (2 leq b leq y). **Function Signature:** ```python def distinct_powers_in_range(x: int, y: int) -> int: pass ``` **Input:** - Two integers `x` and `y` where (2 leq x leq 100) and (2 leq y leq 100). **Output:** - Returns an integer which is the number of distinct values among (a^b) for (2 leq a leq x) and (2 leq b leq y). **Constraints:** - The values of (a^b) can become very large. # Example: ```python print(distinct_powers_in_range(5, 5)) # Outputs: 15 print(distinct_powers_in_range(10, 10)) # Outputs: 69 print(distinct_powers_in_range(2, 2)) # Outputs: 1 ``` **Performance Requirement:** - Ensure your function executes within a reasonable time for the maximum input values (x = 100, y = 100).","solution":"def distinct_powers_in_range(x: int, y: int) -> int: Returns the number of distinct integers of the form a^b where 2 <= a <= x and 2 <= b <= y. unique_powers = set() for a in range(2, x + 1): for b in range(2, y + 1): unique_powers.add(a ** b) return len(unique_powers)"},{"question":"# Question Description Create a Python function that accepts a list of integers and a target sum. The function should generate all unique combinations of numbers from the list that add up to the target sum. Each number in the list may only be used once in each combination, and the list may contain duplicates. The order of numbers within each combination and between different combinations does not matter. The function should leverage recursion (backtracking) to explore different potential combinations. # Function Signature ```python def unique_combinations(nums: list[int], target: int) -> list[list[int]]: Generates all unique combinations of numbers that sum up to the target. Parameters: nums (list[int]): List of integers, can include duplicates but order is irrelevant. target (int): The target sum to achieve with combinations of numbers. Returns: list[list[int]]: A list containing all unique combinations that sum up to the target. Constraints: - All elements in \'nums\' are positive integers. - The \'target\' is a non-negative integer. ``` # Input - A list `nums` of positive integers. - A non-negative integer `target`. # Output - A list of combinations where each combination is a list of numbers that add up to the target sum. # Example ```python >>> unique_combinations([10, 1, 2, 7, 6, 1, 5], 8) [[1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] >>> unique_combinations([2, 5, 2, 1, 2], 5) [[1, 2, 2], [5]] ``` # Constraints - Ensure `nums` contains positive integers. - Handle edge cases like the sum being zero or numbers list containing duplicates. # Notes - Duplicate combinations should be avoided in the final output.","solution":"def unique_combinations(nums, target): def backtrack(start, target, path): if target == 0: result.append(path) return if target < 0: return for i in range(start, len(nums)): if i > start and nums[i] == nums[i-1]: continue backtrack(i + 1, target - nums[i], path + [nums[i]]) nums.sort() result = [] backtrack(0, target, []) return result"},{"question":"# Problem Statement Implement a function that calculates factorial using iterative (non-recursive) approach. Factorial of a non-negative integer n is the product of all positive integers less than or equal to n. This functionality is widely used in combinatorics, probability, and statistical computations. # Function Signature ```python def iterative_factorial(n: int) -> int: Given a non-negative integer n, returns the factorial of the number using iterative approach. Args: n: int - A non-negative integer. Returns: int - The factorial of the given number. Raises: TypeError: If the input is not an integer ValueError: If the input integer is negative Examples: >>> iterative_factorial(5) 120 >>> iterative_factorial(0) 1 >>> iterative_factorial(4) 24 >>> iterative_factorial(1) 1 ``` # Constraints 1. The input number will always be a non-negative integer. 2. The function should raise a ValueError if the input integer is negative. 3. The function should raise a TypeError if the input is not an integer. 4. The maximum input number should be (20). # Detailed Requirements and Examples 1. **Input** - Single integer number. 2. **Output** - The factorial of the given number. 3. **Example Scenarios** ```python - iterative_factorial(5) -> 120 - iterative_factorial(0) -> 1 - iterative_factorial(4) -> 24 - iterative_factorial(1) -> 1 ``` # Performance Requirements - Time complexity must be (O(n)). - Space complexity must be (O(1)). # Hints - Consider using a loop to multiply successive integers up to n. - Think about initializing a result variable and updating it within the loop. # Error Handling - If the input number is a negative integer, raise a ValueError. - If the input is not an integer, raise a TypeError.","solution":"def iterative_factorial(n: int) -> int: Given a non-negative integer n, returns the factorial of the number using iterative approach. Args: n: int - A non-negative integer. Returns: int - The factorial of the given number. Raises: TypeError: If the input is not an integer ValueError: If the input integer is negative Examples: >>> iterative_factorial(5) 120 >>> iterative_factorial(0) 1 >>> iterative_factorial(4) 24 >>> iterative_factorial(1) 1 if not isinstance(n, int): raise TypeError(\\"Input must be an integer\\") if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") result = 1 for i in range(2, n + 1): result *= i return result"},{"question":"# Question Style Implement a Cache Simulator # Cache Simulator Challenge using LRU Policy You are tasked with implementing a cache simulator that utilizes the Least Recently Used (LRU) replacement policy. Given the `Cache` class, complete the necessary functions to manage the cache, process access requests, and simulate cache hits and misses. # Implementation Tasks 1. **Cache Initialization**: - Create an instance of the `Cache` class with specified size (number of cache lines). - Ensure the cache starts empty and is ready to process requests. 2. **Process Cache Access**: - Implement the `access` function to process a memory access request. - When data is accessed, it should update the cache accordingly: - If the data is in the cache (cache hit), move it to the most recently used position. - If the data is not in the cache (cache miss), add it to the cache: - If the cache is full, evict the least recently used item first. 3. **Cache Status Retrieval**: - Implement the `get_cache_contents` function to retrieve the current state of the cache. - Return a list of data currently in the cache, ordered from most recently to least recently accessed. 4. **Cache Hit Rate Calculation**: - Implement the `get_cache_hit_rate` function to calculate the hit rate of the cache. - Hit rate should be calculated as the ratio of cache hits to total cache accesses. # Input - `cache_size` : integer indicating the number of cache lines. - `access_sequence` : list of integer memory addresses to be accessed in sequence. # Output - A list of requests processed along with whether it was a hit or miss. - A final list of contents in the cache. - Cache hit rate after processing all requests. # Constraints - Memory addresses are unique integers. - Cache size is a positive integer. - Access sequence is a finite list of non-negative integers. # Example Scenario You are provided with a sequence of memory access requests. Your task is to simulate the cache operations using LRU policy and calculate the efficiency of the cache by determining the hit rate. # Sample Implementation ```python class Cache: def __init__(self, cache_size): self.cache_size = cache_size self.cache = [] self.access_count = 0 self.hit_count = 0 def access(self, data): if data in self.cache: self.cache.remove(data) self.cache.insert(0, data) self.hit_count += 1 return \\"Hit\\" else: if len(self.cache) == self.cache_size: self.cache.pop() self.cache.insert(0, data) return \\"Miss\\" def get_cache_contents(self): return list(self.cache) def get_cache_hit_rate(self): if self.access_count == 0: return 0.0 return self.hit_count / self.access_count def simulate_cache(cache_size, access_sequence): cache = Cache(cache_size) results = [] for address in access_sequence: result = cache.access(address) cache.access_count += 1 results.append(result) return results, cache.get_cache_contents(), cache.get_cache_hit_rate() # Usage example: cache_size = 3 access_sequence = [1, 2, 3, 2, 1, 4, 5, 1, 2] results, final_cache, hit_rate = simulate_cache(cache_size, access_sequence) print(\\"Access Results:\\", results) print(\\"Final Cache Contents:\\", final_cache) print(\\"Cache Hit Rate:\\", hit_rate) ``` **Explanation**: In the above example, we initialize a cache with a size of 3. The access sequence is processed, producing a series of hits and misses, updating the cache contents, and finally computing the cache hit rate.","solution":"class Cache: def __init__(self, cache_size): self.cache_size = cache_size self.cache = [] self.access_count = 0 self.hit_count = 0 def access(self, data): self.access_count += 1 if data in self.cache: self.cache.remove(data) self.cache.insert(0, data) self.hit_count += 1 return \\"Hit\\" else: if len(self.cache) == self.cache_size: self.cache.pop() self.cache.insert(0, data) return \\"Miss\\" def get_cache_contents(self): return list(self.cache) def get_cache_hit_rate(self): if self.access_count == 0: return 0.0 return self.hit_count / self.access_count def simulate_cache(cache_size, access_sequence): cache = Cache(cache_size) results = [] for address in access_sequence: result = cache.access(address) results.append(result) return results, cache.get_cache_contents(), cache.get_cache_hit_rate()"},{"question":"# Binary Tree - Find the Deepest Node Objective: You are tasked with implementing a method to find the deepest node in a binary tree. The deepest node is defined as the node that is the farthest from the root in terms of the levels. Function Signature: ```python def find_deepest_node(root: TreeNode) -> TreeNode: Finds the deepest node in a binary tree. Args: root (TreeNode): The root node of the binary tree. Returns: TreeNode: The deepest node in the binary tree. Raises: ValueError: If the tree is empty (i.e., root is None). ``` Input: * `root`: An instance of `TreeNode` which is the root of the binary tree. Output: * Returns the deepest node in the binary tree. Constraints: * The TreeNode structure is defined and available for use. * Each node contains an integer value and pointers to left and right child nodes. * The binary tree can have any number of nodes, including 0. Example: ```python # Define the binary tree structure class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example binary tree: # 1 # / # 2 3 # / # 4 5 # # 6 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.left.right.right = TreeNode(6) # Find the deepest node deepest_node = find_deepest_node(root) # The deepest node should be TreeNode with value 6 print(deepest_node.val) # Output: 6 ``` Notes: * If there are multiple deepest nodes (nodes at the same maximal depth but different positions), return any one of them. * Handle cases where the tree has only one node or is empty. * Nodes\' values are unique integers.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right from collections import deque def find_deepest_node(root: TreeNode) -> TreeNode: if root is None: raise ValueError(\\"The tree is empty\\") queue = deque([(root, 0)]) deepest_node = root max_depth = 0 while queue: current, depth = queue.popleft() if depth > max_depth: max_depth = depth deepest_node = current if current.left: queue.append((current.left, depth + 1)) if current.right: queue.append((current.right, depth + 1)) return deepest_node"},{"question":"# Coding Assessment Question: Imagine you are working with a large dataset of hexadecimal numbers and you need to detect specific patterns within them. **Problem Statement:** You are provided with an algorithm that first generates all possible 4-digit hexadecimal numbers (ranging from `0000` to `FFFF`). For each hexadecimal number, the algorithm converts it to its decimal representation and checks if it is a perfect square. Then, it looks for hexadecimal numbers that meet this criterion and aren\'t repeated when squared (i.e., the squared values are unique). Your task is to implement a function to find the hexadecimal number with the highest decimal value that satisfies these conditions, or return `None` if no such number exists. **Requirements:** 1. **is_perfect_square(number: int) -> bool**: Given a number, determine if it is a perfect square. - Input: An integer, `number`. - Output: `True` if `number` is a perfect square, else `False`. 2. **find_largest_hex_perfect_square() -> str**: Finds the hexadecimal representation of the highest decimal value that satisfies the condition. - Output: The 4-digit hexadecimal number as a string or `None` if no such number is found. **Input/Output Format:** - The `find_largest_hex_perfect_square` function should return a string representing the 4-digit hexadecimal number. - If no such number is found, the function should return `None`. **Example:** ```python def is_perfect_square(number): # Your perfect square checking logic here def find_largest_hex_perfect_square(): # Your implementation here # Example use case assert find_largest_hex_perfect_square() == \'FFE0\' # Example placeholder, actual result may differ ``` **Constraints/Limitations:** - For `is_perfect_square`: The number input will always be a non-negative integer. - For `find_largest_hex_perfect_square`: Consider only 4-digit hexadecimal numbers (`0000` to `FFFF`).","solution":"import math def is_perfect_square(number: int) -> bool: Determine if the given number is a perfect square. Args: - number (int): An integer to check. Returns: - bool: True if the number is a perfect square, False otherwise. if number < 0: return False root = int(math.sqrt(number)) return number == root * root def find_largest_hex_perfect_square() -> str: Finds the hexadecimal representation of the highest decimal value that is a perfect square and generates a unique squared value. Returns: - str: The 4-digit hexadecimal number as a string or None if no such number is found. highest_hex = None unique_squares = set() for i in range(0xFFFF, -1, -1): if is_perfect_square(i): hex_str = format(i, \'04X\') square = i * i if square not in unique_squares: unique_squares.add(square) highest_hex = hex_str break return highest_hex"},{"question":"# Coding Assessment Question Matrix Diagonal Sum You are given a two-dimensional integer matrix representing a grid of values. Your task is to write a function that calculates the sum of the elements on both the main diagonal and the anti-diagonal of the matrix. The main diagonal is from the top-left to bottom-right, while the anti-diagonal is from the top-right to bottom-left. If the matrix has an odd dimension (i.e., the matrix is `n x n` with `n` being odd), you must subtract the middle element of the matrix from the total sum as it is counted twice. # Problem Statement Write a Python function `diagonal_sum(matrix: list[list[int]]) -> int` that calculates the combined sum of the elements on both the main diagonal and the anti-diagonal of a square matrix. # Function Signature ```python def diagonal_sum(matrix: list[list[int]]) -> int: ``` # Input - `matrix`: A list of lists (2D array) of integers representing the matrix. The matrix will always be square (i.e., same number of rows and columns). # Output - Returns an integer representing the sum of the elements on both diagonals. For odd-dimension matrices, subtract the middle element once. # Constraints - 1 <= len(matrix) <= 1000 - -10^6 <= matrix[i][j] <= 10^6 # Example ```python matrix_1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Diagonal elements are [1, 5, 9] and [3, 5, 7]. # The sum is 1 + 5 + 9 + 3 + 5 + 7 = 30. # Since the matrix has an odd dimension (3x3), the middle element 5 is subtracted once. # Therefore, the result is 30 - 5 = 25. print(diagonal_sum(matrix_1)) # Output: 25 matrix_2 = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] # Diagonal elements are [1, 6, 11, 16] and [4, 7, 10, 13]. # The sum is 1 + 6 + 11 + 16 + 4 + 7 + 10 + 13 = 68. # No need to subtract the middle element as the dimension is even. print(diagonal_sum(matrix_2)) # Output: 68 matrix_3 = [ [5] ] # Diagonal elements are [5] and [5]. # The sum is 5 + 5 = 10. # Since the matrix has an odd dimension (1x1), the middle element 5 is subtracted once. # Therefore, the result is 10 - 5 = 5. print(diagonal_sum(matrix_3)) # Output: 5 ``` # Guidelines 1. Traverse the matrix to sum the elements on both the main diagonal and the anti-diagonal. 2. Take special care to handle the cases where the matrix\'s dimension is odd. 3. Ensure to minimize the time complexity to make the solution efficient even for larger matrices. # Hints - Use two loops to iterate through the matrix and sum the elements based on the indices. - For the main diagonal, the sum is represented by `matrix[i][i]`. - For the anti-diagonal, the sum is represented by `matrix[i][n-1-i]`, where `n` is the dimension of the matrix.","solution":"def diagonal_sum(matrix: list[list[int]]) -> int: n = len(matrix) total_sum = 0 for i in range(n): total_sum += matrix[i][i] total_sum += matrix[i][n - 1 - i] # If matrix has an odd dimension, subtract the middle element once if n % 2 == 1: middle = n // 2 total_sum -= matrix[middle][middle] return total_sum"},{"question":"# Question: Create a class `IntervalSet` that manages a set of disjoint intervals and supports insertion and query of intervals. An interval is defined as a tuple of two integers `(start, end)`, representing a closed interval `[start, end]`. # Class Signature ```python class IntervalSet: def __init__(self): Initializes an empty set of intervals. pass def add_interval(self, start: int, end: int) -> None: Adds a new interval [start, end] to the set. If this interval overlaps with any existing intervals, they should be merged. Args: start (int): The start of the interval. end (int): The end of the interval. pass def query(self, point: int) -> bool: Checks whether a given point is within any of the intervals in the set. Args: point (int): The point to query. Returns: bool: True if the point is within any interval, False otherwise. pass def get_intervals(self) -> List[Tuple[int, int]]: Returns a list of the intervals in the IntervalSet. Returns: List[Tuple[int, int]]: The list of intervals sorted by the start of each interval. pass ``` # Example Usage ```python interval_set = IntervalSet() interval_set.add_interval(1, 3) interval_set.add_interval(5, 8) interval_set.add_interval(2, 6) assert interval_set.get_intervals() == [(1, 8)] assert interval_set.query(4) == True assert interval_set.query(9) == False interval_set.add_interval(10, 12) assert interval_set.get_intervals() == [(1, 8), (10, 12)] assert interval_set.query(11) == True ``` # Constraints: - The intervals in the `IntervalSet` should be disjoint. - Merging intervals should be handled efficiently. - The function should handle a large number of add and query operations efficiently.","solution":"from typing import List, Tuple class IntervalSet: def __init__(self): Initializes an empty set of intervals. self.intervals = [] def add_interval(self, start: int, end: int) -> None: Adds a new interval [start, end] to the set. If this interval overlaps with any existing intervals, they should be merged. Args: start (int): The start of the interval. end (int): The end of the interval. new_interval = (start, end) self.intervals.append(new_interval) self.intervals.sort() # Merge overlapping intervals merged_intervals = [] current_start, current_end = self.intervals[0] for interval in self.intervals[1:]: next_start, next_end = interval if next_start <= current_end + 1: current_end = max(current_end, next_end) else: merged_intervals.append((current_start, current_end)) current_start, current_end = interval merged_intervals.append((current_start, current_end)) self.intervals = merged_intervals def query(self, point: int) -> bool: Checks whether a given point is within any of the intervals in the set. Args: point (int): The point to query. Returns: bool: True if the point is within any interval, False otherwise. for start, end in self.intervals: if start <= point <= end: return True return False def get_intervals(self) -> List[Tuple[int, int]]: Returns a list of the intervals in the IntervalSet. Returns: List[Tuple[int, int]]: The list of intervals sorted by the start of each interval. return self.intervals"},{"question":"Coding Challenge: Minimum Steps to Equal Array Elements # Question: You are given an array of integers, and your goal is to make all the elements in the array equal. You can perform two types of operations on the array: 1. Increment any element by 1. 2. Decrement any element by 1. Determine the minimum number of steps required to achieve this. **Function Signature**: ```python def min_steps_to_equal_elements(arr: List[int]) -> int: pass ``` **Parameters**: - `arr` (List[int]): A list of integers representing the array. **Returns**: - `int`: The minimum number of steps required to make all elements equal. **Constraints**: - The length of the array `arr` is between 1 and 10^5. - Each element in the array is between -10^4 and 10^4. **Performance Requirements**: - Ensure the function runs efficiently for large input sizes. **Example**: ```python arr = [1, 2, 3] # Explanation: Choose element 1 (increment by 1 three times), 2 (increment by 1 once, decrement by 1 once), or 3 (decrement by 1 three times). # Result: 2 steps to make all elements equal to 2. print(min_steps_to_equal_elements(arr)) # Expected output: 2 arr = [10, 15, 20] # Explanation: Choose 15 as the target, increment the first element by 5 (5 steps), and decrement the third element by 5 (5 steps). # Result: 10 steps to make all elements equal to 15. print(min_steps_to_equal_elements(arr)) # Expected output: 10 ``` **Hint**: To minimize the number of steps required, consider choosing the median of the array as the target value. The sum of the differences from each element to the median is minimized compared to any other potential target value. --- This additional question maintains the consistency in terms of complexity, length, and programming concepts by requiring array manipulation and efficient computation. It also introduces a different context and logic but aligns with the problem-solving skills assessed in the original question.","solution":"from typing import List def min_steps_to_equal_elements(arr: List[int]) -> int: Returns the minimum number of steps required to make all elements in the array equal. arr.sort() median = arr[len(arr) // 2] # Median minimizes the sum of absolute deviations steps = sum(abs(x - median) for x in arr) return steps"},{"question":"# Context Encryption and decryption are crucial in the field of computer security to protect data from unauthorized access. Classic cryptographic techniques, such as the Caesar cipher, are useful for understanding how to implement basic encryption and decryption in programming. # Problem Statement You are required to implement a `CaesarCipher` class that performs both encryption and decryption using the Caesar cipher technique with a configurable shift. # Function Specifications: Encrypt: **Input**: - A string `plaintext` (the text to be encrypted). - An integer `shift` (number of positions each character in the plaintext will be shifted). **Output**: - Returns the encrypted text as a string. Decrypt: **Input**: - A string `ciphertext` (the text to be decrypted). - An integer `shift` (number of positions each character in the ciphertext will be shifted back). **Output**: - Returns the decrypted text as a string. # Example: ```python cipher = CaesarCipher() # Encrypt \\"HELLO WORLD\\" with a shift of 3 encrypted_text = cipher.encrypt(\\"HELLO WORLD\\", 3) print(encrypted_text) # Output: \\"KHOOR ZRUOG\\" # Decrypt back the encrypted text with a shift of 3 decrypted_text = cipher.decrypt(encrypted_text, 3) print(decrypted_text) # Output: \\"HELLO WORLD\\" ``` # Constraints: - The shift will always be a non-negative integer. - The text will contain only uppercase English letters (A-Z) and spaces. - Spaces should remain unchanged after encryption or decryption. # Additional Notes: - The Caesar cipher shifts each letter of the plaintext by the given `shift` amount in the alphabet. For example, with a shift of 3, A becomes D, B becomes E, etc. If the shift passes \'Z\', it wraps around back to \'A\'. - Implement error handling for cases where inputs do not match the expected format.","solution":"class CaesarCipher: def encrypt(self, plaintext, shift): Encrypt the plaintext using Caesar cipher with the specified shift. encrypted_text = [] for char in plaintext: if char == \' \': encrypted_text.append(char) else: new_char = chr(((ord(char) - ord(\'A\') + shift) % 26) + ord(\'A\')) encrypted_text.append(new_char) return \'\'.join(encrypted_text) def decrypt(self, ciphertext, shift): Decrypt the ciphertext using Caesar cipher with the specified shift. decrypted_text = [] for char in ciphertext: if char == \' \': decrypted_text.append(char) else: new_char = chr(((ord(char) - ord(\'A\') - shift + 26) % 26) + ord(\'A\')) decrypted_text.append(new_char) return \'\'.join(decrypted_text)"},{"question":"# Task: Implementing Dijkstra\'s Algorithm for Network Routing As a software engineer at a tech company specializing in networking software, you are tasked with developing an efficient routing algorithm to find the shortest path between nodes in a network. # Problem Statement You are provided with a weighted undirected graph representing a network of nodes and must implement Dijkstra\'s algorithm to find the shortest path from a starting node to all other nodes in the network. Your solution should be optimized for both time and space, suitable for large-scale networks. # Requirements * Implement a function `dijkstra` that takes two inputs: a dictionary `graph` representing the network and a string `start_node` representing the starting node. The function should return a dictionary with the shortest distances from the `start_node` to all other nodes. * The graph is represented as a dictionary where keys are node identifiers and values are lists of tuples. Each tuple provides a connected node and the corresponding edge weight. # Constraints * The graph can contain up to 10,000 nodes and 50,000 edges. * Edge weights are positive integers. * Node identifiers are lowercase English letters only. * The start node is guaranteed to be in the graph. # Input Format * `graph` (dict): A dictionary representing the network graph. * `start_node` (str): The starting node in the graph. # Output Format * A dictionary where keys are node identifiers and values are the shortest distances from the `start_node`. # Example ```python def dijkstra(graph: dict, start_node: str) -> dict: # Implement Dijkstra\'s algorithm here graph = { \'a\': [(\'b\', 7), (\'c\', 9), (\'f\', 14)], \'b\': [(\'a\', 7), (\'c\', 10), (\'d\', 15)], \'c\': [(\'a\', 9), (\'b\', 10), (\'d\', 11), (\'f\', 2)], \'d\': [(\'b\', 15), (\'c\', 11), (\'e\', 6)], \'e\': [(\'d\', 6), (\'f\', 9)], \'f\': [(\'a\', 14), (\'c\', 2), (\'e\', 9)] } print(dijkstra(graph, \'a\')) # Output: {\'a\': 0, \'b\': 7, \'c\': 9, \'d\': 20, \'e\': 20, \'f\': 11} ``` # Considerations 1. Ensure the correctness of your implementation when handling graphs with various node and edge configurations. 2. Optimize your algorithm to handle large scale networks efficiently. 3. Consider using a priority queue to improve the performance of the algorithm.","solution":"import heapq def dijkstra(graph, start_node): Implements Dijkstra\'s algorithm to find the shortest path from start_node to all other nodes in the graph. Parameters: graph (dict): Dictionary representing the network graph. start_node (str): The starting node in the graph. Returns: dict: A dictionary where keys are node identifiers and values are the shortest distances from the start_node. # Initialize the priority queue queue = [(0, start_node)] shortest_paths = {start_node: 0} visited = set() while queue: # Get the node with the smallest distance current_distance, current_node = heapq.heappop(queue) if current_node in visited: continue visited.add(current_node) # Explore neighbours for neighbor, weight in graph.get(current_node, []): distance = current_distance + weight if neighbor not in shortest_paths or distance < shortest_paths[neighbor]: shortest_paths[neighbor] = distance heapq.heappush(queue, (distance, neighbor)) return shortest_paths"},{"question":"**Sorting and Searching: Rotated Sorted Array** You are working with a dataset that comes from a sensor network deployed in the field. Unfortunately, due to an unknown error, the sorted data has been rotated from some pivot point, making it a rotated sorted array. You need to locate a specific value within this array. # Problem Statement Given a rotated sorted array `nums` and an integer `target`, your task is to implement a function `search_rotated_sorted_array(nums, target)` that returns the index of `target` in `nums`. If `target` is not present, the function should return -1. # Expected Input and Output Formats ```python def search_rotated_sorted_array(nums: List[int], target: int) -> int: pass ``` - `nums`: A list of distinct integers which was originally sorted in ascending order but has now been rotated. - `target`: An integer representing the value to search for in the array. **Output**: An integer representing the index of `target` in the array, or -1 if `target` is not found. # Constraints 1. `1 <= len(nums) <= 5000` 2. `-10^4 <= nums[i] <= 10^4` 3. All integers in `nums` are unique. 4. `-10^4 <= target <= 10^4` # Performance Requirements Your solution should run in O(log n) time to handle the upper constraint efficiently. # Scenario Consider that you need to quickly and efficiently locate a value within a rotated dataset coming from a weather station that has odd timestamps due to transmission errors. The goal is to restore proper data order by pinpointing specific values within the dataset. # Example ```python nums = [4, 5, 6, 7, 0, 1, 2] target = 0 print(search_rotated_sorted_array(nums, target)) # Output: 4 ``` In this example, the sorted array `[0, 1, 2, 4, 5, 6, 7]` has been rotated, and the `target` value 0 is located at index 4 after the rotation. The function should correctly return 4. ```python nums = [4, 5, 6, 7, 0, 1, 2] target = 3 print(search_rotated_sorted_array(nums, target)) # Output: -1 ``` In this example, the `target` value 3 does not exist in the array, so the function should return -1.","solution":"def search_rotated_sorted_array(nums, target): Returns the index of target in nums or -1 if target is not present. The nums list is assumed to be a rotated sorted array. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid # Check if the left half is properly sorted if nums[left] <= nums[mid]: if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 # Right half must be sorted else: if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Problem Statement: You are tasked with implementing a function that finds the first non-repeating character in a string. **Function Signature**: ```python def first_unique_char(input_str: str) -> str: This function computes and returns the first non-repeating character in the given string. If every character in the string is repeated, the function should return an empty string. ``` # Input: * A single string `input_str` of length `n` where `1 <= n <= 10^6`. * The string will contain only lowercase English letters. # Output: * A single character representing the first non-repeating character in the string. * If all characters are repeated, return an empty string. # Constraints: * The input should be a non-empty string. * The function should run in linear time O(n), with respect to the length of the string. # Examples: ```python assert first_unique_char(\\"leetcode\\") == \\"l\\" assert first_unique_char(\\"loveleetcode\\") == \\"v\\" assert first_unique_char(\\"aabbcc\\") == \\"\\" ``` # Explanation of Examples: 1. For the string \\"leetcode\\", the first non-repeating character is \\"l\\". 2. For the string \\"loveleetcode\\", the first non-repeating character is \\"v\\". 3. For the string \\"aabbcc\\", there are no non-repeating characters, hence the result is an empty string. # Notes: * Iterate through the string to count the occurrence of each character. * Use a secondary pass to find the first character with a count of one.","solution":"def first_unique_char(input_str: str) -> str: This function computes and returns the first non-repeating character in the given string. If every character in the string is repeated, the function should return an empty string. # Dictionary to store the frequency of each character char_count = {} # First pass: count the frequency of each character for char in input_str: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass: find the first character with a count of one for char in input_str: if char_count[char] == 1: return char # If no unique character found, return empty string return \\"\\""},{"question":"Sort Array By Parity Given an array `nums` of non-negative integers, you need to modify the array so that all even integers appear before all odd integers. You can return any array that satisfies this condition. **Objective**: Implement a function `sort_array_by_parity(nums: List[int]) -> List[int]` that sorts the array by parity, with all the even integers coming before all the odd integers. **Function Signature**: ```python def sort_array_by_parity(nums: List[int]) -> List[int]: pass ``` **Input**: - `nums` (List[int]): A list of non-negative integers with (1 leq len(nums) leq 5000) and (0 leq nums[i] leq 5000). **Output**: - Returns the list sorted by parity, with even numbers first followed by odd numbers. **Example**: ```python >>> sort_array_by_parity([3,1,2,4]) [2,4,3,1] >>> sort_array_by_parity([0,2,1]) [0,2,1] ``` # Detailed Requirements: Your function should: 1. Group all even integers at the beginning of the array. 2. Follow with all odd integers at the end of the array. 3. Preserve the relative order of even and odd integers within their respective groups. 4. Ensure the solution is efficient and handles the upper constraint gracefully. # Constraints: - The length of the array is between 1 and 5000. - The values in the array are between 0 and 5000. # Notes: - Consider using in-place swapping to enhance performance. - Various correct outputs are possible as long as all evens precede all odds (relative ordering within groups doesn\'t need to be maintained).","solution":"from typing import List def sort_array_by_parity(nums: List[int]) -> List[int]: Sort the list such that all even numbers come before all odd numbers. even = [x for x in nums if x % 2 == 0] odd = [x for x in nums if x % 2 != 0] return even + odd"},{"question":"Question Design a function to retrieve all unique words from a paragraph given as input, ignoring case sensitivity and punctuation. Your function should: 1. Convert the input paragraph to lowercase. 2. Remove all punctuation marks. 3. Split the paragraph into individual words. 4. Return a set of unique words found in the paragraph. # Function Signature ```python def get_unique_words(paragraph: str) -> set: Return a set of unique words from the given paragraph. ``` # Input - `paragraph` (str): A string containing the paragraph from which unique words need to be extracted. # Output - Returns a set of unique words found in the paragraph, ignoring case and punctuation. # Example ```python get_unique_words(\\"Hello world! It is a beautiful, beautiful day.\\") # Expected Output: {\'hello\', \'world\', \'it\', \'is\', \'a\', \'beautiful\', \'day\'} get_unique_words(\\"Python is awesome. Isn\'t Python great? Yes, Python is!\\") # Expected Output: {\'python\', \'is\', \'awesome\', \'isnt\', \'great\', \'yes\'} ``` # Constraints * Assume that the paragraph will be non-empty and only contain ASCII characters. * Punctuation marks include the following: `.,!?\\"\'`:;-()[]{}`. # Scenario Consider you are building a text analysis tool where you need to identify and list all unique words used in various text inputs. This helps in generating keyword density reports, finding frequently used terms, and other text-mining tasks.","solution":"import string def get_unique_words(paragraph: str) -> set: Return a set of unique words from the given paragraph. # Convert the paragraph to lowercase paragraph = paragraph.lower() # Remove all punctuation translator = str.maketrans(\'\', \'\', string.punctuation) paragraph = paragraph.translate(translator) # Split the paragraph into words words = paragraph.split() # Return a set of unique words return set(words)"},{"question":"# Context You are working on a file processing system where you need to implement operations to efficiently read, write, and manipulate large text files. # Problem Statement Write a Python class `TextFileProcessor` that supports the following functionalities: 1. **Initialization**: Initialize with a file path. 2. **Read File**: Implement a method to read the entire file into memory. 3. **Write File**: Implement a method to write data to the file. 4. **Count Words**: Implement a method to count the number of words in the file. 5. **Find and Replace**: Implement a method to find and replace a word in the file. 6. **String Representation**: A method to return a string representation of the file\'s content. Additionally, implement a proper unit test suite to validate these functionalities. Ensure to cover edge cases, error handling, and performance considerations where applicable. # Implementation Details 1. **Initialization**: ```python class TextFileProcessor: def __init__(self, file_path: str) -> None: self.file_path = file_path self.content = \\"\\" ``` 2. **Read File**: ```python def read_file(self) -> None: with open(self.file_path, \'r\') as file: self.content = file.read() ``` 3. **Write File**: ```python def write_file(self, data: str) -> None: with open(self.file_path, \'w\') as file: file.write(data) ``` 4. **Count Words**: ```python def count_words(self) -> int: return len(self.content.split()) ``` 5. **Find and Replace**: ```python def find_and_replace(self, old_word: str, new_word: str) -> None: self.content = self.content.replace(old_word, new_word) ``` 6. **String Representation**: ```python def __str__(self) -> str: return self.content ``` # Constraints - The input file path is guaranteed to be valid. - The input file size can be large, so consider efficient memory usage where applicable. - Ensure that file read/write operations handle typical file access errors gracefully (e.g., file not found, permission issues). # Unit Tests Create a test class `TestTextFileProcessor` using `unittest` that validates all aspects of your implementation. Cover typical edge cases and error scenarios like empty files, large files, non-existent files, and permission errors. # Example ```python file_processor = TextFileProcessor(\'example.txt\') # Test Reading File file_processor.read_file() print(str(file_processor)) # Should print the content of the file. # Test Writing File file_processor.write_file(\\"Hello World\\") file_processor.read_file() print(str(file_processor)) # Should print \\"Hello World\\" # Test Counting Words print(file_processor.count_words()) # Should correctly count the number of words. # Test Find and Replace file_processor.find_and_replace(\\"World\\", \\"Universe\\") print(str(file_processor)) # Should print \\"Hello Universe\\" # Test String Representation print(str(file_processor)) # Should print file\'s current content. ``` This new question is designed to align with the format, complexity, and scope of the original coding assessment while introducing a unique problem that involves file I/O operations, word processing, and string manipulation.","solution":"import os class TextFileProcessor: def __init__(self, file_path: str) -> None: self.file_path = file_path self.content = \\"\\" def read_file(self) -> None: try: with open(self.file_path, \'r\') as file: self.content = file.read() except FileNotFoundError: raise except PermissionError: raise def write_file(self, data: str) -> None: try: with open(self.file_path, \'w\') as file: file.write(data) self.content = data except PermissionError: raise def count_words(self) -> int: return len(self.content.split()) def find_and_replace(self, old_word: str, new_word: str) -> None: self.content = self.content.replace(old_word, new_word) def __str__(self) -> str: return self.content"},{"question":"**Problem Statement: Sum of the Unique Digits** You are given a list of integers. Your task is to calculate the sum of all unique digits present in the list. # Detailed Steps: 1. **Read Input**: A list of integers. 2. **Extract Digits**: Extract all digits from the integers in the list. 3. **Identify Unique Digits**: Identify the unique digits among the extracted digits. 4. **Calculate Sum**: Calculate the sum of these unique digits. # Constraints: - The list contains up to `10^5` integers. - Each integer `n` will satisfy `-10^9 <= n <= 10^9`. # Function Signature: ```python def sum_unique_digits(nums: List[int]) -> int: Calculate the sum of all unique digits in the provided list of integers. :param nums: A list of integers. :return: The sum of all unique digits. ``` # Input: - `nums`: A List of integers. # Output: - An integer representing the sum of all unique digits. # Example: Given the list: ```python [123, 456, 789, 123] ``` **Unique Digits**: `1, 2, 3, 4, 5, 6, 7, 8, 9` Sum of Unique Digits: `1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45` **So the function should return `45`.** # Implementation: Implement the `sum_unique_digits` function using the provided guidelines.","solution":"def sum_unique_digits(nums): Calculate the sum of all unique digits in the provided list of integers. :param nums: A list of integers. :return: The sum of all unique digits. unique_digits = set() for num in nums: abs_num_str = str(abs(num)) for char in abs_num_str: unique_digits.add(int(char)) return sum(unique_digits)"},{"question":"# Coding Question: Find the First Repeating Element You are developing a feature that requires identifying the first repeating element in an array of integers. An element is considered repeating if it appears more than once in the array. Your task is to find the first element that repeats, i.e., the element whose second occurrence has the smallest index. Function Signature: Implement the function `first_repeating_element`: ```python def first_repeating_element(arr: list[int]) -> int: pass ``` Input: * `arr`: List of `n` integers, where `1 <= n <= 10^5`. Output: * Returns the first repeating element (`int`). If no such element is found, return `-1`. Constraints: * All integers in the array are between `1` and `10^9`. Examples: ```python >>> first_repeating_element([1, 2, 3, 4, 5, 3, 2, 1]) 1 >>> first_repeating_element([10, 5, 3, 4, 3, 5, 6]) 5 >>> first_repeating_element([1, 2, 3, 4, 5]) -1 ``` Explanation: 1. In the array `[1, 2, 3, 4, 5, 3, 2, 1]`, the first element to repeat is `1`. 2. In the array `[10, 5, 3, 4, 3, 5, 6]`, the first element to repeat is `5`. 3. In the array `[1, 2, 3, 4, 5]`, there are no repeating elements, so the function returns `-1`. Hint: Consider using a hash map to keep track of elements you have seen and their positions to efficiently find the first repeating element.","solution":"def first_repeating_element(arr): Returns the first repeating element in the array. If no such element is found, returns -1. seen = {} first_repeating_index = len(arr) first_repeating_element = -1 for index, value in enumerate(arr): if value in seen: if seen[value] < first_repeating_index: first_repeating_index = seen[value] first_repeating_element = value else: seen[value] = index return first_repeating_element if first_repeating_index != len(arr) else -1"},{"question":"# Matrix Rotation by 90 Degrees Objective You are required to develop a function that rotates a given NxN matrix by 90 degrees in the clockwise direction. This exercise tests your ability to manipulate two-dimensional arrays and handle edge cases involving square matrices. Requirements 1. **Function Signature**: `rotate_matrix(matrix: list[list[int]]) -> list[list[int]]` 2. **Input**: * `matrix`: A list of lists, representing an NxN matrix where 1 ≤ N ≤ 100. * The elements of the matrix will be integers between -10^3 and 10^3. 3. **Output**: * A new NxN matrix resulting from rotating the input matrix by 90 degrees clockwise. Constraints * You must rotate the matrix in-place, meaning you cannot use additional structures for the entire matrix transformation. * Ensure your solution handles both small and large matrices efficiently. Performance Requirements * The solution should run in O(N^2) time complexity, where N is the dimension of the matrix. * The space complexity should be O(1), indicating in-place transformation. Scenario Imagine a scenario where you are developing an image processing application. Each image can be represented as an NxN pixel matrix, and one of the functionalities you need to provide is the ability to rotate the image by 90 degrees clockwise. Efficient and correct rotation of these matrices is critical for proper image display and manipulation. Example ```python # Example usage: matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(rotate_matrix(matrix1)) # Expected Output: [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] matrix2 = [ [1] ] print(rotate_matrix(matrix2)) # Expected Output: [ # [1] # ] matrix3 = [ [1, 2], [3, 4] ] print(rotate_matrix(matrix3)) # Expected Output: [ # [3, 1], # [4, 2] # ] matrix4 = [ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ] print(rotate_matrix(matrix4)) # Expected Output: [ # [-7, -4, -1], # [-8, -5, -2], # [-9, -6, -3] # ] ```","solution":"def rotate_matrix(matrix): Rotates the given NxN matrix by 90 degrees clockwise in place. Args: matrix (list of list of int): The NxN matrix to be rotated. Returns: list of list of int: The rotated matrix. n = len(matrix) # Rotate the matrix layer by layer for layer in range(n // 2): first = layer last = n - 1 - layer for i in range(first, last): offset = i - first # Save top top = matrix[first][i] # left -> top matrix[first][i] = matrix[last - offset][first] # bottom -> left matrix[last - offset][first] = matrix[last][last - offset] # right -> bottom matrix[last][last - offset] = matrix[i][last] # top -> right matrix[i][last] = top return matrix"},{"question":"# Problem Statement: Virtual Plant Watering System In this task, you are to simulate a simple virtual plant watering system. The goal is to manage a collection of virtual plants that need regular watering. Each plant has a specific watering interval and a method to water it. Your function should water all the plants regularly based on their individual schedules, and optimize the process using multithreading to ensure efficient watering for a large number of plants. Requirements 1. **Class Definition** Define a class `Plant` with the following attributes: - `name` (str): The name of the plant. - `watering_interval` (int): The number of seconds between each watering. - `last_watered` (datetime): The timestamp of the last time the plant was watered. Additionally, define the following methods: - `__init__(name: str, watering_interval: int)`: Initializes the plant with its name and watering interval. - `water(self)`: Updates the `last_watered` attribute to the current time. 2. **Function Signature** ```python def maintain_plant_watering_system(plants: List[Plant], total_duration: int) -> None: ``` 3. **Parameters** - `plants` (List[Plant]): A list of `Plant` instances that need to be watered. - `total_duration` (int): The total duration (in seconds) for which the simulation should run. 4. **Output** - The function should have no return value but should print out a log each time a plant is watered, indicating the plant\'s name and the current time. 5. **Constraints** - Use multithreading to water plants concurrently, ensuring that each plant is watered according to its `watering_interval`. - The system should accurately maintain the watering schedule without drifting over long simulation periods. - Use any standard Python library for multithreading and time management. 6. **Performance Requirements** - The solution should efficiently manage a large number of plants (e.g., 1000 plants) without significant delays or increased memory usage. # Example Usage ```python # Define some example plants plant1 = Plant(name=\\"Rose\\", watering_interval=5) plant2 = Plant(name=\\"Tulip\\", watering_interval=7) plant3 = Plant(name=\\"Daisy\\", watering_interval=10) # List of plants plants = [plant1, plant2, plant3] # Run the watering system for 30 seconds maintain_plant_watering_system(plants, total_duration=30) ``` # Example Output (log) ``` Rose is watered at 2022-10-20 08:23:05 Tulip is watered at 2022-10-20 08:23:07 Rose is watered at 2022-10-20 08:23:10 Daisy is watered at 2022-10-20 08:23:10 Tulip is watered at 2022-10-20 08:23:14 Rose is watered at 2022-10-20 08:23:15 ... ```","solution":"import threading import time from datetime import datetime from typing import List class Plant: def __init__(self, name: str, watering_interval: int): self.name = name self.watering_interval = watering_interval self.last_watered = None def water(self): self.last_watered = datetime.now() print(f\\"{self.name} is watered at {self.last_watered.strftime(\'%Y-%m-%d %H:%M:%S\')}\\") def maintain_plant_watering_system(plants: List[Plant], total_duration: int) -> None: def water_plant(plant): while time.time() < end_time: plant.water() time.sleep(plant.watering_interval) end_time = time.time() + total_duration threads = [] for plant in plants: thread = threading.Thread(target=water_plant, args=(plant,)) threads.append(thread) thread.start() for thread in threads: thread.join()"},{"question":"# Question Create a function that simulates a simplified version of the Minesweeper game grid setup. Given the dimensions of the grid and a list of mine positions, your task is to generate a grid where each cell contains either a mine (\'*\') or a number representing the count of mines in the adjacent cells. # Function Signature ```python def create_minesweeper_grid(rows: int, cols: int, mines: list[tuple[int, int]]) -> list[list[str]]: Generate a Minesweeper grid with the given dimensions and mine positions. Parameters: rows (int): The number of rows in the grid. cols (int): The number of columns in the grid. mines (list[tuple[int, int]]): A list of tuples indicating the positions of mines. Returns: list[list[str]]: The generated Minesweeper grid. ``` # Input - `rows`: an integer (1 <= rows <= 100), the number of rows in the grid. - `cols`: an integer (1 <= cols <= 100), the number of columns in the grid. - `mines`: a list of tuples representing the positions of the mines, where each tuple contains two integers `(row, col)` (0 <= row < rows and 0 <= col < cols). # Output - A list of lists representing the Minesweeper grid: - Each element is either a \'*\' (indicating a mine) or a string representing a number (the count of adjacent mines). # Constraints - There are no duplicate mine positions. - The number of mines should not exceed rows * cols - 1. # Examples ```python # Example 1: rows = 3 cols = 3 mines = [(0, 0), (1, 1)] print(create_minesweeper_grid(rows, cols, mines)) # Output: # [[\'*\', \'1\', \'0\'], # [\'1\', \'*\', \'1\'], # [\'0\', \'1\', \'0\']] # Example 2: rows = 4 cols = 4 mines = [(0, 1), (3, 3)] print(create_minesweeper_grid(rows, cols, mines)) # Output: # [[\'1\', \'*\', \'1\', \'0\'], # [\'1\', \'1\', \'1\', \'0\'], # [\'0\', \'0\', \'1\', \'1\'], # [\'0\', \'0\', \'1\', \'*\']] # Example 3: rows = 2 cols = 2 mines = [(0, 0), (1, 1)] print(create_minesweeper_grid(rows, cols, mines)) # Output # [[\'*\', \'1\'], # [\'1\', \'*\']] ``` # Requirements 1. Implement the `create_minesweeper_grid` function. 2. Ensure the implementation correctly updates the grid based on the positions of the mines. 3. The function should be efficient in terms of both time and space complexities. # Notes - Test the function with edge cases: a grid with no mines, a grid with the maximum number of mines, etc. - Focus on ensuring the correct calculation of adjacent mine counts. - The function should handle grids of various sizes efficiently.","solution":"def create_minesweeper_grid(rows: int, cols: int, mines: list[tuple[int, int]]) -> list[list[str]]: def increment_adjacent_cells(grid, i, j, rows, cols): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < rows and 0 <= nj < cols and grid[ni][nj] != \'*\': grid[ni][nj] = str(int(grid[ni][nj]) + 1) # Initialize the grid with zeros grid = [[\'0\' for _ in range(cols)] for _ in range(rows)] # Place mines and increment adjacent cells count for mine in mines: mi, mj = mine grid[mi][mj] = \'*\' increment_adjacent_cells(grid, mi, mj, rows, cols) return grid"},{"question":"# Question: Implement a Custom Binary Search Tree with Enhanced Functionality You are required to implement a variation of a binary search tree (BST) that includes additional functionalities often required in practical scenarios. This BST will handle integer keys and their associated values. **Features to Implement**: 1. **Range Sum Query**: Calculate the sum of values associated with keys within a specified range [low, high]. 2. **Predecessor and Successor**: Find the in-order predecessor and successor of a given key. 3. **Node Counting**: Count the number of nodes within a specified range [low, high]. # Function Definitions: ```python class EnhancedBST: class Node: def __init__(self, key: int, value: int) -> None: self.key = key self.value = value self.left = None self.right = None def __init__(self) -> None: self.root = None def insert(self, key: int, value: int) -> None: \'\'\' Insert a new key-value pair into the BST. Args: key (int): The key to insert. value (int): The value to insert. \'\'\' pass def range_sum(self, low: int, high: int) -> int: \'\'\' Calculate the sum of values of all keys within the given range. Args: low (int): The lower bound of the range. high (int): The upper bound of the range. Returns: int: The sum of the values within the range. \'\'\' pass def find_predecessor(self, key: int) -> int: \'\'\' Find the in-order predecessor of the given key in the BST. Args: key (int): The key to find the predecessor for. Returns: int: The predecessor key. Raises: KeyError: If the key does not exist or has no predecessor. \'\'\' pass def find_successor(self, key: int) -> int: \'\'\' Find the in-order successor of the given key in the BST. Args: key (int): The key to find the successor for. Returns: int: The successor key. Raises: KeyError: If the key does not exist or has no successor. \'\'\' pass def count_nodes_in_range(self, low: int, high: int) -> int: \'\'\' Count the number of nodes within the given range. Args: low (int): The lower bound of the range. high (int): The upper bound of the range. Returns: int: The number of nodes within the range. \'\'\' pass ``` Input Format: 1. For `insert`: `(key, value)` where `key` is an integer and `value` is the integer value associated with it. 2. For `range_sum`: `(low, high)` specifying the range of keys to sum values. 3. For `find_predecessor`: `(key)` specifying the key to find the predecessor for. 4. For `find_successor`: `(key)` specifying the key to find the successor for. 5. For `count_nodes_in_range`: `(low, high)` specifying the range to count the nodes in. Output Format: 1. For `range_sum`: Returns the sum of values of all keys within the specified range. 2. For `find_predecessor`: Returns the in-order predecessor key. 3. For `find_successor`: Returns the in-order successor key. 4. For `count_nodes_in_range`: Returns the number of nodes within the specified range. Constraints: - All keys and values in the BST are integers. - Implement efficient range queries to handle large datasets. - Maintain a balanced BST to optimize search and insert operations. Example Usage: ```python # Creating an instance of EnhancedBST bst = EnhancedBST() # Inserting key-value pairs bst.insert(10, 100) bst.insert(5, 50) bst.insert(15, 150) bst.insert(2, 20) bst.insert(7, 70) # Range sum query print(bst.range_sum(5, 15)) # Output: 370 # Finding predecessor and successor print(bst.find_predecessor(10)) # Output: 7 print(bst.find_successor(7)) # Output: 10 # Counting nodes in range print(bst.count_nodes_in_range(5, 15)) # Output: 3 (nodes with keys 5, 7, 10, 15) ```","solution":"class EnhancedBST: class Node: def __init__(self, key: int, value: int) -> None: self.key = key self.value = value self.left = None self.right = None def __init__(self) -> None: self.root = None def insert(self, key: int, value: int) -> None: def _insert(node, key, value): if node is None: return self.Node(key, value) if key < node.key: node.left = _insert(node.left, key, value) elif key > node.key: node.right = _insert(node.right, key, value) else: node.value = value return node self.root = _insert(self.root, key, value) def range_sum(self, low: int, high: int) -> int: def _range_sum(node, low, high): if not node: return 0 if node.key < low: return _range_sum(node.right, low, high) elif node.key > high: return _range_sum(node.left, low, high) else: return (node.value + _range_sum(node.left, low, high) + _range_sum(node.right, low, high)) return _range_sum(self.root, low, high) def find_predecessor(self, key: int) -> int: def _find_predecessor(node, key): prev = None curr = node while curr: if key > curr.key: prev = curr curr = curr.right else: curr = curr.left return prev.key if prev else None result = _find_predecessor(self.root, key) if result is None: raise KeyError(f\\"No predecessor found for key {key}\\") return result def find_successor(self, key: int) -> int: def _find_successor(node, key): succ = None curr = node while curr: if key < curr.key: succ = curr curr = curr.left else: curr = curr.right return succ.key if succ else None result = _find_successor(self.root, key) if result is None: raise KeyError(f\\"No successor found for key {key}\\") return result def count_nodes_in_range(self, low: int, high: int) -> int: def _count_nodes_range(node, low, high): if not node: return 0 if node.key < low: return _count_nodes_range(node.right, low, high) elif node.key > high: return _count_nodes_range(node.left, low, high) else: return (1 + _count_nodes_range(node.left, low, high) + _count_nodes_range(node.right, low, high)) return _count_nodes_range(self.root, low, high)"},{"question":"# Check for Palindromic Subsequences Task Write a function `is_palindromic_subsequence(s: str, t: str) -> bool` that determines if the string `s` contains the entire string `t` as a subsequence such that `t` forms a palindrome. The function should handle both small and large values of strings efficiently. Specifications - **Input**: - `s`: A string of length `1 <= len(s) <= 10^5` - `t`: A string of length `1 <= len(t) <= min(len(s), 20)` - **Output**: - `True` if `s` contains a subsequence which is exactly `t` and `t` is a palindrome. - `False` otherwise. - **Constraints**: - Your solution should efficiently check for the subsequence and the palindrome properties. Example ```python def is_palindromic_subsequence(s: str, t: str) -> bool: # (Implement your solution here) pass print(is_palindromic_subsequence(\\"abcbad\\", \\"aba\\")) # Output should be True print(is_palindromic_subsequence(\\"abcdefg\\", \\"ace\\")) # Output should be False print(is_palindromic_subsequence(\\"abacabad\\", \\"a\\")) # Output should be True print(is_palindromic_subsequence(\\"racecar\\", \\"racar\\")) # Output should be False ``` Hints: 1. Check first if `t` is a palindrome. 2. If `t` is a palindrome, investigate if `s` contains `t` as a subsequence. 3. Remember the constraints on the length of `s` and `t` to ensure efficiency. Provide a well-optimized solution, considering the constraints, and explain the core idea behind chosen optimization techniques.","solution":"def is_palindromic_subsequence(s: str, t: str) -> bool: def is_palindrome(t: str) -> bool: return t == t[::-1] if not is_palindrome(t): return False # Check if t is a subsequence of s it = iter(s) return all(char in it for char in t)"},{"question":"# Context You are given an array of integers that represents the heights of buildings in a row. You are required to solve a problem that involves finding special integer sequences within this array. This problem will test your ability to utilize advanced data structures and algorithms for efficiency. # Problem Statement Given an integer array `heights` that represents the heights of buildings, write a function `largest_rectangle_area(heights: List[int]) -> int` that returns the area of the largest rectangle that can be formed within the bounds of the heights. You can assume the rectangle can extend vertically between adjacent buildings. # Input - `heights` - A list of non-negative integers. (1 <= len(heights) <= 10^5, 0 <= heights[i] <= 10^4) # Output - Returns the maximum possible area of a rectangle that can be formed with the given heights. # Example ```python heights = [2, 1, 5, 6, 2, 3] print(largest_rectangle_area(heights)) # Output: 10 heights = [4, 2, 0, 3, 2, 5] print(largest_rectangle_area(heights)) # Output: 6 ``` # Constraints - The solution must be efficient, with a time complexity of O(n). # Function Signature ```python def largest_rectangle_area(heights: List[int]) -> int: pass ``` # Hints 1. Consider using a stack to keep track of the indices of the heights in a way that allows for efficient computation of the largest rectangle. 2. While traversing the array, ensure to calculate areas whenever a height shorter than the current height in the stack is encountered.","solution":"from typing import List def largest_rectangle_area(heights: List[int]) -> int: stack = [] # stack to keep track of indices of heights max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"# Scenario: You have been brought on as a software developer for a retail company that needs to optimize its inventory management system. Part of your task involves determining the reorder point for each product to maintain sufficient stock levels. The reorder point is calculated based on the historical demand and the lead time taken to replenish the stock. # Task: Implement a function `calculate_reorder_point(daily_demand: float, lead_time: int, safety_stock: float) -> float` that computes the reorder point using the formula: [ text{Reorder Point} = (text{daily demand} times text{lead time}) + text{safety stock} ] # Input: - `daily_demand` (float): A positive value representing the average daily demand for the product. - `lead_time` (int): A positive integer representing the number of days it takes to restock the product. - `safety_stock` (float): A positive value representing additional stock to cover variability in demand and lead time. # Output: - Returns a float value representing the reorder point for the product. # Constraints: - Ensure all input parameters (`daily_demand`, `lead_time`, and `safety_stock`) are positive values. # Example: ```python >>> calculate_reorder_point(100.5, 5, 20.0) 522.5 >>> calculate_reorder_point(200.2, 8, 50.0) 1651.6 >>> calculate_reorder_point(50.0, 3, 10.0) 160.0 >>> calculate_reorder_point(75.3, 7, 30.0) 557.1 ```","solution":"def calculate_reorder_point(daily_demand: float, lead_time: int, safety_stock: float) -> float: Calculates the reorder point for inventory using the given daily demand, lead time, and safety stock. Args: daily_demand (float): Average daily demand for the product. lead_time (int): Number of days it takes to restock the product. safety_stock (float): Additional stock to cover variability in demand and lead time. Returns: float: The calculated reorder point. if daily_demand <= 0 or lead_time <= 0 or safety_stock < 0: raise ValueError(\\"Invalid input: All inputs must be positive values.\\") reorder_point = (daily_demand * lead_time) + safety_stock return reorder_point"},{"question":"# Question Course Schedule Validator Using Topological Sorting You are given a list of courses and their prerequisites. Implement a function that checks if it is possible to complete all courses without conflicting dependencies (i.e., there are no cycles in the prerequisites). Use topological sorting to determine the validity of the course schedule. Function Signature ```python def can_finish_courses(num_courses: int, prerequisites: List[List[int]]) -> bool: pass ``` Input * `num_courses`: An integer representing the total number of courses, labeled from `0` to `num_courses-1`. * `prerequisites`: A list of pairs `[a, b]` where `a` is a course that requires course `b` to be completed before `a`. Output * Returns a boolean value: `True` if it is possible to complete all the courses given the prerequisites; otherwise, returns `False`. Constraints * 1 ≤ num_courses ≤ 10^5 * 0 ≤ len(prerequisites) ≤ 5 * 10^5 * `0 ≤ a, b < num_courses` Notes * You can assume that there are no duplicate prerequisite pairs in the input. Example ```python num_courses = 4 prerequisites = [[1, 0], [2, 1], [3, 2]] print(can_finish_courses(num_courses, prerequisites)) ``` Expected Output: ``` True ``` Additional Requirements * Your solution should efficiently handle large inputs. * Ensure the case of multiple disconnected subgraphs within the course dependency graph is handled correctly.","solution":"from collections import deque, defaultdict from typing import List def can_finish_courses(num_courses: int, prerequisites: List[List[int]]) -> bool: # Create adjacency list and in-degree counter for graph representation graph = defaultdict(list) in_degree = [0] * num_courses # Build the graph for course, prereq in prerequisites: graph[prereq].append(course) in_degree[course] += 1 # Initialize the queue with courses that have no prerequisites queue = deque([i for i in range(num_courses) if in_degree[i] == 0]) count_processed_courses = 0 while queue: current_course = queue.popleft() count_processed_courses += 1 for neighbor in graph[current_course]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If count of processed courses is equal to the number of courses, there are no cycles return count_processed_courses == num_courses"},{"question":"# Coding Challenge: List Even-Odd Rearrange **Objective**: Write a function that takes a list of integers and rearranges it such that all the even numbers appear before all the odd numbers. The relative order of even numbers as well as odd numbers should be preserved as in the original list. Function Signature ```python def rearrange_even_odd(input_list: List[int]) -> List[int]: pass ``` Input - `input_list` (list): A list of integers. Output - `List[int]`: The rearranged list with all even numbers at the beginning followed by all odd numbers. Constraints - The list will contain between 1 and 1000 integers. - The integers will be non-negative and not greater than 10^6. Examples ```python assert rearrange_even_odd([1, 2, 3, 4, 5]) == [2, 4, 1, 3, 5] assert rearrange_even_odd([1, 3, 5, 2, 4, 6]) == [2, 4, 6, 1, 3, 5] assert rearrange_even_odd([2, 4, 6, 8, 1]) == [2, 4, 6, 8, 1] assert rearrange_even_odd([7, 1, 3, 5]) == [7, 1, 3, 5] assert rearrange_even_odd([10, 20, 30, 1, 2, 3]) == [10, 20, 30, 2, 1, 3] ``` # Implementation Notes 1. Initialize two empty lists, `evens` and `odds`. 2. Loop through the input list and append each element to `evens` if it is even, otherwise to `odds`. 3. Concatenate `evens` and `odds` to form the final result list. 4. Return the concatenated list. Good luck!","solution":"def rearrange_even_odd(input_list): This function accepts a list of integers and rearranges it such that all the even integers appear before all the odd integers while maintaining their relative order. evens = [num for num in input_list if num % 2 == 0] odds = [num for num in input_list if num % 2 != 0] return evens + odds"},{"question":"# Path Between Nodes in a Graph You are asked to write a function `is_path_exists` that determines if there is a path between two given nodes in an undirected graph. The graph is represented as an adjacency list, and the nodes are labeled with integers. You are given the following constraints: - The graph does not have more than 10,000 nodes. - The graph does not contain any cycles. - The graph can be disconnected. - You are given two nodes, `start` and `end`, and you need to determine if there is a path from `start` to `end`. Your function should return `True` if there is a path between the start and end nodes, and `False` otherwise. Function Signature ```python def is_path_exists(graph: Dict[int, List[int]], start: int, end: int) -> bool: ``` Expected Output Your function should return a boolean representing whether a path exists between the two nodes. # Example ```python >>> graph = { ... 0: [1, 2], ... 1: [0, 3], ... 2: [0], ... 3: [1] ... } >>> start = 0 >>> end = 3 >>> is_path_exists(graph, start, end) True >>> start = 2 >>> end = 3 >>> is_path_exists(graph, start, end) False ``` # Guidelines 1. **Input**: - `graph`: A dictionary representing the adjacency list of the graph. - `start`: An integer representing the starting node. - `end`: An integer representing the ending node. 2. **Output**: Return a boolean representing if a path exists between the `start` and `end` nodes. 3. **Complexity**: Ensure the solution efficiently handles large graphs up to 10,000 nodes. 4. **Edge Cases**: Consider if the graph is empty, if the start node is the same as the end node, and if nodes are not connected.","solution":"def is_path_exists(graph, start, end): Determines if there is a path between start and end nodes in an undirected graph. if start == end: return True visited = set() stack = [start] while stack: node = stack.pop() if node == end: return True if node not in visited: visited.add(node) neighbors = graph.get(node, []) for neighbor in neighbors: if neighbor not in visited: stack.append(neighbor) return False"},{"question":"# Coding Assessment Question Objective: Implement a function to convert numbers between different bases. Your function should accept a number as a string, its current base, and the target base, then return the converted number as a string. Description: You are required to write a function `convert_base` that converts a number from one base to another. The function should handle bases between 2 and 36 inclusively. Input: - A string `num` representing the number in the current base. - An integer `from_base` representing the base of the given number. This will be between 2 and 36 inclusive. - An integer `to_base` representing the base to which the number should be converted. This will also be between 2 and 36 inclusive. Output: - Return the converted number as a string in the `to_base`. Constraints: - The input number will only contain valid characters for the given `from_base`. - The input bases and the target base will always be valid. - Assume bases 2 through 36 are inclusive. - Negative numbers are not considered. Example: ```python input_example = (\\"1A\\", 16, 2) expected_output = \\"11010\\" ``` ```python input_example = (\\"1010\\", 2, 16) expected_output = \\"A\\" ``` Function Signature: ```python def convert_base(num: str, from_base: int, to_base: int) -> str: pass ``` Implementation Instructions: 1. First convert the given number from its original base to a decimal (base 10) integer. 2. Then convert the decimal integer to the target base. 3. Ensure your function is efficient and handles edge cases properly.","solution":"def convert_base(num: str, from_base: int, to_base: int) -> str: # Step 1. Convert number from from_base to base 10. base_10_num = int(num, from_base) # Step 2. Convert the base 10 number to the target base (to_base). if base_10_num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" result = \\"\\" while base_10_num > 0: remainder = base_10_num % to_base result = digits[remainder] + result base_10_num //= to_base return result"},{"question":"# Context: When working with large datasets, memory usage and computational time can become significant concerns. One technique to alleviate such issues is to use Bloom Filters, which are space-efficient probabilistic data structures used to test whether an element is a member of a set. The potential drawback of Bloom Filters is the possibility of false positives, but they guarantee no false negatives. This method involves hash functions and bit operations, which are fundamental concepts in computer algorithms and data structures. # Task: Implement the class `BloomFilter` with methods for initializing the filter, adding an element, and querying the membership of an element. The class should use multiple hash functions to set and check bits in the filter. # Class Signature: ```python class BloomFilter: def __init__(self, size: int, num_hashes: int): Parameters: size : int : The size of the bit array used to store the filter data. num_hashes : int : The number of hash functions to use. pass def add(self, item: str) -> None: Parameters: item : str : The string item to be added to the Bloom Filter. pass def query(self, item: str) -> bool: Parameters: item : str : The string item whose membership is to be checked. Returns: bool : True if the item is possibly in the set, False if the item is definitely not in the set. pass ``` # Input Constraints: 1. `size` will be a positive integer (1 ≤ size ≤ 10^6). 2. `num_hashes` will be a positive integer (1 ≤ num_hashes ≤ 10). 3. `item` will be a non-empty string with a length up to 100 characters, consisting of printable ASCII characters. # Example: ```python # Example usage bf = BloomFilter(size=100, num_hashes=3) # Adding items to the Bloom Filter bf.add(\\"foo\\") bf.add(\\"bar\\") # Querying items print(bf.query(\\"foo\\")) # Output: True (likely) print(bf.query(\\"baz\\")) # Output: False (definitely not) ``` # Notes: 1. To implement multiple hash functions, you can use Python\'s built-in `hashlib` and `bitwise` operations. 2. The `add` method should hash the input element `num_hashes` times and set the corresponding bits in the bit array. 3. The `query` method should hash the input element `num_hashes` times and check the corresponding bits in the bit array. 4. Ensure the bit array is efficient in terms of space and supports quick setting and querying operations.","solution":"import hashlib class BloomFilter: def __init__(self, size: int, num_hashes: int): self.size = size self.num_hashes = num_hashes self.bit_array = [0] * size def _hashes(self, item: str): item = item.encode(\'utf-8\') hash1 = int(hashlib.md5(item).hexdigest(), 16) hash2 = int(hashlib.sha1(item).hexdigest(), 16) for i in range(self.num_hashes): yield (hash1 + i * hash2) % self.size def add(self, item: str) -> None: for index in self._hashes(item): self.bit_array[index] = 1 def query(self, item: str) -> bool: return all(self.bit_array[index] for index in self._hashes(item))"},{"question":"# Coding Assessment Question Scenario: You are developing a software that analyzes biodiversity in a large geographical area. This involves understanding patterns of species distribution through efficient search and interval queries on spatial data. Task: Implement a class `IntervalSearch` to manage intervals representing regions of interest. The class should support adding new intervals, and determining if a given point lies within any of the added intervals. # Requirements: 1. Implement the class methods: - `add_interval(start: int, end: int) -> None`: Add a new interval where `start` is inclusive and `end` is inclusive. Both `start` and `end` are guaranteed to be non-negative integers where 0 <= start <= end. - `contains(point: int) -> bool`: Return `True` if the `point` lies within any of the intervals added so far, otherwise `False`. # Input Format: - The `add_interval` method receives two integers `start` and `end`. - The `contains` method receives one integer `point`. # Output Format: - The `add_interval` method does not return anything. - The `contains` method returns a boolean value. # Constraints: - Number of intervals added ( leq 10^4 ). - Value of `start`, `end`, and `point` ( leq 10^9 ). - Optimal performance is required for both adding intervals and querying containment checks. # Code: ```python class IntervalSearch: def __init__(self): self.intervals = [] def add_interval(self, start: int, end: int) -> None: self.intervals.append((start, end)) self.intervals.sort() def contains(self, point: int) -> bool: for start, end in self.intervals: if start <= point <= end: return True return False ``` # Example: ```python # Example usage interval_search = IntervalSearch() interval_search.add_interval(1, 5) interval_search.add_interval(10, 20) interval_search.add_interval(15, 25) print(interval_search.contains(3)) # Output: True print(interval_search.contains(9)) # Output: False print(interval_search.contains(15)) # Output: True ``` # Explanation: - **Input**: Instances of adding intervals and a point to check for containment. - **Process**: Manage a sorted list of intervals and efficiently check if the point lies within any of them. - **Output**: `True` if the point lies within any interval, `False` otherwise.","solution":"class IntervalSearch: def __init__(self): self.intervals = [] def add_interval(self, start: int, end: int) -> None: self.intervals.append((start, end)) self.intervals.sort() def contains(self, point: int) -> bool: for start, end in self.intervals: if start <= point <= end: return True return False"},{"question":"Problem Statement # Context You are tasked with writing a program that will help manage and process a collection of customer orders in a retail application. Each order has a unique identifier and a value indicating the time the order was placed. As customers expect quick processing of their orders, the application needs to handle a scenario where the k most recent orders are retrieved from the list of orders efficiently. # Task Write a Python function `get_k_recent_orders` that returns the k most recent orders from an unsorted list using an efficient algorithm. # Requirements * **Input**: * `orders` (list of tuples): A list of orders, where each order is represented by a tuple containing a unique identifier (str) and a timestamp (int) in seconds since the epoch (1 ≤ len(orders) ≤ 10^5). * `k` (int): An integer (1 ≤ k ≤ len(orders)). * **Output**: * A list of k tuples, each representing the k most recent orders in the input list. # Constraints 1. Each order in the input list is a tuple of the format (order_id: str, timestamp: int). 2. Ensure the `k` most recent orders are sorted in descending order by their timestamps. 3. Handle edge cases robustly, making sure `k` is always within bounds (`1 ≤ k ≤ len(orders)`). # Function Signature ```python def get_k_recent_orders(orders: list[tuple[str, int]], k: int) -> list[tuple[str, int]]: pass ``` # Example ```python assert get_k_recent_orders([(\\"order1\\", 1609459200), (\\"order2\\", 1609462800), (\\"order3\\", 1609455600), (\\"order4\\", 1609466400)], 2) == [(\\"order4\\", 1609466400), (\\"order2\\", 1609462800)] assert get_k_recent_orders([(\\"o1\\", 1629472800), (\\"o2\\", 1629476400), (\\"o3\\", 1629470000)], 1) == [(\\"o2\\", 1629476400)] ``` # Performance Considerations Your solution should aim for an efficient average-case time complexity, specifically targeting O(n log k) time complexity due to the need to maintain a heap of the k most recent orders.","solution":"import heapq from typing import List, Tuple def get_k_recent_orders(orders: List[Tuple[str, int]], k: int) -> List[Tuple[str, int]]: Given a list of orders and a number k, returns the k most recent orders sorted in descending order by their timestamps. :param orders: List of tuples, where each tuple contains an order id and a timestamp :param k: The number of most recent orders to return :return: List of k most recent orders sorted by descending timestamps if k <= 0 or k > len(orders): raise ValueError(\\"k must be within 1 and the length of the orders list\\") # Using nlargest to directly get the k most recent orders return heapq.nlargest(k, orders, key=lambda order: order[1])"},{"question":"# Coding Challenge: String Manipulation and Pattern Matching Scenario You are part of a development team for a text processing application, and one of your tasks is to implement a function that identifies and counts specific patterns in the content. In this particular exercise, you need to find the number of times a specific substring appears in a given string without overlapping. Question Write a Python function that counts the number of non-overlapping occurrences of a substring within a given string. Function Signature ```python def count_substring_occurrences(text: str, pattern: str) -> int: Returns the number of non-overlapping occurrences of the substring \'pattern\' within the string \'text\'. :param text: The string in which to search for the pattern. :param pattern: The substring to search for within the text. :return: An integer count of non-overlapping occurrences of the pattern. ``` Input/Output * **Input Format**: - `text` (string): The text in which to search for the pattern. - `pattern` (string): The substring to look for. * **Output Format**: - An integer representing the count of non-overlapping occurrences of the pattern in the text. Constraints 1. The pattern and text are composed of standard ASCII characters. 2. The length of the pattern is at least 1 character. 3. The length of the text is at most 100,000 characters. 4. The search should be case-sensitive. Performance Requirement Your solution should efficiently handle large inputs. Example ```python # Example 1 count_substring_occurrences(\\"abababa\\", \\"aba\\") # Expected output: 2 # Example 2 count_substring_occurrences(\\"the quick brown fox jumps over the lazy dog\\", \\"the\\") # Expected output: 2 # Example 3 count_substring_occurrences(\\"aaaa\\", \\"aa\\") # Expected output: 2 ``` **Note**: Ensure no additional libraries are used for the task.","solution":"def count_substring_occurrences(text: str, pattern: str) -> int: Returns the number of non-overlapping occurrences of the substring \'pattern\' within the string \'text\'. :param text: The string in which to search for the pattern. :param pattern: The substring to search for within the text. :return: An integer count of non-overlapping occurrences of the pattern. count = 0 i = 0 while i <= len(text) - len(pattern): if text[i:i+len(pattern)] == pattern: count += 1 i += len(pattern) # Move index by the length of pattern to avoid overlapping else: i += 1 return count"},{"question":"# Coding Assessment Question Scenario You have been asked to develop a part of a text processing library that focuses on summarizing texts. Specifically, the library should be able to generate a summary of a given text by counting the occurrences of each unique word and filtering out the words based on their frequencies. Problem Statement Implement functions to summarize a given input string by counting the frequency of each unique word and filtering them based on a specified frequency threshold. Function Requirements and Constraints 1. **Function Signature** ```python def word_count_summary(text: str) -> dict def filter_words_by_frequency(word_dict: dict, threshold: int) -> dict ``` 2. **Parameters**: * `text` - a string consisting of any characters including alphabets, digits, punctuations, and special characters. Words are separated by spaces. * `word_dict` - a dictionary where keys are words and values are their counts. * `threshold` - an integer value to determine the minimum frequency a word must have to be included in the result. 3. **Return Values**: * For `word_count_summary`: A dictionary representing the frequency count of each unique word in the input text. Words are case-insensitive. * For `filter_words_by_frequency`: A dictionary containing words that occur at least `threshold` times, with their corresponding counts. Example Cases * `word_count_summary(\\"This is a test. This test is only a test.\\")` should return `{\\"this\\": 2, \\"is\\": 2, \\"a\\": 2, \\"test\\": 3, \\"only\\": 1}` * `filter_words_by_frequency({\\"this\\": 2, \\"is\\": 2, \\"a\\": 2, \\"test\\": 3, \\"only\\": 1}, 2)` should return `{\\"this\\": 2, \\"is\\": 2, \\"a\\": 2, \\"test\\": 3}` # Function Descriptions 1. **Function: `word_count_summary(text: str) -> dict`** - Parses the input text into words, normalizes them to lowercase, and counts the occurrences of each unique word. Returns a dictionary with words as keys and their counts as values. 2. **Function: `filter_words_by_frequency(word_dict: dict, threshold: int) -> dict`** - Filters the input word dictionary to include only those words whose frequency is equal to or greater than the specified threshold. Returns a filtered dictionary. Notes * Words are considered to be sequences of alphanumeric characters. * The input text may contain punctuation and special characters, which should be ignored when counting words. * The word counting should be case-insensitive, meaning \\"Test\\" and \\"test\\" should be counted as the same word. * Ensure to handle edge cases like empty strings, strings with only special characters, or strings with a single word repeated. Use the given examples to test your functions, and ensure you handle edge cases appropriately.","solution":"import re from collections import Counter def word_count_summary(text: str) -> dict: Parses the input text into words, normalizes them to lowercase, and counts the occurrences of each unique word. Returns a dictionary with words as keys and their counts as values. # Use regex to find all words (sequences of alphanumeric characters) words = re.findall(r\'bw+b\', text.lower()) return dict(Counter(words)) def filter_words_by_frequency(word_dict: dict, threshold: int) -> dict: Filters the input word dictionary to include only those words whose frequency is equal to or greater than the specified threshold. Returns a filtered dictionary. return {word: count for word, count in word_dict.items() if count >= threshold}"},{"question":"Question # Context: Given a set of transactions recorded throughout the day, each transaction is represented as a tuple containing the transaction ID and the transaction amount. Transactions with the same ID are considered duplicates, and only the transaction with the highest amount should be retained for each ID. Your task is to write a function that removes duplicate transactions, retaining only the one with the highest amount for each unique transaction ID. # Task: Write a Python function `remove_duplicates(transactions: List[Tuple[int, float]]) -> List[Tuple[int, float]]:` that returns a list of transactions containing only the highest amount for each unique transaction ID. # Input: - `transactions`: A list of tuples where each tuple consists of an `int` representing the transaction ID and a `float` representing the transaction amount. # Output: - A list of tuples containing unique transaction IDs with the highest corresponding transaction amount. # Constraints: - All transaction amounts are positive floating-point numbers. - There can be multiple transactions with the same ID, but you should retain only one with the maximum amount. - The resulting list of transactions should be sorted by the transaction ID in ascending order. # Example: ```python def remove_duplicates(transactions: List[Tuple[int, float]]) -> List[Tuple[int, float]]: pass # Your implementation here # Examples: print(remove_duplicates([(1, 100.0), (2, 200.0), (1, 150.0), (3, 300.0), (2, 250.0)])) # Expected output: [(1, 150.0), (2, 250.0), (3, 300.0)] print(remove_duplicates([(4, 400.0), (4, 300.0), (5, 200.0)])) # Expected output: [(4, 400.0), (5, 200.0)] ``` # Requirements: - Use a dictionary to store the highest transaction amount for unique transaction IDs. - Ensure the resulting list is sorted by transaction IDs in ascending order. # Performance: - Optimize your solution for the best possible time complexity. - Handle edge cases such as an empty list of transactions or all transactions with unique IDs.","solution":"from typing import List, Tuple def remove_duplicates(transactions: List[Tuple[int, float]]) -> List[Tuple[int, float]]: Removes duplicate transactions and retains the one with the highest amount for each unique transaction ID. Args: transactions (List[Tuple[int, float]]): List of transactions where each transaction is a tuple (ID, amount). Returns: List[Tuple[int, float]]: List of transactions with unique IDs and highest amounts, sorted by ID in ascending order. transaction_dict = {} # Iterate through each transaction for trans_id, amount in transactions: # If the transaction ID exists in dictionary and the current amount is higher, update the amount if trans_id in transaction_dict: transaction_dict[trans_id] = max(transaction_dict[trans_id], amount) else: # Otherwise, add the transaction ID and amount to the dictionary transaction_dict[trans_id] = amount # Create a sorted list of tuples from the dictionary result = sorted(transaction_dict.items()) return result"},{"question":"# Problem Statement Write a function that takes a string of parentheses and determines if it is valid. A valid string must follow these rules: - Only the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\' are allowed. - Every opening bracket must have a corresponding closing bracket of the same type. - Opening brackets must be closed in the correct order. Additionally, add functionality to count the number of valid substrings of balanced parentheses within the given string. # Function Signatures ```python def is_valid_parentheses(s: str) -> bool: Given a string s containing parentheses characters, determine if the string is valid based on the aforementioned rules. def count_valid_substrings(s: str) -> int: Given a string s containing parentheses characters, count the number of valid substrings within s. ``` # Input 1. The function `is_valid_parentheses(s: str)` takes a single string `s`. 2. The function `count_valid_substrings(s: str)` takes a single string `s`. # Output 1. For the function `is_valid_parentheses(s: str)`, return a boolean value `True` if the string is valid, and `False` otherwise. 2. For the function `count_valid_substrings(s: str)`, return an integer representing the count of valid substrings. # Constraints 1. 1 <= len(s) <= 10^4 2. The string `s` will contain only the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', and no other characters. # Example Usage ```python assert is_valid_parentheses(\\"()\\") == True assert is_valid_parentheses(\\"([)]\\") == False assert is_valid_parentheses(\\"{[]}\\") == True assert count_valid_substrings(\\"()[]{}\\") == 6 assert count_valid_substrings(\\"(()\\") == 2 assert count_valid_substrings(\\")()())\\") == 4 ```","solution":"def is_valid_parentheses(s: str) -> bool: stack = [] bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or bracket_map[char] != stack.pop(): return False else: return False return stack == [] def count_valid_substrings(s: str) -> int: count = 0 stack = [] last_index = -1 for i in range(len(s)): if s[i] in \'({[\': stack.append(i) elif s[i] in \')}]\': if stack and is_valid_parentheses(s[stack[-1]:i+1]): count += 1 last_index = i stack.pop() else: stack = [] last_index = -1 else: return 0 return count"},{"question":"# Coding Assessment Question You are required to implement a function that processes a log file and extracts useful information. The log file contains events logged in a specific format, and your task is to summarize these events by counting their occurrences for each user within a given time period. Each event log follows the format: ``` [<timestamp>] <user_id> <event_type> ``` Where: - `<timestamp>` is in the format `YYYY-MM-DD HH:MM:SS` - `<user_id>` is a string representing the ID of the user - `<event_type>` is a string representing the type of event # Task Requirements 1. **Input**: - The `log_filename` (`str`) containing the log file path. - The `start_time` (`str`) marking the beginning of the time period to consider, in the format `YYYY-MM-DD HH:MM:SS`. - The `end_time` (`str`) marking the end of the time period to consider, in the format `YYYY-MM-DD HH:MM:SS`. 2. **Behavior**: - Open and read the log file. - Parse each log entry within the provided time window. - Count how many times each event type occurred for each user. 3. **Output**: - A dictionary where keys are the user IDs and values are dictionaries mapping event types to their respective counts. 4. **Constraints**: - The log file may have up to 1 million entries. - Ensure the solution is efficient, handling large logs within reasonable time and space. 5. **Example**: If the log file contains: ``` [2023-01-01 00:00:01] user1 login [2023-01-01 01:30:00] user1 logout [2023-01-01 12:00:00] user2 login [2023-01-01 12:05:00] user2 action [2023-01-02 00:00:01] user1 action ``` And the inputs are: - `start_time = \\"2023-01-01 00:00:00\\"` - `end_time = \\"2023-01-01 23:59:59\\"` The output should be: ```python { \\"user1\\": {\\"login\\": 1, \\"logout\\": 1}, \\"user2\\": {\\"login\\": 1, \\"action\\": 1} } ``` Here is an example function signature to get you started: ```python from typing import Dict import datetime def summarize_log_events(log_filename: str, start_time: str, end_time: str) -> Dict[str, Dict[str, int]]: pass ``` **Performance Requirements**: - The function should process log entries in O(n) time complexity where n is the number of entries in the log file. - The space complexity should remain efficient, using O(1) additional space relative to the size of user and event type data. Write the `summarize_log_events` function according to the stated requirements.","solution":"from typing import Dict import datetime def summarize_log_events(log_filename: str, start_time: str, end_time: str) -> Dict[str, Dict[str, int]]: summary = {} start_time_dt = datetime.datetime.strptime(start_time, \\"%Y-%m-%d %H:%M:%S\\") end_time_dt = datetime.datetime.strptime(end_time, \\"%Y-%m-%d %H:%M:%S\\") with open(log_filename, \'r\') as log_file: for line in log_file: line_parts = line.strip().split(\' \') timestamp_str = line_parts[0][1:] + \\" \\" + line_parts[1][:-1] user_id = line_parts[2] event_type = line_parts[3] timestamp_dt = datetime.datetime.strptime(timestamp_str, \\"%Y-%m-%d %H:%M:%S\\") if start_time_dt <= timestamp_dt <= end_time_dt: if user_id not in summary: summary[user_id] = {} if event_type not in summary[user_id]: summary[user_id][event_type] = 0 summary[user_id][event_type] += 1 return summary"},{"question":"**Problem Statement:** You are given a string consisting of lowercase alphabets and digits. Your task is to implement the `reorganize_string` function to rearrange the characters of the string so that no two adjacent characters are the same. If it is not possible to rearrange the string in such a way, return an empty string. # Function Signature: ```python def reorganize_string(s: str) -> str: pass ``` # Input: * A string `s` of length `N` where `1 <= N <= 10^5`. # Output: * A rearranged string where no two adjacent characters are the same if possible. If not, return an empty string. # Constraints: * The string `s` will consist of lowercase English letters and digits only. * The solution should run in `O(N log N)` time complexity. # Example Input: ```python \\"aaabbc\\" ``` # Example Output: ```python \\"ababac\\" ``` # Detailed Requirements: 1. **Character Frequency Calculation:** - Count the frequency of each character. 2. **Max Heap Construction:** - Use a max heap (priority queue) to store characters sorted by their frequency in descending order. 3. **Character Placement:** - Use a greedy approach to place the characters such that no two adjacent characters are the same. Place the most frequent characters first. If not possible, return an empty string. # Considerations: * Ensure the edge cases are handled, such as when the input string has only one character or when it’s impossible to rearrange. * Validate the input to handle maximum constraints efficiently. Implement the function `reorganize_string` accordingly.","solution":"from heapq import heappop, heappush from collections import Counter def reorganize_string(s: str) -> str: # Step 1: Calculate character frequencies frequency = Counter(s) max_frequency = max(frequency.values()) # If the highest character frequency is more than half of the length (plus one for odd length), reorganization is impossible if max_frequency > (len(s) + 1) // 2: return \\"\\" # Step 2: Use a max heap to store characters and their frequencies heap = [] for char, freq in frequency.items(): heappush(heap, (-freq, char)) # Push negated frequency to simulate max heap # Step 3: Reorganize string result = [] prev_char, prev_freq = None, 0 while heap: freq, char = heappop(heap) result.append(char) if prev_char and prev_freq < 0: heappush(heap, (prev_freq, prev_char)) # Add the previous character back if it still has remaining count prev_char, prev_freq = char, freq + 1 # Decrement the frequency of the used character return \\"\\".join(result)"},{"question":"# Problem Statement A data scientist at a social media company needs to analyze user engagement metrics efficiently. Specifically, they wish to identify peak engagement periods for a given day. Your task is to help them by finding the hour with the highest user engagement given a list of engagement counts spanning 24 hours (one count per hour). Implement the function `max_engagement` which takes a list of integers representing user engagement counts for each hour of the day and returns the index of the hour with the highest engagement. If there are multiple hours with the same highest engagement, return the earliest hour. # Requirements Function Signature ```python def max_engagement(engagement_counts: list) -> int: ``` Input * `engagement_counts`: A list of 24 integers, each representing the user engagement count for an hour (0 index represents 12:00 AM to 1:00 AM, 1 index represents 1:00 AM to 2:00 AM, etc.). Output * An integer representing the index of the hour with the highest user engagement. Constraints * The list will always contain exactly 24 integers, each representing the number of user engagements in that hour. * All values in the list will be non-negative integers. # Example ```python >>> max_engagement([23, 45, 67, 89, 12, 90, 34, 45, 56, 78, 99, 10, 34, 56, 78, 99, 45, 23, 11, 8, 67, 45, 33, 67]) 10 >>> max_engagement([12, 20, 35, 15, 45, 50, 60, 70, 80, 90, 100, 120, 130, 140, 110, 100, 95, 85, 75, 65, 55, 45, 35, 25]) 13 >>> max_engagement([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]) 23 ``` # Caveats * Ensure your function efficiently handles the constraint of handling a list of 24 hours, raising appropriate exceptions for invalid inputs, such as if the list length is not exactly 24.","solution":"def max_engagement(engagement_counts: list) -> int: Identifies the hour with the highest user engagement. Parameters: engagement_counts (list): A list of 24 integers, each representing the user engagement count for an hour. Returns: int: The index of the hour with the highest user engagement. If there are multiple hours with the same highest engagement, the earliest hour\'s index is returned. Raises: ValueError: If the provided list is not of length 24. if len(engagement_counts) != 24: raise ValueError(\\"List must contain exactly 24 integers.\\") max_index = 0 max_engagement = engagement_counts[0] for i in range(1, 24): if engagement_counts[i] > max_engagement: max_engagement = engagement_counts[i] max_index = i return max_index"},{"question":"# Distributed Key-Value Store Replication You are tasked with designing part of a distributed key-value store that supports data replication for fault tolerance and improved read performance. Each key-value pair can be stored on multiple nodes, ensuring that data is available even if some nodes fail. **Problem Statement** Write a function `replicate_data` that replicates key-value pairs across multiple nodes. The function should ensure that each key is stored on a specified number of nodes, replicating the data as evenly as possible. ```python import random from collections import defaultdict from typing import List, Dict, Tuple def replicate_data( keys: List[int], values: List[int], nodes: List[str], replication_factor: int ) -> Dict[str, List[Tuple[int, int]]]: Replicate key-value pairs across multiple nodes. :param keys: List of int, keys to be stored :param values: List of int, corresponding values for the keys :param nodes: List of str, available nodes for storage :param replication_factor: int, number of nodes each key should be stored on :return: Dictionary where key is node identifier and value is list of key-value tuples stored on that node pass ``` # Requirements 1. **Input Parameters**: - `keys`: A list of keys that need to be replicated. - `values`: A list of values corresponding to the keys. - `nodes`: A list of node identifiers where data can be stored. - `replication_factor`: The number of nodes on which each key should be replicated. 2. **Output**: - The function should return a dictionary where each key is a node identifier and the value is a list of tuples. Each tuple contains a key and its corresponding value. 3. **Assumptions and Constraints**: - The length of `keys` and `values` will be the same. - The `replication_factor` will not exceed the number of nodes. - The replication should be as even as possible among nodes. - If a key needs to be replicated on a specific number of nodes selected out of the available nodes, ensure that no two identical key-value pairs are stored on the same node more than once. # Example ```python >>> replicate_data( keys=[1, 2, 3], values=[10, 20, 30], nodes=[\\"node1\\", \\"node2\\", \\"node3\\"], replication_factor=2 ) { \\"node1\\": [(1, 10), (2, 20)], \\"node2\\": [(1, 10), (3, 30)], \\"node3\\": [(2, 20), (3, 30)] } ``` # Steps to Solve 1. Assign each key-value pair to `replication_factor` different nodes. 2. Ensure the pairs are distributed as evenly as possible among the nodes. 3. Avoid storing the same key-value pair on the same node more than once. # Considerations - Handle edge cases such as an empty list of keys or nodes. - Randomly select nodes in case multiple combinations are possible for even distribution. - Consider optimizing for both speed and memory usage. Good luck and feel free to ask questions for clarification!","solution":"import random from collections import defaultdict from typing import List, Dict, Tuple def replicate_data( keys: List[int], values: List[int], nodes: List[str], replication_factor: int ) -> Dict[str, List[Tuple[int, int]]]: Replicate key-value pairs across multiple nodes. :param keys: List of int, keys to be stored :param values: List of int, corresponding values for the keys :param nodes: List of str, available nodes for storage :param replication_factor: int, number of nodes each key should be stored on :return: Dictionary where key is node identifier and value is list of key-value tuples stored on that node node_data = defaultdict(list) num_nodes = len(nodes) for key, value in zip(keys, values): selected_nodes = random.sample(nodes, replication_factor) for node in selected_nodes: node_data[node].append((key, value)) return node_data"},{"question":"# Problem Statement You are required to implement a function that evaluates a given arithmetic expression string and returns the computed result. The expression can contain positive and negative integers, and the operators `+`, `-`, `*`, and `/`. Division should be treated as integer division, meaning the result should be truncated towards zero. The expression will be valid and contain no parentheses. # Input Format * A string `expression` representing the arithmetic expression. The length of the string can range from ( 1 ) to ( 10^5 ). # Output Format * An integer representing the result of evaluating the expression. # Constraints * The expression string will always be a valid expression. * The expression will not contain any spaces. # Example ```python For the input string \\"3+2*2\\", the output should be `7`. For the input string \\"3/2\\", the output should be `1`. For the input string \\"-3+2\\", the output should be `-1`. For the input string \\"14-3/2\\", the output should be `13`. ``` # Instructions 1. Implement a simple parser to evaluate the arithmetic expression. 2. Ensure your solution handles both positive and negative integers. 3. Take care to follow the correct order of operations: `*` and `/` have higher precedence than `+` and `-`. # Solution Template Here is a starting template for your solution: ```python def calculate(expression): def operate(op, second, first): if op == \'+\': return first + second elif op == \'-\': return first - second elif op == \'*\': return first * second elif op == \'/\': return int(first / second) # truncate towards zero def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 def apply_operations(operators, values): while operators and precedence(operators[-1]) >= precedence(op): values.append(operate(operators.pop(), values.pop(), values.pop())) operators = [] values = [] i = 0 while i < len(expression): if expression[i].isdigit() or (expression[i] == \'-\' and (i == 0 or expression[i-1] in \\"+-*/\\")): j = i if expression[i] == \'-\': j += 1 while j < len(expression) and expression[j].isdigit(): j += 1 values.append(int(expression[i:j])) i = j else: while (operators and precedence(operators[-1]) >= precedence(expression[i])): values.append(operate(operators.pop(), values.pop(), values.pop())) operators.append(expression[i]) i += 1 while operators: values.append(operate(operators.pop(), values.pop(), values.pop())) return values[-1] if __name__ == \\"__main__\\": user_input = input(\\"Enter an arithmetic expression:n\\").strip() print(calculate(user_input)) ``` Ensure to test your function with a variety of inputs to cover edge cases and validate correctness.","solution":"def calculate(expression): def operate(op, second, first): if op == \'+\': return first + second elif op == \'-\': return first - second elif op == \'*\': return first * second elif op == \'/\': return int(first / second) def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 operators = [] values = [] i = 0 while i < len(expression): if expression[i].isdigit() or (expression[i] == \'-\' and (i == 0 or expression[i-1] in \\"+-*/\\")): j = i + 1 while j < len(expression) and expression[j].isdigit(): j += 1 values.append(int(expression[i:j])) i = j else: while (operators and precedence(operators[-1]) >= precedence(expression[i])): values.append(operate(operators.pop(), values.pop(), values.pop())) operators.append(expression[i]) i += 1 while operators: values.append(operate(operators.pop(), values.pop(), values.pop())) return values[-1]"},{"question":"# Task Description You are tasked with implementing a function that simulates the growth process of a unique plant in a grid and calculates the total area covered by the plant after a given number of steps. # Problem Statement The plant starts growing from a single cell located at the center of a grid. During each step of growth, the plant spreads to adjacent cells in all four directions (left, right, up, down). The growth process continues for a specified number of steps. # Function Signature ```python def plant_growth_area(steps: int) -> int: Computes the total area covered by the plant after a given number of growth steps. ``` # Input * `steps` (int): The number of steps the plant grows. It is guaranteed to be a non-negative integer. # Output * An integer representing the total area covered by the plant after the given number of steps. # Constraints * `0 <= steps <= 10^4` * Assume that the grid can expand indefinitely in all directions. # Examples ```python >>> plant_growth_area(0) 1 >>> plant_growth_area(1) 5 >>> plant_growth_area(2) 13 >>> plant_growth_area(3) 25 ``` # Additional Requirements 1. Use efficient algorithms and data structures to handle the potentially large number of iterations. 2. Ensure that the solution scales well with the maximum constraint. # Scenario You need to simulate the iterative growth pattern of the plant and compute the total area covered after a precise number of steps, ensuring efficient handling of large step values.","solution":"def plant_growth_area(steps: int) -> int: Computes the total area covered by the plant after a given number of growth steps. if steps == 0: return 1 else: return 1 + 4 * (steps * (steps + 1) // 2) # The growth pattern follows the sum of the series for perimeter calculations # The center cell itself accounts for 1, and with each step, the four sides grow, # effectively forming squares with side lengths increasing with the steps"},{"question":"# Coding Question: Kth Largest Element in a Stream Context: Maintaining the k-th largest element in a dynamically updating stream of integers is a common problem in many real-time data processing systems. Efficiently handling insertions and maintaining the k-th largest element allows for quick retrieval of the required data point. Problem Statement: Implement a class that dynamically maintains the k-th largest element in a stream of integers using a min-heap. Class Signature: ```python class KthLargestElement: def __init__(self, k: int, nums: List[int]): Initialize the class with the integer k and the stream of integers. Ensure the k-th largest element can be tracked dynamically as new elements are added. Parameters: k (int): The \\"k\\" in the k-th largest element. nums (List[int]): Initial stream of integers. def add(self, val: int) -> int: Add a new integer to the stream and return the k-th largest element. Parameters: val (int): The new integer to be added to the stream. Returns: int: The k-th largest element after the new integer is added. ``` Input: - `k` (1 <= k <= 10^4): The rank of the largest element to maintain. - `nums` (0 <= len(nums) <= 10^4, -10^4 <= nums[i] <= 10^4): The initial stream of integers. - `val` (-10^4 <= val <= 10^4): New integer to be added to the stream. Output: - For every call to `add(val)`, output the k-th largest element in the updated stream. Constraints: - The add operation should run in O(log k) time. Examples: 1. **Input**: - `k = 3` - `nums = [4, 5, 8, 2]` - `val = 3 -> add(3)` produces `4` - `val = 5 -> add(5)` produces `5` - `val = 10 -> add(10)` produces `5` - `val = 9 -> add(9)` produces `8` - `val = 4 -> add(4)` produces `8` **Output**: `[4, 5, 5, 8, 8]` Explanation: - The stream initially contains [4, 5, 8, 2], and the 3rd largest element is 4. - After adding 3, the stream becomes [4, 5, 8, 2, 3], and the 3rd largest element remains 4. - Continue adding 5, 10, etc., and track the 3rd largest element dynamically.","solution":"import heapq class KthLargestElement: def __init__(self, k: int, nums: list): Initialize the class with the integer k and the stream of integers. Ensure the k-th largest element can be tracked dynamically as new elements are added. Parameters: k (int): The \\"k\\" in the k-th largest element. nums (List[int]): Initial stream of integers. self.k = k self.min_heap = nums heapq.heapify(self.min_heap) # Maintain only the k largest elements in the min-heap while len(self.min_heap) > k: heapq.heappop(self.min_heap) def add(self, val: int) -> int: Add a new integer to the stream and return the k-th largest element. Parameters: val (int): The new integer to be added to the stream. Returns: int: The k-th largest element after the new integer is added. heapq.heappush(self.min_heap, val) if len(self.min_heap) > self.k: heapq.heappop(self.min_heap) return self.min_heap[0]"},{"question":"# Question: Write a Function to Determine Frequency of Characters in a String You are tasked with creating a function that analyzes a string and determines the frequency of each character. This analysis will help in various text-processing applications. Your function should count both upper and lower-case letters, numbers, and special characters as distinct. Function Signature ```python def character_frequency(s: str) -> dict[str, int]: Determines the frequency of each character in the input string. :param s: Input string :return: A dictionary where keys are characters and values are their respective frequencies ``` Requirements * The function should return a dictionary with characters as keys and their frequency counts as values. * The input string can include upper and lower-case letters, numbers, and special characters. * Characters should be treated as case-sensitive (\'A\' and \'a\' are different characters). Input * `s`: A string comprised of any ASCII characters. Example: `\\"Hello, World!\\"` Output * A dictionary where each key is a character from the input string and each value is the number of times that character appears in the string. Constraints * The input string can be empty or contain any printable ASCII characters. * The maximum length of the input string is 1000 characters. Examples ```python # Example 1 input_str = \\"Hello, World!\\" expected_output = { \'H\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \',\': 1, \' \': 1, \'W\': 1, \'r\': 1, \'d\': 1, \'!\': 1 } assert character_frequency(input_str) == expected_output # Example 2 input_str = \\"AaBbCc123\\" expected_output = { \'A\': 1, \'a\': 1, \'B\': 1, \'b\': 1, \'C\': 1, \'c\': 1, \'1\': 1, \'2\': 1, \'3\': 1 } assert character_frequency(input_str) == expected_output # Example 3 input_str = \\"\\" expected_output = {} assert character_frequency(input_str) == expected_output ``` Constraints & Limitations * Ensure your implementation handles all edge cases. * The function should be case-sensitive. * Performance should be O(n), where n is the length of the input string. * Think about the character encoding and how different characters should be treated in your function.","solution":"def character_frequency(s: str) -> dict[str, int]: Determines the frequency of each character in the input string. :param s: Input string :return: A dictionary where keys are characters and values are their respective frequencies frequency = {} for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"# Rectangular Spiral Matrix Create a function that generates a rectangular matrix of size `m x n` filled with elements from 1 to m*n in a spiral order. Starting from the top-left corner, the numbers should be appended in a clockwise direction. # Function Signature ```python def spiral_matrix(m: int, n: int) -> [[int]]: pass ``` # Input: * Two integers `m` and `n` (1 ≤ m, n ≤ 1000) # Output: * A `m x n` matrix represented as a list of lists. # Constraints: * The input dimensions `m` and `n` will always be positive integers within the specified range. * Your solution should be efficient even for larger values of `m` and `n`. # Example: ```python >>> spiral_matrix(3, 3) [ [1, 2, 3], [8, 9, 4], [7, 6, 5] ] >>> spiral_matrix(4, 5) [ [1, 2, 3, 4, 5], [14, 15, 16, 17, 6], [13, 20, 19, 18, 7], [12, 11, 10, 9, 8] ] ``` # Requirements: 1. Your algorithm should fill the matrix in a spiral order starting from the top-left corner. 2. Efficiently handle the matrix filling to avoid unnecessary computations. 3. The function must properly handle edge cases where either `m` or `n` is 1. # Scenario: Generating matrices in a specific order can have applications in data visualization or in solving problems related to pathfinding and coordinate mapping. By ensuring the rectangular spiral filling is fast, you provide a foundational tool useful for multiple computational problems.","solution":"def spiral_matrix(m: int, n: int) -> [[int]]: Generate a rectangular m x n matrix filled with elements from 1 to m*n in spiral order. :param m: number of rows :param n: number of columns :return: m x n matrix filled with elements 1 to m*n in spiral order matrix = [[0] * n for _ in range(m)] direction = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up current_dir = 0 x, y = 0, 0 for i in range(1, m * n + 1): matrix[x][y] = i next_x, next_y = x + direction[current_dir][0], y + direction[current_dir][1] if next_x < 0 or next_x >= m or next_y < 0 or next_y >= n or matrix[next_x][next_y] != 0: current_dir = (current_dir + 1) % 4 next_x, next_y = x + direction[current_dir][0], y + direction[current_dir][1] x, y = next_x, next_y return matrix"},{"question":"Problem Statement Given a string containing a series of commands representing movements inside a 2D grid, implement a function that calculates the final position after executing all the commands. Each command will either be an upward movement (\'U\'), a downward movement (\'D\'), a leftward movement (\'L\'), or a rightward movement (\'R\'). The initial position is always at the origin (0, 0). # Function Signature ```python def final_position(commands: str) -> (int, int): :param commands: A string containing the sequence of movement commands (\'U\', \'D\', \'L\', \'R\'). :return: A tuple representing the final coordinate (x, y) after applying all commands. ``` # Input * A string `commands` consisting of characters \'U\', \'D\', \'L\', \'R\' only, representing movements. # Output * A tuple `(x, y)` where `x` and `y` are integers representing the final coordinates after executing all commands. # Constraints * The length of the `commands` string will be between 1 and 1000 inclusive. * The grid is conceptually infinite; hence, do not worry about boundaries. # Example ```python # Example 1 commands = \\"UUDDLRLR\\" assert final_position(commands) == (0, 0) # Example 2 commands = \\"UUUDD\\" assert final_position(commands) == (0, 1) # Example 3 commands = \\"RRRRRDDDDD\\" assert final_position(commands) == (5, -5) ``` # Explanation 1. In the first example, the movements result in returning to the origin after balancing upward and downward as well as leftward and rightward moves. 2. In the second example, there are more \'U\' commands than \'D\', resulting in a net upward movement. 3. The third example has net movements that place the final position at coordinates (5, -5). # Hints * Initialize the starting coordinates. * Iterate through the command string, updating the coordinates based on the command. * Ensure that the function handles all possible command sequences correctly.","solution":"def final_position(commands: str) -> (int, int): x, y = 0, 0 for command in commands: if command == \'U\': y += 1 elif command == \'D\': y -= 1 elif command == \'L\': x -= 1 elif command == \'R\': x += 1 return (x, y)"},{"question":"# Smallest Subarray with Sum Greater Than or Equal to a Given Value You need to implement a function that finds the minimum length of a contiguous subarray of which the sum is greater than or equal to a given value. If there isn\'t one, return 0 instead. Function Signature ```python def min_subarray_len(target: int, nums: list[int]) -> int: ``` Input - **target** (int): The required sum that the subarray should be greater than or equal to. - **nums** (list[int]): A list of non-negative integers. Output - Returns the minimum length of such a subarray, or 0 if no such subarray exists. Example ```python >>> min_subarray_len(7, [2, 3, 1, 2, 4, 3]) 2 >>> min_subarray_len(15, [1, 2, 3, 4, 5]) 5 >>> min_subarray_len(11, [3, 1, 4, 3, 6]) 3 >>> min_subarray_len(100, [1, 2, 3, 4]) 0 ``` Explanation 1. **Example 1**: The minimum length subarray with sum greater than or equal to `7` is `[4, 3]`, so the function returns `2`. 2. **Example 2**: The entire array sums to `15`, and its length is `5`. 3. **Example 3**: The subarray `[4, 3, 6]` sums to `13`, which is greater than `11`, so the function returns `3`. 4. **Example 4**: All elements sum to less than `100`, so the function returns `0`. Constraints - The `nums` list will have a length between `1` and `10^5`. - Each integer in the `nums` list will be between `1` and `10^4`. - The `target` value will be between `1` and `10^9`. Notes - Optimal solutions have time complexity less than O(n^2), typically achieved using the sliding window technique.","solution":"def min_subarray_len(target: int, nums: list[int]) -> int: Finds the minimum length of a contiguous subarray with a sum greater than or equal to target. n = len(nums) min_length = float(\'inf\') # Initialize to infinity current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return min_length if min_length != float(\'inf\') else 0"},{"question":"# Question: Meeting Scheduler You are tasked with creating a meeting scheduler that finds a suitable time slot for a new meeting. All participants should be available during the scheduled time. You are given: * `availability`: a list of lists where each sublist represents the availability of one participant in intervals `[start, end]`. * `duration`: an integer representing the required meeting duration in minutes. Your task is to determine the earliest possible time interval `[start, end]` where all participants are available, and the meeting can be scheduled. If no such interval exists, return an empty list. **Function to Implement:** ```python def schedule_meeting(availability: List[List[Tuple[int, int]]], duration: int) -> List[int]: Finds the earliest possible time interval for the meeting that fits the duration requirement for all participants. Args: availability (List[List[Tuple[int, int]]]): List of availability intervals for each participant. duration (int): Duration of the meeting in minutes. Returns: List[int]: The start and end time of the earliest possible interval [start, end] where the meeting can be scheduled or an empty list if no such interval exists. ``` **Expected Input & Output:** * **Input:** A list of lists with tuples representing available time intervals for each participant and an integer duration. * **Output:** A list containing the start and end time of the meeting interval or an empty list if no such interval is found. **Constraints:** * Each time interval `[start, end]` follows ( 0 leq start < end leq 1440 ) (representing minutes in a day). * All intervals are sorted and non-overlapping for a single participant. * The total number of intervals in `availability` will not exceed 1000. * Meeting duration ( 1 leq duration leq 1440 ). **Performance Requirements:** * Ensure the algorithm efficiently schedules the meeting time within reasonable time and space constraints. **Example:** ```python >>> availability = [ [(180, 240), (300, 360), (480, 540)], [(0, 60), (120, 180), (300, 360), (540, 600)], [(60, 120), (150, 210), (300, 420), (450, 510)] ] >>> duration = 30 >>> schedule_meeting(availability, duration) [300, 330] >>> availability = [ [(0, 30), (180, 240)], [(0, 60), (240, 300)], [(0, 90), (200, 300)] ] >>> duration = 40 >>> schedule_meeting(availability, duration) [] ``` **Evaluation Criteria:** * Correctness: Ensure all cases, including edge cases, are handled correctly. * Efficiency: Implement an efficient solution within the given constraints. * Readability: Write clean, maintainable code with necessary comments.","solution":"from typing import List, Tuple def schedule_meeting(availability: List[List[Tuple[int, int]]], duration: int) -> List[int]: Finds the earliest possible time interval for the meeting that fits the duration requirement for all participants. Args: availability (List[List[Tuple[int, int]]]): List of availability intervals for each participant. duration (int): Duration of the meeting in minutes. Returns: List[int]: The start and end time of the earliest possible interval [start, end] where the meeting can be scheduled or an empty list if no such interval exists. # Convert the availability into a list of individual time points each as (time, type) # where type is 1 for start of an interval and -1 for end of an interval events = [] for a in availability: for start, end in a: events.append((start, 1)) events.append((end, -1)) # Sort the events by time, in case of tie, end event (-1) goes before start event (1) events.sort(key=lambda x: (x[0], x[1])) ongoing_meetings = 0 last_start = None for time, event_type in events: if event_type == 1: ongoing_meetings += 1 if ongoing_meetings == len(availability): # All participants are now available last_start = time elif event_type == -1: if ongoing_meetings == len(availability) and last_start is not None: # All participants were available, check the duration if time - last_start >= duration: return [last_start, last_start + duration] ongoing_meetings -= 1 return []"},{"question":"# Problem Statement You are given a string which is a valid sentence. Your task is to write a function `replace_phrases` that replaces all occurrences of words from a dictionary with their corresponding values. The dictionary will contain phrases as keys and their replacements as values. The function should perform the replacement in such a way that once a word has been replaced, it should not be replaced again even if a replacement key matches its substring. # Input and Output Formats Input: * `sentence` (str): A sentence made up of words separated by spaces. * `replacement_dict` (dict): A dictionary where keys are substrings to be replaced, and values are the corresponding replacements. Output: * A modified sentence (str) with all applicable replacements performed. # Constraints: * The input sentence will only contain alphabetic characters and spaces. * The length of the sentence will not exceed (10^4) characters. * The replacement dictionary can contain up to (10^3) key-value pairs. * All keys and values in the replacement dictionary will be lowercase alphabetic strings without spaces. # Performance Requirements: * Optimize the function to handle the maximum constraints efficiently. # Examples: ```python >>> sentence = \\"the quick brown fox jumps over the lazy dog\\" >>> replacement_dict = {\\"quick\\": \\"fast\\", \\"brown\\": \\"dark\\", \\"the\\": \\"a\\", \\"lazy\\": \\"sleepy\\"} >>> replace_phrases(sentence, replacement_dict) \\"a fast dark fox jumps over a sleepy dog\\" ``` # Additional Test Case: ```python >>> sentence = \\"we love programming because programming is fun\\" >>> replacement_dict = {\\"programming\\": \\"coding\\", \\"fun\\": \\"enjoyable\\", \\"because\\": \\"since\\"} >>> replace_phrases(sentence, replacement_dict) \\"we love coding since coding is enjoyable\\" ``` # Edge Cases: 1. Sentence with no matches in the replacement dictionary: ```python >>> sentence = \\"hello world\\" >>> replacement_dict = {\\"goodbye\\": \\"bye\\", \\"earth\\": \\"planet\\"} >>> replace_phrases(sentence, replacement_dict) \\"hello world\\" ``` 2. Empty Sentence and Empty Replacement Dictionary: ```python >>> replace_phrases(\\"\\", {}) \\"\\" >>> sentence = \\"example sentence\\" >>> replace_phrases(sentence, {}) \\"example sentence\\" >>> replacement_dict = {\\"example\\": \\"sample\\"} >>> replace_phrases(\\"\\", replacement_dict) \\"\\" ``` # Implementation Requirements: * Ensure the input sentence is a string and the replacement_dict is a dictionary, otherwise raise an `AssertionError`. * Ensure that the function handles multiple occurrences of the same word properly.","solution":"def replace_phrases(sentence, replacement_dict): Replace all occurrences of words in the sentence with their corresponding values from the replacement_dict. sentence: A string containing the sentence. replacement_dict: A dictionary where keys are words to be replaced and values are the replacements. Returns: A newly formed sentence after the replacements. assert isinstance(sentence, str), \\"Input sentence must be a string\\" assert isinstance(replacement_dict, dict), \\"Replacement dictionary must be a dictionary\\" words = sentence.split() for i in range(len(words)): if words[i] in replacement_dict: words[i] = replacement_dict[words[i]] return \' \'.join(words)"},{"question":"# Coding Assessment Question: You are required to implement a function to optimize mundane tasks. The task involves determining the smallest number of steps to reduce a given integer to 1. You can perform the following operations: 1. If the number is even, divide it by 2. 2. If the number is odd, you can either: - Subtract 1 from it, or - Add 1 to it. # Objective: Implement the function `min_steps_to_one(n: int) -> int` that returns the minimum number of steps required to reduce the given integer `n` to 1. # Input: * `n` (integer): The starting integer value (1 <= n <= 10^6). # Output: * An integer representing the minimum number of steps required to reduce `n` to 1. # Constraints: * **Performance**: The solution should efficiently handle the upper bound within a reasonable time frame. # Example: ```python def min_steps_to_one(n: int) -> int: # Your implementation here... pass # Test the function with the example cases print(min_steps_to_one(7)) # Expected output: 4 print(min_steps_to_one(10)) # Expected output: 4 ``` # Explanation: - For the input `n = 7`, the sequence of steps can be: 7 → 8 → 4 → 2 → 1, which takes 4 steps. - For the input `n = 10`, the sequence can be: 10 → 5 → 4 → 2 → 1, which also requires 4 steps. # Additional Notes: * Consider edge cases where `n` is already 1. * Ensure the code is optimized and can handle the maximum constraint efficiently.","solution":"def min_steps_to_one(n: int) -> int: Returns the minimum number of steps required to reduce the given integer n to 1 by: - Dividing by 2 if n is even. - Adding or subtracting 1 if n is odd. from collections import deque # Use a deque as a queue to perform BFS. queue = deque([(n, 0)]) visited = set() visited.add(n) while queue: number, steps = queue.popleft() # If we reach 1, return the number of steps taken. if number == 1: return steps # Check next possible steps if number % 2 == 0: # Divide by 2 next_number = number // 2 if next_number not in visited: visited.add(next_number) queue.append((next_number, steps + 1)) else: # Odd: either add 1 or subtract 1 next_number_minus = number - 1 if next_number_minus not in visited: visited.add(next_number_minus) queue.append((next_number_minus, steps + 1)) next_number_plus = number + 1 if next_number_plus not in visited: visited.add(next_number_plus) queue.append((next_number_plus, steps + 1))"},{"question":"# Graph Shortest Path Finder Using Dijkstra\'s Algorithm You are to implement the Dijkstra\'s Algorithm to find the shortest path from a given start node to all other nodes in a weighted graph. The graph will be represented using an adjacency list. Instructions 1. **Define a `Graph` class:** - Store the graph as a dictionary. - Implement methods: - `add_edge`: to add an edge between two nodes with a given weight. - `dijkstra`: to perform Dijkstra\'s algorithm and return a dictionary where keys are nodes and values are the shortest distance from the start node. 2. **Define a `shortest_paths` function:** - Takes an integer `n` (number of nodes), a list of tuples `(u, v, w)` (edges where `u` and `v` are nodes, and `w` is the weight of the edge), and an integer `start` (the start node). - Constructs the graph using the `Graph` class. - Calculates the shortest path from the start node to all other nodes using Dijkstra\'s algorithm. - Returns a dictionary where keys are node indices and values are the shortest paths from the start node. Function Signature ```python def shortest_paths(n: int, edges: list[tuple[int, int, int]], start: int) -> dict[int, int]: ``` Examples - `shortest_paths(5, [(0, 1, 10), (0, 4, 5), (1, 2, 1), (2, 3, 4), (4, 3, 2), (4, 1, 3)], 0)` -> `{0: 0, 1: 8, 2: 9, 3: 7, 4: 5}` - `shortest_paths(3, [(0, 1, 1), (1, 2, 2)], 0)` -> `{0: 0, 1: 1, 2: 3}` - `shortest_paths(4, [(0, 1, 1), (1, 2, 2), (1, 3, 5)], 1)` -> `{0: inf, 1: 0, 2: 2, 3: 5}` Constraints - The graph is directed and positively weighted. - The number of nodes ( n ) can be up to ( 10^5 ). - The number of edges ( m ) can be up to ( 2 times 10^5 ). - Weights of edges ( w ) are non-negative integers. Performance Expectations - Aim for a time complexity of ( O((n + m) log n) ) and space complexity of ( O(n + m) ). **Edge Cases**: - Handle graphs with no edges. - Ensure proper handling of disjoint nodes (nodes unreachable from the start node). - Address large datasets effectively, avoiding performance bottlenecks.","solution":"import heapq class Graph: def __init__(self, n): self.graph = {i: [] for i in range(n)} def add_edge(self, u, v, w): self.graph[u].append((v, w)) def dijkstra(self, start): distances = {node: float(\'inf\') for node in self.graph} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in self.graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def shortest_paths(n, edges, start): graph = Graph(n) for u, v, w in edges: graph.add_edge(u, v, w) return graph.dijkstra(start)"},{"question":"# Question: Implementing a Simple Cache with LRU Replacement Policy Context: You need to design a simple cache system that uses the Least Recently Used (LRU) policy to remove old entries when the cache reaches its capacity. # Task: Implement a class `LRUCache` with the following functionalities: 1. **Initialization**: Method `__init__(capacity)` initializes the cache with a specified capacity. 2. **Get Value**: Method `get(key)` retrieves the value associated with the key and marks it as recently used. 3. **Put/Update Value**: Method `put(key, value)` inserts a new key-value pair into the cache. If the key already exists, it updates the value and marks it as recently used. If the cache is full, it removes the least recently used item before inserting the new key-value pair. 4. **String Representation**: Method `__repr__` returns a string representation of the current state of cache key-value pairs in order of most to least recently used. # Requirements: 1. **Input/Output**: - The methods should operate on instances of `LRUCache`. - The `__repr__` method should return a string that overlays each cache entry as `<key: value>` --->, ordered from most recently used to least recently used. 2. **Constraints**: - The `get` and `put` methods should both have a time complexity of O(1). - Assume all keys and values are integers. # Example: ```python # Initializing the cache with capacity of 3 cache = LRUCache(3) print(cache) # Expected: <END> # Adding entries to the cache cache.put(1, 1) print(cache) # Expected: <1: 1> ---> <END> cache.put(2, 2) print(cache) # Expected: <2: 2> ---> <1: 1> ---> <END> cache.put(3, 3) print(cache) # Expected: <3: 3> ---> <2: 2> ---> <1: 1> ---> <END> # Accessing an existing entry (mark as recently used) cache.get(1) print(cache) # Expected: <1: 1> ---> <3: 3> ---> <2: 2> ---> <END> # Adding a new entry causing eviction of least recently used entry cache.put(4, 4) print(cache) # Expected: <4: 4> ---> <1: 1> ---> <3: 3> ---> <END> # Accessing a non-existing entry print(cache.get(5)) # Expected: -1 # Cache after access attempt of non-existing key print(cache) # Expected: <4: 4> ---> <1: 1> ---> <3: 3> ---> <END> ```","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity): Initialize the LRU Cache with a specific capacity. self.capacity = capacity self.cache = OrderedDict() def get(self, key): Retrieve the value associated with the key if it exists in the cache. If the key exists, move it to the front (most recently used). If the key does not exist, return -1. if key in self.cache: value = self.cache.pop(key) self.cache[key] = value return value return -1 def put(self, key, value): Insert a new key-value pair into the cache. If the key already exists, update its value and mark it as recently used. If the cache is at capacity, remove the least recently used item before inserting the new pair. if key in self.cache: self.cache.pop(key) elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) self.cache[key] = value def __repr__(self): Return a string representation of the cache from most recently used to least recently used. if not self.cache: return \\"<END>\\" return \\" ---> \\".join(f\\"<{key}: {value}>\\" for key, value in reversed(self.cache.items())) + \\" ---> <END>\\""},{"question":"# Question: Implement a Function to Compute the Roots of a Quadratic Equation Context: Quadratic equations appear frequently in mathematical modeling, physics problems, and various computational simulations. Solving such equations accurately is essential in many scenarios. You are tasked with implementing a function that calculates the roots of a quadratic equation given its coefficients. Requirements: Implement a function `quadratic_roots` that: - Takes three parameters: `a`, `b`, and `c`. - Returns a dictionary containing the roots of the quadratic equation. Function Signature: ```python def quadratic_roots(a: float, b: float, c: float) -> dict[str, float or complex]: ``` Input: - `a` (float): The coefficient of (x^2). It can be any real number except zero. - `b` (float): The coefficient of (x). It can be any real number. - `c` (float): The constant term. It can be any real number. Output: - Returns a dictionary with keys \'root1\' and \'root2\', which correspond to the two roots of the quadratic equation. Constraints: - If `a` is zero, raise a `ValueError` with the message \\"Coefficient \'a\' cannot be zero\\". - The returned roots should be real if the discriminant is non-negative and complex if the discriminant is negative. Example: ```python result = quadratic_roots(a=1, b=-3, c=2) print(result) # Output: {\'root1\': 2.0, \'root2\': 1.0} result = quadratic_roots(a=1, b=0, c=-4) print(result) # Output: {\'root1\': 2.0, \'root2\': -2.0} result = quadratic_roots(a=1, b=2, c=5) print(result) # Output: {\'root1\': (-1+2j), \'root2\': (-1-2j)} ``` Implement the function according to the above specifications and ensure proper handling of cases with real and complex roots.","solution":"import cmath def quadratic_roots(a: float, b: float, c: float) -> dict: Compute the roots of a quadratic equation a*x^2 + b*x + c = 0. Args: a (float): Coefficient of x^2. Must not be zero. b (float): Coefficient of x. c (float): Constant term. Returns: dict: Contains the roots with keys \'root1\' and \'root2\'. if a == 0: raise ValueError(\\"Coefficient \'a\' cannot be zero\\") # Calculating the discriminant discriminant = b**2 - 4 * a * c # Finding two roots root1 = (-b + cmath.sqrt(discriminant)) / (2 * a) root2 = (-b - cmath.sqrt(discriminant)) / (2 * a) return {\'root1\': root1, \'root2\': root2}"},{"question":"# Compression Algorithm Implementation You are given the task of implementing a basic compression algorithm for a string consisting of alphabetic characters. The algorithm should compress the string by using the counts of repeated characters. For example, the string `\\"aabcccccaaa\\"` would become `\\"a2b1c5a3\\"`. Function Specifications Write a function `compress_string` with the following signature: ```python def compress_string(s: str) -> str: ``` Input - `s` (str): A string consisting of alphabetic characters, with a length `n` such that `1 <= n <= 1000`. Output The function should return the compressed string if the compressed version is shorter or equal in length to the original string. If the compressed version is longer, return the original string. Constraints - The string will only contain uppercase and lowercase letters (i.e., `a-z`, `A-Z`). - The characters are case-sensitive, so `\\"a\\"` and `\\"A\\"` are considered different characters. Example ```python assert compress_string(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" assert compress_string(\\"abcdef\\") == \\"abcdef\\" assert compress_string(\\"aaAAa\\") == \\"aaAAa\\" ``` Notes 1. The compressed string should use counts in a contiguous manner without any delimiters between character counts. 2. Ensure to handle strings where the compressed version is not shorter. 3. The function should be case-sensitive. [End of Question]","solution":"def compress_string(s: str) -> str: Compresses the input string using the counts of repeated characters. Returns the compressed string if it is shorter than the original, otherwise returns the original string. if len(s) == 0: return s compressed = [] count = 1 # Iterate over the string and count consecutive characters for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(f\\"{s[i - 1]}{count}\\") count = 1 # Append the last set of characters compressed.append(f\\"{s[-1]}{count}\\") compressed_string = \'\'.join(compressed) # Return the original string if compressed version is longer return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Context: A logistics company is developing a transportation management system that calculates the shortest paths for their delivery trucks. They want to implement the Dijkstra\'s algorithm to help determine the most efficient routes between warehouses. # Task: Implement Dijkstra\'s algorithm to find the shortest path from a given start node to all other nodes in a graph. Your solution should be capable of handling an arbitrary list of nodes and edges with non-negative weights. # Requirements: 1. **Function Implementation:** - Implement a function `dijkstra(graph: Dict[str, Dict[str, int]], start: str) -> Dict[str, int]` where `graph` is a dictionary representing the adjacency list of the graph and `start` is the start node. - The function should return a dictionary with the shortest distances from the start node to each other node. 2. **Edge Case Handling:** - Ensure that the function can handle disconnected graphs (nodes that cannot be reached from the start node should have a distance of infinity). 3. **Testing:** - Demonstrate the correctness of your implementation with several test cases. **Input and Output formats:** - **Input:** A dictionary representing the graph and a string representing the start node. - **Output:** A dictionary representing the shortest distances from the start node to each node. **Constraints:** - The graph has no negative weight cycles. - The nodes are represented as strings. - Numpy is not allowed for this task. # Example: ```python graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'C\': 2, \'D\': 5}, \'C\': {\'D\': 1}, \'D\': {} } start = \'A\' # Expected: {\'A\': 0, \'B\': 1, \'C\': 3, \'D\': 4} result = dijkstra(graph, start) print(result) # {\'A\': 0, \'B\': 1, \'C\': 3, \'D\': 4} ``` **Note:** Ensure to avoid referencing the example code directly.","solution":"import heapq from typing import Dict def dijkstra(graph: Dict[str, Dict[str, int]], start: str) -> Dict[str, int]: Returns the shortest distances from the start node to each node in the graph using Dijkstra\'s algorithm. :param graph: Dictionary representing the adjacency list of the graph. :param start: The starting node. :return: Dictionary with the shortest distances to each node. # Initialize the shortest distances shortest_distances = {node: float(\'inf\') for node in graph} shortest_distances[start] = 0 # Priority queue to select the node with the smallest distance priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # Skip if we already found a shorter way to the current node if current_distance > shortest_distances[current_node]: continue for neighbor, weight in graph[current_node].items(): distance = current_distance + weight # Only consider this new path if it\'s better if distance < shortest_distances[neighbor]: shortest_distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return shortest_distances"},{"question":"# Question: Implement a Simple Neural Network for Binary Classification from Scratch You are tasked with implementing a simple neural network from scratch to perform binary classification. The neural network should have one hidden layer with ReLU activation and an output layer with sigmoid activation. You need to implement the functions for forward propagation, backward propagation, and the training process. Step 1: Define the Neural Network Structure 1. **Function Signatures**: ```python def initialize_parameters(n_x: int, n_h: int, n_y: int) -> Dict[str, np.ndarray]: def forward_propagation(X: np.ndarray, parameters: Dict[str, np.ndarray]) -> Tuple[np.ndarray, Dict[str, np.ndarray]]: def compute_cost(A2: np.ndarray, Y: np.ndarray) -> float: def backward_propagation(parameters: Dict[str, np.ndarray], cache: Dict[str, np.ndarray], X: np.ndarray, Y: np.ndarray) -> Dict[str, np.ndarray]: def update_parameters(parameters: Dict[str, np.ndarray], grads: Dict[str, np.ndarray], learning_rate: float) -> Dict[str, np.ndarray]: def nn_model(X: np.ndarray, Y: np.ndarray, n_h: int, num_iterations: int, learning_rate: float) -> Dict[str, np.ndarray]: def predict(parameters: Dict[str, np.ndarray], X: np.ndarray) -> np.ndarray: ``` 2. **Inputs**: - `X`: Numpy array of shape (n_x, m) with the input data (where `n_x` is the number of features and `m` is the number of examples). - `Y`: Numpy array of shape (1, m) with the binary labels (0 or 1). - `n_h`: Integer, number of units in the hidden layer. - `num_iterations`: Integer, the number of iterations for training. - `learning_rate`: Float, the learning rate for gradient descent. 3. **Outputs**: - `parameters`: Dictionary containing the learned parameters `W1`, `b1`, `W2`, and `b2`. Step 2: Implement Neural Network Functions - `initialize_parameters`: Initialize weights and biases. - `forward_propagation`: Implement forward propagation to calculate `Z1`, `A1`, `Z2`, and `A2`. - `compute_cost`: Compute the cross-entropy cost function. - `backward_propagation`: Implement the backpropagation to compute gradients. - `update_parameters`: Update parameters using gradient descent. - `nn_model`: Integrate the above functions to build and train the neural network. - `predict`: Predict the class labels for a given input dataset based on learned parameters. Step 3: Verification and Testing 1. Verify your implementation with a toy dataset. 2. Show the learned parameters and the cost function reduction over iterations. 3. Implement error handling to manage edge cases, such as incorrect input shapes or invalid parameter values. ```python # Example usage: np.random.seed(1) X_train = np.random.randn(2, 100) # Input features Y_train = (np.random.randn(1, 100) > 0).astype(int) # Binary labels parameters = nn_model(X_train, Y_train, n_h=4, num_iterations=10000, learning_rate=1.2) predictions = predict(parameters, X_train) accuracy = float((np.dot(Y_train, predictions.T) + np.dot(1-Y_train, 1-predictions.T)) / float(Y_train.size) * 100) print(f\'Accuracy: {accuracy}%\') ``` **Constraints**: - Do not use machine learning libraries like TensorFlow or PyTorch for neural network implementation. - Use numpy for all basic operations and matrix calculations.","solution":"import numpy as np from typing import Dict, Tuple def initialize_parameters(n_x: int, n_h: int, n_y: int) -> Dict[str, np.ndarray]: np.random.seed(1) W1 = np.random.randn(n_h, n_x) * 0.01 b1 = np.zeros((n_h, 1)) W2 = np.random.randn(n_y, n_h) * 0.01 b2 = np.zeros((n_y, 1)) parameters = {\\"W1\\": W1, \\"b1\\": b1, \\"W2\\": W2, \\"b2\\": b2} return parameters def forward_propagation(X: np.ndarray, parameters: Dict[str, np.ndarray]) -> Tuple[np.ndarray, Dict[str, np.ndarray]]: W1 = parameters[\\"W1\\"] b1 = parameters[\\"b1\\"] W2 = parameters[\\"W2\\"] b2 = parameters[\\"b2\\"] Z1 = np.dot(W1, X) + b1 A1 = np.maximum(0, Z1) # ReLU activation Z2 = np.dot(W2, A1) + b2 A2 = 1 / (1 + np.exp(-Z2)) # Sigmoid activation cache = {\\"Z1\\": Z1, \\"A1\\": A1, \\"Z2\\": Z2, \\"A2\\": A2} return A2, cache def compute_cost(A2: np.ndarray, Y: np.ndarray) -> float: m = Y.shape[1] cost = - np.sum(np.multiply(Y, np.log(A2)) + np.multiply(1 - Y, np.log(1 - A2))) / m cost = np.squeeze(cost) # Ensures cost is the dimension we expect (e.g., turns [[17]] into 17). return cost def backward_propagation(parameters: Dict[str, np.ndarray], cache: Dict[str, np.ndarray], X: np.ndarray, Y: np.ndarray) -> Dict[str, np.ndarray]: m = X.shape[1] W2 = parameters[\\"W2\\"] A1 = cache[\\"A1\\"] A2 = cache[\\"A2\\"] dZ2 = A2 - Y dW2 = np.dot(dZ2, A1.T) / m db2 = np.sum(dZ2, axis=1, keepdims=True) / m dA1 = np.dot(W2.T, dZ2) dZ1 = np.multiply(dA1, np.int64(A1 > 0)) dW1 = np.dot(dZ1, X.T) / m db1 = np.sum(dZ1, axis=1, keepdims=True) / m grads = {\\"dW1\\": dW1, \\"db1\\": db1, \\"dW2\\": dW2, \\"db2\\": db2} return grads def update_parameters(parameters: Dict[str, np.ndarray], grads: Dict[str, np.ndarray], learning_rate: float) -> Dict[str, np.ndarray]: W1 = parameters[\\"W1\\"] b1 = parameters[\\"b1\\"] W2 = parameters[\\"W2\\"] b2 = parameters[\\"b2\\"] W1 = W1 - learning_rate * grads[\\"dW1\\"] b1 = b1 - learning_rate * grads[\\"db1\\"] W2 = W2 - learning_rate * grads[\\"dW2\\"] b2 = b2 - learning_rate * grads[\\"db2\\"] parameters = {\\"W1\\": W1, \\"b1\\": b1, \\"W2\\": W2, \\"b2\\": b2} return parameters def nn_model(X: np.ndarray, Y: np.ndarray, n_h: int, num_iterations: int, learning_rate: float) -> Dict[str, np.ndarray]: n_x = X.shape[0] # number of input features n_y = Y.shape[0] # number of output classes (1 for binary classification) parameters = initialize_parameters(n_x, n_h, n_y) for i in range(num_iterations): A2, cache = forward_propagation(X, parameters) cost = compute_cost(A2, Y) grads = backward_propagation(parameters, cache, X, Y) parameters = update_parameters(parameters, grads, learning_rate) return parameters def predict(parameters: Dict[str, np.ndarray], X: np.ndarray) -> np.ndarray: A2, _ = forward_propagation(X, parameters) predictions = (A2 > 0.5) return predictions.astype(int)"},{"question":"# Question You are given a list of strings, where each string consists of digits and lowercase letters. Your task is to sort the list using a custom sorting function. The custom sorting function sorts first by the sum of the digits in each string (from the smallest to largest sum), and in case of a tie, by alphabetical order of the string. Function Signature ```python def custom_sort(strings: list[str]) -> list[str]: pass ``` # Input - `strings` (list of `str`): A list of strings made up of digits `0-9` and lowercase letters `a-z`. # Output - The function should return a new list of strings sorted according to the custom sorting criteria defined above. # Constraints - `1 <= len(strings) <= 1000` - `1 <= len(strings[i]) <= 100` for each string `strings[i]`. # Example ```python custom_sort([\\"abc123\\", \\"a1b2c3\\", \\"abc\\", \\"123\\", \\"def456\\"]) # Expected output: [\\"abc\\", \\"123\\", \\"a1b2c3\\", \\"abc123\\", \\"def456\\"] custom_sort([\\"0a\\", \\"00\\", \\"b0\\", \\"a\\"]) # Expected output: [\\"a\\", \\"0a\\", \\"b0\\", \\"00\\"] ``` # Additional Context 1. Extract the sum of digits from each string. For instance, the digit sum of \\"abc123\\" is `1 + 2 + 3 = 6`. 2. If two strings have the same digit sum, decide their order based on their lexicographical comparison. - To extract digits and compute their sum from a string, you can iterate through the string and sum up the integers. - Use the `sorted` function with a custom key to sort the list based on the defined criteria. Ensure to test your function with various cases, including cases where: - Strings have widely different digit sums. - Strings have the same digit sum but different alphabetical order. - Strings contain no digits or all characters are digits. Testing edge cases, where strings may be minimal or maximal length defined by constraints, is crucial for validating the implementation. # Implementation Notes ```python def custom_sort(strings: list[str]) -> list[str]: def sorting_key(s): digit_sum = sum(int(char) for char in s if char.isdigit()) return (digit_sum, s) return sorted(strings, key=sorting_key) # Example Usage print(custom_sort([\\"abc123\\", \\"a1b2c3\\", \\"abc\\", \\"123\\", \\"def456\\"])) # Expected output: [\\"abc\\", \\"123\\", \\"a1b2c3\\", \\"abc123\\", \\"def456\\"] print(custom_sort([\\"0a\\", \\"00\\", \\"b0\\", \\"a\\"])) # Expected output: [\\"a\\", \\"0a\\", \\"b0\\", \\"00\\"] ```","solution":"def custom_sort(strings: list[str]) -> list[str]: def sorting_key(s): digit_sum = sum(int(char) for char in s if char.isdigit()) return (digit_sum, s) return sorted(strings, key=sorting_key)"},{"question":"# Question Write a function that determines if a given string contains all unique characters. Consider only the alphanumeric characters and ignore case differences. The whitespace characters should also be ignored in determining the uniqueness of characters. **Function Signature:** ```python def has_all_unique_characters(s: str) -> bool: Check if the input string has all unique characters. Args: s (str): The input string. Returns: bool: True if all characters are unique, False otherwise. Examples: >>> has_all_unique_characters(\\"abcdef\\") True >>> has_all_unique_characters(\\"aabc\\") False >>> has_all_unique_characters(\\"123 mm\\") False >>> has_all_unique_characters(\\"123 4\\") True ``` **Input and Output Formats:** - **Input**: A single string `s`. - **Output**: Boolean `True` if all alphanumeric characters are unique, otherwise `False`. **Constraints:** 1. Input string may contain alphanumeric characters, spaces, and punctuation. 2. Case should be ignored (i.e., `A` and `a` are considered the same). **Performance Requirements**: Ensure your solution runs in linear time O(n), where n is the length of the input string. **Scenario/Context**: Checking for uniqueness of characters in strings is a common task in various applications like password validation, data analysis, and more. This problem tests the ability to correctly process and ignore certain characters, as well as efficiently check for uniqueness.","solution":"def has_all_unique_characters(s: str) -> bool: Check if the input string has all unique alphanumeric characters. Args: s (str): The input string. Returns: bool: True if all alphanumeric characters are unique, False otherwise. Examples: >>> has_all_unique_characters(\\"abcdef\\") True >>> has_all_unique_characters(\\"aabc\\") False >>> has_all_unique_characters(\\"123 mm\\") False >>> has_all_unique_characters(\\"123 4\\") True # Create a set to store unique characters unique_chars = set() # Iterate through each character in the string for char in s: # Check if the character is alphanumeric if char.isalnum(): # Convert to lower case to ignore case differences char = char.lower() # If the character is already in the set, return False if char in unique_chars: return False # Add the character to the set unique_chars.add(char) # If no duplicates were found, return True return True"},{"question":"**Problem Statement:** You are given a matrix representing the heights of plants on a grid, and your task is to find the longest increasing path. Each cell contains a plant height, and you can move in four possible directions: up, down, left, or right, but you can only move to a cell with a greater plant height than the current one. # Function Signature ```python def longest_increasing_path(matrix: list[list[int]]) -> int: pass ``` # Input * A 2D list `matrix` of size `n x m` (0 <= n, m <= 200), where each element is an integer within the range [0, 10^9]. # Output * An integer that represents the length of the longest increasing path. # Constraints * Your solution should have a time complexity that scales well with the input size. * Handle edge cases such as empty matrices and matrices with all identical elements. # Example ```python matrix = [ [9, 9, 4], [6, 6, 8], [2, 1, 1] ] print(longest_increasing_path(matrix)) # Output should be 4 (1 -> 2 -> 6 -> 9) matrix = [ [3, 4, 5], [3, 2, 6], [2, 2, 1] ] print(longest_increasing_path(matrix)) # Output should be 4 (3 -> 4 -> 5 -> 6) ``` # Requirements * Implement an algorithm to find the longest increasing path in the matrix. * Consider using memoization or dynamic programming to avoid redundant calculations. # Notes * You may use helper functions if necessary. * Ensure your code handles edge cases efficiently, such as when the matrix is empty or when all elements are the same. * Avoid excessive use of additional memory.","solution":"def longest_increasing_path(matrix): if not matrix or not matrix[0]: return 0 n, m = len(matrix), len(matrix[0]) memo = [[-1] * m for _ in range(n)] def dfs(x, y): if memo[x][y] != -1: return memo[x][y] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and matrix[nx][ny] > matrix[x][y]: max_length = max(max_length, 1 + dfs(nx, ny)) memo[x][y] = max_length return max_length longest_path = 0 for i in range(n): for j in range(m): longest_path = max(longest_path, dfs(i, j)) return longest_path"},{"question":"# Coding Assessment Question: Context: You are developing a data analysis tool for a shipping company. The tool is used to keep track of shipments, ensuring goods are delivered promptly and efficiently. One core functionality required is to process textual logs of shipment events, extract useful data, and provide summary information. The current challenge involves parsing the logs and identifying delays in shipments based on the timestamps of events. Task: Implement a function named `process_shipment_logs` that follows these steps: 1. Parse a list of shipment log entries. 2. Identify shipments that have experienced delays. 3. Calculate and return the total number of delayed shipments and the average delay time. Each log entry is a string containing a shipment ID, event type (either \\"departed\\" or \\"arrived\\"), and a timestamp in the format \'YYYY-MM-DD HH:MM\'. An example log entry is `\\"SHIP1234 departed 2023-08-01 14:30\\"`. A shipment is considered delayed if the time difference between its \\"departed\\" and \\"arrived\\" events exceeds the company\'s threshold of 72 hours. Requirements: 1. Use `datetime` module to handle and compare timestamps. 2. Implement the function with appropriate error handling for malformed log entries. 3. Ensure efficient processing of the logs and avoid unnecessary computations. Expected Input and Output: **Input**: - `logs` (List of Strings): List of shipment log entries. **Output**: - Tuple: Total number of delayed shipments (Integer) and average delay time in hours (Float), rounded to 2 decimal places. Constraints: - Assume each shipment will have exactly one \\"departed\\" and one \\"arrived\\" log entry. - The log entries list can contain up to 10,000 entries. - Entries are not necessarily in chronological order. Example: ```python # Example shipment logs logs = [ \\"SHIP1234 departed 2023-08-01 14:30\\", \\"SHIP1234 arrived 2023-08-04 16:35\\", \\"SHIP5678 departed 2023-08-01 12:00\\", \\"SHIP5678 arrived 2023-08-04 11:00\\" ] # Expected function call print(process_shipment_logs(logs)) # Example Output # (1, 76.08) ``` Implementation Notes: - Use a dictionary to store the timestamps of each shipment\'s \\"departed\\" and \\"arrived\\" events. - Calculate the delay time for each shipment and check if it exceeds the threshold. - Keep track of both the number of delayed shipments and the total delay time for calculating the average. ```python from datetime import datetime def process_shipment_logs(logs): shipment_data = {} delayed_shipments = 0 total_delay_time = 0.0 delay_threshold = 72.0 # in hours for log in logs: try: parts = log.split() shipment_id = parts[0] event_type = parts[1] timestamp = datetime.strptime(\' \'.join(parts[2:]), \'%Y-%m-%d %H:%M\') if shipment_id not in shipment_data: shipment_data[shipment_id] = {} shipment_data[shipment_id][event_type] = timestamp except (ValueError, IndexError) as e: print(f\\"Malformed log entry: {log}, Error: {e}\\") continue for shipment_id, events in shipment_data.items(): if \'departed\' in events and \'arrived\' in events: time_difference = (events[\'arrived\'] - events[\'departed\']).total_seconds() / 3600 if time_difference > delay_threshold: delayed_shipments += 1 total_delay_time += time_difference average_delay = total_delay_time / delayed_shipments if delayed_shipments > 0 else 0.0 return (delayed_shipments, round(average_delay, 2)) ```","solution":"from datetime import datetime def process_shipment_logs(logs): shipment_data = {} delayed_shipments = 0 total_delay_time = 0.0 delay_threshold = 72.0 # in hours for log in logs: try: parts = log.split() shipment_id = parts[0] event_type = parts[1] timestamp = datetime.strptime(\' \'.join(parts[2:]), \'%Y-%m-%d %H:%M\') if shipment_id not in shipment_data: shipment_data[shipment_id] = {} shipment_data[shipment_id][event_type] = timestamp except (ValueError, IndexError) as e: continue for shipment_id, events in shipment_data.items(): if \'departed\' in events and \'arrived\' in events: time_difference = (events[\'arrived\'] - events[\'departed\']).total_seconds() / 3600 if time_difference > delay_threshold: delayed_shipments += 1 total_delay_time += time_difference average_delay = total_delay_time / delayed_shipments if delayed_shipments > 0 else 0.0 return (delayed_shipments, round(average_delay, 2))"},{"question":"# Coding Question: Daily Stock Average Price Calculation You are required to write a Python function that calculates the average daily stock price from historical stock price data fetched from a public API. The Alpha Vantage API allows querying historical stock price data given a company\'s symbol. # Function: `calculate_daily_average` Input: A `symbol` (string) representing the company\'s stock ticker symbol. Output: A dictionary containing the average opening, closing, highest, and lowest prices for the given stock symbol, or an error message if the symbol is invalid or the request fails: ```python { \\"Symbol\\": str, \\"Average Opening Price\\": float, \\"Average Closing Price\\": float, \\"Average High\\": float, \\"Average Low\\": float, } ``` Constraints: 1. The `symbol` will be a valid stock ticker string. 2. Ensure proper handling of Alpha Vantage API\'s rate-limiting and network errors. 3. Optimize for minimal API calls. 4. Use your API key and the actual endpoint: `https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol={symbol}&apikey={apikey}` Note: - You need to sign up for an API key from Alpha Vantage. - If any field is missing or data is not available, the function should handle it gracefully and return relevant error messages. - Each price should be calculated as the simple average of available daily prices over a set period. # Example: ```python def calculate_daily_average(symbol: str) -> dict: # Implement the function here pass # Running the function with specific stock symbol should give results like: print(calculate_daily_average(\\"AAPL\\")) # Expected Output { \\"Symbol\\": \\"AAPL\\", \\"Average Opening Price\\": 135.67, \\"Average Closing Price\\": 135.12, \\"Average High\\": 137.45, \\"Average Low\\": 133.21, } ``` Use the above analysis and code snippets as a guide to develop the solution to the task.","solution":"import requests def calculate_daily_average(symbol: str) -> dict: API_KEY = \\"YOUR_API_KEY\\" # You need to provide your own API Key url = f\\"https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol={symbol}&apikey={API_KEY}\\" try: response = requests.get(url) response.raise_for_status() data = response.json() if \\"Time Series (Daily)\\" not in data: return {\\"Error\\": \\"Invalid data format or symbol\\"} timeseries = data[\\"Time Series (Daily)\\"] open_prices = [] close_prices = [] high_prices = [] low_prices = [] for date, prices in timeseries.items(): open_prices.append(float(prices[\\"1. open\\"])) close_prices.append(float(prices[\\"4. close\\"])) high_prices.append(float(prices[\\"2. high\\"])) low_prices.append(float(prices[\\"3. low\\"])) avg_opening = sum(open_prices) / len(open_prices) avg_closing = sum(close_prices) / len(close_prices) avg_high = sum(high_prices) / len(high_prices) avg_low = sum(low_prices) / len(low_prices) return { \\"Symbol\\": symbol, \\"Average Opening Price\\": avg_opening, \\"Average Closing Price\\": avg_closing, \\"Average High\\": avg_high, \\"Average Low\\": avg_low, } except requests.RequestException as e: return {\\"Error\\": \\"Network error\\"} except ValueError as e: return {\\"Error\\": \\"Error processing data\\"}"},{"question":"**Scenario**: You have been tasked with developing a feature for an online analytics dashboard. A common operation involves calculating the \\"rolling\\" or \\"moving\\" average of user statistics (such as daily active users) over a specified period of days. Efficient calculation and updating of this statistic is essential for seamless dashboard performance. **Question**: Write a function `rolling_average(data, window_size)` that takes a list `data` of integers representing daily user statistics and an integer `window_size` representing the number of days for the rolling average. The function should return a list of floating-point numbers where each number is the average of the corresponding window of days. If the window size is larger than the number of days in the data, return an empty list. Implement the function based on the following information: * **Input Format**: * A list `data` of integers where the length of the list is at least 1. Each element represents the number of users on a particular day. * An integer `window_size` representing the number of days over which the average is computed. * **Output Format**: * A list of floating-point numbers representing the rolling average calculated for each valid window. **Constraints**: * The length of the input list, n, is such that `1 <= n <= 10^5` * The window size, k, is such that `1 <= k <= n` * Each element in the input list is a non-negative integer and at most `10^6`. **Examples**: ```python def rolling_average(data, window_size): # Implementation goes here # Example Usage data = [10, 20, 30, 40, 50, 60, 70] window_size = 3 print(rolling_average(data, window_size)) # Output: # [20.0, 30.0, 40.0, 50.0, 60.0] data = [1, 2, 3, 4, 5] window_size = 2 print(rolling_average(data, window_size)) # Output: # [1.5, 2.5, 3.5, 4.5] data = [100] window_size = 1 print(rolling_average(data, window_size)) # Output: # [100.0] data = [100] window_size = 2 print(rolling_average(data, window_size)) # Output: # [] ``` **Explanation**: In the given examples, the input `data` represents user statistics over a series of days, and `window_size` specifies the number of days to include in each average calculation. The function should calculate and return a list where each element is the average of the corresponding window of days. For instance, with `data = [10, 20, 30, 40, 50, 60, 70]` and `window_size = 3`, the rolling average is calculated as follows: * The first window (10, 20, 30) averages to 20.0 * The second window (20, 30, 40) averages to 30.0 * The third window (30, 40, 50) averages to 40.0 * and so on. Each resulting value is a floating-point number representing the rolling average for that window of days.","solution":"def rolling_average(data, window_size): Calculates and returns the rolling average of the input list of integers. Parameters: data (list of int): List of daily user statistics. window_size (int): Number of days over which to calculate the average. Returns: list of float: List of rolling averages for the valid windows. n = len(data) if window_size > n: return [] result = [] window_sum = sum(data[:window_size]) result.append(window_sum / window_size) for i in range(window_size, n): window_sum += data[i] - data[i - window_size] result.append(window_sum / window_size) return result"},{"question":"# Problem Statement Given a list of non-negative integers representing the amount of rainwater trapped between bars of varying heights, implement a function to calculate the total volume of trapped rainwater using the two-pointer technique. The heights of the bars are given in a list where the width of each bar is 1 unit. # Function Signature ```python def trap_rainwater(heights: list[int]) -> int: ``` # Input 1. `heights` (list of int): A list of non-negative integers representing the height of bars. # Output * `int`: The total amount of trapped rainwater. # Constraints * The list can contain up to (10^6) elements. * The height of each bar will be between 0 and (10^4). # Requirements * Your solution should have a time complexity of (O(N)), where (N) is the number of elements in the list. * The space complexity should be (O(1)), excluding the input and output. # Example ```python assert trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 assert trap_rainwater([4, 2, 0, 3, 2, 5]) == 9 assert trap_rainwater([1, 1, 1, 1, 1]) == 0 assert trap_rainwater([]) == 0 assert trap_rainwater([5, 4, 3, 2, 1]) == 0 ``` # Hints * Utilize two pointers, one starting from the beginning and the other from the end of the list. * Keep track of the maximum height encountered from the left and right. * Calculate trapped water by considering the current height and the smaller of the two maximum heights at each step. * Efficiently process the list to meet the large input constraints.","solution":"def trap_rainwater(heights: list[int]) -> int: if not heights: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] trapped_water = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) trapped_water += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) trapped_water += max(0, right_max - heights[right]) return trapped_water"},{"question":"# Problem Statement: Implement a function to determine if a given directed graph contains a cycle. A cycle in a directed graph is a sequence of edges that starts and ends at the same vertex with all other vertices distinct. Function Signature: ```python def detect_cycle_in_directed_graph(n: int, edges: List[Tuple[int, int]]) -> bool: pass ``` Expected Input: * `n`: An integer ( 1 leq n leq 10^4 ), representing the number of vertices. * `edges`: A list of tuples where each tuple (u, v) represents a directed edge from vertex u to vertex v. There can be up to ( 10^5 ) edges. Expected Output: * `True` if the graph contains a cycle, `False` otherwise. Constraints: * Vertices are numbered from 1 to n. * Self-loops and multiple edges between the same pair of vertices are allowed. * Implement an algorithm to efficiently detect cycles in the graph. Examples: ```python detect_cycle_in_directed_graph(4, [(1, 2), (2, 3), (3, 4), (4, 2)]) # should return True (cycle exists: 2 -> 3 -> 4 -> 2) detect_cycle_in_directed_graph(3, [(1, 2), (2, 3)]) # should return False (no cycle) detect_cycle_in_directed_graph(5, [(1, 2), (2, 3), (3, 1), (4, 5)]) # should return True (cycle exists: 1 -> 2 -> 3 -> 1) ``` # Additional Information: * You can use depth-first search (DFS) or Kahn\'s algorithm (topological sort) to detect cycles in the directed graph. * Make sure your implementation efficiently handles graphs with the maximum constraint limits.","solution":"from typing import List, Tuple def detect_cycle_in_directed_graph(n: int, edges: List[Tuple[int, int]]) -> bool: from collections import defaultdict, deque # Create adjacency list graph = defaultdict(list) in_degree = {i: 0 for i in range(1, n+1)} for u, v in edges: graph[u].append(v) in_degree[v] += 1 # Queue for all nodes with no incoming edge queue = deque([node for node in in_degree if in_degree[node] == 0]) visited_count = 0 while queue: node = queue.popleft() visited_count += 1 for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If visited all nodes, no cycle; otherwise, there\'s a cycle return visited_count != n"},{"question":"# Problem Statement You are tasked with designing a seating arrangement for a round table conference. The seating must follow specific rules so that no two attendees who dislike each other are seated next to each other. Implement a function `seating_arrangement` that arranges the attendees and returns the arrangement if possible, or an empty list if no valid arrangement exists. # Function Signature ```python def seating_arrangement(attendees: list, dislikes: list) -> list: ``` # Parameters: - `attendees` (list): A list of names of the attendees represented as strings. - `dislikes` (list): A list of pairs (tuples) where each pair consists of two names (strings) who dislike each other. # Returns: - A list of strings representing the seating arrangement in order around the round table if a valid arrangement exists. If no arrangement is possible, it should return an empty list. # Constraints: - Each attendee’s name is unique. - Names in the dislikes list always belong to the attendees list. - If there are multiple valid arrangements, return any one of them. # Example ```python # Example 1 attendees = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"Diana\\"] dislikes = [(\\"Alice\\", \\"Bob\\"), (\\"Charlie\\", \\"Diana\\")] print(seating_arrangement(attendees, dislikes)) # Output: A valid seating arrangement. e.g., [\\"Alice\\", \\"Charlie\\", \\"Bob\\", \\"Diana\\"] # Example 2 attendees = [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] dislikes = [(\\"Alice\\", \\"Charlie\\"), (\\"Alice\\", \\"Bob\\")] print(seating_arrangement(attendees, dislikes)) # Output: [] # Example 3 attendees = [\\"Eve\\", \\"Fin\\", \\"Grace\\", \\"Heidi\\"] dislikes = [(\\"Eve\\", \\"Fin\\"), (\\"Grace\\", \\"Heidi\\")] print(seating_arrangement(attendees, dislikes)) # Output: A valid seating arrangement. e.g., [\\"Eve\\", \\"Grace\\", \\"Fin\\", \\"Heidi\\"] ``` Notes: - Assume that there are no duplicate entries in the dislikes list. - The round table means the first and last attendees in the list are considered next to each other. - The function must handle an empty dislikes list by returning any arrangement of the attendees. - This problem can potentially be solved using backtracking or graph-based approaches. Ensure that your implementation is efficient enough for a reasonable number of attendees (up to 10).","solution":"def seating_arrangement(attendees, dislikes): from itertools import permutations def is_valid(arrangement): for i in range(len(arrangement)): if (arrangement[i], arrangement[i-1]) in dislikes or (arrangement[i-1], arrangement[i]) in dislikes: return False return True for arrangement in permutations(attendees): if is_valid(arrangement): return list(arrangement) return [] # Example usage # attendees = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"Diana\\"] # dislikes = [(\\"Alice\\", \\"Bob\\"), (\\"Charlie\\", \\"Diana\\")] # print(seating_arrangement(attendees, dislikes)) # Output: A valid seating arrangement"},{"question":"# Problem Scenario You have been hired as a developer for a financial technology firm that analyzes market trends. One of the tasks is to assess stock price trends over a period. You need to identify significant increases in stock prices over consecutive days. # Problem Statement Write a function `max_stock_price_increase(prices: List[float]) -> float` that determines the maximum percentage increase between any two consecutive days in the list of stock prices. # Input * `prices` (2 ≤ `len(prices)` ≤ (10^5)) - A list of stock prices in chronological order where each price is a positive float. # Output * `float` - The maximum percentage increase between two consecutive days, rounded to two decimal places. # Example ```python assert max_stock_price_increase([5.0, 10.0, 5.5, 11.0]) == 100.0 assert max_stock_price_increase([8.0, 8.1, 8.3, 8.7, 9.0]) == 4.82 ``` # Constraints * Ensure the function can handle up to (10^5) entries efficiently. * Round the final result to two decimal places. * Take into account that the stock price does not necessarily increase every day. # Function Signature ```python from typing import List def max_stock_price_increase(prices: List[float]) -> float: pass ```","solution":"from typing import List def max_stock_price_increase(prices: List[float]) -> float: Determines the maximum percentage increase between any two consecutive days in the list of stock prices. max_increase = 0.0 for i in range(1, len(prices)): increase = (prices[i] - prices[i-1]) / prices[i-1] * 100 if increase > max_increase: max_increase = increase return round(max_increase, 2)"},{"question":"# Problem Scenario You are tasked with developing a file summarization feature for a large data processing system. The feature should take in a text file and return the most frequently occurring word along with its frequency. The function must ignore case and punctuation, and it should handle large files efficiently. # Task Implement the `most_frequent_word` function in Python that reads a text file and returns the most frequently occurring word and its frequency. # Function Signature ```python def most_frequent_word(file_path: str) -> tuple: ... ``` # Constraints * The text file will contain at least one word. * Words are sequences of characters separated by whitespace or punctuation. * The file size will not exceed 100MB. * Ignore case and punctuation for the purpose of counting word frequency. # Input * `file_path` (str): The path to the text file to be processed. # Output * A tuple containing the most frequently occurring word (str) and its frequency (int). # Example Given a file `sample.txt` with the following content: ``` Hello, world! Hello. Who\'s there? Hello!!! Is anybody there? ``` ```python print(most_frequent_word(\'sample.txt\')) # Output: (\'hello\', 3) ``` # Note * Ensure input validation is performed to catch and handle invalid input scenarios (e.g., file not found). * Optimize the performance to handle large files efficiently by using appropriate data structures and algorithms.","solution":"import re from collections import Counter def most_frequent_word(file_path: str) -> tuple: Reads a text file and returns the most frequently occurring word and its frequency. Parameters: file_path (str): The path to the text file to be processed. Returns: tuple: A tuple containing the most frequently occurring word (str) and its frequency (int). try: with open(file_path, \'r\', encoding=\'utf-8\') as file: text = file.read().lower() # Read and convert to lower case words = re.findall(r\'bw+b\', text) # Extract words using regex word_count = Counter(words) most_common_word, frequency = word_count.most_common(1)[0] return most_common_word, frequency except FileNotFoundError: raise Exception(f\\"The file at {file_path} does not exist.\\") except Exception as e: raise Exception(f\\"An error occurred while processing the file: {str(e)}\\")"},{"question":"# Problem Statement You are given an array of integers that represents the heights of buildings in a row, with the heights given from left to right. Your task is to find the maximum area of water that can be contained between two buildings. The width of each building is considered to be 1 unit. Write a function `max_area_of_water(heights: List[int]) -> int` which: - **Input**: * `heights`: a list of integers representing the heights of the buildings. For example, `[1, 8, 6, 2, 5, 4, 8, 3, 7]`. - **Output**: * Return an integer representing the maximum area of water that can be contained between two buildings. **Constraints**: - `1 <= len(heights) <= 10^4` - `0 <= heights[i] <= 10^4` **Example**: ```python heights = [1, 8, 6, 2, 5, 4, 8, 3, 7] assert max_area_of_water(heights) == 49 ``` **Explanation**: - The maximum area is obtained between the buildings with heights `8` and `7`, and the width between them is `7-1=6`. Hence, the area is `min(8, 7) * 6 = 49`. **Scenarios**: - For a minimal array with `len(heights) = 1`, the maximum area is `0` since there is just one building. - For an array where all heights are `0`, the maximum area is `0` as no water can be contained. Ensure to implement an optimal solution that minimizes time complexity, such as using a two-pointer approach to solve the problem efficiently.","solution":"from typing import List def max_area_of_water(heights: List[int]) -> int: Returns the maximum area of water that can be contained between two buildings. :param heights: List of integers representing the heights of buildings. :return: The maximum area of water that can be contained. left = 0 right = len(heights) - 1 max_area = 0 while left < right: height = min(heights[left], heights[right]) width = right - left max_area = max(max_area, height * width) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"Matrix Transposition Challenge # Scenario You are tasked with developing a tool to facilitate data analysis on matrix operations. One fundamental operation is the transposition of a matrix. Given a matrix, your function should return its transpose. The transpose of a matrix is obtained by swapping the rows with columns. # Task Write a function `transpose_matrix` that: 1. Takes a 2D list `matrix` representing the matrix to be transposed. 2. Returns the transposed matrix. # Function Signature ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: ``` # Input - `matrix` (List[List[int]]): A 2D list representing the original matrix where each list represents a row of the matrix. # Output - Returns the transposed matrix as a 2D list. # Constraints - The number of rows and columns in the matrix will be between 1 and 100. - Each element in the matrix will be an integer between `-10^9` and `10^9`. # Examples ```python # Example 1 matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Transposed matrix should be: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] assert transpose_matrix(matrix) == [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] # Example 2 matrix = [ [1, 2, 3], [4, 5, 6] ] # Transposed matrix should be: # [ # [1, 4], # [2, 5], # [3, 6] # ] assert transpose_matrix(matrix) == [ [1, 4], [2, 5], [3, 6] ] ``` # Note Ensure your implementation handles both square and rectangular matrices, returning the correct transpose each time.","solution":"def transpose_matrix(matrix): Transpose the given matrix. Args: matrix (List[List[int]]): The original matrix to be transposed. Returns: List[List[int]]: The transposed matrix. # Use list comprehension and zip to transpose the matrix transposed = [list(row) for row in zip(*matrix)] return transposed"},{"question":"# Context You are developing a module for a file management system that organizes files based on their last modified date. You\'ll create a function to categorize files into different folders named after the year and month of their modification date. This helps in tidying up directories and making it easier to locate files based on when they were last modified. # Task Implement the `organize_files(files: List[Tuple[str, str]]) -> Dict[str, List[str]]` function, where each file is represented by a tuple containing its name and modification date. The function should group files into folders labeled by year and month. # Input - `files`: A list of tuples, where each tuple contains: - `file_name` (a string) — the name of the file. - `modification_date` (a string) — the last modified date formatted as \\"YYYY-MM-DD\\". # Output - The function should return a dictionary where the keys are strings representing the folder names in \\"YYYY-MM\\" format, and the values are lists of file names that belong to each folder. # Constraints - The `file_name` is a string that consists of alphanumeric characters and may contain underscores and periods. - The `modification_date` is always provided in the \\"YYYY-MM-DD\\" format and is a valid date. - The list can contain up to 10,000 files. # Example ```python files = [ (\\"photo1.jpg\\", \\"2021-06-15\\"), (\\"document.pdf\\", \\"2021-06-20\\"), (\\"report.docx\\", \\"2020-12-23\\"), (\\"photo2.jpg\\", \\"2021-07-01\\") ] # Expected output: # { # \\"2021-06\\": [\\"photo1.jpg\\", \\"document.pdf\\"], # \\"2020-12\\": [\\"report.docx\\"], # \\"2021-07\\": [\\"photo2.jpg\\"] # } assert organize_files(files) == { \\"2021-06\\": [\\"photo1.jpg\\", \\"document.pdf\\"], \\"2020-12\\": [\\"report.docx\\"], \\"2021-07\\": [\\"photo2.jpg\\"] } ``` # Functional Requirements - Extract the year and month from the `modification_date`. - Group files based on the year and month of their modification date. - Return the organized dictionary with folder names as keys and lists of file names as values. # Edge Cases - An empty list of files should return an empty dictionary. - All files with the same modification date should be categorized under the same folder name. - Ensure the function handles different file names and dates correctly without crashing. # Optimization Considerations Since the list can be large, ensure that your implementation processes files efficiently and avoids unnecessary computations or memory usage.","solution":"from typing import List, Tuple, Dict from collections import defaultdict def organize_files(files: List[Tuple[str, str]]) -> Dict[str, List[str]]: Organizes files into folders labeled by year and month of their last modification date. Args: files (List[Tuple[str, str]]): List of tuples where each tuple contains: - file_name (str) — the name of the file. - modification_date (str) — the last modified date formatted as \\"YYYY-MM-DD\\". Returns: Dict[str, List[str]]: A dictionary where keys are folder names in \\"YYYY-MM\\" format, and values are lists of file names that belong to each folder. organized_files = defaultdict(list) for file_name, modification_date in files: # Extract year and month from modification_date folder_name = modification_date[:7] organized_files[folder_name].append(file_name) return dict(organized_files)"},{"question":"# Problem Statement: You need to design a function that simulates the operation of a basic calculator which can perform addition, subtraction, multiplication, and division. The calculator should handle expressions containing positive integers, the four basic operators, and parentheses to enforce operation precedence. You must implement functionalities to evaluate the given mathematical expression and return the correct result. # Function Signature: ```python def evaluate_expression(expression: str) -> float: pass ``` # Input: * `expression`: A string representing a mathematical expression (1 <= length(expression) <= 200). # Output: * Return the evaluated result of the expression as a float. If the result is an integer, convert it to float (e.g., 2 -> 2.0). # Constraints: * The input string will be a valid expression containing positive integers, operators (+, -, *, /), and parentheses. * Division by zero will not occur in the provided expressions. * The results will be within the range of a 64-bit float. * Ensure that the solution efficiently handles the expression within the given constraints. # Example: ```python assert evaluate_expression(\\"3 + 2\\") == 5.0 assert evaluate_expression(\\" 3-2 \\") == 1.0 assert evaluate_expression(\\"2*3/6\\") == 1.0 assert evaluate_expression(\\"(2 + 3) * 4\\") == 20.0 assert evaluate_expression(\\"2 + (3*(4-1))\\") == 11.0 ``` # Note: 1. Implement the evaluation from scratch considering proper precedence of operations and parentheses. 2. Avoid using Python\'s `eval` function or similar built-in capabilities to ensure the program adheres to the problem constraints and potential security requirements. 3. Handle edge cases such as spaces within the input string and ensure floating-point division.","solution":"def evaluate_expression(expression: str) -> float: Evaluate a mathematical expression and return the result as a float. def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': values.append(left / right) def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 def calculate(expression): i = 0 values = [] operators = [] while i < len(expression): if expression[i] == \' \': i += 1 continue if expression[i] == \'(\': operators.append(expression[i]) elif expression[i].isdigit(): val = 0 while (i < len(expression) and expression[i].isdigit()): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == \')\': while len(operators) != 0 and operators[-1] != \'(\': apply_operator(operators, values) operators.pop() else: while (len(operators) != 0 and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while len(operators) != 0: apply_operator(operators, values) return values[-1] result = calculate(expression) return float(result)"},{"question":"# Problem Description You are tasked with implementing a function that integrates the Composite Trapezoidal Rule for numerical integration, a method of estimating the definite integral of a function. Follow the guidelines below to build the required functionality. # Input and Output **Function Signature**: ```python def trapezoidal_rule(func: Callable[[float], float], start: float, end: float, n: int) -> float: pass ``` **Inputs**: * `func` (Callable): The function to integrate, expressed as ( f(x) ). * `start` (float): The starting value of the interval over which to integrate. * `end` (float): The ending value of the interval over which to integrate. * `n` (int): The number of equally spaced subintervals to use for the trapezoidal rule. Must be at least 1. **Output**: * Returns a float which is the estimated value of the definite integral of ( f(x) ) over the interval [start, end]. # Constraints * `start` must be less than `end`. * `n` must be a positive integer greater than 0. * The function ( f(x) ) provided may have varying degrees of complexity, but it will be continuous on the interval [start, end]. # Example ```python def f(x): return x**2 start = 0 end = 1 n = 4 result = trapezoidal_rule(f, start, end, n) print(result) # Output should be approximately 0.34375 ``` # Task Implement the `trapezoidal_rule` method utilizing the composite trapezoidal rule formula to estimate the integral, ensuring validation of inputs and proper handling of potential edge cases.","solution":"from typing import Callable def trapezoidal_rule(func: Callable[[float], float], start: float, end: float, n: int) -> float: Estimates the definite integral of a function using the composite trapezoidal rule. :param func: Callable, the function to integrate, expressed as f(x) :param start: float, the starting value of the interval over which to integrate :param end: float, the ending value of the interval over which to integrate :param n: int, the number of equally spaced subintervals to use for the trapezoidal rule :return: float, the estimated value of the definite integral of f(x) over the interval [start, end] # Validate inputs if start >= end: raise ValueError(\\"The start of the interval must be less than the end.\\") if n <= 0: raise ValueError(\\"The number of subintervals must be a positive integer.\\") # Compute the width of each subinterval h = (end - start) / n # Initialize the sum integral_sum = 0.5 * (func(start) + func(end)) # Sum up the area of each trapezoid for i in range(1, n): x_i = start + i * h integral_sum += func(x_i) # Multiply by the width to get the total integral integral_sum *= h return integral_sum"},{"question":"# Rotate Image Clockwise **Context**: You are developing an image manipulation library and need to implement a feature that rotates an image clockwise by 90 degrees. This feature will be used in various image editing tasks such as reorienting photographs taken in landscape or portrait mode. **Objective**: Write a function that takes a square image (where height and width are the same) represented as a 2D list of integers and rotates the image 90 degrees clockwise. **Function Signature**: ```python def rotate_image(image: List[List[int]]) -> List[List[int]]: pass ``` **Input**: * `image`: A 2D list of integers representing a square image. Each entry in the list is a pixel value. **Output**: * A 2D list of integers representing the rotated image in the same shape as the input. **Constraints**: * The values of the pixels are integers in the range [0, 255]. * The dimensions of the image are at most 1000 x 1000 pixels. **Example**: ```python image = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] result = rotate_image(image) assert result == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` **Additional Notes**: * Ensure the rotation does not modify the input image. The function should return a new rotated image. * Consider performance optimizations for handling large images.","solution":"from typing import List def rotate_image(image: List[List[int]]) -> List[List[int]]: Rotates a square image (2D list of integers) 90 degrees clockwise. n = len(image) rotated_image = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_image[j][n - 1 - i] = image[i][j] return rotated_image"},{"question":"# Coding Question: Compute Running Averages Implement a class that computes running averages of integers appended to it. The class should support the following operations: 1. **Initialize the class**: - The class should be initialized with an empty list to store the numbers. 2. **Method 1: `append(value: int) -> None`** - **Input**: An integer value to be appended to the list. - **Output**: None (The method should simply add the value to the internal list). 3. **Method 2: `get_running_average() -> float`** - **Input**: No inputs. - **Output**: The current running average of the elements in the list as a float. - **Constraints**: If no elements have been added yet, this method should raise a `ValueError`. # Example ```python # Initializing the RunningAverage class ra = RunningAverage() # Appending values and computing running average ra.append(4) assert ra.get_running_average() == 4.0 # Average (4) ra.append(8) assert ra.get_running_average() == 6.0 # Average (4, 8) ra.append(6) assert ra.get_running_average() == 6.0 # Average (4, 8, 6) ra.append(2) assert ra.get_running_average() == 5.0 # Average (4, 8, 6, 2) ``` # Your implementation should handle these edge cases: * Trying to get the running average without any elements appended should raise a `ValueError`. * Appending a single element and getting the running average. * Appending and computing running averages for both negative and positive values.","solution":"class RunningAverage: def __init__(self): self.numbers = [] def append(self, value: int) -> None: self.numbers.append(value) def get_running_average(self) -> float: if not self.numbers: raise ValueError(\\"No elements to average\\") return sum(self.numbers) / len(self.numbers)"},{"question":"# Weather Forecast API Interaction **Objective**: Implement a function to interact with a weather API, robustly handling potential errors and formatting the output in a user-friendly manner. **Scenario**: In a project where users seek to retrieve the weather forecast for a specific city, integrate with the OpenWeatherMap API to fetch the current weather. Ensure the solution is robust and handles common edge cases effectively. **Requirements**: - Define a function `fetch_weather(city: str, api_key: str) -> dict` that: - Takes a city name (string) and the OpenWeatherMap API key (string). - Returns a dictionary with two keys: `\\"success\\"` (boolean) and `\\"data\\"` (a dict with weather details on success or an error message on failure). - Handle empty city name by returning an empty dictionary. - Handle network errors or invalid API responses gracefully. - If the city is not found, return an appropriate message. **Function Signature**: ```python def fetch_weather(city: str, api_key: str) -> dict: pass ``` **Constraints**: - The API key provided is valid. - The input city name is a non-empty string of maximum length 100. **Examples**: 1. `fetch_weather(\\"London\\", \\"YOUR API KEY\\")` - Might return: ```python { \\"success\\": True, \\"data\\": { \\"temperature\\": 12.34, \\"description\\": \\"clear sky\\", \\"humidity\\": 80 } } ``` 2. `fetch_weather(\\"\\", \\"YOUR API KEY\\")` - Should return: ```python { \\"success\\": True, \\"data\\": {} } ``` 3. `fetch_weather(\\"UnknownCity\\", \\"YOUR API KEY\\")` - Should return: ```python { \\"success\\": False, \\"data\\": \\"City not found.\\" } ``` 4. On network failure: - Should return: ```python { \\"success\\": False, \\"data\\": \\"Network error occurred while fetching weather information.\\" } ``` This new question maintains the same format as the example question provided. It integrates a different yet related API (weather forecasting vs. GIF search), ensuring consistency in style, complexity, and scope.","solution":"import requests def fetch_weather(city: str, api_key: str) -> dict: Fetches the current weather for the given city using the OpenWeatherMap API. Parameters: city (str): The name of the city to fetch the weather for. api_key (str): The API key for authenticating with the OpenWeatherMap API. Returns: dict: A dictionary containing the success status and either weather data or an error message. base_url = \\"http://api.openweathermap.org/data/2.5/weather\\" if not city: return {\\"success\\": True, \\"data\\": {}} params = { \'q\': city, \'appid\': api_key, \'units\': \'metric\' } try: response = requests.get(base_url, params=params) response.raise_for_status() weather_data = response.json() if weather_data.get(\'cod\') == 200: data = { \'temperature\': weather_data[\'main\'][\'temp\'], \'description\': weather_data[\'weather\'][0][\'description\'], \'humidity\': weather_data[\'main\'][\'humidity\'] } return {\\"success\\": True, \\"data\\": data} else: return {\\"success\\": False, \\"data\\": \\"City not found.\\"} except requests.exceptions.RequestException: return {\\"success\\": False, \\"data\\": \\"Network error occurred while fetching weather information.\\"}"},{"question":"# Implement a Cache Simulator Write a class `CacheSimulator` to simulate a simple cache that follows the Least Recently Used (LRU) policy. Your class should implement a cache with a fixed size and handle insertion, access, and eviction of items based on the LRU policy. Requirements: 1. The `put` function should insert a key-value pair into the cache. - If the cache is full, it should evict the least recently used item before inserting the new item. 2. The `get` function should retrieve the value associated with a given key. - Each access should update the \\"recently used\\" status of the item. - If the key is not found, it should return `-1`. 3. Utilize a dictionary and a doubly linked list to maintain the cache items and their order of use. # Input and Output Formats: 1. **Input:** - `capacity` (int): The maximum number of items the cache can hold. - `commands` (list of tuples): A list of commands where each command is a tuple. The first element of the tuple is a command type as a string (`\'put\'` or `\'get\'`). For `\'put\'` commands, the second and third elements are the key and value respectively. For `\'get\'` commands, the second element is the key. 2. **Output:** - A list of results from executing the commands. Each result should correspond to a `\'get\'` command. For `\'put\'` commands, append `None` to the results. # Constraints: - ( text{capacity} leq 10^3 ) - ( text{number_of_commands} leq 10^4 ) - ( 0 leq text{key, value} leq 10^4 ) # Example Execution: ```python # Example capacity = 2 commands = [(\'put\', 1, 1), (\'put\', 2, 2), (\'get\', 1), (\'put\', 3, 3), (\'get\', 2), (\'put\', 4, 4), (\'get\', 1), (\'get\', 3), (\'get\', 4)] # Expected output [None, None, 1, None, -1, None, -1, 3, 4] ``` ```python class Node: def __init__(self, key, value): self.key = key self.value = value self.prev = None self.next = None class CacheSimulator: def __init__(self, capacity: int) -> None: Initialize the cache with a fixed capacity. Parameters: - capacity (int): Maximum number of items the cache can hold. self.capacity = capacity self.cache = {} self.head = Node(0, 0) # Dummy head self.tail = Node(0, 0) # Dummy tail self.head.next = self.tail self.tail.prev = self.head def _remove(self, node: Node) -> None: Remove an existing node from the linked list. prev_node = node.prev next_node = node.next prev_node.next = next_node next_node.prev = prev_node def _add(self, node: Node) -> None: Add a new node to the front (right after the dummy head). node.next = self.head.next node.prev = self.head self.head.next.prev = node self.head.next = node def get(self, key: int) -> int: Retrieve the value associated with the key. Update the access status. Parameters: - key (int): The key to be accessed. Returns: - int: The value if key exists, otherwise -1. if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: Insert a key-value pair into the cache. Evict if necessary. Parameters: - key (int): The key to be inserted. - value (int): The value of the key to be inserted. if key in self.cache: self._remove(self.cache[key]) node = Node(key, value) self._add(node) self.cache[key] = node if len(self.cache) > self.capacity: # Remove from the tail node_to_evict = self.tail.prev self._remove(node_to_evict) del self.cache[node_to_evict.key] def execute_commands(capacity: int, commands: list) -> list: cache = CacheSimulator(capacity) results = [] for command in commands: if command[0] == \'get\': result = cache.get(command[1]) results.append(result) elif command[0] == \'put\': cache.put(command[1], command[2]) results.append(None) return results if __name__ == \\"__main__\\": capacity = 2 commands = [(\'put\', 1, 1), (\'put\', 2, 2), (\'get\', 1), (\'put\', 3, 3), (\'get\', 2), (\'put\', 4, 4), (\'get\', 1), (\'get\', 3), (\'get\', 4)] results = execute_commands(capacity, commands) print(results) # Output: [None, None, 1, None, -1, None, -1, 3, 4] ```","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.prev = None self.next = None class CacheSimulator: def __init__(self, capacity: int) -> None: Initialize the cache with a fixed capacity. Parameters: - capacity (int): Maximum number of items the cache can hold. self.capacity = capacity self.cache = {} self.head = Node(0, 0) # Dummy head self.tail = Node(0, 0) # Dummy tail self.head.next = self.tail self.tail.prev = self.head def _remove(self, node: Node) -> None: Remove an existing node from the linked list. prev_node = node.prev next_node = node.next prev_node.next = next_node next_node.prev = prev_node def _add(self, node: Node) -> None: Add a new node to the front (right after the dummy head). node.next = self.head.next node.prev = self.head self.head.next.prev = node self.head.next = node def get(self, key: int) -> int: Retrieve the value associated with the key. Update the access status. Parameters: - key (int): The key to be accessed. Returns: - int: The value if key exists, otherwise -1. if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: Insert a key-value pair into the cache. Evict if necessary. Parameters: - key (int): The key to be inserted. - value (int): The value of the key to be inserted. if key in self.cache: self._remove(self.cache[key]) node = Node(key, value) self._add(node) self.cache[key] = node if len(self.cache) > self.capacity: # Remove from the tail node_to_evict = self.tail.prev self._remove(node_to_evict) del self.cache[node_to_evict.key] def execute_commands(capacity: int, commands: list) -> list: cache = CacheSimulator(capacity) results = [] for command in commands: if command[0] == \'get\': result = cache.get(command[1]) results.append(result) elif command[0] == \'put\': cache.put(command[1], command[2]) results.append(None) return results"},{"question":"# Question: You are tasked with building a simplified version of a data structure known as a Sparse Table, particularly useful for range minimum queries (RMQ). Your goal is to implement this data structure and ensure efficient query times. Class Signature: ```python class SparseTable: def __init__(self, data: List[int]) -> None: pass def query(self, left: int, right: int) -> int: pass ``` # Requirements: 1. Construct a Sparse Table from the given list of integers during initialization. 2. Implement the query method which should return the minimum value in the array between the indices `left` and `right` inclusive. 3. Efficiently handle edge cases such as: - `left` and `right` being the same. - Multiple queries with varying ranges. # Expected input and output formats: - **Input**: - `data`: List of integers representing the array [a1, a2, ..., an]. - `left`: An integer representing the starting index of the query (0-indexed). - `right`: An integer representing the ending index of the query (0-indexed). - **Output**: An integer representing the minimum value in the range `[left, right]`. # Constraints: - **Parameter Constraints**: - The length of the `data` list will be between `1` and `100,000`. - `left` and `right` will be within the bounds of the array. - **Performance Requirements**: - The preprocessing time should be `O(n log n)`. - Each query should be answered in `O(1)` time. # Sample Usage: ```python # Example initialization and query of the SparseTable st = SparseTable([1, 3, 2, 7, 9, 11]) assert st.query(1, 3) == 2 # range: [3, 2, 7] -> min is 2 assert st.query(0, 5) == 1 # range: [1, 3, 2, 7, 9, 11] -> min is 1 assert st.query(2, 2) == 2 # single element range: [2] -> min is 2 ``` # Additional Context: - Utilize an efficient algorithm to construct the Sparse Table, such as dynamic programming to fill the table based on overlapping subproblems. - Store precomputed minimum values of subranges in a structured manner to ensure constant time querying for any given range.","solution":"import math from typing import List class SparseTable: def __init__(self, data: List[int]) -> None: self.n = len(data) self.log = [0] * (self.n + 1) self.log[1] = 0 for i in range(2, self.n + 1): self.log[i] = self.log[i // 2] + 1 self.sparse_table = [ [0] * (self.log[self.n] + 1) for _ in range(self.n) ] for i in range(self.n): self.sparse_table[i][0] = data[i] j = 1 while (1 << j) <= self.n: i = 0 while (i + (1 << j) - 1) < self.n: self.sparse_table[i][j] = min( self.sparse_table[i][j - 1], self.sparse_table[i + (1 << (j - 1))][j - 1] ) i += 1 j += 1 def query(self, left: int, right: int) -> int: j = self.log[right - left + 1] return min( self.sparse_table[left][j], self.sparse_table[right - (1 << j) + 1][j] )"},{"question":"# Problem Statement Write a function `flatten_dictionary` that takes a nested dictionary and returns a flattened dictionary, where the keys are represented in a dot-separated hierarchy. # Requirements: 1. Implement a function `flatten_dictionary` that takes a dictionary `d` as input, which may contain nested dictionaries, and returns a flattened dictionary. 2. Each key in the returned dictionary should represent the path taken through the hierarchy of the input dictionary, separated by dots (\'.\'). 3. Handle edge cases where the input might be an empty dictionary, or contain nested dictionaries with empty dictionaries as values. # Input Format: 1. A dictionary `d` containing any number of nested dictionaries. # Output Format: 1. A single dictionary with flattened key-value pairs. # Constraints: 1. The provided dictionary can be nested up to several levels. 2. Keys in the input dictionaries are strings, and all values are either dictionaries or non-dictionary items. # Example: ```python >>> flatten_dictionary({\\"key\\": \\"value\\", \\"map\\": {\\"innerKey\\": \\"innerValue\\"}}) {\'key\': \'value\', \'map.innerKey\': \'innerValue\'} >>> flatten_dictionary({\\"a\\": \\"1\\", \\"b\\": {\\"c\\": \\"2\\", \\"d\\": {\\"e\\": \\"3\\", \\"f\\": \\"4\\"}}}) {\'a\': \'1\', \'b.c\': \'2\', \'b.d.e\': \'3\', \'b.d.f\': \'4\'} >>> flatten_dictionary({}) {} ``` Note: * Ensure your function handles various levels of nesting efficiently. * The function should also handle cases where nested dictionaries are empty, by omitting those paths in the flattened dictionary. # Function Signature: ```python def flatten_dictionary(d: dict) -> dict: pass ```","solution":"def flatten_dictionary(d, parent_key=\'\', sep=\'.\'): Flattens a nested dictionary. Parameters: - d: dict, the dictionary to flatten. - parent_key: str, the base key to prepend to all keys (for recursion). - sep: str, the separator between different levels of keys. Returns: - dict, the flattened dictionary. items = [] for k, v in d.items(): new_key = parent_key + sep + k if parent_key else k if isinstance(v, dict): items.extend(flatten_dictionary(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"# Objective Write a function to find the next greater element for each element of an array. # Problem Statement Given an array `nums` of size `n`, for each element in the array, find the next greater element. The next greater element for an element `x` is the first greater element that comes after `x` in the array. If it does not exist, return `-1` for this element. # Task Write a Python function `next_greater_elements(nums: List[int]) -> List[int]` that returns a list of integers where each element in the list represents the next greater element of the corresponding element in the input array. # Input - A list of integers `nums` (1 ≤ len(nums) ≤ 10^5), the array for which to find the next greater elements. # Output - A list of integers of the same length as `nums`, representing the next greater element for each element in `nums`. # Example ```python assert next_greater_elements([4, 5, 2, 10]) == [5, 10, 10, -1] assert next_greater_elements([3, 7, 1, 3, 6]) == [7, -1, 3, 6, -1] ``` # Constraints - Your implementation should handle large arrays efficiently. - Your solution should consider the constraint that the largest possible array size can go up to `10^5`. # Hints - Utilize a stack to keep track of the indices of the array elements whose next greater elements are yet to be found. - Process the array from right to left. # Performance Requirements - The solution must operate within a time complexity of O(n). - Memory usage should be reasonable and should support handling an array of up to `n = 100000` elements.","solution":"from typing import List def next_greater_elements(nums: List[int]) -> List[int]: Finds the next greater element for each element in the array. :param nums: List of integers. :return: List of integers where each element is the next greater element for the corresponding input element, or -1 if it does not exist. n = len(nums) result = [-1] * n stack = [] for i in range(n - 1, -1, -1): # Pop elements from the stack until we find the next greater element while stack and stack[-1] <= nums[i]: stack.pop() # If stack is not empty, the top element is the next greater element if stack: result[i] = stack[-1] # Push the current element onto the stack stack.append(nums[i]) return result"},{"question":"# Scenario As a software developer, you have been assigned to create a utility to format phone numbers. The goal is to ensure that the provided phone numbers are stored in a consistent format, as specified below. The user can input a phone number in various formats, and your task is to clean and reformat it to the standard format. # Phone Number Format The standard format should be: `(XXX) XXX-XXXX`, where `X` represents a digit. # Task Write a function: **format_phone_number**: - **Input**: * `phone_number` (str): the phone number input received as a string. - **Output**: * Returns a properly formatted phone number string according to the standard format. - **Constraints**: * The input string may contain digits, spaces, dashes, dots, parentheses, and may have variable lengths. * If the cleaned number does not contain exactly 10 digits, raise a `ValueError` with an appropriate error message. - **Example**: ```python format_phone_number(\\"123-456-7890\\") # Returns \\"(123) 456-7890\\" format_phone_number(\\"123 456 7890\\") # Returns \\"(123) 456-7890\\" format_phone_number(\\"(123).456-7890\\") # Returns \\"(123) 456-7890\\" ``` # Additional Notes - Ensure to handle invalid inputs and raise a `ValueError` with a message \\"Invalid phone number format\\" if the number of digits is not exactly 10 after cleaning. - Validate your solution with unit tests to cover typical scenarios and edge cases.","solution":"def format_phone_number(phone_number): Formats a phone number to the standard format (XXX) XXX-XXXX. Args: phone_number (str): The input phone number in various formats. Returns: str: Formatted phone number. Raises: ValueError: If the cleaned phone number does not contain exactly 10 digits. # Remove non-digit characters cleaned_number = \'\'.join(filter(str.isdigit, phone_number)) # Check if the cleaned number contains exactly 10 digits if len(cleaned_number) != 10: raise ValueError(\\"Invalid phone number format\\") # Format the phone number formatted_number = f\\"({cleaned_number[:3]}) {cleaned_number[3:6]}-{cleaned_number[6:]}\\" return formatted_number"},{"question":"# Reservoir Volume Calculation You are given a list of integers representing the elevations of water columns at different positions. A column with zero height represents a basin. You need to calculate the maximum volume of water that can be trapped between the columns after a rainfall. Task: Write a function `calculate_trapped_water(elevations: list[int]) -> int` that: - Accepts a list of integers representing the elevations of the columns. - Returns the maximum volume of water trapped between the columns. Inputs: - `elevations`: A list of integers where each integer is greater than or equal to zero. - `1 <= len(elevations) <= 10^4`: The number of columns. Output: - Return an integer representing the total volume of trapped water. Constraints: - Elevations are non-negative integers. Example Scenario: ```python elevations = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] # The water trapped between the columns is depicted as: # Column indices: 0 1 2 3 4 5 6 7 8 9 10 11 # Elevations: [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] # Water trapped: [0, 0, 1, 0, 1, 2, 1, 0, 0, 1, 0, 0] # Total Trapped Water: 6 units calculate_trapped_water(elevations) # should return 6 ``` Ensure to handle edge cases and test your implementation for correctness and efficiency.","solution":"def calculate_trapped_water(elevations: list[int]) -> int: Calculate the maximum volume of water that can be trapped. Args: - elevations (list[int]): A list of integers representing the elevations of the columns. Returns: - int: The maximum volume of water trapped between the columns. if not elevations: return 0 n = len(elevations) left_max = [0] * n right_max = [0] * n left_max[0] = elevations[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], elevations[i]) right_max[n - 1] = elevations[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], elevations[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - elevations[i] return trapped_water"},{"question":"# Problem Statement Write a function `remove_duplicates` that takes in a list of integers and returns a new list with duplicates removed. The elements in the new list should be in the same order as their first appearance in the original list. # Function Signature ```python def remove_duplicates(a: List[int]) -> List[int]: ``` # Input - `a`: A list of integers. # Output - Returns a new list of integers with duplicates removed. # Constraints - The length of the list is in the range `[0, 1000]`. - Each integer is in the range `[-1000, 1000]`. # Example ```python # Example 1 a = [1, 2, 2, 3, 4, 4, 5] print(remove_duplicates(a)) # Output: [1, 2, 3, 4, 5] # Example 2 a = [5, 5, 5, 5, 5] print(remove_duplicates(a)) # Output: [5] # Example 3 a = [1, 2, 3, 4, 5] print(remove_duplicates(a)) # Output: [1, 2, 3, 4, 5] # Example 4 a = [] print(remove_duplicates(a)) # Output: [] ``` # Detailed Description 1. **Algorithm to Remove Duplicates** - Utilize a set to track seen elements. - Use a list to store elements in the order they first appear in the original list. - Iterate through the list, and for each element, check if it is in the set. - If it is not in the set, append it to the result list and add it to the set. 2. **Edge Cases** - Handle an empty list by returning an empty list. - Ensure single element lists return the same single element. # Code Template ```python def remove_duplicates(a: List[int]) -> List[int]: seen = set() result = [] for number in a: if number not in seen: result.append(number) seen.add(number) return result ``` Ensure you test your implementation with the given examples and handle edge cases like empty lists and lists with all identical elements correctly.","solution":"from typing import List def remove_duplicates(a: List[int]) -> List[int]: Removes duplicates from the list while maintaining order of first appearance. Parameters: a (List[int]): A list of integers. Returns: List[int]: A new list of integers with duplicates removed in the same order as their first appearance. seen = set() result = [] for number in a: if number not in seen: result.append(number) seen.add(number) return result"},{"question":"# Problem Statement You are required to implement a function that determines if a given number is a power of two. The function should be efficient, handle edge cases gracefully, and perform necessary input validation. # Function Signature ```python def is_power_of_two(n: int) -> bool: Take in a non-negative integer, return True if it is a power of two, else return False. :param n: A non-negative integer :return: A boolean value indicating whether `n` is a power of two. Raise ValueError for negative integers. Raise TypeError for non-integer types. ``` # Input * A single parameter `n`, which is a non-negative integer. # Output * Return `True` if `n` is a power of two, otherwise `False`. # Constraints * `n` is guaranteed to be a non-negative integer in standard usage scenarios. * Type errors and negative values should be appropriately managed by raising `TypeError` and `ValueError`, respectively. # Performance Requirements * The function should efficiently determine if the number is a power of two without using loops. # Examples ```python assert is_power_of_two(1) == True assert is_power_of_two(2) == True assert is_power_of_two(3) == False assert is_power_of_two(4) == True assert is_power_of_two(5) == False assert is_power_of_two(16) == True assert is_power_of_two(218) == False assert is_power_of_two(256) == True assert is_power_of_two(0) == False ``` # Error Handling ```python try: is_power_of_two(-1) except ValueError as e: assert str(e) == \\"Input value must be a non-negative integer\\" try: is_power_of_two(0.5) except TypeError as e: assert str(e) == \\"Input value must be an int type\\" try: is_power_of_two(\\"16\\") except TypeError as e: assert str(e) == \\"Input value must be an int type\\" ``` # Implementation Notes To achieve the desired efficiency, consider using bitwise operations to determine if a number is a power of two. For example, you may find it useful to leverage properties of numbers in binary form, such as `(n & (n - 1)) == 0` which is true only for powers of two.","solution":"def is_power_of_two(n: int) -> bool: Take in a non-negative integer, return True if it is a power of two, else return False. :param n: A non-negative integer :return: A boolean value indicating whether `n` is a power of two. Raise ValueError for negative integers. Raise TypeError for non-integer types. if not isinstance(n, int): raise TypeError(\\"Input value must be an int type\\") if n < 0: raise ValueError(\\"Input value must be a non-negative integer\\") # 0 is not a power of two if n == 0: return False return (n & (n - 1)) == 0"},{"question":"# Question: Segment Tree for Range Sum Queries In this exercise, you will implement a segment tree to efficiently handle range sum queries and point updates on an array. This task involves building the segment tree from the input array, supporting update operations to modify the array elements, and executing sum range queries efficiently. Function Signature ```python class SegmentTree: def __init__(self, array: list[int]): Initializes the segment tree with the provided array. :param array: List of integers to build the segment tree from. pass def update(self, index: int, value: int): Updates the element at the given index to the given value. :param index: Index of the element to update. :param value: The new value to set at the specified index. pass def range_sum(self, left: int, right: int) -> int: Returns the sum of elements in the range [left, right]. :param left: Left boundary of the range (inclusive). :param right: Right boundary of the range (inclusive). :return: Sum of elements in the specified range. pass ``` Input - `array` (list of ints): The base array for building the segment tree. - `index` (int): Index to update in the `update` method. - `value` (int): New value to update at the specified index in the `update` method. - `left` (int): Starting index of the range in the `range_sum` method. - `right` (int): Ending index of the range in the `range_sum` method. Output - The `update` method does not return anything; it modifies the element at the specified index. - The `range_sum` method returns the sum of elements in the specified range. Constraints - The function should handle arrays of any non-negative length up to 100,000. - Updates and queries should be executed efficiently in logarithmic time relative to the size of the array. Example ```python # Initialize the segment tree arr = [1, 3, 5, 7, 9, 11] seg_tree = SegmentTree(arr) # Query the sum of range [1, 3] print(seg_tree.range_sum(1, 3)) # Output should be: 15 (3 + 5 + 7) # Update index 1 to 10 seg_tree.update(1, 10) # Query again after update print(seg_tree.range_sum(1, 3)) # Output should be: 22 (10 + 5 + 7) # Query the sum of range [0, 5] print(seg_tree.range_sum(0, 5)) # Output should be: 43 (1 + 10 + 5 + 7 + 9 + 11) # Update index 4 to 6 seg_tree.update(4, 6) # Query again after update print(seg_tree.range_sum(3, 5)) # Output should be: 24 (7 + 6 + 11) ``` Implement the `SegmentTree` class based on the above specifications, efficiently handling the initialization, updates, and range queries using the segment tree data structure.","solution":"class SegmentTree: def __init__(self, array): Initializes the segment tree with the provided array. :param array: List of integers to build the segment tree from. self.n = len(array) self.tree = [0] * (2 * self.n) # Build the segment tree self.build(array) def build(self, array): # Initialize the leaves of the segment tree for i in range(self.n): self.tree[self.n + i] = array[i] # Build the tree by calculating the parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, index, value): Updates the element at the given index to the given value. :param index: Index of the element to update. :param value: The new value to set at the specified index. # Set value at the position pos = index + self.n self.tree[pos] = value # Move up and update parents while pos > 1: pos //= 2 self.tree[pos] = self.tree[pos * 2] + self.tree[pos * 2 + 1] def range_sum(self, left, right): Returns the sum of elements in the range [left, right]. :param left: Left boundary of the range (inclusive). :param right: Right boundary of the range (inclusive). :return: Sum of elements in the specified range. # Adjust bounds to index the tree left += self.n right += self.n sum_result = 0 while left <= right: if left % 2 == 1: sum_result += self.tree[left] left += 1 if right % 2 == 0: sum_result += self.tree[right] right -= 1 left //= 2 right //= 2 return sum_result"},{"question":"# Scenario: As a software engineer, you are tasked with developing a booking system for a small classroom. The classroom can be booked for different time slots throughout the day for teaching sessions or meetings. Each booking has a title, starting time, ending time, and the name of the person making the booking. You need to implement a system to manage the bookings and ensure no overlapping bookings are allowed. # Task: Implement a class `BookingSystem` that allows adding new bookings, checking for conflicts, and retrieving the list of all bookings. Make sure to handle edge cases such as invalid time slots and overlapping bookings. # Instructions: 1. **Class Implementation**: - Implement the class `BookingSystem` with methods to add a booking, check for time conflicts, and get all bookings. 2. **Methods to Implement**: - `add_booking(title: str, start_time: str, end_time: str, person: str) -> bool` - Adds a new booking if there are no conflicts. Returns `True` if the booking was added successfully, and `False` otherwise. - `has_conflict(start_time: str, end_time: str) -> bool` - Checks if the given time slot conflicts with any existing bookings. Returns `True` if there is a conflict, and `False` otherwise. - `get_bookings() -> List[Tuple[str, str, str, str]]` - Returns a list of all bookings as tuples in the format `(title, start_time, end_time, person)`. 3. **Constraints**: - Time should be represented as a string in the format \\"HH:MM\\". - The `start_time` must be less than the `end_time`. - Bookings should not overlap in time. # Expected Methods: You need to implement the `BookingSystem` class with the following methods: - `add_booking(title: str, start_time: str, end_time: str, person: str) -> bool` - `has_conflict(start_time: str, end_time: str) -> bool` - `get_bookings() -> List[Tuple[str, str, str, str]]` # Example: ```python class BookingSystem: def __init__(self): self.bookings = [] def add_booking(self, title: str, start_time: str, end_time: str, person: str) -> bool: if self.has_conflict(start_time, end_time): return False self.bookings.append((title, start_time, end_time, person)) return True def has_conflict(self, start_time: str, end_time: str) -> bool: for booking in self.bookings: b_start, b_end = booking[1], booking[2] if not (end_time <= b_start or start_time >= b_end): return True return False def get_bookings(self) -> List[Tuple[str, str, str, str]]: return self.bookings # Example usage: # booking_system = BookingSystem() # booking_system.add_booking(\\"Math Class\\", \\"09:00\\", \\"10:00\\", \\"John Doe\\") # print(booking_system.get_bookings()) ``` # Additional Requirements: * Include appropriate error handling for invalid time formats and logical time errors (e.g., end time before start time). * Ensure the system is scalable and efficient in handling multiple bookings.","solution":"from typing import List, Tuple import datetime class BookingSystem: def __init__(self): self.bookings = [] def add_booking(self, title: str, start_time: str, end_time: str, person: str) -> bool: try: start_dt = datetime.datetime.strptime(start_time, \\"%H:%M\\") end_dt = datetime.datetime.strptime(end_time, \\"%H:%M\\") if start_dt >= end_dt: return False except ValueError: return False if self.has_conflict(start_time, end_time): return False self.bookings.append((title, start_time, end_time, person)) return True def has_conflict(self, start_time: str, end_time: str) -> bool: start_dt = datetime.datetime.strptime(start_time, \\"%H:%M\\") end_dt = datetime.datetime.strptime(end_time, \\"%H:%M\\") for booking in self.bookings: b_start = datetime.datetime.strptime(booking[1], \\"%H:%M\\") b_end = datetime.datetime.strptime(booking[2], \\"%H:%M\\") if not (end_dt <= b_start or start_dt >= b_end): return True return False def get_bookings(self) -> List[Tuple[str, str, str, str]]: return self.bookings"},{"question":"# Problem Statement **Scenario**: You are building a utility that plays a fundamental role in handling large datasets. The focus of this task is on efficiently searching through sorted data using a binary search algorithm. **Task**: Implement a function `find_position(nums: List[int], target: int) -> int` that searches for a target value in a sorted list of integers `nums`. The function should return the index of the target if it is present in the list. If the target is not found, return the index where it would be if it were inserted in order while maintaining the sorted order. **Function Signature**: ```python def find_position(nums: List[int], target: int) -> int ``` **Input**: - A sorted list of integers `nums`(`0 <= len(nums) <= 10^4`). The integers in the list are within the range `-10^6` to `10^6`. - An integer `target` within the range `-10^6` to `10^6`. **Output**: - An integer representing the index at which the target is found, or if not found, the index where it should be inserted to maintain sorting order. # Constraints: - `0 <= len(nums) <= 10^4` - `-10^6 <= nums[i], target <= 10^6` # Requirements: - Implement the binary search algorithm to ensure the solution is efficient in terms of time complexity. - Avoid using built-in search functions. Implement the search logic explicitly. # Performance: - The function should run in O(log n) time complexity due to the nature of binary search. # Example: ```python assert find_position([1, 3, 5, 6], 5) == 2 assert find_position([1, 3, 5, 6], 2) == 1 assert find_position([1, 3, 5, 6], 7) == 4 assert find_position([1, 3, 5, 6], 0) == 0 assert find_position([], 5) == 0 ``` **Note**: The function should properly handle edge cases such as empty lists and targets that are outside the range of the list values.","solution":"from typing import List def find_position(nums: List[int], target: int) -> int: Function to perform binary search to find target in sorted list nums. If target is not found, returns the index where it would be inserted in sorted order. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"**Question**: Infix to Postfix Conversion using Stack You are tasked with implementing a function that converts an infix expression to its corresponding postfix expression using the Shunting Yard algorithm. # Problem Statement Given a mathematical expression in infix notation consisting of single-digit operands and the operators `+`, `-`, `*`, `/` (without parentheses), convert it to its equivalent postfix notation. # Input Format - A string `expr` representing a valid infix expression containing single-digit integer operands and the operators `+`, `-`, `*`, and `/`. The expression will have no spaces and will be non-empty. # Output Format - A string representing the postfix notation of the given infix expression. # Constraints - The input expression will be non-empty and will only contain single-digit integers and the operators mentioned. - Division by zero will not occur in the expression. # Example ```python def infix_to_postfix(expr: str) -> str: precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2} stack = [] output = [] for char in expr: if char.isnumeric(): output.append(char) elif char in precedence: while stack and precedence[char] <= precedence[stack[-1]]: output.append(stack.pop()) stack.append(char) while stack: output.append(stack.pop()) return \'\'.join(output) # Example Usage: print(infix_to_postfix(\\"3+5*2\\")) # Output: \\"352*+\\" print(infix_to_postfix(\\"8/2-5\\")) # Output: \\"82/5-\\" ``` # Notes - Ensure your implementation efficiently handles the stack operations. - Consider edge cases, such as when the input contains multiple consecutive operators with different precedence levels. - The function should handle the operators\' precedence correctly. # Explanation - In the example `\\"3+5*2\\"`, the conversion to postfix notation would be `\\"352*+\\"`. - In the example `\\"8/2-5\\"`, the conversion to postfix notation would be `\\"82/5-\\"`. In both cases, the Shunting Yard algorithm appropriately handles operator precedence to ensure the resulting postfix expression is valid for evaluation.","solution":"def infix_to_postfix(expr: str) -> str: precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2} stack = [] output = [] for char in expr: if char.isnumeric(): output.append(char) elif char in precedence: while stack and precedence[char] <= precedence[stack[-1]]: output.append(stack.pop()) stack.append(char) while stack: output.append(stack.pop()) return \'\'.join(output) # Example Usage print(infix_to_postfix(\\"3+5*2\\")) # Output: \\"352*+\\" print(infix_to_postfix(\\"8/2-5\\")) # Output: \\"82/5-\\""},{"question":"# Problem Statement Scenario You are given the task to write a function for a system that processes numerical data to analyze its factors. One of the key functionalities required is to determine if a given number is a prime number or not. Task Write a function `is_prime` which takes a single positive integer as input and returns `True` if the number is a prime and `False` otherwise. Input Format * A single positive integer `n` (2 ≤ `n` ≤ 10^9). Output Format * A boolean value `True` if the input number is prime, and `False` otherwise. Constraints * The input will always be a positive integer within the range [2, 10^9]. * Ensure that the algorithm efficiently handles large input values to avoid performance issues. Example ```python is_prime(5) # Output: True is_prime(4) # Output: False is_prime(17) # Output: True is_prime(1000000007) # Output: True ``` Notes * Recall that a prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. * Consider optimization techniques like checking up to the square root of the number for potential factors. * Think about edge cases and make sure your implementation handles large numbers within the specified constraints efficiently.","solution":"import math def is_prime(n): Returns True if n is a prime number, otherwise False. :param n: int, the number to check if it is a prime :return: bool, True if n is prime, False otherwise if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Scenario You are working on a software project that involves parsing and modifying log files. One of the requirements is to process a list of log entries, where each entry contains a timestamp and a message. The log entries may not be in chronological order, and you need to sort them based on their timestamps. Additionally, you are required to generate a summary report that includes the earliest and latest timestamps and the total number of log entries. # Task Implement a function that takes a list of log entries, each represented as a dictionary with a `timestamp` key and a `message` key. The function should return the sorted list of log entries based on the `timestamp` and also a dictionary containing the earliest timestamp, latest timestamp, and the count of log entries. # Input - A list of log entries, where each entry is a dictionary with `timestamp` (in ISO 8601 format) and `message`. - Constraints: The list can have up to 2000 log entries. # Output - A tuple containing: 1. The sorted list of log entries in chronological order. 2. A dictionary with three keys: `earliest`, `latest`, and `count`. # Function Signature ```python from typing import List, Dict, Tuple def process_log_entries(log_entries: List[Dict[str, str]]) -> Tuple[List[Dict[str, str]], Dict[str, Any]]: pass ``` # Example ```python log_entries = [ {\\"timestamp\\": \\"2021-07-01T12:00:00Z\\", \\"message\\": \\"Log entry 1\\"}, {\\"timestamp\\": \\"2021-07-01T11:00:00Z\\", \\"message\\": \\"Log entry 2\\"}, {\\"timestamp\\": \\"2021-07-01T13:00:00Z\\", \\"message\\": \\"Log entry 3\\"} ] sorted_logs, summary = process_log_entries(log_entries) print(sorted_logs) # Output: [ # {\\"timestamp\\": \\"2021-07-01T11:00:00Z\\", \\"message\\": \\"Log entry 2\\"}, # {\\"timestamp\\": \\"2021-07-01T12:00:00Z\\", \\"message\\": \\"Log entry 1\\"}, # {\\"timestamp\\": \\"2021-07-01T13:00:00Z\\", \\"message\\": \\"Log entry 3\\"} # ] print(summary) # Output: { # \\"earliest\\": \\"2021-07-01T11:00:00Z\\", # \\"latest\\": \\"2021-07-01T13:00:00Z\\", # \\"count\\": 3 # } # Complex example import random import datetime # Generate 1000 log entries with random timestamps log_entries = [ { \\"timestamp\\": (datetime.datetime.now() - datetime.timedelta(days=random.randint(0, 1000))).isoformat() + \'Z\', \\"message\\": f\\"Log entry {i}\\" } for i in range(1000) ] sorted_logs, summary = process_log_entries(log_entries) print(summary) # Output: A dictionary containing the earliest, latest timestamp and the count of log entries. print(sorted_logs[:5]) # Output: The first 5 logs in chronological order. assert sorted_logs == sorted(log_entries, key=lambda x: x[\'timestamp\']) ``` # Constraints - The function must handle edge cases efficiently. - Do not use built-in sort functions. - Assume all timestamps are in valid ISO 8601 format. - Consider the performance for the maximum input size of 2000 log entries.","solution":"from typing import List, Dict, Tuple, Any def process_log_entries(log_entries: List[Dict[str, str]]) -> Tuple[List[Dict[str, str]], Dict[str, Any]]: Processes a list of log entries, sorts them by the timestamps in chronological order, and returns a summary dictionary containing the earliest, latest timestamp, and the count of entries. if not log_entries: return [], {\\"earliest\\": None, \\"latest\\": None, \\"count\\": 0} log_entries.sort(key=lambda entry: entry[\'timestamp\']) earliest = log_entries[0][\'timestamp\'] latest = log_entries[-1][\'timestamp\'] count = len(log_entries) summary = {\\"earliest\\": earliest, \\"latest\\": latest, \\"count\\": count} return log_entries, summary"},{"question":"# Problem Statement Given an array of integers, find out a triplet `(a, b, c)` such that `a ^ b ^ c` is maximized, where `^` denotes the bitwise XOR operation. Output the maximum value that can be achieved. Ensure your algorithm has a time complexity of O(N^2). # Detailed Specification Function Signature ```python def max_triplet_xor(arr: List[int]) -> int: ``` Input Format - `arr`: A list of integers. The length of the list is between 1 and 2000. Output Format Return an integer representing the maximum XOR value of any triplet `(a, b, c)`. # Constraints - 1 <= len(arr) <= 2000 - The elements of `arr` will be integers and can be between 0 and 10^6. # Example Example 1 ```python arr = [3, 9, 5, 7] print(max_triplet_xor(arr)) # Output: 15 ``` In this example, the maximum XOR value is achieved with the triplet (3, 9, 5) which gives 3 ^ 9 ^ 5 = 15. Example 2 ```python arr = [2, 4, 6, 8] print(max_triplet_xor(arr)) # Output: 14 ``` In this example, the maximum XOR value is achieved with the triplet (4, 6, 8) which gives 4 ^ 6 ^ 8 = 14. Example 3 ```python arr = [1, 2, 3, 4, 5] print(max_triplet_xor(arr)) # Output: 7 ``` In this example, the maximum XOR value is achieved with the triplet (1, 2, 4) which gives 1 ^ 2 ^ 4 = 7. # Constraints Your implementation should handle the following constraints: - Ensure that the algorithm runs efficiently for an array size of up to 2000 elements. - Consider edge cases, such as arrays of minimal size (1 or 2 elements), and arrays with all elements being the same. # Notes - Focus on optimizing the algorithm to achieve the required time complexity. - Be sure to handle all edge cases appropriately, including arrays that are too small to form a triplet (in which case, the function should return 0). - Utilize nested loops judiciously to maintain the O(N^2) complexity.","solution":"from typing import List def max_triplet_xor(arr: List[int]) -> int: Given an array of integers, finds the maximum XOR value of any triplet (a, b, c). n = len(arr) if n < 3: return 0 # Not enough elements to form a triplet max_val = 0 for i in range(n): for j in range(i + 1, n): for k in range(j + 1, n): current_xor = arr[i] ^ arr[j] ^ arr[k] if current_xor > max_val: max_val = current_xor return max_val"},{"question":"# Question: Circular Shift of Characters **Scenario:** You are working on a text processing component that involves rotating or circularly shifting the characters in a string. A circular shift means moving characters from the end of the string to the beginning, essentially rotating the string. For example, a circular shift of the string \\"hello\\" by 2 positions yields \\"lohel\\". **Your Task:** Write a Python function `circular_shift(s: str, k: int) -> str` that performs a circular shift on the input string `s` by `k` positions. The shift should be to the right if `k` is positive and to the left if `k` is negative. **Function Signature:** ```python def circular_shift(s: str, k: int) -> str: pass ``` **Input and Output:** * **Input:** A string `s` and an integer `k`. * **Output:** The string `s` after being circularly shifted by `k` positions. **Constraints:** * The input string `s` contains only lowercase and uppercase letters. * 1 ≤ len(s) ≤ 1000 * -1000 ≤ k ≤ 1000 **Requirements:** * Handle both positive and negative values of `k`. * If `k` is greater than the length of the string or less than the negative length of the string, reduce `k` modulo the string\'s length to minimize shifts. * Raise a `ValueError` if the input string is empty or if `k` is not an integer. **Examples:** ```python assert circular_shift(\\"hello\\", 2) == \\"lohel\\" # \\"hello\\" shifted right by 2 assert circular_shift(\\"hello\\", -2) == \\"llohe\\" # \\"hello\\" shifted left by 2 assert circular_shift(\\"abcdef\\", 3) == \\"defabc\\" # \\"abcdef\\" shifted right by 3 assert circular_shift(\\"abcdef\\", -3) == \\"defabc\\" # \\"abcdef\\" shifted left by 3 assert circular_shift(\\"a\\", 1000) == \\"a\\" # Single character remains the same ``` **Performance:** * Your solution should run in O(n) time complexity where `n` is the length of the string. * The space complexity should be O(1) for the in-place shift or O(n) if you create a new string. **Tips:** * Consider how Python slicing can help you implement the circular shift efficiently. * Remember to handle very large or very small values of `k` by using modulo operations.","solution":"def circular_shift(s: str, k: int) -> str: Performs a circular shift on the input string `s` by `k` positions. The shift is to the right if `k` is positive and to the left if `k` is negative. Args: s (str): The input string. k (int): The number of positions to shift the string by. Returns: str: The string after being circularly shifted. Raises: ValueError: If the input string is empty or if `k` is not an integer. if not isinstance(s, str): raise ValueError(\\"The input must be a string.\\") if not isinstance(k, int): raise ValueError(\\"The shift value must be an integer.\\") if len(s) == 0: raise ValueError(\\"The input string must not be empty.\\") n = len(s) k = k % n # Reduce k modulo the string\'s length to minimize shifts return s[-k:] + s[:-k] if k != 0 else s"},{"question":"# Mixed Sorting of a List The following is a coding challenge to demonstrate your ability to manipulate and sort lists according to specific rules. This task requires careful handling of both numerical and alphabetical elements. # Scenario Johnathan works at a data processing firm and encounters a list containing both strings and integers. He needs the list to be sorted in a specific manner where: - All integer values should appear first in ascending order. - All string values should follow the integers, sorted lexicographically (alphabetical order). # Task Write a function `mixed_sort` that takes a list of mixed data types (integers and strings) and returns a list sorted with the described constraints. # Function Signature ```python def mixed_sort(data: list) -> list: pass ``` # Input - `data` (list): The input list containing integers and strings. # Output - Returns the sorted list following the specified rules. # Constraints - The function should handle an empty list appropriately. - Ensure that if the input list contains only integers or only strings, it is sorted correctly. - Lists may contain mixed case strings; handle them according to their ASCII values. # Example **Input** ```python assert mixed_sort([3, \\"apple\\", 1, \\"Banana\\", 2, \\"cherry\\"]) == [1, 2, 3, \\"Banana\\", \\"apple\\", \\"cherry\\"] assert mixed_sort([\\"world\\", \\"hello\\", 5, 3, \\"Python\\", 12]) == [3, 5, 12, \\"Python\\", \\"hello\\", \\"world\\"] assert mixed_sort([]) == [] assert mixed_sort([5, 3, 1, 2]) == [1, 2, 3, 5] assert mixed_sort([\\"apple\\", \\"Banana\\", \\"cherry\\"]) == [\\"Banana\\", \\"apple\\", \\"cherry\\"] ``` **Output** ```python [1, 2, 3, \\"Banana\\", \\"apple\\", \\"cherry\\"] [3, 5, 12, \\"Python\\", \\"hello\\", \\"world\\"] [] [1, 2, 3, 5] [\\"Banana\\", \\"apple\\", \\"cherry\\"] ``` # Notes - You can assume the input list will contain only integers and strings. - The returned list should have integers first (sorted) and strings next (sorted lexicographically).","solution":"def mixed_sort(data: list) -> list: Sort the list such that all integer values appear first in ascending order followed by all string values in lexicographical order. integers = sorted(x for x in data if isinstance(x, int)) strings = sorted(x for x in data if isinstance(x, str)) return integers + strings"},{"question":"**Generate k-Most Frequent Elements** **Context**: In data analysis and machine learning, identifying the most frequent elements in a dataset is a common task. The ability to extract these elements efficiently from large datasets can significantly improve the performance of your data processing pipeline. **Task**: Write a function `k_most_frequent_elements` that takes a list of integers and an integer k. The function should return a list of the k most frequent elements in the input list. If there are multiple elements with the same frequency, prioritize the smaller elements. **Function Signature**: ```python def k_most_frequent_elements(arr: List[int], k: int) -> List[int]: pass ``` **Input**: * `arr` (List[int]): A list of integers. * `k` (int): The number of top frequent elements to return. **Output**: * `List[int]`: A list of the k most frequent elements sorted in descending order by their frequency, and by their value in case of ties. **Constraints**: * The list can contain any integer value. * 1 ≤ k ≤ len(arr). * It is guaranteed that the input list is not empty. **Example**: ```python >>> arr = [1, 1, 1, 2, 2, 3] >>> k = 2 >>> k_most_frequent_elements(arr, k) [1, 2] >>> arr = [4, 4, 1, 1, 2, 2, 2, 3] >>> k = 3 >>> k_most_frequent_elements(arr, k) [2, 1, 4] ``` **Performance Requirements**: * The function should handle large input arrays efficiently. **Edge Cases**: * All elements in the array are the same. * The array contains both positive and negative integers. * The input list contains just k unique elements. **Instructions**: * Implement the function `k_most_frequent_elements`. * Ensure your implementation handles edge cases. * You should prioritize using Python\'s built-in functionalities to maintain efficiency and readability.","solution":"from collections import Counter from typing import List def k_most_frequent_elements(arr: List[int], k: int) -> List[int]: Returns the k most frequent elements from the list `arr`. Parameters: arr (List[int]): A list of integers. k (int): The number of top frequent elements to return. Returns: List[int]: A list with the k most frequent elements sorted by frequency and value. # Count the frequency of elements in the list count = Counter(arr) # Create a list of elements sorted by frequency and then by the element value sorted_elements = sorted(count.items(), key=lambda x: (-x[1], x[0])) # Collect the top k elements from the sorted list result = [element for element, frequency in sorted_elements[:k]] return result"},{"question":"# Sum of Large Integers Representation When working with high-precision arithmetic in various programming languages, handling extremely large integers can be challenging because they might exceed the standard primitive data type limits. To overcome this, we often employ custom representations and algorithms for arithmetic operations. Your task is to implement two functions that handle addition of large integers represented as strings. 1. **`add_large_integers(num1: str, num2: str) -> str`**: - Input: - `num1`: a string representing a large integer. It can be a positive or negative number. - `num2`: a string representing another large integer. It can also be a positive or negative number. - Output: - Return a string representing the sum of `num1` and `num2`. 2. **`validate_integer(num: str) -> bool`**: - Input: - `num`: a string that is claimed to be an integer. - Output: - Return `True` if the input string is a valid integer representation (either positive, negative, or zero), and `False` otherwise. # Constraints - `num1` and `num2` can each have up to 1000 digits. - Both positive and negative integers should be handled appropriately. - You can assume the input strings will be well-formed and will not include any non-numeric characters except for an optional leading `+` or `-` sign. # Examples ```python # Example usage: # Validate integer representations print(validate_integer(\\"123456789012345678901234567890\\")) # True print(validate_integer(\\"-100000000001\\")) # True print(validate_integer(\\"+000000123456\\")) # True print(validate_integer(\\"12.34\\")) # False # Add large integers num1 = \\"123456789012345678901234567890\\" num2 = \\"987654321098765432109876543210\\" print(add_large_integers(num1, num2)) # \\"1111111110111111111011111111100\\" num1 = \\"-123456789012345678901234567890\\" num2 = \\"123456789012345678901234567890\\" print(add_large_integers(num1, num2)) # \\"0\\" num1 = \\"-123456789012345678901234567890\\" num2 = \\"-987654321098765432109876543210\\" print(add_large_integers(num1, num2)) # \\"-1111111110111111111011111111100\\" ``` # Notes - Ensure your implementation handles both the magnitude and sign of the integers correctly. - Validate the input strings for proper integer representation before attempting to add them. - Optimize your solution to handle the edge cases, such as adding very large numbers or numbers with leading zeros.","solution":"def add_large_integers(num1: str, num2: str) -> str: Returns the sum of large integers represented as strings. # Convert the string representations to integers int1 = int(num1) int2 = int(num2) # Calculate the sum and convert it back to string result = int1 + int2 return str(result) def validate_integer(num: str) -> bool: Validates if the input string num is a proper integer representation. if not num: return False if num[0] in (\'-\', \'+\'): return num[1:].isdigit() if len(num) > 1 else False else: return num.isdigit()"},{"question":"# Number Permutation Checker A permutation of a sequence is another sequence with the same elements but in a different order. For example, the following sequences are permutations of each other: *[1, 2, 3], [3, 2, 1], [2, 3, 1]* Given two sequences of integers, your task is to determine if one sequence is a permutation of the other. Task: Implement a function `is_permutation` that takes two sequences of integers and returns `True` if one sequence is a permutation of the other, and `False` otherwise. Function Signature: ```python def is_permutation(seq1: List[int], seq2: List[int]) -> bool: ``` Inputs: - `seq1`: A list of integers. - `seq2`: A list of integers. Outputs: - A boolean value (`True` or `False`). Constraints: - The length of each sequence will be between 1 and 10^5 inclusive. - Each integer in the sequences will be between −10^9 and 10^9 inclusive. Examples: ```python >>> is_permutation([1, 2, 3], [3, 1, 2]) True >>> is_permutation([1, 2, 3], [4, 5, 6]) False ``` Notes: - To check if one sequence is a permutation of the other, consider using a data structure that allows efficient comparison of element frequencies (e.g., dictionaries or `collections.Counter` in Python). - The sequences have equal length for them to be permutations of each other; otherwise, the function should return `False`. Performance Requirements: - Aim for a solution with a time complexity of O(n), where n is the length of the input sequences. This means your solution should efficiently handle the upper limit of input sizes.","solution":"from typing import List from collections import Counter def is_permutation(seq1: List[int], seq2: List[int]) -> bool: Returns True if seq2 is a permutation of seq1, otherwise False. if len(seq1) != len(seq2): return False return Counter(seq1) == Counter(seq2)"},{"question":"# Coding Assessment Question: Determining if a List is a Sub-list of Another List You are provided with two lists of integers `list_a` and `list_b`. Write a function `is_sublist(list_a: list[int], list_b: list[int]) -> bool` to check if `list_b` is a sub-list of `list_a`. In other words, determine if the `list_b` appears as a contiguous sequence within `list_a`. Input: * Two lists of integers `list_a` and `list_b` where `list_a` can have a variable length, and `list_b` can have a length of zero or more but not greater than `list_a`. Output: * Return `True` if `list_b` is a sub-list of `list_a`, otherwise return `False`. Example: ```python >>> is_sublist([1, 2, 3, 4, 5], [2, 3, 4]) True >>> is_sublist([1, 2, 3, 4, 5], [2, 4]) False >>> is_sublist([1, 2, 3, 4, 5], []) True >>> is_sublist([5, 1, 22, 25, 6, -1, 8, 10], [25, 6, -1]) True >>> is_sublist([5, 1, 22, 25, 6, -1, 8, 10], [1, 6, -1]) False ``` Constraints: * The input list `list_a` can contain `n` integers where `0 ≤ n ≤ 1000`. * The input list `list_b` can contain `m` integers where `0 ≤ m ≤ n`. * Both lists `list_a` and `list_b` may contain negative integers and/or positive integers. * The integers in both `list_a` and `list_b` are unique. Performance Requirements: * Your solution should run in O(n * m) time complexity or better, where `n` is the length of `list_a` and `m` is the length of `list_b`. * Your solution should use O(1) extra space. Notes: * Be sure to handle the edge case where `list_b` is an empty list, which should return `True`. * Make sure to validate the input to ensure it meets the above constraints. Implement the `is_sublist` function based on the guidelines provided above: ```python def is_sublist(list_a: list[int], list_b: list[int]) -> bool: # Your implementation here pass ```","solution":"def is_sublist(list_a: list[int], list_b: list[int]) -> bool: Determines if list_b is a sub-list of list_a. if not list_b: return True len_a = len(list_a) len_b = len(list_b) for i in range(len_a - len_b + 1): if list_a[i:i+len_b] == list_b: return True return False"},{"question":"# Problem Statement You are given an initial list of integers, and a series of operations to perform on this list. Each operation is one of the following: 1. **Add**: Add an integer to the list. 2. **Remove**: Remove all occurrences of an integer from the list. 3. **Query**: Find the k-th smallest element in the list (1-based index). Your task is to implement a function to perform these operations efficiently, especially the Query operation. # Function Signature ```python class CustomList: def __init__(self): self.elements = [] def add(self, value: int) -> None: pass def remove(self, value: int) -> None: pass def query(self, k: int) -> int: pass ``` # Input * Operations are provided in a list of tuples where the first element of each tuple is a string indicating the operation type (`\\"Add\\"`, `\\"Remove\\"`, `\\"Query\\"`), and the second element is an integer: the value to add/remove, or the k value for querying. # Output * For each `\\"Query\\"` operation, return the k-th smallest element in the list as an integer. # Constraints * The list can initially be empty. * 1 <= number of operations <= 10^5 * For `\\"Add\\"` and `\\"Remove\\"` operations: -10^9 <= value <= 10^9 * For `\\"Query\\"` operations: 1 <= k <= number of current elements in the list # Example ```python operations = [ (\\"Add\\", 5), (\\"Add\\", 3), (\\"Add\\", 8), (\\"Add\\", 7), (\\"Query\\", 2), (\\"Remove\\", 3), (\\"Query\\", 2) ] custom_list = CustomList() for operation in operations: if operation[0] == \\"Add\\": custom_list.add(operation[1]) elif operation[0] == \\"Remove\\": custom_list.remove(operation[1]) elif operation[0] == \\"Query\\": result = custom_list.query(operation[1]) print(result) ``` # Expected Output ``` 5 7 ``` # Scenario You are managing a dynamic list of integers with the requirements to efficiently add, remove, and query the k-th smallest element. This challenge involves maintaining the list in such a way that query operations can be quickly executed, which likely requires a sophisticated data structure like a balanced tree or a combination of binary search and heap operations for optimal performance in all scenarios. Implement a class that handles these operations efficiently.","solution":"import bisect class CustomList: def __init__(self): self.elements = [] def add(self, value: int) -> None: bisect.insort(self.elements, value) def remove(self, value: int) -> None: self.elements = list(filter(lambda x: x != value, self.elements)) def query(self, k: int) -> int: if 1 <= k <= len(self.elements): return self.elements[k - 1] else: raise IndexError(\\"k is out of range\\")"},{"question":"# Dynamic Report Generation System As an experienced software engineer, you are responsible for developing a dynamic report generation system for a company\'s sales data analysis. The system should be able to handle large datasets efficiently and provide insightful analytical reports based on the input parameters. **Requirements**: 1. Implement a function to initialize the report system with sales data. 2. Implement a function to filter the sales data based on given criteria. 3. Implement a function to generate analytical metrics from the filtered data. 4. Ensure the system can clear the dataset at any point. # Objectives: - **Function**: `initialize_sales_data(sales: List[Dict[str, Any]])` - **Input**: - `sales`: List of dictionaries, where each dictionary represents a sale record. Each record contains keys such as \'product_id\', \'quantity\', \'price\', \'date\'. - **Output**: Initializes the sales data. - **Function**: `filter_sales_data(criteria: Dict[str, Any]) -> List[Dict[str, Any]]` - **Input**: - `criteria`: Dictionary containing the filter conditions. Possible keys are \'product_id\', \'min_quantity\', \'max_quantity\', \'min_price\', \'max_price\', \'start_date\', \'end_date\'. - **Output**: Returns the filtered list of sales data based on the given criteria. - **Function**: `generate_report(filtered_sales: List[Dict[str, Any]]) -> Dict[str, Any]` - **Input**: - `filtered_sales`: List of dictionaries representing the filtered sales data. - **Output**: Returns a dictionary containing aggregated metrics such as total_sales, average_price, and total_quantity. - **Function**: `clear_sales_data()` - **Input**: None - **Output**: Clears the current sales data. Constraints: - The date format should be \'YYYY-MM-DD\'. - Ensure efficient filtering of data even for large datasets. - Use appropriate data structures to manage the sales records for quick access and update. - The input data and filter criteria should be validated for required fields and correct data types. # Example Scenario: 1. Initialize the sales data using: ```python initialize_sales_data([ {\'product_id\': \'A1\', \'quantity\': 10, \'price\': 15.0, \'date\': \'2023-01-01\'}, {\'product_id\': \'B2\', \'quantity\': 5, \'price\': 25.0, \'date\': \'2023-01-02\'}, {\'product_id\': \'A1\', \'quantity\': 2, \'price\': 15.0, \'date\': \'2023-01-03\'} ]) ``` 2. Filter the sales data with criteria such as: ```python filter_sales_data({\'product_id\': \'A1\', \'min_quantity\': 1, \'max_price\': 20.0}) ``` 3. Generate and print the report based on filtered sales data. 4. Clear the sales data and verify that the dataset is empty. # Guidelines: - Thoroughly test the functions with various criteria and datasets. - Document edge cases and handle exceptions gracefully. - Analyze performance for datasets with thousands of records and ensure optimal filtering and aggregation. Can you build the robust report generator that the company needs to drive insightful sales analysis?","solution":"from typing import List, Dict, Any from datetime import datetime class SalesReportSystem: def __init__(self): self.sales_data = [] def initialize_sales_data(self, sales: List[Dict[str, Any]]): Initializes the sales data. self.sales_data = sales def filter_sales_data(self, criteria: Dict[str, Any]) -> List[Dict[str, Any]]: Filters the sales data based on given criteria. filtered_sales = [] for sale in self.sales_data: if \'product_id\' in criteria and sale[\'product_id\'] != criteria[\'product_id\']: continue if \'min_quantity\' in criteria and sale[\'quantity\'] < criteria[\'min_quantity\']: continue if \'max_quantity\' in criteria and sale[\'quantity\'] > criteria[\'max_quantity\']: continue if \'min_price\' in criteria and sale[\'price\'] < criteria[\'min_price\']: continue if \'max_price\' in criteria and sale[\'price\'] > criteria[\'max_price\']: continue if \'start_date\' in criteria and sale[\'date\'] < criteria[\'start_date\']: continue if \'end_date\' in criteria and sale[\'date\'] > criteria[\'end_date\']: continue filtered_sales.append(sale) return filtered_sales def generate_report(self, filtered_sales: List[Dict[str, Any]]) -> Dict[str, Any]: Generates analytical metrics from the filtered sales data. total_sales = sum(sale[\'price\'] * sale[\'quantity\'] for sale in filtered_sales) total_quantity = sum(sale[\'quantity\'] for sale in filtered_sales) average_price = total_sales / total_quantity if total_quantity else 0 return { \'total_sales\': total_sales, \'total_quantity\': total_quantity, \'average_price\': average_price } def clear_sales_data(self): Clears the current sales data. self.sales_data = [] sales_report_system = SalesReportSystem()"},{"question":"Problem Description You are tasked with finding all \\"silver triples\\" in a given range `n`. A \\"silver triple\\" (a, b, c) consists of three integers such that `1 <= a, b, c <= n` and the triple satisfies the following condition: `a^2 + b^2 = c^2`. Once all silver triples are identified, return a list of these triples sorted lexicographically. A triple (a, b, c) is lexicographically smaller than (a\', b\', c\') if `a < a\'` or `(a == a\' and b < b\')` or `(a == a\' and b == b\' and c < c\')`. # Function Signature ```python def find_silver_triples(n: int) -> List[Tuple[int, int, int]]: pass ``` # Input * `n` (int): The upper bound for the integers in the triple, 1 ≤ `n` ≤ 100. # Output * `List[Tuple[int, int, int]]`: A list of tuples, each representing a silver triple (a, b, c) sorted lexicographically. # Example ```python assert find_silver_triples(10) == [(3, 4, 5), (6, 8, 10)] assert find_silver_triples(15) == [(3, 4, 5), (5, 12, 13), (6, 8, 10), (9, 12, 15)] ``` # Constraints * Ensure efficient enumeration and checking of all possible triples (a, b, c). * Pythagorean triples might involve more than just primitive sets, so consider all valid combinations within the given range. * Sorting requirements must be met by ensuring the result list is lexicographically sorted before returning. # Notes * Python\'s tuple comparison operators can be used effectively to sort the list of triples. * Make sure to adhere to the naive bounds for `a`, `b`, and `c` within the provided constraints to maintain function efficiency.","solution":"from typing import List, Tuple def find_silver_triples(n: int) -> List[Tuple[int, int, int]]: silver_triples = [] for a in range(1, n + 1): for b in range(a, n + 1): for c in range(b, n + 1): if a * a + b * b == c * c: silver_triples.append((a, b, c)) silver_triples.sort() return silver_triples"},{"question":"# Problem Statement You have been hired to create a data processing script that processes sales records from multiple store locations. Each record contains the store ID, product ID, and the quantity of product sold. Your task is to write a function that computes the total quantity of each product sold across all stores. # Task Implement a function `calculate_total_sales` that computes the total quantity of each product sold given a list of sales records. Function Signature ```python def calculate_total_sales(sales: List[Tuple[int, int, int]]) -> Dict[int, int]: ``` Input * `sales` (List[Tuple[int, int, int]]): A list of sales records, where each record is a tuple of three integers: * The first integer represents the store ID. * The second integer represents the product ID. * The third integer represents the quantity of the product sold. Output * (Dict[int, int]): A dictionary where the keys are product IDs and the values are the total quantities sold. Constraints * All integers in the input list `sales` are non-negative. * The length of the input list `sales` is at most 10^5. * There are at most 10^4 distinct product IDs. # Example ```python sales_records = [ (1, 1001, 5), (2, 1001, 3), (1, 1002, 7), (3, 1001, 2), (2, 1003, 10), ] total_sales = calculate_total_sales(sales_records) print(total_sales) # Output should be {1001: 10, 1002: 7, 1003: 10} ``` # Notes 1. Ensure your solution handles large inputs efficiently. 2. It is assumed that there are no duplicate records for the same product from the same store. 3. Document any assumptions or additional considerations in your solution.","solution":"from typing import List, Tuple, Dict def calculate_total_sales(sales: List[Tuple[int, int, int]]) -> Dict[int, int]: Computes the total quantity of each product sold across all stores. Parameters: sales (List[Tuple[int, int, int]]): A list of sales records, where each record is a tuple of three integers: The first integer represents the store ID. The second integer represents the product ID. The third integer represents the quantity of the product sold. Returns: Dict[int, int]: A dictionary where the keys are product IDs and the values are the total quantities sold. total_sales = {} for store_id, product_id, quantity in sales: if product_id in total_sales: total_sales[product_id] += quantity else: total_sales[product_id] = quantity return total_sales"},{"question":"# Coding Assessment Question **Context:** Parsing and extracting useful information from text data is a key task in many data processing applications. Writing a function to convert a given string representing a Roman numeral into its integer value is a common problem that can test a candidate\'s understanding of strings, maps, and control structures. **Task:** Write a function named `roman_to_integer` in Python to convert a Roman numeral to an integer. Roman numerals are represented by the following symbols: - \'I\' -> 1 - \'V\' -> 5 - \'X\' -> 10 - \'L\' -> 50 - \'C\' -> 100 - \'D\' -> 500 - \'M\' -> 1000 In Roman numerals, smaller numbers can appear before larger numbers to indicate subtraction. For example, \\"IV\\" means 4. **Function Signature:** ```python def roman_to_integer(roman: str) -> int: ``` **Input:** - `roman`: A string representing a Roman numeral. The string will contain characters \'I\', \'V\', \'X\', \'L\', \'C\', \'D\', \'M\' only and will be a valid Roman numeral within the range from 1 to 3999. **Output:** - An integer representing the numerical value of the Roman numeral. **Constraints:** - The input string `roman` will be non-empty and at most length 15. - The input will always be a valid Roman numeral within the specified range. **Example:** ```python >>> roman_to_integer(\\"III\\") 3 >>> roman_to_integer(\\"IV\\") 4 >>> roman_to_integer(\\"IX\\") 9 >>> roman_to_integer(\\"LVIII\\") 58 >>> roman_to_integer(\\"MCMXCIV\\") 1994 ``` **Note:** - You should not use any external libraries. - Pay attention to special cases where subtraction is used.","solution":"def roman_to_integer(roman: str) -> int: Convert a Roman numeral to an integer. :param roman: A string representing a Roman numeral. :return: An integer representing the numerical value of the Roman numeral. roman_to_value = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total_value = 0 prev_value = 0 for char in reversed(roman): value = roman_to_value[char] if value < prev_value: total_value -= value else: total_value += value prev_value = value return total_value"},{"question":"# Frequency Counter In this task, you are required to implement the method `get_max_frequency` on a provided `TextAnalyzer` class. This method should analyze the given text to find the most frequently occurring word in the entire text. In case there are multiple words with the same highest frequency, return the word which appears first while scanning the text from left to right. Consider words to be sequences of alpha-numeric characters and separate words by spaces or punctuation. Ensure the method is case-insensitive while counting word frequencies. ```python class TextAnalyzer: def __init__(self, text: str): self.text = text def get_max_frequency(self) -> str: This method should return the word with the highest frequency in the text. Returns: str: The word with the highest frequency (case insensitive). # Your code here pass ``` Input Format: - The input to the `TextAnalyzer` class will be a string `text`. Output Format: - Return a string representing the word with the highest frequency. Constraints: 1. The length of `text` can range from 1 to 1000 characters. 2. Text contains only alpha-numeric characters and punctuations (whitespace, commas, periods, etc.). Example: Consider the following text: ``` \\"Hello, hello! This is a test. This test is only a test.\\" ``` - In this case, calling `get_max_frequency` on the `TextAnalyzer` with this text returns `\\"test\\"`, as it appears three times. To validate your solution, ensure you cover various edge cases such as: - Case insensitivity. - Handling punctuation as word separators. - Texts where there are multiple words with the same frequency.","solution":"import re from collections import Counter class TextAnalyzer: def __init__(self, text: str): self.text = text def get_max_frequency(self) -> str: This method should return the word with the highest frequency in the text. Returns: str: The word with the highest frequency (case insensitive). # Convert text to lowercase and use regex to extract words words = re.findall(r\'bw+b\', self.text.lower()) # Count word frequencies word_counts = Counter(words) # Find the word with the highest frequency max_word = max(word_counts, key=lambda word: (word_counts[word], -words.index(word))) return max_word"},{"question":"# Coding Assessment Question You need to develop a function to analyze a list of employee work hours and calculate their total weekly pay based on different hourly wages for regular and overtime hours. Function: `calculate_weekly_pay` Objective: Calculate the weekly pay for each employee based on provided work hours and hourly wages. Requirements: 1. If any employee\'s hours worked spans more than 7 days or contains invalid hours (e.g., negative numbers or hours exceeding 24 per day), the function should raise a `ValueError` with an appropriate message. 2. Regular work hours are up to 40 hours per week. Any hours beyond this are considered overtime. 3. Each employee\'s pay consists of regular hours multiplied by their `regular_wage` and overtime hours multiplied by their `overtime_wage`. Input: * `employee_hours`(list of lists of floats): Nested list where each inner list represents an employee\'s work hours for each day of the week. * `regular_wage`(float): Hourly wage for regular hours. * `overtime_wage`(float): Hourly wage for overtime hours. Output: * `list of floats`: List of total weekly pay for each employee. Constraints: - All hourly wages (`regular_wage` and `overtime_wage`) must be positive floats. - The `employee_hours` list will have a positive length (at least one employee), and each inner list must have exactly 7 elements representing hours worked per day. Example: ```python >>> calculate_weekly_pay([[8, 8, 8, 8, 8, 0, 0], [10, 10, 10, 10, 10, 0, 0]], 20, 30) [800.0, 1100.0] >>> calculate_weekly_pay([[5, 5, 5, 5, 5, 5, 5]], 15, 22.5) 562.5 ``` Error Handling: - The function should raise a `ValueError` with an appropriate message for invalid hours or malformed data. Implement the function `calculate_weekly_pay` as described.","solution":"from typing import List def calculate_weekly_pay(employee_hours: List[List[float]], regular_wage: float, overtime_wage: float) -> List[float]: Calculate the weekly pay for each employee based on work hours and hourly wages. :param employee_hours: List of lists, where each inner list contains 7 elements representing work hours per day. :param regular_wage: Hourly wage for regular hours. :param overtime_wage: Hourly wage for overtime hours. :return: List of total weekly pay for each employee. :raises ValueError: If hours span more than 7 days, contain negative numbers, or exceed 24 hours per day. if regular_wage <= 0 or overtime_wage <= 0: raise ValueError(\\"Hourly wages must be positive.\\") weekly_pays = [] for hours in employee_hours: if len(hours) != 7: raise ValueError(\\"Each employee\'s work hours must span exactly 7 days.\\") if any(h < 0 or h > 24 for h in hours): raise ValueError(\\"Invalid work hours: must be in the range 0 to 24 per day.\\") total_hours = sum(hours) regular_hours = min(total_hours, 40) overtime_hours = max(0, total_hours - 40) regular_pay = regular_hours * regular_wage overtime_pay = overtime_hours * overtime_wage total_pay = regular_pay + overtime_pay weekly_pays.append(total_pay) return weekly_pays"},{"question":"# Matrix Multiplication using Strassen\'s Algorithm Context Matrix multiplication is a fundamental operation in various scientific computations. Strassen\'s algorithm is an efficient algorithm for matrix multiplication that reduces the time complexity compared to the conventional algorithm. Objective Write a function `strassen_multiply(matrix1, matrix2)` that takes two 2D lists of numbers as input representing matrices (A) and (B), and returns a 2D list representing the product matrix (C). Implement Strassen\'s algorithm for multiplication, ensuring that the matrices are square and have dimensions of size (2^n times 2^n) (i.e., dimensions should be a power of 2). Input - Two 2D lists `matrix1` and `matrix2` each containing elements of size (2^n times 2^n), where (1 leq n leq 6). - Each element in the matrices is an integer. Output - A 2D list `C` representing the product matrix of `matrix1` and `matrix2` of the same dimensions. Example ```python matrix1 = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] matrix2 = [ [17, 18, 19, 20], [21, 22, 23, 24], [25, 26, 27, 28], [29, 30, 31, 32] ] C = strassen_multiply(matrix1, matrix2) # C will be the product matrix of the same dimensions as input matrices ``` Constraints 1. Do not use any external libraries except for basic mathematical operations. 2. Ensure that your function handles the splitting and recombination of submatrices correctly. 3. Validate that the input matrices have dimensions that are powers of 2. 4. Your function should terminate within a reasonable time for given constraints. 5. Optimize for clarity and correctness over extreme efficiency but avoid unnecessary inefficiencies.","solution":"def matrix_addition(A, B): Add two matrices A and B. n = len(A) return [[A[i][j] + B[i][j] for j in range(n)] for i in range(n)] def matrix_subtraction(A, B): Subtract matrix B from matrix A. n = len(A) return [[A[i][j] - B[i][j] for j in range(n)] for i in range(n)] def matrix_split(matrix): Split the given matrix into quarters. n = len(matrix) mid = n // 2 A11 = [row[:mid] for row in matrix[:mid]] A12 = [row[mid:] for row in matrix[:mid]] A21 = [row[:mid] for row in matrix[mid:]] A22 = [row[mid:] for row in matrix[mid:]] return A11, A12, A21, A22 def matrix_combine(P11, P12, P21, P22): Combine 4 quadrants into a single matrix. top = [P11[i] + P12[i] for i in range(len(P11))] bottom = [P21[i] + P22[i] for i in range(len(P21))] return top + bottom def strassen_multiply(A, B): Multiply matrix A by matrix B using Strassen\'s algorithm. n = len(A) if n == 1: return [[A[0][0] * B[0][0]]] # Split A and B into 4 submatrices each A11, A12, A21, A22 = matrix_split(A) B11, B12, B21, B22 = matrix_split(B) # M1 = (A11 + A22) * (B11 + B22) M1 = strassen_multiply(matrix_addition(A11, A22), matrix_addition(B11, B22)) # M2 = (A21 + A22) * B11 M2 = strassen_multiply(matrix_addition(A21, A22), B11) # M3 = A11 * (B12 - B22) M3 = strassen_multiply(A11, matrix_subtraction(B12, B22)) # M4 = A22 * (B21 - B11) M4 = strassen_multiply(A22, matrix_subtraction(B21, B11)) # M5 = (A11 + A12) * B22 M5 = strassen_multiply(matrix_addition(A11, A12), B22) # M6 = (A21 - A11) * (B11 + B12) M6 = strassen_multiply(matrix_subtraction(A21, A11), matrix_addition(B11, B12)) # M7 = (A12 - A22) * (B21 + B22) M7 = strassen_multiply(matrix_subtraction(A12, A22), matrix_addition(B21, B22)) # C11 = M1 + M4 - M5 + M7 C11 = matrix_addition(matrix_subtraction(matrix_addition(M1, M4), M5), M7) # C12 = M3 + M5 C12 = matrix_addition(M3, M5) # C21 = M2 + M4 C21 = matrix_addition(M2, M4) # C22 = M1 - M2 + M3 + M6 C22 = matrix_addition(matrix_subtraction(matrix_addition(M1, M3), M2), M6) return matrix_combine(C11, C12, C21, C22)"},{"question":"# Is Unique **Objective**: Implement a function to determine if a string has all unique characters. **Scenario**: You are working on a new feature for a username validation service. One of the requirements is to ensure that the username contains only unique characters. This means that a username like \\"john\\" is valid because all characters are unique, whereas \\"anna\\" is not valid because the character \\"n\\" repeats. **Function Signature**: ```python def is_unique(s: str) -> bool: pass ``` **Input**: - `s` (str): A string to check for uniqueness. It may contain uppercase and lowercase letters. **Output**: - Returns `True` if the string has all unique characters, otherwise returns `False`. **Constraints**: - The input string `s` will have a length of at most 256 characters. - The function should be case-sensitive, meaning \'A\' and \'a\' are considered different characters. **Example**: ```python assert is_unique(\\"john\\") == True assert is_unique(\\"anna\\") == False assert is_unique(\\"123abcXYZ\\") == True assert is_unique(\\"aA\\") == True assert is_unique(\\"hello\\") == False ``` **Guidelines**: - Aim to solve the problem with a time complexity of O(n), where n is the length of the input string. - Consider using additional data structures to keep track of characters encountered. **Performance**: - The function should ideally use O(1) additional space, apart from the input string itself.","solution":"def is_unique(s: str) -> bool: Determines if a string has all unique characters. Args: s (str): The input string to check for uniqueness. Returns: bool: True if all characters are unique, False otherwise. # A set to track characters that have been encountered char_set = set() for char in s: if char in char_set: return False char_set.add(char) return True"},{"question":"**Objective**: Implement a Python function `merge_k_sorted_lists` to merge k sorted linked lists into a single sorted linked list. # Function Signature ```python def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: pass ``` # Input * `lists` (List[Optional[ListNode]]): A list containing the head nodes of k sorted linked lists. # Output * Returns the head node of the merged sorted linked list. # Constraints * The total number of nodes across all lists is at most (10^4). * Each linked list is sorted in non-decreasing order. # Requirements 1. Define the `ListNode` class for the linked list node if not predefined. 2. Merge the k sorted linked lists into a single sorted linked list. 3. Return the head node of the merged linked list. # Example ```python # Example 1: # Input: lists = [1->4->5, 1->3->4, 2->6] # Output: 1->1->2->3->4->4->5->6 ``` **Hint**: Utilize a min-heap (priority queue) to efficiently merge the lists. # Explanation Given k sorted linked lists, merge them into a single sorted linked list such that the merged list maintains the sorted order.","solution":"from typing import List, Optional import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: min_heap = [] # Initialize the heap for i, list_head in enumerate(lists): if list_head: heapq.heappush(min_heap, (list_head.val, i, list_head)) dummy_head = ListNode() current = dummy_head while min_heap: val, i, node = heapq.heappop(min_heap) current.next = ListNode(val) current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, i, node.next)) return dummy_head.next"},{"question":"# Context You are working for an e-commerce company that wants to enhance its recommendation system by analyzing customer reviews. Each review includes multiple aspects like product quality, delivery time, packaging, and customer service. The company aims to summarize the review scores for each product aspect within a specified time range. # Task Implement a function `summarize_reviews` that performs the following steps: 1. **Filter** the reviews based on the provided date range. 2. **Organize** the reviews by product and aspect. 3. **Compute** the average score for each aspect of each product within the specified time range. # Function Signature ```python def summarize_reviews(reviews: list[list[str, str, list[list[str, float]]]], start_date: str, end_date: str) -> dict: Summarize customer reviews by product and aspect within a specified date range. Parameters: - reviews: A list of lists where each sublist contains [product_id, review_date, aspects] and aspects is a list of [aspect_name, score]. - start_date: The start date of the time range as a string in \'YYYY-MM-DD\' format. - end_date: The end date of the time range as a string in \'YYYY-MM-DD\' format. Returns: - A dictionary where keys are product_ids, and values are dictionaries with aspect names as keys and average scores as values. Example: >>> reviews = [ [\\"p1\\", \\"2023-05-14\\", [[\\"quality\\", 4.0], [\\"delivery\\", 5.0]]], [\\"p1\\", \\"2023-06-01\\", [[\\"quality\\", 3.5], [\\"packaging\\", 4.5]]], [\\"p2\\", \\"2023-07-20\\", [[\\"delivery\\", 4.0], [\\"service\\", 4.5]]] ] >>> start_date, end_date = \\"2023-05-01\\", \\"2023-06-30\\" >>> summarize_reviews(reviews, start_date, end_date) {\'p1\': {\'quality\': 3.75, \'delivery\': 5.0, \'packaging\': 4.5}} ``` # Input Constraints - `reviews` contains at least one review and each review is correctly formatted. - `review_date`, `start_date`, and `end_date` are valid dates in \'YYYY-MM-DD\' format. - All aspect scores are floored between 0.0 and 5.0. # Performance Requirements - The implementation should consider optimized performance for potentially large datasets. # Example ```python reviews = [ [\\"p1\\", \\"2023-05-14\\", [[\\"quality\\", 4.0], [\\"delivery\\", 5.0]]], [\\"p1\\", \\"2023-06-01\\", [[\\"quality\\", 3.5], [\\"packaging\\", 4.5]]], [\\"p2\\", \\"2023-07-20\\", [[\\"delivery\\", 4.0], [\\"service\\", 4.5]]], [\\"p1\\", \\"2023-08-10\\", [[\\"quality\\", 4.8], [\\"delivery\\", 4.2]]] ] start_date, end_date = \\"2023-05-01\\", \\"2023-06-30\\" summarized_reviews = summarize_reviews(reviews, start_date, end_date) print(summarized_reviews) # Output: {\'p1\': {\'quality\': 3.75, \'delivery\': 5.0, \'packaging\': 4.5}} ```","solution":"from datetime import datetime from collections import defaultdict def summarize_reviews(reviews, start_date, end_date): Summarize customer reviews by product and aspect within a specified date range. Parameters: - reviews: A list of lists where each sublist contains [product_id, review_date, aspects] and aspects is a list of [aspect_name, score]. - start_date: The start date of the time range as a string in \'YYYY-MM-DD\' format. - end_date: The end date of the time range as a string in \'YYYY-MM-DD\' format. Returns: - A dictionary where keys are product_ids, and values are dictionaries with aspect names as keys and average scores as values. # Convert start_date and end_date to datetime objects for comparison start_date = datetime.strptime(start_date, \\"%Y-%m-%d\\") end_date = datetime.strptime(end_date, \\"%Y-%m-%d\\") # Initialize a nested dictionary to accumulate scores and counts product_aspects = defaultdict(lambda: defaultdict(list)) # Filter and accumulate reviews within the date range for product_id, review_date, aspects in reviews: review_date = datetime.strptime(review_date, \\"%Y-%m-%d\\") if start_date <= review_date <= end_date: for aspect_name, score in aspects: product_aspects[product_id][aspect_name].append(score) # Compute the average score for each aspect of each product summarized_reviews = {} for product_id, aspect_scores in product_aspects.items(): summarized_reviews[product_id] = {} for aspect_name, scores in aspect_scores.items(): average_score = sum(scores) / len(scores) summarized_reviews[product_id][aspect_name] = average_score return summarized_reviews"},{"question":"# Question: Identify Cyclic Patterns in Linked List Background: Understanding and detecting cycles in linked lists is crucial for many applications such as dealing with slow algorithms, avoiding infinite loops, and handling memory more efficiently. Problem Statement: Write a function `detect_cycle(head: Optional[ListNode]) -> bool` that determines if a given singly linked list contains a cycle. Input: * `head`: The head of a singly linked list (ListNode), where each node has: - `val`: Integer representing the value of the node. - `next`: Pointer to the next node in the linked list or None. Output: * Return a boolean value indicating whether the linked list contains a cycle (`True` if it does, `False` otherwise). Example: ```python Input: head = ListNode(3, ListNode(2, ListNode(0, ListNode(-4)))) head.next.next.next.next = head.next Output: True ``` Explanation: 1. The given linked list structure corresponds to: 3 -> 2 -> 0 -> -4 2. The node with value `-4` will point back to the node with value `2`, creating a cycle. 3. Therefore, calling `detect_cycle(head)` will return `True`. Constraints: - The number of nodes in the list is in the range `[0, 10^4]`. - `-10^5 ≤ Node.val ≤ 10^5` - You are not allowed to modify the linked list. - The effective speed and space complexity should be aimed for O(n). Extra Information: - **Finding a cycle in a linked list:** Use Floyd\'s Tortoise and Hare algorithm, which utilizes two pointers moving at different speeds to detect a cycle efficiently. Implementation Guide: 1. **Initialization**: - Define two pointers, slow (tortoise) and fast (hare), both starting at the head of the linked list. 2. **Traversal**: - Move the slow pointer one step at a time. - Move the fast pointer two steps at a time. 3. **Cycle Detection**: - If the fast pointer meets the slow pointer at any point, a cycle exists. - If fast pointer reaches the end (`None`), no cycle exists. --- Implement the function `detect_cycle(head: Optional[ListNode]) -> bool` in Python. ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def detect_cycle(head: ListNode) -> bool: if not head: return False slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def detect_cycle(head: ListNode) -> bool: if not head: return False slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"# Matrix Anti-Diagonal Traversal Context: You\'re tasked with developing a function to retrieve elements from a matrix in an anti-diagonal order. This technique can be used in image processing, data restructuring, or any application requiring non-standard matrix traversal patterns. Problem Statement: Write a function `anti_diagonal(matrix: List[List[int]]) -> List[List[int]]` that takes a 2D list (matrix) of integers and returns a list of lists where each inner list contains elements of the matrix in an anti-diagonal order. The anti-diagonal order starts from the top-left corner of the matrix and proceeds diagonally down and to the right. Input: - A 2D list `matrix` of integers, where the number of rows and columns can be different (non-square matrix). Output: - A list of lists, where each list represents the elements in one anti-diagonal. Constraints: - The elements within the matrix are integers. - The function should handle edge cases, including empty matrices and single-element matrices. Examples: ``` >>> anti_diagonal([]) [] >>> anti_diagonal([[1]]) [[1]] >>> anti_diagonal([[1, 2], [3, 4]]) [[1],[2,3],[4]] >>> anti_diagonal([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1],[2,4],[3,5,7],[6,8],[9]] >>> anti_diagonal([[1, 2, 3, 4], [5, 6, 7, 8]]) [[1], [2, 5], [3, 6], [4, 7], [8]] ``` Performance Requirements: - The function should execute efficiently with respect to both time and space complexities. Implementation Challenge: - Implement the function considering the matrix dimensions can vary. Ensure that the function works for edge cases such as empty matrices and single-element matrices.","solution":"from typing import List def anti_diagonal(matrix: List[List[int]]) -> List[List[int]]: Returns the elements of the matrix in anti-diagonal order. Parameters: matrix (List[List[int]]): 2D list of integers. Returns: List[List[int]]: List of lists where each list contains elements in one anti-diagonal. if not matrix: return [] m, n = len(matrix), len(matrix[0]) result = [] # There are m + n - 1 anti-diagonals in total for diag in range(m + n - 1): current_anti_diagonal = [] # The starting point for each diagonal row = 0 if diag < n else (diag - n + 1) col = diag if diag < n else n - 1 while row < m and col >= 0: current_anti_diagonal.append(matrix[row][col]) row += 1 col -= 1 result.append(current_anti_diagonal) return result"},{"question":"# Implement a Singly Linked List You are required to implement a singly linked list data structure. A singly linked list is a collection of nodes where each node contains a value and a reference to the next node in the sequence. Implement the class `SinglyLinkedList` with the following methods: Requirements: 1. **add(value: int) -> None**: Appends an integer `value` to the end of the list. 2. **remove(value: int) -> bool**: Removes the first occurrence of the specified integer `value` from the list. Returns `True` if the value was found and removed, otherwise returns `False`. 3. **contains(value: int) -> bool**: Checks if the specified integer `value` is present in the list. Returns `True` if found, otherwise returns `False`. 4. **to_list() -> list**: Converts the linked list to a regular Python list containing all its values in order. Constraint: - The class should manage the nodes internally and handle edge cases such as removing from an empty list or checking for a value in an empty list. Example: ```python linked_list = SinglyLinkedList() linked_list.add(1) linked_list.add(2) linked_list.add(3) print(linked_list.to_list()) # Output: [1, 2, 3] print(linked_list.contains(2)) # Output: True print(linked_list.remove(2)) # Output: True print(linked_list.to_list()) # Output: [1, 3] print(linked_list.contains(2)) # Output: False print(linked_list.remove(4)) # Output: False print(linked_list.to_list()) # Output: [1, 3] ``` **Note**: Ensure your implementation does not use any external libraries for managing the linked list; it should be built from scratch.","solution":"class Node: def __init__(self, value): self.value = value self.next = None class SinglyLinkedList: def __init__(self): self.head = None def add(self, value: int) -> None: new_node = Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def remove(self, value: int) -> bool: current = self.head previous = None while current is not None: if current.value == value: if previous is None: self.head = current.next else: previous.next = current.next return True previous = current current = current.next return False def contains(self, value: int) -> bool: current = self.head while current is not None: if current.value == value: return True current = current.next return False def to_list(self) -> list: elements = [] current = self.head while current: elements.append(current.value) current = current.next return elements"},{"question":"# Question You are given a matrix of integers where each row and each column are sorted in ascending order. Write two functions to: 1. Search for an integer in the matrix. 2. Find the smallest element greater than a given integer. Requirements - Implement the function `search_matrix(matrix: list, target: int) -> bool`: * This function should return `True` if the target integer is found in the matrix, else return `False`. * If the input is not a matrix (i.e., a list of lists) or if any of the elements are not integers, raise a `ValueError`. - Implement the function `smallest_greater(matrix: list, target: int) -> int`: * This function should return the smallest integer in the matrix that is greater than the target integer. * If no such integer exists, return `None`. * If the input is not a matrix (i.e., a list of lists) or if any of the elements are not integers, raise a `ValueError`. Input Format * `matrix`: A list of lists where each inner list represents a row of the matrix, and each element is an integer. * `target`: An integer to search for in the matrix. Output Format * `search_matrix`: Return a boolean value indicating if the target integer is present in the matrix. * `smallest_greater`: Return an integer value that is the smallest element greater than the target, or `None` if no such element exists. # Examples ```python >>> search_matrix([[1, 4, 7], [2, 5, 8], [3, 6, 9]], 5) True >>> search_matrix([[1, 4, 7], [2, 5, 8], [3, 6, 9]], 10) False >>> search_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 7) True >>> smallest_greater([[1, 4, 7], [2, 5, 8], [3, 6, 9]], 5) 6 >>> smallest_greater([[1, 4, 7], [2, 5, 8], [3, 6, 9]], 8) 9 >>> smallest_greater([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 9) None ``` Constraints * Each inner list (row) and each column are sorted in ascending order. * The matrix will contain at least one row and one column. * The functions must handle erroneous inputs gracefully by raising `ValueError` with appropriate messages. Additional Information Solving these problems requires an understanding of matrix traversal techniques and efficient searching algorithms, particularly binary search. This is useful in optimizing searches and leveraging the sorted property of rows and columns.","solution":"def search_matrix(matrix: list, target: int) -> bool: Searches for the target integer in a matrix of integers where each row and each column are sorted in ascending order. if not all(isinstance(row, list) for row in matrix) or not all(isinstance(x, int) for row in matrix for x in row): raise ValueError(\\"Invalid matrix. It should be a list of lists of integers.\\") if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False def smallest_greater(matrix: list, target: int) -> int: Finds the smallest integer in the matrix that is greater than the target integer. if not all(isinstance(row, list) for row in matrix) or not all(isinstance(x, int) for row in matrix for x in row): raise ValueError(\\"Invalid matrix. It should be a list of lists of integers.\\") smallest = None for row in matrix: for element in row: if element > target: if smallest is None or element < smallest: smallest = element return smallest"},{"question":"# Question: Efficiently Finding the Most Frequent Elements in an Array **Context:** You need to implement a function that identifies and returns the most frequent elements in an array of integers. This is a common problem that tests your understanding of data structures, algorithm efficiency, and edge case handling. **Objective:** Implement a function `find_most_frequent_elements` that returns the elements that appear most frequently in a given array. If multiple elements have the same highest frequency, return all such elements. **Specifications:** * **Function Signature**: `def find_most_frequent_elements(arr: List[int]) -> List[int]:` * **Inputs**: * `arr`: A list of integers which may contain duplicates. * **Output**: * A list of the most frequent elements in `arr`. * **Constraints**: * If `arr` is empty, return an empty list. * The elements in the result list must be in ascending order. * You may assume the input list can have up to 10^6 elements. Here is a sample output: ```python assert find_most_frequent_elements([1, 3, 2, 1, 4, 3, 5, 3, 1]) == [1, 3] assert find_most_frequent_elements([5, 5, 5, 1, 2, 2, 2, 3]) == [2, 5] assert find_most_frequent_elements([]) == [] ``` # Testing: Ensure to test the function with the following scenarios: * Normal case where multiple elements have the same highest frequency. * Case with a single most frequent element. * Edge case with an empty list. * Case with all unique elements. # Notes: - Optimize for time complexity considering the constraints. - Use appropriate data structures to efficiently keep track of frequencies and manage elements.","solution":"from typing import List from collections import Counter def find_most_frequent_elements(arr: List[int]) -> List[int]: Given a list of integers, returns a list of the most frequent elements in ascending order. Parameters: arr (List[int]): A list of integers which may contain duplicates. Returns: List[int]: A list of the most frequent elements in ascending order. if not arr: return [] # Count the frequency of each element in the array freq_counter = Counter(arr) # Find the maximum frequency max_freq = max(freq_counter.values()) # Extract the elements with the maximum frequency most_frequent = [k for k, v in freq_counter.items() if v == max_freq] # Return the elements sorted in ascending order return sorted(most_frequent)"},{"question":"# Question Implement a function `critical_connections` that determines all critical connections (also known as bridges) in a connected, undirected graph. A critical connection is an edge in the graph that, if removed, would cause one or more nodes to become disconnected from the graph. **Function Signature**: ```python def critical_connections(n: int, connections: list[tuple[int, int]]) -> list[tuple[int, int]]: ``` **Input**: - `n` (int): The number of nodes in the graph. - `connections` (list of tuples): Each tuple `(u, v)` represents an undirected edge between nodes `u` and `v`. **Output**: - A list of tuples, where each tuple `(u, v)` represents a critical connection. **Constraints**: - 2 <= n <= 10^5 - `n-1` <= len(connections) <= `10^5` - Each node is uniquely identified by an integer from 0 to n-1. - It is guaranteed that the input graph is connected. # Examples ```python # Example 1 n = 4 connections = [(0, 1), (1, 2), (2, 0), (1, 3)] print(critical_connections(n, connections)) # Output: [(1, 3)] # Example 2 n = 5 connections = [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4)] print(critical_connections(n, connections)) # Output: [(1, 3), (3, 4)] # Example 3 n = 6 connections = [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4), (4, 5), (5, 3)] print(critical_connections(n, connections)) # Output: [(1, 3)] ``` **Notes**: - Use Tarjan\'s algorithm for finding bridges in an undirected graph, which involves DFS traversal while maintaining `discovery` and `low` arrays for each node. - Ensure to test edge scenarios, such as cases with minimum and maximum connections and varying node degrees. - The output list of critical connections can be returned in any order.","solution":"from collections import defaultdict def critical_connections(n: int, connections: list[tuple[int, int]]) -> list[tuple[int, int]]: def dfs(node, parent, discovery_time, low_time, visited, disc, low, graph, bridges): visited[node] = True disc[node] = discovery_time low[node] = discovery_time discovery_time += 1 for neighbor in graph[node]: if not visited[neighbor]: dfs(neighbor, node, discovery_time, low_time, visited, disc, low, graph, bridges) low[node] = min(low[node], low[neighbor]) if low[neighbor] > disc[node]: bridges.append((node, neighbor)) elif neighbor != parent: low[node] = min(low[node], disc[neighbor]) graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) discovery_time = 0 disc = [-1] * n low = [-1] * n visited = [False] * n bridges = [] for i in range(n): if not visited[i]: dfs(i, -1, discovery_time, low, visited, disc, low, graph, bridges) return bridges"},{"question":"# Linear Regression Categorical Feature Coding Question You are given a dataset containing details of employees, including their job role (categorical), years of experience, and their respective salaries in USD. Your task is to implement a function using Linear Regression that trains on these features to predict salaries while properly handling the categorical feature. **Function Implementation:** 1. **Function Signature**: `def linear_regression_predict(data: dict) -> np.ndarray:` 2. **Input**: The input will be a dictionary with two keys, - `data`: A list of lists where each inner list contains the job role (string) and years of experience (float) of an employee. - `target`: A list of salaries corresponding to each list of features in `data`. 3. **Process**: * Convert the categorical job role feature into numerical representations using one-hot encoding. * Split the dataset into training and testing sets using an 80-20 ratio for training and testing respectively. * Train the Linear Regression model using the training dataset. * Predict the salaries for the test dataset. 4. **Output**: A numpy array containing the predicted salaries for the test dataset. **Constraints**: * Ensure that all necessary preprocessing of the data is performed within the function. * Handle categorical features appropriately using one-hot encoding. * Use appropriate methods to evaluate the model, such as Mean Absolute Error (MAE) and Mean Square Error (MSE). **Example**: ```python >>> data = { ... \\"data\\": [ ... [\\"Software Engineer\\", 5.0], ... [\\"Data Scientist\\", 3.0], ... [\\"Product Manager\\", 10.0], ... [\\"Software Engineer\\", 2.0], ... # Add more feature sets ... ], ... \\"target\\": [120000.0, 98000.0, 150000.0, 70000.0, # Add more target salaries ... ] ... } >>> linear_regression_predict(data) array([119000.0, 95000.0, 148000.0, 68000.0]) # Example output representing predicted salaries (not actual) ``` **Note**: The example provided in the main function of the code snippet is based on a hypothetical dataset. Refer to this example for guidance on processing and feature handling. Good luck, and ensure your solution is well-tested across multiple scenarios to validate its robustness!","solution":"import numpy as np import pandas as pd from sklearn.model_selection import train_test_split from sklearn.linear_model import LinearRegression from sklearn.preprocessing import OneHotEncoder from sklearn.metrics import mean_absolute_error, mean_squared_error def linear_regression_predict(data: dict) -> np.ndarray: # Extract features and target values features = data[\'data\'] target = data[\'target\'] # Convert features to DataFrame df = pd.DataFrame(features, columns=[\'job_role\', \'years_experience\']) # One-hot encode the categorical feature \'job_role\' encoder = OneHotEncoder() encoded_features = encoder.fit_transform(df[\'job_role\'].values.reshape(-1, 1)).toarray() # Create a DataFrame with the encoded features and concatenate the years_experience encoded_feature_names = encoder.get_feature_names_out([\'job_role\']) encoded_df = pd.DataFrame(encoded_features, columns=encoded_feature_names) final_df = pd.concat([encoded_df, df[\'years_experience\']], axis=1) # Split into training and testing data (80-20 split) X_train, X_test, y_train, y_test = train_test_split(final_df, target, test_size=0.2, random_state=42) # Initialize and train the Linear Regression model model = LinearRegression() model.fit(X_train, y_train) # Predict the salaries for the test dataset y_pred = model.predict(X_test) # Calculate evaluation metrics for the model mae = mean_absolute_error(y_test, y_pred) mse = mean_squared_error(y_test, y_pred) print(f\\"Mean Absolute Error: {mae}\\") print(f\\"Mean Squared Error: {mse}\\") return y_pred"},{"question":"# Problem Statement Alice is playing a card game with a deck comprising 5 suits, each suit containing 13 cards numbered from 1 to 13. A total of 65 cards. There are no jokers. Alice draws a hand of 7 cards at random from this deck. She wins if her hand contains at least one card from each suit. Write a program that calculates the probability that Alice wins the game by drawing at least one card from each of the 5 different suits. The answer should be rounded to seven decimal places. # Requirements: 1. Implement a function `probability_alice_wins()` that returns the probability that Alice\'s hand contains at least one card from each suit. 2. Do not use any external libraries except for `itertools`. 3. Ensure the implementation handles the computation efficiently within the constraints. # Inputs and Outputs: - **Input**: No input is required for this function. - **Output**: A single float value representing the probability rounded to seven decimal places. # Function Signature ```python def probability_alice_wins() -> float: pass ``` # Example ```python def probability_alice_wins() -> float: ... print(probability_alice_wins()) # Expected output: 0.0012345 (The actual value will vary based on the exact probability calculation) ``` # Constraints: 1. The probability should be computed by considering all possible card combinations. 2. The returned result must be rounded to seven decimal places. 3. The solution should be efficient, considering the relatively large state space. # Notes: - You may find it useful to use combinatorial methods to compute the possible ways of drawing the cards. - Consider edge cases such as the minimum and maximum number of cards drawn to ensure accuracy. - Use Python\'s `itertools.combinations` to handle the generation of possible hand combinations when necessary.","solution":"import itertools from math import comb def probability_alice_wins() -> float: total_cards = 65 suits = 5 cards_per_suit = 13 cards_to_draw = 7 def nCr(n, r): return comb(n, r) total_combinations = nCr(total_cards, cards_to_draw) def unsuccessful_combinations(): unsuccessful = 0 for no_of_suits_lacking in range(1, suits): remove_combo = nCr(suits, no_of_suits_lacking) remaining_cards = total_cards - (no_of_suits_lacking * cards_per_suit) remaining_hand_combinations = nCr(remaining_cards, cards_to_draw) if no_of_suits_lacking % 2 == 1: unsuccessful += remove_combo * remaining_hand_combinations else: unsuccessful -= remove_combo * remaining_hand_combinations return unsuccessful successful_combinations = total_combinations - unsuccessful_combinations() probability = successful_combinations / total_combinations return round(probability, 7)"},{"question":"# Problem Statement You are given a list of integers, and you need to find the length of the longest subsequence such that every element in the subsequence is a power of two. Implement a function `longest_power_of_two_subsequence(arr)` that finds the length of the longest subsequence where every element is a power of two. # Function Signature ```python def longest_power_of_two_subsequence(arr: list[int]) -> int: pass ``` # Input * `arr` (list[int]): A list of integers. # Output * Returns an integer representing the length of the longest subsequence where every element is a power of two. # Constraints * The length of `arr` is between 1 and 1000. * The elements in `arr` are positive integers up to 10^9. # Example ```python longest_power_of_two_subsequence([3, 6, 4, 8, 2, 16, 5]) == 4 # The valid subsequence is [4, 8, 2, 16] longest_power_of_two_subsequence([1, 2, 3, 5, 7]) == 2 # The valid subsequence is [1, 2] ``` # Additional Notes A power of two is a number of the form 2^n where n is a non-negative integer. For example, 1, 2, 4, 8, 16, etc. The function should find the longest subsequence that consists exclusively of such numbers. # Performance Requirements The solution should be optimized to handle the constraints efficiently by ensuring the algorithm checks each number whether it is a power of two and keeps track of the longest subsequence. # Algorithm 1. Initialize a variable to keep track of the longest length. 2. Iterate through the elements in the list and check if each element is a power of two. 3. Maintain a count of the valid elements found. 4. Return the count as the length of the longest subsequence with powers of two. # Edge Cases * Handle an array filled with a single element. * Ensure the function works for a variety of inputs, including arrays with no powers of two and arrays where every element is a power of two.","solution":"def longest_power_of_two_subsequence(arr: list[int]) -> int: def is_power_of_two(n: int) -> bool: # A number is a power of two if it is greater than zero and its only set bit is a 1 return (n > 0) and (n & (n - 1)) == 0 longest_length = 0 for num in arr: if is_power_of_two(num): longest_length += 1 return longest_length"},{"question":"# Twitter Sentiment Analysis You are working on developing a Twitter sentiment analysis tool that can classify tweets as positive, negative, or neutral. For this task, you need to implement a basic version of the sentiment analysis algorithm using the Bag of Words (BoW) model. The tool will use a predefined vocabulary and classify sentiments based on the occurrence of positive, negative, and neutral words in a tweet. Task Description: Implement a function `classify_tweet_sentiment` that: - Takes as input: * `tweet` (str): The text of the tweet. * `vocabulary` (dict): A dictionary where keys are words and values are their associated sentiment scores. Positive words have positive scores, negative words have negative scores, and neutral words have a score of zero. - Returns: * A string representing the sentiment of the tweet: \\"positive\\", \\"negative\\", or \\"neutral\\". Constraints: - Input tweet will not exceed 280 characters. - The vocabulary dictionary will contain at least 10 words. - Ensure the function is case-insensitive when classifying words. - Handle edge cases such as empty tweets or tweets without any recognizable vocabulary words. Example Usage: ```python >>> tweet = \\"I love sunny days but I hate rain.\\" >>> vocabulary = { \\"love\\": 2, \\"sunny\\": 1, \\"days\\": 0, \\"but\\": 0, \\"hate\\": -2, \\"rain\\": -1 } >>> classify_tweet_sentiment(tweet, vocabulary) \'neutral\' ``` Notes - If the sum of the sentiment scores is positive, the tweet is classified as \\"positive\\". - If the sum is negative, the classification is \\"negative\\". - If the sum is zero, the classification is \\"neutral\\". - Use simple string operations for processing words in the tweet.","solution":"import re def classify_tweet_sentiment(tweet, vocabulary): Classify the sentiment of a tweet based on a predefined vocabulary. Parameters: - tweet (str): The text of the tweet. - vocabulary (dict): Dictionary with words as keys and sentiment scores as values. Returns: - str: The sentiment of the tweet: \\"positive\\", \\"negative\\", or \\"neutral\\". words = re.findall(r\'bw+b\', tweet.lower()) sentiment_score = sum(vocabulary.get(word, 0) for word in words) if sentiment_score > 0: return \\"positive\\" elif sentiment_score < 0: return \\"negative\\" else: return \\"neutral\\""},{"question":"# Question You are tasked with creating a function that determines whether it is possible to transform one given string into another by a series of single character replacements, such that each intermediate string formed during the transformation is a valid English word. You will be provided access to an English dictionary with a function `is_valid_word`, which returns `True` if the input is a valid word and `False` otherwise. **Function Signature:** ```python def can_transform(start: str, end: str, dictionary_function) -> bool: Determines if it is possible to transform the start string into the end string by replacing one character at a time, where each intermediate string is a valid English word. Parameters: start (str): The initial string. end (str): The target string. dictionary_function (Callable[[str], bool]): Function to validate English words. Returns: bool: True if the transformation is possible, otherwise False. pass ``` **Input:** - `start` (str): An input string of length n. - `end` (str): A target string of length n. - `dictionary_function` (Callable): A function that takes a single string argument and returns `True` if the string is a valid English word; `False` otherwise. **Output:** - A boolean value indicating whether the transformation is possible. **Constraints:** - The length of `start` and `end` will be between 1 and 100, inclusive. - All characters in `start` and `end` are lowercase English letters. - `start` and `end` are the same length. - dictionary_function can be called as many times as necessary. **Example:** ```python def is_valid_word(word): # Placeholder dictionary function to simulate a real dictionary check. valid_words = {\\"cat\\", \\"bat\\", \\"cot\\", \\"cog\\", \\"dog\\"} return word in valid_words >>> can_transform(\\"cat\\", \\"dog\\", is_valid_word) True # Possible transformation sequences: \\"cat\\" -> \\"cot\\" -> \\"cog\\" -> \\"dog\\" >>> can_transform(\\"cat\\", \\"bat\\", is_valid_word) True # Transformation sequence is \\"cat\\" -> \\"bat\\" >>> can_transform(\\"cat\\", \\"cot\\", is_valid_word) True # Transformation sequence is \\"cat\\" -> \\"cot\\" >>> can_transform(\\"cat\\", \\"cog\\", is_valid_word) False # No valid transformation sequence to change \\"cat\\" to \\"cog\\" ``` **Instructions:** 1. Implement the `can_transform` function according to the specified requirements. 2. The solution should efficiently check for possible single-letter transformations. 3. Ensure the solution handles scenarios where valid transformations are not possible.","solution":"from collections import deque def can_transform(start: str, end: str, dictionary_function) -> bool: Determines if it is possible to transform the start string into the end string by replacing one character at a time, where each intermediate string is a valid English word. Parameters: start (str): The initial string. end (str): The target string. dictionary_function (Callable[[str], bool]): Function to validate English words. Returns: bool: True if the transformation is possible, otherwise False. if start == end: return dictionary_function(start) def generate_neighbors(word): for i in range(len(word)): for char in \'abcdefghijklmnopqrstuvwxyz\': if word[i] != char: new_word = word[:i] + char + word[i+1:] if dictionary_function(new_word): yield new_word queue = deque([(start, 0)]) visited = set([start]) while queue: current_word, depth = queue.popleft() for neighbor in generate_neighbors(current_word): if neighbor == end: return True if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, depth + 1)) return False"},{"question":"# Question Implement a Python function called `canonical_path` that takes an absolute path of a file or directory in a Unix-style file system and converts it to its canonical form. The canonical path should not contain any `.` (current directory) or `..` (parent directory) references, and it should be as short as possible. Function Signature ```python def canonical_path(path: str) -> str: pass ``` Input * `path`: A string representing the absolute path of a file or directory in a Unix-style file system. Output * Returns the canonical form of the given path as a string. Constraints * The path is a non-empty string consisting of letters, digits, periods, forward slashes `/`, and underscores `_`. Example ```python >>> canonical_path(\\"/home/\\") \'/home\' >>> canonical_path(\\"/../\\") \'/\' >>> canonical_path(\\"/home//foo/\\") \'/home/foo\' >>> canonical_path(\\"/a/./b/../../c/\\") \'/c\' >>> canonical_path(\\"/a/../../b/../c//.//\\") \'/c\' >>> canonical_path(\\"/a//b////c/d//././/..\\") \'/a/b/c\' ``` Notes * Any leading or trailing forward slashes in the input path should be preserved. * Multiple consecutive slashes (`/`) should be treated as a single slash. * Ensure to handle scenarios with `.` and `..` accurately, maintaining the root directory as the starting point if needed. This question assesses the understanding of string manipulation and path normalization, requiring a precise handling of special characters and directory references in a Unix-style file system.","solution":"def canonical_path(path: str) -> str: components = path.split(\'/\') stack = [] for component in components: if component == \'..\': if stack: stack.pop() elif component != \'.\' and component != \'\': stack.append(component) return \'/\' + \'/\'.join(stack)"},{"question":"# Coding Assessment Question Scenario: You are required to develop an efficient function to compute the binomial coefficient, also known as \\"n choose k\\" or ( binom{n}{k} ), which is a common problem in combinatorics and statistics. Problem Statement: Implement a Python function `binomial_coefficient(n: int, k: int) -> int` that computes the binomial coefficient for given integers `n` and `k`. Requirements: 1. The function should validate that `n` and `k` are integers. 2. Non-integer and non-numeric inputs should raise a `TypeError`. 3. If `k` is greater than `n` or if either `n` or `k` is negative, the function should return 0. 4. The function should compute the binomial coefficient using an efficient approach, not exceeding (O(k)) complexity. Input: - Two integers `n` and `k`. Output: - An integer representing the value of the binomial coefficient ( binom{n}{k} ). Constraints: - Your solution should be efficient and implement a direct computation method. - Avoid naive recursive or combinatorial approaches which may lead to large intermediate results. Function Signature: ```python def binomial_coefficient(n: int, k: int) -> int: ``` Example Cases: ```python assert binomial_coefficient(5, 2) == 10 assert binomial_coefficient(10, 3) == 120 assert binomial_coefficient(0, 0) == 1 assert binomial_coefficient(5, 6) == 0 assert binomial_coefficient(-5, 3) == 0 assert binomial_coefficient(20, 10) == 184756 ``` Additional Information: - Factorials or other combinatorial functions should be implemented efficiently to avoid intermediate overflow. - Consider edge cases, such as when n or k are 0, and ensure production-level robustness in your code. Implement the `binomial_coefficient` function as per the outlined requirements.","solution":"def binomial_coefficient(n: int, k: int) -> int: Calculate the binomial coefficient \\"n choose k\\" which is the number of ways to choose k elements from a set of n elements. if not isinstance(n, int) or not isinstance(k, int): raise TypeError(\\"n and k must be integers.\\") if n < 0 or k < 0 or k > n: return 0 # Apply the property C(n, k) == C(n, n-k) if k > n - k: k = n - k # Compute C(n, k) using an iterative approach to avoid overflow result = 1 for i in range(k): result = result * (n - i) // (i + 1) return result"},{"question":"**[Question 2]:** Write a function `connected_components` that finds all the connected components in an undirected graph provided as an adjacency list. The function should return a list of lists, where each list represents a connected component, and each node appears in exactly one component. # Requirements: 1. The function should accept a dictionary representing an adjacency list of the graph. 2. The returned list should contain lists of nodes, each list representing one connected component. 3. The nodes in each component list should be sorted in ascending order. 4. The function should visit each node only once using an appropriate graph traversal algorithm (BFS or DFS). # Function Signature: ```python def connected_components(graph: dict) -> list: Input Parameters ---------------- graph : dict A dictionary representing the adjacency list of an undirected graph. The keys are nodes, and the values are lists of adjacent nodes. Returns ------- result : list A list of lists, where each sublist represents a connected component in the graph. Each sublist contains nodes sorted in ascending order. Examples -------- >>> graph = { ... 1: [2], ... 2: [1, 3], ... 3: [2], ... 4: [5], ... 5: [4] ... } >>> connected_components(graph) [[1, 2, 3], [4, 5]] >>> graph = { ... 1: [2, 3], ... 2: [1], ... 3: [1], ... 4: [] ... } >>> connected_components(graph) [[1, 2, 3], [4]] pass ``` # Constraints: * The graph is undirected and does not contain self-loops or multiple edges between two nodes. * The nodes are represented as integers. * The adjacency list is comprehensive, meaning if an edge exists between node `a` and node `b`, both `a` and `b` must appear in the dictionary. * The function must handle graphs with isolated nodes (nodes with no edges).","solution":"def connected_components(graph: dict) -> list: Returns a list of lists, where each list represents a connected component. Each node appears in exactly one component, and the nodes in each component list are sorted in ascending order. Parameters: graph (dict): A dictionary representing the adjacency list of the graph. Returns: list: A list of lists, each sublist representing a connected component. def dfs(node, visited, component): stack = [node] while stack: v = stack.pop() if v not in visited: visited.add(v) component.append(v) for neighbor in graph[v]: if neighbor not in visited: stack.append(neighbor) visited = set() components = [] for node in graph: if node not in visited: component = [] dfs(node, visited, component) components.append(sorted(component)) return components"},{"question":"# Coding Assessment Question **Context**: As part of your implementation of a custom data analysis library, you need to develop a specialized function for handling missing data. Specifically, you\'ll create an imputation function that fills missing values in a dataframe column using the median of its non-missing values. This function is crucial for ensuring the integrity and reliability of your analyses. **Task**: Write a function `impute_missing_values` that fills the missing values (NaNs) in a specified column of a pandas dataframe with the median of the non-missing values in that column. Function Signature: ```python def impute_missing_values(df: pd.DataFrame, column: str) -> pd.DataFrame: ``` Parameters: * `df` (pd.DataFrame): The input pandas dataframe containing the data. * `column` (str): The name of the column in which to impute missing values. Returns: * `pd.DataFrame`: A pandas dataframe with the missing values in the specified column imputed. Example: ```python import pandas as pd import numpy as np data = { \'A\': [1, 2, np.nan, 4, 5], \'B\': [np.nan, 2, 3, np.nan, 5] } df = pd.DataFrame(data) # Apply the imputation function imputed_df = impute_missing_values(df, \'A\') print(imputed_df) # Expected output: # A B # 0 1.0 NaN # 1 2.0 2.0 # 2 3.0 3.0 # 3 4.0 NaN # 4 5.0 5.0 ``` # Constraints: * The input dataframe can have both numeric and non-numeric columns, but the imputation target column will always be numeric. * Ensure the function handles dataframes with a large number of rows efficiently. * If the target column contains only NaNs, return the dataframe unchanged. * Handle edge cases where the column might be empty or contains no non-missing values. Additional Information: Use `pandas` and `numpy` libraries to implement the solution.","solution":"import pandas as pd import numpy as np def impute_missing_values(df: pd.DataFrame, column: str) -> pd.DataFrame: Fills the missing values (NaNs) in a specified column of a pandas dataframe with the median of the non-missing values in that column. Parameters: df (pd.DataFrame): The input pandas dataframe containing the data. column (str): The name of the column in which to impute missing values. Returns: pd.DataFrame: A pandas dataframe with the missing values in the specified column imputed. if column not in df.columns: raise ValueError(f\\"Column \'{column}\' not found in dataframe.\\") median_value = df[column].median() df[column] = df[column].fillna(median_value) return df"},{"question":"# Sentence Generation for Predictive Text You are tasked with implementing a predictive text algorithm that generates sentences based on a given prefix and a bigram language model. The sentence should terminate either when a termination token is reached or when a specified maximum length is achieved. # Requirements 1. Implement the function `bigram_model_generation(bigram_model: dict, prefix: str, max_length: int) -> str` that generates a sentence based on a given prefix and a bigram model. # Inputs - **bigram_model**: A dictionary where keys are words, and values are dictionaries of subsequent words and their probabilities. For example: ```python { \\"I\\": {\\"am\\": 0.5, \\"like\\": 0.5}, \\"am\\": {\\"a\\": 0.5, \\"the\\": 0.5}, \\"like\\": {\\"to\\": 1.0}, \\"a\\": {\\"student\\": 1.0}, \\"the\\": {\\"teacher\\": 1.0}, \\"to\\": {\\"code\\": 1.0}, \\"student\\": {\\".\\": 1.0}, \\"teacher\\": {\\".\\": 1.0}, \\"code\\": {\\".\\": 1.0} } ``` - **prefix**: A string consisting of one word to start the sentence. - **max_length**: An integer specifying the maximum length of the sentence including the prefix word. # Output - A string that represents the generated sentence. # Constraints 1. The prefix word must exist in the bigram model. 2. The sentence generation should stop either when a termination token `\'.\'` is appended or the maximum length is reached. 3. The probabilities in the bigram model\'s values sum up to 1 for each word. # Performance Requirements The implementation should perform efficiently but does not need to be optimized for large inputs. # Example ```python import random def bigram_model_generation(bigram_model: dict, prefix: str, max_length: int) -> str: if prefix not in bigram_model: raise ValueError(f\\"The prefix \'{prefix}\' is not in the bigram model.\\") generated_sentence = [prefix] current_word = prefix while len(generated_sentence) < max_length: if current_word not in bigram_model: break subsequent_words = bigram_model[current_word] next_word = random.choices(list(subsequent_words.keys()), list(subsequent_words.values()))[0] generated_sentence.append(next_word) if next_word == \'.\': break current_word = next_word return \' \'.join(generated_sentence) # Example Usage: bigram_model = { \\"I\\": {\\"am\\": 0.5, \\"like\\": 0.5}, \\"am\\": {\\"a\\": 0.5, \\"the\\": 0.5}, \\"like\\": {\\"to\\": 1.0}, \\"a\\": {\\"student\\": 1.0}, \\"the\\": {\\"teacher\\": 1.0}, \\"to\\": {\\"code\\": 1.0}, \\"student\\": {\\".\\": 1.0}, \\"teacher\\": {\\".\\": 1.0}, \\"code\\": {\\".\\": 1.0} } prefix = \\"I\\" max_length = 5 print(bigram_model_generation(bigram_model, prefix, max_length)) # Possible Output: \\"I am a student .\\" ``` # Explanation In this example, the prefix is `\\"I\\"` and the maximum length is 5 words including the prefix. The function generates a sentence such as `\\"I am a student .\\"` based on the provided bigram model probabilities. The choice between subsequent words (\\"am\\" or \\"like\\") and further sequence extension depends on the defined probabilities within the model.","solution":"import random def bigram_model_generation(bigram_model: dict, prefix: str, max_length: int) -> str: if prefix not in bigram_model: raise ValueError(f\\"The prefix \'{prefix}\' is not in the bigram model.\\") generated_sentence = [prefix] current_word = prefix while len(generated_sentence) < max_length: if current_word not in bigram_model: break subsequent_words = bigram_model[current_word] next_word = random.choices(list(subsequent_words.keys()), list(subsequent_words.values()))[0] generated_sentence.append(next_word) if next_word == \'.\': break current_word = next_word return \' \'.join(generated_sentence)"},{"question":"# Question Write a function, `level_sum_of_binary_tree`, that takes the root node of a binary tree and returns a list of the sums of the values at each level of the tree. **Function Signature**: ```python def level_sum_of_binary_tree(root: Node | None) -> list[int]: ``` # Input - `root` is the root of the binary tree. It can be `None` if the tree is empty. # Output - The function should return a list of integers, where each integer represents the sum of the nodes\' values at that level of the tree, starting from the root level. # Constraints - The number of nodes in the tree will be in the range [0, 1000]. - The value of nodes will be in the range [-1000, 1000]. # Examples ```python # Example 1 root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.right = Node(6) result = level_sum_of_binary_tree(root) print(result) # Expected Output: [1, 5, 15] # Example 2 root = None result = level_sum_of_binary_tree(root) print(result) # Expected Output: [] # Example 3 root = Node(100) result = level_sum_of_binary_tree(root) print(result) # Expected Output: [100] ``` # Notes - Ensure to handle the case when the tree is empty by returning an empty list. - Each level\'s sum should be within the range and should be returned in order from top to bottom. - Provide examples that cover different edge cases like single node tree and all children on one side tree.","solution":"from collections import deque class Node: def __init__(self, value): self.value = value self.left = None self.right = None def level_sum_of_binary_tree(root: Node | None) -> list[int]: if not root: return [] result = [] queue = deque([root]) while queue: level_sum = 0 level_size = len(queue) for _ in range(level_size): node = queue.popleft() level_sum += node.value if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_sum) return result"},{"question":"Given a binary search tree (BST), your task is to implement a function to find the `k`th largest element in the tree. Your implementation should perform an in-order traversal (right-to-left) to identify the required element efficiently. # Function Signature ```python def kth_largest_element(root: TreeNode, k: int) -> int: pass ``` # Input - `root`: A reference to the root node of the binary search tree. - `k`: An integer (1 ≤ k ≤ number of nodes in the BST) representing the kth largest element to find. # Output - Return the `k`th largest element in the BST. # Constraints 1. The number of nodes in the BST is between 1 and 10^5. 2. Each node\'s value is unique and fits within the range [-10^9, 10^9]. # Examples ```python assert kth_largest_element(create_bst([3,1,4,None,2]), 1) == 4 assert kth_largest_element(create_bst([5,3,6,2,4,None,None,1]), 3) == 4 assert kth_largest_element(create_bst([10,5,15,3,7,None,18]), 2) == 15 assert kth_largest_element(create_bst([2,1,3]), 3) == 1 assert kth_largest_element(create_bst([4,2,6,1,3,5,7]), 4) == 4 ``` # Additional Notes 1. The value in the kth position for the in-order right-to-left traversal of `[3, 1, 4, None, 2]` is `4` because the sorted order (descending) is `[4, 3, 2, 1]`. 2. For the BST `[5,3,6,2,4,None,None,1]`, an in-order right-to-left traversal would yield `[6, 5, 4, 3, 2, 1]`, so the 3rd largest element is `4`. 3. Use a helper function which does an in-order right-to-left traversal to ensure efficiency with large trees.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def kth_largest_element(root: TreeNode, k: int) -> int: def in_order_right_to_left(node): if node is None or len(elements) >= k: return if node.right: in_order_right_to_left(node.right) if len(elements) < k: elements.append(node.value) if node.left: in_order_right_to_left(node.left) elements = [] in_order_right_to_left(root) return elements[-1] def create_bst(values): if not values: return None nodes = [TreeNode(val) if val is not None else None for val in values] for index in range(1, len(nodes)): if nodes[index] is not None: parent_index = (index - 1) // 2 if index % 2 == 1: nodes[parent_index].left = nodes[index] else: nodes[parent_index].right = nodes[index] return nodes[0]"},{"question":"# Question: Implement a Simple Web Crawler Problem Statement: You are tasked with implementing a simple web crawler that extracts all unique URLs from a given webpage up to a certain depth. The crawler should visit each URL starting from the provided URL and continue upto the specified depth, collecting URLs at each step. Requirements: 1. Write a function `extract_urls(html_content: str) -> List[str]` that extracts and returns all unique URLs from the given HTML content as strings. Use regular expressions to find URLs wrapped in `<a>` tags. 2. Write the main function `web_crawler(start_url: str, depth: int) -> None` that initiates the crawling process from the `start_url` and continues up to the specified `depth`. Input Format: * A string `start_url`: The starting URL of the crawl. * An integer `depth`: The depth up to which the crawling should occur. Each level represents another layer of URLs from the start. Output Format: * Print all unique URLs found in the crawling process. Constraints: * `start_url` is a valid URL. * `0 <= depth <= 3` * The total number of unique URLs in any single site is at most 100. Example: Input: ``` Enter the starting URL: http://example.com Enter the crawl depth: 2 ``` Output: ``` http://example.com http://example.com/about http://example.com/contact http://example.com/blog ... ``` Implementation: ```python import requests import re from typing import List from urllib.parse import urljoin def extract_urls(html_content: str) -> List[str]: urls = re.findall(r\'<a [^>]*href=\\"([^\\"]+)\\"\', html_content) return list(set(urls)) def web_crawler(start_url: str, depth: int) -> None: visited = set() to_visit = {start_url} for _ in range(depth + 1): next_level = set() for url in to_visit: if url not in visited: visited.add(url) try: response = requests.get(url) response.raise_for_status() html_content = response.text except requests.RequestException: continue urls = extract_urls(html_content) full_urls = {urljoin(url, u) for u in urls} next_level.update(full_urls) to_visit = next_level - visited for url in visited: print(url) if __name__ == \\"__main__\\": start_url = input(\\"Enter the starting URL: \\") depth = int(input(\\"Enter the crawl depth: \\")) web_crawler(start_url, depth) ``` This question tests the candidate\'s ability to handle web requests, parse HTML, use regular expressions, and manage sets. The complexity lies in ensuring proper URL extraction and managing the crawl depth effectively, similar to the complexity in the previous problem of implementing network protocol simulations.","solution":"import requests import re from typing import List from urllib.parse import urljoin def extract_urls(html_content: str) -> List[str]: Extracts all unique URLs from the given HTML content. Args: html_content (str): A string containing the HTML content to parse. Returns: List[str]: A list of unique URLs found in the HTML content. urls = re.findall(r\'<a [^>]*href=\\"([^\\"]+)\\"\', html_content) return list(set(urls)) def web_crawler(start_url: str, depth: int) -> None: Initiates the crawling process from the start_url and continues up to the specified depth. Args: start_url (str): The starting URL of the crawl. depth (int): The depth up to which the crawling should occur. Returns: None: Prints all unique URLs found in the crawling process. visited = set() to_visit = {start_url} for _ in range(depth + 1): next_level = set() for url in to_visit: if url not in visited: visited.add(url) try: response = requests.get(url) response.raise_for_status() html_content = response.text except requests.RequestException: continue urls = extract_urls(html_content) full_urls = {urljoin(url, u) for u in urls} next_level.update(full_urls) to_visit = next_level - visited for url in visited: print(url)"},{"question":"# Coding Assessment Question Context As part of a data processing pipeline, you need to transform specific JSON data structures into a summarized tabular format for easier consumption. Question Write a Python function called `transform_data` that takes a list of JSON objects, each containing information about an employee. The function should transform this data into a list of lists, with each inner list containing specific attributes: `name`, `age`, `department`, and `salary`. The transformation should follow these steps: 1. Extract the `name`, `age`, `department`, and `salary` values from each JSON object. 2. Compile the extracted data into a list of lists format. Function Signature ```python def transform_data(employee_data: list[dict[str, any]]) -> list[list[any]]: pass ``` Input - `employee_data` (list): A list of JSON objects. Each JSON object represents an employee and contains attributes like `name`, `age`, `department`, and `salary`. Output - A list of lists, where each inner list contains the following elements in order: - `name` (str): The name of the employee. - `age` (int): The age of the employee. - `department` (str): The department the employee belongs to. - `salary` (float): The salary of the employee. Constraints - Assume the input list can contain between 1 and 1000 employee records. - Assume all JSON objects will have the required attributes (`name`, `age`, `department`, `salary`). - The function should handle cases where any attribute might be `None`. Example ```python # Example use case input_data = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"department\\": \\"Engineering\\", \\"salary\\": 100000.0}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"department\\": \\"Marketing\\", \\"salary\\": 70000.0}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"department\\": \\"Sales\\", \\"salary\\": 85000.0}, ] output_data = transform_data(input_data) print(output_data) # Output: [[\'Alice\', 30, \'Engineering\', 100000.0], [\'Bob\', 25, \'Marketing\', 70000.0], [\'Charlie\', 35, \'Sales\', 85000.0]] ``` Guidelines - Use standard Python data structures and methods to achieve the transformation. - Ensure the function is robust and can handle the `None` values appropriately. - Optimize the function for readability and performance.","solution":"def transform_data(employee_data): Transforms a list of employee JSON objects into a list of lists, containing specific attributes: name, age, department, and salary. Args: employee_data (list): A list of JSON objects. Each JSON object represents an employee and contains attributes like name, age, department, and salary. Returns: list: A list of lists containing the extracted data. transformed_data = [] for employee in employee_data: name = employee.get(\'name\') age = employee.get(\'age\') department = employee.get(\'department\') salary = employee.get(\'salary\') transformed_data.append([name, age, department, salary]) return transformed_data"},{"question":"# Task Create a function `most_frequent_char(s: str) -> str` that finds the most frequently occurring character in a given string. If there are multiple characters with the same maximum frequency, return the character that appears first in the string. # Function Signature ```python def most_frequent_char(s: str) -> str: pass ``` # Input - A string `s` (1 ≤ len(s) ≤ 100,000), containing only ASCII characters. # Output - A character representing the most frequently occurring character in the string. # Example ```python assert most_frequent_char(\\"abracadabra\\") == \'a\' assert most_frequent_char(\\"hello world\\") == \'l\' assert most_frequent_char(\\"aabbbccdde\\") == \'b\' assert most_frequent_char(\\"xyzzyx\\") == \'x\' ``` # Constraints - The function should efficiently handle the string operations even for the upper limit of string length. # Performance Requirements - The function must run efficiently for input strings up to 100,000 characters. Consider using data structures that support efficient character frequency counting and retrieval.","solution":"def most_frequent_char(s: str) -> str: Finds and returns the most frequently occurring character in the string s. If there are multiple characters with the same maximum frequency, returns the character that appears first in the string. from collections import Counter # Count the frequency of each character in the string count = Counter(s) # Find the character(s) with the maximum frequency max_freq = max(count.values()) # Return the first character in the string that has the maximum frequency for char in s: if count[char] == max_freq: return char"},{"question":"# Finding Minimum Time to Complete Projects You are given a list of projects and the dependencies between them, where each project depends on the completion of other projects before it can begin. Your task is to determine the minimum time required to complete all the projects. Each project takes exactly one unit of time to complete, and the start of the project is delayed until all its dependencies are completed. You must determine the minimum number of time units required to complete all projects given the dependencies. Function Signature ```python def minimum_time_to_complete_projects(n: int, dependencies: List[Tuple[int, int]]) -> int: ``` # Input * `n` (int): The number of projects. * `dependencies` (List[Tuple[int, int]]): A list of tuples where each tuple `(u, v)` indicates that project `v` depends on project `u` (project `u` must be completed before project `v` can start). # Output * Returns an integer representing the minimum number of time units required to complete all projects. # Constraints * (1 leq n leq 1000) * (0 leq text{number of dependencies} leq 5000) * There are no circular dependencies. * Projects are numbered from `0` to `n-1`. # Example ```python assert minimum_time_to_complete_projects(4, [(0, 1), (1, 2), (2, 3)]) == 4 assert minimum_time_to_complete_projects(5, [(0, 1), (0, 2), (1, 3), (2, 3), (3, 4)]) == 4 ``` # Requirements * Implement the function `minimum_time_to_complete_projects` using topological sorting to determine the order of project completion. * Ensure that the function handles edge cases, optimizes memory usage, and runs efficiently within the constraints. # Notes * You can assume the input represents a valid Directed Acyclic Graph (DAG). * Consider optimizing both the sorting and processing steps for better performance in dense graphs.","solution":"from typing import List, Tuple from collections import deque, defaultdict def minimum_time_to_complete_projects(n: int, dependencies: List[Tuple[int, int]]) -> int: # Step 1: Create the graph and indegree array graph = defaultdict(list) indegree = [0] * n for u, v in dependencies: graph[u].append(v) indegree[v] += 1 # Step 2: Initialize queue with projects that have no dependencies queue = deque() for i in range(n): if indegree[i] == 0: queue.append(i) # Step 3: Perform topological sort and determine the minimum time time = 0 projects_complete = 0 while queue: # Process the projects at the current level level_count = len(queue) for _ in range(level_count): project = queue.popleft() projects_complete += 1 for neighbor in graph[project]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # Increment time for each level processed time += 1 # Step 4: If we have completed all projects, return the time, otherwise 0 return time if projects_complete == n else 0"},{"question":"# Coding Assessment Question Problem Statement: You are given a list of words, each consisting of lowercase English letters. The words are arranged in alphabetical order except that one word is out of place. Your task is to find and return the index of the word that is out of place. Write a function `find_out_of_place_word(words: List[str]) -> int` that takes a list of words in alphabetical order with one word out of place and returns the index of that word. Input: * `words` (2 <= len(words) <= 10^5): A list of strings, where each string consists of lowercase English letters. Output: * An integer representing the index of the word that is out of place. Example: ```python assert find_out_of_place_word([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\", \\"fig\\", \\"grape\\"]) == -1 assert find_out_of_place_word([\\"apple\\", \\"banana\\", \\"fig\\", \\"date\\", \\"grape\\"]) == 2 assert find_out_of_place_word([\\"apricot\\", \\"banana\\", \\"apple\\", \\"cherry\\"]) == 2 assert find_out_of_place_word([\\"apple\\", \\"apricot\\", \\"banana\\", \\"banana\\", \\"cherry\\"]) == -1 ``` Constraints: * The input list of words is almost sorted in alphabetical order except for exactly one word if one is out of place. * If all words are in place and sorted correctly, return -1. * The list can have duplicate words, but the out-of-place word is considered out of order based on strictly alphabetical comparison. Performance: * Implement an efficient algorithm as the length of the list can be large. * Ensure your solution operates within a reasonable time complexity for the given input size.","solution":"from typing import List def find_out_of_place_word(words: List[str]) -> int: Returns the index of the word that is out of place in an otherwise alphabetical order list. Parameters: words (List[str]): A list of words sorted in alphabetical order except for one word. Returns: int: An index of the out-of-place word or -1 if the list is sorted correctly. n = len(words) for i in range(1, n): if words[i] < words[i - 1]: # If we find that words[i] is out of order, the located index is likely the problem. # However, we must confirm if it is the current word or the previous word if i == 1 or words[i] >= words[i - 2]: return i - 1 else: return i return -1"},{"question":"# Merge Sorted Arrays You are given two lists of integers that are already sorted in non-decreasing order. Your task is to write a Python function that merges the two lists into a single list that is also sorted in non-decreasing order. Function Signature ```python def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: ``` Input - `arr1`: A list of integers sorted in non-decreasing order. Length of the list will be between 1 and 100, inclusive. - `arr2`: A list of integers sorted in non-decreasing order. Length of the list will be between 1 and 100, inclusive. Output - Return a list of integers containing all elements from `arr1` and `arr2` sorted in non-decreasing order. Constraints - Both input lists are already sorted. - The combined length of `arr1` and `arr2` will not exceed 200 elements. Example ```python >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 2, 3], [4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([5, 6, 7], [1, 2, 3]) [1, 2, 3, 5, 6, 7] ``` Explanation - In the first example, merging `[1, 3, 5]` and `[2, 4, 6]` gives `[1, 2, 3, 4, 5, 6]`. - In the second example, merging `[1, 2, 3]` and `[4, 5, 6]` gives `[1, 2, 3, 4, 5, 6]`. - In the third example, merging `[5, 6, 7]` and `[1, 2, 3]` gives `[1, 2, 3, 5, 6, 7]`. Use an efficient approach to take advantage of the fact that both input arrays are already sorted.","solution":"from typing import List def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: Merges two sorted lists into a single sorted list. merged_array = [] i, j = 0, 0 # Traverse both arrays and merge them while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # Append remaining elements of arr1 (if any) while i < len(arr1): merged_array.append(arr1[i]) i += 1 # Append remaining elements of arr2 (if any) while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"**Traffic Light System Simulation Task** # Problem Statement You need to implement a simple simulation of a traffic light system for a single intersection. The traffic lights cycle through the colors green, yellow, and red. Each color has a defined duration before switching to the next one. # Requirements 1. **Class Definition**: Implement the class `TrafficLight`. 2. **Constructor**: The constructor should initialize the traffic light with the following durations (in seconds): - `green_duration` (int) - `yellow_duration` (int) - `red_duration` (int) 3. **Methods**: - `cycle_lights()`: This method will cycle through the traffic lights once, following the order: green -> yellow -> red. - Each color should be displayed with its corresponding duration in the format `\\"Green: 30 seconds\\"`, `\\"Yellow: 5 seconds\\"`, `\\"Red: 60 seconds\\"`. - `current_light()`: This method should return the current light color as a string: \\"Green\\", \\"Yellow\\", or \\"Red\\". 4. **Time Simulation**: - You can assume 1 second of real time equals 1 second in the simulation. - Use the `time.sleep()` function to simulate the duration of each light color. # Example ```python import time class TrafficLight: def __init__(self, green_duration, yellow_duration, red_duration): self.green_duration = green_duration self.yellow_duration = yellow_duration self.red_duration = red_duration self.current = \'Red\' def cycle_lights(self): self.current = \'Green\' print(f\\"Green: {self.green_duration} seconds\\") time.sleep(self.green_duration) self.current = \'Yellow\' print(f\\"Yellow: {self.yellow_duration} seconds\\") time.sleep(self.yellow_duration) self.current = \'Red\' print(f\\"Red: {self.red_duration} seconds\\") time.sleep(self.red_duration) def current_light(self): return self.current # Example Usage traffic_light = TrafficLight(30, 5, 60) traffic_light.cycle_lights() print(traffic_light.current_light()) # Expected Output during execution: # Green: 30 seconds # Yellow: 5 seconds # Red: 60 seconds # Red ``` # Notes * Ensure your implementation handles the correct sequencing of lights. * Optimize the simulation for readability and correctness. * Your solution should focus on simulating the traffic light system accurately and efficiently.","solution":"import time class TrafficLight: def __init__(self, green_duration, yellow_duration, red_duration): self.green_duration = green_duration self.yellow_duration = yellow_duration self.red_duration = red_duration self.current = \'Red\' def cycle_lights(self): self.current = \'Green\' print(f\\"Green: {self.green_duration} seconds\\") time.sleep(self.green_duration) self.current = \'Yellow\' print(f\\"Yellow: {self.yellow_duration} seconds\\") time.sleep(self.yellow_duration) self.current = \'Red\' print(f\\"Red: {self.red_duration} seconds\\") time.sleep(self.red_duration) def current_light(self): return self.current"},{"question":"# Multiple Duplicate Element Finder You need to implement a function that identifies all elements that appear more than once in a given list of integers. The result should be a list of these elements in ascending order. **Function Signature**: ```python def find_duplicates(nums: List[int]) -> List[int]: ``` **Parameters**: - `nums (List[int])`: A list of integers where duplicates might exist. **Returns**: - `List[int]`: A sorted list of integers that appear more than once in the input list. # Example: ```python assert find_duplicates([4, 3, 2, 7, 8, 2, 3, 1]) == [2, 3] assert find_duplicates([4, 3, 4, 3, 7, 8, 1, 1]) == [1, 3, 4] assert find_duplicates([10, 20, 30, 20, 10, 40, 10, 50]) == [10, 20] assert find_duplicates([1, 2, 3, 4, 5]) == [] assert find_duplicates([]) == [] ``` # Constraints: * Elements in the input list can be negative or positive integers. * The input list can contain up to 10^5 elements. * The function should be optimized for both time and space: - Time complexity should be O(n log n) or better. - Space complexity should be O(n). # Additional Information: To solve this problem, you can use various approaches: - Sorting the list first and then identifying duplicates. - Using a hash table (dictionary) to count occurrences. - Ensure correctness by handling edge cases like an empty list or a list with all unique elements.","solution":"def find_duplicates(nums): Identifies all elements that appear more than once in the given list of integers. Args: nums (List[int]): A list of integers where duplicates might exist. Returns: List[int]: A sorted list of integers that appear more than once in the input list. from collections import Counter # Count occurrences of each element counts = Counter(nums) # Filter elements that have more than one occurrence duplicates = [num for num, count in counts.items() if count > 1] # Return sorted list of duplicates return sorted(duplicates)"},{"question":"# Find Rotated Array Pivot Context You are given a sorted array of unique integers that has been rotated at an unknown pivot (i.e., `[0, 1, 2, 4, 5, 6, 7]` might become `[4, 5, 6, 7, 0, 1, 2]`). Your task is to find the index of the pivot element (the smallest element). Assume no duplicates exist in the array. Function Signature ```python def find_pivot(nums: list[int]) -> int: ``` Inputs - `nums`: A rotated list of unique integers. Outputs - An integer representing the index of the pivot (smallest element) in the array. Constraints - The input list `nums` will always have at least one element. - The solution should be efficient, targeting logarithmic time complexity, i.e., O(log n). Example ```python >>> find_pivot([4, 5, 6, 7, 0, 1, 2]) 4 >>> find_pivot([0, 1, 2, 3, 4, 5, 6, 7]) 0 >>> find_pivot([2, 3, 4, 5, 1]) 4 >>> find_pivot([1]) 0 >>> find_pivot([2, 1]) 1 ``` Instructions 1. Implement a binary search-like approach to efficiently find the pivot. 2. Initialize pointers at either end of the array. 3. Use the mid-point to decide which half of the array to continue searching in, based on the comparison with the first element. 4. Return the index of the smallest element. Edge Cases to Consider - The list contains only a single element. - The list has not been rotated (i.e., the smallest element is at index 0). Note Use the provided function signature and ensure that the function returns the correct result for all the provided test cases.","solution":"def find_pivot(nums: list[int]) -> int: Finds and returns the index of the pivot (smallest element) in the rotated sorted array. left, right = 0, len(nums) - 1 # If the array is not rotated (the smallest element is at index 0) if nums[left] < nums[right]: return 0 while left < right: mid = (left + right) // 2 if nums[mid] > nums[right]: # pivot is in the right half left = mid + 1 else: # pivot is in the left half right = mid return left"},{"question":"# Coding Assessment Question Scenario You are tasked with developing a function that identifies the most frequent substring of a given length `k` within a larger string. The substring can overlap, and in case of multiple substrings with the same frequency, the lexicographically smallest one should be returned. Problem Statement Write a function `most_frequent_substring(s: str, k: int) -> str` that finds the most frequent substring of length `k` in the given string `s`. If there are multiple substrings with the same frequency, return the lexicographically smallest substring. Input - `s`: A string containing only lowercase English letters. - `k`: An integer representing the length of the substring. Output - The function should return a string representing the most frequent substring of length `k`. Constraints - 1 <= len(s) <= 10^5 - 1 <= k <= len(s) - If `k` is greater than `len(s)`, raise a `ValueError` with the message \\"Invalid Input\\". Example ```python def most_frequent_substring(s: str, k: int) -> str: Returns the most frequent substring of length k >>> s = \\"ababcbabc\\" >>> k = 2 >>> most_frequent_substring(s, k) \'ab\' >>> s = \\"mississippi\\" >>> k = 1 >>> most_frequent_substring(s, k) \'i\' >>> s = \\"aabbcc\\" >>> k = 3 >>> most_frequent_substring(s, k) \'aab\' >>> s = \\"abc\\" >>> k = 4 Traceback (most recent call last): ... ValueError: Invalid Input if len(s) < k or k <= 0: raise ValueError(\\"Invalid Input\\") from collections import Counter substr_freq = Counter(s[i:i+k] for i in range(len(s) - k + 1)) most_common_substr, _ = min(substr_freq.items(), key=lambda x: (-x[1], x[0])) return most_common_substr if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` You are required to ensure your solution handles edge cases appropriately and performs efficiently within the given constraints.","solution":"def most_frequent_substring(s: str, k: int) -> str: Returns the most frequent substring of length k in the given string s. In case of a tie, returns the lexicographically smallest substring. :param s: Input string containing only lowercase English letters. :param k: Length of the substring to consider. :return: The most frequent substring of length k. :raises ValueError: If k is greater than the length of s. if len(s) < k or k <= 0: raise ValueError(\\"Invalid Input\\") from collections import Counter # Count frequency of all substrings of length k substr_freq = Counter(s[i:i+k] for i in range(len(s) - k + 1)) # Find the most frequent substring; in case of tie, the lexicographically smallest most_common_substr = min(substr_freq.items(), key=lambda x: (-x[1], x[0]))[0] return most_common_substr"},{"question":"# Coding Assessment Question: Power of a Number Calculator Context: You are provided with a function that needs to calculate the power of a number based on its base and exponent. The implementation should rely on repeated multiplication and optimize for performance using the concept of exponentiation by squaring. Task: Write a Python function `calculate_power` that takes two integers: `base` and `exponent`, and returns the result of raising `base` to the power of `exponent`. Input: * An integer `base` representing the base number. * A non-negative integer `exponent` representing the exponent to which the base number is raised. Output: * An integer representing the result of the exponentiation. Constraints: * The `exponent` must be a non-negative integer. Raise a `ValueError` if the exponent is negative. * Assume the `base` and result fit within the typical integer range in Python. Example: ```python >>> calculate_power(2, 3) 8 >>> calculate_power(5, 4) 625 >>> calculate_power(3, 0) 1 >>> calculate_power(10, 5) 100000 >>> calculate_power(2, -1) Traceback (most recent call last): ... ValueError: Exponent must be a non-negative integer ``` Requirements: 1. Ensure your function validates that the exponent is non-negative. 2. Include error handling to raise a `ValueError` on invalid input. 3. Implement the solution using the method of exponentiation by squaring to optimize for performance. Performance: * The function should run in logarithmic time ( O(log n) ). * Memory usage must be constant ( O(1) ).","solution":"def calculate_power(base, exponent): Calculate the power of a number using exponentiation by squaring. Arguments: base -- the base number (integer) exponent -- the exponent (non-negative integer) Returns: result of base raised to the power of exponent (integer) Raises: ValueError -- if exponent is negative if exponent < 0: raise ValueError(\\"Exponent must be a non-negative integer\\") result = 1 current_base = base current_exponent = exponent while current_exponent > 0: if (current_exponent % 2) == 1: # If the exponent is odd result *= current_base current_base *= current_base current_exponent //= 2 return result"},{"question":"# Coding Question **Streamlined Post Operations** You are given a class `Post` for managing social media posts. The class includes methods to add tags and likes. Your task is to enhance the class to handle additional functionalities efficiently. Objectives: 1. **Add Comments**: - Add functionality to manage comments on a post. - Ensure comments are stored in the order they are added. 2. **Like Counts**: - Ensure the like count only increments if the user has not already liked the post. You need to implement the enhanced class `EnhancedPost` that meets the above objectives and maintains the existing functionalities. Class Signature: ```python class EnhancedPost: def __init__(self, text: str): pass def add_tag(self, tag: str): pass def add_like(self, user: str): pass def add_comment(self, user: str, comment: str): pass def get_like_count(self) -> int: pass def get_comment_summary(self) -> list: pass ``` Description of Methods: - `__init__(self, text: str)`: Initializes a new post with the given text. Sets up empty lists for tags, likes, and comments. - `add_tag(self, tag: str)`: Adds a new tag to the post if it does not already exist. - `add_like(self, user: str)`: Adds a like from the user if they haven\'t liked the post already. - `add_comment(self, user: str, comment: str)`: Adds a new comment to the post from the specified user. - `get_like_count(self) -> int`: Returns the number of unique likes the post has received. - `get_comment_summary(self) -> list`: Returns a list of all comments as tuples in the form `(user, comment)`. Performance Requirements: - The solution should efficiently handle multiple tags, likes, and comments without significant performance degradation. Examples: ```python # Example 1 post = EnhancedPost(\\"My first post\\") post.add_tag(\\"intro\\") post.add_tag(\\"welcome\\") post.add_like(\\"user1\\") post.add_like(\\"user2\\") post.add_like(\\"user1\\") # Duplicate like should not count post.add_comment(\\"user1\\", \\"Great post!\\") post.add_comment(\\"user2\\", \\"Welcome!\\") print(post.get_like_count()) # Output: 2 print(post.get_comment_summary()) # Output: [(\\"user1\\", \\"Great post!\\"), (\\"user2\\", \\"Welcome!\\")] # Example 2 post2 = EnhancedPost(\\"Another day in paradise\\") post2.add_tag(\\"paradise\\") post2.add_tag(\\"life\\") post2.add_like(\\"user3\\") post2.add_comment(\\"user3\\", \\"Enjoying your posts!\\") print(post2.get_like_count()) # Output: 1 print(post2.get_comment_summary()) # Output: [(\\"user3\\", \\"Enjoying your posts!\\")] ``` Additional Information: - Use appropriate data structures to ensure the efficient storage and retrieval of tags, likes, and comments. - Ensure thread-safety if necessary to handle concurrent interactions.","solution":"class EnhancedPost: def __init__(self, text: str): self.text = text self.tags = set() self.likes = set() self.comments = [] def add_tag(self, tag: str): self.tags.add(tag) def add_like(self, user: str): self.likes.add(user) def add_comment(self, user: str, comment: str): self.comments.append((user, comment)) def get_like_count(self) -> int: return len(self.likes) def get_comment_summary(self) -> list: return self.comments"},{"question":"# Coding Assessment Question You are part of a team developing a sophisticated text editor and have been assigned the task of implementing an auto-complete feature. The goal is to assist users by providing word suggestions as they type. The auto-complete functionality should be efficient and able to handle large dictionaries of words. # Task Details Implement two functions: 1. `add_word(word: str) -> None`: Adds a word to the auto-complete dictionary. - **Input**: A string representing a valid word (e.g., \\"hello\\"). - **Output**: None. - **Constraints**: - The word will contain only lowercase English alphabets. - Ensure the word is not already present in the dictionary before adding. 2. `get_suggestions(prefix: str, max_suggestions: int) -> List[str]`: Retrieves a list of word suggestions based on the given prefix. - **Input**: - A string representing the prefix (e.g., \\"he\\"). - An integer representing the maximum number of suggestions to return. - **Output**: A list of strings representing the suggested words. - **Constraints**: - If no suggestions are found, return an empty list. - The suggestions should be sorted in lexicographical order. - If the number of suggestions exceeds the maximum, truncate the list to contain only the specified number of suggestions. # Example Usage ```python >>> add_word(\\"hello\\") >>> add_word(\\"hell\\") >>> add_word(\\"heaven\\") >>> add_word(\\"heavy\\") >>> get_suggestions(\\"he\\", 2) [\'heaven\', \'heavy\'] >>> get_suggestions(\\"hello\\", 1) [\'hello\'] >>> get_suggestions(\\"ha\\", 3) [] >>> get_suggestions(\\"heav\\", 2) [\'heaven\', \'heavy\'] ``` # Additional Requirements - Ensure your implementation includes appropriate data structures for efficient word storage and retrieval. - Handle edge cases such as empty prefixes and extremely large dictionaries. - Provide at least five unit tests that cover various cases, including non-existent prefixes, exact matches, and different max_suggestions values. Deliver Python code that passes the above example usages and unit tests provided.","solution":"class AutoComplete: def __init__(self): self.words_set = set() self.words_list = [] def add_word(self, word: str) -> None: if word not in self.words_set: self.words_set.add(word) self.words_list.append(word) self.words_list.sort() def get_suggestions(self, prefix: str, max_suggestions: int) -> list: suggestions = [word for word in self.words_list if word.startswith(prefix)] return suggestions[:max_suggestions]"},{"question":"Given two singly linked lists, determine if the two lists intersect. Return the intersecting node(s) if they intersect, and None if they do not. You should optimize the function to work in O(N + M) time complexity and O(1) space complexity where N and M are the lengths of the two linked lists. **Requirements**: 1. Implement `find_intersection` method in the provided `LinkedList` class that identifies the node at which the two lists intersect. If the lists do not intersect, return `None`. 2. Expected Time Complexity: O(N + M) 3. Expected Space Complexity: O(1) **Function Signature**: ```python class ListNode: def __init__(self, value: int = 0, next: \'ListNode\' = None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None def find_intersection(self, other: \'LinkedList\') -> \'ListNode\': # Your implementation here pass ``` **Input/Output**: - Input: Two linked list instances. - Output: A `ListNode` instance representing the intersecting node, or `None` if no intersection exists. **Constraints**: - The ListNode values are integers. - Each list can contain up to 10^5 nodes. - The lists can be empty (i.e., head is None). **Examples**: ```python # Example 1 list1 = LinkedList() list1.head = ListNode(3) list1.head.next = ListNode(6) list1.head.next.next = ListNode(9) list1.head.next.next.next = ListNode(15) list1.head.next.next.next.next = ListNode(30) list2 = LinkedList() list2.head = ListNode(10) list2.head.next = list1.head.next.next.next # 15 Constructed linked lists are: List1: 3 -> 6 -> 9 -> 15 -> 30 ↓ List2: 10 -> ---------------- assert list1.find_intersection(list2) == list1.head.next.next.next # Example 2 list1 = LinkedList() list1.head = ListNode(1) list1.head.next = ListNode(2) list2 = LinkedList() list2.head = ListNode(5) list2.head.next = ListNode(6) assert list1.find_intersection(list2) == None # Example 3 list3 = LinkedList() list3.head = ListNode(1) assert list3.find_intersection(list3) == list3.head ``` Hint: Use two pointers approach to traverse the lists and find the intersection point by aligning the ends of the lists.","solution":"class ListNode: def __init__(self, value: int = 0, next: \'ListNode\' = None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None def find_intersection(self, other: \'LinkedList\') -> \'ListNode\': if not self.head or not other.head: return None length1 = self.get_length(self.head) length2 = self.get_length(other.head) diff = abs(length1 - length2) if length1 > length2: longer, shorter = self.head, other.head else: longer, shorter = other.head, self.head for _ in range(diff): longer = longer.next while longer and shorter: if longer == shorter: return longer longer = longer.next shorter = shorter.next return None def get_length(self, node: \'ListNode\') -> int: length = 0 while node: length += 1 node = node.next return length"},{"question":"# Coding Assessment Question Context: You are tasked with developing a feature for an e-commerce platform to help users find the best deals on products. This feature will filter and sort a list of products based on given criteria. Your objective is to implement a function that dynamically applies various filters and sorts the resulting list of products. Task: Implement the `filter_and_sort_products` function to filter products by category and price range, then sort them by a given attribute. Requirements: 1. **Function Signature**: ```python def filter_and_sort_products(products: list, category: str = None, price_range: tuple = None, sort_by: str = \'price\', ascending: bool = True) -> list: ``` 2. **Input**: * `products` (list): A list of dictionaries, each representing a product with attributes like \'name\', \'category\', \'price\', and \'rating\'. * `category` (str): Optional. If provided, filter products by the specified category. * `price_range` (tuple): Optional. A tuple of `(min_price, max_price)`. If provided, filter products within this price range. * `sort_by` (str): The attribute to sort by (\'price\' or \'rating\'). * `ascending` (bool): Sort order. If `True`, sort in ascending order, otherwise descending. 3. **Output**: * `list`: A list of filtered and sorted product dictionaries. 4. **Constraints**: * The `products` list will have between 1 and 1000 product entries. * Product attributes are guaranteed to be present and correctly formatted. * Price values are non-negative floats. * Rating values are floats between 0 and 5. 5. **Performance Requirements**: * Filtering and sorting operations should efficiently handle the upper limit of product entries. Example Usage: ```python products = [ {\\"name\\": \\"Laptop\\", \\"category\\": \\"electronics\\", \\"price\\": 999.99, \\"rating\\": 4.7}, {\\"name\\": \\"Smartphone\\", \\"category\\": \\"electronics\\", \\"price\\": 599.99, \\"rating\\": 4.5}, {\\"name\\": \\"Coffee Maker\\", \\"category\\": \\"appliances\\", \\"price\\": 49.99, \\"rating\\": 3.9}, {\\"name\\": \\"Blender\\", \\"category\\": \\"appliances\\", \\"price\\": 29.99, \\"rating\\": 4.2} ] # Filter by category \'electronics\' and sort by rating in descending order result = filter_and_sort_products(products, category=\\"electronics\\", sort_by=\\"rating\\", ascending=False) # Expected Output # [ # {\\"name\\": \\"Laptop\\", \\"category\\": \\"electronics\\", \\"price\\": 999.99, \\"rating\\": 4.7}, # {\\"name\\": \\"Smartphone\\", \\"category\\": \\"electronics\\", \\"price\\": 599.99, \\"rating\\": 4.5} # ] ``` Hints: * Use list comprehensions for filtering. * Utilize the `sorted` function with a custom `key` for sorting. * Apply a default sorting mechanism for robustness when `sort_by` is not specified. Good luck!","solution":"def filter_and_sort_products(products, category=None, price_range=None, sort_by=\'price\', ascending=True): Filters and sorts a list of products based on category and price range. :param products: List of dictionaries representing products :param category: Optional. A category to filter the products by. :param price_range: Optional. A tuple (min_price, max_price) to filter the products by price range. :param sort_by: Attribute to sort by (\'price\' or \'rating\'). :param ascending: If True, sort in ascending order, else in descending order. :return: Filtered and sorted list of product dictionaries. if category: products = [product for product in products if product[\'category\'] == category] if price_range: min_price, max_price = price_range products = [ product for product in products if min_price <= product[\'price\'] <= max_price ] products = sorted(products, key=lambda x: x[sort_by], reverse=not ascending) return products"},{"question":"# Word Ladder Manager Problem Statement You are developing a word game where players must transform a start word into an end word by changing one letter at a time, with each intermediate step being a valid word from a provided dictionary. Your task is to write a function that validates the transformation sequence. Requirements Implement the function `is_valid_word_ladder` that takes a list of words and verifies if the sequence is a valid word ladder. Inputs - `words`: A list of strings representing the word ladder sequence. Each word is of the same length and only lowercase letters are used. - `dictionary`: A set of strings representing the dictionary of valid words. Output - A boolean value: - `True` if the sequence is a valid word ladder. - `False` otherwise. Example Here are some example inputs and expected outputs: ```python dictionary = {\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\", \\"lot\\", \\"log\\"} assert is_valid_word_ladder([\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"], dictionary) == True assert is_valid_word_ladder([\\"hit\\", \\"hot\\", \\"dog\\", \\"dot\\", \\"cog\\"], dictionary) == False assert is_valid_word_ladder([\\"hit\\", \\"cat\\", \\"dog\\", \\"cog\\"], dictionary) == False assert is_valid_word_ladder([\\"hit\\", \\"hot\\", \\"lot\\", \\"log\\", \\"cog\\"], dictionary) == True ``` Ensure that the solution verifies each step in the ladder by checking that only one letter changes between consecutive words and that each word exists in the provided dictionary.","solution":"def is_valid_word_ladder(words, dictionary): Verifies if the given sequence of words is a valid word ladder. Args: words: List of strings representing the word ladder sequence. dictionary: Set of strings representing the dictionary of valid words. Returns: True if the sequence is a valid word ladder, False otherwise. if not words or len(words) < 2: return False for i in range(1, len(words)): current_word = words[i - 1] next_word = words[i] if current_word not in dictionary or next_word not in dictionary: return False # Check if the current and next word differ by exactly one letter differ_count = sum(1 for a, b in zip(current_word, next_word) if a != b) if differ_count != 1: return False return True"},{"question":"# Coding Assessment Question Task You are required to write a Python function that simulates a simplified online voting system. The function should count votes for a given list of candidates and announce the winner. Function Specifications Write a function `count_votes(votes: list) -> (str, int)` that: * Takes a single input: * `votes` (list of strings): A list where each element is a vote for a candidate. Each vote is represented by a candidate\'s name (string). * Returns a tuple containing: * The name of the candidate with the highest number of votes (string). * The number of votes the winning candidate received (integer). Constraints * If there is a tie between candidates (i.e., two or more candidates receive the highest number of votes), the function should return the name of the candidate who appears first in alphabetical order. * You may assume that the input list contains at least one vote. * All votes are case-sensitive, meaning \\"Alice\\" and \\"alice\\" would be considered different candidates. * You should use built-in Python data structures and functions to achieve this. Example **Input:** ```python votes = [\\"Alice\\", \\"Bob\\", \\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"Alice\\"] result = count_votes(votes) print(result) ``` **Expected Output:** ```python (\\"Alice\\", 3) ``` **Additional Example** **Input:** ```python votes = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"Bob\\", \\"Charlie\\", \\"Bob\\"] result = count_votes(votes) print(result) ``` **Expected Output:** ```python (\\"Bob\\", 3) ``` Performance Requirements * The function should efficiently handle large lists of votes (up to 10^6 votes) and complete execution within a reasonable time frame (under 2 seconds for the upper limit). Additional Context This function simulates a basic voting mechanism, often used in online polls or elections, where counting votes accurately and efficiently is crucial. Consider edge cases such as ties and ensure the solution is robust and handles them gracefully.","solution":"def count_votes(votes): Counts votes and returns the candidate with the most votes. Parameters: - votes (list of str): A list of candidate names representing votes. Returns: - tuple: A tuple containing the name of the candidate with the most votes, and the number of votes they received. from collections import defaultdict vote_count = defaultdict(int) # Count the votes for each candidate for vote in votes: vote_count[vote] += 1 # Find the candidate with the highest number of votes max_votes = max(vote_count.values()) candidates_with_max_votes = [candidate for candidate, count in vote_count.items() if count == max_votes] # Sort the candidates alphabetically and return the first one winner = sorted(candidates_with_max_votes)[0] return winner, vote_count[winner]"},{"question":"# Text File Word Counter Function Implement a function that reads a text file and counts the frequency of each unique word, ensuring high performance and considering edge cases, constraints, and the storage requirements detailed below. Function Signature ```python def word_counter(file_path: str) -> Dict[str, int]: Counts the frequency of each unique word in a text file. ``` Input * A string `file_path` representing the path to the text file. Output * A dictionary where keys are words (lowercase) and values are their respective frequencies in the file. Constraints and Requirements * Words should be case-insensitive—i.e., \\"Word\\" and \\"word\\" should be treated as the same. * Words are defined as sequences of alphabetical characters. * The function should ignore punctuation and handle files of size up to 10MB efficiently. * Performance requirements: The function should process the file in O(n) time complexity, where \'n\' is the total number of characters in the file. * The function should use O(w) additional space, where ‘w’ is the number of unique words in the file. Example ```python # Assuming the file at \'path/to/textfile.txt\' contains the following text: # \\"Hello world! Hello, Universe.\\" # The result should be: # { # \\"hello\\": 2, # \\"world\\": 1, # \\"universe\\": 1 # } result = word_counter(\\"path/to/textfile.txt\\") print(result) # Output: {\'hello\': 2, \'world\': 1, \'universe\': 1} ``` Testing Design and include unittests to verify your implementation, ensuring to test edge cases such as handling empty files, files with non-alphabetic characters, and large files close to the 10MB limit.","solution":"import re from typing import Dict def word_counter(file_path: str) -> Dict[str, int]: Counts the frequency of each unique word in a text file. :param file_path: string representing the path to the text file :return: dictionary with words (in lowercase) as keys and their frequencies as values word_freq = {} word_pattern = re.compile(r\'b[a-zA-Z]+b\') with open(file_path, \'r\') as file: for line in file: words = word_pattern.findall(line.lower()) for word in words: if word in word_freq: word_freq[word] += 1 else: word_freq[word] = 1 return word_freq"},{"question":"# Prime Number Generator As part of developing a mathematical toolkit, you need to implement a function that generates prime numbers up to a given integer `n`. A prime number is a natural number greater than 1 that is not divisible by any number other than 1 and itself. Objective Write a function `generate_primes` that returns a list of all prime numbers less than or equal to a given integer `n`. Function Signature ```python def generate_primes(n: int) -> List[int]: ``` # Input - An integer `n`. # Output - A list of prime numbers less than or equal to `n`. # Constraints - `2 <= n <= 10^6` # Examples ```python assert generate_primes(10) == [2, 3, 5, 7] assert generate_primes(18) == [2, 3, 5, 7, 11, 13, 17] assert generate_primes(2) == [2] assert generate_primes(1) == [] ``` **Explanation**: 1. For the first example, the prime numbers less than or equal to 10 are `[2, 3, 5, 7]`. 2. For the second example, the prime numbers less than or equal to 18 are `[2, 3, 5, 7, 11, 13, 17]`. # Requirements - Ensure your implementation handles large values efficiently. - Optimize your solution to run within the time limits. - Consider edge cases such as the smallest possible value for `n`.","solution":"from typing import List def generate_primes(n: int) -> List[int]: Returns a list of all prime numbers less than or equal to n. if n < 2: return [] sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers. for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n + 1, start): sieve[multiple] = False return [num for num in range(n + 1) if sieve[num]]"},{"question":"# Merge Two Sorted Arrays Scenario You are working on a data processing application where you frequently need to combine and sort data from two different sources. Each source provides a sorted list of numerical values, and your task is to merge these lists into one sorted array while maintaining the order. Task Implement the function `merge_sorted_arrays` that merges two sorted lists into a single sorted list. Function Signature ```python def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: ``` Input * **arr1** (List[int]): The first sorted list of integers. * **arr2** (List[int]): The second sorted list of integers. Output * **List[int]**: A new list containing all the elements from both input lists, sorted in ascending order. Constraints * Both input lists are already sorted in ascending order. * The total number of elements in the merged list will not exceed 10^6. * The function should handle edge cases such as empty input lists efficiently. Example ```python arr1 = [1, 3, 5, 7] arr2 = [2, 4, 6, 8] assert merge_sorted_arrays(arr1, arr2) == [1, 2, 3, 4, 5, 6, 7, 8] arr1 = [1, 2, 3] arr2 = [] assert merge_sorted_arrays(arr1, arr2) == [1, 2, 3] arr1 = [] arr2 = [4, 5, 6] assert merge_sorted_arrays(arr1, arr2) == [4, 5, 6] arr1 = [1, 1, 2, 3] arr2 = [1, 2, 2, 3] assert merge_sorted_arrays(arr1, arr2) == [1, 1, 1, 2, 2, 2, 3, 3] ```","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted lists into a single sorted list. Args: arr1 (List[int]): The first sorted list of integers. arr2 (List[int]): The second sorted list of integers. Returns: List[int]: A new list containing all the elements from both input lists, sorted in ascending order. result = [] i = j = 0 # Use two pointers to merge the arrays while i < len(arr1) and j < len(arr2): if arr1[i] <= arr2[j]: result.append(arr1[i]) i += 1 else: result.append(arr2[j]) j += 1 # Append remaining elements (if any) from arr1 while i < len(arr1): result.append(arr1[i]) i += 1 # Append remaining elements (if any) from arr2 while j < len(arr2): result.append(arr2[j]) j += 1 return result"},{"question":"# Unique Path Finder You are given the following problem to solve: A robot is located in the top-left corner of an m x n grid (marked \'Start\' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked \'Finish\' in the diagram below). | S | | | |---|---|---| | | | | | | | F | How many possible unique paths are there to reach the bottom-right corner from the top-left corner? # Task Write a function `unique_paths` that computes the number of unique paths available for the robot to go from the start to the finish in an `m x n` grid. Input: - The function takes two integers `m` and `n` representing the grid\'s dimensions. Output: - Return an integer which is the number of unique paths from the start to the finish. # Constraints: - 1 ≤ m, n ≤ 100 # Example ```python >>> unique_paths(3, 2) 3 >>> unique_paths(7, 3) 28 ``` Use the following template to implement the solution: ```python def unique_paths(m, n): if m == 0 or n == 0: return 0 # Create a 2D list to store the number of paths to reach each cell dp = [[1] * n for _ in range(m)] for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1] # Example usage: # print(unique_paths(3, 2)) # Output: 3 # print(unique_paths(7, 3)) # Output: 28 ``` The function `unique_paths` computes the number of unique paths using dynamic programming by filling up a 2D grid where each cell represents the number of ways to reach that cell from the starting point. The result for the bottom-right corner is the desired output.","solution":"def unique_paths(m, n): if m == 0 or n == 0: return 0 # Create a 2D list to store the number of paths to reach each cell dp = [[1] * n for _ in range(m)] for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1] # Example usage: # print(unique_paths(3, 2)) # Output: 3 # print(unique_paths(7, 3)) # Output: 28"},{"question":"# Problem Statement You are required to implement a system for managing a fixed-size circular buffer (or ring buffer). A circular buffer is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end. Implement the buffer to support operations for adding elements, removing elements, and querying its state. # Requirements 1. **Class Definition**: Define the class `CircularBuffer`. 2. **Constructor**: The constructor should take an integer `capacity` indicating the maximum number of elements the buffer can hold. 3. **Add Method**: Implement the `add` method to insert an element into the buffer. If the buffer is full, the oldest data will be overwritten. 4. **Remove Method**: Implement the `remove` method to remove and return the oldest element from the buffer. If the buffer is empty, return `None`. 5. **Is Full Method**: Implement the `is_full` method to check if the buffer is at full capacity. 6. **Is Empty Method**: Implement the `is_empty` method to check if the buffer is empty. 7. **Get Capacity Method**: Implement the `get_capacity` method to return the buffer\'s maximum capacity. 8. **Get Size Method**: Implement the `get_size` method to return the current number of elements in the buffer. 9. **Edge Cases Handling**: Ensure proper handling of scenarios like adding to a full buffer or removing from an empty buffer. # Function Signature ```python class CircularBuffer: def __init__(self, capacity: int): # Your code here def add(self, item: int) -> None: # Your code here def remove(self) -> Optional[int]: # Your code here def is_full(self) -> bool: # Your code here def is_empty(self) -> bool: # Your code here def get_capacity(self) -> int: # Your code here def get_size(self) -> int: # Your code here ``` # Input and Output * `__init__(capacity: int)`: Initializes the circular buffer with a given capacity. * `add(item: int) -> None`: Adds an item to the buffer. If the buffer is full, the oldest item is overwritten. * `remove() -> Optional[int]`: Removes and returns the oldest item from the buffer. Returns `None` if the buffer is empty. * `is_full() -> bool`: Returns `True` if the buffer is full, `False` otherwise. * `is_empty() -> bool`: Returns `True` if the buffer is empty, `False` otherwise. * `get_capacity() -> int`: Returns the buffer\'s maximum capacity. * `get_size() -> int`: Returns the current number of elements in the buffer. # Example ```python buffer = CircularBuffer(3) print(buffer.is_empty()) # Output: True buffer.add(1) buffer.add(2) buffer.add(3) print(buffer.is_full()) # Output: True buffer.add(4) print(buffer.remove()) # Output: 2 print(buffer.get_size()) # Output: 2 print(buffer.get_capacity()) # Output: 3 buffer.add(5) print(buffer.remove()) # Output: 3 buffer.add(6) print(buffer.remove()) # Output: 4 ``` # Performance Requirements * Ensure all operations (add, remove, is_full, is_empty, get_capacity, get_size) perform in O(1) time complexity. * Handle a buffer capacity of up to 10^5 elements efficiently. # Evaluation Criteria * **Correctness**: Accurate implementation of all required methods. * **Efficiency**: Time complexity of O(1) for all operations. * **Robustness**: Proper handling of edge cases such as adding to a full buffer or removing from an empty buffer. * **Code Quality**: Clean, readable, and maintainable code.","solution":"class CircularBuffer: def __init__(self, capacity: int): self.capacity = capacity self.buffer = [None] * capacity self.start = 0 self.end = 0 self.size = 0 def add(self, item: int) -> None: self.buffer[self.end] = item if self.size == self.capacity: self.start = (self.start + 1) % self.capacity else: self.size += 1 self.end = (self.end + 1) % self.capacity def remove(self) -> int: if self.size == 0: return None item = self.buffer[self.start] self.start = (self.start + 1) % self.capacity self.size -= 1 return item def is_full(self) -> bool: return self.size == self.capacity def is_empty(self) -> bool: return self.size == 0 def get_capacity(self) -> int: return self.capacity def get_size(self) -> int: return self.size"},{"question":"**Question:** Write a function `min_edit_distance(str1, str2)` that computes the minimum edit distance between two strings `str1` and `str2` using dynamic programming. The allowed operations are insertion, deletion, or substitution of a single character. # Function Signature ```python def min_edit_distance(str1: str, str2: str) -> int: pass ``` # Input * `str1` (str): The first string, with length ( 0 leq text{len(str1)} leq 1000 ). * `str2` (str): The second string, with length ( 0 leq text{len(str2)} leq 1000 ). # Output * Returns an integer value representing the minimum number of operations required to transform `str1` into `str2`. # Constraints * Both strings `str1` and `str2` contain only lowercase English letters. # Example ```python # Example 1 str1 = \\"kitten\\" str2 = \\"sitting\\" print(min_edit_distance(str1, str2)) # Outputs 3 # Example 2 str1 = \\"flaw\\" str2 = \\"lawn\\" print(min_edit_distance(str1, str2)) # Outputs 2 # Example 3 str1 = \\"intention\\" str2 = \\"execution\\" print(min_edit_distance(str1, str2)) # Outputs 5 ``` # Note: * The function should efficiently compute the result using dynamic programming to handle the larger input sizes within the given constraint. * Consider edge cases such as one or both strings being empty.","solution":"def min_edit_distance(str1, str2): Computes the minimum edit distance between two strings str1 and str2 using dynamic programming. The allowed operations are insertion, deletion, or substitution of a single character. m = len(str1) n = len(str2) # Create a 2D array to store the edit distances dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)] # Initialize the dp array for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If first string is empty, insert all characters of second string elif j == 0: dp[i][j] = i # If second string is empty, remove all characters of first string elif str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # No change required as the characters are the same else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"# Maximum Absolute Value Difference You are required to implement a function that finds the pair of elements in a list that has the maximum absolute value difference and returns that difference. Given a list of integers, the function should efficiently determine the highest absolute difference between any two integers in the list. **Function Signature**: ```python def max_absolute_diff(numbers: list) -> int: pass ``` # Input: * `numbers` (list of integers): A list of ( n ) integers where ( 2 leq n leq 10^6 ). # Output: * Returns an integer indicating the maximum absolute difference between any two integers in the list. # Examples: ```python >>> max_absolute_diff([1, 5, 9, -3, 7]) 12 >>> max_absolute_diff([-10, -20, -30, -40, -50]) 40 ``` # Constraints: * You must determine the maximum absolute difference within a time complexity of (O(n)). * The input list will have at least two elements. * Each integer in the list ranges between (-10^9) and ( 10^9 ). # Requirements: 1. Identify the minimum and maximum values in the list to calculate the difference. 2. Ensure the solution handles edge cases such as both positive and negative numbers gracefully. 3. Avoid using nested loops to ensure the solution is scalable. # Example Explanation: For the input list `[1, 5, 9, -3, 7]`, the minimum value is `-3` and the maximum value is `9`. Therefore, the maximum absolute difference is `9 - (-3) = 12`. For the input list `[-10, -20, -30, -40, -50]`, the minimum value is `-50` and the maximum value is `-10`. Hence, the maximum absolute difference is `-10 - (-50) = 40`.","solution":"def max_absolute_diff(numbers: list) -> int: Returns the maximum absolute difference between any two integers in the input list. if not numbers or len(numbers) < 2: raise ValueError(\\"List must contain at least two elements.\\") min_val = min(numbers) max_val = max(numbers) return abs(max_val - min_val)"},{"question":"# Coding Assessment Question Context In computer graphics, colors are often represented using the RGB color model, where each color is defined by three components: red (R), green (G), and blue (B). Each of these components can have a value ranging from 0 to 255, where 0 means the component is absent, and 255 means it is fully present. You are tasked with creating a function that calculates the average color from a list of RGB color values. Task Implement a function named `average_color` that accepts a list of tuples, where each tuple represents an RGB color. Each tuple contains three integers, representing the red, green, and blue components, respectively. The function should return a tuple with the average red, green, and blue values. Function Signature ```python def average_color(colors: list[tuple[int, int, int]]) -> tuple[int, int, int]: pass ``` Input * `colors` (list of tuples): A list of tuples, where each tuple contains three integers (0-255) representing an RGB color. Output * A tuple with three integers representing the average red, green, and blue components. Constraints * The input list will contain at least one color. * All values in the color tuples will be valid integers between 0 and 255. Examples ```python >>> average_color([(255, 0, 0), (0, 255, 0), (0, 0, 255)]) (85, 85, 85) >>> average_color([(255, 255, 255), (255, 255, 255), (0, 0, 0)]) (170, 170, 170) >>> average_color([(128, 64, 32), (32, 64, 128)]) (80, 64, 80) ``` Additional Notes * Ensure your implementation handles the calculation accurately. * The average should be rounded to the nearest integer. * Consider edge cases such as a single color in the list. [End of Question]","solution":"def average_color(colors): Returns the average color of a list of RGB tuples. Each tuple contains three integers in the range of 0 to 255. num_colors = len(colors) total_red = sum(color[0] for color in colors) total_green = sum(color[1] for color in colors) total_blue = sum(color[2] for color in colors) avg_red = round(total_red / num_colors) avg_green = round(total_green / num_colors) avg_blue = round(total_blue / num_colors) return (avg_red, avg_green, avg_blue)"},{"question":"# Question Title: Database Query Optimization Challenge # Question Description In this task, you are required to write a function that optimizes a set of SQL queries based on given database schema and indexing information. The goal is to enhance the performance of the queries by selecting the most appropriate indexes, taking into account the data distribution and query characteristics. # Function Signature ```python def optimize_queries( db_schema: dict, queries: list[str], data_stats: dict, index_candidates: list[str] ) -> list[str]: pass ``` # Inputs - `db_schema` (Dict): Dictionary where keys are table names and values are lists of columns in each table. - `queries` (List of str): List of SQL queries in string format. - `data_stats` (Dict): Dictionary providing statistics on each table, including the number of rows and distribution of key values. - Example: ```python { \\"table1\\": { \\"row_count\\": 100000, \\"column_stats\\": { \\"column1\\": {\\"unique_values\\": 50, \\"most_common_value_rate\\": 0.1}, \\"column2\\": {\\"unique_values\\": 1000, \\"most_common_value_rate\\": 0.05} } } } ``` - `index_candidates` (List of str): List of potential indexes that can be created. Each string is an SQL command to create an index. # Output - Returns a list of optimized SQL query strings. # Instructions 1. **Index Selection**: - Analyze the provided `index_candidates` and choose the most suitable indexes that will optimize the given `queries`. - Consider the statistics from `data_stats` for effective index selection. 2. **Query Rewriting**: - Modify the original queries if necessary to ensure they make full use of the chosen indexes. - Ensure the changes improve query performance without altering the resulting data set returned by the query. 3. **Performance Considerations**: - Aim to minimize the query execution time and resource usage. - Avoid over-indexing, which might degrade performance due to excessive index maintenance overhead. # Constraints 1. The `db_schema` dictionary accurately describes the structure of the tables and columns that exist in the database. 2. The `data_stats` dictionary provides valid and realistic statistics for each column in the tables. 3. The `index_candidates` list contains valid SQL statements to create the indexes, each targeting specific columns in the tables. # Example Cases Example 1 ```python db_schema = { \\"employees\\": [\\"id\\", \\"name\\", \\"department_id\\", \\"salary\\"], \\"departments\\": [\\"id\\", \\"department_name\\"] } queries = [ \\"SELECT * FROM employees WHERE department_id = 3\\", \\"SELECT name, salary FROM employees ORDER BY salary DESC\\", \\"SELECT department_name, COUNT(*) FROM employees LEFT JOIN departments ON employees.department_id = departments.id GROUP BY department_name\\" ] data_stats = { \\"employees\\": { \\"row_count\\": 100000, \\"column_stats\\": { \\"department_id\\": {\\"unique_values\\": 20, \\"most_common_value_rate\\": 0.1}, \\"salary\\": {\\"unique_values\\": 50000, \\"most_common_value_rate\\": 0.01} } }, \\"departments\\": { \\"row_count\\": 20, \\"column_stats\\": { \\"id\\": {\\"unique_values\\": 20, \\"most_common_value_rate\\": 0.05}, \\"department_name\\": {\\"unique_values\\": 20, \\"most_common_value_rate\\": 0.05} } } } index_candidates = [ \\"CREATE INDEX idx_dept_id ON employees(department_id)\\", \\"CREATE INDEX idx_salary ON employees(salary)\\", \\"CREATE INDEX idx_emp_dept ON employees(department_id, salary)\\" ] optimized_queries = optimize_queries(db_schema, queries, data_stats, index_candidates) ``` Notes - The `optimized_queries` list should contain the rewritten SQL queries after applying the most beneficial indexes. - Ensure that the chosen indexes are balanced considering the query load, data distribution, and maintenance cost. Providing succinct comments in the solution explaining the rationale behind index selections and query modifications can aid in understanding why certain decisions were made.","solution":"def optimize_queries(db_schema, queries, data_stats, index_candidates): Optimizes a set of SQL queries based on provided database schema and index candidates. Args: db_schema (dict): The database schema. queries (list[str]): List of SQL queries. data_stats (dict): Dictionary containing statistics on the data. index_candidates (list[str]): List of potential indexes as SQL commands. Returns: list[str]: List of optimized SQL query strings. # Select indexes which will be used to optimize the queries used_indexes = [] for candidate in index_candidates: # Parse index information table_name = candidate.split(\\" ON \\")[1].split(\\"(\\")[0] columns = candidate.split(\\"(\\")[1].split(\\")\\")[0].split(\\", \\") table_stats = data_stats.get(table_name, {}) if columns: # Determine if the index is likely to be beneficial column_stats = table_stats.get(\\"column_stats\\", {}) if all(column in column_stats for column in columns): used_indexes.append(candidate) # No actual query rewriting needed for the simplistic approach optimized_queries = queries[:] return optimized_queries, used_indexes"},{"question":"# Problem Statement Write a function that takes a list of integers and returns a new list containing the squares of all the even numbers from the original list. # Input - A list of integers `nums` with length `n` (1 <= n <= 1000) # Output - A new list of integers containing the squares of all the even numbers from the input list. # Constraints - -10^4 <= nums[i] <= 10^4 for each integer in `nums` # Example ```python square_even_numbers([1, 2, 3, 4, 5]) ``` Expected Output: ```python [4, 16] ``` ```python square_even_numbers([7, 8, 10, 13]) ``` Expected Output: ```python [64, 100] ``` # Implementation ```python from typing import List def square_even_numbers(nums: List[int]) -> List[int]: return [num ** 2 if num % 2 == 0 else None for num in nums if num % 2 == 0] ```","solution":"from typing import List def square_even_numbers(nums: List[int]) -> List[int]: Takes a list of integers and returns a new list containing the squares of all the even numbers from the original list. Args: nums (List[int]): A list of integers Returns: List[int]: A list of squared even integers return [num ** 2 for num in nums if num % 2 == 0]"},{"question":"# Task: Implement a Priority Queue using Binary Heap Context: A logistics company needs to efficiently manage and prioritize shipments. To optimize their operations, they require a priority queue that can handle dynamic shipment requests based on urgency. You are tasked with implementing a priority queue using a binary heap to ensure fast access to the highest priority shipment. Problem: Implement a `PriorityQueue` class using a binary heap. The priority queue should support inserting elements with different priority levels and extracting the element with the highest priority. Requirements: - **Key Functionality**: - Implement a binary heap to maintain the priority queue. - Support insertion of elements with associated priority levels. - Allow extraction of the highest priority element. - Ensure the heap maintains its properties after each insertion and extraction. - **Input/Output**: ```python class PriorityQueue: def __init__(self) -> None: # Initialize the priority queue (binary heap) self.heap = [] def insert(self, element, priority): # inserts an element with the given priority pass def extract_max(self): # extracts the element with the highest priority pass ``` - **Constraints**: - Elements can have any priority, with higher numbers indicating higher priority. - Handle typical test cases, edge cases, and erroneous scenarios gracefully. - **Performance Expectations**: - Insertion and extraction operations should have an average-case time complexity of O(log n). Function Signatures: You need to define the following: ```python def insert(self, element, priority): def extract_max(self): ``` Example: ```python pq = PriorityQueue() pq.insert(\'shipment1\', 5) pq.insert(\'shipment2\', 3) pq.insert(\'shipment3\', 9) print(pq.extract_max()) # Output: \'shipment3\' print(pq.extract_max()) # Output: \'shipment1\' print(pq.extract_max()) # Output: \'shipment2\' ``` Implement the `PriorityQueue` class using a binary heap for managing and prioritizing shipments.","solution":"class PriorityQueue: def __init__(self) -> None: self.heap = [] def _parent(self, index): return (index - 1) // 2 def _left_child(self, index): return 2 * index + 1 def _right_child(self, index): return 2 * index + 2 def _swap(self, i, j): self.heap[i], self.heap[j] = self.heap[j], self.heap[i] def _heapify_up(self, index): while index > 0 and self.heap[self._parent(index)][1] < self.heap[index][1]: self._swap(index, self._parent(index)) index = self._parent(index) def _heapify_down(self, index): max_index = index left = self._left_child(index) right = self._right_child(index) if left < len(self.heap) and self.heap[left][1] > self.heap[max_index][1]: max_index = left if right < len(self.heap) and self.heap[right][1] > self.heap[max_index][1]: max_index = right if max_index != index: self._swap(index, max_index) self._heapify_down(max_index) def insert(self, element, priority): self.heap.append((element, priority)) self._heapify_up(len(self.heap) - 1) def extract_max(self): if not self.heap: raise IndexError(\\"extract_max from an empty priority queue\\") self._swap(0, len(self.heap) - 1) max_element = self.heap.pop() if self.heap: self._heapify_down(0) return max_element[0]"},{"question":"# Find the Missing Number You are required to write a function that finds the missing number in an array containing n distinct numbers taken from the range 0 to n. The array has size n-1, thus one number is missing from the complete set. Function Signature ```python def find_missing_number(nums: list) -> int: ``` Input - `nums` (list): A list of n-1 integers taken from the range [0, n], representing the complete set with one missing number. Constraints: 1 ≤ len(nums) ≤ 10^5, 0 ≤ nums[i] ≤ len(nums). Output - (int): The missing number from the array. Constraints - Your function should raise a `TypeError` if the input is not a list. - Your function should raise a `ValueError` if the list contains invalid elements (e.g., duplicates, out-of-range numbers). Examples ```python print(find_missing_number([3, 0, 1])) # Output: 2 print(find_missing_number([0, 1])) # Output: 2 print(find_missing_number([9,6,4,2,3,5,7,0,1])) # Output: 8 print(find_missing_number([0])) # Output: 1 ``` Notes - Ensure that the function works efficiently for large inputs within the specified range. - Consider using arithmetic properties or bit manipulation to find the missing number efficiently. - Be mindful of edge cases such as very small or large inputs and ensure appropriate error handling.","solution":"def find_missing_number(nums: list) -> int: if not isinstance(nums, list): raise TypeError(\\"Input must be a list\\") n = len(nums) if not all(isinstance(x, int) for x in nums): raise ValueError(\\"All elements in the list must be integers\\") expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) if len(set(nums)) != len(nums): raise ValueError(\\"List contains duplicate elements\\") for num in nums: if num < 0 or num > n: raise ValueError(\\"List contains out-of-range elements\\") return expected_sum - actual_sum"},{"question":"# Scenario: You are developing a spell-checking feature for a word processor. The feature needs to suggest the closest correct spelling for a given word based on a dictionary of valid English words. The closeness is determined by the minimum number of single-character edits (insertions, deletions, or substitutions) required to transform the given word into any dictionary word. # Problem Description: Implement the function `spell_check(word, dictionary)` that finds and returns the dictionary word with the smallest edit distance to the input word. If there are multiple words with the same minimum edit distance, return any one of them. # Function Signature: ```python def spell_check(word: str, dictionary: List[str]) -> str: ``` # Input: 1. `word` (str): A string representing the misspelled word. 2. `dictionary` (List[str]): A list of strings representing the dictionary of valid words. # Output: - Returns a string representing the closest correct spelling from the dictionary based on the smallest edit distance. # Constraints: - 1 <= len(word) <= 100 - 1 <= len(dictionary) <= 10^4 - 1 <= len(dictionary[i]) <= 100 # Requirements: 1. Use dynamic programming to compute edit (Levenshtein) distance. 2. Handle edge cases such as an empty string for the input word and dictionary words appropriately. # Example: ```python from typing import List def edit_distance(word1: str, word2: str) -> int: m, n = len(word1), len(word2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) return dp[m][n] def spell_check(word: str, dictionary: List[str]) -> str: closest_word = dictionary[0] min_distance = edit_distance(word, closest_word) for dict_word in dictionary[1:]: current_distance = edit_distance(word, dict_word) if current_distance < min_distance: closest_word = dict_word min_distance = current_distance return closest_word # Example usage: print(spell_check(\\"speling\\", [\\"spelling\\", \\"spelt\\", \\"spell\\"])) # Output: \\"spelling\\" ``` Use the provided unit test to validate your implementation.","solution":"from typing import List def edit_distance(word1: str, word2: str) -> int: m, n = len(word1), len(word2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) return dp[m][n] def spell_check(word: str, dictionary: List[str]) -> str: closest_word = dictionary[0] min_distance = edit_distance(word, closest_word) for dict_word in dictionary[1:]: current_distance = edit_distance(word, dict_word) if current_distance < min_distance: closest_word = dict_word min_distance = current_distance return closest_word"},{"question":"# Problem Description You are given a list of unsorted integers where each integer appears exactly twice except for one unique integer that appears only once. Your task is to find that unique integer. # Input A function `find_single_number(nums: list[int]) -> int` that takes a list of integers `nums`. # Output The function should return an integer representing the unique number that appears only once in the list. # Constraints * The input list `nums` will always contain an odd number of integers. * `1 <= len(nums) <= 10^5` * `-10^9 <= nums[i] <= 10^9` # Example ```python assert find_single_number([2, 3, 2, 4, 3]) == 4 assert find_single_number([1, 1, 2, 2, 3]) == 3 assert find_single_number([10, 10, 20]) == 20 ``` # Explanation 1. **Input**: `[2, 3, 2, 4, 3]` **Output**: `4` **Explanation**: The integer 4 appears only once, while each of 2 and 3 appear twice. 2. **Input**: `[1, 1, 2, 2, 3]` **Output**: `3` **Explanation**: The integer 3 appears only once, while each of 1 and 2 appear twice. 3. **Input**: `[10, 10, 20]` **Output**: `20` **Explanation**: The integer 20 appears only once, while the integer 10 appears twice. You need to ensure your implementation efficiently handles the given constraints and edge cases correctly.","solution":"def find_single_number(nums): Given a list of integers where each integer appears exactly twice except for one integer, this function returns the integer that appears only once. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Binary to Decimal Conversion You have been asked to develop a Python function that converts a binary string into its corresponding decimal (base 10) integer value. This function will help students understand the relationship between binary and decimal number systems. **Problem Statement**: Write a function `binary_to_decimal(binary_str: str) -> int` that takes one argument: - `binary_str`: A string representing a binary number (composed only of the characters \'0\' and \'1\'). The function should return an integer representing the decimal equivalent of the binary number. **Input Constraints**: - `binary_str` is a non-empty string containing only \'0\' and \'1\' characters. **Requirements**: 1. Ensure the function handles binary strings of varying lengths, including very large binary numbers. 2. Validate that the `binary_str` contains only \'0\' and \'1\'. If it contains any other character, the function should raise a `ValueError` with a descriptive error message. 3. The function should efficiently convert the binary string to its decimal equivalent. **Example**: ```python >>> binary_to_decimal(\\"1101\\") 13 >>> binary_to_decimal(\\"1010\\") 10 >>> binary_to_decimal(\\"100000\\") 32 >>> binary_to_decimal(\\"11111\\") 31 >>> binary_to_decimal(\\"1\\") 1 >>> binary_to_decimal(\\"0\\") 0 ``` **Instructions**: - Implement the function to handle typical input sizes within reasonable computational limits. - Ensure the function raises appropriate errors for invalid inputs. - Test the function with various binary strings to ensure its accuracy and robustness.","solution":"def binary_to_decimal(binary_str: str) -> int: Convert a binary string to its decimal equivalent. Args: - binary_str (str): A string representing a binary number. Returns: - int: The decimal equivalent of the binary number. Raises: - ValueError: If the input string contains characters other than \'0\' and \'1\'. # Validate input string if any(char not in \'01\' for char in binary_str): raise ValueError(\\"Input string must contain only \'0\' and \'1\'.\\") # Convert binary string to decimal decimal_value = 0 for char in binary_str: decimal_value = decimal_value * 2 + int(char) return decimal_value"},{"question":"# Coding Assessment Question You are implementing a feature for a calendar application that schedules meetings while avoiding conflicts. Each meeting is represented by its start and end times in minutes since the start of the day (e.g., a meeting starting at 9:00 AM and ending at 10:00 AM would be represented as (540, 600)). Objective: Write a function `find_conflicts(meetings: List[Tuple[int, int]]) -> List[Tuple[int, int]]` that takes a list of tuples representing the scheduled meetings and returns a list of tuples representing the meetings that overlap with any other meeting. Input: - `meetings` (1 <= len(meetings) <= 10^4): A list of tuples where each tuple contains two integers representing the start and end times of a meeting in minutes since the start of the day. Output: - Returns a list of tuples representing the meetings that overlap with at least one other meeting, in the order they were provided. Example: ```python assert find_conflicts([(30, 150), (540, 600), (560, 610), (600, 620)]) == [(540, 600), (560, 610), (600, 620)] assert find_conflicts([(0, 50), (60, 120), (130, 180)]) == [] ``` Constraints: - Your solution should have a time complexity of O(n log n). - Handle edge cases where meetings might start or end precisely at the boundary of another meeting. Performance Requirements: - Use efficient sorting and comparison techniques to ensure optimal performance. - Avoid unnecessary iterations and redundant checks to manage large lists of meetings efficiently.","solution":"from typing import List, Tuple def find_conflicts(meetings: List[Tuple[int, int]]) -> List[Tuple[int, int]]: # Sort the meetings based on start time to easily find overlaps sorted_meetings = sorted(meetings, key=lambda x: x[0]) result = [] prev_end = -1 for i in range(len(sorted_meetings)): start, end = sorted_meetings[i] if start < prev_end: # There\'s a conflict if sorted_meetings[i] not in result: result.append(sorted_meetings[i]) # Also add the previous meeting if it\'s not added yet if sorted_meetings[i-1] not in result: result.append(sorted_meetings[i-1]) prev_end = max(prev_end, end) return [meeting for meeting in meetings if meeting in result]"},{"question":"Concert Ticket Management System You are tasked with creating a basic concert ticket management system. The system should support the following operations: 1. **Adding Tickets**: Add a designated number of tickets for a concert. 2. **Booking Tickets**: Book a specific number of tickets for a concert, if available. 3. **Getting Available Tickets**: Retrieve the number of remaining tickets for a concert. To simulate this system, write a class `TicketManager` that manages ticket operations. Below is a detailed specification of the required class and methods: Class Specification **Class**: `TicketManager` **Methods**: 1. `add_tickets(concert: str, quantity: int) -> None` - Adds `quantity` tickets for the specified `concert`. 2. `book_tickets(concert: str, quantity: int) -> str` - Books `quantity` tickets for the specified `concert` if sufficient tickets are available. If not, return a message indicating insufficient tickets. - Returns \\"Successfully booked {quantity} tickets for {concert}\\" if booking is successful. - Returns \\"Insufficient tickets for {concert}\\" if the booking can\'t be completed due to insufficient tickets. 3. `get_available_tickets(concert: str) -> int` - Returns the number of available tickets for the specified `concert`. If no tickets for the concert have been added, return 0. Examples ```python >>> tm = TicketManager() >>> tm.add_tickets(\\"RockFest\\", 100) >>> tm.add_tickets(\\"JazzNight\\", 50) >>> tm.book_tickets(\\"RockFest\\", 30) \\"Successfully booked 30 tickets for RockFest\\" >>> tm.book_tickets(\\"RockFest\\", 80) \\"Insufficient tickets for RockFest\\" >>> tm.get_available_tickets(\\"RockFest\\") 70 >>> tm.get_available_tickets(\\"JazzNight\\") 50 >>> tm.get_available_tickets(\\"HipHopGala\\") 0 ``` Constraints 1. All inputs for `concert` will be valid non-empty strings. 2. All inputs for `quantity` will be non-negative integers. 3. Assume no two concerts share the same name. 4. The operations should be efficient and handle a large number of concerts and ticket quantities. Implement the required class and methods in Python.","solution":"class TicketManager: def __init__(self): self.concerts = {} def add_tickets(self, concert: str, quantity: int) -> None: if concert in self.concerts: self.concerts[concert] += quantity else: self.concerts[concert] = quantity def book_tickets(self, concert: str, quantity: int) -> str: if concert not in self.concerts or self.concerts[concert] < quantity: return f\\"Insufficient tickets for {concert}\\" else: self.concerts[concert] -= quantity return f\\"Successfully booked {quantity} tickets for {concert}\\" def get_available_tickets(self, concert: str) -> int: return self.concerts.get(concert, 0)"},{"question":"**Problem Statement: Kinetic Energy Calculation** You are required to write a function that calculates the kinetic energy of a moving object. The kinetic energy is given by the formula: [ KE = frac{1}{2}mv^2 ] where: - ( m ) is the mass of the object in kilograms (kg). - ( v ) is the velocity of the object in meters per second (m/s). # Function Signature ```python def kinetic_energy(mass: float, velocity: float) -> float: pass ``` # Input: - `mass` (float): The mass of the object in kilograms. Must be positive. - `velocity` (float): The velocity of the object in meters per second. Can be negative, zero, or positive. # Output: - A float value representing the kinetic energy of the object in joules (J). # Constraints: - Mass must be greater than 0 kg. - Velocity is a real number and can be negative, zero, or positive. # Example: ```python >>> kinetic_energy(2, 3) 9.0 >>> kinetic_energy(5, -4) 40.0 >>> kinetic_energy(0.5, 10) 25.0 ``` # Performance Requirements: - The function should operate in constant time, O(1). # Edge Cases: - Handle cases where the velocity is zero. - Handle cases where the mass is a very small positive value. # Implementation: 1. Validate the inputs. 2. Calculate the kinetic energy using the formula. 3. Return the calculated kinetic energy. Implement the function `kinetic_energy` accordingly.","solution":"def kinetic_energy(mass: float, velocity: float) -> float: Calculate the kinetic energy of a moving object. Parameters: - mass (float): The mass of the object in kilograms. Must be positive. - velocity (float): The velocity of the object in meters per second. Can be negative, zero, or positive. Returns: - float: The kinetic energy of the object in joules. if mass <= 0: raise ValueError(\\"Mass must be greater than zero.\\") return 0.5 * mass * velocity * velocity"},{"question":"# Question: Monitor and Alert for Temperature Anomalies In this task, you will handle temperature data from a weather monitoring service. Your goal is to implement two functions to fetch and analyze temperature data. Task 1: **Calculate Average Temperature for a Date Range** Write a function `calculate_average_temperature(start: str, end: str) -> float` that takes two date strings (`start` and `end`) in the format \\"YYYY-MM-DD\\". This function should fetch temperature data for the given date range and return the average temperature. Task 2: **Detect Sudden Temperature Drops** Write a function `detect_temperature_drop(threshold: float) -> str` that fetches temperature data for the last 48 hours in hourly intervals. This function should check for any sudden temperature drop greater than the given threshold. Return the timeframe (e.g., \\"YYYY-MM-DD HH:MM\\") when the drop occurred, or \\"No sudden temperature drop\\" if no significant drop is detected. # Input and Output Formats * **Task 1**: - **Input**: Two strings representing start and end dates (e.g., `calculate_average_temperature(\\"2021-06-01\\", \\"2021-06-05\\")`). - **Output**: A float representing the average temperature. * **Task 2**: - **Input**: A float threshold (e.g., `detect_temperature_drop(5.0)`). - **Output**: A string representing the timeframe or \\"No sudden temperature drop\\". # Constraints - Dates provided for `start` and `end` are valid and sequential. - Handle any potential network or data processing errors gracefully. - Ensure responses from the weather monitoring service are processed efficiently. # Example Scenarios * `calculate_average_temperature(\\"2021-06-01\\", \\"2021-06-05\\")` might return `21.5` if the average temperature over the range is 21.5°C. * `detect_temperature_drop(7.0)` might return `\\"2021-06-03 04:00\\"` if a sudden drop of greater than 7°C occurred at that time, or \\"No sudden temperature drop\\" if no such drop is detected. Make sure your implementation adheres to the provided constraints and efficiently handles the data fetched.","solution":"import requests from datetime import datetime, timedelta API_URL = \\"https://api.weather.com/v1/location/{location}/observations/historical.json\\" def get_temperature_data(start: str, end: str): Fetches temperature data from the weather API for the given date range. Here, we are assuming that \'location\' and \'apiKey\' are already defined. try: response = requests.get(API_URL, params={ \'apiKey\': API_KEY, \'startDate\': start, \'endDate\': end }) response.raise_for_status() return response.json() except requests.exceptions.RequestException as e: print(f\\"Network or API error: {e}\\") return [] def calculate_average_temperature(start: str, end: str) -> float: Calculate the average temperature for the given date range. data = get_temperature_data(start, end) temperatures = [record[\'temperature\'] for record in data[\'observations\']] return sum(temperatures) / len(temperatures) if temperatures else 0.0 def detect_temperature_drop(threshold: float) -> str: Detects any sudden temperature drop greater than the given threshold in the past 48 hours. end_date = datetime.utcnow() start_date = end_date - timedelta(hours=48) data = get_temperature_data(start_date.strftime(\\"%Y%m%d\\"), end_date.strftime(\\"%Y%m%d\\")) temperatures = [(record[\'validTimeLocal\'], record[\'temperature\']) for record in data[\'observations\']] for i in range(1, len(temperatures)): temp_diff = temperatures[i-1][1] - temperatures[i][1] if temp_diff > threshold: return temperatures[i][0] return \\"No sudden temperature drop\\""},{"question":"# Dynamic Circular Buffer Implementation **Background**: A dynamic circular buffer allows data to be added and removed in a way that wraps around when the end of the buffer is reached. It is useful in scenarios like streaming data where a fixed-size buffer needs to efficiently handle continuous data input and output while overwriting older data when the buffer is full. **Objective**: Implement a dynamic circular buffer that can handle continuous data input, manage read and write pointers effectively, and dynamically resize when the buffer is full to avoid data loss. **Task**: 1. Implement the `CircularBuffer` class with methods to initialize the buffer, add elements, remove elements, resize the buffer, and retrieve the current state of the buffer. 2. Write a function `test_circular_buffer_operations()` to test various operations on the circular buffer. **Class Signature**: ```python class CircularBuffer: def __init__(self, size: int): pass def add(self, value: int) -> None: pass def remove(self) -> int: pass def resize(self, new_size: int) -> None: pass def get_buffer(self) -> list[int]: pass ``` **Method Descriptions**: - `__init__(self, size: int)`: Initializes a circular buffer with the given size. - `add(self, value: int) -> None`: Adds a new element to the buffer. If the buffer is full, it should resize to accommodate the new element. - `remove(self) -> int`: Removes and returns the oldest element from the buffer. If the buffer is empty, it should return -1 or raise an appropriate exception. - `resize(self, new_size: int) -> None`: Resizes the buffer to the new size, preserving the current data. - `get_buffer(self) -> list[int]`: Returns the current state of the buffer as a list of integers. **Input**: - Methods will be called with integers as arguments for size, value, and new_size. **Output**: - Methods return either `None` or the appropriate data as integers or lists. **Constraints**: - Initial buffer size will be such that `1 <= size <= 100`. - Buffer values will be integers within the range `-10^6` to `10^6`. - Resize operations will result in a new buffer size that is greater than or equal to the current size. **Example Usage**: ```python def test_circular_buffer_operations(): buffer = CircularBuffer(3) buffer.add(1) buffer.add(2) print(buffer.get_buffer()) # Output: [1, 2] buffer.add(3) print(buffer.get_buffer()) # Output: [1, 2, 3] buffer.add(4) # Buffer is full, should resize print(buffer.get_buffer()) # Output: [1, 2, 3, 4] removed = buffer.remove() print(removed) # Output: 1 print(buffer.get_buffer()) # Output: [2, 3, 4] buffer.resize(6) print(buffer.get_buffer()) # Output: [2, 3, 4] buffer.add(5) buffer.add(6) buffer.add(7) print(buffer.get_buffer()) # Output: [2, 3, 4, 5, 6, 7] ``` You can use the provided method signatures to implement each class method and complete the circular buffer functionality.","solution":"class CircularBuffer: def __init__(self, size: int): self.size = size self.buffer = [None] * size self.read_pointer = 0 self.write_pointer = 0 self.count = 0 def add(self, value: int) -> None: if self.count == self.size: self.resize(self.size * 2) self.buffer[self.write_pointer] = value self.write_pointer = (self.write_pointer + 1) % self.size self.count += 1 def remove(self) -> int: if self.count == 0: raise IndexError(\\"remove from empty buffer\\") value = self.buffer[self.read_pointer] self.buffer[self.read_pointer] = None self.read_pointer = (self.read_pointer + 1) % self.size self.count -= 1 return value def resize(self, new_size: int) -> None: new_buffer = [None] * new_size for i in range(self.count): new_buffer[i] = self.buffer[(self.read_pointer + i) % self.size] self.buffer = new_buffer self.size = new_size self.read_pointer = 0 self.write_pointer = self.count def get_buffer(self) -> list: return [self.buffer[(self.read_pointer + i) % self.size] for i in range(self.count)]"},{"question":"# Scenario You are working on a project that involves manipulating a large dataset of user interaction logs. For efficient analysis, you need to implement a data structure that supports the ability to track the count of unique types of user interactions in near real-time. # Challenge Create a `RealTimeCounter` class that can efficiently track and update the counts of various interaction types using a dictionary-based approach. Your class should support the insertion of interaction types, incrementing their respective counts, and querying the current count of any interaction type. # Task 1. Implement the `add_interaction` method to insert and/or increment the count of a given interaction type. 2. Implement the `get_count` method to retrieve the current count of a specific interaction type. 3. Implement the `most_frequent_interaction` method to return the interaction type with the highest count. If there are multiple interaction types with the same highest count, return any one of them. # Requirements - Implement the methods as specified. - Ensure the dictionary correctly tracks counts of various interaction types. - Optimize for both insertion and query performance. - Handle edge cases such as querying non-existent interaction types. # Input and Output - Input: A series of interaction types to be inserted and a specific interaction type to query. - Output: For each query, return the current count of the interaction type and the most frequent interaction type when requested. # Example Suppose you have the following sequence of operations: ```python rtc = RealTimeCounter() rtc.add_interaction(\\"click\\") print(rtc.get_count(\\"click\\")) # Output: 1 rtc.add_interaction(\\"click\\") print(rtc.get_count(\\"click\\")) # Output: 2 rtc.add_interaction(\\"hover\\") print(rtc.get_count(\\"hover\\")) # Output: 1 print(rtc.most_frequent_interaction()) # Output: \\"click\\" ``` # Constraints - Interaction types are unique strings. - Counts are non-negative integers. - The number of unique interaction types is a positive integer. Implement the `RealTimeCounter` class with the required methods and ensure it efficiently handles real-time interaction count tracking and querying. ```python class RealTimeCounter: def __init__(self): self.interactions = {} def add_interaction(self, interaction_type): if interaction_type in self.interactions: self.interactions[interaction_type] += 1 else: self.interactions[interaction_type] = 1 def get_count(self, interaction_type): return self.interactions.get(interaction_type, 0) def most_frequent_interaction(self): if not self.interactions: return None return max(self.interactions, key=self.interactions.get) ```","solution":"class RealTimeCounter: def __init__(self): self.interactions = {} def add_interaction(self, interaction_type): Inserts or increments the count of a given interaction type. if interaction_type in self.interactions: self.interactions[interaction_type] += 1 else: self.interactions[interaction_type] = 1 def get_count(self, interaction_type): Retrieves the current count of a specific interaction type. If the interaction type does not exist, returns 0. return self.interactions.get(interaction_type, 0) def most_frequent_interaction(self): Returns the interaction type with the highest count. If there are multiple interaction types with the same highest count, returns any one of them. If there are no interactions, returns None. if not self.interactions: return None return max(self.interactions, key=self.interactions.get)"},{"question":"**Question: Network Delay Time** **Context:** Bob is working on a network simulation and needs to determine how long it will take for a signal to reach all nodes in a network. Each node represents a computer and the edges represent the transmission times between them. Bob is given a starting node and needs to calculate the time it will take for a signal to reach all nodes in the network. **Task:** Your task is to implement a function that calculates the minimum time required for a signal to reach all nodes in the network from the starting node. If it\'s impossible for the signal to reach all nodes, the function should return -1. **Function Signature:** ```python def network_delay_time(times: list, N: int, K: int) -> int: pass ``` **Input:** - `times` (a list of tuples): Each tuple (u, v, w) represents an edge where node `u` can transmit a signal to node `v` in `w` units of time. - `N` (int): The total number of nodes in the network. - `K` (int): The starting node. **Output:** - An integer representing the minimum time required for the signal to reach all nodes, or -1 if it\'s impossible. **Constraints:** - `1 <= N <= 100` - `1 <= K <= N` - `1 <= times.length <= 6000` - `1 <= u, v <= N` - `1 <= w <= 100` **Examples:** 1. `network_delay_time([(2, 1, 1), (2, 3, 1), (3, 4, 1)], 4, 2)` should return `2`. 2. `network_delay_time([(1, 2, 1)], 2, 1)` should return `1`. 3. `network_delay_time([(1, 2, 1)], 2, 2)` should return `-1`. **Additional Notes:** 1. Utilize Dijkstra\'s algorithm to find the shortest path from the starting node to all other nodes. 2. Ensure that the function efficiently handles various graph structures within the provided constraints. 3. If there is a node that cannot be reached from the starting node, the function should return -1.","solution":"import heapq import collections def network_delay_time(times, N, K): Calculate the minimum time required for a signal to reach all nodes in the network from starting node K. :param times: List of tuples (u, v, w), each representing an edge with transmission time w from node u to v. :param N: The total number of nodes in the network. :param K: The starting node. :return: Minimum time required for the signal to reach all nodes, or -1 if it\'s impossible. graph = collections.defaultdict(list) for u, v, w in times: graph[u].append((v, w)) min_heap = [(0, K)] dist = {} while min_heap: time, node = heapq.heappop(min_heap) if node in dist: continue dist[node] = time for v, w in graph[node]: if v not in dist: heapq.heappush(min_heap, (time + w, v)) if len(dist) == N: return max(dist.values()) return -1"},{"question":"**Problem Statement: Tron Light Cycle Simulation** In a simplified version of the Tron light cycle game, two players move around a grid. Each player can move in one of four directions (up, down, left, or right). The game takes place on a rectangular grid where each cell can either be empty or occupied by a barrier. You need to implement a function that determines if a player can move from their current position to a target position without hitting any barriers. # Function Signature ```python def can_move(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool: pass ``` # Input: - `grid` (List[List[int]]): A 2D list representing the game grid where 0 represents an empty cell and 1 represents a barrier. - `start` (Tuple[int, int]): A tuple representing the starting position (row, column). - `end` (Tuple[int, int]): A tuple representing the target position (row, column). # Output: - A boolean value: `True` if the player can move from `start` to `end` without hitting any barriers, `False` otherwise. # Constraints: - Assume the grid has at least one cell: 1 <= `rows`, `columns` <= 100. - The start and end positions are within the grid boundaries. - The start and end positions are not barriers themselves. # Example: ```python >>> grid = [ [0, 0, 0, 1], [0, 1, 0, 0], [0, 0, 0, 0], [1, 0, 1, 0] ] >>> start = (0, 0) >>> end = (2, 2) >>> can_move(grid, start, end) True >>> start = (0, 0) >>> end = (3, 0) >>> can_move(grid, start, end) False ``` # Performance Requirements: - The function should operate efficiently even for the maximum grid size. # Edge Cases: - Handle cases where the start and end positions are the same. - Handle cases where there are no possible paths due to barriers. # Implementation: 1. Use a traversal algorithm (e.g., BFS or DFS) to check if a path exists between the start and end positions. 2. Return `True` if a path is found, otherwise return `False`. Implement the function `can_move` accordingly.","solution":"from typing import List, Tuple from collections import deque def can_move(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool: rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and grid[x][y] == 0 queue = deque([start]) visited = set() visited.add(start) while queue: x, y = queue.popleft() if (x, y) == end: return True for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"# Inventory Management System Imagine you are developing an inventory management system for a warehouse. Your task is to implement a function `reorder_items(inventory: dict, threshold: int) -> list[str]` that identifies items in the inventory which need to be reordered based on their stock levels. The inventory is represented as a dictionary where keys are item names (strings) and values are the current stock levels (integers). An item needs to be reordered if its current stock level is less than or equal to a specified threshold. **Function Signature:** ```python def reorder_items(inventory: dict, threshold: int) -> list[str]: pass ``` **Input:** - `inventory`: A dictionary representing the inventory, where keys are item names (strings) and values are integers representing the current stock levels. - `threshold`: An integer representing the stock level threshold for reordering items. **Output:** - A list of strings, containing the names of items that need to be reordered. The order of the items in the output list does not matter. **Constraints:** - Number of items in the inventory can be between 0 and 10,000. - Item names are alphanumeric strings of length up to 20. - Stock levels are non-negative integers. **Example:** ```python inventory = { \\"itemA\\": 3, \\"itemB\\": 10, \\"itemC\\": 5, \\"itemD\\": 2, \\"itemE\\": 8, } threshold = 4 # Expected Output # The order of items may vary # For instance -> [\\"itemA\\", \\"itemC\\", \\"itemD\\"] assert set(reorder_items(inventory, threshold)) == {\\"itemA\\", \\"itemC\\", \\"itemD\\"} ``` **Notes:** - Ensure your function handles cases with no items and items with stock levels at exactly the threshold. - Consider optimizing for performance given the potential size of the inventory.","solution":"def reorder_items(inventory, threshold): Identifies items in the inventory that need to be reordered based on their stock levels. Parameters: inventory (dict): A dictionary where key is the item name (str) and value is the stock level (int). threshold (int): The stock level threshold for reordering items. Returns: list[str]: A list of item names that need to be reordered. return [item for item, stock in inventory.items() if stock <= threshold]"},{"question":"# Context You are working on a custom logging system for a multi-threaded server application. The logger must handle concurrent write operations without corrupting the log data. The log messages are written to a common log file, and each message is prefixed with a timestamp and a thread identifier. # Task Your task is to complete the `Logger` class to ensure that: - Log messages are written to the log file in a thread-safe manner. - Each log message is prefixed with the current timestamp and a unique identifier for the thread that generated the message. # Requirements 1. Implement the `Logger` class with the following methods: - `__init__(self, log_file: str)`: Initialize the logger with the given log file name. - `log(self, message: str)`: Write a log message to the log file with the correct prefix. 2. Ensure that the `log` method is thread-safe. 3. Optimize for minimal latency in logging operations. # Input - `log_file`: A string representing the filename where logs should be written. - `message`: A string representing the log message to be written. # Output No direct output since the log messages will be written to the specified log file. # Function Signatures ```python class Logger: def __init__(self, log_file: str): pass def log(self, message: str) -> None: pass ``` # Example Assuming three threads are logging messages almost simultaneously: ```python # Thread 1 Logger.log(\\"Started processing request\\") # Thread 2 Logger.log(\\"Database query executed\\") # Thread 3 Logger.log(\\"Response sent to client\\") ``` The content of the log file after execution might look like this: ``` [2023-10-15 13:45:23.123456] [Thread-1] Started processing request [2023-10-15 13:45:23.124789] [Thread-2] Database query executed [2023-10-15 13:45:23.125678] [Thread-3] Response sent to client ``` # Constraints - The log file must be accessible and writable by the server process. - You should not make assumptions about the number of threads or the frequency of log messages.","solution":"import threading import datetime class Logger: def __init__(self, log_file: str): self.log_file = log_file self.lock = threading.Lock() def log(self, message: str) -> None: timestamp = datetime.datetime.now().strftime(\\"%Y-%m-%d %H:%M:%S.%f\\") thread_name = threading.current_thread().name log_entry = f\\"[{timestamp}] [{thread_name}] {message}n\\" with self.lock: with open(self.log_file, \'a\') as file: file.write(log_entry)"},{"question":"# Problem Statement You are tasked with implementing a function that determines the order of characters in an alien language. Given a sorted dictionary of an alien language and the number of characters, your goal is to determine the correct character order. # Function Signature ```python def find_alien_dictionary(words: List[str], num_chars: int) -> str: pass ``` # Input and Output The function should take: * `words`: a list of strings representing the sorted dictionary in the alien language. * `num_chars`: an integer representing the number of distinct characters in the alien language. The function should return a string representing the characters of the alien language in the correct order. # Constraints * Each word in the dictionary consists only of lowercase English letters. * All the characters of the alien language will appear in the sorted dictionary. * The length of the words list will be at most 100. * Each word will have a length of at most 100. # Explanation and Example To determine the order of characters in the alien language: 1. Construct a graph where each node is a character, and a directed edge from node U to node V implies that character U appears before character V. 2. Perform a topological sort on the graph to determine the correct character order. Example ``` find_alien_dictionary([\\"wrt\\", \\"wrf\\", \\"er\\", \\"ett\\", \\"rftt\\"], 5) ``` This will process the following steps: 1. \\"wrt\\" -> \\"wrf\\": `t` comes before `f`. 2. \\"wrf\\" -> \\"er\\": `w` comes before `e`. 3. \\"er\\" -> \\"ett\\": `r` comes before `t`. 4. \\"ett\\" -> \\"rftt\\": `e` comes before `r`. Based on the above information, a possible valid order of characters is: ``` \\"wertf\\" ``` # Note Make sure to handle edge cases effectively, including: * When the input dictionary is empty. * When multiple valid orders exist — return any one of them.","solution":"from collections import defaultdict, deque from typing import List def find_alien_dictionary(words: List[str], num_chars: int) -> str: # Step 1: Create a graph (adjacency list) and count the in-degrees of nodes graph = defaultdict(set) in_degree = {char: 0 for word in words for char in word} # Step 2: Build the graph by comparing adjacent words for i in range(len(words) - 1): word1, word2 = words[i], words[i + 1] min_length = min(len(word1), len(word2)) for j in range(min_length): if word1[j] != word2[j]: if word2[j] not in graph[word1[j]]: graph[word1[j]].add(word2[j]) in_degree[word2[j]] += 1 break else: if len(word1) > len(word2): return \\"\\" # Invalid case: prefix rule violated # Step 3: Topological sort using Kahn\'s Algorithm zero_in_degree_queue = deque([char for char in in_degree if in_degree[char] == 0]) topo_order = [] while zero_in_degree_queue: current_char = zero_in_degree_queue.popleft() topo_order.append(current_char) for neighbor in graph[current_char]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) if len(topo_order) != len(in_degree): return \\"\\" # Cycle detected or graph incomplete return \\"\\".join(topo_order)"},{"question":"# Coding Assessment Question: Sum of Unique Elements **Context**: Handling arrays and identifying unique elements are common tasks in programming. Summing only the unique elements of an array can be a useful operation to test your understanding of sets and dictionaries in Python. **Objective**: Write a function `sum_of_unique_elements(nums: List[int]) -> int` that returns the sum of all unique integers in the array `nums`. **Function Signature**: ```python def sum_of_unique_elements(nums: List[int]) -> int: pass ``` # Input: - A list of integers `nums` where `1 <= len(nums) <= 10^5` and `-10^6 <= nums[i] <= 10^6`. # Output: - An integer representing the sum of unique elements in the array. # Constraints: - Each element in the list can be a positive or negative integer. - You must handle large inputs efficiently within the provided constraints. # Examples: ```python >>> sum_of_unique_elements([1, 2, 3, 2, 4]) 10 >>> sum_of_unique_elements([1, 1, 1, 1, 1]) 1 >>> sum_of_unique_elements([0, -1, 1]) 0 >>> sum_of_unique_elements([-1, -2, -2, -3, -4]) -10 >>> sum_of_unique_elements([1000000, -1000000, 1000000]) -1000000 ``` # Additional Notes: 1. Consider using a dictionary or a set to keep track of unique elements. 2. Ensure that the solution handles duplicate elements correctly by summing each element only once. 3. Pay attention to both positive and negative values in the input array. 4. Optimize your solution to handle the upper limits of the input constraints efficiently.","solution":"from typing import List def sum_of_unique_elements(nums: List[int]) -> int: Returns the sum of all unique integers in the array `nums`. Elements are considered unique even if they appear more than once in the input list. return sum(set(nums))"},{"question":"# Problem Statement A logistics company needs to optimize its delivery routes to minimize the total distance traveled between warehouses across different cities. The warehouses are represented as nodes in a graph, where edges denote the distance between nodes. Your task is to implement a function that uses the Dijkstra algorithm to find the shortest path between a given start node and an end node. # Requirements 1. Implement the Dijkstra algorithm to find the shortest path. 2. Ensure the function handles various edge cases such as disconnected nodes. 3. Provide detailed information about the path and the total distance. # Function Signature ```python import heapq def dijkstra_shortest_path(graph: dict, start: str, end: str) -> tuple: Parameters: graph (dict): A dictionary representing the graph where keys are node names, and values are dictionaries with neighboring nodes and edge weights. start (str): The starting node for the path. end (str): The end node for the path. Returns: tuple: a tuple containing two elements: 1. A list of nodes representing the shortest path from start to end. 2. An integer representing the total distance of the shortest path. # implementation ``` # Input Constraints 1. **Graph**: A dictionary where keys are node names, and values are dictionaries with neighboring nodes and the distances to them. 2. **Start Node**: A string representing the starting node. 3. **End Node**: A string representing the end node. 4. **Valid Nodes and Edges**: Ensure the nodes and edges provided are valid and properly formatted. # Output Return a tuple containing: 1. A list of nodes representing the shortest path from the start node to the end node. 2. An integer representing the total distance of the shortest path. # Example **Test the function with the following:** ```python graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'A\': 1, \'C\': 2, \'D\': 5}, \'C\': {\'A\': 4, \'B\': 2, \'D\': 1}, \'D\': {\'B\': 5, \'C\': 1} } start_node = \'A\' end_node = \'D\' shortest_path, total_distance = dijkstra_shortest_path(graph, start_node, end_node) print(f\\"Shortest path from {start_node} to {end_node}: {shortest_path}\\") print(f\\"Total distance: {total_distance}\\") ```","solution":"import heapq def dijkstra_shortest_path(graph: dict, start: str, end: str) -> tuple: Returns the shortest path and its total distance from start to end using Dijkstra\'s algorithm. Parameters: graph (dict): A dictionary representing the graph where keys are node names, and values are dictionaries with neighboring nodes and edge weights. start (str): The starting node for the path. end (str): The end node for the path. Returns: tuple: a tuple containing two elements: 1. A list of nodes representing the shortest path from start to end. 2. An integer representing the total distance of the shortest path. # Priority queue to hold the nodes to explore queue = [(0, start, [])] # Dictionary to hold the shortest distance to each node distances = {start: 0} # Set to hold explored nodes visited = set() while queue: (current_distance, current_node, path) = heapq.heappop(queue) # If the current node is the end node, return the path and the distance if current_node == end: return (path + [end], current_distance) # If the current node has been visited, continue if current_node in visited: continue # Mark current node as visited visited.add(current_node) # Explore all the neighbors for neighbor, weight in graph[current_node].items(): distance = current_distance + weight # If a shorter path to the neighbor is found if neighbor not in distances or distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(queue, (distance, neighbor, path + [current_node])) # If there is no path from start to end, return empty path and infinite distance return ([], float(\'inf\')) # Example graph graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'A\': 1, \'C\': 2, \'D\': 5}, \'C\': {\'A\': 4, \'B\': 2, \'D\': 1}, \'D\': {\'B\': 5, \'C\': 1} } # Start and end nodes start_node = \'A\' end_node = \'D\' # Get the shortest path and total distance shortest_path, total_distance = dijkstra_shortest_path(graph, start_node, end_node) print(f\\"Shortest path from {start_node} to {end_node}: {shortest_path}\\") print(f\\"Total distance: {total_distance}\\")"},{"question":"# Question **K-th Symbol in Grammar** The k-th symbol in an Nth row of a special grammar where first row is `0`. Subsequent rows are derived based on the previous row using the specific rules described below. Generation Rule: - The first row is `0`. - In subsequent rows, replace each occurrence of `0` with `01` and each occurrence of `1` with `10`. Given integers `N` and `K`, return the `K-th` indexed value in the `N-th` row of the grammar. Input * An integer `N` (1 ≤ N ≤ 30). * An integer `K` (1 ≤ K ≤ 2^(N-1)). Output * Return the K-th indexed value (0-based index) in the N-th row. Examples ```python >>> kth_grammar(1, 1) 0 >>> kth_grammar(2, 1) 0 >>> kth_grammar(2, 2) 1 >>> kth_grammar(4, 5) 1 ``` # Explanation * For `N = 1`, the sequence is `0`. * For `N = 2`, the sequence is formed as `01`. * For `N = 3`, by replacing `0` with `01` and `1` with `10`, the sequence becomes `0110`. * For `N = 4`, it expands to `01101001`. Constraints * The solution should ideally be efficient in time complexity without generating the entire sequence up to `N` rows, making use of recursive or iterative strategies to determine the value directly. ```python def kth_grammar(N: int, K: int) -> int: if N == 1: return 0 mid = 2**(N-2) if K <= mid: return kth_grammar(N-1, K) else: return 1 - kth_grammar(N-1, K-mid) ``` # Scenario Consider this scenario: you are working on a compression algorithm that relies on generating successive transformations of binary data to achieve efficient encoding. Understanding and being able to generate the k-th symbol in such a grammar efficiently will be crucial for optimizing the algorithm\'s performance. Requirements * Optimize for large values of N and K to avoid memory overhead. * Avoid generating the entire N-th row sequence; solve using properties of the generation rule. Performance * The solution should be efficient and handle the given constraints comfortably, leveraging recursive patterns efficiently.","solution":"def kth_grammar(N: int, K: int) -> int: Function to find the K-th indexed value in the N-th row in a special grammar. if N == 1: return 0 mid = 2**(N-2) if K <= mid: return kth_grammar(N-1, K) else: return 1 - kth_grammar(N-1, K-mid)"},{"question":"Context You are a software engineer specializing in data processing and algorithm optimization. You have been tasked with enhancing a customer information system by implementing efficient algorithms for identifying unique customers based on their transaction records. Requirements Write a function, `find_unique_customers`, based on the following specifications: # Function: find_unique_customers **Input**: - `transaction_records`: A list of tuples, where each tuple consists of three elements: - `customer_id`: An integer representing the customer\'s unique ID. - `customer_name`: A string representing the customer\'s name. - `transaction_amount`: A float representing the amount spent in the transaction. **Output**: - Returns a list of strings representing unique customer names in the order they first appeared in the `transaction_records`. **Constraints**: - `transaction_records` will have at most 1000 entries. - Each `customer_name` is unique to a `customer_id`, but a `customer_id` can appear multiple times with the same `customer_name`. - Ensure the function efficiently handles the list and extracts unique customer names. Example Usage ```python records = [ (1, \\"Alice\\", 150.0), (2, \\"Bob\\", 120.0), (3, \\"Charlie\\", 100.0), (1, \\"Alice\\", 200.0), (2, \\"Bob\\", 180.0) ] assert find_unique_customers(records) == [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] records = [ (4, \\"David\\", 90.0), (5, \\"Eve\\", 110.0), (4, \\"David\\", 50.0), (6, \\"Frank\\", 200.0) ] assert find_unique_customers(records) == [\\"David\\", \\"Eve\\", \\"Frank\\"] records = [ (7, \\"Grace\\", 300.0) ] assert find_unique_customers(records) == [\\"Grace\\"] records = [] assert find_unique_customers(records) == [] ``` Make sure to account for different edge cases and validate assumptions where appropriate.","solution":"def find_unique_customers(transaction_records): Returns a list of unique customer names in the order they first appeared in the transaction_records. :param transaction_records: List[Tuple[int, str, float]] - A list of tuples with customer_id, customer_name, and transaction_amount :return: List[str] - List of unique customer names seen_customer_ids = set() unique_customers = [] for customer_id, customer_name, _ in transaction_records: if customer_id not in seen_customer_ids: seen_customer_ids.add(customer_id) unique_customers.append(customer_name) return unique_customers"},{"question":"# Coding Question Context You are given the task of implementing an algorithm that generates a specific subset of numbers based on given start and end indices. Instead of producing all numbers, which may be costly, you need to directly generate the required range. Problem Statement Write a function called `generate_subset` that takes three arguments: 1. `start` (an integer): The starting index (inclusive). 2. `end` (an integer): The ending index (exclusive). 3. `step` (an integer): The step increment between each number in the sequence. Your function should return a list of numbers starting from `start`, ending before `end`, and incrementing by `step`. Input Format * `start` (1 <= start <= 10^6): An integer specifying the starting index (inclusive). * `end` (start < end <= 10^6): An integer specifying the ending index (exclusive). * `step` (1 <= step <= 10^4): An integer specifying the step increment. Output Format * A list of integers representing the sequence starting from `start`, ending before `end` and incrementing by `step`. Example * Example 1: ```python generate_subset(1, 10, 2) # Should return [1, 3, 5, 7, 9] ``` * Example 2: ```python generate_subset(5, 20, 3) # Should return [5, 8, 11, 14, 17] ``` Constraints and Performance Requirements - Ensure your solution handles large ranges efficiently. - Avoid using unnecessarily large memory allocations or excessive loops.","solution":"def generate_subset(start, end, step): Generate a list of numbers from start to end with a given step. Args: - start (int): The starting index (inclusive). - end (int): The ending index (exclusive). - step (int): The step increment. Returns: - List[int]: List of integers from start to end with the provided step. return list(range(start, end, step))"},{"question":"# Coding Assessment Question **Scenario**: You are working on a library management system that keeps track of books and their availability. You need to implement a feature that finds books based on a specific search keyword, which could be part of the book title, author\'s name, or genre. **Task**: Implement a function `search_books` that takes a keyword as an argument and returns a list of dictionaries. Each dictionary should contain the book\'s ID, title, author, genre, and availability. The search should be case-insensitive and match the keyword against the book title, author, and genre. **Function Signature**: ```python def search_books(keyword: str) -> list: Searches for books containing the given keyword in their title, author, or genre and returns a list of dictionaries with book details. Args: keyword (str): Substring to search for in book title, author, or genre. Returns: list: List of dictionaries containing book information with keys \'id\', \'title\', \'author\', \'genre\', and \'availability\'. ``` **Example**: ```python books = [ {\\"id\\": 1, \\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"genre\\": \\"Classic\\", \\"availability\\": True}, {\\"id\\": 2, \\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"genre\\": \\"Classic\\", \\"availability\\": False}, {\\"id\\": 3, \\"title\\": \\"The Catcher in the Rye\\", \\"author\\": \\"J.D. Salinger\\", \\"genre\\": \\"Classic\\", \\"availability\\": True}, {\\"id\\": 4, \\"title\\": \\"Dune\\", \\"author\\": \\"Frank Herbert\\", \\"genre\\": \\"Science Fiction\\", \\"availability\\": True}, {\\"id\\": 5, \\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"genre\\": \\"Dystopian\\", \\"availability\\": False} ] results = search_books(\\"classic\\") for book in results: print(book) ``` **Expected Output**: ```python [ {\\"id\\": 1, \\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"genre\\": \\"Classic\\", \\"availability\\": True}, {\\"id\\": 2, \\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"genre\\": \\"Classic\\", \\"availability\\": False}, {\\"id\\": 3, \\"title\\": \\"The Catcher in the Rye\\", \\"author\\": \\"J.D. Salinger\\", \\"genre\\": \\"Classic\\", \\"availability\\": True} ] ``` **Constraints**: 1. Your function must: - Perform a case-insensitive search on the book title, author, and genre. - Return the appropriate list of dictionaries containing book details. 2. Implement the function efficiently, considering the potential size of the book database. **Performance Boundaries**: - Ensure that your function can handle searching through a list of up to 10,000 books without significant performance issues. **Additional Notes**: - You can assume that the list of books is available and pre-defined in your function. - Consider properly structuring and commenting your code for readability and maintainability.","solution":"books = [ {\\"id\\": 1, \\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"genre\\": \\"Classic\\", \\"availability\\": True}, {\\"id\\": 2, \\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"genre\\": \\"Classic\\", \\"availability\\": False}, {\\"id\\": 3, \\"title\\": \\"The Catcher in the Rye\\", \\"author\\": \\"J.D. Salinger\\", \\"genre\\": \\"Classic\\", \\"availability\\": True}, {\\"id\\": 4, \\"title\\": \\"Dune\\", \\"author\\": \\"Frank Herbert\\", \\"genre\\": \\"Science Fiction\\", \\"availability\\": True}, {\\"id\\": 5, \\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"genre\\": \\"Dystopian\\", \\"availability\\": False} ] def search_books(keyword: str) -> list: Searches for books containing the given keyword in their title, author, or genre and returns a list of dictionaries with book details. Args: keyword (str): Substring to search for in book title, author, or genre. Returns: list: List of dictionaries containing book information with keys \'id\', \'title\', \'author\', \'genre\', and \'availability\'. keyword_lower = keyword.lower() result = [] for book in books: if (keyword_lower in book[\\"title\\"].lower() or keyword_lower in book[\\"author\\"].lower() or keyword_lower in book[\\"genre\\"].lower()): result.append(book) return result"},{"question":"Implement a function `find_all_peaks(nums: List[int]) -> List[int]` that takes a list of integers and returns a list of the indices of all the peak elements. A peak element is an element that is greater than its neighbors. For simplicity, consider the element at `nums[0]` to be greater than its left neighbor (if any), and the element at `nums[-1]` to be greater than its right neighbor (if any). # Function Signature ```python def find_all_peaks(nums: List[int]) -> List[int]: ``` # Input * `nums` (List[int]): A list of integers. # Output * A list of integers representing the indices of all the peak elements. # Constraints * The input list will have at least one integer and at most 10^5 integers. * Elements of the list can be positive, negative, or zero. # Examples ```python >>> nums = [1, 3, 2, 7, 6, 4, 10, 8] >>> find_all_peaks(nums) [1, 3, 6] >>> nums = [10] >>> find_all_peaks(nums) [0] >>> nums = [2, 2, 2, 2, 2] >>> find_all_peaks(nums) [] >>> nums = [1, 2, 3, 4, 5] >>> find_all_peaks(nums) [4] >>> nums = [5, 4, 3, 2, 1] >>> find_all_peaks(nums) [0] ``` # Notes * Ensure the result list contains all indices of peak elements. * Handle edge cases such as lists with one element, or lists where all elements are the same. * Consider the performance for lists as large as 10^5 elements.","solution":"from typing import List def find_all_peaks(nums: List[int]) -> List[int]: peaks = [] n = len(nums) if n == 1: return [0] for i in range(n): if i == 0 and nums[i] > nums[i+1]: peaks.append(i) elif i == n-1 and nums[i] > nums[i-1]: peaks.append(i) elif 0 < i < n-1 and nums[i] > nums[i-1] and nums[i] > nums[i+1]: peaks.append(i) return peaks"},{"question":"# Coding Assessment Question Scenario As part of developing a basic arithmetic interpreter, you need to implement a function that evaluates simple mathematical expressions provided as strings. Each expression will consist of two non-negative integers and an operator (either `+`, `-`, `*`, or `/`). The integers and the operator will always be separated by a single space. Your task is to write a function that processes these string expressions and returns the result of the computation. Ensure that the division operation is an integer division (discard the fractional part). You are allowed to use Python\'s built-in arithmetic operators. Task Implement a function `evaluate_expression` that takes a string `expr` representing a simple arithmetic expression and returns the computed result as an integer. Input - A single string `expr` in the format `\'num1 op num2\'` where `num1` and `num2` are non-negative integers (0 ≤ num1, num2 ≤ 1000) and `op` is one of the operators `+`, `-`, `*`, or `/`. There will be exactly one space separating the numbers and the operator. Output - An integer representing the result of the evaluated expression. Constraints - The input string will always be in the correct format as described. - Division will perform integer division (floor division). Examples ```python >>> evaluate_expression(\\"10 + 5\\") 15 >>> evaluate_expression(\\"100 - 30\\") 70 >>> evaluate_expression(\\"7 * 6\\") 42 >>> evaluate_expression(\\"20 / 3\\") 6 >>> evaluate_expression(\\"0 * 999\\") 0 ``` Implementation ```python def evaluate_expression(expr: str) -> int: Evaluate a basic arithmetic expression with two non-negative integers. # Your code here # Sample test cases to validate your function assert evaluate_expression(\\"10 + 5\\") == 15 assert evaluate_expression(\\"100 - 30\\") == 70 assert evaluate_expression(\\"7 * 6\\") == 42 assert evaluate_expression(\\"20 / 3\\") == 6 assert evaluate_expression(\\"0 * 999\\") == 0 print(\\"All tests passed!\\") ```","solution":"def evaluate_expression(expr: str) -> int: Evaluate a basic arithmetic expression with two non-negative integers. num1, op, num2 = expr.split() num1, num2 = int(num1), int(num2) if op == \'+\': return num1 + num2 elif op == \'-\': return num1 - num2 elif op == \'*\': return num1 * num2 elif op == \'/\': return num1 // num2 # Integer division else: raise ValueError(\\"Invalid operator. Only +, -, *, / are allowed.\\")"},{"question":"# Problem Statement You are tasked with implementing a function `find_k_smallest_pairs` that finds `k` pairs of elements from two given arrays such that the sum of the pair elements is minimized. # Input - Two lists of integers `nums1` and `nums2` where ( -10^9 leq text{nums1}[i], text{nums2}[i] leq 10^9 ). - An integer `k`. # Output - A list of lists containing up to `k` pairs `[a, b]` such that `a` belongs to `nums1` and `b` belongs to `nums2`, and the sums of pairs are the smallest possible. - If there are multiple valid solutions, return any. # Constraints 1. The length of `nums1` and `nums2` will be between 0 and 1000 inclusive. 2. (1 leq k leq 1000). 3. The result list cannot have more than `k` pairs. # Examples ```python find_k_smallest_pairs([1, 7, 11], [2, 4, 6], 3) # Output: [[1, 2], [1, 4], [1, 6]] find_k_smallest_pairs([1, 2], [3], 3) # Output: [[1, 3], [2, 3]] find_k_smallest_pairs([1, 3, 5], [2, 4, 6], 2) # Output: [[1, 2], [1, 4]] ``` # Performance Requirements Ensure that your solution runs efficiently within the given constraints. The expected time complexity is (O(k log k)).","solution":"import heapq def find_k_smallest_pairs(nums1, nums2, k): if not nums1 or not nums2 or k == 0: return [] min_heap = [] for i in range(min(len(nums1), k)): heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0)) result = [] while k > 0 and min_heap: sum_val, i, j = heapq.heappop(min_heap) result.append([nums1[i], nums2[j]]) if j + 1 < len(nums2): heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1)) k -= 1 return result"},{"question":"# String Permutations Checker Description: Given two strings, determine if they are permutations of each other. In other words, check if the strings contain the same characters with the same frequency but possibly in different orders. For example, the strings \\"abc\\" and \\"bca\\" are permutations of each other, while \\"abc\\" and \\"abca\\" are not. Challenge: Write a function that takes two strings as input and returns a boolean indicating whether they are permutations of each other. Function Signature: `def are_permutations(str1: str, str2: str) -> bool:` Constraints: - The strings will contain only ASCII characters. - The length of the strings will be <= 1000. Input: - Two strings, `str1` and `str2`. Output: - A boolean value, `True` if the strings are permutations of each other, `False` otherwise. # Example: ```python def are_permutations(str1: str, str2: str) -> bool: Check if two strings are permutations of each other. return sorted(str1) == sorted(str2) # Example usage: print(are_permutations(\\"listen\\", \\"silent\\")) # Expected output: True print(are_permutations(\\"hello\\", \\"billion\\")) # Expected output: False ``` Notes: - You can solve this problem efficiently by utilizing data structures such as dictionaries or arrays to count character occurrences, or by sorting and comparing the strings. - Ensure the solution handles edge cases like empty strings or strings with different lengths.","solution":"def are_permutations(str1: str, str2: str) -> bool: Check if two strings are permutations of each other. Args: str1 (str): The first string str2 (str): The second string Returns: bool: True if the strings are permutations of each other, False otherwise # If lengths are different, they cannot be permutations if len(str1) != len(str2): return False # Create dictionaries to count character occurrences char_count1 = {} char_count2 = {} for char in str1: char_count1[char] = char_count1.get(char, 0) + 1 for char in str2: char_count2[char] = char_count2.get(char, 0) + 1 # Compare character counts return char_count1 == char_count2"},{"question":"# Problem Context In many applications, processing a large list of integers while filtering and transforming its elements can be quite common. Efficient manipulation of such data sets is crucial for performance. In this task, you are required to implement two functions that focus on object-oriented and functional programming paradigms to process the given data more effectively. # Task You are given a list of integers and need to implement a class `ListProcessor` with methods to filter even numbers and to apply a mathematical transformation to each filtered number. Additionally, implement a standalone function `process_numbers` that utilizes these methods. # Requirements 1. **`ListProcessor` Class**: - `__init__(self, numbers: List[int])`: Initializes the list of numbers. - `filter_even(self) -> List[int]`: Returns a list of even numbers from the original list. - `transform(self, func: Callable[[int], int]) -> List[int]`: Applies a transformation function to each filtered number and returns the list of transformed numbers. 2. **Function `process_numbers`**: - **Input**: `numbers (List[int])`, and `transform_func (Callable[[int], int])`. - **Output**: Transformed list of even numbers as defined by `transform_func`. # Example Transformations - Doubling the number. - Squaring the number. # Input and Output Format 1. `ListProcessor` Class methods: - `filter_even(self) -> List[int]` * **Input**: None (uses the internally stored list of numbers). * **Output**: List of even integers. - `transform(self, func: Callable[[int], int]) -> List[int]` * **Input**: A transformation function to apply to each number. * **Output**: List of transformed integers. 2. `process_numbers` function: - **Input**: `numbers (List[int])` and `transform_func (Callable[[int], int])`. - **Output**: Transformed list of even integers. # Constraints - `numbers`: List of integers (1 <= len(numbers) <= 10^6, -10^9 <= numbers[i] <= 10^9) - `transform_func`: Any valid mathematical function that takes an integer and returns an integer. # Performance Expectations - Ensure the time complexity remains (O(n)) where (n) is the length of the input list. - Memory usage should be efficient, making sure no unnecessary data duplication occurs. # Example Implement the `ListProcessor` class and the `process_numbers` function with the following requirements and validate their correctness with test cases. **Sample Test** ```python def double(x): return x * 2 def square(x): return x ** 2 # Example Usage processor = ListProcessor([1, 2, 3, 4, 5, 6]) even_numbers = processor.filter_even() transformed_numbers = processor.transform(double) print(even_numbers) # Output: [2, 4, 6] print(transformed_numbers) # Output: [4, 8, 12] transformed_numbers = process_numbers([1, 2, 3, 4, 5, 6], square) print(transformed_numbers) # Output: [4, 16, 36] # Run additional tests assert process_numbers([10, 15, -20, 25, 30], double) == [20, -40, 60] assert process_numbers([0, 8, -16, 24], square) == [0, 64, 256, 576] print(\\"All tests passed!\\") ```","solution":"from typing import List, Callable class ListProcessor: def __init__(self, numbers: List[int]): self.numbers = numbers def filter_even(self) -> List[int]: return [num for num in self.numbers if num % 2 == 0] def transform(self, func: Callable[[int], int]) -> List[int]: even_numbers = self.filter_even() return [func(num) for num in even_numbers] def process_numbers(numbers: List[int], transform_func: Callable[[int], int]) -> List[int]: processor = ListProcessor(numbers) return processor.transform(transform_func)"},{"question":"# Duplicate Removal in a Linked List Write a function to remove duplicates from an unsorted singly linked list. The duplicates should be completely removed from the list, leaving no repeated elements. You will be provided with the `ListNode` class and the head of the linked list. Function Signature ```python def remove_duplicates(head: Optional[ListNode]) -> Optional[ListNode]: ``` Input * `head`: An instance of `ListNode` representing the head of a singly linked list. Output * The head of the modified list after removing all duplicates. Constraints * The input list can contain zero or more nodes. * Consider appropriate edge cases such as an empty list or a list with all unique elements. * Your solution should operate efficiently even on large lists with up to 100,000 elements. Example ```python >>> class ListNode: ... def __init__(self, val=0, next=None): ... self.val = val ... self.next = next >>> def print_list(head): ... current = head ... result = [] ... while current: ... result.append(current.val) ... current = current.next ... print(result) >>> # Creating the linked list 1 -> 2 -> 3 -> 3 -> 4 -> 4 -> 5 >>> head = ListNode(1, ListNode(2, ListNode(3, ListNode(3, ListNode(4, ListNode(4, ListNode(5))))))) >>> new_head = remove_duplicates(head) >>> print_list(new_head) [1, 2, 5] >>> # Creating the linked list 1 -> 1 -> 2 -> 2 -> 3 -> 3 -> 4 -> 4 >>> head = ListNode(1, ListNode(1, ListNode(2, ListNode(2, ListNode(3, ListNode(3, ListNode(4, ListNode(4)))))))) >>> new_head = remove_duplicates(head) >>> print_list(new_head) [] ``` Performance Requirements * The function should run in O(n) time complexity, where n is the number of elements in the linked list. * Efficient space usage is necessary. Ensure your implementation properly handles duplicate removal, inclusive of all edge cases such as adjacent duplicates and scenarios with no duplicates at all.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head: ListNode) -> ListNode: if not head: return None dummy = ListNode(0, head) prev = dummy current = head while current: has_duplicates = False # Check if next nodes have the same value while current.next and current.val == current.next.val: current = current.next has_duplicates = True # If duplicates were found, skip them if has_duplicates: current = current.next # Skip all duplicates continue # No duplicates found; link prev node to current prev.next = current prev = current current = current.next prev.next = current # Ensure last node is linked correctly if it\'s unique return dummy.next"},{"question":"# Problem Statement You are tasked with implementing a function that processes a directed graph to identify all nodes that can be reached from a given starting node. This problem is essential in scenarios such as finding accessible pages from a starting web page, network routing, and various AI pathfinding algorithms. # Function Specification Function: `reachable_nodes(graph, start)` - **Input**: - A dictionary representing a directed graph, where keys are nodes, and values are lists of nodes that are directly reachable from the key node. - A starting node (string or integer) from which to determine reachable nodes. - **Output**: A set containing all nodes that can be reached from the starting node. - **Constraints**: - Nodes can be any hashable type (string, integer, etc.). - The graph dictionary can be empty. # Examples Example 1: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [], \'D\': [\'E\'], \'E\': [] } >>> reachable_nodes(graph, \'A\') {\'A\', \'B\', \'C\', \'D\', \'E\'} ``` Example 2: ```python graph = { 1: [2, 3], 2: [4], 3: [5], 4: [], 5: [] } >>> reachable_nodes(graph, 1) {1, 2, 3, 4, 5} ``` Example 3: ```python graph = {} >>> reachable_nodes(graph, \'A\') set() ``` # Detailed Instructions 1. **Implement `reachable_nodes` function**: - If the input graph is empty, return an empty set. - Use a Depth-First Search (DFS) or Breadth-First Search (BFS) algorithm to explore the graph. - Initialize a set to keep track of visited nodes. - Start exploring from the provided starting node, marking nodes as visited as they are reached. - Recursively or iteratively visit each node\'s neighbors until all reachable nodes have been visited. - Return the set of reachable nodes. 2. **Edge Cases**: - The start node is not present in the graph keys. - The graph has cycles. - The graph contains disconnected components. - The input graph is empty. 3. **Optimization**: - Ensure that each node is processed only once to maintain efficient traversal, especially for large graphs. # Coding Template ```python def reachable_nodes(graph, start): if start not in graph: return {start} if start else set() visited = set() stack = [start] while stack: node = stack.pop() if node not in visited: visited.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: stack.append(neighbor) return visited ``` Make sure to test your `reachable_nodes` function thoroughly, covering various edge cases to ensure its correctness.","solution":"def reachable_nodes(graph, start): Returns a set of all nodes that can be reached from the given starting node. Parameters: - graph (dict): Dictionary representing the directed graph. - start (str/int): The starting node. Returns: - set: Set of reachable nodes. if not graph or start not in graph: return {start} if start in graph else set() visited = set() stack = [start] while stack: node = stack.pop() if node not in visited: visited.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: stack.append(neighbor) return visited"},{"question":"# Sorting Large Text Files You are provided with a very large text file containing many lines of words. Each line is either a single word or consists of words separated by spaces. Your task is to create a Python script to sort all the lines of this file in alphabetical order and write the sorted lines to a new file. Requirements: 1. **Line Reading Method**: Implement a function `read_lines` that reads all lines from the input file. 2. **Sorting Lines Method**: Implement a function `sort_lines` that sorts the lines. 3. **Line Writing Method**: Implement a function `write_lines` that writes the sorted lines to the output file. # Constraints: * The input file can contain up to 10^6 lines. * Each line in the file is between 1 and 100 characters long. * The lines comprise only whitespace characters and uppercase/lowercase alphabetical characters. * Your implementation should handle the large size of the file efficiently. # Input: * `input_file`: The path to the input text file containing unsorted lines. * `output_file`: The path to the output text file where sorted lines need to be written. # Output: * The sorted lines written to the output file. # Example: ```python # Example input file content (input.txt) \'\'\' orange apple banana apple banana apple \'\'\' # Expected output file content (output.txt) \'\'\' apple apple banana banana apple orange \'\'\' # The script should read the lines: input_file = \\"input.txt\\" output_file = \\"output.txt\\" sort_large_text_file(input_file, output_file) # The content of the output.txt file should be: \'\'\' apple apple banana banana apple orange \'\'\' \'\'\' Write the complete code including the required functions and the script to perform the necessary operations.","solution":"def read_lines(input_file): Reads all lines from the input file and returns a list of lines. Parameters: input_file (str): Path to the input file. Returns: list: List of lines from the file. with open(input_file, \'r\') as file: lines = file.readlines() return [line.strip() for line in lines] def sort_lines(lines): Sorts a list of lines in alphabetical order. Parameters: lines (list): List of lines to sort. Returns: list: Sorted list of lines. return sorted(lines) def write_lines(lines, output_file): Writes the sorted lines to the output file. Parameters: lines (list): List of sorted lines. output_file (str): Path to the output file. with open(output_file, \'w\') as file: for line in lines: file.write(line + \'n\') def sort_large_text_file(input_file, output_file): Reads lines from the input file, sorts them and writes them to the output file. Parameters: input_file (str): Path to the input file. output_file (str): Path to the output file. lines = read_lines(input_file) sorted_lines = sort_lines(lines) write_lines(sorted_lines, output_file)"},{"question":"# Product of Subset Sums **Problem Statement**: Write a function `product_of_subset_sums` that computes the product of the sum of elements for all non-empty subsets of a given list of integers. **Input**: * A list `nums` of integers. **Output**: * An integer representing the product of the sum of elements for all non-empty subsets of the given list. **Constraints**: * The list `nums` will contain between 1 and 20 integers. * Each integer in `nums` will be between `-10` and `10`. **Function Signature**: ```python def product_of_subset_sums(nums: List[int]) -> int: ``` **Example**: ```python # Example 1 nums = [1, 2] # Non-empty subsets: [1], [2], [1, 2] # Sums of non-empty subsets: 1, 2, 3 # Product of these sums: 1 * 2 * 3 = 6 print(product_of_subset_sums(nums)) # Output: 6 # Example 2 nums = [-1, 1] # Non-empty subsets: [-1], [1], [-1, 1] # Sums of non-empty subsets: -1, 1, 0 # Product of these sums: -1 * 1 * 0 = 0 print(product_of_subset_sums(nums)) # Output: 0 ``` # Solution Requirements: 1. Generate all non-empty subsets of the given list. 2. Compute the sum of elements for each non-empty subset. 3. Calculate and return the product of these sums. # Additional Scenarios: 1. **Single Element List**: * For a single element list like `[5]`, the output should be `5` since there is only one non-empty subset. 2. **List with Zero**: * For an input list with a zero, like `[0, 2, 3]`, the expected behavior should still correctly calculate the product, considering subsets like `[0, 2]` and `[0, 3]`. Ensure your algorithm efficiently handles list operations to generate subsets and calculate their sums, even for the upper boundary of the list size.","solution":"from typing import List from itertools import chain, combinations def product_of_subset_sums(nums: List[int]) -> int: Computes the product of the sum of elements for all non-empty subsets of a given list of integers. def all_non_empty_subsets(iterable): \\"all_non_empty_subsets([1, 2, 3]) --> (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\\" s = list(iterable) return chain.from_iterable(combinations(s, r) for r in range(1, len(s)+1)) subset_sums = [sum(subset) for subset in all_non_empty_subsets(nums)] product = 1 for subset_sum in subset_sums: product *= subset_sum return product"},{"question":"# Automated Expense Report Consolidator You are tasked with automating the consolidation of expense reports from multiple employees. Given a list of CSV file paths representing individual expense reports, your goal is to consolidate these into a single CSV file while maintaining each employee\'s original record structure. Requirements: 1. **Function Definition**: ```python def consolidate_expense_reports(file_paths: list, output_path: str) -> str: ``` 2. **Input**: * `file_paths` (list): List of strings, where each string is a valid file path to a CSV file representing an individual employee\'s expense report. * `output_path` (str): A string representing the file path where the consolidated CSV file should be saved. 3. **Output**: * Return a success message indicating the path of the consolidated CSV file. 4. **Constraints**: * Each CSV file contains the same columns: `Date`, `Category`, `Description`, `Amount`, and `EmployeeID`. * Merge and preserve the order of records from each file in the consolidated report. * Handle duplicate records by keeping the first occurrence and ignoring subsequent duplicates. * Gracefully handle file reading errors and continue processing remaining files. * Ensure the consolidated CSV file is correctly formatted and readable. 5. **Performance Requirements**: * The function should handle up to 100 file paths within a reasonable time limit. * Optimize file reading where possible (consider buffering approaches). Example: ```python file_paths = [ \\"employee1_expenses.csv\\", \\"employee2_expenses.csv\\", \\"employee3_expenses.csv\\" ] output_path = \\"consolidated_expenses.csv\\" result = consolidate_expense_reports(file_paths, output_path) # The \'result\' might look like: # \\"Consolidated expense report successfully created at consolidated_expenses.csv\\" ``` Implementation Tips: * Ensure to read and write CSV files correctly using appropriate libraries. * Implement robust error handling for file operations. * Ensure that the final CSV file is free of duplicate records while maintaining input order.","solution":"import csv import os def consolidate_expense_reports(file_paths: list, output_path: str) -> str: seen = set() entries = [] for file_path in file_paths: try: with open(file_path, mode=\'r\', encoding=\'utf-8\') as file: reader = csv.DictReader(file) for row in reader: row_tuple = tuple(row.items()) if row_tuple not in seen: seen.add(row_tuple) entries.append(row) except (IOError, csv.Error) as e: print(f\\"Error processing file {file_path}: {e}\\") if entries: fieldnames = entries[0].keys() with open(output_path, mode=\'w\', encoding=\'utf-8\', newline=\'\') as file: writer = csv.DictWriter(file, fieldnames=fieldnames) writer.writeheader() for entry in entries: writer.writerow(entry) return f\\"Consolidated expense report successfully created at {output_path}\\""},{"question":"# Problem Statement Given a string `text` and a list of strings `dictionary`, write a function `find_substrings` that returns a list of the longest substrings from `text` which appear in `dictionary`. If multiple substrings of the same maximum length exist, return all of them in the order they first appear in `text`. The function should pay close attention to the efficiency of substring checking. # Function Definition ```python def find_substrings(text: str, dictionary: list) -> list: :param text: The main string in which to search for substrings. :param dictionary: A list of valid substrings. :return: A list of the longest substrings found in `text` that are also in `dictionary`. ``` # Input * `text` is a string with a length of up to 10^5 characters. * `dictionary` is a list of strings where each string has a length between 1 and 100 characters. The length of `dictionary` can be up to 1000. # Output * Return a list of the longest substrings found in `text` that are also present in `dictionary`. * If there are multiple longest substrings of the same length, return them in the order they first appear in the `text`. # Constraints * Ensure the algorithm works efficiently, ideally with a time complexity better than O(n * m * k), where n is the length of `text`, m is the length of `dictionary`, and k is the average length of strings in `dictionary`. * Implement the solution without using naive substring matching for every possible substring of `text`. # Performance Requirements * Handle large inputs effectively. * Manage cases where there are repeated substrings or no matching substrings. # Example Example 1: ```python text = \\"ababc\\" dictionary = [\\"ab\\", \\"abc\\", \\"a\\", \\"b\\"] # Output: [\\"abc\\"] ``` Example 2: ```python text = \\"abracadabra\\" dictionary = [\\"abra\\", \\"cad\\", \\"abracadabra\\", \\"ra\\"] # Output: [\\"abracadabra\\"] ``` # Note * The function should be optimal in searching for substrings within the given constraints. * It should correctly handle cases where substrings partially overlap or match at multiple points in the text.","solution":"def find_substrings(text: str, dictionary: list) -> list: Finds the longest substrings in \'text\' that are present in \'dictionary\' :param text: The main string in which to search for substrings. :param dictionary: A list of valid substrings. :return: A list of the longest substrings found in `text` that are also in `dictionary`. longest_length = 0 longest_substrings = [] # Convert the dictionary to a set for O(1) lookups dictionary_set = set(dictionary) # Loop through the text and try all possible substrings for start in range(len(text)): for end in range(start + 1, len(text) + 1): substring = text[start:end] if substring in dictionary_set: substr_len = len(substring) if substr_len > longest_length: longest_length = substr_len longest_substrings = [substring] elif substr_len == longest_length: longest_substrings.append(substring) return longest_substrings"},{"question":"# Coding Assessment Question Scenario You are developing a utility tool that summarizes information from a large collection of text documents. One critical feature is to determine the top `k` most frequently occurring words in each document, ignoring common English stop words. This functionality helps identify key topics and themes within the content. Objectives Your task is to implement a function that returns the `k` most frequent words in a given text document, excluding common English stop words. Function Signature ```python from typing import List, Tuple def most_frequent_words(text: str, k: int) -> List[Tuple[str, int]]: pass ``` Input * A string `text` representing the content of a text document. * An integer `k` representing the number of top frequent words to return. Output * A list of tuples, where each tuple consists of a word and its frequency (in descending order of frequency). If multiple words have the same frequency, order them alphabetically. Constraints * The input text will be a non-empty string composed of lowercase alphabetic characters and spaces. * The integer `k` will always be a positive number and will not exceed the number of unique words in the text. Performance Requirements * The function should handle large text inputs efficiently. Stop Words Assume the following list of common English stop words: ```python stop_words = [ \'a\', \'an\', \'and\', \'are\', \'as\', \'at\', \'be\', \'by\', \'for\', \'from\', \'has\', \'he\', \'in\', \'is\', \'it\', \'its\', \'on\', \'of\', \'that\', \'the\', \'to\', \'was\', \'were\', \'will\', \'with\' ] ``` Example ```python >>> text = \\"the quick brown fox jumps over the lazy dog\\" >>> k = 3 >>> most_frequent_words(text, k) [(\'brown\', 1), (\'dog\', 1), (\'fox\', 1)] >>> text = \\"the the the fox fox dog\\" >>> k = 2 >>> most_frequent_words(text, k) [(\'fox\', 2), (\'dog\', 1)] ``` Instructions 1. Exclude words listed in the stop words list from the frequency count. 2. Sort the words by their frequency in descending order. For words with the same frequency, sort them alphabetically. 3. Ensure the function adheres to the specified input/output formats. 4. Do not import any additional libraries. Use only standard libraries available in Python.","solution":"from typing import List, Tuple from collections import Counter def most_frequent_words(text: str, k: int) -> List[Tuple[str, int]]: stop_words = [ \'a\', \'an\', \'and\', \'are\', \'as\', \'at\', \'be\', \'by\', \'for\', \'from\', \'has\', \'he\', \'in\', \'is\', \'it\', \'its\', \'on\', \'of\', \'that\', \'the\', \'to\', \'was\', \'were\', \'will\', \'with\' ] words = text.split() filtered_words = [word for word in words if word not in stop_words] word_counts = Counter(filtered_words) most_common = word_counts.most_common() # Sort by frequency first (descending), then alphabetically most_common.sort(key=lambda x: (-x[1], x[0])) return most_common[:k]"},{"question":"# Coding Assessment Question Context You are developing a new analytics feature for a software tool that handles large datasets. Part of this feature involves identifying trends and anomalies over time. To achieve this, you need to implement an algorithm that can find the longest increasing subsequence in a sequence of numbers, representing data points collected over time. Problem Statement Implement an algorithm to find the length of the longest increasing subsequence (LIS) in a given sequence of numbers. The longest increasing subsequence is defined as the longest subsequence of a given sequence where the elements are in strictly increasing order. Input - **nums** (List of Integers): A list of integers representing the dataset. Output - An integer representing the length of the longest increasing subsequence. Constraints - Each integer in the sequence will be between `-10^9` to `10^9`. - The length of the input list `nums` will be between `0` to `2000`. Function Signature ```python def length_of_lis(nums: List[int]) -> int: pass ``` Example ```python input: nums = [10, 9, 2, 5, 3, 7, 101, 18] output: 4 ``` Explanation The longest increasing subsequence is `[2, 3, 7, 101]`, which has a length of 4. Notes * Optimize your solution to run in `O(n log n)` time complexity. * Consider using dynamic programming with binary search to achieve the required time complexity. --- Make sure your function handles edge cases, such as an empty list (`[]`, which should return `0`), or lists with only one element.","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in the given list of numbers. if not nums: return 0 from bisect import bisect_left # The array to store our subsequence sub = [] for num in nums: # Find the index of the smallest number >= num i = bisect_left(sub, num) # If num is larger than any element in sub if i == len(sub): sub.append(num) # If there is an element in sub great or equal to num, replace it with num else: sub[i] = num return len(sub)"},{"question":"# Question: You are given a list of integers `numbers` and an integer `k`. Your task is to implement a function `k_largest_elements` that returns a list of the k largest elements in `numbers`. The returned list should be in descending order (from largest to smallest). Function Signature: ```python def k_largest_elements(numbers: list[int], k: int) -> list[int]: # your implementation here ``` Input: - `numbers`: A list of integers. - `k`: An integer indicating the number of largest elements to return. Output: - A list of the k largest elements in descending order. - If `k` is greater than the length of `numbers`, return `numbers` sorted in descending order. - If `numbers` is empty or `k` is 0 or negative, return an empty list. Constraints: - The `numbers` list may contain positive, zero, and negative integers. - The function should handle edge cases such as an empty list or a list with fewer elements than `k`. Examples: ```python >>> k_largest_elements([3, 1, 5, 2, 4], 3) [5, 4, 3] >>> k_largest_elements([10, 20, 15, 5, 30], 2) [30, 20] >>> k_largest_elements([3, 1, 2], 5) [3, 2, 1] >>> k_largest_elements([], 3) [] >>> k_largest_elements([3, 1, 4, 1, 5, 9], -1) [] >>> k_largest_elements([1, 2, 3, 4], 0) [] ``` Constraints to Consider: - If `k` is non-integer, raise a ValueError with the message \\"k must be an integer\\". - If `numbers` is not a list or an iterable of integers, raise a ValueError with the message \\"numbers must be a list of integers\\". # Performance Requirements: - The solution should aim for O(n log k) time complexity where possible using suitable data structures.","solution":"def k_largest_elements(numbers: list[int], k: int) -> list[int]: Returns a list of the k largest elements from the input list `numbers` in descending order. If k is greater than the length of `numbers`, returns `numbers` sorted in descending order. If `numbers` is empty or `k` is non-positive, returns an empty list. if not isinstance(numbers, list) or not all(isinstance(x, int) for x in numbers): raise ValueError(\\"numbers must be a list of integers\\") if not isinstance(k, int): raise ValueError(\\"k must be an integer\\") if k <= 0 or not numbers: return [] # If k is greater than the number of elements in numbers, return all elements sorted if k >= len(numbers): return sorted(numbers, reverse=True) # For performance, use a min-heap of size k to find the k largest elements import heapq k_largest = heapq.nlargest(k, numbers) return sorted(k_largest, reverse=True)"},{"question":"# Balanced Parentheses Using Recursion Objective: Implement a recursive function to check if a string containing parentheses is balanced. Problem Statement: Write a function `is_balanced_recursive(s: str) -> bool` that checks whether the input string `s` has balanced parentheses. The function should be implemented recursively. Function Signature: ```python def is_balanced_recursive(s: str) -> bool: pass ``` Inputs: * `s` (str): A string containing only the characters `(` and `)`. Output: * The function should return `True` if the parentheses in the string `s` are balanced, `False` otherwise. Example: ```python # Example usage print(is_balanced_recursive(\\"()\\")) # Output: True print(is_balanced_recursive(\\"(())\\")) # Output: True print(is_balanced_recursive(\\")(\\")) # Output: False print(is_balanced_recursive(\\"(()\\")) # Output: False print(is_balanced_recursive(\\"((()))\\")) # Output: True print(is_balanced_recursive(\\"\\")) # Output: True ``` Constraints: * Use recursion to solve the problem. * Do not use any stack or list-based solution. * The length of the string `s` will not exceed 1000.","solution":"def is_balanced_recursive(s: str) -> bool: Checks if the string s has balanced parentheses using recursion. Args: s (str): A string containing only the characters \'(\' and \')\'. Returns: bool: True if the string is balanced, False otherwise. def helper(s: str, count: int) -> bool: # Base case: if the string is empty, check the balance count if not s: return count == 0 # If count goes negative, there are more closing brackets than opening if count < 0: return False # Recursively check the rest of the string if s[0] == \'(\': return helper(s[1:], count + 1) else: return helper(s[1:], count - 1) return helper(s, 0)"},{"question":"Subarray Sum Challenge Background In an array, a subarray is defined as a contiguous part of the array. The sum of a subarray is the sum of all the elements within that subarray. Given an integer array, find the subarray with the maximum sum. Problem Statement Write a function `max_subarray_sum(arr: List[int]) -> int` that takes a list of integers `arr` and returns the maximum sum of any subarray. Input - A list of integers `arr` where each element satisfies (-10^5 ≤ arr[i] ≤ 10^5) and the length of the list is (1 ≤ len(arr) ≤ 10^5). Output - An integer representing the maximum sum of any subarray within the given list. Example 1. `max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4])` should return `6` (subarray `[4,-1,2,1]` has the largest sum). 2. `max_subarray_sum([1])` should return `1` (subarray `[1]` itself). 3. `max_subarray_sum([5,4,-1,7,8])` should return `23` (subarray `[5,4,-1,7,8]` has the largest sum). Constraints - Consider edge cases such as arrays with all negative numbers or very large arrays. - Evaluate the efficiency of your solution for large inputs up to length `100,000`. Scenario This problem is common in financial analysis and stock market predictions where identifying periods of maximum gains is essential. It can also be applied in signal processing where the goal is to find the interval with the highest signal strength. Code Template ```python from typing import List def max_subarray_sum(arr: List[int]) -> int: current_sum = arr[0] max_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum # Example usage: print(max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4])) # Output: 6 ``` This new question maintains consistent style, length, complexity, and scope with the original sample question, while introducing a fresh problem that tests similar skills and concepts.","solution":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Returns the maximum sum of any subarray in the given list. if not arr: raise ValueError(\\"Input array cannot be empty\\") current_sum = arr[0] max_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum # Example usage: # print(max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4])) # Output: 6"},{"question":"# Coding Assessment Question Context Graph traversal and pathfinding are crucial concepts in computer science often applied in various domains such as navigation systems, networking, and game development. One common problem is to determine the shortest path in a weighted graph, which can involve heuristics for efficiency. Problem Description You are required to implement the A* algorithm to find the shortest path from a start node to a goal node in a weighted undirected graph. The graph\'s nodes are labeled with non-negative integers, and the edges have positive weights. Function Signature ```python def a_star(graph: dict, start: int, goal: int, heuristic: callable) -> list: pass ``` Input - `graph` (dict): A dictionary representing the adjacency list of the graph. The keys are node labels, and the values are lists of tuples `(neighbor, weight)`, where `neighbor` is a node connected by an edge with the given `weight`. - `start` (int): The starting node label. - `goal` (int): The goal node label. - `heuristic` (callable): A function `h(node: int, goal: int) -> float` that returns the heuristic estimate (as a float) of the cost to reach the goal from the given `node`. Output - Return a list of node labels representing the shortest path from the start node to the goal node, inclusive. If no path exists, return an empty list. Example ```python # Example 1 graph = { 0: [(1, 1), (2, 4)], 1: [(0, 1), (2, 2), (3, 5)], 2: [(0, 4), (1, 2), (3, 1)], 3: [(1, 5), (2, 1)] } start = 0 goal = 3 heuristic = lambda n, g: abs(n - g) assert a_star(graph, start, goal, heuristic) == [0, 1, 2, 3] # Example 2 graph = { 1: [(2, 1)], 2: [(1, 1), (3, 3)], 3: [(2, 3)] } start = 1 goal = 3 heuristic = lambda n, g: abs(n - g) assert a_star(graph, start, goal, heuristic) == [1, 2, 3] # Example 3 graph = { 1: [(2, 2)], 2: [(3, 2)], 3: [(4, 2)], 4: [] } start = 1 goal = 5 heuristic = lambda n, g: abs(n - g) assert a_star(graph, start, goal, heuristic) == [] ``` Constraints - The graph will have at most 1000 nodes and 2000 edges. - All edge weights are positive integers. - The heuristic function will return non-negative values. - The graph is guaranteed to be connected if a path from `start` to `goal` exists. --- This new question maintains the tone, language, and complexity of the original set, focusing on pathfinding in weighted graphs using the A* algorithm. The problem carefully mirrors the original style in context, length, and cognitive challenge.","solution":"import heapq def a_star(graph, start, goal, heuristic): Performs the A* algorithm to find the shortest path in a weighted graph. :param graph: A dictionary representing the adjacency list of the graph. :param start: The starting node label. :param goal: The goal node label. :param heuristic: A function that returns the heuristic estimate to the goal. :return: A list of node labels representing the shortest path from start to goal. open_set = [(0, start)] came_from = {} g_score = {node: float(\'inf\') for node in graph} g_score[start] = 0 f_score = {node: float(\'inf\') for node in graph} f_score[start] = heuristic(start, goal) while open_set: current_score, current = heapq.heappop(open_set) if current == goal: return reconstruct_path(came_from, current) for neighbor, weight in graph.get(current, []): tentative_g_score = g_score[current] + weight if tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal) heapq.heappush(open_set, (f_score[neighbor], neighbor)) return [] def reconstruct_path(came_from, current): total_path = [current] while current in came_from: current = came_from[current] total_path.append(current) total_path.reverse() return total_path"},{"question":"# Problem Statement `fetch_pharmacy_and_price_list` Create a function `longest_unique_substring(s: str) -> str` that takes a single string argument and returns the longest substring without repeating characters. # Function Signature ```python def longest_unique_substring(s: str) -> str: pass ``` # Input - **s**: A string `s` containing any ASCII characters. # Output - Returns the longest substring of `s` that contains no repeating characters. If there are multiple substrings of the same maximum length, return the first one found. # Constraints - The length of `s` is at most 10^4. - The function should be optimized for efficiency given the constraint on the length of `s`. # Requirements - Use a sliding window technique to find the longest substring without repeating characters. - Use a hashmap or a set to keep track of characters currently in the window and their indices. # Example ```python >>> longest_unique_substring(\\"abcabcbb\\") \\"abc\\" >>> longest_unique_substring(\\"bbbbb\\") \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") \\"wke\\" ``` # Notes - Consider edge cases such as an empty string. - The function should handle typical string operations efficiently under the given constraints.","solution":"def longest_unique_substring(s: str) -> str: if not s: return \\"\\" # Dictionary to remember the last index of each character last_index = {} start = 0 max_length = 0 max_substring = \\"\\" for end, char in enumerate(s): if char in last_index and last_index[char] >= start: start = last_index[char] + 1 last_index[char] = end current_length = end - start + 1 if current_length > max_length: max_length = current_length max_substring = s[start:end + 1] return max_substring"},{"question":"# Fibonacci Heap Operations You are required to implement certain operations of a Fibonacci Heap. Fibonacci heaps are a type of priority queue with more efficient amortized time complexity for several operations compared to Binomial Heaps. This implementation must support operations to manage the heap, including insertion, merging, finding the minimum value, and decreasing a key. **Objective**: Implement the following operations for a Fibonacci heap: 1. **Insertion**: Insert a new value into the heap. 2. **Merge**: Merge another Fibonacci heap into the current heap. 3. **Find Minimum**: Return the minimum value from the heap without removing it. 4. **Decrease Key**: Decrease the value of a node within the heap. **Detailed Instructions**: 1. **Insert Operation** - Implement the method `insert(self, val)` in the `FibonacciHeap` class. - This method should insert the value `val` into the heap. - Ensure the heap properties are maintained after insertion. 2. **Merge Operation** - Implement the method `merge_heaps(self, other)` in the `FibonacciHeap` class. - The method should merge the `other` Fibonacci heap into the current heap. - Ensure the heap retains its properties post-merge. 3. **Find Minimum Operation** - Implement the method `find_min(self)` in the `FibonacciHeap` class. - This method should return the minimum value from the heap without removing it. 4. **Decrease Key Operation** - Implement the method `decrease_key(self, node, new_val)` in the `FibonacciHeap` class. - This method should decrease the value of `node` to `new_val`. - Ensure the Fibonacci heap properties are maintained after the key is decreased. Here is the structure of the `FibonacciHeap` class and `Node` class (already provided): ```python class Node: def __init__(self, val): self.val = val self.degree = 0 self.marked = False self.parent = None self.child = None self.left = self self.right = self def add_child(self, child): if self.child is None: self.child = child else: child.left = self.child child.right = self.child.right self.child.right.left = child self.child.right = child child.parent = self self.degree += 1 class FibonacciHeap: def __init__(self): self.min_node = None self.num_nodes = 0 def merge_heaps(self, other): # Merge logic pass def insert(self, val): # Insert logic pass def find_min(self): # Find minimum logic pass def decrease_key(self, node, new_val): # Decrease key logic pass def is_empty(self): return self.min_node is None ``` **Constraints**: 1. Perform the merge operation in-place. 2. Ensure all operations maintain the correct Fibonacci heap properties. 3. The operations should be efficient as per the Fibonacci heap complexities. **Examples**: ```python # Insert Operation heap = FibonacciHeap() heap.insert(10) heap.insert(4) heap.insert(15) assert heap.find_min() == 4 # Decrease Key Operation node = Node(8) heap.insert(node.val) heap.decrease_key(node, 2) assert heap.find_min() == 2 # Merge Operation heap1 = FibonacciHeap() heap1.insert(1) heap1.insert(20) heap2 = FibonacciHeap() heap2.insert(3) heap2.insert(6) heap1.merge_heaps(heap2) assert heap1.find_min() == 1 ```","solution":"class Node: def __init__(self, val): self.val = val self.degree = 0 self.marked = False self.parent = None self.child = None self.left = self self.right = self def add_child(self, child): if self.child is None: self.child = child.left = child.right = child else: child.left = self.child child.right = self.child.right self.child.right.left = child self.child.right = child child.parent = self self.degree += 1 def remove_from_siblings(self): self.left.right = self.right self.right.left = self.left class FibonacciHeap: def __init__(self): self.min_node = None self.num_nodes = 0 def merge_heaps(self, other): if other.min_node is None: return if self.min_node is None: self.min_node = other.min_node else: self._merge_root_lists(self.min_node, other.min_node) if other.min_node.val < self.min_node.val: self.min_node = other.min_node self.num_nodes += other.num_nodes def insert(self, val): new_node = Node(val) if self.min_node is None: self.min_node = new_node else: self._merge_root_lists(self.min_node, new_node) if val < self.min_node.val: self.min_node = new_node self.num_nodes += 1 def find_min(self): if self.min_node is None: return None return self.min_node.val def decrease_key(self, node, new_val): if new_val > node.val: raise ValueError(\\"new key is greater than current key\\") node.val = new_val parent = node.parent if parent and node.val < parent.val: self._cut(node, parent) self._cascading_cut(parent) if node.val < self.min_node.val: self.min_node = node def _merge_root_lists(self, a, b): a_right = a.right a.right = b.right b.right.left = a b.right = a_right a_right.left = b def _cut(self, node, parent): parent.add_child(node) node.parent = None node.marked = False def _cascading_cut(self, node): parent = node.parent if parent: if not node.marked: node.marked = True else: self._cut(node, parent) self._cascading_cut(parent) def is_empty(self): return self.min_node is None"},{"question":"# Context A group of researchers is analyzing a set of natural numbers and their properties. They are particularly interested in identifying and categorizing numbers based on their factor compositions. Specifically, they need a computation to find out whether a number is \\"perfect,\\" \\"abundant,\\" or \\"deficient.\\" # Problem Statement Write a function `number_classification(n: int) -> str` that decides whether a number is \\"perfect,\\" \\"abundant,\\" or \\"deficient.\\" A perfect number equals the sum of its proper divisors (excluding itself). An abundant number is smaller than the sum of its proper divisors, while a deficient number is greater than the sum of its proper divisors. # Function Signature ```python def number_classification(n: int) -> str: pass ``` # Input 1. `n` - an integer, the number to classify. # Output * A string, which can be either \\"perfect\\", \\"abundant\\", or \\"deficient\\" based on the classification criteria. # Examples 1. `number_classification(6)` should return `\\"perfect\\"`. 2. `number_classification(12)` should return `\\"abundant\\"`. 3. `number_classification(15)` should return `\\"deficient\\"`. 4. `number_classification(28)` should return `\\"perfect\\"`. # Constraints * `n` will be a positive integer (1 ≤ n ≤ 10^6). # Notes * Proper divisors of a number `x` are those divisors which do not include `x` itself. * The solution should efficiently handle large inputs up to the constraint limits.","solution":"def number_classification(n: int) -> str: Returns whether a number \'n\' is \\"perfect\\", \\"abundant\\" or \\"deficient\\". if n == 1: return \\"deficient\\" divisors_sum = 1 # 1 is a proper divisor of any number > 1 # Iterate through potential divisors for i in range(2, int(n**0.5) + 1): if n % i == 0: divisors_sum += i if i != n // i: divisors_sum += n // i if divisors_sum == n: return \\"perfect\\" elif divisors_sum > n: return \\"abundant\\" else: return \\"deficient\\""},{"question":"Problem Statement You are provided with assorted functions including a function to update keys in a dictionary and a function to search for elements within a list. Your task is to implement a function `merge_dicts_with_common_keys` that merges two dictionaries by summing the values of common keys and keeping the rest as they are. # Function Signature ```python def merge_dicts_with_common_keys(dict1: dict[str, int], dict2: dict[str, int]) -> dict[str, int]: pass ``` # Input - `dict1`: A dictionary with string keys and integer values. - `dict2`: A dictionary with string keys and integer values. # Output - Returns a merged dictionary where keys that are present in both input dictionaries have their values summed. Keys that appear in only one of the dictionaries should appear in the result with their original values. # Constraints - `len(dict1), len(dict2) <= 10^5` - The keys in dict1 and dict2 are unique within each dictionary. - The values are integers in the range `-10^9 <= value <= 10^9`. # Requirements - Your implementation should efficiently merge the dictionaries. - Handle edge cases such as empty dictionaries. # Example Example 1: ```python dict1 = {\'a\': 1, \'b\': 2, \'c\': 3} dict2 = {\'b\': 3, \'c\': 4, \'d\': 5} merge_dicts_with_common_keys(dict1, dict2) ``` **Output**: `{\'a\': 1, \'b\': 5, \'c\': 7, \'d\': 5}` Example 2: ```python dict1 = {\'apple\': 10, \'banana\': 20} dict2 = {\'banana\': 5, \'cherry\': 15} merge_dicts_with_common_keys(dict1, dict2) ``` **Output**: `{\'apple\': 10, \'banana\': 25, \'cherry\': 15}` Example 3: ```python dict1 = {} dict2 = {\'pear\': 50, \'melon\': 30} merge_dicts_with_common_keys(dict1, dict2) ``` **Output**: `{\'pear\': 50, \'melon\': 30}` # Additional Requirements - Consider using the `collections.defaultdict` to simplify the merging process. - Your implementation should operate in O(n) time, where n is the total number of keys from both dictionaries combined. # Hints - Think about how you can take advantage of dictionary operations like `update` and the `in` keyword for key lookup and updating key values efficiently.","solution":"from collections import defaultdict def merge_dicts_with_common_keys(dict1: dict[str, int], dict2: dict[str, int]) -> dict[str, int]: Merges two dictionaries by summing the values of common keys and keeping the rest unchanged. Parameters: - dict1: Dictionary with string keys and integer values. - dict2: Dictionary with string keys and integer values. Returns: - A dictionary where keys that are present in both input dictionaries have their values summed. Keys that appear in only one of the dictionaries appear in the result with their original values. merged_dict = defaultdict(int) # Add all values from dict1 for key, value in dict1.items(): merged_dict[key] += value # Add all values from dict2 for key, value in dict2.items(): merged_dict[key] += value return dict(merged_dict)"},{"question":"# Problem Statement You are assigned to create a function that generates the shortest path of moves to convert a given start string of \'0\'s and \'1\'s into a target string of identical length, consisting entirely of \'1\'s. Allowed moves include flipping a single bit (0 to 1 or 1 to 0) or flipping all bits of a contiguous subarray of the string. **Input Format:** - A string `start` representing the initial configuration consisting only of characters \'0\' and \'1\'. - A string `target` which is always of the same length as `start`, consisting only of character \'1\'. **Output Format:** - An integer representing the minimum number of moves required to convert `start` to `target`. # Function Signature ```python def min_moves_to_convert(start: str, target: str) -> int: pass ``` # Constraints and Points to Consider: - Both `start` and `target` have the same length and consist solely of \'0\'s and \'1\'s. - The length of `start` (and `target`) is between 1 and 10,000. - Optimize the function considering the constraints. - Consider possible large subarray flips and isolated bit flips to minimize the total number of moves. # Example ```python print(min_moves_to_convert(\\"00101\\", \\"11111\\")) # Expected output: 3 # Explanation: Flip subarray [start:0, end:1] -> \\"11101\\" # Flip subarray [start:3, end:4] -> \\"11111\\" print(min_moves_to_convert(\\"0000\\", \\"1111\\")) # Expected output: 1 # Explanation: Flip subarray [start:0, end:3] -> \\"1111\\" ``` # Notes - Ensure there are no leading zeros in converted segments unless it is part of an overall subarray flip. - Utilize efficient methods for determining the difference and the minimum number of operations. - Consider edge cases such as already having the target string at the start and minimal configurations for the smallest and largest possible inputs.","solution":"def min_moves_to_convert(start: str, target: str) -> int: flips = 0 n = len(start) i = 0 while i < n: if start[i] == \'0\': flips += 1 while i < n and start[i] == \'0\': i += 1 i += 1 return flips"},{"question":"# Scenario In database management systems, indexing is used to speed up the retrieval of records within a table. However, creating and maintaining indices incur certain overheads, and their benefits depend on the data and the types of queries executed. # Problem Create two functions: 1. `estimate_index_cost(table_size: int, index_size: int) -> float`: This function should estimate the cost of maintaining an index given the size of the table and the size of the index. 2. `estimate_query_speedup(table_size: int, query_count: int, query_cost_without_index: float, query_cost_with_index: float) -> float`: This function should estimate the speedup for query execution when an index is used, given the table size, the number of queries, the cost per query without an index, and the cost per query with the index. # Requirements - Implement these functions to handle positive integers and floats. - Raise a `ValueError` with an appropriate message if the input value for table size, index size, query count, query cost without index or query cost with index is non-positive. # Function Signatures ```python def estimate_index_cost(table_size: int, index_size: int) -> float: ... def estimate_query_speedup(table_size: int, query_count: int, query_cost_without_index: float, query_cost_with_index: float) -> float: ... ``` # Input and Output - `estimate_index_cost`: - **Input**: An integer `table_size` representing the number of records in the table, and an integer `index_size` representing the size of the index as a percentage of the table size. - **Output**: A float representing the cost of maintaining the index as a percentage of the table size. - `estimate_query_speedup`: - **Input**: An integer `table_size` representing the number of records in the table, an integer `query_count` representing the number of queries to execute, a float `query_cost_without_index` representing the average cost per query without an index, and a float `query_cost_with_index` representing the average cost per query with an index. - **Output**: A float representing the speedup in query execution time when an index is used. # Constraints - The table size, index size, and query count will be in the range 1 to 10^6. - The query costs will be in the range 0.01 to 10^6. - Handling of input validation for negative or zero values is required. # Examples - `estimate_index_cost(1000, 5)` should return `50.0`. - `estimate_query_speedup(1000, 100, 5.0, 1.0)` should return `4.0`. - `estimate_index_cost(1000, 20)` should return `200.0`. - `estimate_query_speedup(1000, 200, 10.0, 2.5)` should return `4.0`. - `estimate_index_cost(0, 5)` should raise a `ValueError` with the message \\"Table size must be positive.\\" - `estimate_query_speedup(1000, 100, -5.0, 1.0)` should raise a `ValueError` with the message \\"Query cost must be positive.\\" # Testing Provide Python\'s built-in `doctest` module test cases demonstrating the usage and correctness of the functions.","solution":"def estimate_index_cost(table_size: int, index_size: int) -> float: Estimates the cost of maintaining an index. Parameters: table_size (int): The number of records in the table. index_size (int): The size of the index as a percentage of the table size. Returns: float: The cost of maintaining the index as a percentage of the table size. Raises: ValueError: If table_size or index_size is not positive. if table_size <= 0: raise ValueError(\\"Table size must be positive.\\") if index_size <= 0 or index_size > 100: raise ValueError(\\"Index size must be a positive percentage (1-100).\\") return (table_size * index_size * 0.01) def estimate_query_speedup(table_size: int, query_count: int, query_cost_without_index: float, query_cost_with_index: float) -> float: Estimates the speedup for query execution when an index is used. Parameters: table_size (int): The number of records in the table. query_count (int): The number of queries to execute. query_cost_without_index (float): The average cost per query without an index. query_cost_with_index (float): The average cost per query with an index. Returns: float: The speedup in query execution time when an index is used. Raises: ValueError: If table_size, query_count, query_cost_without_index, or query_cost_with_index is not positive. if table_size <= 0: raise ValueError(\\"Table size must be positive.\\") if query_count <= 0: raise ValueError(\\"Query count must be positive.\\") if query_cost_without_index <= 0: raise ValueError(\\"Query cost without index must be positive.\\") if query_cost_with_index <= 0: raise ValueError(\\"Query cost with index must be positive.\\") return query_cost_without_index / query_cost_with_index"},{"question":"**[Question 2]:** **Valid Parentheses Permutations** **Background**: Checking for valid parentheses permutations is a common problem in data structures, particularly using stacks. It involves ensuring that every opening parenthesis has a corresponding closing parenthesis in the correct order. **Problem Statement**: Write a function `is_valid_permutation(s: str) -> bool` that determines if the given string `s` represents a valid permutation of parentheses. A valid permutation follows the correct order where every opening parenthesis \'(\' has a closing parenthesis \')\'. **Implementation Details**: 1. Iterate through the string, using a stack to keep track of opening parentheses. 2. Ensure each opening parenthesis \'(\' is correctly closed by a corresponding \')\'. 3. Return `True` if the string is valid, `False` otherwise. **Input**: * `s` (str): A string consisting of only characters \'(\' and \')\'. **Output**: * `is_valid_permutation` (bool): `True` if the string is a valid permutation of parentheses, `False` otherwise. **Constraints**: * 1 ≤ `len(s)` ≤ 10^5 (to ensure efficiency). * The string may contain only the characters \'(\' and \')\'. **Performance Requirements**: * The solution should operate in O(n) time complexity, where n is the length of the string. **Example**: ```python # Example 1 s = \\"((()))\\" \'\'\' Explanation: - First \'(\' opens - Second \'(\' opens - Third \'(\' opens - Third \')\' closes - Second \')\' closes - First \')\' closes Valid permutation assert is_valid_permutation(\\"((()))\\") == True # Example 2 s = \\"(()())\\" \'\'\' Explanation: - First \'(\' opens - Second \'(\' opens - First \')\' closes - Third \'(\' opens - Second \')\' closes - Third \')\' closes Valid permutation assert is_valid_permutation(\\"(()())\\") == True # Example 3 s = \\"())(\\" \'\'\' Explanation: - First \'(\' opens - First \')\' closes - Second \')\' closes before second \'(\' opens (invalid) Invalid permutation assert is_valid_permutation(\\"())(\\") == False ``` *Note*: Make sure your function accurately identifies balanced strings while accommodating the constraints provided.","solution":"def is_valid_permutation(s: str) -> bool: Determine if the given string s is a valid permutation of parentheses. stack = [] for char in s: if char == \'(\': stack.append(char) elif char == \')\': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"# String Rotation Index In this task, you are required to implement a function that determines the index by which a string has been rotated. A rotated string is obtained by taking a string and moving a certain number of characters from the beginning to the end. Your task is to determine and return this index given the original and rotated strings. **Function Signature:** ```python def find_rotation_index(original: str, rotated: str) -> int: pass ``` **Parameters:** - `original` (str): The original string. - `rotated` (str): The rotated version of the original string. **Returns:** - `index` (int): The number of characters that have been moved from the beginning of the original string to the end to form the rotated string. **Constraints:** 1. The original and rotated strings are non-empty and consist of lowercase alphabetic characters. 2. The length of the original string will be the same as the length of the rotated string. 3. If the rotated string is not a valid rotation of the original string, return -1. **Special Cases:** - If the rotated string is identical to the original string, the rotation index is 0. - If the rotated string is not a valid rotation of the original string, the function should return -1. **Examples:** 1. `find_rotation_index(original=\\"abcde\\", rotated=\\"cdeab\\")` → `2` 2. `find_rotation_index(original=\\"hello\\", rotated=\\"lohel\\")` → `3` 3. `find_rotation_index(original=\\"rotation\\", rotated=\\"rotation\\")` → `0` 4. `find_rotation_index(original=\\"abc\\", rotated=\\"acb\\")` → `-1` **Your task is to implement the `find_rotation_index` function described above. Ensure to handle edge cases and provide appropriate error messages where necessary.**","solution":"def find_rotation_index(original: str, rotated: str) -> int: Determines the index by which a string has been rotated. Parameters: original (str): The original string. rotated (str): The rotated version of the original string. Returns: int: The number of characters that have been moved from the beginning of the original string to the end to form the rotated string. Returns -1 if the rotated string is not a valid rotation of the original string. # Check if the rotated string is a valid rotation of the original string if len(original) != len(rotated): return -1 if original == rotated: return 0 # Concatenate the original string with itself concatenated = original + original # Try to find the rotated string in the concatenated string index = concatenated.find(rotated) # If the rotated string is found, return the index # Otherwise, return -1 (invalid rotation) return index if index != -1 else -1"},{"question":"# Context As part of a collaboration tool, you need to implement a feature that tracks changes in text documents over time. This will involve comparing different versions of a document and identifying added, removed, or unchanged lines. # Task Write a function `diff_versions` that compares two versions of a document and returns the differences. The function should output three lists: lines that were added, lines that were removed, and lines that remained unchanged. # Requirements * Your function should take two parameters: `version1` and `version2`, both of which are lists of strings (each string represents a line in the document). * Return a tuple of three lists in the following order: (added lines, removed lines, unchanged lines). * Ensure the function handles edge cases such as empty documents and identical versions. # Function Signature ```python def diff_versions(version1: list[str], version2: list[str]) -> tuple[list[str], list[str], list[str]]: pass ``` # Example Usage ```python >>> version1 = [\\"line1\\", \\"line2\\", \\"line3\\"] >>> version2 = [\\"line1\\", \\"line2 modified\\", \\"line4\\"] >>> diff_versions(version1, version2) ([\'line2 modified\', \'line4\'], [\'line3\'], [\'line1\']) >>> version1 = [\\"lineA\\", \\"lineB\\", \\"lineC\\"] >>> version2 = [\\"lineA\\", \\"lineC\\"] >>> diff_versions(version1, version2) ([], [\'lineB\'], [\'lineA\', \'lineC\']) >>> version1 = [] >>> version2 = [\\"line1\\"] >>> diff_versions(version1, version2) ([\'line1\'], [], []) >>> version1 = [\\"line only in v1\\"] >>> version2 = [] >>> diff_versions(version1, version2) ([], [\'line only in v1\'], []) ``` # Constraints and Considerations * Implement the function efficiently to handle large documents with thousands of lines. * You may use standard Python libraries but avoid third-party libraries. * Ensure proper error handling and consider edge cases where both versions are identical, one is empty, or both are empty.","solution":"def diff_versions(version1: list[str], version2: list[str]) -> tuple[list[str], list[str], list[str]]: Compares two versions of a document and returns the differences. :param version1: List of strings representing lines in the first version. :param version2: List of strings representing lines in the second version. :return: A tuple containing three lists: added lines, removed lines, unchanged lines. added = [line for line in version2 if line not in version1] removed = [line for line in version1 if line not in version2] unchanged = [line for line in version1 if line in version2] return added, removed, unchanged"},{"question":"# Graph Traversal and Pathfinding Challenge In this task, you need to implement algorithms for graph traversal and shortest path finding. There are two parts to this task: Part A: Depth-First Search (DFS) Traversal Implement a Depth-First Search traversal for an undirected graph. 1. `__init__(self, vertices: int)`: Initializes the graph with the number of vertices and an adjacency list. 2. `add_edge(self, u: int, v: int)`: Adds an undirected edge between vertices `u` and `v`. 3. `dfs(self, start: int) -> List[int]`: Performs a DFS traversal starting from vertex `start` and returns a list of visited vertices in the order they were visited. Part B: Dijkstra\'s Shortest Path Algorithm Implement Dijkstra\'s algorithm to find the shortest path from a source vertex to all other vertices in a weighted graph. 1. `__init__(self, vertices: int)`: Initializes the graph with the number of vertices and an adjacency list with edge weights. 2. `add_edge(self, u: int, v: int, weight: int)`: Adds a weighted edge between vertices `u` and `v`. 3. `dijkstra(self, start: int) -> Dict[int, int]`: Performs Dijkstra’s algorithm starting from vertex `start` and returns a dictionary where keys are vertex indices and values are the shortest distance from the start vertex to that vertex. # Input and Output * `add_edge(u, v)` in DFS accepts two integer vertices. * `add_edge(u, v, weight)` in Dijkstra accepts two integer vertices and an integer weight. * `dfs(start)` returns a list of visited vertices in order. * `dijkstra(start)` returns a dictionary of shortest distances from the start vertex. # Performance Requirements Ensure that your implementation meets the specified time complexities: * `add_edge`: O(1) for both DFS and Dijkstra * `dfs`: O(V + E) * `dijkstra`: O(V^2) using a simple priority queue, O(V log V + E log V) using a binary heap-based priority queue # Example ```python # Part A: Depth-First Search graph_dfs = GraphDFS(4) graph_dfs.add_edge(0, 1) graph_dfs.add_edge(0, 2) graph_dfs.add_edge(1, 2) graph_dfs.add_edge(2, 3) print(graph_dfs.dfs(0)) # [0, 1, 2, 3] # Part B: Dijkstra\'s Shortest Path graph_dijkstra = GraphDijkstra(5) graph_dijkstra.add_edge(0, 1, 10) graph_dijkstra.add_edge(0, 4, 3) graph_dijkstra.add_edge(1, 4, 4) graph_dijkstra.add_edge(1, 2, 2) graph_dijkstra.add_edge(2, 3, 9) graph_dijkstra.add_edge(4, 2, 8) graph_dijkstra.add_edge(4, 3, 2) print(graph_dijkstra.dijkstra(0)) # {0: 0, 1: 10, 2: 11, 3: 5, 4: 3} ``` Implement the classes `GraphDFS` and `GraphDijkstra` with the specified methods and ensure your code passes the above examples.","solution":"from typing import List, Dict import heapq # Part A: Depth-First Search (DFS) Traversal class GraphDFS: def __init__(self, vertices: int): self.vertices = vertices self.graph = [[] for _ in range(vertices)] def add_edge(self, u: int, v: int): self.graph[u].append(v) self.graph[v].append(u) def dfs(self, start: int) -> List[int]: visited = [False] * self.vertices result = [] def dfs_util(v): visited[v] = True result.append(v) for neighbor in self.graph[v]: if not visited[neighbor]: dfs_util(neighbor) dfs_util(start) return result # Part B: Dijkstra\'s Shortest Path Algorithm class GraphDijkstra: def __init__(self, vertices: int): self.vertices = vertices self.graph = [[] for _ in range(vertices)] def add_edge(self, u: int, v: int, weight: int): self.graph[u].append((v, weight)) self.graph[v].append((u, weight)) def dijkstra(self, start: int) -> Dict[int, int]: distances = {i: float(\'inf\') for i in range(self.vertices)} distances[start] = 0 priority_queue = [(0, start)] # (distance, vertex) heapq.heapify(priority_queue) while priority_queue: current_distance, u = heapq.heappop(priority_queue) if current_distance > distances[u]: continue for neighbor, weight in self.graph[u]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Context In 2D matrix manipulation problems, one common task is to figure out how to rotate a given NxN matrix 90 degrees clockwise. By rotating, we mean rearranging the elements of the matrix into a new configuration. Write a function that receives a square NxN matrix and returns a new matrix, which is a 90-degree clockwise rotation of the original matrix. # Function Implementation You need to implement the function `rotate_matrix_90_clockwise`: ```python def rotate_matrix_90_clockwise(matrix): Rotates a given NxN matrix 90 degrees clockwise. Args: matrix (list of list of int): NxN matrix to rotate. Returns: list of list of int: A new NxN matrix that represents the rotated matrix. Example: >>> rotate_matrix_90_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] pass ``` * **Input Format**: - A square matrix represented as a list of lists of integers. * **Output Format**: - A new square matrix that is the 90-degree clockwise rotation of the input matrix. * **Constraints**: - The size of the matrix `N x N` where `1 <= N <= 100`. # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(rotate_matrix_90_clockwise(matrix)) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` # Additional Notes * Ensure to handle edge cases where the matrix size is `1x1`. * The input matrix should remain unchanged. You should return a new matrix that represents the rotated matrix.","solution":"def rotate_matrix_90_clockwise(matrix): Rotates a given NxN matrix 90 degrees clockwise. Args: matrix (list of list of int): NxN matrix to rotate. Returns: list of list of int: A new NxN matrix that represents the rotated matrix. N = len(matrix) # Create a new NxN matrix filled with zeros rotated_matrix = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): rotated_matrix[j][N-1-i] = matrix[i][j] return rotated_matrix"},{"question":"# Coding Assessment Question: Matrix Diagonal Traverse Scenario: You are assigned to traverse a 2D matrix in a diagonal order. Given a `m x n` matrix of integers, return all elements of the matrix in a diagonal order as a 1D list. Challenge: Implement a function `findDiagonalOrder` that takes a 2D list `mat` representing the matrix as input and returns a list of its diagonal elements. Requirements: 1. **Input Format**: - A 2D list `mat` with `m` rows and `n` columns where `m` and `n` are the dimensions of the matrix. 2. **Output Format**: - A list of integers representing the elements of the matrix in diagonal order traversal. 3. **Constraints**: - The dimensions of the matrix (both `m` and `n`) will not exceed `1000`. - The elements of the matrix will be integers between `-1000` and `1000`. Example: You need to implement the diagonal traversal correctly as demonstrated in the below example: ```python # Example usage mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] result = findDiagonalOrder(mat) print(result) # Expected output: [1, 2, 4, 7, 5, 3, 6, 8, 9] ``` Explanation: - The matrix should be traversed in the following diagonal order: - Start from the top-left corner and move upwards-rightwards (if possible), then downwards-leftwards in a zigzag manner. Implement the `findDiagonalOrder` function to achieve diagonal traversal as specified. ```python def findDiagonalOrder(mat): if not mat or not mat[0]: return [] m, n = len(mat), len(mat[0]) result, intermediate = [], [] for d in range(m + n - 1): intermediate.clear() r = 0 if d < n else d - n + 1 c = d if d < n else n - 1 while r < m and c > -1: intermediate.append(mat[r][c]) r += 1 c -= 1 if d % 2 == 0: result.extend(intermediate[::-1]) else: result.extend(intermediate) return result ```","solution":"def findDiagonalOrder(mat): if not mat or not mat[0]: return [] m, n = len(mat), len(mat[0]) result, intermediate = [], [] for d in range(m + n - 1): intermediate.clear() r = 0 if d < n else d - n + 1 c = d if d < n else n - 1 while r < m and c > -1: intermediate.append(mat[r][c]) r += 1 c -= 1 if d % 2 == 0: result.extend(intermediate[::-1]) else: result.extend(intermediate) return result"},{"question":"# Prime Factorization and Divisor Summation Context You are given an integer and you need to determine its prime factorization. Additionally, you need to compute the sum of all its divisors, including the number itself. Task 1. Implement a function, `prime_factors(n: int) -> list` that returns the prime factorization of the input number. 2. Implement a function, `sum_of_divisors(n: int) -> int` that calculates the sum of all divisors of the number. Specifications 1. You have two functions to implement: ```python def prime_factors(n: int) -> list: Determine the prime factors of the provided number. Args: n: An integer Returns: list: A list of prime factors of n in ascending order. Raises: ValueError: If input is not a positive integer def sum_of_divisors(n: int) -> int: Return the sum of all divisors of the number. Args: n: An integer Returns: int: The sum of all divisors of n Raises: ValueError: If input is not a positive integer ``` Input and Output Formats * **Input**: * `n` - A positive integer. * The integer should be greater than 0. * **Output**: * For `prime_factors`: Return a list of prime factors of the integer in ascending order. * For `sum_of_divisors`: Return an integer representing the sum of all divisors of the number. Constraints * The number `n` should be a positive integer greater than 0. Examples ```python assert prime_factors(28) == [2, 2, 7] assert prime_factors(45) == [3, 3, 5] assert sum_of_divisors(28) == 56 # 1 + 2 + 4 + 7 + 14 + 28 assert sum_of_divisors(12) == 28 # 1 + 2 + 3 + 4 + 6 + 12 ```","solution":"def prime_factors(n: int) -> list: Determine the prime factors of the provided number. Args: n: An integer Returns: list: A list of prime factors of n in ascending order. Raises: ValueError: If input is not a positive integer if n <= 0: raise ValueError(\\"Input must be a positive integer\\") factors = [] # handle 2 separately to allow increment of divisor by 2 later on while n % 2 == 0: factors.append(2) n //= 2 # Check for odd factors divisor = 3 while n != 1 and divisor * divisor <= n: while n % divisor == 0: factors.append(divisor) n //= divisor divisor += 2 if n > 1: factors.append(n) return factors def sum_of_divisors(n: int) -> int: Return the sum of all divisors of the number. Args: n: An integer Returns: int: The sum of all divisors of n Raises: ValueError: If input is not a positive integer if n <= 0: raise ValueError(\\"Input must be a positive integer\\") total = 0 # Find divisors up to sqrt(n) and their complements for i in range(1, int(n**0.5) + 1): if n % i == 0: total += i if i != n // i: # avoid adding square root twice if n is a perfect square total += n // i return total"},{"question":"# Question: Convert Base64 to ASCII Text Base64 is a binary-to-text encoding scheme that is primarily used to encode binary data in a format that can be transmitted over text-based protocols. You are tasked with implementing the functionality to decode a Base64 encoded string into its corresponding ASCII text representation. Function: `base64_to_ascii` ```python def base64_to_ascii(encoded_str: str) -> str: Decode a Base64 encoded string to its ASCII text representation. Parameters: encoded_str (str) : The Base64 encoded string. Returns: str : The decoded ASCII string. ``` # Constraints: 1. The `encoded_str` will only contain valid Base64 characters (`A-Z`, `a-z`, `0-9`, `+`, `/`, and padding character `=`). 2. The length of the `encoded_str` will be a multiple of 4. 3. Assume the input is always a valid Base64 encoded string. # Example: ```python >>> base64_to_ascii(\\"SGVsbG8gV29ybGQ=\\") # Expected output \\"Hello World\\" >>> base64_to_ascii(\\"UHl0aG9u\\") # Expected output \\"Python\\" >>> base64_to_ascii(\\"QmFzZTY0\\") # Expected output \\"Base64\\" >>> base64_to_ascii(\\"ZWNobw==\\") # Expected output \\"echo\\" ``` # Additional Requirements: 1. The function should handle different lengths of encoded input efficiently. 2. Adhere to O(n) time complexity where n is the length of the encoded string.","solution":"import base64 def base64_to_ascii(encoded_str: str) -> str: Decode a Base64 encoded string to its ASCII text representation. Parameters: encoded_str (str) : The Base64 encoded string. Returns: str : The decoded ASCII string. decoded_bytes = base64.b64decode(encoded_str) decoded_str = decoded_bytes.decode(\'ascii\') return decoded_str"},{"question":"Coding Challenge: Digital Root Calculation In this challenge, you are required to write a function to compute the digital root of a non-negative integer. The digital root of a non-negative integer is the single-digit value obtained by an iterative process of summing digits, on each iteration using the result from the previous iteration, until a single-digit number is reached. # Function Specification: ```python def digital_root(n: int) -> int: Calculate the digital root of a non-negative integer. The digital root is found by repeatedly summing the digits of the given non-negative integer until a single-digit number is obtained. Args: n (int): The non-negative integer. Returns: int: The digital root of the integer. ``` # Constraints 1. The input `n` will be a non-negative integer. 2. The calculation should handle very large integers efficiently. # Input * `n`: a non-negative integer representing the number for which the digital root is to be calculated. # Output * Return the digital root as an integer. # Example ```python >>> digital_root(12345) 6 >>> digital_root(0) 0 >>> digital_root(9) 9 >>> digital_root(99) 9 >>> digital_root(493193) 2 ``` # Additional Considerations Think about edge cases such as: * What happens if the input number is already a single-digit? * How to handle very large integers effectively? Implement your function efficiently to ensure it performs well even with very large inputs.","solution":"def digital_root(n: int) -> int: Calculate the digital root of a non-negative integer. The digital root is found by repeatedly summing the digits of the given non-negative integer until a single-digit number is obtained. Args: n (int): The non-negative integer. Returns: int: The digital root of the integer. while n >= 10: n = sum(int(digit) for digit in str(n)) return n"},{"question":"# Problem Develop two functions `sequence_sum` and `sequence_product` that operate on a sequence of integers provided as a string. The sequence contains integers separated by commas. The functions should calculate the sum and product of the integers, respectively, and handle both positive and negative values. # Requirements 1. Validate the input to ensure it\'s a well-formed string of integers separated by commas. 2. Handle edge cases such as an empty sequence or invalid inputs gracefully. 3. Write independent tests to verify your implementation. # Constraints * The input sequence will be a string with integers separated by commas. * The integers in the sequence can be both positive and negative. * You should not use Python\'s built-in sum() or prod() functions. # Input and Output Format - `sequence_sum(sequence: str) -> int` - `sequence_product(sequence: str) -> int` Here\'s an example of how these functions should work: ```python sequence = \\"1,2,3,-4,5\\" assert sequence_sum(sequence) == 7 assert sequence_product(sequence) == -120 empty_sequence = \\"\\" assert sequence_sum(empty_sequence) == 0 assert sequence_product(empty_sequence) == 1 ``` # Additional Information - Use exception handling to manage invalid inputs and ensure the functions return appropriate results for edge cases. - Consider inputs such as an empty sequence, sequences with only one number, and sequences with both positive and negative numbers. # Solution Template ```python def sequence_sum(sequence: str) -> int: Calculate the sum of integers in the string sequence. if not sequence: return 0 try: numbers = [int(x) for x in sequence.split(\',\')] except ValueError: raise ValueError(\\"Invalid input: sequence must contain only integers separated by commas\\") total_sum = 0 for num in numbers: total_sum += num return total_sum def sequence_product(sequence: str) -> int: Calculate the product of integers in the string sequence. if not sequence: return 1 try: numbers = [int(x) for x in sequence.split(\',\')] except ValueError: raise ValueError(\\"Invalid input: sequence must contain only integers separated by commas\\") total_product = 1 for num in numbers: total_product *= num return total_product ``` # Example Usage ```python sequence = \\"1,2,3,-4,5\\" print(sequence_sum(sequence)) # Output: 7 print(sequence_product(sequence)) # Output: -120 empty_sequence = \\"\\" print(sequence_sum(empty_sequence)) # Output: 0 print(sequence_product(empty_sequence)) # Output: 1 ``` This newly composed problem maintains the style, complexity, and scope of the original set. It explores the domains of string manipulation, arithmetic calculations, and error handling in Python, which are common in coding assessments.","solution":"def sequence_sum(sequence: str) -> int: Calculate the sum of integers in the string sequence. if not sequence: return 0 try: numbers = [int(x) for x in sequence.split(\',\')] except ValueError: raise ValueError(\\"Invalid input: sequence must contain only integers separated by commas\\") total_sum = 0 for num in numbers: total_sum += num return total_sum def sequence_product(sequence: str) -> int: Calculate the product of integers in the string sequence. if not sequence: return 1 try: numbers = [int(x) for x in sequence.split(\',\')] except ValueError: raise ValueError(\\"Invalid input: sequence must contain only integers separated by commas\\") total_product = 1 for num in numbers: total_product *= num return total_product"},{"question":"# Coding Assessment Question **Context:** You are developing a module to evaluate mathematical expressions described as strings. An expression can include integers, parentheses, and the operators `+`, `-`, `*`, and `/`. You need to write a function to compute the value of these expressions by taking operator precedence and parentheses into account. **Problem Statement:** Write a function `evaluate_expression(expression: str) -> int` that takes a string `expression` representing a valid mathematical expression and returns the integer result of the computation. You must handle the standard operator precedence and support all basic operations (i.e., addition, subtraction, multiplication, and division). **Input:** - A string `expression` containing a valid mathematical expression. - The expression will only contain integers, the operators `+`, `-`, `*`, `/`, and parentheses `(`, `)`. - The input string will be non-empty and valid according to the usual rules of arithmetic. **Output:** - An integer representing the result of evaluating the mathematical expression. **Constraints:** - The expression string\'s length will be within a reasonable limit for manual calculations, not exceeding 100 characters. - Division in this problem refers to integer division, i.e., the quotient is floored. # Function Signature ```python def evaluate_expression(expression: str) -> int: pass ``` # Examples ```python # Example 1: print(evaluate_expression(\\"3+2*2\\")) # Output: 7 # Example 2: print(evaluate_expression(\\" 3/2 \\")) # Output: 1 # Example 3: print(evaluate_expression(\\" 3+5 / 2 \\")) # Output: 5 # Example 4: print(evaluate_expression(\\"(2+6*3+5-(3*14/7+2)*5)+3\\")) # Output: -12 ```","solution":"def evaluate_expression(expression: str) -> int: def helper(tokens): stack = [] num = 0 sign = \'+\' while len(tokens) > 0: char = tokens.pop(0) if char.isnumeric(): num = num * 10 + int(char) if char == \'(\': num = helper(tokens) if (not char.isnumeric() and char != \' \') or len(tokens) == 0: if sign == \'+\': stack.append(num) elif sign == \'-\': stack.append(-num) elif sign == \'*\': stack.append(stack.pop() * num) elif sign == \'/\': stack.append(int(stack.pop() / num)) num = 0 sign = char if char == \')\': break return sum(stack) return helper(list(expression))"},{"question":"# Task: Implement a Trie Data Structure for a Simple Spell Checker # Problem Statement You are assigned the task of implementing a Trie (Prefix Tree) data structure to support the functionalities of a simple spell checker. The Trie should be able to store words and allow efficient insertion, search, and prefix-based search operations. Requirements 1. **Trie Node**: - Each node should store a character, a boolean flag indicating if it is the end of a word, and references to its child nodes. 2. **Trie Operations**: - **Insertion**: - Insert a word into the Trie. - **Search**: - Determine if a word exists in the Trie. - Return `True` if the word exists, otherwise `False`. - **Prefix Search**: - Check if there is any word in the Trie that starts with a given prefix. - Return `True` if such a word exists, otherwise `False`. 3. **Edge Cases**: - Handle the insertion of duplicate words. - Handle searches for words and prefixes not present in the Trie. - Verify performance under a large number of insertions and queries. Implementation Details - Implement the `TrieNode` class for initializing Trie nodes. - Implement the `Trie` class with the following methods: - `insert(word: str) -> None`: Inserts a word into the Trie. - `search(word: str) -> bool`: Searches for a word in the Trie and returns `True` if the word exists, otherwise `False`. - `starts_with(prefix: str) -> bool`: Returns `True` if there is any word in the Trie that starts with the given prefix, otherwise `False`. Constraints - Words and prefixes consist of lowercase alphabets (\'a\' to \'z\') and are non-empty. # Example Usage ```python trie = Trie() # Insertion trie.insert(\\"hello\\") trie.insert(\\"help\\") trie.insert(\\"held\\") trie.insert(\\"heap\\") # Search assert trie.search(\\"help\\") is True assert trie.search(\\"helicopter\\") is False # Prefix Search assert trie.starts_with(\\"he\\") is True assert trie.starts_with(\\"hel\\") is True assert trie.starts_with(\\"hell\\") is True assert trie.starts_with(\\"hellish\\") is False ``` Ensure that your implementation adheres to the given requirements and efficiently handles insertion, search, and prefix-based search operations within the Trie.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix): node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"# Vector Magnitude Calculation # Problem Context You are tasked with writing a function to calculate the magnitude of a high-dimensional vector. In mathematics, the magnitude (or length) of a vector in Euclidean space is defined as the square root of the sum of the squares of its components. # Task Implement the `vector_magnitude` function that takes a list of floats representing the components of a vector and returns the magnitude of the vector. # Input and Output * **Input**: - `components`: a list of floats where each float represents a component of the vector. The length of the list will be between 1 and 10^5. The elements of the list can have values between -10^5 and 10^5. * **Output**: - A float representing the magnitude of the vector, calculated using Euclidean distance formula. # Constraints - The input list `components` will have a length between 1 and 10^5. - Each component in the list will be a float between -10^5 and 10^5. - Python’s floating-point precision should be taken into account for very large and very small values. # Sample Function Signature ```python def vector_magnitude(components: list) -> float: ``` # Example ```python >>> vector_magnitude([3.0, 4.0]) 5.0 # Explanation: The magnitude is sqrt(3^2 + 4^2) = sqrt(9 + 16) = sqrt(25) = 5 >>> vector_magnitude([1.0, 2.0, 2.0]) 3.0 # The magnitude is sqrt(1^2 + 2^2 + 2^2) = sqrt(1 + 4 + 4) = sqrt(9) = 3 >>> vector_magnitude([0.0, 0.0, 0.0, 0.0]) 0.0 # The magnitude is sqrt(0^2 + 0^2 + 0^2 + 0^2) = sqrt(0) = 0 ``` # Additional Requirements 1. Carefully handle edge cases, such as vectors with zero components. 2. Ensure the function is efficient and performs well with the maximum input size.","solution":"import math from typing import List def vector_magnitude(components: List[float]) -> float: Calculate the magnitude of a high-dimensional vector. Args: components: A list of floats representing the components of the vector. Returns: A float representing the magnitude of the vector. return math.sqrt(sum(x**2 for x in components))"},{"question":"# Inventory Management System You are tasked with developing a simple inventory management system. The system should allow adding, updating, and querying items in the inventory. **Problem Statement:** Create a class `Inventory` that manages a collection of items, each with a name and a quantity. Implement methods to add items, update quantities, and query the quantity of a specific item. **Class Definition:** ```python class Inventory: def __init__(self): Initialize an empty inventory. pass def add_item(self, name: str, quantity: int): Add an item to the inventory with the given quantity. If the item already exists, update its quantity. :param name: Name of the item. :param quantity: Quantity of the item. pass def update_quantity(self, name: str, quantity: int): Update the quantity of an existing item. If the item does not exist, raise a ValueError. :param name: Name of the item. :param quantity: New quantity of the item. pass def get_quantity(self, name: str) -> int: Get the quantity of the given item. If the item does not exist, return 0. :param name: Name of the item. :return: Quantity of the item. pass ``` **Requirements:** 1. The `Inventory` class should initialize an empty inventory. 2. The `add_item` method: - If the item does not exist in the inventory, add it with the specified quantity. - If the item already exists, update its quantity by adding the provided quantity to its current quantity. 3. The `update_quantity` method: - If the item exists, update its quantity to the new provided quantity. - If the item does not exist, raise a `ValueError`. 4. The `get_quantity` method: - If the item exists, return its quantity. - If the item does not exist, return 0. **Examples:** ```python >>> inventory = Inventory() >>> inventory.add_item(\'apple\', 10) >>> inventory.add_item(\'banana\', 5) >>> inventory.get_quantity(\'apple\') 10 >>> inventory.get_quantity(\'banana\') 5 >>> inventory.get_quantity(\'orange\') 0 >>> inventory.add_item(\'apple\', 5) >>> inventory.get_quantity(\'apple\') 15 >>> inventory.update_quantity(\'banana\', 10) >>> inventory.get_quantity(\'banana\') 10 >>> inventory.update_quantity(\'orange\', 7) Traceback (most recent call last): ... ValueError: Item does not exist in inventory ```","solution":"class Inventory: def __init__(self): Initialize an empty inventory. self._items = {} def add_item(self, name: str, quantity: int): Add an item to the inventory with the given quantity. If the item already exists, update its quantity. :param name: Name of the item. :param quantity: Quantity of the item. if name in self._items: self._items[name] += quantity else: self._items[name] = quantity def update_quantity(self, name: str, quantity: int): Update the quantity of an existing item. If the item does not exist, raise a ValueError. :param name: Name of the item. :param quantity: New quantity of the item. if name in self._items: self._items[name] = quantity else: raise ValueError(\\"Item does not exist in inventory\\") def get_quantity(self, name: str) -> int: Get the quantity of the given item. If the item does not exist, return 0. :param name: Name of the item. :return: Quantity of the item. return self._items.get(name, 0)"},{"question":"# Problem Statement You have been given two lists of integers representing two sets of numbers. Your task is to determine the union of these two sets, sort the result in ascending order, and remove any duplicates. Additionally, you should return the result in the form of a list. # Function Signature ```python def union_of_sets(list1: list, list2: list) -> list: Compute the union of two lists, sort the result in ascending order, and remove any duplicates. Parameters: - list1 (list): A list of integers. - list2 (list): Another list of integers. Returns: - list: A sorted list of the union of the input lists with duplicates removed. pass ``` # Input - `list1` and `list2` are lists of integers. Note that these lists might contain duplicate values. # Output - A sorted list containing the union of the two sets derived from `list1` and `list2`. # Constraints - The length of `list1` and `list2` can range from (0) to (10^4). - The integers in `list1` and `list2` can range from (-10^6) to (10^6). # Example ```python union_of_sets([1, 2, 3, 5, 7], [3, 4, 5, 6]) # Output: [1, 2, 3, 4, 5, 6, 7] union_of_sets([10, 20, 30, 40], [30, 40, 50, 60]) # Output: [10, 20, 30, 40, 50, 60] union_of_sets([], [1, 2, 3]) # Output: [1, 2, 3] union_of_sets([4, 5, 6], []) # Output: [4, 5, 6] ``` # Notes - Remember to consider edge cases where one or both of the lists are empty. - The function should handle large integers with appropriate efficiency.","solution":"def union_of_sets(list1: list, list2: list) -> list: Compute the union of two lists, sort the result in ascending order, and remove any duplicates. Parameters: - list1 (list): A list of integers. - list2 (list): Another list of integers. Returns: - list: A sorted list of the union of the input lists with duplicates removed. result_set = set(list1).union(set(list2)) sorted_list = sorted(result_set) return sorted_list"},{"question":"# Coding Assessment Question Context You are developing a software feature for a logistics application that involves calculating the shortest path for delivering packages. One of the sub-tasks involves determining whether a point lies within a given rectangle, which represents a delivery zone. Task Implement a function `is_point_in_rectangle(x: float, y: float, rect: tuple) -> bool` that checks if a given point (x, y) is inside or on the boundary of a rectangle. The rectangle is defined by a tuple of four float values representing its bottom-left corner and top-right corner coordinates in the following format: `(x1, y1, x2, y2)`, where `(x1, y1)` are the coordinates of the bottom-left corner and `(x2, y2)` are the coordinates of the top-right corner. The function should return `True` if the point (x, y) is within or on the boundaries of the rectangle and `False` otherwise. Input and Output Format **Input**: * `x`: float - x-coordinate of the point. * `y`: float - y-coordinate of the point. * `rect`: tuple - a 4-tuple of floats `(x1, y1, x2, y2)` representing the bottom-left and top-right corners of the rectangle. **Output**: * bool - `True` if the point is inside or on the boundary of the rectangle, `False` otherwise. Constraints * The bottom-left corner `(x1, y1)` will always have coordinates less than the top-right corner `(x2, y2)` with respect to both axes. * The coordinates provided for the point and corners will be floats within the range of -10^6 to 10^6. Examples ```python # Example 1 x, y = 3, 4 rect = (1, 2, 6, 5) is_point_in_rectangle(x, y, rect) # Expected Output: True # Example 2 x, y = 7, 4 rect = (1, 2, 6, 5) is_point_in_rectangle(x, y, rect) # Expected Output: False # Example 3 x, y = 1, 2 rect = (1, 2, 6, 5) is_point_in_rectangle(x, y, rect) # Expected Output: True # Example 4 x, y = 4.5, 5.5 rect = (2.5, 3.0, 5.5, 7.0) is_point_in_rectangle(x, y, rect) # Expected Output: False ``` Implement the function to ensure it covers all possible edge cases and validates the point\'s position accurately within the given rectangle.","solution":"def is_point_in_rectangle(x: float, y: float, rect: tuple) -> bool: Checks if a given point (x, y) is inside or on the boundary of the rectangle defined by rect (x1, y1, x2, y2). Args: x (float): x-coordinate of the point. y (float): y-coordinate of the point. rect (tuple): Tuple of four floats (x1, y1, x2, y2) representing the bottom-left and top-right corners of the rectangle. Returns: bool: True if the point is inside or on the boundary of the rectangle, False otherwise. x1, y1, x2, y2 = rect return x1 <= x <= x2 and y1 <= y <= y2"},{"question":"# Validate Unicode Anagrams **Scenario**: You are developing an application that handles internationalization and needs to account for various languages and scripts. One of your tasks involves identifying anagrams, which are words or phrases formed by rearranging the letters of another, using all the original letters exactly once. However, due to the diverse range of Unicode characters, an anagram detection function must seamlessly handle not only basic Latin characters but also other Unicode scripts. **Task**: Write a function `validate_unicode_anagrams(s1: str, s2: str) -> bool` that checks if the two provided strings are anagrams of each other. Summary points to consider: * The function should handle the full range of Unicode characters. * Ignore differences in character case and assume that both strings are well-formed without spaces or punctuation marks. **Input**: * `s1` - A string containing Unicode characters. * `s2` - Another string containing Unicode characters. **Output**: * Return a boolean value: `True` if the strings are anagrams, `False` otherwise. **Constraints**: * 1 <= len(s1), len(s2) <= 10^5 * Both input strings will contain characters from the Unicode set. **Example**: ```python >>> validate_unicode_anagrams(\\"你好\\", \\"好你\\") True >>> validate_unicode_anagrams(\\"αβγ\\", \\"γβα\\") True >>> validate_unicode_anagrams(\\"abc\\", \\"abcd\\") False >>> validate_unicode_anagrams(\\"résumé\\", \\"ésumré\\") True ``` **Note**: - Transform the characters to a consistent case to ignore case sensitivity. - Efficiently check if both strings contain the same characters with the same frequency. Implement an optimal solution considering the potential length of strings in the constraint. Use hashmaps or similar structures to count and compare character frequencies.","solution":"def validate_unicode_anagrams(s1: str, s2: str) -> bool: Checks if two strings are anagrams of each other, ignoring case. Parameters: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if the strings are anagrams, False otherwise. # Normalize by converting both strings to lower case s1 = s1.lower() s2 = s2.lower() # If lengths are different, they cannot be anagrams if len(s1) != len(s2): return False # Count characters in both strings and compare from collections import Counter return Counter(s1) == Counter(s2)"},{"question":"# Stock Price Fluctuation Analysis In the world of financial markets, tracking stock prices is crucial for investors. Given a list of stock prices throughout a specific day, it is essential to analyze the minimum, maximum, and average prices within specific intervals to make informed decisions. You are tasked with writing a function that computes various statistics for given time intervals based on stock prices provided in chronological order. # Task Write a function `stock_analysis(prices: List[int], intervals: List[Tuple[int, int]]) -> List[dict]` that computes the minimum, maximum, and average prices of the stocks within given intervals. Input - `prices (List[int])`: A list of integers representing the stock prices at different timestamps. - `intervals (List[Tuple[int, int]])`: A list of tuples where each tuple consists of two integers, representing the start and end indices (inclusive) of an interval within the prices list. Output - A list of dictionaries, where each dictionary corresponds to an interval in `intervals` and contains: - `\'min_price\'`: The minimum stock price within the interval. - `\'max_price\'`: The maximum stock price within the interval. - `\'avg_price\'`: The average stock price within the interval, rounded to 2 decimal places. # Examples ```python stock_analysis([100, 102, 98, 105, 110, 108], [(0, 2), (2, 5)]) # Output: [{\'min_price\': 98, \'max_price\': 102, \'avg_price\': 100.0}, {\'min_price\': 98, \'max_price\': 110, \'avg_price\': 105.25}] stock_analysis([120, 115, 118, 122, 121], [(1, 3), (0, 4)]) # Output: [{\'min_price\': 115, \'max_price\': 122, \'avg_price\': 118.33}, {\'min_price\': 115, \'max_price\': 122, \'avg_price\': 119.2}] ``` Constraints: - The function should handle invalid interval inputs by raising appropriate `ValueError` exceptions. - `prices` list will always contain at least one element. - Each interval\'s start index must be less than or equal to the end index and both should be valid indices within `prices`. # Function Signature ```python from typing import List, Tuple, Dict def stock_analysis(prices: List[int], intervals: List[Tuple[int, int]]) -> List[dict]: pass ``` Ensure you test the function with various edge cases, including but not limited to duplicate prices, single priced intervals, and invalid intervals.","solution":"from typing import List, Tuple, Dict def stock_analysis(prices: List[int], intervals: List[Tuple[int, int]]) -> List[dict]: results = [] for start, end in intervals: # Validate the interval if start < 0 or end >= len(prices) or start > end: raise ValueError(\\"Invalid interval provided.\\") # Extract the interval from the prices list interval_prices = prices[start:end + 1] # Calculate the minimum, maximum, and average prices min_price = min(interval_prices) max_price = max(interval_prices) avg_price = round(sum(interval_prices) / len(interval_prices), 2) # Append the results in the required format results.append({ \'min_price\': min_price, \'max_price\': max_price, \'avg_price\': avg_price }) return results"},{"question":"# Scenario You have been assigned a project where you need to manage a company\'s network of computers. One of your tasks is to ensure that all internal communications between the computers are secure. To do this, you need to implement a mechanism that takes the current network setup and verifies whether there exists a path between every pair of computers. # Task Write a function `is_connected_network` that determines if the network of computers is fully connected. Represent the computers as nodes and the direct communication links between them as edges of an undirected graph. # Function Signature ```python def is_connected_network(num_computers: int, connections: list[tuple[int, int]]) -> bool: Checks if there is a path between every pair of computers in the network. :param num_computers: Number of computers (nodes) in the network. :param connections: List of tuples where each tuple represents a direct link (edge) between two computers. :return: True if the network is fully connected, False otherwise. ``` # Input - `num_computers`: An integer `n`, where 1 ≤ n ≤ 10^5, representing the number of computers. - `connections`: A list of tuples, where each tuple `(a, b)` represents a direct connection between computer `a` and computer `b`. Here, 1 ≤ a, b ≤ n and `len(connections)` ≤ 2 * 10^5. # Output - The function should return `True` if there is a path between every pair of computers, `False` otherwise. # Constraints - The network may have redundant connections, meaning multiple direct links between the same pair of computers and self-loops. - Consider edge cases such as a single computer or multiple isolated computers with no connections. # Performance Requirements - The algorithm should efficiently handle the upper limits of input sizes. # Example ```python num_computers = 4 connections = [(1, 2), (2, 3), (3, 4)] print(is_connected_network(num_computers, connections)) # Output: True num_computers = 4 connections = [(1, 2), (2, 3)] print(is_connected_network(num_computers, connections)) # Output: False ``` # Notes - Consider using depth-first search (DFS) or breadth-first search (BFS) to explore the connectivity of the network. - Make sure to account for all special cases, such as isolated computers or small networks.","solution":"def is_connected_network(num_computers, connections): Checks if there is a path between every pair of computers in the network. :param num_computers: Number of computers (nodes) in the network. :param connections: List of tuples where each tuple represents a direct link (edge) between two computers. :return: True if the network is fully connected, False otherwise. if num_computers == 1: return True # A single computer is trivially connected. # Build the adjacency list for the graph from collections import defaultdict graph = defaultdict(list) for a, b in connections: graph[a].append(b) graph[b].append(a) # Use DFS to check connectivity visited = set() def dfs(node): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) stack.extend(neighbor for neighbor in graph[current] if neighbor not in visited) # Start DFS from the first computer (assuming computers are numbered from 1 to num_computers) dfs(1) # If visited all computers, then network is fully connected return len(visited) == num_computers"},{"question":"# Problem Description You are tasked with implementing a simple key-value store with snapshots functionality. The key-value store should support storing, retrieving, and deleting key-value pairs, as well as creating and restoring snapshots. # Function Specifications 1. **set(key: str, value: str)**: Inserts or updates the key-value pair in the store. - **Input**: A string `key` and a string `value`. - **Output**: None - **Behavior**: If the `key` already exists, update its value. Otherwise, add the new key-value pair to the store. 2. **get(key: str) -> str**: Retrieves the value for the given key. - **Input**: A string `key`. - **Output**: A string representing the value associated with the `key`. If the `key` does not exist, return `\\"Key not found\\"`. 3. **delete(key: str)**: Removes the key-value pair from the store. - **Input**: A string `key`. - **Output**: None - **Behavior**: If the `key` exists, remove it from the store. If the `key` does not exist, do nothing. 4. **create_snapshot() -> int**: Creates a snapshot of the current state of the key-value store. - **Input**: None - **Output**: An integer representing the snapshot ID. - **Behavior**: Capture the current state of the key-value store and return a unique snapshot ID. 5. **restore_snapshot(snapshot_id: int)**: Restores the key-value store to the state captured by the specified snapshot ID. - **Input**: An integer `snapshot_id`. - **Output**: None - **Behavior**: If the `snapshot_id` exists, restore the store to that state. If the `snapshot_id` does not exist, do nothing. # Constraints - Keys and values will be non-empty strings. - The key-value store will not exceed a reasonable number of entries. - Snapshot IDs will always be positive integers. - No two snapshots will share the same ID. # Example ```python store = KeyValueStore() # Setting and getting values store.set(\\"name\\", \\"Alice\\") store.set(\\"age\\", \\"30\\") print(store.get(\\"name\\")) # Alice # Deleting a key store.delete(\\"age\\") print(store.get(\\"age\\")) # Key not found # Creating snapshots snap_id1 = store.create_snapshot() store.set(\\"name\\", \\"Bob\\") snap_id2 = store.create_snapshot() print(store.get(\\"name\\")) # Bob # Restoring snapshots store.restore_snapshot(snap_id1) print(store.get(\\"name\\")) # Alice store.restore_snapshot(snap_id2) print(store.get(\\"name\\")) # Bob ``` # Requirements - Ensure your implementation is efficient and handles a reasonable number of operations on the key-value store. - Consider edge cases such as attempting to get or delete a key that does not exist. - Each snapshot should be uniquely identifiable and restore the state accurately.","solution":"class KeyValueStore: def __init__(self): self.store = {} self.snapshots = {} self.next_snapshot_id = 1 def set(self, key, value): self.store[key] = value def get(self, key): return self.store.get(key, \\"Key not found\\") def delete(self, key): if key in self.store: del self.store[key] def create_snapshot(self): snapshot_id = self.next_snapshot_id self.snapshots[snapshot_id] = self.store.copy() self.next_snapshot_id += 1 return snapshot_id def restore_snapshot(self, snapshot_id): if snapshot_id in self.snapshots: self.store = self.snapshots[snapshot_id].copy()"},{"question":"**Context**: You are working on implementing a custom data structure to handle a unique type of query on a 2D grid. The grid supports operations to update the value at a specific cell and query the maximum value within a subgrid. **Task**: 1. Create a class `GridManager` that efficiently supports updates and range maximum queries on a 2D grid. 2. Implement a function `perform_operations` that processes a series of operations on an instance of `GridManager`. # Class Definition ```python class GridManager: def __init__(self, rows: int, cols: int): Initializes a GridManager with the specified number of rows and columns. :param rows: Number of rows in the grid. :param cols: Number of columns in the grid. # Implement this method pass def update(self, row: int, col: int, value: int) -> None: Updates the value at the specified cell. :param row: Row index of the cell to update. :param col: Column index of the cell to update. :param value: The new value to set. # Implement this method pass def query_max(self, row1: int, col1: int, row2: int, col2: int) -> int: Returns the maximum value within the specified subgrid. :param row1: Row index of the top-left corner of the subgrid. :param col1: Column index of the top-left corner of the subgrid. :param row2: Row index of the bottom-right corner of the subgrid. :param col2: Column index of the bottom-right corner of the subgrid. :return: The maximum value within the subgrid. # Implement this method pass ``` # Function Definition ```python def perform_operations(operations: list[tuple[str, ...]]) -> list[int]: Processes a series of operations on a GridManager instance and returns the results of the queries. :param operations: A list of operations to perform. Each operation is a tuple where the first element is a string indicating the operation type (\'init\', \'update\', \'query\'), followed by the respective parameters. :return: A list of integers representing the results of the \'query\' operations. # Implement this method pass ``` # Constraints: 1. The number of rows, `M`, will not exceed 1000. 2. The number of columns, `N`, will not exceed 1000. 3. The number of operations, `O`, will not exceed 100000. 4. The values within the cells can range from -10^6 to 10^6. # Example: ```python operations = [ (\'init\', 3, 3), (\'update\', 0, 0, 5), (\'update\', 1, 1, 10), (\'update\', 2, 2, -2), (\'query\', 1, 1, 2, 2), (\'query\', 0, 0, 2, 2) ] results = perform_operations(operations) # `results` should be [10, 10] ``` **Note**: The `perform_operations` function should correctly initialize the `GridManager`, perform updates, and return the results of the maximum value queries in the order they are received.","solution":"class GridManager: def __init__(self, rows: int, cols: int): Initializes a GridManager with the specified number of rows and columns. self.rows = rows self.cols = cols self.grid = [[-float(\'inf\')] * cols for _ in range(rows)] def update(self, row: int, col: int, value: int) -> None: Updates the value at the specified cell. self.grid[row][col] = value def query_max(self, row1: int, col1: int, row2: int, col2: int) -> int: Returns the maximum value within the specified subgrid. max_val = -float(\'inf\') for i in range(row1, row2 + 1): for j in range(col1, col2 + 1): if self.grid[i][j] > max_val: max_val = self.grid[i][j] return max_val def perform_operations(operations: list[tuple[str, ...]]) -> list[int]: Processes a series of operations on a GridManager instance and returns the results of the queries. results = [] grid_manager = None for op in operations: if op[0] == \'init\': _, rows, cols = op grid_manager = GridManager(rows, cols) elif op[0] == \'update\': _, row, col, value = op grid_manager.update(row, col, value) elif op[0] == \'query\': _, row1, col1, row2, col2 = op results.append(grid_manager.query_max(row1, col1, row2, col2)) return results"},{"question":"# Question: Serialize and Deserialize a Binary Tree Given the root of a binary tree, your task is two-fold: first, create a function to serialize the tree, converting it into a string representation. Second, create a function to deserialize the string back into the original binary tree structure. This pair of functions should allow the original tree to be faithfully reconstructed from its serialized form. # Function Signatures ```python def serialize(root: Node) -> str: def deserialize(data: str) -> Node: ``` # Input * `root`: The root node of the binary tree (Node object) to be serialized (for the `serialize` function). * `data`: A string representation of the binary tree, as produced by your serialize function (for the `deserialize` function). # Output * The `serialize` function should return a string that uniquely represents the binary tree structure. * The `deserialize` function should return the root node of the binary tree reconstructed from the input string. # Constraints * The number of nodes in the tree is in the range [0, 1000]. * -10^5 <= Node.value <= 10^5 # Example ```python class Node: def __init__(self, value: int): self.value = value self.left = None self.right = None tree = Node(1) tree.left = Node(2) tree.right = Node(3) tree.right.left = Node(4) tree.right.right = Node(5) # Example serialized_tree = serialize(tree) print(serialized_tree) # Output: \\"1,2,None,None,3,4,None,None,5,None,None\\" deserialized_tree = deserialize(serialized_tree) ``` # Note * The serialized format must contain explicit placeholders (e.g., \\"None\\") for absent children, ensuring that the structure is unambiguous. * The order of traversal for serialization can be pre-order, where you process the current node, then the left subtree, and then the right subtree. * Ensure the deserialization correctly rebuilds the tree to its original structure. * You can assume that the Node class and helper functions to traverse the tree will be provided in the infrastructure of your coding environment. This requires implementing the functions to handle tree data structures for reliable long-term storage, transmission, and reconstruction.","solution":"class Node: def __init__(self, value: int): self.value = value self.left = None self.right = None def serialize(root: Node) -> str: Encodes a tree to a single string. def helper(node): if not node: result.append(\\"None\\") else: result.append(str(node.value)) helper(node.left) helper(node.right) result = [] helper(root) return \',\'.join(result) def deserialize(data: str) -> Node: Decodes your encoded data to tree. def helper(): value = next(values) if value == \\"None\\": return None node = Node(int(value)) node.left = helper() node.right = helper() return node values = iter(data.split(\',\')) return helper()"},{"question":"# Optimizing a Weighted Graph for Shortest Paths Problem Statement: You are tasked with implementing an algorithm to find the shortest path in a weighted, directed graph from a given source to all other nodes. The graph does not contain any negative-weight cycles. Requirements: 1. **Function Signature**: ```python def dijkstra(graph: Dict[int, List[Tuple[int, int]]], source: int) -> Dict[int, int]: ``` 2. **Input and Output Format**: - `graph`: A dictionary where keys are node identifiers (integers) and values are lists of tuples. Each tuple represents a directed edge with a target node and a weight (e.g., `{0: [(1, 4), (2, 1)], 1: [(2, 1)], 2: [(3, 2)], 3: []}`). - `source`: An integer representing the source node from which to calculate the shortest paths. - Returns: A dictionary where keys are node identifiers and values are the shortest distances from the `source` node to each node. 3. **Constraints**: - The graph is a directed graph with non-negative weights. - The source node will always be a valid node in the graph. - Ensure that the algorithm can handle large graphs efficiently. 4. **Performance Requirements**: - The implemented algorithm should run in O((V + E) log V) time complexity, where V is the number of vertices and E is the number of edges. Example Usage: ```python graph = { 0: [(1, 4), (2, 1)], 1: [(2, 1)], 2: [(3, 2)], 3: [] } # Finding shortest paths from node 0 distances = dijkstra(graph, 0) # Outputting distances print(distances) # Output: {0: 0, 1: 4, 2: 1, 3: 3} ``` Implement the `dijkstra` function to fulfill the above specifications.","solution":"import heapq from typing import Dict, List, Tuple def dijkstra(graph: Dict[int, List[Tuple[int, int]]], source: int) -> Dict[int, int]: Finds the shortest paths from the source node to all other nodes in a weighted, directed graph. :param graph: A dictionary where keys are node identifiers and values are lists of tuples representing the connected nodes and edge weights. :param source: The source node from which to calculate shortest paths. :return: A dictionary where keys are node identifiers and values are the shortest distances from the source node to each node. min_heap = [(0, source)] distances = {source: 0} while min_heap: current_distance, current_node = heapq.heappop(min_heap) if current_distance > distances.get(current_node, float(\'inf\')): continue for neighbor, weight in graph.get(current_node, []): distance = current_distance + weight if distance < distances.get(neighbor, float(\'inf\')): distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return distances"},{"question":"# Problem Statement You are given an array of integers `arr` and an integer `k`. Your task is to write a function that computes the maximum sum of `k` consecutive elements in the array. Write a function called `max_consecutive_sum` that takes in the array and the integer `k` and returns the maximum sum. # Function Signature ```python def max_consecutive_sum(arr: list[int], k: int) -> int: pass ``` # Input * `arr` (List of integers): The input array, 1 ≤ len(arr) ≤ 100000. * `k` (Integer): The number of consecutive elements to sum, 1 ≤ k ≤ len(arr). # Output * Returns an integer representing the maximum sum of `k` consecutive elements in the array. # Constraints * All elements in the array are integers. * The elements can be positive, negative or zero. # Example ```python assert max_consecutive_sum([1, 2, 3, 4, 5, 6], 2) == 11 assert max_consecutive_sum([4, -1, 2, 1, 6, -5, 3], 3) == 9 assert max_consecutive_sum([1, -2, -3, 4, -1, 2, 1, -5, 4], 4) == 6 assert max_consecutive_sum([-1, -2, -3, -4], 2) == -3 ``` # Additional Notes Approach solving this task using a sliding window technique: 1. Initialize the sum of the first `k` elements. 2. Slide the window through the array, adding the next element and subtracting the element that is no longer in the window. 3. Keep track of the maximum sum encountered during the sliding process. 4. Return the maximum sum after iterating through the entire array.","solution":"def max_consecutive_sum(arr: list[int], k: int) -> int: Computes the maximum sum of k consecutive elements in the array. Parameters: - arr: List of integers. - k: Number of consecutive elements to sum. Returns: - Integer, maximum sum of k consecutive elements. n = len(arr) # Compute the sum of the first k elements max_sum = curr_sum = sum(arr[:k]) # Use sliding window to find max sum of any k consecutive elements for i in range(k, n): curr_sum += arr[i] - arr[i - k] if curr_sum > max_sum: max_sum = curr_sum return max_sum"},{"question":"# Problem Statement You are responsible for enhancing a log processing system that extracts meaningful information from large log files. The log file contains entries representing events that occur over time. Your task is to extend the capabilities of the `LogAnalyzer` class by adding functionality to: 1. Count occurrences of a specific event type. 2. Identify the most frequent event in the log file. 3. Calculate the time difference between the first and last occurrence of a specific event. # Task Requirements 1. Implement three new methods in the `LogAnalyzer` class: * `count_event(self, event_type: str) -> int`: Returns the count of occurrences of the specified `event_type` in the log file. * `most_frequent_event(self) -> str`: Returns the type of the most frequently occurring event in the log file. In case of a tie, return any one of the most frequent events. * `event_time_span(self, event_type: str) -> int`: Returns the time difference, in seconds, between the first and last occurrence of the specified `event_type`. The log file entries are in the format `\\"[timestamp] event_type\\"`. If the event type does not exist in the log file, return `-1`. # Input - The log is a list of strings in the format `\\"[timestamp] event_type\\"`. - The `timestamp` is in `YYYY-MM-DD HH:MM:SS` format. - The `event_type` is a string without spaces. # Output - For `count_event`, return an integer. - For `most_frequent_event`, return a string. - For `event_time_span`, return an integer representing the time span in seconds, or `-1` if the event type is not found. # Constraints 1. The log file can contain up to `10^5` entries. 2. The timestamp will always be valid and in the specified format. 3. The `event_type` will be a non-empty string without spaces. # Example ```python log_entries = [ \\"[2023-01-01 12:00:00] login\\", \\"[2023-01-01 12:05:00] logout\\", \\"[2023-01-01 12:10:00] login\\", \\"[2023-01-01 12:15:00] login\\", \\"[2023-01-01 12:20:00] transfer\\", \\"[2023-01-01 12:25:00] login\\" ] log_analyzer = LogAnalyzer(log_entries) # Example usage: print(log_analyzer.count_event(\'login\')) # Output: 4 print(log_analyzer.most_frequent_event()) # Output: \'login\' print(log_analyzer.event_time_span(\'login\')) # Output: 1500 print(log_analyzer.event_time_span(\'logout\')) # Output: 0 print(log_analyzer.event_time_span(\'transfer\')) # Output: 0 print(log_analyzer.event_time_span(\'purchase\')) # Output: -1 ``` Implement the methods in such a way that they are efficient and handle the constraints mentioned. ---","solution":"from collections import defaultdict from datetime import datetime class LogAnalyzer: def __init__(self, log_entries): self.log_entries = log_entries def count_event(self, event_type: str) -> int: count = 0 for entry in self.log_entries: if entry.endswith(event_type): count += 1 return count def most_frequent_event(self) -> str: event_count = defaultdict(int) for entry in self.log_entries: event_type = entry.split(\'] \')[-1] event_count[event_type] += 1 return max(event_count, key=event_count.get) def event_time_span(self, event_type: str) -> int: timestamps = [] for entry in self.log_entries: if entry.endswith(event_type): timestamp_str = entry.split(\'] \')[0][1:] timestamp = datetime.strptime(timestamp_str, \\"%Y-%m-%d %H:%M:%S\\") timestamps.append(timestamp) if not timestamps: return -1 timestamps.sort() return int((timestamps[-1] - timestamps[0]).total_seconds())"},{"question":"# Problem: Distance Calculation in a 2D Grid Given a 2D grid of size ( n times m ) with an initial position ((r1, c1)) and a target position ((r2, c2)), implement a function to calculate the minimum steps required to reach the target position from the initial position. The movement is restricted to the following directions: up, down, left, and right. **Input Format** - The first input line contains two integers ( n ) and ( m ) (1 ≤ ( n, m ) ≤ ( 10^9)) representing the dimensions of the grid. - The second input line contains two integers ( r1 ) and ( c1 ) (1 ≤ ( r1 le n ), 1 ≤ ( c1 le m )) representing the initial position. - The third input line contains two integers ( r2 ) and ( c2 ) (1 ≤ ( r2 le n ), 1 ≤ ( c2 le m )) representing the target position. **Output Format** - Return the minimum number of steps required to reach the target position from the initial position. **Constraints** - The grid is considered infinite, so there are no boundaries. - The solution should handle large dimensions efficiently. **Example** *Input:* ``` 1000000000 1000000000 2 3 100000 100000 ``` *Output:* ``` 199995 ``` # Detailed Requirements 1. Implement a function `min_steps_in_grid` that accepts the grid dimensions, initial position, and target position. 2. The function should use the Manhattan Distance formula to determine the minimum number of steps. **Explanation** - The minimum steps can be calculated using the Manhattan Distance: (|r2 - r1| + |c2 - c1|.) - This ensures the solution remains efficient even with very large grid sizes.","solution":"def min_steps_in_grid(n, m, r1, c1, r2, c2): Returns the minimum number of steps required to reach the target position from the initial position in a 2D grid. Parameters: - n: Number of rows in the grid (irrelevant due to infinite grid) - m: Number of columns in the grid (irrelevant due to infinite grid) - r1: Initial row position - c1: Initial column position - r2: Target row position - c2: Target column position Returns: - An integer representing the minimum steps required. return abs(r2 - r1) + abs(c2 - c1)"},{"question":"# Coding Assessment Question Scenario You are developing a matrix manipulation library for a scientific computing platform. One of the common operations required is transposing a matrix. You need to write a function that performs this operation efficiently. Task Write a function `transpose_matrix` that takes a 2D list (matrix) as input and returns a new 2D list that is the transpose of the input matrix. The transpose of a matrix is obtained by flipping it over its diagonal, switching the row and column indices of the matrix. Input * A 2D list `matrix` consisting of `n` rows and `m` columns, where `1 ≤ n, m ≤ 1000`. Output * A 2D list that represents the transpose of the input matrix. Constraints * The function must handle matrices of dimensions up to 1000x1000 efficiently. * The input matrix will always be rectangular (rows and columns) and contain only integers. Example ```python assert transpose_matrix([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]] assert transpose_matrix([[1, 2], [3, 4], [5, 6]]) == [[1, 3, 5], [2, 4, 6]] assert transpose_matrix([[7]]) == [[7]] assert transpose_matrix([[1, 2, 3, 4]]) == [[1], [2], [3], [4]] ``` This new question adheres to the guidelines provided by maintaining a consistent style, complexity, and scope with the given sample question. It explores matrix manipulation, which is a common topic in programming assessments.","solution":"def transpose_matrix(matrix): Returns the transpose of the input matrix. :param matrix: A 2D list representing the matrix to be transposed. :return: A 2D list representing the transpose of the input matrix. if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) transposed = [[0] * rows for _ in range(cols)] for i in range(rows): for j in range(cols): transposed[j][i] = matrix[i][j] return transposed"},{"question":"# Coding Assessment Question Scenario You are developing a system to handle and analyze customer feedback from an ecommerce platform. One of the tasks is to identify and extract specific keywords from the feedback to gain insights into common issues and suggestions. Task Description Write a function `extract_keywords` that takes the following parameters: * `feedback`: A list of strings, where each string is a customer feedback entry. * `keywords`: A list of strings, where each string represents a keyword to search for. * `case_sensitive`: A boolean indicating whether the keyword search should be case sensitive (`True`) or case insensitive (`False`). Your function should return a dictionary where the keys are the keywords and the values are lists of feedback entries that contain those keywords. Input and Output Formats ```python def extract_keywords(feedback, keywords, case_sensitive=True) -> dict: pass # Example usage: feedback = [\\"Great product quality, fast delivery!\\", \\"Received a defective item, had to return it.\\", \\"Customer service was very helpful.\\", \\"Product quality was not up to the mark.\\"] keywords = [\\"quality\\", \\"delivery\\", \\"service\\"] case_sensitive = False result = extract_keywords(feedback, keywords, case_sensitive) print(result) # Expected Output: # { # \\"quality\\": [\\"Great product quality, fast delivery!\\", \\"Product quality was not up to the mark.\\"], # \\"delivery\\": [\\"Great product quality, fast delivery!\\"], # \\"service\\": [\\"Customer service was very helpful.\\"] # } ``` Constraints * If `case_sensitive` is `False`, the keyword search should ignore case differences. * If a keyword is not found in any feedback entry, it should still appear as a key in the result dictionary with an empty list as its value. * Ensure the function can handle a large number of feedback entries (up to 10,000 entries) efficiently. Performance Requirements * Your function should efficiently handle searches through extensive lists of feedback. * Implement optimizations to avoid redundant searches and minimize execution time.","solution":"def extract_keywords(feedback, keywords, case_sensitive=True): Extracts and returns feedback entries that contain specific keywords. Parameters: feedback (list of str): List of feedback entries. keywords (list of str): List of keywords to search for. case_sensitive (bool): Whether the search should be case sensitive. Returns: dict: A dictionary where keys are keywords and values are lists of feedback entries containing those keywords. result = {keyword: [] for keyword in keywords} for entry in feedback: for keyword in keywords: if case_sensitive: if keyword in entry: result[keyword].append(entry) else: if keyword.lower() in entry.lower(): result[keyword].append(entry) return result"},{"question":"Problem Statement You have been asked to implement a function that simulates the operation of a simplified social network where users can follow each other. Your task is to develop an algorithm that can determine the number of distinct users that a specific user can reach, either directly or indirectly, by following the connections. # Goal Implement the function `reachable_users(n: int, connections: List[Tuple[int, int]], start_user: int) -> int` that takes an integer `n` representing the total number of users, a list of tuples `connections` where each tuple `(a, b)` indicates that user `a` follows user `b`, and an integer `start_user` which is the user for whom we want to determine the number of reachable users. # Input - `n` (1 ≤ n ≤ 10^6): The number of users in the network. - `connections` (0 ≤ |connections| ≤ 10^7): A list of tuples representing follow relationships. - `start_user` (1 ≤ start_user ≤ n): The user for which we want to find the number of reachable users. # Output - Returns an integer representing the number of distinct users that the `start_user` can reach directly or indirectly. # Constraints 1. Ensure that your solution is efficient both in terms of time and space. 2. Optimize the algorithm to handle large inputs within acceptable limits. # Example ```python def reachable_users(n: int, connections: List[Tuple[int, int]], start_user: int) -> int: # Your solution here pass # Test cases assert reachable_users(5, [(1, 2), (2, 3), (3, 4), (4, 5)], 1) == 4 assert reachable_users(5, [(1, 2), (2, 3), (3, 4), (4, 2)], 1) == 3 assert reachable_users(4, [(1, 2), (2, 3), (3, 4), (4, 1)], 2) == 3 assert reachable_users(3, [(1, 2), (2, 3)], 3) == 0 print(\\"All test cases passed!\\") ``` # Explanation - For the first test case, user 1 can reach users 2, 3, 4, and 5, so the output is 4. - For the second test case, user 1 can reach users 2, 3, and 4, but since user 4 is connected back to 2, it forms a loop but user 1 can\'t reach user 5, so the output is 3. - For the third test case, user 2 can reach users 3, and 4, but not back to user 1 due to the order of connections. - For the fourth test case, user 3 cannot reach any other users directly or indirectly. # Additional Notes 1. Use appropriate graph traversal methods such as Breadth-First Search (BFS) or Depth-First Search (DFS). 2. Keep track of visited nodes to prevent infinite loops and redundant calculations. 3. Ensure that the solution handles edge cases, such as no connections or self-connections, effectively.","solution":"def reachable_users(n, connections, start_user): from collections import defaultdict, deque # Build graph graph = defaultdict(list) for src, dest in connections: graph[src].append(dest) # Perform BFS to count reachable users visited = set() queue = deque([start_user]) while queue: user = queue.popleft() if user not in visited: visited.add(user) for neighbor in graph[user]: if neighbor not in visited: queue.append(neighbor) return len(visited) - 1 # Exclude the start_user itself"},{"question":"# Coding Assessment Question: Cyclic Rotation and String Matching Context Given two strings, a cyclic rotation of a string is created by moving characters from the start of the string to the end in order. For example, if we cyclically rotate the string \'abc\' once, it becomes \'bca\', and if we rotate it twice, it becomes \'cab\'. The task is to find if there is any cyclic rotation of a string `s1` that is a substring of another string `s2`. Objective Implement a function `is_cyclic_rotation_substring(s1: str, s2: str) -> bool` that returns `True` if any cyclic rotation of `s1` appears as a substring in `s2`, and `False` otherwise. Input/Output Formats - **Input**: * A string `s1` of length n (1 ≤ n ≤ 10^6). * A string `s2` of length m (1 ≤ m ≤ 10^6). - **Output**: * A boolean value (`True` or `False`). Constraints - Both strings contain only lowercase English letters. - The function should be efficient in terms of both time and space usage. Performance Requirements - The solution should aim for time complexity of O(n + m) to ensure it runs efficiently even for maximum input sizes. Example ```python def is_cyclic_rotation_substring(s1: str, s2: str) -> bool: # Implementation here print(is_cyclic_rotation_substring(\\"abc\\", \\"bca\\")) # Expected Output: True print(is_cyclic_rotation_substring(\\"abcde\\", \\"cdeab\\")) # Expected Output: True print(is_cyclic_rotation_substring(\\"abcde\\", \\"abcdx\\")) # Expected Output: False ``` By viewing the problem from the perspective of string matching and considering that a cyclic rotation of `s1` can be represented as a substring of `s1 + s1`, you can leverage common string algorithms to solve it efficiently.","solution":"def is_cyclic_rotation_substring(s1: str, s2: str) -> bool: Returns True if any cyclic rotation of s1 appears as a substring in s2, otherwise returns False. if not s1 or not s2: return False # Generate the concatenated string of s1 with itself concatenated = s1 + s1 # Check if s2 is a substring of the concatenated string return s2 in concatenated"},{"question":"# Distance Calculation Between Cities In this task, you are required to implement the `distance_between_cities` function, which computes the distance between two cities given their coordinates. The distance should be calculated using the Haversine formula, which accounts for the spherical shape of the Earth. The function takes as input the latitude and longitude of two cities and returns the distance between them in kilometers. Function Signature ```python def distance_between_cities(lat1: float, lon1: float, lat2: float, lon2: float) -> float: ``` Input: - `lat1`: Latitude of the first city in degrees. - `lon1`: Longitude of the first city in degrees. - `lat2`: Latitude of the second city in degrees. - `lon2`: Longitude of the second city in degrees. Output: - A float representing the distance between the two cities in kilometers. Constraints: 1. Assume that the input coordinates are valid and correspond to real geographical locations. 2. The function should handle edge cases where the cities are extremely close to each other or located on opposite sides of the globe. Performance Requirements: - The function should be efficient in terms of computational complexity. - It should use the Haversine formula to ensure accuracy for large distances. # Example Usage: ```python # Example 1: Distance between New York City and Los Angeles nyc_lat, nyc_lon = 40.7128, -74.0060 la_lat, la_lon = 34.0522, -118.2437 print(distance_between_cities(nyc_lat, nyc_lon, la_lat, la_lon)) # Expected output: ~3940.07 km # Example 2: Distance between Paris and Berlin paris_lat, paris_lon = 48.8566, 2.3522 berlin_lat, berlin_lon = 52.5200, 13.4050 print(distance_between_cities(paris_lat, paris_lon, berlin_lat, berlin_lon)) # Expected output: ~878.88 km # Example 3: Distance between Tokyo and Sydney tokyo_lat, tokyo_lon = 35.6895, 139.6917 sydney_lat, sydney_lon = -33.8688, 151.2093 print(distance_between_cities(tokyo_lat, tokyo_lon, sydney_lat, sydney_lon)) # Expected output: ~7830.45 km ``` # Implementation Notes: Your function should use the Haversine formula, given by: [ a = sin^2(Delta lat / 2) + cos(lat1) * cos(lat2) * sin^2(Delta lon / 2) ] [ c = 2 * atan2(sqrt{a}, sqrt{1-a}) ] [ d = R * c ] Where: - (Delta lat) is the difference in latitudes of the two cities (in radians) - (Delta lon) is the difference in longitudes of the two cities (in radians) - (R) is the Earth\'s radius (mean radius = 6371 km) Ensure to: - Convert the input coordinates from degrees to radians before performing trigonometric calculations. - Return a clear and precise result formatted to a reasonable number of decimal places. ```python import math def distance_between_cities(lat1: float, lon1: float, lat2: float, lon2: float) -> float: R = 6371.0 # Earth\'s radius in km # Convert latitude and longitude from degrees to radians lat1_rad = math.radians(lat1) lon1_rad = math.radians(lon1) lat2_rad = math.radians(lat2) lon2_rad = math.radians(lon2) # Calculate the differences in coordinates delta_lat = lat2_rad - lat1_rad delta_lon = lon2_rad - lon1_rad # Haversine formula a = math.sin(delta_lat / 2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(delta_lon / 2)**2 c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a)) # Distance in kilometers distance = R * c return distance # Example test cases print(distance_between_cities(40.7128, -74.0060, 34.0522, -118.2437)) # Expected output: ~3940.07 km print(distance_between_cities(48.8566, 2.3522, 52.5200, 13.4050)) # Expected output: ~878.88 km print(distance_between_cities(35.6895, 139.6917, -33.8688, 151.2093)) # Expected output: ~7830.45 km ```","solution":"import math def distance_between_cities(lat1: float, lon1: float, lat2: float, lon2: float) -> float: R = 6371.0 # Earth\'s radius in km # Convert latitude and longitude from degrees to radians lat1_rad = math.radians(lat1) lon1_rad = math.radians(lon1) lat2_rad = math.radians(lat2) lon2_rad = math.radians(lon2) # Calculate the differences in coordinates delta_lat = lat2_rad - lat1_rad delta_lon = lon2_rad - lon1_rad # Haversine formula a = math.sin(delta_lat / 2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(delta_lon / 2)**2 c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a)) # Distance in kilometers distance = R * c return distance"},{"question":"# Question: Implement Optimized Run-Length Encoding and Decoding You are tasked with implementing Run-Length Encoding (RLE) for string compression and its decoding counterpart. RLE is a simple form of data compression where consecutive occurrences of the same character are replaced by one occurrence of that character followed by the number of occurrences. Function Specifications: 1. `encode_rle(data: str) -> str` - **Input**: A string (`data`) containing only uppercase alphabets. - **Output**: Encoded string using Run-Length Encoding. - **Example**: ```python assert encode_rle(\\"AAAABBBCCDAA\\") == \\"A4B3C2D1A2\\" assert encode_rle(\\"HHHHHPPPPPAA\\") == \\"H5P5A2\\" ``` 2. `decode_rle(data: str) -> str` - **Input**: A string (`data`) encoded using Run-Length Encoding. - **Output**: The original uncompressed string. - **Example**: ```python assert decode_rle(\\"A4B3C2D1A2\\") == \\"AAAABBBCCDAA\\" assert decode_rle(\\"H5P5A2\\") == \\"HHHHHPPPPPAA\\" ``` Requirements: - Handle edge cases such as empty strings and strings with no consecutive repeating characters. - Ensure the encode and decode functions are optimized for performance and avoid excessive computational complexity. Constraints: - The input string for encoding consists of only uppercase alphabets (A-Z). - The encoded format will not contain any digits outside the scope of RLE encoding (i.e., after a character indicating its count). Your task is to implement these functions following the given specifications and constraints to ensure accurate and efficient Run-Length Encoding and Decoding.","solution":"def encode_rle(data: str) -> str: if not data: return \\"\\" encoded_str = [] count = 1 for i in range(1, len(data)): if data[i] == data[i - 1]: count += 1 else: encoded_str.append(f\\"{data[i - 1]}{count}\\") count = 1 encoded_str.append(f\\"{data[-1]}{count}\\") return \\"\\".join(encoded_str) def decode_rle(data: str) -> str: decoded_str = [] i = 0 while i < len(data): char = data[i] count = \\"\\" i += 1 while i < len(data) and data[i].isdigit(): count += data[i] i += 1 decoded_str.append(char * int(count)) return \\"\\".join(decoded_str)"},{"question":"# Scenario You are tasked with developing a scheduling system for a co-working space. This system should manage reservations for different rooms while ensuring that no two reservations for the same room overlap. To achieve this, you need to implement an Interval Tree that supports: 1. Adding a new reservation. 2. Deleting an existing reservation. 3. Checking if a proposed reservation overlaps with any existing reservation. 4. Retrieving a list of all reservations sorted by their start time. # Task Implement the following methods in a class `IntervalTree`: 1. `add_reservation(self, start: int, end: int) -> IntervalTree`: * Adds a reservation with the given `start` and `end` times to the Interval Tree while maintaining its properties. * Returns the root of the tree. 2. `remove_reservation(self, start: int, end: int) -> IntervalTree`: * Removes the reservation with the given `start` and `end` times from the Interval Tree while maintaining its properties. * Returns the root of the tree. 3. `check_overlap(self, start: int, end: int) -> bool`: * Checks if the proposed reservation `[start, end]` overlaps with any existing reservation. * Returns `True` if there is an overlap, else `False`. 4. `get_sorted_reservations(self) -> List[Tuple[int, int]]`: * Returns a list of all reservations as tuples `(start, end)` sorted by their start times. # Constraints: 1. Each reservation is represented by a start and end time, where `start < end`. 2. The integer values for `start` and `end` will range from `0` to `10^6`. 3. The total number of reservations `n` will not exceed `10^5`. # Performance Requirement: Ensure that the `add_reservation` and `remove_reservation` operations maintain an average time complexity of O(log n). # Example: ```python # Initialize Interval Tree tree = IntervalTree() # Add reservations tree = tree.add_reservation(10, 20) tree = tree.add_reservation(15, 25) tree = tree.add_reservation(30, 40) # Check overlap overlap = tree.check_overlap(14, 16) print(overlap) # Output: True # List sorted reservations reservations = tree.get_sorted_reservations() print(reservations) # Output: [(10, 20), (15, 25), (30, 40)] # Remove reservation tree = tree.remove_reservation(15, 25) reservations = tree.get_sorted_reservations() print(reservations) # Output: [(10, 20), (30, 40)] ``` **Note**: Avoid using any built-in libraries for tree structures.","solution":"class IntervalTreeNode: def __init__(self, start, end): self.start = start self.end = end self.max_end = end self.left = None self.right = None class IntervalTree: def __init__(self): self.root = None def add_reservation(self, start, end): if start >= end: return self.root self.root = self._insert(self.root, start, end) return self.root def _insert(self, node, start, end): if not node: return IntervalTreeNode(start, end) if start < node.start: node.left = self._insert(node.left, start, end) else: node.right = self._insert(node.right, start, end) node.max_end = max(node.max_end, end) return node def remove_reservation(self, start, end): if start >= end: return self.root self.root = self._delete(self.root, start, end) return self.root def _delete(self, node, start, end): if not node: return None if start < node.start: node.left = self._delete(node.left, start, end) elif start > node.start: node.right = self._delete(node.right, start, end) elif node.end == end: if not node.left: return node.right if not node.right: return node.left min_larger_node = self._get_min(node.right) node.start, node.end = min_larger_node.start, min_larger_node.end node.right = self._delete(node.right, min_larger_node.start, min_larger_node.end) node.max_end = max(node.end, self._get_max_end(node.left), self._get_max_end(node.right)) return node def _get_min(self, node): while node.left: node = node.left return node def _get_max_end(self, node): return node.max_end if node else 0 def check_overlap(self, start, end): return self._check_overlap(self.root, start, end) def _check_overlap(self, node, start, end): if not node: return False if node.start < end and start < node.end: return True if node.left and node.left.max_end > start: return self._check_overlap(node.left, start, end) return self._check_overlap(node.right, start, end) def get_sorted_reservations(self): results = [] self._in_order_traversal(self.root, results) return results def _in_order_traversal(self, node, results): if not node: return self._in_order_traversal(node.left, results) results.append((node.start, node.end)) self._in_order_traversal(node.right, results)"},{"question":"# Coding Challenge: Multiset Permutations Generator Write a function that generates all distinct permutations of elements from a given multiset. A multiset is a set that allows duplicate elements. Return the permutations in lexicographic order. # Task Implement the function `multiset_permutations` which takes a multiset as input and generates all distinct permutations of it in lexicographic order without using Python\'s built-in permutation functions. # Function Signature ```python def multiset_permutations(multiset: list[int]) -> list[list[int]]: ``` # Inputs - `multiset`: A list of integers where duplicates are allowed, representing the multiset. # Outputs - Returns a list of lists, where each inner list represents a distinct permutation of the multiset, sorted in lexicographic order. # Constraints 1. The length of `multiset` will be between 1 and 8, inclusive. 2. Elements in the multiset are integers between -10 and 10, inclusive. # Example ```python multiset = [1, 1, 2] print(multiset_permutations(multiset)) # Expected Output: # [[1, 1, 2], [1, 2, 1], [2, 1, 1]] multiset = [2, 2, 1, 1] print(multiset_permutations(multiset)) # Expected Output: # [[1, 1, 2, 2], [1, 2, 1, 2], [1, 2, 2, 1], [2, 1, 1, 2], [2, 1, 2, 1], [2, 2, 1, 1]] ``` # Additional Information - Ensure the generated permutations are in lexicographic order. - Permutations should not include any duplicates. # Hints - Use backtracking with state to generate permutations, making sure to skip duplicates. - Consider sorting the multiset first to facilitate generation in lexicographic order. - Use a counter or similar data structure to efficiently manage duplicates during permutation generation.","solution":"def multiset_permutations(multiset): Generate all distinct permutations of elements from a given multiset in lexicographic order. def backtrack(path, counter): if len(path) == len(multiset): result.append(path[:]) return for number in sorted(counter): # Lexicographic order if counter[number] > 0: path.append(number) counter[number] -= 1 backtrack(path, counter) path.pop() counter[number] += 1 from collections import Counter counter = Counter(multiset) result = [] backtrack([], counter) return result"},{"question":"# Coding Assessment Question Problem Context: In the game of Battleship, a board is a 2D grid of n x n cells, where each cell either contains a part of a battleship or is empty. Battleships can only be placed horizontally or vertically, and no two battleships will touch (they will always have at least one empty cell between them). Task: Write a function to count the number of battleships on a given board. Function Signature: ```python def count_battleships(board: List[List[str]]) -> int: ``` Input: * A 2D grid \'board\' of size ( n times n ) (2 ≤ n ≤ 200), where \'X\' represents part of a battleship and \'.\' represents an empty cell. Output: * An integer: The number of distinct battleships present on the board. Constraints: * Battleships can only be placed horizontally or vertically, and each battleship occupies one or more consecutive cells. Example: ```python >>> count_battleships([ ... [\'X\', \'.\', \'.\', \'X\'], ... [\'.\', \'.\', \'.\', \'X\'], ... [\'.\', \'.\', \'.\', \'X\'] ... ]) 2 >>> count_battleships([ ... [\'.\', \'X\', \'X\', \'.\'], ... [\'.\', \'.\', \'.\', \'.\'], ... [\'.\', \'X\', \'X\', \'.\'] ... ]) 2 >>> count_battleships([ ... [\'.\', \'.\', \'.\'], ... [\'.\', \'.\', \'.\'], ... [\'.\', \'.\', \'.\'] ... ]) 0 ``` Notes: * A battleship is represented by a vertical or horizontal sequence of \'X\' cells. * The function should be optimized for performance within the given constraints. * No two battleships will be adjacent or diagonal to each other. They will always have at least one empty cell between them.","solution":"def count_battleships(board): if not board: return 0 def dfs(i, j): if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] == \'.\': return board[i][j] = \'.\' for x, y in ((0, 1), (1, 0), (0, -1), (-1, 0)): dfs(i + x, j + y) count = 0 for i in range(len(board)): for j in range(len(board[0])): if board[i][j] == \'X\': count += 1 dfs(i, j) return count"},{"question":"Question: Common Elements in Two Sorted Lists # Context You are given two lists of integers, both sorted in non-decreasing order. Your task is to find all the common elements present in both lists using an efficient approach. # Task Write a function `find_common_elements(list1: List[int], list2: List[int]) -> List[int]` that takes two lists of integers as input and returns a list of the common elements found in both lists. The returned list should also be sorted in non-decreasing order. # Input * Two lists of integers, `list1` and `list2`. # Output * A list of integers containing the common elements found in both `list1` and `list2`. # Constraints * Each list will contain integers in the range `1 <= list[i] <= 10^6`. * Each list will have at most `10^5` elements. * If there are no common elements, return an empty list. # Performance Requirements * The solution should be optimized to handle large lists efficiently. * Aim for a linear time complexity. # Examples ```python assert find_common_elements([1, 2, 4, 5, 6], [2, 3, 5, 7]) == [2, 5] assert find_common_elements([1, 3, 4, 6, 8], [2, 4, 6, 8]) == [4, 6, 8] assert find_common_elements([1, 2, 3], [4, 5, 6]) == [] assert find_common_elements([], [1, 2, 3]) == [] assert find_common_elements([1, 2, 3], []) == [] ``` # Additional Information * Consider using two pointers or binary search to achieve an optimal solution. * Validate input lists and handle edge cases, such as one or both lists being empty.","solution":"def find_common_elements(list1, list2): Finds all the common elements present in both sorted lists and returns a sorted list of these common elements. common_elements = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] == list2[j]: common_elements.append(list1[i]) i += 1 j += 1 elif list1[i] < list2[j]: i += 1 else: j += 1 return common_elements"},{"question":"# Question You\'re developing a game where players can craft items using various components. Your task is to implement a system that manages the inventory and crafting process. Specifically, you need to write a function `craft_item(inventory: dict, recipe: dict) -> bool` that attempts to craft an item based on the provided recipe and updates the inventory accordingly. The function should take two arguments: 1. `inventory`: A dictionary where keys are component names and values are the number of components available. 2. `recipe`: A dictionary where keys are component names and values are the number of components needed to craft the item. The function should return `True` if the item can be crafted (i.e., all required components are available in the necessary quantities) and `False` otherwise. If the item can be crafted, the inventory should be updated to reflect the used components. Example Usage: ```python >>> inventory = {\\"wood\\": 10, \\"metal\\": 5, \\"plastic\\": 2} >>> recipe = {\\"wood\\": 3, \\"metal\\": 2, \\"plastic\\": 1} >>> craft_item(inventory, recipe) True >>> inventory {\'wood\': 7, \'metal\': 3, \'plastic\': 1} >>> inventory = {\\"wood\\": 4, \\"metal\\": 1, \\"plastic\\": 2} >>> recipe = {\\"wood\\": 5, \\"metal\\": 2, \\"plastic\\": 1} >>> craft_item(inventory, recipe) False >>> inventory {\'wood\': 4, \'metal\': 1, \'plastic\': 2} ``` Constraints: - The `inventory` and `recipe` dictionaries will always contain positive integers for component quantities. - The component names in `recipe` will always be a subset of or equal to the keys in `inventory`. - The function should not cause any side effects other than updating the inventory when crafting is successful. # Instructions: 1. Check if all required components in the recipe are available in sufficient quantity in the inventory. 2. If any component is lacking, return `False`. 3. If all components are available, deduct the quantities from the inventory and return `True`. 4. Use the provided example usage for guidance on expected behavior.","solution":"def craft_item(inventory: dict, recipe: dict) -> bool: Attempts to craft an item based on the provided recipe and updates the inventory accordingly. Parameters: inventory (dict): A dictionary where keys are component names and values are the number of components available. recipe (dict): A dictionary where keys are component names and values are the number of components needed to craft the item. Returns: bool: True if the item can be crafted, False otherwise. # Check if all required components are available in the necessary quantities for component, quantity_needed in recipe.items(): if inventory.get(component, 0) < quantity_needed: return False # If all components are available, deduct the quantities from the inventory for component, quantity_needed in recipe.items(): inventory[component] -= quantity_needed return True"},{"question":"A company needs to organize their employees into project teams. Each project team should have exactly `k` employees. The company has `n` employees and a list of their pairs of preferences for working together. Your task is to determine if it is possible to form project teams following these constraints: - Each project team has exactly `k` members. - All members of a project team must be listed in pairs of preferences. - Each employee can only be in one project team. **Example**: For `n = 4`, `k = 2`, and pairs = `[(1, 2), (2, 3), (3, 4), (1, 4)]`: - Possible teams: [(1, 2), (3, 4)], [(1, 4), (2, 3)] **Write a function `can_form_teams(n: int, k: int, pairs: List[Tuple[int, int]]) -> bool` that returns whether it is possible to form the required project teams**. **Input**: - An integer `n` (1 <= n <= 50), representing the number of employees. - An integer `k` (1 <= k <= n), representing the size of each project team. - A list of tuples `pairs`, where each tuple represents a pair of employees who want to work together. **Output**: - A boolean value indicating whether it is possible to form project teams following the given constraints. **Constraints**: - The number of employees n is a positive integer up to 50. - The size of each project team k is a positive integer up to n. - The list pairs contains tuples of unique pairs of employees. **Example**: ```python >>> can_form_teams(4, 2, [(1, 2), (2, 3), (3, 4), (1, 4)]) True >>> can_form_teams(5, 2, [(1, 2), (2, 3), (3, 4), (4, 5)]) False ``` The implementation should be efficient, considering all constraints and edge cases, such as when it\'s impossible to form teams or when employees have missing pairs.","solution":"def can_form_teams(n, k, pairs): from collections import defaultdict import itertools if n % k != 0: return False # Create a graph from the pairs adjacency_list = defaultdict(set) for a, b in pairs: adjacency_list[a].add(b) adjacency_list[b].add(a) # Function to find all k-sized cliques in the graph def k_cliques(adjacency_list, k): potential_cliques = list(itertools.combinations(adjacency_list.keys(), k)) valid_cliques = [] for clique in potential_cliques: if all(adjacency_list[u].intersection(clique) >= set(clique) - {u} for u in clique): valid_cliques.append(set(clique)) return valid_cliques # Find all k-sized cliques cliques = k_cliques(adjacency_list, k) if len(cliques) < n // k: return False # Check for overlap in cliques visited = set() for clique in cliques: if visited.intersection(clique): continue visited.update(clique) return len(visited) == n"},{"question":"You are developing a feature for a text processing application that involves analyzing words within a sentence. Specifically, you need to implement a function that identifies the longest word in a given sentence. If there are multiple words with the same maximum length, your function should return the first one that appears. # Task: Your task is to implement a function `find_longest_word` that takes a string representing a sentence and returns the longest word in that sentence. # Function Signature: ```python def find_longest_word(sentence: str) -> str: pass ``` # Expected Input and Output: * **Input:** A string containing a sentence. The sentence only consists of alphabetic characters and spaces. * **Output:** A string representing the longest word in the sentence. # Constraints: * The input sentence will contain at least one word and will not exceed 1000 characters in length. * Words in the sentence are separated by single spaces, with no leading or trailing spaces. # Examples: ```python >>> find_longest_word(\\"The quick brown fox jumps over the lazy dog\\") \\"jumps\\" >>> find_longest_word(\\"May the force be with you\\") \\"force\\" >>> find_longest_word(\\"OpenAI creates AI that benefits humanity\\") \\"benefits\\" >>> find_longest_word(\\"A journey of a thousand miles begins with a single step\\") \\"thousand\\" ``` # Context: In your role as a developer at a company specializing in linguistic data processing, you are tasked with enhancing the readability analysis tool. It needs to highlight significant words, and identifying the longest word in sentences is a key feature of the tool. Your implementation should handle various sentence lengths efficiently.","solution":"def find_longest_word(sentence: str) -> str: Finds the longest word in a given sentence. If multiple words have the same length, return the first one found. Parameters: - sentence (str): A string representing a sentence. Returns: - str: The longest word in the sentence. words = sentence.split() longest_word = \\"\\" for word in words: if len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"# Problem Statement You are given an array of positive integers representing the prices of items in a store and a positive integer `budget` representing the amount of money you have. Write a function to determine the maximum number of items you can purchase without exceeding your budget. # Function Signature ```python def max_items(prices: List[int], budget: int) -> int: ``` # Input - `prices` (List[int]): A list of positive integers representing the prices of items. The length of the list is between `1` and `10^4`. - `budget` (int): A positive integer representing your budget. # Output - (int): The maximum number of items you can buy without exceeding your budget. # Constraints - (1 leq text{len(prices)} leq 10^4) - (1 leq text{prices[i]} leq 10^4) - (1 leq text{budget} leq 10^9) # Requirements - Your solution should have a time complexity of (O(n log n)). # Example ```python assert max_items([1, 12, 5, 111, 200], 10) == 2 # Buy items with prices 1 and 5 assert max_items([20, 10, 5, 30, 100], 35) == 3 # Buy items with prices 5, 10, and 20 assert max_items([100, 200, 300, 400], 50) == 0 # No items can be bought within the budget assert max_items([10, 9, 8, 7], 25) == 3 # Buy items with prices 7, 8, and 9 ``` # Note Your solution should ensure to purchase the maximum number of items within the given budget, and you can assume inputs are always valid and within specified constraints.","solution":"from typing import List def max_items(prices: List[int], budget: int) -> int: Determine the maximum number of items that can be purchased without exceeding the budget. :param prices: List of positive integers representing the prices of items. :param budget: A positive integer representing the budget. :return: Maximum number of items that can be purchased. prices.sort() count = 0 total_spent = 0 for price in prices: if total_spent + price <= budget: total_spent += price count += 1 else: break return count"},{"question":"# Coding Question: Implement and Optimize Sliding Window Maximum You are given an array of integers and an integer `k`, representing the size of a sliding window. The task is to find the maximum value in each sliding window of size `k` as the window moves from the beginning to the end of the array. Your tasks are: 1. Implement the sliding window maximum using a deque (double-ended queue) to achieve an optimal solution with linear complexity. 2. Your solution should handle large inputs efficiently and consider edge cases. # Function Signature ```python def max_sliding_window(nums: list, k: int) -> list: pass ``` # Inputs and Outputs - **Input**: An array of integers `nums`, where each integer can be positive, negative, or zero. An integer `k` indicating the size of the sliding window. - **Output**: A list of integers representing the maximum value in each sliding window of size `k`. # Constraints: - Your implementation should handle arrays of valid integer sizes up to 10^5 elements efficiently. - The sliding window size `k` will be a positive integer and less than or equal to the length of the array. - You must account for edge cases such as an empty array, single-element arrays, and `k` equal to 1 or the length of the array. # Example ```python >>> max_sliding_window([10, -2, 4, 8, 6], 3) [10, 8, 8] >>> max_sliding_window([], 3) [] >>> max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3) [3, 3, 5, 5, 6, 7] >>> max_sliding_window([1], 1) [1] >>> max_sliding_window([1, 2, 3, 4, 5], 5) [5] ``` Successfully implementing and optimizing the sliding window maximum algorithm will demonstrate your ability to handle complex data structures and large inputs efficiently while maintaining the correctness of the algorithm.","solution":"from collections import deque def max_sliding_window(nums, k): Find the maximum value in each sliding window of size `k` in the array `nums`. Args: nums (list): List of integers. k (int): Size of the sliding window. Returns: list: List of integers representing the maximum value in each sliding window. if not nums or k == 0: return [] deque_index = deque() max_values = [] for i, num in enumerate(nums): # Remove indices that are out of the current window if deque_index and deque_index[0] == i - k: deque_index.popleft() # Remove elements that are less than the current element from the deque while deque_index and nums[deque_index[-1]] < num: deque_index.pop() # Append current element\'s index to the deque deque_index.append(i) # Add the maximum for the current window to the result list if i >= k - 1: max_values.append(nums[deque_index[0]]) return max_values"},{"question":"# Problem Description You are given an integer `n` and a list of `n` unique integers. You need to count the number of pairs `(a, b)` such that `a + b` is even. Write a function that returns the count of such pairs. # Function Signature ```python def count_even_sum_pairs(n: int, nums: list) -> int: ``` # Input - `n` (int): The number of unique integers, where `2 <= n <= 10^5`. - `nums` (list of int): A list of `n` unique integers, where each integer is in the range `[-10^9, 10^9]`. # Output - (int): The number of pairs `(a, b)` such that `a + b` is even. # Constraints - The number of integers, `n`, will be in the range [2, 10^5]. - The list `nums` will contain unique integers. # Performance Requirements - The solution must handle up to 100,000 integers efficiently. - Consider leveraging mathematical properties of even and odd numbers to simplify the problem. # Example Cases Example 1: ```python n = 4 nums = [1, 2, 3, 4] output = 2 ``` Example 2: ```python n = 5 nums = [0, 1, 2, 3, 4] output = 4 ``` Example 3: ```python n = 3 nums = [-1, -2, -3] output = 1 ``` # Additional Information 1. Your code should handle edge cases such as all integers being even or odd. 2. Note that any two even integers sum to an even number, and any two odd integers sum to an even number. Utilize this property to optimize your solution.","solution":"def count_even_sum_pairs(n: int, nums: list) -> int: Returns the count of pairs (a, b) such that a + b is even. even_count = sum(1 for num in nums if num % 2 == 0) odd_count = n - even_count # Any two even numbers sum to an even number even_pairs = even_count * (even_count - 1) // 2 # Any two odd numbers sum to an even number odd_pairs = odd_count * (odd_count - 1) // 2 # Total number of pairs with even sum return even_pairs + odd_pairs"},{"question":"# Binary Search Tree Insertion Scenario: You are working on developing a component of a database system that stores records in a Binary Search Tree (BST) to allow efficient data retrieval. Your task is to implement a function to insert a new record into the BST, ensuring the tree properties are maintained. Question: Implement a function `insert_into_bst(root: BSTNode | None, value: int) -> BSTNode` that inserts a new integer value into a BST. The BST node is represented by the `BSTNode` class which has the properties `val` (an integer value), and `left` and `right` (references to child nodes). Provide your own implementation for the `BSTNode` class if needed. # Function Specification: Input: 1. `root` (`BSTNode | None`): The root node of the BST. 2. `value` (`int`): The integer value to be inserted into the BST. Output: Should return the root node (`BSTNode`) of the BST after the insertion, which might be a new root if the tree was initially empty. # Constraints: - All current values in the BST are distinct. - The BST can contain up to (10^5) nodes. - Input values will be within the range ([-10^6, 10^6]). # Example: ```python class BSTNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example BST construction before insertion # 4 # / # 2 6 # / / # 1 3 5 7 root = BSTNode(4, BSTNode(2, BSTNode(1), BSTNode(3)), BSTNode(6, BSTNode(5), BSTNode(7))) # Insert new value new_value = 8 root = insert_into_bst(root, new_value) # Example output for the updated tree after inserting value 8 # 4 # / # 2 6 # / / # 1 3 5 7 # # 8 print(f\\"Inserted {new_value} into BST\\") # Output verification: function should return the root of the updated tree ``` **Note:** Consider edge cases such as inserting a value into an empty tree, adding a new leaf node, and maintaining BST properties.","solution":"class BSTNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_into_bst(root, value): Inserts a new value into the BST and returns the root of the BST. :param root: BSTNode | None - The root of the BST. :param value: int - The value to be inserted. :return: BSTNode - The root of the BST after insertion. if root is None: return BSTNode(value) if value < root.val: root.left = insert_into_bst(root.left, value) else: root.right = insert_into_bst(root.right, value) return root"},{"question":"# Problem: Validate and Normalize Phone Numbers You need to create a function `normalize_phone_number` that accepts phone numbers in various formats and normalizes them to a consistent format. The function should handle different delimiters and optional country codes. # Function Signature ```python def normalize_phone_number(phone: str) -> str: Normalizes a given phone number to the format \'+CC-XXX-XXX-XXXX\'. Args: phone (str): The phone number to normalize. Returns: str: The normalized phone number in the format \'+CC-XXX-XXX-XXXX\'. Raises: ValueError: If phone is not a string or if it does not represent a valid phone number. Example: >>> normalize_phone_number(\\"+1 (800) 555-1234\\") \'+1-800-555-1234\' >>> normalize_phone_number(\\"(800) 555-1234\\") \'+1-800-555-1234\' >>> normalize_phone_number(\\"800.555.1234\\") \'+1-800-555-1234\' ``` # Constraints * You may assume the input string contains only numbers, spaces, parentheses, dots, or dashes. * The function should add a default country code \'+1\' if none is provided. * The input string will not be empty. # Implementation Requirements Implement the `normalize_phone_number` function: * Validate the input to ensure it\'s a string and follows a recognizable phone number pattern. * Strip out any non-numeric characters except for a leading \'+\' if present. * Add the default country code \'+1\' if the input does not start with a \'+\' and country code. * Format the number into the consistent format \'+CC-XXX-XXX-XXXX\'. # Edge Cases to Consider * Input phone numbers with various delimiters (spaces, parentheses, dots, dashes). * Input phone numbers with and without a country code. * Input verification for non-string types. # Example Tests ```python print(normalize_phone_number(\\"+1 (800) 555-1234\\")) # Output: \'+1-800-555-1234\' print(normalize_phone_number(\\"(800) 555-1234\\")) # Output: \'+1-800-555-1234\' print(normalize_phone_number(\\"800.555.1234\\")) # Output: \'+1-800-555-1234\' ``` **Write your implementation of the `normalize_phone_number` function below:** ```python def normalize_phone_number(phone: str) -> str: Normalizes a given phone number to the format \'+CC-XXX-XXX-XXXX\'. Args: phone (str): The phone number to normalize. Returns: str: The normalized phone number in the format \'+CC-XXX-XXX-XXXX\'. Raises: ValueError: If phone is not a string or if it does not represent a valid phone number. import re if not isinstance(phone, str): raise ValueError(\\"The input must be a string.\\") # Remove all non-numeric characters except \'+\' normalized_phone = re.sub(r\'D\', \'\', phone) # Check if the country code is present if not phone.startswith(\'+\'): # Add default country code \'+1\' normalized_phone = \'1\' + normalized_phone # Format the phone number formatted_phone = f\\"+{normalized_phone[0]}-{normalized_phone[1:4]}-{normalized_phone[4:7]}-{normalized_phone[7:11]}\\" return formatted_phone ```","solution":"def normalize_phone_number(phone: str) -> str: Normalizes a given phone number to the format \'+CC-XXX-XXX-XXXX\'. Args: phone (str): The phone number to normalize. Returns: str: The normalized phone number in the format \'+CC-XXX-XXX-XXXX\'. Raises: ValueError: If phone is not a string or if it does not represent a valid phone number. import re if not isinstance(phone, str): raise ValueError(\\"The input must be a string.\\") # Remove all non-numeric characters except leading \'+\' digits = re.sub(r\'[^d]\', \'\', phone) # If there\'s no leading country code, assume \'+1\' if phone.startswith(\'+\'): country_code = \'+\' + digits[:1] digits = digits[1:] else: country_code = \'+1\' if len(digits) != 10: raise ValueError(\\"The phone number must have 10 digits.\\") # Format the phone number formatted_phone = f\\"{country_code}-{digits[0:3]}-{digits[3:6]}-{digits[6:10]}\\" return formatted_phone"},{"question":"# Scenario You are a developer in a firm specializing in data analysis and transformation tasks. Your current assignment involves processing strings according to specific rules. Your task is to implement a function that, given a string, transforms it by replacing each character with the next character in the alphabet. If the character is \'z\' or \'Z\', it should wrap around to \'a\' or \'A\', respectively. # Problem Statement Given a string `s`, write a function `shift_string(s: str) -> str` that returns a new string where each character in the input string is replaced by the next character in the alphabet. The transformation should preserve the case of the original characters. # Input * `s` (String): The input string containing only alphabetic characters (1 ≤ len(s) ≤ 10^5). # Output * Return the transformed string as a new string. # Example ```python >>> shift_string(\\"abc\\") \\"bcd\\" >>> shift_string(\\"XYZ\\") \\"YZA\\" >>> shift_string(\\"HelloWorld\\") \\"IfmmpXpsme\\" ``` # Constraints * The function should handle both uppercase and lowercase letters. * Optimize the solution to handle the upper limit of the string length efficiently. # Note Consider edge cases, such as strings containing only \'z\' or \'Z\', and ensure that they wrap around correctly to \'a\' or \'A\'.","solution":"def shift_string(s: str) -> str: Returns a new string where each character in the input string is replaced by the next character in the alphabet. The transformation preserves the case of the original characters. result = [] for char in s: if \'a\' <= char <= \'z\': if char == \'z\': result.append(\'a\') else: result.append(chr(ord(char) + 1)) elif \'A\' <= char <= \'Z\': if char == \'Z\': result.append(\'A\') else: result.append(chr(ord(char) + 1)) return \'\'.join(result)"},{"question":"# Coding Assessment Question **Scenario:** You are working at a logistics company that needs to develop an efficient routing system for their delivery service. The company has a list of delivery locations, and they need to determine the shortest possible route that visits each location exactly once and returns to the starting point. This is a classic problem known as the Travelling Salesman Problem (TSP). **Task:** Implement a solution that uses a backtracking approach to find the shortest possible route. Your solution should also handle returning to the starting location. # Requirements: 1. **Function:** `travelling_salesman(dist_matrix: list[list[int]]) -> tuple` - Takes a 2D list `dist_matrix` representing the distance between each pair of locations. - Returns a tuple containing two elements: - The minimum distance of the route. - A list representing the order in which the locations are visited, starting and ending at the same location. # Input: - **`dist_matrix`**: A 2D list where `dist_matrix[i][j]` represents the distance between location `i` and location `j`. The matrix is symmetric, and all diagonal elements are zero (`dist_matrix[i][i] = 0`). # Output: - **From `travelling_salesman`**: A tuple containing: - The minimum distance. - A list of integers representing the sequence of visited locations. # Constraints: - The number of locations will be between 2 and 12. # Example: ```python dist_matrix = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] result = travelling_salesman(dist_matrix) print(result) ``` **Output:** ``` (80, [0, 1, 3, 2, 0]) ``` **Edge Cases to Consider:** 1. The minimum input case with only 2 locations. 2. Multiple equally optimal routes. 3. Distances with large values or zeros, except for self-distances which should always be zero.","solution":"from itertools import permutations def travelling_salesman(dist_matrix): n = len(dist_matrix) min_path_cost = float(\'inf\') best_path = [] for perm in permutations(range(1, n)): current_cost = dist_matrix[0][perm[0]] for i in range(n - 2): current_cost += dist_matrix[perm[i]][perm[i + 1]] current_cost += dist_matrix[perm[-1]][0] if current_cost < min_path_cost: min_path_cost = current_cost best_path = [0] + list(perm) + [0] return min_path_cost, best_path"},{"question":"# Question: Calculate the Probability of Winning a Dice Game You are playing a simplified dice game where you roll two standard six-sided dice. Your goal is to choose a target number between 2 and 12 (inclusive). You win if the sum of the numbers on the two dice equals your target number after a single roll, and you lose otherwise. Write a function to calculate the probability of winning the game for a given target number. Function Signature ```python def probability_of_winning(target: int) -> str: Calculates the probability of winning the dice game with a given target number. Parameters: target (int): The target sum to win the game. Returns: str: The probability of winning formatted as a string with five decimal places of precision. ``` Input - `target`: An integer (2 ≤ `target` ≤ 12) representing the target sum for the dice roll. Output - Return a string representing the probability of winning the game, formatted to five decimal places. Constraints - The value of `target` will always be within the provided input range. - You must consider all possible outcomes of rolling two six-sided dice. Example ```python print(probability_of_winning(7)) # Output: \'0.16667\' print(probability_of_winning(2)) # Output: \'0.02778\' print(probability_of_winning(12)) # Output: \'0.02778\' ``` Notes - Consider how many combinations of two six-sided dice will result in each possible target number. - Ensure precise floating-point arithmetic to achieve the required precision. - You may use basic probability principles to solve the problem.","solution":"def probability_of_winning(target: int) -> str: Calculates the probability of winning the dice game with a given target number. Parameters: target (int): The target sum to win the game. Returns: str: The probability of winning formatted as a string with five decimal places of precision. # Total possible outcomes when rolling two six-sided dice total_outcomes = 6 * 6 # Counting the number of favorable outcomes for a given target favorable_outcomes = 0 # Roll two dice and count occurrences of the target sum for i in range(1, 7): # First die can be any number from 1 to 6 for j in range(1, 7): # Second die can be any number from 1 to 6 if i + j == target: favorable_outcomes += 1 # Calculate probability as the ratio of favorable outcomes to total outcomes probability = favorable_outcomes / total_outcomes # Return the probability formatted to five decimal places return f\\"{probability:.5f}\\""},{"question":"# Implement the Prime Factorization Algorithm In this coding task, you are required to implement an enhanced version of the prime factorization algorithm. Function Signature ```python def prime_factorization(n: int) -> dict: ``` Input and Output Formats * **Input**: A single parameter `n` which is a positive integer greater than 1. * **Output**: A dictionary where the keys are prime factors and the values are their respective powers. Constraints - (2 leq n leq 10^{12}) Performance Requirements - The function should complete within a reasonable time frame for the provided constraint (up to (10^{12})). Task Requirements 1. Implement the prime factorization algorithm in the defined function. 2. **Enhance** the implementation by ensuring the algorithm works efficiently for very large values of `n`. 3. **Optimize** the function to minimize redundant computations especially for composite numbers. Hints - Consider the use of efficient algorithms such as the Pollard\'s rho algorithm for factorization. - Leverage mathematical insights like the Sieve of Eratosthenes for generating prime numbers up to (sqrt{n}). Example ```python assert prime_factorization(75) == {3: 1, 5: 2} assert prime_factorization(100) == {2: 2, 5: 2} assert prime_factorization(13195) == {5: 1, 7: 1, 13: 1, 29: 1} assert prime_factorization(2) == {2: 1} ```","solution":"def prime_factorization(n: int) -> dict: Returns the prime factorization of the given integer n. Parameters: n (int): A positive integer greater than 1. Returns: factors (dict): A dictionary where keys are prime factors and values are their respective powers. def trial_division(n): factors = {} # Check for the number of 2s that divide n count = 0 while n % 2 == 0: n = n // 2 count += 1 if count > 0: factors[2] = count # n must be odd at this point so start a loop from 3 with a step of 2 for i in range(3, int(n**0.5) + 1, 2): count = 0 while n % i == 0: n = n // i count += 1 if count > 0: factors[i] = count # This condition checks if n is a prime number greater than 2 if n > 2: factors[n] = 1 return factors return trial_division(n)"},{"question":"# Finding Duplicate Numbers # Objective Your task is to write a function that identifies all duplicate numbers in a given list and returns them sorted in ascending order. # Problem Description Implement the `find_duplicates` function that takes a list of integers as input and returns a list containing the duplicate elements sorted in ascending order. # Function Signature ```python def find_duplicates(nums: List[int]) -> List[int]: pass ``` # Input/Output Specifications * **Input**: A list of integers. * Example: `[4, 2, 4, 5, 2, 3, 1, 0, -1, -1, -1]` * **Output**: A list of integers containing the duplicates, sorted in ascending order. * Example: `[-1, 2, 4]` # Constraints * The list can have up to 10^5 elements. * The integers in the list range from -10^6 to 10^6. * The list can contain negative values and zero. * Each duplicate element should appear only once in the output list, regardless of how many times it appears in the input. # Examples ```python >>> find_duplicates([4, 2, 4, 5, 2, 3, 1, 0, -1, -1, -1]) [-1, 2, 4] >>> find_duplicates([0, 1, 2, 3, 4, 5]) [] >>> find_duplicates([5, 5, 5, -2, -2, -45, -45]) [-45, -2, 5] >>> find_duplicates([9, 8, 7, 6, 8, 5, 5, 7, 9]) [5, 7, 8, 9] >>> find_duplicates([]) [] ``` # Implementation Details * Ensure that your solution handles empty input gracefully. * The returned list should be free of duplicates within itself and sorted in ascending order.","solution":"from typing import List def find_duplicates(nums: List[int]) -> List[int]: Identifies all duplicate numbers in a given list and returns them sorted in ascending order. from collections import Counter # Count frequency of each number count = Counter(nums) # Extract numbers that appear more than once duplicates = [num for num, freq in count.items() if freq > 1] # Sort and return the duplicates duplicates.sort() return duplicates"},{"question":"# Question: Managing Employee Hierarchy with Depth Information Your task is to create a function that processes a list of employees in a company and determines the hierarchical depth of each employee in the organizational chart. You are given a list of tuples where each tuple contains an employee and their direct manager. The CEO of the company does not have a manager and is represented with `None`. Your function should compute the depth of each employee from the CEO (depth 0). Write a function `employee_depth(employee_list: list[tuple[str, str]]) -> dict[str, int]` that returns a dictionary where the keys are employee names and the values are their respective depths in the hierarchy. # Input * `employee_list` (list of tuple of str): A list of tuples where each tuple contains two strings: an employee\'s name and their direct manager\'s name (`employee, manager`). If the employee is the CEO, the manager will be `None`. # Output * A dictionary with employee names as keys and their respective depths as values. # Constraints * The number of employees (`n`): 1 ≤ n ≤ 10^4. * Each employee has a unique name consisting of 1 ≤ len(name) ≤ 100 alphanumeric characters. * The input guarantees a single, consistent hierarchy without cycles. # Examples ```python employee_list = [(\\"Alice\\", \\"Bob\\"), (\\"Bob\\", \\"Charlie\\"), (\\"Charlie\\", None)] print(employee_depth(employee_list)) # Expected Output: {\\"Alice\\": 2, \\"Bob\\": 1, \\"Charlie\\": 0} employee_list = [(\\"David\\", \\"Edward\\"), (\\"Edward\\", \\"Fiona\\"), (\\"Fiona\\", \\"George\\"), (\\"George\\", None)] print(employee_depth(employee_list)) # Expected Output: {\\"David\\": 3, \\"Edward\\": 2, \\"Fiona\\": 1, \\"George\\": 0} employee_list = [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"C\\", None), (\\"D\\", \\"C\\")] print(employee_depth(employee_list)) # Expected Output: {\\"A\\": 2, \\"B\\": 1, \\"C\\": 0, \\"D\\": 1} ``` Ensure your function is efficient and can handle the upper limits of the input constraints. Consider using efficient data structures to store and traverse the hierarchical relationships. Your implementation should also handle edge cases, such as employees with no subordinates.","solution":"def employee_depth(employee_list): Computes the hierarchical depth of each employee in the company. Parameters: employee_list (list of tuple of str): A list where each tuple contains an employee\'s name and their manager\'s name. The manager\'s name is None if it is the CEO. Returns: dict: A dictionary with employee names as keys and their respective depths as values. from collections import defaultdict, deque # Build the manager-to-employees map and employee-to-manager map employee_to_manager = {} manager_to_employees = defaultdict(list) for employee, manager in employee_list: employee_to_manager[employee] = manager if manager is not None: manager_to_employees[manager].append(employee) # Find the CEO ceo = next(employee for employee, manager in employee_list if manager is None) # BFS to determine depths depths = {ceo: 0} queue = deque([ceo]) while queue: current = queue.popleft() current_depth = depths[current] for subordinate in manager_to_employees[current]: depths[subordinate] = current_depth + 1 queue.append(subordinate) return depths"},{"question":"# Problem Description You are given an array that contains a mix of integers and the string \\"zero\\". Your task is to reorganize the array so that all \\"zero\\" strings are moved to the end of the array, while maintaining the relative order of the non-zero integer elements. # Task Write a function `move_zeros_to_end` that takes a list as input and returns the list with all \\"zero\\" strings moved to the end. # Input * `array` (List): A list containing integers and the string \\"zero\\". # Output * (List): A list with all \\"zero\\" strings moved to the end, while maintaining the relative order of the non-zero integers. # Constraints * The list can be empty. * The list contains at least one element. * The elements of the list are either integers or the string \\"zero\\". # Performance Requirements * The solution should have a linear time complexity, i.e., O(n), where n is the length of the list. # Example ```python def move_zeros_to_end(array: list) -> list: pass # Example usage: print(move_zeros_to_end([1, \\"zero\\", 3, 4, \\"zero\\", 6])) # Output: [1, 3, 4, 6, \'zero\', \'zero\'] print(move_zeros_to_end([\\"zero\\", \\"zero\\", 1, 2, 3])) # Output: [1, 2, 3, \'zero\', \'zero\'] print(move_zeros_to_end([7, 8, \\"zero\\", 9, 10, \\"zero\\"])) # Output: [7, 8, 9, 10, \'zero\', \'zero\'] print(move_zeros_to_end([])) # Output: [] print(move_zeros_to_end([0, \\"zero\\", 2, 0, \\"zero\\", \\"zero\\", 5, 6])) # Output: [0, 2, 0, 5, 6, \'zero\', \'zero\', \'zero\'] ```","solution":"def move_zeros_to_end(array: list) -> list: non_zero_elements = [x for x in array if x != \\"zero\\"] zero_count = array.count(\\"zero\\") result = non_zero_elements + [\\"zero\\"] * zero_count return result # Example usage: # print(move_zeros_to_end([1, \\"zero\\", 3, 4, \\"zero\\", 6])) # Output: [1, 3, 4, 6, \'zero\', \'zero\'] # print(move_zeros_to_end([\\"zero\\", \\"zero\\", 1, 2, 3])) # Output: [1, 2, 3, \'zero\', \'zero\'] # print(move_zeros_to_end([7, 8, \\"zero\\", 9, 10, \\"zero\\"])) # Output: [7, 8, 9, 10, \'zero\', \'zero\'] # print(move_zeros_to_end([])) # Output: [] # print(move_zeros_to_end([0, \\"zero\\", 2, 0, \\"zero\\", \\"zero\\", 5, 6])) # Output: [0, 2, 0, 5, 6, \'zero\', \'zero\', \'zero\']"},{"question":"# Problem Statement Write a function `find_pythagorean_triplet(sum: int) -> tuple` that returns a Pythagorean triplet `(a, b, c)` such that (a^2 + b^2 = c^2) and (a + b + c =) `sum`. If no such triplet exists, return an empty tuple `()`. # Input * An integer `sum` where (1 leq sum leq 3000). # Output * A tuple `(a, b, c)` representing the Pythagorean triplet. If no triplet exists, return an empty tuple `()`. # Constraints 1. `sum` is a positive integer. # Examples ```python assert find_pythagorean_triplet(12) == (3, 4, 5) # 3^2 + 4^2 = 9 + 16 = 25 = 5^2 assert find_pythagorean_triplet(30) == (5, 12, 13) # 5^2 + 12^2 = 25 + 144 = 169 = 13^2 assert find_pythagorean_triplet(1000) == (200, 375, 425) # Predefined example, 200^2 + 375^2 = 40000 + 140625 = 180625 = 425^2 assert find_pythagorean_triplet(17) == () # No triplet exists for this sum assert find_pythagorean_triplet(1) == () # No triplet exists for this sum ``` # Explanation A Pythagorean triplet is a set of three natural numbers (a < b < c) where (a^2 + b^2 = c^2). The task is to find one such triplet for which the sum (a + b + c) equals the given input `sum`. # Additional Notes - Implement an efficient method to find the triplets to avoid unnecessary calculations. - Consider an optimized approach, such as limiting the search space using mathematical insights into Pythagorean triplets. - Ensure the function handles edge cases and large values of `sum` gracefully.","solution":"def find_pythagorean_triplet(target_sum): Finds a Pythagorean triplet (a, b, c) such that a^2 + b^2 = c^2 and a + b + c = target_sum. for a in range(1, target_sum): for b in range(a + 1, target_sum - a): c = target_sum - a - b if c > b and a * a + b * b == c * c: return (a, b, c) return ()"},{"question":"# Sum of Unique Elements in a List You have been provided with a list of integers. Your task is to determine the sum of all the unique elements within this list. Ensure your solution efficiently handles the uniqueness of elements and computes the sum accordingly. --- # Function Specification **Function Name**: `sum_of_unique_elements` **Input**: - One list of integers, `numbers` of length `n`. **Output**: - Integer: Returns the sum of all unique elements in the list. # Example ```python assert sum_of_unique_elements([1, 2, 2, 3, 4, 4, 5]) == 9 # Unique elements are [1, 3, 5] assert sum_of_unique_elements([7, 8, 8, 8, 9]) == 16 # Unique elements are [7, 9] assert sum_of_unique_elements([10, 10, 10, 10]) == 0 # No unique elements assert sum_of_unique_elements([1, 1, 2, 2, 3, 3, 4]) == 4 # Unique element is [4] assert sum_of_unique_elements([]) == 0 # No elements at all ``` # Constraints - The list can have up to (10^5) elements. - Each element in the list is an integer between (-10^9) and (10^9). # Additional Information - Numbers outside the defined range will not be passed to the function. - Aim to achieve a time complexity of (O(n)) and space complexity of (O(n)). # Performance Requirements - The solution must be efficient to handle cases where the list is large. - Ensure that there are no redundant calculations and the operations over the list are minimized. --- # Implementation Task Write a function `sum_of_unique_elements(numbers: list[int]) -> int` that adheres to the specifications and passes all the given test cases. Avoid using external libraries except for necessary built-in Python functionalities.","solution":"def sum_of_unique_elements(numbers): Returns the sum of all unique elements in the list. from collections import Counter # Use a Counter to count the occurrences of each element. count = Counter(numbers) # Sum the elements that appear exactly once. unique_sum = sum(num for num, freq in count.items() if freq == 1) return unique_sum"},{"question":"# Array Rotation and Counting Inversions Task You are developing a feature for a data analysis tool that involves rotating arrays and counting inversions in them. Rotating an array shifts all elements to the right by a given number of positions, and counting inversions means determining how many pairs of elements are out of order. Task Implement two functions: 1. `rotate_array(arr: list[int], k: int) -> list[int]` 2. `count_inversions(arr: list[int]) -> int` # Input - `rotate_array` - `arr`: A list of integers representing the array. - `k`: An integer representing the number of positions to rotate the array to the right. - `count_inversions` - `arr`: A list of integers representing the array. # Output - `rotate_array` returns the array after rotating it `k` positions to the right (list of integers). - `count_inversions` returns the number of inversions in the array (integer). # Constraints - The length of `arr` is between 1 and 10^5. - Elements of `arr` and `k` are integers (negative values are allowed for array elements; `k` is non-negative). # Examples ```python assert rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert rotate_array([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5] assert count_inversions([2, 4, 1, 3, 5]) == 3 assert count_inversions([5, 4, 3, 2, 1]) == 10 ``` # Notes - For `rotate_array`, ensure that rotating the array multiple times (more than the length of the array) is handled efficiently. - For `count_inversions`, an inversion is defined as a pair of indices `(i, j)` such that `i < j` and `arr[i] > arr[j]`. # Hints - The rotation functionality can be achieved by slicing the array effectively. - Counting inversions may be optimized using a modified merge sort algorithm for better performance on large inputs.","solution":"def rotate_array(arr, k): Rotate the array arr to the right by k positions. n = len(arr) k = k % n # handle k larger than the length of the array return arr[-k:] + arr[:-k] def count_inversions(arr): Count the number of inversions in the array arr. def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 # Conditions are checked to ensure that i doesn\'t exceed mid and j doesn\'t exceed right while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: # There are mid - i inversions because all the remaining elements in the # left subarray (arr[i]...arr[mid]) are greater than arr[j] temp_arr[k] = arr[j] inv_count += (mid - i + 1) j += 1 k += 1 # Copy the remaining elements of left subarray, if any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if any while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 # Copy the sorted subarray into Original array for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right) // 2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count return merge_sort_and_count(arr, [0] * len(arr), 0, len(arr) - 1)"},{"question":"# SQL Query Optimization and Execution Plan Analysis You are given a SQL database that contains three tables: `employees`, `departments`, and `salaries`. The `employees` table contains employee information, the `departments` table contains department information, and the `salaries` table contains salary information for each employee. Your task is to execute a given SQL query and analyze its execution plan to identify potential performance improvements. Requirements: 1. Optimize the provided SQL query to make it more efficient. 2. Analyze the execution plan before and after optimization, explaining the changes and their impact on performance. 3. Recommend appropriate indexes or other database modifications that could improve query performance. # Schema: 1. **`employees`**: - `emp_id` (integer, primary key) - `emp_name` (varchar) - `dept_id` (integer, foreign key to `departments(dept_id)`) 2. **`departments`**: - `dept_id` (integer, primary key) - `dept_name` (varchar) 3. **`salaries`**: - `emp_id` (integer, foreign key to `employees(emp_id)`) - `salary` (integer) - `effective_date` (date) # Initial SQL Query: ```sql SELECT e.emp_name, d.dept_name, s.salary FROM employees e JOIN departments d ON e.dept_id = d.dept_id JOIN salaries s ON e.emp_id = s.emp_id WHERE s.effective_date = (SELECT MAX(s2.effective_date) FROM salaries s2 WHERE s2.emp_id = e.emp_id); ``` # Instructions: 1. **Optimize the SQL Query**: Rewrite the SQL query to improve its performance while maintaining the same functionality. 2. **Execution Plan Analysis**: Obtain and analyze the execution plan for both the initial and optimized queries. 3. **Performance Recommendations**: Based on your analysis, recommend changes, such as indexing strategies or schema modifications, to further improve query performance. # Expected Output: 1. **Optimized SQL Query**: Provide your optimized version of the SQL query. 2. **Execution Plan Analysis**: A detailed comparison of the execution plans before and after the optimization. 3. **Performance Recommendations**: A clear explanation of any suggested indexes or schema changes, and their expected impact on performance. Example Execution Plan Analysis: - **Initial Query Execution Plan**: - Sequential scan on `salaries`: High cost due to checking all rows in the `salaries` table for each employee. - Nested loops for subquery evaluation: Inefficient due to repeated evaluation for each employee. - **Optimized Query Execution Plan**: - Use of indexes: Reduced cost by efficiently locating `salaries` entries. - Join strategies: Improved join performance with better join algorithms and index utilization. Example Performance Recommendations: - **Create indexes** on frequently queried fields, such as `salaries(effective_date)` and `employees(dept_id)`. - **Partition the `salaries` table** based on `effective_date` to speed up date-based queries. - **Materialized views**: For complex aggregations or subqueries, materialized views might reduce runtime. # Sample Optimized Query: ```sql SELECT e.emp_name, d.dept_name, s.salary FROM employees e JOIN departments d ON e.dept_id = d.dept_id JOIN ( SELECT s1.emp_id, s1.salary FROM salaries s1 JOIN ( SELECT emp_id, MAX(effective_date) AS max_date FROM salaries GROUP BY emp_id ) s2 ON s1.emp_id = s2.emp_id AND s1.effective_date = s2.max_date ) s ON e.emp_id = s.emp_id; ``` # Sample Execution Plan Analysis: - **Initial Plan**: Relatively high cost due to nested loop on subquery and lack of indexes. - **Optimized Plan**: Reduced cost with hash join and index usage. # Sample Performance Recommendations: - **Indexes**: Create index on `salaries(effective_date, emp_id)` and `employees(dept_id)`. - **Partition**: Consider partitioning `salaries` by year or quarter if historical data accumulates significantly. Output your optimized query, execution plan analysis, and recommendations in a clear, structured format.","solution":"# Optimized SQL Query optimized_query = \'\'\' SELECT e.emp_name, d.dept_name, s.salary FROM employees e JOIN departments d ON e.dept_id = d.dept_id JOIN ( SELECT s1.emp_id, s1.salary FROM salaries s1 JOIN ( SELECT emp_id, MAX(effective_date) AS max_date FROM salaries GROUP BY emp_id ) s2 ON s1.emp_id = s2.emp_id AND s1.effective_date = s2.max_date ) s ON e.emp_id = s.emp_id; \'\'\'"},{"question":"# Scenario You are developing a file exploration feature for a new project management software. Part of this requirement is to search for a specific file pattern within deeply nested directories. # Task Write a function `search_files` that, given a directory path and a file name pattern, recursively searches through all subdirectories and returns a list of full paths to the files whose names match the pattern using Unix shell-style wildcards. # Expected Function Signature ```python import os import fnmatch def search_files(directory: str, pattern: str) -> list: pass ``` # Input - `directory`: A string representing the absolute path of the directory to start the search. - `pattern`: A string representing the file name pattern to match (e.g., `*.txt`, `data_*.csv`). # Output - Returns a list of strings where each string is the absolute path of a file that matches the provided pattern. # Constraints - The function must handle directories with large numbers of files efficiently. - It should return paths in lexicographical order. # Performance Requirements - The function should be optimized for depth-first search to minimize memory usage. # Example ```python assert search_files(\'/path/to/directory\', \'*.txt\') == [\'/path/to/directory/file1.txt\', \'/path/to/directory/subdir/file2.txt\'] assert search_files(\'/project\', \'data_*.csv\') == [\'/project/data_2021.csv\', \'/project/reports/data_2022.csv\'] assert search_files(\'/home/user/documents\', \'report_*.pdf\') == [\'/home/user/documents/report_2020.pdf\'] ``` # Notes 1. Ensure that the directory path provided is valid and accessible. 2. Return an empty list if no files match the pattern.","solution":"import os import fnmatch def search_files(directory: str, pattern: str) -> list: Recursively searches through all subdirectories starting from the given directory and returns a list of file paths whose names match the provided pattern. Args: - directory: The directory path to start the search from. - pattern: The file name pattern to match using Unix shell-style wildcards. Returns: - A list of paths to files matching the pattern. matching_files = [] for root, dirs, files in os.walk(directory): for filename in fnmatch.filter(files, pattern): matching_files.append(os.path.join(root, filename)) matching_files.sort() # Ensure the results are in lexicographical order return matching_files"},{"question":"# Question: Enhanced Order Processing System You are tasked with enhancing an order processing system for an e-commerce platform. The existing system processes orders synchronously and is prone to delays during high traffic. Your job is to improve this system’s performance and reliability by implementing asynchronous order processing, error handling, and logging. **Task** 1. Modify the `process_order` function to handle order processing asynchronously. 2. Add a retry mechanism for transient errors such as network issues or temporary unavailability of services. 3. Implement logging to record details of each processed order as well as all error occurrences. 4. Ensure the function can handle multiple orders concurrently without significant performance degradation. # Requirements **Function Signature** ```python import aiohttp # You may use this library for asynchronous requests import logging # You may use this library for logging async def process_order(order_id: str) -> bool: pass # Your implementation here ``` **Input** - `order_id` (str): Unique identifier of the order to be processed. **Output** - Returns a boolean value indicating whether the order was processed successfully. **Constraints** - Use asynchronous programming for order processing tasks. - Implement a retry mechanism for transient errors. - Log details of each processed order and any errors encountered. - Manage concurrent order processing efficiently. **Performance** - Ensure the system can handle high traffic by processing multiple orders concurrently with minimal latency. # Example ```python import asyncio # Assuming your function implementation is complete async def main(): order_id = \\"ORDER12345\\" try: success = await process_order(order_id) if success: print(f\\"Order {order_id} processed successfully.\\") else: print(f\\"Failed to process order {order_id}.\\") except Exception as e: print(f\\"Error: {e}\\") asyncio.run(main()) ``` # Notes - Use proper logging to capture the details and results of each order processing attempt. - Ensure the retry mechanism covers multiple transient error scenarios and does not indefinitely retry on persistent failures.","solution":"import aiohttp import asyncio import logging from aiohttp import ClientSession logging.basicConfig(level=logging.INFO) async def process_order(order_id: str, max_retries: int = 3) -> bool: Asynchronously processes an order with retry mechanism and logging. Args: order_id (str): Unique identifier of the order to be processed. max_retries (int): Maximum number of retries for transient errors. Returns: bool: True if the order was processed successfully, otherwise False. for attempt in range(1, max_retries + 1): try: async with aiohttp.ClientSession() as session: async with session.post(\\"http://example.com/api/orders/process\\", json={\\"order_id\\": order_id}) as response: if response.status == 200: logging.info(f\\"Order {order_id} processed successfully.\\") return True else: logging.error(f\\"Failed to process order {order_id}, status code: {response.status}\\") except aiohttp.ClientError as e: logging.error(f\\"Attempt {attempt} - Network error occurred: {e}, order_id: {order_id}\\") if attempt == max_retries: logging.error(f\\"Max retries reached for order {order_id}. Failing the order.\\") return False await asyncio.sleep(2 ** attempt) except Exception as e: logging.error(f\\"Attempt {attempt} - An error occurred: {e}, order_id: {order_id}\\") return False return False"},{"question":"# Context You have been hired by an educational startup that teaches Data Structures through practical applications. They want to demonstrate the use of a Binary Search Tree (BST) to store and retrieve data efficiently. # Task Implement a class called `BST` which represents a binary search tree. The tree should support the following operations: - Insert a value - Search for a value - Delete a value - Traverse the tree in-order # Specifications * **Class Definition**: - `class BST:` - Methods: - `insert(self, value: int) -> None`: Inserts a value into the BST. - `search(self, value: int) -> bool`: Returns `True` if the value is found in the BST, otherwise returns `False`. - `delete(self, value: int) -> None`: Deletes a value from the BST if it exists. - `inorder_traverse(self) -> List[int]`: Returns a list of values from an in-order traversal of the BST. * **Input Format**: - For `insert`, `search`, and `delete` methods, a single integer `value`. * **Output Format**: - For `search`, return a boolean. - For `inorder_traverse`, return a list of integers. - For `insert` and `delete`, return `None`. # Example ```python # Create a BST instance bst = BST() # Insert values bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(2) bst.insert(4) # Search for values print(bst.search(3)) # True print(bst.search(8)) # False # Inorder traversal print(bst.inorder_traverse()) # [2, 3, 4, 5, 7] # Delete a value bst.delete(3) print(bst.search(3)) # False print(bst.inorder_traverse()) # [2, 4, 5, 7] ``` # Notes * Ensure your implementation handles all edge cases, including: - Inserting into an empty BST - Deleting non-existent values - Deleting leaf nodes, nodes with one child, and nodes with two children * Aim to maintain the properties of the BST after each operation. * No restrictions on helper methods within your class to facilitate operations.","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = Node(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.value: if node.left is None: node.left = Node(value) else: self._insert_recursive(node.left, value) elif value > node.value: if node.right is None: node.right = Node(value) else: self._insert_recursive(node.right, value) def search(self, value): return self._search_recursive(self.root, value) def _search_recursive(self, node, value): if node is None: return False if value == node.value: return True elif value < node.value: return self._search_recursive(node.left, value) else: return self._search_recursive(node.right, value) def delete(self, value): self.root = self._delete_recursive(self.root, value) def _delete_recursive(self, node, value): if node is None: return node if value < node.value: node.left = self._delete_recursive(node.left, value) elif value > node.value: node.right = self._delete_recursive(node.right, value) else: if node.left is None: return node.right elif node.right is None: return node.left min_larger_node = self._get_min(node.right) node.value = min_larger_node.value node.right = self._delete_recursive(node.right, min_larger_node.value) return node def _get_min(self, node): current = node while current.left is not None: current = current.left return current def inorder_traverse(self): result = [] self._inorder_recursive(self.root, result) return result def _inorder_recursive(self, node, result): if node: self._inorder_recursive(node.left, result) result.append(node.value) self._inorder_recursive(node.right, result)"},{"question":"# Sum of Consecutive Odd Integers You are developing a tool that requires summing consecutive odd integers. Implement the following functions: 1. `sum_of_consecutive_odds(start: int, count: int) -> int`: This function should return the sum of `count` consecutive odd integers starting from `start`. If `start` is an even number, the sequence should start from the next odd number. 2. `generate_odd_sequence(start: int, count: int) -> List[int]`: This function should return a list containing `count` consecutive odd integers starting from `start`. If `start` is an even number, the sequence should start from the next odd number. Input - `start` is a non-negative integer (0 ≤ start ≤ 10^6). - `count` is a positive integer (1 leq text{count} leq 10^4). Output - `sum_of_consecutive_odds(start)` should return an integer which is the sum of `count` consecutive odd integers starting from `start`. - `generate_odd_sequence(start, count)` should return a list of `count` consecutive odd integers starting from `start`. Constraints - Optimize for execution time and space, given the input limits. - Handle edge cases including small values and near the bounds. Example ```python # Example usage: print(sum_of_consecutive_odds(10, 5)) # Expected: 55 (11 + 13 + 15 + 17 + 19) print(generate_odd_sequence(10, 5)) # Expected: [11, 13, 15, 17, 19] ``` Implement these functions in Python and ensure they handle edge cases effectively.","solution":"def sum_of_consecutive_odds(start, count): Returns the sum of a specified count of consecutive odd integers starting from start. If start is even, the sequence starts from the next odd number. # Adjust start to the next odd number if it is even if start % 2 == 0: start += 1 # Sum of the arithmetic series of odd numbers return sum(start + 2*i for i in range(count)) def generate_odd_sequence(start, count): Returns a list of a specified count of consecutive odd integers starting from start. If start is even, the sequence starts from the next odd number. # Adjust start to the next odd number if it is even if start % 2 == 0: start += 1 # Generate the sequence of odd numbers return [start + 2*i for i in range(count)]"},{"question":"Consider an inventory management system where products are defined with various attributes such as `ProductID`, `ProductName`, `Category`, `Price`, and `StockQuantity`. Your task is to create a new class called `Product` with the following functionalities: 1. **Initialization**: Initializes the product with the given attributes. 2. **Check Stock**: Method to check if the stock is available. 3. **Update Stock**: Method to update the stock quantity by adding or subtracting the specified amount. 4. **Apply Discount**: Method to apply a discount percentage to the price. 5. **Display Product Info**: Method to display all the product information. # Constraints: - `ProductID` should be a unique identifier. - `Price` and `StockQuantity` should be non-negative values. # Input and Output: - Expected input: String inputs for `ProductID`, `ProductName`, and `Category`; float for `Price`; and integer for `StockQuantity`. - Expected output: A `Product` instance which can check stock, update stock, apply discounts, and display product information. # Example Scenario: You are developing an e-commerce platform that requires managing product inventories. This `Product` class will be a part of your inventory management module. # Class Specifications: Class Name: `Product` **Initialization**: ```python def __init__(self, product_id: str, product_name: str, category: str, price: float, stock_quantity: int) -> None: # Initialize the product with attributes ``` Raises a `ValueError` if `price` or `stock_quantity` are negative. **Check Stock**: ```python def check_stock(self) -> bool: # Return True if stock_quantity > 0, else False ``` **Update Stock**: ```python def update_stock(self, amount: int) -> None: # Update the stock quantity by the given amount (positive or negative) # Raise a ValueError if resulting stock quantity is negative ``` **Apply Discount**: ```python def apply_discount(self, discount_percentage: float) -> None: # Apply a discount to the price # Raise a ValueError if discount_percentage is not between 0 and 100 ``` **Display Product Info**: ```python def display_info(self) -> None: # Print all product information (ProductID, ProductName, Category, Price, StockQuantity) ``` # Example: ```python # Creating a Product instance product = Product(\\"P001\\", \\"Laptop\\", \\"Electronics\\", 1000.0, 50) # Displaying product information product.display_info() # Output should display all details of the product # Checking stock availability print(product.check_stock()) # Output: True # Updating stock quantity product.update_stock(-5) # Decrease stock by 5 print(product.stock_quantity) # Output: 45 # Applying a discount product.apply_discount(10) # Apply a 10% discount print(product.price) # Output: 900.0 # Final product info product.display_info() # Output should display the updated details of the product ``` Note: Ensure the methods perform all necessary validations and raise appropriate errors when constraints are not met.","solution":"class Product: def __init__(self, product_id: str, product_name: str, category: str, price: float, stock_quantity: int) -> None: if price < 0: raise ValueError(\\"Price cannot be negative\\") if stock_quantity < 0: raise ValueError(\\"Stock quantity cannot be negative\\") self.product_id = product_id self.product_name = product_name self.category = category self.price = price self.stock_quantity = stock_quantity def check_stock(self) -> bool: return self.stock_quantity > 0 def update_stock(self, amount: int) -> None: if self.stock_quantity + amount < 0: raise ValueError(\\"Resulting stock quantity cannot be negative\\") self.stock_quantity += amount def apply_discount(self, discount_percentage: float) -> None: if not (0 <= discount_percentage <= 100): raise ValueError(\\"Discount percentage must be between 0 and 100\\") self.price -= self.price * (discount_percentage / 100) def display_info(self) -> None: print(f\\"ProductID: {self.product_id}\\") print(f\\"ProductName: {self.product_name}\\") print(f\\"Category: {self.category}\\") print(f\\"Price: {self.price:.2f}\\") print(f\\"StockQuantity: {self.stock_quantity}\\")"},{"question":"# Sum of Diagonal Elements in a Square Matrix Context: You are working with square matrices and need an efficient way to compute the sums of both the primary and secondary diagonals. This task is commonly needed in various mathematical and computational problems, such as algorithms related to image processing or matrix operations. Requirements: 1. **Function 1**: Implement a function `sum_primary_diagonal(matrix: list[list[int]]) -> int` that calculates the sum of the primary diagonal elements. The function should: * Ensure the input is a square matrix. * Traverse the primary diagonal and sum its elements efficiently. 2. **Function 2**: Implement a function `sum_secondary_diagonal(matrix: list[list[int]]) -> int` that calculates the sum of the secondary diagonal elements. The function should: * Ensure the input is a square matrix. * Traverse the secondary diagonal and sum its elements efficiently. Constraints: * Ensure that both functions handle invalid inputs gracefully and provide meaningful error messages. * Matrices will always be non-empty, and the smallest matrix size is 1x1. * Inputs will always contain integer elements. Input: - Both functions receive a single parameter: * `matrix` - a square matrix represented as a list of lists. Output: - Both functions return an integer: * The sum of the respective diagonal elements. Example Usage: ```python >>> sum_primary_diagonal([[1, 2], [3, 4]]) 5 >>> sum_primary_diagonal([[5]]) 5 >>> sum_primary_diagonal([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 15 >>> sum_secondary_diagonal([[1, 2], [3, 4]]) 4 >>> sum_secondary_diagonal([[5]]) 5 >>> sum_secondary_diagonal([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 15 ``` Example Error Handling: ```python >>> sum_primary_diagonal([[1, 2], [3, 4, 5]]) Traceback (most recent call last): ... ValueError: Input must be a square matrix. >>> sum_secondary_diagonal([[]]) Traceback (most recent call last): ... ValueError: Input must be a non-empty square matrix. ```","solution":"def sum_primary_diagonal(matrix): Returns the sum of the primary diagonal elements of a square matrix. if not matrix or not all(len(row) == len(matrix) for row in matrix): raise ValueError(\\"Input must be a square matrix.\\") size = len(matrix) return sum(matrix[i][i] for i in range(size)) def sum_secondary_diagonal(matrix): Returns the sum of the secondary diagonal elements of a square matrix. if not matrix or not all(len(row) == len(matrix) for row in matrix): raise ValueError(\\"Input must be a square matrix.\\") size = len(matrix) return sum(matrix[i][size - 1 - i] for i in range(size))"},{"question":"**Scenario**: You are working on a library management system, and you need to implement a way to efficiently catalog and retrieve information about books. Each book has a title, author, publication year, and ISBN. There will be operations to add new books, retrieve details of a book by ISBN, and list all books by a particular author. **Task**: Implement a class `LibraryCatalog` with the following methods: 1. `add_book(title: str, author: str, year: int, isbn: str) -> None`: Adds a book to the catalog with the specified details. 2. `get_book_by_isbn(isbn: str) -> dict`: Retrieves details of a book given its ISBN. The details should be returned as a dictionary with keys `title`, `author`, `year`, and `isbn`. 3. `list_books_by_author(author: str) -> list`: Lists all books of a specific author. Each book should be represented as a dictionary similar to the one returned by `get_book_by_isbn`. * Expected input and output formats: * `add_book(title, author, year, isbn)` -> None * `get_book_by_isbn(isbn)` -> `{ \\"title\\": str, \\"author\\": str, \\"year\\": int, \\"isbn\\": str }` * `list_books_by_author(author)` -> `[ { \\"title\\": str, \\"author\\": str, \\"year\\": int, \\"isbn\\": str }, ... ]` * Constraints: * ISBNs are unique for each book. * There should not be any duplicate entries in the catalog. * Author names and book titles are case-sensitive. * Handle cases where a requested ISBN or author does not exist gracefully. Below is the starting code for the class: ```python class LibraryCatalog: def __init__(self): # Initialize any necessary data structures here. pass def add_book(self, title: str, author: str, year: int, isbn: str) -> None: # Implement the logic to add a book to the catalog. pass def get_book_by_isbn(self, isbn: str) -> dict: # Implement the logic to retrieve a book by its ISBN. pass def list_books_by_author(self, author: str) -> list: # Implement the logic to list all books by a particular author. pass ```","solution":"class LibraryCatalog: def __init__(self): self.books_by_isbn = {} self.books_by_author = {} def add_book(self, title: str, author: str, year: int, isbn: str) -> None: if isbn in self.books_by_isbn: raise ValueError(\\"A book with this ISBN already exists.\\") book = { \\"title\\": title, \\"author\\": author, \\"year\\": year, \\"isbn\\": isbn } self.books_by_isbn[isbn] = book if author not in self.books_by_author: self.books_by_author[author] = [] self.books_by_author[author].append(book) def get_book_by_isbn(self, isbn: str) -> dict: if isbn not in self.books_by_isbn: raise ValueError(\\"No book with this ISBN exists.\\") return self.books_by_isbn[isbn] def list_books_by_author(self, author: str) -> list: if author not in self.books_by_author: return [] return self.books_by_author[author]"},{"question":"# Problem Statement You are tasked to implement a function `find_common_libraries` that takes in two integer arrays representing the IDs of libraries that two different users frequent. The function should return an array of IDs that both users have in common, sorted in ascending order. If no common libraries exist, return an empty array. # Input * Two non-null integer arrays `user1_libraries` and `user2_libraries`. * `0 <= len(user1_libraries), len(user2_libraries) <= 10^5` * Each ID in the arrays is unique and ranges from `1` to `10^9`. # Output * A sorted array of integers representing the common library IDs. # Constraints * The function should efficiently handle the size constraints of the input arrays. * Aim for optimal time and space complexity, considering both the sorting and search operations. # Examples * Example 1: ```python find_common_libraries([101, 102, 103, 104], [103, 104, 105, 106]) ``` Expected Output: ``` [103, 104] ``` * Example 2: ```python find_common_libraries([11, 22, 33, 44], [55, 66, 77, 88]) ``` Expected Output: ``` [] ``` # Additional Context Consider an application where matching user preferences or activities is essential, like a social platform integrating library visits. Efficiently finding common interests can enhance features like friend recommendations or activity group formations. Write the function `find_common_libraries` that fulfills this requirement.","solution":"def find_common_libraries(user1_libraries, user2_libraries): Returns a sorted list of common library IDs between two users. :param user1_libraries: List[int], list of library IDs for user 1. :param user2_libraries: List[int], list of library IDs for user 2. :return: List[int], sorted list of common library IDs. # Converting both lists to sets for efficient intersection set1 = set(user1_libraries) set2 = set(user2_libraries) # Finding common elements using intersection of sets common_libraries = set1 & set2 # Returning the sorted list of common elements return sorted(list(common_libraries))"},{"question":"# Problem Statement You need to design and implement a function `merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]` that takes in two sorted arrays of integers and returns a single sorted array containing all elements from both input arrays. # Requirements and Constraints 1. **Input**: - `arr1`: A list of integers sorted in ascending order. - `arr2`: A list of integers sorted in ascending order. 2. **Output**: - Returns a list of integers sorted in ascending order containing all elements from `arr1` and `arr2`. 3. **Constraints**: - Each input list will have a length in the range [0, 1000]. - Elements in the lists will be in the range `[-10^6, 10^6]`. # Example **Input**: ```python arr1 = [1, 3, 5] arr2 = [2, 4, 6] ``` **Output**: ```python [1, 2, 3, 4, 5, 6] ``` **Input**: ```python arr1 = [-5, 0, 3] arr2 = [-10, -4, 1] ``` **Output**: ```python [-10, -5, -4, 0, 1, 3] ``` # Instructions 1. Implement the function `merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]`. 2. You should not use any built-in sorting functions; focus on merging two sorted lists efficiently. 3. Ensure the algorithm has a time complexity of `O(n + m)`, where `n` and `m` are the lengths of `arr1` and `arr2` respectively. 4. Test your function thoroughly with different arrays of varying lengths and values. ```python from typing import List def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: # Your code goes here pass # Example usage: # arr1 = [1, 3, 5] # arr2 = [2, 4, 6] # result = merge_sorted_arrays(arr1, arr2) ```","solution":"from typing import List def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: result = [] i, j = 0, 0 # Merge arr1 and arr2 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: result.append(arr1[i]) i += 1 else: result.append(arr2[j]) j += 1 # Include remaining elements while i < len(arr1): result.append(arr1[i]) i += 1 while j < len(arr2): result.append(arr2[j]) j += 1 return result"},{"question":"# Question You have been given the task of developing a simple spell-checking tool that identifies and corrects common misspellings in a given text based on a provided dictionary. Function Specifications: 1. **spell_check(text: str, dictionary: Set[str]) -> str** * Takes a `text` string and a `dictionary` set of correctly spelled words. * Identifies and corrects words in `text` that are not in the `dictionary`. * If a word in `text` is not found in the `dictionary`, suggest the closest word from the dictionary that differs by either one character substitution, insertion, or deletion. 2. **find_closest_word(word: str, dictionary: Set[str]) -> str** * Finds and returns the closest word from the `dictionary` to the given `word`. * Uses one character edit distance (Levenshtein distance with a maximum of 1) to determine the closest word. Input/Output Requirements: * The `text` to be checked and corrected can contain any alphabetical characters and spaces, but no punctuation. * The `dictionary` will only contain lowercase words with no spaces or punctuation. * The `text` string will be composed of lowercase words separated by spaces. * The output should replace only the misspelled words with their closest suggestions from the dictionary. Constraints: * Maintain O(m * n) time complexity for the spell check process, where `m` is the number of words in `text` and `n` is the number of words in `dictionary`. * Assume the dictionary contains a reasonable number of words that can fit into memory. * If there are multiple closest words (with the same edit distance), the function should return any one of them. Example: ```python def test_spell_check(): dictionary = {\\"this\\", \\"is\\", \\"a\\", \\"test\\", \\"message\\"} text = \\"ths is a tst mesage\\" corrected_text = spell_check(text, dictionary) assert corrected_text == \\"this is a test message\\" test_spell_check() ``` Additional Context: Consider the situation where the text is being used in casual messaging services or note-taking apps, and quick correction of minor spelling errors would significantly enhance the user\'s experience. The goal is not to create a comprehensive spell checker but a simple tool that performs quick and reasonable corrections.","solution":"def find_closest_word(word, dictionary): Finds and returns the closest word from the dictionary to the given word. Uses one character edit distance (Levenshtein distance with a maximum of 1) to determine the closest word. min_distance = float(\'inf\') closest_word = word def calculate_edit_distance(word1, word2): if abs(len(word1) - len(word2)) > 1: return float(\'inf\') m, n = len(word1), len(word2) if m > n: word1, word2 = word2, word1 m, n = n, m prev_row = list(range(m + 1)) for j in range(1, n + 1): current_row = [j] + [0] * m for i in range(1, m + 1): insertion = prev_row[i] + 1 deletion = current_row[i - 1] + 1 substitution = prev_row[i - 1] if word1[i - 1] != word2[j - 1]: substitution += 1 current_row[i] = min(insertion, deletion, substitution) prev_row = current_row distance = prev_row[m] return distance for dict_word in dictionary: distance = calculate_edit_distance(word, dict_word) if distance < min_distance: min_distance = distance closest_word = dict_word return closest_word def spell_check(text, dictionary): Takes a text string and a dictionary set of correctly spelled words. Identifies and corrects words in text that are not in the dictionary. words = text.split() corrected_text = [] for word in words: if word in dictionary: corrected_text.append(word) else: corrected_text.append(find_closest_word(word, dictionary)) return \' \'.join(corrected_text)"},{"question":"# Problem Statement: You are required to create a function that analyzes the trend of a stock based on its daily closing prices over a given period. Specifically, you need to determine the length of the longest upward trend in the list of closing prices. An upward trend is defined as a sequence of days where each day\'s closing price is higher than the previous day\'s closing price. # Function Signature ```python def longest_upward_trend(prices: List[int]) -> int: pass ``` # Input - `prices` (List[int]): A list of integers representing the daily closing prices of a stock. # Output - Returns an integer representing the length of the longest upward trend in the list of prices. # Examples ```python >>> longest_upward_trend([100, 102, 101, 103, 105, 107]) 4 >>> longest_upward_trend([101, 100, 99, 98, 97]) 1 >>> longest_upward_trend([100, 101, 102, 103, 104]) 5 >>> longest_upward_trend([50, 50, 50, 50, 50]) 1 >>> longest_upward_trend([]) 0 ``` # Constraints - The length of the list `prices` will not exceed 10,000. - All prices are positive integers and will not exceed 1,000,000. # Notes - Consider edge cases such as an empty list, lists with all identical elements, and lists with no upward trends. - The solution should be efficient, with a time complexity of O(n) and space complexity of O(1). - You can assume the list will contain non-negative integers only.","solution":"from typing import List def longest_upward_trend(prices: List[int]) -> int: if not prices: return 0 longest_streak = 0 current_streak = 1 for i in range(1, len(prices)): if prices[i] > prices[i-1]: current_streak += 1 else: if current_streak > longest_streak: longest_streak = current_streak current_streak = 1 return max(longest_streak, current_streak)"},{"question":"# Problem Statement Once you\'ve completed the function that calculates the smallest positive number evenly divisible by all integers from 1 to `n`, it\'s time to address another important problem. Implement a function that checks if a number is a power of any number greater than 1. # Function Signature ```python def is_power_of_any(num: int) -> bool: pass ``` # Input - **num** (2 <= num <= 10^9): The number to check if it is a power of any integer greater than 1. # Output - **bool**: Return `True` if the number is a power of any integer greater than 1, otherwise return `False`. # Examples ```python assert is_power_of_any(4) == True # 4 = 2^2 assert is_power_of_any(27) == True # 27 = 3^3 assert is_power_of_any(1) == False # 1 < 2 assert is_power_of_any(16) == True # 16 = 2^4 assert is_power_of_any(31) == False # 31 is not a power of any integer greater than 1 ``` # Performance Requirements - The solution should be optimized to handle the maximum constraint efficiently. - Consider mathematical properties and efficient iteration to solve the problem within a reasonable time frame. # Hints - Consider iterating through possible bases and checking if taking logarithms might confirm if the numbers are powers. - Be cautious about numerical precision and potential floating point inaccuracies. # Additional Constraints - Ensure your solution does not rely on simple brute force approaches that would be infeasible for large inputs (e.g., up to 10^9).","solution":"import math def is_power_of_any(num: int) -> bool: if num < 2: return False max_base = int(math.sqrt(num)) + 1 for base in range(2, max_base): current = base while current <= num: current *= base if current == num: return True return False # Example runs print(is_power_of_any(4)) # Expected: True (2^2) print(is_power_of_any(27)) # Expected: True (3^3) print(is_power_of_any(1)) # Expected: False (1 < 2) print(is_power_of_any(16)) # Expected: True (2^4) print(is_power_of_any(31)) # Expected: False (31 is not a power of any integer > 1)"},{"question":"# String Permutation Check Context In many programming applications, such as cryptographic algorithms and password validation, it\'s often necessary to determine whether one string is a permutation of another. A permutation is a rearrangement of the characters of a string into a new order. Problem Statement You are given two strings and must determine if one string is a permutation of the other. Write a function `is_permutation` that takes two strings and returns `True` if one string is a permutation of the other, and `False` otherwise. Function Signature ```python def is_permutation(str1: str, str2: str) -> bool: pass ``` Parameters - `str1`: A string containing alphanumeric characters. - `str2`: A string containing alphanumeric characters. Constraints - The length of the strings will be between 1 and 1000 characters. - Both strings are case-sensitive (i.e., \'A\' is different from \'a\'). Expected Output - The function returns a boolean value: `True` if one string is a permutation of the other, `False` otherwise. Example ```python >>> is_permutation(\\"abc\\", \\"bca\\") True >>> is_permutation(\\"abc\\", \\"def\\") False >>> is_permutation(\\"aabbcc\\", \\"abccba\\") True >>> is_permutation(\\"hello\\", \\"holle\\") True >>> is_permutation(\\"test\\", \\"best\\") False ``` Performance Requirements - Your implementation should efficiently handle the input constraints. - Aim for a time complexity of O(n), where n is the length of the longer string. Notes - Consider edge cases where one string is empty or both strings have different lengths. - Ensure your solution handles all alphanumeric characters correctly.","solution":"def is_permutation(str1: str, str2: str) -> bool: Determine if two strings are permutations of each other. if len(str1) != len(str2): return False from collections import Counter return Counter(str1) == Counter(str2)"},{"question":"# Problem Statement You are tasked with creating a function that calculates the final score of a student based on an array of scores in their various subjects. The final score is determined by the mean (average) of all valid scores rounded to two decimal places. A score is valid if it falls within the range of 0 to 100 (inclusive). # Function Signature ```python def calculate_final_score(scores: list) -> float: ``` # Parameters: - `scores` (list): A list of integers or floats representing the scores in various subjects. Must contain at least one valid score. # Returns: - The function should return a float representing the average of the valid scores, rounded to two decimal places. # Constraints: - The function must raise a `ValueError` if the `scores` list does not contain any valid scores. # Example ```python # Example 1 print(calculate_final_score([95, 85, 92, 88, 76])) # Output: 87.20 # Example 2 print(calculate_final_score([100, 100, 100, 0, 0, 0])) # Output: 50.00 # Example 3 print(calculate_final_score([-10, 105, 80, 90])) # Output: 85.00 # Example 4 print(calculate_final_score([45.5, 78.3, 86.0])) # Output: 69.93 # Example 5 print(calculate_final_score([55])) # Output: 55.00 ``` Notes: - Ensure the function filters out invalid scores that are not within the range of 0 to 100 (inclusive). - Utilize Python\'s built-in `sum` and `len` functions to simplify the calculation of the mean. - Make sure your function performs input validation and raises a `ValueError` if the list does not contain any valid scores.","solution":"def calculate_final_score(scores): Calculates the average of valid scores in the list, rounded to two decimal places. A valid score is between 0 and 100 inclusive. Parameters: scores (list): A list of integers or floats representing the scores. Returns: float: The average of valid scores rounded to two decimal places. Raises: ValueError: If there are no valid scores in the list. valid_scores = [score for score in scores if 0 <= score <= 100] if not valid_scores: raise ValueError(\\"No valid scores available.\\") average_score = sum(valid_scores) / len(valid_scores) return round(average_score, 2)"},{"question":"# Question Imagine you have a list of stock prices recorded daily. You want to understand the trading windows where the stock prices showed an increasing trend. Implement a function `find_increasing_trends` that identifies all such periods and returns the start and end indices of each trend. 1. **Input Validation**: Ensure the input list is not empty. 2. **Trend Identification**: Find and return all continuous subarrays where each element is strictly greater than the previous one. 3. **Optimize Time Complexity**: Ensure that the function efficiently handles large input sizes. Function Signature ```python def find_increasing_trends(prices: list[float]) -> list[tuple[int, int]]: pass ``` Input and Output Formats * **Input**: * `prices`: A list of floating-point numbers representing daily stock prices. * **Output**: * Returns a list of tuples, where each tuple contains the start and end indices of an increasing trend. Constraints * The input list should have at least one element. * Indices should be zero-based. Scenario Suppose you are a financial analyst using historical stock data to identify periods of price increase to better inform investment strategies. This tool would help you automatically identify and analyze these periods without manually checking through potentially large datasets. Example ```python # Simple usage >>> find_increasing_trends([1.0, 1.2, 1.4, 1.3, 1.5, 1.7]) [(0, 2), (3, 5)] # Edge case where there are no increasing trends >>> find_increasing_trends([1.0, 0.8, 0.6]) [] # Single element list >>> find_increasing_trends([1.0]) [] # Continuous increasing trend >>> find_increasing_trends([1.0, 1.1, 1.2, 1.3, 1.4]) [(0, 4)] ```","solution":"def find_increasing_trends(prices: list[float]) -> list[tuple[int, int]]: Identifies all periods where the stock prices showed an increasing trend. :param prices: A list of daily stock prices :return: A list of tuples containing the start and end indices of each increasing trend if not prices: raise ValueError(\\"The input list cannot be empty.\\") increasing_trends = [] n = len(prices) start = None for i in range(1, n): if prices[i] > prices[i - 1]: if start is None: start = i - 1 else: if start is not None: increasing_trends.append((start, i - 1)) start = None if start is not None: increasing_trends.append((start, n - 1)) return increasing_trends"},{"question":"# Question: Find First Non-Repeating Character in a String You are given a string `s` consisting of lowercase English letters. Write a function to find the first non-repeating character in `s` and return its index. If it does not exist, return `-1`. # Input * A string `s` (1 ≤ length of s ≤ 10^5) consisting of only lowercase English letters. # Output * Return the index of the first non-repeating character in `s`. If no such character exists, return `-1`. # Constraints * The solution should have a time complexity of O(n), where n is the length of the string. # Example Input ```python s = \\"leetcode\\" ``` Output ```python 0 ``` Input ```python s = \\"loveleetcode\\" ``` Output ```python 2 ``` Input ```python s = \\"aabb\\" ``` Output ```python -1 ``` # Function Signature ```python def first_non_repeating_character(s: str) -> int: pass ``` The function `first_non_repeating_character` should efficiently determine the index of the first unique character in the given string or return `-1` if no such character exists. This assessment tests the candidate\'s understanding of string manipulation, dictionary usage, and algorithmic efficiency.","solution":"def first_non_repeating_character(s: str) -> int: Finds the index of the first non-repeating character in the given string. :param s: str - Input string consisting of lowercase English letters. :return: int - Index of the first non-repeating character, or -1 if none exists. # Dictionary to store the frequency and first index of each character char_count = {} # Count the occurrence of each character and note their first index for index, letter in enumerate(s): if letter in char_count: char_count[letter][0] += 1 else: char_count[letter] = [1, index] # Find the first character with frequency 1 for letter in s: if char_count[letter][0] == 1: return char_count[letter][1] # If no non-repeating character was found return -1"},{"question":"# Problem Statement You are tasked with creating a program that determines the total resistance in a circuit consisting of multiple resistors connected in series and parallel combinations. When resistors are connected in series, the total resistance is the sum of the individual resistances: [ R_{total} = R_1 + R_2 + R_3 + ldots + R_n ] When resistors are connected in parallel, the total resistance is given by the reciprocal of the sum of the reciprocals of the individual resistances: [ frac{1}{R_{total}} = frac{1}{R_1} + frac{1}{R_2} + frac{1}{R_3} + ldots + frac{1}{R_n} ] # Task Write a function named `calculate_total_resistance` that takes a single parameter: 1. `resistors` (List[List[float]]): A list of lists where each inner list represents a group of resistors connected in parallel. Each resistor value is a positive float. The function should calculate and return the total resistance of the entire circuit assuming all groups (inner lists) are connected in series. # Input and Output Format * **Input**: - A list of lists `resistors`: Each list contains the resistance values of resistors connected in parallel. * **Output**: - A float representing the total resistance of the circuit rounded to three decimal places. # Constraints - Each resistance value must be a positive float. - There is at least one resistor in each group. - There is at least one group of resistors. If any of the constraints are violated, the function should raise a `ValueError` with an appropriate error message. # Example ```python def calculate_total_resistance(resistors: List[List[float]]) -> float: # Your code here # Example Usage print(calculate_total_resistance([[2.0, 3.0], [1.0, 4.0, 6.0]])) # Returns 3.100 print(calculate_total_resistance([[5.0, 5.0], [10.0]])) # Returns 15.000 ``` # Notes 1. Ensure that the function handles edge cases and raises `ValueError` for invalid inputs. 2. Utilize appropriate mathematical operations to compute the required total resistance accurately.","solution":"from typing import List def calculate_total_resistance(resistors: List[List[float]]) -> float: if not resistors or not all(resistors) or any(r <= 0 for group in resistors for r in group): raise ValueError(\\"Input must be a list of lists with positive resistance values.\\") total_resistance = 0 for parallel_group in resistors: reciprocal_sum = sum(1/r for r in parallel_group) parallel_resistance = 1 / reciprocal_sum total_resistance += parallel_resistance return round(total_resistance, 3)"},{"question":"Fibonacci Sequence Algorithm Optimization # Objective Implement a Python function that efficiently computes the nth Fibonacci number. You are required to write a function optimized for both space and time complexity. # Description The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. The sequence goes 0, 1, 1, 2, 3, 5, 8, ..., etc. Your task is to create a function `optimized_fibonacci` that returns the nth Fibonacci number. # Requirements 1. Implement the `optimized_fibonacci` function to compute the nth Fibonacci number. 2. The function should be optimized to run in O(log n) time complexity using matrix exponentiation. # Input - `n` (int): The position in the Fibonacci sequence to compute. # Output - Return the nth Fibonacci number as an integer. # Constraints 1. `0 <= n <= 10^18` # Example ```python def optimized_fibonacci(n: int) -> int: # Your implementation here pass # Example usage: print(optimized_fibonacci(0)) # Output: 0 print(optimized_fibonacci(1)) # Output: 1 print(optimized_fibonacci(10)) # Output: 55 print(optimized_fibonacci(50)) # Output: 12586269025 ``` # Hints 1. Use matrix exponentiation to achieve O(log n) time complexity. 2. The matrix exponentiation method involves the transformation matrix: ``` | 1 1 | | 1 0 | ``` # Detailed Explanation - The nth Fibonacci number can be represented as the top left element of the nth power of a 2x2 matrix. - Matrix exponentiation can rapidly compute the nth power of a matrix using the divide and conquer method. # Implementation Example (Outline) ```python def multiply_matrices(A, B): return [ [A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]] ] def matrix_power(matrix, n): result = [[1, 0], [0, 1]] # Identity matrix base = matrix while n > 0: if n % 2 == 1: result = multiply_matrices(result, base) base = multiply_matrices(base, base) n //= 2 return result def optimized_fibonacci(n: int) -> int: if n == 0: return 0 if n == 1: return 1 F = [[1, 1], [1, 0]] result = matrix_power(F, n-1) return result[0][0] # Example usage print(optimized_fibonacci(0)) # Output: 0 print(optimized_fibonacci(1)) # Output: 1 print(optimized_fibonacci(10)) # Output: 55 print(optimized_fibonacci(50)) # Output: 12586269025 ``` * Ensure you handle edge cases and validate inputs where necessary. * Optimize the implementation to handle very large values of n efficiently.","solution":"def multiply_matrices(A, B): Multiplies two 2x2 matrices A and B. return [ [A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]] ] def matrix_power(matrix, n): Performs matrix exponentiation. Returns matrix^n. result = [[1, 0], [0, 1]] # Identity matrix base = matrix while n > 0: if n % 2 == 1: result = multiply_matrices(result, base) base = multiply_matrices(base, base) n //= 2 return result def optimized_fibonacci(n: int) -> int: Computes the nth Fibonacci number using matrix exponentiation. if n == 0: return 0 if n == 1: return 1 F = [[1, 1], [1, 0]] result = matrix_power(F, n-1) return result[0][0]"},{"question":"# Problem Statement: You are given a list of integers where each integer can be positive, negative, or zero. Your task is to sort the list such that the positive numbers appear first, followed by the negative numbers, with zeros appearing at the end. The relative order of the positive and negative numbers should be preserved from the original list. # Function Signature: ```python def sort_integers(nums: List[int]) -> List[int]: ``` # Input: - `nums` (List[int]): A list of integers with length in the range [1, 10^5]. # Output: - (List[int]): The list sorted such that positive numbers appear first, followed by negative numbers, and zeros at the end. # Constraints: - The input list can contain a mix of positive, negative numbers, and zeros. # Example: ```python >>> sort_integers([3, -1, 0, -2, 5, 0, 2]) [3, 5, 2, -1, -2, 0, 0] >>> sort_integers([-1, 0, -3, 2, -2, 3]) [2, 3, -1, -3, -2, 0] >>> sort_integers([0, 0, -3, -2, -1]) [-3, -2, -1, 0, 0] ``` # Requirements: 1. Maintain the relative order of positive and negative numbers as they appear in the original list. 2. Ensure that the zeros are all moved to the end of the list. 3. Implement an efficient solution with respect to time and space complexity. # Notes: - Pay attention to edge cases like lists with all positive numbers, all negative numbers, or all zeros. - Your solution should handle large input sizes efficiently and preserve the relative order of the numbers as described. Good luck with your implementation!","solution":"from typing import List def sort_integers(nums: List[int]) -> List[int]: Sorts the list such that positive numbers appear first, followed by negative numbers, with zeros appearing at the end. The relative order of positive and negative numbers is preserved. positive = [num for num in nums if num > 0] negative = [num for num in nums if num < 0] zeros = [num for num in nums if num == 0] return positive + negative + zeros"},{"question":"# Implementing a Simple Encryption Algorithm You need to implement a simple encryption algorithm that encrypts and decrypts a given string using a provided key. The algorithm shifts each character in the string by a number of positions specified by the key in the ASCII table. The provided key is used cyclically if it is shorter than the number of characters in the string. Requirements: 1. Implement a class `SimpleEncryption` with two methods: `encrypt` and `decrypt`. 2. The `encrypt` method should take a plain text string and a key (string) and return the encrypted text. 3. The `decrypt` method should take the encrypted text and the same key and return the original plain text. # Input and Output Formats 1. **Input**: - **encrypt** - `plain_text` (str): A string representing the plain text. - `key` (str): A string representing the encryption key. - **decrypt** - `encrypted_text` (str): A string representing the encrypted text. - `key` (str): A string representing the encryption key used for decryption. 2. **Output**: - **encrypt** (str): A string representing the encrypted text. - **decrypt** (str): A string representing the decrypted text. # Constraints: - The input strings and key will only contain printable ASCII characters (ASCII value 32-126). - The length of `plain_text` and `encrypted_text` should be between 1 and 1000 characters. - The length of `key` should be between 1 and 100 characters. # Example: ```python # Example usage: encryption = SimpleEncryption() plain_text = \\"Hello, World!\\" key = \\"key123\\" encrypted_text = encryption.encrypt(plain_text, key) # Encrypted text should be something like: \\"Rijvs, Yqyvn!\\" decrypted_text = encryption.decrypt(encrypted_text, key) # Decrypted text should be \\"Hello, World!\\" ``` ```python class SimpleEncryption: def encrypt(self, plain_text: str, key: str) -> str: Encrypt the plain text using the provided key. Parameters: - plain_text (str): The text to be encrypted. - key (str): The key used for encryption. Returns: - str: The encrypted text. encrypted_text = [] key_length = len(key) for i, char in enumerate(plain_text): key_char = key[i % key_length] encrypted_char = chr((ord(char) + ord(key_char)) % 127) if encrypted_char < \' \': encrypted_char = chr(ord(encrypted_char) + 32) encrypted_text.append(encrypted_char) return \'\'.join(encrypted_text) def decrypt(self, encrypted_text: str, key: str) -> str: Decrypt the encrypted text using the provided key. Parameters: - encrypted_text (str): The text to be decrypted. - key (str): The key used for decryption. Returns: - str: The decrypted text. decrypted_text = [] key_length = len(key) for i, char in enumerate(encrypted_text): key_char = key[i % key_length] decrypted_char = chr((ord(char) - ord(key_char)) % 127) if decrypted_char < \' \': decrypted_char = chr(ord(decrypted_char) + 32) decrypted_text.append(decrypted_char) return \'\'.join(decrypted_text) # Example usage if __name__ == \\"__main__\\": encryption = SimpleEncryption() plain_text = \\"Hello, World!\\" key = \\"key123\\" encrypted_text = encryption.encrypt(plain_text, key) print(f\\"Encrypted text: {encrypted_text}\\") decrypted_text = encryption.decrypt(encrypted_text, key) print(f\\"Decrypted text: {decrypted_text}\\") ```","solution":"class SimpleEncryption: def encrypt(self, plain_text: str, key: str) -> str: Encrypt the plain text using the provided key. Parameters: - plain_text (str): The text to be encrypted. - key (str): The key used for encryption. Returns: - str: The encrypted text. encrypted_text = [] key_length = len(key) for i, char in enumerate(plain_text): key_char = key[i % key_length] encrypted_char = chr(((ord(char) - 32 + ord(key_char) - 32) % 95) + 32) encrypted_text.append(encrypted_char) return \'\'.join(encrypted_text) def decrypt(self, encrypted_text: str, key: str) -> str: Decrypt the encrypted text using the provided key. Parameters: - encrypted_text (str): The text to be decrypted. - key (str): The key used for decryption. Returns: - str: The decrypted text. decrypted_text = [] key_length = len(key) for i, char in enumerate(encrypted_text): key_char = key[i % key_length] decrypted_char = chr(((ord(char) - 32 - (ord(key_char) - 32)) % 95) + 32) decrypted_text.append(decrypted_char) return \'\'.join(decrypted_text) # Example usage if __name__ == \\"__main__\\": encryption = SimpleEncryption() plain_text = \\"Hello, World!\\" key = \\"key123\\" encrypted_text = encryption.encrypt(plain_text, key) print(f\\"Encrypted text: {encrypted_text}\\") decrypted_text = encryption.decrypt(encrypted_text, key) print(f\\"Decrypted text: {decrypted_text}\\")"},{"question":"# Scenario: You are working on a navigation system that uses a graph to represent cities and the roads between them. Each road has a specific travel time, and you need to determine the shortest path between two cities. Implement a function to find the shortest travel time between a given pair of cities using Dijkstra\'s algorithm. # Task: Implement a function `shortest_travel_time(graph: dict, start: str, end: str) -> int` that computes the shortest travel time between the `start` city and the `end` city using Dijkstra\'s algorithm. # Function Signature: ```python def shortest_travel_time(graph: dict, start: str, end: str) -> int: pass ``` # Input: * `graph`: A dictionary where the keys are city names (strings) and the values are dictionaries. The inner dictionary keys are the neighboring city names, and the values are the travel times (integers) to those cities. * `start`: A string representing the name of the starting city. * `end`: A string representing the name of the destination city. # Output: * Return an integer representing the shortest travel time between the `start` and `end` cities. If there is no path, return -1. # Example: ```python >>> graph = { ... \'A\': {\'B\': 1, \'C\': 4}, ... \'B\': {\'A\': 1, \'C\': 2, \'D\': 5}, ... \'C\': {\'A\': 4, \'B\': 2, \'D\': 1}, ... \'D\': {\'B\': 5, \'C\': 1} ... } >>> shortest_travel_time(graph, \'A\', \'D\') 4 >>> shortest_travel_time(graph, \'A\', \'C\') 3 >>> shortest_travel_time(graph, \'A\', \'A\') 0 >>> shortest_travel_time(graph, \'A\', \'Z\') -1 ``` # Constraints: * The graph may have up to 100,000 nodes and 1,000,000 edges. # Notes: * Implement and test your `shortest_travel_time` function thoroughly. * Ensure your algorithm efficiently handles the specified constraints.","solution":"import heapq def shortest_travel_time(graph: dict, start: str, end: str) -> int: Returns the shortest travel time between start and end cities using Dijkstra\'s algorithm. If there is no path, returns -1. if start not in graph or end not in graph: return -1 # Priority queue to store (distance, node) tuples priority_queue = [(0, start)] # Dictionary to store the shortest distance to each node distances = {start: 0} # Set to keep track of visited nodes visited = set() while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_node in visited: continue if current_node == end: return current_distance visited.add(current_node) for neighbor, weight in graph[current_node].items(): if neighbor in visited: continue new_distance = current_distance + weight if new_distance < distances.get(neighbor, float(\'inf\')): distances[neighbor] = new_distance heapq.heappush(priority_queue, (new_distance, neighbor)) return -1"},{"question":"Question: Least Common Multiple (LCM) of Three Numbers Scenario Given three integers, determine the least common multiple (LCM) of these numbers. The least common multiple of three integers is the smallest positive integer that is divisible by all three of the given integers. # Task Write a function: ```python def find_lcm_of_three(a: int, b: int, c: int) -> int: Determine and return the least common multiple (LCM) of three integers. ``` # Input - The function receives three integers `a`, `b`, and `c` where, `1 <= a, b, c <= 10^6`. # Output - The function should return a single integer, which is the least common multiple (LCM) of the three input numbers. # Constraints - The integers are within the given range. # Performance Requirements - Ensure the solution is efficient in calculating LCM, especially within the specified input constraints. # Examples - `>>> find_lcm_of_three(4, 6, 8)` - Output: 24 - `>>> find_lcm_of_three(12, 15, 20)` - Output: 60 - `>>> find_lcm_of_three(7, 13, 19)` - Output: 1729 # Notes - Consider edge cases such as when two or more of the numbers are the same. - Ensure to handle large values efficiently within the constraints. # Hints - Utilize the properties of the greatest common divisor (GCD) to calculate the LCM. - The formula for LCM of two numbers can be extended to three numbers. - Consider breaking down the problem into smaller, more manageable components to simplify calculations.","solution":"import math def find_lcm(x, y): Helper function to find the least common multiple (LCM) of two numbers. return x * y // math.gcd(x, y) def find_lcm_of_three(a: int, b: int, c: int) -> int: Determine and return the least common multiple (LCM) of three integers. lcm_ab = find_lcm(a, b) lcm_abc = find_lcm(lcm_ab, c) return lcm_abc"},{"question":"# Scenario An online bookstore needs to manage its inventory more efficiently by implementing a feature that identifies the best-selling books for a given period. The store records each sale, including the book\'s ISBN and the date of sale. To optimize their stock for future sales, they want to generate a ranking of the top N best-selling books within a specified date range. # Task Write a Python function `top_n_bestsellers(sales: List[Dict[str, str]], start_date: str, end_date: str, n: int) -> List[str]` that returns a list of the ISBNs of the top N best-selling books for the given date range. Input * `sales` is a list of dictionaries, each representing a sale with keys: - `isbn`: A string representing the book\'s ISBN. - `date`: A string representing the date of the sale in the format \'YYYY-MM-DD\'. * `start_date`: A string representing the start date of the range in the format \'YYYY-MM-DD\'. * `end_date`: A string representing the end date of the range in the format \'YYYY-MM-DD\'. * `n`: An integer representing the number of top-selling books to return. Output * Return a list of the ISBNs of the top N best-selling books in descending order of sales within the specified date range. * If there are ties in the number of sales, the order of the tied ISBNs in the output list does not matter. * If there are fewer than N unique books sold in the date range, return the ISBNs of all the books sold. Constraints * The function should only consider sales that fall within the given date range, inclusive. * You may assume that the input dates are valid and the sales list is non-empty. * Dates are in the format \'YYYY-MM-DD\'. Example Inputs and their corresponding outputs: ```python sales = [ {\\"isbn\\": \\"978-3-16-148410-0\\", \\"date\\": \\"2023-01-15\\"}, {\\"isbn\\": \\"978-1-4028-9462-6\\", \\"date\\": \\"2023-01-15\\"}, {\\"isbn\\": \\"978-1-4028-9462-6\\", \\"date\\": \\"2023-01-16\\"}, {\\"isbn\\": \\"978-0-321-49362-7\\", \\"date\\": \\"2023-01-17\\"}, {\\"isbn\\": \\"978-3-16-148410-0\\", \\"date\\": \\"2023-01-18\\"}, {\\"isbn\\": \\"978-3-16-148410-0\\", \\"date\\": \\"2023-01-18\\"}, ] top_n_bestsellers(sales, \\"2023-01-15\\", \\"2023-01-18\\", 2) # Returns: [\\"978-3-16-148410-0\\", \\"978-1-4028-9462-6\\"] top_n_bestsellers(sales, \\"2023-01-15\\", \\"2023-01-16\\", 1) # Returns: [\\"978-1-4028-9462-6\\"] top_n_bestsellers(sales, \\"2023-01-19\\", \\"2023-01-20\\", 1) # Returns: [] ``` **Note**: Ensure the function is efficient for large datasets and handles edge cases such as: - No sales in the specified date range. - `n` being larger than the number of unique books sold.","solution":"from typing import List, Dict from collections import Counter from datetime import datetime def top_n_bestsellers(sales: List[Dict[str, str]], start_date: str, end_date: str, n: int) -> List[str]: Returns a list of the ISBNs of the top N best-selling books for the given date range. # Parse the date strings into datetime objects for comparison start_date_parsed = datetime.strptime(start_date, \'%Y-%m-%d\') end_date_parsed = datetime.strptime(end_date, \'%Y-%m-%d\') # Filter sales to include only those within the date range filtered_sales = [sale for sale in sales if start_date_parsed <= datetime.strptime(sale[\'date\'], \'%Y-%m-%d\') <= end_date_parsed] # Count the number of sales for each ISBN sales_count = Counter(sale[\'isbn\'] for sale in filtered_sales) # Get the top N bestsellers top_n = sales_count.most_common(n) # Return a list of the ISBNs of the top N best-selling books return [isbn for isbn, count in top_n]"},{"question":"# String Compression Algorithm Background In several applications, particularly in data transmission and storage optimization, it is useful to compress strings by eliminating redundancy. You are to implement a simple compression algorithm to achieve this. Task Your task is to implement two functions: 1. `compress_string(input_string: str) -> str`: Compresses the given string by collapsing consecutive identical characters into a single character followed by the count. 2. `decompress_string(compressed_string: str) -> str`: Decompresses the given compressed string back to its original form. Details: - The `input_string` consists of only alphabetic characters (both uppercase and lowercase). - Do not output the count if it is 1. - The `compressed_string` will follow the format where consecutive identical characters are represented by one character followed by the count if the count is more than 1. Input - `input_string`: A string of alphabetic characters to be compressed. - `compressed_string`: A string representing the compressed form of `input_string`. Output - For `compress_string`: A compressed string based on the described compression algorithm. - For `decompress_string`: The original string reconstructed from the compressed form. Examples ```python assert compress_string(\'aaabbc\') == \'a3b2c\' assert decompress_string(\'a3b2c\') == \'aaabbc\' assert compress_string(\'abc\') == \'abc\' assert decompress_string(\'abc\') == \'abc\' ``` Requirements - Implement the compression and decompression according to the provided specifications. - Ensure that the algorithm handles both uppercase and lowercase characters correctly. Constraints - `input_string` will contain only alphabetic characters. - `compressed_string` will be a valid compressed representation using the compression format described. - The length of `input_string` and `compressed_string`: 1 ≤ length ≤ 10^4","solution":"def compress_string(input_string: str) -> str: if not input_string: return \'\' compressed = [] count = 1 for i in range(1, len(input_string)): if input_string[i] == input_string[i - 1]: count += 1 else: compressed.append(input_string[i - 1]) if count > 1: compressed.append(str(count)) count = 1 compressed.append(input_string[-1]) if count > 1: compressed.append(str(count)) return \'\'.join(compressed) def decompress_string(compressed_string: str) -> str: decompressed = [] i = 0 while i < len(compressed_string): char = compressed_string[i] i += 1 count = 0 while i < len(compressed_string) and compressed_string[i].isdigit(): count = count * 10 + int(compressed_string[i]) i += 1 if count == 0: count = 1 decompressed.append(char * count) return \'\'.join(decompressed)"},{"question":"# Scenario You are working on a program that handles large sets of numerical data. To efficiently process these data sets, you need to implement a priority queue that allows for fast insertion and deletion of elements according to their priority. # Problem Statement Implement a class `PriorityQueue` representing a max-priority queue using a binary heap. Your class should support the following operations efficiently: `insert(item: T, priority: int)` to add an item with a given priority, and `extract_max() -> T` to remove and return the item with the highest priority. If the queue is empty, `extract_max` should raise an exception. Ensure your implementation maintains the properties of a max-heap during these operations. # Specifications * **Classes**: * `PriorityQueue` represents the max-priority queue. * **Methods**: * `insert(item: T, priority: int) -> None`: Insert an item with the given priority. * `extract_max() -> T`: Remove and return the item with the highest priority. * **Constraints**: * Both `insert` and `extract_max` operations should run in O(log n) time complexity. * Assume the queue can contain any type of elements as items. * An item cannot be inserted with the same priority as another item. # Example ```python pq = PriorityQueue() pq.insert(\\"apple\\", 5) pq.insert(\\"banana\\", 3) pq.insert(\\"cherry\\", 10) print(pq.extract_max()) # Expected output: \\"cherry\\" print(pq.extract_max()) # Expected output: \\"apple\\" pq.insert(\\"date\\", 7) print(pq.extract_max()) # Expected output: \\"date\\" print(pq.extract_max()) # Expected output: \\"banana\\" ``` # Bonus Extend the `PriorityQueue` class to support a change in priority of any given item in the queue. Provide an additional method: * `change_priority(item: T, new_priority: int) -> None`: Adjust the priority of the specified item to the new priority efficiently.","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] self.entry_finder = {} # map from items to their heap entry self.REMOVED = \'<removed>\' self.counter = 0 def insert(self, item, priority): if item in self.entry_finder: self.remove_item(item) count = self.counter entry = [-priority, count, item] self.entry_finder[item] = entry heapq.heappush(self.heap, entry) self.counter += 1 def remove_item(self, item): entry = self.entry_finder.pop(item) entry[-1] = self.REMOVED def extract_max(self): while self.heap: priority, count, item = heapq.heappop(self.heap) if item is not self.REMOVED: del self.entry_finder[item] return item raise KeyError(\'pop from an empty priority queue\') def change_priority(self, item, new_priority): self.insert(item, new_priority)"},{"question":"# Balanced Binary Search Tree (BST) from a Sorted Array Implement a method called `sorted_array_to_bst` that converts a given sorted (in ascending order) list into a balanced binary search tree (BST). A balanced BST is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than one. # Function Signature ```python def sorted_array_to_bst(nums: List[int]) -> Optional[TreeNode]: pass ``` # Input - `nums`: A list of integers sorted in ascending order. # Output - Returns the root node of a balanced BST. # TreeNode Class You are provided with the following `TreeNode` class definition to use: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Example Scenario Consider the input list: ```python nums = [-10, -3, 0, 5, 9] ``` A possible balanced BST for this input would be: ``` 0 / -3 9 / / -10 5 ``` # Constraints - The `nums` list contains no duplicates and is sorted in ascending order. - The length of `nums` is at least 1 and at most 10^4. # Sample Test Case ```python # Define the ListNode class as given in the prompt class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example input nums = [-10, -3, 0, 5, 9] # Convert the sorted array to a BST root = sorted_array_to_bst(nums) # Function to print the binary tree in-order def print_in_order(root): if root: print_in_order(root.left) print(root.val) print_in_order(root.right) print_in_order(root) ``` # Tips - Utilize a recursive approach to find the middle element of the list to ensure the BST remains balanced. - Always pick the middle element as the root to divide the list into two halves for the left and right subtrees. - Handle edge cases, such as when the list is empty, although it should not occur given the constraints. This question combines recursion, tree data structures, and algorithm design, fitting well with the preceding coding assessment questions in terms of style, complexity, and scope.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums: List[int]) -> Optional[TreeNode]: if not nums: return None # Helper function to construct BST from sorted array def build_bst(left: int, right: int) -> Optional[TreeNode]: if left > right: return None mid = (left + right) // 2 node = TreeNode(nums[mid]) node.left = build_bst(left, mid - 1) node.right = build_bst(mid + 1, right) return node return build_bst(0, len(nums) - 1)"},{"question":"# Scenario You are tasked with developing a utility for an e-commerce platform that generates unique discount codes for promotional campaigns. Each discount code must be alphanumeric and comply with specific length requirements. Additionally, you need to ensure that every generated discount code is unique within the current batch. # Question Write a function `generate_discount_codes(batch_size: int, code_length: int) -> list` to generate a list of unique discount codes based on the provided parameters: 1. **batch_size**: The number of unique discount codes to generate. 2. **code_length**: The length of each discount code. # Input/Output Format - **Input**: - `batch_size`: an integer within range ([1, 1000]) - `code_length`: an integer within range ([1, 20]) - **Output**: - Returns a list of `batch_size` unique alphanumeric strings, each of `code_length`. # Constraints - Each discount code should be a string consisting of uppercase letters and digits. - Ensure that all generated codes in the list are unique. - Consider the performance implication of generating a large batch of codes. # Examples ```python assert len(generate_discount_codes(10, 8)) == 10 assert all(len(code) == 8 for code in generate_discount_codes(5, 8)) assert len(set(generate_discount_codes(15, 10))) == 15 ```","solution":"import random import string def generate_discount_codes(batch_size: int, code_length: int) -> list: Generates a list of unique alphanumeric discount codes. Parameters: - batch_size: int, the number of discount codes to generate. - code_length: int, the length of each discount code. Returns: - list of unique alphanumeric discount codes. if batch_size < 1 or batch_size > 1000: raise ValueError(\\"batch_size must be within the range [1, 1000]\\") if code_length < 1 or code_length > 20: raise ValueError(\\"code_length must be within the range [1, 20]\\") chars = string.ascii_uppercase + string.digits unique_codes = set() while len(unique_codes) < batch_size: new_code = \'\'.join(random.choices(chars, k=code_length)) unique_codes.add(new_code) return list(unique_codes)"},{"question":"# Efficient Routing Using Dijkstra\'s Algorithm **Context**: A logistics company needs to find the shortest paths for its delivery trucks between various warehouses in a city. The city is represented as a graph with warehouses as nodes and roads with varying travel times as edges. Your task is to implement Dijkstra\'s algorithm to determine the shortest route from a starting warehouse to all other warehouses. # Task: Implement the `dijkstra` function to calculate the shortest paths from a given start node to all other nodes in the graph. You are provided with a `Graph` class that includes the methods for adding nodes and edges. # Function Signature: ```python def dijkstra(graph: \'Graph\', start: str) -> dict: pass ``` # Graph Class Definition: ```python class Graph: def __init__(self): self.nodes = set() self.edges = defaultdict(list) self.distances = {} def add_node(self, value): self.nodes.add(value) def add_edge(self, from_node, to_node, distance): self.edges[from_node].append(to_node) self.edges[to_node].append(from_node) self.distances[(from_node, to_node)] = distance self.distances[(to_node, from_node)] = distance ``` # Input: - `graph (Graph)`: An instance of the Graph class representing the city. - `start (str)`: The starting warehouse node from which to calculate shortest paths. # Output: - A dictionary where keys are the warehouse nodes and values are the shortest distances from the start node to that node. # Constraints: - Ensure your algorithm handles large graphs efficiently. - Assume all node values are unique strings. - You may need to handle cases where nodes might be isolated with no connecting edges. # Example: ```python g = Graph() g.add_node(\'A\') g.add_node(\'B\') g.add_node(\'C\') g.add_node(\'D\') g.add_edge(\'A\', \'B\', 1) g.add_edge(\'A\', \'C\', 4) g.add_edge(\'B\', \'C\', 2) g.add_edge(\'B\', \'D\', 5) g.add_edge(\'C\', \'D\', 1) shortest_paths = dijkstra(g, \'A\') print(shortest_paths) # Expected output: {\'A\': 0, \'B\': 1, \'C\': 3, \'D\': 4} ``` **Expectation**: A solution demonstrating proficiency with Dijkstra\'s algorithm, properly handling graph traversal and maintaining efficient time complexity for sparse and dense graphs alike.","solution":"import heapq from collections import defaultdict class Graph: def __init__(self): self.nodes = set() self.edges = defaultdict(list) self.distances = {} def add_node(self, value): self.nodes.add(value) def add_edge(self, from_node, to_node, distance): self.edges[from_node].append(to_node) self.edges[to_node].append(from_node) self.distances[(from_node, to_node)] = distance self.distances[(to_node, from_node)] = distance def dijkstra(graph, start): Implements Dijkstra\'s algorithm to find the shortest path from \'start\' node to all other nodes in the graph. # Initialize distances dictionary with infinite distances except the start node shortest_paths = {node: float(\'inf\') for node in graph.nodes} shortest_paths[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > shortest_paths[current_node]: continue for neighbor in graph.edges[current_node]: distance = graph.distances[(current_node, neighbor)] new_distance = current_distance + distance if new_distance < shortest_paths[neighbor]: shortest_paths[neighbor] = new_distance heapq.heappush(priority_queue, (new_distance, neighbor)) return shortest_paths"},{"question":"# Problem Statement You are tasked with implementing a function that calculates the minimum number of bills and coins needed to make a given amount in a specific currency. The currency uses the following denominations: 500, 100, 50, 20, 10, 5, 1 (all in whole units of the currency). Your function should return a dictionary where the keys are the denominations and the values are the number of each denomination needed to make up the given amount. # Function Signature ```python def minimum_bills_and_coins(amount: int) -> dict: pass ``` # Input - `amount` (int): The total amount you need to make in the currency (non-negative integer). # Output - `dict`: A dictionary where the keys are the denominations (500, 100, 50, 20, 10, 5, 1) and the values are the number of each denomination required to make the amount. # Constraints - The amount (`amount`) must be ≥ 0. # Example ```python >>> minimum_bills_and_coins(687) {500: 1, 100: 1, 50: 1, 20: 1, 10: 1, 5: 1, 1: 2} >>> minimum_bills_and_coins(1234) {500: 2, 100: 2, 50: 0, 20: 1, 10: 1, 5: 0, 1: 4} ``` # Notes - You can assume that the amount will be a non-negative integer. - If the amount is zero, the function should return a dictionary with all denominations set to 0. - Ensure that the function yields the minimum number of bills and coins needed. # Requirements - Implement the function by first handling edge cases such as the amount being zero by returning the appropriate dictionary with all denominations set to 0. - Your solution should follow the greedy approach to calculate the minimum number of bills and coins needed. # Implementation Complete the function `minimum_bills_and_coins` with the above constraints and details.","solution":"def minimum_bills_and_coins(amount: int) -> dict: Returns the minimum number of bills and coins needed to make up the given amount. Parameters: amount (int): The total amount of money in whole units of the currency. Returns: dict: A dictionary where the keys are the denominations and the values are the number of each denomination needed to make up the given amount. denominations = [500, 100, 50, 20, 10, 5, 1] result = {denom: 0 for denom in denominations} for denom in denominations: if amount >= denom: result[denom] = amount // denom amount = amount % denom return result"},{"question":"# Count Subarrays with Sum You are given an array of integers and a target sum. Your task is to implement a function that finds the number of subarrays (contiguous sequences) that sum up to the target sum. Function Signature ```python def count_subarrays_with_sum(arr: list, target_sum: int) -> int: pass ``` Input * `arr` (list of int): A list of integers. * `target_sum` (int): The target sum for the subarrays. Output * `int`: The number of subarrays that add up to the target sum. Constraints * All elements in arr and target_sum will be integers. * The array length will be between 1 and 10^5. * The integers in the array can be positive, negative, or zero. Example ```python >>> count_subarrays_with_sum([1, -1, 0, 1, 1], 2) 3 >>> count_subarrays_with_sum([1, 2, 3], 3) 2 ``` Instructions 1. Use an efficient approach to avoid a brute-force solution that may not perform well for large arrays. 2. Consider leveraging a hash map or similar data structure to keep track of cumulative sums and their frequencies for optimized search and counting. 3. Ensure the solution handles edge cases such as arrays with negative numbers and zero sum properly.","solution":"def count_subarrays_with_sum(arr: list, target_sum: int) -> int: Finds the number of subarrays that sum up to the target_sum. Args: arr (list of int): The input array of integers. target_sum (int): The target sum for the subarrays. Returns: int: The number of subarrays that add up to target_sum. from collections import defaultdict cumulative_sum_map = defaultdict(int) cumulative_sum_map[0] = 1 cumulative_sum = 0 count = 0 for num in arr: cumulative_sum += num if cumulative_sum - target_sum in cumulative_sum_map: count += cumulative_sum_map[cumulative_sum - target_sum] cumulative_sum_map[cumulative_sum] += 1 return count"},{"question":"# Scenario You need to analyze a series of events represented by timestamps and count how many events occurred within a specific time interval. Each event is recorded with a timestamp in the format \\"YYYY-MM-DD hh:mm:ss\\". Your task is to write a function that will count the number of events that occurred within any given time interval. # Task Write a function `count_events_within_interval` that takes a list of timestamp strings and two additional timestamp strings representing the start and end of the interval. The function should return the count of events that occurred within the given time interval (inclusive). # Input/Output - **Input**: - `events` - A list of strings representing timestamps in \\"YYYY-MM-DD hh:mm:ss\\" format. - `start_time` - A string representing the start of the interval in \\"YYYY-MM-DD hh:mm:ss\\" format. - `end_time` - A string representing the end of the interval in \\"YYYY-MM-DD hh:mm:ss\\" format. - **Output**: An integer which is the count of events within the given interval (inclusive). # Constraints - Assume all timestamps are in the same timezone and the format is always valid. - The list of events can contain up to 10,000 timestamps. - The start and end time will always be such that start_time <= end_time. # Function Signature ```python from typing import List def count_events_within_interval(events: List[str], start_time: str, end_time: str) -> int: ``` # Example ```python events = [ \\"2023-10-01 12:30:45\\", \\"2023-10-01 12:45:00\\", \\"2023-10-02 14:00:00\\", \\"2023-10-03 10:15:20\\", \\"2023-10-04 08:30:10\\" ] start_time = \\"2023-10-01 12:00:00\\" end_time = \\"2023-10-02 15:00:00\\" # Expected output: 3, because three events occurred within this interval. print(count_events_within_interval(events, start_time, end_time)) # Output: 3 ``` # Notes Ensure that your function handles the inclusive nature of the interval correctly and accounts for events that occur precisely at the start or end times. It should also efficiently handle checking timestamps within the list.","solution":"from typing import List from datetime import datetime def count_events_within_interval(events: List[str], start_time: str, end_time: str) -> int: start_dt = datetime.strptime(start_time, \\"%Y-%m-%d %H:%M:%S\\") end_dt = datetime.strptime(end_time, \\"%Y-%m-%d %H:%M:%S\\") count = 0 for event in events: event_dt = datetime.strptime(event, \\"%Y-%m-%d %H:%M:%S\\") if start_dt <= event_dt <= end_dt: count += 1 return count"},{"question":"# Scenario You\'re developing a system to manage reservations for a conference room. The room can be booked for multiple time slots throughout the day, and you need to ensure there are no overlapping reservations. # Task Write a function `is_reservation_valid` that determines if a new reservation can be added without overlapping any existing reservations. Reservations are provided as a list of tuples, each containing a start and end time in a 24-hour format (HH:MM). The new reservation should also be in the same format. # Expected Function Signature ```python def is_reservation_valid(existing_reservations: list, new_reservation: tuple) -> bool: pass ``` # Input - `existing_reservations`: A list of tuples where each tuple contains two strings representing the start and end times of existing reservations (e.g., `(\'09:00\', \'10:30\')`). The list can be empty. - `new_reservation`: A tuple containing two strings representing the start and end times of the new reservation (e.g., `(\'11:00\', \'12:00\')`). # Output - Returns a boolean value (`True` or `False`) indicating whether the new reservation can be added without overlapping any existing reservations. # Constraints - The reservation times are in a 24-hour format. - End time of a reservation is always greater than the start time. - The function must handle time conflicts accurately to ensure no overlaps. # Example ```python assert is_reservation_valid([(\'09:00\', \'10:30\'), (\'11:00\', \'12:30\')], (\'10:30\', \'11:00\')) == True assert is_reservation_valid([(\'09:00\', \'10:30\'), (\'11:00\', \'12:30\')], (\'10:00\', \'11:00\')) == False assert is_reservation_valid([], (\'10:00\', \'11:00\')) == True assert is_reservation_valid([(\'09:00\', \'10:30\')], (\'10:30\', \'11:00\')) == True assert is_reservation_valid([(\'09:00\', \'10:00\'), (\'10:30\', \'11:30\')], (\'10:00\', \'10:30\')) == True ``` # Notes 1. Ensure the new reservation does not overlap with any of the existing reservations. 2. Consider edge cases where reservations might end exactly when another begins. 3. The function should handle an empty list of existing reservations correctly.","solution":"def is_reservation_valid(existing_reservations, new_reservation): Determine if the new reservation can be added without overlapping any existing reservations. :param existing_reservations: A list of tuples with start and end times. :param new_reservation: A tuple with the start and end times of the new reservation. :return: True if the new reservation does not overlap with existing reservations, False otherwise. new_start, new_end = new_reservation for start, end in existing_reservations: if not (new_end <= start or new_start >= end): return False return True"},{"question":"# Problem Description You are tasked with developing a small library management system that keeps track of book inventory. Each book has a unique ISBN, title, author, and a count of the number of copies available. Your objective is to write a function that helps in updating the book inventory based on various operations such as adding new books, borrowing books, and returning books. # Function to Implement Write a Python class `LibraryInventory` with the following methods: 1. `__init__(self)`: Initializes an empty inventory. 2. `add_book(self, isbn: str, title: str, author: str, copies: int) -> str`: Adds a book to the inventory or updates the number of copies if the book already exists. * If a new book is added, return: \\"Book added: `<title>` by `<author>` with `<copies>` copies.\\" * If an existing book\'s copies are updated, return: \\"Updated book: `<title>` now has `<copies>` copies.\\" 3. `borrow_book(self, isbn: str) -> str`: Decreases the count of available copies if the book exists and there are available copies, otherwise return an appropriate message. * If the borrow is successful, return: \\"Borrowed book: `<title>`.\\" * If the book does not exist, return: \\"Error: Book not found.\\" * If no copies are available, return: \\"Error: No copies available.\\" 4. `return_book(self, isbn: str) -> str`: Increases the count of available copies if the book exists, otherwise return an appropriate message. * If the return is successful, return: \\"Returned book: `<title>`.\\" * If the book does not exist, return: \\"Error: Book not found.\\" # Example ```python class LibraryInventory: def __init__(self): # Your implementation here def add_book(self, isbn: str, title: str, author: str, copies: int) -> str: # Your implementation here def borrow_book(self, isbn: str) -> str: # Your implementation here def return_book(self, isbn: str) -> str: # Your implementation here # Example Usage library = LibraryInventory() print(library.add_book(\\"12345\\", \\"Python Programming\\", \\"John Doe\\", 5)) # Expected: \\"Book added: Python Programming by John Doe with 5 copies.\\" print(library.borrow_book(\\"12345\\")) # Expected: \\"Borrowed book: Python Programming.\\" print(library.return_book(\\"12345\\")) # Expected: \\"Returned book: Python Programming.\\" print(library.borrow_book(\\"67890\\")) # Expected: \\"Error: Book not found.\\" print(library.add_book(\\"12345\\", \\"Python Programming\\", \\"John Doe\\", 3)) # Expected: \\"Updated book: Python Programming now has 3 copies.\\" ``` # Input - `isbn` (str): The unique ISBN number of the book. - `title` (str): The title of the book. - `author` (str): The author of the book. - `copies` (int): The number of copies available. # Output - For `add_book` method: Return a string message indicating whether a new book was added or the copies were updated. - For `borrow_book` method: Return a string message indicating the success or failure of borrowing the book. - For `return_book` method: Return a string message indicating the success or failure of returning the book. # Constraints - Assume ISBN, title, and author are always provided as non-empty strings. - Number of copies (`copies`) will always be a positive integer when adding a book. - The class should effectively manage the inventory operations in an efficient way.","solution":"class LibraryInventory: def __init__(self): # Initialize an empty inventory dictionary self.inventory = {} def add_book(self, isbn: str, title: str, author: str, copies: int) -> str: # Check if the book already exists in the inventory if isbn in self.inventory: # Update the number of copies self.inventory[isbn][\'copies\'] += copies return f\\"Updated book: {title} now has {self.inventory[isbn][\'copies\']} copies.\\" else: # Add a new book to the inventory self.inventory[isbn] = {\'title\': title, \'author\': author, \'copies\': copies} return f\\"Book added: {title} by {author} with {copies} copies.\\" def borrow_book(self, isbn: str) -> str: # Check if the book exists in the inventory if isbn not in self.inventory: return \\"Error: Book not found.\\" # Check if there are copies available to borrow if self.inventory[isbn][\'copies\'] > 0: self.inventory[isbn][\'copies\'] -= 1 return f\\"Borrowed book: {self.inventory[isbn][\'title\']}.\\" else: return \\"Error: No copies available.\\" def return_book(self, isbn: str) -> str: # Check if the book exists in the inventory if isbn not in self.inventory: return \\"Error: Book not found.\\" # Return the book (increase the count of available copies) self.inventory[isbn][\'copies\'] += 1 return f\\"Returned book: {self.inventory[isbn][\'title\']}.\\""},{"question":"# Problem Statement You are required to implement a function that converts a given number into its corresponding Excel column name. In Excel, column names are represented by letters: A, B, C, ..., Z, AA, AB, and so on. # Functional Requirements Implement a function `number_to_excel_column(n: int) -> str` that: - Converts an integer into its respective Excel column name. - Takes the following parameter: * `n` (int): The column number, starting from 1. # Constraints - The input parameter `n` will be a positive integer between 1 and 2,147,483,647 (inclusive). # Example ```python from typing import List def number_to_excel_column(n: int) -> str: result = [] while n > 0: n -= 1 result.append(chr(n % 26 + ord(\'A\'))) n //= 26 return \'\'.join(result[::-1]) # Test cases print(number_to_excel_column(1)) # Output: \'A\' print(number_to_excel_column(28)) # Output: \'AB\' print(number_to_excel_column(701)) # Output: \'ZY\' print(number_to_excel_column(702)) # Output: \'ZZ\' print(number_to_excel_column(703)) # Output: \'AAA\' print(number_to_excel_column(2147483647)) # Output: \'FXSHRXW\' ``` # Your Task Implement the `number_to_excel_column` function according to the specifications above. Use the provided test cases to verify your implementation. Ensure that the function correctly maps positive integers to their corresponding Excel column names.","solution":"def number_to_excel_column(n: int) -> str: result = [] while n > 0: n -= 1 # Decrement n because Excel columns are 1-based result.append(chr(n % 26 + ord(\'A\'))) # Get the current letter n //= 26 # Move on to the next significant place return \'\'.join(result[::-1]) # Reverse the result to get the correct column name"},{"question":"# Problem Statement You are given a list of integers. Your task is to group the integers by their parity and order the result such that all even numbers appear before any odd numbers. The order of the numbers within each group (even and odd) should remain the same as in the original list. # Function Signature ```python def group_by_parity(nums: list[int]) -> list[int]: pass ``` # Input - A list of integers `nums` where: - `1 <= len(nums) <= 10^5` - `-10^9 <= nums[i] <= 10^9` # Output - A list of integers where all even numbers appear before any odd numbers, while maintaining the original relative order of even and odd numbers separately. # Example ```python assert group_by_parity([1, 2, 3, 4]) == [2, 4, 1, 3] assert group_by_parity([7, 5, 6, 8, 9]) == [6, 8, 7, 5, 9] assert group_by_parity([2, 4, 6]) == [2, 4, 6] assert group_by_parity([1, 3, 5]) == [1, 3, 5] ``` # Constraints - The solution should perform in O(n) time complexity, where n is the length of the input list. - Extra space usage should be minimized, ideally O(1) apart from the space required for the output. # Context This problem tests your ability to manipulate and reorder lists according to specified criteria. Such skills are essential in various areas of software development including data processing, sorting algorithms, and list comprehensions. # Example Execution ```python group_by_parity([1, 2, 3, 4]) # Output: [2, 4, 1, 3] group_by_parity([7, 5, 6, 8, 9]) # Output: [6, 8, 7, 5, 9] ```","solution":"def group_by_parity(nums: list[int]) -> list[int]: Groups integers by their parity with all even numbers appearing before odd ones. Parameters: nums (list[int]): A list of integers. Returns: list[int]: A list where all even numbers come before any odd numbers, maintaining original order within parity groups. even_numbers = [num for num in nums if num % 2 == 0] odd_numbers = [num for num in nums if num % 2 != 0] return even_numbers + odd_numbers"},{"question":"# Question: You are tasked with implementing a simplified in-memory database. The database should support basic CRUD operations and also maintain counts of occurrences of each value stored in the database. The database should perform efficiently and support the following operations: - `set(key, value)`: Store the `value` at the specified `key`. If the `key` already exists, update the value. - `get(key)`: Retrieve the value associated with the specified `key`. If the `key` is not found, return `None`. - `delete(key)`: Remove the key and its associated value from the database if it exists. - `count(value)`: Return the number of keys that have the specified `value`. **Requirements**: - Implement a class `InMemoryDatabase` that supports the above operations. - Ensure the `count` operation runs in O(1) time complexity. - The database must be able to handle a large number of operations efficiently. **Input/Output**: - `set(key: str, value: int) -> None` - `get(key: str) -> int | None` - `delete(key: str) -> None` - `count(value: int) -> int` **Constraints**: - The number of `set`, `get`, `delete`, and `count` operations will be in the range [1, 10^5]. - The values will be in the range of [1, 10^5]. **Example**: ```python db = InMemoryDatabase() db.set(\'a\', 1) db.set(\'b\', 2) db.set(\'c\', 1) print(db.get(\'a\')) # returns 1 print(db.count(1)) # returns 2 (keys \'a\' and \'c\') db.delete(\'a\') print(db.count(1)) # returns 1 (only key \'c\') print(db.get(\'a\')) # returns None db.set(\'b\', 1) print(db.count(1)) # returns 2 (keys \'b\' and \'c\') ``` Your implementation should ensure thread safety if multiple threads access the database simultaneously.","solution":"class InMemoryDatabase: def __init__(self): self.data = {} self.value_counts = {} def _update_counts(self, key, old_value, new_value): Helper method to update the value count dictionary. if old_value is not None: if self.value_counts[old_value] == 1: del self.value_counts[old_value] else: self.value_counts[old_value] -= 1 if new_value is not None: if new_value in self.value_counts: self.value_counts[new_value] += 1 else: self.value_counts[new_value] = 1 def set(self, key, value): if key in self.data: old_value = self.data[key] self.data[key] = value self._update_counts(key, old_value, value) else: self.data[key] = value self._update_counts(key, None, value) def get(self, key): return self.data.get(key) def delete(self, key): if key in self.data: old_value = self.data.pop(key) self._update_counts(key, old_value, None) def count(self, value): return self.value_counts.get(value, 0)"},{"question":"# Coding Assessment Question Problem Statement You are tasked with writing a function that checks whether a given positive integer number is a \\"Special Number.\\" A \\"Special Number\\" is defined as a number that is equal to the sum of its digits each raised to the power of their respective position (1-indexed) in the number. For example, for the number `135`: ``` 1^1 + 3^2 + 5^3 = 1 + 9 + 125 = 135 ``` Therefore, `135` is a Special Number. Function Signature ```python def is_special_number(input_num: int) -> bool: pass ``` Input - A single integer `input_num` (`1 <= input_num <= 10^6`). Output - A boolean value `True` if the number is a \\"Special Number\\", otherwise `False`. Constraints - The input number will always be a positive integer within the specified range. Example Usage ```python assert is_special_number(89) == True # 8^1 + 9^2 = 8 + 81 = 89 assert is_special_number(135) == True # 1^1 + 3^2 + 5^3 = 1 + 9 + 125 = 135 assert is_special_number(10) == False # 1^1 + 0^2 = 1 + 0 = 1 assert is_special_number(1) == True # 1^1 = 1 assert is_special_number(407) == False # 4^1 + 0^2 + 7^3 = 4 + 0 + 343 = 347 ``` Performance Requirements The function should have a time complexity of O(d), where d is the number of digits in the input number, and a space complexity of O(1).","solution":"def is_special_number(input_num: int) -> bool: Checks if the input number is a \\"Special Number\\". A \\"Special Number\\" is defined as a number that is equal to the sum of its digits each raised to the power of their respective position (1-indexed). Args: input_num (int): The number to check. Returns: bool: True if the number is a \\"Special Number\\", False otherwise. input_str = str(input_num) total = sum(int(digit) ** (index + 1) for index, digit in enumerate(input_str)) return total == input_num"},{"question":"# Scenario You are developing an image processing application that needs to apply multiple filters to an image. The filters that can be applied include grayscale, blur, and edge detection. Each filter has to be applied in a specific sequence depending on user input. The application must be able to handle large images efficiently and should not crash due to memory constraints. # Task Implement the function `apply_filters` that processes an image by applying a series of filters in a specified order. Your implementation should: 1. Support the three mentioned filters: grayscale, blur, and edge detection. 2. Apply the filters in the order specified by the user. 3. Handle both large and small images seamlessly. # Function Signature ```python def apply_filters(image_path: str, filters: List[str]) -> Image: pass ``` # Input * `image_path` (str): The file path to the input image. * `filters` (List[str]): A list of filters to apply in the specified order. Each filter will be one of: `\\"grayscale\\"`, `\\"blur\\"`, `\\"edge_detection\\"`. # Output * `Image`: The processed image after applying all the filters in the specified order. # Constraints * `image_path` will be a valid file path to an image file. * `filters` will be a non-empty list of valid filter names. * The image file can be of any common format (e.g., JPG, PNG). * Memory usage should be optimized to handle large images efficiently. # Example ```python from PIL import Image # Assuming the image file path is correct and points to a valid image result_image = apply_filters(\\"input_image.jpg\\", [\\"grayscale\\", \\"blur\\", \\"edge_detection\\"]) result_image.show() ``` # Notes * Use appropriate libraries (e.g., PIL/Pillow) for image processing. * Each filter should be implemented as a separate function and called in sequence as specified in `filters`. * Raise a `ValueError` if an invalid filter name is provided. * Provide meaningful error messages for any other exceptions encountered. * Ensure your implementation is efficient and can handle large images without excessive memory usage.","solution":"from PIL import Image, ImageFilter import os def apply_filters(image_path: str, filters: list) -> Image: Applies a series of filters to an image in a specified order. Parameters: - image_path (str): The file path to the input image. - filters (list): A list of filters to apply in the specified order. Each filter will be one of: \\"grayscale\\", \\"blur\\", \\"edge_detection\\". Returns: - Image: The processed image after applying all the filters in the specified order. valid_filters = {\\"grayscale\\", \\"blur\\", \\"edge_detection\\"} # Check if all filters are valid for f in filters: if f not in valid_filters: raise ValueError(f\\"Invalid filter: {f}\\") try: image = Image.open(image_path) except FileNotFoundError: raise FileNotFoundError(f\\"No such file: {image_path}\\") except Exception as e: raise Exception(f\\"Error loading image from {image_path}: {str(e)}\\") for f in filters: if f == \\"grayscale\\": image = image.convert(\\"L\\") elif f == \\"blur\\": image = image.filter(ImageFilter.BLUR) elif f == \\"edge_detection\\": image = image.filter(ImageFilter.FIND_EDGES) return image"},{"question":"# Scenario You are developing a feature for a search engine where you need to normalize the query frequencies. These frequencies are stored in a list. To standardize the data, you will use min-max normalization, which scales the frequencies so that they fall within a specified range (typically between 0 and 1). # Task Implement the function `min_max_normalize(frequencies: list, min_value: float, max_value: float) -> list` that applies min-max normalization to the given list of query frequencies. # Function Signature ```python def min_max_normalize(frequencies: list, min_value: float, max_value: float) -> list: pass ``` # Input: * `frequencies` (list): A list of non-negative floating-point numbers representing query frequencies. * `min_value` (float): The minimum value of the desired normalized range. * `max_value` (float): The maximum value of the desired normalized range. # Output: * Returns a list of normalized frequencies, where the normalization is performed using the min-max scaling technique. # Constraints: - The `frequencies` list can have 0 or more elements. - Each element in the `frequencies` list is a non-negative float. - `min_value` and `max_value` are floats where `min_value < max_value`. # Examples: 1. Input: `frequencies = [100, 200, 300, 400]`, `min_value = 0`, `max_value = 1` Output: `[0.0, 0.3333333333333333, 0.6666666666666666, 1.0]` 2. Input: `frequencies = [5, 10, 15]`, `min_value = -1`, `max_value = 1` Output: `[-1.0, 0.0, 1.0]` # Note: The formula for min-max normalization is given by: [ text{normalized_value} = min_value + frac{(text{frequency} - min(frequencies)) times (max_value - min_value)}{max(frequencies) - min(frequencies)} ] This technique ensures that the normalized values are scaled within the specified range `[min_value, max_value]`. Apply this method efficiently to handle lists with a large number of frequencies typically seen in real-time search engine data processing.","solution":"def min_max_normalize(frequencies: list, min_value: float, max_value: float) -> list: Normalize the given list of query frequencies using min-max normalization. Params: - frequencies (list): A list of non-negative floating-point numbers representing query frequencies. - min_value (float): The minimum value of the desired normalized range. - max_value (float): The maximum value of the desired normalized range. Returns: - A list of normalized frequencies, scaled within the range [min_value, max_value]. if not frequencies: return [] min_freq = min(frequencies) max_freq = max(frequencies) if min_freq == max_freq: # All frequencies are the same, return mid point of min_value and max_value for all return [min_value + (max_value - min_value) / 2] * len(frequencies) return [ min_value + ((freq - min_freq) * (max_value - min_value) / (max_freq - min_freq)) for freq in frequencies ]"},{"question":"# Reverse Nodes in k-Group Coding Assessment Question Context As part of the team managing a large-scale data processing pipeline, your team often deals with linked lists requiring various rearrangements. One common operation is reversing nodes in groups to ensure data integrity and optimize memory usage during batch processing. Description Write a function `reverse_k_group(head: ListNode | None, k: int) -> ListNode | None` that reverses the nodes of a linked list in groups of size `k` and returns the modified list. Each node consists of: ```python @dataclass class ListNode: value: int = 0 next: ListNode | None = None ``` # Input - A reference to the head of the linked list. - An integer `k` representing the group size for reversal. # Output - A reference to the head of the modified linked list where nodes are reversed in groups of size `k`. # Constraints - The given linked list may contain zero or more nodes. - The number of nodes in the list and `k` are within the range `[1, 1000]`. - If the number of nodes is not a multiple of `k`, the remaining nodes should remain as is. # Example ```python # Given the following linked list: 1 -> 2 -> 3 -> 4 -> 5 head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) # After calling reverse_k_group with k = 2 new_head = reverse_k_group(head, 2) # The modified list should be: 2 -> 1 -> 4 -> 3 -> 5 # After calling reverse_k_group with k = 3 new_head = reverse_k_group(head, 3) # The modified list should be: 3 -> 2 -> 1 -> 4 -> 5 ``` # Notes - Ensure your function runs efficiently and handles edge cases such as lists with fewer than `k` nodes or exactly `k` nodes. - You should not use extra space for another list; modify the list in place with O(1) extra memory. Implement the `reverse_k_group` function to achieve the above requirements.","solution":"from typing import Optional from dataclasses import dataclass @dataclass class ListNode: value: int = 0 next: Optional[\'ListNode\'] = None def reverse_k_group(head: Optional[ListNode], k: int) -> Optional[ListNode]: def reverse_list(start: ListNode, end: ListNode) -> ListNode: prev, curr = None, start while curr != end: nxt = curr.next curr.next = prev prev = curr curr = nxt return prev dummy = ListNode(0) dummy.next = head group_prev = dummy while True: kth = group_prev for _ in range(k): kth = kth.next if not kth: return dummy.next group_next = kth.next prev = group_prev.next kth.next = None group_prev.next = reverse_list(prev, None) prev.next = group_next group_prev = prev return dummy.next"},{"question":"# Question: Find the Second Maximum Number in a List You need to implement a function that finds the second maximum number in a list of integers. Your function should handle input validation and work efficiently for larger lists. Function Definition ```python def second_maximum(numbers: list) -> int: Finds the second maximum number in a list of integers. Arguments: numbers -- a list containing integers Returns: An integer which is the second maximum number in the list. ``` Input Format - A list of integers, `numbers`, which may have duplicates. Output Format - An integer that is the second maximum number in the given list. Constraints - The list should have at least two distinct integers. - The function should raise a `TypeError` if the input is not a list or if the list contains non-integer elements. - The function should raise a `ValueError` if the list contains fewer than two distinct integers. # Example Input/Output ```python second_maximum([4, 2, 5, 1, 5]) # Output: 4 second_maximum([10, 20, 20, 5, 3]) # Output: 10 second_maximum([1, 1, 2, 2, 3, 2]) # Output: 2 second_maximum([7, 7, -1, -1, -2]) # Output: -1 second_maximum([100, 50, 50, 49, -1]) # Output: 50 ``` Additional Notes - Ensure to handle edge cases such as very large integers or very small (negative) integers. - You should not use any built-in functions or libraries that directly find the second maximum number. - Implement logic manually to find the second maximum integer in the list.","solution":"def second_maximum(numbers: list) -> int: Finds the second maximum number in a list of integers. Arguments: numbers -- a list containing integers Returns: An integer which is the second maximum number in the list. Raises: TypeError -- if the input is not a list or contains non-integer elements ValueError -- if there are less than two distinct integers in the input list if not isinstance(numbers, list): raise TypeError(\\"Input must be a list.\\") for number in numbers: if not isinstance(number, int): raise TypeError(\\"All elements in the list must be integers.\\") distinct_numbers = set(numbers) if len(distinct_numbers) < 2: raise ValueError(\\"The list must contain at least two distinct integers.\\") first_max = second_max = float(\'-inf\') for number in distinct_numbers: if number > first_max: second_max = first_max first_max = number elif number > second_max: second_max = number return second_max"},{"question":"# Scenario You are building a string processing utility in Python that involves searching and modifying substrings. One of the functionalities includes replacing a specific substring within a given string with another substring. # Objective Write a Python function named `replace_substring` that accepts three arguments: the main string, the substring to be replaced, and the replacement substring. The function should return a new string where all occurrences of the target substring are replaced by the replacement substring. # Function Signature ```python def replace_substring(main_string: str, target: str, replacement: str) -> str: pass ``` # Input 1. `main_string` (str): The original string in which the replacements are to be made. 2. `target` (str): The substring that needs to be replaced. 3. `replacement` (str): The substring that will replace the target substring. # Output * Returns a new string with all occurrences of the target substring replaced by the replacement substring. # Constraints * The `main_string`, `target`, and `replacement` strings must contain one or more characters. * If the `target` is an empty string, raise a ValueError. * If any of the inputs are not strings, raise a TypeError. # Requirements 1. The function should raise a ValueError if the `target` is an empty string. 2. The function should raise a TypeError if any of the inputs are not strings. # Examples ```python >>> replace_substring(\\"hello world\\", \\"world\\", \\"there\\") \'hello there\' >>> replace_substring(\\"hello world world\\", \\"world\\", \\"there\\") \'hello there there\' >>> replace_substring(\\"foo bar foo\\", \\"foo\\", \\"baz\\") \'baz bar baz\' >>> replace_substring(\\"abc def abc\\", \\"abc\\", \\"xyz\\") \'xyz def xyz\' >>> replace_substring(\\"hello\\", \\"\\", \\"there\\") Traceback (most recent call last): ... ValueError: The target substring must not be empty >>> replace_substring(123, \\"1\\", \\"one\\") Traceback (most recent call last): ... TypeError: Inputs must be strings >>> replace_substring(\\"hello world\\", \\"world\\", 42) Traceback (most recent call last): ... TypeError: Inputs must be strings ``` # Notes * The solution should be efficient with the capability to handle large input strings. * Handling of edge cases should be clearly thought out and documented. Assumptions and implementation details should be well-documented in the code.","solution":"def replace_substring(main_string: str, target: str, replacement: str) -> str: Replace all occurrences of \'target\' substring in \'main_string\' with \'replacement\' substring. Parameters: main_string (str): The original string to perform replacements on. target (str): The substring that needs to be replaced. replacement (str): The substring to replace the target with. Returns: str: A string with all occurrences of the target substring replaced by the replacement substring. Raises: ValueError: If the target substring is empty. TypeError: If any of the inputs are not strings. if not isinstance(main_string, str) or not isinstance(target, str) or not isinstance(replacement, str): raise TypeError(\\"Inputs must be strings\\") if target == \\"\\": raise ValueError(\\"The target substring must not be empty\\") return main_string.replace(target, replacement)"},{"question":"# Problem Statement Objective Write a function in language M that takes a positive integer n and returns the n-th number in the Fibonacci sequence. The Fibonacci sequence is defined as follows: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n > 1 Motivation This task evaluates your understanding of recursion and iterative processes, as well as your ability to implement and optimize a standard algorithm in a specified programming language. # Requirements 1. **Input**: A single positive integer n (0 ≤ n ≤ 30), specifying the position in the Fibonacci sequence. 2. **Output**: The n-th Fibonacci number. # Constraints - The function must handle input within the defined range (0 to 30) efficiently. - Consider both time and space complexity in your solution. # Performance - The implementation should return the result within a reasonable time frame (e.g., less than a second for the maximum input value). # Specification Example If you were to solve this in Python, a valid function might resemble: ```python def fibonacci(n): if n == 0: return 0 elif n == 1: return 1 else: a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b ``` Ensure that your solution abides by the constraints and runs successfully in language M. Notes - You can use either a recursive or iterative approach, but aim for the most efficient solution given the constraints. - Consider edge cases, such as the smallest and largest possible values of n, to ensure your function handles all valid inputs correctly.","solution":"def fibonacci(n): Returns the nth Fibonacci number. Parameters: n (int): The position in the Fibonacci sequence (0 ≤ n ≤ 30). Returns: int: The nth Fibonacci number. if n == 0: return 0 elif n == 1: return 1 else: a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Matrix Rotation Background Matrix rotation is a common operation in image processing and computer graphics. Given an (n times n) matrix, rotating the matrix 90 degrees clockwise involves reassigning the position of elements to achieve a new orientation. Task Write a function `rotate_matrix` that takes an (n times n) 2D list (matrix) and rotates it 90 degrees clockwise in place. Implement the function signature: ```python def rotate_matrix(matrix: List[List[int]]) -> None: pass ``` Constraints * The function should raise a `ValueError` if the input matrix is not square. * Your solution should modify the matrix in place and not use any extra (n times n) space. Examples ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix1) print(matrix1) # Output: [[7,4,1], [8,5,2], [9,6,3]] matrix2 = [ [1, 2], [3, 4] ] rotate_matrix(matrix2) print(matrix2) # Output: [[3,1], [4,2]] ``` Hints * Consider how you might swap elements in place by breaking down the rotation into layers. * Remember that rotating an (n times n) matrix involves moving each layer of the matrix.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the given n x n matrix 90 degrees clockwise in place. Raises ValueError if matrix is not square. n = len(matrix) for row in matrix: if len(row) != n: raise ValueError(\\"Input matrix must be square\\") for i in range(n // 2): for j in range(i, n - i - 1): # Perform the rotation of 4 elements temp = matrix[i][j] matrix[i][j] = matrix[n - j - 1][i] matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1] matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1] matrix[j][n - i - 1] = temp"},{"question":"# Question: You are implementing a function to analyze patterns in a list of sales figures from a store. Your task is to write a Python function `is_boom_bust_pattern` that returns `True` if the sales figures exhibit a \\"boom-bust\\" pattern and `False` otherwise. A boom-bust pattern is defined as a sequence where each element alternates between strictly increasing and strictly decreasing. Function Signature ```python def is_boom_bust_pattern(sales: list[int]) -> bool: ``` # Input - `sales`: A list of integers representing daily sales figures. # Output - Returns `True` if the sales figures follow a boom-bust pattern. - Returns `False` otherwise. # Constraints - All elements in the list `sales` are integers. - The list can be empty or have up to `10^5` elements. # Examples ```python assert is_boom_bust_pattern([1, 3, 2, 4, 3, 5]) == True assert is_boom_bust_pattern([1, 2, 2, 4]) == False assert is_boom_bust_pattern([10, 5, 7, 3, 6]) == True assert is_boom_bust_pattern([8, 4, 6, 6, 2]) == False assert is_boom_bust_pattern([]) == True ``` # Requirements 1. Ensure the function handles an empty list gracefully. 2. Handle input validation to ensure the elements are integers; raise a `ValueError` for invalid inputs. 3. Optimize the function to efficiently handle large lists up to the size constraint.","solution":"def is_boom_bust_pattern(sales): Returns True if the sales figures follow a boom-bust pattern, otherwise False. A boom-bust pattern is defined as a sequence where each element alternates between strictly increasing and strictly decreasing. if not sales: return True for i in range(1, len(sales) - 1): if not ((sales[i-1] < sales[i] and sales[i] > sales[i+1]) or (sales[i-1] > sales[i] and sales[i] < sales[i+1])): return False return True"},{"question":"# Sudoku Solver You are tasked with implementing a Sudoku solver that utilizes backtracking to fill out a 9x9 Sudoku grid. The goal is to demonstrate your understanding of recursion, backtracking algorithms, and array manipulations. # Functional Requirements: 1. **Sudoku Grid**: Implement a function that takes a 9x9 grid (2D list) representing a Sudoku puzzle. 2. **Solving**: The function should fill the grid with numbers (1-9) in such a way that each row, column, and 3x3 sub-grid contains all of the digits from 1 to 9 exactly once. 3. **Validation**: Ensure that the grid respects the constraints of Sudoku at each step of the solution process. # Input and Output Formats: - **Input**: 1. A 9x9 grid represented as a 2D list of integers, where empty cells are represented by 0. - **Output**: 1. A function that fills the input grid in-place with the solution. 2. If the puzzle is unsolvable, the grid should remain unchanged. # Constraints: 1. Utilize a backtracking approach to efficiently solve the puzzle. 2. Ensure that the solution is found by filling one number at a time and backtracking when an invalid number placement is encountered. 3. Validate number placement against existing row, column, and sub-grid numbers before placing it in the cell. # Performance Requirements: 1. Efficiently find solutions using backtracking, minimizing unnecessary computations. 2. Ensure memory usage adheres to recursion depth limits and doesn\'t cause stack overflow. # Implementation Scenario: You are required to implement the function `solve_sudoku(grid: List[List[int]]) -> bool`: ```python from typing import List def solve_sudoku(grid: List[List[int]]) -> bool: # Helper function to check if a number can be placed at (row, col) def is_valid(num, row, col): for i in range(9): if grid[row][i] == num or grid[i][col] == num: return False start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(start_row, start_row + 3): for j in range(start_col, start_col + 3): if grid[i][j] == num: return False return True # Helper function to solve the sudoku using backtracking def backtrack(): for row in range(9): for col in range(9): if grid[row][col] == 0: for num in range(1, 10): if is_valid(num, row, col): grid[row][col] = num if backtrack(): return True grid[row][col] = 0 return False return True # Initiating the backtracking process return backtrack() ``` *Note*: The solution function should fill the input grid in-place and return a boolean indicating whether a solution was found. Ensure you test the function with various Sudoku puzzles to validate its correctness and efficiency.","solution":"from typing import List def solve_sudoku(grid: List[List[int]]) -> bool: def is_valid(num, row, col): for i in range(9): if grid[row][i] == num or grid[i][col] == num: return False start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(start_row, start_row + 3): for j in range(start_col, start_col + 3): if grid[i][j] == num: return False return True def backtrack(): for row in range(9): for col in range(9): if grid[row][col] == 0: for num in range(1, 10): if is_valid(num, row, col): grid[row][col] = num if backtrack(): return True grid[row][col] = 0 return False return True return backtrack()"},{"question":"**Problem Statement**: Given a string `s`, write a function that finds the longest substring with all unique characters. Your task will be to implement both a sliding window technique and a brute-force method to solve this problem. Ensure to handle common edge cases and error conditions properly. # Function Signatures: ```python def longest_unique_substring_sliding_window(s: str) -> str: pass def longest_unique_substring_brute_force(s: str) -> str: pass ``` # Input: The function `longest_unique_substring_sliding_window` and `longest_unique_substring_brute_force` should accept the following input: - `s` is a string. # Output: - Both functions should return a string, representing the longest substring with all unique characters. - If the input is not a string, raise a `ValueError` with the message `\\"<function_name>() only accepts string values\\"`. - If the input string is empty, both functions should return an empty string. # Examples: ```python longest_unique_substring_sliding_window(\\"abcabcbb\\") # Expected output: \\"abc\\" longest_unique_substring_brute_force(\\"bbbbb\\") # Expected output: \\"b\\" longest_unique_substring_sliding_window(\\"pwwkew\\") # Expected output: \\"wke\\" longest_unique_substring_brute_force(\\"\\") # Expected output: \\"\\" ``` # Constraints: - Both functions must handle the edge cases and errors as specified. - The sliding window function must run in ( O(n) ) time complexity. - The brute-force function may run in ( O(n^2) ) time complexity where ( n ) is the length of the input string. - The implementation should be efficient in terms of both time and space within the given constraints.","solution":"def longest_unique_substring_sliding_window(s: str) -> str: if not isinstance(s, str): raise ValueError(\\"longest_unique_substring_sliding_window() only accepts string values\\") n = len(s) if n == 0: return \\"\\" char_index_map = {} start = 0 max_length = 0 max_substr = \\"\\" for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end if end - start + 1 > max_length: max_length = end - start + 1 max_substr = s[start:end + 1] return max_substr def longest_unique_substring_brute_force(s: str) -> str: if not isinstance(s, str): raise ValueError(\\"longest_unique_substring_brute_force() only accepts string values\\") n = len(s) if n == 0: return \\"\\" def all_unique(substring: str) -> bool: return len(set(substring)) == len(substring) max_length = 0 max_substr = \\"\\" for i in range(n): for j in range(i + 1, n + 1): if all_unique(s[i:j]) and (j - i) > max_length: max_length = j - i max_substr = s[i:j] return max_substr"},{"question":"# Graph Traversal Algorithms As a navigation system developer, you need to implement a functionality that finds the shortest path between two points in a city represented as a graph. The graph’s nodes represent intersections, and the edges represent the roads connecting these intersections with assigned weights indicating the travel time. Task Write a Python function `find_shortest_path(graph: dict, start: str, end: str) -> list` that finds and returns the shortest path from `start` to `end`. If there\'s no path between the two nodes, return an empty list. # Input - A dictionary `graph` where keys are node names (strings) and values are dictionaries. Each inner dictionary represents the neighboring nodes and the travel time to them (e.g., `{\'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'A\': 1, \'C\': 2}, \'C\': {\'A\': 4, \'B\': 2}}`). - A string `start` representing the starting node. - A string `end` representing the destination node. # Output - A list of nodes representing the shortest path from `start` to `end`, inclusive. If no path exists, return an empty list. # Requirements and Constraints 1. **Algorithm**: Implement Dijkstra\'s algorithm to find the shortest path. 2. **Edge Cases**: - If `start` or `end` does not exist in the graph, return an empty list. - If `start` equals `end`, return a list containing only the start node. - Ensure to handle cases where the graph might be disconnected. # Example: Suppose the input `graph` is: ```python graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'A\': 1, \'C\': 2, \'D\': 5}, \'C\': {\'A\': 4, \'B\': 2, \'D\': 1}, \'D\': {\'B\': 5, \'C\': 1} } start = \'A\' end = \'D\' ``` Your function should return: ```python [\'A\', \'B\', \'C\', \'D\'] ``` If the input `graph` is: ```python graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'A\': 1, \'C\': 2}, \'C\': {\'A\': 4, \'B\': 2}, \'D\': {} } start = \'A\' end = \'D\' ``` Your function should return: ```python [] ``` Implement the function `find_shortest_path` to meet the described requirements and considerations.","solution":"import heapq def find_shortest_path(graph, start, end): Implements Dijkstra\'s algorithm to find the shortest path in a graph. Args: graph: A dictionary representing the graph where the keys are nodes and the values are dictionaries of neighboring nodes with their corresponding weights. start: The starting node. end: The destination node. Returns: A list of nodes representing the shortest path from start to end. If no path exists, returns an empty list. if start not in graph or end not in graph: return [] # Priority queue to store (distance to node, node, path to node) pq = [(0, start, [])] visited = set() while pq: current_distance, current_node, path = heapq.heappop(pq) if current_node in visited: continue # Add the current node to the visited set visited.add(current_node) # Update the path path = path + [current_node] # Check if we have reached the end if current_node == end: return path # Check the neighbors for neighbor, weight in graph[current_node].items(): if neighbor not in visited: heapq.heappush(pq, (current_distance + weight, neighbor, path)) # If the end node was not reached return []"},{"question":"# Graph Connectivity Checker Description You are working on network analysis for a telecommunication company. One of the essential tasks is to determine if a network of connections between nodes (representing relay stations) is fully connected. A network is fully connected if there is a path between any pair of nodes. Task Implement the `is_network_fully_connected` function to check if the given network is fully connected. The network is represented by an adjacency list where each node is connected to zero or more other nodes. Function Signature ```python def is_network_fully_connected(network: dict[int, list[int]]) -> bool: pass ``` Input - `network (dict[int, list[int]])`: A dictionary where keys are node IDs (integers) and values are lists of node IDs that are directly connected to the key node. Output - `bool`: Return `True` if the entire network is fully connected, `False` otherwise. Constraints - Nodes are denoted by non-negative integers. - The graph is undirected, meaning if node `A` is connected to node `B`, then node `B` is also connected to node `A`. - The network may have from 1 to 1000 nodes. You need to implement the logic to traverse the graph and determine if all nodes are reachable from any starting node. Example ```python # Example 1: network = { 0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2] } # All nodes are connected either directly or indirectly print(is_network_fully_connected(network)) # Output: True # Example 2: network = { 0: [1], 1: [0], 2: [3], 3: [2] } # There are two separate groups, {0, 1} and {2, 3} that are not connected to each other print(is_network_fully_connected(network)) # Output: False ``` Note You can use graph traversal algorithms such as Depth-First Search (DFS) or Breadth-First Search (BFS) to solve this problem. Ensure that you account for all nodes in the network and check their connectivity status accurately.","solution":"def is_network_fully_connected(network: dict[int, list[int]]) -> bool: Determine if a network represented by an adjacency list is fully connected. Arguments: network -- adjacency list representing the network Returns: True if network is fully connected, otherwise False if not network: return False # Function to perform BFS def bfs(start_node, network, visited): queue = [start_node] visited.add(start_node) while queue: node = queue.pop(0) for neighbor in network[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) # Keeping track of visited nodes visited = set() # Start BFS from any node (let\'s start from the first node in the dictionary) start_node = next(iter(network)) bfs(start_node, network, visited) # Check if all nodes are visited return len(visited) == len(network)"},{"question":"# Sorting Complex Objects You are required to write a function that takes a list of dictionaries representing employees, sorts them by the specified key in ascending order, and returns a list of their names in the sorted order. Each dictionary contains \'name\', \'age\', and \'salary\'. Function Signature ```python def sort_employees(employees: List[Dict[str, Union[str, int]]], key: str) -> List[str]: ``` Input: - `employees` (List[Dict[str, Union[str, int]]]): A list of dictionaries where each dictionary contains: - \'name\' (str): The name of the employee. - \'age\' (int): The age of the employee. - \'salary\' (int): The salary of the employee. - `key` (str): The key by which to sort the employees. Can be one of \'name\', \'age\', or \'salary\'. Output: - Returns a list of employee names, sorted by the specified key in ascending order. Constraints: - The list of employees will have at most 100 entries. - The \'name\' key will always have a non-empty string. - The \'age\' and \'salary\' keys will always have positive integers. Example: ```python employees = [ {\\"name\\": \\"John\\", \\"age\\": 30, \\"salary\\": 5000}, {\\"name\\": \\"Doe\\", \\"age\\": 22, \\"salary\\": 6000}, {\\"name\\": \\"Jane\\", \\"age\\": 25, \\"salary\\": 7000} ] sort_employees(employees, \\"age\\") ``` This should return: ```python [\'Doe\', \'Jane\', \'John\'] ``` Notes: - You should not modify the input list. - If two employees have the same value for the specified key, maintain their original order relative to each other (stable sorting).","solution":"from typing import List, Dict, Union def sort_employees(employees: List[Dict[str, Union[str, int]]], key: str) -> List[str]: Returns a list of employee names sorted by the specified key. Parameters: employees (list of dict): List of dictionaries each containing \'name\', \'age\', and \'salary\'. key (str): The key by which to sort the employees; can be \'name\', \'age\', or \'salary\'. Returns: list of str: List of sorted employee names. sorted_employees = sorted(employees, key=lambda x: x[key]) return [employee[\'name\'] for employee in sorted_employees]"},{"question":"# Question: Efficient String Compression **Context**: You are working on optimizing data storage and need to implement a custom string compression algorithm without using any built-in compression libraries. The goal is to replace consecutive repeated characters with a single character followed by the count of repetitions. If the compressed string is not shorter than the original, the function should return the original string instead. **Requirements**: 1. Implement a function to compress the given string. 2. The compression should only occur if there are consecutive characters. 3. If the compressed string is not shorter than the original string, return the original string. 4. Handle both uppercase and lowercase alphabetic characters. **Function Signature**: ```python def string_compression(s: str) -> str: pass ``` **Input**: - `s (str)`: The string to be compressed. The length of the string should be between 1 and 1000 characters. **Output**: - Return a compressed string if the compressed version is shorter, otherwise return the original string. **Constraints**: - The string will only contain alphabetical characters (both uppercase and lowercase). **Examples**: ```python >>> string_compression(\\"aabcccccaaa\\") \'a2b1c5a3\' >>> string_compression(\\"abcdef\\") \'abcdef\' >>> string_compression(\\"aabbcc\\") \'aabbcc\' ``` **Hint**: Use a loop to traverse the string and count consecutive characters. Build the compressed string and compare its length to the original string.","solution":"def string_compression(s: str) -> str: if len(s) <= 1: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed.append(s[i-1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Coding Assessment Question Context: You are developing a software to help users manage their schedules by detecting and resolving conflicts between their appointments. The goal is to ensure that no two appointments overlap. Task: Write a Python function `resolve_conflicts(appointments: list[tuple[int, int]]) -> list[tuple[int, int]]` that takes a list of appointment time intervals and returns a new list with conflicts resolved by removing the minimum number of intervals. Implementation Steps: 1. Sort the appointments based on their start times. 2. Iterate through the sorted list to identify overlapping intervals. 3. Remove the minimum number of overlapping intervals to ensure no two intervals overlap. 4. Return the list of non-overlapping intervals. Input Format: - `appointments`: A list of tuples, where each tuple consists of two integers representing the start and end times of an appointment. The end time is always greater than the start time. Output Format: - Return a list of tuples representing the non-overlapping intervals. Constraints: - Assume each appointment interval is non-singleton, with both start and end times being integers within the range 0 <= start < end <= 10^9. - The input list has at most 1000 intervals. Performance Requirements: - The solution should have a time complexity of O(n log n) due to sorting, and a space complexity of O(n), where n is the number of appointment intervals. Example: Suppose `appointments` is given as: ```python [(1, 3), (2, 4), (3, 5), (6, 8)] ``` Calling `resolve_conflicts(appointments)` should yield: ```python [(1, 3), (3, 5), (6, 8)] ``` (Note: The exact list of intervals returned may vary as long as the output list contains the maximum number of non-overlapping intervals.) Note: - Ensure that the appointments in the output list are sorted by their start times. - If there are multiple valid outputs, any of them are acceptable.","solution":"def resolve_conflicts(appointments): Resolves conflicts in a list of appointment intervals by removing the minimum number of intervals such that no two intervals overlap. Returns a list of non-overlapping intervals sorted by start time. :param appointments: List of tuples (start, end) :return: List of tuples (start, end) representing non-overlapping intervals if not appointments: return [] # Sort appointments by end times appointments.sort(key=lambda x: x[1]) # Initialize the list of non-overlapping appointments non_overlapping = [appointments[0]] # Iterate through sorted appointments to find non-overlapping intervals for i in range(1, len(appointments)): last_end_time = non_overlapping[-1][1] current_start, current_end = appointments[i] if current_start >= last_end_time: non_overlapping.append((current_start, current_end)) return non_overlapping"},{"question":"# Character Replacement Counter Given a string `s` and an integer `k`, write a function that returns the length of the longest substring that can be obtained by replacing at most `k` characters in the original string with any other characters to create a substring with all same characters. # Requirements 1. Implement the function `character_replacement` that takes a string `s` and an integer `k` as input and returns an integer, which is the length of the longest such substring. 2. The solution should be efficient with respect to both time and space complexity. 3. Provide solutions that operate within practical bounds for input length and value of `k`. # Input and Output Specifications * **Input**: A string `s` consisting of uppercase English letters and an integer `k` (`0 <= k <= len(s)`). * **Output**: An integer representing the length of the longest substring achievable. # Function Signature ```python def character_replacement(s: str, k: int) -> int: ``` # Constraints * The length of the input string `s` will be between 1 and 10^4. * The input string contains only uppercase English letters (A-Z). * The value of `k` is guaranteed to be non-negative and not greater than the length of `s`. # Examples 1. `character_replacement(\\"ABAB\\", 2)` - Expected Output: `4` (Replace all ‘B’s with ‘A’s making it \\"AAAA\\" or all ‘A’s with ‘B’s making it \\"BBBB\\") 2. `character_replacement(\\"AABABBA\\", 1)` - Expected Output: `4` (Replace one \'B\' with \'A\' to get \\"AAAA\\" or one \'A\' with \'B\' to get \\"BBBB\\") 3. `character_replacement(\\"ABAA\\", 0)` - Expected Output: `2` (Since `k=0`, no replacements are allowed, so the longest substring with the same character is \\"AA\\") 4. `character_replacement(\\"ABCDE\\", 2)` - Expected Output: `3` (For example, replace two characters to make either \\"AAA\\", \\"BBB\\", \\"CCC\\", \\"DDD\\" or \\"EEE\\") # Instructions 1. Implement the function `character_replacement` as specified. 2. Ensure the function handles the provided examples and additional edge cases gracefully. 3. Optimize the function to work within acceptable time complexity, especially for larger input strings.","solution":"def character_replacement(s: str, k: int) -> int: max_freq = 0 count = {} left = 0 max_length = 0 for right in range(len(s)): count[s[right]] = count.get(s[right], 0) + 1 max_freq = max(max_freq, count[s[right]]) while (right - left + 1) - max_freq > k: count[s[left]] -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"Rotate a Matrix by 90 Degrees Given an NxN matrix represented as a list of lists, write a function `rotate_matrix(matrix: list[list[int]]) -> None` to rotate the matrix by 90 degrees in a clockwise direction in-place. # Input * **matrix**: A list of lists, where each inner list is of the same length as the number of inner lists (NxN matrix). # Output * The function returns `None`; the matrix should be modified in-place to represent the rotated matrix. # Constraints * You should not use any extra space; modify the matrix in-place. * The length of the inner lists and the number of inner lists (both N) are between 1 and 100. # Examples ```python def rotate_matrix(matrix: list[list[int]]) -> None: # Your code here. matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix1) print(matrix1) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] matrix2 = [ [1, 2], [3, 4] ] rotate_matrix(matrix2) print(matrix2) # Output: # [ # [3, 1], # [4, 2] # ] ``` # Guidelines * Ensure the solution modifies the original matrix and does not create a new matrix. * Consider edge cases like a 1x1 matrix or lists with very few elements. * Make efficient use of nested loops or appropriate algorithms to rotate the matrix in-place.","solution":"def rotate_matrix(matrix): Rotates an NxN matrix by 90 degrees clockwise in-place. Args: matrix (list of list of int): NxN matrix to be rotated. Returns: None: The function modifies the matrix in-place. n = len(matrix) # Perform the rotation in layers for layer in range(n // 2): first = layer last = n - 1 - layer for i in range(first, last): # Offset is used to keep track of the position in the layer offset = i - first # Save the top element top = matrix[first][i] # Move left element to top matrix[first][i] = matrix[last - offset][first] # Move bottom element to left matrix[last - offset][first] = matrix[last][last - offset] # Move right element to bottom matrix[last][last - offset] = matrix[i][last] # Move saved top element to right matrix[i][last] = top"},{"question":"# Secure String Match You have been approached by a renowned technology firm that requires a secure method to match encrypted strings. The company uses a proprietary encryption scheme where each character in the string is shifted forward by a fixed, but unknown number of positions in the ASCII table. They need you to develop a program that can determine if two encrypted strings are a match, accounting for this fixed shift. **Requirements**: 1. Implement a function that initializes the system with a specific shift value. 2. Implement a function to encrypt a given string using the initialized shift value. 3. Implement a function to decrypt a given string. 4. Implement a function to check if two encrypted strings are a match. # Objectives: - **Function**: `initialize_shift(shift: int)` - **Input**: - `shift`: Integer, the fixed number of positions each character is shifted in the ASCII table. - **Output**: Initializes the encryption/decryption shift value. - **Function**: `encrypt_string(plain_text: str) -> str` - **Input**: - `plain_text`: String to be encrypted. - **Output**: Returns the encrypted string. - **Function**: `decrypt_string(encrypted_text: str) -> str` - **Input**: - `encrypted_text`: String to be decrypted. - **Output**: Returns the decrypted string. - **Function**: `match_strings(encrypted_text1: str, encrypted_text2: str) -> bool` - **Input**: - `encrypted_text1`: The first encrypted string. - `encrypted_text2`: The second encrypted string. - **Output**: Returns `True` if the two encrypted strings match when decrypted, otherwise `False`. Constraints: - The `shift` value should be within the range of 1 to 25. - The encrypted characters must wrap around within the printable ASCII characters (from 32 to 126). - Ensure that the functions handle edge cases gracefully. - The `match_strings` function should not decrypt the strings directly but should determine a match based on their encrypted state. # Example Scenario: 1. Initialize the system with a shift: ```python initialize_shift(3) ``` 2. Encrypt a string: ```python encrypted = encrypt_string(\\"Hello, World!\\") ``` 3. Decrypt the string to verify: ```python decrypted = decrypt_string(encrypted) ``` 4. Match two encrypted strings to check if they correspond to the same plain text: ```python match = match_strings(encrypted, \\"Khoor#Zruog\\") ``` # Guidelines: - Test the functions with different shift values. - Ensure the algorithm is efficient, even for large strings. - Document potential edge cases and ensure proper handling. Are you ready to secure string comparisons in a world of encrypted communications?","solution":"class SecureStringMatch: def __init__(self): self.shift = 0 def initialize_shift(self, shift: int): if shift < 1 or shift > 25: raise ValueError(\\"Shift must be within the range of 1 to 25\\") self.shift = shift def encrypt_string(self, plain_text: str) -> str: encrypted_text = \'\'.join( chr((ord(char) - 32 + self.shift) % 95 + 32) for char in plain_text ) return encrypted_text def decrypt_string(self, encrypted_text: str) -> str: decrypted_text = \'\'.join( chr((ord(char) - 32 - self.shift) % 95 + 32) for char in encrypted_text ) return decrypted_text def match_strings(self, encrypted_text1: str, encrypted_text2: str) -> bool: decrypted_text1 = self.decrypt_string(encrypted_text1) decrypted_text2 = self.decrypt_string(encrypted_text2) return decrypted_text1 == decrypted_text2 secure_string_match = SecureStringMatch()"},{"question":"# Coding Assessment Question: Efficient Finding of Missing Number in Arithmetic Sequence You are given an arithmetic sequence missing one number. The task is to determine the missing number using an efficient algorithm. An arithmetic sequence has a constant difference between consecutive terms. **Objective**: Implement a function `find_missing_number` which finds the missing number in a given arithmetic sequence. # Function Signature ```python def find_missing_number(sequence: list[int]) -> int: pass ``` # Input - `sequence` (list of int): A list of integers representing an arithmetic sequence with exactly one number missing. # Output - Returns an integer representing the missing number in the sequence. # Constraints - `sequence` is guaranteed to contain at least 3 numbers. - `sequence` can have positive or negative integers. - The sequence is sorted. # Requirements - Implement the `find_missing_number` function. - The function should efficiently identify the missing number. # Example ```python # Example sequence with a missing number sequence = [2, 4, 6, 10, 12] # Finding the missing number in the sequence result = find_missing_number(sequence) print(\\"Missing number in the sequence:\\", result) # Expected Output: 8 ``` # Hints - Consider calculating the common difference based on the first two terms. - Use binary search to identify the point where the difference deviates from the common difference, indicating the missing number.","solution":"def find_missing_number(sequence): Finds the missing number in an arithmetic sequence. Parameters: sequence (list of int): A list of integers representing an arithmetic sequence with one number missing. Returns: int: The missing number in the sequence. n = len(sequence) total_expected_sum = (n + 1) * (sequence[0] + sequence[-1]) // 2 actual_sum = sum(sequence) return total_expected_sum - actual_sum"},{"question":"Path Planning with Dijkstra\'s Algorithm You are required to implement Dijkstra\'s shortest-path algorithm to find the shortest path in a weighted, directed graph. Given a graph represented by a weighted adjacency matrix and a starting node, the algorithm should return the shortest distance to each node and the predecessor of each node in the shortest path tree. # Function Signature ```python def dijkstra(graph: List[List[int]], start: int) -> Tuple[List[int], List[int]]: ``` # Input * `graph`: A 2D list `graph` where `graph[i][j]` represents the weight of the edge from node `i` to node `j`. If there is no direct edge, the weight is represented by a large number (e.g., `float(\'inf\')`). * `start`: An integer representing the starting node for the shortest-path algorithm. # Output * Returns a tuple `(distances, predecessors)`: - `distances`: A list of integers where the `i`-th element represents the shortest distance from the start node to node `i`. - `predecessors`: A list of integers where the `i`-th element represents the predecessor of node `i` in the shortest path tree. If no path exists, the predecessor should be `-1`. # Constraints * `1 <= len(graph) <= 200` (number of nodes in the graph) * All edge weights are non-negative integers. * The graph may represent real-world problems where some nodes are unreachable from others. # Example ```python graph = [ [0, 7, 9, float(\'inf\'), float(\'inf\'), 14], [7, 0, 10, 15, float(\'inf\'), float(\'inf\')], [9, 10, 0, 11, float(\'inf\'), 2], [float(\'inf\'), 15, 11, 0, 6, float(\'inf\')], [float(\'inf\'), float(\'inf\'), float(\'inf\'), 6, 0, 9], [14, float(\'inf\'), 2, float(\'inf\'), 9, 0] ] start = 0 distances, predecessors = dijkstra(graph, start) print(\\"Distances:\\", distances) print(\\"Predecessors:\\", predecessors) ``` # Expected Output ``` Distances: [0, 7, 9, 20, 20, 11] Predecessors: [-1, 0, 0, 2, 5, 2] ``` # Performance Requirements * The algorithm should efficiently handle graphs with size up to 200 nodes. * Ensure that the algorithm completes in a reasonable time for large inputs. # Additional Notes * You should not use any existing libraries that provide Dijkstra\'s algorithm; the implementation should be from scratch. * The function should handle edge cases gracefully where some nodes may be completely disconnected from the graph.","solution":"from typing import List, Tuple import heapq def dijkstra(graph: List[List[int]], start: int) -> Tuple[List[int], List[int]]: Implements Dijkstra\'s algorithm for finding the shortest paths from a starting node to all other nodes. Args: - graph: A 2D list representing the weighted adjacency matrix of the graph. - start: An integer representing the starting node. Returns: - A tuple of two lists: * distances: A list where each element represents the shortest distance from the start node to that node. * predecessors: A list where each element represents the predecessor of that node in the shortest path. n = len(graph) distances = [float(\'inf\')] * n predecessors = [-1] * n distances[start] = 0 # Priority queue for maintaining vertices to be processed queue = [(0, start)] visited = set() while queue: current_distance, u = heapq.heappop(queue) if u in visited: continue visited.add(u) for v in range(n): if graph[u][v] != float(\'inf\') and v not in visited: distance = current_distance + graph[u][v] if distance < distances[v]: distances[v] = distance predecessors[v] = u heapq.heappush(queue, (distance, v)) return distances, predecessors"},{"question":"# Problem Statement You are required to implement a function that generates a list of the first `n` fibonacci numbers. The number `n` is provided as input and the output should be a list of integers representing the first `n` terms in the fibonacci sequence. # Detailed Instructions * **Function Name**: `fibonacci_series` * **Input**: - `n` - an integer representing the number of terms in the fibonacci sequence. * **Output**: - Returns a list of integers where each integer is a term in the fibonacci sequence up to the nth term. # Requirements 1. If `n` is less than or equal to 0, return an empty list. 2. Assume the input will always be a non-negative integer. 3. The sequence must begin with 0 and 1. # Examples ```python >>> fibonacci_series(5) [0, 1, 1, 2, 3] >>> fibonacci_series(2) [0, 1] >>> fibonacci_series(0) [] >>> fibonacci_series(1) [0] ``` # Constraints * `0 <= n <= 10**6` # Performance Requirements * The function should be efficient in computing the result and must operate within a reasonable time for the upper constraints. Good luck!","solution":"def fibonacci_series(n): Returns a list of first `n` fibonacci numbers. if n <= 0: return [] if n == 1: return [0] fib_sequence = [0, 1] while len(fib_sequence) < n: fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence"},{"question":"# Problem Description Implement a function that takes a list of floating-point numbers and normalizes them. Normalization in this context means adjusting the values in the list such that the entire range of values is scaled to fit between 0 and 1 based on their original distribution. # Function Signature ```python def normalize_floats(values: list[float]) -> list[float]: ``` # Input - A list of floating-point numbers `values`. The list can contain any number of elements, including being empty. # Output - A list of floating-point numbers where each value from the input list has been normalized to the range [0, 1]. # Constraints 1. Each value in the list `values` is a floating-point number. 2. The list can be empty or contain up to 10,000 elements. 3. If the list is empty, the function should return an empty list. 4. If all values in the list are the same, they should all be normalized to 0. # Example ```python >>> normalize_floats([1.0, 2.0, 3.0]) [0.0, 0.5, 1.0] >>> normalize_floats([10.0, 20.0, 30.0, 40.0]) [0.0, 0.3333333333333333, 0.6666666666666666, 1.0] >>> normalize_floats([42.0]) [0.0] >>> normalize_floats([]) [] ``` # Detailed Steps 1. **Validation**: Ensure the input is a list of floating-point numbers. 2. **Edge Case**: If the input list is empty, return an empty list. 3. **Min and Max Calculation**: Determine the minimum and maximum values in the list. 4. **Normalization**: - If the list contains only identical values, return a list of zeroes as all values normalize to 0. - Otherwise, normalize each value using the formula: [ text{normalized_value} = frac{text{value} - text{min}}{text{max} - text{min}} ] 5. **Output**: Return the list of normalized floating-point numbers. # Edge Cases - Properly handle an empty input list. - Handle the case where all values in the list are identical. Use this design to ensure your implementation is robust, efficient, and meets the problem requirements.","solution":"def normalize_floats(values: list[float]) -> list[float]: if not values: return [] min_val = min(values) max_val = max(values) if min_val == max_val: return [0.0] * len(values) return [(value - min_val) / (max_val - min_val) for value in values]"},{"question":"# Find the Missing Number in a Sequence Objective Write a function that finds the missing number in a sequence from 1 to n. Function Signature ```python def find_missing_number(nums: List[int]) -> int: ``` Parameters * `nums` (List[int]): A list of unique integers from 1 to n, with exactly one number missing. Returns * `int`: The missing integer in the sequence from 1 to n. Constraints 1. `nums` contains unique integers. 2. `1 <= len(nums) <= 10^6` 3. All elements are guaranteed to be within the range from 1 to n, except one number which is missing. 4. The input list will not be sorted. Examples ```python >>> find_missing_number([1, 2, 4, 6, 5, 3, 8]) 7 >>> find_missing_number([2, 3, 1, 5, 6]) 4 >>> find_missing_number([1, 3]) 2 >>> find_missing_number([1, 2, 3, 5]) 4 ``` Edge Cases * The missing number is at the start of the sequence. * The missing number is at the end of the sequence. Instructions 1. Implement `find_missing_number` adhering to the function signature above. 2. Optimize for time and space complexity. Potential solutions can involve arithmetic series properties or hash sets. 3. Ensure to handle both small and large inputs efficiently. Testing Use the provided examples and edge cases to validate your implementation.","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Finds the missing number in the sequence from 1 to n. Args: nums (List[int]): A list of unique integers from 1 to n, with exactly one number missing. Returns: int: The missing integer in the sequence from 1 to n. n = len(nums) + 1 total_sum = n * (n + 1) // 2 actual_sum = sum(nums) return total_sum - actual_sum"},{"question":"# Question: Implement a Rate-Limited Request Handler **Context**: You are developing a web service that handles user requests. To ensure fair usage and manage server load, you need to implement a rate-limited request handler. Each user has a limit on the number of requests they can make within a given time frame. **Function to Implement**: Implement the following function: ```python def rate_limited_request_handler(user_id, timestamp, limit, period, request_log): Implementation of a rate-limited request handler. Parameters: user_id : str representing the unique ID of the user making the request. timestamp : int representing the current time in seconds since the epoch. limit : int representing the maximum number of requests allowed within the period. period : int representing the time frame in seconds within which the request limit is applied. request_log : dict where the keys are user IDs and the values are lists of timestamps of their requests. Returns: bool : True if the request is allowed, False if it exceeds the rate limit. ``` **Input/Output**: - **Input**: - `user_id`: A string representing the unique ID of the user. - `timestamp`: An integer representing the current time in seconds since the epoch. - `limit`: An integer representing the maximum number of requests allowed within the period. - `period`: An integer representing the time frame in seconds within which the request limit is applied. - `request_log`: A dictionary where the keys are user IDs and the values are lists of timestamps of their requests. - **Output**: - `bool`: Return `True` if the request is allowed, otherwise return `False`. **Constraints**: - The `user_id` is a non-empty string with a maximum length of 64 characters. - The `timestamp` is an integer representing the current time in seconds since the epoch. - The `limit` and `period` are positive integers. - `request_log` contains a maximum of 10,000 user entries, each with a list of up to 1,000 timestamps. **Requirements**: 1. Implement logic to check if a given request is within the allowed rate limit. 2. Maintain an efficient data structure to track and update user request logs. 3. Ensure that the handler removes outdated timestamps beyond the rate-limiting period for efficiency. **Performance Considerations**: - The function should efficiently handle concurrent requests from multiple users. - Optimize the data structure and logic to quickly check and update the request log within the constraints.","solution":"def rate_limited_request_handler(user_id, timestamp, limit, period, request_log): Implementation of a rate-limited request handler. Parameters: user_id : str representing the unique ID of the user making the request. timestamp : int representing the current time in seconds since the epoch. limit : int representing the maximum number of requests allowed within the period. period : int representing the time frame in seconds within which the request limit is applied. request_log : dict where the keys are user IDs and the values are lists of timestamps of their requests. Returns: bool : True if the request is allowed, False if it exceeds the rate limit. if user_id not in request_log: request_log[user_id] = [] # Filter out requests which are outside the allowed period while request_log[user_id] and request_log[user_id][0] <= timestamp - period: request_log[user_id].pop(0) # Check if the user has exceeded the rate limit if len(request_log[user_id]) >= limit: return False # Add the new request to the log request_log[user_id].append(timestamp) return True"},{"question":"# Question: Weather Data Analysis with Custom Weather Metrics You are tasked with analyzing a dataset of daily weather readings and computing custom weather metrics for a specified range of days. The dataset consists of daily temperature readings in Celsius and daily precipitation levels in millimeters. Your goal is to implement functions that calculate the average temperature, total precipitation, and the maximum temperature fluctuation within a given range of days. # Task 1. **Implement the `calculate_average_temperature` function**: This function should compute the average temperature over a specified range of days. 2. **Implement the `calculate_total_precipitation` function**: This function should compute the total precipitation over a specified range of days. 3. **Implement the `calculate_max_fluctuation` function**: This function should calculate the maximum temperature fluctuation, defined as the largest difference between any two consecutive days\' temperatures, within a specified range of days. # Requirements: - Each function must handle edge cases, such as invalid day ranges or empty datasets, gracefully. - Solutions should be efficient, aiming for linear time complexity relative to the number of days in the range. # Input: - `weather_data` (list of tuples): Each tuple contains two values - the temperature (float) and the precipitation level (float) for a day. - `start_day` (int): The starting index of the range of days (inclusive). - `end_day` (int): The ending index of the range of days (inclusive). # Output: - `calculate_average_temperature` should return a float representing the average temperature over the specified range. - `calculate_total_precipitation` should return a float representing the total precipitation over the specified range. - `calculate_max_fluctuation` should return a float representing the maximum temperature fluctuation over the specified range. # Function Signatures: ```python def calculate_average_temperature(weather_data: list[tuple[float, float]], start_day: int, end_day: int) -> float: pass def calculate_total_precipitation(weather_data: list[tuple[float, float]], start_day: int, end_day: int) -> float: pass def calculate_max_fluctuation(weather_data: list[tuple[float, float]], start_day: int, end_day: int) -> float: pass ``` # Example: ```python weather_data = [(20.5, 5.0), (22.3, 0.0), (19.8, 10.0), (25.1, 2.5), (18.7, 0.0)] # Calculating average temperature from day 1 to day 3 >>> calculate_average_temperature(weather_data, 1, 3) 22.066666666666666 # Calculating total precipitation from day 0 to day 4 >>> calculate_total_precipitation(weather_data, 0, 4) 17.5 # Calculating maximum temperature fluctuation from day 1 to day 3 >>> calculate_max_fluctuation(weather_data, 1, 3) 5.3 ``` **Note**: - Make sure that the `start_day` to `end_day` range indices are inclusive. - Ensure that the functions handle scenarios where `start_day` or `end_day` are out of range of the `weather_data` list.","solution":"def calculate_average_temperature(weather_data, start_day, end_day): Returns the average temperature over a specified range of days. if not weather_data or start_day < 0 or end_day >= len(weather_data) or start_day > end_day: return None total_temperature = sum(weather_data[i][0] for i in range(start_day, end_day + 1)) return total_temperature / (end_day - start_day + 1) def calculate_total_precipitation(weather_data, start_day, end_day): Returns the total precipitation over a specified range of days. if not weather_data or start_day < 0 or end_day >= len(weather_data) or start_day > end_day: return None total_precipitation = sum(weather_data[i][1] for i in range(start_day, end_day + 1)) return total_precipitation def calculate_max_fluctuation(weather_data, start_day, end_day): Returns the maximum temperature fluctuation over a specified range of days. if not weather_data or start_day < 0 or end_day >= len(weather_data) or start_day > end_day: return None max_fluctuation = 0 for i in range(start_day, end_day): fluctuation = abs(weather_data[i+1][0] - weather_data[i][0]) if fluctuation > max_fluctuation: max_fluctuation = fluctuation return max_fluctuation"},{"question":"# Problem Statement Given a string, write a function that determines if the string contains all the letters from \'a\' to \'z\' (i.e., the string is a pangram). The function should ignore case and non-alphabetical characters. # Function Signature ```python def is_pangram(s: str) -> bool: ``` # Input * `s` (str): A string. # Output * (bool): `True` if the string is a pangram, `False` otherwise. # Constraints * The input string `s` can have a length of up to 10^5 characters. * The string can contain letters, digits, punctuation marks, and whitespace. # Example ```python assert is_pangram(\\"The quick brown fox jumps over the lazy dog.\\") == True assert is_pangram(\\"Pack my box with five dozen liquor jugs.\\") == True assert is_pangram(\\"Hello World!\\") == False assert is_pangram(\\"\\") == False assert is_pangram(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\") == True ``` # Requirements * The solution should have a time complexity of O(N), where N is the length of the input string. * Handle edge cases such as an empty string, strings with only non-alphabetical characters, and very long strings efficiently.","solution":"def is_pangram(s: str) -> bool: Determines if the string contains all the letters from \'a\' to \'z\'. The function ignores case and non-alphabetical characters. Parameters: - s (str): The input string. Returns: - bool: True if the string is a pangram, False otherwise. # Use a set to track the unique alphabetical characters in the string alphabet_set = set() # Loop through each character in the string for char in s: # Convert the character to lowercase lower_char = char.lower() # If the character is a letter, add it to the set if \'a\' <= lower_char <= \'z\': alphabet_set.add(lower_char) # If we have collected all 26 letters, return True if len(alphabet_set) == 26: return True # If we finish the loop without finding all letters, return False return False"},{"question":"You are tasked with creating a function that approximates the area under the curve of a given function `fnc` over an interval `[x_start, x_end]` using Simpson\'s rule for numerical integration. To demonstrate your understanding of numerical integration techniques, your function should adhere to the following requirements: # Function Signature ```python def simpsons_rule_integration( fnc: Callable[[float], float], x_start: float, x_end: float, n: int = 1000 ) -> float: ``` # Input - `fnc`: A function which defines the curve. - `x_start`: A float indicating the start of the interval. - `x_end`: A float indicating the end of the interval. - `n`: The number of sub-intervals to use for the approximation (default 1000 and must be even). # Output - Returns a float representing the approximate area under the curve. # Constraints - The function operates under the assumption that `x_start` is less than `x_end`. - The function `fnc` is continuous over the interval `[x_start, x_end]`. - Accurate performance is essential; test cases may involve functions with varying rates of change across the interval. # Example ```python import math def f(x): return math.sin(x) print(simpsons_rule_integration(f, 0, math.pi)) ``` Expected output should be a float denoting the approximate area under the curve from `0` to `π` for `f(x) = sin(x)`. **Note**: Ensure to handle edge cases appropriately, such as scenarios where `n` is not even or `x_start` equals `x_end`. Optimize your function for performance while maintaining accuracy.","solution":"from typing import Callable def simpsons_rule_integration( fnc: Callable[[float], float], x_start: float, x_end: float, n: int = 1000 ) -> float: if x_start == x_end: return 0.0 if n % 2 != 0: raise ValueError(\\"n must be even\\") h = (x_end - x_start) / n x = x_start result = fnc(x) for i in range(1, n): x += h if i % 2 == 0: result += 2 * fnc(x) else: result += 4 * fnc(x) result += fnc(x_end) result *= h / 3 return result"},{"question":"# Fibonacci Sequence Optimizer Your task is to implement an efficient generator that produces Fibonacci numbers up to a given integer ( text{max_n} ). The objective is to create a function named `optimized_fibonacci(max_n: int) -> Generator[int, None, None]` that efficiently generates Fibonacci numbers without storing the entire sequence in memory. Requirements: 1. The function should yield Fibonacci numbers less than or equal to the given integer ( text{max_n} ). 2. It should be optimized to handle large values of ( text{max_n} ) efficiently. 3. Use a generator to produce the sequence to ensure space efficiency. Constraints: - ( 0 leq text{max_n} leq 10^{12} ) Expected Input and Output: ```python >>> list(optimized_fibonacci(0)) [] >>> list(optimized_fibonacci(1)) [0, 1, 1] >>> list(optimized_fibonacci(10)) [0, 1, 1, 2, 3, 5, 8] >>> list(optimized_fibonacci(20)) [0, 1, 1, 2, 3, 5, 8, 13] >>> list(optimized_fibonacci(50)) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> list(optimized_fibonacci(100)) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89] ```","solution":"from typing import Generator def optimized_fibonacci(max_n: int) -> Generator[int, None, None]: Generates Fibonacci numbers up to and including max_n. :param max_n: The upper bound for Fibonacci numbers to generate :return: A generator yielding Fibonacci numbers less than or equal to max_n a, b = 0, 1 while a <= max_n: yield a a, b = b, a + b"},{"question":"# Context: You are part of a team developing a software system that performs operations on a matrix for data analysis. One common task is to rotate the matrix elements clockwise by 90 degrees. Correspondingly, you need to implement a function that can perform this rotation efficiently. # Task: Implement a function `rotate_matrix(matrix: List[List[int]]) -> List[List[int]]` that receives a square matrix (2D list) and returns a new matrix which is the result of rotating the original matrix 90 degrees clockwise. # Input: - `matrix` : A list of lists where each inner list represents a row of the matrix. # Output: - A list of lists representing the rotated matrix. # Constraints: - The matrix will always be a non-empty square matrix (NxN) where 1 <= N <= 1000. - The elements of the matrix are integers. # Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] Output = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` # Implementation Notes: 1. First transpose the matrix. 2. Then reverse each row of the transposed matrix to get the final result. Good luck!","solution":"def rotate_matrix(matrix): Rotates a square matrix 90 degrees clockwise. matrix: List[List[int]] - a square matrix (NxN) Returns: List[List[int]] - the rotated matrix n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i+1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"# Problem Statement: You have been tasked with creating a function that generates the sequence of prime numbers up to a given number `n`. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. # Your Task: Implement the function `generate_primes` to return a list of all prime numbers up to (and including, if applicable) the provided number `n`. # Function Signature: ```python def generate_primes(n: int) -> list: Input Parameters: ----------------- n: (int) the upper limit (inclusive) up to which to generate prime numbers Returns: -------- list: a list of integers where each element is a prime number less than or equal to `n` Raises: ------- ValueError: If `n` is less than 2 ``` # Input: * `n` (int): a positive integer representing the upper limit for generating prime numbers, `n >= 2`. # Output: * The function should return a list of integers representing all prime numbers up to and including `n`. # Constraints: * The function should efficiently generate prime numbers using a suitable algorithm (e.g., the Sieve of Eratosthenes). * Ensure input validation to handle cases where `n` is less than 2. # Examples: ```python >>> generate_primes(10) [2, 3, 5, 7] >>> generate_primes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> generate_primes(2) [2] ``` # Notes: * Focus on the efficiency of prime number generation. The Sieve of Eratosthenes is recommended for its performance on larger values of `n`. * Include relevant checks and exception handling to ensure robustness. # Additional Information: ```python def generate_primes(n: int) -> list: if n < 2: raise ValueError(\\"n must be greater than or equal to 2\\") sieve = [True] * (n + 1) sieve[0], sieve[1] = False, False # 0 and 1 are not prime numbers for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n + 1, start): sieve[multiple] = False primes = [num for num, is_prime in enumerate(sieve) if is_prime] return primes ```","solution":"def generate_primes(n: int) -> list: Returns a list of all prime numbers up to and including n. Parameters: n (int): The upper limit (inclusive) up to which to generate prime numbers Returns: list: A list of integers where each element is a prime number less than or equal to n Raises: ValueError: If n is less than 2 if n < 2: raise ValueError(\\"n must be greater than or equal to 2\\") sieve = [True] * (n + 1) sieve[0], sieve[1] = False, False # 0 and 1 are not prime numbers for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n + 1, start): sieve[multiple] = False primes = [num for num, is_prime in enumerate(sieve) if is_prime] return primes"},{"question":"# Balanced Binary Search Tree (BST) Checker A balanced binary search tree (BST) is defined as a binary tree in which the left and right subtrees of every node differ in height by at most 1 and a BST where each node\'s left subtree contains only nodes with values less than the node\'s value and each node\'s right subtree contains only nodes with values greater than the node\'s value. Your task is to check whether a given binary tree is a balanced BST. # Your Task: Write a function `is_balanced_bst(root)` that verifies if the provided binary tree is a balanced BST. The function should return `True` if the tree is a balanced BST, otherwise `False`. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced_bst(root: TreeNode) -> bool: # Your implementation here pass ``` # Input: - `root`: The root node of the binary tree. # Output: - A boolean value indicating whether the tree is a balanced BST. # Constraints: - The number of nodes in the tree is between 1 and 1000. - Node values are integers. # Example: ```python # Example 1 root = TreeNode(2) root.left = TreeNode(1) root.right = TreeNode(3) print(is_balanced_bst(root)) # Output: True # Example 2 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) print(is_balanced_bst(root)) # Output: False ``` # Notes: - Ensure to handle edge cases such as single node trees or skewed trees. - Aim to achieve an efficient solution with reduced runtime. - Use helper functions if necessary to maintain clean and modular code.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced_bst(root: TreeNode) -> bool: def is_balanced_and_bst(node): if not node: return (True, 0, float(\'-inf\'), float(\'inf\')) left_balanced, left_height, left_max, left_min = is_balanced_and_bst(node.left) right_balanced, right_height, right_max, right_min = is_balanced_and_bst(node.right) current_balanced = ( left_balanced and right_balanced and abs(left_height - right_height) <= 1 and left_max < node.val < right_min ) current_height = max(left_height, right_height) + 1 current_max = max(node.val, right_max) current_min = min(node.val, left_min) return current_balanced, current_height, current_max, current_min balanced, _, _, _ = is_balanced_and_bst(root) return balanced"},{"question":"# Fibonacci Cycle Detection In a sequence of Fibonacci numbers, a repeating cycle might appear when the sequence is taken modulo a given value `m`. Your task is to find the length of such a cycle, called the Pisano period, for a given integer `m`. # Task Write a function `fibonacci_cycle_length(m: int) -> int` that returns the length of the Pisano period for the input integer `m`. # Details - **Input**: A single integer `m` where ( 1 leq m leq 10^5 ). - **Output**: An integer representing the length of the Pisano period for the given `m`. - **Constraints**: The function should handle erroneous inputs gracefully (e.g., non-integer, negative). # Performance Requirements - The function should have a time complexity of (O(m^2)) or better. # Example ```python def fibonacci_cycle_length(m: int) -> int: pass # Your implementation here # Example usages and expected outputs print(fibonacci_cycle_length(2)) # Expected output: 3 print(fibonacci_cycle_length(5)) # Expected output: 20 print(fibonacci_cycle_length(7)) # Expected output: 16 ``` # Explanation 1. **Fibonacci Sequence Modulo m**: Generate the Fibonacci sequence, reduce each term modulo `m`, and store the results. 2. **Cycle Detection**: Detect where the sequence starts repeating. The cycle length is the number of terms from the start of one cycle to the start of the next. 3. **Pisano Period**: This is what we\'re calculating. It\'s the length of the cycle of the Fibonacci sequence modulo `m`. # Constraints 1. The sequence is guaranteed to start repeating because the Fibonacci sequence, being linear, will eventually cycle when reduced modulo any integer `m`. 2. Input validation should account for non-integer and invalid values of `m`. # Additional Notes - **Implementation Tip**: You can start detecting cycles from the first two Fibonacci numbers (0 and 1). When these numbers reappear in the sequence in the same order, the cycle has been detected. - **Efficiency**: Despite the apparent simplicity, detecting the cycle effectively may require careful attention to avoid excessive computations. This question tests the candidate\'s understanding of modular arithmetic, sequence detection, and efficient computation techniques, making it a unique yet complementary addition to the existing set.","solution":"def fibonacci_cycle_length(m: int) -> int: if not isinstance(m, int) or m <= 0: raise ValueError(\\"Input must be a positive integer.\\") a, b = 0, 1 for i in range(0, m * m): a, b = b, (a + b) % m if a == 0 and b == 1: return i + 1 return m # Based on theoretical bounds, this line should never be reached."},{"question":"# Shortest Path in Weighted Graph You are given a directed, weighted graph represented by an adjacency matrix. Your task is to find the shortest path from a given source node to a destination node using Dijkstra\'s algorithm. **Problem**: Write a function `shortest_path` to compute the shortest path distance from the source to the destination in the given graph. **Function signature**: ```python def shortest_path(graph: List[List[int]], source: int, destination: int) -> int: pass ``` **Input**: - `graph`: A 2D list of integers representing the adjacency matrix of the directed graph. `graph[u][v]` represents the weight of the edge from vertex `u` to vertex `v`. If there\'s no edge, the value is `float(\'inf\')`. - `source`: An integer representing the source node. - `destination`: An integer representing the destination node. **Output**: - Return an integer representing the minimum distance from the source to the destination in the given graph. If no path exists, return `-1`. **Constraints**: - The number of vertices `V` in the graph will be `2 <= V <= 100`. - Edge weights are non-negative integers or `float(\'inf\')` for no edge. - Ensure that weights and path calculations maintain non-negative integer values and fit within standard integer ranges. **Example**: ```python graph = [ [0, 10, float(\'inf\'), 30, 100], [float(\'inf\'), 0, 50, float(\'inf\'), float(\'inf\')], [float(\'inf\'), float(\'inf\'), 0, float(\'inf\'), 10], [float(\'inf\'), float(\'inf\'), 20, 0, 60], [float(\'inf\'), float(\'inf\'), float(\'inf\'), float(\'inf\'), 0] ] assert shortest_path(graph, 0, 4) == 60 assert shortest_path(graph, 1, 4) == 60 assert shortest_path(graph, 2, 4) == 10 assert shortest_path(graph, 3, 1) == -1 ``` **Notes**: - The function should not alter the original graph as the graph may be reused. - Ensure your implementation handles edge cases and larger graphs efficiently within the provided constraints. - If the destination node is unreachable from the source, return `-1`.","solution":"import heapq from typing import List def shortest_path(graph: List[List[int]], source: int, destination: int) -> int: V = len(graph) # Initialize distances with infinity distances = [float(\'inf\')] * V distances[source] = 0 # Priority queue to select the edge with the smallest weight first priority_queue = [(0, source)] # (distance, vertex) while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) # If the popped vertex distance is greater than the known distance, skip it if current_distance > distances[current_vertex]: continue # Check if we have reached the destination if current_vertex == destination: return current_distance # Examine and relax all neighbors for neighbor in range(V): if graph[current_vertex][neighbor] != float(\'inf\'): distance = current_distance + graph[current_vertex][neighbor] if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) # If the destination is still at infinity, it means it\'s unreachable return -1 if distances[destination] == float(\'inf\') else distances[destination]"},{"question":"# Coding Assessment Question **Context**: You are developing a blogging platform, and one of the features is the ability to find trending topics based on tags used in recent posts. The platform uses a tagging system where each blog post can have multiple tags, and you need to identify the tags that are currently trending. # Task Your task is to implement a function that finds the top `k` trending tags from a list of recent blog posts, based on their frequency of occurrence. **Specifications**: 1. Implement the function `find_trending_tags(posts, k)` that identifies the top `k` trending tags. - Parameters: * `posts`: List of strings, where each string represents a blog post. Tags within each post are denoted by a `#` prefix and are separated by spaces. * `k`: An integer representing the number of top trending tags to return. - Returns: A list of the top `k` trending tags in descending order of their frequency. If multiple tags have the same frequency, they should be returned in lexicographical order. - Constraints: * `k` will be at least 1 and not more than the total number of unique tags. * Each post will contain at least one tag. **Steps**: 1. Extract all tags from the list of recent posts. 2. Count the frequency of each tag. 3. Sort the tags by their frequency in descending order, with ties broken by lexicographical order. 4. Return the top `k` tags. **Example**: ```python posts = [ \\"#python #coding #technology\\", \\"#python #development\\", \\"#sports #fitness\\", \\"#technology #coding\\", \\"#fitness #wellness\\", \\"#development #python\\" ] k = 3 find_trending_tags(posts, k) # Expected output: [\'#python\', \'#coding\', \'#development\'] ``` **Note**: - Tags are case-sensitive. - Ensure your function is efficient and can handle a large number of posts effectively.","solution":"def find_trending_tags(posts, k): from collections import Counter tag_counter = Counter() for post in posts: tags = [tag for tag in post.split() if tag.startswith(\'#\')] tag_counter.update(tags) sorted_tags = sorted(tag_counter.items(), key=lambda x: (-x[1], x[0])) return [tag for tag, count in sorted_tags[:k]]"},{"question":"# Producer-Consumer Queue with Thread Synchronization You are tasked with implementing a Producer-Consumer queue using threading to manage resource sharing between producer and consumer threads in a concurrent environment. Function Specification: Implement the functions `producer(queue, n)` and `consumer(queue, n)` alongside the necessary threading and synchronization mechanisms. Your goal is to: 1. Use a queue to hold produced items. 2. Implement the `producer` function that adds items to the queue. 3. Implement the `consumer` function that removes items from the queue. 4. Use threading to allow multiple producers and consumers to run concurrently. 5. Ensure thread synchronization to avoid race conditions, such as using locks or semaphores. 6. Ensure producers produce a fixed number of items and consumers consume a fixed number of items. Input: - The producer and consumer function parameters: - `queue`: A shared queue object that holds produced items. - `n` (int): The number of items to produce or consume. Constraints: - The queue can hold a maximum of 10 items at any time. - Producers should wait if the queue is full before adding more items. - Consumers should wait if the queue is empty before removing items. - Use threading and synchronization constructs from Python’s `threading` and `queue` modules. Example Usage: ```python import threading import queue def producer(queue, n): for i in range(n): # Produce an item item = f\\"item-{i}\\" # Add item to queue queue.put(item) print(f\\"Produced: {item}\\") print(\\"Producer finished producing\\") def consumer(queue, n): for _ in range(n): # Remove an item from queue item = queue.get() print(f\\"Consumed: {item}\\") print(\\"Consumer finished consuming\\") if __name__ == \\"__main__\\": # Shared queue with a max size of 10 q = queue.Queue(maxsize=10) # Number of items to produce and consume num_items = 20 # Create producer and consumer threads producer_thread = threading.Thread(target=producer, args=(q, num_items)) consumer_thread = threading.Thread(target=consumer, args=(q, num_items)) # Start threads producer_thread.start() consumer_thread.start() # Wait for threads to complete producer_thread.join() consumer_thread.join() print(\\"All tasks are complete\\") ``` Notes: - Ensure thread safety when accessing the shared queue. - Consider edge cases such as empty queue consumption and full queue production. - You can use the `queue.Queue`, `threading.Lock`, and other synchronization primitives for implementation.","solution":"import threading import queue def producer(queue, n): for i in range(n): item = f\\"item-{i}\\" queue.put(item) print(f\\"Produced: {item}\\") print(\\"Producer finished producing\\") def consumer(queue, n): for _ in range(n): item = queue.get() print(f\\"Consumed: {item}\\") print(\\"Consumer finished consuming\\") def run_producer_consumer(num_producers, num_consumers, num_items): q = queue.Queue(maxsize=10) producer_threads = [threading.Thread(target=producer, args=(q, num_items)) for _ in range(num_producers)] consumer_threads = [threading.Thread(target=consumer, args=(q, num_items)) for _ in range(num_consumers)] for t in producer_threads: t.start() for t in consumer_threads: t.start() for t in producer_threads: t.join() for t in consumer_threads: t.join() print(\\"All tasks are complete\\")"},{"question":"# Coding Assessment Question Scenario You have been contracted to clean and standardize textual data collected from various sources. A key step in this process is removing all punctuation from provided text strings. Your task is to implement a function that eliminates punctuation from any given string. Task Create the function `remove_punctuation` in Python, adhering to the provided guidelines. The function will take a string as input and return a new string with all punctuation characters removed. Guidelines - Implement the `remove_punctuation` function. - Preserve all spaces and alphanumeric characters in the original string. - The function should handle edge cases, such as empty strings and strings with no punctuation. Function Signature ```python def remove_punctuation(text: str) -> str: pass ``` Input - `text`: A string consisting of alphanumeric characters, spaces, and punctuation. Output - A new string with all punctuation removed. Constraints - Use standard Python libraries to achieve the result. - The punctuation characters to remove include: `!\\"#%&\'()*+,-./:;<=>?@[]^_`{|}~` Example ```python assert remove_punctuation(\\"Hello, World!\\") == \\"Hello World\\" assert remove_punctuation(\\"It\'s raining... Isn\'t it?\\") == \\"Its raining Isnt it\\" assert remove_punctuation(\\"\\") == \\"\\" assert remove_punctuation(\\"NoPunctuationHere\\") == \\"NoPunctuationHere\\" ``` Performance Considerations - Aim for a linear time complexity, O(n), where n is the length of the input string. - Ensure the function is efficient and can handle long strings effectively.","solution":"def remove_punctuation(text: str) -> str: Removes all punctuation characters from the input string. Parameters: text (str): The input string containing alphanumeric characters, spaces, and possibly punctuation. Returns: str: The cleaned string with all punctuation characters removed. import string # Create a translation table that maps all punctuation to None translator = str.maketrans(\'\', \'\', string.punctuation) # Translate the input text using the translation table to remove punctuation return text.translate(translator)"},{"question":"# Advanced Data Stream Integrity Check As a software engineer focusing on data validation, you are tasked with developing a system that continuously monitors and verifies the integrity of streaming integer data. The system must flag discrepancies and track the state of the data stream to ensure consistency and reliability. **Requirements**: 1. Implement a function to initialize the data stream verification system. 2. Implement a function to input a batch of integer values into the data stream. 3. Implement a function to check for integrity violations based on a running checksum. 4. Implement a function to retrieve the current state of the data stream. # Objectives: - **Function**: `initialize_stream_system(initial_state: List[int])` - **Input**: - `initial_state`: List of integers representing the initial state of the data stream. - **Output**: Initializes the stream verification system. - **Function**: `input_batch_data(data: List[int])` - **Input**: - `data`: List of integer values to be added to the data stream. - **Output**: Updates the data stream with the new batch of integers. - **Function**: `check_integrity() -> bool` - **Input**: None - **Output**: Returns `True` if the data stream is consistent and `False` if there\'s an integrity violation. - **Function**: `get_current_state() -> List[int]` - **Input**: None - **Output**: Returns the current state of the data stream as a list of integers. Constraints: - Ensure the running checksum is a reliable indicator of stream consistency. - Each integer in the data stream must be within the bounds of a 32-bit signed integer. - Efficiently manage large batches of input data to maintain performance. - The system should handle up to 1,000,000 integers in a single input batch. # Example Scenario: 1. Initialize the system using: ```python initialize_stream_system([1, 2, 3, 4, 5]) ``` 2. Input a batch of integers into the system and validate the integrity: ```python input_batch_data([6, 7, 8, 9, 10]) ``` 3. Check if the data stream remains consistent: ```python print(check_integrity()) # Should return True if no violations are detected ``` 4. Verify and print the current state of the data stream: ```python print(get_current_state()) # Expected: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ``` # Guidelines: - Thoroughly test each functionality with various edge cases. - Comment on the potential performance implications for large-scale data batches. - Ensure that the integrity check reliably detects both simple and subtle data inconsistencies. Are you prepared to uphold the integrity of the data stream? Let\'s begin!","solution":"class DataStreamVerificationSystem: def __init__(self): self.stream = [] self.checksum = 0 def initialize_stream_system(self, initial_state): self.stream = initial_state self.checksum = self.calculate_checksum(initial_state) def input_batch_data(self, data): self.stream.extend(data) self.checksum = self.calculate_checksum(self.stream) def check_integrity(self): return self.checksum == self.calculate_checksum(self.stream) def get_current_state(self): return self.stream def calculate_checksum(self, data): return sum(data) # Instance of DataStreamVerificationSystem for direct use data_stream_system = DataStreamVerificationSystem() def initialize_stream_system(initial_state): data_stream_system.initialize_stream_system(initial_state) def input_batch_data(data): data_stream_system.input_batch_data(data) def check_integrity(): return data_stream_system.check_integrity() def get_current_state(): return data_stream_system.get_current_state()"},{"question":"# Problem Statement You are given a list of strings, each representing a different mathematical expression containing variables, constants, and operations (`+`, `-`, `*`, `/`). Your task is to implement a function `evaluate_expressions(exprs: List[str], variables: Dict[str, float]) -> List[float]`, which takes a list of expressions and a dictionary of variable values, evaluates each expression, and returns the results as a list of floats. # Input * `exprs`: A list of strings, where each string represents a mathematical expression. Variables in the expressions are alphanumeric and case-sensitive. * `variables`: A dictionary where the keys are variable names (strings) and the values are their corresponding float values. # Output * A list of floats, where each float is the result of evaluating the corresponding expression in `exprs`. # Constraints 1. Expressions will be valid and well-formed. 2. Variables used in expressions will always be present in the `variables` dictionary. 3. Division by zero will not occur. 4. Expressions will only include `+`, `-`, `*`, `/` operators and parentheses for grouping. 5. You may assume the usage of basic arithmetic only, without trigonometric, logarithmic, or other advanced functions. # Requirements * Parse and evaluate each expression accurately. * Ensure the function raises a `ValueError` if an expression contains an undefined variable. # Example ```python from typing import List, Dict exprs = [\\"a + b * c\\", \\"d / e - f\\", \\"(g + h) * i\\"] variables = { \\"a\\": 1.0, \\"b\\": 2.0, \\"c\\": 3.0, \\"d\\": 10.0, \\"e\\": 2.0, \\"f\\": 3.0, \\"g\\": 4.0, \\"h\\": 5.0, \\"i\\": 2.0 } # Example usage results = evaluate_expressions(exprs, variables) print(results) # Output should be: [7.0, 2.0, 18.0] ```","solution":"from typing import List, Dict import re def evaluate_expressions(exprs: List[str], variables: Dict[str, float]) -> List[float]: Evaluates a list of mathematical expressions with given variable values. Args: - exprs: List of strings, where each string is a mathematical expression. - variables: Dictionary of variable values. Returns: - List of floats, where each float is the result of the corresponding expression. def substitute_variables(expression, variables): Substitute variables in the expression with their corresponding values. def replace_variable(match): var = match.group(0) if var in variables: return str(variables[var]) raise ValueError(f\\"Undefined variable \'{var}\' in expression \'{expression}\'\\") # Replace all variables with their values return re.sub(r\'b[A-Za-z_]w*b\', replace_variable, expression) results = [] for expr in exprs: substituted_expr = substitute_variables(expr, variables) result = eval(substituted_expr) results.append(float(result)) return results"},{"question":"# Question: Implement a System Using Disjoint Set Union (DSU) with Path Compression and Union by Rank Scenario You are tasked with implementing a data structure to keep track of a set of elements partitioned into disjoint (non-overlapping) subsets. Specifically, you should implement a Disjoint Set Union (DSU) system, also known as Union-Find, with path compression and union by rank. These operations will allow for efficient union and find operations by reducing the time complexity. Requirements Implement a class `DisjointSetUnion` with the following methods: - `__init__(self, n: int)`: - Initializes the DSU system with `n` elements, each in its own set. - `find(self, x: int) -> int`: - Returns the representative (or root) of the set containing `x` using path compression for optimization. - `union(self, x: int, y: int)`: - Merges the sets containing `x` and `y` using union by rank for optimization. # Example ```python # Example usage dsu = DisjointSetUnion(5) dsu.union(0, 1) dsu.union(1, 2) dsu.union(3, 4) print(dsu.find(0)) # Returns 0 or 1 or 2, since they are in the same set print(dsu.find(1)) # Returns 0 or 1 or 2 dsu.union(2, 3) print(dsu.find(4)) # Returns 0 or 1 or 2 or 3 or 4 since all elements are now in the same set ``` # Constraints - The number of elements `n` will be at most `10^4`. - The initial elements will be integers from `0` to `n-1`. - The number of operations (`union` and `find` calls) will be at most `10^4`. # Explanation - **Path Compression**: This is a technique used in the `find` operation to make subsequent calls faster by flattening the structure of the tree whenever `find` is called, so all elements directly point to the root. - **Union by Rank**: This technique is used to keep the tree flat by attaching the smaller tree under the root of the larger tree during the union operation. Implement the class `DisjointSetUnion` as described, ensuring optimization through path compression and union by rank techniques.","solution":"class DisjointSetUnion: def __init__(self, n): Initializes the DSU system with `n` elements, each in its own set. self.parent = list(range(n)) self.rank = [0] * n def find(self, x): Returns the representative (or root) of the set containing `x` using path compression. if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) # path compression return self.parent[x] def union(self, x, y): Merges the sets containing `x` and `y` using union by rank. rootX = self.find(x) rootY = self.find(y) if rootX != rootY: # Union by rank if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1"},{"question":"Question You are given a class `TimeIntervalProcessor` that helps manage a list of time intervals. Each time interval is represented as a tuple of two integers where the first integer is the start time and the second integer is the end time. The class allows you to insert new intervals and merge them with the existing ones if they overlap or are contiguous. Your task is to implement the `insert_and_merge` method in the `TimeIntervalProcessor` class. This method should take a new interval, insert it into the list, and merge any overlapping or contiguous intervals. # Function Signature ```python def insert_and_merge(self, interval: Tuple[int, int]) -> None: ``` # Parameters - `interval`: A tuple of two integers representing the start and end times of the interval to be inserted and merged. # Returns - None (the method should modify the internal state of the `TimeIntervalProcessor` instance). # Constraints - All times are non-negative integers. - The intervals within the list are initially sorted in ascending order by start time. # Edge Cases to Consider - Inserting an interval that overlaps with multiple existing intervals. - Inserting an interval that does not overlap but is contiguous with one or more existing intervals. - Inserting an interval into an empty list. # Example Usage ```python processor = TimeIntervalProcessor() processor.insert_and_merge((1, 5)) processor.insert_and_merge((2, 6)) processor.insert_and_merge((8, 10)) print(processor.intervals) # Should output: [(1, 6), (8, 10)] processor.insert_and_merge((7, 9)) print(processor.intervals) # Should output: [(1, 6), (7, 10)] processor.insert_and_merge((0, 0)) print(processor.intervals) # Should output: [(0, 0), (1, 6), (7, 10)] ``` # Class Definition Here\'s the partial implementation of the `TimeIntervalProcessor` class: ```python from typing import List, Tuple class TimeIntervalProcessor: def __init__(self): self.intervals: List[Tuple[int, int]] = [] def insert_and_merge(self, interval: Tuple[int, int]) -> None: # Implement this method to modify `self.intervals` pass def __repr__(self) -> str: return str(self.intervals) ``` Implement the `insert_and_merge` method to complete the class.","solution":"from typing import List, Tuple class TimeIntervalProcessor: def __init__(self): self.intervals: List[Tuple[int, int]] = [] def insert_and_merge(self, interval: Tuple[int, int]) -> None: new_start, new_end = interval merged_intervals = [] i = 0 while i < len(self.intervals): start, end = self.intervals[i] if end < new_start: merged_intervals.append((start, end)) i += 1 elif new_end < start: break else: new_start = min(new_start, start) new_end = max(new_end, end) i += 1 merged_intervals.append((new_start, new_end)) merged_intervals.extend(self.intervals[i:]) self.intervals = merged_intervals"},{"question":"# Question: Movie Review Sentiment Analysis You are required to write a Python function to analyze the sentiment of movie reviews. The sentiment should be determined as \\"Positive\\", \\"Negative\\", or \\"Neutral\\" based on the number of positive and negative words present in the review. You will be provided with two lists: `positive_words` and `negative_words`, which contain words typically associated with positive and negative sentiments, respectively. Requirements: 1. **Input**: - A string representing the movie review. - Two lists of strings (`positive_words` and `negative_words`). 2. **Sentiment Analysis**: - Tokenize the review string into individual words. - Count the number of positive and negative words present in the review. - Determine the sentiment based on the counts: - \\"Positive\\" if the review contains more positive words than negative. - \\"Negative\\" if the review contains more negative words than positive. - \\"Neutral\\" if the counts are equal or if neither positive nor negative words are found. 3. **Case Insensitivity**: - Ensure that the sentiment analysis is case-insensitive. 4. **Output**: - Return the determined sentiment (\\"Positive\\", \\"Negative\\", or \\"Neutral\\"). Implementation Details: 1. **Tokenization**: - Split the review into words using whitespace as the delimiter. 2. **Counting**: - Count the occurrences of words in the review that are present in the `positive_words` and `negative_words` lists. 3. **Output**: - Return the determined sentiment. 4. **Helper Functions**: - Implement helper functions to split the review, count words, and determine the sentiment. Constraints: - Python 3 must be used. - The review will be a non-empty string with at least one character. - The `positive_words` and `negative_words` lists will not be empty. Example Usage: ```python positive_words = [\'good\', \'great\', \'excellent\', \'awesome\', \'fantastic\'] negative_words = [\'bad\', \'terrible\', \'awful\', \'horrible\', \'poor\'] review = \\"The movie was excellent with a fantastic performance by the lead actor but the plot was horrible and the pacing was bad.\\" assert analyze_movie_review_sentiment(review, positive_words, negative_words) == \\"Neutral\\" ``` # Sentiment Analysis Function: Implement your solution with the function signature given below: ```python def analyze_movie_review_sentiment(review: str, positive_words: list, negative_words: list) -> str: pass ```","solution":"def analyze_movie_review_sentiment(review: str, positive_words: list, negative_words: list) -> str: Analyzes the sentiment of a movie review. Parameters: review (str): The movie review. positive_words (list): A list of positive words. negative_words (list): A list of negative words. Returns: str: The sentiment of the review (\\"Positive\\", \\"Negative\\", \\"Neutral\\"). # Convert review to lower case to make it case-insensitive review_lower = review.lower() # Tokenize the review by splitting on whitespace words = review_lower.split() # Count the occurrences of positive and negative words in the review positive_count = sum(1 for word in words if word in positive_words) negative_count = sum(1 for word in words if word in negative_words) # Determine the sentiment based on the counts of positive and negative words if positive_count > negative_count: return \\"Positive\\" elif negative_count > positive_count: return \\"Negative\\" else: return \\"Neutral\\""},{"question":"# Objective Create a class to manage a collection of tasks with priorities and implement methods to add, remove, and retrieve tasks based on priority. # Specifications * **Class Name**: TaskManager * **Methods**: * `add_task`: * **Input**: * `task` (str): The description of the task. * `priority` (int): The priority of the task, where a lower number means higher priority. * **Output**: None * `remove_task`: * **Input**: * `task` (str): The description of the task to be removed. * **Output**: None * `get_next_task`: * **Output**: * (str): The description of the highest priority task. # Constraints * The `priority` parameter will be a positive integer. * Tasks will have distinct descriptions. * The methods should handle the case where there are no tasks appropriately (e.g., `get_next_task` should return `None` if no tasks are available). # Performance * The add and remove operations should ideally perform in O(log n) time. * The retrieval of the next task should perform in O(1) time. # Example ```python class TaskManager: def __init__(self): # Your implementation goes here def add_task(self, task: str, priority: int): # Your implementation goes here def remove_task(self, task: str): # Your implementation goes here def get_next_task(self) -> str: # Your implementation goes here # Example Usage tm = TaskManager() tm.add_task(\\"Write report\\", 2) tm.add_task(\\"Fix bug\\", 1) tm.add_task(\\"Prepare presentation\\", 3) print(tm.get_next_task()) # Output: \\"Fix bug\\" tm.remove_task(\\"Fix bug\\") print(tm.get_next_task()) # Output: \\"Write report\\" ``` # Additional Notes 1. Ensure the class handles edge cases such as attempting to remove a non-existing task. 2. Implement proper error handling for invalid inputs.","solution":"import heapq class TaskManager: def __init__(self): self.tasks = [] self.task_map = set() # To quickly check if a task exists def add_task(self, task: str, priority: int): if task in self.task_map: raise ValueError(f\\"Task \'{task}\' already exists.\\") heapq.heappush(self.tasks, (priority, task)) self.task_map.add(task) def remove_task(self, task: str): if task not in self.task_map: raise ValueError(f\\"Task \'{task}\' does not exist.\\") self.tasks = [(p, t) for p, t in self.tasks if t != task] heapq.heapify(self.tasks) self.task_map.remove(task) def get_next_task(self) -> str: if not self.tasks: return None return self.tasks[0][1]"},{"question":"# Coding Assessment Question # Objective Design and implement a function that performs complex number arithmetic operations on a given pair of complex numbers. # Problem Statement You are required to implement a function that given two complex numbers and a specified operation (addition, subtraction, multiplication, division), performs the requested operation and returns the result. # Function Signature ```python def complex_number_arithmetic( complex_num1: complex, complex_num2: complex, operation: str ) -> complex: ``` # Input * `complex_num1 (complex)`: The first complex number in the operation. * `complex_num2 (complex)`: The second complex number in the operation. * `operation (str)`: A string that specifies the arithmetic operation to perform. It can be one of the following: `\\"add\\"`, `\\"subtract\\"`, `\\"multiply\\"`, `\\"divide\\"`. # Output * `complex`: The result of the specified arithmetic operation applied to the two complex numbers. # Requirements 1. Handle potential division by zero errors gracefully. 2. Ensure the function returns a complex number as the result. # Constraints * The real and imaginary parts of the `complex_num1` and `complex_num2` will be between -1000.0 and 1000.0. * The `operation` string will always be one of the specified valid operations. # Example ```python complex_num1 = 3 + 4j complex_num2 = 1 + 2j result = complex_number_arithmetic(complex_num1, complex_num2, \\"add\\") print(result) # Expected Output: (4+6j) result = complex_number_arithmetic(complex_num1, complex_num2, \\"subtract\\") print(result) # Expected Output: (2+2j) result = complex_number_arithmetic(complex_num1, complex_num2, \\"multiply\\") print(result) # Expected Output: (-5+10j) result = complex_number_arithmetic(complex_num1, complex_num2, \\"divide\\") print(result) # Expected Output: (2.2-0.4j) ``` # Notes 1. Consider handling edge cases such as division by zero. 2. Optimize the function for both clarity and efficiency. 3. You may assume that the input values will always be within the given constraints for typical scenarios.","solution":"def complex_number_arithmetic(complex_num1: complex, complex_num2: complex, operation: str) -> complex: Perform arithmetic operations on two complex numbers. Args: complex_num1 (complex): The first complex number. complex_num2 (complex): The second complex number. operation (str): The operation to perform (\'add\', \'subtract\', \'multiply\', \'divide\'). Returns: complex: The result of the operation. if operation == \\"add\\": return complex_num1 + complex_num2 elif operation == \\"subtract\\": return complex_num1 - complex_num2 elif operation == \\"multiply\\": return complex_num1 * complex_num2 elif operation == \\"divide\\": try: return complex_num1 / complex_num2 except ZeroDivisionError: raise ValueError(\\"Cannot divide by zero\\") else: raise ValueError(\\"Invalid operation specified.\\")"},{"question":"# Context A software company\'s transaction log has several million entries. Each entry records user activities, including user ID, transaction type, and timestamp. Your task is to identify the top 3 users with the highest number of unique transaction types over the entire dataset. This requires efficiently processing large volumes of data to determine unique transaction types for each user and then identifying the top users. # Requirements 1. Parse the transaction log and count unique transaction types for each user. 2. Determine the top 3 users based on the highest number of unique transaction types. 3. Ensure your solution handles large datasets and is optimal in terms of time and space complexity. # Input/Output 1. **Function**: `top_users_with_unique_transactions(transactions)` - **Arguments**: - `transactions`: List of tuples `[(userID, transactionType, timestamp), ...]`. - **Returns**: List of the top 3 user IDs with the highest number of unique transaction types. - If less than 3 users exist, return the list of available user IDs sorted by the number of unique transactions. # Constraints - Each user transaction entry is recorded only once per type but may appear multiple times if they perform several types. - Each tuple consists of a string for `userID`, a string for `transactionType`, and a string for `timestamp`. - The dataset can be exceedingly large, consider memory and time constraints. # Example ```python transactions = [ (\'user_1\', \'type_a\', \'2023-01-01 00:00:01\'), (\'user_2\', \'type_b\', \'2023-01-01 00:00:02\'), (\'user_3\', \'type_a\', \'2023-01-01 00:00:03\'), (\'user_1\', \'type_b\', \'2023-01-01 00:00:04\'), (\'user_2\', \'type_c\', \'2023-01-01 00:00:05\'), (\'user_3\', \'type_d\', \'2023-01-01 00:00:06\'), (\'user_1\', \'type_a\', \'2023-01-01 00:00:07\'), (\'user_2\', \'type_a\', \'2023-01-01 00:00:08\'), ] top_users = top_users_with_unique_transactions(transactions) print(top_users) # Output would be a list of top 3 user IDs, for example: [\'user_1\', \'user_2\', \'user_3\'] ``` # Criteria - Solution\'s correctness in identifying and counting unique transaction types. - Efficient use of data structures to handle large datasets. - Proper handling of edge cases and tie-breaking for user transactions.","solution":"from collections import defaultdict def top_users_with_unique_transactions(transactions): Determines the top 3 users with the highest number of unique transaction types. Arguments: transactions: List of tuples [(userID, transactionType, timestamp), ...] Returns: List of the top 3 user IDs with the highest number of unique transaction types. user_transactions = defaultdict(set) for user_id, transaction_type, _ in transactions: user_transactions[user_id].add(transaction_type) sorted_users = sorted(user_transactions.items(), key=lambda x: len(x[1]), reverse=True) return [user[0] for user in sorted_users[:3]]"},{"question":"```markdown Problem Statement You are given a list of strings. Your task is to implement a function that: 1. Groups the anagrams together in sublists (`group_anagrams` function). 2. Finds the longest string in the list that can be rearranged to form a palindrome (`longest_palindrome` function). You must implement both functions with the following specifications: # Function Signature ```python def group_anagrams(lst: list[str]) -> list[list[str]]: # Your implementation here def longest_palindrome(lst: list[str]) -> str: # Your implementation here ``` # Input - `lst`: A list of strings. You may assume that the list is not extremely large (typical input size <= 10^5). # Output - `group_anagrams(lst)`: Returns a list of lists, where each sublist contains strings that are anagrams of each other. - `longest_palindrome(lst)`: Returns the longest string from the list that can be rearranged to form a palindrome. If multiple candidates have the same length, return any of them. # Constraints - The list is non-empty. - Strings contain only lowercase letters. - For `group_anagrams`, the order of sublists or strings within each sublist does not matter. - For `longest_palindrome`, if no string can be rearranged to form a palindrome, return an empty string. # Performance Requirements - The `group_anagrams` function should run in O(n * k log k) time, where `n` is the number of strings, and `k` is the maximum length of a string in `lst`. - The `longest_palindrome` function should run in O(n * k) time. # Example ```python >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\'eat\', \'tea\', \'ate\'], [\'tan\', \'nat\'], [\'bat\']] >>> group_anagrams([\\"\\", \\"b\\", \\"\\"]) [[\'\', \'\'], [\'b\']] >>> longest_palindrome([\\"abc\\", \\"carerac\\", \\"aabb\\", \\"bbaacc\\", \\"abb\\"]) \\"carerac\\" >>> longest_palindrome([\\"abc\\", \\"def\\", \\"ghi\\"]) \\"\\" ``` # Additional Information For both functions, consider edge cases such as an entirely uniform string list, very short strings, or very long individual strings. ```","solution":"from collections import defaultdict def group_anagrams(lst: list[str]) -> list[list[str]]: Groups anagrams together. anagram_dict = defaultdict(list) for word in lst: sorted_word = \'\'.join(sorted(word)) anagram_dict[sorted_word].append(word) return list(anagram_dict.values()) def longest_palindrome(lst: list[str]) -> str: Finds the longest string that can be rearranged to form a palindrome. def can_form_palindrome(s: str) -> bool: Checks if a word can be rearranged to form a palindrome. char_count = defaultdict(int) for char in s: char_count[char] += 1 odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1 max_length = 0 longest_pal = \\"\\" for word in lst: if can_form_palindrome(word): if len(word) > max_length: max_length = len(word) longest_pal = word return longest_pal"},{"question":"Average Rating of Movies from Multiple Reviewers You are tasked with developing an application that calculates the average rating of movies given reviews from multiple reviewers. Each reviewer can rate multiple movies, but not necessarily all movies in the list. Your goal is to process the reviews and provide the average rating for each movie. Input and Output: - **Input**: * A list of tuples \'reviews\' where each tuple contains: * An integer \'movie_id\' representing the unique identifier for the movie. * An integer \'reviewer_id\' representing the unique identifier for the reviewer. * An integer \'rating\' representing the rating given by the reviewer to the movie (rating range is 1 to 5). - **Output**: * A dictionary where the keys are movie_ids and the values are the average ratings (float) of the corresponding movies. Constraints: - There are at most 10^6 reviews. - There are at most 10^5 movies. - Each movie has at least one rating. Performance: - Your solution must efficiently handle large amounts of reviews, considering both time and space complexities. Example: ```python reviews = [ (1, 101, 5), (1, 102, 4), (2, 101, 3), (2, 103, 4), (3, 104, 2), (3, 101, 3), (3, 105, 4) ] # Expected Output: {1: 4.5, 2: 3.5, 3: 3.0} print(calculate_average_ratings(reviews)) ``` Function Signature: ```python from typing import List, Tuple, Dict def calculate_average_ratings(reviews: List[Tuple[int, int, int]]) -> Dict[int, float]: pass ``` Provide the implementation for the `calculate_average_ratings` function that meets the constraints and handles all edge cases efficiently.","solution":"from typing import List, Tuple, Dict def calculate_average_ratings(reviews: List[Tuple[int, int, int]]) -> Dict[int, float]: Calculate the average rating of movies given reviews from multiple reviewers. :param reviews: List of tuples; each tuple contains (movie_id, reviewer_id, rating) :return: Dictionary where keys are movie_ids and values are average ratings from collections import defaultdict # Dictionary to store total ratings and number of ratings for each movie movie_ratings = defaultdict(lambda: [0, 0]) for movie_id, reviewer_id, rating in reviews: movie_ratings[movie_id][0] += rating # Sum of ratings movie_ratings[movie_id][1] += 1 # Count of ratings # Dictionary to store the average rating for each movie average_ratings = {} for movie_id, (total_rating, count) in movie_ratings.items(): average_ratings[movie_id] = total_rating / count return average_ratings"},{"question":"# Question: Implement a Function to Simplify Unix/Linux Style Path In Unix/Linux operating systems, a path is a string that denotes the location of a file or directory. Paths can include directories denoted by \\".\\", which means the current directory, or \\"..\\", which means the parent directory. A path may also include multiple forward slashes (\\"/\\") which are treated as a single slash. The task is to simplify such a path to its canonical form. Function Signature ```python def simplify_unix_path(path: str) -> str: # your code here ``` Input - `path` (str): The input string representing a Unix/Linux style path. It consists of lowercase alphabets, forward slashes, and periods. Output - (str): The simplified Unix/Linux style path. Constraints - The maximum length of `path` is 10^4. - The input path is always a valid Unix/Linux style path. Examples ```python simplify_unix_path(\\"/home//foo/\\") # Returns \\"/home/foo\\" simplify_unix_path(\\"/a/./b/../../c/\\") # Returns \\"/c\\" simplify_unix_path(\\"/../\\") # Returns \\"/\\" simplify_unix_path(\\"/home//foo/./bar\\") # Returns \\"/home/foo/bar\\" simplify_unix_path(\\"/a//b////c/d//././/..\\") # Returns \\"/a/b/c\\" simplify_unix_path(\\"/a/.../b/./c/../d/\\") # Returns \\"/a/.../b/d\\" simplify_unix_path(\\"/\\") # Returns \\"/\\" ``` # Explanation - The function processes each component of the path, skipping empty and current directory (\\".\\") components. - When encountering a parent directory (\\"..\\"), it pops the last directory from the stack unless it is empty. - It then constructs the simplified path using the remaining components in the stack. - If the resulting path is an empty string, the root directory \\"/\\" is returned. **Note**: You are expected to implement the path simplification manually and not use any built-in functions that directly simplify paths.","solution":"def simplify_unix_path(path: str) -> str: components = path.split(\\"/\\") stack = [] for part in components: if part == \\"..\\": if stack: stack.pop() elif part and part != \\".\\": stack.append(part) simplified_path = \\"/\\" + \\"/\\".join(stack) return simplified_path"},{"question":"# Coding Assessment Question Context: In matrix theory, a Toeplitz matrix is a matrix in which each descending diagonal from left to right is constant. For example, the following matrix is a Toeplitz matrix: ``` 1 2 3 4 5 1 2 3 6 5 1 2 7 6 5 1 ``` but this one is not: ``` 1 2 3 4 5 1 9 3 6 5 1 2 7 6 5 1 ``` Problem: Write a function that checks whether a given matrix is a Toeplitz matrix. The function should return `True` if the matrix is a Toeplitz matrix, and `False` otherwise. Function Signature: ```python def is_toeplitz(matrix: list[list[int]]) -> bool: ``` Input: - `matrix`: a 2D list of integers representing the matrix. Output: - Returns `True` if the matrix is a Toeplitz matrix. - Returns `False` otherwise. Requirements: 1. The function must handle edge cases such as an empty matrix or matrices with only one row or one column. 2. The function should efficiently check the condition with minimal redundant comparisons. Constraints: - The input matrix can be empty, in which case it should return `True` (an empty matrix is trivially a Toeplitz matrix). - The elements in the matrix are all integers. Example: ```python >>> is_toeplitz([[1, 2, 3, 4], [5, 1, 2, 3], [6, 5, 1, 2], [7, 6, 5, 1]]) True >>> is_toeplitz([[1, 2, 3, 4], [5, 1, 9, 3], [6, 5, 1, 2], [7, 6, 5, 1]]) False >>> is_toeplitz([[1]]) True >>> is_toeplitz([]) True ``` Note: Implement necessary checks for the input matrix to ensure it handles edge cases appropriately and does not assume the matrix has a fixed size.","solution":"def is_toeplitz(matrix): Checks if the given matrix is a Toeplitz matrix. Args: matrix (list[list[int]]): The input 2D list of integers representing the matrix. Returns: bool: True if the matrix is a Toeplitz matrix, False otherwise. if not matrix or not matrix[0]: return True rows = len(matrix) cols = len(matrix[0]) for row in range(1, rows): for col in range(1, cols): if matrix[row][col] != matrix[row - 1][col - 1]: return False return True"},{"question":"# Coding Question **Objective**: Write a function to evaluate a list of binary OR gate operations. # Problem Statement You are given a list of tuples where each tuple contains two integers representing the inputs for a binary OR gate. You need to write a function `evaluate_or_operations(operations: List[Tuple[int, int]]) -> List[int]` that takes this list as input and returns a list of outputs corresponding to each OR gate operation. # Input Format - A list of tuples, each containing two integers (0 or 1). - Example: `[(0, 0), (1, 0), (1, 1), (0, 1)]` # Output Format - A list of integers (0 or 1) corresponding to the evaluation of each OR operation. - Example: `[0, 1, 1, 1]` # Constraints - Each integer in the tuples will be either 0 or 1. - The list can be empty, in which case the output should also be an empty list. # Example ```python assert evaluate_or_operations([(0, 0), (1, 0), (1, 1), (0, 1)]) == [0, 1, 1, 1] assert evaluate_or_operations([]) == [] assert evaluate_or_operations([(1, 0)]) == [1] ``` # Requirements - You must write the core logic using the principles of the OR gate. - Ensure that your implementation is efficient and handles all edge cases.","solution":"from typing import List, Tuple def evaluate_or_operations(operations: List[Tuple[int, int]]) -> List[int]: Evaluates a list of binary OR gate operations. Args: operations : List[Tuple[int, int]] : A list of tuples where each tuple contains two integers (0 or 1). Returns: List[int] : A list of integers (0 or 1) corresponding to the evaluation of each OR operation. return [a | b for a, b in operations]"},{"question":"Problem Statement Suppose you are given a text document represented as a list of sentences. Your task is to implement two functions: 1. A function that finds the sentence with the fewest unique words (`min_unique_words` function). 2. A function that finds the sentence with the highest unique word count using a more efficient method (`max_unique_words_optimized` function). # Function Signature ```python def min_unique_words(sentences: list[str]) -> str: # Your implementation here def max_unique_words_optimized(sentences: list[str]) -> str: # Your implementation here ``` # Input - `sentences`: A list of sentences where each sentence is a string. - Each sentence contains words separated by spaces. - You can assume each sentence contains only alphabetic characters, no punctuation. - The list contains at least one sentence. # Output - `min_unique_words(sentences)`: Returns the sentence with the minimum number of unique words. - `max_unique_words_optimized(sentences)`: Returns the sentence with the maximum number of unique words using an optimized method. # Constraints - Ignore case when counting unique words (i.e., \\"Word\\" and \\"word\\" are considered the same). - If there are multiple sentences with the same number of unique words for either minimum or maximum, return any of them. - Avoid using any complex built-in functions that directly solve the problem. # Performance Requirements - The `min_unique_words` function should run in O(n*m) time, where `n` is the number of sentences, and `m` is the average length of a sentence. - The `max_unique_words_optimized` function should also run in O(n*m) time, optimized to avoid unnecessary recomputation within a linear scan. # Example ```python >>> min_unique_words([\\"Hello world\\", \\"Hello\\", \\"Unique words count\\"]) \\"Hello\\" >>> min_unique_words([\\"This is a test\\", \\"Test\\", \\"Another test sentence\\"]) \\"Test\\" >>> max_unique_words_optimized([\\"Hello world\\", \\"Hello\\", \\"Unique words count\\"]) \\"Unique words count\\" >>> max_unique_words_optimized([\\"This is a test\\", \\"Test\\", \\"Another test sentence\\"]) \\"This is a test\\" ``` # Additional Information For both functions, account for edge cases such as: - Sentences with single words. - Sentences with all unique words. - Sentences with all words the same.","solution":"def min_unique_words(sentences): Returns the sentence with the fewest unique words. def unique_word_count(sentence): # Convert all words to lowercase and count unique words using a set words = sentence.lower().split() return len(set(words)) return min(sentences, key=unique_word_count) def max_unique_words_optimized(sentences): Returns the sentence with the most unique words using an optimized method. def unique_word_count(sentence): # Convert all words to lowercase and count unique words using a set words = sentence.lower().split() return len(set(words)) return max(sentences, key=unique_word_count)"},{"question":"# Problem Statement You are tasked with developing a text processing function to analyze a list of articles. Your function should identify the most frequent noun in each article and return a summary report. # Task Implement a function `summarize_articles` that processes and analyzes a list of articles by finding the most frequent noun in each one. Function Signature ```python def summarize_articles(articles: list) -> list: ``` Input * `articles` (list): A list of string articles. Each article is a non-empty string. Output * (list): A list of dictionaries. Each dictionary corresponds to an article with two keys: - `article`: the original article text. - `most_frequent_noun`: the most frequent noun in the article. Constraints * An article will have at most 1000 words. * Each word in an article is separated by a space. * Each word contains only alphabetical characters (lowercase and uppercase). * Articles are case-insensitive (i.e., treat \\"Cat\\" and \\"cat\\" as the same word). * In case of a tie in frequency, return any one of the most frequent nouns. * Nouns are defined as any word that is not a commonly used stop word. Stop Words Here is the list of common stop words: [\\"a\\", \\"an\\", \\"and\\", \\"are\\", \\"as\\", \\"at\\", \\"be\\", \\"but\\", \\"by\\", \\"for\\", \\"if\\", \\"in\\", \\"is\\", \\"it\\", \\"of\\", \\"on\\", \\"or\\", \\"the\\", \\"to\\", \\"with\\"] # Example ```python articles = [ \\"The cat sat on the mat with the cat\\", \\"Dogs are great pets but cats are greater\\" ] summary = summarize_articles(articles) print(summary) # Output should be a list of dictionaries summarizing each article # [ # {\\"article\\": \\"The cat sat on the mat with the cat\\", \\"most_frequent_noun\\": \\"cat\\"}, # {\\"article\\": \\"Dogs are great pets but cats are greater\\", \\"most_frequent_noun\\": \\"dogs\\"} # ] ``` # Notes 1. Ensure to convert all words to lowercase before processing. 2. Utilize a set for stop words for efficient look-up. 3. If there are multiple most frequent nouns, any one of them is acceptable. 4. Document any assumptions or additional considerations in your solution.","solution":"from collections import Counter import re def summarize_articles(articles: list) -> list: stop_words = set([\\"a\\", \\"an\\", \\"and\\", \\"are\\", \\"as\\", \\"at\\", \\"be\\", \\"but\\", \\"by\\", \\"for\\", \\"if\\", \\"in\\", \\"is\\", \\"it\\", \\"of\\", \\"on\\", \\"or\\", \\"the\\", \\"to\\", \\"with\\"]) def find_most_frequent_noun(text): words = re.findall(r\'bw+b\', text.lower()) filtered_words = [word for word in words if word not in stop_words] counter = Counter(filtered_words) most_common_nouns = counter.most_common(1) return most_common_nouns[0][0] if most_common_nouns else None summary = [{\\"article\\": article, \\"most_frequent_noun\\": find_most_frequent_noun(article)} for article in articles] return summary"},{"question":"# Coding Assessment Question Context Data manipulation and string processing are fundamental tasks in many applications. One common operation is to find the longest substring that contains at most two distinct characters. This type of problem can help evaluate skills in string manipulation and sliding window technique. Problem Description Write a function `longest_substring_two_distinct` that takes a single string parameter `s` and returns the longest substring which contains at most two distinct characters. The function should handle errors gracefully for invalid input such as non-string types. Input and Output - **Input**: - `s` (str): The input string. - **Output**: - Returns the longest substring with at most two distinct characters (str). - Returns an empty string if `s` is empty. - Raises a `TypeError` if `s` is not a string. Constraints - The length of the input string `s` will not exceed 10,000 characters. Examples ``` >>> longest_substring_two_distinct(\\"eceba\\") ece >>> longest_substring_two_distinct(\\"ccaabbb\\") aabbb >>> longest_substring_two_distinct(\\"a\\") a >>> longest_substring_two_distinct(\\"\\") \'\' >>> longest_substring_two_distinct(None) Traceback (most recent call last): ... TypeError: The input must be a string. ``` Performance Requirement Your solution should efficiently handle string lengths up to 10,000 characters. Hints - Consider using a sliding window approach to maintain a window with at most two distinct characters. - Use a dictionary to keep track of characters and their positions.","solution":"def longest_substring_two_distinct(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"The input must be a string.\\") n = len(s) if n == 0: return \\"\\" left = 0 right = 0 max_length = 0 start_idx = 0 char_index_map = {} while right < n: char_index_map[s[right]] = right if len(char_index_map) > 2: left_most_char = min(char_index_map, key=char_index_map.get) left = char_index_map[left_most_char] + 1 del char_index_map[left_most_char] if right - left + 1 > max_length: max_length = right - left + 1 start_idx = left right += 1 return s[start_idx:start_idx + max_length]"},{"question":"Binary Search Tree (BST) Implementation and Operations Context A Binary Search Tree (BST) is a data structure where each node has at most two children, referred to as the left and right child. For each node, the values in the left subtree are less than the node\'s value, and the values in the right subtree are greater. This problem will test your understanding of BSTs, recursive algorithms, and basic tree operations. Task Implement a class `BST` that supports the following methods: - `insert(value: int) -> None`: Inserts a value into the BST. - `find(value: int) -> bool`: Returns `True` if the value exists in the BST, `False` otherwise. - `delete(value: int) -> bool`: Removes a value from the BST if it exists and returns `True`; otherwise returns `False`. - `inorder_traversal() -> list[int]`: Returns a list of all values in the BST, sorted in ascending order. Specifications 1. **Input**: - The methods will be called with appropriate parameters as specified. 2. **Output**: - Each method returns the expected result based on its description. 3. **Constraints**: - The BST must handle integer values only. - Method calls can be intermixed, and the BST must maintain valid structure after each operation. Requirements 1. **Class Definition**: - Implement a class `BST` with the methods `insert`, `find`, `delete`, and `inorder_traversal`. - Define a helper class `BSTNode` to represent each node in the tree, with attributes for value, left child, and right child. 2. **Behavior**: - Ensure your BST implementation properly maintains the BST properties. - Handle edge cases, such as inserting duplicates or deleting non-existent elements gracefully. Example ```python class BSTNode: def __init__(self, value): self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, value: int) -> None: if self.root is None: self.root = BSTNode(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.left = BSTNode(value) else: self._insert(node.left, value) elif value > node.value: if node.right is None: node.right = BSTNode(value) else: self._insert(node.right, value) def find(self, value: int) -> bool: return self._find(self.root, value) def _find(self, node, value): if node is None: return False if value == node.value: return True elif value < node.value: return self._find(node.left, value) else: return self._find(node.right, value) def delete(self, value: int) -> bool: self.root, deleted = self._delete(self.root, value) return deleted def _delete(self, node, value): if node is None: return node, False if value < node.value: node.left, deleted = self._delete(node.left, value) return node, deleted elif value > node.value: node.right, deleted = self._delete(node.right, value) return node, deleted if node.left is None: return node.right, True elif node.right is None: return node.left, True min_larger_node = self._get_min(node.right) node.value = min_larger_node.value node.right, _ = self._delete(node.right, node.value) return node, True def _get_min(self, node): while node.left is not None: node = node.left return node def inorder_traversal(self) -> list[int]: result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, node, result): if node is not None: self._inorder_traversal(node.left, result) result.append(node.value) self._inorder_traversal(node.right, result) # Example usage: bst = BST() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(2) print(bst.inorder_traversal()) # Output: [2, 5, 10, 15] print(bst.find(5)) # Output: True print(bst.delete(5)) # Output: True print(bst.inorder_traversal()) # Output: [2, 10, 15] print(bst.find(5)) # Output: False ``` Write your `BST` class and demonstrate it with an example as shown.","solution":"class BSTNode: def __init__(self, value): self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, value: int) -> None: if self.root is None: self.root = BSTNode(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.left = BSTNode(value) else: self._insert(node.left, value) elif value > node.value: if node.right is None: node.right = BSTNode(value) else: self._insert(node.right, value) def find(self, value: int) -> bool: return self._find(self.root, value) def _find(self, node, value): if node is None: return False if value == node.value: return True elif value < node.value: return self._find(node.left, value) else: return self._find(node.right, value) def delete(self, value: int) -> bool: self.root, deleted = self._delete(self.root, value) return deleted def _delete(self, node, value): if node is None: return node, False if value < node.value: node.left, deleted = self._delete(node.left, value) return node, deleted elif value > node.value: node.right, deleted = self._delete(node.right, value) return node, deleted if node.left is None: return node.right, True elif node.right is None: return node.left, True min_larger_node = self._get_min(node.right) node.value = min_larger_node.value node.right, _ = self._delete(node.right, node.value) return node, True def _get_min(self, node): while node.left is not None: node = node.left return node def inorder_traversal(self) -> list[int]: result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, node, result): if node is not None: self._inorder_traversal(node.left, result) result.append(node.value) self._inorder_traversal(node.right, result) # Example usage: bst = BST() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(2) print(bst.inorder_traversal()) # Output: [2, 5, 10, 15] print(bst.find(5)) # Output: True print(bst.delete(5)) # Output: True print(bst.inorder_traversal()) # Output: [2, 10, 15] print(bst.find(5)) # Output: False"},{"question":"# Substring Anagram Checker Context In some applications, it is necessary to find whether one string can be rearranged to form a substring of another string. This is commonly referred to as the \\"substring anagram\\" problem. Efficiently solving this problem can involve techniques such as the sliding window. Problem Statement You need to implement a function `is_anagram_in_string` that determines whether any permutation of a given search word is a substring of a target string. Function Signature ```python def is_anagram_in_string(search_word: str, target_string: str) -> bool: pass ``` Parameters - `search_word` (str): The search word to check permutations of. - `target_string` (str): The string in which to search for permutations. Returns - bool: `True` if any permutation of the `search_word` is found in the `target_string` as a substring, otherwise `False`. Constraints - Both `search_word` and `target_string` consist of only lowercase English letters. - The length of `search_word` will not exceed the length of `target_string`. - Constraints: 1 <= len(search_word), len(target_string) <= 104 Examples ```python >>> is_anagram_in_string(\\"ab\\", \\"eidbaooo\\") True >>> is_anagram_in_string(\\"ab\\", \\"eidboaoo\\") False >>> is_anagram_in_string(\\"abc\\", \\"bca\\") True >>> is_anagram_in_string(\\"abcd\\", \\"dbac\\") True ``` Notes - Implement an efficient algorithm to check for permutations in linear or near-linear time. - You may use techniques such as character counting or sliding window to achieve optimal performance. - Consider edge cases where `search_word` is the same as `target_string` or where `search_word` characters do not appear in `target_string` at all.","solution":"def is_anagram_in_string(search_word: str, target_string: str) -> bool: from collections import Counter # Early return if search_word is longer than target_string if len(search_word) > len(target_string): return False search_count = Counter(search_word) window_count = Counter(target_string[:len(search_word)]) # Use a sliding window to check if any substring of target_string is an anagram of search_word for i in range(len(search_word), len(target_string)): if search_count == window_count: return True # Slide the window right: remove the leftmost character of the previous window and add the next character window_count[target_string[i]] += 1 window_count[target_string[i - len(search_word)]] -= 1 # Clean the counter to avoid zero counts causing potential mismatch if window_count[target_string[i - len(search_word)]] == 0: del window_count[target_string[i - len(search_word)]] # Check the last window return search_count == window_count"},{"question":"# Graph Representation and Traversal Objective Implement a graph structure using an adjacency list and provide functions for both Depth-First Search (DFS) and Breadth-First Search (BFS). The graph should support insertion of edges and allow traversal from any given starting vertex. Problem Statement You are required to enhance the given Graph structure to support the following operations: 1. **Insert Edge**: Add an edge between two vertices in the graph. 2. **Perform DFS**: Given a starting vertex, perform a Depth-First Search and return the vertices in the order they are visited. 3. **Perform BFS**: Given a starting vertex, perform a Breadth-First Search and return the vertices in the order they are visited. Function Specifications 1. **add_edge(vertex1: str, vertex2: str)**: This function will take two strings representing vertices and add an undirected edge between them in the graph. 2. **dfs(start_vertex: str) -> List[str]**: This function will take a string representing the starting vertex and return a list of vertices visited in Depth-First Search order. 3. **bfs(start_vertex: str) -> List[str]**: This function will take a string representing the starting vertex and return a list of vertices visited in Breadth-First Search order. Input and Output - **Input**: - Strings `vertex1` and `vertex2` for the `add_edge` function. - String `start_vertex` for both the `dfs` and `bfs` functions. - **Output**: - None for the `add_edge` function. - List of strings for both the `dfs` and `bfs` functions. Example ```python # Create a new Graph instance graph = Graph() # Add edges to the Graph edges = [ (\\"A\\", \\"B\\"), (\\"A\\", \\"C\\"), (\\"B\\", \\"D\\"), (\\"B\\", \\"E\\"), (\\"C\\", \\"F\\"), (\\"C\\", \\"G\\") ] for edge in edges: graph.add_edge(*edge) # Perform DFS traversal print(graph.dfs(\\"A\\")) # Output: [\'A\', \'B\', \'D\', \'E\', \'C\', \'F\', \'G\'] # Perform BFS traversal print(graph.bfs(\\"A\\")) # Output: [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\', \'G\'] ``` Constraints - The graph is undirected and may have cycles. - All input vertices are unique and represented as uppercase characters. - Implement efficient solutions with respect to time and space complexity.","solution":"from collections import defaultdict, deque from typing import List class Graph: def __init__(self): self.graph = defaultdict(list) def add_edge(self, vertex1: str, vertex2: str): Adds an edge between vertex1 and vertex2. self.graph[vertex1].append(vertex2) self.graph[vertex2].append(vertex1) def dfs(self, start_vertex: str) -> List[str]: Performs a Depth-First Search (DFS) starting from start_vertex. Returns the list of vertices in the order they are visited. visited = set() result = [] def dfs_recursive(v): visited.add(v) result.append(v) for neighbor in self.graph[v]: if neighbor not in visited: dfs_recursive(neighbor) dfs_recursive(start_vertex) return result def bfs(self, start_vertex: str) -> List[str]: Performs a Breadth-First Search (BFS) starting from start_vertex. Returns the list of vertices in the order they are visited. visited = set([start_vertex]) queue = deque([start_vertex]) result = [] while queue: v = queue.popleft() result.append(v) for neighbor in self.graph[v]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return result"},{"question":"# Coding Challenge: Optimizing Inventory Management Scenario You are developing a warehouse management system and need to optimize product storage based on the frequency of incoming inventory. Each product has a unique ID, and various shipments can contain different quantities of these products. Your task is to analyze the incoming data and determine the top `k` most frequently received products over a given period. Question Write a Python function that takes a list of product shipments and an integer `k`, and returns the IDs of the top `k` most frequently received products. Function Signature ```python def top_k_frequent_products(shipments: List[int], k: int) -> List[int]: Returns the IDs of the top k most frequently received products from the list of shipments. Parameters: shipments (List[int]): A list of integers representing product IDs from various shipments. k (int): The number of top frequent product IDs to return. Returns: List[int]: A list of the top k most frequently received product IDs. ``` Input/Output * **Input Format**: - `shipments`: A list of integers where each integer represents a product ID. - `k`: An integer indicating the number of top frequent product IDs to return. * **Output Format**: A list of integers representing the top `k` frequent product IDs. Constraints 1. The length of the `shipments` list is between 1 and 10^5. 2. Product IDs are positive integers and can be as large as 10^9. 3. The value of `k` is less than or equal to the number of unique product IDs in the `shipments` list. 4. If there is a tie in frequency, return the product IDs in ascending order of their IDs. Performance Requirement Ensure that your solution runs efficiently for large values up to the maximum constraints. Example ```python shipments = [4, 1, 2, 2, 3, 4, 1, 4, 4, 3, 2, 1, 1] k = 2 top_k_frequent_products(shipments, k) # Expected output: [1, 4] ``` **Note**: - The shipments `[4, 1, 4, 2, 4, 3, 4, 1, 2, 2, 3, 2, 1]` contain products with IDs 1, 2, 3, and 4. - The frequencies are: `1 -> 4`, `2 -> 4`, `3 -> 2`, `4 -> 4`. - The top 2 products by frequency are `1` and `4`. Since there is a tie, IDs are returned in ascending order: `[1, 4]`.","solution":"from typing import List from collections import Counter def top_k_frequent_products(shipments: List[int], k: int) -> List[int]: Returns the IDs of the top k most frequently received products from the list of shipments. Parameters: shipments (List[int]): A list of integers representing product IDs from various shipments. k (int): The number of top frequent product IDs to return. Returns: List[int]: A list of the top k most frequently received product IDs. # Count the frequency of each product ID product_count = Counter(shipments) # Sort products by frequency first, then by ID to break ties sorted_products = sorted(product_count.items(), key=lambda x: (-x[1], x[0])) # Get the top k product IDs top_k_products = [product_id for product_id, count in sorted_products[:k]] return top_k_products"},{"question":"# Scenario: You are developing software for a shipping company that needs to calculate the volume of packages for efficient loading onto delivery trucks. Each package is specified by its dimensions (length, width, and height). # Task: Implement a function `calculate_volume(length: float, width: float, height: float) -> float` to determine the volume of a package in cubic meters. Ensure proper error handling for invalid dimensions. # Input: - `length` (float): The length of the package in meters. - `width` (float): The width of the package in meters. - `height` (float): The height of the package in meters. # Output: - `float`: The calculated volume of the package in cubic meters. # Constraints: - The length, width, and height must each be positive values. - If any of the dimensions are non-positive, the function should raise a ValueError with an appropriate message. # Example: ```plaintext Input: 2.0, 1.5, 0.5 Output: 1.5 Input: 1.0, 1.0, 1.0 Output: 1.0 Input: -2.0, 1.5, 0.5 Output: \\"Dimensions must be positive values!\\", ValueError Exception Input: 2.0, 0, 1.0 Output: \\"Dimensions must be positive values!\\", ValueError Exception ``` # Note: - Remember to validate the input dimensions thoroughly before performing the volume calculation.","solution":"def calculate_volume(length: float, width: float, height: float) -> float: Calculates the volume of a package given its dimensions. Args: length (float): The length of the package in meters. width (float): The width of the package in meters. height (float): The height of the package in meters. Returns: float: The volume of the package in cubic meters. Raises: ValueError: If any of the dimensions are non-positive. # Validate the dimensions if length <= 0 or width <= 0 or height <= 0: raise ValueError(\\"Dimensions must be positive values!\\") # Calculate and return the volume return length * width * height"},{"question":"# Question: Distinct Integers in Sliding Window **Context**: You are tasked with analyzing a data stream where you need to frequently query the number of distinct integers within a moving window of fixed size. This scenario is typical in real-time monitoring systems where memory and processing power are constraints. **Problem Statement**: Write a function named `distinct_integers_in_sliding_window` that analyzes a list of integers and returns a list containing the count of distinct integers in every window of size `w` as it slides from the start to the end of the list. **Function Signature**: ```python def distinct_integers_in_sliding_window(nums: list, w: int) -> list: ``` **Input**: * `nums` (list of int): A list of integers representing the data stream. * `w` (int): An integer representing the size of the sliding window. **Output**: * Returns a list of integers where each integer represents the count of distinct numbers in the corresponding window of size `w`. **Constraints**: * `1 <= len(nums) <= 10^5` * `0 <= nums[i] <= 10^6` for all valid `i` * `1 <= w <= len(nums)` **Example**: ```python print(distinct_integers_in_sliding_window([1, 2, 1, 3, 4, 2, 3], 4)) # Output: [3, 4, 4, 3] print(distinct_integers_in_sliding_window([1, 2, 3, 4, 5], 3)) # Output: [3, 3, 3] ``` **Verification**: 1. Ensure that the algorithm efficiently handles the sliding window operation. 2. Check for edge cases such as all elements being the same or the window size being equal to the length of the list. 3. Optimize for large input sizes to maintain acceptable performance.","solution":"def distinct_integers_in_sliding_window(nums: list, w: int) -> list: Returns a list of counts of distinct integers in each sliding window of size w. if w > len(nums): return [] from collections import defaultdict distinct_counts = [] count_map = defaultdict(int) distinct_count = 0 for i in range(w): if count_map[nums[i]] == 0: distinct_count += 1 count_map[nums[i]] += 1 distinct_counts.append(distinct_count) for i in range(w, len(nums)): if count_map[nums[i - w]] == 1: distinct_count -= 1 count_map[nums[i - w]] -= 1 if count_map[nums[i]] == 0: distinct_count += 1 count_map[nums[i]] += 1 distinct_counts.append(distinct_count) return distinct_counts"},{"question":"# Matrix Transposition and Element Summation **Context:** Matrix operations are foundational in various fields such as computer graphics, machine learning, and data analysis. Transposition and element-wise summation of matrices are common operations needed to manipulate and analyze data effectively. You are tasked with implementing a function that transposes a given matrix and then sums the elements of each row of the transposed matrix. **Objective:** Write a function `transpose_and_sum(matrix: list[list[int]]) -> list[int]` that takes a 2D list (matrix) of integers, transposes it, and returns a list of the sums of each row of the transposed matrix. **Function Signature:** ```python def transpose_and_sum(matrix: list[list[int]]) -> list[int]: pass ``` **Inputs:** * `matrix` (list of list of int): A 2D list representing the matrix with dimensions `m x n` (1 ≤ m, n ≤ 100). **Outputs:** * list of int: A list where the i-th element represents the sum of the elements in the i-th row of the transposed matrix. **Constraints:** * The matrix will have at least one element and all elements will be integers. * Handle edge cases where the matrix might have only one row or one column. **Example:** ```python >>> transpose_and_sum([[1, 2, 3], [4, 5, 6]]) [5, 7, 9] >>> transpose_and_sum([[1, 2], [3, 4], [5, 6]]) [9, 12] >>> transpose_and_sum([[3]]) [3] >>> transpose_and_sum([[1, -1], [-1, 1]]) [0, 0] ``` **Challenge:** Implement the function `transpose_and_sum` ensuring efficiency and correctness, properly handling edge cases, and ensuring the function works within the given constraints.","solution":"def transpose_and_sum(matrix: list[list[int]]) -> list[int]: Transposes the given matrix and returns a list of the sums of each row of the transposed matrix. # Calculate the transpose of the matrix transposed_matrix = list(map(list, zip(*matrix))) # Sum each row of the transposed matrix sums = [sum(row) for row in transposed_matrix] return sums"},{"question":"# Coding Challenge **Context**: You are given an array of n integers and a number k. Your task is to determine the maximum sum of any k consecutive elements in the array. This problem tests your ability to efficiently traverse and manipulate arrays, particularly in the context of a sliding window approach. Function Signature: ```python def max_subarray_sum(arr: list, k: int) -> int: ``` Parameters: - `arr`: a list of integers, where each integer represents an element in the array. - `k`: an integer, the number of consecutive elements to consider for the sum. Output: - Return an integer representing the maximum sum of any k consecutive elements in the array. Constraints: * 1 <= len(arr) <= 10^5 * 1 <= k <= len(arr) * The array can contain both positive and negative integers. * Optimize for performance to handle large arrays. Instructions: 1. Implement a function `window_sum(arr, k, start)` that calculates the sum of k consecutive elements starting from the `start` index. 2. Implement a function `max_subarray_sum(arr, k)` that utilizes the sliding window technique to find the maximum sum of any k consecutive elements in the array efficiently. 3. Ensure the implementation correctly handles both positive and negative integers within the array. 4. Optimize for performance to handle large arrays up to 100,000 elements. Example: ```python arr = [2, 1, 5, 1, 3, 2] k = 3 output = max_subarray_sum(arr, k) print(output) ``` Expected Output: ``` 9 ``` Note: This problem is designed to assess your understanding of array manipulation, particularly using the sliding window technique to achieve optimal efficiency for large datasets.","solution":"def max_subarray_sum(arr, k): Returns the maximum sum of any k consecutive elements in the array. Parameters: arr (list): A list of integers. k (int): The number of consecutive elements to consider for the sum. Returns: int: The maximum sum of any k consecutive elements in the array. n = len(arr) if n == 0 or k > n: return 0 # Calculate the sum of the first k elements current_sum = sum(arr[:k]) max_sum = current_sum # Slide the window across the array, adjusting the sum by subtracting # the element that is left behind and adding the new element. for i in range(n - k): current_sum = current_sum - arr[i] + arr[i + k] if current_sum > max_sum: max_sum = current_sum return max_sum"}]'),O={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},N={class:"search-container"},F={class:"card-container"},R={key:0,class:"empty-state"},z=["disabled"],L={key:0},P={key:1};function D(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",N,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",F,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",R,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",P,"Loading...")):(n(),i("span",L,"See more"))],8,z)):u("",!0)])}const Y=h(O,[["render",D],["__scopeId","data-v-bba0e64f"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"quotes/52.md","filePath":"quotes/52.md"}'),j={name:"quotes/52.md"},V=Object.assign(j,{setup(r){return(e,l)=>(n(),i("div",null,[x(Y)]))}});export{M as __pageData,V as default};
